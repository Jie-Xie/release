; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04OALOKMFL@cp?$CFu?$AA@			; `string'
PUBLIC	_Py_IncRef
PUBLIC	_Py_device_encoding
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	__imp_GetConsoleOutputCP:PROC
EXTRN	__imp_GetConsoleCP:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	__imp_isatty:PROC
EXTRN	_PyVerify_fd:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\fileutils.c
pdata	SEGMENT
$pdata$_Py_device_encoding DD imagerel $LN11
	DD	imagerel $LN11+158
	DD	imagerel $unwind$_Py_device_encoding
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_device_encoding DD 010801H
	DD	06208H
xdata	ENDS
;	COMDAT ??_C@_04OALOKMFL@cp?$CFu?$AA@
CONST	SEGMENT
??_C@_04OALOKMFL@cp?$CFu?$AA@ DB 'cp%u', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_device_encoding
_TEXT	SEGMENT
cp$ = 32
fd$ = 64
_Py_device_encoding PROC				; COMDAT

; 19   : {

$LN11:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 20   : #if defined(MS_WINDOWS) || defined(MS_WIN64)
; 21   :     UINT cp;
; 22   : #endif
; 23   :     if (!_PyVerify_fd(fd) || !isatty(fd)) {

  00008	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  0000c	e8 00 00 00 00	 call	 _PyVerify_fd
  00011	85 c0		 test	 eax, eax
  00013	74 0e		 je	 SHORT $LN7@Py_device_
  00015	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  0001f	85 c0		 test	 eax, eax
  00021	75 15		 jne	 SHORT $LN8@Py_device_
$LN7@Py_device_:

; 24   :         Py_RETURN_NONE;

  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0002a	e8 00 00 00 00	 call	 _Py_IncRef
  0002f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00036	eb 61		 jmp	 SHORT $LN9@Py_device_
$LN8@Py_device_:

; 25   :     }
; 26   : #if defined(MS_WINDOWS) || defined(MS_WIN64)
; 27   :     if (fd == 0)

  00038	83 7c 24 40 00	 cmp	 DWORD PTR fd$[rsp], 0
  0003d	75 0c		 jne	 SHORT $LN6@Py_device_

; 28   :         cp = GetConsoleCP();

  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCP
  00045	89 44 24 20	 mov	 DWORD PTR cp$[rsp], eax
  00049	eb 22		 jmp	 SHORT $LN5@Py_device_
$LN6@Py_device_:

; 29   :     else if (fd == 1 || fd == 2)

  0004b	83 7c 24 40 01	 cmp	 DWORD PTR fd$[rsp], 1
  00050	74 07		 je	 SHORT $LN3@Py_device_
  00052	83 7c 24 40 02	 cmp	 DWORD PTR fd$[rsp], 2
  00057	75 0c		 jne	 SHORT $LN4@Py_device_
$LN3@Py_device_:

; 30   :         cp = GetConsoleOutputCP();

  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleOutputCP
  0005f	89 44 24 20	 mov	 DWORD PTR cp$[rsp], eax

; 31   :     else

  00063	eb 08		 jmp	 SHORT $LN2@Py_device_
$LN4@Py_device_:

; 32   :         cp = 0;

  00065	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cp$[rsp], 0
$LN2@Py_device_:
$LN5@Py_device_:

; 33   :     /* GetConsoleCP() and GetConsoleOutputCP() return 0 if the application
; 34   :        has no console */
; 35   :     if (cp != 0)

  0006d	83 7c 24 20 00	 cmp	 DWORD PTR cp$[rsp], 0
  00072	74 12		 je	 SHORT $LN1@Py_device_

; 36   :         return PyUnicode_FromFormat("cp%u", (unsigned int)cp);

  00074	8b 54 24 20	 mov	 edx, DWORD PTR cp$[rsp]
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04OALOKMFL@cp?$CFu?$AA@
  0007f	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00084	eb 13		 jmp	 SHORT $LN9@Py_device_
$LN1@Py_device_:

; 37   : #elif defined(CODESET)
; 38   :     {
; 39   :         char *codeset = nl_langinfo(CODESET);
; 40   :         if (codeset != NULL && codeset[0] != 0)
; 41   :             return PyUnicode_FromString(codeset);
; 42   :     }
; 43   : #endif
; 44   :     Py_RETURN_NONE;

  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0008d	e8 00 00 00 00	 call	 _Py_IncRef
  00092	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN9@Py_device_:

; 45   : }

  00099	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009d	c3		 ret	 0
_Py_device_encoding ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	_Py_char2wchar
EXTRN	PyMem_Free:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	__imp_mbstowcs:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\fileutils.c
pdata	SEGMENT
$pdata$_Py_char2wchar DD imagerel $LN14
	DD	imagerel $LN14+307
	DD	imagerel $unwind$_Py_char2wchar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_char2wchar DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_char2wchar
_TEXT	SEGMENT
count$ = 32
argsize$ = 40
res$ = 48
tmp$120532 = 72
arg$ = 96
size$ = 104
_Py_char2wchar PROC					; COMDAT

; 243  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 244  : #ifdef __APPLE__
; 245  :     wchar_t *wstr;
; 246  :     wstr = _Py_DecodeUTF8_surrogateescape(arg, strlen(arg));
; 247  :     if (size != NULL) {
; 248  :         if (wstr != NULL)
; 249  :             *size = wcslen(wstr);
; 250  :         else
; 251  :             *size = (size_t)-1;
; 252  :     }
; 253  :     return wstr;
; 254  : #else
; 255  :     wchar_t *res;
; 256  :     size_t argsize;
; 257  :     size_t count;
; 258  :     unsigned char *in;
; 259  :     wchar_t *out;
; 260  : #ifdef HAVE_MBRTOWC
; 261  :     mbstate_t mbs;
; 262  : #endif
; 263  : 
; 264  : #ifndef MS_WINDOWS
; 265  :     if (force_ascii == -1)
; 266  :         force_ascii = check_force_ascii();
; 267  : 
; 268  :     if (force_ascii) {
; 269  :         /* force ASCII encoding to workaround mbstowcs() issue */
; 270  :         res = decode_ascii_surrogateescape(arg, size);
; 271  :         if (res == NULL)
; 272  :             goto oom;
; 273  :         return res;
; 274  :     }
; 275  : #endif
; 276  : 
; 277  : #ifdef HAVE_BROKEN_MBSTOWCS
; 278  :     /* Some platforms have a broken implementation of
; 279  :      * mbstowcs which does not count the characters that
; 280  :      * would result from conversion.  Use an upper bound.
; 281  :      */
; 282  :     argsize = strlen(arg);
; 283  : #else
; 284  :     argsize = mbstowcs(NULL, arg, 0);

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  00016	33 c9		 xor	 ecx, ecx
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mbstowcs
  0001e	48 89 44 24 28	 mov	 QWORD PTR argsize$[rsp], rax

; 285  : #endif
; 286  :     if (argsize != (size_t)-1) {

  00023	48 83 7c 24 28
	ff		 cmp	 QWORD PTR argsize$[rsp], -1
  00029	0f 84 c4 00 00
	00		 je	 $LN11@Py_char2wc

; 287  :         res = (wchar_t *)PyMem_Malloc((argsize+1)*sizeof(wchar_t));

  0002f	48 8b 44 24 28	 mov	 rax, QWORD PTR argsize$[rsp]
  00034	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 PyMem_Malloc
  00041	48 89 44 24 30	 mov	 QWORD PTR res$[rsp], rax

; 288  :         if (!res)

  00046	48 83 7c 24 30
	00		 cmp	 QWORD PTR res$[rsp], 0
  0004c	75 05		 jne	 SHORT $LN10@Py_char2wc

; 289  :             goto oom;

  0004e	e9 c5 00 00 00	 jmp	 $oom$120529
$LN10@Py_char2wc:

; 290  :         count = mbstowcs(res, arg, argsize+1);

  00053	48 8b 44 24 28	 mov	 rax, QWORD PTR argsize$[rsp]
  00058	48 ff c0	 inc	 rax
  0005b	4c 8b c0	 mov	 r8, rax
  0005e	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  00063	48 8b 4c 24 30	 mov	 rcx, QWORD PTR res$[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mbstowcs
  0006e	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 291  :         if (count != (size_t)-1) {

  00073	48 83 7c 24 20
	ff		 cmp	 QWORD PTR count$[rsp], -1
  00079	74 6e		 je	 SHORT $LN9@Py_char2wc

; 292  :             wchar_t *tmp;
; 293  :             /* Only use the result if it contains no
; 294  :                surrogate characters. */
; 295  :             for (tmp = res; *tmp != 0 &&
; 296  :                          (*tmp < 0xd800 || *tmp > 0xdfff); tmp++)

  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR res$[rsp]
  00080	48 89 44 24 48	 mov	 QWORD PTR tmp$120532[rsp], rax
  00085	eb 0e		 jmp	 SHORT $LN8@Py_char2wc
$LN7@Py_char2wc:
  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR tmp$120532[rsp]
  0008c	48 83 c0 02	 add	 rax, 2
  00090	48 89 44 24 48	 mov	 QWORD PTR tmp$120532[rsp], rax
$LN8@Py_char2wc:
  00095	48 8b 44 24 48	 mov	 rax, QWORD PTR tmp$120532[rsp]
  0009a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0009d	85 c0		 test	 eax, eax
  0009f	74 20		 je	 SHORT $LN6@Py_char2wc
  000a1	48 8b 44 24 48	 mov	 rax, QWORD PTR tmp$120532[rsp]
  000a6	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000a9	3d 00 d8 00 00	 cmp	 eax, 55296		; 0000d800H
  000ae	7c 0f		 jl	 SHORT $LN5@Py_char2wc
  000b0	48 8b 44 24 48	 mov	 rax, QWORD PTR tmp$120532[rsp]
  000b5	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000b8	3d ff df 00 00	 cmp	 eax, 57343		; 0000dfffH
  000bd	7e 02		 jle	 SHORT $LN6@Py_char2wc
$LN5@Py_char2wc:

; 297  :                 ;

  000bf	eb c6		 jmp	 SHORT $LN7@Py_char2wc
$LN6@Py_char2wc:

; 298  :             if (*tmp == 0) {

  000c1	48 8b 44 24 48	 mov	 rax, QWORD PTR tmp$120532[rsp]
  000c6	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000c9	85 c0		 test	 eax, eax
  000cb	75 1c		 jne	 SHORT $LN4@Py_char2wc

; 299  :                 if (size != NULL)

  000cd	48 83 7c 24 68
	00		 cmp	 QWORD PTR size$[rsp], 0
  000d3	74 0d		 je	 SHORT $LN3@Py_char2wc

; 300  :                     *size = count;

  000d5	48 8b 44 24 68	 mov	 rax, QWORD PTR size$[rsp]
  000da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  000df	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN3@Py_char2wc:

; 301  :                 return res;

  000e2	48 8b 44 24 30	 mov	 rax, QWORD PTR res$[rsp]
  000e7	eb 45		 jmp	 SHORT $LN12@Py_char2wc
$LN4@Py_char2wc:
$LN9@Py_char2wc:

; 302  :             }
; 303  :         }
; 304  :         PyMem_Free(res);

  000e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR res$[rsp]
  000ee	e8 00 00 00 00	 call	 PyMem_Free
$LN11@Py_char2wc:

; 305  :     }
; 306  :     /* Conversion failed. Fall back to escaping with surrogateescape. */
; 307  : #ifdef HAVE_MBRTOWC
; 308  :     /* Try conversion with mbrtwoc (C99), and escape non-decodable bytes. */
; 309  : 
; 310  :     /* Overallocate; as multi-byte characters are in the argument, the
; 311  :        actual output could use less memory. */
; 312  :     argsize = strlen(arg) + 1;
; 313  :     res = (wchar_t*)PyMem_Malloc(argsize*sizeof(wchar_t));
; 314  :     if (!res)
; 315  :         goto oom;
; 316  :     in = (unsigned char*)arg;
; 317  :     out = res;
; 318  :     memset(&mbs, 0, sizeof mbs);
; 319  :     while (argsize) {
; 320  :         size_t converted = mbrtowc(out, (char*)in, argsize, &mbs);
; 321  :         if (converted == 0)
; 322  :             /* Reached end of string; null char stored. */
; 323  :             break;
; 324  :         if (converted == (size_t)-2) {
; 325  :             /* Incomplete character. This should never happen,
; 326  :                since we provide everything that we have -
; 327  :                unless there is a bug in the C library, or I
; 328  :                misunderstood how mbrtowc works. */
; 329  :             PyMem_Free(res);
; 330  :             if (size != NULL)
; 331  :                 *size = (size_t)-2;
; 332  :             return NULL;
; 333  :         }
; 334  :         if (converted == (size_t)-1) {
; 335  :             /* Conversion error. Escape as UTF-8b, and start over
; 336  :                in the initial shift state. */
; 337  :             *out++ = 0xdc00 + *in++;
; 338  :             argsize--;
; 339  :             memset(&mbs, 0, sizeof mbs);
; 340  :             continue;
; 341  :         }
; 342  :         if (*out >= 0xd800 && *out <= 0xdfff) {
; 343  :             /* Surrogate character.  Escape the original
; 344  :                byte sequence with surrogateescape. */
; 345  :             argsize -= converted;
; 346  :             while (converted--)
; 347  :                 *out++ = 0xdc00 + *in++;
; 348  :             continue;
; 349  :         }
; 350  :         /* successfully converted some bytes */
; 351  :         in += converted;
; 352  :         argsize -= converted;
; 353  :         out++;
; 354  :     }
; 355  :     if (size != NULL)
; 356  :         *size = out - res;
; 357  : #else   /* HAVE_MBRTOWC */
; 358  :     /* Cannot use C locale for escaping; manually escape as if charset
; 359  :        is ASCII (i.e. escape all bytes > 128. This will still roundtrip
; 360  :        correctly in the locale's charset, which must be an ASCII superset. */
; 361  :     res = decode_ascii_surrogateescape(arg, size);

  000f3	48 8b 54 24 68	 mov	 rdx, QWORD PTR size$[rsp]
  000f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR arg$[rsp]
  000fd	e8 00 00 00 00	 call	 decode_ascii_surrogateescape
  00102	48 89 44 24 30	 mov	 QWORD PTR res$[rsp], rax

; 362  :     if (res == NULL)

  00107	48 83 7c 24 30
	00		 cmp	 QWORD PTR res$[rsp], 0
  0010d	75 02		 jne	 SHORT $LN2@Py_char2wc

; 363  :         goto oom;

  0010f	eb 07		 jmp	 SHORT $oom$120529
$LN2@Py_char2wc:

; 364  : #endif   /* HAVE_MBRTOWC */
; 365  :     return res;

  00111	48 8b 44 24 30	 mov	 rax, QWORD PTR res$[rsp]
  00116	eb 16		 jmp	 SHORT $LN12@Py_char2wc
$oom$120529:

; 366  : oom:
; 367  :     if (size != NULL)

  00118	48 83 7c 24 68
	00		 cmp	 QWORD PTR size$[rsp], 0
  0011e	74 0c		 je	 SHORT $LN1@Py_char2wc

; 368  :         *size = (size_t)-1;

  00120	48 8b 44 24 68	 mov	 rax, QWORD PTR size$[rsp]
  00125	48 c7 00 ff ff
	ff ff		 mov	 QWORD PTR [rax], -1
$LN1@Py_char2wc:

; 369  :     return NULL;

  0012c	33 c0		 xor	 eax, eax
$LN12@Py_char2wc:

; 370  : #endif   /* __APPLE__ */
; 371  : }

  0012e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00132	c3		 ret	 0
_Py_char2wchar ENDP
_TEXT	ENDS
EXTRN	strlen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$decode_ascii_surrogateescape DD imagerel decode_ascii_surrogateescape
	DD	imagerel decode_ascii_surrogateescape+254
	DD	imagerel $unwind$decode_ascii_surrogateescape
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_ascii_surrogateescape DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT decode_ascii_surrogateescape
_TEXT	SEGMENT
res$ = 32
in$ = 40
out$ = 48
arg$ = 80
size$ = 88
decode_ascii_surrogateescape PROC			; COMDAT

; 200  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 201  :     wchar_t *res;
; 202  :     unsigned char *in;
; 203  :     wchar_t *out;
; 204  : 
; 205  :     res = PyMem_Malloc((strlen(arg)+1)*sizeof(wchar_t));

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR arg$[rsp]
  00013	e8 00 00 00 00	 call	 strlen
  00018	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 PyMem_Malloc
  00025	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 206  :     if (!res)

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR res$[rsp], 0
  00030	75 07		 jne	 SHORT $LN6@decode_asc

; 207  :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 c0 00 00 00	 jmp	 $LN7@decode_asc
$LN6@decode_asc:

; 208  : 
; 209  :     in = (unsigned char*)arg;

  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  0003e	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax

; 210  :     out = res;

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
  00048	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax
$LN5@decode_asc:

; 211  :     while(*in)

  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  00052	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00055	85 c0		 test	 eax, eax
  00057	74 6e		 je	 SHORT $LN4@decode_asc

; 212  :         if(*in < 128)

  00059	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  0005e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00061	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00066	7d 2d		 jge	 SHORT $LN3@decode_asc

; 213  :             *out++ = *in++;

  00068	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  0006d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00070	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00075	66 89 01	 mov	 WORD PTR [rcx], ax
  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  0007d	48 83 c0 02	 add	 rax, 2
  00081	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax
  00086	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  0008b	48 ff c0	 inc	 rax
  0008e	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax

; 214  :         else

  00093	eb 30		 jmp	 SHORT $LN2@decode_asc
$LN3@decode_asc:

; 215  :             *out++ = 0xdc00 + *in++;

  00095	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  0009a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009d	05 00 dc 00 00	 add	 eax, 56320		; 0000dc00H
  000a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  000a7	66 89 01	 mov	 WORD PTR [rcx], ax
  000aa	48 8b 44 24 30	 mov	 rax, QWORD PTR out$[rsp]
  000af	48 83 c0 02	 add	 rax, 2
  000b3	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax
  000b8	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  000bd	48 ff c0	 inc	 rax
  000c0	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax
$LN2@decode_asc:
  000c5	eb 86		 jmp	 SHORT $LN5@decode_asc
$LN4@decode_asc:

; 216  :     *out = 0;

  000c7	33 c0		 xor	 eax, eax
  000c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  000ce	66 89 01	 mov	 WORD PTR [rcx], ax

; 217  :     if (size != NULL)

  000d1	48 83 7c 24 58
	00		 cmp	 QWORD PTR size$[rsp], 0
  000d7	74 1b		 je	 SHORT $LN1@decode_asc

; 218  :         *size = out - res;

  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
  000de	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  000e3	48 2b c8	 sub	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	48 d1 f8	 sar	 rax, 1
  000ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR size$[rsp]
  000f1	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN1@decode_asc:

; 219  :     return res;

  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
$LN7@decode_asc:

; 220  : }

  000f9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fd	c3		 ret	 0
decode_ascii_surrogateescape ENDP
_TEXT	ENDS
PUBLIC	_Py_wchar2char
EXTRN	__imp_wcstombs:PROC
EXTRN	__imp_wcslen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_wchar2char DD imagerel $LN22
	DD	imagerel $LN22+536
	DD	imagerel $unwind$_Py_wchar2char
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_wchar2char DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_wchar2char
_TEXT	SEGMENT
i$ = 32
size$ = 40
len$ = 48
buf$ = 56
converted$ = 64
bytes$ = 72
c$ = 80
result$ = 88
text$ = 112
error_pos$ = 120
_Py_wchar2char PROC					; COMDAT

; 386  : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 387  : #ifdef __APPLE__
; 388  :     Py_ssize_t len;
; 389  :     PyObject *unicode, *bytes = NULL;
; 390  :     char *cpath;
; 391  : 
; 392  :     unicode = PyUnicode_FromWideChar(text, wcslen(text));
; 393  :     if (unicode == NULL)
; 394  :         return NULL;
; 395  : 
; 396  :     bytes = _PyUnicode_AsUTF8String(unicode, "surrogateescape");
; 397  :     Py_DECREF(unicode);
; 398  :     if (bytes == NULL) {
; 399  :         PyErr_Clear();
; 400  :         if (error_pos != NULL)
; 401  :             *error_pos = (size_t)-1;
; 402  :         return NULL;
; 403  :     }
; 404  : 
; 405  :     len = PyBytes_GET_SIZE(bytes);
; 406  :     cpath = PyMem_Malloc(len+1);
; 407  :     if (cpath == NULL) {
; 408  :         PyErr_Clear();
; 409  :         Py_DECREF(bytes);
; 410  :         if (error_pos != NULL)
; 411  :             *error_pos = (size_t)-1;
; 412  :         return NULL;
; 413  :     }
; 414  :     memcpy(cpath, PyBytes_AsString(bytes), len + 1);
; 415  :     Py_DECREF(bytes);
; 416  :     return cpath;
; 417  : #else   /* __APPLE__ */
; 418  :     const size_t len = wcslen(text);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR text$[rsp]
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00019	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 419  :     char *result = NULL, *bytes = NULL;

  0001e	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0
  00027	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR bytes$[rsp], 0

; 420  :     size_t i, size, converted;
; 421  :     wchar_t c, buf[2];
; 422  : 
; 423  : #ifndef MS_WINDOWS
; 424  :     if (force_ascii == -1)
; 425  :         force_ascii = check_force_ascii();
; 426  : 
; 427  :     if (force_ascii)
; 428  :         return encode_ascii_surrogateescape(text, error_pos);
; 429  : #endif
; 430  : 
; 431  :     /* The function works in two steps:
; 432  :        1. compute the length of the output buffer in bytes (size)
; 433  :        2. outputs the bytes */
; 434  :     size = 0;

  00030	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR size$[rsp], 0

; 435  :     buf[1] = 0;

  00039	33 c0		 xor	 eax, eax
  0003b	66 89 44 24 3a	 mov	 WORD PTR buf$[rsp+2], ax
$LN19@Py_wchar2c:

; 436  :     while (1) {

  00040	33 c0		 xor	 eax, eax
  00042	83 f8 01	 cmp	 eax, 1
  00045	0f 84 c3 01 00
	00		 je	 $LN18@Py_wchar2c

; 437  :         for (i=0; i < len; i++) {

  0004b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00054	eb 0d		 jmp	 SHORT $LN17@Py_wchar2c
$LN16@Py_wchar2c:
  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0005b	48 ff c0	 inc	 rax
  0005e	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN17@Py_wchar2c:
  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00068	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0006d	0f 83 3e 01 00
	00		 jae	 $LN15@Py_wchar2c

; 438  :             c = text[i];

  00073	48 8b 44 24 70	 mov	 rax, QWORD PTR text$[rsp]
  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0007d	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00081	66 89 44 24 50	 mov	 WORD PTR c$[rsp], ax

; 439  :             if (c >= 0xdc80 && c <= 0xdcff) {

  00086	0f b7 44 24 50	 movzx	 eax, WORD PTR c$[rsp]
  0008b	3d 80 dc 00 00	 cmp	 eax, 56448		; 0000dc80H
  00090	7c 58		 jl	 SHORT $LN14@Py_wchar2c
  00092	0f b7 44 24 50	 movzx	 eax, WORD PTR c$[rsp]
  00097	3d ff dc 00 00	 cmp	 eax, 56575		; 0000dcffH
  0009c	7f 4c		 jg	 SHORT $LN14@Py_wchar2c

; 440  :                 /* UTF-8b surrogate */
; 441  :                 if (bytes != NULL) {

  0009e	48 83 7c 24 48
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  000a4	74 2d		 je	 SHORT $LN13@Py_wchar2c

; 442  :                     *bytes++ = c - 0xdc00;

  000a6	0f b7 44 24 50	 movzx	 eax, WORD PTR c$[rsp]
  000ab	2d 00 dc 00 00	 sub	 eax, 56320		; 0000dc00H
  000b0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytes$[rsp]
  000b5	88 01		 mov	 BYTE PTR [rcx], al
  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR bytes$[rsp]
  000bc	48 ff c0	 inc	 rax
  000bf	48 89 44 24 48	 mov	 QWORD PTR bytes$[rsp], rax

; 443  :                     size--;

  000c4	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000c9	48 ff c8	 dec	 rax
  000cc	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 444  :                 }
; 445  :                 else

  000d1	eb 0d		 jmp	 SHORT $LN12@Py_wchar2c
$LN13@Py_wchar2c:

; 446  :                     size++;

  000d3	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000d8	48 ff c0	 inc	 rax
  000db	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
$LN12@Py_wchar2c:

; 447  :                 continue;

  000e0	e9 71 ff ff ff	 jmp	 $LN16@Py_wchar2c

; 448  :             }
; 449  :             else {

  000e5	e9 c2 00 00 00	 jmp	 $LN11@Py_wchar2c
$LN14@Py_wchar2c:

; 450  :                 buf[0] = c;

  000ea	0f b7 44 24 50	 movzx	 eax, WORD PTR c$[rsp]
  000ef	66 89 44 24 38	 mov	 WORD PTR buf$[rsp], ax

; 451  :                 if (bytes != NULL)

  000f4	48 83 7c 24 48
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  000fa	74 1c		 je	 SHORT $LN10@Py_wchar2c

; 452  :                     converted = wcstombs(bytes, buf, size);

  000fc	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  00101	48 8d 54 24 38	 lea	 rdx, QWORD PTR buf$[rsp]
  00106	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytes$[rsp]
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs
  00111	48 89 44 24 40	 mov	 QWORD PTR converted$[rsp], rax

; 453  :                 else

  00116	eb 15		 jmp	 SHORT $LN9@Py_wchar2c
$LN10@Py_wchar2c:

; 454  :                     converted = wcstombs(NULL, buf, 0);

  00118	45 33 c0	 xor	 r8d, r8d
  0011b	48 8d 54 24 38	 lea	 rdx, QWORD PTR buf$[rsp]
  00120	33 c9		 xor	 ecx, ecx
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstombs
  00128	48 89 44 24 40	 mov	 QWORD PTR converted$[rsp], rax
$LN9@Py_wchar2c:

; 455  :                 if (converted == (size_t)-1) {

  0012d	48 83 7c 24 40
	ff		 cmp	 QWORD PTR converted$[rsp], -1
  00133	75 2e		 jne	 SHORT $LN8@Py_wchar2c

; 456  :                     if (result != NULL)

  00135	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  0013b	74 0a		 je	 SHORT $LN7@Py_wchar2c

; 457  :                         PyMem_Free(result);

  0013d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  00142	e8 00 00 00 00	 call	 PyMem_Free
$LN7@Py_wchar2c:

; 458  :                     if (error_pos != NULL)

  00147	48 83 7c 24 78
	00		 cmp	 QWORD PTR error_pos$[rsp], 0
  0014d	74 0d		 je	 SHORT $LN6@Py_wchar2c

; 459  :                         *error_pos = i;

  0014f	48 8b 44 24 78	 mov	 rax, QWORD PTR error_pos$[rsp]
  00154	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00159	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN6@Py_wchar2c:

; 460  :                     return NULL;

  0015c	33 c0		 xor	 eax, eax
  0015e	e9 b0 00 00 00	 jmp	 $LN20@Py_wchar2c
$LN8@Py_wchar2c:

; 461  :                 }
; 462  :                 if (bytes != NULL) {

  00163	48 83 7c 24 48
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  00169	74 2c		 je	 SHORT $LN5@Py_wchar2c

; 463  :                     bytes += converted;

  0016b	48 8b 44 24 40	 mov	 rax, QWORD PTR converted$[rsp]
  00170	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bytes$[rsp]
  00175	48 03 c8	 add	 rcx, rax
  00178	48 8b c1	 mov	 rax, rcx
  0017b	48 89 44 24 48	 mov	 QWORD PTR bytes$[rsp], rax

; 464  :                     size -= converted;

  00180	48 8b 44 24 40	 mov	 rax, QWORD PTR converted$[rsp]
  00185	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  0018a	48 2b c8	 sub	 rcx, rax
  0018d	48 8b c1	 mov	 rax, rcx
  00190	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 465  :                 }
; 466  :                 else

  00195	eb 15		 jmp	 SHORT $LN4@Py_wchar2c
$LN5@Py_wchar2c:

; 467  :                     size += converted;

  00197	48 8b 44 24 40	 mov	 rax, QWORD PTR converted$[rsp]
  0019c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  001a1	48 03 c8	 add	 rcx, rax
  001a4	48 8b c1	 mov	 rax, rcx
  001a7	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
$LN4@Py_wchar2c:
$LN11@Py_wchar2c:

; 468  :             }
; 469  :         }

  001ac	e9 a5 fe ff ff	 jmp	 $LN16@Py_wchar2c
$LN15@Py_wchar2c:

; 470  :         if (result != NULL) {

  001b1	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  001b7	74 0a		 je	 SHORT $LN3@Py_wchar2c

; 471  :             *bytes = '\0';

  001b9	48 8b 44 24 48	 mov	 rax, QWORD PTR bytes$[rsp]
  001be	c6 00 00	 mov	 BYTE PTR [rax], 0

; 472  :             break;

  001c1	eb 4b		 jmp	 SHORT $LN18@Py_wchar2c
$LN3@Py_wchar2c:

; 473  :         }
; 474  : 
; 475  :         size += 1; /* nul byte at the end */

  001c3	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  001c8	48 ff c0	 inc	 rax
  001cb	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 476  :         result = PyMem_Malloc(size);

  001d0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  001d5	e8 00 00 00 00	 call	 PyMem_Malloc
  001da	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 477  :         if (result == NULL) {

  001df	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  001e5	75 18		 jne	 SHORT $LN2@Py_wchar2c

; 478  :             if (error_pos != NULL)

  001e7	48 83 7c 24 78
	00		 cmp	 QWORD PTR error_pos$[rsp], 0
  001ed	74 0c		 je	 SHORT $LN1@Py_wchar2c

; 479  :                 *error_pos = (size_t)-1;

  001ef	48 8b 44 24 78	 mov	 rax, QWORD PTR error_pos$[rsp]
  001f4	48 c7 00 ff ff
	ff ff		 mov	 QWORD PTR [rax], -1
$LN1@Py_wchar2c:

; 480  :             return NULL;

  001fb	33 c0		 xor	 eax, eax
  001fd	eb 14		 jmp	 SHORT $LN20@Py_wchar2c
$LN2@Py_wchar2c:

; 481  :         }
; 482  :         bytes = result;

  001ff	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00204	48 89 44 24 48	 mov	 QWORD PTR bytes$[rsp], rax

; 483  :     }

  00209	e9 32 fe ff ff	 jmp	 $LN19@Py_wchar2c
$LN18@Py_wchar2c:

; 484  :     return result;

  0020e	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
$LN20@Py_wchar2c:

; 485  : #endif   /* __APPLE__ */
; 486  : }

  00213	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00217	c3		 ret	 0
_Py_wchar2char ENDP
_TEXT	ENDS
PUBLIC	_Py_stat
EXTRN	__imp__wstat64i32:PROC
EXTRN	PyUnicode_AsUnicode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_stat DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$_Py_stat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_stat DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_stat
_TEXT	SEGMENT
wstatbuf$ = 32
wpath$ = 80
err$ = 88
path$ = 112
statbuf$ = 120
_Py_stat PROC						; COMDAT

; 525  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 526  : #ifdef MS_WINDOWS
; 527  :     int err;
; 528  :     struct _stat wstatbuf;
; 529  :     wchar_t *wpath;
; 530  : 
; 531  :     wpath = PyUnicode_AsUnicode(path);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR path$[rsp]
  00013	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00018	48 89 44 24 50	 mov	 QWORD PTR wpath$[rsp], rax

; 532  :     if (wpath == NULL)

  0001d	48 83 7c 24 50
	00		 cmp	 QWORD PTR wpath$[rsp], 0
  00023	75 07		 jne	 SHORT $LN2@Py_stat

; 533  :         return -2;

  00025	b8 fe ff ff ff	 mov	 eax, -2
  0002a	eb 2d		 jmp	 SHORT $LN3@Py_stat
$LN2@Py_stat:

; 534  :     err = _wstat(wpath, &wstatbuf);

  0002c	48 8d 54 24 20	 lea	 rdx, QWORD PTR wstatbuf$[rsp]
  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR wpath$[rsp]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wstat64i32
  0003c	89 44 24 58	 mov	 DWORD PTR err$[rsp], eax

; 535  :     if (!err)

  00040	83 7c 24 58 00	 cmp	 DWORD PTR err$[rsp], 0
  00045	75 0e		 jne	 SHORT $LN1@Py_stat

; 536  :         statbuf->st_mode = wstatbuf.st_mode;

  00047	48 8b 44 24 78	 mov	 rax, QWORD PTR statbuf$[rsp]
  0004c	0f b7 4c 24 26	 movzx	 ecx, WORD PTR wstatbuf$[rsp+6]
  00051	66 89 48 06	 mov	 WORD PTR [rax+6], cx
$LN1@Py_stat:

; 537  :     return err;

  00055	8b 44 24 58	 mov	 eax, DWORD PTR err$[rsp]
$LN3@Py_stat:

; 538  : #else
; 539  :     int ret;
; 540  :     PyObject *bytes = PyUnicode_EncodeFSDefault(path);
; 541  :     if (bytes == NULL)
; 542  :         return -2;
; 543  :     ret = stat(PyBytes_AS_STRING(bytes), statbuf);
; 544  :     Py_DECREF(bytes);
; 545  :     return ret;
; 546  : #endif
; 547  : }

  00059	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0005d	c3		 ret	 0
_Py_stat ENDP
_TEXT	ENDS
PUBLIC	_Py_wfopen
EXTRN	__imp__wfopen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_wfopen DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$_Py_wfopen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_wfopen DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_wfopen
_TEXT	SEGMENT
path$ = 48
mode$ = 56
_Py_wfopen PROC						; COMDAT

; 556  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 557  : #ifndef MS_WINDOWS
; 558  :     FILE *f;
; 559  :     char *cpath;
; 560  :     char cmode[10];
; 561  :     size_t r;
; 562  :     r = wcstombs(cmode, mode, 10);
; 563  :     if (r == (size_t)-1 || r >= 10) {
; 564  :         errno = EINVAL;
; 565  :         return NULL;
; 566  :     }
; 567  :     cpath = _Py_wchar2char(path, NULL);
; 568  :     if (cpath == NULL)
; 569  :         return NULL;
; 570  :     f = fopen(cpath, cmode);
; 571  :     PyMem_Free(cpath);
; 572  :     return f;
; 573  : #else
; 574  :     return _wfopen(path, mode);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR mode$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR path$[rsp]
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wfopen

; 575  : #endif
; 576  : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
_Py_wfopen ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@PLNMAGID@str?5file?5path?5expected?5under?5Win@ ; `string'
PUBLIC	_Py_fopen
EXTRN	__imp_MultiByteToWideChar:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_fopen DD imagerel $LN6
	DD	imagerel $LN6+172
	DD	imagerel $unwind$_Py_fopen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_fopen DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0CN@PLNMAGID@str?5file?5path?5expected?5under?5Win@
CONST	SEGMENT
??_C@_0CN@PLNMAGID@str?5file?5path?5expected?5under?5Win@ DB 'str file pa'
	DB	'th expected under Windows, got %R', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_fopen
_TEXT	SEGMENT
usize$ = 48
wmode$ = 56
wpath$ = 80
path$ = 112
mode$ = 120
_Py_fopen PROC						; COMDAT

; 586  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 587  : #ifdef MS_WINDOWS
; 588  :     wchar_t *wpath;
; 589  :     wchar_t wmode[10];
; 590  :     int usize;
; 591  : 
; 592  :     if (!PyUnicode_Check(path)) {

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR path$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00022	85 c0		 test	 eax, eax
  00024	75 20		 jne	 SHORT $LN3@Py_fopen

; 593  :         PyErr_Format(PyExc_TypeError,
; 594  :                      "str file path expected under Windows, got %R",
; 595  :                      Py_TYPE(path));

  00026	48 8b 44 24 70	 mov	 rax, QWORD PTR path$[rsp]
  0002b	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@PLNMAGID@str?5file?5path?5expected?5under?5Win@
  00036	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003d	e8 00 00 00 00	 call	 PyErr_Format

; 596  :         return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	eb 61		 jmp	 SHORT $LN4@Py_fopen
$LN3@Py_fopen:

; 597  :     }
; 598  :     wpath = PyUnicode_AsUnicode(path);

  00046	48 8b 4c 24 70	 mov	 rcx, QWORD PTR path$[rsp]
  0004b	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00050	48 89 44 24 50	 mov	 QWORD PTR wpath$[rsp], rax

; 599  :     if (wpath == NULL)

  00055	48 83 7c 24 50
	00		 cmp	 QWORD PTR wpath$[rsp], 0
  0005b	75 04		 jne	 SHORT $LN2@Py_fopen

; 600  :         return NULL;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 46		 jmp	 SHORT $LN4@Py_fopen
$LN2@Py_fopen:

; 601  : 
; 602  :     usize = MultiByteToWideChar(CP_ACP, 0, mode, -1, wmode, sizeof(wmode));

  00061	c7 44 24 28 14
	00 00 00	 mov	 DWORD PTR [rsp+40], 20
  00069	48 8d 44 24 38	 lea	 rax, QWORD PTR wmode$[rsp]
  0006e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00073	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  00079	4c 8b 44 24 78	 mov	 r8, QWORD PTR mode$[rsp]
  0007e	33 d2		 xor	 edx, edx
  00080	33 c9		 xor	 ecx, ecx
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MultiByteToWideChar
  00088	89 44 24 30	 mov	 DWORD PTR usize$[rsp], eax

; 603  :     if (usize == 0)

  0008c	83 7c 24 30 00	 cmp	 DWORD PTR usize$[rsp], 0
  00091	75 04		 jne	 SHORT $LN1@Py_fopen

; 604  :         return NULL;

  00093	33 c0		 xor	 eax, eax
  00095	eb 10		 jmp	 SHORT $LN4@Py_fopen
$LN1@Py_fopen:

; 605  : 
; 606  :     return _wfopen(wpath, wmode);

  00097	48 8d 54 24 38	 lea	 rdx, QWORD PTR wmode$[rsp]
  0009c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR wpath$[rsp]
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wfopen
$LN4@Py_fopen:

; 607  : #else
; 608  :     FILE *f;
; 609  :     PyObject *bytes;
; 610  :     if (!PyUnicode_FSConverter(path, &bytes))
; 611  :         return NULL;
; 612  :     f = fopen(PyBytes_AS_STRING(bytes), mode);
; 613  :     Py_DECREF(bytes);
; 614  :     return f;
; 615  : #endif
; 616  : }

  000a7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ab	c3		 ret	 0
_Py_fopen ENDP
_TEXT	ENDS
PUBLIC	_Py_wgetcwd
EXTRN	__imp__wgetcwd:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_wgetcwd DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$_Py_wgetcwd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_wgetcwd DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_wgetcwd
_TEXT	SEGMENT
buf$ = 48
size$ = 56
_Py_wgetcwd PROC					; COMDAT

; 709  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 710  : #ifdef MS_WINDOWS
; 711  :     return _wgetcwd(buf, size);

  0000e	8b 54 24 38	 mov	 edx, DWORD PTR size$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wgetcwd

; 712  : #else
; 713  :     char fname[MAXPATHLEN];
; 714  :     wchar_t *wname;
; 715  :     size_t len;
; 716  : 
; 717  :     if (getcwd(fname, Py_ARRAY_LENGTH(fname)) == NULL)
; 718  :         return NULL;
; 719  :     wname = _Py_char2wchar(fname, &len);
; 720  :     if (wname == NULL)
; 721  :         return NULL;
; 722  :     if (size <= len) {
; 723  :         PyMem_Free(wname);
; 724  :         return NULL;
; 725  :     }
; 726  :     wcsncpy(buf, wname, size);
; 727  :     PyMem_Free(wname);
; 728  :     return buf;
; 729  : #endif
; 730  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
_Py_wgetcwd ENDP
_TEXT	ENDS
END
