; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	deflate_copyright
CONST	SEGMENT
deflate_copyright DB ' deflate 1.2.5 Copyright 1995-2010 Jean-loup Gailly'
	DB	' and Mark Adler ', 00H
?my_version@?1??deflateInit2_@@9@9 DB '1.2.5', 00H	; `deflateInit2_'::`2'::my_version
	ORG $+6
configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DQ	FLAT:deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DQ	FLAT:deflate_slow
CONST	ENDS
PUBLIC	deflateInit2_
PUBLIC	deflateInit_
;	COMDAT pdata
; File c:\src\pyparallel\modules\zlib\deflate.c
pdata	SEGMENT
$pdata$deflateInit_ DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$deflateInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit_ DD 011701H
	DD	08217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateInit_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
version$ = 96
stream_size$ = 104
deflateInit_ PROC					; COMDAT

; 203  : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 204  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
; 205  :                          Z_DEFAULT_STRATEGY, version, stream_size);

  00017	8b 44 24 68	 mov	 eax, DWORD PTR stream_size$[rsp]
  0001b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0001f	48 8b 44 24 60	 mov	 rax, QWORD PTR version$[rsp]
  00024	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00029	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00031	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00039	41 b9 0f 00 00
	00		 mov	 r9d, 15
  0003f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00045	8b 54 24 58	 mov	 edx, DWORD PTR level$[rsp]
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0004e	e8 00 00 00 00	 call	 deflateInit2_

; 206  :     /* To do: ignore strm->next_in if we use it as window */
; 207  : }

  00053	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00057	c3		 ret	 0
deflateInit_ ENDP
_TEXT	ENDS
PUBLIC	deflateReset
PUBLIC	deflateEnd
EXTRN	z_errmsg:BYTE
EXTRN	zcfree:PROC
EXTRN	zcalloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit2_ DD imagerel $LN18
	DD	imagerel $LN18+1088
	DD	imagerel $unwind$deflateInit2_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit2_ DD 011701H
	DD	08217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateInit2_
_TEXT	SEGMENT
s$ = 32
overlay$ = 40
wrap$ = 48
tv271 = 52
tv281 = 56
tv307 = 60
strm$ = 80
level$ = 88
method$ = 96
windowBits$ = 104
memLevel$ = 112
strategy$ = 120
version$ = 128
stream_size$ = 136
deflateInit2_ PROC					; COMDAT

; 220  : {

$LN18:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 221  :     deflate_state *s;
; 222  :     int wrap = 1;

  00017	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 1

; 223  :     static const char my_version[] = ZLIB_VERSION;
; 224  : 
; 225  :     ushf *overlay;
; 226  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 227  :      * output size for (length,distance) codes is <= 24 bits.
; 228  :      */
; 229  : 
; 230  :     if (version == Z_NULL || version[0] != my_version[0] ||
; 231  :         stream_size != sizeof(z_stream)) {

  0001f	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR version$[rsp], 0
  00028	74 24		 je	 SHORT $LN14@deflateIni
  0002a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR version$[rsp]
  00032	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00035	0f be 0d 00 00
	00 00		 movsx	 ecx, BYTE PTR ?my_version@?1??deflateInit2_@@9@9
  0003c	3b c1		 cmp	 eax, ecx
  0003e	75 0e		 jne	 SHORT $LN14@deflateIni
  00040	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR stream_size$[rsp]
  00048	48 83 f8 58	 cmp	 rax, 88			; 00000058H
  0004c	74 0a		 je	 SHORT $LN15@deflateIni
$LN14@deflateIni:

; 232  :         return Z_VERSION_ERROR;

  0004e	b8 fa ff ff ff	 mov	 eax, -6
  00053	e9 e3 03 00 00	 jmp	 $LN16@deflateIni
$LN15@deflateIni:

; 233  :     }
; 234  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00058	48 83 7c 24 50
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0005e	75 0a		 jne	 SHORT $LN13@deflateIni
  00060	b8 fe ff ff ff	 mov	 eax, -2
  00065	e9 d1 03 00 00	 jmp	 $LN16@deflateIni
$LN13@deflateIni:

; 235  : 
; 236  :     strm->msg = Z_NULL;

  0006a	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0006f	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 237  :     if (strm->zalloc == (alloc_func)0) {

  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0007c	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00081	75 1d		 jne	 SHORT $LN12@deflateIni

; 238  :         strm->zalloc = zcalloc;

  00083	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcalloc
  0008f	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 239  :         strm->opaque = (voidpf)0;

  00093	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00098	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN12@deflateIni:

; 240  :     }
; 241  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  000a0	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000a5	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000aa	75 10		 jne	 SHORT $LN11@deflateIni
  000ac	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcfree
  000b8	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN11@deflateIni:

; 242  : 
; 243  : #ifdef FASTEST
; 244  :     if (level != 0) level = 1;
; 245  : #else
; 246  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  000bc	83 7c 24 58 ff	 cmp	 DWORD PTR level$[rsp], -1
  000c1	75 08		 jne	 SHORT $LN10@deflateIni
  000c3	c7 44 24 58 06
	00 00 00	 mov	 DWORD PTR level$[rsp], 6
$LN10@deflateIni:

; 247  : #endif
; 248  : 
; 249  :     if (windowBits < 0) { /* suppress zlib wrapper */

  000cb	83 7c 24 68 00	 cmp	 DWORD PTR windowBits$[rsp], 0
  000d0	7d 14		 jge	 SHORT $LN9@deflateIni

; 250  :         wrap = 0;

  000d2	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 0

; 251  :         windowBits = -windowBits;

  000da	8b 44 24 68	 mov	 eax, DWORD PTR windowBits$[rsp]
  000de	f7 d8		 neg	 eax
  000e0	89 44 24 68	 mov	 DWORD PTR windowBits$[rsp], eax
  000e4	eb 1a		 jmp	 SHORT $LN8@deflateIni
$LN9@deflateIni:

; 252  :     }
; 253  : #ifdef GZIP
; 254  :     else if (windowBits > 15) {

  000e6	83 7c 24 68 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  000eb	7e 13		 jle	 SHORT $LN7@deflateIni

; 255  :         wrap = 2;       /* write gzip wrapper instead */

  000ed	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 2

; 256  :         windowBits -= 16;

  000f5	8b 44 24 68	 mov	 eax, DWORD PTR windowBits$[rsp]
  000f9	83 e8 10	 sub	 eax, 16
  000fc	89 44 24 68	 mov	 DWORD PTR windowBits$[rsp], eax
$LN7@deflateIni:
$LN8@deflateIni:

; 257  :     }
; 258  : #endif
; 259  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 260  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 261  :         strategy < 0 || strategy > Z_FIXED) {

  00100	83 7c 24 70 01	 cmp	 DWORD PTR memLevel$[rsp], 1
  00105	7c 38		 jl	 SHORT $LN5@deflateIni
  00107	83 7c 24 70 09	 cmp	 DWORD PTR memLevel$[rsp], 9
  0010c	7f 31		 jg	 SHORT $LN5@deflateIni
  0010e	83 7c 24 60 08	 cmp	 DWORD PTR method$[rsp], 8
  00113	75 2a		 jne	 SHORT $LN5@deflateIni
  00115	83 7c 24 68 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  0011a	7c 23		 jl	 SHORT $LN5@deflateIni
  0011c	83 7c 24 68 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  00121	7f 1c		 jg	 SHORT $LN5@deflateIni
  00123	83 7c 24 58 00	 cmp	 DWORD PTR level$[rsp], 0
  00128	7c 15		 jl	 SHORT $LN5@deflateIni
  0012a	83 7c 24 58 09	 cmp	 DWORD PTR level$[rsp], 9
  0012f	7f 0e		 jg	 SHORT $LN5@deflateIni
  00131	83 7c 24 78 00	 cmp	 DWORD PTR strategy$[rsp], 0
  00136	7c 07		 jl	 SHORT $LN5@deflateIni
  00138	83 7c 24 78 04	 cmp	 DWORD PTR strategy$[rsp], 4
  0013d	7e 0a		 jle	 SHORT $LN6@deflateIni
$LN5@deflateIni:

; 262  :         return Z_STREAM_ERROR;

  0013f	b8 fe ff ff ff	 mov	 eax, -2
  00144	e9 f2 02 00 00	 jmp	 $LN16@deflateIni
$LN6@deflateIni:

; 263  :     }
; 264  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */

  00149	83 7c 24 68 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  0014e	75 08		 jne	 SHORT $LN4@deflateIni
  00150	c7 44 24 68 09
	00 00 00	 mov	 DWORD PTR windowBits$[rsp], 9
$LN4@deflateIni:

; 265  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  00158	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0015e	ba 01 00 00 00	 mov	 edx, 1
  00163	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00168	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0016c	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00171	ff 50 30	 call	 QWORD PTR [rax+48]
  00174	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 266  :     if (s == Z_NULL) return Z_MEM_ERROR;

  00179	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  0017f	75 0a		 jne	 SHORT $LN3@deflateIni
  00181	b8 fc ff ff ff	 mov	 eax, -4
  00186	e9 b0 02 00 00	 jmp	 $LN16@deflateIni
$LN3@deflateIni:

; 267  :     strm->state = (struct internal_state FAR *)s;

  0018b	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00190	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00195	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 268  :     s->strm = strm;

  00199	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0019e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  001a3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 269  : 
; 270  :     s->wrap = wrap;

  001a6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001ab	8b 4c 24 30	 mov	 ecx, DWORD PTR wrap$[rsp]
  001af	89 48 2c	 mov	 DWORD PTR [rax+44], ecx

; 271  :     s->gzhead = Z_NULL;

  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001b7	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 272  :     s->w_bits = windowBits;

  001bf	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001c4	8b 4c 24 68	 mov	 ecx, DWORD PTR windowBits$[rsp]
  001c8	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 273  :     s->w_size = 1 << s->w_bits;

  001cb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001d0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001d3	b9 01 00 00 00	 mov	 ecx, 1
  001d8	89 4c 24 34	 mov	 DWORD PTR tv271[rsp], ecx
  001dc	0f b6 c8	 movzx	 ecx, al
  001df	8b 44 24 34	 mov	 eax, DWORD PTR tv271[rsp]
  001e3	d3 e0		 shl	 eax, cl
  001e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001ea	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 274  :     s->w_mask = s->w_size - 1;

  001ed	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001f2	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  001f5	ff c8		 dec	 eax
  001f7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001fc	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 275  : 
; 276  :     s->hash_bits = memLevel + 7;

  001ff	8b 44 24 70	 mov	 eax, DWORD PTR memLevel$[rsp]
  00203	83 c0 07	 add	 eax, 7
  00206	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0020b	89 41 78	 mov	 DWORD PTR [rcx+120], eax

; 277  :     s->hash_size = 1 << s->hash_bits;

  0020e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00213	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  00216	b9 01 00 00 00	 mov	 ecx, 1
  0021b	89 4c 24 38	 mov	 DWORD PTR tv281[rsp], ecx
  0021f	0f b6 c8	 movzx	 ecx, al
  00222	8b 44 24 38	 mov	 eax, DWORD PTR tv281[rsp]
  00226	d3 e0		 shl	 eax, cl
  00228	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0022d	89 41 74	 mov	 DWORD PTR [rcx+116], eax

; 278  :     s->hash_mask = s->hash_size - 1;

  00230	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00235	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00238	ff c8		 dec	 eax
  0023a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0023f	89 41 7c	 mov	 DWORD PTR [rcx+124], eax

; 279  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

  00242	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00247	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  0024a	83 c0 02	 add	 eax, 2
  0024d	33 d2		 xor	 edx, edx
  0024f	b9 03 00 00 00	 mov	 ecx, 3
  00254	f7 f1		 div	 ecx
  00256	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0025b	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 280  : 
; 281  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  00261	41 b8 02 00 00
	00		 mov	 r8d, 2
  00267	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0026c	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  0026f	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00274	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00278	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0027d	ff 50 30	 call	 QWORD PTR [rax+48]
  00280	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00285	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 282  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  00289	41 b8 02 00 00
	00		 mov	 r8d, 2
  0028f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00294	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  00297	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0029c	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  002a0	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  002a5	ff 50 30	 call	 QWORD PTR [rax+48]
  002a8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  002ad	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 283  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  002b1	41 b8 02 00 00
	00		 mov	 r8d, 2
  002b7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002bc	8b 50 74	 mov	 edx, DWORD PTR [rax+116]
  002bf	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  002c4	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  002c8	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  002cd	ff 50 30	 call	 QWORD PTR [rax+48]
  002d0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  002d5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 284  : 
; 285  :     s->high_water = 0;      /* nothing written to s->window yet */

  002d9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002de	c7 80 18 17 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5912], 0

; 286  : 
; 287  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  002e8	8b 44 24 70	 mov	 eax, DWORD PTR memLevel$[rsp]
  002ec	83 c0 06	 add	 eax, 6
  002ef	b9 01 00 00 00	 mov	 ecx, 1
  002f4	89 4c 24 3c	 mov	 DWORD PTR tv307[rsp], ecx
  002f8	0f b6 c8	 movzx	 ecx, al
  002fb	8b 44 24 3c	 mov	 eax, DWORD PTR tv307[rsp]
  002ff	d3 e0		 shl	 eax, cl
  00301	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00306	89 81 f0 16 00
	00		 mov	 DWORD PTR [rcx+5872], eax

; 288  : 
; 289  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  0030c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00312	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00317	8b 90 f0 16 00
	00		 mov	 edx, DWORD PTR [rax+5872]
  0031d	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00322	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00326	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0032b	ff 50 30	 call	 QWORD PTR [rax+48]
  0032e	48 89 44 24 28	 mov	 QWORD PTR overlay$[rsp], rax

; 290  :     s->pending_buf = (uchf *) overlay;

  00333	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00338	48 8b 4c 24 28	 mov	 rcx, QWORD PTR overlay$[rsp]
  0033d	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 291  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  00341	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00346	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  0034c	48 c1 e0 02	 shl	 rax, 2
  00350	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00355	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 292  : 
; 293  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
; 294  :         s->pending_buf == Z_NULL) {

  00358	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0035d	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  00362	74 24		 je	 SHORT $LN1@deflateIni
  00364	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00369	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0036e	74 18		 je	 SHORT $LN1@deflateIni
  00370	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00375	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0037a	74 0c		 je	 SHORT $LN1@deflateIni
  0037c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00381	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00386	75 30		 jne	 SHORT $LN2@deflateIni
$LN1@deflateIni:

; 295  :         s->status = FINISH_STATE;

  00388	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0038d	c7 40 08 9a 02
	00 00		 mov	 DWORD PTR [rax+8], 666	; 0000029aH

; 296  :         strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);

  00394	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00399	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR z_errmsg+48
  003a0	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 297  :         deflateEnd (strm);

  003a4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  003a9	e8 00 00 00 00	 call	 deflateEnd

; 298  :         return Z_MEM_ERROR;

  003ae	b8 fc ff ff ff	 mov	 eax, -4
  003b3	e9 83 00 00 00	 jmp	 $LN16@deflateIni
$LN2@deflateIni:

; 299  :     }
; 300  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  003b8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003bd	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  003c3	33 d2		 xor	 edx, edx
  003c5	b9 02 00 00 00	 mov	 ecx, 2
  003ca	48 f7 f1	 div	 rcx
  003cd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR overlay$[rsp]
  003d2	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  003d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  003db	48 89 81 f8 16
	00 00		 mov	 QWORD PTR [rcx+5880], rax

; 301  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  003e2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003e7	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  003ed	48 6b c0 03	 imul	 rax, 3
  003f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  003f6	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  003fa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  003ff	48 89 81 e8 16
	00 00		 mov	 QWORD PTR [rcx+5864], rax

; 302  : 
; 303  :     s->level = level;

  00406	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0040b	8b 4c 24 58	 mov	 ecx, DWORD PTR level$[rsp]
  0040f	89 88 ac 00 00
	00		 mov	 DWORD PTR [rax+172], ecx

; 304  :     s->strategy = strategy;

  00415	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0041a	8b 4c 24 78	 mov	 ecx, DWORD PTR strategy$[rsp]
  0041e	89 88 b0 00 00
	00		 mov	 DWORD PTR [rax+176], ecx

; 305  :     s->method = (Byte)method;

  00424	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00429	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR method$[rsp]
  0042e	88 48 3c	 mov	 BYTE PTR [rax+60], cl

; 306  : 
; 307  :     return deflateReset(strm);

  00431	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00436	e8 00 00 00 00	 call	 deflateReset
$LN16@deflateIni:

; 308  : }

  0043b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0043f	c3		 ret	 0
deflateInit2_ ENDP
_TEXT	ENDS
PUBLIC	deflateSetDictionary
EXTRN	memcpy:PROC
EXTRN	adler32:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetDictionary DD imagerel $LN12
	DD	imagerel $LN12+640
	DD	imagerel $unwind$deflateSetDictionary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetDictionary DD 011301H
	DD	0a213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateSetDictionary
_TEXT	SEGMENT
length$ = 32
n$ = 36
s$ = 40
hash_head$ = 48
tv225 = 56
tv236 = 64
strm$ = 96
dictionary$ = 104
dictLength$ = 112
deflateSetDictionary PROC				; COMDAT

; 315  : {

$LN12:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 316  :     deflate_state *s;
; 317  :     uInt length = dictLength;

  00013	8b 44 24 70	 mov	 eax, DWORD PTR dictLength$[rsp]
  00017	89 44 24 20	 mov	 DWORD PTR length$[rsp], eax

; 318  :     uInt n;
; 319  :     IPos hash_head = 0;

  0001b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0

; 320  : 
; 321  :     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
; 322  :         strm->state->wrap == 2 ||
; 323  :         (strm->state->wrap == 1 && strm->state->status != INIT_STATE))

  00023	48 83 7c 24 60
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00029	74 41		 je	 SHORT $LN8@deflateSet
  0002b	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00030	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00035	74 35		 je	 SHORT $LN8@deflateSet
  00037	48 83 7c 24 68
	00		 cmp	 QWORD PTR dictionary$[rsp], 0
  0003d	74 2d		 je	 SHORT $LN8@deflateSet
  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00044	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00048	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  0004c	74 1e		 je	 SHORT $LN8@deflateSet
  0004e	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00053	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00057	83 78 2c 01	 cmp	 DWORD PTR [rax+44], 1
  0005b	75 19		 jne	 SHORT $LN9@deflateSet
  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  00062	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00066	83 78 08 2a	 cmp	 DWORD PTR [rax+8], 42	; 0000002aH
  0006a	74 0a		 je	 SHORT $LN9@deflateSet
$LN8@deflateSet:

; 324  :         return Z_STREAM_ERROR;

  0006c	b8 fe ff ff ff	 mov	 eax, -2
  00071	e9 05 02 00 00	 jmp	 $LN10@deflateSet
$LN9@deflateSet:

; 325  : 
; 326  :     s = strm->state;

  00076	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  0007b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007f	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 327  :     if (s->wrap)

  00084	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00089	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0008d	74 1f		 je	 SHORT $LN7@deflateSet

; 328  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  0008f	44 8b 44 24 70	 mov	 r8d, DWORD PTR dictLength$[rsp]
  00094	48 8b 54 24 68	 mov	 rdx, QWORD PTR dictionary$[rsp]
  00099	48 8b 44 24 60	 mov	 rax, QWORD PTR strm$[rsp]
  0009e	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  000a1	e8 00 00 00 00	 call	 adler32
  000a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strm$[rsp]
  000ab	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN7@deflateSet:

; 329  : 
; 330  :     if (length < MIN_MATCH) return Z_OK;

  000ae	83 7c 24 20 03	 cmp	 DWORD PTR length$[rsp], 3
  000b3	73 07		 jae	 SHORT $LN6@deflateSet
  000b5	33 c0		 xor	 eax, eax
  000b7	e9 bf 01 00 00	 jmp	 $LN10@deflateSet
$LN6@deflateSet:

; 331  :     if (length > s->w_size) {

  000bc	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000c1	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000c4	39 44 24 20	 cmp	 DWORD PTR length$[rsp], eax
  000c8	76 2a		 jbe	 SHORT $LN5@deflateSet

; 332  :         length = s->w_size;

  000ca	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000cf	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000d2	89 44 24 20	 mov	 DWORD PTR length$[rsp], eax

; 333  :         dictionary += dictLength - length; /* use the tail of the dictionary */

  000d6	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  000da	8b 4c 24 70	 mov	 ecx, DWORD PTR dictLength$[rsp]
  000de	2b c8		 sub	 ecx, eax
  000e0	8b c1		 mov	 eax, ecx
  000e2	8b c0		 mov	 eax, eax
  000e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dictionary$[rsp]
  000e9	48 03 c8	 add	 rcx, rax
  000ec	48 8b c1	 mov	 rax, rcx
  000ef	48 89 44 24 68	 mov	 QWORD PTR dictionary$[rsp], rax
$LN5@deflateSet:

; 334  :     }
; 335  :     zmemcpy(s->window, dictionary, length);

  000f4	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  000f8	44 8b c0	 mov	 r8d, eax
  000fb	48 8b 54 24 68	 mov	 rdx, QWORD PTR dictionary$[rsp]
  00100	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00105	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  00109	e8 00 00 00 00	 call	 memcpy

; 336  :     s->strstart = length;

  0010e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00113	8b 4c 24 20	 mov	 ecx, DWORD PTR length$[rsp]
  00117	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 337  :     s->block_start = (long)length;

  0011d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00122	8b 4c 24 20	 mov	 ecx, DWORD PTR length$[rsp]
  00126	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 338  : 
; 339  :     /* Insert all strings in the hash table (except for the last two bytes).
; 340  :      * s->lookahead stays null, so s->ins_h will be recomputed at the next
; 341  :      * call of fill_window.
; 342  :      */
; 343  :     s->ins_h = s->window[0];

  0012c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00131	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00135	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00138	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0013d	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 344  :     UPDATE_HASH(s, s->ins_h, s->window[1]);

  00140	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00145	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0014b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00150	48 89 4c 24 38	 mov	 QWORD PTR tv225[rsp], rcx
  00155	0f b6 c8	 movzx	 ecx, al
  00158	48 8b 44 24 38	 mov	 rax, QWORD PTR tv225[rsp]
  0015d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00160	d3 e0		 shl	 eax, cl
  00162	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00167	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0016b	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0016f	33 c1		 xor	 eax, ecx
  00171	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00176	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  00179	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0017e	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 345  :     for (n = 0; n <= length - MIN_MATCH; n++) {

  00181	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00189	eb 0a		 jmp	 SHORT $LN4@deflateSet
$LN3@deflateSet:
  0018b	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  0018f	ff c0		 inc	 eax
  00191	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax
$LN4@deflateSet:
  00195	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  00199	83 e8 03	 sub	 eax, 3
  0019c	39 44 24 24	 cmp	 DWORD PTR n$[rsp], eax
  001a0	0f 87 c4 00 00
	00		 ja	 $LN2@deflateSet

; 346  :         INSERT_STRING(s, n, hash_head);

  001a6	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001ab	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  001b6	48 89 4c 24 40	 mov	 QWORD PTR tv236[rsp], rcx
  001bb	0f b6 c8	 movzx	 ecx, al
  001be	48 8b 44 24 40	 mov	 rax, QWORD PTR tv236[rsp]
  001c3	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001c6	d3 e0		 shl	 eax, cl
  001c8	8b 4c 24 24	 mov	 ecx, DWORD PTR n$[rsp]
  001cc	83 c1 02	 add	 ecx, 2
  001cf	8b c9		 mov	 ecx, ecx
  001d1	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  001d6	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  001da	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001de	33 c1		 xor	 eax, ecx
  001e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  001e5	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  001e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  001ed	89 41 70	 mov	 DWORD PTR [rcx+112], eax
  001f0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001f5	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  001fd	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00201	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00206	8b 52 4c	 mov	 edx, DWORD PTR [rdx+76]
  00209	44 8b 44 24 24	 mov	 r8d, DWORD PTR n$[rsp]
  0020e	44 23 c2	 and	 r8d, edx
  00211	41 8b d0	 mov	 edx, r8d
  00214	8b d2		 mov	 edx, edx
  00216	4c 8b 44 24 28	 mov	 r8, QWORD PTR s$[rsp]
  0021b	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  0021f	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00223	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax
  00228	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0022d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00230	8b 4c 24 24	 mov	 ecx, DWORD PTR n$[rsp]
  00234	23 c8		 and	 ecx, eax
  00236	8b c1		 mov	 eax, ecx
  00238	8b c0		 mov	 eax, eax
  0023a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0023f	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00243	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00247	89 44 24 30	 mov	 DWORD PTR hash_head$[rsp], eax
  0024b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00250	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00253	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00258	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0025c	0f b7 54 24 24	 movzx	 edx, WORD PTR n$[rsp]
  00261	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 347  :     }

  00265	e9 21 ff ff ff	 jmp	 $LN3@deflateSet
$LN2@deflateSet:

; 348  :     if (hash_head) hash_head = 0;  /* to make compiler happy */

  0026a	83 7c 24 30 00	 cmp	 DWORD PTR hash_head$[rsp], 0
  0026f	74 08		 je	 SHORT $LN1@deflateSet
  00271	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0
$LN1@deflateSet:

; 349  :     return Z_OK;

  00279	33 c0		 xor	 eax, eax
$LN10@deflateSet:

; 350  : }

  0027b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0027f	c3		 ret	 0
deflateSetDictionary ENDP
_TEXT	ENDS
EXTRN	_tr_init:PROC
EXTRN	crc32:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateReset DD imagerel $LN10
	DD	imagerel $LN10+322
	DD	imagerel $unwind$deflateReset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateReset DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateReset
_TEXT	SEGMENT
s$ = 32
tv87 = 40
tv131 = 44
strm$ = 64
deflateReset PROC					; COMDAT

; 355  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 356  :     deflate_state *s;
; 357  : 
; 358  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 359  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 24		 je	 SHORT $LN2@deflateRes
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	74 18		 je	 SHORT $LN2@deflateRes
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00022	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00027	74 0c		 je	 SHORT $LN2@deflateRes
  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0002e	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00033	75 0a		 jne	 SHORT $LN3@deflateRes
$LN2@deflateRes:

; 360  :         return Z_STREAM_ERROR;

  00035	b8 fe ff ff ff	 mov	 eax, -2
  0003a	e9 fe 00 00 00	 jmp	 $LN4@deflateRes
$LN3@deflateRes:

; 361  :     }
; 362  : 
; 363  :     strm->total_in = strm->total_out = 0;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00044	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 364  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0005c	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 365  :     strm->data_type = Z_UNKNOWN;

  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00069	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 366  : 
; 367  :     s = (deflate_state *)strm->state;

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00075	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00079	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 368  :     s->pending = 0;

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00083	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 369  :     s->pending_out = s->pending_buf;

  0008a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0008f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00094	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00098	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 370  : 
; 371  :     if (s->wrap < 0) {

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000a1	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000a5	7d 12		 jge	 SHORT $LN1@deflateRes

; 372  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  000a7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000ac	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000af	f7 d8		 neg	 eax
  000b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000b6	89 41 2c	 mov	 DWORD PTR [rcx+44], eax
$LN1@deflateRes:

; 373  :     }
; 374  :     s->status = s->wrap ? INIT_STATE : BUSY_STATE;

  000b9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000be	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000c2	74 0a		 je	 SHORT $LN6@deflateRes
  000c4	c7 44 24 28 2a
	00 00 00	 mov	 DWORD PTR tv87[rsp], 42	; 0000002aH
  000cc	eb 08		 jmp	 SHORT $LN7@deflateRes
$LN6@deflateRes:
  000ce	c7 44 24 28 71
	00 00 00	 mov	 DWORD PTR tv87[rsp], 113 ; 00000071H
$LN7@deflateRes:
  000d6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000db	8b 4c 24 28	 mov	 ecx, DWORD PTR tv87[rsp]
  000df	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 375  :     strm->adler =
; 376  : #ifdef GZIP
; 377  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 378  : #endif
; 379  :         adler32(0L, Z_NULL, 0);

  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000e7	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  000eb	75 12		 jne	 SHORT $LN8@deflateRes
  000ed	45 33 c0	 xor	 r8d, r8d
  000f0	33 d2		 xor	 edx, edx
  000f2	33 c9		 xor	 ecx, ecx
  000f4	e8 00 00 00 00	 call	 crc32
  000f9	89 44 24 2c	 mov	 DWORD PTR tv131[rsp], eax
  000fd	eb 10		 jmp	 SHORT $LN9@deflateRes
$LN8@deflateRes:
  000ff	45 33 c0	 xor	 r8d, r8d
  00102	33 d2		 xor	 edx, edx
  00104	33 c9		 xor	 ecx, ecx
  00106	e8 00 00 00 00	 call	 adler32
  0010b	89 44 24 2c	 mov	 DWORD PTR tv131[rsp], eax
$LN9@deflateRes:
  0010f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00114	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv131[rsp]
  00118	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 380  :     s->last_flush = Z_NO_FLUSH;

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00120	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 381  : 
; 382  :     _tr_init(s);

  00127	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0012c	e8 00 00 00 00	 call	 _tr_init

; 383  :     lm_init(s);

  00131	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00136	e8 00 00 00 00	 call	 lm_init

; 384  : 
; 385  :     return Z_OK;

  0013b	33 c0		 xor	 eax, eax
$LN4@deflateRes:

; 386  : }

  0013d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00141	c3		 ret	 0
deflateReset ENDP
_TEXT	ENDS
PUBLIC	deflateSetHeader
; Function compile flags: /Odtp
;	COMDAT deflateSetHeader
_TEXT	SEGMENT
strm$ = 8
head$ = 16
deflateSetHeader PROC					; COMDAT

; 392  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 393  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000a	48 83 7c 24 08
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00010	74 0c		 je	 SHORT $LN2@deflateSet@2
  00012	48 8b 44 24 08	 mov	 rax, QWORD PTR strm$[rsp]
  00017	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001c	75 07		 jne	 SHORT $LN3@deflateSet@2
$LN2@deflateSet@2:
  0001e	b8 fe ff ff ff	 mov	 eax, -2
  00023	eb 2a		 jmp	 SHORT $LN4@deflateSet@2
$LN3@deflateSet@2:

; 394  :     if (strm->state->wrap != 2) return Z_STREAM_ERROR;

  00025	48 8b 44 24 08	 mov	 rax, QWORD PTR strm$[rsp]
  0002a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0002e	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  00032	74 07		 je	 SHORT $LN1@deflateSet@2
  00034	b8 fe ff ff ff	 mov	 eax, -2
  00039	eb 14		 jmp	 SHORT $LN4@deflateSet@2
$LN1@deflateSet@2:

; 395  :     strm->state->gzhead = head;

  0003b	48 8b 44 24 08	 mov	 rax, QWORD PTR strm$[rsp]
  00040	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00044	48 8b 4c 24 10	 mov	 rcx, QWORD PTR head$[rsp]
  00049	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 396  :     return Z_OK;

  0004d	33 c0		 xor	 eax, eax
$LN4@deflateSet@2:

; 397  : }

  0004f	f3 c3		 fatret	 0
deflateSetHeader ENDP
_TEXT	ENDS
PUBLIC	deflatePrime
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflatePrime DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$deflatePrime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflatePrime DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflatePrime
_TEXT	SEGMENT
tv82 = 0
strm$ = 32
bits$ = 40
value$ = 48
deflatePrime PROC					; COMDAT

; 404  : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 405  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00012	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00018	74 0c		 je	 SHORT $LN1@deflatePri
  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0001f	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00024	75 07		 jne	 SHORT $LN2@deflatePri
$LN1@deflatePri:
  00026	b8 fe ff ff ff	 mov	 eax, -2
  0002b	eb 43		 jmp	 SHORT $LN3@deflatePri
$LN2@deflatePri:

; 406  :     strm->state->bi_valid = bits;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00032	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00036	8b 4c 24 28	 mov	 ecx, DWORD PTR bits$[rsp]
  0003a	89 88 14 17 00
	00		 mov	 DWORD PTR [rax+5908], ecx

; 407  :     strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));

  00040	8b 44 24 28	 mov	 eax, DWORD PTR bits$[rsp]
  00044	b9 01 00 00 00	 mov	 ecx, 1
  00049	89 0c 24	 mov	 DWORD PTR tv82[rsp], ecx
  0004c	0f b6 c8	 movzx	 ecx, al
  0004f	8b 04 24	 mov	 eax, DWORD PTR tv82[rsp]
  00052	d3 e0		 shl	 eax, cl
  00054	ff c8		 dec	 eax
  00056	8b 4c 24 30	 mov	 ecx, DWORD PTR value$[rsp]
  0005a	23 c8		 and	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR strm$[rsp]
  00063	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00067	66 89 81 10 17
	00 00		 mov	 WORD PTR [rcx+5904], ax

; 408  :     return Z_OK;

  0006e	33 c0		 xor	 eax, eax
$LN3@deflatePri:

; 409  : }

  00070	48 83 c4 18	 add	 rsp, 24
  00074	c3		 ret	 0
deflatePrime ENDP
_TEXT	ENDS
PUBLIC	deflate
PUBLIC	deflateParams
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateParams DD imagerel $LN11
	DD	imagerel $LN11+418
	DD	imagerel $unwind$deflateParams
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateParams DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateParams
_TEXT	SEGMENT
s$ = 32
err$ = 40
func$ = 48
strm$ = 80
level$ = 88
strategy$ = 96
deflateParams PROC					; COMDAT

; 416  : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 417  :     deflate_state *s;
; 418  :     compress_func func;
; 419  :     int err = Z_OK;

  00012	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR err$[rsp], 0

; 420  : 
; 421  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001a	48 83 7c 24 50
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00020	74 0c		 je	 SHORT $LN7@deflatePar
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00027	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0002c	75 0a		 jne	 SHORT $LN8@deflatePar
$LN7@deflatePar:
  0002e	b8 fe ff ff ff	 mov	 eax, -2
  00033	e9 65 01 00 00	 jmp	 $LN9@deflatePar
$LN8@deflatePar:

; 422  :     s = strm->state;

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0003d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00041	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 423  : 
; 424  : #ifdef FASTEST
; 425  :     if (level != 0) level = 1;
; 426  : #else
; 427  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  00046	83 7c 24 58 ff	 cmp	 DWORD PTR level$[rsp], -1
  0004b	75 08		 jne	 SHORT $LN6@deflatePar
  0004d	c7 44 24 58 06
	00 00 00	 mov	 DWORD PTR level$[rsp], 6
$LN6@deflatePar:

; 428  : #endif
; 429  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  00055	83 7c 24 58 00	 cmp	 DWORD PTR level$[rsp], 0
  0005a	7c 15		 jl	 SHORT $LN4@deflatePar
  0005c	83 7c 24 58 09	 cmp	 DWORD PTR level$[rsp], 9
  00061	7f 0e		 jg	 SHORT $LN4@deflatePar
  00063	83 7c 24 60 00	 cmp	 DWORD PTR strategy$[rsp], 0
  00068	7c 07		 jl	 SHORT $LN4@deflatePar
  0006a	83 7c 24 60 04	 cmp	 DWORD PTR strategy$[rsp], 4
  0006f	7e 0a		 jle	 SHORT $LN5@deflatePar
$LN4@deflatePar:

; 430  :         return Z_STREAM_ERROR;

  00071	b8 fe ff ff ff	 mov	 eax, -2
  00076	e9 22 01 00 00	 jmp	 $LN9@deflatePar
$LN5@deflatePar:

; 431  :     }
; 432  :     func = configuration_table[s->level].func;

  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00080	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  00087	48 6b c0 10	 imul	 rax, 16
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  00092	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00097	48 89 44 24 30	 mov	 QWORD PTR func$[rsp], rax

; 433  : 
; 434  :     if ((strategy != s->strategy || func != configuration_table[level].func) &&
; 435  :         strm->total_in != 0) {

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000a1	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [rax+176]
  000a7	39 44 24 60	 cmp	 DWORD PTR strategy$[rsp], eax
  000ab	75 1c		 jne	 SHORT $LN2@deflatePar
  000ad	48 63 44 24 58	 movsxd	 rax, DWORD PTR level$[rsp]
  000b2	48 6b c0 10	 imul	 rax, 16
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  000bd	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  000c2	48 39 44 24 30	 cmp	 QWORD PTR func$[rsp], rax
  000c7	74 1e		 je	 SHORT $LN3@deflatePar
$LN2@deflatePar:
  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000ce	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  000d2	74 13		 je	 SHORT $LN3@deflatePar

; 436  :         /* Flush the last buffer: */
; 437  :         err = deflate(strm, Z_BLOCK);

  000d4	ba 05 00 00 00	 mov	 edx, 5
  000d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  000de	e8 00 00 00 00	 call	 deflate
  000e3	89 44 24 28	 mov	 DWORD PTR err$[rsp], eax
$LN3@deflatePar:

; 438  :     }
; 439  :     if (s->level != level) {

  000e7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000ec	8b 4c 24 58	 mov	 ecx, DWORD PTR level$[rsp]
  000f0	39 88 ac 00 00
	00		 cmp	 DWORD PTR [rax+172], ecx
  000f6	0f 84 8e 00 00
	00		 je	 $LN1@deflatePar

; 440  :         s->level = level;

  000fc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00101	8b 4c 24 58	 mov	 ecx, DWORD PTR level$[rsp]
  00105	89 88 ac 00 00
	00		 mov	 DWORD PTR [rax+172], ecx

; 441  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  0010b	48 63 44 24 58	 movsxd	 rax, DWORD PTR level$[rsp]
  00110	48 6b c0 10	 imul	 rax, 16
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  0011b	0f b7 44 01 02	 movzx	 eax, WORD PTR [rcx+rax+2]
  00120	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00125	89 81 a8 00 00
	00		 mov	 DWORD PTR [rcx+168], eax

; 442  :         s->good_match       = configuration_table[level].good_length;

  0012b	48 63 44 24 58	 movsxd	 rax, DWORD PTR level$[rsp]
  00130	48 6b c0 10	 imul	 rax, 16
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  0013b	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0013f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00144	89 81 b4 00 00
	00		 mov	 DWORD PTR [rcx+180], eax

; 443  :         s->nice_match       = configuration_table[level].nice_length;

  0014a	48 63 44 24 58	 movsxd	 rax, DWORD PTR level$[rsp]
  0014f	48 6b c0 10	 imul	 rax, 16
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  0015a	0f b7 44 01 04	 movzx	 eax, WORD PTR [rcx+rax+4]
  0015f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00164	89 81 b8 00 00
	00		 mov	 DWORD PTR [rcx+184], eax

; 444  :         s->max_chain_length = configuration_table[level].max_chain;

  0016a	48 63 44 24 58	 movsxd	 rax, DWORD PTR level$[rsp]
  0016f	48 6b c0 10	 imul	 rax, 16
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  0017a	0f b7 44 01 06	 movzx	 eax, WORD PTR [rcx+rax+6]
  0017f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00184	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax
$LN1@deflatePar:

; 445  :     }
; 446  :     s->strategy = strategy;

  0018a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0018f	8b 4c 24 60	 mov	 ecx, DWORD PTR strategy$[rsp]
  00193	89 88 b0 00 00
	00		 mov	 DWORD PTR [rax+176], ecx

; 447  :     return err;

  00199	8b 44 24 28	 mov	 eax, DWORD PTR err$[rsp]
$LN9@deflatePar:

; 448  : }

  0019d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a1	c3		 ret	 0
deflateParams ENDP
_TEXT	ENDS
PUBLIC	deflateTune
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateTune DD imagerel $LN5
	DD	imagerel $LN5+126
	DD	imagerel $unwind$deflateTune
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateTune DD 011701H
	DD	02217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateTune
_TEXT	SEGMENT
s$ = 0
strm$ = 32
good_length$ = 40
max_lazy$ = 48
nice_length$ = 56
max_chain$ = 64
deflateTune PROC					; COMDAT

; 457  : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 18	 sub	 rsp, 24

; 458  :     deflate_state *s;
; 459  : 
; 460  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00017	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0001d	74 0c		 je	 SHORT $LN1@deflateTun
  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00024	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00029	75 07		 jne	 SHORT $LN2@deflateTun
$LN1@deflateTun:
  0002b	b8 fe ff ff ff	 mov	 eax, -2
  00030	eb 47		 jmp	 SHORT $LN3@deflateTun
$LN2@deflateTun:

; 461  :     s = strm->state;

  00032	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00037	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003b	48 89 04 24	 mov	 QWORD PTR s$[rsp], rax

; 462  :     s->good_match = good_length;

  0003f	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00043	8b 4c 24 28	 mov	 ecx, DWORD PTR good_length$[rsp]
  00047	89 88 b4 00 00
	00		 mov	 DWORD PTR [rax+180], ecx

; 463  :     s->max_lazy_match = max_lazy;

  0004d	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00051	8b 4c 24 30	 mov	 ecx, DWORD PTR max_lazy$[rsp]
  00055	89 88 a8 00 00
	00		 mov	 DWORD PTR [rax+168], ecx

; 464  :     s->nice_match = nice_length;

  0005b	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  0005f	8b 4c 24 38	 mov	 ecx, DWORD PTR nice_length$[rsp]
  00063	89 88 b8 00 00
	00		 mov	 DWORD PTR [rax+184], ecx

; 465  :     s->max_chain_length = max_chain;

  00069	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  0006d	8b 4c 24 40	 mov	 ecx, DWORD PTR max_chain$[rsp]
  00071	89 88 a4 00 00
	00		 mov	 DWORD PTR [rax+164], ecx

; 466  :     return Z_OK;

  00077	33 c0		 xor	 eax, eax
$LN3@deflateTun:

; 467  : }

  00079	48 83 c4 18	 add	 rsp, 24
  0007d	c3		 ret	 0
deflateTune ENDP
_TEXT	ENDS
PUBLIC	deflateBound
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateBound DD imagerel $LN26
	DD	imagerel $LN26+489
	DD	imagerel $unwind$deflateBound
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateBound DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateBound
_TEXT	SEGMENT
s$ = 0
complen$ = 8
wraplen$ = 12
str$ = 16
tv77 = 24
tv80 = 28
strm$ = 48
sourceLen$ = 56
deflateBound PROC					; COMDAT

; 489  : {

$LN26:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 490  :     deflate_state *s;
; 491  :     uLong complen, wraplen;
; 492  :     Bytef *str;
; 493  : 
; 494  :     /* conservative upper bound for compressed data */
; 495  :     complen = sourceLen +
; 496  :               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;

  0000d	8b 44 24 38	 mov	 eax, DWORD PTR sourceLen$[rsp]
  00011	83 c0 07	 add	 eax, 7
  00014	c1 e8 03	 shr	 eax, 3
  00017	8b 4c 24 38	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  0001b	03 c8		 add	 ecx, eax
  0001d	8b c1		 mov	 eax, ecx
  0001f	8b 4c 24 38	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  00023	83 c1 3f	 add	 ecx, 63			; 0000003fH
  00026	c1 e9 06	 shr	 ecx, 6
  00029	8d 44 08 05	 lea	 eax, DWORD PTR [rax+rcx+5]
  0002d	89 44 24 08	 mov	 DWORD PTR complen$[rsp], eax

; 497  : 
; 498  :     /* if can't get parameters, return conservative bound plus zlib wrapper */
; 499  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00031	48 83 7c 24 30
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00037	74 0c		 je	 SHORT $LN20@deflateBou
  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  0003e	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00043	75 0c		 jne	 SHORT $LN21@deflateBou
$LN20@deflateBou:

; 500  :         return complen + 6;

  00045	8b 44 24 08	 mov	 eax, DWORD PTR complen$[rsp]
  00049	83 c0 06	 add	 eax, 6
  0004c	e9 93 01 00 00	 jmp	 $LN22@deflateBou
$LN21@deflateBou:

; 501  : 
; 502  :     /* compute wrapper length */
; 503  :     s = strm->state;

  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00056	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005a	48 89 04 24	 mov	 QWORD PTR s$[rsp], rax

; 504  :     switch (s->wrap) {

  0005e	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00062	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00065	89 44 24 18	 mov	 DWORD PTR tv77[rsp], eax
  00069	83 7c 24 18 00	 cmp	 DWORD PTR tv77[rsp], 0
  0006e	74 13		 je	 SHORT $LN17@deflateBou
  00070	83 7c 24 18 01	 cmp	 DWORD PTR tv77[rsp], 1
  00075	74 19		 je	 SHORT $LN16@deflateBou
  00077	83 7c 24 18 02	 cmp	 DWORD PTR tv77[rsp], 2
  0007c	74 41		 je	 SHORT $LN15@deflateBou
  0007e	e9 0c 01 00 00	 jmp	 $LN3@deflateBou
$LN17@deflateBou:

; 505  :     case 0:                                 /* raw deflate */
; 506  :         wraplen = 0;

  00083	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR wraplen$[rsp], 0

; 507  :         break;

  0008b	e9 07 01 00 00	 jmp	 $LN18@deflateBou
$LN16@deflateBou:

; 508  :     case 1:                                 /* zlib wrapper */
; 509  :         wraplen = 6 + (s->strstart ? 4 : 0);

  00090	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00094	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  0009b	74 0a		 je	 SHORT $LN24@deflateBou
  0009d	c7 44 24 1c 04
	00 00 00	 mov	 DWORD PTR tv80[rsp], 4
  000a5	eb 08		 jmp	 SHORT $LN25@deflateBou
$LN24@deflateBou:
  000a7	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN25@deflateBou:
  000af	8b 44 24 1c	 mov	 eax, DWORD PTR tv80[rsp]
  000b3	83 c0 06	 add	 eax, 6
  000b6	89 44 24 0c	 mov	 DWORD PTR wraplen$[rsp], eax

; 510  :         break;

  000ba	e9 d8 00 00 00	 jmp	 $LN18@deflateBou
$LN15@deflateBou:

; 511  :     case 2:                                 /* gzip wrapper */
; 512  :         wraplen = 18;

  000bf	c7 44 24 0c 12
	00 00 00	 mov	 DWORD PTR wraplen$[rsp], 18

; 513  :         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */

  000c7	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  000cb	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000d0	0f 84 b7 00 00
	00		 je	 $LN14@deflateBou

; 514  :             if (s->gzhead->extra != Z_NULL)

  000d6	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  000da	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000de	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000e3	74 17		 je	 SHORT $LN13@deflateBou

; 515  :                 wraplen += 2 + s->gzhead->extra_len;

  000e5	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  000e9	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000ed	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000f0	8b 4c 24 0c	 mov	 ecx, DWORD PTR wraplen$[rsp]
  000f4	8d 44 01 02	 lea	 eax, DWORD PTR [rcx+rax+2]
  000f8	89 44 24 0c	 mov	 DWORD PTR wraplen$[rsp], eax
$LN13@deflateBou:

; 516  :             str = s->gzhead->name;

  000fc	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00100	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00104	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00108	48 89 44 24 10	 mov	 QWORD PTR str$[rsp], rax

; 517  :             if (str != Z_NULL)

  0010d	48 83 7c 24 10
	00		 cmp	 QWORD PTR str$[rsp], 0
  00113	74 23		 je	 SHORT $LN12@deflateBou
$LN11@deflateBou:

; 518  :                 do {
; 519  :                     wraplen++;

  00115	8b 44 24 0c	 mov	 eax, DWORD PTR wraplen$[rsp]
  00119	ff c0		 inc	 eax
  0011b	89 44 24 0c	 mov	 DWORD PTR wraplen$[rsp], eax

; 520  :                 } while (*str++);

  0011f	48 8b 44 24 10	 mov	 rax, QWORD PTR str$[rsp]
  00124	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00127	48 8b 4c 24 10	 mov	 rcx, QWORD PTR str$[rsp]
  0012c	48 ff c1	 inc	 rcx
  0012f	48 89 4c 24 10	 mov	 QWORD PTR str$[rsp], rcx
  00134	85 c0		 test	 eax, eax
  00136	75 dd		 jne	 SHORT $LN11@deflateBou
$LN12@deflateBou:

; 521  :             str = s->gzhead->comment;

  00138	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  0013c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00140	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00144	48 89 44 24 10	 mov	 QWORD PTR str$[rsp], rax

; 522  :             if (str != Z_NULL)

  00149	48 83 7c 24 10
	00		 cmp	 QWORD PTR str$[rsp], 0
  0014f	74 23		 je	 SHORT $LN8@deflateBou
$LN7@deflateBou:

; 523  :                 do {
; 524  :                     wraplen++;

  00151	8b 44 24 0c	 mov	 eax, DWORD PTR wraplen$[rsp]
  00155	ff c0		 inc	 eax
  00157	89 44 24 0c	 mov	 DWORD PTR wraplen$[rsp], eax

; 525  :                 } while (*str++);

  0015b	48 8b 44 24 10	 mov	 rax, QWORD PTR str$[rsp]
  00160	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00163	48 8b 4c 24 10	 mov	 rcx, QWORD PTR str$[rsp]
  00168	48 ff c1	 inc	 rcx
  0016b	48 89 4c 24 10	 mov	 QWORD PTR str$[rsp], rcx
  00170	85 c0		 test	 eax, eax
  00172	75 dd		 jne	 SHORT $LN7@deflateBou
$LN8@deflateBou:

; 526  :             if (s->gzhead->hcrc)

  00174	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00178	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0017c	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00180	74 0b		 je	 SHORT $LN4@deflateBou

; 527  :                 wraplen += 2;

  00182	8b 44 24 0c	 mov	 eax, DWORD PTR wraplen$[rsp]
  00186	83 c0 02	 add	 eax, 2
  00189	89 44 24 0c	 mov	 DWORD PTR wraplen$[rsp], eax
$LN4@deflateBou:
$LN14@deflateBou:

; 528  :         }
; 529  :         break;

  0018d	eb 08		 jmp	 SHORT $LN18@deflateBou
$LN3@deflateBou:

; 530  :     default:                                /* for compiler happiness */
; 531  :         wraplen = 6;

  0018f	c7 44 24 0c 06
	00 00 00	 mov	 DWORD PTR wraplen$[rsp], 6
$LN18@deflateBou:

; 532  :     }
; 533  : 
; 534  :     /* if not default parameters, return conservative bound */
; 535  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  00197	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  0019b	83 78 48 0f	 cmp	 DWORD PTR [rax+72], 15
  0019f	75 0a		 jne	 SHORT $LN1@deflateBou
  001a1	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  001a5	83 78 78 0f	 cmp	 DWORD PTR [rax+120], 15
  001a9	74 0e		 je	 SHORT $LN2@deflateBou
$LN1@deflateBou:

; 536  :         return complen + wraplen;

  001ab	8b 44 24 0c	 mov	 eax, DWORD PTR wraplen$[rsp]
  001af	8b 4c 24 08	 mov	 ecx, DWORD PTR complen$[rsp]
  001b3	03 c8		 add	 ecx, eax
  001b5	8b c1		 mov	 eax, ecx
  001b7	eb 2b		 jmp	 SHORT $LN22@deflateBou
$LN2@deflateBou:

; 537  : 
; 538  :     /* default settings: return tight bound for that case */
; 539  :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
; 540  :            (sourceLen >> 25) + 13 - 6 + wraplen;

  001b9	8b 44 24 38	 mov	 eax, DWORD PTR sourceLen$[rsp]
  001bd	c1 e8 0c	 shr	 eax, 12
  001c0	8b 4c 24 38	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  001c4	03 c8		 add	 ecx, eax
  001c6	8b c1		 mov	 eax, ecx
  001c8	8b 4c 24 38	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  001cc	c1 e9 0e	 shr	 ecx, 14
  001cf	03 c1		 add	 eax, ecx
  001d1	8b 4c 24 38	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  001d5	c1 e9 19	 shr	 ecx, 25
  001d8	8b 54 24 0c	 mov	 edx, DWORD PTR wraplen$[rsp]
  001dc	03 d0		 add	 edx, eax
  001de	8b c2		 mov	 eax, edx
  001e0	8d 44 01 07	 lea	 eax, DWORD PTR [rcx+rax+7]
$LN22@deflateBou:

; 541  : }

  001e4	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001e8	c3		 ret	 0
deflateBound ENDP
_TEXT	ENDS
EXTRN	memset:PROC
EXTRN	_tr_stored_block:PROC
EXTRN	_tr_align:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate DD imagerel $LN110
	DD	imagerel $LN110+4938
	DD	imagerel $unwind$deflate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate DD 021001H
	DD	0130110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate
_TEXT	SEGMENT
s$ = 32
old_flush$ = 40
level_flags$5130 = 44
header$5129 = 48
beg$5144 = 52
beg$5156 = 56
val$5157 = 60
beg$5169 = 64
val$5170 = 68
bstate$5196 = 72
tv199 = 76
tv198 = 80
tv219 = 84
tv223 = 88
tv228 = 92
tv233 = 96
tv238 = 100
tv302 = 104
tv301 = 108
tv686 = 112
tv685 = 116
tv834 = 120
tv833 = 128
strm$ = 160
flush$ = 168
deflate	PROC						; COMDAT

; 585  : {

$LN110:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 586  :     int old_flush; /* value of flush param for previous deflate call */
; 587  :     deflate_state *s;
; 588  : 
; 589  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 590  :         flush > Z_BLOCK || flush < 0) {

  00010	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR strm$[rsp], 0
  00019	74 23		 je	 SHORT $LN82@deflate
  0001b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	74 14		 je	 SHORT $LN82@deflate
  0002a	83 bc 24 a8 00
	00 00 05	 cmp	 DWORD PTR flush$[rsp], 5
  00032	7f 0a		 jg	 SHORT $LN82@deflate
  00034	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  0003c	7d 0a		 jge	 SHORT $LN83@deflate
$LN82@deflate:

; 591  :         return Z_STREAM_ERROR;

  0003e	b8 fe ff ff ff	 mov	 eax, -2
  00043	e9 fa 12 00 00	 jmp	 $LN84@deflate
$LN83@deflate:

; 592  :     }
; 593  :     s = strm->state;

  00048	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00050	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00054	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 594  : 
; 595  :     if (strm->next_out == Z_NULL ||
; 596  :         (strm->next_in == Z_NULL && strm->avail_in != 0) ||
; 597  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {

  00059	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00061	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00066	74 34		 je	 SHORT $LN80@deflate
  00068	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00070	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00074	75 0e		 jne	 SHORT $LN79@deflate
  00076	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0007e	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00082	75 18		 jne	 SHORT $LN80@deflate
$LN79@deflate:
  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00089	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  00090	75 27		 jne	 SHORT $LN81@deflate
  00092	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  0009a	74 1d		 je	 SHORT $LN81@deflate
$LN80@deflate:

; 598  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  0009c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000a4	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR z_errmsg+32
  000ab	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  000af	b8 fe ff ff ff	 mov	 eax, -2
  000b4	e9 89 12 00 00	 jmp	 $LN84@deflate
$LN81@deflate:

; 599  :     }
; 600  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  000b9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000c1	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  000c5	75 1d		 jne	 SHORT $LN78@deflate
  000c7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000cf	48 8b 0d 38 00
	00 00		 mov	 rcx, QWORD PTR z_errmsg+56
  000d6	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  000da	b8 fb ff ff ff	 mov	 eax, -5
  000df	e9 5e 12 00 00	 jmp	 $LN84@deflate
$LN78@deflate:

; 601  : 
; 602  :     s->strm = strm; /* just in case */

  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000e9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  000f1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 603  :     old_flush = s->last_flush;

  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000f9	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000fc	89 44 24 28	 mov	 DWORD PTR old_flush$[rsp], eax

; 604  :     s->last_flush = flush;

  00100	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00105	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR flush$[rsp]
  0010c	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 605  : 
; 606  :     /* Write the header */
; 607  :     if (s->status == INIT_STATE) {

  0010f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00114	83 78 08 2a	 cmp	 DWORD PTR [rax+8], 42	; 0000002aH
  00118	0f 85 ae 06 00
	00		 jne	 $LN77@deflate

; 608  : #ifdef GZIP
; 609  :         if (s->wrap == 2) {

  0011e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00123	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  00127	0f 85 64 05 00
	00		 jne	 $LN76@deflate

; 610  :             strm->adler = crc32(0L, Z_NULL, 0);

  0012d	45 33 c0	 xor	 r8d, r8d
  00130	33 d2		 xor	 edx, edx
  00132	33 c9		 xor	 ecx, ecx
  00134	e8 00 00 00 00	 call	 crc32
  00139	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00141	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 611  :             put_byte(s, 31);

  00144	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00149	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0014c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00151	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00155	c6 04 08 1f	 mov	 BYTE PTR [rax+rcx], 31
  00159	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0015e	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00161	ff c0		 inc	 eax
  00163	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00168	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 612  :             put_byte(s, 139);

  0016b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00170	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00173	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00178	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0017c	c6 04 08 8b	 mov	 BYTE PTR [rax+rcx], 139	; 0000008bH
  00180	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00185	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00188	ff c0		 inc	 eax
  0018a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0018f	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 613  :             put_byte(s, 8);

  00192	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00197	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0019a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0019f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  001a3	c6 04 08 08	 mov	 BYTE PTR [rax+rcx], 8
  001a7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001ac	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001af	ff c0		 inc	 eax
  001b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001b6	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 614  :             if (s->gzhead == Z_NULL) {

  001b9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001be	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  001c3	0f 85 74 01 00
	00		 jne	 $LN75@deflate

; 615  :                 put_byte(s, 0);

  001c9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001ce	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001d6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  001da	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  001de	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001e3	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001e6	ff c0		 inc	 eax
  001e8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001ed	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 616  :                 put_byte(s, 0);

  001f0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001f5	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001f8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001fd	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00201	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  00205	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0020a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0020d	ff c0		 inc	 eax
  0020f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00214	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 617  :                 put_byte(s, 0);

  00217	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0021c	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0021f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00224	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00228	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  0022c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00231	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00234	ff c0		 inc	 eax
  00236	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0023b	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 618  :                 put_byte(s, 0);

  0023e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00243	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00246	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0024b	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0024f	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  00253	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00258	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0025b	ff c0		 inc	 eax
  0025d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00262	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 619  :                 put_byte(s, 0);

  00265	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0026a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0026d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00272	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00276	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
  0027a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0027f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00282	ff c0		 inc	 eax
  00284	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00289	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 620  :                 put_byte(s, s->level == 9 ? 2 :
; 621  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 622  :                              4 : 0));

  0028c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00291	83 b8 ac 00 00
	00 09		 cmp	 DWORD PTR [rax+172], 9
  00298	75 0a		 jne	 SHORT $LN88@deflate
  0029a	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR tv199[rsp], 2
  002a2	eb 36		 jmp	 SHORT $LN89@deflate
$LN88@deflate:
  002a4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002a9	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  002b0	7d 18		 jge	 SHORT $LN86@deflate
  002b2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002b7	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  002be	7c 0a		 jl	 SHORT $LN86@deflate
  002c0	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv198[rsp], 0
  002c8	eb 08		 jmp	 SHORT $LN87@deflate
$LN86@deflate:
  002ca	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR tv198[rsp], 4
$LN87@deflate:
  002d2	8b 44 24 50	 mov	 eax, DWORD PTR tv198[rsp]
  002d6	89 44 24 4c	 mov	 DWORD PTR tv199[rsp], eax
$LN89@deflate:
  002da	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002df	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  002e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  002e7	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002eb	0f b6 54 24 4c	 movzx	 edx, BYTE PTR tv199[rsp]
  002f0	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  002f3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002f8	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  002fb	ff c0		 inc	 eax
  002fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00302	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 623  :                 put_byte(s, OS_CODE);

  00305	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0030a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0030d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00312	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00316	c6 04 08 0b	 mov	 BYTE PTR [rax+rcx], 11
  0031a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0031f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00322	ff c0		 inc	 eax
  00324	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00329	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 624  :                 s->status = BUSY_STATE;

  0032c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00331	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H

; 625  :             }
; 626  :             else {

  00338	e9 4f 03 00 00	 jmp	 $LN74@deflate
$LN75@deflate:

; 627  :                 put_byte(s, (s->gzhead->text ? 1 : 0) +
; 628  :                             (s->gzhead->hcrc ? 2 : 0) +
; 629  :                             (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 630  :                             (s->gzhead->name == Z_NULL ? 0 : 8) +
; 631  :                             (s->gzhead->comment == Z_NULL ? 0 : 16)
; 632  :                         );

  0033d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00342	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00346	83 38 00	 cmp	 DWORD PTR [rax], 0
  00349	74 0a		 je	 SHORT $LN90@deflate
  0034b	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv219[rsp], 1
  00353	eb 08		 jmp	 SHORT $LN91@deflate
$LN90@deflate:
  00355	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv219[rsp], 0
$LN91@deflate:
  0035d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00362	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00366	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  0036a	74 0a		 je	 SHORT $LN92@deflate
  0036c	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR tv223[rsp], 2
  00374	eb 08		 jmp	 SHORT $LN93@deflate
$LN92@deflate:
  00376	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv223[rsp], 0
$LN93@deflate:
  0037e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00383	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00387	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0038c	75 0a		 jne	 SHORT $LN94@deflate
  0038e	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv228[rsp], 0
  00396	eb 08		 jmp	 SHORT $LN95@deflate
$LN94@deflate:
  00398	c7 44 24 5c 04
	00 00 00	 mov	 DWORD PTR tv228[rsp], 4
$LN95@deflate:
  003a0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003a5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  003a9	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  003ae	75 0a		 jne	 SHORT $LN96@deflate
  003b0	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv233[rsp], 0
  003b8	eb 08		 jmp	 SHORT $LN97@deflate
$LN96@deflate:
  003ba	c7 44 24 60 08
	00 00 00	 mov	 DWORD PTR tv233[rsp], 8
$LN97@deflate:
  003c2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003c7	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  003cb	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  003d0	75 0a		 jne	 SHORT $LN98@deflate
  003d2	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv238[rsp], 0
  003da	eb 08		 jmp	 SHORT $LN99@deflate
$LN98@deflate:
  003dc	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR tv238[rsp], 16
$LN99@deflate:
  003e4	8b 44 24 58	 mov	 eax, DWORD PTR tv223[rsp]
  003e8	8b 4c 24 54	 mov	 ecx, DWORD PTR tv219[rsp]
  003ec	03 c8		 add	 ecx, eax
  003ee	8b c1		 mov	 eax, ecx
  003f0	03 44 24 5c	 add	 eax, DWORD PTR tv228[rsp]
  003f4	03 44 24 60	 add	 eax, DWORD PTR tv233[rsp]
  003f8	03 44 24 64	 add	 eax, DWORD PTR tv238[rsp]
  003fc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00401	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00404	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00409	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0040d	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00410	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00415	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00418	ff c0		 inc	 eax
  0041a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0041f	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 633  :                 put_byte(s, (Byte)(s->gzhead->time & 0xff));

  00422	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00427	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0042b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0042e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00433	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00438	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0043b	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00440	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00444	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00447	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0044c	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0044f	ff c0		 inc	 eax
  00451	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00456	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 634  :                 put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  00459	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0045e	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00462	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00465	c1 e8 08	 shr	 eax, 8
  00468	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0046d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00472	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00475	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  0047a	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0047e	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00481	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00486	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00489	ff c0		 inc	 eax
  0048b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00490	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 635  :                 put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  00493	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00498	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0049c	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0049f	c1 e8 10	 shr	 eax, 16
  004a2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  004ac	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  004af	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  004b4	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  004b8	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  004bb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004c0	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  004c3	ff c0		 inc	 eax
  004c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  004ca	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 636  :                 put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  004cd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004d2	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  004d6	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  004d9	c1 e8 18	 shr	 eax, 24
  004dc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004e1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  004e6	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  004e9	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  004ee	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  004f2	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  004f5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004fa	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  004fd	ff c0		 inc	 eax
  004ff	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00504	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 637  :                 put_byte(s, s->level == 9 ? 2 :
; 638  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 639  :                              4 : 0));

  00507	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0050c	83 b8 ac 00 00
	00 09		 cmp	 DWORD PTR [rax+172], 9
  00513	75 0a		 jne	 SHORT $LN102@deflate
  00515	c7 44 24 68 02
	00 00 00	 mov	 DWORD PTR tv302[rsp], 2
  0051d	eb 36		 jmp	 SHORT $LN103@deflate
$LN102@deflate:
  0051f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00524	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  0052b	7d 18		 jge	 SHORT $LN100@deflate
  0052d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00532	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  00539	7c 0a		 jl	 SHORT $LN100@deflate
  0053b	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv301[rsp], 0
  00543	eb 08		 jmp	 SHORT $LN101@deflate
$LN100@deflate:
  00545	c7 44 24 6c 04
	00 00 00	 mov	 DWORD PTR tv301[rsp], 4
$LN101@deflate:
  0054d	8b 44 24 6c	 mov	 eax, DWORD PTR tv301[rsp]
  00551	89 44 24 68	 mov	 DWORD PTR tv302[rsp], eax
$LN103@deflate:
  00555	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0055a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0055d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00562	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00566	0f b6 54 24 68	 movzx	 edx, BYTE PTR tv302[rsp]
  0056b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  0056e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00573	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00576	ff c0		 inc	 eax
  00578	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0057d	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 640  :                 put_byte(s, s->gzhead->os & 0xff);

  00580	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00585	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00589	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0058c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00591	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00596	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00599	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  0059e	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  005a2	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  005a5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005aa	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  005ad	ff c0		 inc	 eax
  005af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  005b4	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 641  :                 if (s->gzhead->extra != Z_NULL) {

  005b7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005bc	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  005c0	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  005c5	74 71		 je	 SHORT $LN73@deflate

; 642  :                     put_byte(s, s->gzhead->extra_len & 0xff);

  005c7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005cc	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  005d0	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  005d3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005d8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  005dd	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  005e0	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  005e5	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  005e9	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  005ec	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005f1	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  005f4	ff c0		 inc	 eax
  005f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  005fb	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 643  :                     put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  005fe	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00603	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00607	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0060a	c1 e8 08	 shr	 eax, 8
  0060d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00612	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00617	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0061a	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  0061f	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00623	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00626	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0062b	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0062e	ff c0		 inc	 eax
  00630	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00635	89 41 28	 mov	 DWORD PTR [rcx+40], eax
$LN73@deflate:

; 644  :                 }
; 645  :                 if (s->gzhead->hcrc)

  00638	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0063d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00641	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00645	74 2d		 je	 SHORT $LN72@deflate

; 646  :                     strm->adler = crc32(strm->adler, s->pending_buf,
; 647  :                                         s->pending);

  00647	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0064c	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  00650	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00655	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00659	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00661	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00664	e8 00 00 00 00	 call	 crc32
  00669	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00671	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN72@deflate:

; 648  :                 s->gzindex = 0;

  00674	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00679	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 649  :                 s->status = EXTRA_STATE;

  00680	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00685	c7 40 08 45 00
	00 00		 mov	 DWORD PTR [rax+8], 69	; 00000045H
$LN74@deflate:

; 650  :             }
; 651  :         }
; 652  :         else

  0068c	e9 3b 01 00 00	 jmp	 $LN71@deflate
$LN76@deflate:

; 653  : #endif
; 654  :         {
; 655  :             uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  00691	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00696	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00699	83 e8 08	 sub	 eax, 8
  0069c	c1 e0 04	 shl	 eax, 4
  0069f	83 c0 08	 add	 eax, 8
  006a2	c1 e0 08	 shl	 eax, 8
  006a5	89 44 24 30	 mov	 DWORD PTR header$5129[rsp], eax

; 656  :             uInt level_flags;
; 657  : 
; 658  :             if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  006a9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006ae	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  006b5	7d 0e		 jge	 SHORT $LN69@deflate
  006b7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006bc	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  006c3	7d 0a		 jge	 SHORT $LN70@deflate
$LN69@deflate:

; 659  :                 level_flags = 0;

  006c5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR level_flags$5130[rsp], 0
  006cd	eb 38		 jmp	 SHORT $LN68@deflate
$LN70@deflate:

; 660  :             else if (s->level < 6)

  006cf	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006d4	83 b8 ac 00 00
	00 06		 cmp	 DWORD PTR [rax+172], 6
  006db	7d 0a		 jge	 SHORT $LN67@deflate

; 661  :                 level_flags = 1;

  006dd	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR level_flags$5130[rsp], 1
  006e5	eb 20		 jmp	 SHORT $LN66@deflate
$LN67@deflate:

; 662  :             else if (s->level == 6)

  006e7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006ec	83 b8 ac 00 00
	00 06		 cmp	 DWORD PTR [rax+172], 6
  006f3	75 0a		 jne	 SHORT $LN65@deflate

; 663  :                 level_flags = 2;

  006f5	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR level_flags$5130[rsp], 2

; 664  :             else

  006fd	eb 08		 jmp	 SHORT $LN64@deflate
$LN65@deflate:

; 665  :                 level_flags = 3;

  006ff	c7 44 24 2c 03
	00 00 00	 mov	 DWORD PTR level_flags$5130[rsp], 3
$LN64@deflate:
$LN66@deflate:
$LN68@deflate:

; 666  :             header |= (level_flags << 6);

  00707	8b 44 24 2c	 mov	 eax, DWORD PTR level_flags$5130[rsp]
  0070b	c1 e0 06	 shl	 eax, 6
  0070e	8b 4c 24 30	 mov	 ecx, DWORD PTR header$5129[rsp]
  00712	0b c8		 or	 ecx, eax
  00714	8b c1		 mov	 eax, ecx
  00716	89 44 24 30	 mov	 DWORD PTR header$5129[rsp], eax

; 667  :             if (s->strstart != 0) header |= PRESET_DICT;

  0071a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0071f	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  00726	74 0b		 je	 SHORT $LN63@deflate
  00728	8b 44 24 30	 mov	 eax, DWORD PTR header$5129[rsp]
  0072c	83 c8 20	 or	 eax, 32			; 00000020H
  0072f	89 44 24 30	 mov	 DWORD PTR header$5129[rsp], eax
$LN63@deflate:

; 668  :             header += 31 - (header % 31);

  00733	33 d2		 xor	 edx, edx
  00735	8b 44 24 30	 mov	 eax, DWORD PTR header$5129[rsp]
  00739	b9 1f 00 00 00	 mov	 ecx, 31
  0073e	f7 f1		 div	 ecx
  00740	8b c2		 mov	 eax, edx
  00742	b9 1f 00 00 00	 mov	 ecx, 31
  00747	2b c8		 sub	 ecx, eax
  00749	8b c1		 mov	 eax, ecx
  0074b	8b 4c 24 30	 mov	 ecx, DWORD PTR header$5129[rsp]
  0074f	03 c8		 add	 ecx, eax
  00751	8b c1		 mov	 eax, ecx
  00753	89 44 24 30	 mov	 DWORD PTR header$5129[rsp], eax

; 669  : 
; 670  :             s->status = BUSY_STATE;

  00757	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0075c	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H

; 671  :             putShortMSB(s, header);

  00763	8b 54 24 30	 mov	 edx, DWORD PTR header$5129[rsp]
  00767	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0076c	e8 00 00 00 00	 call	 putShortMSB

; 672  : 
; 673  :             /* Save the adler32 of the preset dictionary: */
; 674  :             if (s->strstart != 0) {

  00771	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00776	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  0077d	74 36		 je	 SHORT $LN62@deflate

; 675  :                 putShortMSB(s, (uInt)(strm->adler >> 16));

  0077f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00787	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0078a	c1 e8 10	 shr	 eax, 16
  0078d	8b d0		 mov	 edx, eax
  0078f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00794	e8 00 00 00 00	 call	 putShortMSB

; 676  :                 putShortMSB(s, (uInt)(strm->adler & 0xffff));

  00799	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  007a1	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  007a4	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  007a9	8b d0		 mov	 edx, eax
  007ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  007b0	e8 00 00 00 00	 call	 putShortMSB
$LN62@deflate:

; 677  :             }
; 678  :             strm->adler = adler32(0L, Z_NULL, 0);

  007b5	45 33 c0	 xor	 r8d, r8d
  007b8	33 d2		 xor	 edx, edx
  007ba	33 c9		 xor	 ecx, ecx
  007bc	e8 00 00 00 00	 call	 adler32
  007c1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  007c9	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN71@deflate:
$LN77@deflate:

; 679  :         }
; 680  :     }
; 681  : #ifdef GZIP
; 682  :     if (s->status == EXTRA_STATE) {

  007cc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  007d1	83 78 08 45	 cmp	 DWORD PTR [rax+8], 69	; 00000045H
  007d5	0f 85 c7 01 00
	00		 jne	 $LN61@deflate

; 683  :         if (s->gzhead->extra != Z_NULL) {

  007db	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  007e0	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  007e4	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  007e9	0f 84 a7 01 00
	00		 je	 $LN60@deflate

; 684  :             uInt beg = s->pending;  /* start of bytes to update crc */

  007ef	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  007f4	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  007f7	89 44 24 34	 mov	 DWORD PTR beg$5144[rsp], eax
$LN59@deflate:

; 685  : 
; 686  :             while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {

  007fb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00800	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00804	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00807	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0080c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00811	39 41 38	 cmp	 DWORD PTR [rcx+56], eax
  00814	0f 83 f3 00 00
	00		 jae	 $LN58@deflate

; 687  :                 if (s->pending == s->pending_buf_size) {

  0081a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0081f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00824	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00827	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  0082a	0f 85 86 00 00
	00		 jne	 $LN57@deflate

; 688  :                     if (s->gzhead->hcrc && s->pending > beg)

  00830	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00835	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00839	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  0083d	74 4a		 je	 SHORT $LN56@deflate
  0083f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00844	8b 4c 24 34	 mov	 ecx, DWORD PTR beg$5144[rsp]
  00848	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  0084b	76 3c		 jbe	 SHORT $LN56@deflate

; 689  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 690  :                                             s->pending - beg);

  0084d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00852	8b 4c 24 34	 mov	 ecx, DWORD PTR beg$5144[rsp]
  00856	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00859	2b c1		 sub	 eax, ecx
  0085b	8b 4c 24 34	 mov	 ecx, DWORD PTR beg$5144[rsp]
  0085f	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00864	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00868	44 8b c0	 mov	 r8d, eax
  0086b	48 8b d1	 mov	 rdx, rcx
  0086e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00876	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00879	e8 00 00 00 00	 call	 crc32
  0087e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00886	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN56@deflate:

; 691  :                     flush_pending(strm);

  00889	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00891	e8 00 00 00 00	 call	 flush_pending

; 692  :                     beg = s->pending;

  00896	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0089b	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0089e	89 44 24 34	 mov	 DWORD PTR beg$5144[rsp], eax

; 693  :                     if (s->pending == s->pending_buf_size)

  008a2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  008ac	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  008af	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  008b2	75 02		 jne	 SHORT $LN55@deflate

; 694  :                         break;

  008b4	eb 57		 jmp	 SHORT $LN58@deflate
$LN55@deflate:
$LN57@deflate:

; 695  :                 }
; 696  :                 put_byte(s, s->gzhead->extra[s->gzindex]);

  008b6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008bb	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  008bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  008c4	8b 49 38	 mov	 ecx, DWORD PTR [rcx+56]
  008c7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  008cb	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  008d0	8b 52 28	 mov	 edx, DWORD PTR [rdx+40]
  008d3	4c 8b 44 24 20	 mov	 r8, QWORD PTR s$[rsp]
  008d8	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  008dc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  008e0	42 88 04 02	 mov	 BYTE PTR [rdx+r8], al
  008e4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008e9	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  008ec	ff c0		 inc	 eax
  008ee	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  008f3	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 697  :                 s->gzindex++;

  008f6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008fb	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  008fe	ff c0		 inc	 eax
  00900	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00905	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 698  :             }

  00908	e9 ee fe ff ff	 jmp	 $LN59@deflate
$LN58@deflate:

; 699  :             if (s->gzhead->hcrc && s->pending > beg)

  0090d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00912	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00916	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  0091a	74 4a		 je	 SHORT $LN54@deflate
  0091c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00921	8b 4c 24 34	 mov	 ecx, DWORD PTR beg$5144[rsp]
  00925	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00928	76 3c		 jbe	 SHORT $LN54@deflate

; 700  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 701  :                                     s->pending - beg);

  0092a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0092f	8b 4c 24 34	 mov	 ecx, DWORD PTR beg$5144[rsp]
  00933	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00936	2b c1		 sub	 eax, ecx
  00938	8b 4c 24 34	 mov	 ecx, DWORD PTR beg$5144[rsp]
  0093c	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00941	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00945	44 8b c0	 mov	 r8d, eax
  00948	48 8b d1	 mov	 rdx, rcx
  0094b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00953	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00956	e8 00 00 00 00	 call	 crc32
  0095b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00963	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN54@deflate:

; 702  :             if (s->gzindex == s->gzhead->extra_len) {

  00966	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0096b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0096f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00974	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00977	39 41 38	 cmp	 DWORD PTR [rcx+56], eax
  0097a	75 18		 jne	 SHORT $LN53@deflate

; 703  :                 s->gzindex = 0;

  0097c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00981	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 704  :                 s->status = NAME_STATE;

  00988	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0098d	c7 40 08 49 00
	00 00		 mov	 DWORD PTR [rax+8], 73	; 00000049H
$LN53@deflate:

; 705  :             }
; 706  :         }
; 707  :         else

  00994	eb 0c		 jmp	 SHORT $LN52@deflate
$LN60@deflate:

; 708  :             s->status = NAME_STATE;

  00996	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0099b	c7 40 08 49 00
	00 00		 mov	 DWORD PTR [rax+8], 73	; 00000049H
$LN52@deflate:
$LN61@deflate:

; 709  :     }
; 710  :     if (s->status == NAME_STATE) {

  009a2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009a7	83 78 08 49	 cmp	 DWORD PTR [rax+8], 73	; 00000049H
  009ab	0f 85 af 01 00
	00		 jne	 $LN51@deflate

; 711  :         if (s->gzhead->name != Z_NULL) {

  009b1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009b6	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  009ba	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  009bf	0f 84 8f 01 00
	00		 je	 $LN50@deflate

; 712  :             uInt beg = s->pending;  /* start of bytes to update crc */

  009c5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009ca	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  009cd	89 44 24 38	 mov	 DWORD PTR beg$5156[rsp], eax
$LN49@deflate:

; 713  :             int val;
; 714  : 
; 715  :             do {
; 716  :                 if (s->pending == s->pending_buf_size) {

  009d1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  009db	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  009de	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  009e1	0f 85 8e 00 00
	00		 jne	 $LN46@deflate

; 717  :                     if (s->gzhead->hcrc && s->pending > beg)

  009e7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009ec	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  009f0	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  009f4	74 4a		 je	 SHORT $LN45@deflate
  009f6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009fb	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$5156[rsp]
  009ff	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00a02	76 3c		 jbe	 SHORT $LN45@deflate

; 718  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 719  :                                             s->pending - beg);

  00a04	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00a09	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$5156[rsp]
  00a0d	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00a10	2b c1		 sub	 eax, ecx
  00a12	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$5156[rsp]
  00a16	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00a1b	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00a1f	44 8b c0	 mov	 r8d, eax
  00a22	48 8b d1	 mov	 rdx, rcx
  00a25	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00a2d	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00a30	e8 00 00 00 00	 call	 crc32
  00a35	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00a3d	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN45@deflate:

; 720  :                     flush_pending(strm);

  00a40	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00a48	e8 00 00 00 00	 call	 flush_pending

; 721  :                     beg = s->pending;

  00a4d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00a52	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00a55	89 44 24 38	 mov	 DWORD PTR beg$5156[rsp], eax

; 722  :                     if (s->pending == s->pending_buf_size) {

  00a59	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00a5e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00a63	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00a66	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00a69	75 0a		 jne	 SHORT $LN44@deflate

; 723  :                         val = 1;

  00a6b	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR val$5157[rsp], 1

; 724  :                         break;

  00a73	eb 65		 jmp	 SHORT $LN47@deflate
$LN44@deflate:
$LN46@deflate:

; 725  :                     }
; 726  :                 }
; 727  :                 val = s->gzhead->name[s->gzindex++];

  00a75	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00a7a	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00a7e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00a83	8b 49 38	 mov	 ecx, DWORD PTR [rcx+56]
  00a86	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00a8a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00a8e	89 44 24 3c	 mov	 DWORD PTR val$5157[rsp], eax
  00a92	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00a97	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00a9a	ff c0		 inc	 eax
  00a9c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00aa1	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 728  :                 put_byte(s, val);

  00aa4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00aa9	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00aac	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00ab1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00ab5	0f b6 54 24 3c	 movzx	 edx, BYTE PTR val$5157[rsp]
  00aba	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  00abd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ac2	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00ac5	ff c0		 inc	 eax
  00ac7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00acc	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 729  :             } while (val != 0);

  00acf	83 7c 24 3c 00	 cmp	 DWORD PTR val$5157[rsp], 0
  00ad4	0f 85 f7 fe ff
	ff		 jne	 $LN49@deflate
$LN47@deflate:

; 730  :             if (s->gzhead->hcrc && s->pending > beg)

  00ada	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00adf	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00ae3	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00ae7	74 4a		 je	 SHORT $LN43@deflate
  00ae9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00aee	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$5156[rsp]
  00af2	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00af5	76 3c		 jbe	 SHORT $LN43@deflate

; 731  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 732  :                                     s->pending - beg);

  00af7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00afc	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$5156[rsp]
  00b00	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b03	2b c1		 sub	 eax, ecx
  00b05	8b 4c 24 38	 mov	 ecx, DWORD PTR beg$5156[rsp]
  00b09	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00b0e	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00b12	44 8b c0	 mov	 r8d, eax
  00b15	48 8b d1	 mov	 rdx, rcx
  00b18	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00b20	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00b23	e8 00 00 00 00	 call	 crc32
  00b28	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00b30	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN43@deflate:

; 733  :             if (val == 0) {

  00b33	83 7c 24 3c 00	 cmp	 DWORD PTR val$5157[rsp], 0
  00b38	75 18		 jne	 SHORT $LN42@deflate

; 734  :                 s->gzindex = 0;

  00b3a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b3f	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 735  :                 s->status = COMMENT_STATE;

  00b46	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b4b	c7 40 08 5b 00
	00 00		 mov	 DWORD PTR [rax+8], 91	; 0000005bH
$LN42@deflate:

; 736  :             }
; 737  :         }
; 738  :         else

  00b52	eb 0c		 jmp	 SHORT $LN41@deflate
$LN50@deflate:

; 739  :             s->status = COMMENT_STATE;

  00b54	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b59	c7 40 08 5b 00
	00 00		 mov	 DWORD PTR [rax+8], 91	; 0000005bH
$LN41@deflate:
$LN51@deflate:

; 740  :     }
; 741  :     if (s->status == COMMENT_STATE) {

  00b60	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b65	83 78 08 5b	 cmp	 DWORD PTR [rax+8], 91	; 0000005bH
  00b69	0f 85 a3 01 00
	00		 jne	 $LN40@deflate

; 742  :         if (s->gzhead->comment != Z_NULL) {

  00b6f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b74	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00b78	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00b7d	0f 84 83 01 00
	00		 je	 $LN39@deflate

; 743  :             uInt beg = s->pending;  /* start of bytes to update crc */

  00b83	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b88	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b8b	89 44 24 40	 mov	 DWORD PTR beg$5169[rsp], eax
$LN38@deflate:

; 744  :             int val;
; 745  : 
; 746  :             do {
; 747  :                 if (s->pending == s->pending_buf_size) {

  00b8f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b94	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00b99	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00b9c	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00b9f	0f 85 8e 00 00
	00		 jne	 $LN35@deflate

; 748  :                     if (s->gzhead->hcrc && s->pending > beg)

  00ba5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00baa	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00bae	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00bb2	74 4a		 je	 SHORT $LN34@deflate
  00bb4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00bb9	8b 4c 24 40	 mov	 ecx, DWORD PTR beg$5169[rsp]
  00bbd	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00bc0	76 3c		 jbe	 SHORT $LN34@deflate

; 749  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 750  :                                             s->pending - beg);

  00bc2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00bc7	8b 4c 24 40	 mov	 ecx, DWORD PTR beg$5169[rsp]
  00bcb	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00bce	2b c1		 sub	 eax, ecx
  00bd0	8b 4c 24 40	 mov	 ecx, DWORD PTR beg$5169[rsp]
  00bd4	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00bd9	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00bdd	44 8b c0	 mov	 r8d, eax
  00be0	48 8b d1	 mov	 rdx, rcx
  00be3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00beb	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00bee	e8 00 00 00 00	 call	 crc32
  00bf3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00bfb	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN34@deflate:

; 751  :                     flush_pending(strm);

  00bfe	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00c06	e8 00 00 00 00	 call	 flush_pending

; 752  :                     beg = s->pending;

  00c0b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c10	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00c13	89 44 24 40	 mov	 DWORD PTR beg$5169[rsp], eax

; 753  :                     if (s->pending == s->pending_buf_size) {

  00c17	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c1c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00c21	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00c24	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00c27	75 0a		 jne	 SHORT $LN33@deflate

; 754  :                         val = 1;

  00c29	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR val$5170[rsp], 1

; 755  :                         break;

  00c31	eb 65		 jmp	 SHORT $LN36@deflate
$LN33@deflate:
$LN35@deflate:

; 756  :                     }
; 757  :                 }
; 758  :                 val = s->gzhead->comment[s->gzindex++];

  00c33	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c38	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00c3c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00c41	8b 49 38	 mov	 ecx, DWORD PTR [rcx+56]
  00c44	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00c48	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00c4c	89 44 24 44	 mov	 DWORD PTR val$5170[rsp], eax
  00c50	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c55	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00c58	ff c0		 inc	 eax
  00c5a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00c5f	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 759  :                 put_byte(s, val);

  00c62	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c67	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00c6a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00c6f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00c73	0f b6 54 24 44	 movzx	 edx, BYTE PTR val$5170[rsp]
  00c78	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  00c7b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c80	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00c83	ff c0		 inc	 eax
  00c85	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00c8a	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 760  :             } while (val != 0);

  00c8d	83 7c 24 44 00	 cmp	 DWORD PTR val$5170[rsp], 0
  00c92	0f 85 f7 fe ff
	ff		 jne	 $LN38@deflate
$LN36@deflate:

; 761  :             if (s->gzhead->hcrc && s->pending > beg)

  00c98	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c9d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00ca1	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00ca5	74 4a		 je	 SHORT $LN32@deflate
  00ca7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00cac	8b 4c 24 40	 mov	 ecx, DWORD PTR beg$5169[rsp]
  00cb0	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00cb3	76 3c		 jbe	 SHORT $LN32@deflate

; 762  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 763  :                                     s->pending - beg);

  00cb5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00cba	8b 4c 24 40	 mov	 ecx, DWORD PTR beg$5169[rsp]
  00cbe	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00cc1	2b c1		 sub	 eax, ecx
  00cc3	8b 4c 24 40	 mov	 ecx, DWORD PTR beg$5169[rsp]
  00cc7	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00ccc	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00cd0	44 8b c0	 mov	 r8d, eax
  00cd3	48 8b d1	 mov	 rdx, rcx
  00cd6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00cde	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00ce1	e8 00 00 00 00	 call	 crc32
  00ce6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00cee	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN32@deflate:

; 764  :             if (val == 0)

  00cf1	83 7c 24 44 00	 cmp	 DWORD PTR val$5170[rsp], 0
  00cf6	75 0c		 jne	 SHORT $LN31@deflate

; 765  :                 s->status = HCRC_STATE;

  00cf8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00cfd	c7 40 08 67 00
	00 00		 mov	 DWORD PTR [rax+8], 103	; 00000067H
$LN31@deflate:

; 766  :         }
; 767  :         else

  00d04	eb 0c		 jmp	 SHORT $LN30@deflate
$LN39@deflate:

; 768  :             s->status = HCRC_STATE;

  00d06	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d0b	c7 40 08 67 00
	00 00		 mov	 DWORD PTR [rax+8], 103	; 00000067H
$LN30@deflate:
$LN40@deflate:

; 769  :     }
; 770  :     if (s->status == HCRC_STATE) {

  00d12	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d17	83 78 08 67	 cmp	 DWORD PTR [rax+8], 103	; 00000067H
  00d1b	0f 85 ee 00 00
	00		 jne	 $LN29@deflate

; 771  :         if (s->gzhead->hcrc) {

  00d21	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d26	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00d2a	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00d2e	0f 84 cf 00 00
	00		 je	 $LN28@deflate

; 772  :             if (s->pending + 2 > s->pending_buf_size)

  00d34	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d39	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00d3c	83 c0 02	 add	 eax, 2
  00d3f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00d44	3b 41 18	 cmp	 eax, DWORD PTR [rcx+24]
  00d47	76 0d		 jbe	 SHORT $LN27@deflate

; 773  :                 flush_pending(strm);

  00d49	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00d51	e8 00 00 00 00	 call	 flush_pending
$LN27@deflate:

; 774  :             if (s->pending + 2 <= s->pending_buf_size) {

  00d56	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d5b	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00d5e	83 c0 02	 add	 eax, 2
  00d61	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00d66	3b 41 18	 cmp	 eax, DWORD PTR [rcx+24]
  00d69	0f 87 92 00 00
	00		 ja	 $LN26@deflate

; 775  :                 put_byte(s, (Byte)(strm->adler & 0xff));

  00d6f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00d77	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00d7a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00d7f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00d84	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00d87	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00d8c	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00d90	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00d93	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d98	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00d9b	ff c0		 inc	 eax
  00d9d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00da2	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 776  :                 put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  00da5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00dad	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00db0	c1 e8 08	 shr	 eax, 8
  00db3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00db8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00dbd	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00dc0	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00dc5	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00dc9	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00dcc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dd1	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00dd4	ff c0		 inc	 eax
  00dd6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00ddb	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 777  :                 strm->adler = crc32(0L, Z_NULL, 0);

  00dde	45 33 c0	 xor	 r8d, r8d
  00de1	33 d2		 xor	 edx, edx
  00de3	33 c9		 xor	 ecx, ecx
  00de5	e8 00 00 00 00	 call	 crc32
  00dea	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00df2	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 778  :                 s->status = BUSY_STATE;

  00df5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dfa	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H
$LN26@deflate:

; 779  :             }
; 780  :         }
; 781  :         else

  00e01	eb 0c		 jmp	 SHORT $LN25@deflate
$LN28@deflate:

; 782  :             s->status = BUSY_STATE;

  00e03	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e08	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H
$LN25@deflate:
$LN29@deflate:

; 783  :     }
; 784  : #endif
; 785  : 
; 786  :     /* Flush as much pending output as possible */
; 787  :     if (s->pending != 0) {

  00e0f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e14	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00e18	74 30		 je	 SHORT $LN24@deflate

; 788  :         flush_pending(strm);

  00e1a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00e22	e8 00 00 00 00	 call	 flush_pending

; 789  :         if (strm->avail_out == 0) {

  00e27	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00e2f	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00e33	75 13		 jne	 SHORT $LN23@deflate

; 790  :             /* Since avail_out is 0, deflate will be called again with
; 791  :              * more output space, but possibly with both pending and
; 792  :              * avail_in equal to zero. There won't be anything to do,
; 793  :              * but this is not an error situation so make sure we
; 794  :              * return OK instead of BUF_ERROR at next call of deflate:
; 795  :              */
; 796  :             s->last_flush = -1;

  00e35	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e3a	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 797  :             return Z_OK;

  00e41	33 c0		 xor	 eax, eax
  00e43	e9 fa 04 00 00	 jmp	 $LN84@deflate
$LN23@deflate:

; 798  :         }
; 799  : 
; 800  :     /* Make sure there is something to do and avoid duplicate consecutive
; 801  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 802  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 803  :      */
; 804  :     } else if (strm->avail_in == 0 && flush <= old_flush &&

  00e48	eb 42		 jmp	 SHORT $LN22@deflate
$LN24@deflate:

; 805  :                flush != Z_FINISH) {

  00e4a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00e52	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00e56	75 34		 jne	 SHORT $LN21@deflate
  00e58	8b 44 24 28	 mov	 eax, DWORD PTR old_flush$[rsp]
  00e5c	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR flush$[rsp], eax
  00e63	7f 27		 jg	 SHORT $LN21@deflate
  00e65	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00e6d	74 1d		 je	 SHORT $LN21@deflate

; 806  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00e6f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00e77	48 8b 0d 38 00
	00 00		 mov	 rcx, QWORD PTR z_errmsg+56
  00e7e	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  00e82	b8 fb ff ff ff	 mov	 eax, -5
  00e87	e9 b6 04 00 00	 jmp	 $LN84@deflate
$LN21@deflate:
$LN22@deflate:

; 807  :     }
; 808  : 
; 809  :     /* User must not provide more input after the first FINISH: */
; 810  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  00e8c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e91	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  00e98	75 2b		 jne	 SHORT $LN20@deflate
  00e9a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00ea2	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00ea6	74 1d		 je	 SHORT $LN20@deflate

; 811  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00ea8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00eb0	48 8b 0d 38 00
	00 00		 mov	 rcx, QWORD PTR z_errmsg+56
  00eb7	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  00ebb	b8 fb ff ff ff	 mov	 eax, -5
  00ec0	e9 7d 04 00 00	 jmp	 $LN84@deflate
$LN20@deflate:

; 812  :     }
; 813  : 
; 814  :     /* Start a new block or continue the current one.
; 815  :      */
; 816  :     if (strm->avail_in != 0 || s->lookahead != 0 ||
; 817  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {

  00ec5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00ecd	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00ed1	75 2e		 jne	 SHORT $LN18@deflate
  00ed3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ed8	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00edf	75 20		 jne	 SHORT $LN18@deflate
  00ee1	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  00ee9	0f 84 d0 01 00
	00		 je	 $LN19@deflate
  00eef	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ef4	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  00efb	0f 84 be 01 00
	00		 je	 $LN19@deflate
$LN18@deflate:

; 818  :         block_state bstate;
; 819  : 
; 820  :         bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
; 821  :                     (s->strategy == Z_RLE ? deflate_rle(s, flush) :
; 822  :                         (*(configuration_table[s->level].func))(s, flush));

  00f01	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f06	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  00f0d	75 17		 jne	 SHORT $LN106@deflate
  00f0f	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  00f16	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00f1b	e8 00 00 00 00	 call	 deflate_huff
  00f20	89 44 24 70	 mov	 DWORD PTR tv686[rsp], eax
  00f24	eb 63		 jmp	 SHORT $LN107@deflate
$LN106@deflate:
  00f26	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f2b	83 b8 b0 00 00
	00 03		 cmp	 DWORD PTR [rax+176], 3
  00f32	75 17		 jne	 SHORT $LN104@deflate
  00f34	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  00f3b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00f40	e8 00 00 00 00	 call	 deflate_rle
  00f45	89 44 24 74	 mov	 DWORD PTR tv685[rsp], eax
  00f49	eb 36		 jmp	 SHORT $LN105@deflate
$LN104@deflate:
  00f4b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f50	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  00f57	48 6b c0 10	 imul	 rax, 16
  00f5b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  00f62	48 89 4c 24 78	 mov	 QWORD PTR tv834[rsp], rcx
  00f67	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  00f6e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00f73	4c 8b 44 24 78	 mov	 r8, QWORD PTR tv834[rsp]
  00f78	41 ff 54 00 08	 call	 QWORD PTR [r8+rax+8]
  00f7d	89 44 24 74	 mov	 DWORD PTR tv685[rsp], eax
$LN105@deflate:
  00f81	8b 44 24 74	 mov	 eax, DWORD PTR tv685[rsp]
  00f85	89 44 24 70	 mov	 DWORD PTR tv686[rsp], eax
$LN107@deflate:
  00f89	8b 44 24 70	 mov	 eax, DWORD PTR tv686[rsp]
  00f8d	89 44 24 48	 mov	 DWORD PTR bstate$5196[rsp], eax

; 823  : 
; 824  :         if (bstate == finish_started || bstate == finish_done) {

  00f91	83 7c 24 48 02	 cmp	 DWORD PTR bstate$5196[rsp], 2
  00f96	74 07		 je	 SHORT $LN16@deflate
  00f98	83 7c 24 48 03	 cmp	 DWORD PTR bstate$5196[rsp], 3
  00f9d	75 0c		 jne	 SHORT $LN17@deflate
$LN16@deflate:

; 825  :             s->status = FINISH_STATE;

  00f9f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00fa4	c7 40 08 9a 02
	00 00		 mov	 DWORD PTR [rax+8], 666	; 0000029aH
$LN17@deflate:

; 826  :         }
; 827  :         if (bstate == need_more || bstate == finish_started) {

  00fab	83 7c 24 48 00	 cmp	 DWORD PTR bstate$5196[rsp], 0
  00fb0	74 07		 je	 SHORT $LN14@deflate
  00fb2	83 7c 24 48 02	 cmp	 DWORD PTR bstate$5196[rsp], 2
  00fb7	75 21		 jne	 SHORT $LN15@deflate
$LN14@deflate:

; 828  :             if (strm->avail_out == 0) {

  00fb9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00fc1	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00fc5	75 0c		 jne	 SHORT $LN13@deflate

; 829  :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */

  00fc7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00fcc	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN13@deflate:

; 830  :             }
; 831  :             return Z_OK;

  00fd3	33 c0		 xor	 eax, eax
  00fd5	e9 68 03 00 00	 jmp	 $LN84@deflate
$LN15@deflate:

; 832  :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 833  :              * of deflate should use the same flush parameter to make sure
; 834  :              * that the flush is complete. So we don't have to output an
; 835  :              * empty block here, this will be done at next call. This also
; 836  :              * ensures that for a very small output buffer, we emit at most
; 837  :              * one empty block.
; 838  :              */
; 839  :         }
; 840  :         if (bstate == block_done) {

  00fda	83 7c 24 48 01	 cmp	 DWORD PTR bstate$5196[rsp], 1
  00fdf	0f 85 da 00 00
	00		 jne	 $LN12@deflate

; 841  :             if (flush == Z_PARTIAL_FLUSH) {

  00fe5	83 bc 24 a8 00
	00 00 01	 cmp	 DWORD PTR flush$[rsp], 1
  00fed	75 0f		 jne	 SHORT $LN11@deflate

; 842  :                 _tr_align(s);

  00fef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00ff4	e8 00 00 00 00	 call	 _tr_align
  00ff9	e9 93 00 00 00	 jmp	 $LN10@deflate
$LN11@deflate:

; 843  :             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

  00ffe	83 bc 24 a8 00
	00 00 05	 cmp	 DWORD PTR flush$[rsp], 5
  01006	0f 84 85 00 00
	00		 je	 $LN9@deflate

; 844  :                 _tr_stored_block(s, (char*)0, 0L, 0);

  0100c	45 33 c9	 xor	 r9d, r9d
  0100f	45 33 c0	 xor	 r8d, r8d
  01012	33 d2		 xor	 edx, edx
  01014	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01019	e8 00 00 00 00	 call	 _tr_stored_block

; 845  :                 /* For a full flush, this empty block will be recognized
; 846  :                  * as a special marker by inflate_sync().
; 847  :                  */
; 848  :                 if (flush == Z_FULL_FLUSH) {

  0101e	83 bc 24 a8 00
	00 00 03	 cmp	 DWORD PTR flush$[rsp], 3
  01026	75 69		 jne	 SHORT $LN8@deflate

; 849  :                     CLEAR_HASH(s);             /* forget history */

  01028	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0102d	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  01030	ff c8		 dec	 eax
  01032	8b c0		 mov	 eax, eax
  01034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01039	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0103d	33 d2		 xor	 edx, edx
  0103f	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  01043	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01048	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0104b	ff c8		 dec	 eax
  0104d	8b c0		 mov	 eax, eax
  0104f	48 d1 e0	 shl	 rax, 1
  01052	4c 8b c0	 mov	 r8, rax
  01055	33 d2		 xor	 edx, edx
  01057	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0105c	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  01060	e8 00 00 00 00	 call	 memset

; 850  :                     if (s->lookahead == 0) {

  01065	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0106a	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  01071	75 1e		 jne	 SHORT $LN7@deflate

; 851  :                         s->strstart = 0;

  01073	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01078	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+148], 0

; 852  :                         s->block_start = 0L;

  01082	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01087	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0
$LN7@deflate:
$LN8@deflate:
$LN9@deflate:
$LN10@deflate:

; 853  :                     }
; 854  :                 }
; 855  :             }
; 856  :             flush_pending(strm);

  01091	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01099	e8 00 00 00 00	 call	 flush_pending

; 857  :             if (strm->avail_out == 0) {

  0109e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  010a6	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  010aa	75 13		 jne	 SHORT $LN6@deflate

; 858  :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */

  010ac	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010b1	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 859  :               return Z_OK;

  010b8	33 c0		 xor	 eax, eax
  010ba	e9 83 02 00 00	 jmp	 $LN84@deflate
$LN6@deflate:
$LN12@deflate:
$LN19@deflate:

; 860  :             }
; 861  :         }
; 862  :     }
; 863  :     Assert(strm->avail_out > 0, "bug2");
; 864  : 
; 865  :     if (flush != Z_FINISH) return Z_OK;

  010bf	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  010c7	74 07		 je	 SHORT $LN5@deflate
  010c9	33 c0		 xor	 eax, eax
  010cb	e9 72 02 00 00	 jmp	 $LN84@deflate
$LN5@deflate:

; 866  :     if (s->wrap <= 0) return Z_STREAM_END;

  010d0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010d5	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  010d9	7f 0a		 jg	 SHORT $LN4@deflate
  010db	b8 01 00 00 00	 mov	 eax, 1
  010e0	e9 5d 02 00 00	 jmp	 $LN84@deflate
$LN4@deflate:

; 867  : 
; 868  :     /* Write the trailer */
; 869  : #ifdef GZIP
; 870  :     if (s->wrap == 2) {

  010e5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010ea	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  010ee	0f 85 c4 01 00
	00		 jne	 $LN3@deflate

; 871  :         put_byte(s, (Byte)(strm->adler & 0xff));

  010f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  010fc	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  010ff	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01104	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01109	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0110c	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  01111	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  01115	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  01118	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0111d	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  01120	ff c0		 inc	 eax
  01122	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01127	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 872  :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  0112a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01132	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01135	c1 e8 08	 shr	 eax, 8
  01138	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0113d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01142	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  01145	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  0114a	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0114e	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  01151	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01156	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  01159	ff c0		 inc	 eax
  0115b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01160	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 873  :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  01163	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0116b	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0116e	c1 e8 10	 shr	 eax, 16
  01171	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01176	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0117b	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0117e	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  01183	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  01187	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  0118a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0118f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  01192	ff c0		 inc	 eax
  01194	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01199	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 874  :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  0119c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  011a4	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  011a7	c1 e8 18	 shr	 eax, 24
  011aa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  011af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  011b4	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  011b7	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  011bc	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  011c0	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  011c3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011c8	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  011cb	ff c0		 inc	 eax
  011cd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  011d2	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 875  :         put_byte(s, (Byte)(strm->total_in & 0xff));

  011d5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  011dd	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  011e0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  011e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  011ea	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  011ed	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  011f2	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  011f6	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  011f9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011fe	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  01201	ff c0		 inc	 eax
  01203	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01208	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 876  :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  0120b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01213	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  01216	c1 e8 08	 shr	 eax, 8
  01219	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0121e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01223	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  01226	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  0122b	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0122f	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  01232	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01237	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0123a	ff c0		 inc	 eax
  0123c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01241	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 877  :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  01244	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0124c	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0124f	c1 e8 10	 shr	 eax, 16
  01252	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01257	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0125c	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0125f	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  01264	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  01268	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  0126b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01270	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  01273	ff c0		 inc	 eax
  01275	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0127a	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 878  :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  0127d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01285	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  01288	c1 e8 18	 shr	 eax, 24
  0128b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01290	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01295	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  01298	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  0129d	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  012a1	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  012a4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  012a9	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  012ac	ff c0		 inc	 eax
  012ae	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  012b3	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 879  :     }
; 880  :     else

  012b6	eb 36		 jmp	 SHORT $LN2@deflate
$LN3@deflate:

; 881  : #endif
; 882  :     {
; 883  :         putShortMSB(s, (uInt)(strm->adler >> 16));

  012b8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  012c0	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  012c3	c1 e8 10	 shr	 eax, 16
  012c6	8b d0		 mov	 edx, eax
  012c8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  012cd	e8 00 00 00 00	 call	 putShortMSB

; 884  :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  012d2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  012da	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  012dd	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  012e2	8b d0		 mov	 edx, eax
  012e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  012e9	e8 00 00 00 00	 call	 putShortMSB
$LN2@deflate:

; 885  :     }
; 886  :     flush_pending(strm);

  012ee	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  012f6	e8 00 00 00 00	 call	 flush_pending

; 887  :     /* If avail_out is zero, the application will call deflate again
; 888  :      * to flush the rest.
; 889  :      */
; 890  :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  012fb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01300	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  01304	7e 12		 jle	 SHORT $LN1@deflate
  01306	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0130b	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0130e	f7 d8		 neg	 eax
  01310	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01315	89 41 2c	 mov	 DWORD PTR [rcx+44], eax
$LN1@deflate:

; 891  :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  01318	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0131d	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  01321	74 0d		 je	 SHORT $LN108@deflate
  01323	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv833[rsp], 0
  0132e	eb 0b		 jmp	 SHORT $LN109@deflate
$LN108@deflate:
  01330	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv833[rsp], 1
$LN109@deflate:
  0133b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv833[rsp]
$LN84@deflate:

; 892  : }

  01342	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  01349	c3		 ret	 0
deflate	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT putShortMSB
_TEXT	SEGMENT
s$ = 8
b$ = 16
putShortMSB PROC					; COMDAT

; 551  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 552  :     put_byte(s, (Byte)(b >> 8));

  00009	8b 44 24 10	 mov	 eax, DWORD PTR b$[rsp]
  0000d	c1 e8 08	 shr	 eax, 8
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s$[rsp]
  00015	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00018	48 8b 54 24 08	 mov	 rdx, QWORD PTR s$[rsp]
  0001d	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00021	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00024	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00029	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0002c	ff c0		 inc	 eax
  0002e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s$[rsp]
  00033	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 553  :     put_byte(s, (Byte)(b & 0xff));

  00036	8b 44 24 10	 mov	 eax, DWORD PTR b$[rsp]
  0003a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s$[rsp]
  00044	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00047	48 8b 54 24 08	 mov	 rdx, QWORD PTR s$[rsp]
  0004c	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00050	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00053	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00058	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0005b	ff c0		 inc	 eax
  0005d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s$[rsp]
  00062	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 554  : }

  00065	c3		 ret	 0
putShortMSB ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$flush_pending DD imagerel flush_pending
	DD	imagerel flush_pending+270
	DD	imagerel $unwind$flush_pending
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$flush_pending DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT flush_pending
_TEXT	SEGMENT
len$ = 32
strm$ = 64
flush_pending PROC					; COMDAT

; 564  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 565  :     unsigned len = strm->state->pending;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0000e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00012	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00015	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 566  : 
; 567  :     if (len > strm->avail_out) len = strm->avail_out;

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0001e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00021	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  00025	76 0c		 jbe	 SHORT $LN3@flush_pend
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002f	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN3@flush_pend:

; 568  :     if (len == 0) return;

  00033	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  00038	75 05		 jne	 SHORT $LN2@flush_pend
  0003a	e9 ca 00 00 00	 jmp	 $LN4@flush_pend
$LN2@flush_pend:

; 569  : 
; 570  :     zmemcpy(strm->next_out, strm->state->pending_out, len);

  0003f	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00048	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0004c	44 8b c0	 mov	 r8d, eax
  0004f	48 8b 51 20	 mov	 rdx, QWORD PTR [rcx+32]
  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00058	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0005c	e8 00 00 00 00	 call	 memcpy

; 571  :     strm->next_out  += len;

  00061	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0006a	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00073	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 572  :     strm->state->pending_out  += len;

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00080	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00084	48 03 48 20	 add	 rcx, QWORD PTR [rax+32]
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00090	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00094	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 573  :     strm->total_out += len;

  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0009d	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000a0	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000a9	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 574  :     strm->avail_out  -= len;

  000ac	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000b1	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000b5	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000b8	2b c1		 sub	 eax, ecx
  000ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000bf	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 575  :     strm->state->pending -= len;

  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c7	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000cb	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000cf	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000d2	2b c1		 sub	 eax, ecx
  000d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000d9	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000dd	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 576  :     if (strm->state->pending == 0) {

  000e0	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000e5	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000e9	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  000ed	75 1a		 jne	 SHORT $LN1@flush_pend

; 577  :         strm->state->pending_out = strm->state->pending_buf;

  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000f4	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000fd	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00101	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00105	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN1@flush_pend:
$LN4@flush_pend:

; 578  :     }
; 579  : }

  00109	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0010d	c3		 ret	 0
flush_pending ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateEnd DD imagerel $LN12
	DD	imagerel $LN12+374
	DD	imagerel $unwind$deflateEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateEnd DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateEnd
_TEXT	SEGMENT
status$ = 32
tv151 = 36
strm$ = 64
deflateEnd PROC						; COMDAT

; 897  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 898  :     int status;
; 899  : 
; 900  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN6@deflateEnd
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 0a		 jne	 SHORT $LN7@deflateEnd
$LN6@deflateEnd:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	e9 4a 01 00 00	 jmp	 $LN8@deflateEnd
$LN7@deflateEnd:

; 901  : 
; 902  :     status = strm->state->status;

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00030	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00033	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 903  :     if (status != INIT_STATE &&
; 904  :         status != EXTRA_STATE &&
; 905  :         status != NAME_STATE &&
; 906  :         status != COMMENT_STATE &&
; 907  :         status != HCRC_STATE &&
; 908  :         status != BUSY_STATE &&
; 909  :         status != FINISH_STATE) {

  00037	83 7c 24 20 2a	 cmp	 DWORD PTR status$[rsp], 42 ; 0000002aH
  0003c	74 37		 je	 SHORT $LN5@deflateEnd
  0003e	83 7c 24 20 45	 cmp	 DWORD PTR status$[rsp], 69 ; 00000045H
  00043	74 30		 je	 SHORT $LN5@deflateEnd
  00045	83 7c 24 20 49	 cmp	 DWORD PTR status$[rsp], 73 ; 00000049H
  0004a	74 29		 je	 SHORT $LN5@deflateEnd
  0004c	83 7c 24 20 5b	 cmp	 DWORD PTR status$[rsp], 91 ; 0000005bH
  00051	74 22		 je	 SHORT $LN5@deflateEnd
  00053	83 7c 24 20 67	 cmp	 DWORD PTR status$[rsp], 103 ; 00000067H
  00058	74 1b		 je	 SHORT $LN5@deflateEnd
  0005a	83 7c 24 20 71	 cmp	 DWORD PTR status$[rsp], 113 ; 00000071H
  0005f	74 14		 je	 SHORT $LN5@deflateEnd
  00061	81 7c 24 20 9a
	02 00 00	 cmp	 DWORD PTR status$[rsp], 666 ; 0000029aH
  00069	74 0a		 je	 SHORT $LN5@deflateEnd

; 910  :       return Z_STREAM_ERROR;

  0006b	b8 fe ff ff ff	 mov	 eax, -2
  00070	e9 fc 00 00 00	 jmp	 $LN8@deflateEnd
$LN5@deflateEnd:

; 911  :     }
; 912  : 
; 913  :     /* Deallocate in reverse order of allocations: */
; 914  :     TRY_FREE(strm, strm->state->pending_buf);

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00083	74 1e		 je	 SHORT $LN4@deflateEnd
  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0008a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008e	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00097	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a0	ff 50 38	 call	 QWORD PTR [rax+56]
$LN4@deflateEnd:

; 915  :     TRY_FREE(strm, strm->state->head);

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000ac	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000b1	74 1e		 je	 SHORT $LN3@deflateEnd
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000b8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000bc	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  000c0	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c5	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000c9	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ce	ff 50 38	 call	 QWORD PTR [rax+56]
$LN3@deflateEnd:

; 916  :     TRY_FREE(strm, strm->state->prev);

  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d6	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000da	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000df	74 1e		 je	 SHORT $LN2@deflateEnd
  000e1	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000e6	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000ea	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  000ee	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000f3	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000fc	ff 50 38	 call	 QWORD PTR [rax+56]
$LN2@deflateEnd:

; 917  :     TRY_FREE(strm, strm->state->window);

  000ff	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00104	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00108	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  0010d	74 1e		 je	 SHORT $LN1@deflateEnd
  0010f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00114	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00118	48 8b 50 50	 mov	 rdx, QWORD PTR [rax+80]
  0011c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00121	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00125	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0012a	ff 50 38	 call	 QWORD PTR [rax+56]
$LN1@deflateEnd:

; 918  : 
; 919  :     ZFREE(strm, strm->state);

  0012d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00132	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  00136	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0013b	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0013f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00144	ff 50 38	 call	 QWORD PTR [rax+56]

; 920  :     strm->state = Z_NULL;

  00147	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0014c	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 921  : 
; 922  :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  00154	83 7c 24 20 71	 cmp	 DWORD PTR status$[rsp], 113 ; 00000071H
  00159	75 0a		 jne	 SHORT $LN10@deflateEnd
  0015b	c7 44 24 24 fd
	ff ff ff	 mov	 DWORD PTR tv151[rsp], -3
  00163	eb 08		 jmp	 SHORT $LN11@deflateEnd
$LN10@deflateEnd:
  00165	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN11@deflateEnd:
  0016d	8b 44 24 24	 mov	 eax, DWORD PTR tv151[rsp]
$LN8@deflateEnd:

; 923  : }

  00171	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00175	c3		 ret	 0
deflateEnd ENDP
_TEXT	ENDS
PUBLIC	deflateCopy
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateCopy DD imagerel $LN8
	DD	imagerel $LN8+766
	DD	imagerel $unwind$deflateCopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateCopy DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateCopy
_TEXT	SEGMENT
overlay$ = 32
ds$ = 40
ss$ = 48
dest$ = 80
source$ = 88
deflateCopy PROC					; COMDAT

; 933  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 934  : #ifdef MAXSEG_64K
; 935  :     return Z_STREAM_ERROR;
; 936  : #else
; 937  :     deflate_state *ds;
; 938  :     deflate_state *ss;
; 939  :     ushf *overlay;
; 940  : 
; 941  : 
; 942  :     if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR source$[rsp], 0
  00014	74 14		 je	 SHORT $LN4@deflateCop
  00016	48 83 7c 24 50
	00		 cmp	 QWORD PTR dest$[rsp], 0
  0001c	74 0c		 je	 SHORT $LN4@deflateCop
  0001e	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	75 0a		 jne	 SHORT $LN5@deflateCop
$LN4@deflateCop:

; 943  :         return Z_STREAM_ERROR;

  0002a	b8 fe ff ff ff	 mov	 eax, -2
  0002f	e9 c5 02 00 00	 jmp	 $LN6@deflateCop
$LN5@deflateCop:

; 944  :     }
; 945  : 
; 946  :     ss = source->state;

  00034	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00039	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003d	48 89 44 24 30	 mov	 QWORD PTR ss$[rsp], rax

; 947  : 
; 948  :     zmemcpy(dest, source, sizeof(z_stream));

  00042	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  00048	48 8b 54 24 58	 mov	 rdx, QWORD PTR source$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00052	e8 00 00 00 00	 call	 memcpy

; 949  : 
; 950  :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  00057	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0005d	ba 01 00 00 00	 mov	 edx, 1
  00062	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00067	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0006b	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00070	ff 50 30	 call	 QWORD PTR [rax+48]
  00073	48 89 44 24 28	 mov	 QWORD PTR ds$[rsp], rax

; 951  :     if (ds == Z_NULL) return Z_MEM_ERROR;

  00078	48 83 7c 24 28
	00		 cmp	 QWORD PTR ds$[rsp], 0
  0007e	75 0a		 jne	 SHORT $LN3@deflateCop
  00080	b8 fc ff ff ff	 mov	 eax, -4
  00085	e9 6f 02 00 00	 jmp	 $LN6@deflateCop
$LN3@deflateCop:

; 952  :     dest->state = (struct internal_state FAR *) ds;

  0008a	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0008f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  00094	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 953  :     zmemcpy(ds, ss, sizeof(deflate_state));

  00098	41 b8 20 17 00
	00		 mov	 r8d, 5920		; 00001720H
  0009e	48 8b 54 24 30	 mov	 rdx, QWORD PTR ss$[rsp]
  000a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  000a8	e8 00 00 00 00	 call	 memcpy

; 954  :     ds->strm = dest;

  000ad	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  000b2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  000b7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 955  : 
; 956  :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  000ba	41 b8 02 00 00
	00		 mov	 r8d, 2
  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  000c5	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000cd	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000d1	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000d6	ff 50 30	 call	 QWORD PTR [rax+48]
  000d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  000de	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 957  :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  000e2	41 b8 02 00 00
	00		 mov	 r8d, 2
  000e8	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  000ed	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000f5	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000f9	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000fe	ff 50 30	 call	 QWORD PTR [rax+48]
  00101	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  00106	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 958  :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  0010a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00110	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00115	8b 50 74	 mov	 edx, DWORD PTR [rax+116]
  00118	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0011d	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00121	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00126	ff 50 30	 call	 QWORD PTR [rax+48]
  00129	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  0012e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 959  :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  00132	41 b8 04 00 00
	00		 mov	 r8d, 4
  00138	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0013d	8b 90 f0 16 00
	00		 mov	 edx, DWORD PTR [rax+5872]
  00143	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00148	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0014c	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00151	ff 50 30	 call	 QWORD PTR [rax+48]
  00154	48 89 44 24 20	 mov	 QWORD PTR overlay$[rsp], rax

; 960  :     ds->pending_buf = (uchf *) overlay;

  00159	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0015e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR overlay$[rsp]
  00163	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 961  : 
; 962  :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
; 963  :         ds->pending_buf == Z_NULL) {

  00167	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0016c	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  00171	74 24		 je	 SHORT $LN1@deflateCop
  00173	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00178	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0017d	74 18		 je	 SHORT $LN1@deflateCop
  0017f	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00184	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00189	74 0c		 je	 SHORT $LN1@deflateCop
  0018b	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00190	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00195	75 14		 jne	 SHORT $LN2@deflateCop
$LN1@deflateCop:

; 964  :         deflateEnd (dest);

  00197	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  0019c	e8 00 00 00 00	 call	 deflateEnd

; 965  :         return Z_MEM_ERROR;

  001a1	b8 fc ff ff ff	 mov	 eax, -4
  001a6	e9 4e 01 00 00	 jmp	 $LN6@deflateCop
$LN2@deflateCop:

; 966  :     }
; 967  :     /* following zmemcpy do not work for 16-bit MSDOS */
; 968  :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  001b0	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  001b3	d1 e0		 shl	 eax, 1
  001b5	8b c0		 mov	 eax, eax
  001b7	44 8b c0	 mov	 r8d, eax
  001ba	48 8b 44 24 30	 mov	 rax, QWORD PTR ss$[rsp]
  001bf	48 8b 50 50	 mov	 rdx, QWORD PTR [rax+80]
  001c3	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  001c8	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  001cc	e8 00 00 00 00	 call	 memcpy

; 969  :     zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));

  001d1	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  001d6	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  001d9	48 d1 e0	 shl	 rax, 1
  001dc	4c 8b c0	 mov	 r8, rax
  001df	48 8b 44 24 30	 mov	 rax, QWORD PTR ss$[rsp]
  001e4	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  001e8	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  001ed	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  001f1	e8 00 00 00 00	 call	 memcpy

; 970  :     zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));

  001f6	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  001fb	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  001fe	48 d1 e0	 shl	 rax, 1
  00201	4c 8b c0	 mov	 r8, rax
  00204	48 8b 44 24 30	 mov	 rax, QWORD PTR ss$[rsp]
  00209	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  0020d	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00212	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00216	e8 00 00 00 00	 call	 memcpy

; 971  :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  0021b	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00220	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00223	44 8b c0	 mov	 r8d, eax
  00226	48 8b 44 24 30	 mov	 rax, QWORD PTR ss$[rsp]
  0022b	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0022f	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00234	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00238	e8 00 00 00 00	 call	 memcpy

; 972  : 
; 973  :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  0023d	48 8b 44 24 30	 mov	 rax, QWORD PTR ss$[rsp]
  00242	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ss$[rsp]
  00247	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0024b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0024f	48 2b c1	 sub	 rax, rcx
  00252	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  00257	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0025b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  00260	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 974  :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  00264	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00269	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  0026f	33 d2		 xor	 edx, edx
  00271	b9 02 00 00 00	 mov	 ecx, 2
  00276	48 f7 f1	 div	 rcx
  00279	48 8b 4c 24 20	 mov	 rcx, QWORD PTR overlay$[rsp]
  0027e	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00282	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  00287	48 89 81 f8 16
	00 00		 mov	 QWORD PTR [rcx+5880], rax

; 975  :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  0028e	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00293	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00299	48 6b c0 03	 imul	 rax, 3
  0029d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  002a2	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  002a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  002ab	48 89 81 e8 16
	00 00		 mov	 QWORD PTR [rcx+5864], rax

; 976  : 
; 977  :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  002b2	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002b7	48 05 bc 00 00
	00		 add	 rax, 188		; 000000bcH
  002bd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  002c2	48 89 81 40 0b
	00 00		 mov	 QWORD PTR [rcx+2880], rax

; 978  :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  002c9	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002ce	48 05 b0 09 00
	00		 add	 rax, 2480		; 000009b0H
  002d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  002d9	48 89 81 58 0b
	00 00		 mov	 QWORD PTR [rcx+2904], rax

; 979  :     ds->bl_desc.dyn_tree = ds->bl_tree;

  002e0	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002e5	48 05 a4 0a 00
	00		 add	 rax, 2724		; 00000aa4H
  002eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  002f0	48 89 81 70 0b
	00 00		 mov	 QWORD PTR [rcx+2928], rax

; 980  : 
; 981  :     return Z_OK;

  002f7	33 c0		 xor	 eax, eax
$LN6@deflateCop:

; 982  : #endif /* MAXSEG_64K */
; 983  : }

  002f9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002fd	c3		 ret	 0
deflateCopy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lm_init DD imagerel lm_init
	DD	imagerel lm_init+350
	DD	imagerel $unwind$lm_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lm_init DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lm_init
_TEXT	SEGMENT
s$ = 48
lm_init	PROC						; COMDAT

; 1024 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1025 :     s->window_size = (ulg)2L*s->w_size;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0000e	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00011	d1 e0		 shl	 eax, 1
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00018	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 1026 : 
; 1027 :     CLEAR_HASH(s);

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00020	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00023	ff c8		 dec	 eax
  00025	8b c0		 mov	 eax, eax
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00030	33 d2		 xor	 edx, edx
  00032	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0003b	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0003e	ff c8		 dec	 eax
  00040	8b c0		 mov	 eax, eax
  00042	48 d1 e0	 shl	 rax, 1
  00045	4c 8b c0	 mov	 r8, rax
  00048	33 d2		 xor	 edx, edx
  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0004f	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00053	e8 00 00 00 00	 call	 memset

; 1028 : 
; 1029 :     /* Set the default configuration parameters:
; 1030 :      */
; 1031 :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0005d	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  00064	48 6b c0 10	 imul	 rax, 16
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  0006f	0f b7 44 01 02	 movzx	 eax, WORD PTR [rcx+rax+2]
  00074	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00079	89 81 a8 00 00
	00		 mov	 DWORD PTR [rcx+168], eax

; 1032 :     s->good_match       = configuration_table[s->level].good_length;

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00084	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  0008b	48 6b c0 10	 imul	 rax, 16
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  00096	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0009a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0009f	89 81 b4 00 00
	00		 mov	 DWORD PTR [rcx+180], eax

; 1033 :     s->nice_match       = configuration_table[s->level].nice_length;

  000a5	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000aa	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  000b1	48 6b c0 10	 imul	 rax, 16
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  000bc	0f b7 44 01 04	 movzx	 eax, WORD PTR [rcx+rax+4]
  000c1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000c6	89 81 b8 00 00
	00		 mov	 DWORD PTR [rcx+184], eax

; 1034 :     s->max_chain_length = configuration_table[s->level].max_chain;

  000cc	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000d1	48 63 80 ac 00
	00 00		 movsxd	 rax, DWORD PTR [rax+172]
  000d8	48 6b c0 10	 imul	 rax, 16
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_table
  000e3	0f b7 44 01 06	 movzx	 eax, WORD PTR [rcx+rax+6]
  000e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000ed	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax

; 1035 : 
; 1036 :     s->strstart = 0;

  000f3	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000f8	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+148], 0

; 1037 :     s->block_start = 0L;

  00102	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00107	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0

; 1038 :     s->lookahead = 0;

  00111	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00116	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+156], 0

; 1039 :     s->match_length = s->prev_length = MIN_MATCH-1;

  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00125	c7 80 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+160], 2
  0012f	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00134	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 1040 :     s->match_available = 0;

  0013e	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00143	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 1041 :     s->ins_h = 0;

  0014d	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00152	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 1042 : #ifndef FASTEST
; 1043 : #ifdef ASMV
; 1044 :     match_init(); /* initialize the asm code */
; 1045 : #endif
; 1046 : #endif
; 1047 : }

  00159	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0015d	c3		 ret	 0
lm_init	ENDP
_TEXT	ENDS
EXTRN	_tr_flush_block:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_stored DD imagerel deflate_stored
	DD	imagerel deflate_stored+858
	DD	imagerel $unwind$deflate_stored
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_stored DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_stored
_TEXT	SEGMENT
max_start$ = 32
max_block_size$ = 36
tv135 = 40
tv160 = 48
tv169 = 56
tv181 = 64
tv190 = 72
tv192 = 76
s$ = 96
flush$ = 104
deflate_stored PROC					; COMDAT

; 1465 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1466 :     /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
; 1467 :      * to pending_buf_size, and each stored block has a 5 byte header:
; 1468 :      */
; 1469 :     ulg max_block_size = 0xffff;

  0000d	c7 44 24 24 ff
	ff 00 00	 mov	 DWORD PTR max_block_size$[rsp], 65535 ; 0000ffffH

; 1470 :     ulg max_start;
; 1471 : 
; 1472 :     if (max_block_size > s->pending_buf_size - 5) {

  00015	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0001a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0001d	83 e8 05	 sub	 eax, 5
  00020	39 44 24 24	 cmp	 DWORD PTR max_block_size$[rsp], eax
  00024	76 0f		 jbe	 SHORT $LN12@deflate_st

; 1473 :         max_block_size = s->pending_buf_size - 5;

  00026	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0002b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002e	83 e8 05	 sub	 eax, 5
  00031	89 44 24 24	 mov	 DWORD PTR max_block_size$[rsp], eax
$LN12@deflate_st:
$LN11@deflate_st:

; 1474 :     }
; 1475 : 
; 1476 :     /* Copy as much as possible from input to output: */
; 1477 :     for (;;) {
; 1478 :         /* Fill the window as much as possible: */
; 1479 :         if (s->lookahead <= 1) {

  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0003a	83 b8 9c 00 00
	00 01		 cmp	 DWORD PTR [rax+156], 1
  00041	77 39		 ja	 SHORT $LN9@deflate_st

; 1480 : 
; 1481 :             Assert(s->strstart < s->w_size+MAX_DIST(s) ||
; 1482 :                    s->block_start >= (long)s->w_size, "slide too late");
; 1483 : 
; 1484 :             fill_window(s);

  00043	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00048	e8 00 00 00 00	 call	 fill_window

; 1485 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  0004d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00052	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00059	75 0e		 jne	 SHORT $LN8@deflate_st
  0005b	83 7c 24 68 00	 cmp	 DWORD PTR flush$[rsp], 0
  00060	75 07		 jne	 SHORT $LN8@deflate_st
  00062	33 c0		 xor	 eax, eax
  00064	e9 ec 02 00 00	 jmp	 $LN13@deflate_st
$LN8@deflate_st:

; 1486 : 
; 1487 :             if (s->lookahead == 0) break; /* flush the current block */

  00069	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0006e	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00075	75 05		 jne	 SHORT $LN7@deflate_st
  00077	e9 f2 01 00 00	 jmp	 $LN10@deflate_st
$LN7@deflate_st:
$LN9@deflate_st:

; 1488 :         }
; 1489 :         Assert(s->block_start >= 0L, "block gone");
; 1490 : 
; 1491 :         s->strstart += s->lookahead;

  0007c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00081	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00087	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0008c	03 81 9c 00 00
	00		 add	 eax, DWORD PTR [rcx+156]
  00092	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00097	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1492 :         s->lookahead = 0;

  0009d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000a2	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+156], 0

; 1493 : 
; 1494 :         /* Emit a stored block if pending_buf will be full: */
; 1495 :         max_start = s->block_start + max_block_size;

  000ac	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000b1	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  000b7	03 44 24 24	 add	 eax, DWORD PTR max_block_size$[rsp]
  000bb	89 44 24 20	 mov	 DWORD PTR max_start$[rsp], eax

; 1496 :         if (s->strstart == 0 || (ulg)s->strstart >= max_start) {

  000bf	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000c4	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  000cb	74 15		 je	 SHORT $LN5@deflate_st
  000cd	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000d2	8b 4c 24 20	 mov	 ecx, DWORD PTR max_start$[rsp]
  000d6	39 88 94 00 00
	00		 cmp	 DWORD PTR [rax+148], ecx
  000dc	0f 82 c2 00 00
	00		 jb	 $LN6@deflate_st
$LN5@deflate_st:

; 1497 :             /* strstart == 0 is possible when wraparound on 16-bit machine */
; 1498 :             s->lookahead = (uInt)(s->strstart - max_start);

  000e2	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000e7	8b 4c 24 20	 mov	 ecx, DWORD PTR max_start$[rsp]
  000eb	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  000f1	2b c1		 sub	 eax, ecx
  000f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000f8	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1499 :             s->strstart = (uInt)max_start;

  000fe	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00103	8b 4c 24 20	 mov	 ecx, DWORD PTR max_start$[rsp]
  00107	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1500 :             FLUSH_BLOCK(s, 0);

  0010d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00112	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00119	7c 1b		 jl	 SHORT $LN15@deflate_st
  0011b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00120	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00126	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0012b	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  0012f	48 89 44 24 28	 mov	 QWORD PTR tv135[rsp], rax
  00134	eb 09		 jmp	 SHORT $LN16@deflate_st
$LN15@deflate_st:
  00136	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv135[rsp], 0
$LN16@deflate_st:
  0013f	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00144	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00149	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  0014f	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00155	2b c1		 sub	 eax, ecx
  00157	45 33 c9	 xor	 r9d, r9d
  0015a	44 8b c0	 mov	 r8d, eax
  0015d	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv135[rsp]
  00162	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00167	e8 00 00 00 00	 call	 _tr_flush_block
  0016c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00171	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00176	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  0017c	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00182	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00187	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0018a	e8 00 00 00 00	 call	 flush_pending
  0018f	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00194	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00197	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0019b	75 07		 jne	 SHORT $LN4@deflate_st
  0019d	33 c0		 xor	 eax, eax
  0019f	e9 b1 01 00 00	 jmp	 $LN13@deflate_st
$LN4@deflate_st:
$LN6@deflate_st:

; 1501 :         }
; 1502 :         /* Flush if we may have to slide, otherwise block_start may become
; 1503 :          * negative and the data will be gone:
; 1504 :          */
; 1505 :         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {

  001a4	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001ae	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  001b4	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  001ba	2b c1		 sub	 eax, ecx
  001bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001c1	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  001c4	81 e9 06 01 00
	00		 sub	 ecx, 262		; 00000106H
  001ca	3b c1		 cmp	 eax, ecx
  001cc	0f 82 97 00 00
	00		 jb	 $LN3@deflate_st

; 1506 :             FLUSH_BLOCK(s, 0);

  001d2	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001d7	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  001de	7c 1b		 jl	 SHORT $LN17@deflate_st
  001e0	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001e5	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  001eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001f0	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  001f4	48 89 44 24 30	 mov	 QWORD PTR tv160[rsp], rax
  001f9	eb 09		 jmp	 SHORT $LN18@deflate_st
$LN17@deflate_st:
  001fb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv160[rsp], 0
$LN18@deflate_st:
  00204	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00209	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0020e	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00214	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0021a	2b c1		 sub	 eax, ecx
  0021c	45 33 c9	 xor	 r9d, r9d
  0021f	44 8b c0	 mov	 r8d, eax
  00222	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv160[rsp]
  00227	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0022c	e8 00 00 00 00	 call	 _tr_flush_block
  00231	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00236	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0023b	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00241	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00247	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0024c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0024f	e8 00 00 00 00	 call	 flush_pending
  00254	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00259	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0025c	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00260	75 07		 jne	 SHORT $LN2@deflate_st
  00262	33 c0		 xor	 eax, eax
  00264	e9 ec 00 00 00	 jmp	 $LN13@deflate_st
$LN2@deflate_st:
$LN3@deflate_st:

; 1507 :         }
; 1508 :     }

  00269	e9 c7 fd ff ff	 jmp	 $LN11@deflate_st
$LN10@deflate_st:

; 1509 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  0026e	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  00273	75 0a		 jne	 SHORT $LN19@deflate_st
  00275	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv169[rsp], 1
  0027d	eb 08		 jmp	 SHORT $LN20@deflate_st
$LN19@deflate_st:
  0027f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
$LN20@deflate_st:
  00287	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0028c	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00293	7c 1b		 jl	 SHORT $LN21@deflate_st
  00295	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0029a	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  002a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002a5	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  002a9	48 89 44 24 40	 mov	 QWORD PTR tv181[rsp], rax
  002ae	eb 09		 jmp	 SHORT $LN22@deflate_st
$LN21@deflate_st:
  002b0	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv181[rsp], 0
$LN22@deflate_st:
  002b9	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002c3	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  002c9	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  002cf	2b c1		 sub	 eax, ecx
  002d1	44 8b 4c 24 38	 mov	 r9d, DWORD PTR tv169[rsp]
  002d6	44 8b c0	 mov	 r8d, eax
  002d9	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv181[rsp]
  002de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002e3	e8 00 00 00 00	 call	 _tr_flush_block
  002e8	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002f2	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  002f8	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  002fe	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00303	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00306	e8 00 00 00 00	 call	 flush_pending
  0030b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00310	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00313	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00317	75 1f		 jne	 SHORT $LN1@deflate_st
  00319	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  0031e	75 0a		 jne	 SHORT $LN23@deflate_st
  00320	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv190[rsp], 2
  00328	eb 08		 jmp	 SHORT $LN24@deflate_st
$LN23@deflate_st:
  0032a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv190[rsp], 0
$LN24@deflate_st:
  00332	8b 44 24 48	 mov	 eax, DWORD PTR tv190[rsp]
  00336	eb 1d		 jmp	 SHORT $LN13@deflate_st
$LN1@deflate_st:

; 1510 :     return flush == Z_FINISH ? finish_done : block_done;

  00338	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  0033d	75 0a		 jne	 SHORT $LN25@deflate_st
  0033f	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv192[rsp], 3
  00347	eb 08		 jmp	 SHORT $LN26@deflate_st
$LN25@deflate_st:
  00349	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
$LN26@deflate_st:
  00351	8b 44 24 4c	 mov	 eax, DWORD PTR tv192[rsp]
$LN13@deflate_st:

; 1511 : }

  00355	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00359	c3		 ret	 0
deflate_stored ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_window DD imagerel fill_window
	DD	imagerel fill_window+1143
	DD	imagerel $unwind$fill_window
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_window DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fill_window
_TEXT	SEGMENT
p$ = 32
n$ = 40
more$ = 44
wsize$ = 48
m$ = 52
init$5368 = 56
curr$5366 = 60
tv141 = 64
tv153 = 68
tv332 = 72
s$ = 96
fill_window PROC					; COMDAT

; 1307 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1308 :     register unsigned n, m;
; 1309 :     register Posf *p;
; 1310 :     unsigned more;    /* Amount of free space at the end of the window. */
; 1311 :     uInt wsize = s->w_size;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0000e	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00011	89 44 24 30	 mov	 DWORD PTR wsize$[rsp], eax
$LN23@fill_windo:

; 1312 : 
; 1313 :     do {
; 1314 :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00015	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0001a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0001f	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  00025	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00028	2b c1		 sub	 eax, ecx
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	2b 81 94 00 00
	00		 sub	 eax, DWORD PTR [rcx+148]
  00035	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax

; 1315 : 
; 1316 :         /* Deal with !@#$% 64K limit: */
; 1317 :         if (sizeof(int) <= 2) {

  00039	33 c0		 xor	 eax, eax
  0003b	85 c0		 test	 eax, eax
  0003d	74 3e		 je	 SHORT $LN20@fill_windo

; 1318 :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {

  0003f	83 7c 24 2c 00	 cmp	 DWORD PTR more$[rsp], 0
  00044	75 26		 jne	 SHORT $LN19@fill_windo
  00046	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0004b	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  00052	75 18		 jne	 SHORT $LN19@fill_windo
  00054	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00059	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00060	75 0a		 jne	 SHORT $LN19@fill_windo

; 1319 :                 more = wsize;

  00062	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00066	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax
  0006a	eb 11		 jmp	 SHORT $LN18@fill_windo
$LN19@fill_windo:

; 1320 : 
; 1321 :             } else if (more == (unsigned)(-1)) {

  0006c	83 7c 24 2c ff	 cmp	 DWORD PTR more$[rsp], -1 ; ffffffffH
  00071	75 0a		 jne	 SHORT $LN17@fill_windo

; 1322 :                 /* Very unlikely, but possible on 16 bit machine if
; 1323 :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 1324 :                  */
; 1325 :                 more--;

  00073	8b 44 24 2c	 mov	 eax, DWORD PTR more$[rsp]
  00077	ff c8		 dec	 eax
  00079	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax
$LN17@fill_windo:
$LN18@fill_windo:
$LN20@fill_windo:

; 1326 :             }
; 1327 :         }
; 1328 : 
; 1329 :         /* If the window is almost full and there is insufficient lookahead,
; 1330 :          * move the upper half to the lower one to make room in the upper half.
; 1331 :          */
; 1332 :         if (s->strstart >= wsize+MAX_DIST(s)) {

  0007d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00082	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00085	8b 4c 24 30	 mov	 ecx, DWORD PTR wsize$[rsp]
  00089	8d 84 01 fa fe
	ff ff		 lea	 eax, DWORD PTR [rcx+rax-262]
  00090	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00095	39 81 94 00 00
	00		 cmp	 DWORD PTR [rcx+148], eax
  0009b	0f 82 81 01 00
	00		 jb	 $LN16@fill_windo

; 1333 : 
; 1334 :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize);

  000a1	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  000a5	8b 4c 24 30	 mov	 ecx, DWORD PTR wsize$[rsp]
  000a9	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  000ae	48 03 4a 50	 add	 rcx, QWORD PTR [rdx+80]
  000b2	44 8b c0	 mov	 r8d, eax
  000b5	48 8b d1	 mov	 rdx, rcx
  000b8	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000bd	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  000c1	e8 00 00 00 00	 call	 memcpy

; 1335 :             s->match_start -= wsize;

  000c6	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000cb	8b 4c 24 30	 mov	 ecx, DWORD PTR wsize$[rsp]
  000cf	8b 80 98 00 00
	00		 mov	 eax, DWORD PTR [rax+152]
  000d5	2b c1		 sub	 eax, ecx
  000d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000dc	89 81 98 00 00
	00		 mov	 DWORD PTR [rcx+152], eax

; 1336 :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */

  000e2	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000e7	8b 4c 24 30	 mov	 ecx, DWORD PTR wsize$[rsp]
  000eb	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  000f1	2b c1		 sub	 eax, ecx
  000f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000f8	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1337 :             s->block_start -= (long) wsize;

  000fe	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00103	8b 4c 24 30	 mov	 ecx, DWORD PTR wsize$[rsp]
  00107	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0010d	2b c1		 sub	 eax, ecx
  0010f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00114	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 1338 : 
; 1339 :             /* Slide the hash table (could be avoided with 32 bit values
; 1340 :                at the expense of memory usage). We slide even when level == 0
; 1341 :                to keep the hash table consistent if we switch back to level > 0
; 1342 :                later. (Using level 0 permanently is not an optimal usage of
; 1343 :                zlib, so we don't care about this pathological case.)
; 1344 :              */
; 1345 :             n = s->hash_size;

  0011a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0011f	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00122	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 1346 :             p = &s->head[n];

  00126	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  0012a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0012f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00133	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00137	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN15@fill_windo:

; 1347 :             do {
; 1348 :                 m = *--p;

  0013c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00141	48 83 e8 02	 sub	 rax, 2
  00145	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0014a	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0014f	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00152	89 44 24 34	 mov	 DWORD PTR m$[rsp], eax

; 1349 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  00156	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  0015a	39 44 24 34	 cmp	 DWORD PTR m$[rsp], eax
  0015e	72 12		 jb	 SHORT $LN26@fill_windo
  00160	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00164	8b 4c 24 34	 mov	 ecx, DWORD PTR m$[rsp]
  00168	2b c8		 sub	 ecx, eax
  0016a	8b c1		 mov	 eax, ecx
  0016c	89 44 24 40	 mov	 DWORD PTR tv141[rsp], eax
  00170	eb 08		 jmp	 SHORT $LN27@fill_windo
$LN26@fill_windo:
  00172	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
$LN27@fill_windo:
  0017a	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0017f	0f b7 4c 24 40	 movzx	 ecx, WORD PTR tv141[rsp]
  00184	66 89 08	 mov	 WORD PTR [rax], cx

; 1350 :             } while (--n);

  00187	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  0018b	ff c8		 dec	 eax
  0018d	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
  00191	83 7c 24 28 00	 cmp	 DWORD PTR n$[rsp], 0
  00196	75 a4		 jne	 SHORT $LN15@fill_windo

; 1351 : 
; 1352 :             n = wsize;

  00198	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  0019c	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 1353 : #ifndef FASTEST
; 1354 :             p = &s->prev[n];

  001a0	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  001a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001a9	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  001ad	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  001b1	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN12@fill_windo:

; 1355 :             do {
; 1356 :                 m = *--p;

  001b6	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001bb	48 83 e8 02	 sub	 rax, 2
  001bf	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  001c4	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001c9	0f b7 00	 movzx	 eax, WORD PTR [rax]
  001cc	89 44 24 34	 mov	 DWORD PTR m$[rsp], eax

; 1357 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  001d0	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  001d4	39 44 24 34	 cmp	 DWORD PTR m$[rsp], eax
  001d8	72 12		 jb	 SHORT $LN28@fill_windo
  001da	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  001de	8b 4c 24 34	 mov	 ecx, DWORD PTR m$[rsp]
  001e2	2b c8		 sub	 ecx, eax
  001e4	8b c1		 mov	 eax, ecx
  001e6	89 44 24 44	 mov	 DWORD PTR tv153[rsp], eax
  001ea	eb 08		 jmp	 SHORT $LN29@fill_windo
$LN28@fill_windo:
  001ec	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN29@fill_windo:
  001f4	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001f9	0f b7 4c 24 44	 movzx	 ecx, WORD PTR tv153[rsp]
  001fe	66 89 08	 mov	 WORD PTR [rax], cx

; 1358 :                 /* If n is not on any hash chain, prev[n] is garbage but
; 1359 :                  * its value will never be used.
; 1360 :                  */
; 1361 :             } while (--n);

  00201	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  00205	ff c8		 dec	 eax
  00207	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
  0020b	83 7c 24 28 00	 cmp	 DWORD PTR n$[rsp], 0
  00210	75 a4		 jne	 SHORT $LN12@fill_windo

; 1362 : #endif
; 1363 :             more += wsize;

  00212	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00216	8b 4c 24 2c	 mov	 ecx, DWORD PTR more$[rsp]
  0021a	03 c8		 add	 ecx, eax
  0021c	8b c1		 mov	 eax, ecx
  0021e	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax
$LN16@fill_windo:

; 1364 :         }
; 1365 :         if (s->strm->avail_in == 0) return;

  00222	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00227	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0022a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0022e	75 05		 jne	 SHORT $LN9@fill_windo
  00230	e9 3d 02 00 00	 jmp	 $LN24@fill_windo
$LN9@fill_windo:

; 1366 : 
; 1367 :         /* If there was no sliding:
; 1368 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1369 :          *    more == window_size - lookahead - strstart
; 1370 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1371 :          * => more >= window_size - 2*WSIZE + 2
; 1372 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1373 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1374 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1375 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1376 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1377 :          */
; 1378 :         Assert(more >= 2, "more < 2");
; 1379 : 
; 1380 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  00235	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0023a	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00240	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00245	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00249	48 03 c8	 add	 rcx, rax
  0024c	48 8b c1	 mov	 rax, rcx
  0024f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00254	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  0025a	48 03 c1	 add	 rax, rcx
  0025d	44 8b 44 24 2c	 mov	 r8d, DWORD PTR more$[rsp]
  00262	48 8b d0	 mov	 rdx, rax
  00265	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0026a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0026d	e8 00 00 00 00	 call	 read_buf
  00272	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 1381 :         s->lookahead += n;

  00276	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0027b	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00281	03 44 24 28	 add	 eax, DWORD PTR n$[rsp]
  00285	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0028a	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1382 : 
; 1383 :         /* Initialize the hash value now that we have some input: */
; 1384 :         if (s->lookahead >= MIN_MATCH) {

  00290	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00295	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  0029c	72 70		 jb	 SHORT $LN8@fill_windo

; 1385 :             s->ins_h = s->window[s->strstart];

  0029e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002a3	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  002a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002ae	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  002b2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002bb	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 1386 :             UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  002be	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002c3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002ce	48 89 4c 24 48	 mov	 QWORD PTR tv332[rsp], rcx
  002d3	0f b6 c8	 movzx	 ecx, al
  002d6	48 8b 44 24 48	 mov	 rax, QWORD PTR tv332[rsp]
  002db	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002de	d3 e0		 shl	 eax, cl
  002e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002e5	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  002eb	ff c1		 inc	 ecx
  002ed	8b c9		 mov	 ecx, ecx
  002ef	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  002f4	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  002f8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002fc	33 c1		 xor	 eax, ecx
  002fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00303	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  00306	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0030b	89 41 70	 mov	 DWORD PTR [rcx+112], eax
$LN8@fill_windo:

; 1387 : #if MIN_MATCH != 3
; 1388 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1389 : #endif
; 1390 :         }
; 1391 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1392 :          * but this is not important since only literal bytes will be emitted.
; 1393 :          */
; 1394 : 
; 1395 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  0030e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00313	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  0031d	73 12		 jae	 SHORT $LN7@fill_windo
  0031f	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00324	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00327	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0032b	0f 85 e4 fc ff
	ff		 jne	 $LN23@fill_windo
$LN7@fill_windo:

; 1396 : 
; 1397 :     /* If the WIN_INIT bytes after the end of the current data have never been
; 1398 :      * written, then zero those bytes in order to avoid memory check reports of
; 1399 :      * the use of uninitialized (or uninitialised as Julian writes) bytes by
; 1400 :      * the longest match routines.  Update the high water mark for the next
; 1401 :      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
; 1402 :      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
; 1403 :      */
; 1404 :     if (s->high_water < s->window_size) {

  00331	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00336	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0033b	8b 49 58	 mov	 ecx, DWORD PTR [rcx+88]
  0033e	39 88 18 17 00
	00		 cmp	 DWORD PTR [rax+5912], ecx
  00344	0f 83 28 01 00
	00		 jae	 $LN6@fill_windo

; 1405 :         ulg curr = s->strstart + (ulg)(s->lookahead);

  0034a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0034f	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00355	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0035a	03 81 9c 00 00
	00		 add	 eax, DWORD PTR [rcx+156]
  00360	89 44 24 3c	 mov	 DWORD PTR curr$5366[rsp], eax

; 1406 :         ulg init;
; 1407 : 
; 1408 :         if (s->high_water < curr) {

  00364	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00369	8b 4c 24 3c	 mov	 ecx, DWORD PTR curr$5366[rsp]
  0036d	39 88 18 17 00
	00		 cmp	 DWORD PTR [rax+5912], ecx
  00373	73 5b		 jae	 SHORT $LN5@fill_windo

; 1409 :             /* Previous high water mark below current data -- zero WIN_INIT
; 1410 :              * bytes or up to end of window, whichever is less.
; 1411 :              */
; 1412 :             init = s->window_size - curr;

  00375	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0037a	8b 4c 24 3c	 mov	 ecx, DWORD PTR curr$5366[rsp]
  0037e	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00381	2b c1		 sub	 eax, ecx
  00383	89 44 24 38	 mov	 DWORD PTR init$5368[rsp], eax

; 1413 :             if (init > WIN_INIT)

  00387	81 7c 24 38 02
	01 00 00	 cmp	 DWORD PTR init$5368[rsp], 258 ; 00000102H
  0038f	76 08		 jbe	 SHORT $LN4@fill_windo

; 1414 :                 init = WIN_INIT;

  00391	c7 44 24 38 02
	01 00 00	 mov	 DWORD PTR init$5368[rsp], 258 ; 00000102H
$LN4@fill_windo:

; 1415 :             zmemzero(s->window + curr, (unsigned)init);

  00399	8b 44 24 38	 mov	 eax, DWORD PTR init$5368[rsp]
  0039d	8b 4c 24 3c	 mov	 ecx, DWORD PTR curr$5366[rsp]
  003a1	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  003a6	48 03 4a 50	 add	 rcx, QWORD PTR [rdx+80]
  003aa	44 8b c0	 mov	 r8d, eax
  003ad	33 d2		 xor	 edx, edx
  003af	e8 00 00 00 00	 call	 memset

; 1416 :             s->high_water = curr + init;

  003b4	8b 44 24 38	 mov	 eax, DWORD PTR init$5368[rsp]
  003b8	8b 4c 24 3c	 mov	 ecx, DWORD PTR curr$5366[rsp]
  003bc	03 c8		 add	 ecx, eax
  003be	8b c1		 mov	 eax, ecx
  003c0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003c5	89 81 18 17 00
	00		 mov	 DWORD PTR [rcx+5912], eax
  003cb	e9 a2 00 00 00	 jmp	 $LN3@fill_windo
$LN5@fill_windo:

; 1417 :         }
; 1418 :         else if (s->high_water < (ulg)curr + WIN_INIT) {

  003d0	8b 44 24 3c	 mov	 eax, DWORD PTR curr$5366[rsp]
  003d4	05 02 01 00 00	 add	 eax, 258		; 00000102H
  003d9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003de	39 81 18 17 00
	00		 cmp	 DWORD PTR [rcx+5912], eax
  003e4	0f 83 88 00 00
	00		 jae	 $LN2@fill_windo

; 1419 :             /* High water mark at or above current data, but below current data
; 1420 :              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
; 1421 :              * to end of window, whichever is less.
; 1422 :              */
; 1423 :             init = (ulg)curr + WIN_INIT - s->high_water;

  003ea	8b 44 24 3c	 mov	 eax, DWORD PTR curr$5366[rsp]
  003ee	05 02 01 00 00	 add	 eax, 258		; 00000102H
  003f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003f8	2b 81 18 17 00
	00		 sub	 eax, DWORD PTR [rcx+5912]
  003fe	89 44 24 38	 mov	 DWORD PTR init$5368[rsp], eax

; 1424 :             if (init > s->window_size - s->high_water)

  00402	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00407	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0040c	8b 89 18 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5912]
  00412	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00415	2b c1		 sub	 eax, ecx
  00417	39 44 24 38	 cmp	 DWORD PTR init$5368[rsp], eax
  0041b	76 19		 jbe	 SHORT $LN1@fill_windo

; 1425 :                 init = s->window_size - s->high_water;

  0041d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00422	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00427	8b 89 18 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5912]
  0042d	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00430	2b c1		 sub	 eax, ecx
  00432	89 44 24 38	 mov	 DWORD PTR init$5368[rsp], eax
$LN1@fill_windo:

; 1426 :             zmemzero(s->window + s->high_water, (unsigned)init);

  00436	8b 44 24 38	 mov	 eax, DWORD PTR init$5368[rsp]
  0043a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0043f	8b 89 18 17 00
	00		 mov	 ecx, DWORD PTR [rcx+5912]
  00445	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  0044a	48 03 4a 50	 add	 rcx, QWORD PTR [rdx+80]
  0044e	44 8b c0	 mov	 r8d, eax
  00451	33 d2		 xor	 edx, edx
  00453	e8 00 00 00 00	 call	 memset

; 1427 :             s->high_water += init;

  00458	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0045d	8b 80 18 17 00
	00		 mov	 eax, DWORD PTR [rax+5912]
  00463	03 44 24 38	 add	 eax, DWORD PTR init$5368[rsp]
  00467	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0046c	89 81 18 17 00
	00		 mov	 DWORD PTR [rcx+5912], eax
$LN2@fill_windo:
$LN3@fill_windo:
$LN6@fill_windo:
$LN24@fill_windo:

; 1428 :         }
; 1429 :     }
; 1430 : }

  00472	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00476	c3		 ret	 0
fill_window ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_buf DD imagerel read_buf
	DD	imagerel read_buf+259
	DD	imagerel $unwind$read_buf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_buf DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT read_buf
_TEXT	SEGMENT
len$ = 32
strm$ = 64
buf$ = 72
size$ = 80
read_buf PROC						; COMDAT

; 996  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 997  :     unsigned len = strm->avail_in;

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0001b	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 998  : 
; 999  :     if (len > size) len = size;

  0001f	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00023	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  00027	76 08		 jbe	 SHORT $LN5@read_buf
  00029	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0002d	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN5@read_buf:

; 1000 :     if (len == 0) return 0;

  00031	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  00036	75 07		 jne	 SHORT $LN4@read_buf
  00038	33 c0		 xor	 eax, eax
  0003a	e9 bf 00 00 00	 jmp	 $LN6@read_buf
$LN4@read_buf:

; 1001 : 
; 1002 :     strm->avail_in  -= len;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00044	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00048	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004b	2b c1		 sub	 eax, ecx
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00052	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1003 : 
; 1004 :     if (strm->state->wrap == 1) {

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0005a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005e	83 78 2c 01	 cmp	 DWORD PTR [rax+44], 1
  00062	75 24		 jne	 SHORT $LN3@read_buf

; 1005 :         strm->adler = adler32(strm->adler, strm->next_in, len);

  00064	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0006e	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00076	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00079	e8 00 00 00 00	 call	 adler32
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00083	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00086	eb 31		 jmp	 SHORT $LN2@read_buf
$LN3@read_buf:

; 1006 :     }
; 1007 : #ifdef GZIP
; 1008 :     else if (strm->state->wrap == 2) {

  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0008d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00091	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  00095	75 22		 jne	 SHORT $LN1@read_buf

; 1009 :         strm->adler = crc32(strm->adler, strm->next_in, len);

  00097	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a1	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a9	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  000ac	e8 00 00 00 00	 call	 crc32
  000b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000b6	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN1@read_buf:
$LN2@read_buf:

; 1010 :     }
; 1011 : #endif
; 1012 :     zmemcpy(buf, strm->next_in, len);

  000b9	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000bd	44 8b c0	 mov	 r8d, eax
  000c0	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c5	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000c8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  000cd	e8 00 00 00 00	 call	 memcpy

; 1013 :     strm->next_in  += len;

  000d2	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000db	48 03 01	 add	 rax, QWORD PTR [rcx]
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000e3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1014 :     strm->total_in += len;

  000e6	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000eb	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000ee	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  000f2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000f7	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 1015 : 
; 1016 :     return (int)len;

  000fa	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
$LN6@read_buf:

; 1017 : }

  000fe	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00102	c3		 ret	 0
read_buf ENDP
_TEXT	ENDS
EXTRN	_dist_code:BYTE
EXTRN	_length_code:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_fast DD imagerel deflate_fast
	DD	imagerel deflate_fast+2430
	DD	imagerel $unwind$deflate_fast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_fast DD 021001H
	DD	0130110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_fast
_TEXT	SEGMENT
bflush$ = 32
hash_head$ = 36
len$5434 = 40
dist$5435 = 44
cc$5443 = 48
tv464 = 56
tv215 = 64
tv232 = 68
tv544 = 72
tv291 = 80
tv587 = 88
tv354 = 96
tv375 = 104
tv384 = 112
tv396 = 120
tv405 = 128
tv407 = 132
s$ = 160
flush$ = 168
deflate_fast PROC					; COMDAT

; 1523 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
$LN17@deflate_fa:

; 1524 :     IPos hash_head;       /* head of the hash chain */
; 1525 :     int bflush;           /* set if current block must be flushed */
; 1526 : 
; 1527 :     for (;;) {
; 1528 :         /* Make sure that we always have enough lookahead, except
; 1529 :          * at the end of the input file. We need MAX_MATCH bytes
; 1530 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1531 :          * string following the next match.
; 1532 :          */
; 1533 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00010	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00018	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00022	73 48		 jae	 SHORT $LN15@deflate_fa

; 1534 :             fill_window(s);

  00024	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 fill_window

; 1535 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00031	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00039	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00043	73 11		 jae	 SHORT $LN14@deflate_fa
  00045	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  0004d	75 07		 jne	 SHORT $LN14@deflate_fa

; 1536 :                 return need_more;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 20 09 00 00	 jmp	 $LN18@deflate_fa
$LN14@deflate_fa:

; 1537 :             }
; 1538 :             if (s->lookahead == 0) break; /* flush the current block */

  00056	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005e	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00065	75 05		 jne	 SHORT $LN13@deflate_fa
  00067	e9 ea 07 00 00	 jmp	 $LN16@deflate_fa
$LN13@deflate_fa:
$LN15@deflate_fa:

; 1539 :         }
; 1540 : 
; 1541 :         /* Insert the string window[strstart .. strstart+2] in the
; 1542 :          * dictionary, and set hash_head to the head of the hash chain:
; 1543 :          */
; 1544 :         hash_head = NIL;

  0006c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0

; 1545 :         if (s->lookahead >= MIN_MATCH) {

  00074	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0007c	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  00083	0f 82 09 01 00
	00		 jb	 $LN12@deflate_fa

; 1546 :             INSERT_STRING(s, s->strstart, hash_head);

  00089	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00091	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00097	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0009f	48 89 4c 24 38	 mov	 QWORD PTR tv464[rsp], rcx
  000a4	0f b6 c8	 movzx	 ecx, al
  000a7	48 8b 44 24 38	 mov	 rax, QWORD PTR tv464[rsp]
  000ac	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000af	d3 e0		 shl	 eax, cl
  000b1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000b9	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  000bf	83 c1 02	 add	 ecx, 2
  000c2	8b c9		 mov	 ecx, ecx
  000c4	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  000cc	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  000d0	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000d4	33 c1		 xor	 eax, ecx
  000d6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000de	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  000e1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000e9	89 41 70	 mov	 DWORD PTR [rcx+112], eax
  000ec	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000f4	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000f7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000ff	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00103	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0010b	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  00113	45 8b 40 4c	 mov	 r8d, DWORD PTR [r8+76]
  00117	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [rdx+148]
  0011d	41 23 d0	 and	 edx, r8d
  00120	8b d2		 mov	 edx, edx
  00122	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  0012a	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  0012e	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00132	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax
  00137	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0013f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00147	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0014a	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00150	23 c1		 and	 eax, ecx
  00152	8b c0		 mov	 eax, eax
  00154	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0015c	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00160	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00164	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  00168	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00170	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00173	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0017b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0017f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00187	0f b7 92 94 00
	00 00		 movzx	 edx, WORD PTR [rdx+148]
  0018e	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
$LN12@deflate_fa:

; 1547 :         }
; 1548 : 
; 1549 :         /* Find the longest match, discarding those <= prev_length.
; 1550 :          * At this point we have always match_length < MIN_MATCH
; 1551 :          */
; 1552 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  00192	83 7c 24 24 00	 cmp	 DWORD PTR hash_head$[rsp], 0
  00197	74 48		 je	 SHORT $LN11@deflate_fa
  00199	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001a1	8b 4c 24 24	 mov	 ecx, DWORD PTR hash_head$[rsp]
  001a5	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  001ab	2b c1		 sub	 eax, ecx
  001ad	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001b5	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  001b8	81 e9 06 01 00
	00		 sub	 ecx, 262		; 00000106H
  001be	3b c1		 cmp	 eax, ecx
  001c0	77 1f		 ja	 SHORT $LN11@deflate_fa

; 1553 :             /* To simplify the code, we prevent matches with the string
; 1554 :              * of window index 0 (in particular we have to avoid a match
; 1555 :              * of the string with itself at the start of the input file).
; 1556 :              */
; 1557 :             s->match_length = longest_match (s, hash_head);

  001c2	8b 54 24 24	 mov	 edx, DWORD PTR hash_head$[rsp]
  001c6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001ce	e8 00 00 00 00	 call	 longest_match
  001d3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001db	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN11@deflate_fa:

; 1558 :             /* longest_match() sets match_start */
; 1559 :         }
; 1560 :         if (s->match_length >= MIN_MATCH) {

  001e1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001e9	83 b8 88 00 00
	00 03		 cmp	 DWORD PTR [rax+136], 3
  001f0	0f 82 70 04 00
	00		 jb	 $LN10@deflate_fa

; 1561 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1562 : 
; 1563 :             _tr_tally_dist(s, s->strstart - s->match_start,
; 1564 :                            s->match_length - MIN_MATCH, bflush);

  001f6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001fe	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00204	83 e8 03	 sub	 eax, 3
  00207	88 44 24 28	 mov	 BYTE PTR len$5434[rsp], al
  0020b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00213	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0021b	8b 89 98 00 00
	00		 mov	 ecx, DWORD PTR [rcx+152]
  00221	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00227	2b c1		 sub	 eax, ecx
  00229	66 89 44 24 2c	 mov	 WORD PTR dist$5435[rsp], ax
  0022e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00236	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  0023c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00244	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  0024b	0f b7 54 24 2c	 movzx	 edx, WORD PTR dist$5435[rsp]
  00250	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  00254	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0025c	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00262	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0026a	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00271	0f b6 54 24 28	 movzx	 edx, BYTE PTR len$5434[rsp]
  00276	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  00279	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00281	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00287	ff c0		 inc	 eax
  00289	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00291	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  00297	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$5435[rsp]
  0029c	66 ff c8	 dec	 ax
  0029f	66 89 44 24 2c	 mov	 WORD PTR dist$5435[rsp], ax
  002a4	0f b6 44 24 28	 movzx	 eax, BYTE PTR len$5434[rsp]
  002a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_length_code
  002b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002b4	05 01 01 00 00	 add	 eax, 257		; 00000101H
  002b9	48 98		 cdqe
  002bb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002c3	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  002cb	66 ff c0	 inc	 ax
  002ce	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR len$5434[rsp]
  002d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_length_code
  002da	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002de	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  002e4	48 63 c9	 movsxd	 rcx, ecx
  002e7	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  002ef	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  002f7	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$5435[rsp]
  002fc	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00301	7d 16		 jge	 SHORT $LN20@deflate_fa
  00303	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$5435[rsp]
  00308	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  0030f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00313	89 44 24 40	 mov	 DWORD PTR tv215[rsp], eax
  00317	eb 1e		 jmp	 SHORT $LN21@deflate_fa
$LN20@deflate_fa:
  00319	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$5435[rsp]
  0031e	c1 f8 07	 sar	 eax, 7
  00321	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00326	48 98		 cdqe
  00328	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  0032f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00333	89 44 24 40	 mov	 DWORD PTR tv215[rsp], eax
$LN21@deflate_fa:
  00337	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv215[rsp]
  0033c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00344	0f b7 84 81 b0
	09 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2480]
  0034c	66 ff c0	 inc	 ax
  0034f	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR tv215[rsp]
  00354	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0035c	66 89 84 8a b0
	09 00 00	 mov	 WORD PTR [rdx+rcx*4+2480], ax
  00364	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0036c	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00372	ff c8		 dec	 eax
  00374	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0037c	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  00382	75 0a		 jne	 SHORT $LN22@deflate_fa
  00384	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv232[rsp], 1
  0038c	eb 08		 jmp	 SHORT $LN23@deflate_fa
$LN22@deflate_fa:
  0038e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv232[rsp], 0
$LN23@deflate_fa:
  00396	8b 44 24 44	 mov	 eax, DWORD PTR tv232[rsp]
  0039a	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1565 : 
; 1566 :             s->lookahead -= s->match_length;

  0039e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003ae	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  003b4	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  003ba	2b c1		 sub	 eax, ecx
  003bc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003c4	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1567 : 
; 1568 :             /* Insert new strings in the hash table only if the match length
; 1569 :              * is not too large. This saves time but degrades compression.
; 1570 :              */
; 1571 : #ifndef FASTEST
; 1572 :             if (s->match_length <= s->max_insert_length &&
; 1573 :                 s->lookahead >= MIN_MATCH) {

  003ca	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003d2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003da	8b 89 a8 00 00
	00		 mov	 ecx, DWORD PTR [rcx+168]
  003e0	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  003e6	0f 87 ae 01 00
	00		 ja	 $LN9@deflate_fa
  003ec	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003f4	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  003fb	0f 82 99 01 00
	00		 jb	 $LN9@deflate_fa

; 1574 :                 s->match_length--; /* string at strstart already in table */

  00401	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00409	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0040f	ff c8		 dec	 eax
  00411	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00419	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN8@deflate_fa:

; 1575 :                 do {
; 1576 :                     s->strstart++;

  0041f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00427	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0042d	ff c0		 inc	 eax
  0042f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00437	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1577 :                     INSERT_STRING(s, s->strstart, hash_head);

  0043d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00445	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0044b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00453	48 89 4c 24 48	 mov	 QWORD PTR tv544[rsp], rcx
  00458	0f b6 c8	 movzx	 ecx, al
  0045b	48 8b 44 24 48	 mov	 rax, QWORD PTR tv544[rsp]
  00460	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00463	d3 e0		 shl	 eax, cl
  00465	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0046d	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00473	83 c1 02	 add	 ecx, 2
  00476	8b c9		 mov	 ecx, ecx
  00478	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00480	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  00484	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00488	33 c1		 xor	 eax, ecx
  0048a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00492	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  00495	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0049d	89 41 70	 mov	 DWORD PTR [rcx+112], eax
  004a0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004a8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004ab	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004b3	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  004b7	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  004bf	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  004c7	45 8b 40 4c	 mov	 r8d, DWORD PTR [r8+76]
  004cb	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [rdx+148]
  004d1	41 23 d0	 and	 edx, r8d
  004d4	8b d2		 mov	 edx, edx
  004d6	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  004de	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  004e2	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  004e6	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax
  004eb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004f3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004fb	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  004fe	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00504	23 c1		 and	 eax, ecx
  00506	8b c0		 mov	 eax, eax
  00508	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00510	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00514	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00518	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  0051c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00524	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00527	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0052f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00533	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0053b	0f b7 92 94 00
	00 00		 movzx	 edx, WORD PTR [rdx+148]
  00542	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 1578 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1579 :                      * always MIN_MATCH bytes ahead.
; 1580 :                      */
; 1581 :                 } while (--s->match_length != 0);

  00546	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0054e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00554	ff c8		 dec	 eax
  00556	89 44 24 50	 mov	 DWORD PTR tv291[rsp], eax
  0055a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00562	8b 4c 24 50	 mov	 ecx, DWORD PTR tv291[rsp]
  00566	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx
  0056c	83 7c 24 50 00	 cmp	 DWORD PTR tv291[rsp], 0
  00571	0f 85 a8 fe ff
	ff		 jne	 $LN8@deflate_fa

; 1582 :                 s->strstart++;

  00577	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0057f	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00585	ff c0		 inc	 eax
  00587	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0058f	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1583 :             } else

  00595	e9 c7 00 00 00	 jmp	 $LN5@deflate_fa
$LN9@deflate_fa:

; 1584 : #endif
; 1585 :             {
; 1586 :                 s->strstart += s->match_length;

  0059a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005a2	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  005a8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005b0	03 81 88 00 00
	00		 add	 eax, DWORD PTR [rcx+136]
  005b6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005be	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1587 :                 s->match_length = 0;

  005c4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005cc	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 1588 :                 s->ins_h = s->window[s->strstart];

  005d6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005de	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  005e4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005ec	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  005f0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005f4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005fc	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 1589 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  005ff	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00607	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0060d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00615	48 89 4c 24 58	 mov	 QWORD PTR tv587[rsp], rcx
  0061a	0f b6 c8	 movzx	 ecx, al
  0061d	48 8b 44 24 58	 mov	 rax, QWORD PTR tv587[rsp]
  00622	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00625	d3 e0		 shl	 eax, cl
  00627	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0062f	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00635	ff c1		 inc	 ecx
  00637	8b c9		 mov	 ecx, ecx
  00639	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00641	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  00645	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00649	33 c1		 xor	 eax, ecx
  0064b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00653	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  00656	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0065e	89 41 70	 mov	 DWORD PTR [rcx+112], eax
$LN5@deflate_fa:

; 1590 : #if MIN_MATCH != 3
; 1591 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1592 : #endif
; 1593 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1594 :                  * matter since it will be recomputed at next deflate call.
; 1595 :                  */
; 1596 :             }
; 1597 :         } else {

  00661	e9 2b 01 00 00	 jmp	 $LN4@deflate_fa
$LN10@deflate_fa:

; 1598 :             /* No match, output a literal byte */
; 1599 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1600 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  00666	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0066e	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00674	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0067c	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00680	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00684	88 44 24 30	 mov	 BYTE PTR cc$5443[rsp], al
  00688	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00690	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00696	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0069e	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  006a5	33 d2		 xor	 edx, edx
  006a7	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  006ab	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006b3	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  006b9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006c1	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  006c8	0f b6 54 24 30	 movzx	 edx, BYTE PTR cc$5443[rsp]
  006cd	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  006d0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006d8	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  006de	ff c0		 inc	 eax
  006e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006e8	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  006ee	0f b6 44 24 30	 movzx	 eax, BYTE PTR cc$5443[rsp]
  006f3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006fb	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  00703	66 ff c0	 inc	 ax
  00706	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR cc$5443[rsp]
  0070b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00713	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  0071b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00723	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00729	ff c8		 dec	 eax
  0072b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00733	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  00739	75 0a		 jne	 SHORT $LN24@deflate_fa
  0073b	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv354[rsp], 1
  00743	eb 08		 jmp	 SHORT $LN25@deflate_fa
$LN24@deflate_fa:
  00745	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv354[rsp], 0
$LN25@deflate_fa:
  0074d	8b 44 24 60	 mov	 eax, DWORD PTR tv354[rsp]
  00751	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1601 :             s->lookahead--;

  00755	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0075d	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00763	ff c8		 dec	 eax
  00765	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0076d	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1602 :             s->strstart++;

  00773	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0077b	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00781	ff c0		 inc	 eax
  00783	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0078b	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax
$LN4@deflate_fa:

; 1603 :         }
; 1604 :         if (bflush) FLUSH_BLOCK(s, 0);

  00791	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  00796	0f 84 b5 00 00
	00		 je	 $LN3@deflate_fa
  0079c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007a4	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  007ab	7c 21		 jl	 SHORT $LN26@deflate_fa
  007ad	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007b5	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  007bb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007c3	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  007c7	48 89 44 24 68	 mov	 QWORD PTR tv375[rsp], rax
  007cc	eb 09		 jmp	 SHORT $LN27@deflate_fa
$LN26@deflate_fa:
  007ce	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv375[rsp], 0
$LN27@deflate_fa:
  007d7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007df	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007e7	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  007ed	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  007f3	2b c1		 sub	 eax, ecx
  007f5	45 33 c9	 xor	 r9d, r9d
  007f8	44 8b c0	 mov	 r8d, eax
  007fb	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv375[rsp]
  00800	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00808	e8 00 00 00 00	 call	 _tr_flush_block
  0080d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00815	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0081d	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00823	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00829	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00831	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00834	e8 00 00 00 00	 call	 flush_pending
  00839	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00841	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00844	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00848	75 07		 jne	 SHORT $LN2@deflate_fa
  0084a	33 c0		 xor	 eax, eax
  0084c	e9 25 01 00 00	 jmp	 $LN18@deflate_fa
$LN2@deflate_fa:
$LN3@deflate_fa:

; 1605 :     }

  00851	e9 ba f7 ff ff	 jmp	 $LN17@deflate_fa
$LN16@deflate_fa:

; 1606 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00856	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  0085e	75 0a		 jne	 SHORT $LN28@deflate_fa
  00860	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv384[rsp], 1
  00868	eb 08		 jmp	 SHORT $LN29@deflate_fa
$LN28@deflate_fa:
  0086a	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv384[rsp], 0
$LN29@deflate_fa:
  00872	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0087a	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00881	7c 21		 jl	 SHORT $LN30@deflate_fa
  00883	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0088b	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00891	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00899	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  0089d	48 89 44 24 78	 mov	 QWORD PTR tv396[rsp], rax
  008a2	eb 09		 jmp	 SHORT $LN31@deflate_fa
$LN30@deflate_fa:
  008a4	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv396[rsp], 0
$LN31@deflate_fa:
  008ad	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008b5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008bd	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  008c3	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  008c9	2b c1		 sub	 eax, ecx
  008cb	44 8b 4c 24 70	 mov	 r9d, DWORD PTR tv384[rsp]
  008d0	44 8b c0	 mov	 r8d, eax
  008d3	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv396[rsp]
  008d8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008e0	e8 00 00 00 00	 call	 _tr_flush_block
  008e5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008ed	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008f5	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  008fb	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00901	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00909	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0090c	e8 00 00 00 00	 call	 flush_pending
  00911	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00919	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0091c	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00920	75 2b		 jne	 SHORT $LN1@deflate_fa
  00922	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  0092a	75 0d		 jne	 SHORT $LN32@deflate_fa
  0092c	c7 84 24 80 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv405[rsp], 2
  00937	eb 0b		 jmp	 SHORT $LN33@deflate_fa
$LN32@deflate_fa:
  00939	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv405[rsp], 0
$LN33@deflate_fa:
  00944	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv405[rsp]
  0094b	eb 29		 jmp	 SHORT $LN18@deflate_fa
$LN1@deflate_fa:

; 1607 :     return flush == Z_FINISH ? finish_done : block_done;

  0094d	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00955	75 0d		 jne	 SHORT $LN34@deflate_fa
  00957	c7 84 24 84 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv407[rsp], 3
  00962	eb 0b		 jmp	 SHORT $LN35@deflate_fa
$LN34@deflate_fa:
  00964	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv407[rsp], 1
$LN35@deflate_fa:
  0096f	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv407[rsp]
$LN18@deflate_fa:

; 1608 : }

  00976	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0097d	c3		 ret	 0
deflate_fast ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$longest_match DD imagerel longest_match
	DD	imagerel longest_match+1096
	DD	imagerel $unwind$longest_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$longest_match DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT longest_match
_TEXT	SEGMENT
best_len$ = 0
chain_length$ = 4
scan_end1$ = 8
prev$ = 16
scan_end$ = 24
len$ = 28
scan$ = 32
strend$ = 40
match$ = 48
limit$ = 56
nice_match$ = 60
wmask$ = 64
tv79 = 68
s$ = 96
cur_match$ = 104
longest_match PROC					; COMDAT

; 1066 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1067 :     unsigned chain_length = s->max_chain_length;/* max hash chain length */

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00012	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [rax+164]
  00018	89 44 24 04	 mov	 DWORD PTR chain_length$[rsp], eax

; 1068 :     register Bytef *scan = s->window + s->strstart; /* current string */

  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00021	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00030	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax

; 1069 :     register Bytef *match;                       /* matched string */
; 1070 :     register int len;                           /* length of current match */
; 1071 :     int best_len = s->prev_length;              /* best match length so far */

  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0003a	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  00040	89 04 24	 mov	 DWORD PTR best_len$[rsp], eax

; 1072 :     int nice_match = s->nice_match;             /* stop if match long enough */

  00043	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00048	8b 80 b8 00 00
	00		 mov	 eax, DWORD PTR [rax+184]
  0004e	89 44 24 3c	 mov	 DWORD PTR nice_match$[rsp], eax

; 1073 :     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
; 1074 :         s->strstart - (IPos)MAX_DIST(s) : NIL;

  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00057	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0005a	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  0005f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00064	39 81 94 00 00
	00		 cmp	 DWORD PTR [rcx+148], eax
  0006a	76 22		 jbe	 SHORT $LN18@longest_ma
  0006c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00071	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00074	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  00079	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0007e	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00084	2b c8		 sub	 ecx, eax
  00086	8b c1		 mov	 eax, ecx
  00088	89 44 24 44	 mov	 DWORD PTR tv79[rsp], eax
  0008c	eb 08		 jmp	 SHORT $LN19@longest_ma
$LN18@longest_ma:
  0008e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN19@longest_ma:
  00096	8b 44 24 44	 mov	 eax, DWORD PTR tv79[rsp]
  0009a	89 44 24 38	 mov	 DWORD PTR limit$[rsp], eax

; 1075 :     /* Stop when cur_match becomes <= limit. To simplify the code,
; 1076 :      * we prevent matches with the string of window index 0.
; 1077 :      */
; 1078 :     Posf *prev = s->prev;

  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000a3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a7	48 89 44 24 10	 mov	 QWORD PTR prev$[rsp], rax

; 1079 :     uInt wmask = s->w_mask;

  000ac	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000b1	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000b4	89 44 24 40	 mov	 DWORD PTR wmask$[rsp], eax

; 1080 : 
; 1081 : #ifdef UNALIGNED_OK
; 1082 :     /* Compare two bytes at a time. Note: this is not always beneficial.
; 1083 :      * Try with and without -DUNALIGNED_OK to check.
; 1084 :      */
; 1085 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
; 1086 :     register ush scan_start = *(ushf*)scan;
; 1087 :     register ush scan_end   = *(ushf*)(scan+best_len-1);
; 1088 : #else
; 1089 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH;

  000b8	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000bd	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  000c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000c8	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000cc	48 8d 84 01 02
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+258]
  000d4	48 89 44 24 28	 mov	 QWORD PTR strend$[rsp], rax

; 1090 :     register Byte scan_end1  = scan[best_len-1];

  000d9	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  000dc	ff c8		 dec	 eax
  000de	48 98		 cdqe
  000e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  000e5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e9	88 44 24 08	 mov	 BYTE PTR scan_end1$[rsp], al

; 1091 :     register Byte scan_end   = scan[best_len];

  000ed	48 63 04 24	 movsxd	 rax, DWORD PTR best_len$[rsp]
  000f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  000f6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000fa	88 44 24 18	 mov	 BYTE PTR scan_end$[rsp], al

; 1092 : #endif
; 1093 : 
; 1094 :     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
; 1095 :      * It is easy to get rid of this optimization if necessary.
; 1096 :      */
; 1097 :     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
; 1098 : 
; 1099 :     /* Do not waste too much time if we already have a good match: */
; 1100 :     if (s->prev_length >= s->good_match) {

  000fe	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00103	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00108	8b 89 b4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+180]
  0010e	39 88 a0 00 00
	00		 cmp	 DWORD PTR [rax+160], ecx
  00114	72 0b		 jb	 SHORT $LN15@longest_ma

; 1101 :         chain_length >>= 2;

  00116	8b 44 24 04	 mov	 eax, DWORD PTR chain_length$[rsp]
  0011a	c1 e8 02	 shr	 eax, 2
  0011d	89 44 24 04	 mov	 DWORD PTR chain_length$[rsp], eax
$LN15@longest_ma:

; 1102 :     }
; 1103 :     /* Do not look for matches beyond the end of the input. This is necessary
; 1104 :      * to make deflate deterministic.
; 1105 :      */
; 1106 :     if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

  00121	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00126	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  0012c	39 44 24 3c	 cmp	 DWORD PTR nice_match$[rsp], eax
  00130	76 0f		 jbe	 SHORT $LN14@longest_ma
  00132	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00137	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  0013d	89 44 24 3c	 mov	 DWORD PTR nice_match$[rsp], eax
$LN14@longest_ma:
$LN13@longest_ma:

; 1107 : 
; 1108 :     Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
; 1109 : 
; 1110 :     do {
; 1111 :         Assert(cur_match < s->strstart, "no future");
; 1112 :         match = s->window + cur_match;

  00141	8b 44 24 68	 mov	 eax, DWORD PTR cur_match$[rsp]
  00145	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0014a	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  0014e	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax

; 1113 : 
; 1114 :         /* Skip to next match if the match length cannot increase
; 1115 :          * or if the match length is less than 2.  Note that the checks below
; 1116 :          * for insufficient lookahead only occur occasionally for performance
; 1117 :          * reasons.  Therefore uninitialized memory will be accessed, and
; 1118 :          * conditional jumps will be made that depend on those values.
; 1119 :          * However the length of the match is limited to the lookahead, so
; 1120 :          * the output of deflate is not affected by the uninitialized values.
; 1121 :          */
; 1122 : #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
; 1123 :         /* This code assumes sizeof(unsigned short) == 2. Do not use
; 1124 :          * UNALIGNED_OK if your compiler uses a different size.
; 1125 :          */
; 1126 :         if (*(ushf*)(match+best_len-1) != scan_end ||
; 1127 :             *(ushf*)match != scan_start) continue;
; 1128 : 
; 1129 :         /* It is not necessary to compare scan[2] and match[2] since they are
; 1130 :          * always equal when the other bytes match, given that the hash keys
; 1131 :          * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
; 1132 :          * strstart+3, +5, ... up to strstart+257. We check for insufficient
; 1133 :          * lookahead only every 4th comparison; the 128th check will be made
; 1134 :          * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
; 1135 :          * necessary to put more guard bytes at the end of the window, or
; 1136 :          * to check more often for insufficient lookahead.
; 1137 :          */
; 1138 :         Assert(scan[2] == match[2], "scan[2]?");
; 1139 :         scan++, match++;
; 1140 :         do {
; 1141 :         } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1142 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1143 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1144 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1145 :                  scan < strend);
; 1146 :         /* The funny "do {}" generates better code on most compilers */
; 1147 : 
; 1148 :         /* Here, scan <= window+strstart+257 */
; 1149 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1150 :         if (*scan == *match) scan++;
; 1151 : 
; 1152 :         len = (MAX_MATCH - 1) - (int)(strend-scan);
; 1153 :         scan = strend - (MAX_MATCH-1);
; 1154 : 
; 1155 : #else /* UNALIGNED_OK */
; 1156 : 
; 1157 :         if (match[best_len]   != scan_end  ||
; 1158 :             match[best_len-1] != scan_end1 ||
; 1159 :             *match            != *scan     ||
; 1160 :             *++match          != scan[1])      continue;

  00153	48 63 04 24	 movsxd	 rax, DWORD PTR best_len$[rsp]
  00157	48 8b 4c 24 30	 mov	 rcx, QWORD PTR match$[rsp]
  0015c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00160	0f b6 4c 24 18	 movzx	 ecx, BYTE PTR scan_end$[rsp]
  00165	3b c1		 cmp	 eax, ecx
  00167	75 4f		 jne	 SHORT $LN9@longest_ma
  00169	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  0016c	ff c8		 dec	 eax
  0016e	48 98		 cdqe
  00170	48 8b 4c 24 30	 mov	 rcx, QWORD PTR match$[rsp]
  00175	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00179	0f b6 4c 24 08	 movzx	 ecx, BYTE PTR scan_end1$[rsp]
  0017e	3b c1		 cmp	 eax, ecx
  00180	75 36		 jne	 SHORT $LN9@longest_ma
  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00187	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0018a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  0018f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00192	3b c1		 cmp	 eax, ecx
  00194	75 22		 jne	 SHORT $LN9@longest_ma
  00196	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0019b	48 ff c0	 inc	 rax
  0019e	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  001a3	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001a8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  001b0	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  001b4	3b c1		 cmp	 eax, ecx
  001b6	74 05		 je	 SHORT $LN10@longest_ma
$LN9@longest_ma:
  001b8	e9 2c 02 00 00	 jmp	 $LN12@longest_ma
$LN10@longest_ma:

; 1161 : 
; 1162 :         /* The check at best_len-1 can be removed because it will be made
; 1163 :          * again later. (This heuristic is not always a win.)
; 1164 :          * It is not necessary to compare scan[2] and match[2] since they
; 1165 :          * are always equal when the other bytes match, given that
; 1166 :          * the hash keys are equal and that HASH_BITS >= 8.
; 1167 :          */
; 1168 :         scan += 2, match++;

  001bd	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  001c2	48 83 c0 02	 add	 rax, 2
  001c6	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  001cb	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001d0	48 ff c0	 inc	 rax
  001d3	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
$LN8@longest_ma:

; 1169 :         Assert(*scan == *match, "match[2]?");
; 1170 : 
; 1171 :         /* We check for insufficient lookahead only every 8th comparison;
; 1172 :          * the 256th check will be made at strstart+258.
; 1173 :          */
; 1174 :         do {
; 1175 :         } while (*++scan == *++match && *++scan == *++match &&
; 1176 :                  *++scan == *++match && *++scan == *++match &&
; 1177 :                  *++scan == *++match && *++scan == *++match &&
; 1178 :                  *++scan == *++match && *++scan == *++match &&
; 1179 :                  scan < strend);

  001d8	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  001dd	48 ff c0	 inc	 rax
  001e0	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  001e5	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001ea	48 ff c0	 inc	 rax
  001ed	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  001f2	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001f7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  001ff	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00202	3b c8		 cmp	 ecx, eax
  00204	0f 85 62 01 00
	00		 jne	 $LN5@longest_ma
  0020a	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0020f	48 ff c0	 inc	 rax
  00212	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00217	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0021c	48 ff c0	 inc	 rax
  0021f	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  00224	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00229	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0022c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  00231	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00234	3b c8		 cmp	 ecx, eax
  00236	0f 85 30 01 00
	00		 jne	 $LN5@longest_ma
  0023c	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00241	48 ff c0	 inc	 rax
  00244	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00249	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0024e	48 ff c0	 inc	 rax
  00251	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  00256	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0025b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0025e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  00263	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00266	3b c8		 cmp	 ecx, eax
  00268	0f 85 fe 00 00
	00		 jne	 $LN5@longest_ma
  0026e	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00273	48 ff c0	 inc	 rax
  00276	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  0027b	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00280	48 ff c0	 inc	 rax
  00283	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  00288	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0028d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00290	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  00295	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00298	3b c8		 cmp	 ecx, eax
  0029a	0f 85 cc 00 00
	00		 jne	 $LN5@longest_ma
  002a0	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  002a5	48 ff c0	 inc	 rax
  002a8	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  002ad	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  002b2	48 ff c0	 inc	 rax
  002b5	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  002ba	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  002bf	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  002c7	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002ca	3b c8		 cmp	 ecx, eax
  002cc	0f 85 9a 00 00
	00		 jne	 $LN5@longest_ma
  002d2	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  002d7	48 ff c0	 inc	 rax
  002da	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  002df	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  002e4	48 ff c0	 inc	 rax
  002e7	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  002ec	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  002f1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  002f9	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002fc	3b c8		 cmp	 ecx, eax
  002fe	75 6c		 jne	 SHORT $LN5@longest_ma
  00300	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00305	48 ff c0	 inc	 rax
  00308	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  0030d	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00312	48 ff c0	 inc	 rax
  00315	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  0031a	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0031f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00322	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  00327	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0032a	3b c8		 cmp	 ecx, eax
  0032c	75 3e		 jne	 SHORT $LN5@longest_ma
  0032e	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00333	48 ff c0	 inc	 rax
  00336	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  0033b	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00340	48 ff c0	 inc	 rax
  00343	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  00348	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0034d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00350	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  00355	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00358	3b c8		 cmp	 ecx, eax
  0035a	75 10		 jne	 SHORT $LN5@longest_ma
  0035c	48 8b 44 24 28	 mov	 rax, QWORD PTR strend$[rsp]
  00361	48 39 44 24 20	 cmp	 QWORD PTR scan$[rsp], rax
  00366	0f 82 6c fe ff
	ff		 jb	 $LN8@longest_ma
$LN5@longest_ma:

; 1180 : 
; 1181 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1182 : 
; 1183 :         len = MAX_MATCH - (int)(strend - scan);

  0036c	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00371	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strend$[rsp]
  00376	48 2b c8	 sub	 rcx, rax
  00379	48 8b c1	 mov	 rax, rcx
  0037c	b9 02 01 00 00	 mov	 ecx, 258		; 00000102H
  00381	2b c8		 sub	 ecx, eax
  00383	8b c1		 mov	 eax, ecx
  00385	89 44 24 1c	 mov	 DWORD PTR len$[rsp], eax

; 1184 :         scan = strend - MAX_MATCH;

  00389	48 8b 44 24 28	 mov	 rax, QWORD PTR strend$[rsp]
  0038e	48 2d 02 01 00
	00		 sub	 rax, 258		; 00000102H
  00394	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax

; 1185 : 
; 1186 : #endif /* UNALIGNED_OK */
; 1187 : 
; 1188 :         if (len > best_len) {

  00399	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  0039c	39 44 24 1c	 cmp	 DWORD PTR len$[rsp], eax
  003a0	7e 47		 jle	 SHORT $LN4@longest_ma

; 1189 :             s->match_start = cur_match;

  003a2	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  003a7	8b 4c 24 68	 mov	 ecx, DWORD PTR cur_match$[rsp]
  003ab	89 88 98 00 00
	00		 mov	 DWORD PTR [rax+152], ecx

; 1190 :             best_len = len;

  003b1	8b 44 24 1c	 mov	 eax, DWORD PTR len$[rsp]
  003b5	89 04 24	 mov	 DWORD PTR best_len$[rsp], eax

; 1191 :             if (len >= nice_match) break;

  003b8	8b 44 24 3c	 mov	 eax, DWORD PTR nice_match$[rsp]
  003bc	39 44 24 1c	 cmp	 DWORD PTR len$[rsp], eax
  003c0	7c 02		 jl	 SHORT $LN3@longest_ma
  003c2	eb 5f		 jmp	 SHORT $LN11@longest_ma
$LN3@longest_ma:

; 1192 : #ifdef UNALIGNED_OK
; 1193 :             scan_end = *(ushf*)(scan+best_len-1);
; 1194 : #else
; 1195 :             scan_end1  = scan[best_len-1];

  003c4	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  003c7	ff c8		 dec	 eax
  003c9	48 98		 cdqe
  003cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  003d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003d4	88 44 24 08	 mov	 BYTE PTR scan_end1$[rsp], al

; 1196 :             scan_end   = scan[best_len];

  003d8	48 63 04 24	 movsxd	 rax, DWORD PTR best_len$[rsp]
  003dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR scan$[rsp]
  003e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e5	88 44 24 18	 mov	 BYTE PTR scan_end$[rsp], al
$LN4@longest_ma:
$LN12@longest_ma:

; 1197 : #endif
; 1198 :         }
; 1199 :     } while ((cur_match = prev[cur_match & wmask]) > limit
; 1200 :              && --chain_length != 0);

  003e9	8b 44 24 40	 mov	 eax, DWORD PTR wmask$[rsp]
  003ed	8b 4c 24 68	 mov	 ecx, DWORD PTR cur_match$[rsp]
  003f1	23 c8		 and	 ecx, eax
  003f3	8b c1		 mov	 eax, ecx
  003f5	8b c0		 mov	 eax, eax
  003f7	48 8b 4c 24 10	 mov	 rcx, QWORD PTR prev$[rsp]
  003fc	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00400	89 44 24 68	 mov	 DWORD PTR cur_match$[rsp], eax
  00404	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  00408	39 44 24 68	 cmp	 DWORD PTR cur_match$[rsp], eax
  0040c	76 15		 jbe	 SHORT $LN2@longest_ma
  0040e	8b 44 24 04	 mov	 eax, DWORD PTR chain_length$[rsp]
  00412	ff c8		 dec	 eax
  00414	89 44 24 04	 mov	 DWORD PTR chain_length$[rsp], eax
  00418	83 7c 24 04 00	 cmp	 DWORD PTR chain_length$[rsp], 0
  0041d	0f 85 1e fd ff
	ff		 jne	 $LN13@longest_ma
$LN2@longest_ma:
$LN11@longest_ma:

; 1201 : 
; 1202 :     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;

  00423	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00428	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  0042e	39 04 24	 cmp	 DWORD PTR best_len$[rsp], eax
  00431	77 05		 ja	 SHORT $LN1@longest_ma
  00433	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  00436	eb 0b		 jmp	 SHORT $LN16@longest_ma
$LN1@longest_ma:

; 1203 :     return s->lookahead;

  00438	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0043d	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
$LN16@longest_ma:

; 1204 : }

  00443	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00447	c3		 ret	 0
longest_match ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_slow DD imagerel deflate_slow
	DD	imagerel deflate_slow+3114
	DD	imagerel $unwind$deflate_slow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_slow DD 021001H
	DD	0130110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_slow
_TEXT	SEGMENT
bflush$ = 32
hash_head$ = 36
max_insert$5475 = 40
len$5476 = 44
dist$5477 = 48
cc$5492 = 52
cc$5502 = 53
tv543 = 56
tv242 = 64
tv259 = 68
tv270 = 72
tv644 = 80
tv313 = 88
tv333 = 96
tv377 = 104
tv390 = 112
tv451 = 120
tv454 = 124
tv466 = 128
tv475 = 136
tv477 = 140
s$ = 160
flush$ = 168
deflate_slow PROC					; COMDAT

; 1619 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
$LN23@deflate_sl:

; 1620 :     IPos hash_head;          /* head of hash chain */
; 1621 :     int bflush;              /* set if current block must be flushed */
; 1622 : 
; 1623 :     /* Process the input block. */
; 1624 :     for (;;) {
; 1625 :         /* Make sure that we always have enough lookahead, except
; 1626 :          * at the end of the input file. We need MAX_MATCH bytes
; 1627 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1628 :          * string following the next match.
; 1629 :          */
; 1630 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00010	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00018	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00022	73 48		 jae	 SHORT $LN21@deflate_sl

; 1631 :             fill_window(s);

  00024	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 fill_window

; 1632 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00031	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00039	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00043	73 11		 jae	 SHORT $LN20@deflate_sl
  00045	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  0004d	75 07		 jne	 SHORT $LN20@deflate_sl

; 1633 :                 return need_more;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 cc 0b 00 00	 jmp	 $LN24@deflate_sl
$LN20@deflate_sl:

; 1634 :             }
; 1635 :             if (s->lookahead == 0) break; /* flush the current block */

  00056	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005e	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00065	75 05		 jne	 SHORT $LN19@deflate_sl
  00067	e9 73 09 00 00	 jmp	 $LN22@deflate_sl
$LN19@deflate_sl:
$LN21@deflate_sl:

; 1636 :         }
; 1637 : 
; 1638 :         /* Insert the string window[strstart .. strstart+2] in the
; 1639 :          * dictionary, and set hash_head to the head of the hash chain:
; 1640 :          */
; 1641 :         hash_head = NIL;

  0006c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0

; 1642 :         if (s->lookahead >= MIN_MATCH) {

  00074	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0007c	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  00083	0f 82 09 01 00
	00		 jb	 $LN18@deflate_sl

; 1643 :             INSERT_STRING(s, s->strstart, hash_head);

  00089	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00091	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00097	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0009f	48 89 4c 24 38	 mov	 QWORD PTR tv543[rsp], rcx
  000a4	0f b6 c8	 movzx	 ecx, al
  000a7	48 8b 44 24 38	 mov	 rax, QWORD PTR tv543[rsp]
  000ac	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000af	d3 e0		 shl	 eax, cl
  000b1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000b9	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  000bf	83 c1 02	 add	 ecx, 2
  000c2	8b c9		 mov	 ecx, ecx
  000c4	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  000cc	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  000d0	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000d4	33 c1		 xor	 eax, ecx
  000d6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000de	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  000e1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000e9	89 41 70	 mov	 DWORD PTR [rcx+112], eax
  000ec	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000f4	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000f7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000ff	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00103	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0010b	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  00113	45 8b 40 4c	 mov	 r8d, DWORD PTR [r8+76]
  00117	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [rdx+148]
  0011d	41 23 d0	 and	 edx, r8d
  00120	8b d2		 mov	 edx, edx
  00122	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  0012a	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  0012e	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00132	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax
  00137	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0013f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00147	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0014a	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00150	23 c1		 and	 eax, ecx
  00152	8b c0		 mov	 eax, eax
  00154	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0015c	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00160	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00164	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  00168	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00170	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00173	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0017b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0017f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00187	0f b7 92 94 00
	00 00		 movzx	 edx, WORD PTR [rdx+148]
  0018e	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
$LN18@deflate_sl:

; 1644 :         }
; 1645 : 
; 1646 :         /* Find the longest match, discarding those <= prev_length.
; 1647 :          */
; 1648 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  00192	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0019a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001a2	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  001a8	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx
  001ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001b6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001be	8b 89 98 00 00
	00		 mov	 ecx, DWORD PTR [rcx+152]
  001c4	89 88 8c 00 00
	00		 mov	 DWORD PTR [rax+140], ecx

; 1649 :         s->match_length = MIN_MATCH-1;

  001ca	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001d2	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 1650 : 
; 1651 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
; 1652 :             s->strstart - hash_head <= MAX_DIST(s)) {

  001dc	83 7c 24 24 00	 cmp	 DWORD PTR hash_head$[rsp], 0
  001e1	0f 84 d8 00 00
	00		 je	 $LN17@deflate_sl
  001e7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001ef	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001f7	8b 89 a8 00 00
	00		 mov	 ecx, DWORD PTR [rcx+168]
  001fd	39 88 a0 00 00
	00		 cmp	 DWORD PTR [rax+160], ecx
  00203	0f 83 b6 00 00
	00		 jae	 $LN17@deflate_sl
  00209	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00211	8b 4c 24 24	 mov	 ecx, DWORD PTR hash_head$[rsp]
  00215	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0021b	2b c1		 sub	 eax, ecx
  0021d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00225	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  00228	81 e9 06 01 00
	00		 sub	 ecx, 262		; 00000106H
  0022e	3b c1		 cmp	 eax, ecx
  00230	0f 87 89 00 00
	00		 ja	 $LN17@deflate_sl

; 1653 :             /* To simplify the code, we prevent matches with the string
; 1654 :              * of window index 0 (in particular we have to avoid a match
; 1655 :              * of the string with itself at the start of the input file).
; 1656 :              */
; 1657 :             s->match_length = longest_match (s, hash_head);

  00236	8b 54 24 24	 mov	 edx, DWORD PTR hash_head$[rsp]
  0023a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00242	e8 00 00 00 00	 call	 longest_match
  00247	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0024f	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 1658 :             /* longest_match() sets match_start */
; 1659 : 
; 1660 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED
; 1661 : #if TOO_FAR <= 32767
; 1662 :                 || (s->match_length == MIN_MATCH &&
; 1663 :                     s->strstart - s->match_start > TOO_FAR)
; 1664 : #endif
; 1665 :                 )) {

  00255	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0025d	83 b8 88 00 00
	00 05		 cmp	 DWORD PTR [rax+136], 5
  00264	77 59		 ja	 SHORT $LN16@deflate_sl
  00266	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0026e	83 b8 b0 00 00
	00 01		 cmp	 DWORD PTR [rax+176], 1
  00275	74 36		 je	 SHORT $LN15@deflate_sl
  00277	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0027f	83 b8 88 00 00
	00 03		 cmp	 DWORD PTR [rax+136], 3
  00286	75 37		 jne	 SHORT $LN16@deflate_sl
  00288	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00290	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00298	8b 89 98 00 00
	00		 mov	 ecx, DWORD PTR [rcx+152]
  0029e	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  002a4	2b c1		 sub	 eax, ecx
  002a6	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  002ab	76 12		 jbe	 SHORT $LN16@deflate_sl
$LN15@deflate_sl:

; 1666 : 
; 1667 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1668 :                  * but we will ignore the current match anyway.
; 1669 :                  */
; 1670 :                 s->match_length = MIN_MATCH-1;

  002ad	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002b5	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2
$LN16@deflate_sl:
$LN17@deflate_sl:

; 1671 :             }
; 1672 :         }
; 1673 :         /* If there was a match at the previous step and the current
; 1674 :          * match is not better, output the previous match:
; 1675 :          */
; 1676 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  002bf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002c7	83 b8 a0 00 00
	00 03		 cmp	 DWORD PTR [rax+160], 3
  002ce	0f 82 b2 04 00
	00		 jb	 $LN14@deflate_sl
  002d4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002dc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002e4	8b 89 a0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+160]
  002ea	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  002f0	0f 87 90 04 00
	00		 ja	 $LN14@deflate_sl

; 1677 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  002f6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002fe	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00304	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0030c	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  00312	8d 44 08 fd	 lea	 eax, DWORD PTR [rax+rcx-3]
  00316	89 44 24 28	 mov	 DWORD PTR max_insert$5475[rsp], eax

; 1678 :             /* Do not insert strings in hash table beyond this. */
; 1679 : 
; 1680 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1681 : 
; 1682 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,
; 1683 :                            s->prev_length - MIN_MATCH, bflush);

  0031a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00322	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  00328	83 e8 03	 sub	 eax, 3
  0032b	88 44 24 2c	 mov	 BYTE PTR len$5476[rsp], al
  0032f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00337	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0033d	ff c8		 dec	 eax
  0033f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00347	2b 81 8c 00 00
	00		 sub	 eax, DWORD PTR [rcx+140]
  0034d	66 89 44 24 30	 mov	 WORD PTR dist$5477[rsp], ax
  00352	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0035a	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00360	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00368	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  0036f	0f b7 54 24 30	 movzx	 edx, WORD PTR dist$5477[rsp]
  00374	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  00378	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00380	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00386	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0038e	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00395	0f b6 54 24 2c	 movzx	 edx, BYTE PTR len$5476[rsp]
  0039a	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  0039d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003a5	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  003ab	ff c0		 inc	 eax
  003ad	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003b5	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  003bb	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$5477[rsp]
  003c0	66 ff c8	 dec	 ax
  003c3	66 89 44 24 30	 mov	 WORD PTR dist$5477[rsp], ax
  003c8	0f b6 44 24 2c	 movzx	 eax, BYTE PTR len$5476[rsp]
  003cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_length_code
  003d4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003d8	05 01 01 00 00	 add	 eax, 257		; 00000101H
  003dd	48 98		 cdqe
  003df	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003e7	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  003ef	66 ff c0	 inc	 ax
  003f2	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR len$5476[rsp]
  003f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_length_code
  003fe	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00402	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00408	48 63 c9	 movsxd	 rcx, ecx
  0040b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00413	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  0041b	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$5477[rsp]
  00420	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00425	7d 16		 jge	 SHORT $LN26@deflate_sl
  00427	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$5477[rsp]
  0042c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  00433	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00437	89 44 24 40	 mov	 DWORD PTR tv242[rsp], eax
  0043b	eb 1e		 jmp	 SHORT $LN27@deflate_sl
$LN26@deflate_sl:
  0043d	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$5477[rsp]
  00442	c1 f8 07	 sar	 eax, 7
  00445	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0044a	48 98		 cdqe
  0044c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  00453	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00457	89 44 24 40	 mov	 DWORD PTR tv242[rsp], eax
$LN27@deflate_sl:
  0045b	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv242[rsp]
  00460	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00468	0f b7 84 81 b0
	09 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2480]
  00470	66 ff c0	 inc	 ax
  00473	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR tv242[rsp]
  00478	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00480	66 89 84 8a b0
	09 00 00	 mov	 WORD PTR [rdx+rcx*4+2480], ax
  00488	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00490	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00496	ff c8		 dec	 eax
  00498	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004a0	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  004a6	75 0a		 jne	 SHORT $LN28@deflate_sl
  004a8	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv259[rsp], 1
  004b0	eb 08		 jmp	 SHORT $LN29@deflate_sl
$LN28@deflate_sl:
  004b2	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv259[rsp], 0
$LN29@deflate_sl:
  004ba	8b 44 24 44	 mov	 eax, DWORD PTR tv259[rsp]
  004be	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1684 : 
; 1685 :             /* Insert in hash table all strings up to the end of the match.
; 1686 :              * strstart-1 and strstart are already inserted. If there is not
; 1687 :              * enough lookahead, the last two strings are not inserted in
; 1688 :              * the hash table.
; 1689 :              */
; 1690 :             s->lookahead -= s->prev_length-1;

  004c2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004ca	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  004d0	ff c8		 dec	 eax
  004d2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004da	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  004e0	2b c8		 sub	 ecx, eax
  004e2	8b c1		 mov	 eax, ecx
  004e4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004ec	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1691 :             s->prev_length -= 2;

  004f2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004fa	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  00500	83 e8 02	 sub	 eax, 2
  00503	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0050b	89 81 a0 00 00
	00		 mov	 DWORD PTR [rcx+160], eax
$LN13@deflate_sl:

; 1692 :             do {
; 1693 :                 if (++s->strstart <= max_insert) {

  00511	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00519	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0051f	ff c0		 inc	 eax
  00521	89 44 24 48	 mov	 DWORD PTR tv270[rsp], eax
  00525	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0052d	8b 4c 24 48	 mov	 ecx, DWORD PTR tv270[rsp]
  00531	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx
  00537	8b 44 24 28	 mov	 eax, DWORD PTR max_insert$5475[rsp]
  0053b	39 44 24 48	 cmp	 DWORD PTR tv270[rsp], eax
  0053f	0f 87 09 01 00
	00		 ja	 $LN10@deflate_sl

; 1694 :                     INSERT_STRING(s, s->strstart, hash_head);

  00545	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0054d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00553	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0055b	48 89 4c 24 50	 mov	 QWORD PTR tv644[rsp], rcx
  00560	0f b6 c8	 movzx	 ecx, al
  00563	48 8b 44 24 50	 mov	 rax, QWORD PTR tv644[rsp]
  00568	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0056b	d3 e0		 shl	 eax, cl
  0056d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00575	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  0057b	83 c1 02	 add	 ecx, 2
  0057e	8b c9		 mov	 ecx, ecx
  00580	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00588	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  0058c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00590	33 c1		 xor	 eax, ecx
  00592	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0059a	23 41 7c	 and	 eax, DWORD PTR [rcx+124]
  0059d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005a5	89 41 70	 mov	 DWORD PTR [rcx+112], eax
  005a8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005b0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  005b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005bb	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  005bf	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  005c7	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  005cf	45 8b 40 4c	 mov	 r8d, DWORD PTR [r8+76]
  005d3	8b 92 94 00 00
	00		 mov	 edx, DWORD PTR [rdx+148]
  005d9	41 23 d0	 and	 edx, r8d
  005dc	8b d2		 mov	 edx, edx
  005de	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  005e6	4d 8b 40 60	 mov	 r8, QWORD PTR [r8+96]
  005ea	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  005ee	66 41 89 04 50	 mov	 WORD PTR [r8+rdx*2], ax
  005f3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005fb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00603	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00606	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0060c	23 c1		 and	 eax, ecx
  0060e	8b c0		 mov	 eax, eax
  00610	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00618	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0061c	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00620	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  00624	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0062c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0062f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00637	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0063b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00643	0f b7 92 94 00
	00 00		 movzx	 edx, WORD PTR [rdx+148]
  0064a	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
$LN10@deflate_sl:

; 1695 :                 }
; 1696 :             } while (--s->prev_length != 0);

  0064e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00656	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  0065c	ff c8		 dec	 eax
  0065e	89 44 24 58	 mov	 DWORD PTR tv313[rsp], eax
  00662	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0066a	8b 4c 24 58	 mov	 ecx, DWORD PTR tv313[rsp]
  0066e	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx
  00674	83 7c 24 58 00	 cmp	 DWORD PTR tv313[rsp], 0
  00679	0f 85 92 fe ff
	ff		 jne	 $LN13@deflate_sl

; 1697 :             s->match_available = 0;

  0067f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00687	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 1698 :             s->match_length = MIN_MATCH-1;

  00691	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00699	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 1699 :             s->strstart++;

  006a3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006ab	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  006b1	ff c0		 inc	 eax
  006b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006bb	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1700 : 
; 1701 :             if (bflush) FLUSH_BLOCK(s, 0);

  006c1	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  006c6	0f 84 b5 00 00
	00		 je	 $LN9@deflate_sl
  006cc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006d4	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  006db	7c 21		 jl	 SHORT $LN30@deflate_sl
  006dd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006e5	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  006eb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006f3	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  006f7	48 89 44 24 60	 mov	 QWORD PTR tv333[rsp], rax
  006fc	eb 09		 jmp	 SHORT $LN31@deflate_sl
$LN30@deflate_sl:
  006fe	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv333[rsp], 0
$LN31@deflate_sl:
  00707	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0070f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00717	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  0071d	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00723	2b c1		 sub	 eax, ecx
  00725	45 33 c9	 xor	 r9d, r9d
  00728	44 8b c0	 mov	 r8d, eax
  0072b	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv333[rsp]
  00730	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00738	e8 00 00 00 00	 call	 _tr_flush_block
  0073d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00745	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0074d	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00753	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00759	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00761	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00764	e8 00 00 00 00	 call	 flush_pending
  00769	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00771	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00774	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00778	75 07		 jne	 SHORT $LN8@deflate_sl
  0077a	33 c0		 xor	 eax, eax
  0077c	e9 a1 04 00 00	 jmp	 $LN24@deflate_sl
$LN8@deflate_sl:
$LN9@deflate_sl:
  00781	e9 54 02 00 00	 jmp	 $LN7@deflate_sl
$LN14@deflate_sl:

; 1702 : 
; 1703 :         } else if (s->match_available) {

  00786	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0078e	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  00795	0f 84 f1 01 00
	00		 je	 $LN6@deflate_sl

; 1704 :             /* If there was no match at the previous position, output a
; 1705 :              * single literal. If there was a match but the current match
; 1706 :              * is longer, truncate the previous match to a single literal.
; 1707 :              */
; 1708 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1709 :             _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  0079b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007a3	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  007a9	ff c8		 dec	 eax
  007ab	8b c0		 mov	 eax, eax
  007ad	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007b5	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  007b9	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  007bd	88 44 24 34	 mov	 BYTE PTR cc$5492[rsp], al
  007c1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007c9	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  007cf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007d7	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  007de	33 d2		 xor	 edx, edx
  007e0	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  007e4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007ec	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  007f2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007fa	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00801	0f b6 54 24 34	 movzx	 edx, BYTE PTR cc$5492[rsp]
  00806	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  00809	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00811	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00817	ff c0		 inc	 eax
  00819	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00821	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  00827	0f b6 44 24 34	 movzx	 eax, BYTE PTR cc$5492[rsp]
  0082c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00834	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  0083c	66 ff c0	 inc	 ax
  0083f	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR cc$5492[rsp]
  00844	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0084c	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  00854	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0085c	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00862	ff c8		 dec	 eax
  00864	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0086c	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  00872	75 0a		 jne	 SHORT $LN32@deflate_sl
  00874	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv377[rsp], 1
  0087c	eb 08		 jmp	 SHORT $LN33@deflate_sl
$LN32@deflate_sl:
  0087e	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv377[rsp], 0
$LN33@deflate_sl:
  00886	8b 44 24 68	 mov	 eax, DWORD PTR tv377[rsp]
  0088a	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1710 :             if (bflush) {

  0088e	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  00893	0f 84 9d 00 00
	00		 je	 $LN5@deflate_sl

; 1711 :                 FLUSH_BLOCK_ONLY(s, 0);

  00899	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008a1	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  008a8	7c 21		 jl	 SHORT $LN34@deflate_sl
  008aa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008b2	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  008b8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008c0	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  008c4	48 89 44 24 70	 mov	 QWORD PTR tv390[rsp], rax
  008c9	eb 09		 jmp	 SHORT $LN35@deflate_sl
$LN34@deflate_sl:
  008cb	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv390[rsp], 0
$LN35@deflate_sl:
  008d4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008dc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008e4	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  008ea	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  008f0	2b c1		 sub	 eax, ecx
  008f2	45 33 c9	 xor	 r9d, r9d
  008f5	44 8b c0	 mov	 r8d, eax
  008f8	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv390[rsp]
  008fd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00905	e8 00 00 00 00	 call	 _tr_flush_block
  0090a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00912	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0091a	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00920	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00926	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0092e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00931	e8 00 00 00 00	 call	 flush_pending
$LN5@deflate_sl:

; 1712 :             }
; 1713 :             s->strstart++;

  00936	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0093e	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00944	ff c0		 inc	 eax
  00946	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0094e	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1714 :             s->lookahead--;

  00954	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0095c	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00962	ff c8		 dec	 eax
  00964	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0096c	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1715 :             if (s->strm->avail_out == 0) return need_more;

  00972	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0097a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0097d	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00981	75 07		 jne	 SHORT $LN4@deflate_sl
  00983	33 c0		 xor	 eax, eax
  00985	e9 98 02 00 00	 jmp	 $LN24@deflate_sl
$LN4@deflate_sl:

; 1716 :         } else {

  0098a	eb 4e		 jmp	 SHORT $LN3@deflate_sl
$LN6@deflate_sl:

; 1717 :             /* There is no previous match to compare with, wait for
; 1718 :              * the next step to decide.
; 1719 :              */
; 1720 :             s->match_available = 1;

  0098c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00994	c7 80 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+144], 1

; 1721 :             s->strstart++;

  0099e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009a6	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  009ac	ff c0		 inc	 eax
  009ae	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009b6	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1722 :             s->lookahead--;

  009bc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009c4	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  009ca	ff c8		 dec	 eax
  009cc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009d4	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax
$LN3@deflate_sl:
$LN7@deflate_sl:

; 1723 :         }
; 1724 :     }

  009da	e9 31 f6 ff ff	 jmp	 $LN23@deflate_sl
$LN22@deflate_sl:

; 1725 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 1726 :     if (s->match_available) {

  009df	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009e7	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  009ee	0f 84 05 01 00
	00		 je	 $LN2@deflate_sl

; 1727 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1728 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  009f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009fc	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00a02	ff c8		 dec	 eax
  00a04	8b c0		 mov	 eax, eax
  00a06	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a0e	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00a12	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00a16	88 44 24 35	 mov	 BYTE PTR cc$5502[rsp], al
  00a1a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a22	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00a28	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a30	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00a37	33 d2		 xor	 edx, edx
  00a39	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  00a3d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a45	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00a4b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a53	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00a5a	0f b6 54 24 35	 movzx	 edx, BYTE PTR cc$5502[rsp]
  00a5f	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  00a62	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a6a	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00a70	ff c0		 inc	 eax
  00a72	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a7a	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  00a80	0f b6 44 24 35	 movzx	 eax, BYTE PTR cc$5502[rsp]
  00a85	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00a8d	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  00a95	66 ff c0	 inc	 ax
  00a98	0f b6 4c 24 35	 movzx	 ecx, BYTE PTR cc$5502[rsp]
  00a9d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00aa5	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  00aad	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ab5	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00abb	ff c8		 dec	 eax
  00abd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ac5	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  00acb	75 0a		 jne	 SHORT $LN36@deflate_sl
  00acd	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv451[rsp], 1
  00ad5	eb 08		 jmp	 SHORT $LN37@deflate_sl
$LN36@deflate_sl:
  00ad7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv451[rsp], 0
$LN37@deflate_sl:
  00adf	8b 44 24 78	 mov	 eax, DWORD PTR tv451[rsp]
  00ae3	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1729 :         s->match_available = 0;

  00ae7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00aef	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0
$LN2@deflate_sl:

; 1730 :     }
; 1731 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00af9	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00b01	75 0a		 jne	 SHORT $LN38@deflate_sl
  00b03	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv454[rsp], 1
  00b0b	eb 08		 jmp	 SHORT $LN39@deflate_sl
$LN38@deflate_sl:
  00b0d	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv454[rsp], 0
$LN39@deflate_sl:
  00b15	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b1d	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00b24	7c 24		 jl	 SHORT $LN40@deflate_sl
  00b26	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b2e	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00b34	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b3c	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00b40	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv466[rsp], rax
  00b48	eb 0c		 jmp	 SHORT $LN41@deflate_sl
$LN40@deflate_sl:
  00b4a	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv466[rsp], 0
$LN41@deflate_sl:
  00b56	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b5e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b66	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00b6c	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00b72	2b c1		 sub	 eax, ecx
  00b74	44 8b 4c 24 7c	 mov	 r9d, DWORD PTR tv454[rsp]
  00b79	44 8b c0	 mov	 r8d, eax
  00b7c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv466[rsp]
  00b84	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b8c	e8 00 00 00 00	 call	 _tr_flush_block
  00b91	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b99	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ba1	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00ba7	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00bad	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bb5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00bb8	e8 00 00 00 00	 call	 flush_pending
  00bbd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bc5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00bc8	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00bcc	75 2b		 jne	 SHORT $LN1@deflate_sl
  00bce	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00bd6	75 0d		 jne	 SHORT $LN42@deflate_sl
  00bd8	c7 84 24 88 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv475[rsp], 2
  00be3	eb 0b		 jmp	 SHORT $LN43@deflate_sl
$LN42@deflate_sl:
  00be5	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv475[rsp], 0
$LN43@deflate_sl:
  00bf0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv475[rsp]
  00bf7	eb 29		 jmp	 SHORT $LN24@deflate_sl
$LN1@deflate_sl:

; 1732 :     return flush == Z_FINISH ? finish_done : block_done;

  00bf9	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00c01	75 0d		 jne	 SHORT $LN44@deflate_sl
  00c03	c7 84 24 8c 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv477[rsp], 3
  00c0e	eb 0b		 jmp	 SHORT $LN45@deflate_sl
$LN44@deflate_sl:
  00c10	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv477[rsp], 1
$LN45@deflate_sl:
  00c1b	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv477[rsp]
$LN24@deflate_sl:

; 1733 : }

  00c22	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00c29	c3		 ret	 0
deflate_slow ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_rle DD imagerel deflate_rle
	DD	imagerel deflate_rle+1992
	DD	imagerel $unwind$deflate_rle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_rle DD 021001H
	DD	0110110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_rle
_TEXT	SEGMENT
prev$ = 32
scan$ = 40
bflush$ = 48
strend$ = 56
len$5532 = 64
dist$5533 = 68
cc$5535 = 72
tv219 = 76
tv236 = 80
tv279 = 84
tv300 = 88
tv309 = 96
tv321 = 104
tv330 = 112
tv332 = 116
s$ = 144
flush$ = 152
deflate_rle PROC					; COMDAT

; 1744 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
$LN17@deflate_rl:

; 1745 :     int bflush;             /* set if current block must be flushed */
; 1746 :     uInt prev;              /* byte at distance one to match */
; 1747 :     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
; 1748 : 
; 1749 :     for (;;) {
; 1750 :         /* Make sure that we always have enough lookahead, except
; 1751 :          * at the end of the input file. We need MAX_MATCH bytes
; 1752 :          * for the longest encodable run.
; 1753 :          */
; 1754 :         if (s->lookahead < MAX_MATCH) {

  00010	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00018	81 b8 9c 00 00
	00 02 01 00 00	 cmp	 DWORD PTR [rax+156], 258 ; 00000102H
  00022	73 48		 jae	 SHORT $LN15@deflate_rl

; 1755 :             fill_window(s);

  00024	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 fill_window

; 1756 :             if (s->lookahead < MAX_MATCH && flush == Z_NO_FLUSH) {

  00031	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00039	81 b8 9c 00 00
	00 02 01 00 00	 cmp	 DWORD PTR [rax+156], 258 ; 00000102H
  00043	73 11		 jae	 SHORT $LN14@deflate_rl
  00045	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  0004d	75 07		 jne	 SHORT $LN14@deflate_rl

; 1757 :                 return need_more;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 6a 07 00 00	 jmp	 $LN18@deflate_rl
$LN14@deflate_rl:

; 1758 :             }
; 1759 :             if (s->lookahead == 0) break; /* flush the current block */

  00056	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0005e	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00065	75 05		 jne	 SHORT $LN13@deflate_rl
  00067	e9 46 06 00 00	 jmp	 $LN16@deflate_rl
$LN13@deflate_rl:
$LN15@deflate_rl:

; 1760 :         }
; 1761 : 
; 1762 :         /* See how many times the previous byte repeats */
; 1763 :         s->match_length = 0;

  0006c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00074	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 1764 :         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {

  0007e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00086	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  0008d	0f 82 1e 02 00
	00		 jb	 $LN12@deflate_rl
  00093	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0009b	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  000a2	0f 86 09 02 00
	00		 jbe	 $LN12@deflate_rl

; 1765 :             scan = s->window + s->strstart - 1;

  000a8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b0	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  000b6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000be	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000c2	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  000c7	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax

; 1766 :             prev = *scan;

  000cc	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  000d1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d4	89 44 24 20	 mov	 DWORD PTR prev$[rsp], eax

; 1767 :             if (prev == *++scan && prev == *++scan && prev == *++scan) {

  000d8	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  000dd	48 ff c0	 inc	 rax
  000e0	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  000e5	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  000ea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ed	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  000f1	0f 85 ba 01 00
	00		 jne	 $LN11@deflate_rl
  000f7	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  000fc	48 ff c0	 inc	 rax
  000ff	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00104	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00109	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0010c	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  00110	0f 85 9b 01 00
	00		 jne	 $LN11@deflate_rl
  00116	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0011b	48 ff c0	 inc	 rax
  0011e	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00123	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00128	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012b	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  0012f	0f 85 7c 01 00
	00		 jne	 $LN11@deflate_rl

; 1768 :                 strend = s->window + s->strstart + MAX_MATCH;

  00135	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0013d	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00143	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0014b	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0014f	48 8d 84 01 02
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+258]
  00157	48 89 44 24 38	 mov	 QWORD PTR strend$[rsp], rax
$LN10@deflate_rl:

; 1769 :                 do {
; 1770 :                 } while (prev == *++scan && prev == *++scan &&
; 1771 :                          prev == *++scan && prev == *++scan &&
; 1772 :                          prev == *++scan && prev == *++scan &&
; 1773 :                          prev == *++scan && prev == *++scan &&
; 1774 :                          scan < strend);

  0015c	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00161	48 ff c0	 inc	 rax
  00164	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00169	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0016e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00171	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  00175	0f 85 d5 00 00
	00		 jne	 $LN7@deflate_rl
  0017b	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00180	48 ff c0	 inc	 rax
  00183	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00188	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0018d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00190	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  00194	0f 85 b6 00 00
	00		 jne	 $LN7@deflate_rl
  0019a	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0019f	48 ff c0	 inc	 rax
  001a2	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  001a7	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001ac	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001af	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  001b3	0f 85 97 00 00
	00		 jne	 $LN7@deflate_rl
  001b9	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001be	48 ff c0	 inc	 rax
  001c1	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  001c6	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001cb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001ce	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  001d2	75 7c		 jne	 SHORT $LN7@deflate_rl
  001d4	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001d9	48 ff c0	 inc	 rax
  001dc	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  001e1	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001e6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001e9	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  001ed	75 61		 jne	 SHORT $LN7@deflate_rl
  001ef	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  001f4	48 ff c0	 inc	 rax
  001f7	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  001fc	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00201	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00204	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  00208	75 46		 jne	 SHORT $LN7@deflate_rl
  0020a	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0020f	48 ff c0	 inc	 rax
  00212	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00217	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0021c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0021f	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  00223	75 2b		 jne	 SHORT $LN7@deflate_rl
  00225	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  0022a	48 ff c0	 inc	 rax
  0022d	48 89 44 24 28	 mov	 QWORD PTR scan$[rsp], rax
  00232	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00237	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0023a	39 44 24 20	 cmp	 DWORD PTR prev$[rsp], eax
  0023e	75 10		 jne	 SHORT $LN7@deflate_rl
  00240	48 8b 44 24 38	 mov	 rax, QWORD PTR strend$[rsp]
  00245	48 39 44 24 28	 cmp	 QWORD PTR scan$[rsp], rax
  0024a	0f 82 0c ff ff
	ff		 jb	 $LN10@deflate_rl
$LN7@deflate_rl:

; 1775 :                 s->match_length = MAX_MATCH - (int)(strend - scan);

  00250	48 8b 44 24 28	 mov	 rax, QWORD PTR scan$[rsp]
  00255	48 8b 4c 24 38	 mov	 rcx, QWORD PTR strend$[rsp]
  0025a	48 2b c8	 sub	 rcx, rax
  0025d	48 8b c1	 mov	 rax, rcx
  00260	b9 02 01 00 00	 mov	 ecx, 258		; 00000102H
  00265	2b c8		 sub	 ecx, eax
  00267	8b c1		 mov	 eax, ecx
  00269	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00271	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 1776 :                 if (s->match_length > s->lookahead)

  00277	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0027f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00287	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  0028d	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  00293	76 1c		 jbe	 SHORT $LN6@deflate_rl

; 1777 :                     s->match_length = s->lookahead;

  00295	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0029d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a5	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  002ab	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx
$LN6@deflate_rl:
$LN11@deflate_rl:
$LN12@deflate_rl:

; 1778 :             }
; 1779 :         }
; 1780 : 
; 1781 :         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
; 1782 :         if (s->match_length >= MIN_MATCH) {

  002b1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002b9	83 b8 88 00 00
	00 03		 cmp	 DWORD PTR [rax+136], 3
  002c0	0f 82 fc 01 00
	00		 jb	 $LN5@deflate_rl

; 1783 :             check_match(s, s->strstart, s->strstart - 1, s->match_length);
; 1784 : 
; 1785 :             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

  002c6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002ce	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002d4	83 e8 03	 sub	 eax, 3
  002d7	88 44 24 40	 mov	 BYTE PTR len$5532[rsp], al
  002db	b8 01 00 00 00	 mov	 eax, 1
  002e0	66 89 44 24 44	 mov	 WORD PTR dist$5533[rsp], ax
  002e5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002ed	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  002f3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002fb	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00302	0f b7 54 24 44	 movzx	 edx, WORD PTR dist$5533[rsp]
  00307	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  0030b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00313	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00319	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00321	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00328	0f b6 54 24 40	 movzx	 edx, BYTE PTR len$5532[rsp]
  0032d	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  00330	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00338	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  0033e	ff c0		 inc	 eax
  00340	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00348	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  0034e	0f b7 44 24 44	 movzx	 eax, WORD PTR dist$5533[rsp]
  00353	66 ff c8	 dec	 ax
  00356	66 89 44 24 44	 mov	 WORD PTR dist$5533[rsp], ax
  0035b	0f b6 44 24 40	 movzx	 eax, BYTE PTR len$5532[rsp]
  00360	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_length_code
  00367	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0036b	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00370	48 98		 cdqe
  00372	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0037a	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  00382	66 ff c0	 inc	 ax
  00385	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR len$5532[rsp]
  0038a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_length_code
  00391	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00395	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  0039b	48 63 c9	 movsxd	 rcx, ecx
  0039e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  003a6	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  003ae	0f b7 44 24 44	 movzx	 eax, WORD PTR dist$5533[rsp]
  003b3	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  003b8	7d 16		 jge	 SHORT $LN20@deflate_rl
  003ba	0f b7 44 24 44	 movzx	 eax, WORD PTR dist$5533[rsp]
  003bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  003c6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ca	89 44 24 4c	 mov	 DWORD PTR tv219[rsp], eax
  003ce	eb 1e		 jmp	 SHORT $LN21@deflate_rl
$LN20@deflate_rl:
  003d0	0f b7 44 24 44	 movzx	 eax, WORD PTR dist$5533[rsp]
  003d5	c1 f8 07	 sar	 eax, 7
  003d8	05 00 01 00 00	 add	 eax, 256		; 00000100H
  003dd	48 98		 cdqe
  003df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_dist_code
  003e6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ea	89 44 24 4c	 mov	 DWORD PTR tv219[rsp], eax
$LN21@deflate_rl:
  003ee	48 63 44 24 4c	 movsxd	 rax, DWORD PTR tv219[rsp]
  003f3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003fb	0f b7 84 81 b0
	09 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+2480]
  00403	66 ff c0	 inc	 ax
  00406	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR tv219[rsp]
  0040b	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00413	66 89 84 8a b0
	09 00 00	 mov	 WORD PTR [rdx+rcx*4+2480], ax
  0041b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00423	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00429	ff c8		 dec	 eax
  0042b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00433	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  00439	75 0a		 jne	 SHORT $LN22@deflate_rl
  0043b	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv236[rsp], 1
  00443	eb 08		 jmp	 SHORT $LN23@deflate_rl
$LN22@deflate_rl:
  00445	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv236[rsp], 0
$LN23@deflate_rl:
  0044d	8b 44 24 50	 mov	 eax, DWORD PTR tv236[rsp]
  00451	89 44 24 30	 mov	 DWORD PTR bflush$[rsp], eax

; 1786 : 
; 1787 :             s->lookahead -= s->match_length;

  00455	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0045d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00465	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  0046b	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00471	2b c1		 sub	 eax, ecx
  00473	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0047b	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1788 :             s->strstart += s->match_length;

  00481	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00489	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0048f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00497	03 81 88 00 00
	00		 add	 eax, DWORD PTR [rcx+136]
  0049d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004a5	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1789 :             s->match_length = 0;

  004ab	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004b3	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 1790 :         } else {

  004bd	e9 2b 01 00 00	 jmp	 $LN4@deflate_rl
$LN5@deflate_rl:

; 1791 :             /* No match, output a literal byte */
; 1792 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1793 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  004c2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004ca	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  004d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004d8	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  004dc	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  004e0	88 44 24 48	 mov	 BYTE PTR cc$5535[rsp], al
  004e4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004ec	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  004f2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004fa	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00501	33 d2		 xor	 edx, edx
  00503	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  00507	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0050f	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00515	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0051d	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00524	0f b6 54 24 48	 movzx	 edx, BYTE PTR cc$5535[rsp]
  00529	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  0052c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00534	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  0053a	ff c0		 inc	 eax
  0053c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00544	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  0054a	0f b6 44 24 48	 movzx	 eax, BYTE PTR cc$5535[rsp]
  0054f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00557	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  0055f	66 ff c0	 inc	 ax
  00562	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR cc$5535[rsp]
  00567	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0056f	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  00577	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0057f	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00585	ff c8		 dec	 eax
  00587	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0058f	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  00595	75 0a		 jne	 SHORT $LN24@deflate_rl
  00597	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv279[rsp], 1
  0059f	eb 08		 jmp	 SHORT $LN25@deflate_rl
$LN24@deflate_rl:
  005a1	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv279[rsp], 0
$LN25@deflate_rl:
  005a9	8b 44 24 54	 mov	 eax, DWORD PTR tv279[rsp]
  005ad	89 44 24 30	 mov	 DWORD PTR bflush$[rsp], eax

; 1794 :             s->lookahead--;

  005b1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005b9	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  005bf	ff c8		 dec	 eax
  005c1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005c9	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1795 :             s->strstart++;

  005cf	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005d7	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  005dd	ff c0		 inc	 eax
  005df	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005e7	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax
$LN4@deflate_rl:

; 1796 :         }
; 1797 :         if (bflush) FLUSH_BLOCK(s, 0);

  005ed	83 7c 24 30 00	 cmp	 DWORD PTR bflush$[rsp], 0
  005f2	0f 84 b5 00 00
	00		 je	 $LN3@deflate_rl
  005f8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00600	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00607	7c 21		 jl	 SHORT $LN26@deflate_rl
  00609	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00611	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00617	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0061f	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00623	48 89 44 24 58	 mov	 QWORD PTR tv300[rsp], rax
  00628	eb 09		 jmp	 SHORT $LN27@deflate_rl
$LN26@deflate_rl:
  0062a	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv300[rsp], 0
$LN27@deflate_rl:
  00633	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0063b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00643	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00649	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0064f	2b c1		 sub	 eax, ecx
  00651	45 33 c9	 xor	 r9d, r9d
  00654	44 8b c0	 mov	 r8d, eax
  00657	48 8b 54 24 58	 mov	 rdx, QWORD PTR tv300[rsp]
  0065c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00664	e8 00 00 00 00	 call	 _tr_flush_block
  00669	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00671	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00679	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  0067f	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00685	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0068d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00690	e8 00 00 00 00	 call	 flush_pending
  00695	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0069d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006a0	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  006a4	75 07		 jne	 SHORT $LN2@deflate_rl
  006a6	33 c0		 xor	 eax, eax
  006a8	e9 13 01 00 00	 jmp	 $LN18@deflate_rl
$LN2@deflate_rl:
$LN3@deflate_rl:

; 1798 :     }

  006ad	e9 5e f9 ff ff	 jmp	 $LN17@deflate_rl
$LN16@deflate_rl:

; 1799 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  006b2	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  006ba	75 0a		 jne	 SHORT $LN28@deflate_rl
  006bc	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv309[rsp], 1
  006c4	eb 08		 jmp	 SHORT $LN29@deflate_rl
$LN28@deflate_rl:
  006c6	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv309[rsp], 0
$LN29@deflate_rl:
  006ce	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006d6	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  006dd	7c 21		 jl	 SHORT $LN30@deflate_rl
  006df	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006e7	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  006ed	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006f5	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  006f9	48 89 44 24 68	 mov	 QWORD PTR tv321[rsp], rax
  006fe	eb 09		 jmp	 SHORT $LN31@deflate_rl
$LN30@deflate_rl:
  00700	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR tv321[rsp], 0
$LN31@deflate_rl:
  00709	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00711	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00719	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  0071f	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00725	2b c1		 sub	 eax, ecx
  00727	44 8b 4c 24 60	 mov	 r9d, DWORD PTR tv309[rsp]
  0072c	44 8b c0	 mov	 r8d, eax
  0072f	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv321[rsp]
  00734	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0073c	e8 00 00 00 00	 call	 _tr_flush_block
  00741	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00749	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00751	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00757	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  0075d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00765	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00768	e8 00 00 00 00	 call	 flush_pending
  0076d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00775	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00778	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0077c	75 22		 jne	 SHORT $LN1@deflate_rl
  0077e	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00786	75 0a		 jne	 SHORT $LN32@deflate_rl
  00788	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv330[rsp], 2
  00790	eb 08		 jmp	 SHORT $LN33@deflate_rl
$LN32@deflate_rl:
  00792	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv330[rsp], 0
$LN33@deflate_rl:
  0079a	8b 44 24 70	 mov	 eax, DWORD PTR tv330[rsp]
  0079e	eb 20		 jmp	 SHORT $LN18@deflate_rl
$LN1@deflate_rl:

; 1800 :     return flush == Z_FINISH ? finish_done : block_done;

  007a0	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  007a8	75 0a		 jne	 SHORT $LN34@deflate_rl
  007aa	c7 44 24 74 03
	00 00 00	 mov	 DWORD PTR tv332[rsp], 3
  007b2	eb 08		 jmp	 SHORT $LN35@deflate_rl
$LN34@deflate_rl:
  007b4	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv332[rsp], 1
$LN35@deflate_rl:
  007bc	8b 44 24 74	 mov	 eax, DWORD PTR tv332[rsp]
$LN18@deflate_rl:

; 1801 : }

  007c0	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  007c7	c3		 ret	 0
deflate_rle ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_huff DD imagerel deflate_huff
	DD	imagerel deflate_huff+739
	DD	imagerel $unwind$deflate_huff
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_huff DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_huff
_TEXT	SEGMENT
bflush$ = 32
cc$5560 = 36
tv136 = 40
tv157 = 48
tv166 = 56
tv178 = 64
tv187 = 72
tv189 = 76
s$ = 96
flush$ = 104
deflate_huff PROC					; COMDAT

; 1810 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN8@deflate_hu:

; 1811 :     int bflush;             /* set if current block must be flushed */
; 1812 : 
; 1813 :     for (;;) {
; 1814 :         /* Make sure that we have a literal to write. */
; 1815 :         if (s->lookahead == 0) {

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00012	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00019	75 2b		 jne	 SHORT $LN6@deflate_hu

; 1816 :             fill_window(s);

  0001b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00020	e8 00 00 00 00	 call	 fill_window

; 1817 :             if (s->lookahead == 0) {

  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0002a	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00031	75 13		 jne	 SHORT $LN5@deflate_hu

; 1818 :                 if (flush == Z_NO_FLUSH)

  00033	83 7c 24 68 00	 cmp	 DWORD PTR flush$[rsp], 0
  00038	75 07		 jne	 SHORT $LN4@deflate_hu

; 1819 :                     return need_more;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 9d 02 00 00	 jmp	 $LN9@deflate_hu
$LN4@deflate_hu:

; 1820 :                 break;      /* flush the current block */

  00041	e9 b1 01 00 00	 jmp	 $LN7@deflate_hu
$LN5@deflate_hu:
$LN6@deflate_hu:

; 1821 :             }
; 1822 :         }
; 1823 : 
; 1824 :         /* Output a literal byte */
; 1825 :         s->match_length = 0;

  00046	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0004b	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 1826 :         Tracevv((stderr,"%c", s->window[s->strstart]));
; 1827 :         _tr_tally_lit (s, s->window[s->strstart], bflush);

  00055	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0005a	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00060	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00065	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00069	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0006d	88 44 24 24	 mov	 BYTE PTR cc$5560[rsp], al
  00071	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00076	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00081	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00088	33 d2		 xor	 edx, edx
  0008a	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  0008e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00093	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  00099	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0009e	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  000a5	0f b6 54 24 24	 movzx	 edx, BYTE PTR cc$5560[rsp]
  000aa	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  000ad	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000b2	8b 80 f4 16 00
	00		 mov	 eax, DWORD PTR [rax+5876]
  000b8	ff c0		 inc	 eax
  000ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000bf	89 81 f4 16 00
	00		 mov	 DWORD PTR [rcx+5876], eax
  000c5	0f b6 44 24 24	 movzx	 eax, BYTE PTR cc$5560[rsp]
  000ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000cf	0f b7 84 81 bc
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*4+188]
  000d7	66 ff c0	 inc	 ax
  000da	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR cc$5560[rsp]
  000df	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  000e4	66 89 84 8a bc
	00 00 00	 mov	 WORD PTR [rdx+rcx*4+188], ax
  000ec	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000f1	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  000f7	ff c8		 dec	 eax
  000f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000fe	39 81 f4 16 00
	00		 cmp	 DWORD PTR [rcx+5876], eax
  00104	75 0a		 jne	 SHORT $LN11@deflate_hu
  00106	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  0010e	eb 08		 jmp	 SHORT $LN12@deflate_hu
$LN11@deflate_hu:
  00110	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN12@deflate_hu:
  00118	8b 44 24 28	 mov	 eax, DWORD PTR tv136[rsp]
  0011c	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1828 :         s->lookahead--;

  00120	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00125	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  0012b	ff c8		 dec	 eax
  0012d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00132	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 1829 :         s->strstart++;

  00138	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0013d	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00143	ff c0		 inc	 eax
  00145	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0014a	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1830 :         if (bflush) FLUSH_BLOCK(s, 0);

  00150	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  00155	0f 84 97 00 00
	00		 je	 $LN3@deflate_hu
  0015b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00160	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00167	7c 1b		 jl	 SHORT $LN13@deflate_hu
  00169	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0016e	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00174	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00179	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  0017d	48 89 44 24 30	 mov	 QWORD PTR tv157[rsp], rax
  00182	eb 09		 jmp	 SHORT $LN14@deflate_hu
$LN13@deflate_hu:
  00184	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv157[rsp], 0
$LN14@deflate_hu:
  0018d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00192	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00197	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  0019d	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  001a3	2b c1		 sub	 eax, ecx
  001a5	45 33 c9	 xor	 r9d, r9d
  001a8	44 8b c0	 mov	 r8d, eax
  001ab	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv157[rsp]
  001b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001b5	e8 00 00 00 00	 call	 _tr_flush_block
  001ba	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001c4	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  001ca	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  001d0	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001d5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001d8	e8 00 00 00 00	 call	 flush_pending
  001dd	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001e2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e5	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  001e9	75 07		 jne	 SHORT $LN2@deflate_hu
  001eb	33 c0		 xor	 eax, eax
  001ed	e9 ec 00 00 00	 jmp	 $LN9@deflate_hu
$LN2@deflate_hu:
$LN3@deflate_hu:

; 1831 :     }

  001f2	e9 16 fe ff ff	 jmp	 $LN8@deflate_hu
$LN7@deflate_hu:

; 1832 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  001f7	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  001fc	75 0a		 jne	 SHORT $LN15@deflate_hu
  001fe	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv166[rsp], 1
  00206	eb 08		 jmp	 SHORT $LN16@deflate_hu
$LN15@deflate_hu:
  00208	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
$LN16@deflate_hu:
  00210	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00215	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  0021c	7c 1b		 jl	 SHORT $LN17@deflate_hu
  0021e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00223	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00229	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0022e	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00232	48 89 44 24 40	 mov	 QWORD PTR tv178[rsp], rax
  00237	eb 09		 jmp	 SHORT $LN18@deflate_hu
$LN17@deflate_hu:
  00239	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv178[rsp], 0
$LN18@deflate_hu:
  00242	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00247	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0024c	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  00252	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00258	2b c1		 sub	 eax, ecx
  0025a	44 8b 4c 24 38	 mov	 r9d, DWORD PTR tv166[rsp]
  0025f	44 8b c0	 mov	 r8d, eax
  00262	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv178[rsp]
  00267	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0026c	e8 00 00 00 00	 call	 _tr_flush_block
  00271	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00276	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0027b	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00281	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
  00287	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0028c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0028f	e8 00 00 00 00	 call	 flush_pending
  00294	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00299	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0029c	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  002a0	75 1f		 jne	 SHORT $LN1@deflate_hu
  002a2	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  002a7	75 0a		 jne	 SHORT $LN19@deflate_hu
  002a9	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv187[rsp], 2
  002b1	eb 08		 jmp	 SHORT $LN20@deflate_hu
$LN19@deflate_hu:
  002b3	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN20@deflate_hu:
  002bb	8b 44 24 48	 mov	 eax, DWORD PTR tv187[rsp]
  002bf	eb 1d		 jmp	 SHORT $LN9@deflate_hu
$LN1@deflate_hu:

; 1833 :     return flush == Z_FINISH ? finish_done : block_done;

  002c1	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  002c6	75 0a		 jne	 SHORT $LN21@deflate_hu
  002c8	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv189[rsp], 3
  002d0	eb 08		 jmp	 SHORT $LN22@deflate_hu
$LN21@deflate_hu:
  002d2	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv189[rsp], 1
$LN22@deflate_hu:
  002da	8b 44 24 4c	 mov	 eax, DWORD PTR tv189[rsp]
$LN9@deflate_hu:

; 1834 : }

  002de	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002e2	c3		 ret	 0
deflate_huff ENDP
_TEXT	ENDS
END
