; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BA@BMMFNEOG@sys?4thread_info?$AA@	; `string'
PUBLIC	??_C@_0CH@KAFBKKBP@name?5and?5version?5of?5the?5thread?5l@ ; `string'
PUBLIC	??_C@_07CPCPJPKL@version?$AA@			; `string'
PUBLIC	??_C@_0CA@FJHANMOC@name?5of?5the?5lock?5implementation?$AA@ ; `string'
PUBLIC	??_C@_04MKMCLCOO@lock?$AA@			; `string'
PUBLIC	??_C@_0CC@CBIIPCCD@name?5of?5the?5thread?5implementatio@ ; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
_BSS	SEGMENT
thread_debug DD	01H DUP (?)
	ALIGN	8

_pythread_stacksize DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BA@BMMFNEOG@sys?4thread_info?$AA@
CONST	SEGMENT
??_C@_0BA@BMMFNEOG@sys?4thread_info?$AA@ DB 'sys.thread_info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KAFBKKBP@name?5and?5version?5of?5the?5thread?5l@
CONST	SEGMENT
??_C@_0CH@KAFBKKBP@name?5and?5version?5of?5the?5thread?5l@ DB 'name and v'
	DB	'ersion of the thread library', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPCPJPKL@version?$AA@
CONST	SEGMENT
??_C@_07CPCPJPKL@version?$AA@ DB 'version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FJHANMOC@name?5of?5the?5lock?5implementation?$AA@
CONST	SEGMENT
??_C@_0CA@FJHANMOC@name?5of?5the?5lock?5implementation?$AA@ DB 'name of t'
	DB	'he lock implementation', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKMCLCOO@lock?$AA@
CONST	SEGMENT
??_C@_04MKMCLCOO@lock?$AA@ DB 'lock', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@CBIIPCCD@name?5of?5the?5thread?5implementatio@
CONST	SEGMENT
??_C@_0CC@CBIIPCCD@name?5of?5the?5thread?5implementatio@ DB 'name of the '
	DB	'thread implementation', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
threadinfo__doc__ DB 'sys.thread_info', 0aH, 0aH, 'A struct sequence hold'
	DB	'ing information about the thread implementation.', 00H
	ORG $+8
threadinfo_fields DQ FLAT:??_C@_04MEMAJGDJ@name?$AA@
	DQ	FLAT:??_C@_0CC@CBIIPCCD@name?5of?5the?5thread?5implementatio@
	DQ	FLAT:??_C@_04MKMCLCOO@lock?$AA@
	DQ	FLAT:??_C@_0CA@FJHANMOC@name?5of?5the?5lock?5implementation?$AA@
	DQ	FLAT:??_C@_07CPCPJPKL@version?$AA@
	DQ	FLAT:??_C@_0CH@KAFBKKBP@name?5and?5version?5of?5the?5thread?5l@
	DQ	0000000000000000H
	ORG $+8
threadinfo_desc DQ FLAT:??_C@_0BA@BMMFNEOG@sys?4thread_info?$AA@
	DQ	FLAT:threadinfo__doc__
	DQ	FLAT:threadinfo_fields
	DD	03H
	ORG $+4
_DATA	ENDS
PUBLIC	??_C@_0BN@FEMMLDGG@PyThread_init_thread?5called?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@KBNOKJAK@PYTHONTHREADDEBUG?$AA@	; `string'
PUBLIC	PyThread_init_thread
EXTRN	__imp_printf:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_getenv:PROC
EXTRN	Py_IgnoreEnvironmentFlag:DWORD
_BSS	SEGMENT
initialized DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\python\thread.c
pdata	SEGMENT
$pdata$PyThread_init_thread DD imagerel $LN10
	DD	imagerel $LN10+158
	DD	imagerel $unwind$PyThread_init_thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_init_thread DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0BN@FEMMLDGG@PyThread_init_thread?5called?6?$AA@
CONST	SEGMENT
??_C@_0BN@FEMMLDGG@PyThread_init_thread?5called?6?$AA@ DB 'PyThread_init_'
	DB	'thread called', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBNOKJAK@PYTHONTHREADDEBUG?$AA@
CONST	SEGMENT
??_C@_0BC@KBNOKJAK@PYTHONTHREADDEBUG?$AA@ DB 'PYTHONTHREADDEBUG', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyThread_init_thread
_TEXT	SEGMENT
p$ = 32
tv67 = 40
PyThread_init_thread PROC				; COMDAT

; 61   : {

$LN10:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 62   : #ifdef Py_DEBUG
; 63   :     char *p = Py_GETENV("PYTHONTHREADDEBUG");

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  0000b	74 0b		 je	 SHORT $LN7@PyThread_i
  0000d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv67[rsp], 0
  00016	eb 12		 jmp	 SHORT $LN8@PyThread_i
$LN7@PyThread_i:
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@KBNOKJAK@PYTHONTHREADDEBUG?$AA@
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  00025	48 89 44 24 28	 mov	 QWORD PTR tv67[rsp], rax
$LN8@PyThread_i:
  0002a	48 8b 44 24 28	 mov	 rax, QWORD PTR tv67[rsp]
  0002f	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 64   : 
; 65   :     if (p) {

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$[rsp], 0
  0003a	74 29		 je	 SHORT $LN4@PyThread_i

; 66   :         if (*p)

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00041	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00044	85 c0		 test	 eax, eax
  00046	74 13		 je	 SHORT $LN3@PyThread_i

; 67   :             thread_debug = atoi(p);

  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00053	89 05 00 00 00
	00		 mov	 DWORD PTR thread_debug, eax

; 68   :         else

  00059	eb 0a		 jmp	 SHORT $LN2@PyThread_i
$LN3@PyThread_i:

; 69   :             thread_debug = 1;

  0005b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR thread_debug, 1
$LN2@PyThread_i:
$LN4@PyThread_i:

; 70   :     }
; 71   : #endif /* Py_DEBUG */
; 72   :     if (initialized)

  00065	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR initialized, 0
  0006c	74 02		 je	 SHORT $LN1@PyThread_i

; 73   :         return;

  0006e	eb 29		 jmp	 SHORT $LN5@PyThread_i
$LN1@PyThread_i:

; 74   :     initialized = 1;

  00070	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR initialized, 1

; 75   :     dprintf(("PyThread_init_thread called\n"));

  0007a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  00080	83 e0 01	 and	 eax, 1
  00083	85 c0		 test	 eax, eax
  00085	74 0d		 je	 SHORT $LN9@PyThread_i
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@FEMMLDGG@PyThread_init_thread?5called?6?$AA@
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN9@PyThread_i:

; 76   :     PyThread__init_thread();

  00094	e8 00 00 00 00	 call	 PyThread__init_thread
$LN5@PyThread_i:

; 77   : }

  00099	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009d	c3		 ret	 0
PyThread_init_thread ENDP
_TEXT	ENDS
PUBLIC	AllocNonRecursiveMutex
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\thread_nt.h
pdata	SEGMENT
$pdata$AllocNonRecursiveMutex DD imagerel $LN6
	DD	imagerel $LN6+125
	DD	imagerel $unwind$AllocNonRecursiveMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AllocNonRecursiveMutex DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT AllocNonRecursiveMutex
_TEXT	SEGMENT
m$ = 32
AllocNonRecursiveMutex PROC				; COMDAT

; 36   : {

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 37   :     PNRMUTEX m = (PNRMUTEX)malloc(sizeof(NRMUTEX));

  00004	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0000f	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 38   :     if (!m)

  00014	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  0001a	75 04		 jne	 SHORT $LN3@AllocNonRe

; 39   :         return NULL;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 58		 jmp	 SHORT $LN4@AllocNonRe
$LN3@AllocNonRe:

; 40   :     if (PyCOND_INIT(&m->cv))

  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00025	48 83 c0 28	 add	 rax, 40			; 00000028H
  00029	48 8b c8	 mov	 rcx, rax
  0002c	e8 00 00 00 00	 call	 PyCOND_INIT
  00031	85 c0		 test	 eax, eax
  00033	74 02		 je	 SHORT $LN2@AllocNonRe

; 41   :         goto fail;

  00035	eb 34		 jmp	 SHORT $fail$120861
$LN2@AllocNonRe:

; 42   :     if (PyMUTEX_INIT(&m->cs)) {

  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  0003c	e8 00 00 00 00	 call	 PyMUTEX_INIT
  00041	85 c0		 test	 eax, eax
  00043	74 13		 je	 SHORT $LN1@AllocNonRe

; 43   :         PyCOND_FINI(&m->cv);

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0004a	48 83 c0 28	 add	 rax, 40			; 00000028H
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 PyCOND_FINI

; 44   :         goto fail;

  00056	eb 13		 jmp	 SHORT $fail$120861
$LN1@AllocNonRe:

; 45   :     }
; 46   :     m->locked = 0;

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0005d	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 47   :     return m;

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00069	eb 0d		 jmp	 SHORT $LN4@AllocNonRe
$fail$120861:

; 48   : fail:
; 49   :     free(m);

  0006b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 50   :     return NULL;

  00076	33 c0		 xor	 eax, eax
$LN4@AllocNonRe:

; 51   : }

  00078	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007c	c3		 ret	 0
AllocNonRecursiveMutex ENDP
_TEXT	ENDS
EXTRN	__imp_InitializeCriticalSection:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$PyMUTEX_INIT DD imagerel PyMUTEX_INIT
	DD	imagerel PyMUTEX_INIT+27
	DD	imagerel $unwind$PyMUTEX_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_INIT DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMUTEX_INIT
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_INIT PROC					; COMDAT

; 175  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 176  :     InitializeCriticalSection(cs);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cs$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 177  :     return 0;

  00014	33 c0		 xor	 eax, eax

; 178  : }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
PyMUTEX_INIT ENDP
_TEXT	ENDS
EXTRN	__imp_CreateSemaphoreA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_INIT DD imagerel PyCOND_INIT
	DD	imagerel PyCOND_INIT+73
	DD	imagerel $unwind$PyCOND_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_INIT DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyCOND_INIT
_TEXT	SEGMENT
cv$ = 48
PyCOND_INIT PROC					; COMDAT

; 213  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 214  :     /* A semaphore with a "large" max value,  The positive value
; 215  :      * is only needed to catch those "lost wakeup" events and
; 216  :      * race conditions when a timed wait elapses.
; 217  :      */
; 218  :     cv->sem = CreateSemaphore(NULL, 0, 100000, NULL);

  00009	45 33 c9	 xor	 r9d, r9d
  0000c	41 b8 a0 86 01
	00		 mov	 r8d, 100000		; 000186a0H
  00012	33 d2		 xor	 edx, edx
  00014	33 c9		 xor	 ecx, ecx
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateSemaphoreA
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cv$[rsp]
  00021	48 89 01	 mov	 QWORD PTR [rcx], rax

; 219  :     if (cv->sem==NULL)

  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR cv$[rsp]
  00029	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0002d	75 07		 jne	 SHORT $LN1@PyCOND_INI

; 220  :         return -1;

  0002f	b8 ff ff ff ff	 mov	 eax, -1
  00034	eb 0e		 jmp	 SHORT $LN2@PyCOND_INI
$LN1@PyCOND_INI:

; 221  :     cv->waiting = 0;

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR cv$[rsp]
  0003b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 222  :     return 0;

  00042	33 c0		 xor	 eax, eax
$LN2@PyCOND_INI:

; 223  : }

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
PyCOND_INIT ENDP
_TEXT	ENDS
EXTRN	__imp_CloseHandle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_FINI DD imagerel PyCOND_FINI
	DD	imagerel PyCOND_FINI+54
	DD	imagerel $unwind$PyCOND_FINI
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_FINI DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyCOND_FINI
_TEXT	SEGMENT
tv67 = 32
cv$ = 64
PyCOND_FINI PROC					; COMDAT

; 227  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 228  :     return CloseHandle(cv->sem) ? 0 : -1;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR cv$[rsp]
  0000e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00017	85 c0		 test	 eax, eax
  00019	74 0a		 je	 SHORT $LN3@PyCOND_FIN
  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
  00023	eb 08		 jmp	 SHORT $LN4@PyCOND_FIN
$LN3@PyCOND_FIN:
  00025	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR tv67[rsp], -1
$LN4@PyCOND_FIN:
  0002d	8b 44 24 20	 mov	 eax, DWORD PTR tv67[rsp]

; 229  : }

  00031	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00035	c3		 ret	 0
PyCOND_FINI ENDP
_TEXT	ENDS
PUBLIC	FreeNonRecursiveMutex
;	COMDAT pdata
; File c:\src\pyparallel\python\thread_nt.h
pdata	SEGMENT
$pdata$FreeNonRecursiveMutex DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$FreeNonRecursiveMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FreeNonRecursiveMutex DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT FreeNonRecursiveMutex
_TEXT	SEGMENT
mutex$ = 48
FreeNonRecursiveMutex PROC				; COMDAT

; 55   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 56   :     if (mutex) {

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR mutex$[rsp], 0
  0000f	74 26		 je	 SHORT $LN1@FreeNonRec

; 57   :         PyCOND_FINI(&mutex->cv);

  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR mutex$[rsp]
  00016	48 83 c0 28	 add	 rax, 40			; 00000028H
  0001a	48 8b c8	 mov	 rcx, rax
  0001d	e8 00 00 00 00	 call	 PyCOND_FINI

; 58   :         PyMUTEX_FINI(&mutex->cs);

  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mutex$[rsp]
  00027	e8 00 00 00 00	 call	 PyMUTEX_FINI

; 59   :         free(mutex);

  0002c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mutex$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@FreeNonRec:

; 60   :     }
; 61   : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
FreeNonRecursiveMutex ENDP
_TEXT	ENDS
EXTRN	__imp_DeleteCriticalSection:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$PyMUTEX_FINI DD imagerel PyMUTEX_FINI
	DD	imagerel PyMUTEX_FINI+27
	DD	imagerel $unwind$PyMUTEX_FINI
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_FINI DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMUTEX_FINI
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_FINI PROC					; COMDAT

; 182  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 183  :     DeleteCriticalSection(cs);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cs$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 184  :     return 0;

  00014	33 c0		 xor	 eax, eax

; 185  : }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
PyMUTEX_FINI ENDP
_TEXT	ENDS
PUBLIC	EnterNonRecursiveMutex
EXTRN	__imp_GetTickCount:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\thread_nt.h
pdata	SEGMENT
$pdata$EnterNonRecursiveMutex DD imagerel $LN17
	DD	imagerel $LN17+288
	DD	imagerel $unwind$EnterNonRecursiveMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$EnterNonRecursiveMutex DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT EnterNonRecursiveMutex
_TEXT	SEGMENT
result$ = 32
now$120887 = 36
target$120888 = 40
mutex$ = 64
milliseconds$ = 72
EnterNonRecursiveMutex PROC				; COMDAT

; 65   : {

$LN17:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 66   :     DWORD result = WAIT_OBJECT_0;

  0000d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 67   :     if (PyMUTEX_LOCK(&mutex->cs))

  00015	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mutex$[rsp]
  0001a	e8 00 00 00 00	 call	 PyMUTEX_LOCK
  0001f	85 c0		 test	 eax, eax
  00021	74 0a		 je	 SHORT $LN14@EnterNonRe

; 68   :         return WAIT_FAILED;

  00023	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00028	e9 ee 00 00 00	 jmp	 $LN15@EnterNonRe
$LN14@EnterNonRe:

; 69   :     if (milliseconds == INFINITE) {

  0002d	83 7c 24 48 ff	 cmp	 DWORD PTR milliseconds$[rsp], -1 ; ffffffffH
  00032	75 33		 jne	 SHORT $LN13@EnterNonRe
$LN12@EnterNonRe:

; 70   :         while (mutex->locked) {

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR mutex$[rsp]
  00039	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0003d	74 26		 je	 SHORT $LN11@EnterNonRe

; 71   :             if (PyCOND_WAIT(&mutex->cv, &mutex->cs)) {

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR mutex$[rsp]
  00044	48 83 c0 28	 add	 rax, 40			; 00000028H
  00048	48 8b 54 24 40	 mov	 rdx, QWORD PTR mutex$[rsp]
  0004d	48 8b c8	 mov	 rcx, rax
  00050	e8 00 00 00 00	 call	 PyCOND_WAIT
  00055	85 c0		 test	 eax, eax
  00057	74 0a		 je	 SHORT $LN10@EnterNonRe

; 72   :                 result = WAIT_FAILED;

  00059	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR result$[rsp], -1 ; ffffffffH

; 73   :                 break;

  00061	eb 02		 jmp	 SHORT $LN11@EnterNonRe
$LN10@EnterNonRe:

; 74   :             }
; 75   :         }

  00063	eb cf		 jmp	 SHORT $LN12@EnterNonRe
$LN11@EnterNonRe:

; 76   :     } else if (milliseconds != 0) {

  00065	eb 76		 jmp	 SHORT $LN9@EnterNonRe
$LN13@EnterNonRe:
  00067	83 7c 24 48 00	 cmp	 DWORD PTR milliseconds$[rsp], 0
  0006c	74 6f		 je	 SHORT $LN8@EnterNonRe

; 77   :         /* wait at least until the target */
; 78   :         DWORD now, target = GetTickCount() + milliseconds;

  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  00074	03 44 24 48	 add	 eax, DWORD PTR milliseconds$[rsp]
  00078	89 44 24 28	 mov	 DWORD PTR target$120888[rsp], eax
$LN7@EnterNonRe:

; 79   :         while (mutex->locked) {

  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR mutex$[rsp]
  00081	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  00085	74 56		 je	 SHORT $LN6@EnterNonRe

; 80   :             if (PyCOND_TIMEDWAIT(&mutex->cv, &mutex->cs, milliseconds*1000) < 0) {

  00087	8b 44 24 48	 mov	 eax, DWORD PTR milliseconds$[rsp]
  0008b	69 c0 e8 03 00
	00		 imul	 eax, 1000		; 000003e8H
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mutex$[rsp]
  00096	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0009a	44 8b c0	 mov	 r8d, eax
  0009d	48 8b 54 24 40	 mov	 rdx, QWORD PTR mutex$[rsp]
  000a2	e8 00 00 00 00	 call	 PyCOND_TIMEDWAIT
  000a7	85 c0		 test	 eax, eax
  000a9	7d 0a		 jge	 SHORT $LN5@EnterNonRe

; 81   :                 result = WAIT_FAILED;

  000ab	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR result$[rsp], -1 ; ffffffffH

; 82   :                 break;

  000b3	eb 28		 jmp	 SHORT $LN6@EnterNonRe
$LN5@EnterNonRe:

; 83   :             }
; 84   :             now = GetTickCount();

  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  000bb	89 44 24 24	 mov	 DWORD PTR now$120887[rsp], eax

; 85   :             if (target <= now)

  000bf	8b 44 24 24	 mov	 eax, DWORD PTR now$120887[rsp]
  000c3	39 44 24 28	 cmp	 DWORD PTR target$120888[rsp], eax
  000c7	77 02		 ja	 SHORT $LN4@EnterNonRe

; 86   :                 break;

  000c9	eb 12		 jmp	 SHORT $LN6@EnterNonRe
$LN4@EnterNonRe:

; 87   :             milliseconds = target-now;

  000cb	8b 44 24 24	 mov	 eax, DWORD PTR now$120887[rsp]
  000cf	8b 4c 24 28	 mov	 ecx, DWORD PTR target$120888[rsp]
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 48	 mov	 DWORD PTR milliseconds$[rsp], eax

; 88   :         }

  000db	eb 9f		 jmp	 SHORT $LN7@EnterNonRe
$LN6@EnterNonRe:
$LN8@EnterNonRe:
$LN9@EnterNonRe:

; 89   :     }
; 90   :     if (!mutex->locked) {

  000dd	48 8b 44 24 40	 mov	 rax, QWORD PTR mutex$[rsp]
  000e2	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  000e6	75 16		 jne	 SHORT $LN3@EnterNonRe

; 91   :         mutex->locked = 1;

  000e8	48 8b 44 24 40	 mov	 rax, QWORD PTR mutex$[rsp]
  000ed	c7 40 38 01 00
	00 00		 mov	 DWORD PTR [rax+56], 1

; 92   :         result = WAIT_OBJECT_0;

  000f4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0
  000fc	eb 0f		 jmp	 SHORT $LN2@EnterNonRe
$LN3@EnterNonRe:

; 93   :     } else if (result == WAIT_OBJECT_0)

  000fe	83 7c 24 20 00	 cmp	 DWORD PTR result$[rsp], 0
  00103	75 08		 jne	 SHORT $LN1@EnterNonRe

; 94   :         result = WAIT_TIMEOUT;

  00105	c7 44 24 20 02
	01 00 00	 mov	 DWORD PTR result$[rsp], 258 ; 00000102H
$LN1@EnterNonRe:
$LN2@EnterNonRe:

; 95   :     /* else, it is WAIT_FAILED */
; 96   :     PyMUTEX_UNLOCK(&mutex->cs); /* must ignore result here */

  0010d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mutex$[rsp]
  00112	e8 00 00 00 00	 call	 PyMUTEX_UNLOCK

; 97   :     return result;

  00117	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN15@EnterNonRe:

; 98   : }

  0011b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011f	c3		 ret	 0
EnterNonRecursiveMutex ENDP
_TEXT	ENDS
EXTRN	__imp_EnterCriticalSection:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$PyMUTEX_LOCK DD imagerel PyMUTEX_LOCK
	DD	imagerel PyMUTEX_LOCK+27
	DD	imagerel $unwind$PyMUTEX_LOCK
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_LOCK DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMUTEX_LOCK
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_LOCK PROC					; COMDAT

; 189  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 190  :     EnterCriticalSection(cs);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cs$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 191  :     return 0;

  00014	33 c0		 xor	 eax, eax

; 192  : }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
PyMUTEX_LOCK ENDP
_TEXT	ENDS
EXTRN	__imp_LeaveCriticalSection:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMUTEX_UNLOCK DD imagerel PyMUTEX_UNLOCK
	DD	imagerel PyMUTEX_UNLOCK+27
	DD	imagerel $unwind$PyMUTEX_UNLOCK
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_UNLOCK DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMUTEX_UNLOCK
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_UNLOCK PROC					; COMDAT

; 196  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 197  :     LeaveCriticalSection(cs);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cs$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 198  :     return 0;

  00014	33 c0		 xor	 eax, eax

; 199  : }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
PyMUTEX_UNLOCK ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_WAIT DD imagerel PyCOND_WAIT
	DD	imagerel PyCOND_WAIT+73
	DD	imagerel $unwind$PyCOND_WAIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_WAIT DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyCOND_WAIT
_TEXT	SEGMENT
result$ = 32
tv69 = 36
cv$ = 64
cs$ = 72
PyCOND_WAIT PROC					; COMDAT

; 267  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 268  :     int result = _PyCOND_WAIT_MS(cv, cs, INFINITE);

  0000e	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  00014	48 8b 54 24 48	 mov	 rdx, QWORD PTR cs$[rsp]
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cv$[rsp]
  0001e	e8 00 00 00 00	 call	 _PyCOND_WAIT_MS
  00023	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 269  :     return result >= 0 ? 0 : result;

  00027	83 7c 24 20 00	 cmp	 DWORD PTR result$[rsp], 0
  0002c	7c 0a		 jl	 SHORT $LN3@PyCOND_WAI
  0002e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  00036	eb 08		 jmp	 SHORT $LN4@PyCOND_WAI
$LN3@PyCOND_WAI:
  00038	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
  0003c	89 44 24 24	 mov	 DWORD PTR tv69[rsp], eax
$LN4@PyCOND_WAI:
  00040	8b 44 24 24	 mov	 eax, DWORD PTR tv69[rsp]

; 270  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
PyCOND_WAIT ENDP
_TEXT	ENDS
EXTRN	__imp_WaitForSingleObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyCOND_WAIT_MS DD imagerel _PyCOND_WAIT_MS
	DD	imagerel _PyCOND_WAIT_MS+152
	DD	imagerel $unwind$_PyCOND_WAIT_MS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyCOND_WAIT_MS DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyCOND_WAIT_MS
_TEXT	SEGMENT
wait$ = 32
tv79 = 36
cv$ = 64
cs$ = 72
ms$ = 80
_PyCOND_WAIT_MS PROC					; COMDAT

; 236  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 237  :     DWORD wait;
; 238  :     cv->waiting++;

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR cv$[rsp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0001b	ff c0		 inc	 eax
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cv$[rsp]
  00022	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 239  :     PyMUTEX_UNLOCK(cs);

  00025	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cs$[rsp]
  0002a	e8 00 00 00 00	 call	 PyMUTEX_UNLOCK

; 240  :     /* "lost wakeup bug" would occur if the caller were interrupted here,
; 241  :      * but we are safe because we are using a semaphore wich has an internal
; 242  :      * count.
; 243  :      */
; 244  :     wait = WaitForSingleObject(cv->sem, ms);

  0002f	8b 54 24 50	 mov	 edx, DWORD PTR ms$[rsp]
  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR cv$[rsp]
  00038	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  00041	89 44 24 20	 mov	 DWORD PTR wait$[rsp], eax

; 245  :     PyMUTEX_LOCK(cs);

  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cs$[rsp]
  0004a	e8 00 00 00 00	 call	 PyMUTEX_LOCK

; 246  :     if (wait != WAIT_OBJECT_0)

  0004f	83 7c 24 20 00	 cmp	 DWORD PTR wait$[rsp], 0
  00054	74 12		 je	 SHORT $LN2@PyCOND_WAI@2

; 247  :         --cv->waiting;

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR cv$[rsp]
  0005b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0005e	ff c8		 dec	 eax
  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cv$[rsp]
  00065	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN2@PyCOND_WAI@2:

; 248  :         /* Here we have a benign race condition with PyCOND_SIGNAL.
; 249  :          * When failure occurs or timeout, it is possible that
; 250  :          * PyCOND_SIGNAL also decrements this value
; 251  :          * and signals releases the mutex.  This is benign because it
; 252  :          * just means an extra spurious wakeup for a waiting thread.
; 253  :          * ('waiting' corresponds to the semaphore's "negative" count and
; 254  :          * we may end up with e.g. (waiting == -1 && sem.count == 1).  When
; 255  :          * a new thread comes along, it will pass right throuhgh, having
; 256  :          * adjusted it to (waiting == 0 && sem.count == 0).
; 257  :          */
; 258  :          
; 259  :     if (wait == WAIT_FAILED)

  00068	83 7c 24 20 ff	 cmp	 DWORD PTR wait$[rsp], -1 ; ffffffffH
  0006d	75 07		 jne	 SHORT $LN1@PyCOND_WAI@2

; 260  :         return -1;

  0006f	b8 ff ff ff ff	 mov	 eax, -1
  00074	eb 1d		 jmp	 SHORT $LN3@PyCOND_WAI@2
$LN1@PyCOND_WAI@2:

; 261  :     /* return 0 on success, 1 on timeout */
; 262  :     return wait != WAIT_OBJECT_0;

  00076	83 7c 24 20 00	 cmp	 DWORD PTR wait$[rsp], 0
  0007b	74 0a		 je	 SHORT $LN5@PyCOND_WAI@2
  0007d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00085	eb 08		 jmp	 SHORT $LN6@PyCOND_WAI@2
$LN5@PyCOND_WAI@2:
  00087	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN6@PyCOND_WAI@2:
  0008f	8b 44 24 24	 mov	 eax, DWORD PTR tv79[rsp]
$LN3@PyCOND_WAI@2:

; 263  : }

  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
_PyCOND_WAIT_MS ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_TIMEDWAIT DD imagerel PyCOND_TIMEDWAIT
	DD	imagerel PyCOND_TIMEDWAIT+54
	DD	imagerel $unwind$PyCOND_TIMEDWAIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_TIMEDWAIT DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyCOND_TIMEDWAIT
_TEXT	SEGMENT
cv$ = 48
cs$ = 56
us$ = 64
PyCOND_TIMEDWAIT PROC					; COMDAT

; 274  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 275  :     return _PyCOND_WAIT_MS(cv, cs, us/1000);

  00013	8b 44 24 40	 mov	 eax, DWORD PTR us$[rsp]
  00017	99		 cdq
  00018	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0001d	f7 f9		 idiv	 ecx
  0001f	44 8b c0	 mov	 r8d, eax
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR cs$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cv$[rsp]
  0002c	e8 00 00 00 00	 call	 _PyCOND_WAIT_MS

; 276  : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
PyCOND_TIMEDWAIT ENDP
_TEXT	ENDS
PUBLIC	LeaveNonRecursiveMutex
;	COMDAT pdata
; File c:\src\pyparallel\python\thread_nt.h
pdata	SEGMENT
$pdata$LeaveNonRecursiveMutex DD imagerel $LN4
	DD	imagerel $LN4+91
	DD	imagerel $unwind$LeaveNonRecursiveMutex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LeaveNonRecursiveMutex DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT LeaveNonRecursiveMutex
_TEXT	SEGMENT
result$ = 32
mutex$ = 64
LeaveNonRecursiveMutex PROC				; COMDAT

; 102  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 103  :     BOOL result;
; 104  :     if (PyMUTEX_LOCK(&mutex->cs))

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mutex$[rsp]
  0000e	e8 00 00 00 00	 call	 PyMUTEX_LOCK
  00013	85 c0		 test	 eax, eax
  00015	74 04		 je	 SHORT $LN1@LeaveNonRe

; 105  :         return FALSE;

  00017	33 c0		 xor	 eax, eax
  00019	eb 3b		 jmp	 SHORT $LN2@LeaveNonRe
$LN1@LeaveNonRe:

; 106  :     mutex->locked = 0;

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR mutex$[rsp]
  00020	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 107  :     result = PyCOND_SIGNAL(&mutex->cv);

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR mutex$[rsp]
  0002c	48 83 c0 28	 add	 rax, 40			; 00000028H
  00030	48 8b c8	 mov	 rcx, rax
  00033	e8 00 00 00 00	 call	 PyCOND_SIGNAL
  00038	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 108  :     result &= PyMUTEX_UNLOCK(&mutex->cs);

  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mutex$[rsp]
  00041	e8 00 00 00 00	 call	 PyMUTEX_UNLOCK
  00046	8b 4c 24 20	 mov	 ecx, DWORD PTR result$[rsp]
  0004a	23 c8		 and	 ecx, eax
  0004c	8b c1		 mov	 eax, ecx
  0004e	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 109  :     return result;

  00052	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN2@LeaveNonRe:

; 110  : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
LeaveNonRecursiveMutex ENDP
_TEXT	ENDS
EXTRN	__imp_ReleaseSemaphore:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$PyCOND_SIGNAL DD imagerel PyCOND_SIGNAL
	DD	imagerel PyCOND_SIGNAL+95
	DD	imagerel $unwind$PyCOND_SIGNAL
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_SIGNAL DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyCOND_SIGNAL
_TEXT	SEGMENT
tv75 = 32
cv$ = 64
PyCOND_SIGNAL PROC					; COMDAT

; 280  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 281  :     /* this test allows PyCOND_SIGNAL to be a no-op unless required
; 282  :      * to wake someone up, thus preventing an unbounded increase of
; 283  :      * the semaphore's internal counter.
; 284  :      */
; 285  :     if (cv->waiting > 0) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR cv$[rsp]
  0000e	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00012	7e 44		 jle	 SHORT $LN1@PyCOND_SIG

; 286  :         /* notifying thread decreases the cv->waiting count so that
; 287  :          * a delay between notify and actual wakeup of the target thread
; 288  :          * doesn't cause a number of extra ReleaseSemaphore calls.
; 289  :          */
; 290  :         cv->waiting--;

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR cv$[rsp]
  00019	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0001c	ff c8		 dec	 eax
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cv$[rsp]
  00023	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 291  :         return ReleaseSemaphore(cv->sem, 1, NULL) ? 0 : -1;

  00026	45 33 c0	 xor	 r8d, r8d
  00029	ba 01 00 00 00	 mov	 edx, 1
  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR cv$[rsp]
  00033	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
  0003c	85 c0		 test	 eax, eax
  0003e	74 0a		 je	 SHORT $LN4@PyCOND_SIG
  00040	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  00048	eb 08		 jmp	 SHORT $LN5@PyCOND_SIG
$LN4@PyCOND_SIG:
  0004a	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR tv75[rsp], -1
$LN5@PyCOND_SIG:
  00052	8b 44 24 20	 mov	 eax, DWORD PTR tv75[rsp]
  00056	eb 02		 jmp	 SHORT $LN2@PyCOND_SIG
$LN1@PyCOND_SIG:

; 292  :     }
; 293  :     return 0;

  00058	33 c0		 xor	 eax, eax
$LN2@PyCOND_SIG:

; 294  : }

  0005a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005e	c3		 ret	 0
PyCOND_SIGNAL ENDP
; Function compile flags: /Odtp
; File c:\src\pyparallel\python\thread_nt.h
_TEXT	ENDS
;	COMDAT PyThread__init_thread
_TEXT	SEGMENT
PyThread__init_thread PROC				; COMDAT

; 151  : }

  00000	c3		 ret	 0
PyThread__init_thread ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@NOGFBENP@?$CFld?3?5PyThread_start_new_thread?5s@ ; `string'
PUBLIC	??_C@_0DB@FHNFCLAD@?$CFld?3?5PyThread_start_new_thread?5f@ ; `string'
PUBLIC	??_C@_1JC@KIOODEIE@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AA_?$AAp?$AAy?$AAt?$AAh@ ; `string'
PUBLIC	??_C@_1EK@IENPHKJG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_@ ; `string'
PUBLIC	??_C@_0CH@OENMMLIC@?$CFld?3?5PyThread_start_new_thread?5c@ ; `string'
PUBLIC	PyThread_get_thread_ident
PUBLIC	PyThread_start_new_thread
EXTRN	__imp_HeapFree:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp__beginthreadex:PROC
EXTRN	__imp__wassert:PROC
EXTRN	__imp_HeapAlloc:PROC
EXTRN	__imp_GetProcessHeap:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_start_new_thread DD imagerel $LN11
	DD	imagerel $LN11+374
	DD	imagerel $unwind$PyThread_start_new_thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_start_new_thread DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0CO@NOGFBENP@?$CFld?3?5PyThread_start_new_thread?5s@
CONST	SEGMENT
??_C@_0CO@NOGFBENP@?$CFld?3?5PyThread_start_new_thread?5s@ DB '%ld: PyThr'
	DB	'ead_start_new_thread succeeded: %p', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@FHNFCLAD@?$CFld?3?5PyThread_start_new_thread?5f@
CONST	SEGMENT
??_C@_0DB@FHNFCLAD@?$CFld?3?5PyThread_start_new_thread?5f@ DB '%ld: PyThr'
	DB	'ead_start_new_thread failed, errno %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JC@KIOODEIE@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AA_?$AAp?$AAy?$AAt?$AAh@
CONST	SEGMENT
??_C@_1JC@KIOODEIE@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AA_?$AAp?$AAy?$AAt?$AAh@ DB '('
	DB	00H, 'P', 00H, 'y', 00H, '_', 00H, 's', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H, 'u'
	DB	00H, 'n', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H
	DB	'd', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, ')', 00H, '('
	DB	00H, '_', 00H, 'p', 00H, 'y', 00H, 't', 00H, 'h', 00H, 'r', 00H
	DB	'e', 00H, 'a', 00H, 'd', 00H, '_', 00H, 's', 00H, 't', 00H, 'a'
	DB	00H, 'c', 00H, 'k', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '_'
	DB	00H, 'p', 00H, 'y', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 'd', 00H, '_', 00H, 's', 00H, 't', 00H, 'a', 00H, 'c'
	DB	00H, 'k', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@IENPHKJG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_@
CONST	SEGMENT
??_C@_1EK@IENPHKJG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'p', 00H, 'y', 00H
	DB	't', 00H, 'h', 00H, 'o', 00H, 'n', 00H, '\', 00H, 't', 00H, 'h'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, '_', 00H, 'n', 00H
	DB	't', 00H, '.', 00H, 'h', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OENMMLIC@?$CFld?3?5PyThread_start_new_thread?5c@
CONST	SEGMENT
??_C@_0CH@OENMMLIC@?$CFld?3?5PyThread_start_new_thread?5c@ DB '%ld: PyThr'
	DB	'ead_start_new_thread called', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyThread_start_new_thread
_TEXT	SEGMENT
threadID$ = 48
hThread$ = 56
obj$ = 64
e$120945 = 72
func$ = 96
arg$ = 104
PyThread_start_new_thread PROC				; COMDAT

; 181  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 182  :     HANDLE hThread;
; 183  :     unsigned threadID;
; 184  :     callobj *obj;
; 185  : 
; 186  :     dprintf(("%ld: PyThread_start_new_thread called\n",
; 187  :              PyThread_get_thread_ident()));

  0000e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	74 14		 je	 SHORT $LN7@PyThread_s
  0001b	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00020	8b d0		 mov	 edx, eax
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@OENMMLIC@?$CFld?3?5PyThread_start_new_thread?5c@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN7@PyThread_s:

; 188  :     if (!initialized)

  0002f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR initialized, 0
  00036	75 05		 jne	 SHORT $LN4@PyThread_s

; 189  :         PyThread_init_thread();

  00038	e8 00 00 00 00	 call	 PyThread_init_thread
$LN4@PyThread_s:

; 190  : 
; 191  :     obj = (callobj*)HeapAlloc(GetProcessHeap(), 0, sizeof(*obj));

  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcessHeap
  00043	41 b8 10 00 00
	00		 mov	 r8d, 16
  00049	33 d2		 xor	 edx, edx
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_HeapAlloc
  00054	48 89 44 24 40	 mov	 QWORD PTR obj$[rsp], rax

; 192  :     if (!obj)

  00059	48 83 7c 24 40
	00		 cmp	 QWORD PTR obj$[rsp], 0
  0005f	75 0a		 jne	 SHORT $LN3@PyThread_s

; 193  :         return -1;

  00061	b8 ff ff ff ff	 mov	 eax, -1
  00066	e9 06 01 00 00	 jmp	 $LN5@PyThread_s
$LN3@PyThread_s:

; 194  :     obj->func = func;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  00070	48 8b 4c 24 60	 mov	 rcx, QWORD PTR func$[rsp]
  00075	48 89 08	 mov	 QWORD PTR [rax], rcx

; 195  :     obj->arg = arg;

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  0007d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR arg$[rsp]
  00082	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 196  : #if defined(MS_WINCE)
; 197  :     hThread = CreateThread(NULL,
; 198  :                            Py_SAFE_DOWNCAST(_pythread_stacksize, Py_ssize_t, SIZE_T),
; 199  :                            bootstrap, obj, 0, &threadID);
; 200  : #else
; 201  :     hThread = (HANDLE)_beginthreadex(0,
; 202  :                       Py_SAFE_DOWNCAST(_pythread_stacksize,
; 203  :                                        Py_ssize_t, unsigned int),
; 204  :                       bootstrap, obj,
; 205  :                       0, &threadID);

  00086	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _pythread_stacksize
  0008c	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR _pythread_stacksize
  00093	74 1c		 je	 SHORT $LN8@PyThread_s
  00095	41 b8 cb 00 00
	00		 mov	 r8d, 203		; 000000cbH
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EK@IENPHKJG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_@
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JC@KIOODEIE@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AA_?$AAp?$AAy?$AAt?$AAh@
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000af	33 c0		 xor	 eax, eax
$LN8@PyThread_s:
  000b1	48 8d 44 24 30	 lea	 rax, QWORD PTR threadID$[rsp]
  000b6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000bb	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  000c3	4c 8b 4c 24 40	 mov	 r9, QWORD PTR obj$[rsp]
  000c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:bootstrap
  000cf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _pythread_stacksize
  000d5	33 c9		 xor	 ecx, ecx
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__beginthreadex
  000dd	48 89 44 24 38	 mov	 QWORD PTR hThread$[rsp], rax

; 206  : #endif
; 207  :     if (hThread == 0) {

  000e2	48 83 7c 24 38
	00		 cmp	 QWORD PTR hThread$[rsp], 0
  000e8	75 52		 jne	 SHORT $LN2@PyThread_s

; 208  : #if defined(MS_WINCE)
; 209  :         /* Save error in variable, to prevent PyThread_get_thread_ident
; 210  :            from clobbering it. */
; 211  :         unsigned e = GetLastError();
; 212  :         dprintf(("%ld: PyThread_start_new_thread failed, win32 error code %u\n",
; 213  :                  PyThread_get_thread_ident(), e));
; 214  : #else
; 215  :         /* I've seen errno == EAGAIN here, which means "there are
; 216  :          * too many threads".
; 217  :          */
; 218  :         int e = errno;

  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f0	8b 00		 mov	 eax, DWORD PTR [rax]
  000f2	89 44 24 48	 mov	 DWORD PTR e$120945[rsp], eax

; 219  :         dprintf(("%ld: PyThread_start_new_thread failed, errno %d\n",
; 220  :                  PyThread_get_thread_ident(), e));

  000f6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  000fc	83 e0 01	 and	 eax, 1
  000ff	85 c0		 test	 eax, eax
  00101	74 19		 je	 SHORT $LN9@PyThread_s
  00103	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00108	44 8b 44 24 48	 mov	 r8d, DWORD PTR e$120945[rsp]
  0010d	8b d0		 mov	 edx, eax
  0010f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@FHNFCLAD@?$CFld?3?5PyThread_start_new_thread?5f@
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN9@PyThread_s:

; 221  : #endif
; 222  :         threadID = (unsigned)-1;

  0011c	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR threadID$[rsp], -1 ; ffffffffH

; 223  :         HeapFree(GetProcessHeap(), 0, obj);

  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcessHeap
  0012a	4c 8b 44 24 40	 mov	 r8, QWORD PTR obj$[rsp]
  0012f	33 d2		 xor	 edx, edx
  00131	48 8b c8	 mov	 rcx, rax
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_HeapFree

; 224  :     }
; 225  :     else {

  0013a	eb 31		 jmp	 SHORT $LN1@PyThread_s
$LN2@PyThread_s:

; 226  :         dprintf(("%ld: PyThread_start_new_thread succeeded: %p\n",
; 227  :                  PyThread_get_thread_ident(), (void*)hThread));

  0013c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  00142	83 e0 01	 and	 eax, 1
  00145	85 c0		 test	 eax, eax
  00147	74 19		 je	 SHORT $LN10@PyThread_s
  00149	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0014e	4c 8b 44 24 38	 mov	 r8, QWORD PTR hThread$[rsp]
  00153	8b d0		 mov	 edx, eax
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@NOGFBENP@?$CFld?3?5PyThread_start_new_thread?5s@
  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN10@PyThread_s:

; 228  :         CloseHandle(hThread);

  00162	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hThread$[rsp]
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN1@PyThread_s:

; 229  :     }
; 230  :     return (long) threadID;

  0016d	8b 44 24 30	 mov	 eax, DWORD PTR threadID$[rsp]
$LN5@PyThread_s:

; 231  : }

  00171	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00175	c3		 ret	 0
PyThread_start_new_thread ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bootstrap DD imagerel bootstrap
	DD	imagerel bootstrap+84
	DD	imagerel $unwind$bootstrap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bootstrap DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bootstrap
_TEXT	SEGMENT
arg$ = 32
obj$ = 40
func$ = 48
call$ = 80
bootstrap PROC						; COMDAT

; 170  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 171  :     callobj *obj = (callobj*)call;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR call$[rsp]
  0000e	48 89 44 24 28	 mov	 QWORD PTR obj$[rsp], rax

; 172  :     void (*func)(void*) = obj->func;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR obj$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 30	 mov	 QWORD PTR func$[rsp], rax

; 173  :     void *arg = obj->arg;

  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR obj$[rsp]
  00025	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00029	48 89 44 24 20	 mov	 QWORD PTR arg$[rsp], rax

; 174  :     HeapFree(GetProcessHeap(), 0, obj);

  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcessHeap
  00034	4c 8b 44 24 28	 mov	 r8, QWORD PTR obj$[rsp]
  00039	33 d2		 xor	 edx, edx
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_HeapFree

; 175  :     func(arg);

  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR arg$[rsp]
  00049	ff 54 24 30	 call	 QWORD PTR func$[rsp]

; 176  :     return 0;

  0004d	33 c0		 xor	 eax, eax

; 177  : }

  0004f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00053	c3		 ret	 0
bootstrap ENDP
_TEXT	ENDS
EXTRN	__imp_GetCurrentThreadId:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_get_thread_ident DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$PyThread_get_thread_ident
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_get_thread_ident DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyThread_get_thread_ident
_TEXT	SEGMENT
PyThread_get_thread_ident PROC				; COMDAT

; 239  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 240  :     if (!initialized)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR initialized, 0
  0000b	75 05		 jne	 SHORT $LN1@PyThread_g

; 241  :         PyThread_init_thread();

  0000d	e8 00 00 00 00	 call	 PyThread_init_thread
$LN1@PyThread_g:

; 242  : 
; 243  :     return GetCurrentThreadId();

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId

; 244  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
PyThread_get_thread_ident ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@OMCHPCEJ@?$CFld?3?5PyThread_exit_thread?5called@ ; `string'
PUBLIC	PyThread_exit_thread
EXTRN	__imp__endthreadex:PROC
EXTRN	__imp_exit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_exit_thread DD imagerel $LN5
	DD	imagerel $LN5+67
	DD	imagerel $unwind$PyThread_exit_thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_exit_thread DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CC@OMCHPCEJ@?$CFld?3?5PyThread_exit_thread?5called@
CONST	SEGMENT
??_C@_0CC@OMCHPCEJ@?$CFld?3?5PyThread_exit_thread?5called@ DB '%ld: PyThr'
	DB	'ead_exit_thread called', 0aH, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyThread_exit_thread
_TEXT	SEGMENT
PyThread_exit_thread PROC				; COMDAT

; 248  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 249  :     dprintf(("%ld: PyThread_exit_thread called\n", PyThread_get_thread_ident()));

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  0000a	83 e0 01	 and	 eax, 1
  0000d	85 c0		 test	 eax, eax
  0000f	74 14		 je	 SHORT $LN4@PyThread_e
  00011	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00016	8b d0		 mov	 edx, eax
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@OMCHPCEJ@?$CFld?3?5PyThread_exit_thread?5called@
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN4@PyThread_e:

; 250  :     if (!initialized)

  00025	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR initialized, 0
  0002c	75 08		 jne	 SHORT $LN1@PyThread_e

; 251  :         exit(0);

  0002e	33 c9		 xor	 ecx, ecx
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN1@PyThread_e:

; 252  : #if defined(MS_WINCE)
; 253  :     ExitThread(0);
; 254  : #else
; 255  :     _endthreadex(0);

  00036	33 c9		 xor	 ecx, ecx
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__endthreadex
$LN3@PyThread_e:

; 256  : #endif
; 257  : }

  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00042	c3		 ret	 0
PyThread_exit_thread ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@DGNIMKBK@?$CFld?3?5PyThread_allocate_lock?$CI?$CJ?5?9?$DO@ ; `string'
PUBLIC	??_C@_0BP@BPMFMPAI@PyThread_allocate_lock?5called?6?$AA@ ; `string'
PUBLIC	PyThread_allocate_lock
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_allocate_lock DD imagerel $LN6
	DD	imagerel $LN6+102
	DD	imagerel $unwind$PyThread_allocate_lock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_allocate_lock DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0CF@DGNIMKBK@?$CFld?3?5PyThread_allocate_lock?$CI?$CJ?5?9?$DO@
CONST	SEGMENT
??_C@_0CF@DGNIMKBK@?$CFld?3?5PyThread_allocate_lock?$CI?$CJ?5?9?$DO@ DB '%'
	DB	'ld: PyThread_allocate_lock() -> %p', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BPMFMPAI@PyThread_allocate_lock?5called?6?$AA@
CONST	SEGMENT
??_C@_0BP@BPMFMPAI@PyThread_allocate_lock?5called?6?$AA@ DB 'PyThread_all'
	DB	'ocate_lock called', 0aH, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyThread_allocate_lock
_TEXT	SEGMENT
aLock$ = 32
PyThread_allocate_lock PROC				; COMDAT

; 266  : {

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 267  :     PNRMUTEX aLock;
; 268  : 
; 269  :     dprintf(("PyThread_allocate_lock called\n"));

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  0000a	83 e0 01	 and	 eax, 1
  0000d	85 c0		 test	 eax, eax
  0000f	74 0d		 je	 SHORT $LN4@PyThread_a
  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@BPMFMPAI@PyThread_allocate_lock?5called?6?$AA@
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN4@PyThread_a:

; 270  :     if (!initialized)

  0001e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR initialized, 0
  00025	75 05		 jne	 SHORT $LN1@PyThread_a

; 271  :         PyThread_init_thread();

  00027	e8 00 00 00 00	 call	 PyThread_init_thread
$LN1@PyThread_a:

; 272  : 
; 273  :     aLock = AllocNonRecursiveMutex() ;

  0002c	e8 00 00 00 00	 call	 AllocNonRecursiveMutex
  00031	48 89 44 24 20	 mov	 QWORD PTR aLock$[rsp], rax

; 274  : 
; 275  :     dprintf(("%ld: PyThread_allocate_lock() -> %p\n", PyThread_get_thread_ident(), aLock));

  00036	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	74 19		 je	 SHORT $LN5@PyThread_a
  00043	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00048	4c 8b 44 24 20	 mov	 r8, QWORD PTR aLock$[rsp]
  0004d	8b d0		 mov	 edx, eax
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@DGNIMKBK@?$CFld?3?5PyThread_allocate_lock?$CI?$CJ?5?9?$DO@
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN5@PyThread_a:

; 276  : 
; 277  :     return (PyThread_type_lock) aLock;

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR aLock$[rsp]

; 278  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
PyThread_allocate_lock ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@HHIHKPIL@?$CFld?3?5PyThread_free_lock?$CI?$CFp?$CJ?5call@ ; `string'
PUBLIC	PyThread_free_lock
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_free_lock DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$PyThread_free_lock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_free_lock DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0CE@HHIHKPIL@?$CFld?3?5PyThread_free_lock?$CI?$CFp?$CJ?5call@
CONST	SEGMENT
??_C@_0CE@HHIHKPIL@?$CFld?3?5PyThread_free_lock?$CI?$CFp?$CJ?5call@ DB '%'
	DB	'ld: PyThread_free_lock(%p) called', 0aH, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyThread_free_lock
_TEXT	SEGMENT
aLock$ = 48
PyThread_free_lock PROC					; COMDAT

; 282  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 283  :     dprintf(("%ld: PyThread_free_lock(%p) called\n", PyThread_get_thread_ident(),aLock));

  00009	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  0000f	83 e0 01	 and	 eax, 1
  00012	85 c0		 test	 eax, eax
  00014	74 19		 je	 SHORT $LN3@PyThread_f
  00016	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0001b	4c 8b 44 24 30	 mov	 r8, QWORD PTR aLock$[rsp]
  00020	8b d0		 mov	 edx, eax
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@HHIHKPIL@?$CFld?3?5PyThread_free_lock?$CI?$CFp?$CJ?5call@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN3@PyThread_f:

; 284  : 
; 285  :     FreeNonRecursiveMutex(aLock) ;

  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR aLock$[rsp]
  00034	e8 00 00 00 00	 call	 FreeNonRecursiveMutex

; 286  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
PyThread_free_lock ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@OGFLBHCO@?$CFld?3?5PyThread_acquire_lock?$CI?$CFp?0?5?$CF@ ; `string'
PUBLIC	??_C@_0DD@DBOLABC@?$CFld?3?5PyThread_acquire_lock_timed@ ; `string'
PUBLIC	??_C@_0DL@MFNCOGKO@Timeout?5too?5large?5for?5a?5DWORD?0?5p@ ; `string'
PUBLIC	PyThread_acquire_lock_timed
EXTRN	Py_FatalError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_acquire_lock_timed DD imagerel $LN11
	DD	imagerel $LN11+265
	DD	imagerel $unwind$PyThread_acquire_lock_timed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_acquire_lock_timed DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0CM@OGFLBHCO@?$CFld?3?5PyThread_acquire_lock?$CI?$CFp?0?5?$CF@
CONST	SEGMENT
??_C@_0CM@OGFLBHCO@?$CFld?3?5PyThread_acquire_lock?$CI?$CFp?0?5?$CF@ DB '%'
	DB	'ld: PyThread_acquire_lock(%p, %lld) -> %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@DBOLABC@?$CFld?3?5PyThread_acquire_lock_timed@
CONST	SEGMENT
??_C@_0DD@DBOLABC@?$CFld?3?5PyThread_acquire_lock_timed@ DB '%ld: PyThrea'
	DB	'd_acquire_lock_timed(%p, %lld) called', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MFNCOGKO@Timeout?5too?5large?5for?5a?5DWORD?0?5p@
CONST	SEGMENT
??_C@_0DL@MFNCOGKO@Timeout?5too?5large?5for?5a?5DWORD?0?5p@ DB 'Timeout t'
	DB	'oo large for a DWORD, please check PY_TIMEOUT_MAX', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyThread_acquire_lock_timed
_TEXT	SEGMENT
success$ = 48
milliseconds$ = 56
aLock$ = 80
microseconds$ = 88
intr_flag$ = 96
PyThread_acquire_lock_timed PROC			; COMDAT

; 297  : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 298  :     /* Fow now, intr_flag does nothing on Windows, and lock acquires are
; 299  :      * uninterruptible.  */
; 300  :     PyLockStatus success;
; 301  :     PY_TIMEOUT_T milliseconds;
; 302  : 
; 303  :     if (microseconds >= 0) {

  00013	48 83 7c 24 58
	00		 cmp	 QWORD PTR microseconds$[rsp], 0
  00019	7c 51		 jl	 SHORT $LN6@PyThread_a@2

; 304  :         milliseconds = microseconds / 1000;

  0001b	48 8b 44 24 58	 mov	 rax, QWORD PTR microseconds$[rsp]
  00020	48 99		 cdq
  00022	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00027	48 f7 f9	 idiv	 rcx
  0002a	48 89 44 24 38	 mov	 QWORD PTR milliseconds$[rsp], rax

; 305  :         if (microseconds % 1000 > 0)

  0002f	48 8b 44 24 58	 mov	 rax, QWORD PTR microseconds$[rsp]
  00034	48 99		 cdq
  00036	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0003b	48 f7 f9	 idiv	 rcx
  0003e	48 8b c2	 mov	 rax, rdx
  00041	48 85 c0	 test	 rax, rax
  00044	7e 0d		 jle	 SHORT $LN5@PyThread_a@2

; 306  :             ++milliseconds;

  00046	48 8b 44 24 38	 mov	 rax, QWORD PTR milliseconds$[rsp]
  0004b	48 ff c0	 inc	 rax
  0004e	48 89 44 24 38	 mov	 QWORD PTR milliseconds$[rsp], rax
$LN5@PyThread_a@2:

; 307  :         if ((DWORD) milliseconds != milliseconds)

  00053	8b 44 24 38	 mov	 eax, DWORD PTR milliseconds$[rsp]
  00057	48 3b 44 24 38	 cmp	 rax, QWORD PTR milliseconds$[rsp]
  0005c	74 0c		 je	 SHORT $LN4@PyThread_a@2

; 308  :             Py_FatalError("Timeout too large for a DWORD, "
; 309  :                            "please check PY_TIMEOUT_MAX");

  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DL@MFNCOGKO@Timeout?5too?5large?5for?5a?5DWORD?0?5p@
  00065	e8 00 00 00 00	 call	 Py_FatalError
$LN4@PyThread_a@2:

; 310  :     }
; 311  :     else

  0006a	eb 0a		 jmp	 SHORT $LN3@PyThread_a@2
$LN6@PyThread_a@2:

; 312  :         milliseconds = INFINITE;

  0006c	b8 ff ff ff ff	 mov	 eax, -1
  00071	48 89 44 24 38	 mov	 QWORD PTR milliseconds$[rsp], rax
$LN3@PyThread_a@2:

; 313  : 
; 314  :     dprintf(("%ld: PyThread_acquire_lock_timed(%p, %lld) called\n",
; 315  :              PyThread_get_thread_ident(), aLock, microseconds));

  00076	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  0007c	83 e0 01	 and	 eax, 1
  0007f	85 c0		 test	 eax, eax
  00081	74 1e		 je	 SHORT $LN9@PyThread_a@2
  00083	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00088	4c 8b 4c 24 58	 mov	 r9, QWORD PTR microseconds$[rsp]
  0008d	4c 8b 44 24 50	 mov	 r8, QWORD PTR aLock$[rsp]
  00092	8b d0		 mov	 edx, eax
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DD@DBOLABC@?$CFld?3?5PyThread_acquire_lock_timed@
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN9@PyThread_a@2:

; 316  : 
; 317  :     if (aLock && EnterNonRecursiveMutex((PNRMUTEX)aLock,
; 318  :                                         (DWORD)milliseconds) == WAIT_OBJECT_0) {

  000a1	48 83 7c 24 50
	00		 cmp	 QWORD PTR aLock$[rsp], 0
  000a7	74 1c		 je	 SHORT $LN2@PyThread_a@2
  000a9	8b 54 24 38	 mov	 edx, DWORD PTR milliseconds$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR aLock$[rsp]
  000b2	e8 00 00 00 00	 call	 EnterNonRecursiveMutex
  000b7	85 c0		 test	 eax, eax
  000b9	75 0a		 jne	 SHORT $LN2@PyThread_a@2

; 319  :         success = PY_LOCK_ACQUIRED;

  000bb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR success$[rsp], 1

; 320  :     }
; 321  :     else {

  000c3	eb 08		 jmp	 SHORT $LN1@PyThread_a@2
$LN2@PyThread_a@2:

; 322  :         success = PY_LOCK_FAILURE;

  000c5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR success$[rsp], 0
$LN1@PyThread_a@2:

; 323  :     }
; 324  : 
; 325  :     dprintf(("%ld: PyThread_acquire_lock(%p, %lld) -> %d\n",
; 326  :              PyThread_get_thread_ident(), aLock, microseconds, success));

  000cd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  000d3	83 e0 01	 and	 eax, 1
  000d6	85 c0		 test	 eax, eax
  000d8	74 26		 je	 SHORT $LN10@PyThread_a@2
  000da	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  000df	8b 4c 24 30	 mov	 ecx, DWORD PTR success$[rsp]
  000e3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000e7	4c 8b 4c 24 58	 mov	 r9, QWORD PTR microseconds$[rsp]
  000ec	4c 8b 44 24 50	 mov	 r8, QWORD PTR aLock$[rsp]
  000f1	8b d0		 mov	 edx, eax
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CM@OGFLBHCO@?$CFld?3?5PyThread_acquire_lock?$CI?$CFp?0?5?$CF@
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN10@PyThread_a@2:

; 327  : 
; 328  :     return success;

  00100	8b 44 24 30	 mov	 eax, DWORD PTR success$[rsp]

; 329  : }

  00104	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00108	c3		 ret	 0
PyThread_acquire_lock_timed ENDP
_TEXT	ENDS
PUBLIC	PyThread_acquire_lock
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_acquire_lock DD imagerel $LN5
	DD	imagerel $LN5+64
	DD	imagerel $unwind$PyThread_acquire_lock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_acquire_lock DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyThread_acquire_lock
_TEXT	SEGMENT
tv67 = 32
aLock$ = 64
waitflag$ = 72
PyThread_acquire_lock PROC				; COMDAT

; 332  : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 333  :     return PyThread_acquire_lock_timed(aLock, waitflag ? -1 : 0, 0);

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR waitflag$[rsp], 0
  00012	74 0a		 je	 SHORT $LN3@PyThread_a@3
  00014	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR tv67[rsp], -1
  0001c	eb 08		 jmp	 SHORT $LN4@PyThread_a@3
$LN3@PyThread_a@3:
  0001e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@PyThread_a@3:
  00026	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv67[rsp]
  0002b	45 33 c0	 xor	 r8d, r8d
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR aLock$[rsp]
  00036	e8 00 00 00 00	 call	 PyThread_acquire_lock_timed

; 334  : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
PyThread_acquire_lock ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@LCKKGHBB@?$CFld?3?5Could?5not?5PyThread_release_@ ; `string'
PUBLIC	??_C@_0CH@NLHAHDOC@?$CFld?3?5PyThread_release_lock?$CI?$CFp?$CJ?5c@ ; `string'
PUBLIC	PyThread_release_lock
EXTRN	__imp_GetLastError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_release_lock DD imagerel $LN7
	DD	imagerel $LN7+129
	DD	imagerel $unwind$PyThread_release_lock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_release_lock DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0DF@LCKKGHBB@?$CFld?3?5Could?5not?5PyThread_release_@
CONST	SEGMENT
??_C@_0DF@LCKKGHBB@?$CFld?3?5Could?5not?5PyThread_release_@ DB '%ld: Coul'
	DB	'd not PyThread_release_lock(%p) error: %ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NLHAHDOC@?$CFld?3?5PyThread_release_lock?$CI?$CFp?$CJ?5c@
CONST	SEGMENT
??_C@_0CH@NLHAHDOC@?$CFld?3?5PyThread_release_lock?$CI?$CFp?$CJ?5c@ DB '%'
	DB	'ld: PyThread_release_lock(%p) called', 0aH, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyThread_release_lock
_TEXT	SEGMENT
tv78 = 32
aLock$ = 64
PyThread_release_lock PROC				; COMDAT

; 338  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 339  :     dprintf(("%ld: PyThread_release_lock(%p) called\n", PyThread_get_thread_ident(),aLock));

  00009	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  0000f	83 e0 01	 and	 eax, 1
  00012	85 c0		 test	 eax, eax
  00014	74 19		 je	 SHORT $LN5@PyThread_r
  00016	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0001b	4c 8b 44 24 40	 mov	 r8, QWORD PTR aLock$[rsp]
  00020	8b d0		 mov	 edx, eax
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@NLHAHDOC@?$CFld?3?5PyThread_release_lock?$CI?$CFp?$CJ?5c@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN5@PyThread_r:

; 340  : 
; 341  :     if (!(aLock && LeaveNonRecursiveMutex((PNRMUTEX) aLock)))

  0002f	48 83 7c 24 40
	00		 cmp	 QWORD PTR aLock$[rsp], 0
  00035	74 0e		 je	 SHORT $LN1@PyThread_r
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR aLock$[rsp]
  0003c	e8 00 00 00 00	 call	 LeaveNonRecursiveMutex
  00041	85 c0		 test	 eax, eax
  00043	75 37		 jne	 SHORT $LN2@PyThread_r
$LN1@PyThread_r:

; 342  :         dprintf(("%ld: Could not PyThread_release_lock(%p) error: %ld\n", PyThread_get_thread_ident(), aLock, GetLastError()));

  00045	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR thread_debug
  0004b	83 e0 01	 and	 eax, 1
  0004e	85 c0		 test	 eax, eax
  00050	74 2a		 je	 SHORT $LN6@PyThread_r
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00058	89 44 24 20	 mov	 DWORD PTR tv78[rsp], eax
  0005c	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00061	8b 4c 24 20	 mov	 ecx, DWORD PTR tv78[rsp]
  00065	44 8b c9	 mov	 r9d, ecx
  00068	4c 8b 44 24 40	 mov	 r8, QWORD PTR aLock$[rsp]
  0006d	8b d0		 mov	 edx, eax
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DF@LCKKGHBB@?$CFld?3?5Could?5not?5PyThread_release_@
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN6@PyThread_r:
$LN2@PyThread_r:

; 343  : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
PyThread_release_lock ENDP
_TEXT	ENDS
PUBLIC	PyThread_create_key
EXTRN	__imp_TlsAlloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_create_key DD imagerel $LN4
	DD	imagerel $LN4+37
	DD	imagerel $unwind$PyThread_create_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_create_key DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyThread_create_key
_TEXT	SEGMENT
result$ = 32
PyThread_create_key PROC				; COMDAT

; 379  : {

$LN4:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 380  :     DWORD result= TlsAlloc();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TlsAlloc
  0000a	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 381  :     if (result == TLS_OUT_OF_INDEXES)

  0000e	83 7c 24 20 ff	 cmp	 DWORD PTR result$[rsp], -1 ; ffffffffH
  00013	75 07		 jne	 SHORT $LN1@PyThread_c

; 382  :         return -1;

  00015	b8 ff ff ff ff	 mov	 eax, -1
  0001a	eb 04		 jmp	 SHORT $LN2@PyThread_c
$LN1@PyThread_c:

; 383  :     return (int)result;

  0001c	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN2@PyThread_c:

; 384  : }

  00020	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00024	c3		 ret	 0
PyThread_create_key ENDP
_TEXT	ENDS
PUBLIC	PyThread_delete_key
EXTRN	__imp_TlsFree:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_delete_key DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$PyThread_delete_key
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_delete_key DD 010801H
	DD	04208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyThread_delete_key
_TEXT	SEGMENT
key$ = 48
PyThread_delete_key PROC				; COMDAT

; 388  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 389  :     TlsFree(key);

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR key$[rsp]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TlsFree

; 390  : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
PyThread_delete_key ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BM@IFHPBCCM@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	PyThread_set_key_value
EXTRN	__imp_TlsSetValue:PROC
EXTRN	__imp_TlsGetValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_set_key_value DD imagerel $LN6
	DD	imagerel $LN6+116
	DD	imagerel $unwind$PyThread_set_key_value
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_set_key_value DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT ??_C@_1BM@IFHPBCCM@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@IFHPBCCM@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyThread_set_key_value
_TEXT	SEGMENT
ok$ = 32
oldvalue$ = 40
key$ = 64
value$ = 72
PyThread_set_key_value PROC				; COMDAT

; 397  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 398  :     BOOL ok;
; 399  :     void *oldvalue;
; 400  : 
; 401  :     assert(value != NULL);

  0000d	48 83 7c 24 48
	00		 cmp	 QWORD PTR value$[rsp], 0
  00013	75 1c		 jne	 SHORT $LN5@PyThread_s@2
  00015	41 b8 91 01 00
	00		 mov	 r8d, 401		; 00000191H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EK@IENPHKJG@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@IFHPBCCM@?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002f	33 c0		 xor	 eax, eax
$LN5@PyThread_s@2:

; 402  :     oldvalue = TlsGetValue(key);

  00031	8b 4c 24 40	 mov	 ecx, DWORD PTR key$[rsp]
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TlsGetValue
  0003b	48 89 44 24 28	 mov	 QWORD PTR oldvalue$[rsp], rax

; 403  :     if (oldvalue != NULL)

  00040	48 83 7c 24 28
	00		 cmp	 QWORD PTR oldvalue$[rsp], 0
  00046	74 04		 je	 SHORT $LN2@PyThread_s@2

; 404  :         /* ignore value if already set */
; 405  :         return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 23		 jmp	 SHORT $LN3@PyThread_s@2
$LN2@PyThread_s@2:

; 406  :     ok = TlsSetValue(key, value);

  0004c	48 8b 54 24 48	 mov	 rdx, QWORD PTR value$[rsp]
  00051	8b 4c 24 40	 mov	 ecx, DWORD PTR key$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TlsSetValue
  0005b	89 44 24 20	 mov	 DWORD PTR ok$[rsp], eax

; 407  :     if (!ok)

  0005f	83 7c 24 20 00	 cmp	 DWORD PTR ok$[rsp], 0
  00064	75 07		 jne	 SHORT $LN1@PyThread_s@2

; 408  :         return -1;

  00066	b8 ff ff ff ff	 mov	 eax, -1
  0006b	eb 02		 jmp	 SHORT $LN3@PyThread_s@2
$LN1@PyThread_s@2:

; 409  :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN3@PyThread_s@2:

; 410  : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
PyThread_set_key_value ENDP
_TEXT	ENDS
PUBLIC	PyThread_get_key_value
EXTRN	__imp_SetLastError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_get_key_value DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$PyThread_get_key_value
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_get_key_value DD 010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyThread_get_key_value
_TEXT	SEGMENT
error$ = 32
result$ = 40
key$ = 64
PyThread_get_key_value PROC				; COMDAT

; 414  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 415  :     /* because TLS is used in the Py_END_ALLOW_THREAD macro,
; 416  :      * it is necessary to preserve the windows error state, because
; 417  :      * it is assumed to be preserved across the call to the macro.
; 418  :      * Ideally, the macro should be fixed, but it is simpler to
; 419  :      * do it here.
; 420  :      */
; 421  :     DWORD error = GetLastError();

  00008	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0000e	89 44 24 20	 mov	 DWORD PTR error$[rsp], eax

; 422  :     void *result = TlsGetValue(key);

  00012	8b 4c 24 40	 mov	 ecx, DWORD PTR key$[rsp]
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TlsGetValue
  0001c	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 423  :     SetLastError(error);

  00021	8b 4c 24 20	 mov	 ecx, DWORD PTR error$[rsp]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError

; 424  :     return result;

  0002b	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]

; 425  : }

  00030	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00034	c3		 ret	 0
PyThread_get_key_value ENDP
_TEXT	ENDS
PUBLIC	PyThread_delete_key_value
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_delete_key_value DD imagerel $LN3
	DD	imagerel $LN3+25
	DD	imagerel $unwind$PyThread_delete_key_value
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_delete_key_value DD 010801H
	DD	04208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyThread_delete_key_value
_TEXT	SEGMENT
key$ = 48
PyThread_delete_key_value PROC				; COMDAT

; 429  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 430  :     /* NULL is used as "key missing", and it is also the default
; 431  :      * given by TlsGetValue() if nothing has been set yet.
; 432  :      */
; 433  :     TlsSetValue(key, NULL);

  00008	33 d2		 xor	 edx, edx
  0000a	8b 4c 24 30	 mov	 ecx, DWORD PTR key$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TlsSetValue

; 434  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
PyThread_delete_key_value ENDP
_TEXT	ENDS
PUBLIC	PyThread_ReInitTLS
; Function compile flags: /Odtp
;	COMDAT PyThread_ReInitTLS
_TEXT	SEGMENT
PyThread_ReInitTLS PROC					; COMDAT

; 441  : {}

  00000	c3		 ret	 0
PyThread_ReInitTLS ENDP
_TEXT	ENDS
PUBLIC	PyThread_get_stacksize
; Function compile flags: /Odtp
; File c:\src\pyparallel\python\thread.c
;	COMDAT PyThread_get_stacksize
_TEXT	SEGMENT
PyThread_get_stacksize PROC				; COMDAT

; 109  :     return _pythread_stacksize;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _pythread_stacksize

; 110  : }

  00007	c3		 ret	 0
PyThread_get_stacksize ENDP
_TEXT	ENDS
PUBLIC	PyThread_set_stacksize
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyThread_set_stacksize DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$PyThread_set_stacksize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_set_stacksize DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyThread_set_stacksize
_TEXT	SEGMENT
size$ = 48
PyThread_set_stacksize PROC				; COMDAT

; 119  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 120  : #if defined(THREAD_SET_STACKSIZE)
; 121  :     return THREAD_SET_STACKSIZE(size);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size$[rsp]
  0000e	e8 00 00 00 00	 call	 _pythread_nt_set_stacksize

; 122  : #else
; 123  :     return -2;
; 124  : #endif
; 125  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
PyThread_set_stacksize ENDP
; Function compile flags: /Odtp
; File c:\src\pyparallel\python\thread_nt.h
_TEXT	ENDS
;	COMDAT _pythread_nt_set_stacksize
_TEXT	SEGMENT
size$ = 8
_pythread_nt_set_stacksize PROC				; COMDAT

; 354  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 355  :     /* set to default */
; 356  :     if (size == 0) {

  00005	48 83 7c 24 08
	00		 cmp	 QWORD PTR size$[rsp], 0
  0000b	75 0f		 jne	 SHORT $LN2@pythread_n

; 357  :         _pythread_stacksize = 0;

  0000d	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR _pythread_stacksize, 0

; 358  :         return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	eb 2b		 jmp	 SHORT $LN3@pythread_n
$LN2@pythread_n:

; 359  :     }
; 360  : 
; 361  :     /* valid range? */
; 362  :     if (size >= THREAD_MIN_STACKSIZE && size < THREAD_MAX_STACKSIZE) {

  0001c	48 81 7c 24 08
	00 80 00 00	 cmp	 QWORD PTR size$[rsp], 32768 ; 00008000H
  00025	72 1b		 jb	 SHORT $LN1@pythread_n
  00027	48 81 7c 24 08
	00 00 00 10	 cmp	 QWORD PTR size$[rsp], 268435456 ; 10000000H
  00030	73 10		 jae	 SHORT $LN1@pythread_n

; 363  :         _pythread_stacksize = size;

  00032	48 8b 44 24 08	 mov	 rax, QWORD PTR size$[rsp]
  00037	48 89 05 00 00
	00 00		 mov	 QWORD PTR _pythread_stacksize, rax

; 364  :         return 0;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 05		 jmp	 SHORT $LN3@pythread_n
$LN1@pythread_n:

; 365  :     }
; 366  : 
; 367  :     return -1;

  00042	b8 ff ff ff ff	 mov	 eax, -1
$LN3@pythread_n:

; 368  : }

  00047	f3 c3		 fatret	 0
_pythread_nt_set_stacksize ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	_Py_DecRef
PUBLIC	??_C@_02JKEHMDF@nt?$AA@				; `string'
PUBLIC	PyThread_GetInfo
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyStructSequence_New:PROC
EXTRN	PyStructSequence_InitType:PROC
_BSS	SEGMENT
ThreadInfoType DB 01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\python\thread.c
pdata	SEGMENT
$pdata$PyThread_GetInfo DD imagerel $LN6
	DD	imagerel $LN6+263
	DD	imagerel $unwind$PyThread_GetInfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyThread_GetInfo DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_02JKEHMDF@nt?$AA@
CONST	SEGMENT
??_C@_02JKEHMDF@nt?$AA@ DB 'nt', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyThread_GetInfo
_TEXT	SEGMENT
threadinfo$ = 32
value$ = 40
pos$ = 48
PyThread_GetInfo PROC					; COMDAT

; 397  : {

$LN6:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 398  :     PyObject *threadinfo, *value;
; 399  :     int pos = 0;

  00004	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR pos$[rsp], 0

; 400  : #if (defined(_POSIX_THREADS) && defined(HAVE_CONFSTR) \
; 401  :      && defined(_CS_GNU_LIBPTHREAD_VERSION))
; 402  :     char buffer[255];
; 403  :     int len;
; 404  : #endif
; 405  : 
; 406  :     if (ThreadInfoType.tp_name == 0)

  0000c	48 83 3d 70 00
	00 00 00	 cmp	 QWORD PTR ThreadInfoType+112, 0
  00014	75 13		 jne	 SHORT $LN3@PyThread_G

; 407  :         PyStructSequence_InitType(&ThreadInfoType, &threadinfo_desc);

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:threadinfo_desc
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadInfoType
  00024	e8 00 00 00 00	 call	 PyStructSequence_InitType
$LN3@PyThread_G:

; 408  : 
; 409  :     threadinfo = PyStructSequence_New(&ThreadInfoType);

  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ThreadInfoType
  00030	e8 00 00 00 00	 call	 PyStructSequence_New
  00035	48 89 44 24 20	 mov	 QWORD PTR threadinfo$[rsp], rax

; 410  :     if (threadinfo == NULL)

  0003a	48 83 7c 24 20
	00		 cmp	 QWORD PTR threadinfo$[rsp], 0
  00040	75 07		 jne	 SHORT $LN2@PyThread_G

; 411  :         return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	e9 b9 00 00 00	 jmp	 $LN4@PyThread_G
$LN2@PyThread_G:

; 412  : 
; 413  :     value = PyUnicode_FromString(PYTHREAD_NAME);

  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02JKEHMDF@nt?$AA@
  00050	e8 00 00 00 00	 call	 PyUnicode_FromString
  00055	48 89 44 24 28	 mov	 QWORD PTR value$[rsp], rax

; 414  :     if (value == NULL) {

  0005a	48 83 7c 24 28
	00		 cmp	 QWORD PTR value$[rsp], 0
  00060	75 11		 jne	 SHORT $LN1@PyThread_G

; 415  :         Py_DECREF(threadinfo);

  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR threadinfo$[rsp]
  00067	e8 00 00 00 00	 call	 _Py_DecRef

; 416  :         return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	e9 8f 00 00 00	 jmp	 $LN4@PyThread_G
$LN1@PyThread_G:

; 417  :     }
; 418  :     PyStructSequence_SET_ITEM(threadinfo, pos++, value);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR pos$[rsp]
  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR threadinfo$[rsp]
  0007d	48 8b 54 24 28	 mov	 rdx, QWORD PTR value$[rsp]
  00082	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx
  00087	8b 44 24 30	 mov	 eax, DWORD PTR pos$[rsp]
  0008b	ff c0		 inc	 eax
  0008d	89 44 24 30	 mov	 DWORD PTR pos$[rsp], eax

; 419  : 
; 420  : #ifdef _POSIX_THREADS
; 421  : #ifdef USE_SEMAPHORES
; 422  :     value = PyUnicode_FromString("semaphore");
; 423  : #else
; 424  :     value = PyUnicode_FromString("mutex+cond");
; 425  : #endif
; 426  :     if (value == NULL) {
; 427  :         Py_DECREF(threadinfo);
; 428  :         return NULL;
; 429  :     }
; 430  : #else
; 431  :     Py_INCREF(Py_None);

  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00098	e8 00 00 00 00	 call	 _Py_IncRef

; 432  :     value = Py_None;

  0009d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000a4	48 89 44 24 28	 mov	 QWORD PTR value$[rsp], rax

; 433  : #endif
; 434  :     PyStructSequence_SET_ITEM(threadinfo, pos++, value);

  000a9	48 63 44 24 30	 movsxd	 rax, DWORD PTR pos$[rsp]
  000ae	48 8b 4c 24 20	 mov	 rcx, QWORD PTR threadinfo$[rsp]
  000b3	48 8b 54 24 28	 mov	 rdx, QWORD PTR value$[rsp]
  000b8	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR pos$[rsp]
  000c1	ff c0		 inc	 eax
  000c3	89 44 24 30	 mov	 DWORD PTR pos$[rsp], eax

; 435  : 
; 436  : #if (defined(_POSIX_THREADS) && defined(HAVE_CONFSTR) \
; 437  :      && defined(_CS_GNU_LIBPTHREAD_VERSION))
; 438  :     value = NULL;
; 439  :     len = confstr(_CS_GNU_LIBPTHREAD_VERSION, buffer, sizeof(buffer));
; 440  :     if (1 < len && len < sizeof(buffer)) {
; 441  :         value = PyUnicode_DecodeFSDefaultAndSize(buffer, len-1);
; 442  :         if (value == NULL)
; 443  :             PyErr_Clear();
; 444  :     }
; 445  :     if (value == NULL)
; 446  : #endif
; 447  :     {
; 448  :         Py_INCREF(Py_None);

  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000ce	e8 00 00 00 00	 call	 _Py_IncRef

; 449  :         value = Py_None;

  000d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000da	48 89 44 24 28	 mov	 QWORD PTR value$[rsp], rax

; 450  :     }
; 451  :     PyStructSequence_SET_ITEM(threadinfo, pos++, value);

  000df	48 63 44 24 30	 movsxd	 rax, DWORD PTR pos$[rsp]
  000e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR threadinfo$[rsp]
  000e9	48 8b 54 24 28	 mov	 rdx, QWORD PTR value$[rsp]
  000ee	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx
  000f3	8b 44 24 30	 mov	 eax, DWORD PTR pos$[rsp]
  000f7	ff c0		 inc	 eax
  000f9	89 44 24 30	 mov	 DWORD PTR pos$[rsp], eax

; 452  :     return threadinfo;

  000fd	48 8b 44 24 20	 mov	 rax, QWORD PTR threadinfo$[rsp]
$LN4@PyThread_G:

; 453  : }

  00102	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00106	c3		 ret	 0
PyThread_GetInfo ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
END
