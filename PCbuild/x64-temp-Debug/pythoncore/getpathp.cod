; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
module_search_path DQ 01H DUP (?)
python3_checked DD 01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
?keyPrefix@?1??getpythonregpath@@9@9 DB 'S', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	'w', 00H, 'a', 00H, 'r', 00H, 'e', 00H, '\', 00H, 'P', 00H, 'y'
	DB	00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H, '\', 00H, 'P', 00H
	DB	'y', 00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H, 'C', 00H, 'o'
	DB	00H, 'r', 00H, 'e', 00H, '\', 00H, 00H, 00H	; `getpythonregpath'::`2'::keyPrefix
?keySuffix@?1??getpythonregpath@@9@9 DB '\', 00H, 'P', 00H, 'y', 00H, 't', 00H
	DB	'h', 00H, 'o', 00H, 'n', 00H, 'P', 00H, 'a', 00H, 't', 00H, 'h'
	DB	00H, 00H, 00H				; `getpythonregpath'::`2'::keySuffix
CONST	ENDS
PUBLIC	Py_SetPath
EXTRN	__imp_wcscpy:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_wcslen:PROC
EXTRN	__imp_wcsncpy:PROC
EXTRN	Py_GetProgramName:PROC
EXTRN	__imp_free:PROC
_BSS	SEGMENT
prefix	DW	0101H DUP (?)
	ALIGN	4

progpath DW	0101H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\pc\getpathp.c
pdata	SEGMENT
$pdata$Py_SetPath DD imagerel $LN6
	DD	imagerel $LN6+159
	DD	imagerel $unwind$Py_SetPath
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_SetPath DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Py_SetPath
_TEXT	SEGMENT
prog$120758 = 32
path$ = 64
Py_SetPath PROC						; COMDAT

; 746  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 747  :     if (module_search_path != NULL) {

  00009	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR module_search_path, 0
  00011	74 18		 je	 SHORT $LN3@Py_SetPath

; 748  :         free(module_search_path);

  00013	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR module_search_path
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 749  :         module_search_path = NULL;

  00020	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR module_search_path, 0
$LN3@Py_SetPath:

; 750  :     }
; 751  :     if (path != NULL) {

  0002b	48 83 7c 24 40
	00		 cmp	 QWORD PTR path$[rsp], 0
  00031	74 67		 je	 SHORT $LN2@Py_SetPath

; 752  :         extern wchar_t *Py_GetProgramName(void);
; 753  :         wchar_t *prog = Py_GetProgramName();

  00033	e8 00 00 00 00	 call	 Py_GetProgramName
  00038	48 89 44 24 20	 mov	 QWORD PTR prog$120758[rsp], rax

; 754  :         wcsncpy(progpath, prog, MAXPATHLEN);

  0003d	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00043	48 8b 54 24 20	 mov	 rdx, QWORD PTR prog$120758[rsp]
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:progpath
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 755  :         prefix[0] = L'\0';

  00055	33 c0		 xor	 eax, eax
  00057	66 89 05 00 00
	00 00		 mov	 WORD PTR prefix, ax

; 756  :         module_search_path = malloc((wcslen(path) + 1) * sizeof(wchar_t));

  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00069	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 05 00 00
	00 00		 mov	 QWORD PTR module_search_path, rax

; 757  :         if (module_search_path != NULL)

  0007e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR module_search_path, 0
  00086	74 12		 je	 SHORT $LN1@Py_SetPath

; 758  :             wcscpy(module_search_path, path);

  00088	48 8b 54 24 40	 mov	 rdx, QWORD PTR path$[rsp]
  0008d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR module_search_path
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy
$LN1@Py_SetPath:
$LN2@Py_SetPath:

; 759  : 	}
; 760  : }

  0009a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009e	c3		 ret	 0
Py_SetPath ENDP
_TEXT	ENDS
PUBLIC	Py_GetPath
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_GetPath DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$Py_GetPath
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_GetPath DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Py_GetPath
_TEXT	SEGMENT
Py_GetPath PROC						; COMDAT

; 764  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 765  :     if (!module_search_path)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR module_search_path, 0
  0000c	75 05		 jne	 SHORT $LN1@Py_GetPath

; 766  :         calculate_path();

  0000e	e8 00 00 00 00	 call	 calculate_path
$LN1@Py_GetPath:

; 767  :     return module_search_path;

  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR module_search_path

; 768  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
Py_GetPath ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@LJKPPDHP@Using?5default?5static?5path?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@LBHPPBDF@Using?5environment?5$PYTHONPATH?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@GDJMEGDE@Can?8t?5malloc?5dynamic?5PYTHONPATH?4@ ; `string'
PUBLIC	??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BE@BGJONEDM@?$AAl?$AAi?$AAb?$AA?2?$AAo?$AAs?$AA?4?$AAp?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_19GPBMHKKP@?$AAh?$AAo?$AAm?$AAe?$AA?$AA@	; `string'
PUBLIC	??_C@_13BPINEIPE@?$AAr?$AA?$AA@			; `string'
PUBLIC	??_C@_1BG@PEBPDCLB@?$AAp?$AAy?$AAv?$AAe?$AAn?$AAv?$AA?4?$AAc?$AAf?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@IAOFAKHE@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAP?$AAA?$AAT?$AAH?$AA?$AA@ ; `string'
EXTRN	__imp_wcschr:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp__errno:PROC
EXTRN	_Py_wfopen:PROC
EXTRN	__imp__wgetenv:PROC
EXTRN	Py_IgnoreEnvironmentFlag:DWORD
EXTRN	Py_GetPythonHome:PROC
_BSS	SEGMENT
	ALIGN	4

dllpath	DW	0101H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$calculate_path DD imagerel calculate_path
	DD	imagerel calculate_path+2711
	DD	imagerel $unwind$calculate_path
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$calculate_path DD 020701H
	DD	01210107H
xdata	ENDS
;	COMDAT ??_C@_0BM@LJKPPDHP@Using?5default?5static?5path?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@LJKPPDHP@Using?5default?5static?5path?4?6?$AA@ DB 'Using defaul'
	DB	't static path.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LBHPPBDF@Using?5environment?5$PYTHONPATH?4?6?$AA@
CONST	SEGMENT
??_C@_0CA@LBHPPBDF@Using?5environment?5$PYTHONPATH?4?6?$AA@ DB 'Using env'
	DB	'ironment $PYTHONPATH.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GDJMEGDE@Can?8t?5malloc?5dynamic?5PYTHONPATH?4@
CONST	SEGMENT
??_C@_0CC@GDJMEGDE@Can?8t?5malloc?5dynamic?5PYTHONPATH?4@ DB 'Can''t mall'
	DB	'oc dynamic PYTHONPATH.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@ DB '.'
	DB	00H, '\', 00H, 'D', 00H, 'L', 00H, 'L', 00H, 's', 00H, ';', 00H
	DB	'.', 00H, '\', 00H, 'l', 00H, 'i', 00H, 'b', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@BGJONEDM@?$AAl?$AAi?$AAb?$AA?2?$AAo?$AAs?$AA?4?$AAp?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@BGJONEDM@?$AAl?$AAi?$AAb?$AA?2?$AAo?$AAs?$AA?4?$AAp?$AAy?$AA?$AA@ DB 'l'
	DB	00H, 'i', 00H, 'b', 00H, '\', 00H, 'o', 00H, 's', 00H, '.', 00H
	DB	'p', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19GPBMHKKP@?$AAh?$AAo?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19GPBMHKKP@?$AAh?$AAo?$AAm?$AAe?$AA?$AA@ DB 'h', 00H, 'o', 00H, 'm', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_13BPINEIPE@?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_13BPINEIPE@?$AAr?$AA?$AA@ DB 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@PEBPDCLB@?$AAp?$AAy?$AAv?$AAe?$AAn?$AAv?$AA?4?$AAc?$AAf?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@PEBPDCLB@?$AAp?$AAy?$AAv?$AAe?$AAn?$AAv?$AA?4?$AAc?$AAf?$AAg?$AA?$AA@ DB 'p'
	DB	00H, 'y', 00H, 'v', 00H, 'e', 00H, 'n', 00H, 'v', 00H, '.', 00H
	DB	'c', 00H, 'f', 00H, 'g', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@IAOFAKHE@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAP?$AAA?$AAT?$AAH?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@IAOFAKHE@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAP?$AAA?$AAT?$AAH?$AA?$AA@ DB 'P'
	DB	00H, 'Y', 00H, 'T', 00H, 'H', 00H, 'O', 00H, 'N', 00H, 'P', 00H
	DB	'A', 00H, 'T', 00H, 'H', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT calculate_path
_TEXT	SEGMENT
machinepath$ = 32
bufsz$ = 40
zip_path$ = 48
envpath$ = 576
skiphome$ = 584
len$ = 592
skipdefault$ = 600
buf$ = 608
pythonhome$ = 616
argv0_path$ = 624
userpath$ = 1152
env_file$120654 = 1160
tmpbuffer$120651 = 1168
env_cfg$120652 = 1696
p$120693 = 1704
p$120722 = 1712
n$120724 = 1720
q$120723 = 1728
lookBuf$120736 = 1744
look$120737 = 2272
lookEnd$120742 = 2280
nchars$120741 = 2288
tv165 = 2296
tv176 = 2300
calculate_path PROC					; COMDAT

; 475  : {

  00000	48 81 ec 08 09
	00 00		 sub	 rsp, 2312		; 00000908H

; 476  :     wchar_t argv0_path[MAXPATHLEN+1];
; 477  :     wchar_t *buf;
; 478  :     size_t bufsz;
; 479  :     wchar_t *pythonhome = Py_GetPythonHome();

  00007	e8 00 00 00 00	 call	 Py_GetPythonHome
  0000c	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR pythonhome$[rsp], rax

; 480  :     wchar_t *envpath = NULL;

  00014	48 c7 84 24 40
	02 00 00 00 00
	00 00		 mov	 QWORD PTR envpath$[rsp], 0

; 481  : 
; 482  : #ifdef MS_WINDOWS
; 483  :     int skiphome, skipdefault;
; 484  :     wchar_t *machinepath = NULL;

  00020	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR machinepath$[rsp], 0

; 485  :     wchar_t *userpath = NULL;

  00029	48 c7 84 24 80
	04 00 00 00 00
	00 00		 mov	 QWORD PTR userpath$[rsp], 0

; 486  :     wchar_t zip_path[MAXPATHLEN+1];
; 487  :     size_t len;
; 488  : 
; 489  :     if (!Py_IgnoreEnvironmentFlag) {

  00035	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  0003c	75 15		 jne	 SHORT $LN50@calculate_

; 490  :         envpath = _wgetenv(L"PYTHONPATH");

  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@IAOFAKHE@?$AAP?$AAY?$AAT?$AAH?$AAO?$AAN?$AAP?$AAA?$AAT?$AAH?$AA?$AA@
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wgetenv
  0004b	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR envpath$[rsp], rax
$LN50@calculate_:

; 491  :     }
; 492  : #else
; 493  :     char *_envpath = Py_GETENV("PYTHONPATH");
; 494  :     wchar_t wenvpath[MAXPATHLEN+1];
; 495  :     if (_envpath) {
; 496  :         size_t r = mbstowcs(wenvpath, _envpath, MAXPATHLEN+1);
; 497  :         envpath = wenvpath;
; 498  :         if (r == (size_t)-1 || r >= MAXPATHLEN)
; 499  :             envpath = NULL;
; 500  :     }
; 501  : #endif
; 502  : 
; 503  :     get_progpath();

  00053	e8 00 00 00 00	 call	 get_progpath

; 504  :     /* progpath guaranteed \0 terminated in MAXPATH+1 bytes. */
; 505  :     wcscpy(argv0_path, progpath);

  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:progpath
  0005f	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR argv0_path$[rsp]
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 506  :     reduce(argv0_path);

  0006d	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR argv0_path$[rsp]
  00075	e8 00 00 00 00	 call	 reduce

; 507  : 
; 508  :     /* Search for an environment configuration file, first in the
; 509  :        executable's directory and then in the parent directory.
; 510  :        If found, open it for use when searching for prefixes.
; 511  :     */
; 512  : 
; 513  :     {
; 514  :         wchar_t tmpbuffer[MAXPATHLEN+1];
; 515  :         wchar_t *env_cfg = L"pyvenv.cfg";

  0007a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BG@PEBPDCLB@?$AAp?$AAy?$AAv?$AAe?$AAn?$AAv?$AA?4?$AAc?$AAf?$AAg?$AA?$AA@
  00081	48 89 84 24 a0
	06 00 00	 mov	 QWORD PTR env_cfg$120652[rsp], rax

; 516  :         FILE * env_file = NULL;

  00089	48 c7 84 24 88
	04 00 00 00 00
	00 00		 mov	 QWORD PTR env_file$120654[rsp], 0

; 517  : 
; 518  :         wcscpy(tmpbuffer, argv0_path);

  00095	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR argv0_path$[rsp]
  0009d	48 8d 8c 24 90
	04 00 00	 lea	 rcx, QWORD PTR tmpbuffer$120651[rsp]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 519  :         join(tmpbuffer, env_cfg);

  000ab	48 8b 94 24 a0
	06 00 00	 mov	 rdx, QWORD PTR env_cfg$120652[rsp]
  000b3	48 8d 8c 24 90
	04 00 00	 lea	 rcx, QWORD PTR tmpbuffer$120651[rsp]
  000bb	e8 00 00 00 00	 call	 join

; 520  :         env_file = _Py_wfopen(tmpbuffer, L"r");

  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13BPINEIPE@?$AAr?$AA?$AA@
  000c7	48 8d 8c 24 90
	04 00 00	 lea	 rcx, QWORD PTR tmpbuffer$120651[rsp]
  000cf	e8 00 00 00 00	 call	 _Py_wfopen
  000d4	48 89 84 24 88
	04 00 00	 mov	 QWORD PTR env_file$120654[rsp], rax

; 521  :         if (env_file == NULL) {

  000dc	48 83 bc 24 88
	04 00 00 00	 cmp	 QWORD PTR env_file$120654[rsp], 0
  000e5	75 6e		 jne	 SHORT $LN49@calculate_

; 522  :             errno = 0;

  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ed	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 523  :             reduce(tmpbuffer);

  000f3	48 8d 8c 24 90
	04 00 00	 lea	 rcx, QWORD PTR tmpbuffer$120651[rsp]
  000fb	e8 00 00 00 00	 call	 reduce

; 524  :             reduce(tmpbuffer);

  00100	48 8d 8c 24 90
	04 00 00	 lea	 rcx, QWORD PTR tmpbuffer$120651[rsp]
  00108	e8 00 00 00 00	 call	 reduce

; 525  :             join(tmpbuffer, env_cfg);

  0010d	48 8b 94 24 a0
	06 00 00	 mov	 rdx, QWORD PTR env_cfg$120652[rsp]
  00115	48 8d 8c 24 90
	04 00 00	 lea	 rcx, QWORD PTR tmpbuffer$120651[rsp]
  0011d	e8 00 00 00 00	 call	 join

; 526  :             env_file = _Py_wfopen(tmpbuffer, L"r");

  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13BPINEIPE@?$AAr?$AA?$AA@
  00129	48 8d 8c 24 90
	04 00 00	 lea	 rcx, QWORD PTR tmpbuffer$120651[rsp]
  00131	e8 00 00 00 00	 call	 _Py_wfopen
  00136	48 89 84 24 88
	04 00 00	 mov	 QWORD PTR env_file$120654[rsp], rax

; 527  :             if (env_file == NULL) {

  0013e	48 83 bc 24 88
	04 00 00 00	 cmp	 QWORD PTR env_file$120654[rsp], 0
  00147	75 0c		 jne	 SHORT $LN48@calculate_

; 528  :                 errno = 0;

  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0014f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN48@calculate_:
$LN49@calculate_:

; 529  :             }
; 530  :         }
; 531  :         if (env_file != NULL) {

  00155	48 83 bc 24 88
	04 00 00 00	 cmp	 QWORD PTR env_file$120654[rsp], 0
  0015e	74 50		 je	 SHORT $LN47@calculate_

; 532  :             /* Look for a 'home' variable and set argv0_path to it, if found */
; 533  :             if (find_env_config_value(env_file, L"home", tmpbuffer)) {

  00160	4c 8d 84 24 90
	04 00 00	 lea	 r8, QWORD PTR tmpbuffer$120651[rsp]
  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19GPBMHKKP@?$AAh?$AAo?$AAm?$AAe?$AA?$AA@
  0016f	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR env_file$120654[rsp]
  00177	e8 00 00 00 00	 call	 find_env_config_value
  0017c	85 c0		 test	 eax, eax
  0017e	74 16		 je	 SHORT $LN46@calculate_

; 534  :                 wcscpy(argv0_path, tmpbuffer);

  00180	48 8d 94 24 90
	04 00 00	 lea	 rdx, QWORD PTR tmpbuffer$120651[rsp]
  00188	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR argv0_path$[rsp]
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy
$LN46@calculate_:

; 535  :             }
; 536  :             fclose(env_file);

  00196	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR env_file$120654[rsp]
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 537  :             env_file = NULL;

  001a4	48 c7 84 24 88
	04 00 00 00 00
	00 00		 mov	 QWORD PTR env_file$120654[rsp], 0
$LN47@calculate_:

; 538  :         }
; 539  :     }
; 540  : 
; 541  :     if (pythonhome == NULL || *pythonhome == '\0') {

  001b0	48 83 bc 24 68
	02 00 00 00	 cmp	 QWORD PTR pythonhome$[rsp], 0
  001b9	74 0f		 je	 SHORT $LN44@calculate_
  001bb	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR pythonhome$[rsp]
  001c3	0f b7 00	 movzx	 eax, WORD PTR [rax]
  001c6	85 c0		 test	 eax, eax
  001c8	75 37		 jne	 SHORT $LN45@calculate_
$LN44@calculate_:

; 542  :         if (search_for_prefix(argv0_path, LANDMARK))

  001ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BE@BGJONEDM@?$AAl?$AAi?$AAb?$AA?2?$AAo?$AAs?$AA?4?$AAp?$AAy?$AA?$AA@
  001d1	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR argv0_path$[rsp]
  001d9	e8 00 00 00 00	 call	 search_for_prefix
  001de	85 c0		 test	 eax, eax
  001e0	74 11		 je	 SHORT $LN43@calculate_

; 543  :             pythonhome = prefix;

  001e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:prefix
  001e9	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR pythonhome$[rsp], rax

; 544  :         else

  001f1	eb 0c		 jmp	 SHORT $LN42@calculate_
$LN43@calculate_:

; 545  :             pythonhome = NULL;

  001f3	48 c7 84 24 68
	02 00 00 00 00
	00 00		 mov	 QWORD PTR pythonhome$[rsp], 0
$LN42@calculate_:

; 546  :     }
; 547  :     else

  001ff	eb 1b		 jmp	 SHORT $LN41@calculate_
$LN45@calculate_:

; 548  :         wcsncpy(prefix, pythonhome, MAXPATHLEN);

  00201	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00207	48 8b 94 24 68
	02 00 00	 mov	 rdx, QWORD PTR pythonhome$[rsp]
  0020f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prefix
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy
$LN41@calculate_:

; 549  : 
; 550  :     if (envpath && *envpath == '\0')

  0021c	48 83 bc 24 40
	02 00 00 00	 cmp	 QWORD PTR envpath$[rsp], 0
  00225	74 1b		 je	 SHORT $LN40@calculate_
  00227	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR envpath$[rsp]
  0022f	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00232	85 c0		 test	 eax, eax
  00234	75 0c		 jne	 SHORT $LN40@calculate_

; 551  :         envpath = NULL;

  00236	48 c7 84 24 40
	02 00 00 00 00
	00 00		 mov	 QWORD PTR envpath$[rsp], 0
$LN40@calculate_:

; 552  : 
; 553  : 
; 554  : #ifdef MS_WINDOWS
; 555  :     /* Calculate zip archive path */
; 556  :     if (dllpath[0])             /* use name of python DLL */

  00242	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR dllpath
  00249	85 c0		 test	 eax, eax
  0024b	74 1a		 je	 SHORT $LN39@calculate_

; 557  :         wcsncpy(zip_path, dllpath, MAXPATHLEN);

  0024d	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00253	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:dllpath
  0025a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR zip_path$[rsp]
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 558  :     else                        /* use name of executable program */

  00265	eb 18		 jmp	 SHORT $LN38@calculate_
$LN39@calculate_:

; 559  :         wcsncpy(zip_path, progpath, MAXPATHLEN);

  00267	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0026d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:progpath
  00274	48 8d 4c 24 30	 lea	 rcx, QWORD PTR zip_path$[rsp]
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy
$LN38@calculate_:

; 560  :     zip_path[MAXPATHLEN] = '\0';

  0027f	33 c0		 xor	 eax, eax
  00281	66 89 84 24 30
	02 00 00	 mov	 WORD PTR zip_path$[rsp+512], ax

; 561  :     len = wcslen(zip_path);

  00289	48 8d 4c 24 30	 lea	 rcx, QWORD PTR zip_path$[rsp]
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00294	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR len$[rsp], rax

; 562  :     if (len > 4) {

  0029c	48 83 bc 24 50
	02 00 00 04	 cmp	 QWORD PTR len$[rsp], 4
  002a5	76 38		 jbe	 SHORT $LN37@calculate_

; 563  :         zip_path[len-3] = 'z';          /* change ending to "zip" */

  002a7	b8 7a 00 00 00	 mov	 eax, 122		; 0000007aH
  002ac	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  002b4	66 89 44 4c 2a	 mov	 WORD PTR zip_path$[rsp+rcx*2-6], ax

; 564  :         zip_path[len-2] = 'i';

  002b9	b8 69 00 00 00	 mov	 eax, 105		; 00000069H
  002be	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  002c6	66 89 44 4c 2c	 mov	 WORD PTR zip_path$[rsp+rcx*2-4], ax

; 565  :         zip_path[len-1] = 'p';

  002cb	b8 70 00 00 00	 mov	 eax, 112		; 00000070H
  002d0	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  002d8	66 89 44 4c 2e	 mov	 WORD PTR zip_path$[rsp+rcx*2-2], ax

; 566  :     }
; 567  :     else {

  002dd	eb 07		 jmp	 SHORT $LN36@calculate_
$LN37@calculate_:

; 568  :         zip_path[0] = 0;

  002df	33 c0		 xor	 eax, eax
  002e1	66 89 44 24 30	 mov	 WORD PTR zip_path$[rsp], ax
$LN36@calculate_:

; 569  :     }
; 570  : 
; 571  :     skiphome = pythonhome==NULL ? 0 : 1;

  002e6	48 83 bc 24 68
	02 00 00 00	 cmp	 QWORD PTR pythonhome$[rsp], 0
  002ef	75 0d		 jne	 SHORT $LN53@calculate_
  002f1	c7 84 24 f8 08
	00 00 00 00 00
	00		 mov	 DWORD PTR tv165[rsp], 0
  002fc	eb 0b		 jmp	 SHORT $LN54@calculate_
$LN53@calculate_:
  002fe	c7 84 24 f8 08
	00 00 01 00 00
	00		 mov	 DWORD PTR tv165[rsp], 1
$LN54@calculate_:
  00309	8b 84 24 f8 08
	00 00		 mov	 eax, DWORD PTR tv165[rsp]
  00310	89 84 24 48 02
	00 00		 mov	 DWORD PTR skiphome$[rsp], eax

; 572  : #ifdef Py_ENABLE_SHARED
; 573  :     machinepath = getpythonregpath(HKEY_LOCAL_MACHINE, skiphome);

  00317	8b 94 24 48 02
	00 00		 mov	 edx, DWORD PTR skiphome$[rsp]
  0031e	48 c7 c1 02 00
	00 80		 mov	 rcx, -2147483646	; ffffffff80000002H
  00325	e8 00 00 00 00	 call	 getpythonregpath
  0032a	48 89 44 24 20	 mov	 QWORD PTR machinepath$[rsp], rax

; 574  :     userpath = getpythonregpath(HKEY_CURRENT_USER, skiphome);

  0032f	8b 94 24 48 02
	00 00		 mov	 edx, DWORD PTR skiphome$[rsp]
  00336	48 c7 c1 01 00
	00 80		 mov	 rcx, -2147483647	; ffffffff80000001H
  0033d	e8 00 00 00 00	 call	 getpythonregpath
  00342	48 89 84 24 80
	04 00 00	 mov	 QWORD PTR userpath$[rsp], rax

; 575  : #endif
; 576  :     /* We only use the default relative PYTHONPATH if we havent
; 577  :        anything better to use! */
; 578  :     skipdefault = envpath!=NULL || pythonhome!=NULL || \
; 579  :                   machinepath!=NULL || userpath!=NULL;

  0034a	48 83 bc 24 40
	02 00 00 00	 cmp	 QWORD PTR envpath$[rsp], 0
  00353	75 2b		 jne	 SHORT $LN55@calculate_
  00355	48 83 bc 24 68
	02 00 00 00	 cmp	 QWORD PTR pythonhome$[rsp], 0
  0035e	75 20		 jne	 SHORT $LN55@calculate_
  00360	48 83 7c 24 20
	00		 cmp	 QWORD PTR machinepath$[rsp], 0
  00366	75 18		 jne	 SHORT $LN55@calculate_
  00368	48 83 bc 24 80
	04 00 00 00	 cmp	 QWORD PTR userpath$[rsp], 0
  00371	75 0d		 jne	 SHORT $LN55@calculate_
  00373	c7 84 24 fc 08
	00 00 00 00 00
	00		 mov	 DWORD PTR tv176[rsp], 0
  0037e	eb 0b		 jmp	 SHORT $LN56@calculate_
$LN55@calculate_:
  00380	c7 84 24 fc 08
	00 00 01 00 00
	00		 mov	 DWORD PTR tv176[rsp], 1
$LN56@calculate_:
  0038b	8b 84 24 fc 08
	00 00		 mov	 eax, DWORD PTR tv176[rsp]
  00392	89 84 24 58 02
	00 00		 mov	 DWORD PTR skipdefault$[rsp], eax

; 580  : #endif
; 581  : 
; 582  :     /* We need to construct a path from the following parts.
; 583  :        (1) the PYTHONPATH environment variable, if set;
; 584  :        (2) for Win32, the zip archive file path;
; 585  :        (3) for Win32, the machinepath and userpath, if set;
; 586  :        (4) the PYTHONPATH config macro, with the leading "."
; 587  :            of each component replaced with pythonhome, if set;
; 588  :        (5) the directory containing the executable (argv0_path).
; 589  :        The length calculation calculates #4 first.
; 590  :        Extra rules:
; 591  :        - If PYTHONHOME is set (in any way) item (3) is ignored.
; 592  :        - If registry values are used, (4) and (5) are ignored.
; 593  :     */
; 594  : 
; 595  :     /* Calculate size of return buffer */
; 596  :     if (pythonhome != NULL) {

  00399	48 83 bc 24 68
	02 00 00 00	 cmp	 QWORD PTR pythonhome$[rsp], 0
  003a2	74 7d		 je	 SHORT $LN35@calculate_

; 597  :         wchar_t *p;
; 598  :         bufsz = 1;

  003a4	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR bufsz$[rsp], 1

; 599  :         for (p = PYTHONPATH; *p; p++) {

  003ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@
  003b4	48 89 84 24 a8
	06 00 00	 mov	 QWORD PTR p$120693[rsp], rax
  003bc	eb 14		 jmp	 SHORT $LN34@calculate_
$LN33@calculate_:
  003be	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR p$120693[rsp]
  003c6	48 83 c0 02	 add	 rax, 2
  003ca	48 89 84 24 a8
	06 00 00	 mov	 QWORD PTR p$120693[rsp], rax
$LN34@calculate_:
  003d2	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR p$120693[rsp]
  003da	0f b7 00	 movzx	 eax, WORD PTR [rax]
  003dd	85 c0		 test	 eax, eax
  003df	74 1f		 je	 SHORT $LN32@calculate_

; 600  :             if (*p == DELIM)

  003e1	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR p$120693[rsp]
  003e9	0f b7 00	 movzx	 eax, WORD PTR [rax]
  003ec	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  003ef	75 0d		 jne	 SHORT $LN31@calculate_

; 601  :                 bufsz++; /* number of DELIM plus one */

  003f1	48 8b 44 24 28	 mov	 rax, QWORD PTR bufsz$[rsp]
  003f6	48 ff c0	 inc	 rax
  003f9	48 89 44 24 28	 mov	 QWORD PTR bufsz$[rsp], rax
$LN31@calculate_:

; 602  :         }

  003fe	eb be		 jmp	 SHORT $LN33@calculate_
$LN32@calculate_:

; 603  :         bufsz *= wcslen(pythonhome);

  00400	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR pythonhome$[rsp]
  00408	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  0040e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufsz$[rsp]
  00413	48 0f af c8	 imul	 rcx, rax
  00417	48 8b c1	 mov	 rax, rcx
  0041a	48 89 44 24 28	 mov	 QWORD PTR bufsz$[rsp], rax

; 604  :     }
; 605  :     else

  0041f	eb 09		 jmp	 SHORT $LN30@calculate_
$LN35@calculate_:

; 606  :         bufsz = 0;

  00421	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR bufsz$[rsp], 0
$LN30@calculate_:

; 607  :     bufsz += wcslen(PYTHONPATH) + 1;

  0042a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@
  00431	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00437	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufsz$[rsp]
  0043c	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  00441	48 89 44 24 28	 mov	 QWORD PTR bufsz$[rsp], rax

; 608  :     bufsz += wcslen(argv0_path) + 1;

  00446	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR argv0_path$[rsp]
  0044e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00454	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufsz$[rsp]
  00459	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  0045e	48 89 44 24 28	 mov	 QWORD PTR bufsz$[rsp], rax

; 609  : #ifdef MS_WINDOWS
; 610  :     if (userpath)

  00463	48 83 bc 24 80
	04 00 00 00	 cmp	 QWORD PTR userpath$[rsp], 0
  0046c	74 1d		 je	 SHORT $LN29@calculate_

; 611  :         bufsz += wcslen(userpath) + 1;

  0046e	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR userpath$[rsp]
  00476	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  0047c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufsz$[rsp]
  00481	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  00486	48 89 44 24 28	 mov	 QWORD PTR bufsz$[rsp], rax
$LN29@calculate_:

; 612  :     if (machinepath)

  0048b	48 83 7c 24 20
	00		 cmp	 QWORD PTR machinepath$[rsp], 0
  00491	74 1a		 je	 SHORT $LN28@calculate_

; 613  :         bufsz += wcslen(machinepath) + 1;

  00493	48 8b 4c 24 20	 mov	 rcx, QWORD PTR machinepath$[rsp]
  00498	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  0049e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufsz$[rsp]
  004a3	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  004a8	48 89 44 24 28	 mov	 QWORD PTR bufsz$[rsp], rax
$LN28@calculate_:

; 614  :     bufsz += wcslen(zip_path) + 1;

  004ad	48 8d 4c 24 30	 lea	 rcx, QWORD PTR zip_path$[rsp]
  004b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  004b8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufsz$[rsp]
  004bd	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  004c2	48 89 44 24 28	 mov	 QWORD PTR bufsz$[rsp], rax

; 615  : #endif
; 616  :     if (envpath != NULL)

  004c7	48 83 bc 24 40
	02 00 00 00	 cmp	 QWORD PTR envpath$[rsp], 0
  004d0	74 1d		 je	 SHORT $LN27@calculate_

; 617  :         bufsz += wcslen(envpath) + 1;

  004d2	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR envpath$[rsp]
  004da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  004e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufsz$[rsp]
  004e5	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  004ea	48 89 44 24 28	 mov	 QWORD PTR bufsz$[rsp], rax
$LN27@calculate_:

; 618  : 
; 619  :     module_search_path = buf = malloc(bufsz*sizeof(wchar_t));

  004ef	48 8b 44 24 28	 mov	 rax, QWORD PTR bufsz$[rsp]
  004f4	48 d1 e0	 shl	 rax, 1
  004f7	48 8b c8	 mov	 rcx, rax
  004fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00500	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax
  00508	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00510	48 89 05 00 00
	00 00		 mov	 QWORD PTR module_search_path, rax

; 620  :     if (buf == NULL) {

  00517	48 83 bc 24 60
	02 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00520	0f 85 a9 00 00
	00		 jne	 $LN26@calculate_

; 621  :         /* We can't exit, so print a warning and limp along */
; 622  :         fprintf(stderr, "Can't malloc dynamic PYTHONPATH.\n");

  00526	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0052c	48 83 c0 60	 add	 rax, 96			; 00000060H
  00530	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@GDJMEGDE@Can?8t?5malloc?5dynamic?5PYTHONPATH?4@
  00537	48 8b c8	 mov	 rcx, rax
  0053a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 623  :         if (envpath) {

  00540	48 83 bc 24 40
	02 00 00 00	 cmp	 QWORD PTR envpath$[rsp], 0
  00549	74 2b		 je	 SHORT $LN25@calculate_

; 624  :             fprintf(stderr, "Using environment $PYTHONPATH.\n");

  0054b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00551	48 83 c0 60	 add	 rax, 96			; 00000060H
  00555	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@LBHPPBDF@Using?5environment?5$PYTHONPATH?4?6?$AA@
  0055c	48 8b c8	 mov	 rcx, rax
  0055f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 625  :             module_search_path = envpath;

  00565	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR envpath$[rsp]
  0056d	48 89 05 00 00
	00 00		 mov	 QWORD PTR module_search_path, rax

; 626  :         }
; 627  :         else {

  00574	eb 28		 jmp	 SHORT $LN24@calculate_
$LN25@calculate_:

; 628  :             fprintf(stderr, "Using default static path.\n");

  00576	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0057c	48 83 c0 60	 add	 rax, 96			; 00000060H
  00580	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@LJKPPDHP@Using?5default?5static?5path?4?6?$AA@
  00587	48 8b c8	 mov	 rcx, rax
  0058a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 629  :             module_search_path = PYTHONPATH;

  00590	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@
  00597	48 89 05 00 00
	00 00		 mov	 QWORD PTR module_search_path, rax
$LN24@calculate_:

; 630  :         }
; 631  : #ifdef MS_WINDOWS
; 632  :         if (machinepath)

  0059e	48 83 7c 24 20
	00		 cmp	 QWORD PTR machinepath$[rsp], 0
  005a4	74 0b		 je	 SHORT $LN23@calculate_

; 633  :             free(machinepath);

  005a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR machinepath$[rsp]
  005ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@calculate_:

; 634  :         if (userpath)

  005b1	48 83 bc 24 80
	04 00 00 00	 cmp	 QWORD PTR userpath$[rsp], 0
  005ba	74 0e		 je	 SHORT $LN22@calculate_

; 635  :             free(userpath);

  005bc	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR userpath$[rsp]
  005c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN22@calculate_:

; 636  : #endif /* MS_WINDOWS */
; 637  :         return;

  005ca	e9 c0 04 00 00	 jmp	 $LN51@calculate_
$LN26@calculate_:

; 638  :     }
; 639  : 
; 640  :     if (envpath) {

  005cf	48 83 bc 24 40
	02 00 00 00	 cmp	 QWORD PTR envpath$[rsp], 0
  005d8	74 52		 je	 SHORT $LN21@calculate_

; 641  :         wcscpy(buf, envpath);

  005da	48 8b 94 24 40
	02 00 00	 mov	 rdx, QWORD PTR envpath$[rsp]
  005e2	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  005ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 642  :         buf = wcschr(buf, L'\0');

  005f0	33 d2		 xor	 edx, edx
  005f2	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  005fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  00600	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 643  :         *buf++ = DELIM;

  00608	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  0060d	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00615	66 89 01	 mov	 WORD PTR [rcx], ax
  00618	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00620	48 83 c0 02	 add	 rax, 2
  00624	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax
$LN21@calculate_:

; 644  :     }
; 645  : #ifdef MS_WINDOWS
; 646  :     if (zip_path[0]) {

  0062c	0f b7 44 24 30	 movzx	 eax, WORD PTR zip_path$[rsp]
  00631	85 c0		 test	 eax, eax
  00633	74 4f		 je	 SHORT $LN20@calculate_

; 647  :         wcscpy(buf, zip_path);

  00635	48 8d 54 24 30	 lea	 rdx, QWORD PTR zip_path$[rsp]
  0063a	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00642	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 648  :         buf = wcschr(buf, L'\0');

  00648	33 d2		 xor	 edx, edx
  0064a	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00652	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  00658	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 649  :         *buf++ = DELIM;

  00660	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  00665	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0066d	66 89 01	 mov	 WORD PTR [rcx], ax
  00670	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00678	48 83 c0 02	 add	 rax, 2
  0067c	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax
$LN20@calculate_:

; 650  :     }
; 651  :     if (userpath) {

  00684	48 83 bc 24 80
	04 00 00 00	 cmp	 QWORD PTR userpath$[rsp], 0
  0068d	74 60		 je	 SHORT $LN19@calculate_

; 652  :         wcscpy(buf, userpath);

  0068f	48 8b 94 24 80
	04 00 00	 mov	 rdx, QWORD PTR userpath$[rsp]
  00697	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0069f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 653  :         buf = wcschr(buf, L'\0');

  006a5	33 d2		 xor	 edx, edx
  006a7	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  006af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  006b5	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 654  :         *buf++ = DELIM;

  006bd	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  006c2	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  006ca	66 89 01	 mov	 WORD PTR [rcx], ax
  006cd	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  006d5	48 83 c0 02	 add	 rax, 2
  006d9	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 655  :         free(userpath);

  006e1	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR userpath$[rsp]
  006e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN19@calculate_:

; 656  :     }
; 657  :     if (machinepath) {

  006ef	48 83 7c 24 20
	00		 cmp	 QWORD PTR machinepath$[rsp], 0
  006f5	74 5a		 je	 SHORT $LN18@calculate_

; 658  :         wcscpy(buf, machinepath);

  006f7	48 8b 54 24 20	 mov	 rdx, QWORD PTR machinepath$[rsp]
  006fc	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00704	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 659  :         buf = wcschr(buf, L'\0');

  0070a	33 d2		 xor	 edx, edx
  0070c	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00714	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  0071a	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 660  :         *buf++ = DELIM;

  00722	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  00727	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0072f	66 89 01	 mov	 WORD PTR [rcx], ax
  00732	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0073a	48 83 c0 02	 add	 rax, 2
  0073e	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 661  :         free(machinepath);

  00746	48 8b 4c 24 20	 mov	 rcx, QWORD PTR machinepath$[rsp]
  0074b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN18@calculate_:

; 662  :     }
; 663  :     if (pythonhome == NULL) {

  00751	48 83 bc 24 68
	02 00 00 00	 cmp	 QWORD PTR pythonhome$[rsp], 0
  0075a	75 3c		 jne	 SHORT $LN17@calculate_

; 664  :         if (!skipdefault) {

  0075c	83 bc 24 58 02
	00 00 00	 cmp	 DWORD PTR skipdefault$[rsp], 0
  00764	75 2d		 jne	 SHORT $LN16@calculate_

; 665  :             wcscpy(buf, PYTHONPATH);

  00766	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@
  0076d	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00775	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 666  :             buf = wcschr(buf, L'\0');

  0077b	33 d2		 xor	 edx, edx
  0077d	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00785	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  0078b	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax
$LN16@calculate_:

; 667  :         }
; 668  :     }
; 669  : #else
; 670  :     if (pythonhome == NULL) {
; 671  :         wcscpy(buf, PYTHONPATH);
; 672  :         buf = wcschr(buf, L'\0');
; 673  :     }
; 674  : #endif /* MS_WINDOWS */
; 675  :     else {

  00793	e9 6b 01 00 00	 jmp	 $LN15@calculate_
$LN17@calculate_:

; 676  :         wchar_t *p = PYTHONPATH;

  00798	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1BK@PICAMADE@?$AA?4?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?$DL?$AA?4?$AA?2?$AAl?$AAi?$AAb?$AA?$AA@
  0079f	48 89 84 24 b0
	06 00 00	 mov	 QWORD PTR p$120722[rsp], rax
$LN14@calculate_:

; 677  :         wchar_t *q;
; 678  :         size_t n;
; 679  :         for (;;) {
; 680  :             q = wcschr(p, DELIM);

  007a7	66 ba 3b 00	 mov	 dx, 59			; 0000003bH
  007ab	48 8b 8c 24 b0
	06 00 00	 mov	 rcx, QWORD PTR p$120722[rsp]
  007b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  007b9	48 89 84 24 c0
	06 00 00	 mov	 QWORD PTR q$120723[rsp], rax

; 681  :             if (q == NULL)

  007c1	48 83 bc 24 c0
	06 00 00 00	 cmp	 QWORD PTR q$120723[rsp], 0
  007ca	75 18		 jne	 SHORT $LN12@calculate_

; 682  :                 n = wcslen(p);

  007cc	48 8b 8c 24 b0
	06 00 00	 mov	 rcx, QWORD PTR p$120722[rsp]
  007d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  007da	48 89 84 24 b8
	06 00 00	 mov	 QWORD PTR n$120724[rsp], rax

; 683  :             else

  007e2	eb 21		 jmp	 SHORT $LN11@calculate_
$LN12@calculate_:

; 684  :                 n = q-p;

  007e4	48 8b 84 24 b0
	06 00 00	 mov	 rax, QWORD PTR p$120722[rsp]
  007ec	48 8b 8c 24 c0
	06 00 00	 mov	 rcx, QWORD PTR q$120723[rsp]
  007f4	48 2b c8	 sub	 rcx, rax
  007f7	48 8b c1	 mov	 rax, rcx
  007fa	48 d1 f8	 sar	 rax, 1
  007fd	48 89 84 24 b8
	06 00 00	 mov	 QWORD PTR n$120724[rsp], rax
$LN11@calculate_:

; 685  :             if (p[0] == '.' && is_sep(p[1])) {

  00805	48 8b 84 24 b0
	06 00 00	 mov	 rax, QWORD PTR p$120722[rsp]
  0080d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00810	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00813	75 6a		 jne	 SHORT $LN10@calculate_
  00815	48 8b 84 24 b0
	06 00 00	 mov	 rax, QWORD PTR p$120722[rsp]
  0081d	0f b7 48 02	 movzx	 ecx, WORD PTR [rax+2]
  00821	e8 00 00 00 00	 call	 is_sep
  00826	85 c0		 test	 eax, eax
  00828	74 55		 je	 SHORT $LN10@calculate_

; 686  :                 wcscpy(buf, pythonhome);

  0082a	48 8b 94 24 68
	02 00 00	 mov	 rdx, QWORD PTR pythonhome$[rsp]
  00832	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0083a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 687  :                 buf = wcschr(buf, L'\0');

  00840	33 d2		 xor	 edx, edx
  00842	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0084a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  00850	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 688  :                 p++;

  00858	48 8b 84 24 b0
	06 00 00	 mov	 rax, QWORD PTR p$120722[rsp]
  00860	48 83 c0 02	 add	 rax, 2
  00864	48 89 84 24 b0
	06 00 00	 mov	 QWORD PTR p$120722[rsp], rax

; 689  :                 n--;

  0086c	48 8b 84 24 b8
	06 00 00	 mov	 rax, QWORD PTR n$120724[rsp]
  00874	48 ff c8	 dec	 rax
  00877	48 89 84 24 b8
	06 00 00	 mov	 QWORD PTR n$120724[rsp], rax
$LN10@calculate_:

; 690  :             }
; 691  :             wcsncpy(buf, p, n);

  0087f	4c 8b 84 24 b8
	06 00 00	 mov	 r8, QWORD PTR n$120724[rsp]
  00887	48 8b 94 24 b0
	06 00 00	 mov	 rdx, QWORD PTR p$120722[rsp]
  0088f	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00897	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 692  :             buf += n;

  0089d	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  008a5	48 8b 8c 24 b8
	06 00 00	 mov	 rcx, QWORD PTR n$120724[rsp]
  008ad	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  008b1	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 693  :             if (q == NULL)

  008b9	48 83 bc 24 c0
	06 00 00 00	 cmp	 QWORD PTR q$120723[rsp], 0
  008c2	75 02		 jne	 SHORT $LN9@calculate_

; 694  :                 break;

  008c4	eb 3d		 jmp	 SHORT $LN13@calculate_
$LN9@calculate_:

; 695  :             *buf++ = DELIM;

  008c6	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  008cb	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  008d3	66 89 01	 mov	 WORD PTR [rcx], ax
  008d6	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  008de	48 83 c0 02	 add	 rax, 2
  008e2	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 696  :             p = q+1;

  008ea	48 8b 84 24 c0
	06 00 00	 mov	 rax, QWORD PTR q$120723[rsp]
  008f2	48 83 c0 02	 add	 rax, 2
  008f6	48 89 84 24 b0
	06 00 00	 mov	 QWORD PTR p$120722[rsp], rax

; 697  :         }

  008fe	e9 a4 fe ff ff	 jmp	 $LN14@calculate_
$LN13@calculate_:
$LN15@calculate_:

; 698  :     }
; 699  :     if (argv0_path) {

  00903	48 8d 84 24 70
	02 00 00	 lea	 rax, QWORD PTR argv0_path$[rsp]
  0090b	48 85 c0	 test	 rax, rax
  0090e	74 52		 je	 SHORT $LN8@calculate_

; 700  :         *buf++ = DELIM;

  00910	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  00915	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0091d	66 89 01	 mov	 WORD PTR [rcx], ax
  00920	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00928	48 83 c0 02	 add	 rax, 2
  0092c	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 701  :         wcscpy(buf, argv0_path);

  00934	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR argv0_path$[rsp]
  0093c	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00944	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 702  :         buf = wcschr(buf, L'\0');

  0094a	33 d2		 xor	 edx, edx
  0094c	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00954	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  0095a	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax
$LN8@calculate_:

; 703  :     }
; 704  :     *buf = L'\0';

  00962	33 c0		 xor	 eax, eax
  00964	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0096c	66 89 01	 mov	 WORD PTR [rcx], ax

; 705  :     /* Now to pull one last hack/trick.  If sys.prefix is
; 706  :        empty, then try and find it somewhere on the paths
; 707  :        we calculated.  We scan backwards, as our general policy
; 708  :        is that Python core directories are at the *end* of
; 709  :        sys.path.  We assume that our "lib" directory is
; 710  :        on the path, and that our 'prefix' directory is
; 711  :        the parent of that.
; 712  :     */
; 713  :     if (*prefix==L'\0') {

  0096f	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR prefix
  00976	85 c0		 test	 eax, eax
  00978	0f 85 11 01 00
	00		 jne	 $LN7@calculate_

; 714  :         wchar_t lookBuf[MAXPATHLEN+1];
; 715  :         wchar_t *look = buf - 1; /* 'buf' is at the end of the buffer */

  0097e	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00986	48 83 e8 02	 sub	 rax, 2
  0098a	48 89 84 24 e0
	08 00 00	 mov	 QWORD PTR look$120737[rsp], rax
$LN6@calculate_:

; 716  :         while (1) {

  00992	33 c0		 xor	 eax, eax
  00994	83 f8 01	 cmp	 eax, 1
  00997	0f 84 f2 00 00
	00		 je	 $LN5@calculate_

; 717  :             Py_ssize_t nchars;
; 718  :             wchar_t *lookEnd = look;

  0099d	48 8b 84 24 e0
	08 00 00	 mov	 rax, QWORD PTR look$120737[rsp]
  009a5	48 89 84 24 e8
	08 00 00	 mov	 QWORD PTR lookEnd$120742[rsp], rax
$LN4@calculate_:

; 719  :             /* 'look' will end up one character before the
; 720  :                start of the path in question - even if this
; 721  :                is one character before the start of the buffer
; 722  :             */
; 723  :             while (look >= module_search_path && *look != DELIM)

  009ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR module_search_path
  009b4	48 39 84 24 e0
	08 00 00	 cmp	 QWORD PTR look$120737[rsp], rax
  009bc	72 26		 jb	 SHORT $LN3@calculate_
  009be	48 8b 84 24 e0
	08 00 00	 mov	 rax, QWORD PTR look$120737[rsp]
  009c6	0f b7 00	 movzx	 eax, WORD PTR [rax]
  009c9	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  009cc	74 16		 je	 SHORT $LN3@calculate_

; 724  :                 look--;

  009ce	48 8b 84 24 e0
	08 00 00	 mov	 rax, QWORD PTR look$120737[rsp]
  009d6	48 83 e8 02	 sub	 rax, 2
  009da	48 89 84 24 e0
	08 00 00	 mov	 QWORD PTR look$120737[rsp], rax
  009e2	eb c9		 jmp	 SHORT $LN4@calculate_
$LN3@calculate_:

; 725  :             nchars = lookEnd-look;

  009e4	48 8b 84 24 e0
	08 00 00	 mov	 rax, QWORD PTR look$120737[rsp]
  009ec	48 8b 8c 24 e8
	08 00 00	 mov	 rcx, QWORD PTR lookEnd$120742[rsp]
  009f4	48 2b c8	 sub	 rcx, rax
  009f7	48 8b c1	 mov	 rax, rcx
  009fa	48 d1 f8	 sar	 rax, 1
  009fd	48 89 84 24 f0
	08 00 00	 mov	 QWORD PTR nchars$120741[rsp], rax

; 726  :             wcsncpy(lookBuf, look+1, nchars);

  00a05	48 8b 84 24 e0
	08 00 00	 mov	 rax, QWORD PTR look$120737[rsp]
  00a0d	48 83 c0 02	 add	 rax, 2
  00a11	4c 8b 84 24 f0
	08 00 00	 mov	 r8, QWORD PTR nchars$120741[rsp]
  00a19	48 8b d0	 mov	 rdx, rax
  00a1c	48 8d 8c 24 d0
	06 00 00	 lea	 rcx, QWORD PTR lookBuf$120736[rsp]
  00a24	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 727  :             lookBuf[nchars] = L'\0';

  00a2a	33 c0		 xor	 eax, eax
  00a2c	48 8b 8c 24 f0
	08 00 00	 mov	 rcx, QWORD PTR nchars$120741[rsp]
  00a34	66 89 84 4c d0
	06 00 00	 mov	 WORD PTR lookBuf$120736[rsp+rcx*2], ax

; 728  :             /* Up one level to the parent */
; 729  :             reduce(lookBuf);

  00a3c	48 8d 8c 24 d0
	06 00 00	 lea	 rcx, QWORD PTR lookBuf$120736[rsp]
  00a44	e8 00 00 00 00	 call	 reduce

; 730  :             if (search_for_prefix(lookBuf, LANDMARK)) {

  00a49	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BE@BGJONEDM@?$AAl?$AAi?$AAb?$AA?2?$AAo?$AAs?$AA?4?$AAp?$AAy?$AA?$AA@
  00a50	48 8d 8c 24 d0
	06 00 00	 lea	 rcx, QWORD PTR lookBuf$120736[rsp]
  00a58	e8 00 00 00 00	 call	 search_for_prefix
  00a5d	85 c0		 test	 eax, eax
  00a5f	74 02		 je	 SHORT $LN2@calculate_

; 731  :                 break;

  00a61	eb 2c		 jmp	 SHORT $LN5@calculate_
$LN2@calculate_:

; 732  :             }
; 733  :             /* If we are out of paths to search - give up */
; 734  :             if (look < module_search_path)

  00a63	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR module_search_path
  00a6a	48 39 84 24 e0
	08 00 00	 cmp	 QWORD PTR look$120737[rsp], rax
  00a72	73 02		 jae	 SHORT $LN1@calculate_

; 735  :                 break;

  00a74	eb 19		 jmp	 SHORT $LN5@calculate_
$LN1@calculate_:

; 736  :             look--;

  00a76	48 8b 84 24 e0
	08 00 00	 mov	 rax, QWORD PTR look$120737[rsp]
  00a7e	48 83 e8 02	 sub	 rax, 2
  00a82	48 89 84 24 e0
	08 00 00	 mov	 QWORD PTR look$120737[rsp], rax

; 737  :         }

  00a8a	e9 03 ff ff ff	 jmp	 $LN6@calculate_
$LN5@calculate_:
$LN7@calculate_:
$LN51@calculate_:

; 738  :     }
; 739  : }

  00a8f	48 81 c4 08 09
	00 00		 add	 rsp, 2312		; 00000908H
  00a96	c3		 ret	 0
calculate_path ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_sep DD imagerel is_sep
	DD	imagerel is_sep+53
	DD	imagerel $unwind$is_sep
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_sep DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT is_sep
_TEXT	SEGMENT
tv68 = 0
ch$ = 32
is_sep	PROC						; COMDAT

; 102  : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 18	 sub	 rsp, 24

; 103  : #ifdef ALTSEP
; 104  :     return ch == SEP || ch == ALTSEP;

  00009	0f b7 44 24 20	 movzx	 eax, WORD PTR ch$[rsp]
  0000e	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00011	74 13		 je	 SHORT $LN3@is_sep
  00013	0f b7 44 24 20	 movzx	 eax, WORD PTR ch$[rsp]
  00018	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0001b	74 09		 je	 SHORT $LN3@is_sep
  0001d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
  00024	eb 07		 jmp	 SHORT $LN4@is_sep
$LN3@is_sep:
  00026	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv68[rsp], 1
$LN4@is_sep:
  0002d	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]

; 105  : #else
; 106  :     return ch == SEP;
; 107  : #endif
; 108  : }

  00030	48 83 c4 18	 add	 rsp, 24
  00034	c3		 ret	 0
is_sep	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$reduce DD imagerel reduce
	DD	imagerel reduce+92
	DD	imagerel $unwind$reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$reduce DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT reduce
_TEXT	SEGMENT
i$ = 32
dir$ = 64
reduce	PROC						; COMDAT

; 115  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 116  :     size_t i = wcslen(dir);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dir$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00014	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN2@reduce:

; 117  :     while (i > 0 && !is_sep(dir[i]))

  00019	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$[rsp], 0
  0001f	76 26		 jbe	 SHORT $LN1@reduce
  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR dir$[rsp]
  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0002b	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]
  0002f	e8 00 00 00 00	 call	 is_sep
  00034	85 c0		 test	 eax, eax
  00036	75 0f		 jne	 SHORT $LN1@reduce

; 118  :         --i;

  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0003d	48 ff c8	 dec	 rax
  00040	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  00045	eb d2		 jmp	 SHORT $LN2@reduce
$LN1@reduce:

; 119  :     dir[i] = '\0';

  00047	33 c0		 xor	 eax, eax
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dir$[rsp]
  0004e	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00053	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax

; 120  : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
reduce	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@EFCACFEH@buffer?5overflow?5in?5getpathp?4c?8s?5@ ; `string'
EXTRN	Py_FatalError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$join DD	imagerel join
	DD	imagerel join+276
	DD	imagerel $unwind$join
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$join DD	010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CL@EFCACFEH@buffer?5overflow?5in?5getpathp?4c?8s?5@
CONST	SEGMENT
??_C@_0CL@EFCACFEH@buffer?5overflow?5in?5getpathp?4c?8s?5@ DB 'buffer ove'
	DB	'rflow in getpathp.c''s joinpath()', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT join
_TEXT	SEGMENT
n$ = 32
k$ = 40
buffer$ = 64
stuff$ = 72
join	PROC						; COMDAT

; 158  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 159  :     size_t n, k;
; 160  :     if (is_sep(stuff[0]))

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR stuff$[rsp]
  00013	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00016	e8 00 00 00 00	 call	 is_sep
  0001b	85 c0		 test	 eax, eax
  0001d	74 0b		 je	 SHORT $LN5@join

; 161  :         n = 0;

  0001f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0

; 162  :     else {

  00028	eb 5b		 jmp	 SHORT $LN4@join
$LN5@join:

; 163  :         n = wcslen(buffer);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00035	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 164  :         if (n > 0 && !is_sep(buffer[n-1]) && n < MAXPATHLEN)

  0003a	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  00040	76 43		 jbe	 SHORT $LN3@join
  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  0004c	0f b7 4c 48 fe	 movzx	 ecx, WORD PTR [rax+rcx*2-2]
  00051	e8 00 00 00 00	 call	 is_sep
  00056	85 c0		 test	 eax, eax
  00058	75 2b		 jne	 SHORT $LN3@join
  0005a	48 81 7c 24 20
	00 01 00 00	 cmp	 QWORD PTR n$[rsp], 256	; 00000100H
  00063	73 20		 jae	 SHORT $LN3@join

; 165  :             buffer[n++] = SEP;

  00065	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  0006a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  0006f	48 8b 54 24 20	 mov	 rdx, QWORD PTR n$[rsp]
  00074	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  0007d	48 ff c0	 inc	 rax
  00080	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax
$LN3@join:
$LN4@join:

; 166  :     }
; 167  :     if (n > MAXPATHLEN)

  00085	48 81 7c 24 20
	00 01 00 00	 cmp	 QWORD PTR n$[rsp], 256	; 00000100H
  0008e	76 0c		 jbe	 SHORT $LN2@join

; 168  :         Py_FatalError("buffer overflow in getpathp.c's joinpath()");

  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CL@EFCACFEH@buffer?5overflow?5in?5getpathp?4c?8s?5@
  00097	e8 00 00 00 00	 call	 Py_FatalError
$LN2@join:

; 169  :     k = wcslen(stuff);

  0009c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR stuff$[rsp]
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  000a7	48 89 44 24 28	 mov	 QWORD PTR k$[rsp], rax

; 170  :     if (n + k > MAXPATHLEN)

  000ac	48 8b 44 24 28	 mov	 rax, QWORD PTR k$[rsp]
  000b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  000b6	48 03 c8	 add	 rcx, rax
  000b9	48 8b c1	 mov	 rax, rcx
  000bc	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  000c2	76 0f		 jbe	 SHORT $LN1@join

; 171  :         k = MAXPATHLEN - n;

  000c4	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  000c9	48 2b 44 24 20	 sub	 rax, QWORD PTR n$[rsp]
  000ce	48 89 44 24 28	 mov	 QWORD PTR k$[rsp], rax
$LN1@join:

; 172  :     wcsncpy(buffer+n, stuff, k);

  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR buffer$[rsp]
  000d8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  000dd	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  000e1	4c 8b 44 24 28	 mov	 r8, QWORD PTR k$[rsp]
  000e6	48 8b 54 24 48	 mov	 rdx, QWORD PTR stuff$[rsp]
  000eb	48 8b c8	 mov	 rcx, rax
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 173  :     buffer[n+k] = '\0';

  000f4	48 8b 44 24 28	 mov	 rax, QWORD PTR k$[rsp]
  000f9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  000fe	48 03 c8	 add	 rcx, rax
  00101	48 8b c1	 mov	 rax, rcx
  00104	33 c9		 xor	 ecx, ecx
  00106	48 8b 54 24 40	 mov	 rdx, QWORD PTR buffer$[rsp]
  0010b	66 89 0c 42	 mov	 WORD PTR [rdx+rax*2], cx

; 174  : }

  0010f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00113	c3		 ret	 0
join	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$search_for_prefix DD imagerel search_for_prefix
	DD	imagerel search_for_prefix+83
	DD	imagerel $unwind$search_for_prefix
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$search_for_prefix DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT search_for_prefix
_TEXT	SEGMENT
argv0_path$ = 48
landmark$ = 56
search_for_prefix PROC					; COMDAT

; 197  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 198  :     /* Search from argv0_path, until landmark is found */
; 199  :     wcscpy(prefix, argv0_path);

  0000e	48 8b 54 24 30	 mov	 rdx, QWORD PTR argv0_path$[rsp]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prefix
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy
$LN4@search_for:

; 200  :     do {
; 201  :         if (gotlandmark(landmark))

  00020	48 8b 4c 24 38	 mov	 rcx, QWORD PTR landmark$[rsp]
  00025	e8 00 00 00 00	 call	 gotlandmark
  0002a	85 c0		 test	 eax, eax
  0002c	74 07		 je	 SHORT $LN1@search_for

; 202  :             return 1;

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	eb 19		 jmp	 SHORT $LN5@search_for
$LN1@search_for:

; 203  :         reduce(prefix);

  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prefix
  0003c	e8 00 00 00 00	 call	 reduce

; 204  :     } while (prefix[0]);

  00041	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR prefix
  00048	85 c0		 test	 eax, eax
  0004a	75 d4		 jne	 SHORT $LN4@search_for

; 205  :     return 0;

  0004c	33 c0		 xor	 eax, eax
$LN5@search_for:

; 206  : }

  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	c3		 ret	 0
search_for_prefix ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gotlandmark DD imagerel gotlandmark
	DD	imagerel gotlandmark+87
	DD	imagerel $unwind$gotlandmark
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gotlandmark DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gotlandmark
_TEXT	SEGMENT
n$ = 32
ok$ = 40
landmark$ = 64
gotlandmark PROC					; COMDAT

; 182  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 183  :     int ok;
; 184  :     Py_ssize_t n;
; 185  : 
; 186  :     n = wcslen(prefix);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prefix
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00016	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 187  :     join(prefix, landmark);

  0001b	48 8b 54 24 40	 mov	 rdx, QWORD PTR landmark$[rsp]
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prefix
  00027	e8 00 00 00 00	 call	 join

; 188  :     ok = ismodule(prefix);

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:prefix
  00033	e8 00 00 00 00	 call	 ismodule
  00038	89 44 24 28	 mov	 DWORD PTR ok$[rsp], eax

; 189  :     prefix[n] = '\0';

  0003c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:prefix
  00043	33 c9		 xor	 ecx, ecx
  00045	48 8b 54 24 20	 mov	 rdx, QWORD PTR n$[rsp]
  0004a	66 89 0c 50	 mov	 WORD PTR [rax+rdx*2], cx

; 190  :     return ok;

  0004e	8b 44 24 28	 mov	 eax, DWORD PTR ok$[rsp]

; 191  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
gotlandmark ENDP
_TEXT	ENDS
PUBLIC	??_C@_13PHCIHIAO@?$AAc?$AA?$AA@			; `string'
PUBLIC	??_C@_13LNPOMHLG@?$AAo?$AA?$AA@			; `string'
EXTRN	__imp_wcscat:PROC
EXTRN	Py_OptimizeFlag:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$ismodule DD imagerel ismodule
	DD	imagerel ismodule+128
	DD	imagerel $unwind$ismodule
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ismodule DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_13PHCIHIAO@?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_13PHCIHIAO@?$AAc?$AA?$AA@ DB 'c', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13LNPOMHLG@?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_13LNPOMHLG@?$AAo?$AA?$AA@ DB 'o', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ismodule
_TEXT	SEGMENT
tv72 = 32
filename$ = 64
ismodule PROC						; COMDAT

; 134  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 135  :     if (exists(filename))

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  0000e	e8 00 00 00 00	 call	 exists
  00013	85 c0		 test	 eax, eax
  00015	74 07		 je	 SHORT $LN3@ismodule

; 136  :         return 1;

  00017	b8 01 00 00 00	 mov	 eax, 1
  0001c	eb 5d		 jmp	 SHORT $LN4@ismodule
$LN3@ismodule:

; 137  : 
; 138  :     /* Check for the compiled version of prefix. */
; 139  :     if (wcslen(filename) < MAXPATHLEN) {

  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00029	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  0002f	73 48		 jae	 SHORT $LN2@ismodule

; 140  :         wcscat(filename, Py_OptimizeFlag ? L"o" : L"c");

  00031	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_OptimizeFlag, 0
  00038	74 0e		 je	 SHORT $LN6@ismodule
  0003a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_13LNPOMHLG@?$AAo?$AA?$AA@
  00041	48 89 44 24 20	 mov	 QWORD PTR tv72[rsp], rax
  00046	eb 0c		 jmp	 SHORT $LN7@ismodule
$LN6@ismodule:
  00048	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_13PHCIHIAO@?$AAc?$AA?$AA@
  0004f	48 89 44 24 20	 mov	 QWORD PTR tv72[rsp], rax
$LN7@ismodule:
  00054	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv72[rsp]
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscat

; 141  :         if (exists(filename))

  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00069	e8 00 00 00 00	 call	 exists
  0006e	85 c0		 test	 eax, eax
  00070	74 07		 je	 SHORT $LN1@ismodule

; 142  :             return 1;

  00072	b8 01 00 00 00	 mov	 eax, 1
  00077	eb 02		 jmp	 SHORT $LN4@ismodule
$LN1@ismodule:
$LN2@ismodule:

; 143  :     }
; 144  :     return 0;

  00079	33 c0		 xor	 eax, eax
$LN4@ismodule:

; 145  : }

  0007b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007f	c3		 ret	 0
ismodule ENDP
_TEXT	ENDS
EXTRN	__imp_GetFileAttributesW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$exists DD imagerel exists
	DD	imagerel exists+52
	DD	imagerel $unwind$exists
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$exists DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT exists
_TEXT	SEGMENT
tv67 = 32
filename$ = 64
exists	PROC						; COMDAT

; 125  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 126  :     return GetFileAttributesW(filename) != 0xFFFFFFFF;

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesW
  00014	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00017	74 0a		 je	 SHORT $LN3@exists
  00019	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  00021	eb 08		 jmp	 SHORT $LN4@exists
$LN3@exists:
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@exists:
  0002b	8b 44 24 20	 mov	 eax, DWORD PTR tv67[rsp]

; 127  : }

  0002f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00033	c3		 ret	 0
exists	ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@HCFKPKKA@?$AAd?$AAa?$AAt?$AAa?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AAl?$AAe?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@DAEHDGFN@?$AA?4?$AA?4?$AA?2?$AAP?$AAC?$AA?2?$AAg?$AAe?$AAt?$AAp?$AAa?$AAt?$AAh?$AAp?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	__imp__wassert:PROC
EXTRN	__imp_RegCloseKey:PROC
EXTRN	__imp_RegQueryValueExW:PROC
EXTRN	__imp_RegEnumKeyExW:PROC
EXTRN	memset:PROC
EXTRN	__imp_RegQueryInfoKeyA:PROC
EXTRN	__imp_RegOpenKeyExW:PROC
EXTRN	__imp_mbstowcs:PROC
EXTRN	memcpy:PROC
EXTRN	strlen:PROC
EXTRN	PyWin_DLLVersionString:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$getpythonregpath DD imagerel getpythonregpath
	DD	imagerel getpythonregpath+1712
	DD	imagerel $unwind$getpythonregpath
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getpythonregpath DD 021001H
	DD	05f0110H
xdata	ENDS
;	COMDAT ??_C@_1CM@HCFKPKKA@?$AAd?$AAa?$AAt?$AAa?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AAl?$AAe?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@HCFKPKKA@?$AAd?$AAa?$AAt?$AAa?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AAl?$AAe?$AAn?$AA?$AA@ DB 'd'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, 'S', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, ' ', 00H, '>', 00H, ' ', 00H, '(', 00H, 'D', 00H, 'W'
	DB	00H, 'O', 00H, 'R', 00H, 'D', 00H, ')', 00H, 'l', 00H, 'e', 00H
	DB	'n', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DAEHDGFN@?$AA?4?$AA?4?$AA?2?$AAP?$AAC?$AA?2?$AAg?$AAe?$AAt?$AAp?$AAa?$AAt?$AAh?$AAp?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@DAEHDGFN@?$AA?4?$AA?4?$AA?2?$AAP?$AAC?$AA?2?$AAg?$AAe?$AAt?$AAp?$AAa?$AAt?$AAh?$AAp?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'C', 00H, '\', 00H, 'g', 00H
	DB	'e', 00H, 't', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'h', 00H, 'p'
	DB	00H, '.', 00H, 'c', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT getpythonregpath
_TEXT	SEGMENT
newKey$ = 96
versionLen$ = 104
rc$ = 112
keyBufPtr$ = 120
retval$ = 128
index$ = 136
keyBuf$ = 144
dataSize$ = 152
numKeys$ = 156
dataBuf$ = 160
ppPaths$ = 168
subKey$120515 = 176
rc$120517 = 184
keyBuf$120514 = 192
reqdSize$120516 = 720
szCur$120535 = 728
reqdSize$120536 = 736
len$120542 = 744
keyBase$ = 768
skipcore$ = 776
getpythonregpath PROC					; COMDAT

; 230  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec f8 02
	00 00		 sub	 rsp, 760		; 000002f8H

; 231  :     HKEY newKey = 0;

  00010	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR newKey$[rsp], 0

; 232  :     DWORD dataSize = 0;

  00019	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR dataSize$[rsp], 0

; 233  :     DWORD numKeys = 0;

  00024	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR numKeys$[rsp], 0

; 234  :     LONG rc;
; 235  :     wchar_t *retval = NULL;

  0002f	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR retval$[rsp], 0

; 236  :     WCHAR *dataBuf = NULL;

  0003b	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR dataBuf$[rsp], 0

; 237  :     static const WCHAR keyPrefix[] = L"Software\\Python\\PythonCore\\";
; 238  :     static const WCHAR keySuffix[] = L"\\PythonPath";
; 239  :     size_t versionLen;
; 240  :     DWORD index;
; 241  :     WCHAR *keyBuf = NULL;

  00047	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR keyBuf$[rsp], 0

; 242  :     WCHAR *keyBufPtr;
; 243  :     WCHAR **ppPaths = NULL;

  00053	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ppPaths$[rsp], 0

; 244  : 
; 245  :     /* Tried to use sysget("winver") but here is too early :-( */
; 246  :     versionLen = strlen(PyWin_DLLVersionString);

  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyWin_DLLVersionString
  00066	e8 00 00 00 00	 call	 strlen
  0006b	48 89 44 24 68	 mov	 QWORD PTR versionLen$[rsp], rax

; 247  :     /* Space for all the chars, plus one \0 */
; 248  :     keyBuf = keyBufPtr = malloc(sizeof(keyPrefix) +
; 249  :                                 sizeof(WCHAR)*(versionLen-1) +
; 250  :                                 sizeof(keySuffix));

  00070	48 8b 44 24 68	 mov	 rax, QWORD PTR versionLen$[rsp]
  00075	48 8d 44 00 4e	 lea	 rax, QWORD PTR [rax+rax+78]
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00083	48 89 44 24 78	 mov	 QWORD PTR keyBufPtr$[rsp], rax
  00088	48 8b 44 24 78	 mov	 rax, QWORD PTR keyBufPtr$[rsp]
  0008d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR keyBuf$[rsp], rax

; 251  :     if (keyBuf==NULL) goto done;

  00095	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR keyBuf$[rsp], 0
  0009e	75 05		 jne	 SHORT $LN29@getpythonr
  000a0	e9 58 05 00 00	 jmp	 $done$120493
$LN29@getpythonr:

; 252  : 
; 253  :     memcpy(keyBufPtr, keyPrefix, sizeof(keyPrefix)-sizeof(WCHAR));

  000a5	41 b8 36 00 00
	00		 mov	 r8d, 54			; 00000036H
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?keyPrefix@?1??getpythonregpath@@9@9
  000b2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR keyBufPtr$[rsp]
  000b7	e8 00 00 00 00	 call	 memcpy

; 254  :     keyBufPtr += Py_ARRAY_LENGTH(keyPrefix) - 1;

  000bc	48 8b 44 24 78	 mov	 rax, QWORD PTR keyBufPtr$[rsp]
  000c1	48 83 c0 36	 add	 rax, 54			; 00000036H
  000c5	48 89 44 24 78	 mov	 QWORD PTR keyBufPtr$[rsp], rax

; 255  :     mbstowcs(keyBufPtr, PyWin_DLLVersionString, versionLen);

  000ca	4c 8b 44 24 68	 mov	 r8, QWORD PTR versionLen$[rsp]
  000cf	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyWin_DLLVersionString
  000d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR keyBufPtr$[rsp]
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mbstowcs

; 256  :     keyBufPtr += versionLen;

  000e1	48 8b 44 24 78	 mov	 rax, QWORD PTR keyBufPtr$[rsp]
  000e6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR versionLen$[rsp]
  000eb	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  000ef	48 89 44 24 78	 mov	 QWORD PTR keyBufPtr$[rsp], rax

; 257  :     /* NULL comes with this one! */
; 258  :     memcpy(keyBufPtr, keySuffix, sizeof(keySuffix));

  000f4	41 b8 18 00 00
	00		 mov	 r8d, 24
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?keySuffix@?1??getpythonregpath@@9@9
  00101	48 8b 4c 24 78	 mov	 rcx, QWORD PTR keyBufPtr$[rsp]
  00106	e8 00 00 00 00	 call	 memcpy

; 259  :     /* Open the root Python key */
; 260  :     rc=RegOpenKeyExW(keyBase,
; 261  :                     keyBuf, /* subkey */
; 262  :             0, /* reserved */
; 263  :             KEY_READ,
; 264  :             &newKey);

  0010b	48 8d 44 24 60	 lea	 rax, QWORD PTR newKey$[rsp]
  00110	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00115	41 b9 19 00 02
	00		 mov	 r9d, 131097		; 00020019H
  0011b	45 33 c0	 xor	 r8d, r8d
  0011e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR keyBuf$[rsp]
  00126	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR keyBase$[rsp]
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExW
  00134	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 265  :     if (rc!=ERROR_SUCCESS) goto done;

  00138	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  0013d	74 05		 je	 SHORT $LN28@getpythonr
  0013f	e9 b9 04 00 00	 jmp	 $done$120493
$LN28@getpythonr:

; 266  :     /* Find out how big our core buffer is, and how many subkeys we have */
; 267  :     rc = RegQueryInfoKey(newKey, NULL, NULL, NULL, &numKeys, NULL, NULL,
; 268  :                     NULL, NULL, &dataSize, NULL, NULL);

  00144	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  0014d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR [rsp+80], 0
  00156	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dataSize$[rsp]
  0015e	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00163	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0016c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00175	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0017e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00187	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR numKeys$[rsp]
  0018f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00194	45 33 c9	 xor	 r9d, r9d
  00197	45 33 c0	 xor	 r8d, r8d
  0019a	33 d2		 xor	 edx, edx
  0019c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newKey$[rsp]
  001a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryInfoKeyA
  001a7	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 269  :     if (rc!=ERROR_SUCCESS) goto done;

  001ab	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  001b0	74 05		 je	 SHORT $LN27@getpythonr
  001b2	e9 46 04 00 00	 jmp	 $done$120493
$LN27@getpythonr:

; 270  :     if (skipcore) dataSize = 0; /* Only count core ones if we want them! */

  001b7	83 bc 24 08 03
	00 00 00	 cmp	 DWORD PTR skipcore$[rsp], 0
  001bf	74 0b		 je	 SHORT $LN26@getpythonr
  001c1	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR dataSize$[rsp], 0
$LN26@getpythonr:

; 271  :     /* Allocate a temp array of char buffers, so we only need to loop
; 272  :        reading the registry once
; 273  :     */
; 274  :     ppPaths = malloc( sizeof(WCHAR *) * numKeys );

  001cc	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR numKeys$[rsp]
  001d3	48 c1 e0 03	 shl	 rax, 3
  001d7	48 8b c8	 mov	 rcx, rax
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001e0	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR ppPaths$[rsp], rax

; 275  :     if (ppPaths==NULL) goto done;

  001e8	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR ppPaths$[rsp], 0
  001f1	75 05		 jne	 SHORT $LN25@getpythonr
  001f3	e9 05 04 00 00	 jmp	 $done$120493
$LN25@getpythonr:

; 276  :     memset(ppPaths, 0, sizeof(WCHAR *) * numKeys);

  001f8	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR numKeys$[rsp]
  001ff	48 c1 e0 03	 shl	 rax, 3
  00203	4c 8b c0	 mov	 r8, rax
  00206	33 d2		 xor	 edx, edx
  00208	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ppPaths$[rsp]
  00210	e8 00 00 00 00	 call	 memset

; 277  :     /* Loop over all subkeys, allocating a temp sub-buffer. */
; 278  :     for(index=0;index<numKeys;index++) {

  00215	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR index$[rsp], 0
  00220	eb 10		 jmp	 SHORT $LN24@getpythonr
$LN23@getpythonr:
  00222	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR index$[rsp]
  00229	ff c0		 inc	 eax
  0022b	89 84 24 88 00
	00 00		 mov	 DWORD PTR index$[rsp], eax
$LN24@getpythonr:
  00232	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR numKeys$[rsp]
  00239	39 84 24 88 00
	00 00		 cmp	 DWORD PTR index$[rsp], eax
  00240	0f 83 8b 01 00
	00		 jae	 $LN22@getpythonr

; 279  :         WCHAR keyBuf[MAX_PATH+1];
; 280  :         HKEY subKey = 0;

  00246	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR subKey$120515[rsp], 0

; 281  :         DWORD reqdSize = MAX_PATH+1;

  00252	c7 84 24 d0 02
	00 00 05 01 00
	00		 mov	 DWORD PTR reqdSize$120516[rsp], 261 ; 00000105H

; 282  :         /* Get the sub-key name */
; 283  :         DWORD rc = RegEnumKeyExW(newKey, index, keyBuf, &reqdSize,
; 284  :                                  NULL, NULL, NULL, NULL );

  0025d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00266	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0026f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00278	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00281	4c 8d 8c 24 d0
	02 00 00	 lea	 r9, QWORD PTR reqdSize$120516[rsp]
  00289	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR keyBuf$120514[rsp]
  00291	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR index$[rsp]
  00298	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newKey$[rsp]
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegEnumKeyExW
  002a3	89 84 24 b8 00
	00 00		 mov	 DWORD PTR rc$120517[rsp], eax

; 285  :         if (rc!=ERROR_SUCCESS) goto done;

  002aa	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR rc$120517[rsp], 0
  002b2	74 05		 je	 SHORT $LN21@getpythonr
  002b4	e9 44 03 00 00	 jmp	 $done$120493
$LN21@getpythonr:

; 286  :         /* Open the sub-key */
; 287  :         rc=RegOpenKeyExW(newKey,
; 288  :                                         keyBuf, /* subkey */
; 289  :                         0, /* reserved */
; 290  :                         KEY_READ,
; 291  :                         &subKey);

  002b9	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR subKey$120515[rsp]
  002c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c6	41 b9 19 00 02
	00		 mov	 r9d, 131097		; 00020019H
  002cc	45 33 c0	 xor	 r8d, r8d
  002cf	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR keyBuf$120514[rsp]
  002d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newKey$[rsp]
  002dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExW
  002e2	89 84 24 b8 00
	00 00		 mov	 DWORD PTR rc$120517[rsp], eax

; 292  :         if (rc!=ERROR_SUCCESS) goto done;

  002e9	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR rc$120517[rsp], 0
  002f1	74 05		 je	 SHORT $LN20@getpythonr
  002f3	e9 05 03 00 00	 jmp	 $done$120493
$LN20@getpythonr:

; 293  :         /* Find the value of the buffer size, malloc, then read it */
; 294  :         RegQueryValueExW(subKey, NULL, 0, NULL, NULL, &reqdSize);

  002f8	48 8d 84 24 d0
	02 00 00	 lea	 rax, QWORD PTR reqdSize$120516[rsp]
  00300	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00305	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0030e	45 33 c9	 xor	 r9d, r9d
  00311	45 33 c0	 xor	 r8d, r8d
  00314	33 d2		 xor	 edx, edx
  00316	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR subKey$120515[rsp]
  0031e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExW

; 295  :         if (reqdSize) {

  00324	83 bc 24 d0 02
	00 00 00	 cmp	 DWORD PTR reqdSize$120516[rsp], 0
  0032c	0f 84 8c 00 00
	00		 je	 $LN19@getpythonr

; 296  :             ppPaths[index] = malloc(reqdSize);

  00332	8b 84 24 d0 02
	00 00		 mov	 eax, DWORD PTR reqdSize$120516[rsp]
  00339	8b c8		 mov	 ecx, eax
  0033b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00341	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR index$[rsp]
  00348	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR ppPaths$[rsp]
  00350	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 297  :             if (ppPaths[index]) {

  00354	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR index$[rsp]
  0035b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ppPaths$[rsp]
  00363	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00368	74 54		 je	 SHORT $LN18@getpythonr

; 298  :                 RegQueryValueExW(subKey, NULL, 0, NULL,
; 299  :                                 (LPBYTE)ppPaths[index],
; 300  :                                 &reqdSize);

  0036a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR index$[rsp]
  00371	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR reqdSize$120516[rsp]
  00379	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0037e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ppPaths$[rsp]
  00386	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0038a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0038f	45 33 c9	 xor	 r9d, r9d
  00392	45 33 c0	 xor	 r8d, r8d
  00395	33 d2		 xor	 edx, edx
  00397	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR subKey$120515[rsp]
  0039f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExW

; 301  :                 dataSize += reqdSize + 1; /* 1 for the ";" */

  003a5	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR dataSize$[rsp]
  003ac	8b 8c 24 d0 02
	00 00		 mov	 ecx, DWORD PTR reqdSize$120516[rsp]
  003b3	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  003b7	89 84 24 98 00
	00 00		 mov	 DWORD PTR dataSize$[rsp], eax
$LN18@getpythonr:
$LN19@getpythonr:

; 302  :             }
; 303  :         }
; 304  :         RegCloseKey(subKey);

  003be	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR subKey$120515[rsp]
  003c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey

; 305  :     }

  003cc	e9 51 fe ff ff	 jmp	 $LN23@getpythonr
$LN22@getpythonr:

; 306  : 
; 307  :     /* return null if no path to return */
; 308  :     if (dataSize == 0) goto done;

  003d1	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR dataSize$[rsp], 0
  003d9	75 05		 jne	 SHORT $LN17@getpythonr
  003db	e9 1d 02 00 00	 jmp	 $done$120493
$LN17@getpythonr:

; 309  : 
; 310  :     /* original datasize from RegQueryInfo doesn't include the \0 */
; 311  :     dataBuf = malloc((dataSize+1) * sizeof(WCHAR));

  003e0	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR dataSize$[rsp]
  003e7	ff c0		 inc	 eax
  003e9	8b c0		 mov	 eax, eax
  003eb	48 d1 e0	 shl	 rax, 1
  003ee	48 8b c8	 mov	 rcx, rax
  003f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  003f7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR dataBuf$[rsp], rax

; 312  :     if (dataBuf) {

  003ff	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dataBuf$[rsp], 0
  00408	0f 84 ef 01 00
	00		 je	 $LN16@getpythonr

; 313  :         WCHAR *szCur = dataBuf;

  0040e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dataBuf$[rsp]
  00416	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR szCur$120535[rsp], rax

; 314  :         DWORD reqdSize = dataSize;

  0041e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR dataSize$[rsp]
  00425	89 84 24 e0 02
	00 00		 mov	 DWORD PTR reqdSize$120536[rsp], eax

; 315  :         /* Copy our collected strings */
; 316  :         for (index=0;index<numKeys;index++) {

  0042c	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR index$[rsp], 0
  00437	eb 10		 jmp	 SHORT $LN15@getpythonr
$LN14@getpythonr:
  00439	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR index$[rsp]
  00440	ff c0		 inc	 eax
  00442	89 84 24 88 00
	00 00		 mov	 DWORD PTR index$[rsp], eax
$LN15@getpythonr:
  00449	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR numKeys$[rsp]
  00450	39 84 24 88 00
	00 00		 cmp	 DWORD PTR index$[rsp], eax
  00457	0f 83 08 01 00
	00		 jae	 $LN13@getpythonr

; 317  :             if (index > 0) {

  0045d	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR index$[rsp], 0
  00465	76 34		 jbe	 SHORT $LN12@getpythonr

; 318  :                 *(szCur++) = L';';

  00467	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  0046c	48 8b 8c 24 d8
	02 00 00	 mov	 rcx, QWORD PTR szCur$120535[rsp]
  00474	66 89 01	 mov	 WORD PTR [rcx], ax
  00477	48 8b 84 24 d8
	02 00 00	 mov	 rax, QWORD PTR szCur$120535[rsp]
  0047f	48 83 c0 02	 add	 rax, 2
  00483	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR szCur$120535[rsp], rax

; 319  :                 dataSize--;

  0048b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR dataSize$[rsp]
  00492	ff c8		 dec	 eax
  00494	89 84 24 98 00
	00 00		 mov	 DWORD PTR dataSize$[rsp], eax
$LN12@getpythonr:

; 320  :             }
; 321  :             if (ppPaths[index]) {

  0049b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR index$[rsp]
  004a2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ppPaths$[rsp]
  004aa	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  004af	0f 84 ab 00 00
	00		 je	 $LN11@getpythonr

; 322  :                 Py_ssize_t len = wcslen(ppPaths[index]);

  004b5	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR index$[rsp]
  004bc	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ppPaths$[rsp]
  004c4	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  004ce	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR len$120542[rsp], rax

; 323  :                 wcsncpy(szCur, ppPaths[index], len);

  004d6	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR index$[rsp]
  004dd	4c 8b 84 24 e8
	02 00 00	 mov	 r8, QWORD PTR len$120542[rsp]
  004e5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ppPaths$[rsp]
  004ed	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  004f1	48 8b 8c 24 d8
	02 00 00	 mov	 rcx, QWORD PTR szCur$120535[rsp]
  004f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 324  :                 szCur += len;

  004ff	48 8b 84 24 d8
	02 00 00	 mov	 rax, QWORD PTR szCur$120535[rsp]
  00507	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR len$120542[rsp]
  0050f	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00513	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR szCur$120535[rsp], rax

; 325  :                 assert(dataSize > (DWORD)len);

  0051b	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR len$120542[rsp]
  00522	39 84 24 98 00
	00 00		 cmp	 DWORD PTR dataSize$[rsp], eax
  00529	77 1c		 ja	 SHORT $LN32@getpythonr
  0052b	41 b8 45 01 00
	00		 mov	 r8d, 325		; 00000145H
  00531	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@DAEHDGFN@?$AA?4?$AA?4?$AA?2?$AAP?$AAC?$AA?2?$AAg?$AAe?$AAt?$AAp?$AAa?$AAt?$AAh?$AAp?$AA?4?$AAc?$AA?$AA@
  00538	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@HCFKPKKA@?$AAd?$AAa?$AAt?$AAa?$AAS?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA?$CI?$AAD?$AAW?$AAO?$AAR?$AAD?$AA?$CJ?$AAl?$AAe?$AAn?$AA?$AA@
  0053f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00545	33 c0		 xor	 eax, eax
$LN32@getpythonr:

; 326  :                 dataSize -= (DWORD)len;

  00547	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR len$120542[rsp]
  0054e	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR dataSize$[rsp]
  00555	2b c8		 sub	 ecx, eax
  00557	8b c1		 mov	 eax, ecx
  00559	89 84 24 98 00
	00 00		 mov	 DWORD PTR dataSize$[rsp], eax
$LN11@getpythonr:

; 327  :             }
; 328  :         }

  00560	e9 d4 fe ff ff	 jmp	 $LN14@getpythonr
$LN13@getpythonr:

; 329  :         if (skipcore)

  00565	83 bc 24 08 03
	00 00 00	 cmp	 DWORD PTR skipcore$[rsp], 0
  0056d	74 0f		 je	 SHORT $LN10@getpythonr

; 330  :             *szCur = '\0';

  0056f	33 c0		 xor	 eax, eax
  00571	48 8b 8c 24 d8
	02 00 00	 mov	 rcx, QWORD PTR szCur$120535[rsp]
  00579	66 89 01	 mov	 WORD PTR [rcx], ax

; 331  :         else {

  0057c	eb 6f		 jmp	 SHORT $LN9@getpythonr
$LN10@getpythonr:

; 332  :             /* If we have no values, we dont need a ';' */
; 333  :             if (numKeys) {

  0057e	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR numKeys$[rsp], 0
  00586	74 34		 je	 SHORT $LN8@getpythonr

; 334  :                 *(szCur++) = L';';

  00588	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  0058d	48 8b 8c 24 d8
	02 00 00	 mov	 rcx, QWORD PTR szCur$120535[rsp]
  00595	66 89 01	 mov	 WORD PTR [rcx], ax
  00598	48 8b 84 24 d8
	02 00 00	 mov	 rax, QWORD PTR szCur$120535[rsp]
  005a0	48 83 c0 02	 add	 rax, 2
  005a4	48 89 84 24 d8
	02 00 00	 mov	 QWORD PTR szCur$120535[rsp], rax

; 335  :                 dataSize--;

  005ac	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR dataSize$[rsp]
  005b3	ff c8		 dec	 eax
  005b5	89 84 24 98 00
	00 00		 mov	 DWORD PTR dataSize$[rsp], eax
$LN8@getpythonr:

; 336  :             }
; 337  :             /* Now append the core path entries -
; 338  :                this will include the NULL
; 339  :             */
; 340  :             rc = RegQueryValueExW(newKey, NULL, 0, NULL,
; 341  :                                   (LPBYTE)szCur, &dataSize);

  005bc	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dataSize$[rsp]
  005c4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005c9	48 8b 84 24 d8
	02 00 00	 mov	 rax, QWORD PTR szCur$120535[rsp]
  005d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005d6	45 33 c9	 xor	 r9d, r9d
  005d9	45 33 c0	 xor	 r8d, r8d
  005dc	33 d2		 xor	 edx, edx
  005de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newKey$[rsp]
  005e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExW
  005e9	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
$LN9@getpythonr:

; 342  :         }
; 343  :         /* And set the result - caller must free */
; 344  :         retval = dataBuf;

  005ed	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dataBuf$[rsp]
  005f5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR retval$[rsp], rax
$LN16@getpythonr:
$done$120493:

; 345  :     }
; 346  : done:
; 347  :     /* Loop freeing my temp buffers */
; 348  :     if (ppPaths) {

  005fd	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR ppPaths$[rsp], 0
  00606	74 6c		 je	 SHORT $LN7@getpythonr

; 349  :         for(index=0;index<numKeys;index++)

  00608	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR index$[rsp], 0
  00613	eb 10		 jmp	 SHORT $LN6@getpythonr
$LN5@getpythonr:
  00615	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR index$[rsp]
  0061c	ff c0		 inc	 eax
  0061e	89 84 24 88 00
	00 00		 mov	 DWORD PTR index$[rsp], eax
$LN6@getpythonr:
  00625	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR numKeys$[rsp]
  0062c	39 84 24 88 00
	00 00		 cmp	 DWORD PTR index$[rsp], eax
  00633	73 31		 jae	 SHORT $LN4@getpythonr

; 350  :             if (ppPaths[index]) free(ppPaths[index]);

  00635	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR index$[rsp]
  0063c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ppPaths$[rsp]
  00644	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00649	74 19		 je	 SHORT $LN3@getpythonr
  0064b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR index$[rsp]
  00652	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ppPaths$[rsp]
  0065a	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0065e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@getpythonr:

; 351  :         free(ppPaths);

  00664	eb af		 jmp	 SHORT $LN5@getpythonr
$LN4@getpythonr:
  00666	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ppPaths$[rsp]
  0066e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@getpythonr:

; 352  :     }
; 353  :     if (newKey)

  00674	48 83 7c 24 60
	00		 cmp	 QWORD PTR newKey$[rsp], 0
  0067a	74 0b		 je	 SHORT $LN2@getpythonr

; 354  :         RegCloseKey(newKey);

  0067c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newKey$[rsp]
  00681	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey
$LN2@getpythonr:

; 355  :     if (keyBuf)

  00687	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR keyBuf$[rsp], 0
  00690	74 0e		 je	 SHORT $LN1@getpythonr

; 356  :         free(keyBuf);

  00692	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR keyBuf$[rsp]
  0069a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@getpythonr:

; 357  :     return retval;

  006a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR retval$[rsp]

; 358  : }

  006a8	48 81 c4 f8 02
	00 00		 add	 rsp, 760		; 000002f8H
  006af	c3		 ret	 0
getpythonregpath ENDP
_TEXT	ENDS
PUBLIC	??_C@_1O@KDDPCNEL@?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_19IJOJOJIB@?$AAP?$AAA?$AAT?$AAH?$AA?$AA@	; `string'
EXTRN	__imp_GetModuleFileNameW:PROC
EXTRN	PyWin_DLLhModule:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_progpath DD imagerel get_progpath
	DD	imagerel get_progpath+485
	DD	imagerel $unwind$get_progpath
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_progpath DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_1O@KDDPCNEL@?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1O@KDDPCNEL@?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?$AA@ DB 'p', 00H, 'y'
	DB	00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19IJOJOJIB@?$AAP?$AAA?$AAT?$AAH?$AA?$AA@
CONST	SEGMENT
??_C@_19IJOJOJIB@?$AAP?$AAA?$AAT?$AAH?$AA?$AA@ DB 'P', 00H, 'A', 00H, 'T', 00H
	DB	'H', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT get_progpath
_TEXT	SEGMENT
prog$ = 32
path$ = 40
delim$120585 = 48
len$120587 = 56
tv133 = 64
get_progpath PROC					; COMDAT

; 364  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 365  :     extern wchar_t *Py_GetProgramName(void);
; 366  :     wchar_t *path = _wgetenv(L"PATH");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_19IJOJOJIB@?$AAP?$AAA?$AAT?$AAH?$AA?$AA@
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wgetenv
  00011	48 89 44 24 28	 mov	 QWORD PTR path$[rsp], rax

; 367  :     wchar_t *prog = Py_GetProgramName();

  00016	e8 00 00 00 00	 call	 Py_GetProgramName
  0001b	48 89 44 24 20	 mov	 QWORD PTR prog$[rsp], rax

; 368  : 
; 369  : #ifdef MS_WINDOWS
; 370  : #ifdef Py_ENABLE_SHARED
; 371  :     extern HANDLE PyWin_DLLhModule;
; 372  :     /* static init of progpath ensures final char remains \0 */
; 373  :     if (PyWin_DLLhModule)

  00020	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR PyWin_DLLhModule, 0
  00028	74 27		 je	 SHORT $LN16@get_progpa

; 374  :         if (!GetModuleFileNameW(PyWin_DLLhModule, dllpath, MAXPATHLEN))

  0002a	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:dllpath
  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyWin_DLLhModule
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameW
  00044	85 c0		 test	 eax, eax
  00046	75 09		 jne	 SHORT $LN15@get_progpa

; 375  :             dllpath[0] = 0;

  00048	33 c0		 xor	 eax, eax
  0004a	66 89 05 00 00
	00 00		 mov	 WORD PTR dllpath, ax
$LN15@get_progpa:
$LN16@get_progpa:

; 376  : #else
; 377  :     dllpath[0] = 0;
; 378  : #endif
; 379  :     if (GetModuleFileNameW(NULL, progpath, MAXPATHLEN))

  00051	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:progpath
  0005e	33 c9		 xor	 ecx, ecx
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameW
  00066	85 c0		 test	 eax, eax
  00068	74 05		 je	 SHORT $LN14@get_progpa

; 380  :         return;

  0006a	e9 71 01 00 00	 jmp	 $LN17@get_progpa
$LN14@get_progpa:

; 381  : #endif
; 382  :     if (prog == NULL || *prog == '\0')

  0006f	48 83 7c 24 20
	00		 cmp	 QWORD PTR prog$[rsp], 0
  00075	74 0c		 je	 SHORT $LN12@get_progpa
  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR prog$[rsp]
  0007c	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0007f	85 c0		 test	 eax, eax
  00081	75 0c		 jne	 SHORT $LN13@get_progpa
$LN12@get_progpa:

; 383  :         prog = L"python";

  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1O@KDDPCNEL@?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?$AA@
  0008a	48 89 44 24 20	 mov	 QWORD PTR prog$[rsp], rax
$LN13@get_progpa:

; 384  : 
; 385  :     /* If there is no slash in the argv0 path, then we have to
; 386  :      * assume python is on the user's $PATH, since there's no
; 387  :      * other way to find a directory to start the search from.  If
; 388  :      * $PATH isn't exported, you lose.
; 389  :      */
; 390  : #ifdef ALTSEP
; 391  :     if (wcschr(prog, SEP) || wcschr(prog, ALTSEP))

  0008f	66 ba 5c 00	 mov	 dx, 92			; 0000005cH
  00093	48 8b 4c 24 20	 mov	 rcx, QWORD PTR prog$[rsp]
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  0009e	48 85 c0	 test	 rax, rax
  000a1	75 14		 jne	 SHORT $LN10@get_progpa
  000a3	66 ba 2f 00	 mov	 dx, 47			; 0000002fH
  000a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR prog$[rsp]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  000b2	48 85 c0	 test	 rax, rax
  000b5	74 1d		 je	 SHORT $LN11@get_progpa
$LN10@get_progpa:

; 392  : #else
; 393  :     if (wcschr(prog, SEP))
; 394  : #endif
; 395  :         wcsncpy(progpath, prog, MAXPATHLEN);

  000b7	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  000bd	48 8b 54 24 20	 mov	 rdx, QWORD PTR prog$[rsp]
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:progpath
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy
  000cf	e9 0c 01 00 00	 jmp	 $LN9@get_progpa
$LN11@get_progpa:

; 396  :     else if (path) {

  000d4	48 83 7c 24 28
	00		 cmp	 QWORD PTR path$[rsp], 0
  000da	0f 84 f7 00 00
	00		 je	 $LN8@get_progpa
$LN7@get_progpa:

; 397  :         while (1) {

  000e0	33 c0		 xor	 eax, eax
  000e2	83 f8 01	 cmp	 eax, 1
  000e5	0f 84 ea 00 00
	00		 je	 $LN6@get_progpa

; 398  :             wchar_t *delim = wcschr(path, DELIM);

  000eb	66 ba 3b 00	 mov	 dx, 59			; 0000003bH
  000ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR path$[rsp]
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  000fa	48 89 44 24 30	 mov	 QWORD PTR delim$120585[rsp], rax

; 399  : 
; 400  :             if (delim) {

  000ff	48 83 7c 24 30
	00		 cmp	 QWORD PTR delim$120585[rsp], 0
  00105	74 6d		 je	 SHORT $LN5@get_progpa

; 401  :                 size_t len = delim - path;

  00107	48 8b 44 24 28	 mov	 rax, QWORD PTR path$[rsp]
  0010c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delim$120585[rsp]
  00111	48 2b c8	 sub	 rcx, rax
  00114	48 8b c1	 mov	 rax, rcx
  00117	48 d1 f8	 sar	 rax, 1
  0011a	48 89 44 24 38	 mov	 QWORD PTR len$120587[rsp], rax

; 402  :                 /* ensure we can't overwrite buffer */
; 403  :                 len = min(MAXPATHLEN,len);

  0011f	48 81 7c 24 38
	00 01 00 00	 cmp	 QWORD PTR len$120587[rsp], 256 ; 00000100H
  00128	76 0b		 jbe	 SHORT $LN19@get_progpa
  0012a	48 c7 44 24 40
	00 01 00 00	 mov	 QWORD PTR tv133[rsp], 256 ; 00000100H
  00133	eb 0a		 jmp	 SHORT $LN20@get_progpa
$LN19@get_progpa:
  00135	48 8b 44 24 38	 mov	 rax, QWORD PTR len$120587[rsp]
  0013a	48 89 44 24 40	 mov	 QWORD PTR tv133[rsp], rax
$LN20@get_progpa:
  0013f	48 8b 44 24 40	 mov	 rax, QWORD PTR tv133[rsp]
  00144	48 89 44 24 38	 mov	 QWORD PTR len$120587[rsp], rax

; 404  :                 wcsncpy(progpath, path, len);

  00149	4c 8b 44 24 38	 mov	 r8, QWORD PTR len$120587[rsp]
  0014e	48 8b 54 24 28	 mov	 rdx, QWORD PTR path$[rsp]
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:progpath
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 405  :                 *(progpath + len) = '\0';

  00160	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:progpath
  00167	33 c9		 xor	 ecx, ecx
  00169	48 8b 54 24 38	 mov	 rdx, QWORD PTR len$120587[rsp]
  0016e	66 89 0c 50	 mov	 WORD PTR [rax+rdx*2], cx

; 406  :             }
; 407  :             else

  00172	eb 18		 jmp	 SHORT $LN4@get_progpa
$LN5@get_progpa:

; 408  :                 wcsncpy(progpath, path, MAXPATHLEN);

  00174	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0017a	48 8b 54 24 28	 mov	 rdx, QWORD PTR path$[rsp]
  0017f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:progpath
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy
$LN4@get_progpa:

; 409  : 
; 410  :             /* join() is safe for MAXPATHLEN+1 size buffer */
; 411  :             join(progpath, prog);

  0018c	48 8b 54 24 20	 mov	 rdx, QWORD PTR prog$[rsp]
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:progpath
  00198	e8 00 00 00 00	 call	 join

; 412  :             if (exists(progpath))

  0019d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:progpath
  001a4	e8 00 00 00 00	 call	 exists
  001a9	85 c0		 test	 eax, eax
  001ab	74 02		 je	 SHORT $LN3@get_progpa

; 413  :                 break;

  001ad	eb 26		 jmp	 SHORT $LN6@get_progpa
$LN3@get_progpa:

; 414  : 
; 415  :             if (!delim) {

  001af	48 83 7c 24 30
	00		 cmp	 QWORD PTR delim$120585[rsp], 0
  001b5	75 0b		 jne	 SHORT $LN2@get_progpa

; 416  :                 progpath[0] = '\0';

  001b7	33 c0		 xor	 eax, eax
  001b9	66 89 05 00 00
	00 00		 mov	 WORD PTR progpath, ax

; 417  :                 break;

  001c0	eb 13		 jmp	 SHORT $LN6@get_progpa
$LN2@get_progpa:

; 418  :             }
; 419  :             path = delim + 1;

  001c2	48 8b 44 24 30	 mov	 rax, QWORD PTR delim$120585[rsp]
  001c7	48 83 c0 02	 add	 rax, 2
  001cb	48 89 44 24 28	 mov	 QWORD PTR path$[rsp], rax

; 420  :         }

  001d0	e9 0b ff ff ff	 jmp	 $LN7@get_progpa
$LN6@get_progpa:

; 421  :     }
; 422  :     else

  001d5	eb 09		 jmp	 SHORT $LN1@get_progpa
$LN8@get_progpa:

; 423  :         progpath[0] = '\0';

  001d7	33 c0		 xor	 eax, eax
  001d9	66 89 05 00 00
	00 00		 mov	 WORD PTR progpath, ax
$LN1@get_progpa:
$LN9@get_progpa:
$LN17@get_progpa:

; 424  : }

  001e0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e4	c3		 ret	 0
get_progpath ENDP
_TEXT	ENDS
PUBLIC	??_C@_15JNBOKNOG@?$AA?$AN?$AA?6?$AA?$AA@	; `string'
PUBLIC	??_C@_13NMPKAAJP@?$AA?$DN?$AA?$AA@		; `string'
PUBLIC	??_C@_15DEJJBEOA@?$AA?5?$AA?7?$AA?$AA@		; `string'
PUBLIC	??_C@_19JPEEHMMI@?$AA?5?$AA?7?$AA?$AN?$AA?6?$AA?$AA@ ; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0BA@GMJLDMKP@surrogateescape?$AA@		; `string'
EXTRN	__imp_wcscmp:PROC
EXTRN	__imp_wcstok:PROC
EXTRN	PyUnicode_AsWideChar:PROC
EXTRN	PyUnicode_DecodeUTF8:PROC
EXTRN	__imp_fgets:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_fseek:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$find_env_config_value DD imagerel find_env_config_value
	DD	imagerel find_env_config_value+529
	DD	imagerel $unwind$find_env_config_value
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$find_env_config_value DD 021601H
	DD	0d10116H
xdata	ENDS
;	COMDAT ??_C@_15JNBOKNOG@?$AA?$AN?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_15JNBOKNOG@?$AA?$AN?$AA?6?$AA?$AA@ DB 0dH, 00H, 0aH, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13NMPKAAJP@?$AA?$DN?$AA?$AA@
CONST	SEGMENT
??_C@_13NMPKAAJP@?$AA?$DN?$AA?$AA@ DB '=', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15DEJJBEOA@?$AA?5?$AA?7?$AA?$AA@
CONST	SEGMENT
??_C@_15DEJJBEOA@?$AA?5?$AA?7?$AA?$AA@ DB ' ', 00H, 09H, 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19JPEEHMMI@?$AA?5?$AA?7?$AA?$AN?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_19JPEEHMMI@?$AA?5?$AA?7?$AA?$AN?$AA?6?$AA?$AA@ DB ' ', 00H, 09H, 00H
	DB	0dH, 00H, 0aH, 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
CONST	SEGMENT
??_C@_0BA@GMJLDMKP@surrogateescape?$AA@ DB 'surrogateescape', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT find_env_config_value
_TEXT	SEGMENT
result$ = 32
buffer$ = 48
p$120605 = 576
decoded$120607 = 584
n$120608 = 592
tmpbuffer$120606 = 608
k$120616 = 1648
tok$120619 = 1656
env_file$ = 1680
key$ = 1688
value$ = 1696
find_env_config_value PROC				; COMDAT

; 428  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 06
	00 00		 sub	 rsp, 1672		; 00000688H

; 429  :     int result = 0; /* meaning not found */

  00016	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 430  :     char buffer[MAXPATHLEN*2+1];  /* allow extra for key, '=', etc. */
; 431  : 
; 432  :     fseek(env_file, 0, SEEK_SET);

  0001e	45 33 c0	 xor	 r8d, r8d
  00021	33 d2		 xor	 edx, edx
  00023	48 8b 8c 24 90
	06 00 00	 mov	 rcx, QWORD PTR env_file$[rsp]
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
$LN13@find_env_c:
$LN10@find_env_c:

; 433  :     while (!feof(env_file)) {

  00031	48 8b 8c 24 90
	06 00 00	 mov	 rcx, QWORD PTR env_file$[rsp]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  0003f	85 c0		 test	 eax, eax
  00041	0f 85 be 01 00
	00		 jne	 $LN9@find_env_c

; 434  :         char * p = fgets(buffer, MAXPATHLEN*2, env_file);

  00047	4c 8b 84 24 90
	06 00 00	 mov	 r8, QWORD PTR env_file$[rsp]
  0004f	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00054	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  0005f	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR p$120605[rsp], rax

; 435  :         wchar_t tmpbuffer[MAXPATHLEN*2+1];
; 436  :         PyObject * decoded;
; 437  :         int n;
; 438  : 
; 439  :         if (p == NULL)

  00067	48 83 bc 24 40
	02 00 00 00	 cmp	 QWORD PTR p$120605[rsp], 0
  00070	75 05		 jne	 SHORT $LN8@find_env_c

; 440  :             break;

  00072	e9 8e 01 00 00	 jmp	 $LN9@find_env_c
$LN8@find_env_c:

; 441  :         n = strlen(p);

  00077	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR p$120605[rsp]
  0007f	e8 00 00 00 00	 call	 strlen
  00084	89 84 24 50 02
	00 00		 mov	 DWORD PTR n$120608[rsp], eax

; 442  :         if (p[n - 1] != '\n') {

  0008b	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR n$120608[rsp]
  00092	ff c8		 dec	 eax
  00094	48 98		 cdqe
  00096	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR p$120605[rsp]
  0009e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000a2	83 f8 0a	 cmp	 eax, 10
  000a5	74 05		 je	 SHORT $LN7@find_env_c

; 443  :             /* line has overflowed - bail */
; 444  :             break;

  000a7	e9 59 01 00 00	 jmp	 $LN9@find_env_c
$LN7@find_env_c:

; 445  :         }
; 446  :         if (p[0] == '#')    /* Comment - skip */

  000ac	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR p$120605[rsp]
  000b4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b7	83 f8 23	 cmp	 eax, 35			; 00000023H
  000ba	75 05		 jne	 SHORT $LN6@find_env_c

; 447  :             continue;

  000bc	e9 70 ff ff ff	 jmp	 $LN10@find_env_c
$LN6@find_env_c:

; 448  :         decoded = PyUnicode_DecodeUTF8(buffer, n, "surrogateescape");

  000c1	48 63 84 24 50
	02 00 00	 movsxd	 rax, DWORD PTR n$120608[rsp]
  000c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
  000d0	48 8b d0	 mov	 rdx, rax
  000d3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  000d8	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  000dd	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR decoded$120607[rsp], rax

; 449  :         if (decoded != NULL) {

  000e5	48 83 bc 24 48
	02 00 00 00	 cmp	 QWORD PTR decoded$120607[rsp], 0
  000ee	0f 84 0c 01 00
	00		 je	 $LN5@find_env_c

; 450  :             Py_ssize_t k;
; 451  :             k = PyUnicode_AsWideChar(decoded,
; 452  :                                      tmpbuffer, MAXPATHLEN * 2);

  000f4	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  000fa	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR tmpbuffer$120606[rsp]
  00102	48 8b 8c 24 48
	02 00 00	 mov	 rcx, QWORD PTR decoded$120607[rsp]
  0010a	e8 00 00 00 00	 call	 PyUnicode_AsWideChar
  0010f	48 89 84 24 70
	06 00 00	 mov	 QWORD PTR k$120616[rsp], rax

; 453  :             Py_DECREF(decoded);

  00117	48 8b 8c 24 48
	02 00 00	 mov	 rcx, QWORD PTR decoded$120607[rsp]
  0011f	e8 00 00 00 00	 call	 _Py_DecRef

; 454  :             if (k >= 0) {

  00124	48 83 bc 24 70
	06 00 00 00	 cmp	 QWORD PTR k$120616[rsp], 0
  0012d	0f 8c cd 00 00
	00		 jl	 $LN4@find_env_c

; 455  :                 wchar_t * tok = wcstok(tmpbuffer, L" \t\r\n");

  00133	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19JPEEHMMI@?$AA?5?$AA?7?$AA?$AN?$AA?6?$AA?$AA@
  0013a	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR tmpbuffer$120606[rsp]
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstok
  00148	48 89 84 24 78
	06 00 00	 mov	 QWORD PTR tok$120619[rsp], rax

; 456  :                 if ((tok != NULL) && !wcscmp(tok, key)) {

  00150	48 83 bc 24 78
	06 00 00 00	 cmp	 QWORD PTR tok$120619[rsp], 0
  00159	0f 84 a1 00 00
	00		 je	 $LN3@find_env_c
  0015f	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00167	48 8b 8c 24 78
	06 00 00	 mov	 rcx, QWORD PTR tok$120619[rsp]
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscmp
  00175	85 c0		 test	 eax, eax
  00177	0f 85 83 00 00
	00		 jne	 $LN3@find_env_c

; 457  :                     tok = wcstok(NULL, L" \t");

  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15DEJJBEOA@?$AA?5?$AA?7?$AA?$AA@
  00184	33 c9		 xor	 ecx, ecx
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstok
  0018c	48 89 84 24 78
	06 00 00	 mov	 QWORD PTR tok$120619[rsp], rax

; 458  :                     if ((tok != NULL) && !wcscmp(tok, L"=")) {

  00194	48 83 bc 24 78
	06 00 00 00	 cmp	 QWORD PTR tok$120619[rsp], 0
  0019d	74 61		 je	 SHORT $LN2@find_env_c
  0019f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13NMPKAAJP@?$AA?$DN?$AA?$AA@
  001a6	48 8b 8c 24 78
	06 00 00	 mov	 rcx, QWORD PTR tok$120619[rsp]
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscmp
  001b4	85 c0		 test	 eax, eax
  001b6	75 48		 jne	 SHORT $LN2@find_env_c

; 459  :                         tok = wcstok(NULL, L"\r\n");

  001b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15JNBOKNOG@?$AA?$AN?$AA?6?$AA?$AA@
  001bf	33 c9		 xor	 ecx, ecx
  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcstok
  001c7	48 89 84 24 78
	06 00 00	 mov	 QWORD PTR tok$120619[rsp], rax

; 460  :                         if (tok != NULL) {

  001cf	48 83 bc 24 78
	06 00 00 00	 cmp	 QWORD PTR tok$120619[rsp], 0
  001d8	74 26		 je	 SHORT $LN1@find_env_c

; 461  :                             wcsncpy(value, tok, MAXPATHLEN);

  001da	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  001e0	48 8b 94 24 78
	06 00 00	 mov	 rdx, QWORD PTR tok$120619[rsp]
  001e8	48 8b 8c 24 a0
	06 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncpy

; 462  :                             result = 1;

  001f6	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR result$[rsp], 1

; 463  :                             break;

  001fe	eb 05		 jmp	 SHORT $LN9@find_env_c
$LN1@find_env_c:
$LN2@find_env_c:
$LN3@find_env_c:
$LN4@find_env_c:
$LN5@find_env_c:

; 464  :                         }
; 465  :                     }
; 466  :                 }
; 467  :             }
; 468  :         }
; 469  :     }

  00200	e9 2c fe ff ff	 jmp	 $LN13@find_env_c
$LN9@find_env_c:

; 470  :     return result;

  00205	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]

; 471  : }

  00209	48 81 c4 88 06
	00 00		 add	 rsp, 1672		; 00000688H
  00210	c3		 ret	 0
find_env_config_value ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	Py_GetPrefix
;	COMDAT pdata
; File c:\src\pyparallel\pc\getpathp.c
pdata	SEGMENT
$pdata$Py_GetPrefix DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$Py_GetPrefix
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_GetPrefix DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Py_GetPrefix
_TEXT	SEGMENT
Py_GetPrefix PROC					; COMDAT

; 772  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 773  :     if (!module_search_path)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR module_search_path, 0
  0000c	75 05		 jne	 SHORT $LN1@Py_GetPref

; 774  :         calculate_path();

  0000e	e8 00 00 00 00	 call	 calculate_path
$LN1@Py_GetPref:

; 775  :     return prefix;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:prefix

; 776  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
Py_GetPrefix ENDP
_TEXT	ENDS
PUBLIC	Py_GetExecPrefix
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_GetExecPrefix DD imagerel $LN3
	DD	imagerel $LN3+14
	DD	imagerel $unwind$Py_GetExecPrefix
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_GetExecPrefix DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Py_GetExecPrefix
_TEXT	SEGMENT
Py_GetExecPrefix PROC					; COMDAT

; 780  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 781  :     return Py_GetPrefix();

  00004	e8 00 00 00 00	 call	 Py_GetPrefix

; 782  : }

  00009	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000d	c3		 ret	 0
Py_GetExecPrefix ENDP
_TEXT	ENDS
PUBLIC	Py_GetProgramFullPath
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_GetProgramFullPath DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$Py_GetProgramFullPath
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_GetProgramFullPath DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Py_GetProgramFullPath
_TEXT	SEGMENT
Py_GetProgramFullPath PROC				; COMDAT

; 786  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 787  :     if (!module_search_path)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR module_search_path, 0
  0000c	75 05		 jne	 SHORT $LN1@Py_GetProg

; 788  :         calculate_path();

  0000e	e8 00 00 00 00	 call	 calculate_path
$LN1@Py_GetProg:

; 789  :     return progpath;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:progpath

; 790  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
Py_GetProgramFullPath ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@EKBGBMOG@?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ ; `string'
PUBLIC	_Py_CheckPython3
EXTRN	__imp_LoadLibraryExW:PROC
EXTRN	__imp_wcsrchr:PROC
_BSS	SEGMENT
	ALIGN	8

hPython3 DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_CheckPython3 DD imagerel $LN10
	DD	imagerel $LN10+301
	DD	imagerel $unwind$_Py_CheckPython3
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_CheckPython3 DD 020701H
	DD	04b0107H
xdata	ENDS
;	COMDAT ??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB '\'
	DB	00H, 'D', 00H, 'L', 00H, 'L', 00H, 's', 00H, '\', 00H, 'p', 00H
	DB	'y', 00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H, '3', 00H, '.'
	DB	00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@EKBGBMOG@?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@EKBGBMOG@?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@ DB '\'
	DB	00H, 'p', 00H, 'y', 00H, 't', 00H, 'h', 00H, 'o', 00H, 'n', 00H
	DB	'3', 00H, '.', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_CheckPython3
_TEXT	SEGMENT
s$ = 32
py3path$ = 48
tv66 = 576
tv90 = 580
_Py_CheckPython3 PROC					; COMDAT

; 802  : {

$LN10:
  00000	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H

; 803  :     wchar_t py3path[MAXPATHLEN+1];
; 804  :     wchar_t *s;
; 805  :     if (python3_checked)

  00007	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR python3_checked, 0
  0000e	74 2e		 je	 SHORT $LN3@Py_CheckPy

; 806  :         return hPython3 != NULL;

  00010	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hPython3, 0
  00018	74 0d		 je	 SHORT $LN6@Py_CheckPy
  0001a	c7 84 24 40 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv66[rsp], 1
  00025	eb 0b		 jmp	 SHORT $LN7@Py_CheckPy
$LN6@Py_CheckPy:
  00027	c7 84 24 40 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv66[rsp], 0
$LN7@Py_CheckPy:
  00032	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR tv66[rsp]
  00039	e9 e7 00 00 00	 jmp	 $LN4@Py_CheckPy
$LN3@Py_CheckPy:

; 807  :     python3_checked = 1;

  0003e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR python3_checked, 1

; 808  : 
; 809  :     /* If there is a python3.dll next to the python3y.dll,
; 810  :        assume this is a build tree; use that DLL */
; 811  :     wcscpy(py3path, dllpath);

  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:dllpath
  0004f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR py3path$[rsp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 812  :     s = wcsrchr(py3path, L'\\');

  0005a	66 ba 5c 00	 mov	 dx, 92			; 0000005cH
  0005e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR py3path$[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsrchr
  00069	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 813  :     if (!s)

  0006e	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  00074	75 0a		 jne	 SHORT $LN2@Py_CheckPy

; 814  :         s = py3path;

  00076	48 8d 44 24 30	 lea	 rax, QWORD PTR py3path$[rsp]
  0007b	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
$LN2@Py_CheckPy:

; 815  :     wcscpy(s, L"\\python3.dll");

  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BK@EKBGBMOG@?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  00087	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 816  :     hPython3 = LoadLibraryExW(py3path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

  00092	41 b8 08 00 00
	00		 mov	 r8d, 8
  00098	33 d2		 xor	 edx, edx
  0009a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR py3path$[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryExW
  000a5	48 89 05 00 00
	00 00		 mov	 QWORD PTR hPython3, rax

; 817  :     if (hPython3 != NULL)

  000ac	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hPython3, 0
  000b4	74 07		 je	 SHORT $LN1@Py_CheckPy

; 818  :         return 1;

  000b6	b8 01 00 00 00	 mov	 eax, 1
  000bb	eb 68		 jmp	 SHORT $LN4@Py_CheckPy
$LN1@Py_CheckPy:

; 819  : 
; 820  :     /* Check sys.prefix\DLLs\python3.dll */
; 821  :     wcscpy(py3path, Py_GetPrefix());

  000bd	e8 00 00 00 00	 call	 Py_GetPrefix
  000c2	48 8b d0	 mov	 rdx, rax
  000c5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR py3path$[rsp]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 822  :     wcscat(py3path, L"\\DLLs\\python3.dll");

  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@GFEFPPOH@?$AA?2?$AAD?$AAL?$AAL?$AAs?$AA?2?$AAp?$AAy?$AAt?$AAh?$AAo?$AAn?$AA3?$AA?4?$AAd?$AAl?$AAl?$AA?$AA@
  000d7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR py3path$[rsp]
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscat

; 823  :     hPython3 = LoadLibraryExW(py3path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

  000e2	41 b8 08 00 00
	00		 mov	 r8d, 8
  000e8	33 d2		 xor	 edx, edx
  000ea	48 8d 4c 24 30	 lea	 rcx, QWORD PTR py3path$[rsp]
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryExW
  000f5	48 89 05 00 00
	00 00		 mov	 QWORD PTR hPython3, rax

; 824  :     return hPython3 != NULL;

  000fc	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hPython3, 0
  00104	74 0d		 je	 SHORT $LN8@Py_CheckPy
  00106	c7 84 24 44 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv90[rsp], 1
  00111	eb 0b		 jmp	 SHORT $LN9@Py_CheckPy
$LN8@Py_CheckPy:
  00113	c7 84 24 44 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv90[rsp], 0
$LN9@Py_CheckPy:
  0011e	8b 84 24 44 02
	00 00		 mov	 eax, DWORD PTR tv90[rsp]
$LN4@Py_CheckPy:

; 825  : }

  00125	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  0012c	c3		 ret	 0
_Py_CheckPython3 ENDP
_TEXT	ENDS
END
