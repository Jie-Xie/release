; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07JGEBJGAH@_bisect?$AA@			; `string'
PUBLIC	??_C@_0M@PBGOOMDD@insort_left?$AA@		; `string'
PUBLIC	??_C@_0M@IMPIOGJF@bisect_left?$AA@		; `string'
PUBLIC	??_C@_06IPFCDKBL@insort?$AA@			; `string'
PUBLIC	??_C@_0N@KFNOAAJD@insort_right?$AA@		; `string'
PUBLIC	??_C@_06OCAJHHHK@bisect?$AA@			; `string'
PUBLIC	??_C@_0N@JKBGJAEE@bisect_right?$AA@		; `string'
PUBLIC	??_C@_06OAOPNKHP@insert?$AA@			; `string'
PUBLIC	??_C@_02PCEFGMJL@hi?$AA@			; `string'
PUBLIC	??_C@_02KDBGGDMB@lo?$AA@			; `string'
PUBLIC	??_C@_01FJMABOPO@x?$AA@				; `string'
PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
;	COMDAT ??_C@_07JGEBJGAH@_bisect?$AA@
CONST	SEGMENT
??_C@_07JGEBJGAH@_bisect?$AA@ DB '_bisect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PBGOOMDD@insort_left?$AA@
CONST	SEGMENT
??_C@_0M@PBGOOMDD@insort_left?$AA@ DB 'insort_left', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IMPIOGJF@bisect_left?$AA@
CONST	SEGMENT
??_C@_0M@IMPIOGJF@bisect_left?$AA@ DB 'bisect_left', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IPFCDKBL@insort?$AA@
CONST	SEGMENT
??_C@_06IPFCDKBL@insort?$AA@ DB 'insort', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFNOAAJD@insort_right?$AA@
CONST	SEGMENT
??_C@_0N@KFNOAAJD@insort_right?$AA@ DB 'insort_right', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OCAJHHHK@bisect?$AA@
CONST	SEGMENT
??_C@_06OCAJHHHK@bisect?$AA@ DB 'bisect', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JKBGJAEE@bisect_right?$AA@
CONST	SEGMENT
??_C@_0N@JKBGJAEE@bisect_right?$AA@ DB 'bisect_right', 00H ; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_insert@?3??insort_left@@9@9 DQ 0000000000000000H	; `insort_left'::`4'::PyId_insert
	DQ	FLAT:??_C@_06OAOPNKHP@insert?$AA@
	DQ	0000000000000000H
?PyId_insert@?3??insort_right@@9@9 DQ 0000000000000000H	; `insort_right'::`4'::PyId_insert
	DQ	FLAT:??_C@_06OAOPNKHP@insert?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_06OAOPNKHP@insert?$AA@
CONST	SEGMENT
??_C@_06OAOPNKHP@insert?$AA@ DB 'insert', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?keywords@?1??bisect_right@@9@9 DQ FLAT:??_C@_01MCMALHOG@a?$AA@ ; `bisect_right'::`2'::keywords
	DQ	FLAT:??_C@_01FJMABOPO@x?$AA@
	DQ	FLAT:??_C@_02KDBGGDMB@lo?$AA@
	DQ	FLAT:??_C@_02PCEFGMJL@hi?$AA@
	DQ	0000000000000000H
?keywords@?1??insort_right@@9@9 DQ FLAT:??_C@_01MCMALHOG@a?$AA@ ; `insort_right'::`2'::keywords
	DQ	FLAT:??_C@_01FJMABOPO@x?$AA@
	DQ	FLAT:??_C@_02KDBGGDMB@lo?$AA@
	DQ	FLAT:??_C@_02PCEFGMJL@hi?$AA@
	DQ	0000000000000000H
bisect_right_doc DB 'bisect_right(a, x[, lo[, hi]]) -> index', 0aH, 0aH, 'R'
	DB	'eturn the index where to insert item x in list a, assuming a '
	DB	'is sorted.', 0aH, 0aH, 'The return value i is such that all e'
	DB	' in a[:i] have e <= x, and all e in', 0aH, 'a[i:] have e > x.'
	DB	'  So if x already appears in the list, i points just', 0aH, 'b'
	DB	'eyond the rightmost x already there', 0aH, 0aH, 'Optional arg'
	DB	's lo (default 0) and hi (default len(a)) bound the', 0aH, 'sl'
	DB	'ice of a to be searched.', 0aH, 00H
	ORG $+13
insort_right_doc DB 'insort_right(a, x[, lo[, hi]])', 0aH, 0aH, 'Insert i'
	DB	'tem x in list a, and keep it sorted assuming a is sorted.', 0aH
	DB	0aH, 'If x is already in a, insert it to the right of the righ'
	DB	'tmost x.', 0aH, 0aH, 'Optional args lo (default 0) and hi (de'
	DB	'fault len(a)) bound the', 0aH, 'slice of a to be searched.', 0aH
	DB	00H
?keywords@?1??bisect_left@@9@9 DQ FLAT:??_C@_01MCMALHOG@a?$AA@ ; `bisect_left'::`2'::keywords
	DQ	FLAT:??_C@_01FJMABOPO@x?$AA@
	DQ	FLAT:??_C@_02KDBGGDMB@lo?$AA@
	DQ	FLAT:??_C@_02PCEFGMJL@hi?$AA@
	DQ	0000000000000000H
	ORG $+8
bisect_left_doc DB 'bisect_left(a, x[, lo[, hi]]) -> index', 0aH, 0aH, 'R'
	DB	'eturn the index where to insert item x in list a, assuming a '
	DB	'is sorted.', 0aH, 0aH, 'The return value i is such that all e'
	DB	' in a[:i] have e < x, and all e in', 0aH, 'a[i:] have e >= x.'
	DB	'  So if x already appears in the list, i points just', 0aH, 'b'
	DB	'efore the leftmost x already there.', 0aH, 0aH, 'Optional arg'
	DB	's lo (default 0) and hi (default len(a)) bound the', 0aH, 'sl'
	DB	'ice of a to be searched.', 0aH, 00H
	ORG $+6
?keywords@?1??insort_left@@9@9 DQ FLAT:??_C@_01MCMALHOG@a?$AA@ ; `insort_left'::`2'::keywords
	DQ	FLAT:??_C@_01FJMABOPO@x?$AA@
	DQ	FLAT:??_C@_02KDBGGDMB@lo?$AA@
	DQ	FLAT:??_C@_02PCEFGMJL@hi?$AA@
	DQ	0000000000000000H
insort_left_doc DB 'insort_left(a, x[, lo[, hi]])', 0aH, 0aH, 'Insert ite'
	DB	'm x in list a, and keep it sorted assuming a is sorted.', 0aH
	DB	0aH, 'If x is already in a, insert it to the left of the leftm'
	DB	'ost x.', 0aH, 0aH, 'Optional args lo (default 0) and hi (defa'
	DB	'ult len(a)) bound the', 0aH, 'slice of a to be searched.', 0aH
	DB	00H
	ORG $+3
bisect_doc DB	'Alias for bisect_right().', 0aH, 00H
	ORG $+5
insort_doc DB	'Alias for insort_right().', 0aH, 00H
	ORG $+5
bisect_methods DQ FLAT:??_C@_0N@JKBGJAEE@bisect_right?$AA@
	DQ	FLAT:bisect_right
	DD	03H
	ORG $+4
	DQ	FLAT:bisect_right_doc
	DQ	FLAT:??_C@_06OCAJHHHK@bisect?$AA@
	DQ	FLAT:bisect_right
	DD	03H
	ORG $+4
	DQ	FLAT:bisect_doc
	DQ	FLAT:??_C@_0N@KFNOAAJD@insort_right?$AA@
	DQ	FLAT:insort_right
	DD	03H
	ORG $+4
	DQ	FLAT:insort_right_doc
	DQ	FLAT:??_C@_06IPFCDKBL@insort?$AA@
	DQ	FLAT:insort_right
	DD	03H
	ORG $+4
	DQ	FLAT:insort_doc
	DQ	FLAT:??_C@_0M@IMPIOGJF@bisect_left?$AA@
	DQ	FLAT:bisect_left
	DD	03H
	ORG $+4
	DQ	FLAT:bisect_left_doc
	DQ	FLAT:??_C@_0M@PBGOOMDD@insort_left?$AA@
	DQ	FLAT:insort_left
	DD	03H
	ORG $+4
	DQ	FLAT:insort_left_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_doc DB	'Bisection algorithms.', 0aH, 0aH, 'This module provides '
	DB	'support for maintaining a list in sorted order without', 0aH, 'h'
	DB	'aving to sort the list after each insertion. For long lists o'
	DB	'f items with', 0aH, 'expensive comparison operations, this ca'
	DB	'n be an improvement over the more', 0aH, 'common approach.', 0aH
	DB	00H
	ORG $+6
_bisectmodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07JGEBJGAH@_bisect?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:bisect_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_02PCEFGMJL@hi?$AA@
CONST	SEGMENT
??_C@_02PCEFGMJL@hi?$AA@ DB 'hi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KDBGGDMB@lo?$AA@
CONST	SEGMENT
??_C@_02KDBGGDMB@lo?$AA@ DB 'lo', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FJMABOPO@x?$AA@
CONST	SEGMENT
??_C@_01FJMABOPO@x?$AA@ DB 'x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
CONST	ENDS
PUBLIC	??_C@_0BD@DDMMKPPA@OO?$HMnn?3bisect_right?$AA@	; `string'
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_bisectmodule.c
pdata	SEGMENT
$pdata$bisect_right DD imagerel bisect_right
	DD	imagerel bisect_right+177
	DD	imagerel $unwind$bisect_right
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bisect_right DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_0BD@DDMMKPPA@OO?$HMnn?3bisect_right?$AA@
CONST	SEGMENT
??_C@_0BD@DDMMKPPA@OO?$HMnn?3bisect_right?$AA@ DB 'OO|nn:bisect_right', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bisect_right
_TEXT	SEGMENT
lo$ = 64
index$ = 72
list$ = 80
hi$ = 88
item$ = 96
self$ = 128
args$ = 136
kw$ = 144
bisect_right PROC					; COMDAT

; 46   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 47   :     PyObject *list, *item;
; 48   :     Py_ssize_t lo = 0;

  00013	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR lo$[rsp], 0

; 49   :     Py_ssize_t hi = -1;

  0001c	48 c7 44 24 58
	ff ff ff ff	 mov	 QWORD PTR hi$[rsp], -1

; 50   :     Py_ssize_t index;
; 51   :     static char *keywords[] = {"a", "x", "lo", "hi", NULL};
; 52   : 
; 53   :     if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|nn:bisect_right",
; 54   :         keywords, &list, &item, &lo, &hi))

  00025	48 8d 44 24 58	 lea	 rax, QWORD PTR hi$[rsp]
  0002a	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0002f	48 8d 44 24 40	 lea	 rax, QWORD PTR lo$[rsp]
  00034	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00039	48 8d 44 24 60	 lea	 rax, QWORD PTR item$[rsp]
  0003e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00043	48 8d 44 24 50	 lea	 rax, QWORD PTR list$[rsp]
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??bisect_right@@9@9
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BD@DDMMKPPA@OO?$HMnn?3bisect_right?$AA@
  0005b	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  00063	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0006b	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00070	85 c0		 test	 eax, eax
  00072	75 04		 jne	 SHORT $LN2@bisect_rig

; 55   :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	eb 34		 jmp	 SHORT $LN3@bisect_rig
$LN2@bisect_rig:

; 56   :     index = internal_bisect_right(list, item, lo, hi);

  00078	4c 8b 4c 24 58	 mov	 r9, QWORD PTR hi$[rsp]
  0007d	4c 8b 44 24 40	 mov	 r8, QWORD PTR lo$[rsp]
  00082	48 8b 54 24 60	 mov	 rdx, QWORD PTR item$[rsp]
  00087	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  0008c	e8 00 00 00 00	 call	 internal_bisect_right
  00091	48 89 44 24 48	 mov	 QWORD PTR index$[rsp], rax

; 57   :     if (index < 0)

  00096	48 83 7c 24 48
	00		 cmp	 QWORD PTR index$[rsp], 0
  0009c	7d 04		 jge	 SHORT $LN1@bisect_rig

; 58   :         return NULL;

  0009e	33 c0		 xor	 eax, eax
  000a0	eb 0a		 jmp	 SHORT $LN3@bisect_rig
$LN1@bisect_rig:

; 59   :     return PyLong_FromSsize_t(index);

  000a2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR index$[rsp]
  000a7	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN3@bisect_rig:

; 60   : }

  000ac	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000b0	c3		 ret	 0
bisect_right ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0BI@EJLDOAAC@lo?5must?5be?5non?9negative?$AA@ ; `string'
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	PySequence_GetItem:PROC
EXTRN	PySequence_Size:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$internal_bisect_right DD imagerel internal_bisect_right
	DD	imagerel internal_bisect_right+290
	DD	imagerel $unwind$internal_bisect_right
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$internal_bisect_right DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT ??_C@_0BI@EJLDOAAC@lo?5must?5be?5non?9negative?$AA@
CONST	SEGMENT
??_C@_0BI@EJLDOAAC@lo?5must?5be?5non?9negative?$AA@ DB 'lo must be non-ne'
	DB	'gative', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT internal_bisect_right
_TEXT	SEGMENT
mid$ = 32
res$ = 40
litem$ = 48
list$ = 80
item$ = 88
lo$ = 96
hi$ = 104
internal_bisect_right PROC				; COMDAT

; 11   : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 12   :     PyObject *litem;
; 13   :     Py_ssize_t mid, res;
; 14   : 
; 15   :     if (lo < 0) {

  00018	48 83 7c 24 60
	00		 cmp	 QWORD PTR lo$[rsp], 0
  0001e	7d 1f		 jge	 SHORT $LN9@internal_b

; 16   :         PyErr_SetString(PyExc_ValueError, "lo must be non-negative");

  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJLDOAAC@lo?5must?5be?5non?9negative?$AA@
  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002e	e8 00 00 00 00	 call	 PyErr_SetString

; 17   :         return -1;

  00033	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0003a	e9 de 00 00 00	 jmp	 $LN10@internal_b
$LN9@internal_b:

; 18   :     }
; 19   :     if (hi == -1) {

  0003f	48 83 7c 24 68
	ff		 cmp	 QWORD PTR hi$[rsp], -1
  00045	75 23		 jne	 SHORT $LN8@internal_b

; 20   :         hi = PySequence_Size(list);

  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  0004c	e8 00 00 00 00	 call	 PySequence_Size
  00051	48 89 44 24 68	 mov	 QWORD PTR hi$[rsp], rax

; 21   :         if (hi < 0)

  00056	48 83 7c 24 68
	00		 cmp	 QWORD PTR hi$[rsp], 0
  0005c	7d 0c		 jge	 SHORT $LN7@internal_b

; 22   :             return -1;

  0005e	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00065	e9 b3 00 00 00	 jmp	 $LN10@internal_b
$LN7@internal_b:
$LN8@internal_b:
$LN6@internal_b:

; 23   :     }
; 24   :     while (lo < hi) {

  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR hi$[rsp]
  0006f	48 39 44 24 60	 cmp	 QWORD PTR lo$[rsp], rax
  00074	0f 8d 9e 00 00
	00		 jge	 $LN5@internal_b

; 25   :         /* The (size_t)cast ensures that the addition and subsequent division
; 26   :            are performed as unsigned operations, avoiding difficulties from
; 27   :            signed overflow.  (See issue 13496.) */
; 28   :         mid = ((size_t)lo + hi) / 2;

  0007a	48 8b 44 24 68	 mov	 rax, QWORD PTR hi$[rsp]
  0007f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lo$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	33 d2		 xor	 edx, edx
  0008c	b9 02 00 00 00	 mov	 ecx, 2
  00091	48 f7 f1	 div	 rcx
  00094	48 89 44 24 20	 mov	 QWORD PTR mid$[rsp], rax

; 29   :         litem = PySequence_GetItem(list, mid);

  00099	48 8b 54 24 20	 mov	 rdx, QWORD PTR mid$[rsp]
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  000a3	e8 00 00 00 00	 call	 PySequence_GetItem
  000a8	48 89 44 24 30	 mov	 QWORD PTR litem$[rsp], rax

; 30   :         if (litem == NULL)

  000ad	48 83 7c 24 30
	00		 cmp	 QWORD PTR litem$[rsp], 0
  000b3	75 09		 jne	 SHORT $LN4@internal_b

; 31   :             return -1;

  000b5	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000bc	eb 5f		 jmp	 SHORT $LN10@internal_b
$LN4@internal_b:

; 32   :         res = PyObject_RichCompareBool(item, litem, Py_LT);

  000be	45 33 c0	 xor	 r8d, r8d
  000c1	48 8b 54 24 30	 mov	 rdx, QWORD PTR litem$[rsp]
  000c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR item$[rsp]
  000cb	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000d0	48 98		 cdqe
  000d2	48 89 44 24 28	 mov	 QWORD PTR res$[rsp], rax

; 33   :         Py_DECREF(litem);

  000d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR litem$[rsp]
  000dc	e8 00 00 00 00	 call	 _Py_DecRef

; 34   :         if (res < 0)

  000e1	48 83 7c 24 28
	00		 cmp	 QWORD PTR res$[rsp], 0
  000e7	7d 09		 jge	 SHORT $LN3@internal_b

; 35   :             return -1;

  000e9	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000f0	eb 2b		 jmp	 SHORT $LN10@internal_b
$LN3@internal_b:

; 36   :         if (res)

  000f2	48 83 7c 24 28
	00		 cmp	 QWORD PTR res$[rsp], 0
  000f8	74 0c		 je	 SHORT $LN2@internal_b

; 37   :             hi = mid;

  000fa	48 8b 44 24 20	 mov	 rax, QWORD PTR mid$[rsp]
  000ff	48 89 44 24 68	 mov	 QWORD PTR hi$[rsp], rax

; 38   :         else

  00104	eb 0d		 jmp	 SHORT $LN1@internal_b
$LN2@internal_b:

; 39   :             lo = mid + 1;

  00106	48 8b 44 24 20	 mov	 rax, QWORD PTR mid$[rsp]
  0010b	48 ff c0	 inc	 rax
  0010e	48 89 44 24 60	 mov	 QWORD PTR lo$[rsp], rax
$LN1@internal_b:

; 40   :     }

  00113	e9 52 ff ff ff	 jmp	 $LN6@internal_b
$LN5@internal_b:

; 41   :     return lo;

  00118	48 8b 44 24 60	 mov	 rax, QWORD PTR lo$[rsp]
$LN10@internal_b:

; 42   : }

  0011d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00121	c3		 ret	 0
internal_bisect_right ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_02DFBGJDAN@nO?$AA@			; `string'
PUBLIC	??_C@_0BD@MAEDPCH@OO?$HMnn?3insort_right?$AA@	; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	_PyObject_CallMethodId_SizeT:PROC
EXTRN	PyList_Insert:PROC
EXTRN	PyList_Type:BYTE
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\_bisectmodule.c
pdata	SEGMENT
$pdata$insort_right DD imagerel insort_right
	DD	imagerel insort_right+328
	DD	imagerel $unwind$insort_right
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insort_right DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_02DFBGJDAN@nO?$AA@
CONST	SEGMENT
??_C@_02DFBGJDAN@nO?$AA@ DB 'nO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MAEDPCH@OO?$HMnn?3insort_right?$AA@
CONST	SEGMENT
??_C@_0BD@MAEDPCH@OO?$HMnn?3insort_right?$AA@ DB 'OO|nn:insort_right', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT insort_right
_TEXT	SEGMENT
lo$ = 64
index$ = 72
list$ = 80
hi$ = 88
result$ = 96
item$ = 104
self$ = 128
args$ = 136
kw$ = 144
insort_right PROC					; COMDAT

; 76   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 77   :     PyObject *list, *item, *result;
; 78   :     Py_ssize_t lo = 0;

  00013	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR lo$[rsp], 0

; 79   :     Py_ssize_t hi = -1;

  0001c	48 c7 44 24 58
	ff ff ff ff	 mov	 QWORD PTR hi$[rsp], -1

; 80   :     Py_ssize_t index;
; 81   :     static char *keywords[] = {"a", "x", "lo", "hi", NULL};
; 82   : 
; 83   :     if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|nn:insort_right",
; 84   :         keywords, &list, &item, &lo, &hi))

  00025	48 8d 44 24 58	 lea	 rax, QWORD PTR hi$[rsp]
  0002a	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0002f	48 8d 44 24 40	 lea	 rax, QWORD PTR lo$[rsp]
  00034	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR item$[rsp]
  0003e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00043	48 8d 44 24 50	 lea	 rax, QWORD PTR list$[rsp]
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??insort_right@@9@9
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BD@MAEDPCH@OO?$HMnn?3insort_right?$AA@
  0005b	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  00063	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0006b	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00070	85 c0		 test	 eax, eax
  00072	75 07		 jne	 SHORT $LN6@insort_rig

; 85   :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	e9 c8 00 00 00	 jmp	 $LN7@insort_rig
$LN6@insort_rig:

; 86   :     index = internal_bisect_right(list, item, lo, hi);

  0007b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR hi$[rsp]
  00080	4c 8b 44 24 40	 mov	 r8, QWORD PTR lo$[rsp]
  00085	48 8b 54 24 68	 mov	 rdx, QWORD PTR item$[rsp]
  0008a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  0008f	e8 00 00 00 00	 call	 internal_bisect_right
  00094	48 89 44 24 48	 mov	 QWORD PTR index$[rsp], rax

; 87   :     if (index < 0)

  00099	48 83 7c 24 48
	00		 cmp	 QWORD PTR index$[rsp], 0
  0009f	7d 07		 jge	 SHORT $LN5@insort_rig

; 88   :         return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	e9 9b 00 00 00	 jmp	 $LN7@insort_rig
$LN5@insort_rig:

; 89   :     if (PyList_CheckExact(list)) {

  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  000b4	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000b8	75 1e		 jne	 SHORT $LN4@insort_rig

; 90   :         if (PyList_Insert(list, index, item) < 0)

  000ba	4c 8b 44 24 68	 mov	 r8, QWORD PTR item$[rsp]
  000bf	48 8b 54 24 48	 mov	 rdx, QWORD PTR index$[rsp]
  000c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  000c9	e8 00 00 00 00	 call	 PyList_Insert
  000ce	85 c0		 test	 eax, eax
  000d0	7d 04		 jge	 SHORT $LN3@insort_rig

; 91   :             return NULL;

  000d2	33 c0		 xor	 eax, eax
  000d4	eb 6d		 jmp	 SHORT $LN7@insort_rig
$LN3@insort_rig:

; 92   :     } else {

  000d6	eb 58		 jmp	 SHORT $LN2@insort_rig
$LN4@insort_rig:

; 93   :         _Py_IDENTIFIER(insert);
; 94   : 
; 95   :         result = _PyObject_CallMethodId(list, &PyId_insert, "nO", index, item);

  000d8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_insert@?3??insort_right@@9@9
  000dd	8b c0		 mov	 eax, eax
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000e5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000ee	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000f2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR item$[rsp]
  000f7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000fc	4c 8b 4c 24 48	 mov	 r9, QWORD PTR index$[rsp]
  00101	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02DFBGJDAN@nO?$AA@
  00108	48 8b d0	 mov	 rdx, rax
  0010b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  00110	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  00115	48 89 44 24 60	 mov	 QWORD PTR result$[rsp], rax

; 96   :         if (result == NULL)

  0011a	48 83 7c 24 60
	00		 cmp	 QWORD PTR result$[rsp], 0
  00120	75 04		 jne	 SHORT $LN1@insort_rig

; 97   :             return NULL;

  00122	33 c0		 xor	 eax, eax
  00124	eb 1d		 jmp	 SHORT $LN7@insort_rig
$LN1@insort_rig:

; 98   :         Py_DECREF(result);

  00126	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  0012b	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@insort_rig:

; 99   :     }
; 100  : 
; 101  :     Py_RETURN_NONE;

  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00137	e8 00 00 00 00	 call	 _Py_IncRef
  0013c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN7@insort_rig:

; 102  : }

  00143	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00147	c3		 ret	 0
insort_right ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@OKGJABHJ@OO?$HMnn?3bisect_left?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\modules\_bisectmodule.c
pdata	SEGMENT
$pdata$bisect_left DD imagerel bisect_left
	DD	imagerel bisect_left+177
	DD	imagerel $unwind$bisect_left
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bisect_left DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_0BC@OKGJABHJ@OO?$HMnn?3bisect_left?$AA@
CONST	SEGMENT
??_C@_0BC@OKGJABHJ@OO?$HMnn?3bisect_left?$AA@ DB 'OO|nn:bisect_left', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bisect_left
_TEXT	SEGMENT
lo$ = 64
index$ = 72
list$ = 80
hi$ = 88
item$ = 96
self$ = 128
args$ = 136
kw$ = 144
bisect_left PROC					; COMDAT

; 151  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 152  :     PyObject *list, *item;
; 153  :     Py_ssize_t lo = 0;

  00013	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR lo$[rsp], 0

; 154  :     Py_ssize_t hi = -1;

  0001c	48 c7 44 24 58
	ff ff ff ff	 mov	 QWORD PTR hi$[rsp], -1

; 155  :     Py_ssize_t index;
; 156  :     static char *keywords[] = {"a", "x", "lo", "hi", NULL};
; 157  : 
; 158  :     if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|nn:bisect_left",
; 159  :         keywords, &list, &item, &lo, &hi))

  00025	48 8d 44 24 58	 lea	 rax, QWORD PTR hi$[rsp]
  0002a	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0002f	48 8d 44 24 40	 lea	 rax, QWORD PTR lo$[rsp]
  00034	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00039	48 8d 44 24 60	 lea	 rax, QWORD PTR item$[rsp]
  0003e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00043	48 8d 44 24 50	 lea	 rax, QWORD PTR list$[rsp]
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??bisect_left@@9@9
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BC@OKGJABHJ@OO?$HMnn?3bisect_left?$AA@
  0005b	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  00063	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0006b	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00070	85 c0		 test	 eax, eax
  00072	75 04		 jne	 SHORT $LN2@bisect_lef

; 160  :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	eb 34		 jmp	 SHORT $LN3@bisect_lef
$LN2@bisect_lef:

; 161  :     index = internal_bisect_left(list, item, lo, hi);

  00078	4c 8b 4c 24 58	 mov	 r9, QWORD PTR hi$[rsp]
  0007d	4c 8b 44 24 40	 mov	 r8, QWORD PTR lo$[rsp]
  00082	48 8b 54 24 60	 mov	 rdx, QWORD PTR item$[rsp]
  00087	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  0008c	e8 00 00 00 00	 call	 internal_bisect_left
  00091	48 89 44 24 48	 mov	 QWORD PTR index$[rsp], rax

; 162  :     if (index < 0)

  00096	48 83 7c 24 48
	00		 cmp	 QWORD PTR index$[rsp], 0
  0009c	7d 04		 jge	 SHORT $LN1@bisect_lef

; 163  :         return NULL;

  0009e	33 c0		 xor	 eax, eax
  000a0	eb 0a		 jmp	 SHORT $LN3@bisect_lef
$LN1@bisect_lef:

; 164  :     return PyLong_FromSsize_t(index);

  000a2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR index$[rsp]
  000a7	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN3@bisect_lef:

; 165  : }

  000ac	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000b0	c3		 ret	 0
bisect_left ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$internal_bisect_left DD imagerel internal_bisect_left
	DD	imagerel internal_bisect_left+290
	DD	imagerel $unwind$internal_bisect_left
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$internal_bisect_left DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT internal_bisect_left
_TEXT	SEGMENT
mid$ = 32
res$ = 40
litem$ = 48
list$ = 80
item$ = 88
lo$ = 96
hi$ = 104
internal_bisect_left PROC				; COMDAT

; 116  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 117  :     PyObject *litem;
; 118  :     Py_ssize_t mid, res;
; 119  : 
; 120  :     if (lo < 0) {

  00018	48 83 7c 24 60
	00		 cmp	 QWORD PTR lo$[rsp], 0
  0001e	7d 1f		 jge	 SHORT $LN9@internal_b@2

; 121  :         PyErr_SetString(PyExc_ValueError, "lo must be non-negative");

  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@EJLDOAAC@lo?5must?5be?5non?9negative?$AA@
  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002e	e8 00 00 00 00	 call	 PyErr_SetString

; 122  :         return -1;

  00033	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0003a	e9 de 00 00 00	 jmp	 $LN10@internal_b@2
$LN9@internal_b@2:

; 123  :     }
; 124  :     if (hi == -1) {

  0003f	48 83 7c 24 68
	ff		 cmp	 QWORD PTR hi$[rsp], -1
  00045	75 23		 jne	 SHORT $LN8@internal_b@2

; 125  :         hi = PySequence_Size(list);

  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  0004c	e8 00 00 00 00	 call	 PySequence_Size
  00051	48 89 44 24 68	 mov	 QWORD PTR hi$[rsp], rax

; 126  :         if (hi < 0)

  00056	48 83 7c 24 68
	00		 cmp	 QWORD PTR hi$[rsp], 0
  0005c	7d 0c		 jge	 SHORT $LN7@internal_b@2

; 127  :             return -1;

  0005e	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00065	e9 b3 00 00 00	 jmp	 $LN10@internal_b@2
$LN7@internal_b@2:
$LN8@internal_b@2:
$LN6@internal_b@2:

; 128  :     }
; 129  :     while (lo < hi) {

  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR hi$[rsp]
  0006f	48 39 44 24 60	 cmp	 QWORD PTR lo$[rsp], rax
  00074	0f 8d 9e 00 00
	00		 jge	 $LN5@internal_b@2

; 130  :         /* The (size_t)cast ensures that the addition and subsequent division
; 131  :            are performed as unsigned operations, avoiding difficulties from
; 132  :            signed overflow.  (See issue 13496.) */
; 133  :         mid = ((size_t)lo + hi) / 2;

  0007a	48 8b 44 24 68	 mov	 rax, QWORD PTR hi$[rsp]
  0007f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lo$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	33 d2		 xor	 edx, edx
  0008c	b9 02 00 00 00	 mov	 ecx, 2
  00091	48 f7 f1	 div	 rcx
  00094	48 89 44 24 20	 mov	 QWORD PTR mid$[rsp], rax

; 134  :         litem = PySequence_GetItem(list, mid);

  00099	48 8b 54 24 20	 mov	 rdx, QWORD PTR mid$[rsp]
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  000a3	e8 00 00 00 00	 call	 PySequence_GetItem
  000a8	48 89 44 24 30	 mov	 QWORD PTR litem$[rsp], rax

; 135  :         if (litem == NULL)

  000ad	48 83 7c 24 30
	00		 cmp	 QWORD PTR litem$[rsp], 0
  000b3	75 09		 jne	 SHORT $LN4@internal_b@2

; 136  :             return -1;

  000b5	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000bc	eb 5f		 jmp	 SHORT $LN10@internal_b@2
$LN4@internal_b@2:

; 137  :         res = PyObject_RichCompareBool(litem, item, Py_LT);

  000be	45 33 c0	 xor	 r8d, r8d
  000c1	48 8b 54 24 58	 mov	 rdx, QWORD PTR item$[rsp]
  000c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR litem$[rsp]
  000cb	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000d0	48 98		 cdqe
  000d2	48 89 44 24 28	 mov	 QWORD PTR res$[rsp], rax

; 138  :         Py_DECREF(litem);

  000d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR litem$[rsp]
  000dc	e8 00 00 00 00	 call	 _Py_DecRef

; 139  :         if (res < 0)

  000e1	48 83 7c 24 28
	00		 cmp	 QWORD PTR res$[rsp], 0
  000e7	7d 09		 jge	 SHORT $LN3@internal_b@2

; 140  :             return -1;

  000e9	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000f0	eb 2b		 jmp	 SHORT $LN10@internal_b@2
$LN3@internal_b@2:

; 141  :         if (res)

  000f2	48 83 7c 24 28
	00		 cmp	 QWORD PTR res$[rsp], 0
  000f8	74 0f		 je	 SHORT $LN2@internal_b@2

; 142  :             lo = mid + 1;

  000fa	48 8b 44 24 20	 mov	 rax, QWORD PTR mid$[rsp]
  000ff	48 ff c0	 inc	 rax
  00102	48 89 44 24 60	 mov	 QWORD PTR lo$[rsp], rax

; 143  :         else

  00107	eb 0a		 jmp	 SHORT $LN1@internal_b@2
$LN2@internal_b@2:

; 144  :             hi = mid;

  00109	48 8b 44 24 20	 mov	 rax, QWORD PTR mid$[rsp]
  0010e	48 89 44 24 68	 mov	 QWORD PTR hi$[rsp], rax
$LN1@internal_b@2:

; 145  :     }

  00113	e9 52 ff ff ff	 jmp	 $LN6@internal_b@2
$LN5@internal_b@2:

; 146  :     return lo;

  00118	48 8b 44 24 60	 mov	 rax, QWORD PTR lo$[rsp]
$LN10@internal_b@2:

; 147  : }

  0011d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00121	c3		 ret	 0
internal_bisect_left ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@JHPPALNP@OO?$HMnn?3insort_left?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$insort_left DD imagerel insort_left
	DD	imagerel insort_left+328
	DD	imagerel $unwind$insort_left
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insort_left DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_0BC@JHPPALNP@OO?$HMnn?3insort_left?$AA@
CONST	SEGMENT
??_C@_0BC@JHPPALNP@OO?$HMnn?3insort_left?$AA@ DB 'OO|nn:insort_left', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT insort_left
_TEXT	SEGMENT
lo$ = 64
index$ = 72
list$ = 80
hi$ = 88
result$ = 96
item$ = 104
self$ = 128
args$ = 136
kw$ = 144
insort_left PROC					; COMDAT

; 181  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 182  :     PyObject *list, *item, *result;
; 183  :     Py_ssize_t lo = 0;

  00013	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR lo$[rsp], 0

; 184  :     Py_ssize_t hi = -1;

  0001c	48 c7 44 24 58
	ff ff ff ff	 mov	 QWORD PTR hi$[rsp], -1

; 185  :     Py_ssize_t index;
; 186  :     static char *keywords[] = {"a", "x", "lo", "hi", NULL};
; 187  : 
; 188  :     if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|nn:insort_left",
; 189  :         keywords, &list, &item, &lo, &hi))

  00025	48 8d 44 24 58	 lea	 rax, QWORD PTR hi$[rsp]
  0002a	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0002f	48 8d 44 24 40	 lea	 rax, QWORD PTR lo$[rsp]
  00034	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR item$[rsp]
  0003e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00043	48 8d 44 24 50	 lea	 rax, QWORD PTR list$[rsp]
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??insort_left@@9@9
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BC@JHPPALNP@OO?$HMnn?3insort_left?$AA@
  0005b	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  00063	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0006b	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00070	85 c0		 test	 eax, eax
  00072	75 07		 jne	 SHORT $LN6@insort_lef

; 190  :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	e9 c8 00 00 00	 jmp	 $LN7@insort_lef
$LN6@insort_lef:

; 191  :     index = internal_bisect_left(list, item, lo, hi);

  0007b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR hi$[rsp]
  00080	4c 8b 44 24 40	 mov	 r8, QWORD PTR lo$[rsp]
  00085	48 8b 54 24 68	 mov	 rdx, QWORD PTR item$[rsp]
  0008a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  0008f	e8 00 00 00 00	 call	 internal_bisect_left
  00094	48 89 44 24 48	 mov	 QWORD PTR index$[rsp], rax

; 192  :     if (index < 0)

  00099	48 83 7c 24 48
	00		 cmp	 QWORD PTR index$[rsp], 0
  0009f	7d 07		 jge	 SHORT $LN5@insort_lef

; 193  :         return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	e9 9b 00 00 00	 jmp	 $LN7@insort_lef
$LN5@insort_lef:

; 194  :     if (PyList_CheckExact(list)) {

  000a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  000b4	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000b8	75 1e		 jne	 SHORT $LN4@insort_lef

; 195  :         if (PyList_Insert(list, index, item) < 0)

  000ba	4c 8b 44 24 68	 mov	 r8, QWORD PTR item$[rsp]
  000bf	48 8b 54 24 48	 mov	 rdx, QWORD PTR index$[rsp]
  000c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  000c9	e8 00 00 00 00	 call	 PyList_Insert
  000ce	85 c0		 test	 eax, eax
  000d0	7d 04		 jge	 SHORT $LN3@insort_lef

; 196  :             return NULL;

  000d2	33 c0		 xor	 eax, eax
  000d4	eb 6d		 jmp	 SHORT $LN7@insort_lef
$LN3@insort_lef:

; 197  :     } else {

  000d6	eb 58		 jmp	 SHORT $LN2@insort_lef
$LN4@insort_lef:

; 198  :         _Py_IDENTIFIER(insert);
; 199  :         result = _PyObject_CallMethodId(list, &PyId_insert, "nO", index, item);

  000d8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_insert@?3??insort_left@@9@9
  000dd	8b c0		 mov	 eax, eax
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000e5	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000ee	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000f2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR item$[rsp]
  000f7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000fc	4c 8b 4c 24 48	 mov	 r9, QWORD PTR index$[rsp]
  00101	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02DFBGJDAN@nO?$AA@
  00108	48 8b d0	 mov	 rdx, rax
  0010b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR list$[rsp]
  00110	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  00115	48 89 44 24 60	 mov	 QWORD PTR result$[rsp], rax

; 200  :         if (result == NULL)

  0011a	48 83 7c 24 60
	00		 cmp	 QWORD PTR result$[rsp], 0
  00120	75 04		 jne	 SHORT $LN1@insort_lef

; 201  :             return NULL;

  00122	33 c0		 xor	 eax, eax
  00124	eb 1d		 jmp	 SHORT $LN7@insort_lef
$LN1@insort_lef:

; 202  :         Py_DECREF(result);

  00126	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  0012b	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@insort_lef:

; 203  :     }
; 204  : 
; 205  :     Py_RETURN_NONE;

  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00137	e8 00 00 00 00	 call	 _Py_IncRef
  0013c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN7@insort_lef:

; 206  : }

  00143	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00147	c3		 ret	 0
insort_left ENDP
_TEXT	ENDS
PUBLIC	PyInit__bisect
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__bisect DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$PyInit__bisect
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__bisect DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyInit__bisect
_TEXT	SEGMENT
PyInit__bisect PROC					; COMDAT

; 260  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 261  :     return PyModule_Create(&_bisectmodule);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_bisectmodule
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs

; 262  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
PyInit__bisect ENDP
_TEXT	ENDS
END
