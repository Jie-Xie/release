; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_Py_isspace__doc__
PUBLIC	_Py_isalpha__doc__
PUBLIC	_Py_isalnum__doc__
PUBLIC	_Py_isdigit__doc__
PUBLIC	_Py_islower__doc__
PUBLIC	_Py_isupper__doc__
PUBLIC	_Py_istitle__doc__
PUBLIC	_Py_lower__doc__
PUBLIC	_Py_upper__doc__
PUBLIC	_Py_title__doc__
PUBLIC	_Py_capitalize__doc__
PUBLIC	_Py_swapcase__doc__
PUBLIC	_Py_maketrans__doc__
CONST	SEGMENT
_Py_isspace__doc__ DB 'B.isspace() -> bool', 0aH, 0aH, 'Return True if al'
	DB	'l characters in B are whitespace', 0aH, 'and there is at leas'
	DB	't one character in B, False otherwise.', 00H
	ORG $+14
_Py_isalpha__doc__ DB 'B.isalpha() -> bool', 0aH, 0aH, 'Return True if al'
	DB	'l characters in B are alphabetic', 0aH, 'and there is at leas'
	DB	't one character in B, False otherwise.', 00H
	ORG $+14
_Py_isalnum__doc__ DB 'B.isalnum() -> bool', 0aH, 0aH, 'Return True if al'
	DB	'l characters in B are alphanumeric', 0aH, 'and there is at le'
	DB	'ast one character in B, False otherwise.', 00H
	ORG $+12
_Py_isdigit__doc__ DB 'B.isdigit() -> bool', 0aH, 0aH, 'Return True if al'
	DB	'l characters in B are digits', 0aH, 'and there is at least on'
	DB	'e character in B, False otherwise.', 00H
	ORG $+2
_Py_islower__doc__ DB 'B.islower() -> bool', 0aH, 0aH, 'Return True if al'
	DB	'l cased characters in B are lowercase and there is', 0aH, 'at'
	DB	' least one cased character in B, False otherwise.', 00H
	ORG $+3
_Py_isupper__doc__ DB 'B.isupper() -> bool', 0aH, 0aH, 'Return True if al'
	DB	'l cased characters in B are uppercase and there is', 0aH, 'at'
	DB	' least one cased character in B, False otherwise.', 00H
	ORG $+3
_Py_istitle__doc__ DB 'B.istitle() -> bool', 0aH, 0aH, 'Return True if B '
	DB	'is a titlecased string and there is at least one', 0aH, 'char'
	DB	'acter in B, i.e. uppercase characters may only follow uncased'
	DB	0aH, 'characters and lowercase characters only cased ones. Ret'
	DB	'urn False', 0aH, 'otherwise.', 00H
	ORG $+10
_Py_lower__doc__ DB 'B.lower() -> copy of B', 0aH, 0aH, 'Return a copy of'
	DB	' B with all ASCII characters converted to lowercase.', 00H
	ORG $+3
_Py_upper__doc__ DB 'B.upper() -> copy of B', 0aH, 0aH, 'Return a copy of'
	DB	' B with all ASCII characters converted to uppercase.', 00H
	ORG $+3
_Py_title__doc__ DB 'B.title() -> copy of B', 0aH, 0aH, 'Return a titleca'
	DB	'sed version of B, i.e. ASCII words start with uppercase', 0aH
	DB	'characters, all remaining cased characters have lowercase.', 00H
	ORG $+5
_Py_capitalize__doc__ DB 'B.capitalize() -> copy of B', 0aH, 0aH, 'Return'
	DB	' a copy of B with only its first character capitalized (ASCII'
	DB	')', 0aH, 'and the rest lower-cased.', 00H
	ORG $+4
_Py_swapcase__doc__ DB 'B.swapcase() -> copy of B', 0aH, 0aH, 'Return a c'
	DB	'opy of B with uppercase ASCII characters converted', 0aH, 'to'
	DB	' lowercase ASCII and vice versa.', 00H
	ORG $+5
_Py_maketrans__doc__ DB 'B.maketrans(frm, to) -> translation table', 0aH, 0aH
	DB	'Return a translation table (a bytes object of length 256) sui'
	DB	'table', 0aH, 'for use in the bytes or bytearray translate met'
	DB	'hod where each byte', 0aH, 'in frm is mapped to the byte at t'
	DB	'he same position in to.', 0aH, 'The bytes objects frm and to '
	DB	'must be of the same length.', 00H
CONST	ENDS
PUBLIC	_Py_IncRef
PUBLIC	_Py_bytes_isspace
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytes_methods.c
pdata	SEGMENT
$pdata$_Py_bytes_isspace DD imagerel $LN9
	DD	imagerel $LN9+246
	DD	imagerel $unwind$_Py_bytes_isspace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_isspace DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_isspace
_TEXT	SEGMENT
p$ = 32
e$ = 40
cptr$ = 64
len$ = 72
_Py_bytes_isspace PROC					; COMDAT

; 12   : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 13   :     register const unsigned char *p
; 14   :         = (unsigned char *) cptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR cptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 15   :     register const unsigned char *e;
; 16   : 
; 17   :     /* Shortcut for single character strings */
; 18   :     if (len == 1 && Py_ISSPACE(*p))

  00018	48 83 7c 24 48
	01		 cmp	 QWORD PTR len$[rsp], 1
  0001e	75 39		 jne	 SHORT $LN6@Py_bytes_i
  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00025	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002d	0f b6 c0	 movzx	 eax, al
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00037	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0003a	83 e0 08	 and	 eax, 8
  0003d	85 c0		 test	 eax, eax
  0003f	74 18		 je	 SHORT $LN6@Py_bytes_i

; 19   :         Py_RETURN_TRUE;

  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00048	e8 00 00 00 00	 call	 _Py_IncRef
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00054	e9 98 00 00 00	 jmp	 $LN7@Py_bytes_i
$LN6@Py_bytes_i:

; 20   : 
; 21   :     /* Special case for empty strings */
; 22   :     if (len == 0)

  00059	48 83 7c 24 48
	00		 cmp	 QWORD PTR len$[rsp], 0
  0005f	75 15		 jne	 SHORT $LN5@Py_bytes_i

; 23   :         Py_RETURN_FALSE;

  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00068	e8 00 00 00 00	 call	 _Py_IncRef
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00074	eb 7b		 jmp	 SHORT $LN7@Py_bytes_i
$LN5@Py_bytes_i:

; 24   : 
; 25   :     e = p + len;

  00076	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 89 44 24 28	 mov	 QWORD PTR e$[rsp], rax

; 26   :     for (; p < e; p++) {

  0008b	eb 0d		 jmp	 SHORT $LN4@Py_bytes_i
$LN3@Py_bytes_i:
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00092	48 ff c0	 inc	 rax
  00095	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN4@Py_bytes_i:
  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR e$[rsp]
  0009f	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  000a4	73 38		 jae	 SHORT $LN2@Py_bytes_i

; 27   :         if (!Py_ISSPACE(*p))

  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000ab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ae	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b3	0f b6 c0	 movzx	 eax, al
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000bd	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000c0	83 e0 08	 and	 eax, 8
  000c3	85 c0		 test	 eax, eax
  000c5	75 15		 jne	 SHORT $LN1@Py_bytes_i

; 28   :             Py_RETURN_FALSE;

  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000ce	e8 00 00 00 00	 call	 _Py_IncRef
  000d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000da	eb 15		 jmp	 SHORT $LN7@Py_bytes_i
$LN1@Py_bytes_i:

; 29   :     }

  000dc	eb af		 jmp	 SHORT $LN3@Py_bytes_i
$LN2@Py_bytes_i:

; 30   :     Py_RETURN_TRUE;

  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000e5	e8 00 00 00 00	 call	 _Py_IncRef
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
$LN7@Py_bytes_i:

; 31   : }

  000f1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f5	c3		 ret	 0
_Py_bytes_isspace ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	_Py_bytes_isalpha
;	COMDAT pdata
; File c:\src\pyparallel\objects\bytes_methods.c
pdata	SEGMENT
$pdata$_Py_bytes_isalpha DD imagerel $LN9
	DD	imagerel $LN9+246
	DD	imagerel $unwind$_Py_bytes_isalpha
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_isalpha DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_isalpha
_TEXT	SEGMENT
p$ = 32
e$ = 40
cptr$ = 64
len$ = 72
_Py_bytes_isalpha PROC					; COMDAT

; 42   : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 43   :     register const unsigned char *p
; 44   :         = (unsigned char *) cptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR cptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 45   :     register const unsigned char *e;
; 46   : 
; 47   :     /* Shortcut for single character strings */
; 48   :     if (len == 1 && Py_ISALPHA(*p))

  00018	48 83 7c 24 48
	01		 cmp	 QWORD PTR len$[rsp], 1
  0001e	75 39		 jne	 SHORT $LN6@Py_bytes_i@2
  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00025	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002d	0f b6 c0	 movzx	 eax, al
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00037	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0003a	83 e0 03	 and	 eax, 3
  0003d	85 c0		 test	 eax, eax
  0003f	74 18		 je	 SHORT $LN6@Py_bytes_i@2

; 49   :         Py_RETURN_TRUE;

  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00048	e8 00 00 00 00	 call	 _Py_IncRef
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00054	e9 98 00 00 00	 jmp	 $LN7@Py_bytes_i@2
$LN6@Py_bytes_i@2:

; 50   : 
; 51   :     /* Special case for empty strings */
; 52   :     if (len == 0)

  00059	48 83 7c 24 48
	00		 cmp	 QWORD PTR len$[rsp], 0
  0005f	75 15		 jne	 SHORT $LN5@Py_bytes_i@2

; 53   :         Py_RETURN_FALSE;

  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00068	e8 00 00 00 00	 call	 _Py_IncRef
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00074	eb 7b		 jmp	 SHORT $LN7@Py_bytes_i@2
$LN5@Py_bytes_i@2:

; 54   : 
; 55   :     e = p + len;

  00076	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 89 44 24 28	 mov	 QWORD PTR e$[rsp], rax

; 56   :     for (; p < e; p++) {

  0008b	eb 0d		 jmp	 SHORT $LN4@Py_bytes_i@2
$LN3@Py_bytes_i@2:
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00092	48 ff c0	 inc	 rax
  00095	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN4@Py_bytes_i@2:
  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR e$[rsp]
  0009f	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  000a4	73 38		 jae	 SHORT $LN2@Py_bytes_i@2

; 57   :         if (!Py_ISALPHA(*p))

  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000ab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ae	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b3	0f b6 c0	 movzx	 eax, al
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000bd	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000c0	83 e0 03	 and	 eax, 3
  000c3	85 c0		 test	 eax, eax
  000c5	75 15		 jne	 SHORT $LN1@Py_bytes_i@2

; 58   :             Py_RETURN_FALSE;

  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000ce	e8 00 00 00 00	 call	 _Py_IncRef
  000d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000da	eb 15		 jmp	 SHORT $LN7@Py_bytes_i@2
$LN1@Py_bytes_i@2:

; 59   :     }

  000dc	eb af		 jmp	 SHORT $LN3@Py_bytes_i@2
$LN2@Py_bytes_i@2:

; 60   :     Py_RETURN_TRUE;

  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000e5	e8 00 00 00 00	 call	 _Py_IncRef
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
$LN7@Py_bytes_i@2:

; 61   : }

  000f1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f5	c3		 ret	 0
_Py_bytes_isalpha ENDP
_TEXT	ENDS
PUBLIC	_Py_bytes_isalnum
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_bytes_isalnum DD imagerel $LN9
	DD	imagerel $LN9+246
	DD	imagerel $unwind$_Py_bytes_isalnum
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_isalnum DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_isalnum
_TEXT	SEGMENT
p$ = 32
e$ = 40
cptr$ = 64
len$ = 72
_Py_bytes_isalnum PROC					; COMDAT

; 72   : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 73   :     register const unsigned char *p
; 74   :         = (unsigned char *) cptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR cptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 75   :     register const unsigned char *e;
; 76   : 
; 77   :     /* Shortcut for single character strings */
; 78   :     if (len == 1 && Py_ISALNUM(*p))

  00018	48 83 7c 24 48
	01		 cmp	 QWORD PTR len$[rsp], 1
  0001e	75 39		 jne	 SHORT $LN6@Py_bytes_i@3
  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00025	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002d	0f b6 c0	 movzx	 eax, al
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00037	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0003a	83 e0 07	 and	 eax, 7
  0003d	85 c0		 test	 eax, eax
  0003f	74 18		 je	 SHORT $LN6@Py_bytes_i@3

; 79   :         Py_RETURN_TRUE;

  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00048	e8 00 00 00 00	 call	 _Py_IncRef
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00054	e9 98 00 00 00	 jmp	 $LN7@Py_bytes_i@3
$LN6@Py_bytes_i@3:

; 80   : 
; 81   :     /* Special case for empty strings */
; 82   :     if (len == 0)

  00059	48 83 7c 24 48
	00		 cmp	 QWORD PTR len$[rsp], 0
  0005f	75 15		 jne	 SHORT $LN5@Py_bytes_i@3

; 83   :         Py_RETURN_FALSE;

  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00068	e8 00 00 00 00	 call	 _Py_IncRef
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00074	eb 7b		 jmp	 SHORT $LN7@Py_bytes_i@3
$LN5@Py_bytes_i@3:

; 84   : 
; 85   :     e = p + len;

  00076	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 89 44 24 28	 mov	 QWORD PTR e$[rsp], rax

; 86   :     for (; p < e; p++) {

  0008b	eb 0d		 jmp	 SHORT $LN4@Py_bytes_i@3
$LN3@Py_bytes_i@3:
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00092	48 ff c0	 inc	 rax
  00095	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN4@Py_bytes_i@3:
  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR e$[rsp]
  0009f	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  000a4	73 38		 jae	 SHORT $LN2@Py_bytes_i@3

; 87   :         if (!Py_ISALNUM(*p))

  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000ab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ae	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b3	0f b6 c0	 movzx	 eax, al
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000bd	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000c0	83 e0 07	 and	 eax, 7
  000c3	85 c0		 test	 eax, eax
  000c5	75 15		 jne	 SHORT $LN1@Py_bytes_i@3

; 88   :             Py_RETURN_FALSE;

  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000ce	e8 00 00 00 00	 call	 _Py_IncRef
  000d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000da	eb 15		 jmp	 SHORT $LN7@Py_bytes_i@3
$LN1@Py_bytes_i@3:

; 89   :     }

  000dc	eb af		 jmp	 SHORT $LN3@Py_bytes_i@3
$LN2@Py_bytes_i@3:

; 90   :     Py_RETURN_TRUE;

  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000e5	e8 00 00 00 00	 call	 _Py_IncRef
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
$LN7@Py_bytes_i@3:

; 91   : }

  000f1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f5	c3		 ret	 0
_Py_bytes_isalnum ENDP
_TEXT	ENDS
PUBLIC	_Py_bytes_isdigit
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_bytes_isdigit DD imagerel $LN9
	DD	imagerel $LN9+246
	DD	imagerel $unwind$_Py_bytes_isdigit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_isdigit DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_isdigit
_TEXT	SEGMENT
p$ = 32
e$ = 40
cptr$ = 64
len$ = 72
_Py_bytes_isdigit PROC					; COMDAT

; 102  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 103  :     register const unsigned char *p
; 104  :         = (unsigned char *) cptr;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR cptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 105  :     register const unsigned char *e;
; 106  : 
; 107  :     /* Shortcut for single character strings */
; 108  :     if (len == 1 && Py_ISDIGIT(*p))

  00018	48 83 7c 24 48
	01		 cmp	 QWORD PTR len$[rsp], 1
  0001e	75 39		 jne	 SHORT $LN6@Py_bytes_i@4
  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00025	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002d	0f b6 c0	 movzx	 eax, al
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00037	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0003a	83 e0 04	 and	 eax, 4
  0003d	85 c0		 test	 eax, eax
  0003f	74 18		 je	 SHORT $LN6@Py_bytes_i@4

; 109  :         Py_RETURN_TRUE;

  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00048	e8 00 00 00 00	 call	 _Py_IncRef
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00054	e9 98 00 00 00	 jmp	 $LN7@Py_bytes_i@4
$LN6@Py_bytes_i@4:

; 110  : 
; 111  :     /* Special case for empty strings */
; 112  :     if (len == 0)

  00059	48 83 7c 24 48
	00		 cmp	 QWORD PTR len$[rsp], 0
  0005f	75 15		 jne	 SHORT $LN5@Py_bytes_i@4

; 113  :         Py_RETURN_FALSE;

  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00068	e8 00 00 00 00	 call	 _Py_IncRef
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00074	eb 7b		 jmp	 SHORT $LN7@Py_bytes_i@4
$LN5@Py_bytes_i@4:

; 114  : 
; 115  :     e = p + len;

  00076	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 89 44 24 28	 mov	 QWORD PTR e$[rsp], rax

; 116  :     for (; p < e; p++) {

  0008b	eb 0d		 jmp	 SHORT $LN4@Py_bytes_i@4
$LN3@Py_bytes_i@4:
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00092	48 ff c0	 inc	 rax
  00095	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN4@Py_bytes_i@4:
  0009a	48 8b 44 24 28	 mov	 rax, QWORD PTR e$[rsp]
  0009f	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  000a4	73 38		 jae	 SHORT $LN2@Py_bytes_i@4

; 117  :         if (!Py_ISDIGIT(*p))

  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000ab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ae	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b3	0f b6 c0	 movzx	 eax, al
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000bd	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000c0	83 e0 04	 and	 eax, 4
  000c3	85 c0		 test	 eax, eax
  000c5	75 15		 jne	 SHORT $LN1@Py_bytes_i@4

; 118  :             Py_RETURN_FALSE;

  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000ce	e8 00 00 00 00	 call	 _Py_IncRef
  000d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000da	eb 15		 jmp	 SHORT $LN7@Py_bytes_i@4
$LN1@Py_bytes_i@4:

; 119  :     }

  000dc	eb af		 jmp	 SHORT $LN3@Py_bytes_i@4
$LN2@Py_bytes_i@4:

; 120  :     Py_RETURN_TRUE;

  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000e5	e8 00 00 00 00	 call	 _Py_IncRef
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
$LN7@Py_bytes_i@4:

; 121  : }

  000f1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f5	c3		 ret	 0
_Py_bytes_isdigit ENDP
_TEXT	ENDS
PUBLIC	_Py_bytes_islower
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_bytes_islower DD imagerel $LN11
	DD	imagerel $LN11+284
	DD	imagerel $unwind$_Py_bytes_islower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_islower DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_islower
_TEXT	SEGMENT
p$ = 32
cased$ = 40
e$ = 48
cptr$ = 80
len$ = 88
_Py_bytes_islower PROC					; COMDAT

; 132  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 133  :     register const unsigned char *p
; 134  :         = (unsigned char *) cptr;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR cptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 135  :     register const unsigned char *e;
; 136  :     int cased;
; 137  : 
; 138  :     /* Shortcut for single character strings */
; 139  :     if (len == 1)

  00018	48 83 7c 24 58
	01		 cmp	 QWORD PTR len$[rsp], 1
  0001e	75 29		 jne	 SHORT $LN8@Py_bytes_i@5

; 140  :         return PyBool_FromLong(Py_ISLOWER(*p));

  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00025	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002d	0f b6 c0	 movzx	 eax, al
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00037	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0003a	83 e0 01	 and	 eax, 1
  0003d	8b c8		 mov	 ecx, eax
  0003f	e8 00 00 00 00	 call	 PyBool_FromLong
  00044	e9 ce 00 00 00	 jmp	 $LN9@Py_bytes_i@5
$LN8@Py_bytes_i@5:

; 141  : 
; 142  :     /* Special case for empty strings */
; 143  :     if (len == 0)

  00049	48 83 7c 24 58
	00		 cmp	 QWORD PTR len$[rsp], 0
  0004f	75 18		 jne	 SHORT $LN7@Py_bytes_i@5

; 144  :         Py_RETURN_FALSE;

  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00058	e8 00 00 00 00	 call	 _Py_IncRef
  0005d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00064	e9 ae 00 00 00	 jmp	 $LN9@Py_bytes_i@5
$LN7@Py_bytes_i@5:

; 145  : 
; 146  :     e = p + len;

  00069	48 8b 44 24 58	 mov	 rax, QWORD PTR len$[rsp]
  0006e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 30	 mov	 QWORD PTR e$[rsp], rax

; 147  :     cased = 0;

  0007e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR cased$[rsp], 0

; 148  :     for (; p < e; p++) {

  00086	eb 0d		 jmp	 SHORT $LN6@Py_bytes_i@5
$LN5@Py_bytes_i@5:
  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0008d	48 ff c0	 inc	 rax
  00090	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN6@Py_bytes_i@5:
  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR e$[rsp]
  0009a	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  0009f	73 6d		 jae	 SHORT $LN4@Py_bytes_i@5

; 149  :         if (Py_ISUPPER(*p))

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000a6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000ae	0f b6 c0	 movzx	 eax, al
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000b8	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000bb	83 e0 02	 and	 eax, 2
  000be	85 c0		 test	 eax, eax
  000c0	74 17		 je	 SHORT $LN3@Py_bytes_i@5

; 150  :             Py_RETURN_FALSE;

  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000c9	e8 00 00 00 00	 call	 _Py_IncRef
  000ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000d5	eb 40		 jmp	 SHORT $LN9@Py_bytes_i@5
  000d7	eb 30		 jmp	 SHORT $LN2@Py_bytes_i@5
$LN3@Py_bytes_i@5:

; 151  :         else if (!cased && Py_ISLOWER(*p))

  000d9	83 7c 24 28 00	 cmp	 DWORD PTR cased$[rsp], 0
  000de	75 29		 jne	 SHORT $LN1@Py_bytes_i@5
  000e0	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000e5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000ed	0f b6 c0	 movzx	 eax, al
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000f7	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000fa	83 e0 01	 and	 eax, 1
  000fd	85 c0		 test	 eax, eax
  000ff	74 08		 je	 SHORT $LN1@Py_bytes_i@5

; 152  :             cased = 1;

  00101	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR cased$[rsp], 1
$LN1@Py_bytes_i@5:
$LN2@Py_bytes_i@5:

; 153  :     }

  00109	e9 7a ff ff ff	 jmp	 $LN5@Py_bytes_i@5
$LN4@Py_bytes_i@5:

; 154  :     return PyBool_FromLong(cased);

  0010e	8b 4c 24 28	 mov	 ecx, DWORD PTR cased$[rsp]
  00112	e8 00 00 00 00	 call	 PyBool_FromLong
$LN9@Py_bytes_i@5:

; 155  : }

  00117	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011b	c3		 ret	 0
_Py_bytes_islower ENDP
_TEXT	ENDS
PUBLIC	_Py_bytes_isupper
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_bytes_isupper DD imagerel $LN11
	DD	imagerel $LN11+284
	DD	imagerel $unwind$_Py_bytes_isupper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_isupper DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_isupper
_TEXT	SEGMENT
p$ = 32
cased$ = 40
e$ = 48
cptr$ = 80
len$ = 88
_Py_bytes_isupper PROC					; COMDAT

; 166  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 167  :     register const unsigned char *p
; 168  :         = (unsigned char *) cptr;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR cptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 169  :     register const unsigned char *e;
; 170  :     int cased;
; 171  : 
; 172  :     /* Shortcut for single character strings */
; 173  :     if (len == 1)

  00018	48 83 7c 24 58
	01		 cmp	 QWORD PTR len$[rsp], 1
  0001e	75 29		 jne	 SHORT $LN8@Py_bytes_i@6

; 174  :         return PyBool_FromLong(Py_ISUPPER(*p));

  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00025	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002d	0f b6 c0	 movzx	 eax, al
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00037	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0003a	83 e0 02	 and	 eax, 2
  0003d	8b c8		 mov	 ecx, eax
  0003f	e8 00 00 00 00	 call	 PyBool_FromLong
  00044	e9 ce 00 00 00	 jmp	 $LN9@Py_bytes_i@6
$LN8@Py_bytes_i@6:

; 175  : 
; 176  :     /* Special case for empty strings */
; 177  :     if (len == 0)

  00049	48 83 7c 24 58
	00		 cmp	 QWORD PTR len$[rsp], 0
  0004f	75 18		 jne	 SHORT $LN7@Py_bytes_i@6

; 178  :         Py_RETURN_FALSE;

  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00058	e8 00 00 00 00	 call	 _Py_IncRef
  0005d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00064	e9 ae 00 00 00	 jmp	 $LN9@Py_bytes_i@6
$LN7@Py_bytes_i@6:

; 179  : 
; 180  :     e = p + len;

  00069	48 8b 44 24 58	 mov	 rax, QWORD PTR len$[rsp]
  0006e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 30	 mov	 QWORD PTR e$[rsp], rax

; 181  :     cased = 0;

  0007e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR cased$[rsp], 0

; 182  :     for (; p < e; p++) {

  00086	eb 0d		 jmp	 SHORT $LN6@Py_bytes_i@6
$LN5@Py_bytes_i@6:
  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0008d	48 ff c0	 inc	 rax
  00090	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN6@Py_bytes_i@6:
  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR e$[rsp]
  0009a	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  0009f	73 6d		 jae	 SHORT $LN4@Py_bytes_i@6

; 183  :         if (Py_ISLOWER(*p))

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000a6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000ae	0f b6 c0	 movzx	 eax, al
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000b8	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000bb	83 e0 01	 and	 eax, 1
  000be	85 c0		 test	 eax, eax
  000c0	74 17		 je	 SHORT $LN3@Py_bytes_i@6

; 184  :             Py_RETURN_FALSE;

  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000c9	e8 00 00 00 00	 call	 _Py_IncRef
  000ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000d5	eb 40		 jmp	 SHORT $LN9@Py_bytes_i@6
  000d7	eb 30		 jmp	 SHORT $LN2@Py_bytes_i@6
$LN3@Py_bytes_i@6:

; 185  :         else if (!cased && Py_ISUPPER(*p))

  000d9	83 7c 24 28 00	 cmp	 DWORD PTR cased$[rsp], 0
  000de	75 29		 jne	 SHORT $LN1@Py_bytes_i@6
  000e0	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000e5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000ed	0f b6 c0	 movzx	 eax, al
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000f7	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000fa	83 e0 02	 and	 eax, 2
  000fd	85 c0		 test	 eax, eax
  000ff	74 08		 je	 SHORT $LN1@Py_bytes_i@6

; 186  :             cased = 1;

  00101	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR cased$[rsp], 1
$LN1@Py_bytes_i@6:
$LN2@Py_bytes_i@6:

; 187  :     }

  00109	e9 7a ff ff ff	 jmp	 $LN5@Py_bytes_i@6
$LN4@Py_bytes_i@6:

; 188  :     return PyBool_FromLong(cased);

  0010e	8b 4c 24 28	 mov	 ecx, DWORD PTR cased$[rsp]
  00112	e8 00 00 00 00	 call	 PyBool_FromLong
$LN9@Py_bytes_i@6:

; 189  : }

  00117	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011b	c3		 ret	 0
_Py_bytes_isupper ENDP
_TEXT	ENDS
PUBLIC	_Py_bytes_istitle
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_bytes_istitle DD imagerel $LN14
	DD	imagerel $LN14+364
	DD	imagerel $unwind$_Py_bytes_istitle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_istitle DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_istitle
_TEXT	SEGMENT
p$ = 32
previous_is_cased$ = 40
cased$ = 44
e$ = 48
ch$20559 = 56
cptr$ = 80
len$ = 88
_Py_bytes_istitle PROC					; COMDAT

; 202  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 203  :     register const unsigned char *p
; 204  :         = (unsigned char *) cptr;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR cptr$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 205  :     register const unsigned char *e;
; 206  :     int cased, previous_is_cased;
; 207  : 
; 208  :     /* Shortcut for single character strings */
; 209  :     if (len == 1)

  00018	48 83 7c 24 58
	01		 cmp	 QWORD PTR len$[rsp], 1
  0001e	75 29		 jne	 SHORT $LN11@Py_bytes_i@7

; 210  :         return PyBool_FromLong(Py_ISUPPER(*p));

  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00025	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002d	0f b6 c0	 movzx	 eax, al
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00037	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0003a	83 e0 02	 and	 eax, 2
  0003d	8b c8		 mov	 ecx, eax
  0003f	e8 00 00 00 00	 call	 PyBool_FromLong
  00044	e9 1e 01 00 00	 jmp	 $LN12@Py_bytes_i@7
$LN11@Py_bytes_i@7:

; 211  : 
; 212  :     /* Special case for empty strings */
; 213  :     if (len == 0)

  00049	48 83 7c 24 58
	00		 cmp	 QWORD PTR len$[rsp], 0
  0004f	75 18		 jne	 SHORT $LN10@Py_bytes_i@7

; 214  :         Py_RETURN_FALSE;

  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00058	e8 00 00 00 00	 call	 _Py_IncRef
  0005d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00064	e9 fe 00 00 00	 jmp	 $LN12@Py_bytes_i@7
$LN10@Py_bytes_i@7:

; 215  : 
; 216  :     e = p + len;

  00069	48 8b 44 24 58	 mov	 rax, QWORD PTR len$[rsp]
  0006e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 30	 mov	 QWORD PTR e$[rsp], rax

; 217  :     cased = 0;

  0007e	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR cased$[rsp], 0

; 218  :     previous_is_cased = 0;

  00086	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR previous_is_cased$[rsp], 0

; 219  :     for (; p < e; p++) {

  0008e	eb 0d		 jmp	 SHORT $LN9@Py_bytes_i@7
$LN8@Py_bytes_i@7:
  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00095	48 ff c0	 inc	 rax
  00098	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN9@Py_bytes_i@7:
  0009d	48 8b 44 24 30	 mov	 rax, QWORD PTR e$[rsp]
  000a2	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  000a7	0f 83 b1 00 00
	00		 jae	 $LN7@Py_bytes_i@7

; 220  :         register const unsigned char ch = *p;

  000ad	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000b2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b5	88 44 24 38	 mov	 BYTE PTR ch$20559[rsp], al

; 221  : 
; 222  :         if (Py_ISUPPER(ch)) {

  000b9	0f b6 44 24 38	 movzx	 eax, BYTE PTR ch$20559[rsp]
  000be	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c3	0f b6 c0	 movzx	 eax, al
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000cd	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000d0	83 e0 02	 and	 eax, 2
  000d3	85 c0		 test	 eax, eax
  000d5	74 2e		 je	 SHORT $LN6@Py_bytes_i@7

; 223  :             if (previous_is_cased)

  000d7	83 7c 24 28 00	 cmp	 DWORD PTR previous_is_cased$[rsp], 0
  000dc	74 15		 je	 SHORT $LN5@Py_bytes_i@7

; 224  :                 Py_RETURN_FALSE;

  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000e5	e8 00 00 00 00	 call	 _Py_IncRef
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000f1	eb 74		 jmp	 SHORT $LN12@Py_bytes_i@7
$LN5@Py_bytes_i@7:

; 225  :             previous_is_cased = 1;

  000f3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR previous_is_cased$[rsp], 1

; 226  :             cased = 1;

  000fb	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR cased$[rsp], 1
  00103	eb 54		 jmp	 SHORT $LN4@Py_bytes_i@7
$LN6@Py_bytes_i@7:

; 227  :         }
; 228  :         else if (Py_ISLOWER(ch)) {

  00105	0f b6 44 24 38	 movzx	 eax, BYTE PTR ch$20559[rsp]
  0010a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0010f	0f b6 c0	 movzx	 eax, al
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00119	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0011c	83 e0 01	 and	 eax, 1
  0011f	85 c0		 test	 eax, eax
  00121	74 2e		 je	 SHORT $LN3@Py_bytes_i@7

; 229  :             if (!previous_is_cased)

  00123	83 7c 24 28 00	 cmp	 DWORD PTR previous_is_cased$[rsp], 0
  00128	75 15		 jne	 SHORT $LN2@Py_bytes_i@7

; 230  :                 Py_RETURN_FALSE;

  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00131	e8 00 00 00 00	 call	 _Py_IncRef
  00136	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0013d	eb 28		 jmp	 SHORT $LN12@Py_bytes_i@7
$LN2@Py_bytes_i@7:

; 231  :             previous_is_cased = 1;

  0013f	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR previous_is_cased$[rsp], 1

; 232  :             cased = 1;

  00147	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR cased$[rsp], 1

; 233  :         }
; 234  :         else

  0014f	eb 08		 jmp	 SHORT $LN1@Py_bytes_i@7
$LN3@Py_bytes_i@7:

; 235  :             previous_is_cased = 0;

  00151	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR previous_is_cased$[rsp], 0
$LN1@Py_bytes_i@7:
$LN4@Py_bytes_i@7:

; 236  :     }

  00159	e9 32 ff ff ff	 jmp	 $LN8@Py_bytes_i@7
$LN7@Py_bytes_i@7:

; 237  :     return PyBool_FromLong(cased);

  0015e	8b 4c 24 2c	 mov	 ecx, DWORD PTR cased$[rsp]
  00162	e8 00 00 00 00	 call	 PyBool_FromLong
$LN12@Py_bytes_i@7:

; 238  : }

  00167	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0016b	c3		 ret	 0
_Py_bytes_istitle ENDP
_TEXT	ENDS
PUBLIC	_Py_bytes_lower
EXTRN	_Py_ctype_tolower:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_bytes_lower DD imagerel $LN6
	DD	imagerel $LN6+112
	DD	imagerel $unwind$_Py_bytes_lower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_lower DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_lower
_TEXT	SEGMENT
i$ = 0
result$ = 32
cptr$ = 40
len$ = 48
_Py_bytes_lower PROC					; COMDAT

; 248  : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 249  :     Py_ssize_t i;
; 250  : 
; 251  :     for (i = 0; i < len; i++) {

  00013	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001b	eb 0b		 jmp	 SHORT $LN3@Py_bytes_l
$LN2@Py_bytes_l:
  0001d	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00021	48 ff c0	 inc	 rax
  00024	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN3@Py_bytes_l:
  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  0002d	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  00031	7d 38		 jge	 SHORT $LN1@Py_bytes_l

; 252  :         result[i] = Py_TOLOWER((unsigned char) cptr[i]);

  00033	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00037	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cptr$[rsp]
  0003c	48 03 c8	 add	 rcx, rax
  0003f	48 8b c1	 mov	 rax, rcx
  00042	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00045	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004a	0f b6 c0	 movzx	 eax, al
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_tolower
  00054	48 8b 14 24	 mov	 rdx, QWORD PTR i$[rsp]
  00058	4c 8b 44 24 20	 mov	 r8, QWORD PTR result$[rsp]
  0005d	4c 03 c2	 add	 r8, rdx
  00060	49 8b d0	 mov	 rdx, r8
  00063	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00067	88 02		 mov	 BYTE PTR [rdx], al

; 253  :     }

  00069	eb b2		 jmp	 SHORT $LN2@Py_bytes_l
$LN1@Py_bytes_l:

; 254  : }

  0006b	48 83 c4 18	 add	 rsp, 24
  0006f	c3		 ret	 0
_Py_bytes_lower ENDP
_TEXT	ENDS
PUBLIC	_Py_bytes_upper
EXTRN	_Py_ctype_toupper:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_bytes_upper DD imagerel $LN6
	DD	imagerel $LN6+112
	DD	imagerel $unwind$_Py_bytes_upper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_upper DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_upper
_TEXT	SEGMENT
i$ = 0
result$ = 32
cptr$ = 40
len$ = 48
_Py_bytes_upper PROC					; COMDAT

; 264  : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 265  :     Py_ssize_t i;
; 266  : 
; 267  :     for (i = 0; i < len; i++) {

  00013	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001b	eb 0b		 jmp	 SHORT $LN3@Py_bytes_u
$LN2@Py_bytes_u:
  0001d	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00021	48 ff c0	 inc	 rax
  00024	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN3@Py_bytes_u:
  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  0002d	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  00031	7d 38		 jge	 SHORT $LN1@Py_bytes_u

; 268  :         result[i] = Py_TOUPPER((unsigned char) cptr[i]);

  00033	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00037	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cptr$[rsp]
  0003c	48 03 c8	 add	 rcx, rax
  0003f	48 8b c1	 mov	 rax, rcx
  00042	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00045	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004a	0f b6 c0	 movzx	 eax, al
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_toupper
  00054	48 8b 14 24	 mov	 rdx, QWORD PTR i$[rsp]
  00058	4c 8b 44 24 20	 mov	 r8, QWORD PTR result$[rsp]
  0005d	4c 03 c2	 add	 r8, rdx
  00060	49 8b d0	 mov	 rdx, r8
  00063	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00067	88 02		 mov	 BYTE PTR [rdx], al

; 269  :     }

  00069	eb b2		 jmp	 SHORT $LN2@Py_bytes_u
$LN1@Py_bytes_u:

; 270  : }

  0006b	48 83 c4 18	 add	 rsp, 24
  0006f	c3		 ret	 0
_Py_bytes_upper ENDP
_TEXT	ENDS
PUBLIC	_Py_bytes_title
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_bytes_title DD imagerel $LN12
	DD	imagerel $LN12+285
	DD	imagerel $unwind$_Py_bytes_title
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_title DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_title
_TEXT	SEGMENT
i$ = 0
previous_is_cased$ = 8
c$20612 = 12
result$ = 32
s$ = 40
len$ = 48
_Py_bytes_title PROC					; COMDAT

; 281  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 282  :     Py_ssize_t i;
; 283  :     int previous_is_cased = 0;

  00013	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR previous_is_cased$[rsp], 0

; 284  : 
; 285  :     for (i = 0; i < len; i++) {

  0001b	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00023	eb 0b		 jmp	 SHORT $LN9@Py_bytes_t
$LN8@Py_bytes_t:
  00025	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00029	48 ff c0	 inc	 rax
  0002c	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN9@Py_bytes_t:
  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00035	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  00039	0f 8d d9 00 00
	00		 jge	 $LN7@Py_bytes_t

; 286  :         int c = Py_CHARMASK(*s++);

  0003f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00044	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00047	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004c	0f b6 c0	 movzx	 eax, al
  0004f	89 44 24 0c	 mov	 DWORD PTR c$20612[rsp], eax
  00053	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00058	48 ff c0	 inc	 rax
  0005b	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 287  :         if (Py_ISLOWER(c)) {

  00060	8b 44 24 0c	 mov	 eax, DWORD PTR c$20612[rsp]
  00064	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00069	0f b6 c0	 movzx	 eax, al
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00073	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00076	83 e0 01	 and	 eax, 1
  00079	85 c0		 test	 eax, eax
  0007b	74 2c		 je	 SHORT $LN6@Py_bytes_t

; 288  :             if (!previous_is_cased)

  0007d	83 7c 24 08 00	 cmp	 DWORD PTR previous_is_cased$[rsp], 0
  00082	75 1b		 jne	 SHORT $LN5@Py_bytes_t

; 289  :                 c = Py_TOUPPER(c);

  00084	8b 44 24 0c	 mov	 eax, DWORD PTR c$20612[rsp]
  00088	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0008d	0f b6 c0	 movzx	 eax, al
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_toupper
  00097	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009b	89 44 24 0c	 mov	 DWORD PTR c$20612[rsp], eax
$LN5@Py_bytes_t:

; 290  :             previous_is_cased = 1;

  0009f	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR previous_is_cased$[rsp], 1
  000a7	eb 51		 jmp	 SHORT $LN4@Py_bytes_t
$LN6@Py_bytes_t:

; 291  :         } else if (Py_ISUPPER(c)) {

  000a9	8b 44 24 0c	 mov	 eax, DWORD PTR c$20612[rsp]
  000ad	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b2	0f b6 c0	 movzx	 eax, al
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000bc	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000bf	83 e0 02	 and	 eax, 2
  000c2	85 c0		 test	 eax, eax
  000c4	74 2c		 je	 SHORT $LN3@Py_bytes_t

; 292  :             if (previous_is_cased)

  000c6	83 7c 24 08 00	 cmp	 DWORD PTR previous_is_cased$[rsp], 0
  000cb	74 1b		 je	 SHORT $LN2@Py_bytes_t

; 293  :                 c = Py_TOLOWER(c);

  000cd	8b 44 24 0c	 mov	 eax, DWORD PTR c$20612[rsp]
  000d1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000d6	0f b6 c0	 movzx	 eax, al
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_tolower
  000e0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e4	89 44 24 0c	 mov	 DWORD PTR c$20612[rsp], eax
$LN2@Py_bytes_t:

; 294  :             previous_is_cased = 1;

  000e8	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR previous_is_cased$[rsp], 1

; 295  :         } else

  000f0	eb 08		 jmp	 SHORT $LN1@Py_bytes_t
$LN3@Py_bytes_t:

; 296  :             previous_is_cased = 0;

  000f2	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR previous_is_cased$[rsp], 0
$LN1@Py_bytes_t:
$LN4@Py_bytes_t:

; 297  :         *result++ = c;

  000fa	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  000ff	0f b6 4c 24 0c	 movzx	 ecx, BYTE PTR c$20612[rsp]
  00104	88 08		 mov	 BYTE PTR [rax], cl
  00106	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0010b	48 ff c0	 inc	 rax
  0010e	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 298  :     }

  00113	e9 0d ff ff ff	 jmp	 $LN8@Py_bytes_t
$LN7@Py_bytes_t:

; 299  : }

  00118	48 83 c4 18	 add	 rsp, 24
  0011c	c3		 ret	 0
_Py_bytes_title ENDP
_TEXT	ENDS
PUBLIC	_Py_bytes_capitalize
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_bytes_capitalize DD imagerel $LN11
	DD	imagerel $LN11+307
	DD	imagerel $unwind$_Py_bytes_capitalize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_capitalize DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_capitalize
_TEXT	SEGMENT
i$ = 0
c$20633 = 8
c$20642 = 12
result$ = 32
s$ = 40
len$ = 48
_Py_bytes_capitalize PROC				; COMDAT

; 310  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 311  :     Py_ssize_t i;
; 312  : 
; 313  :     if (0 < len) {

  00013	48 83 7c 24 30
	00		 cmp	 QWORD PTR len$[rsp], 0
  00019	7e 77		 jle	 SHORT $LN8@Py_bytes_c

; 314  :         int c = Py_CHARMASK(*s++);

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00020	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00023	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00028	0f b6 c0	 movzx	 eax, al
  0002b	89 44 24 08	 mov	 DWORD PTR c$20633[rsp], eax
  0002f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00034	48 ff c0	 inc	 rax
  00037	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 315  :         if (Py_ISLOWER(c))

  0003c	8b 44 24 08	 mov	 eax, DWORD PTR c$20633[rsp]
  00040	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00045	0f b6 c0	 movzx	 eax, al
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0004f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00052	83 e0 01	 and	 eax, 1
  00055	85 c0		 test	 eax, eax
  00057	74 20		 je	 SHORT $LN7@Py_bytes_c

; 316  :             *result = Py_TOUPPER(c);

  00059	8b 44 24 08	 mov	 eax, DWORD PTR c$20633[rsp]
  0005d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00062	0f b6 c0	 movzx	 eax, al
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_toupper
  0006c	48 8b 54 24 20	 mov	 rdx, QWORD PTR result$[rsp]
  00071	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00075	88 02		 mov	 BYTE PTR [rdx], al

; 317  :         else

  00077	eb 0c		 jmp	 SHORT $LN6@Py_bytes_c
$LN7@Py_bytes_c:

; 318  :             *result = c;

  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0007e	0f b6 4c 24 08	 movzx	 ecx, BYTE PTR c$20633[rsp]
  00083	88 08		 mov	 BYTE PTR [rax], cl
$LN6@Py_bytes_c:

; 319  :         result++;

  00085	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0008a	48 ff c0	 inc	 rax
  0008d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN8@Py_bytes_c:

; 320  :     }
; 321  :     for (i = 1; i < len; i++) {

  00092	48 c7 04 24 01
	00 00 00	 mov	 QWORD PTR i$[rsp], 1
  0009a	eb 0b		 jmp	 SHORT $LN5@Py_bytes_c
$LN4@Py_bytes_c:
  0009c	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  000a0	48 ff c0	 inc	 rax
  000a3	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN5@Py_bytes_c:
  000a7	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  000ac	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  000b0	7d 7c		 jge	 SHORT $LN3@Py_bytes_c

; 322  :         int c = Py_CHARMASK(*s++);

  000b2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000b7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ba	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000bf	0f b6 c0	 movzx	 eax, al
  000c2	89 44 24 0c	 mov	 DWORD PTR c$20642[rsp], eax
  000c6	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000cb	48 ff c0	 inc	 rax
  000ce	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 323  :         if (Py_ISUPPER(c))

  000d3	8b 44 24 0c	 mov	 eax, DWORD PTR c$20642[rsp]
  000d7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000dc	0f b6 c0	 movzx	 eax, al
  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000e6	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000e9	83 e0 02	 and	 eax, 2
  000ec	85 c0		 test	 eax, eax
  000ee	74 20		 je	 SHORT $LN2@Py_bytes_c

; 324  :             *result = Py_TOLOWER(c);

  000f0	8b 44 24 0c	 mov	 eax, DWORD PTR c$20642[rsp]
  000f4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000f9	0f b6 c0	 movzx	 eax, al
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_tolower
  00103	48 8b 54 24 20	 mov	 rdx, QWORD PTR result$[rsp]
  00108	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0010c	88 02		 mov	 BYTE PTR [rdx], al

; 325  :         else

  0010e	eb 0c		 jmp	 SHORT $LN1@Py_bytes_c
$LN2@Py_bytes_c:

; 326  :             *result = c;

  00110	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00115	0f b6 4c 24 0c	 movzx	 ecx, BYTE PTR c$20642[rsp]
  0011a	88 08		 mov	 BYTE PTR [rax], cl
$LN1@Py_bytes_c:

; 327  :         result++;

  0011c	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00121	48 ff c0	 inc	 rax
  00124	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 328  :     }

  00129	e9 6e ff ff ff	 jmp	 $LN4@Py_bytes_c
$LN3@Py_bytes_c:

; 329  : }

  0012e	48 83 c4 18	 add	 rsp, 24
  00132	c3		 ret	 0
_Py_bytes_capitalize ENDP
_TEXT	ENDS
PUBLIC	_Py_bytes_swapcase
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_bytes_swapcase DD imagerel $LN10
	DD	imagerel $LN10+245
	DD	imagerel $unwind$_Py_bytes_swapcase
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_swapcase DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_bytes_swapcase
_TEXT	SEGMENT
i$ = 0
c$20659 = 8
result$ = 32
s$ = 40
len$ = 48
_Py_bytes_swapcase PROC					; COMDAT

; 340  : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 341  :     Py_ssize_t i;
; 342  : 
; 343  :     for (i = 0; i < len; i++) {

  00013	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001b	eb 0b		 jmp	 SHORT $LN7@Py_bytes_s
$LN6@Py_bytes_s:
  0001d	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00021	48 ff c0	 inc	 rax
  00024	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN7@Py_bytes_s:
  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  0002d	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  00031	0f 8d b9 00 00
	00		 jge	 $LN5@Py_bytes_s

; 344  :         int c = Py_CHARMASK(*s++);

  00037	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0003c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0003f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00044	0f b6 c0	 movzx	 eax, al
  00047	89 44 24 08	 mov	 DWORD PTR c$20659[rsp], eax
  0004b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00050	48 ff c0	 inc	 rax
  00053	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 345  :         if (Py_ISLOWER(c)) {

  00058	8b 44 24 08	 mov	 eax, DWORD PTR c$20659[rsp]
  0005c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00061	0f b6 c0	 movzx	 eax, al
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0006b	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0006e	83 e0 01	 and	 eax, 1
  00071	85 c0		 test	 eax, eax
  00073	74 20		 je	 SHORT $LN4@Py_bytes_s

; 346  :             *result = Py_TOUPPER(c);

  00075	8b 44 24 08	 mov	 eax, DWORD PTR c$20659[rsp]
  00079	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007e	0f b6 c0	 movzx	 eax, al
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_toupper
  00088	48 8b 54 24 20	 mov	 rdx, QWORD PTR result$[rsp]
  0008d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00091	88 02		 mov	 BYTE PTR [rdx], al
  00093	eb 49		 jmp	 SHORT $LN3@Py_bytes_s
$LN4@Py_bytes_s:

; 347  :         }
; 348  :         else if (Py_ISUPPER(c)) {

  00095	8b 44 24 08	 mov	 eax, DWORD PTR c$20659[rsp]
  00099	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0009e	0f b6 c0	 movzx	 eax, al
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  000a8	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000ab	83 e0 02	 and	 eax, 2
  000ae	85 c0		 test	 eax, eax
  000b0	74 20		 je	 SHORT $LN2@Py_bytes_s

; 349  :             *result = Py_TOLOWER(c);

  000b2	8b 44 24 08	 mov	 eax, DWORD PTR c$20659[rsp]
  000b6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000bb	0f b6 c0	 movzx	 eax, al
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_tolower
  000c5	48 8b 54 24 20	 mov	 rdx, QWORD PTR result$[rsp]
  000ca	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ce	88 02		 mov	 BYTE PTR [rdx], al

; 350  :         }
; 351  :         else

  000d0	eb 0c		 jmp	 SHORT $LN1@Py_bytes_s
$LN2@Py_bytes_s:

; 352  :             *result = c;

  000d2	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  000d7	0f b6 4c 24 08	 movzx	 ecx, BYTE PTR c$20659[rsp]
  000dc	88 08		 mov	 BYTE PTR [rax], cl
$LN1@Py_bytes_s:
$LN3@Py_bytes_s:

; 353  :         result++;

  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  000e3	48 ff c0	 inc	 rax
  000e6	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 354  :     }

  000eb	e9 2d ff ff ff	 jmp	 $LN6@Py_bytes_s
$LN5@Py_bytes_s:

; 355  : }

  000f0	48 83 c4 18	 add	 rsp, 24
  000f4	c3		 ret	 0
_Py_bytes_swapcase ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CG@OADLJEAH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@BKBPPAOF@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AA_?$AAm?$AAe?$AAt?$AAh?$AAo?$AAd?$AAs?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CK@EBIGHGMM@maketrans?5arguments?5must?5have?5sa@ ; `string'
PUBLIC	??_C@_0N@PCKKDHD@OO?3maketrans?$AA@		; `string'
PUBLIC	_Py_bytes_maketrans
EXTRN	PyBuffer_Release:PROC
EXTRN	__imp__wassert:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_bytes_maketrans DD imagerel $LN17
	DD	imagerel $LN17+478
	DD	imagerel $unwind$_Py_bytes_maketrans
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_bytes_maketrans DD 020c01H
	DD	01f010cH
xdata	ENDS
;	COMDAT ??_C@_1CG@OADLJEAH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@OADLJEAH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@BKBPPAOF@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AA_?$AAm?$AAe?$AAt?$AAh?$AAo?$AAd?$AAs?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@BKBPPAOF@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AA_?$AAm?$AAe?$AAt?$AAh?$AAo?$AAd?$AAs?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'b', 00H, 'y', 00H, 't'
	DB	00H, 'e', 00H, 's', 00H, '_', 00H, 'm', 00H, 'e', 00H, 't', 00H
	DB	'h', 00H, 'o', 00H, 'd', 00H, 's', 00H, '.', 00H, 'c', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EBIGHGMM@maketrans?5arguments?5must?5have?5sa@
CONST	SEGMENT
??_C@_0CK@EBIGHGMM@maketrans?5arguments?5must?5have?5sa@ DB 'maketrans ar'
	DB	'guments must have same length', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PCKKDHD@OO?3maketrans?$AA@
CONST	SEGMENT
??_C@_0N@PCKKDHD@OO?3maketrans?$AA@ DB 'OO:maketrans', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_bytes_maketrans
_TEXT	SEGMENT
p$ = 32
frm$ = 40
res$ = 48
i$ = 56
to$ = 64
bto$ = 80
bfrm$ = 160
args$ = 256
_Py_bytes_maketrans PROC				; COMDAT

; 386  : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 387  :     PyObject *frm, *to, *res = NULL;

  0000c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR res$[rsp], 0

; 388  :     Py_buffer bfrm, bto;
; 389  :     Py_ssize_t i;
; 390  :     char *p;
; 391  : 
; 392  :     bfrm.len = -1;

  00015	48 c7 84 24 b0
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR bfrm$[rsp+16], -1

; 393  :     bto.len = -1;

  00021	48 c7 44 24 60
	ff ff ff ff	 mov	 QWORD PTR bto$[rsp+16], -1

; 394  : 
; 395  :     if (!PyArg_ParseTuple(args, "OO:maketrans", &frm, &to))

  0002a	4c 8d 4c 24 40	 lea	 r9, QWORD PTR to$[rsp]
  0002f	4c 8d 44 24 28	 lea	 r8, QWORD PTR frm$[rsp]
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@PCKKDHD@OO?3maketrans?$AA@
  0003b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00043	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00048	85 c0		 test	 eax, eax
  0004a	75 07		 jne	 SHORT $LN13@Py_bytes_m

; 396  :         return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 83 01 00 00	 jmp	 $LN14@Py_bytes_m
$LN13@Py_bytes_m:

; 397  :     if (_getbuffer(frm, &bfrm) < 0)

  00053	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR bfrm$[rsp]
  0005b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR frm$[rsp]
  00060	e8 00 00 00 00	 call	 _getbuffer
  00065	48 85 c0	 test	 rax, rax
  00068	7d 07		 jge	 SHORT $LN12@Py_bytes_m

; 398  :         return NULL;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 65 01 00 00	 jmp	 $LN14@Py_bytes_m
$LN12@Py_bytes_m:

; 399  :     if (_getbuffer(to, &bto) < 0)

  00071	48 8d 54 24 50	 lea	 rdx, QWORD PTR bto$[rsp]
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR to$[rsp]
  0007b	e8 00 00 00 00	 call	 _getbuffer
  00080	48 85 c0	 test	 rax, rax
  00083	7d 05		 jge	 SHORT $LN11@Py_bytes_m

; 400  :         goto done;

  00085	e9 1d 01 00 00	 jmp	 $done$20701
$LN11@Py_bytes_m:

; 401  :     if (bfrm.len != bto.len) {

  0008a	48 8b 44 24 60	 mov	 rax, QWORD PTR bto$[rsp+16]
  0008f	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR bfrm$[rsp+16], rax
  00097	74 18		 je	 SHORT $LN10@Py_bytes_m

; 402  :         PyErr_Format(PyExc_ValueError,
; 403  :                      "maketrans arguments must have same length");

  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@EBIGHGMM@maketrans?5arguments?5must?5have?5sa@
  000a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a7	e8 00 00 00 00	 call	 PyErr_Format

; 404  :         goto done;

  000ac	e9 f6 00 00 00	 jmp	 $done$20701
$LN10@Py_bytes_m:

; 405  :     }
; 406  :     res = PyBytes_FromStringAndSize(NULL, 256);

  000b1	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  000b6	33 c9		 xor	 ecx, ecx
  000b8	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000bd	48 89 44 24 30	 mov	 QWORD PTR res$[rsp], rax

; 407  :     if (!res) {

  000c2	48 83 7c 24 30
	00		 cmp	 QWORD PTR res$[rsp], 0
  000c8	75 05		 jne	 SHORT $LN9@Py_bytes_m

; 408  :         goto done;

  000ca	e9 d8 00 00 00	 jmp	 $done$20701
$LN9@Py_bytes_m:

; 409  :     }
; 410  :     p = PyBytes_AS_STRING(res);

  000cf	48 8b 44 24 30	 mov	 rax, QWORD PTR res$[rsp]
  000d4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000de	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000e3	85 c0		 test	 eax, eax
  000e5	75 1c		 jne	 SHORT $LN16@Py_bytes_m
  000e7	41 b8 9a 01 00
	00		 mov	 r8d, 410		; 0000019aH
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DG@BKBPPAOF@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAb?$AAy?$AAt?$AAe?$AAs?$AA_?$AAm?$AAe?$AAt?$AAh?$AAo?$AAd?$AAs?$AA?4?$AAc?$AA?$AA@
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@OADLJEAH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00101	33 c0		 xor	 eax, eax
$LN16@Py_bytes_m:
  00103	48 8b 44 24 30	 mov	 rax, QWORD PTR res$[rsp]
  00108	48 83 c0 78	 add	 rax, 120		; 00000078H
  0010c	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 411  :     for (i = 0; i < 256; i++)

  00111	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0011a	eb 0d		 jmp	 SHORT $LN8@Py_bytes_m
$LN7@Py_bytes_m:
  0011c	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00121	48 ff c0	 inc	 rax
  00124	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN8@Py_bytes_m:
  00129	48 81 7c 24 38
	00 01 00 00	 cmp	 QWORD PTR i$[rsp], 256	; 00000100H
  00132	7d 19		 jge	 SHORT $LN6@Py_bytes_m

; 412  :         p[i] = (char) i;

  00134	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00139	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0013e	48 03 c8	 add	 rcx, rax
  00141	48 8b c1	 mov	 rax, rcx
  00144	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR i$[rsp]
  00149	88 08		 mov	 BYTE PTR [rax], cl
  0014b	eb cf		 jmp	 SHORT $LN7@Py_bytes_m
$LN6@Py_bytes_m:

; 413  :     for (i = 0; i < bfrm.len; i++) {

  0014d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00156	eb 0d		 jmp	 SHORT $LN5@Py_bytes_m
$LN4@Py_bytes_m:
  00158	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0015d	48 ff c0	 inc	 rax
  00160	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN5@Py_bytes_m:
  00165	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR bfrm$[rsp+16]
  0016d	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00172	7d 33		 jge	 SHORT $LN3@Py_bytes_m

; 414  :         p[((unsigned char *)bfrm.buf)[i]] = ((char *)bto.buf)[i];

  00174	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00179	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR bfrm$[rsp]
  00181	48 03 c8	 add	 rcx, rax
  00184	48 8b c1	 mov	 rax, rcx
  00187	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0018a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0018f	48 8b 54 24 50	 mov	 rdx, QWORD PTR bto$[rsp]
  00194	48 03 d1	 add	 rdx, rcx
  00197	48 8b ca	 mov	 rcx, rdx
  0019a	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  0019f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001a2	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl

; 415  :     }

  001a5	eb b1		 jmp	 SHORT $LN4@Py_bytes_m
$LN3@Py_bytes_m:
$done$20701:

; 416  : 
; 417  : done:
; 418  :     if (bfrm.len != -1)

  001a7	48 83 bc 24 b0
	00 00 00 ff	 cmp	 QWORD PTR bfrm$[rsp+16], -1
  001b0	74 0d		 je	 SHORT $LN2@Py_bytes_m

; 419  :         PyBuffer_Release(&bfrm);

  001b2	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR bfrm$[rsp]
  001ba	e8 00 00 00 00	 call	 PyBuffer_Release
$LN2@Py_bytes_m:

; 420  :     if (bto.len != -1)

  001bf	48 83 7c 24 60
	ff		 cmp	 QWORD PTR bto$[rsp+16], -1
  001c5	74 0a		 je	 SHORT $LN1@Py_bytes_m

; 421  :         PyBuffer_Release(&bto);

  001c7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR bto$[rsp]
  001cc	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@Py_bytes_m:

; 422  :     return res;

  001d1	48 8b 44 24 30	 mov	 rax, QWORD PTR res$[rsp]
$LN14@Py_bytes_m:

; 423  : }

  001d6	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  001dd	c3		 ret	 0
_Py_bytes_maketrans ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@ ; `string'
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_getbuffer DD imagerel _getbuffer
	DD	imagerel _getbuffer+142
	DD	imagerel $unwind$_getbuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_getbuffer DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@
CONST	SEGMENT
??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@ DB 'Type %'
	DB	'.100s doesn''t support the buffer API', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _getbuffer
_TEXT	SEGMENT
buffer$ = 32
obj$ = 64
view$ = 72
_getbuffer PROC						; COMDAT

; 368  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 369  :     PyBufferProcs *buffer = Py_TYPE(obj)->tp_as_buffer;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  0001e	48 89 44 24 20	 mov	 QWORD PTR buffer$[rsp], rax

; 370  : 
; 371  :     if (buffer == NULL || buffer->bf_getbuffer == NULL)

  00023	48 83 7c 24 20
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00029	74 0b		 je	 SHORT $LN2@getbuffer
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00030	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00034	75 29		 jne	 SHORT $LN3@getbuffer
$LN2@getbuffer:

; 372  :     {
; 373  :         PyErr_Format(PyExc_TypeError,
; 374  :                      "Type %.100s doesn't support the buffer API",
; 375  :                      Py_TYPE(obj)->tp_name);

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  0003b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003f	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@HMLNEJOC@Type?5?$CF?4100s?5doesn?8t?5support?5the?5@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00051	e8 00 00 00 00	 call	 PyErr_Format

; 376  :         return -1;

  00056	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0005d	eb 2a		 jmp	 SHORT $LN4@getbuffer
$LN3@getbuffer:

; 377  :     }
; 378  : 
; 379  :     if (buffer->bf_getbuffer(obj, view, PyBUF_SIMPLE) < 0)

  0005f	45 33 c0	 xor	 r8d, r8d
  00062	48 8b 54 24 48	 mov	 rdx, QWORD PTR view$[rsp]
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR buffer$[rsp]
  00071	ff 10		 call	 QWORD PTR [rax]
  00073	85 c0		 test	 eax, eax
  00075	7d 09		 jge	 SHORT $LN1@getbuffer

; 380  :         return -1;

  00077	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0007e	eb 09		 jmp	 SHORT $LN4@getbuffer
$LN1@getbuffer:

; 381  :     return view->len;

  00080	48 8b 44 24 48	 mov	 rax, QWORD PTR view$[rsp]
  00085	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
$LN4@getbuffer:

; 382  : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
_getbuffer ENDP
_TEXT	ENDS
END
