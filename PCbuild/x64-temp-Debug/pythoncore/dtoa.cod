; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
private_mem DQ	0120H DUP (?)
_BSS	ENDS
CONST	SEGMENT
tens	DQ	03ff0000000000000r		; 1
	DQ	04024000000000000r		; 10
	DQ	04059000000000000r		; 100
	DQ	0408f400000000000r		; 1000
	DQ	040c3880000000000r		; 10000
	DQ	040f86a0000000000r		; 100000
	DQ	0412e848000000000r		; 1e+006
	DQ	0416312d000000000r		; 1e+007
	DQ	04197d78400000000r		; 1e+008
	DQ	041cdcd6500000000r		; 1e+009
	DQ	04202a05f20000000r		; 1e+010
	DQ	042374876e8000000r		; 1e+011
	DQ	0426d1a94a2000000r		; 1e+012
	DQ	042a2309ce5400000r		; 1e+013
	DQ	042d6bcc41e900000r		; 1e+014
	DQ	0430c6bf526340000r		; 1e+015
	DQ	04341c37937e08000r		; 1e+016
	DQ	04376345785d8a000r		; 1e+017
	DQ	043abc16d674ec800r		; 1e+018
	DQ	043e158e460913d00r		; 1e+019
	DQ	04415af1d78b58c40r		; 1e+020
	DQ	0444b1ae4d6e2ef50r		; 1e+021
	DQ	04480f0cf064dd592r		; 1e+022
bigtens	DQ	04341c37937e08000r		; 1e+016
	DQ	04693b8b5b5056e17r		; 1e+032
	DQ	04d384f03e93ff9f5r		; 1e+064
	DQ	05a827748f9301d32r		; 1e+128
	DQ	075154fdd7f73bf3cr		; 1e+256
tinytens DQ	03c9cd2b297d889bcr		; 1e-016
	DQ	03949f623d5a8a733r		; 1e-032
	DQ	032a50ffd44f4a73dr		; 1e-064
	DQ	0255bba08cf8c979dr		; 1e-128
	DQ	01168062864ac6f43r		; 8.11296e-225
CONST	ENDS
_DATA	SEGMENT
pmem_next DQ	FLAT:private_mem
?p05@?1??pow5mult@@9@9 DD 05H				; `pow5mult'::`2'::p05
	DD	019H
	DD	07dH
_DATA	ENDS
PUBLIC	_Py_dg_stdnan
EXTRN	_fltused:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\python\dtoa.c
pdata	SEGMENT
$pdata$_Py_dg_stdnan DD imagerel $LN4
	DD	imagerel $LN4+52
	DD	imagerel $unwind$_Py_dg_stdnan
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_dg_stdnan DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_dg_stdnan
_TEXT	SEGMENT
rv$ = 0
sign$ = 32
_Py_dg_stdnan PROC					; COMDAT

; 1525 : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 1526 :     U rv;
; 1527 :     word0(&rv) = NAN_WORD0;

  00008	c7 44 24 04 00
	00 f8 7f	 mov	 DWORD PTR rv$[rsp+4], 2146959360 ; 7ff80000H

; 1528 :     word1(&rv) = NAN_WORD1;

  00010	c7 04 24 00 00
	00 00		 mov	 DWORD PTR rv$[rsp], 0

; 1529 :     if (sign)

  00017	83 7c 24 20 00	 cmp	 DWORD PTR sign$[rsp], 0
  0001c	74 0c		 je	 SHORT $LN1@Py_dg_stdn

; 1530 :         word0(&rv) |= Sign_bit;

  0001e	8b 44 24 04	 mov	 eax, DWORD PTR rv$[rsp+4]
  00022	0f ba e8 1f	 bts	 eax, 31
  00026	89 44 24 04	 mov	 DWORD PTR rv$[rsp+4], eax
$LN1@Py_dg_stdn:

; 1531 :     return dval(&rv);

  0002a	f2 0f 10 04 24	 movsdx	 xmm0, QWORD PTR rv$[rsp]

; 1532 : }

  0002f	48 83 c4 18	 add	 rsp, 24
  00033	c3		 ret	 0
_Py_dg_stdnan ENDP
_TEXT	ENDS
PUBLIC	__mask@@NegDouble@
PUBLIC	_Py_dg_infinity
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_dg_infinity DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$_Py_dg_infinity
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_dg_infinity DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT __mask@@NegDouble@
CONST	SEGMENT
__mask@@NegDouble@ DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_dg_infinity
_TEXT	SEGMENT
rv$ = 0
tv67 = 8
sign$ = 32
_Py_dg_infinity PROC					; COMDAT

; 1539 : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 1540 :     U rv;
; 1541 :     word0(&rv) = POSINF_WORD0;

  00008	c7 44 24 04 00
	00 f0 7f	 mov	 DWORD PTR rv$[rsp+4], 2146435072 ; 7ff00000H

; 1542 :     word1(&rv) = POSINF_WORD1;

  00010	c7 04 24 00 00
	00 00		 mov	 DWORD PTR rv$[rsp], 0

; 1543 :     return sign ? -dval(&rv) : dval(&rv);

  00017	83 7c 24 20 00	 cmp	 DWORD PTR sign$[rsp], 0
  0001c	74 15		 je	 SHORT $LN3@Py_dg_infi
  0001e	f2 0f 10 04 24	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  00023	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  0002b	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR tv67[rsp], xmm0
  00031	eb 0b		 jmp	 SHORT $LN4@Py_dg_infi
$LN3@Py_dg_infi:
  00033	f2 0f 10 04 24	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  00038	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR tv67[rsp], xmm0
$LN4@Py_dg_infi:
  0003e	f2 0f 10 44 24
	08		 movsdx	 xmm0, QWORD PTR tv67[rsp]

; 1544 : }

  00044	48 83 c4 18	 add	 rsp, 24
  00048	c3		 ret	 0
_Py_dg_infinity ENDP
_TEXT	ENDS
PUBLIC	__real@8000000000000000
PUBLIC	__real@3fcfffff94a03595
PUBLIC	__real@3fe0000035afe535
PUBLIC	__real@3fdfffff94a03595
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	_Py_dg_strtod
EXTRN	__imp__errno:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_dg_strtod DD imagerel $LN208
	DD	imagerel $LN208+7587
	DD	imagerel $unwind$_Py_dg_strtod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_dg_strtod DD 021101H
	DD	0350111H
xdata	ENDS
;	COMDAT __real@8000000000000000
CONST	SEGMENT
__real@8000000000000000 DQ 08000000000000000r	; -0
CONST	ENDS
;	COMDAT __real@3fcfffff94a03595
CONST	SEGMENT
__real@3fcfffff94a03595 DQ 03fcfffff94a03595r	; 0.25
CONST	ENDS
;	COMDAT __real@3fe0000035afe535
CONST	SEGMENT
__real@3fe0000035afe535 DQ 03fe0000035afe535r	; 0.5
CONST	ENDS
;	COMDAT __real@3fdfffff94a03595
CONST	SEGMENT
__real@3fdfffff94a03595 DQ 03fdfffff94a03595r	; 0.5
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+009
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_dg_strtod
_TEXT	SEGMENT
bbe$ = 32
bb5$ = 36
adj$ = 40
bd0$ = 48
bc$ = 56
y$ = 72
rv0$ = 80
nd$ = 88
s0$ = 96
i$ = 104
bb2$ = 108
aadj1$ = 112
s$ = 120
odd$ = 128
esign$ = 132
lz$ = 136
error$ = 140
bb$ = 144
sign$ = 152
bd2$ = 156
nd0$ = 160
ndigits$ = 168
bd$ = 176
z$ = 184
rv$ = 192
aadj$ = 200
s1$ = 208
k$ = 216
bb1$ = 224
e1$ = 232
dsign$ = 236
fraclen$ = 240
delta$ = 248
c$ = 256
bd5$ = 260
abs_exp$ = 264
e$ = 268
bs$ = 272
L$ = 280
aadj2$ = 288
j$ = 296
bs2$ = 300
tv65 = 304
tv74 = 308
tv89 = 312
tv143 = 316
tv152 = 320
tv176 = 324
tv191 = 328
tv201 = 332
tv208 = 336
tv903 = 340
tv907 = 344
tv358 = 348
tv404 = 352
tv429 = 360
tv992 = 364
tv551 = 368
tv604 = 376
tv640 = 384
tv685 = 392
tv688 = 400
tv693 = 408
s00$ = 432
se$ = 440
_Py_dg_strtod PROC					; COMDAT

; 1548 : {

$LN208:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H

; 1549 :     int bb2, bb5, bbe, bd2, bd5, bs2, c, dsign, e, e1, error;
; 1550 :     int esign, i, j, k, lz, nd, nd0, odd, sign;
; 1551 :     const char *s, *s0, *s1;
; 1552 :     double aadj, aadj1;
; 1553 :     U aadj2, adj, rv, rv0;
; 1554 :     ULong y, z, abs_exp;
; 1555 :     Long L;
; 1556 :     BCinfo bc;
; 1557 :     Bigint *bb, *bb1, *bd, *bd0, *bs, *delta;
; 1558 :     size_t ndigits, fraclen;
; 1559 : 
; 1560 :     dval(&rv) = 0.;

  00011	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00015	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0

; 1561 : 
; 1562 :     /* Start parsing. */
; 1563 :     c = *(s = s00);

  0001e	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR s00$[rsp]
  00026	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
  0002b	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00030	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00033	89 84 24 00 01
	00 00		 mov	 DWORD PTR c$[rsp], eax

; 1564 : 
; 1565 :     /* Parse optional sign, if present. */
; 1566 :     sign = 0;

  0003a	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sign$[rsp], 0

; 1567 :     switch (c) {

  00045	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  0004c	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00053	83 bc 24 30 01
	00 00 2b	 cmp	 DWORD PTR tv65[rsp], 43	; 0000002bH
  0005b	74 17		 je	 SHORT $LN172@Py_dg_strt
  0005d	83 bc 24 30 01
	00 00 2d	 cmp	 DWORD PTR tv65[rsp], 45	; 0000002dH
  00065	74 02		 je	 SHORT $LN173@Py_dg_strt
  00067	eb 27		 jmp	 SHORT $LN174@Py_dg_strt
$LN173@Py_dg_strt:

; 1568 :     case '-':
; 1569 :         sign = 1;

  00069	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR sign$[rsp], 1
$LN172@Py_dg_strt:

; 1570 :         /* no break */
; 1571 :     case '+':
; 1572 :         c = *++s;

  00074	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00079	48 ff c0	 inc	 rax
  0007c	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
  00081	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00086	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00089	89 84 24 00 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
$LN174@Py_dg_strt:

; 1573 :     }
; 1574 : 
; 1575 :     /* Skip leading zeros: lz is true iff there were leading zeros. */
; 1576 :     s1 = s;

  00090	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00095	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR s1$[rsp], rax
$LN171@Py_dg_strt:

; 1577 :     while (c == '0')

  0009d	83 bc 24 00 01
	00 00 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  000a5	75 1e		 jne	 SHORT $LN170@Py_dg_strt

; 1578 :         c = *++s;

  000a7	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  000ac	48 ff c0	 inc	 rax
  000af	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
  000b4	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  000b9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000bc	89 84 24 00 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
  000c3	eb d8		 jmp	 SHORT $LN171@Py_dg_strt
$LN170@Py_dg_strt:

; 1579 :     lz = s != s1;

  000c5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s1$[rsp]
  000cd	48 39 44 24 78	 cmp	 QWORD PTR s$[rsp], rax
  000d2	74 0d		 je	 SHORT $LN178@Py_dg_strt
  000d4	c7 84 24 34 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv74[rsp], 1
  000df	eb 0b		 jmp	 SHORT $LN179@Py_dg_strt
$LN178@Py_dg_strt:
  000e1	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv74[rsp], 0
$LN179@Py_dg_strt:
  000ec	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR tv74[rsp]
  000f3	89 84 24 88 00
	00 00		 mov	 DWORD PTR lz$[rsp], eax

; 1580 : 
; 1581 :     /* Point s0 at the first nonzero digit (if any).  fraclen will be the
; 1582 :        number of digits between the decimal point and the end of the
; 1583 :        digit string.  ndigits will be the total number of digits ignoring
; 1584 :        leading zeros. */
; 1585 :     s0 = s1 = s;

  000fa	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  000ff	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR s1$[rsp], rax
  00107	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s1$[rsp]
  0010f	48 89 44 24 60	 mov	 QWORD PTR s0$[rsp], rax
$LN169@Py_dg_strt:

; 1586 :     while ('0' <= c && c <= '9')

  00114	83 bc 24 00 01
	00 00 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  0011c	7c 28		 jl	 SHORT $LN168@Py_dg_strt
  0011e	83 bc 24 00 01
	00 00 39	 cmp	 DWORD PTR c$[rsp], 57	; 00000039H
  00126	7f 1e		 jg	 SHORT $LN168@Py_dg_strt

; 1587 :         c = *++s;

  00128	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  0012d	48 ff c0	 inc	 rax
  00130	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
  00135	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  0013a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0013d	89 84 24 00 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
  00144	eb ce		 jmp	 SHORT $LN169@Py_dg_strt
$LN168@Py_dg_strt:

; 1588 :     ndigits = s - s1;

  00146	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s1$[rsp]
  0014e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  00153	48 2b c8	 sub	 rcx, rax
  00156	48 8b c1	 mov	 rax, rcx
  00159	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR ndigits$[rsp], rax

; 1589 :     fraclen = 0;

  00161	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR fraclen$[rsp], 0

; 1590 : 
; 1591 :     /* Parse decimal point and following digits. */
; 1592 :     if (c == '.') {

  0016d	83 bc 24 00 01
	00 00 2e	 cmp	 DWORD PTR c$[rsp], 46	; 0000002eH
  00175	0f 85 63 01 00
	00		 jne	 $LN167@Py_dg_strt

; 1593 :         c = *++s;

  0017b	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00180	48 ff c0	 inc	 rax
  00183	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
  00188	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  0018d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00190	89 84 24 00 01
	00 00		 mov	 DWORD PTR c$[rsp], eax

; 1594 :         if (!ndigits) {

  00197	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR ndigits$[rsp], 0
  001a0	0f 85 a7 00 00
	00		 jne	 $LN166@Py_dg_strt

; 1595 :             s1 = s;

  001a6	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  001ab	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR s1$[rsp], rax
$LN165@Py_dg_strt:

; 1596 :             while (c == '0')

  001b3	83 bc 24 00 01
	00 00 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  001bb	75 1e		 jne	 SHORT $LN164@Py_dg_strt

; 1597 :                 c = *++s;

  001bd	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  001c2	48 ff c0	 inc	 rax
  001c5	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
  001ca	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  001cf	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001d2	89 84 24 00 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
  001d9	eb d8		 jmp	 SHORT $LN165@Py_dg_strt
$LN164@Py_dg_strt:

; 1598 :             lz = lz || s != s1;

  001db	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR lz$[rsp], 0
  001e3	75 1c		 jne	 SHORT $LN180@Py_dg_strt
  001e5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s1$[rsp]
  001ed	48 39 44 24 78	 cmp	 QWORD PTR s$[rsp], rax
  001f2	75 0d		 jne	 SHORT $LN180@Py_dg_strt
  001f4	c7 84 24 38 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv89[rsp], 0
  001ff	eb 0b		 jmp	 SHORT $LN181@Py_dg_strt
$LN180@Py_dg_strt:
  00201	c7 84 24 38 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv89[rsp], 1
$LN181@Py_dg_strt:
  0020c	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR tv89[rsp]
  00213	89 84 24 88 00
	00 00		 mov	 DWORD PTR lz$[rsp], eax

; 1599 :             fraclen += (s - s1);

  0021a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s1$[rsp]
  00222	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  00227	48 2b c8	 sub	 rcx, rax
  0022a	48 8b c1	 mov	 rax, rcx
  0022d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR fraclen$[rsp]
  00235	48 03 c8	 add	 rcx, rax
  00238	48 8b c1	 mov	 rax, rcx
  0023b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR fraclen$[rsp], rax

; 1600 :             s0 = s;

  00243	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00248	48 89 44 24 60	 mov	 QWORD PTR s0$[rsp], rax
$LN166@Py_dg_strt:

; 1601 :         }
; 1602 :         s1 = s;

  0024d	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00252	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR s1$[rsp], rax
$LN163@Py_dg_strt:

; 1603 :         while ('0' <= c && c <= '9')

  0025a	83 bc 24 00 01
	00 00 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  00262	7c 28		 jl	 SHORT $LN162@Py_dg_strt
  00264	83 bc 24 00 01
	00 00 39	 cmp	 DWORD PTR c$[rsp], 57	; 00000039H
  0026c	7f 1e		 jg	 SHORT $LN162@Py_dg_strt

; 1604 :             c = *++s;

  0026e	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00273	48 ff c0	 inc	 rax
  00276	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
  0027b	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00280	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00283	89 84 24 00 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
  0028a	eb ce		 jmp	 SHORT $LN163@Py_dg_strt
$LN162@Py_dg_strt:

; 1605 :         ndigits += s - s1;

  0028c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s1$[rsp]
  00294	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  00299	48 2b c8	 sub	 rcx, rax
  0029c	48 8b c1	 mov	 rax, rcx
  0029f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ndigits$[rsp]
  002a7	48 03 c8	 add	 rcx, rax
  002aa	48 8b c1	 mov	 rax, rcx
  002ad	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR ndigits$[rsp], rax

; 1606 :         fraclen += s - s1;

  002b5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s1$[rsp]
  002bd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  002c2	48 2b c8	 sub	 rcx, rax
  002c5	48 8b c1	 mov	 rax, rcx
  002c8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR fraclen$[rsp]
  002d0	48 03 c8	 add	 rcx, rax
  002d3	48 8b c1	 mov	 rax, rcx
  002d6	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR fraclen$[rsp], rax
$LN167@Py_dg_strt:

; 1607 :     }
; 1608 : 
; 1609 :     /* Now lz is true if and only if there were leading zero digits, and
; 1610 :        ndigits gives the total number of digits ignoring leading zeros.  A
; 1611 :        valid input must have at least one digit. */
; 1612 :     if (!ndigits && !lz) {

  002de	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR ndigits$[rsp], 0
  002e7	75 2d		 jne	 SHORT $LN161@Py_dg_strt
  002e9	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR lz$[rsp], 0
  002f1	75 23		 jne	 SHORT $LN161@Py_dg_strt

; 1613 :         if (se)

  002f3	48 83 bc 24 b8
	01 00 00 00	 cmp	 QWORD PTR se$[rsp], 0
  002fc	74 13		 je	 SHORT $LN160@Py_dg_strt

; 1614 :             *se = (char *)s00;

  002fe	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR se$[rsp]
  00306	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR s00$[rsp]
  0030e	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN160@Py_dg_strt:

; 1615 :         goto parse_error;

  00311	e9 cb 19 00 00	 jmp	 $parse_error$20952
$LN161@Py_dg_strt:

; 1616 :     }
; 1617 : 
; 1618 :     /* Range check ndigits and fraclen to make sure that they, and values
; 1619 :        computed with them, can safely fit in an int. */
; 1620 :     if (ndigits > MAX_DIGITS || fraclen > MAX_DIGITS) {

  00316	48 81 bc 24 a8
	00 00 00 00 ca
	9a 3b		 cmp	 QWORD PTR ndigits$[rsp], 1000000000 ; 3b9aca00H
  00322	77 0e		 ja	 SHORT $LN158@Py_dg_strt
  00324	48 81 bc 24 f0
	00 00 00 00 ca
	9a 3b		 cmp	 QWORD PTR fraclen$[rsp], 1000000000 ; 3b9aca00H
  00330	76 23		 jbe	 SHORT $LN159@Py_dg_strt
$LN158@Py_dg_strt:

; 1621 :         if (se)

  00332	48 83 bc 24 b8
	01 00 00 00	 cmp	 QWORD PTR se$[rsp], 0
  0033b	74 13		 je	 SHORT $LN157@Py_dg_strt

; 1622 :             *se = (char *)s00;

  0033d	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR se$[rsp]
  00345	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR s00$[rsp]
  0034d	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN157@Py_dg_strt:

; 1623 :         goto parse_error;

  00350	e9 8c 19 00 00	 jmp	 $parse_error$20952
$LN159@Py_dg_strt:

; 1624 :     }
; 1625 :     nd = (int)ndigits;

  00355	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ndigits$[rsp]
  0035c	89 44 24 58	 mov	 DWORD PTR nd$[rsp], eax

; 1626 :     nd0 = (int)ndigits - (int)fraclen;

  00360	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR fraclen$[rsp]
  00367	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR ndigits$[rsp]
  0036e	2b c8		 sub	 ecx, eax
  00370	8b c1		 mov	 eax, ecx
  00372	89 84 24 a0 00
	00 00		 mov	 DWORD PTR nd0$[rsp], eax

; 1627 : 
; 1628 :     /* Parse exponent. */
; 1629 :     e = 0;

  00379	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR e$[rsp], 0

; 1630 :     if (c == 'e' || c == 'E') {

  00384	83 bc 24 00 01
	00 00 65	 cmp	 DWORD PTR c$[rsp], 101	; 00000065H
  0038c	74 0e		 je	 SHORT $LN155@Py_dg_strt
  0038e	83 bc 24 00 01
	00 00 45	 cmp	 DWORD PTR c$[rsp], 69	; 00000045H
  00396	0f 85 d0 01 00
	00		 jne	 $LN156@Py_dg_strt
$LN155@Py_dg_strt:

; 1631 :         s00 = s;

  0039c	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  003a1	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR s00$[rsp], rax

; 1632 :         c = *++s;

  003a9	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  003ae	48 ff c0	 inc	 rax
  003b1	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
  003b6	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  003bb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003be	89 84 24 00 01
	00 00		 mov	 DWORD PTR c$[rsp], eax

; 1633 : 
; 1634 :         /* Exponent sign. */
; 1635 :         esign = 0;

  003c5	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR esign$[rsp], 0

; 1636 :         switch (c) {

  003d0	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  003d7	89 84 24 3c 01
	00 00		 mov	 DWORD PTR tv143[rsp], eax
  003de	83 bc 24 3c 01
	00 00 2b	 cmp	 DWORD PTR tv143[rsp], 43 ; 0000002bH
  003e6	74 17		 je	 SHORT $LN151@Py_dg_strt
  003e8	83 bc 24 3c 01
	00 00 2d	 cmp	 DWORD PTR tv143[rsp], 45 ; 0000002dH
  003f0	74 02		 je	 SHORT $LN152@Py_dg_strt
  003f2	eb 27		 jmp	 SHORT $LN153@Py_dg_strt
$LN152@Py_dg_strt:

; 1637 :         case '-':
; 1638 :             esign = 1;

  003f4	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR esign$[rsp], 1
$LN151@Py_dg_strt:

; 1639 :             /* no break */
; 1640 :         case '+':
; 1641 :             c = *++s;

  003ff	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00404	48 ff c0	 inc	 rax
  00407	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
  0040c	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00411	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00414	89 84 24 00 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
$LN153@Py_dg_strt:

; 1642 :         }
; 1643 : 
; 1644 :         /* Skip zeros.  lz is true iff there are leading zeros. */
; 1645 :         s1 = s;

  0041b	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00420	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR s1$[rsp], rax
$LN150@Py_dg_strt:

; 1646 :         while (c == '0')

  00428	83 bc 24 00 01
	00 00 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  00430	75 1e		 jne	 SHORT $LN149@Py_dg_strt

; 1647 :             c = *++s;

  00432	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00437	48 ff c0	 inc	 rax
  0043a	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
  0043f	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  00444	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00447	89 84 24 00 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
  0044e	eb d8		 jmp	 SHORT $LN150@Py_dg_strt
$LN149@Py_dg_strt:

; 1648 :         lz = s != s1;

  00450	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s1$[rsp]
  00458	48 39 44 24 78	 cmp	 QWORD PTR s$[rsp], rax
  0045d	74 0d		 je	 SHORT $LN182@Py_dg_strt
  0045f	c7 84 24 40 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv152[rsp], 1
  0046a	eb 0b		 jmp	 SHORT $LN183@Py_dg_strt
$LN182@Py_dg_strt:
  0046c	c7 84 24 40 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv152[rsp], 0
$LN183@Py_dg_strt:
  00477	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR tv152[rsp]
  0047e	89 84 24 88 00
	00 00		 mov	 DWORD PTR lz$[rsp], eax

; 1649 : 
; 1650 :         /* Get absolute value of the exponent. */
; 1651 :         s1 = s;

  00485	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  0048a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR s1$[rsp], rax

; 1652 :         abs_exp = 0;

  00492	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR abs_exp$[rsp], 0
$LN148@Py_dg_strt:

; 1653 :         while ('0' <= c && c <= '9') {

  0049d	83 bc 24 00 01
	00 00 30	 cmp	 DWORD PTR c$[rsp], 48	; 00000030H
  004a5	7c 44		 jl	 SHORT $LN147@Py_dg_strt
  004a7	83 bc 24 00 01
	00 00 39	 cmp	 DWORD PTR c$[rsp], 57	; 00000039H
  004af	7f 3a		 jg	 SHORT $LN147@Py_dg_strt

; 1654 :             abs_exp = 10*abs_exp + (c - '0');

  004b1	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR abs_exp$[rsp]
  004b8	6b c0 0a	 imul	 eax, 10
  004bb	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  004c2	8d 44 08 d0	 lea	 eax, DWORD PTR [rax+rcx-48]
  004c6	89 84 24 08 01
	00 00		 mov	 DWORD PTR abs_exp$[rsp], eax

; 1655 :             c = *++s;

  004cd	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  004d2	48 ff c0	 inc	 rax
  004d5	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
  004da	48 8b 44 24 78	 mov	 rax, QWORD PTR s$[rsp]
  004df	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004e2	89 84 24 00 01
	00 00		 mov	 DWORD PTR c$[rsp], eax

; 1656 :         }

  004e9	eb b2		 jmp	 SHORT $LN148@Py_dg_strt
$LN147@Py_dg_strt:

; 1657 : 
; 1658 :         /* abs_exp will be correct modulo 2**32.  But 10**9 < 2**32, so if
; 1659 :            there are at most 9 significant exponent digits then overflow is
; 1660 :            impossible. */
; 1661 :         if (s - s1 > 9 || abs_exp > MAX_ABS_EXP)

  004eb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s1$[rsp]
  004f3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  004f8	48 2b c8	 sub	 rcx, rax
  004fb	48 8b c1	 mov	 rax, rcx
  004fe	48 83 f8 09	 cmp	 rax, 9
  00502	7f 0d		 jg	 SHORT $LN145@Py_dg_strt
  00504	81 bc 24 08 01
	00 00 00 ab 90
	41		 cmp	 DWORD PTR abs_exp$[rsp], 1100000000 ; 4190ab00H
  0050f	76 0d		 jbe	 SHORT $LN146@Py_dg_strt
$LN145@Py_dg_strt:

; 1662 :             e = (int)MAX_ABS_EXP;

  00511	c7 84 24 0c 01
	00 00 00 ab 90
	41		 mov	 DWORD PTR e$[rsp], 1100000000 ; 4190ab00H

; 1663 :         else

  0051c	eb 0e		 jmp	 SHORT $LN144@Py_dg_strt
$LN146@Py_dg_strt:

; 1664 :             e = (int)abs_exp;

  0051e	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR abs_exp$[rsp]
  00525	89 84 24 0c 01
	00 00		 mov	 DWORD PTR e$[rsp], eax
$LN144@Py_dg_strt:

; 1665 :         if (esign)

  0052c	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR esign$[rsp], 0
  00534	74 10		 je	 SHORT $LN143@Py_dg_strt

; 1666 :             e = -e;

  00536	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  0053d	f7 d8		 neg	 eax
  0053f	89 84 24 0c 01
	00 00		 mov	 DWORD PTR e$[rsp], eax
$LN143@Py_dg_strt:

; 1667 : 
; 1668 :         /* A valid exponent must have at least one digit. */
; 1669 :         if (s == s1 && !lz)

  00546	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR s1$[rsp]
  0054e	48 39 44 24 78	 cmp	 QWORD PTR s$[rsp], rax
  00553	75 17		 jne	 SHORT $LN142@Py_dg_strt
  00555	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR lz$[rsp], 0
  0055d	75 0d		 jne	 SHORT $LN142@Py_dg_strt

; 1670 :             s = s00;

  0055f	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR s00$[rsp]
  00567	48 89 44 24 78	 mov	 QWORD PTR s$[rsp], rax
$LN142@Py_dg_strt:
$LN156@Py_dg_strt:

; 1671 :     }
; 1672 : 
; 1673 :     /* Adjust exponent to take into account position of the point. */
; 1674 :     e -= nd - nd0;

  0056c	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR nd0$[rsp]
  00573	8b 4c 24 58	 mov	 ecx, DWORD PTR nd$[rsp]
  00577	2b c8		 sub	 ecx, eax
  00579	8b c1		 mov	 eax, ecx
  0057b	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  00582	2b c8		 sub	 ecx, eax
  00584	8b c1		 mov	 eax, ecx
  00586	89 84 24 0c 01
	00 00		 mov	 DWORD PTR e$[rsp], eax

; 1675 :     if (nd0 <= 0)

  0058d	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR nd0$[rsp], 0
  00595	7f 0b		 jg	 SHORT $LN141@Py_dg_strt

; 1676 :         nd0 = nd;

  00597	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  0059b	89 84 24 a0 00
	00 00		 mov	 DWORD PTR nd0$[rsp], eax
$LN141@Py_dg_strt:

; 1677 : 
; 1678 :     /* Finished parsing.  Set se to indicate how far we parsed */
; 1679 :     if (se)

  005a2	48 83 bc 24 b8
	01 00 00 00	 cmp	 QWORD PTR se$[rsp], 0
  005ab	74 10		 je	 SHORT $LN140@Py_dg_strt

; 1680 :         *se = (char *)s;

  005ad	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR se$[rsp]
  005b5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR s$[rsp]
  005ba	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN140@Py_dg_strt:

; 1681 : 
; 1682 :     /* If all digits were zero, exit with return value +-0.0.  Otherwise,
; 1683 :        strip trailing zeros: scan back until we hit a nonzero digit. */
; 1684 :     if (!nd)

  005bd	83 7c 24 58 00	 cmp	 DWORD PTR nd$[rsp], 0
  005c2	75 05		 jne	 SHORT $LN139@Py_dg_strt

; 1685 :         goto ret;

  005c4	e9 d2 16 00 00	 jmp	 $ret$20985
$LN139@Py_dg_strt:

; 1686 :     for (i = nd; i > 0; ) {

  005c9	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  005cd	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN138@Py_dg_strt:
  005d1	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  005d6	7e 55		 jle	 SHORT $LN137@Py_dg_strt

; 1687 :         --i;

  005d8	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  005dc	ff c8		 dec	 eax
  005de	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1688 :         if (s0[i < nd0 ? i : i+1] != '0') {

  005e2	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR nd0$[rsp]
  005e9	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  005ed	7d 0d		 jge	 SHORT $LN184@Py_dg_strt
  005ef	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  005f3	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  005fa	eb 0d		 jmp	 SHORT $LN185@Py_dg_strt
$LN184@Py_dg_strt:
  005fc	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00600	ff c0		 inc	 eax
  00602	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv176[rsp], eax
$LN185@Py_dg_strt:
  00609	48 63 84 24 44
	01 00 00	 movsxd	 rax, DWORD PTR tv176[rsp]
  00611	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s0$[rsp]
  00616	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0061a	83 f8 30	 cmp	 eax, 48			; 00000030H
  0061d	74 0c		 je	 SHORT $LN136@Py_dg_strt

; 1689 :             ++i;

  0061f	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00623	ff c0		 inc	 eax
  00625	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1690 :             break;

  00629	eb 02		 jmp	 SHORT $LN137@Py_dg_strt
$LN136@Py_dg_strt:

; 1691 :         }
; 1692 :     }

  0062b	eb a4		 jmp	 SHORT $LN138@Py_dg_strt
$LN137@Py_dg_strt:

; 1693 :     e += nd - i;

  0062d	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00631	8b 4c 24 58	 mov	 ecx, DWORD PTR nd$[rsp]
  00635	2b c8		 sub	 ecx, eax
  00637	8b c1		 mov	 eax, ecx
  00639	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  00640	03 c8		 add	 ecx, eax
  00642	8b c1		 mov	 eax, ecx
  00644	89 84 24 0c 01
	00 00		 mov	 DWORD PTR e$[rsp], eax

; 1694 :     nd = i;

  0064b	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0064f	89 44 24 58	 mov	 DWORD PTR nd$[rsp], eax

; 1695 :     if (nd0 > nd)

  00653	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  00657	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR nd0$[rsp], eax
  0065e	7e 0b		 jle	 SHORT $LN135@Py_dg_strt

; 1696 :         nd0 = nd;

  00660	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  00664	89 84 24 a0 00
	00 00		 mov	 DWORD PTR nd0$[rsp], eax
$LN135@Py_dg_strt:

; 1697 : 
; 1698 :     /* Summary of parsing results.  After parsing, and dealing with zero
; 1699 :      * inputs, we have values s0, nd0, nd, e, sign, where:
; 1700 :      *
; 1701 :      *  - s0 points to the first significant digit of the input string
; 1702 :      *
; 1703 :      *  - nd is the total number of significant digits (here, and
; 1704 :      *    below, 'significant digits' means the set of digits of the
; 1705 :      *    significand of the input that remain after ignoring leading
; 1706 :      *    and trailing zeros).
; 1707 :      *
; 1708 :      *  - nd0 indicates the position of the decimal point, if present; it
; 1709 :      *    satisfies 1 <= nd0 <= nd.  The nd significant digits are in
; 1710 :      *    s0[0:nd0] and s0[nd0+1:nd+1] using the usual Python half-open slice
; 1711 :      *    notation.  (If nd0 < nd, then s0[nd0] contains a '.'  character; if
; 1712 :      *    nd0 == nd, then s0[nd0] could be any non-digit character.)
; 1713 :      *
; 1714 :      *  - e is the adjusted exponent: the absolute value of the number
; 1715 :      *    represented by the original input string is n * 10**e, where
; 1716 :      *    n is the integer represented by the concatenation of
; 1717 :      *    s0[0:nd0] and s0[nd0+1:nd+1]
; 1718 :      *
; 1719 :      *  - sign gives the sign of the input:  1 for negative, 0 for positive
; 1720 :      *
; 1721 :      *  - the first and last significant digits are nonzero
; 1722 :      */
; 1723 : 
; 1724 :     /* put first DBL_DIG+1 digits into integer y and z.
; 1725 :      *
; 1726 :      *  - y contains the value represented by the first min(9, nd)
; 1727 :      *    significant digits
; 1728 :      *
; 1729 :      *  - if nd > 9, z contains the value represented by significant digits
; 1730 :      *    with indices in [9, min(16, nd)).  So y * 10**(min(16, nd) - 9) + z
; 1731 :      *    gives the value represented by the first min(16, nd) sig. digits.
; 1732 :      */
; 1733 : 
; 1734 :     bc.e0 = e1 = e;

  0066b	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  00672	89 84 24 e8 00
	00 00		 mov	 DWORD PTR e1$[rsp], eax
  00679	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  00680	89 44 24 38	 mov	 DWORD PTR bc$[rsp], eax

; 1735 :     y = z = 0;

  00684	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR z$[rsp], 0
  0068f	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR z$[rsp]
  00696	89 44 24 48	 mov	 DWORD PTR y$[rsp], eax

; 1736 :     for (i = 0; i < nd; i++) {

  0069a	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  006a2	eb 0a		 jmp	 SHORT $LN134@Py_dg_strt
$LN133@Py_dg_strt:
  006a4	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  006a8	ff c0		 inc	 eax
  006aa	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN134@Py_dg_strt:
  006ae	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  006b2	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  006b6	0f 8d ad 00 00
	00		 jge	 $LN132@Py_dg_strt

; 1737 :         if (i < 9)

  006bc	83 7c 24 68 09	 cmp	 DWORD PTR i$[rsp], 9
  006c1	7d 49		 jge	 SHORT $LN131@Py_dg_strt

; 1738 :             y = 10*y + s0[i < nd0 ? i : i+1] - '0';

  006c3	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR nd0$[rsp]
  006ca	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  006ce	7d 0d		 jge	 SHORT $LN186@Py_dg_strt
  006d0	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  006d4	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv191[rsp], eax
  006db	eb 0d		 jmp	 SHORT $LN187@Py_dg_strt
$LN186@Py_dg_strt:
  006dd	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  006e1	ff c0		 inc	 eax
  006e3	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv191[rsp], eax
$LN187@Py_dg_strt:
  006ea	8b 44 24 48	 mov	 eax, DWORD PTR y$[rsp]
  006ee	6b c0 0a	 imul	 eax, 10
  006f1	48 63 8c 24 48
	01 00 00	 movsxd	 rcx, DWORD PTR tv191[rsp]
  006f9	48 8b 54 24 60	 mov	 rdx, QWORD PTR s0$[rsp]
  006fe	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00702	8d 44 08 d0	 lea	 eax, DWORD PTR [rax+rcx-48]
  00706	89 44 24 48	 mov	 DWORD PTR y$[rsp], eax
  0070a	eb 58		 jmp	 SHORT $LN130@Py_dg_strt
$LN131@Py_dg_strt:

; 1739 :         else if (i < DBL_DIG+1)

  0070c	83 7c 24 68 10	 cmp	 DWORD PTR i$[rsp], 16
  00711	7d 4f		 jge	 SHORT $LN129@Py_dg_strt

; 1740 :             z = 10*z + s0[i < nd0 ? i : i+1] - '0';

  00713	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR nd0$[rsp]
  0071a	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  0071e	7d 0d		 jge	 SHORT $LN188@Py_dg_strt
  00720	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00724	89 84 24 4c 01
	00 00		 mov	 DWORD PTR tv201[rsp], eax
  0072b	eb 0d		 jmp	 SHORT $LN189@Py_dg_strt
$LN188@Py_dg_strt:
  0072d	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00731	ff c0		 inc	 eax
  00733	89 84 24 4c 01
	00 00		 mov	 DWORD PTR tv201[rsp], eax
$LN189@Py_dg_strt:
  0073a	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR z$[rsp]
  00741	6b c0 0a	 imul	 eax, 10
  00744	48 63 8c 24 4c
	01 00 00	 movsxd	 rcx, DWORD PTR tv201[rsp]
  0074c	48 8b 54 24 60	 mov	 rdx, QWORD PTR s0$[rsp]
  00751	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00755	8d 44 08 d0	 lea	 eax, DWORD PTR [rax+rcx-48]
  00759	89 84 24 b8 00
	00 00		 mov	 DWORD PTR z$[rsp], eax

; 1741 :         else

  00760	eb 02		 jmp	 SHORT $LN128@Py_dg_strt
$LN129@Py_dg_strt:

; 1742 :             break;

  00762	eb 05		 jmp	 SHORT $LN132@Py_dg_strt
$LN128@Py_dg_strt:
$LN130@Py_dg_strt:

; 1743 :     }

  00764	e9 3b ff ff ff	 jmp	 $LN133@Py_dg_strt
$LN132@Py_dg_strt:

; 1744 : 
; 1745 :     k = nd < DBL_DIG + 1 ? nd : DBL_DIG + 1;

  00769	83 7c 24 58 10	 cmp	 DWORD PTR nd$[rsp], 16
  0076e	7d 0d		 jge	 SHORT $LN190@Py_dg_strt
  00770	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  00774	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv208[rsp], eax
  0077b	eb 0b		 jmp	 SHORT $LN191@Py_dg_strt
$LN190@Py_dg_strt:
  0077d	c7 84 24 50 01
	00 00 10 00 00
	00		 mov	 DWORD PTR tv208[rsp], 16
$LN191@Py_dg_strt:
  00788	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR tv208[rsp]
  0078f	89 84 24 d8 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 1746 :     dval(&rv) = y;

  00796	8b 44 24 48	 mov	 eax, DWORD PTR y$[rsp]
  0079a	66 0f ef c0	 pxor	 xmm0, xmm0
  0079e	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  007a3	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0

; 1747 :     if (k > 9) {

  007ac	83 bc 24 d8 00
	00 00 09	 cmp	 DWORD PTR k$[rsp], 9
  007b4	7e 3e		 jle	 SHORT $LN127@Py_dg_strt

; 1748 :         dval(&rv) = tens[k - 9] * dval(&rv) + z;

  007b6	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  007bd	83 e8 09	 sub	 eax, 9
  007c0	48 98		 cdqe
  007c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  007c9	f2 0f 10 04 c1	 movsdx	 xmm0, QWORD PTR [rcx+rax*8]
  007ce	f2 0f 59 84 24
	c0 00 00 00	 mulsd	 xmm0, QWORD PTR rv$[rsp]
  007d7	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR z$[rsp]
  007de	66 0f ef c9	 pxor	 xmm1, xmm1
  007e2	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  007e7	f2 0f 58 c1	 addsd	 xmm0, xmm1
  007eb	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0
$LN127@Py_dg_strt:

; 1749 :     }
; 1750 :     bd0 = 0;

  007f4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR bd0$[rsp], 0

; 1751 :     if (nd <= DBL_DIG
; 1752 :         && Flt_Rounds == 1
; 1753 :         ) {

  007fd	83 7c 24 58 0f	 cmp	 DWORD PTR nd$[rsp], 15
  00802	0f 8f 18 01 00
	00		 jg	 $LN126@Py_dg_strt
  00808	33 c0		 xor	 eax, eax
  0080a	83 f8 01	 cmp	 eax, 1
  0080d	0f 84 0d 01 00
	00		 je	 $LN126@Py_dg_strt

; 1754 :         if (!e)

  00813	83 bc 24 0c 01
	00 00 00	 cmp	 DWORD PTR e$[rsp], 0
  0081b	75 05		 jne	 SHORT $LN125@Py_dg_strt

; 1755 :             goto ret;

  0081d	e9 79 14 00 00	 jmp	 $ret$20985
$LN125@Py_dg_strt:

; 1756 :         if (e > 0) {

  00822	83 bc 24 0c 01
	00 00 00	 cmp	 DWORD PTR e$[rsp], 0
  0082a	0f 8e b8 00 00
	00		 jle	 $LN124@Py_dg_strt

; 1757 :             if (e <= Ten_pmax) {

  00830	83 bc 24 0c 01
	00 00 16	 cmp	 DWORD PTR e$[rsp], 22
  00838	7f 2b		 jg	 SHORT $LN123@Py_dg_strt

; 1758 :                 dval(&rv) *= tens[e];

  0083a	48 63 84 24 0c
	01 00 00	 movsxd	 rax, DWORD PTR e$[rsp]
  00842	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  00849	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  00852	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  00857	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0

; 1759 :                 goto ret;

  00860	e9 36 14 00 00	 jmp	 $ret$20985
$LN123@Py_dg_strt:

; 1760 :             }
; 1761 :             i = DBL_DIG - nd;

  00865	b8 0f 00 00 00	 mov	 eax, 15
  0086a	2b 44 24 58	 sub	 eax, DWORD PTR nd$[rsp]
  0086e	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1762 :             if (e <= Ten_pmax + i) {

  00872	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00876	83 c0 16	 add	 eax, 22
  00879	39 84 24 0c 01
	00 00		 cmp	 DWORD PTR e$[rsp], eax
  00880	7f 64		 jg	 SHORT $LN122@Py_dg_strt

; 1763 :                 /* A fancier test would sometimes let us do
; 1764 :                  * this for larger i values.
; 1765 :                  */
; 1766 :                 e -= i;

  00882	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00886	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  0088d	2b c8		 sub	 ecx, eax
  0088f	8b c1		 mov	 eax, ecx
  00891	89 84 24 0c 01
	00 00		 mov	 DWORD PTR e$[rsp], eax

; 1767 :                 dval(&rv) *= tens[i];

  00898	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  0089d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  008a4	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  008ad	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  008b2	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0

; 1768 :                 dval(&rv) *= tens[e];

  008bb	48 63 84 24 0c
	01 00 00	 movsxd	 rax, DWORD PTR e$[rsp]
  008c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  008ca	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  008d3	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  008d8	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0

; 1769 :                 goto ret;

  008e1	e9 b5 13 00 00	 jmp	 $ret$20985
$LN122@Py_dg_strt:

; 1770 :             }

  008e6	eb 38		 jmp	 SHORT $LN121@Py_dg_strt
$LN124@Py_dg_strt:

; 1771 :         }
; 1772 :         else if (e >= -Ten_pmax) {

  008e8	83 bc 24 0c 01
	00 00 ea	 cmp	 DWORD PTR e$[rsp], -22
  008f0	7c 2e		 jl	 SHORT $LN120@Py_dg_strt

; 1773 :             dval(&rv) /= tens[-e];

  008f2	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  008f9	f7 d8		 neg	 eax
  008fb	48 98		 cdqe
  008fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  00904	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  0090d	f2 0f 5e 04 c1	 divsd	 xmm0, QWORD PTR [rcx+rax*8]
  00912	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0

; 1774 :             goto ret;

  0091b	e9 7b 13 00 00	 jmp	 $ret$20985
$LN120@Py_dg_strt:
$LN121@Py_dg_strt:
$LN126@Py_dg_strt:

; 1775 :         }
; 1776 :     }
; 1777 :     e1 += nd - k;

  00920	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00927	8b 4c 24 58	 mov	 ecx, DWORD PTR nd$[rsp]
  0092b	2b c8		 sub	 ecx, eax
  0092d	8b c1		 mov	 eax, ecx
  0092f	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR e1$[rsp]
  00936	03 c8		 add	 ecx, eax
  00938	8b c1		 mov	 eax, ecx
  0093a	89 84 24 e8 00
	00 00		 mov	 DWORD PTR e1$[rsp], eax

; 1778 : 
; 1779 :     bc.scale = 0;

  00941	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR bc$[rsp+12], 0

; 1780 : 
; 1781 :     /* Get starting approximation = rv * 10**e1 */
; 1782 : 
; 1783 :     if (e1 > 0) {

  00949	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR e1$[rsp], 0
  00951	0f 8e 82 01 00
	00		 jle	 $LN119@Py_dg_strt

; 1784 :         if ((i = e1 & 15))

  00957	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  0095e	83 e0 0f	 and	 eax, 15
  00961	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  00965	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  0096a	74 23		 je	 SHORT $LN118@Py_dg_strt

; 1785 :             dval(&rv) *= tens[i];

  0096c	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00971	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  00978	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  00981	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  00986	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0
$LN118@Py_dg_strt:

; 1786 :         if (e1 &= ~15) {

  0098f	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  00996	83 e0 f0	 and	 eax, -16
  00999	89 84 24 e8 00
	00 00		 mov	 DWORD PTR e1$[rsp], eax
  009a0	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR e1$[rsp], 0
  009a8	0f 84 26 01 00
	00		 je	 $LN117@Py_dg_strt

; 1787 :             if (e1 > DBL_MAX_10_EXP)

  009ae	81 bc 24 e8 00
	00 00 34 01 00
	00		 cmp	 DWORD PTR e1$[rsp], 308	; 00000134H
  009b9	7e 05		 jle	 SHORT $LN116@Py_dg_strt

; 1788 :                 goto ovfl;

  009bb	e9 78 13 00 00	 jmp	 $ovfl$21010
$LN116@Py_dg_strt:

; 1789 :             e1 >>= 4;

  009c0	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  009c7	c1 f8 04	 sar	 eax, 4
  009ca	89 84 24 e8 00
	00 00		 mov	 DWORD PTR e1$[rsp], eax

; 1790 :             for(j = 0; e1 > 1; j++, e1 >>= 1)

  009d1	c7 84 24 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  009dc	eb 20		 jmp	 SHORT $LN115@Py_dg_strt
$LN114@Py_dg_strt:
  009de	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  009e5	ff c0		 inc	 eax
  009e7	89 84 24 28 01
	00 00		 mov	 DWORD PTR j$[rsp], eax
  009ee	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  009f5	d1 f8		 sar	 eax, 1
  009f7	89 84 24 e8 00
	00 00		 mov	 DWORD PTR e1$[rsp], eax
$LN115@Py_dg_strt:
  009fe	83 bc 24 e8 00
	00 00 01	 cmp	 DWORD PTR e1$[rsp], 1
  00a06	7e 36		 jle	 SHORT $LN113@Py_dg_strt

; 1791 :                 if (e1 & 1)

  00a08	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  00a0f	83 e0 01	 and	 eax, 1
  00a12	85 c0		 test	 eax, eax
  00a14	74 26		 je	 SHORT $LN112@Py_dg_strt

; 1792 :                     dval(&rv) *= bigtens[j];

  00a16	48 63 84 24 28
	01 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00a1e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bigtens
  00a25	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  00a2e	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  00a33	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0
$LN112@Py_dg_strt:

; 1793 :             /* The last multiplication could overflow. */
; 1794 :             word0(&rv) -= P*Exp_msk1;

  00a3c	eb a0		 jmp	 SHORT $LN114@Py_dg_strt
$LN113@Py_dg_strt:
  00a3e	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  00a45	2d 00 00 50 03	 sub	 eax, 55574528		; 03500000H
  00a4a	89 84 24 c4 00
	00 00		 mov	 DWORD PTR rv$[rsp+4], eax

; 1795 :             dval(&rv) *= bigtens[j];

  00a51	48 63 84 24 28
	01 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00a59	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bigtens
  00a60	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  00a69	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  00a6e	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0

; 1796 :             if ((z = word0(&rv) & Exp_mask)
; 1797 :                 > Exp_msk1*(DBL_MAX_EXP+Bias-P))

  00a77	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  00a7e	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00a83	89 84 24 b8 00
	00 00		 mov	 DWORD PTR z$[rsp], eax
  00a8a	81 bc 24 b8 00
	00 00 00 00 a0
	7c		 cmp	 DWORD PTR z$[rsp], 2090860544 ; 7ca00000H
  00a95	76 05		 jbe	 SHORT $LN111@Py_dg_strt

; 1798 :                 goto ovfl;

  00a97	e9 9c 12 00 00	 jmp	 $ovfl$21010
$LN111@Py_dg_strt:

; 1799 :             if (z > Exp_msk1*(DBL_MAX_EXP+Bias-1-P)) {

  00a9c	81 bc 24 b8 00
	00 00 00 00 90
	7c		 cmp	 DWORD PTR z$[rsp], 2089811968 ; 7c900000H
  00aa7	76 18		 jbe	 SHORT $LN110@Py_dg_strt

; 1800 :                 /* set to largest number */
; 1801 :                 /* (Can't trust DBL_MAX) */
; 1802 :                 word0(&rv) = Big0;

  00aa9	c7 84 24 c4 00
	00 00 ff ff ef
	7f		 mov	 DWORD PTR rv$[rsp+4], 2146435071 ; 7fefffffH

; 1803 :                 word1(&rv) = Big1;

  00ab4	c7 84 24 c0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rv$[rsp], -1	; ffffffffH

; 1804 :             }
; 1805 :             else

  00abf	eb 13		 jmp	 SHORT $LN109@Py_dg_strt
$LN110@Py_dg_strt:

; 1806 :                 word0(&rv) += P*Exp_msk1;

  00ac1	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  00ac8	05 00 00 50 03	 add	 eax, 55574528		; 03500000H
  00acd	89 84 24 c4 00
	00 00		 mov	 DWORD PTR rv$[rsp+4], eax
$LN109@Py_dg_strt:
$LN117@Py_dg_strt:

; 1807 :         }

  00ad4	e9 ec 01 00 00	 jmp	 $LN108@Py_dg_strt
$LN119@Py_dg_strt:

; 1808 :     }
; 1809 :     else if (e1 < 0) {

  00ad9	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR e1$[rsp], 0
  00ae1	0f 8d de 01 00
	00		 jge	 $LN107@Py_dg_strt

; 1810 :         /* The input decimal value lies in [10**e1, 10**(e1+16)).
; 1811 : 
; 1812 :            If e1 <= -512, underflow immediately.
; 1813 :            If e1 <= -256, set bc.scale to 2*P.
; 1814 : 
; 1815 :            So for input value < 1e-256, bc.scale is always set;
; 1816 :            for input value >= 1e-240, bc.scale is never set.
; 1817 :            For input values in [1e-256, 1e-240), bc.scale may or may
; 1818 :            not be set. */
; 1819 : 
; 1820 :         e1 = -e1;

  00ae7	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  00aee	f7 d8		 neg	 eax
  00af0	89 84 24 e8 00
	00 00		 mov	 DWORD PTR e1$[rsp], eax

; 1821 :         if ((i = e1 & 15))

  00af7	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  00afe	83 e0 0f	 and	 eax, 15
  00b01	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  00b05	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  00b0a	74 23		 je	 SHORT $LN106@Py_dg_strt

; 1822 :             dval(&rv) /= tens[i];

  00b0c	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00b11	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  00b18	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  00b21	f2 0f 5e 04 c1	 divsd	 xmm0, QWORD PTR [rcx+rax*8]
  00b26	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0
$LN106@Py_dg_strt:

; 1823 :         if (e1 >>= 4) {

  00b2f	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  00b36	c1 f8 04	 sar	 eax, 4
  00b39	89 84 24 e8 00
	00 00		 mov	 DWORD PTR e1$[rsp], eax
  00b40	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR e1$[rsp], 0
  00b48	0f 84 77 01 00
	00		 je	 $LN105@Py_dg_strt

; 1824 :             if (e1 >= 1 << n_bigtens)

  00b4e	83 bc 24 e8 00
	00 00 20	 cmp	 DWORD PTR e1$[rsp], 32	; 00000020H
  00b56	7c 05		 jl	 SHORT $LN104@Py_dg_strt

; 1825 :                 goto undfl;

  00b58	e9 a6 11 00 00	 jmp	 $undfl$21023
$LN104@Py_dg_strt:

; 1826 :             if (e1 & Scale_Bit)

  00b5d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  00b64	83 e0 10	 and	 eax, 16
  00b67	85 c0		 test	 eax, eax
  00b69	74 08		 je	 SHORT $LN103@Py_dg_strt

; 1827 :                 bc.scale = 2*P;

  00b6b	c7 44 24 44 6a
	00 00 00	 mov	 DWORD PTR bc$[rsp+12], 106 ; 0000006aH
$LN103@Py_dg_strt:

; 1828 :             for(j = 0; e1 > 0; j++, e1 >>= 1)

  00b73	c7 84 24 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  00b7e	eb 20		 jmp	 SHORT $LN102@Py_dg_strt
$LN101@Py_dg_strt:
  00b80	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00b87	ff c0		 inc	 eax
  00b89	89 84 24 28 01
	00 00		 mov	 DWORD PTR j$[rsp], eax
  00b90	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  00b97	d1 f8		 sar	 eax, 1
  00b99	89 84 24 e8 00
	00 00		 mov	 DWORD PTR e1$[rsp], eax
$LN102@Py_dg_strt:
  00ba0	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR e1$[rsp], 0
  00ba8	7e 36		 jle	 SHORT $LN100@Py_dg_strt

; 1829 :                 if (e1 & 1)

  00baa	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR e1$[rsp]
  00bb1	83 e0 01	 and	 eax, 1
  00bb4	85 c0		 test	 eax, eax
  00bb6	74 26		 je	 SHORT $LN99@Py_dg_strt

; 1830 :                     dval(&rv) *= tinytens[j];

  00bb8	48 63 84 24 28
	01 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00bc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tinytens
  00bc7	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  00bd0	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  00bd5	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0
$LN99@Py_dg_strt:

; 1831 :             if (bc.scale && (j = 2*P + 1 - ((word0(&rv) & Exp_mask)

  00bde	eb a0		 jmp	 SHORT $LN101@Py_dg_strt
$LN100@Py_dg_strt:

; 1832 :                                             >> Exp_shift)) > 0) {

  00be0	83 7c 24 44 00	 cmp	 DWORD PTR bc$[rsp+12], 0
  00be5	0f 84 c0 00 00
	00		 je	 $LN98@Py_dg_strt
  00beb	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  00bf2	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00bf7	c1 e8 14	 shr	 eax, 20
  00bfa	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  00bff	2b c8		 sub	 ecx, eax
  00c01	8b c1		 mov	 eax, ecx
  00c03	89 84 24 28 01
	00 00		 mov	 DWORD PTR j$[rsp], eax
  00c0a	83 bc 24 28 01
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  00c12	0f 8e 93 00 00
	00		 jle	 $LN98@Py_dg_strt

; 1833 :                 /* scaled rv is denormal; clear j low bits */
; 1834 :                 if (j >= 32) {

  00c18	83 bc 24 28 01
	00 00 20	 cmp	 DWORD PTR j$[rsp], 32	; 00000020H
  00c20	7c 58		 jl	 SHORT $LN97@Py_dg_strt

; 1835 :                     word1(&rv) = 0;

  00c22	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rv$[rsp], 0

; 1836 :                     if (j >= 53)

  00c2d	83 bc 24 28 01
	00 00 35	 cmp	 DWORD PTR j$[rsp], 53	; 00000035H
  00c35	7c 0d		 jl	 SHORT $LN96@Py_dg_strt

; 1837 :                         word0(&rv) = (P+2)*Exp_msk1;

  00c37	c7 84 24 c4 00
	00 00 00 00 70
	03		 mov	 DWORD PTR rv$[rsp+4], 57671680 ; 03700000H

; 1838 :                     else

  00c42	eb 34		 jmp	 SHORT $LN95@Py_dg_strt
$LN96@Py_dg_strt:

; 1839 :                         word0(&rv) &= 0xffffffff << (j-32);

  00c44	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00c4b	83 e8 20	 sub	 eax, 32			; 00000020H
  00c4e	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00c53	89 8c 24 54 01
	00 00		 mov	 DWORD PTR tv903[rsp], ecx
  00c5a	0f b6 c8	 movzx	 ecx, al
  00c5d	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR tv903[rsp]
  00c64	d3 e0		 shl	 eax, cl
  00c66	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR rv$[rsp+4]
  00c6d	23 c8		 and	 ecx, eax
  00c6f	8b c1		 mov	 eax, ecx
  00c71	89 84 24 c4 00
	00 00		 mov	 DWORD PTR rv$[rsp+4], eax
$LN95@Py_dg_strt:

; 1840 :                 }
; 1841 :                 else

  00c78	eb 31		 jmp	 SHORT $LN94@Py_dg_strt
$LN97@Py_dg_strt:

; 1842 :                     word1(&rv) &= 0xffffffff << j;

  00c7a	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00c81	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00c86	89 8c 24 58 01
	00 00		 mov	 DWORD PTR tv907[rsp], ecx
  00c8d	0f b6 c8	 movzx	 ecx, al
  00c90	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR tv907[rsp]
  00c97	d3 e0		 shl	 eax, cl
  00c99	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR rv$[rsp]
  00ca0	23 c8		 and	 ecx, eax
  00ca2	8b c1		 mov	 eax, ecx
  00ca4	89 84 24 c0 00
	00 00		 mov	 DWORD PTR rv$[rsp], eax
$LN94@Py_dg_strt:
$LN98@Py_dg_strt:

; 1843 :             }
; 1844 :             if (!dval(&rv))

  00cab	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  00cb4	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00cbc	7a 07		 jp	 SHORT $LN93@Py_dg_strt
  00cbe	75 05		 jne	 SHORT $LN93@Py_dg_strt

; 1845 :                 goto undfl;

  00cc0	e9 3e 10 00 00	 jmp	 $undfl$21023
$LN93@Py_dg_strt:
$LN105@Py_dg_strt:
$LN107@Py_dg_strt:
$LN108@Py_dg_strt:

; 1846 :         }
; 1847 :     }
; 1848 : 
; 1849 :     /* Now the hard part -- adjusting rv to the correct value.*/
; 1850 : 
; 1851 :     /* Put digits into bd: true value = bd * 10^e */
; 1852 : 
; 1853 :     bc.nd = nd;

  00cc5	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  00cc9	89 44 24 3c	 mov	 DWORD PTR bc$[rsp+4], eax

; 1854 :     bc.nd0 = nd0;       /* Only needed if nd > STRTOD_DIGLIM, but done here */

  00ccd	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR nd0$[rsp]
  00cd4	89 44 24 40	 mov	 DWORD PTR bc$[rsp+8], eax

; 1855 :                         /* to silence an erroneous warning about bc.nd0 */
; 1856 :                         /* possibly not being initialized. */
; 1857 :     if (nd > STRTOD_DIGLIM) {

  00cd8	83 7c 24 58 28	 cmp	 DWORD PTR nd$[rsp], 40	; 00000028H
  00cdd	0f 8e 2e 01 00
	00		 jle	 $LN92@Py_dg_strt

; 1858 :         /* ASSERT(STRTOD_DIGLIM >= 18); 18 == one more than the */
; 1859 :         /* minimum number of decimal digits to distinguish double values */
; 1860 :         /* in IEEE arithmetic. */
; 1861 : 
; 1862 :         /* Truncate input to 18 significant digits, then discard any trailing
; 1863 :            zeros on the result by updating nd, nd0, e and y suitably. (There's
; 1864 :            no need to update z; it's not reused beyond this point.) */
; 1865 :         for (i = 18; i > 0; ) {

  00ce3	c7 44 24 68 12
	00 00 00	 mov	 DWORD PTR i$[rsp], 18
$LN91@Py_dg_strt:
  00ceb	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  00cf0	7e 55		 jle	 SHORT $LN90@Py_dg_strt

; 1866 :             /* scan back until we hit a nonzero digit.  significant digit 'i'
; 1867 :             is s0[i] if i < nd0, s0[i+1] if i >= nd0. */
; 1868 :             --i;

  00cf2	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00cf6	ff c8		 dec	 eax
  00cf8	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1869 :             if (s0[i < nd0 ? i : i+1] != '0') {

  00cfc	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR nd0$[rsp]
  00d03	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  00d07	7d 0d		 jge	 SHORT $LN192@Py_dg_strt
  00d09	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00d0d	89 84 24 5c 01
	00 00		 mov	 DWORD PTR tv358[rsp], eax
  00d14	eb 0d		 jmp	 SHORT $LN193@Py_dg_strt
$LN192@Py_dg_strt:
  00d16	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00d1a	ff c0		 inc	 eax
  00d1c	89 84 24 5c 01
	00 00		 mov	 DWORD PTR tv358[rsp], eax
$LN193@Py_dg_strt:
  00d23	48 63 84 24 5c
	01 00 00	 movsxd	 rax, DWORD PTR tv358[rsp]
  00d2b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s0$[rsp]
  00d30	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00d34	83 f8 30	 cmp	 eax, 48			; 00000030H
  00d37	74 0c		 je	 SHORT $LN89@Py_dg_strt

; 1870 :                 ++i;

  00d39	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00d3d	ff c0		 inc	 eax
  00d3f	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1871 :                 break;

  00d43	eb 02		 jmp	 SHORT $LN90@Py_dg_strt
$LN89@Py_dg_strt:

; 1872 :             }
; 1873 :         }

  00d45	eb a4		 jmp	 SHORT $LN91@Py_dg_strt
$LN90@Py_dg_strt:

; 1874 :         e += nd - i;

  00d47	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00d4b	8b 4c 24 58	 mov	 ecx, DWORD PTR nd$[rsp]
  00d4f	2b c8		 sub	 ecx, eax
  00d51	8b c1		 mov	 eax, ecx
  00d53	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  00d5a	03 c8		 add	 ecx, eax
  00d5c	8b c1		 mov	 eax, ecx
  00d5e	89 84 24 0c 01
	00 00		 mov	 DWORD PTR e$[rsp], eax

; 1875 :         nd = i;

  00d65	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00d69	89 44 24 58	 mov	 DWORD PTR nd$[rsp], eax

; 1876 :         if (nd0 > nd)

  00d6d	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  00d71	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR nd0$[rsp], eax
  00d78	7e 0b		 jle	 SHORT $LN88@Py_dg_strt

; 1877 :             nd0 = nd;

  00d7a	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  00d7e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR nd0$[rsp], eax
$LN88@Py_dg_strt:

; 1878 :         if (nd < 9) { /* must recompute y */

  00d85	83 7c 24 58 09	 cmp	 DWORD PTR nd$[rsp], 9
  00d8a	0f 8d 81 00 00
	00		 jge	 $LN87@Py_dg_strt

; 1879 :             y = 0;

  00d90	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR y$[rsp], 0

; 1880 :             for(i = 0; i < nd0; ++i)

  00d98	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00da0	eb 0a		 jmp	 SHORT $LN86@Py_dg_strt
$LN85@Py_dg_strt:
  00da2	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00da6	ff c0		 inc	 eax
  00da8	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN86@Py_dg_strt:
  00dac	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR nd0$[rsp]
  00db3	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  00db7	7d 1f		 jge	 SHORT $LN84@Py_dg_strt

; 1881 :                 y = 10*y + s0[i] - '0';

  00db9	8b 44 24 48	 mov	 eax, DWORD PTR y$[rsp]
  00dbd	6b c0 0a	 imul	 eax, 10
  00dc0	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR i$[rsp]
  00dc5	48 8b 54 24 60	 mov	 rdx, QWORD PTR s0$[rsp]
  00dca	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00dce	8d 44 08 d0	 lea	 eax, DWORD PTR [rax+rcx-48]
  00dd2	89 44 24 48	 mov	 DWORD PTR y$[rsp], eax
  00dd6	eb ca		 jmp	 SHORT $LN85@Py_dg_strt
$LN84@Py_dg_strt:

; 1882 :             for(; i < nd; ++i)

  00dd8	eb 0a		 jmp	 SHORT $LN83@Py_dg_strt
$LN82@Py_dg_strt:
  00dda	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00dde	ff c0		 inc	 eax
  00de0	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN83@Py_dg_strt:
  00de4	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  00de8	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  00dec	7d 23		 jge	 SHORT $LN81@Py_dg_strt

; 1883 :                 y = 10*y + s0[i+1] - '0';

  00dee	8b 44 24 48	 mov	 eax, DWORD PTR y$[rsp]
  00df2	6b c0 0a	 imul	 eax, 10
  00df5	8b 4c 24 68	 mov	 ecx, DWORD PTR i$[rsp]
  00df9	ff c1		 inc	 ecx
  00dfb	48 63 c9	 movsxd	 rcx, ecx
  00dfe	48 8b 54 24 60	 mov	 rdx, QWORD PTR s0$[rsp]
  00e03	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00e07	8d 44 08 d0	 lea	 eax, DWORD PTR [rax+rcx-48]
  00e0b	89 44 24 48	 mov	 DWORD PTR y$[rsp], eax
  00e0f	eb c9		 jmp	 SHORT $LN82@Py_dg_strt
$LN81@Py_dg_strt:
$LN87@Py_dg_strt:
$LN92@Py_dg_strt:

; 1884 :         }
; 1885 :     }
; 1886 :     bd0 = s2b(s0, nd0, nd, y);

  00e11	44 8b 4c 24 48	 mov	 r9d, DWORD PTR y$[rsp]
  00e16	44 8b 44 24 58	 mov	 r8d, DWORD PTR nd$[rsp]
  00e1b	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR nd0$[rsp]
  00e22	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s0$[rsp]
  00e27	e8 00 00 00 00	 call	 s2b
  00e2c	48 89 44 24 30	 mov	 QWORD PTR bd0$[rsp], rax

; 1887 :     if (bd0 == NULL)

  00e31	48 83 7c 24 30
	00		 cmp	 QWORD PTR bd0$[rsp], 0
  00e37	75 05		 jne	 SHORT $LN80@Py_dg_strt

; 1888 :         goto failed_malloc;

  00e39	e9 ac 0e 00 00	 jmp	 $failed_malloc$21050
$LN80@Py_dg_strt:
$LN79@Py_dg_strt:

; 1889 : 
; 1890 :     /* Notation for the comments below.  Write:
; 1891 : 
; 1892 :          - dv for the absolute value of the number represented by the original
; 1893 :            decimal input string.
; 1894 : 
; 1895 :          - if we've truncated dv, write tdv for the truncated value.
; 1896 :            Otherwise, set tdv == dv.
; 1897 : 
; 1898 :          - srv for the quantity rv/2^bc.scale; so srv is the current binary
; 1899 :            approximation to tdv (and dv).  It should be exactly representable
; 1900 :            in an IEEE 754 double.
; 1901 :     */
; 1902 : 
; 1903 :     for(;;) {
; 1904 : 
; 1905 :         /* This is the main correction loop for _Py_dg_strtod.
; 1906 : 
; 1907 :            We've got a decimal value tdv, and a floating-point approximation
; 1908 :            srv=rv/2^bc.scale to tdv.  The aim is to determine whether srv is
; 1909 :            close enough (i.e., within 0.5 ulps) to tdv, and to compute a new
; 1910 :            approximation if not.
; 1911 : 
; 1912 :            To determine whether srv is close enough to tdv, compute integers
; 1913 :            bd, bb and bs proportional to tdv, srv and 0.5 ulp(srv)
; 1914 :            respectively, and then use integer arithmetic to determine whether
; 1915 :            |tdv - srv| is less than, equal to, or greater than 0.5 ulp(srv).
; 1916 :         */
; 1917 : 
; 1918 :         bd = Balloc(bd0->k);

  00e3e	48 8b 44 24 30	 mov	 rax, QWORD PTR bd0$[rsp]
  00e43	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00e46	e8 00 00 00 00	 call	 Balloc
  00e4b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR bd$[rsp], rax

; 1919 :         if (bd == NULL) {

  00e53	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR bd$[rsp], 0
  00e5c	75 0f		 jne	 SHORT $LN77@Py_dg_strt

; 1920 :             Bfree(bd0);

  00e5e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  00e63	e8 00 00 00 00	 call	 Bfree

; 1921 :             goto failed_malloc;

  00e68	e9 7d 0e 00 00	 jmp	 $failed_malloc$21050
$LN77@Py_dg_strt:

; 1922 :         }
; 1923 :         Bcopy(bd, bd0);

  00e6d	48 8b 44 24 30	 mov	 rax, QWORD PTR bd0$[rsp]
  00e72	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  00e76	48 8d 04 85 08
	00 00 00	 lea	 rax, QWORD PTR [rax*4+8]
  00e7e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  00e83	48 83 c1 10	 add	 rcx, 16
  00e87	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR bd$[rsp]
  00e8f	48 83 c2 10	 add	 rdx, 16
  00e93	48 89 94 24 60
	01 00 00	 mov	 QWORD PTR tv404[rsp], rdx
  00e9b	4c 8b c0	 mov	 r8, rax
  00e9e	48 8b d1	 mov	 rdx, rcx
  00ea1	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR tv404[rsp]
  00ea9	48 8b c8	 mov	 rcx, rax
  00eac	e8 00 00 00 00	 call	 memcpy

; 1924 :         bb = sd2b(&rv, bc.scale, &bbe);   /* srv = bb * 2^bbe */

  00eb1	4c 8d 44 24 20	 lea	 r8, QWORD PTR bbe$[rsp]
  00eb6	8b 54 24 44	 mov	 edx, DWORD PTR bc$[rsp+12]
  00eba	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  00ec2	e8 00 00 00 00	 call	 sd2b
  00ec7	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR bb$[rsp], rax

; 1925 :         if (bb == NULL) {

  00ecf	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR bb$[rsp], 0
  00ed8	75 1c		 jne	 SHORT $LN76@Py_dg_strt

; 1926 :             Bfree(bd);

  00eda	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  00ee2	e8 00 00 00 00	 call	 Bfree

; 1927 :             Bfree(bd0);

  00ee7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  00eec	e8 00 00 00 00	 call	 Bfree

; 1928 :             goto failed_malloc;

  00ef1	e9 f4 0d 00 00	 jmp	 $failed_malloc$21050
$LN76@Py_dg_strt:

; 1929 :         }
; 1930 :         /* Record whether lsb of bb is odd, in case we need this
; 1931 :            for the round-to-even step later. */
; 1932 :         odd = bb->x[0] & 1;

  00ef6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR bb$[rsp]
  00efe	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00f01	83 e0 01	 and	 eax, 1
  00f04	89 84 24 80 00
	00 00		 mov	 DWORD PTR odd$[rsp], eax

; 1933 : 
; 1934 :         /* tdv = bd * 10**e;  srv = bb * 2**bbe */
; 1935 :         bs = i2b(1);

  00f0b	b9 01 00 00 00	 mov	 ecx, 1
  00f10	e8 00 00 00 00	 call	 i2b
  00f15	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR bs$[rsp], rax

; 1936 :         if (bs == NULL) {

  00f1d	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR bs$[rsp], 0
  00f26	75 29		 jne	 SHORT $LN75@Py_dg_strt

; 1937 :             Bfree(bb);

  00f28	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  00f30	e8 00 00 00 00	 call	 Bfree

; 1938 :             Bfree(bd);

  00f35	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  00f3d	e8 00 00 00 00	 call	 Bfree

; 1939 :             Bfree(bd0);

  00f42	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  00f47	e8 00 00 00 00	 call	 Bfree

; 1940 :             goto failed_malloc;

  00f4c	e9 99 0d 00 00	 jmp	 $failed_malloc$21050
$LN75@Py_dg_strt:

; 1941 :         }
; 1942 : 
; 1943 :         if (e >= 0) {

  00f51	83 bc 24 0c 01
	00 00 00	 cmp	 DWORD PTR e$[rsp], 0
  00f59	7c 2e		 jl	 SHORT $LN74@Py_dg_strt

; 1944 :             bb2 = bb5 = 0;

  00f5b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR bb5$[rsp], 0
  00f63	8b 44 24 24	 mov	 eax, DWORD PTR bb5$[rsp]
  00f67	89 44 24 6c	 mov	 DWORD PTR bb2$[rsp], eax

; 1945 :             bd2 = bd5 = e;

  00f6b	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  00f72	89 84 24 04 01
	00 00		 mov	 DWORD PTR bd5$[rsp], eax
  00f79	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR bd5$[rsp]
  00f80	89 84 24 9c 00
	00 00		 mov	 DWORD PTR bd2$[rsp], eax

; 1946 :         }
; 1947 :         else {

  00f87	eb 2e		 jmp	 SHORT $LN73@Py_dg_strt
$LN74@Py_dg_strt:

; 1948 :             bb2 = bb5 = -e;

  00f89	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  00f90	f7 d8		 neg	 eax
  00f92	89 44 24 24	 mov	 DWORD PTR bb5$[rsp], eax
  00f96	8b 44 24 24	 mov	 eax, DWORD PTR bb5$[rsp]
  00f9a	89 44 24 6c	 mov	 DWORD PTR bb2$[rsp], eax

; 1949 :             bd2 = bd5 = 0;

  00f9e	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR bd5$[rsp], 0
  00fa9	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR bd5$[rsp]
  00fb0	89 84 24 9c 00
	00 00		 mov	 DWORD PTR bd2$[rsp], eax
$LN73@Py_dg_strt:

; 1950 :         }
; 1951 :         if (bbe >= 0)

  00fb7	83 7c 24 20 00	 cmp	 DWORD PTR bbe$[rsp], 0
  00fbc	7c 12		 jl	 SHORT $LN72@Py_dg_strt

; 1952 :             bb2 += bbe;

  00fbe	8b 44 24 20	 mov	 eax, DWORD PTR bbe$[rsp]
  00fc2	8b 4c 24 6c	 mov	 ecx, DWORD PTR bb2$[rsp]
  00fc6	03 c8		 add	 ecx, eax
  00fc8	8b c1		 mov	 eax, ecx
  00fca	89 44 24 6c	 mov	 DWORD PTR bb2$[rsp], eax

; 1953 :         else

  00fce	eb 16		 jmp	 SHORT $LN71@Py_dg_strt
$LN72@Py_dg_strt:

; 1954 :             bd2 -= bbe;

  00fd0	8b 44 24 20	 mov	 eax, DWORD PTR bbe$[rsp]
  00fd4	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR bd2$[rsp]
  00fdb	2b c8		 sub	 ecx, eax
  00fdd	8b c1		 mov	 eax, ecx
  00fdf	89 84 24 9c 00
	00 00		 mov	 DWORD PTR bd2$[rsp], eax
$LN71@Py_dg_strt:

; 1955 :         bs2 = bb2;

  00fe6	8b 44 24 6c	 mov	 eax, DWORD PTR bb2$[rsp]
  00fea	89 84 24 2c 01
	00 00		 mov	 DWORD PTR bs2$[rsp], eax

; 1956 :         bb2++;

  00ff1	8b 44 24 6c	 mov	 eax, DWORD PTR bb2$[rsp]
  00ff5	ff c0		 inc	 eax
  00ff7	89 44 24 6c	 mov	 DWORD PTR bb2$[rsp], eax

; 1957 :         bd2++;

  00ffb	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR bd2$[rsp]
  01002	ff c0		 inc	 eax
  01004	89 84 24 9c 00
	00 00		 mov	 DWORD PTR bd2$[rsp], eax

; 1958 : 
; 1959 :         /* At this stage bd5 - bb5 == e == bd2 - bb2 + bbe, bb2 - bs2 == 1,
; 1960 :            and bs == 1, so:
; 1961 : 
; 1962 :               tdv == bd * 10**e = bd * 2**(bbe - bb2 + bd2) * 5**(bd5 - bb5)
; 1963 :               srv == bb * 2**bbe = bb * 2**(bbe - bb2 + bb2)
; 1964 :               0.5 ulp(srv) == 2**(bbe-1) = bs * 2**(bbe - bb2 + bs2)
; 1965 : 
; 1966 :            It follows that:
; 1967 : 
; 1968 :               M * tdv = bd * 2**bd2 * 5**bd5
; 1969 :               M * srv = bb * 2**bb2 * 5**bb5
; 1970 :               M * 0.5 ulp(srv) = bs * 2**bs2 * 5**bb5
; 1971 : 
; 1972 :            for some constant M.  (Actually, M == 2**(bb2 - bbe) * 5**bb5, but
; 1973 :            this fact is not needed below.)
; 1974 :         */
; 1975 : 
; 1976 :         /* Remove factor of 2**i, where i = min(bb2, bd2, bs2). */
; 1977 :         i = bb2 < bd2 ? bb2 : bd2;

  0100b	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR bd2$[rsp]
  01012	39 44 24 6c	 cmp	 DWORD PTR bb2$[rsp], eax
  01016	7d 0d		 jge	 SHORT $LN194@Py_dg_strt
  01018	8b 44 24 6c	 mov	 eax, DWORD PTR bb2$[rsp]
  0101c	89 84 24 68 01
	00 00		 mov	 DWORD PTR tv429[rsp], eax
  01023	eb 0e		 jmp	 SHORT $LN195@Py_dg_strt
$LN194@Py_dg_strt:
  01025	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR bd2$[rsp]
  0102c	89 84 24 68 01
	00 00		 mov	 DWORD PTR tv429[rsp], eax
$LN195@Py_dg_strt:
  01033	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR tv429[rsp]
  0103a	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1978 :         if (i > bs2)

  0103e	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR bs2$[rsp]
  01045	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  01049	7e 0b		 jle	 SHORT $LN70@Py_dg_strt

; 1979 :             i = bs2;

  0104b	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR bs2$[rsp]
  01052	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN70@Py_dg_strt:

; 1980 :         if (i > 0) {

  01056	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  0105b	7e 3c		 jle	 SHORT $LN69@Py_dg_strt

; 1981 :             bb2 -= i;

  0105d	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  01061	8b 4c 24 6c	 mov	 ecx, DWORD PTR bb2$[rsp]
  01065	2b c8		 sub	 ecx, eax
  01067	8b c1		 mov	 eax, ecx
  01069	89 44 24 6c	 mov	 DWORD PTR bb2$[rsp], eax

; 1982 :             bd2 -= i;

  0106d	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  01071	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR bd2$[rsp]
  01078	2b c8		 sub	 ecx, eax
  0107a	8b c1		 mov	 eax, ecx
  0107c	89 84 24 9c 00
	00 00		 mov	 DWORD PTR bd2$[rsp], eax

; 1983 :             bs2 -= i;

  01083	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  01087	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR bs2$[rsp]
  0108e	2b c8		 sub	 ecx, eax
  01090	8b c1		 mov	 eax, ecx
  01092	89 84 24 2c 01
	00 00		 mov	 DWORD PTR bs2$[rsp], eax
$LN69@Py_dg_strt:

; 1984 :         }
; 1985 : 
; 1986 :         /* Scale bb, bd, bs by the appropriate powers of 2 and 5. */
; 1987 :         if (bb5 > 0) {

  01099	83 7c 24 24 00	 cmp	 DWORD PTR bb5$[rsp], 0
  0109e	0f 8e bb 00 00
	00		 jle	 $LN68@Py_dg_strt

; 1988 :             bs = pow5mult(bs, bb5);

  010a4	8b 54 24 24	 mov	 edx, DWORD PTR bb5$[rsp]
  010a8	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  010b0	e8 00 00 00 00	 call	 pow5mult
  010b5	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR bs$[rsp], rax

; 1989 :             if (bs == NULL) {

  010bd	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR bs$[rsp], 0
  010c6	75 29		 jne	 SHORT $LN67@Py_dg_strt

; 1990 :                 Bfree(bb);

  010c8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  010d0	e8 00 00 00 00	 call	 Bfree

; 1991 :                 Bfree(bd);

  010d5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  010dd	e8 00 00 00 00	 call	 Bfree

; 1992 :                 Bfree(bd0);

  010e2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  010e7	e8 00 00 00 00	 call	 Bfree

; 1993 :                 goto failed_malloc;

  010ec	e9 f9 0b 00 00	 jmp	 $failed_malloc$21050
$LN67@Py_dg_strt:

; 1994 :             }
; 1995 :             bb1 = mult(bs, bb);

  010f1	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR bb$[rsp]
  010f9	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  01101	e8 00 00 00 00	 call	 mult
  01106	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR bb1$[rsp], rax

; 1996 :             Bfree(bb);

  0110e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  01116	e8 00 00 00 00	 call	 Bfree

; 1997 :             bb = bb1;

  0111b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR bb1$[rsp]
  01123	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR bb$[rsp], rax

; 1998 :             if (bb == NULL) {

  0112b	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR bb$[rsp], 0
  01134	75 29		 jne	 SHORT $LN66@Py_dg_strt

; 1999 :                 Bfree(bs);

  01136	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  0113e	e8 00 00 00 00	 call	 Bfree

; 2000 :                 Bfree(bd);

  01143	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  0114b	e8 00 00 00 00	 call	 Bfree

; 2001 :                 Bfree(bd0);

  01150	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  01155	e8 00 00 00 00	 call	 Bfree

; 2002 :                 goto failed_malloc;

  0115a	e9 8b 0b 00 00	 jmp	 $failed_malloc$21050
$LN66@Py_dg_strt:
$LN68@Py_dg_strt:

; 2003 :             }
; 2004 :         }
; 2005 :         if (bb2 > 0) {

  0115f	83 7c 24 6c 00	 cmp	 DWORD PTR bb2$[rsp], 0
  01164	7e 4d		 jle	 SHORT $LN65@Py_dg_strt

; 2006 :             bb = lshift(bb, bb2);

  01166	8b 54 24 6c	 mov	 edx, DWORD PTR bb2$[rsp]
  0116a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  01172	e8 00 00 00 00	 call	 lshift
  01177	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR bb$[rsp], rax

; 2007 :             if (bb == NULL) {

  0117f	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR bb$[rsp], 0
  01188	75 29		 jne	 SHORT $LN64@Py_dg_strt

; 2008 :                 Bfree(bs);

  0118a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  01192	e8 00 00 00 00	 call	 Bfree

; 2009 :                 Bfree(bd);

  01197	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  0119f	e8 00 00 00 00	 call	 Bfree

; 2010 :                 Bfree(bd0);

  011a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  011a9	e8 00 00 00 00	 call	 Bfree

; 2011 :                 goto failed_malloc;

  011ae	e9 37 0b 00 00	 jmp	 $failed_malloc$21050
$LN64@Py_dg_strt:
$LN65@Py_dg_strt:

; 2012 :             }
; 2013 :         }
; 2014 :         if (bd5 > 0) {

  011b3	83 bc 24 04 01
	00 00 00	 cmp	 DWORD PTR bd5$[rsp], 0
  011bb	7e 50		 jle	 SHORT $LN63@Py_dg_strt

; 2015 :             bd = pow5mult(bd, bd5);

  011bd	8b 94 24 04 01
	00 00		 mov	 edx, DWORD PTR bd5$[rsp]
  011c4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  011cc	e8 00 00 00 00	 call	 pow5mult
  011d1	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR bd$[rsp], rax

; 2016 :             if (bd == NULL) {

  011d9	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR bd$[rsp], 0
  011e2	75 29		 jne	 SHORT $LN62@Py_dg_strt

; 2017 :                 Bfree(bb);

  011e4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  011ec	e8 00 00 00 00	 call	 Bfree

; 2018 :                 Bfree(bs);

  011f1	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  011f9	e8 00 00 00 00	 call	 Bfree

; 2019 :                 Bfree(bd0);

  011fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  01203	e8 00 00 00 00	 call	 Bfree

; 2020 :                 goto failed_malloc;

  01208	e9 dd 0a 00 00	 jmp	 $failed_malloc$21050
$LN62@Py_dg_strt:
$LN63@Py_dg_strt:

; 2021 :             }
; 2022 :         }
; 2023 :         if (bd2 > 0) {

  0120d	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR bd2$[rsp], 0
  01215	7e 50		 jle	 SHORT $LN61@Py_dg_strt

; 2024 :             bd = lshift(bd, bd2);

  01217	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR bd2$[rsp]
  0121e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  01226	e8 00 00 00 00	 call	 lshift
  0122b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR bd$[rsp], rax

; 2025 :             if (bd == NULL) {

  01233	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR bd$[rsp], 0
  0123c	75 29		 jne	 SHORT $LN60@Py_dg_strt

; 2026 :                 Bfree(bb);

  0123e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  01246	e8 00 00 00 00	 call	 Bfree

; 2027 :                 Bfree(bs);

  0124b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  01253	e8 00 00 00 00	 call	 Bfree

; 2028 :                 Bfree(bd0);

  01258	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  0125d	e8 00 00 00 00	 call	 Bfree

; 2029 :                 goto failed_malloc;

  01262	e9 83 0a 00 00	 jmp	 $failed_malloc$21050
$LN60@Py_dg_strt:
$LN61@Py_dg_strt:

; 2030 :             }
; 2031 :         }
; 2032 :         if (bs2 > 0) {

  01267	83 bc 24 2c 01
	00 00 00	 cmp	 DWORD PTR bs2$[rsp], 0
  0126f	7e 50		 jle	 SHORT $LN59@Py_dg_strt

; 2033 :             bs = lshift(bs, bs2);

  01271	8b 94 24 2c 01
	00 00		 mov	 edx, DWORD PTR bs2$[rsp]
  01278	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  01280	e8 00 00 00 00	 call	 lshift
  01285	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR bs$[rsp], rax

; 2034 :             if (bs == NULL) {

  0128d	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR bs$[rsp], 0
  01296	75 29		 jne	 SHORT $LN58@Py_dg_strt

; 2035 :                 Bfree(bb);

  01298	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  012a0	e8 00 00 00 00	 call	 Bfree

; 2036 :                 Bfree(bd);

  012a5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  012ad	e8 00 00 00 00	 call	 Bfree

; 2037 :                 Bfree(bd0);

  012b2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  012b7	e8 00 00 00 00	 call	 Bfree

; 2038 :                 goto failed_malloc;

  012bc	e9 29 0a 00 00	 jmp	 $failed_malloc$21050
$LN58@Py_dg_strt:
$LN59@Py_dg_strt:

; 2039 :             }
; 2040 :         }
; 2041 : 
; 2042 :         /* Now bd, bb and bs are scaled versions of tdv, srv and 0.5 ulp(srv),
; 2043 :            respectively.  Compute the difference |tdv - srv|, and compare
; 2044 :            with 0.5 ulp(srv). */
; 2045 : 
; 2046 :         delta = diff(bb, bd);

  012c1	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR bd$[rsp]
  012c9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  012d1	e8 00 00 00 00	 call	 diff
  012d6	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR delta$[rsp], rax

; 2047 :         if (delta == NULL) {

  012de	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR delta$[rsp], 0
  012e7	75 36		 jne	 SHORT $LN57@Py_dg_strt

; 2048 :             Bfree(bb);

  012e9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  012f1	e8 00 00 00 00	 call	 Bfree

; 2049 :             Bfree(bs);

  012f6	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  012fe	e8 00 00 00 00	 call	 Bfree

; 2050 :             Bfree(bd);

  01303	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  0130b	e8 00 00 00 00	 call	 Bfree

; 2051 :             Bfree(bd0);

  01310	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  01315	e8 00 00 00 00	 call	 Bfree

; 2052 :             goto failed_malloc;

  0131a	e9 cb 09 00 00	 jmp	 $failed_malloc$21050
$LN57@Py_dg_strt:

; 2053 :         }
; 2054 :         dsign = delta->sign;

  0131f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR delta$[rsp]
  01327	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0132a	89 84 24 ec 00
	00 00		 mov	 DWORD PTR dsign$[rsp], eax

; 2055 :         delta->sign = 0;

  01331	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR delta$[rsp]
  01339	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 2056 :         i = cmp(delta, bs);

  01340	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR bs$[rsp]
  01348	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR delta$[rsp]
  01350	e8 00 00 00 00	 call	 cmp
  01355	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 2057 :         if (bc.nd > nd && i <= 0) {

  01359	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  0135d	39 44 24 3c	 cmp	 DWORD PTR bc$[rsp+4], eax
  01361	0f 8e af 00 00
	00		 jle	 $LN56@Py_dg_strt
  01367	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  0136c	0f 8f a4 00 00
	00		 jg	 $LN56@Py_dg_strt

; 2058 :             if (dsign)

  01372	83 bc 24 ec 00
	00 00 00	 cmp	 DWORD PTR dsign$[rsp], 0
  0137a	74 05		 je	 SHORT $LN55@Py_dg_strt

; 2059 :                 break;  /* Must use bigcomp(). */

  0137c	e9 79 08 00 00	 jmp	 $LN78@Py_dg_strt
$LN55@Py_dg_strt:

; 2060 : 
; 2061 :             /* Here rv overestimates the truncated decimal value by at most
; 2062 :                0.5 ulp(rv).  Hence rv either overestimates the true decimal
; 2063 :                value by <= 0.5 ulp(rv), or underestimates it by some small
; 2064 :                amount (< 0.1 ulp(rv)); either way, rv is within 0.5 ulps of
; 2065 :                the true decimal value, so it's possible to exit.
; 2066 : 
; 2067 :                Exception: if scaled rv is a normal exact power of 2, but not
; 2068 :                DBL_MIN, then rv - 0.5 ulp(rv) takes us all the way down to the
; 2069 :                next double, so the correctly rounded result is either rv - 0.5
; 2070 :                ulp(rv) or rv; in this case, use bigcomp to distinguish. */
; 2071 : 
; 2072 :             if (!word1(&rv) && !(word0(&rv) & Bndry_mask)) {

  01381	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR rv$[rsp], 0
  01389	75 7b		 jne	 SHORT $LN54@Py_dg_strt
  0138b	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  01392	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  01397	85 c0		 test	 eax, eax
  01399	75 6b		 jne	 SHORT $LN54@Py_dg_strt

; 2073 :                 /* rv can't be 0, since it's an overestimate for some
; 2074 :                    nonzero value.  So rv is a normal power of 2. */
; 2075 :                 j = (int)(word0(&rv) & Exp_mask) >> Exp_shift;

  0139b	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  013a2	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  013a7	c1 f8 14	 sar	 eax, 20
  013aa	89 84 24 28 01
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 2076 :                 /* rv / 2^bc.scale = 2^(j - 1023 - bc.scale); use bigcomp if
; 2077 :                    rv / 2^bc.scale >= 2^-1021. */
; 2078 :                 if (j - bc.scale >= 2) {

  013b1	8b 44 24 44	 mov	 eax, DWORD PTR bc$[rsp+12]
  013b5	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR j$[rsp]
  013bc	2b c8		 sub	 ecx, eax
  013be	8b c1		 mov	 eax, ecx
  013c0	83 f8 02	 cmp	 eax, 2
  013c3	7c 41		 jl	 SHORT $LN53@Py_dg_strt

; 2079 :                     dval(&rv) -= 0.5 * sulp(&rv, &bc);

  013c5	48 8d 54 24 38	 lea	 rdx, QWORD PTR bc$[rsp]
  013ca	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  013d2	e8 00 00 00 00	 call	 sulp
  013d7	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@3fe0000000000000
  013df	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  013e3	66 0f 28 c1	 movapd	 xmm0, xmm1
  013e7	f2 0f 10 8c 24
	c0 00 00 00	 movsdx	 xmm1, QWORD PTR rv$[rsp]
  013f0	f2 0f 5c c8	 subsd	 xmm1, xmm0
  013f4	66 0f 28 c1	 movapd	 xmm0, xmm1
  013f8	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0

; 2080 :                     break; /* Use bigcomp. */

  01401	e9 f4 07 00 00	 jmp	 $LN78@Py_dg_strt
$LN53@Py_dg_strt:
$LN54@Py_dg_strt:

; 2081 :                 }
; 2082 :             }
; 2083 : 
; 2084 :             {
; 2085 :                 bc.nd = nd;

  01406	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  0140a	89 44 24 3c	 mov	 DWORD PTR bc$[rsp+4], eax

; 2086 :                 i = -1; /* Discarded digits make delta smaller. */

  0140e	c7 44 24 68 ff
	ff ff ff	 mov	 DWORD PTR i$[rsp], -1
$LN56@Py_dg_strt:

; 2087 :             }
; 2088 :         }
; 2089 : 
; 2090 :         if (i < 0) {

  01416	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  0141b	0f 8d db 00 00
	00		 jge	 $LN52@Py_dg_strt

; 2091 :             /* Error is less than half an ulp -- check for
; 2092 :              * special case of mantissa a power of two.
; 2093 :              */
; 2094 :             if (dsign || word1(&rv) || word0(&rv) & Bndry_mask
; 2095 :                 || (word0(&rv) & Exp_mask) <= (2*P+1)*Exp_msk1
; 2096 :                 ) {

  01421	83 bc 24 ec 00
	00 00 00	 cmp	 DWORD PTR dsign$[rsp], 0
  01429	75 2d		 jne	 SHORT $LN50@Py_dg_strt
  0142b	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR rv$[rsp], 0
  01433	75 23		 jne	 SHORT $LN50@Py_dg_strt
  01435	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  0143c	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  01441	85 c0		 test	 eax, eax
  01443	75 13		 jne	 SHORT $LN50@Py_dg_strt
  01445	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  0144c	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  01451	3d 00 00 b0 06	 cmp	 eax, 112197632		; 06b00000H
  01456	77 05		 ja	 SHORT $LN51@Py_dg_strt
$LN50@Py_dg_strt:

; 2097 :                 break;

  01458	e9 9d 07 00 00	 jmp	 $LN78@Py_dg_strt
$LN51@Py_dg_strt:

; 2098 :             }
; 2099 :             if (!delta->x[0] && delta->wds <= 1) {

  0145d	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR delta$[rsp]
  01465	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  01469	75 13		 jne	 SHORT $LN49@Py_dg_strt
  0146b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR delta$[rsp]
  01473	83 78 14 01	 cmp	 DWORD PTR [rax+20], 1
  01477	7f 05		 jg	 SHORT $LN49@Py_dg_strt

; 2100 :                 /* exact result */
; 2101 :                 break;

  01479	e9 7c 07 00 00	 jmp	 $LN78@Py_dg_strt
$LN49@Py_dg_strt:

; 2102 :             }
; 2103 :             delta = lshift(delta,Log2P);

  0147e	ba 01 00 00 00	 mov	 edx, 1
  01483	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR delta$[rsp]
  0148b	e8 00 00 00 00	 call	 lshift
  01490	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR delta$[rsp], rax

; 2104 :             if (delta == NULL) {

  01498	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR delta$[rsp], 0
  014a1	75 36		 jne	 SHORT $LN48@Py_dg_strt

; 2105 :                 Bfree(bb);

  014a3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  014ab	e8 00 00 00 00	 call	 Bfree

; 2106 :                 Bfree(bs);

  014b0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  014b8	e8 00 00 00 00	 call	 Bfree

; 2107 :                 Bfree(bd);

  014bd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  014c5	e8 00 00 00 00	 call	 Bfree

; 2108 :                 Bfree(bd0);

  014ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  014cf	e8 00 00 00 00	 call	 Bfree

; 2109 :                 goto failed_malloc;

  014d4	e9 11 08 00 00	 jmp	 $failed_malloc$21050
$LN48@Py_dg_strt:

; 2110 :             }
; 2111 :             if (cmp(delta, bs) > 0)

  014d9	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR bs$[rsp]
  014e1	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR delta$[rsp]
  014e9	e8 00 00 00 00	 call	 cmp
  014ee	85 c0		 test	 eax, eax
  014f0	7e 05		 jle	 SHORT $LN47@Py_dg_strt

; 2112 :                 goto drop_down;

  014f2	e9 f1 00 00 00	 jmp	 $drop_down$21101
$LN47@Py_dg_strt:

; 2113 :             break;

  014f7	e9 fe 06 00 00	 jmp	 $LN78@Py_dg_strt
$LN52@Py_dg_strt:

; 2114 :         }
; 2115 :         if (i == 0) {

  014fc	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  01501	0f 85 0a 02 00
	00		 jne	 $LN46@Py_dg_strt

; 2116 :             /* exactly half-way between */
; 2117 :             if (dsign) {

  01507	83 bc 24 ec 00
	00 00 00	 cmp	 DWORD PTR dsign$[rsp], 0
  0150f	0f 84 b1 00 00
	00		 je	 $LN45@Py_dg_strt

; 2118 :                 if ((word0(&rv) & Bndry_mask1) == Bndry_mask1
; 2119 :                     &&  word1(&rv) == (
; 2120 :                         (bc.scale &&
; 2121 :                          (y = word0(&rv) & Exp_mask) <= 2*P*Exp_msk1) ?
; 2122 :                         (0xffffffff & (0xffffffff << (2*P+1-(y>>Exp_shift)))) :
; 2123 :                         0xffffffff)) {

  01515	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  0151c	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  01521	3d ff ff 0f 00	 cmp	 eax, 1048575		; 000fffffH
  01526	0f 85 95 00 00
	00		 jne	 $LN44@Py_dg_strt
  0152c	83 7c 24 44 00	 cmp	 DWORD PTR bc$[rsp+12], 0
  01531	74 4b		 je	 SHORT $LN196@Py_dg_strt
  01533	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  0153a	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  0153f	89 44 24 48	 mov	 DWORD PTR y$[rsp], eax
  01543	81 7c 24 48 00
	00 a0 06	 cmp	 DWORD PTR y$[rsp], 111149056 ; 06a00000H
  0154b	77 31		 ja	 SHORT $LN196@Py_dg_strt
  0154d	8b 44 24 48	 mov	 eax, DWORD PTR y$[rsp]
  01551	c1 e8 14	 shr	 eax, 20
  01554	b9 6b 00 00 00	 mov	 ecx, 107		; 0000006bH
  01559	2b c8		 sub	 ecx, eax
  0155b	8b c1		 mov	 eax, ecx
  0155d	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  01562	89 8c 24 6c 01
	00 00		 mov	 DWORD PTR tv992[rsp], ecx
  01569	0f b6 c8	 movzx	 ecx, al
  0156c	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR tv992[rsp]
  01573	d3 e0		 shl	 eax, cl
  01575	89 84 24 70 01
	00 00		 mov	 DWORD PTR tv551[rsp], eax
  0157c	eb 0b		 jmp	 SHORT $LN197@Py_dg_strt
$LN196@Py_dg_strt:
  0157e	c7 84 24 70 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv551[rsp], -1 ; ffffffffH
$LN197@Py_dg_strt:
  01589	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR tv551[rsp]
  01590	39 84 24 c0 00
	00 00		 cmp	 DWORD PTR rv$[rsp], eax
  01597	75 28		 jne	 SHORT $LN44@Py_dg_strt

; 2124 :                     /*boundary case -- increment exponent*/
; 2125 :                     word0(&rv) = (word0(&rv) & Exp_mask)
; 2126 :                         + Exp_msk1
; 2127 :                         ;

  01599	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  015a0	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  015a5	05 00 00 10 00	 add	 eax, 1048576		; 00100000H
  015aa	89 84 24 c4 00
	00 00		 mov	 DWORD PTR rv$[rsp+4], eax

; 2128 :                     word1(&rv) = 0;

  015b1	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rv$[rsp], 0

; 2129 :                     /* dsign = 0; */
; 2130 :                     break;

  015bc	e9 39 06 00 00	 jmp	 $LN78@Py_dg_strt
$LN44@Py_dg_strt:

; 2131 :                 }

  015c1	e9 aa 00 00 00	 jmp	 $LN43@Py_dg_strt
$LN45@Py_dg_strt:

; 2132 :             }
; 2133 :             else if (!(word0(&rv) & Bndry_mask) && !word1(&rv)) {

  015c6	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  015cd	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  015d2	85 c0		 test	 eax, eax
  015d4	0f 85 96 00 00
	00		 jne	 $LN42@Py_dg_strt
  015da	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR rv$[rsp], 0
  015e2	0f 85 88 00 00
	00		 jne	 $LN42@Py_dg_strt
$drop_down$21101:

; 2134 :               drop_down:
; 2135 :                 /* boundary case -- decrement exponent */
; 2136 :                 if (bc.scale) {

  015e8	83 7c 24 44 00	 cmp	 DWORD PTR bc$[rsp+12], 0
  015ed	74 46		 je	 SHORT $LN41@Py_dg_strt

; 2137 :                     L = word0(&rv) & Exp_mask;

  015ef	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  015f6	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  015fb	89 84 24 18 01
	00 00		 mov	 DWORD PTR L$[rsp], eax

; 2138 :                     if (L <= (2*P+1)*Exp_msk1) {

  01602	81 bc 24 18 01
	00 00 00 00 b0
	06		 cmp	 DWORD PTR L$[rsp], 112197632 ; 06b00000H
  0160d	7f 26		 jg	 SHORT $LN40@Py_dg_strt

; 2139 :                         if (L > (P+2)*Exp_msk1)

  0160f	81 bc 24 18 01
	00 00 00 00 70
	03		 cmp	 DWORD PTR L$[rsp], 57671680 ; 03700000H
  0161a	7e 05		 jle	 SHORT $LN39@Py_dg_strt

; 2140 :                             /* round even ==> */
; 2141 :                             /* accept rv */
; 2142 :                             break;

  0161c	e9 d9 05 00 00	 jmp	 $LN78@Py_dg_strt
$LN39@Py_dg_strt:

; 2143 :                         /* rv = smallest denormal */
; 2144 :                         if (bc.nd > nd)

  01621	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  01625	39 44 24 3c	 cmp	 DWORD PTR bc$[rsp+4], eax
  01629	7e 05		 jle	 SHORT $LN38@Py_dg_strt

; 2145 :                             break;

  0162b	e9 ca 05 00 00	 jmp	 $LN78@Py_dg_strt
$LN38@Py_dg_strt:

; 2146 :                         goto undfl;

  01630	e9 ce 06 00 00	 jmp	 $undfl$21023
$LN40@Py_dg_strt:
$LN41@Py_dg_strt:

; 2147 :                     }
; 2148 :                 }
; 2149 :                 L = (word0(&rv) & Exp_mask) - Exp_msk1;

  01635	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  0163c	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  01641	2d 00 00 10 00	 sub	 eax, 1048576		; 00100000H
  01646	89 84 24 18 01
	00 00		 mov	 DWORD PTR L$[rsp], eax

; 2150 :                 word0(&rv) = L | Bndry_mask1;

  0164d	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR L$[rsp]
  01654	0d ff ff 0f 00	 or	 eax, 1048575		; 000fffffH
  01659	89 84 24 c4 00
	00 00		 mov	 DWORD PTR rv$[rsp+4], eax

; 2151 :                 word1(&rv) = 0xffffffff;

  01660	c7 84 24 c0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rv$[rsp], -1	; ffffffffH

; 2152 :                 break;

  0166b	e9 8a 05 00 00	 jmp	 $LN78@Py_dg_strt
$LN42@Py_dg_strt:
$LN43@Py_dg_strt:

; 2153 :             }
; 2154 :             if (!odd)

  01670	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR odd$[rsp], 0
  01678	75 05		 jne	 SHORT $LN37@Py_dg_strt

; 2155 :                 break;

  0167a	e9 7b 05 00 00	 jmp	 $LN78@Py_dg_strt
$LN37@Py_dg_strt:

; 2156 :             if (dsign)

  0167f	83 bc 24 ec 00
	00 00 00	 cmp	 DWORD PTR dsign$[rsp], 0
  01687	74 2e		 je	 SHORT $LN36@Py_dg_strt

; 2157 :                 dval(&rv) += sulp(&rv, &bc);

  01689	48 8d 54 24 38	 lea	 rdx, QWORD PTR bc$[rsp]
  0168e	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  01696	e8 00 00 00 00	 call	 sulp
  0169b	f2 0f 10 8c 24
	c0 00 00 00	 movsdx	 xmm1, QWORD PTR rv$[rsp]
  016a4	f2 0f 58 c8	 addsd	 xmm1, xmm0
  016a8	66 0f 28 c1	 movapd	 xmm0, xmm1
  016ac	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0

; 2158 :             else {

  016b5	eb 55		 jmp	 SHORT $LN35@Py_dg_strt
$LN36@Py_dg_strt:

; 2159 :                 dval(&rv) -= sulp(&rv, &bc);

  016b7	48 8d 54 24 38	 lea	 rdx, QWORD PTR bc$[rsp]
  016bc	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  016c4	e8 00 00 00 00	 call	 sulp
  016c9	f2 0f 10 8c 24
	c0 00 00 00	 movsdx	 xmm1, QWORD PTR rv$[rsp]
  016d2	f2 0f 5c c8	 subsd	 xmm1, xmm0
  016d6	66 0f 28 c1	 movapd	 xmm0, xmm1
  016da	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0

; 2160 :                 if (!dval(&rv)) {

  016e3	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  016ec	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  016f4	7a 16		 jp	 SHORT $LN34@Py_dg_strt
  016f6	75 14		 jne	 SHORT $LN34@Py_dg_strt

; 2161 :                     if (bc.nd >nd)

  016f8	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  016fc	39 44 24 3c	 cmp	 DWORD PTR bc$[rsp+4], eax
  01700	7e 05		 jle	 SHORT $LN33@Py_dg_strt

; 2162 :                         break;

  01702	e9 f3 04 00 00	 jmp	 $LN78@Py_dg_strt
$LN33@Py_dg_strt:

; 2163 :                     goto undfl;

  01707	e9 f7 05 00 00	 jmp	 $undfl$21023
$LN34@Py_dg_strt:
$LN35@Py_dg_strt:

; 2164 :                 }
; 2165 :             }
; 2166 :             /* dsign = 1 - dsign; */
; 2167 :             break;

  0170c	e9 e9 04 00 00	 jmp	 $LN78@Py_dg_strt
$LN46@Py_dg_strt:

; 2168 :         }
; 2169 :         if ((aadj = ratio(delta, bs)) <= 2.) {

  01711	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR bs$[rsp]
  01719	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR delta$[rsp]
  01721	e8 00 00 00 00	 call	 ratio
  01726	f2 0f 11 84 24
	c8 00 00 00	 movsdx	 QWORD PTR aadj$[rsp], xmm0
  0172f	f2 0f 10 84 24
	c8 00 00 00	 movsdx	 xmm0, QWORD PTR aadj$[rsp]
  01738	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  01740	66 0f 2f c8	 comisd	 xmm1, xmm0
  01744	0f 82 e8 00 00
	00		 jb	 $LN32@Py_dg_strt

; 2170 :             if (dsign)

  0174a	83 bc 24 ec 00
	00 00 00	 cmp	 DWORD PTR dsign$[rsp], 0
  01752	74 22		 je	 SHORT $LN31@Py_dg_strt

; 2171 :                 aadj = aadj1 = 1.;

  01754	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0175c	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR aadj1$[rsp], xmm0
  01762	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR aadj1$[rsp]
  01768	f2 0f 11 84 24
	c8 00 00 00	 movsdx	 QWORD PTR aadj$[rsp], xmm0
  01771	e9 ba 00 00 00	 jmp	 $LN30@Py_dg_strt
$LN31@Py_dg_strt:

; 2172 :             else if (word1(&rv) || word0(&rv) & Bndry_mask) {

  01776	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR rv$[rsp], 0
  0177e	75 10		 jne	 SHORT $LN28@Py_dg_strt
  01780	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  01787	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  0178c	85 c0		 test	 eax, eax
  0178e	74 49		 je	 SHORT $LN29@Py_dg_strt
$LN28@Py_dg_strt:

; 2173 :                 if (word1(&rv) == Tiny1 && !word0(&rv)) {

  01790	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR rv$[rsp], 1
  01798	75 1e		 jne	 SHORT $LN27@Py_dg_strt
  0179a	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR rv$[rsp+4], 0
  017a2	75 14		 jne	 SHORT $LN27@Py_dg_strt

; 2174 :                     if (bc.nd >nd)

  017a4	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  017a8	39 44 24 3c	 cmp	 DWORD PTR bc$[rsp+4], eax
  017ac	7e 05		 jle	 SHORT $LN26@Py_dg_strt

; 2175 :                         break;

  017ae	e9 47 04 00 00	 jmp	 $LN78@Py_dg_strt
$LN26@Py_dg_strt:

; 2176 :                     goto undfl;

  017b3	e9 4b 05 00 00	 jmp	 $undfl$21023
$LN27@Py_dg_strt:

; 2177 :                 }
; 2178 :                 aadj = 1.;

  017b8	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  017c0	f2 0f 11 84 24
	c8 00 00 00	 movsdx	 QWORD PTR aadj$[rsp], xmm0

; 2179 :                 aadj1 = -1.;

  017c9	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  017d1	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR aadj1$[rsp], xmm0

; 2180 :             }
; 2181 :             else {

  017d7	eb 57		 jmp	 SHORT $LN25@Py_dg_strt
$LN29@Py_dg_strt:

; 2182 :                 /* special case -- power of FLT_RADIX to be */
; 2183 :                 /* rounded down... */
; 2184 : 
; 2185 :                 if (aadj < 2./FLT_RADIX)

  017d9	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  017e1	66 0f 2f 84 24
	c8 00 00 00	 comisd	 xmm0, QWORD PTR aadj$[rsp]
  017ea	76 13		 jbe	 SHORT $LN24@Py_dg_strt

; 2186 :                     aadj = 1./FLT_RADIX;

  017ec	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3fe0000000000000
  017f4	f2 0f 11 84 24
	c8 00 00 00	 movsdx	 QWORD PTR aadj$[rsp], xmm0

; 2187 :                 else

  017fd	eb 1a		 jmp	 SHORT $LN23@Py_dg_strt
$LN24@Py_dg_strt:

; 2188 :                     aadj *= 0.5;

  017ff	f2 0f 10 84 24
	c8 00 00 00	 movsdx	 xmm0, QWORD PTR aadj$[rsp]
  01808	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  01810	f2 0f 11 84 24
	c8 00 00 00	 movsdx	 QWORD PTR aadj$[rsp], xmm0
$LN23@Py_dg_strt:

; 2189 :                 aadj1 = -aadj;

  01819	f2 0f 10 84 24
	c8 00 00 00	 movsdx	 xmm0, QWORD PTR aadj$[rsp]
  01822	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  0182a	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR aadj1$[rsp], xmm0
$LN25@Py_dg_strt:
$LN30@Py_dg_strt:

; 2190 :             }
; 2191 :         }
; 2192 :         else {

  01830	eb 7b		 jmp	 SHORT $LN22@Py_dg_strt
$LN32@Py_dg_strt:

; 2193 :             aadj *= 0.5;

  01832	f2 0f 10 84 24
	c8 00 00 00	 movsdx	 xmm0, QWORD PTR aadj$[rsp]
  0183b	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe0000000000000
  01843	f2 0f 11 84 24
	c8 00 00 00	 movsdx	 QWORD PTR aadj$[rsp], xmm0

; 2194 :             aadj1 = dsign ? aadj : -aadj;

  0184c	83 bc 24 ec 00
	00 00 00	 cmp	 DWORD PTR dsign$[rsp], 0
  01854	74 14		 je	 SHORT $LN198@Py_dg_strt
  01856	f2 0f 10 84 24
	c8 00 00 00	 movsdx	 xmm0, QWORD PTR aadj$[rsp]
  0185f	f2 0f 11 84 24
	78 01 00 00	 movsdx	 QWORD PTR tv604[rsp], xmm0
  01868	eb 1a		 jmp	 SHORT $LN199@Py_dg_strt
$LN198@Py_dg_strt:
  0186a	f2 0f 10 84 24
	c8 00 00 00	 movsdx	 xmm0, QWORD PTR aadj$[rsp]
  01873	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  0187b	f2 0f 11 84 24
	78 01 00 00	 movsdx	 QWORD PTR tv604[rsp], xmm0
$LN199@Py_dg_strt:
  01884	f2 0f 10 84 24
	78 01 00 00	 movsdx	 xmm0, QWORD PTR tv604[rsp]
  0188d	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR aadj1$[rsp], xmm0

; 2195 :             if (Flt_Rounds == 0)

  01893	33 c0		 xor	 eax, eax
  01895	85 c0		 test	 eax, eax
  01897	74 14		 je	 SHORT $LN21@Py_dg_strt

; 2196 :                 aadj1 += 0.5;

  01899	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR aadj1$[rsp]
  0189f	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  018a7	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR aadj1$[rsp], xmm0
$LN21@Py_dg_strt:
$LN22@Py_dg_strt:

; 2197 :         }
; 2198 :         y = word0(&rv) & Exp_mask;

  018ad	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  018b4	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  018b9	89 44 24 48	 mov	 DWORD PTR y$[rsp], eax

; 2199 : 
; 2200 :         /* Check for overflow */
; 2201 : 
; 2202 :         if (y == Exp_msk1*(DBL_MAX_EXP+Bias-1)) {

  018bd	81 7c 24 48 00
	00 e0 7f	 cmp	 DWORD PTR y$[rsp], 2145386496 ; 7fe00000H
  018c5	0f 85 f7 00 00
	00		 jne	 $LN20@Py_dg_strt

; 2203 :             dval(&rv0) = dval(&rv);

  018cb	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  018d4	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR rv0$[rsp], xmm0

; 2204 :             word0(&rv) -= P*Exp_msk1;

  018da	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  018e1	2d 00 00 50 03	 sub	 eax, 55574528		; 03500000H
  018e6	89 84 24 c4 00
	00 00		 mov	 DWORD PTR rv$[rsp+4], eax

; 2205 :             adj.d = aadj1 * ulp(&rv);

  018ed	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  018f5	e8 00 00 00 00	 call	 ulp
  018fa	f2 0f 10 4c 24
	70		 movsdx	 xmm1, QWORD PTR aadj1$[rsp]
  01900	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  01904	66 0f 28 c1	 movapd	 xmm0, xmm1
  01908	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR adj$[rsp], xmm0

; 2206 :             dval(&rv) += adj.d;

  0190e	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  01917	f2 0f 58 44 24
	28		 addsd	 xmm0, QWORD PTR adj$[rsp]
  0191d	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0

; 2207 :             if ((word0(&rv) & Exp_mask) >=
; 2208 :                 Exp_msk1*(DBL_MAX_EXP+Bias-P)) {

  01926	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  0192d	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  01932	3d 00 00 a0 7c	 cmp	 eax, 2090860544		; 7ca00000H
  01937	72 71		 jb	 SHORT $LN19@Py_dg_strt

; 2209 :                 if (word0(&rv0) == Big0 && word1(&rv0) == Big1) {

  01939	81 7c 24 54 ff
	ff ef 7f	 cmp	 DWORD PTR rv0$[rsp+4], 2146435071 ; 7fefffffH
  01941	75 4a		 jne	 SHORT $LN18@Py_dg_strt
  01943	83 7c 24 50 ff	 cmp	 DWORD PTR rv0$[rsp], -1	; ffffffffH
  01948	75 43		 jne	 SHORT $LN18@Py_dg_strt

; 2210 :                     Bfree(bb);

  0194a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  01952	e8 00 00 00 00	 call	 Bfree

; 2211 :                     Bfree(bd);

  01957	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  0195f	e8 00 00 00 00	 call	 Bfree

; 2212 :                     Bfree(bs);

  01964	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  0196c	e8 00 00 00 00	 call	 Bfree

; 2213 :                     Bfree(bd0);

  01971	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  01976	e8 00 00 00 00	 call	 Bfree

; 2214 :                     Bfree(delta);

  0197b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR delta$[rsp]
  01983	e8 00 00 00 00	 call	 Bfree

; 2215 :                     goto ovfl;

  01988	e9 ab 03 00 00	 jmp	 $ovfl$21010
$LN18@Py_dg_strt:

; 2216 :                 }
; 2217 :                 word0(&rv) = Big0;

  0198d	c7 84 24 c4 00
	00 00 ff ff ef
	7f		 mov	 DWORD PTR rv$[rsp+4], 2146435071 ; 7fefffffH

; 2218 :                 word1(&rv) = Big1;

  01998	c7 84 24 c0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rv$[rsp], -1	; ffffffffH

; 2219 :                 goto cont;

  019a3	e9 19 02 00 00	 jmp	 $cont$21131

; 2220 :             }
; 2221 :             else

  019a8	eb 13		 jmp	 SHORT $LN17@Py_dg_strt
$LN19@Py_dg_strt:

; 2222 :                 word0(&rv) += P*Exp_msk1;

  019aa	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  019b1	05 00 00 50 03	 add	 eax, 55574528		; 03500000H
  019b6	89 84 24 c4 00
	00 00		 mov	 DWORD PTR rv$[rsp+4], eax
$LN17@Py_dg_strt:

; 2223 :         }
; 2224 :         else {

  019bd	e9 28 01 00 00	 jmp	 $LN16@Py_dg_strt
$LN20@Py_dg_strt:

; 2225 :             if (bc.scale && y <= 2*P*Exp_msk1) {

  019c2	83 7c 24 44 00	 cmp	 DWORD PTR bc$[rsp+12], 0
  019c7	0f 84 e4 00 00
	00		 je	 $LN15@Py_dg_strt
  019cd	81 7c 24 48 00
	00 a0 06	 cmp	 DWORD PTR y$[rsp], 111149056 ; 06a00000H
  019d5	0f 87 d6 00 00
	00		 ja	 $LN15@Py_dg_strt

; 2226 :                 if (aadj <= 0x7fffffff) {

  019db	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@41dfffffffc00000
  019e3	66 0f 2f 84 24
	c8 00 00 00	 comisd	 xmm0, QWORD PTR aadj$[rsp]
  019ec	0f 82 86 00 00
	00		 jb	 $LN14@Py_dg_strt

; 2227 :                     if ((z = (ULong)aadj) <= 0)

  019f2	f2 48 0f 2c 84
	24 c8 00 00 00	 cvttsd2si rax, QWORD PTR aadj$[rsp]
  019fc	89 84 24 b8 00
	00 00		 mov	 DWORD PTR z$[rsp], eax
  01a03	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR z$[rsp], 0
  01a0b	77 0b		 ja	 SHORT $LN13@Py_dg_strt

; 2228 :                         z = 1;

  01a0d	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR z$[rsp], 1
$LN13@Py_dg_strt:

; 2229 :                     aadj = z;

  01a18	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR z$[rsp]
  01a1f	66 0f ef c0	 pxor	 xmm0, xmm0
  01a23	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  01a28	f2 0f 11 84 24
	c8 00 00 00	 movsdx	 QWORD PTR aadj$[rsp], xmm0

; 2230 :                     aadj1 = dsign ? aadj : -aadj;

  01a31	83 bc 24 ec 00
	00 00 00	 cmp	 DWORD PTR dsign$[rsp], 0
  01a39	74 14		 je	 SHORT $LN200@Py_dg_strt
  01a3b	f2 0f 10 84 24
	c8 00 00 00	 movsdx	 xmm0, QWORD PTR aadj$[rsp]
  01a44	f2 0f 11 84 24
	80 01 00 00	 movsdx	 QWORD PTR tv640[rsp], xmm0
  01a4d	eb 1a		 jmp	 SHORT $LN201@Py_dg_strt
$LN200@Py_dg_strt:
  01a4f	f2 0f 10 84 24
	c8 00 00 00	 movsdx	 xmm0, QWORD PTR aadj$[rsp]
  01a58	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  01a60	f2 0f 11 84 24
	80 01 00 00	 movsdx	 QWORD PTR tv640[rsp], xmm0
$LN201@Py_dg_strt:
  01a69	f2 0f 10 84 24
	80 01 00 00	 movsdx	 xmm0, QWORD PTR tv640[rsp]
  01a72	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR aadj1$[rsp], xmm0
$LN14@Py_dg_strt:

; 2231 :                 }
; 2232 :                 dval(&aadj2) = aadj1;

  01a78	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR aadj1$[rsp]
  01a7e	f2 0f 11 84 24
	20 01 00 00	 movsdx	 QWORD PTR aadj2$[rsp], xmm0

; 2233 :                 word0(&aadj2) += (2*P+1)*Exp_msk1 - y;

  01a87	b8 00 00 b0 06	 mov	 eax, 112197632		; 06b00000H
  01a8c	2b 44 24 48	 sub	 eax, DWORD PTR y$[rsp]
  01a90	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR aadj2$[rsp+4]
  01a97	03 c8		 add	 ecx, eax
  01a99	8b c1		 mov	 eax, ecx
  01a9b	89 84 24 24 01
	00 00		 mov	 DWORD PTR aadj2$[rsp+4], eax

; 2234 :                 aadj1 = dval(&aadj2);

  01aa2	f2 0f 10 84 24
	20 01 00 00	 movsdx	 xmm0, QWORD PTR aadj2$[rsp]
  01aab	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR aadj1$[rsp], xmm0
$LN15@Py_dg_strt:

; 2235 :             }
; 2236 :             adj.d = aadj1 * ulp(&rv);

  01ab1	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  01ab9	e8 00 00 00 00	 call	 ulp
  01abe	f2 0f 10 4c 24
	70		 movsdx	 xmm1, QWORD PTR aadj1$[rsp]
  01ac4	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  01ac8	66 0f 28 c1	 movapd	 xmm0, xmm1
  01acc	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR adj$[rsp], xmm0

; 2237 :             dval(&rv) += adj.d;

  01ad2	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  01adb	f2 0f 58 44 24
	28		 addsd	 xmm0, QWORD PTR adj$[rsp]
  01ae1	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0
$LN16@Py_dg_strt:

; 2238 :         }
; 2239 :         z = word0(&rv) & Exp_mask;

  01aea	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  01af1	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  01af6	89 84 24 b8 00
	00 00		 mov	 DWORD PTR z$[rsp], eax

; 2240 :         if (bc.nd == nd) {

  01afd	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  01b01	39 44 24 3c	 cmp	 DWORD PTR bc$[rsp+4], eax
  01b05	0f 85 b6 00 00
	00		 jne	 $LN12@Py_dg_strt

; 2241 :             if (!bc.scale)

  01b0b	83 7c 24 44 00	 cmp	 DWORD PTR bc$[rsp+12], 0
  01b10	0f 85 ab 00 00
	00		 jne	 $LN11@Py_dg_strt

; 2242 :                 if (y == z) {

  01b16	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR z$[rsp]
  01b1d	39 44 24 48	 cmp	 DWORD PTR y$[rsp], eax
  01b21	0f 85 9a 00 00
	00		 jne	 $LN10@Py_dg_strt

; 2243 :                     /* Can we stop now? */
; 2244 :                     L = (Long)aadj;

  01b27	f2 0f 2c 84 24
	c8 00 00 00	 cvttsd2si eax, QWORD PTR aadj$[rsp]
  01b30	89 84 24 18 01
	00 00		 mov	 DWORD PTR L$[rsp], eax

; 2245 :                     aadj -= L;

  01b37	66 0f 6e 84 24
	18 01 00 00	 movd	 xmm0, DWORD PTR L$[rsp]
  01b40	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  01b44	f2 0f 10 8c 24
	c8 00 00 00	 movsdx	 xmm1, QWORD PTR aadj$[rsp]
  01b4d	f2 0f 5c c8	 subsd	 xmm1, xmm0
  01b51	66 0f 28 c1	 movapd	 xmm0, xmm1
  01b55	f2 0f 11 84 24
	c8 00 00 00	 movsdx	 QWORD PTR aadj$[rsp], xmm0

; 2246 :                     /* The tolerances below are conservative. */
; 2247 :                     if (dsign || word1(&rv) || word0(&rv) & Bndry_mask) {

  01b5e	83 bc 24 ec 00
	00 00 00	 cmp	 DWORD PTR dsign$[rsp], 0
  01b66	75 1a		 jne	 SHORT $LN8@Py_dg_strt
  01b68	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR rv$[rsp], 0
  01b70	75 10		 jne	 SHORT $LN8@Py_dg_strt
  01b72	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR rv$[rsp+4]
  01b79	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  01b7e	85 c0		 test	 eax, eax
  01b80	74 2a		 je	 SHORT $LN9@Py_dg_strt
$LN8@Py_dg_strt:

; 2248 :                         if (aadj < .4999999 || aadj > .5000001)

  01b82	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3fdfffff94a03595
  01b8a	66 0f 2f 84 24
	c8 00 00 00	 comisd	 xmm0, QWORD PTR aadj$[rsp]
  01b93	77 13		 ja	 SHORT $LN6@Py_dg_strt
  01b95	f2 0f 10 84 24
	c8 00 00 00	 movsdx	 xmm0, QWORD PTR aadj$[rsp]
  01b9e	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3fe0000035afe535
  01ba6	76 02		 jbe	 SHORT $LN7@Py_dg_strt
$LN6@Py_dg_strt:

; 2249 :                             break;

  01ba8	eb 50		 jmp	 SHORT $LN78@Py_dg_strt
$LN7@Py_dg_strt:

; 2250 :                     }
; 2251 :                     else if (aadj < .4999999/FLT_RADIX)

  01baa	eb 15		 jmp	 SHORT $LN5@Py_dg_strt
$LN9@Py_dg_strt:
  01bac	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3fcfffff94a03595
  01bb4	66 0f 2f 84 24
	c8 00 00 00	 comisd	 xmm0, QWORD PTR aadj$[rsp]
  01bbd	76 02		 jbe	 SHORT $LN4@Py_dg_strt

; 2252 :                         break;

  01bbf	eb 39		 jmp	 SHORT $LN78@Py_dg_strt
$LN4@Py_dg_strt:
$LN5@Py_dg_strt:
$LN10@Py_dg_strt:
$LN11@Py_dg_strt:
$LN12@Py_dg_strt:
$cont$21131:

; 2253 :                 }
; 2254 :         }
; 2255 :       cont:
; 2256 :         Bfree(bb);

  01bc1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  01bc9	e8 00 00 00 00	 call	 Bfree

; 2257 :         Bfree(bd);

  01bce	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  01bd6	e8 00 00 00 00	 call	 Bfree

; 2258 :         Bfree(bs);

  01bdb	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  01be3	e8 00 00 00 00	 call	 Bfree

; 2259 :         Bfree(delta);

  01be8	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR delta$[rsp]
  01bf0	e8 00 00 00 00	 call	 Bfree

; 2260 :     }

  01bf5	e9 44 f2 ff ff	 jmp	 $LN79@Py_dg_strt
$LN78@Py_dg_strt:

; 2261 :     Bfree(bb);

  01bfa	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR bb$[rsp]
  01c02	e8 00 00 00 00	 call	 Bfree

; 2262 :     Bfree(bd);

  01c07	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR bd$[rsp]
  01c0f	e8 00 00 00 00	 call	 Bfree

; 2263 :     Bfree(bs);

  01c14	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  01c1c	e8 00 00 00 00	 call	 Bfree

; 2264 :     Bfree(bd0);

  01c21	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bd0$[rsp]
  01c26	e8 00 00 00 00	 call	 Bfree

; 2265 :     Bfree(delta);

  01c2b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR delta$[rsp]
  01c33	e8 00 00 00 00	 call	 Bfree

; 2266 :     if (bc.nd > nd) {

  01c38	8b 44 24 58	 mov	 eax, DWORD PTR nd$[rsp]
  01c3c	39 44 24 3c	 cmp	 DWORD PTR bc$[rsp+4], eax
  01c40	7e 2a		 jle	 SHORT $LN3@Py_dg_strt

; 2267 :         error = bigcomp(&rv, s0, &bc);

  01c42	4c 8d 44 24 38	 lea	 r8, QWORD PTR bc$[rsp]
  01c47	48 8b 54 24 60	 mov	 rdx, QWORD PTR s0$[rsp]
  01c4c	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  01c54	e8 00 00 00 00	 call	 bigcomp
  01c59	89 84 24 8c 00
	00 00		 mov	 DWORD PTR error$[rsp], eax

; 2268 :         if (error)

  01c60	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR error$[rsp], 0
  01c68	74 02		 je	 SHORT $LN2@Py_dg_strt

; 2269 :             goto failed_malloc;

  01c6a	eb 7e		 jmp	 SHORT $failed_malloc$21050
$LN2@Py_dg_strt:
$LN3@Py_dg_strt:

; 2270 :     }
; 2271 : 
; 2272 :     if (bc.scale) {

  01c6c	83 7c 24 44 00	 cmp	 DWORD PTR bc$[rsp+12], 0
  01c71	74 28		 je	 SHORT $LN1@Py_dg_strt

; 2273 :         word0(&rv0) = Exp_1 - 2*P*Exp_msk1;

  01c73	c7 44 24 54 00
	00 50 39	 mov	 DWORD PTR rv0$[rsp+4], 961544192 ; 39500000H

; 2274 :         word1(&rv0) = 0;

  01c7b	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rv0$[rsp], 0

; 2275 :         dval(&rv) *= dval(&rv0);

  01c83	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  01c8c	f2 0f 59 44 24
	50		 mulsd	 xmm0, QWORD PTR rv0$[rsp]
  01c92	f2 0f 11 84 24
	c0 00 00 00	 movsdx	 QWORD PTR rv$[rsp], xmm0
$LN1@Py_dg_strt:
$ret$20985:

; 2276 :     }
; 2277 : 
; 2278 :   ret:
; 2279 :     return sign ? -dval(&rv) : dval(&rv);

  01c9b	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR sign$[rsp], 0
  01ca3	74 1c		 je	 SHORT $LN202@Py_dg_strt
  01ca5	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  01cae	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  01cb6	f2 0f 11 84 24
	88 01 00 00	 movsdx	 QWORD PTR tv685[rsp], xmm0
  01cbf	eb 12		 jmp	 SHORT $LN203@Py_dg_strt
$LN202@Py_dg_strt:
  01cc1	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  01cca	f2 0f 11 84 24
	88 01 00 00	 movsdx	 QWORD PTR tv685[rsp], xmm0
$LN203@Py_dg_strt:
  01cd3	f2 0f 10 84 24
	88 01 00 00	 movsdx	 xmm0, QWORD PTR tv685[rsp]
  01cdc	e9 ba 00 00 00	 jmp	 $LN176@Py_dg_strt
$parse_error$20952:

; 2280 : 
; 2281 :   parse_error:
; 2282 :     return 0.0;

  01ce1	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01ce5	e9 b1 00 00 00	 jmp	 $LN176@Py_dg_strt
$failed_malloc$21050:

; 2283 : 
; 2284 :   failed_malloc:
; 2285 :     errno = ENOMEM;

  01cea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01cf0	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 2286 :     return -1.0;

  01cf6	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@bff0000000000000
  01cfe	e9 98 00 00 00	 jmp	 $LN176@Py_dg_strt
$undfl$21023:

; 2287 : 
; 2288 :   undfl:
; 2289 :     return sign ? -0.0 : 0.0;

  01d03	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR sign$[rsp], 0
  01d0b	74 13		 je	 SHORT $LN204@Py_dg_strt
  01d0d	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@8000000000000000
  01d15	f2 0f 11 84 24
	90 01 00 00	 movsdx	 QWORD PTR tv688[rsp], xmm0
  01d1e	eb 0d		 jmp	 SHORT $LN205@Py_dg_strt
$LN204@Py_dg_strt:
  01d20	66 0f 57 c0	 xorpd	 xmm0, xmm0
  01d24	f2 0f 11 84 24
	90 01 00 00	 movsdx	 QWORD PTR tv688[rsp], xmm0
$LN205@Py_dg_strt:
  01d2d	f2 0f 10 84 24
	90 01 00 00	 movsdx	 xmm0, QWORD PTR tv688[rsp]
  01d36	eb 63		 jmp	 SHORT $LN176@Py_dg_strt
$ovfl$21010:

; 2290 : 
; 2291 :   ovfl:
; 2292 :     errno = ERANGE;

  01d38	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01d3e	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 2293 :     /* Can't trust HUGE_VAL */
; 2294 :     word0(&rv) = Exp_mask;

  01d44	c7 84 24 c4 00
	00 00 00 00 f0
	7f		 mov	 DWORD PTR rv$[rsp+4], 2146435072 ; 7ff00000H

; 2295 :     word1(&rv) = 0;

  01d4f	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rv$[rsp], 0

; 2296 :     return sign ? -dval(&rv) : dval(&rv);

  01d5a	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR sign$[rsp], 0
  01d62	74 1c		 je	 SHORT $LN206@Py_dg_strt
  01d64	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  01d6d	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  01d75	f2 0f 11 84 24
	98 01 00 00	 movsdx	 QWORD PTR tv693[rsp], xmm0
  01d7e	eb 12		 jmp	 SHORT $LN207@Py_dg_strt
$LN206@Py_dg_strt:
  01d80	f2 0f 10 84 24
	c0 00 00 00	 movsdx	 xmm0, QWORD PTR rv$[rsp]
  01d89	f2 0f 11 84 24
	98 01 00 00	 movsdx	 QWORD PTR tv693[rsp], xmm0
$LN207@Py_dg_strt:
  01d92	f2 0f 10 84 24
	98 01 00 00	 movsdx	 xmm0, QWORD PTR tv693[rsp]
$LN176@Py_dg_strt:

; 2297 : 
; 2298 : }

  01d9b	48 81 c4 a8 01
	00 00		 add	 rsp, 424		; 000001a8H
  01da2	c3		 ret	 0
_Py_dg_strtod ENDP
_TEXT	ENDS
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Balloc DD imagerel Balloc
	DD	imagerel Balloc+155
	DD	imagerel $unwind$Balloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Balloc DD 010801H
	DD	08208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Balloc
_TEXT	SEGMENT
x$ = 32
len$ = 36
rv$ = 40
tv87 = 48
k$ = 80
Balloc	PROC						; COMDAT

; 418  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 419  :     int x;
; 420  :     Bigint *rv;
; 421  :     unsigned int len;
; 422  : 
; 423  :     x = 1 << k;

  00008	8b 44 24 50	 mov	 eax, DWORD PTR k$[rsp]
  0000c	b9 01 00 00 00	 mov	 ecx, 1
  00011	89 4c 24 30	 mov	 DWORD PTR tv87[rsp], ecx
  00015	0f b6 c8	 movzx	 ecx, al
  00018	8b 44 24 30	 mov	 eax, DWORD PTR tv87[rsp]
  0001c	d3 e0		 shl	 eax, cl
  0001e	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 424  :     len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
; 425  :         /sizeof(double);

  00022	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00026	ff c8		 dec	 eax
  00028	48 98		 cdqe
  0002a	48 8d 04 85 27
	00 00 00	 lea	 rax, QWORD PTR [rax*4+39]
  00032	33 d2		 xor	 edx, edx
  00034	b9 08 00 00 00	 mov	 ecx, 8
  00039	48 f7 f1	 div	 rcx
  0003c	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 426  : 
; 427  :     rv = (Bigint*)MALLOC(len*sizeof(double));

  00040	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00044	48 c1 e0 03	 shl	 rax, 3
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 PyMem_Malloc
  00050	48 89 44 24 28	 mov	 QWORD PTR rv$[rsp], rax

; 428  :     if (rv == NULL)

  00055	48 83 7c 24 28
	00		 cmp	 QWORD PTR rv$[rsp], 0
  0005b	75 04		 jne	 SHORT $LN1@Balloc

; 429  :         return NULL;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 35		 jmp	 SHORT $LN2@Balloc
$LN1@Balloc:

; 430  : 
; 431  :     rv->k = k;

  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR rv$[rsp]
  00066	8b 4c 24 50	 mov	 ecx, DWORD PTR k$[rsp]
  0006a	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 432  :     rv->maxwds = x;

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR rv$[rsp]
  00072	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00076	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 433  :     rv->sign = rv->wds = 0;

  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR rv$[rsp]
  0007e	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR rv$[rsp]
  0008a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 434  :     return rv;

  00091	48 8b 44 24 28	 mov	 rax, QWORD PTR rv$[rsp]
$LN2@Balloc:

; 435  : }

  00096	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009a	c3		 ret	 0
Balloc	ENDP
_TEXT	ENDS
EXTRN	PyMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Bfree DD	imagerel Bfree
	DD	imagerel Bfree+32
	DD	imagerel $unwind$Bfree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Bfree DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Bfree
_TEXT	SEGMENT
v$ = 48
Bfree	PROC						; COMDAT

; 441  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 442  :     if (v) {

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$[rsp], 0
  0000f	74 0a		 je	 SHORT $LN1@Bfree

; 443  :         FREE((void*)v);

  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00016	e8 00 00 00 00	 call	 PyMem_Free
$LN1@Bfree:

; 444  :     }
; 445  : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
Bfree	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s2b DD	imagerel s2b
	DD	imagerel s2b+385
	DD	imagerel $unwind$s2b
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s2b DD	011701H
	DD	0a217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT s2b
_TEXT	SEGMENT
y$ = 32
x$ = 36
i$ = 40
b$ = 48
k$ = 56
tv83 = 60
tv95 = 64
s$ = 96
nd0$ = 104
nd$ = 112
y9$ = 120
s2b	PROC						; COMDAT

; 512  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 513  :     Bigint *b;
; 514  :     int i, k;
; 515  :     Long x, y;
; 516  : 
; 517  :     x = (nd + 8) / 9;

  00017	8b 44 24 70	 mov	 eax, DWORD PTR nd$[rsp]
  0001b	83 c0 08	 add	 eax, 8
  0001e	99		 cdq
  0001f	b9 09 00 00 00	 mov	 ecx, 9
  00024	f7 f9		 idiv	 ecx
  00026	89 44 24 24	 mov	 DWORD PTR x$[rsp], eax

; 518  :     for(k = 0, y = 1; x > y; y <<= 1, k++) ;

  0002a	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00032	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR y$[rsp], 1
  0003a	eb 14		 jmp	 SHORT $LN13@s2b
$LN12@s2b:
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR y$[rsp]
  00040	d1 e0		 shl	 eax, 1
  00042	89 44 24 20	 mov	 DWORD PTR y$[rsp], eax
  00046	8b 44 24 38	 mov	 eax, DWORD PTR k$[rsp]
  0004a	ff c0		 inc	 eax
  0004c	89 44 24 38	 mov	 DWORD PTR k$[rsp], eax
$LN13@s2b:
  00050	8b 44 24 20	 mov	 eax, DWORD PTR y$[rsp]
  00054	39 44 24 24	 cmp	 DWORD PTR x$[rsp], eax
  00058	7e 02		 jle	 SHORT $LN11@s2b
  0005a	eb e0		 jmp	 SHORT $LN12@s2b
$LN11@s2b:

; 519  :     b = Balloc(k);

  0005c	8b 4c 24 38	 mov	 ecx, DWORD PTR k$[rsp]
  00060	e8 00 00 00 00	 call	 Balloc
  00065	48 89 44 24 30	 mov	 QWORD PTR b$[rsp], rax

; 520  :     if (b == NULL)

  0006a	48 83 7c 24 30
	00		 cmp	 QWORD PTR b$[rsp], 0
  00070	75 07		 jne	 SHORT $LN10@s2b

; 521  :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	e9 03 01 00 00	 jmp	 $LN14@s2b
$LN10@s2b:

; 522  :     b->x[0] = y9;

  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  0007e	8b 4c 24 78	 mov	 ecx, DWORD PTR y9$[rsp]
  00082	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 523  :     b->wds = 1;

  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  0008a	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 524  : 
; 525  :     if (nd <= 9)

  00091	83 7c 24 70 09	 cmp	 DWORD PTR nd$[rsp], 9
  00096	7f 0a		 jg	 SHORT $LN9@s2b

; 526  :       return b;

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
  0009d	e9 da 00 00 00	 jmp	 $LN14@s2b
$LN9@s2b:

; 527  : 
; 528  :     s += 9;

  000a2	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000a7	48 83 c0 09	 add	 rax, 9
  000ab	48 89 44 24 60	 mov	 QWORD PTR s$[rsp], rax

; 529  :     for (i = 9; i < nd0; i++) {

  000b0	c7 44 24 28 09
	00 00 00	 mov	 DWORD PTR i$[rsp], 9
  000b8	eb 0a		 jmp	 SHORT $LN8@s2b
$LN7@s2b:
  000ba	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000be	ff c0		 inc	 eax
  000c0	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN8@s2b:
  000c4	8b 44 24 68	 mov	 eax, DWORD PTR nd0$[rsp]
  000c8	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  000cc	7d 43		 jge	 SHORT $LN6@s2b

; 530  :         b = multadd(b, 10, *s++ - '0');

  000ce	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000d3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000d6	83 e8 30	 sub	 eax, 48			; 00000030H
  000d9	89 44 24 3c	 mov	 DWORD PTR tv83[rsp], eax
  000dd	44 8b 44 24 3c	 mov	 r8d, DWORD PTR tv83[rsp]
  000e2	ba 0a 00 00 00	 mov	 edx, 10
  000e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  000ec	e8 00 00 00 00	 call	 multadd
  000f1	48 89 44 24 30	 mov	 QWORD PTR b$[rsp], rax
  000f6	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000fb	48 ff c0	 inc	 rax
  000fe	48 89 44 24 60	 mov	 QWORD PTR s$[rsp], rax

; 531  :         if (b == NULL)

  00103	48 83 7c 24 30
	00		 cmp	 QWORD PTR b$[rsp], 0
  00109	75 04		 jne	 SHORT $LN5@s2b

; 532  :             return NULL;

  0010b	33 c0		 xor	 eax, eax
  0010d	eb 6d		 jmp	 SHORT $LN14@s2b
$LN5@s2b:

; 533  :     }

  0010f	eb a9		 jmp	 SHORT $LN7@s2b
$LN6@s2b:

; 534  :     s++;

  00111	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00116	48 ff c0	 inc	 rax
  00119	48 89 44 24 60	 mov	 QWORD PTR s$[rsp], rax

; 535  :     for(; i < nd; i++) {

  0011e	eb 0a		 jmp	 SHORT $LN4@s2b
$LN3@s2b:
  00120	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00124	ff c0		 inc	 eax
  00126	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@s2b:
  0012a	8b 44 24 70	 mov	 eax, DWORD PTR nd$[rsp]
  0012e	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00132	7d 43		 jge	 SHORT $LN2@s2b

; 536  :         b = multadd(b, 10, *s++ - '0');

  00134	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00139	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0013c	83 e8 30	 sub	 eax, 48			; 00000030H
  0013f	89 44 24 40	 mov	 DWORD PTR tv95[rsp], eax
  00143	44 8b 44 24 40	 mov	 r8d, DWORD PTR tv95[rsp]
  00148	ba 0a 00 00 00	 mov	 edx, 10
  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00152	e8 00 00 00 00	 call	 multadd
  00157	48 89 44 24 30	 mov	 QWORD PTR b$[rsp], rax
  0015c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00161	48 ff c0	 inc	 rax
  00164	48 89 44 24 60	 mov	 QWORD PTR s$[rsp], rax

; 537  :         if (b == NULL)

  00169	48 83 7c 24 30
	00		 cmp	 QWORD PTR b$[rsp], 0
  0016f	75 04		 jne	 SHORT $LN1@s2b

; 538  :             return NULL;

  00171	33 c0		 xor	 eax, eax
  00173	eb 07		 jmp	 SHORT $LN14@s2b
$LN1@s2b:

; 539  :     }

  00175	eb a9		 jmp	 SHORT $LN3@s2b
$LN2@s2b:

; 540  :     return b;

  00177	48 8b 44 24 30	 mov	 rax, QWORD PTR b$[rsp]
$LN14@s2b:

; 541  : }

  0017c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00180	c3		 ret	 0
s2b	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$multadd DD imagerel multadd
	DD	imagerel multadd+358
	DD	imagerel $unwind$multadd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$multadd DD 011201H
	DD	0a212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT multadd
_TEXT	SEGMENT
y$ = 32
x$ = 40
i$ = 48
wds$ = 52
carry$ = 56
b1$ = 64
tv94 = 72
b$ = 96
m$ = 104
a$ = 112
multadd	PROC						; COMDAT

; 458  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 459  :     int i, wds;
; 460  : #ifdef ULLong
; 461  :     ULong *x;
; 462  :     ULLong carry, y;
; 463  : #else
; 464  :     ULong carry, *x, y;
; 465  :     ULong xi, z;
; 466  : #endif
; 467  :     Bigint *b1;
; 468  : 
; 469  :     wds = b->wds;

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR b$[rsp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0001a	89 44 24 34	 mov	 DWORD PTR wds$[rsp], eax

; 470  :     x = b->x;

  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR b$[rsp]
  00023	48 83 c0 18	 add	 rax, 24
  00027	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax

; 471  :     i = 0;

  0002c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 472  :     carry = a;

  00034	48 63 44 24 70	 movsxd	 rax, DWORD PTR a$[rsp]
  00039	48 89 44 24 38	 mov	 QWORD PTR carry$[rsp], rax
$LN6@multadd:

; 473  :     do {
; 474  : #ifdef ULLong
; 475  :         y = *x * (ULLong)m + carry;

  0003e	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  00043	8b 00		 mov	 eax, DWORD PTR [rax]
  00045	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR m$[rsp]
  0004a	48 0f af c1	 imul	 rax, rcx
  0004e	48 03 44 24 38	 add	 rax, QWORD PTR carry$[rsp]
  00053	48 89 44 24 20	 mov	 QWORD PTR y$[rsp], rax

; 476  :         carry = y >> 32;

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR y$[rsp]
  0005d	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00061	48 89 44 24 38	 mov	 QWORD PTR carry$[rsp], rax

; 477  :         *x++ = (ULong)(y & FFFFFFFF);

  00066	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0006b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR y$[rsp]
  00070	48 23 c8	 and	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  0007b	89 01		 mov	 DWORD PTR [rcx], eax
  0007d	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  00082	48 83 c0 04	 add	 rax, 4
  00086	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax

; 478  : #else
; 479  :         xi = *x;
; 480  :         y = (xi & 0xffff) * m + carry;
; 481  :         z = (xi >> 16) * m + (y >> 16);
; 482  :         carry = z >> 16;
; 483  :         *x++ = (z << 16) + (y & 0xffff);
; 484  : #endif
; 485  :     }
; 486  :     while(++i < wds);

  0008b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0008f	ff c0		 inc	 eax
  00091	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00095	8b 44 24 34	 mov	 eax, DWORD PTR wds$[rsp]
  00099	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0009d	7c 9f		 jl	 SHORT $LN6@multadd

; 487  :     if (carry) {

  0009f	48 83 7c 24 38
	00		 cmp	 QWORD PTR carry$[rsp], 0
  000a5	0f 84 b1 00 00
	00		 je	 $LN3@multadd

; 488  :         if (wds >= b->maxwds) {

  000ab	48 8b 44 24 60	 mov	 rax, QWORD PTR b$[rsp]
  000b0	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000b3	39 44 24 34	 cmp	 DWORD PTR wds$[rsp], eax
  000b7	7c 7b		 jl	 SHORT $LN2@multadd

; 489  :             b1 = Balloc(b->k+1);

  000b9	48 8b 44 24 60	 mov	 rax, QWORD PTR b$[rsp]
  000be	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000c1	ff c0		 inc	 eax
  000c3	8b c8		 mov	 ecx, eax
  000c5	e8 00 00 00 00	 call	 Balloc
  000ca	48 89 44 24 40	 mov	 QWORD PTR b1$[rsp], rax

; 490  :             if (b1 == NULL){

  000cf	48 83 7c 24 40
	00		 cmp	 QWORD PTR b1$[rsp], 0
  000d5	75 0e		 jne	 SHORT $LN1@multadd

; 491  :                 Bfree(b);

  000d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR b$[rsp]
  000dc	e8 00 00 00 00	 call	 Bfree

; 492  :                 return NULL;

  000e1	33 c0		 xor	 eax, eax
  000e3	eb 7c		 jmp	 SHORT $LN7@multadd
$LN1@multadd:

; 493  :             }
; 494  :             Bcopy(b1, b);

  000e5	48 8b 44 24 60	 mov	 rax, QWORD PTR b$[rsp]
  000ea	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  000ee	48 8d 04 85 08
	00 00 00	 lea	 rax, QWORD PTR [rax*4+8]
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR b$[rsp]
  000fb	48 83 c1 10	 add	 rcx, 16
  000ff	48 8b 54 24 40	 mov	 rdx, QWORD PTR b1$[rsp]
  00104	48 83 c2 10	 add	 rdx, 16
  00108	48 89 54 24 48	 mov	 QWORD PTR tv94[rsp], rdx
  0010d	4c 8b c0	 mov	 r8, rax
  00110	48 8b d1	 mov	 rdx, rcx
  00113	48 8b 44 24 48	 mov	 rax, QWORD PTR tv94[rsp]
  00118	48 8b c8	 mov	 rcx, rax
  0011b	e8 00 00 00 00	 call	 memcpy

; 495  :             Bfree(b);

  00120	48 8b 4c 24 60	 mov	 rcx, QWORD PTR b$[rsp]
  00125	e8 00 00 00 00	 call	 Bfree

; 496  :             b = b1;

  0012a	48 8b 44 24 40	 mov	 rax, QWORD PTR b1$[rsp]
  0012f	48 89 44 24 60	 mov	 QWORD PTR b$[rsp], rax
$LN2@multadd:

; 497  :         }
; 498  :         b->x[wds++] = (ULong)carry;

  00134	48 63 44 24 34	 movsxd	 rax, DWORD PTR wds$[rsp]
  00139	48 8b 4c 24 60	 mov	 rcx, QWORD PTR b$[rsp]
  0013e	8b 54 24 38	 mov	 edx, DWORD PTR carry$[rsp]
  00142	89 54 81 18	 mov	 DWORD PTR [rcx+rax*4+24], edx
  00146	8b 44 24 34	 mov	 eax, DWORD PTR wds$[rsp]
  0014a	ff c0		 inc	 eax
  0014c	89 44 24 34	 mov	 DWORD PTR wds$[rsp], eax

; 499  :         b->wds = wds;

  00150	48 8b 44 24 60	 mov	 rax, QWORD PTR b$[rsp]
  00155	8b 4c 24 34	 mov	 ecx, DWORD PTR wds$[rsp]
  00159	89 48 14	 mov	 DWORD PTR [rax+20], ecx
$LN3@multadd:

; 500  :     }
; 501  :     return b;

  0015c	48 8b 44 24 60	 mov	 rax, QWORD PTR b$[rsp]
$LN7@multadd:

; 502  : }

  00161	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00165	c3		 ret	 0
multadd	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$i2b DD	imagerel i2b
	DD	imagerel i2b+69
	DD	imagerel $unwind$i2b
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$i2b DD	010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT i2b
_TEXT	SEGMENT
b$ = 32
i$ = 64
i2b	PROC						; COMDAT

; 624  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 625  :     Bigint *b;
; 626  : 
; 627  :     b = Balloc(1);

  00008	b9 01 00 00 00	 mov	 ecx, 1
  0000d	e8 00 00 00 00	 call	 Balloc
  00012	48 89 44 24 20	 mov	 QWORD PTR b$[rsp], rax

; 628  :     if (b == NULL)

  00017	48 83 7c 24 20
	00		 cmp	 QWORD PTR b$[rsp], 0
  0001d	75 04		 jne	 SHORT $LN1@i2b

; 629  :         return NULL;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 1d		 jmp	 SHORT $LN2@i2b
$LN1@i2b:

; 630  :     b->x[0] = i;

  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  00028	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  0002c	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 631  :     b->wds = 1;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  00034	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 632  :     return b;

  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
$LN2@i2b:

; 633  : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	c3		 ret	 0
i2b	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mult DD	imagerel mult
	DD	imagerel mult+872
	DD	imagerel $unwind$mult
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mult DD	021101H
	DD	0150111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mult
_TEXT	SEGMENT
y$ = 32
x$ = 40
xbe$ = 48
xb$ = 56
xa$ = 64
wa$ = 72
carry$ = 80
xc0$ = 88
wc$ = 96
z$ = 104
k$ = 112
xc$ = 120
xae$ = 128
wb$ = 136
c$ = 144
a$ = 176
b$ = 184
mult	PROC						; COMDAT

; 640  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 641  :     Bigint *c;
; 642  :     int k, wa, wb, wc;
; 643  :     ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
; 644  :     ULong y;
; 645  : #ifdef ULLong
; 646  :     ULLong carry, z;
; 647  : #else
; 648  :     ULong carry, z;
; 649  :     ULong z2;
; 650  : #endif
; 651  : 
; 652  :     if ((!a->x[0] && a->wds == 1) || (!b->x[0] && b->wds == 1)) {

  00011	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00019	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0001d	75 0e		 jne	 SHORT $LN18@mult
  0001f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00027	83 78 14 01	 cmp	 DWORD PTR [rax+20], 1
  0002b	74 1c		 je	 SHORT $LN19@mult
$LN18@mult:
  0002d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00035	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00039	75 5a		 jne	 SHORT $LN20@mult
  0003b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00043	83 78 14 01	 cmp	 DWORD PTR [rax+20], 1
  00047	75 4c		 jne	 SHORT $LN20@mult
$LN19@mult:

; 653  :         c = Balloc(0);

  00049	33 c9		 xor	 ecx, ecx
  0004b	e8 00 00 00 00	 call	 Balloc
  00050	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR c$[rsp], rax

; 654  :         if (c == NULL)

  00058	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR c$[rsp], 0
  00061	75 07		 jne	 SHORT $LN17@mult

; 655  :             return NULL;

  00063	33 c0		 xor	 eax, eax
  00065	e9 f6 02 00 00	 jmp	 $LN21@mult
$LN17@mult:

; 656  :         c->wds = 1;

  0006a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00072	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 657  :         c->x[0] = 0;

  00079	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00081	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 658  :         return c;

  00088	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00090	e9 cb 02 00 00	 jmp	 $LN21@mult
$LN20@mult:

; 659  :     }
; 660  : 
; 661  :     if (a->wds < b->wds) {

  00095	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0009d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  000a5	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  000a8	39 48 14	 cmp	 DWORD PTR [rax+20], ecx
  000ab	7d 30		 jge	 SHORT $LN16@mult

; 662  :         c = a;

  000ad	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000b5	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR c$[rsp], rax

; 663  :         a = b;

  000bd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000c5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR a$[rsp], rax

; 664  :         b = c;

  000cd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000d5	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR b$[rsp], rax
$LN16@mult:

; 665  :     }
; 666  :     k = a->k;

  000dd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000e5	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000e8	89 44 24 70	 mov	 DWORD PTR k$[rsp], eax

; 667  :     wa = a->wds;

  000ec	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000f4	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000f7	89 44 24 48	 mov	 DWORD PTR wa$[rsp], eax

; 668  :     wb = b->wds;

  000fb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00103	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00106	89 84 24 88 00
	00 00		 mov	 DWORD PTR wb$[rsp], eax

; 669  :     wc = wa + wb;

  0010d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR wb$[rsp]
  00114	8b 4c 24 48	 mov	 ecx, DWORD PTR wa$[rsp]
  00118	03 c8		 add	 ecx, eax
  0011a	8b c1		 mov	 eax, ecx
  0011c	89 44 24 60	 mov	 DWORD PTR wc$[rsp], eax

; 670  :     if (wc > a->maxwds)

  00120	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00128	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0012b	39 44 24 60	 cmp	 DWORD PTR wc$[rsp], eax
  0012f	7e 0a		 jle	 SHORT $LN15@mult

; 671  :         k++;

  00131	8b 44 24 70	 mov	 eax, DWORD PTR k$[rsp]
  00135	ff c0		 inc	 eax
  00137	89 44 24 70	 mov	 DWORD PTR k$[rsp], eax
$LN15@mult:

; 672  :     c = Balloc(k);

  0013b	8b 4c 24 70	 mov	 ecx, DWORD PTR k$[rsp]
  0013f	e8 00 00 00 00	 call	 Balloc
  00144	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR c$[rsp], rax

; 673  :     if (c == NULL)

  0014c	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR c$[rsp], 0
  00155	75 07		 jne	 SHORT $LN14@mult

; 674  :         return NULL;

  00157	33 c0		 xor	 eax, eax
  00159	e9 02 02 00 00	 jmp	 $LN21@mult
$LN14@mult:

; 675  :     for(x = c->x, xa = x + wc; x < xa; x++)

  0015e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00166	48 83 c0 18	 add	 rax, 24
  0016a	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax
  0016f	48 63 44 24 60	 movsxd	 rax, DWORD PTR wc$[rsp]
  00174	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  00179	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  0017d	48 89 44 24 40	 mov	 QWORD PTR xa$[rsp], rax
  00182	eb 0e		 jmp	 SHORT $LN13@mult
$LN12@mult:
  00184	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  00189	48 83 c0 04	 add	 rax, 4
  0018d	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax
$LN13@mult:
  00192	48 8b 44 24 40	 mov	 rax, QWORD PTR xa$[rsp]
  00197	48 39 44 24 28	 cmp	 QWORD PTR x$[rsp], rax
  0019c	73 0d		 jae	 SHORT $LN11@mult

; 676  :         *x = 0;

  0019e	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  001a3	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  001a9	eb d9		 jmp	 SHORT $LN12@mult
$LN11@mult:

; 677  :     xa = a->x;

  001ab	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  001b3	48 83 c0 18	 add	 rax, 24
  001b7	48 89 44 24 40	 mov	 QWORD PTR xa$[rsp], rax

; 678  :     xae = xa + wa;

  001bc	48 63 44 24 48	 movsxd	 rax, DWORD PTR wa$[rsp]
  001c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR xa$[rsp]
  001c6	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  001ca	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR xae$[rsp], rax

; 679  :     xb = b->x;

  001d2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  001da	48 83 c0 18	 add	 rax, 24
  001de	48 89 44 24 38	 mov	 QWORD PTR xb$[rsp], rax

; 680  :     xbe = xb + wb;

  001e3	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR wb$[rsp]
  001eb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR xb$[rsp]
  001f0	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  001f4	48 89 44 24 30	 mov	 QWORD PTR xbe$[rsp], rax

; 681  :     xc0 = c->x;

  001f9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00201	48 83 c0 18	 add	 rax, 24
  00205	48 89 44 24 58	 mov	 QWORD PTR xc0$[rsp], rax

; 682  : #ifdef ULLong
; 683  :     for(; xb < xbe; xc0++) {

  0020a	eb 0e		 jmp	 SHORT $LN10@mult
$LN9@mult:
  0020c	48 8b 44 24 58	 mov	 rax, QWORD PTR xc0$[rsp]
  00211	48 83 c0 04	 add	 rax, 4
  00215	48 89 44 24 58	 mov	 QWORD PTR xc0$[rsp], rax
$LN10@mult:
  0021a	48 8b 44 24 30	 mov	 rax, QWORD PTR xbe$[rsp]
  0021f	48 39 44 24 38	 cmp	 QWORD PTR xb$[rsp], rax
  00224	0f 83 ce 00 00
	00		 jae	 $LN8@mult

; 684  :         if ((y = *xb++)) {

  0022a	48 8b 44 24 38	 mov	 rax, QWORD PTR xb$[rsp]
  0022f	8b 00		 mov	 eax, DWORD PTR [rax]
  00231	89 44 24 20	 mov	 DWORD PTR y$[rsp], eax
  00235	8b 44 24 20	 mov	 eax, DWORD PTR y$[rsp]
  00239	48 8b 4c 24 38	 mov	 rcx, QWORD PTR xb$[rsp]
  0023e	48 83 c1 04	 add	 rcx, 4
  00242	48 89 4c 24 38	 mov	 QWORD PTR xb$[rsp], rcx
  00247	85 c0		 test	 eax, eax
  00249	0f 84 a4 00 00
	00		 je	 $LN7@mult

; 685  :             x = xa;

  0024f	48 8b 44 24 40	 mov	 rax, QWORD PTR xa$[rsp]
  00254	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax

; 686  :             xc = xc0;

  00259	48 8b 44 24 58	 mov	 rax, QWORD PTR xc0$[rsp]
  0025e	48 89 44 24 78	 mov	 QWORD PTR xc$[rsp], rax

; 687  :             carry = 0;

  00263	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR carry$[rsp], 0
$LN6@mult:

; 688  :             do {
; 689  :                 z = *x++ * (ULLong)y + *xc + carry;

  0026c	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  00271	8b 00		 mov	 eax, DWORD PTR [rax]
  00273	8b 4c 24 20	 mov	 ecx, DWORD PTR y$[rsp]
  00277	48 0f af c1	 imul	 rax, rcx
  0027b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR xc$[rsp]
  00280	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00282	48 8b 54 24 50	 mov	 rdx, QWORD PTR carry$[rsp]
  00287	48 03 d0	 add	 rdx, rax
  0028a	48 8b c2	 mov	 rax, rdx
  0028d	48 03 c8	 add	 rcx, rax
  00290	48 8b c1	 mov	 rax, rcx
  00293	48 89 44 24 68	 mov	 QWORD PTR z$[rsp], rax
  00298	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  0029d	48 83 c0 04	 add	 rax, 4
  002a1	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax

; 690  :                 carry = z >> 32;

  002a6	48 8b 44 24 68	 mov	 rax, QWORD PTR z$[rsp]
  002ab	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  002af	48 89 44 24 50	 mov	 QWORD PTR carry$[rsp], rax

; 691  :                 *xc++ = (ULong)(z & FFFFFFFF);

  002b4	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  002b9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR z$[rsp]
  002be	48 23 c8	 and	 rcx, rax
  002c1	48 8b c1	 mov	 rax, rcx
  002c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR xc$[rsp]
  002c9	89 01		 mov	 DWORD PTR [rcx], eax
  002cb	48 8b 44 24 78	 mov	 rax, QWORD PTR xc$[rsp]
  002d0	48 83 c0 04	 add	 rax, 4
  002d4	48 89 44 24 78	 mov	 QWORD PTR xc$[rsp], rax

; 692  :             }
; 693  :             while(x < xae);

  002d9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR xae$[rsp]
  002e1	48 39 44 24 28	 cmp	 QWORD PTR x$[rsp], rax
  002e6	72 84		 jb	 SHORT $LN6@mult

; 694  :             *xc = (ULong)carry;

  002e8	48 8b 44 24 78	 mov	 rax, QWORD PTR xc$[rsp]
  002ed	8b 4c 24 50	 mov	 ecx, DWORD PTR carry$[rsp]
  002f1	89 08		 mov	 DWORD PTR [rax], ecx
$LN7@mult:

; 695  :         }
; 696  :     }

  002f3	e9 14 ff ff ff	 jmp	 $LN9@mult
$LN8@mult:

; 697  : #else
; 698  :     for(; xb < xbe; xb++, xc0++) {
; 699  :         if (y = *xb & 0xffff) {
; 700  :             x = xa;
; 701  :             xc = xc0;
; 702  :             carry = 0;
; 703  :             do {
; 704  :                 z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
; 705  :                 carry = z >> 16;
; 706  :                 z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
; 707  :                 carry = z2 >> 16;
; 708  :                 Storeinc(xc, z2, z);
; 709  :             }
; 710  :             while(x < xae);
; 711  :             *xc = carry;
; 712  :         }
; 713  :         if (y = *xb >> 16) {
; 714  :             x = xa;
; 715  :             xc = xc0;
; 716  :             carry = 0;
; 717  :             z2 = *xc;
; 718  :             do {
; 719  :                 z = (*x & 0xffff) * y + (*xc >> 16) + carry;
; 720  :                 carry = z >> 16;
; 721  :                 Storeinc(xc, z, z2);
; 722  :                 z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
; 723  :                 carry = z2 >> 16;
; 724  :             }
; 725  :             while(x < xae);
; 726  :             *xc = z2;
; 727  :         }
; 728  :     }
; 729  : #endif
; 730  :     for(xc0 = c->x, xc = xc0 + wc; wc > 0 && !*--xc; --wc) ;

  002f8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00300	48 83 c0 18	 add	 rax, 24
  00304	48 89 44 24 58	 mov	 QWORD PTR xc0$[rsp], rax
  00309	48 63 44 24 60	 movsxd	 rax, DWORD PTR wc$[rsp]
  0030e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR xc0$[rsp]
  00313	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00317	48 89 44 24 78	 mov	 QWORD PTR xc$[rsp], rax
  0031c	eb 0a		 jmp	 SHORT $LN3@mult
$LN2@mult:
  0031e	8b 44 24 60	 mov	 eax, DWORD PTR wc$[rsp]
  00322	ff c8		 dec	 eax
  00324	89 44 24 60	 mov	 DWORD PTR wc$[rsp], eax
$LN3@mult:
  00328	83 7c 24 60 00	 cmp	 DWORD PTR wc$[rsp], 0
  0032d	7e 1a		 jle	 SHORT $LN1@mult
  0032f	48 8b 44 24 78	 mov	 rax, QWORD PTR xc$[rsp]
  00334	48 83 e8 04	 sub	 rax, 4
  00338	48 89 44 24 78	 mov	 QWORD PTR xc$[rsp], rax
  0033d	48 8b 44 24 78	 mov	 rax, QWORD PTR xc$[rsp]
  00342	83 38 00	 cmp	 DWORD PTR [rax], 0
  00345	75 02		 jne	 SHORT $LN1@mult
  00347	eb d5		 jmp	 SHORT $LN2@mult
$LN1@mult:

; 731  :     c->wds = wc;

  00349	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00351	8b 4c 24 60	 mov	 ecx, DWORD PTR wc$[rsp]
  00355	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 732  :     return c;

  00358	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
$LN21@mult:

; 733  : }

  00360	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00367	c3		 ret	 0
mult	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pow5mult DD imagerel pow5mult
	DD	imagerel pow5mult+329
	DD	imagerel $unwind$pow5mult
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pow5mult DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT pow5mult
_TEXT	SEGMENT
p51$ = 32
i$ = 40
p5$ = 48
b1$ = 56
b$ = 80
k$ = 88
pow5mult PROC						; COMDAT

; 803  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 804  :     Bigint *b1, *p5, *p51;
; 805  :     int i;
; 806  :     static int p05[3] = { 5, 25, 125 };
; 807  : 
; 808  :     if ((i = k & 3)) {

  0000d	8b 44 24 58	 mov	 eax, DWORD PTR k$[rsp]
  00011	83 e0 03	 and	 eax, 3
  00014	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00018	83 7c 24 28 00	 cmp	 DWORD PTR i$[rsp], 0
  0001d	74 33		 je	 SHORT $LN10@pow5mult

; 809  :         b = multadd(b, p05[i-1], 0);

  0001f	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00023	ff c8		 dec	 eax
  00025	48 98		 cdqe
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?p05@?1??pow5mult@@9@9
  0002e	45 33 c0	 xor	 r8d, r8d
  00031	8b 14 81	 mov	 edx, DWORD PTR [rcx+rax*4]
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR b$[rsp]
  00039	e8 00 00 00 00	 call	 multadd
  0003e	48 89 44 24 50	 mov	 QWORD PTR b$[rsp], rax

; 810  :         if (b == NULL)

  00043	48 83 7c 24 50
	00		 cmp	 QWORD PTR b$[rsp], 0
  00049	75 07		 jne	 SHORT $LN9@pow5mult

; 811  :             return NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	e9 f2 00 00 00	 jmp	 $LN11@pow5mult
$LN9@pow5mult:
$LN10@pow5mult:

; 812  :     }
; 813  : 
; 814  :     if (!(k >>= 2))

  00052	8b 44 24 58	 mov	 eax, DWORD PTR k$[rsp]
  00056	c1 f8 02	 sar	 eax, 2
  00059	89 44 24 58	 mov	 DWORD PTR k$[rsp], eax
  0005d	83 7c 24 58 00	 cmp	 DWORD PTR k$[rsp], 0
  00062	75 0a		 jne	 SHORT $LN8@pow5mult

; 815  :         return b;

  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR b$[rsp]
  00069	e9 d6 00 00 00	 jmp	 $LN11@pow5mult
$LN8@pow5mult:

; 816  :     p5 = i2b(625);

  0006e	b9 71 02 00 00	 mov	 ecx, 625		; 00000271H
  00073	e8 00 00 00 00	 call	 i2b
  00078	48 89 44 24 30	 mov	 QWORD PTR p5$[rsp], rax

; 817  :     if (p5 == NULL) {

  0007d	48 83 7c 24 30
	00		 cmp	 QWORD PTR p5$[rsp], 0
  00083	75 11		 jne	 SHORT $LN7@pow5mult

; 818  :         Bfree(b);

  00085	48 8b 4c 24 50	 mov	 rcx, QWORD PTR b$[rsp]
  0008a	e8 00 00 00 00	 call	 Bfree

; 819  :         return NULL;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 ae 00 00 00	 jmp	 $LN11@pow5mult
$LN7@pow5mult:
$LN6@pow5mult:

; 820  :     }
; 821  : 
; 822  :     for(;;) {
; 823  :         if (k & 1) {

  00096	8b 44 24 58	 mov	 eax, DWORD PTR k$[rsp]
  0009a	83 e0 01	 and	 eax, 1
  0009d	85 c0		 test	 eax, eax
  0009f	74 3e		 je	 SHORT $LN4@pow5mult

; 824  :             b1 = mult(b, p5);

  000a1	48 8b 54 24 30	 mov	 rdx, QWORD PTR p5$[rsp]
  000a6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR b$[rsp]
  000ab	e8 00 00 00 00	 call	 mult
  000b0	48 89 44 24 38	 mov	 QWORD PTR b1$[rsp], rax

; 825  :             Bfree(b);

  000b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR b$[rsp]
  000ba	e8 00 00 00 00	 call	 Bfree

; 826  :             b = b1;

  000bf	48 8b 44 24 38	 mov	 rax, QWORD PTR b1$[rsp]
  000c4	48 89 44 24 50	 mov	 QWORD PTR b$[rsp], rax

; 827  :             if (b == NULL) {

  000c9	48 83 7c 24 50
	00		 cmp	 QWORD PTR b$[rsp], 0
  000cf	75 0e		 jne	 SHORT $LN3@pow5mult

; 828  :                 Bfree(p5);

  000d1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p5$[rsp]
  000d6	e8 00 00 00 00	 call	 Bfree

; 829  :                 return NULL;

  000db	33 c0		 xor	 eax, eax
  000dd	eb 65		 jmp	 SHORT $LN11@pow5mult
$LN3@pow5mult:
$LN4@pow5mult:

; 830  :             }
; 831  :         }
; 832  :         if (!(k >>= 1))

  000df	8b 44 24 58	 mov	 eax, DWORD PTR k$[rsp]
  000e3	d1 f8		 sar	 eax, 1
  000e5	89 44 24 58	 mov	 DWORD PTR k$[rsp], eax
  000e9	83 7c 24 58 00	 cmp	 DWORD PTR k$[rsp], 0
  000ee	75 02		 jne	 SHORT $LN2@pow5mult

; 833  :             break;

  000f0	eb 43		 jmp	 SHORT $LN5@pow5mult
$LN2@pow5mult:

; 834  :         p51 = mult(p5, p5);

  000f2	48 8b 54 24 30	 mov	 rdx, QWORD PTR p5$[rsp]
  000f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p5$[rsp]
  000fc	e8 00 00 00 00	 call	 mult
  00101	48 89 44 24 20	 mov	 QWORD PTR p51$[rsp], rax

; 835  :         Bfree(p5);

  00106	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p5$[rsp]
  0010b	e8 00 00 00 00	 call	 Bfree

; 836  :         p5 = p51;

  00110	48 8b 44 24 20	 mov	 rax, QWORD PTR p51$[rsp]
  00115	48 89 44 24 30	 mov	 QWORD PTR p5$[rsp], rax

; 837  :         if (p5 == NULL) {

  0011a	48 83 7c 24 30
	00		 cmp	 QWORD PTR p5$[rsp], 0
  00120	75 0e		 jne	 SHORT $LN1@pow5mult

; 838  :             Bfree(b);

  00122	48 8b 4c 24 50	 mov	 rcx, QWORD PTR b$[rsp]
  00127	e8 00 00 00 00	 call	 Bfree

; 839  :             return NULL;

  0012c	33 c0		 xor	 eax, eax
  0012e	eb 14		 jmp	 SHORT $LN11@pow5mult
$LN1@pow5mult:

; 840  :         }
; 841  :     }

  00130	e9 61 ff ff ff	 jmp	 $LN6@pow5mult
$LN5@pow5mult:

; 842  :     Bfree(p5);

  00135	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p5$[rsp]
  0013a	e8 00 00 00 00	 call	 Bfree

; 843  :     return b;

  0013f	48 8b 44 24 50	 mov	 rax, QWORD PTR b$[rsp]
$LN11@pow5mult:

; 844  : }

  00144	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00148	c3		 ret	 0
pow5mult ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lshift DD imagerel lshift
	DD	imagerel lshift+607
	DD	imagerel $unwind$lshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lshift DD 010d01H
	DD	0e20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lshift
_TEXT	SEGMENT
x$ = 32
n$ = 40
i$ = 44
n1$ = 48
xe$ = 56
z$ = 64
x1$ = 72
k1$ = 80
b1$ = 88
tv170 = 96
tv176 = 104
b$ = 128
k$ = 136
lshift	PROC						; COMDAT

; 854  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 855  :     int i, k1, n, n1;
; 856  :     Bigint *b1;
; 857  :     ULong *x, *x1, *xe, z;
; 858  : 
; 859  :     if (!k || (!b->x[0] && b->wds == 1))

  0000d	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR k$[rsp], 0
  00015	74 1c		 je	 SHORT $LN17@lshift
  00017	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0001f	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00023	75 1b		 jne	 SHORT $LN18@lshift
  00025	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0002d	83 78 14 01	 cmp	 DWORD PTR [rax+20], 1
  00031	75 0d		 jne	 SHORT $LN18@lshift
$LN17@lshift:

; 860  :         return b;

  00033	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0003b	e9 1a 02 00 00	 jmp	 $LN19@lshift
$LN18@lshift:

; 861  : 
; 862  :     n = k >> 5;

  00040	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00047	c1 f8 05	 sar	 eax, 5
  0004a	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 863  :     k1 = b->k;

  0004e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00056	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00059	89 44 24 50	 mov	 DWORD PTR k1$[rsp], eax

; 864  :     n1 = n + b->wds + 1;

  0005d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00065	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00068	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  0006c	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  00070	89 44 24 30	 mov	 DWORD PTR n1$[rsp], eax

; 865  :     for(i = b->maxwds; n1 > i; i <<= 1)

  00074	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0007c	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0007f	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
  00083	eb 0a		 jmp	 SHORT $LN16@lshift
$LN15@lshift:
  00085	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  00089	d1 e0		 shl	 eax, 1
  0008b	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN16@lshift:
  0008f	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  00093	39 44 24 30	 cmp	 DWORD PTR n1$[rsp], eax
  00097	7e 0c		 jle	 SHORT $LN14@lshift

; 866  :         k1++;

  00099	8b 44 24 50	 mov	 eax, DWORD PTR k1$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	89 44 24 50	 mov	 DWORD PTR k1$[rsp], eax
  000a3	eb e0		 jmp	 SHORT $LN15@lshift
$LN14@lshift:

; 867  :     b1 = Balloc(k1);

  000a5	8b 4c 24 50	 mov	 ecx, DWORD PTR k1$[rsp]
  000a9	e8 00 00 00 00	 call	 Balloc
  000ae	48 89 44 24 58	 mov	 QWORD PTR b1$[rsp], rax

; 868  :     if (b1 == NULL) {

  000b3	48 83 7c 24 58
	00		 cmp	 QWORD PTR b1$[rsp], 0
  000b9	75 14		 jne	 SHORT $LN13@lshift

; 869  :         Bfree(b);

  000bb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  000c3	e8 00 00 00 00	 call	 Bfree

; 870  :         return NULL;

  000c8	33 c0		 xor	 eax, eax
  000ca	e9 8b 01 00 00	 jmp	 $LN19@lshift
$LN13@lshift:

; 871  :     }
; 872  :     x1 = b1->x;

  000cf	48 8b 44 24 58	 mov	 rax, QWORD PTR b1$[rsp]
  000d4	48 83 c0 18	 add	 rax, 24
  000d8	48 89 44 24 48	 mov	 QWORD PTR x1$[rsp], rax

; 873  :     for(i = 0; i < n; i++)

  000dd	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000e5	eb 0a		 jmp	 SHORT $LN12@lshift
$LN11@lshift:
  000e7	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  000eb	ff c0		 inc	 eax
  000ed	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN12@lshift:
  000f1	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  000f5	39 44 24 2c	 cmp	 DWORD PTR i$[rsp], eax
  000f9	7d 1b		 jge	 SHORT $LN10@lshift

; 874  :         *x1++ = 0;

  000fb	48 8b 44 24 48	 mov	 rax, QWORD PTR x1$[rsp]
  00100	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00106	48 8b 44 24 48	 mov	 rax, QWORD PTR x1$[rsp]
  0010b	48 83 c0 04	 add	 rax, 4
  0010f	48 89 44 24 48	 mov	 QWORD PTR x1$[rsp], rax
  00114	eb d1		 jmp	 SHORT $LN11@lshift
$LN10@lshift:

; 875  :     x = b->x;

  00116	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0011e	48 83 c0 18	 add	 rax, 24
  00122	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 876  :     xe = x + b->wds;

  00127	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0012f	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  00133	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00138	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  0013c	48 89 44 24 38	 mov	 QWORD PTR xe$[rsp], rax

; 877  :     if (k &= 0x1f) {

  00141	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00148	83 e0 1f	 and	 eax, 31
  0014b	89 84 24 88 00
	00 00		 mov	 DWORD PTR k$[rsp], eax
  00152	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR k$[rsp], 0
  0015a	0f 84 a4 00 00
	00		 je	 $LN9@lshift

; 878  :         k1 = 32 - k;

  00160	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00165	2b 84 24 88 00
	00 00		 sub	 eax, DWORD PTR k$[rsp]
  0016c	89 44 24 50	 mov	 DWORD PTR k1$[rsp], eax

; 879  :         z = 0;

  00170	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR z$[rsp], 0
$LN8@lshift:

; 880  :         do {
; 881  :             *x1++ = *x << k | z;

  00178	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  0017f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00184	48 89 4c 24 60	 mov	 QWORD PTR tv170[rsp], rcx
  00189	0f b6 c8	 movzx	 ecx, al
  0018c	48 8b 44 24 60	 mov	 rax, QWORD PTR tv170[rsp]
  00191	8b 00		 mov	 eax, DWORD PTR [rax]
  00193	d3 e0		 shl	 eax, cl
  00195	0b 44 24 40	 or	 eax, DWORD PTR z$[rsp]
  00199	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x1$[rsp]
  0019e	89 01		 mov	 DWORD PTR [rcx], eax
  001a0	48 8b 44 24 48	 mov	 rax, QWORD PTR x1$[rsp]
  001a5	48 83 c0 04	 add	 rax, 4
  001a9	48 89 44 24 48	 mov	 QWORD PTR x1$[rsp], rax

; 882  :             z = *x++ >> k1;

  001ae	8b 44 24 50	 mov	 eax, DWORD PTR k1$[rsp]
  001b2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  001b7	48 89 4c 24 68	 mov	 QWORD PTR tv176[rsp], rcx
  001bc	0f b6 c8	 movzx	 ecx, al
  001bf	48 8b 44 24 68	 mov	 rax, QWORD PTR tv176[rsp]
  001c4	8b 00		 mov	 eax, DWORD PTR [rax]
  001c6	d3 e8		 shr	 eax, cl
  001c8	89 44 24 40	 mov	 DWORD PTR z$[rsp], eax
  001cc	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  001d1	48 83 c0 04	 add	 rax, 4
  001d5	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 883  :         }
; 884  :         while(x < xe);

  001da	48 8b 44 24 38	 mov	 rax, QWORD PTR xe$[rsp]
  001df	48 39 44 24 20	 cmp	 QWORD PTR x$[rsp], rax
  001e4	72 92		 jb	 SHORT $LN8@lshift

; 885  :         if ((*x1 = z))

  001e6	48 8b 44 24 48	 mov	 rax, QWORD PTR x1$[rsp]
  001eb	8b 4c 24 40	 mov	 ecx, DWORD PTR z$[rsp]
  001ef	89 08		 mov	 DWORD PTR [rax], ecx
  001f1	83 7c 24 40 00	 cmp	 DWORD PTR z$[rsp], 0
  001f6	74 0a		 je	 SHORT $LN5@lshift

; 886  :             ++n1;

  001f8	8b 44 24 30	 mov	 eax, DWORD PTR n1$[rsp]
  001fc	ff c0		 inc	 eax
  001fe	89 44 24 30	 mov	 DWORD PTR n1$[rsp], eax
$LN5@lshift:

; 887  :     }
; 888  :     else do

  00202	eb 36		 jmp	 SHORT $LN4@lshift
$LN9@lshift:
$LN3@lshift:

; 889  :              *x1++ = *x++;

  00204	48 8b 44 24 48	 mov	 rax, QWORD PTR x1$[rsp]
  00209	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  0020e	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00210	89 08		 mov	 DWORD PTR [rax], ecx
  00212	48 8b 44 24 48	 mov	 rax, QWORD PTR x1$[rsp]
  00217	48 83 c0 04	 add	 rax, 4
  0021b	48 89 44 24 48	 mov	 QWORD PTR x1$[rsp], rax
  00220	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  00225	48 83 c0 04	 add	 rax, 4
  00229	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 890  :         while(x < xe);

  0022e	48 8b 44 24 38	 mov	 rax, QWORD PTR xe$[rsp]
  00233	48 39 44 24 20	 cmp	 QWORD PTR x$[rsp], rax
  00238	72 ca		 jb	 SHORT $LN3@lshift
$LN4@lshift:

; 891  :     b1->wds = n1 - 1;

  0023a	8b 44 24 30	 mov	 eax, DWORD PTR n1$[rsp]
  0023e	ff c8		 dec	 eax
  00240	48 8b 4c 24 58	 mov	 rcx, QWORD PTR b1$[rsp]
  00245	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 892  :     Bfree(b);

  00248	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00250	e8 00 00 00 00	 call	 Bfree

; 893  :     return b1;

  00255	48 8b 44 24 58	 mov	 rax, QWORD PTR b1$[rsp]
$LN19@lshift:

; 894  : }

  0025a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0025e	c3		 ret	 0
lshift	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@JJPKIPG@cmp?5called?5with?5b?9?$DOx?$FLb?9?$DOwds?91?$FN?5?$DN@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0CE@LHELIPEF@cmp?5called?5with?5a?9?$DOx?$FLa?9?$DOwds?91?$FN?5?$DN@ ; `string'
EXTRN	__imp_exit:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmp DD	imagerel cmp
	DD	imagerel cmp+385
	DD	imagerel $unwind$cmp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmp DD	010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0CE@JJPKIPG@cmp?5called?5with?5b?9?$DOx?$FLb?9?$DOwds?91?$FN?5?$DN@
CONST	SEGMENT
??_C@_0CE@JJPKIPG@cmp?5called?5with?5b?9?$DOx?$FLb?9?$DOwds?91?$FN?5?$DN@ DB 'c'
	DB	'mp called with b->x[b->wds-1] == 0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LHELIPEF@cmp?5called?5with?5a?9?$DOx?$FLa?9?$DOwds?91?$FN?5?$DN@
CONST	SEGMENT
??_C@_0CE@LHELIPEF@cmp?5called?5with?5a?9?$DOx?$FLa?9?$DOwds?91?$FN?5?$DN@ DB 'c'
	DB	'mp called with a->x[a->wds-1] == 0', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cmp
_TEXT	SEGMENT
i$ = 32
xa0$ = 40
xb$ = 48
xa$ = 56
j$ = 64
xb0$ = 72
tv138 = 80
a$ = 112
b$ = 120
cmp	PROC						; COMDAT

; 901  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 902  :     ULong *xa, *xa0, *xb, *xb0;
; 903  :     int i, j;
; 904  : 
; 905  :     i = a->wds;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00013	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00016	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 906  :     j = b->wds;

  0001a	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  0001f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00022	89 44 24 40	 mov	 DWORD PTR j$[rsp], eax

; 907  : #ifdef DEBUG
; 908  :     if (i > 1 && !a->x[i-1])

  00026	83 7c 24 20 01	 cmp	 DWORD PTR i$[rsp], 1
  0002b	7e 40		 jle	 SHORT $LN7@cmp
  0002d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00031	ff c8		 dec	 eax
  00033	48 98		 cdqe
  00035	48 8b 4c 24 70	 mov	 rcx, QWORD PTR a$[rsp]
  0003a	83 7c 81 18 00	 cmp	 DWORD PTR [rcx+rax*4+24], 0
  0003f	75 2c		 jne	 SHORT $LN7@cmp

; 909  :         Bug("cmp called with a->x[a->wds-1] == 0");

  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00047	48 83 c0 60	 add	 rax, 96			; 00000060H
  0004b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CE@LHELIPEF@cmp?5called?5with?5a?9?$DOx?$FLa?9?$DOwds?91?$FN?5?$DN@
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6?$AA@
  00059	48 8b c8	 mov	 rcx, rax
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
  00062	b9 01 00 00 00	 mov	 ecx, 1
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN7@cmp:

; 910  :     if (j > 1 && !b->x[j-1])

  0006d	83 7c 24 40 01	 cmp	 DWORD PTR j$[rsp], 1
  00072	7e 40		 jle	 SHORT $LN6@cmp
  00074	8b 44 24 40	 mov	 eax, DWORD PTR j$[rsp]
  00078	ff c8		 dec	 eax
  0007a	48 98		 cdqe
  0007c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  00081	83 7c 81 18 00	 cmp	 DWORD PTR [rcx+rax*4+24], 0
  00086	75 2c		 jne	 SHORT $LN6@cmp

; 911  :         Bug("cmp called with b->x[b->wds-1] == 0");

  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0008e	48 83 c0 60	 add	 rax, 96			; 00000060H
  00092	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CE@JJPKIPG@cmp?5called?5with?5b?9?$DOx?$FLb?9?$DOwds?91?$FN?5?$DN@
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6?$AA@
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
  000a9	b9 01 00 00 00	 mov	 ecx, 1
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN6@cmp:

; 912  : #endif
; 913  :     if (i -= j)

  000b4	8b 44 24 40	 mov	 eax, DWORD PTR j$[rsp]
  000b8	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000bc	2b c8		 sub	 ecx, eax
  000be	8b c1		 mov	 eax, ecx
  000c0	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  000c4	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  000c9	74 09		 je	 SHORT $LN5@cmp

; 914  :         return i;

  000cb	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000cf	e9 a8 00 00 00	 jmp	 $LN8@cmp
$LN5@cmp:

; 915  :     xa0 = a->x;

  000d4	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  000d9	48 83 c0 18	 add	 rax, 24
  000dd	48 89 44 24 28	 mov	 QWORD PTR xa0$[rsp], rax

; 916  :     xa = xa0 + j;

  000e2	48 63 44 24 40	 movsxd	 rax, DWORD PTR j$[rsp]
  000e7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xa0$[rsp]
  000ec	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000f0	48 89 44 24 38	 mov	 QWORD PTR xa$[rsp], rax

; 917  :     xb0 = b->x;

  000f5	48 8b 44 24 78	 mov	 rax, QWORD PTR b$[rsp]
  000fa	48 83 c0 18	 add	 rax, 24
  000fe	48 89 44 24 48	 mov	 QWORD PTR xb0$[rsp], rax

; 918  :     xb = xb0 + j;

  00103	48 63 44 24 40	 movsxd	 rax, DWORD PTR j$[rsp]
  00108	48 8b 4c 24 48	 mov	 rcx, QWORD PTR xb0$[rsp]
  0010d	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00111	48 89 44 24 30	 mov	 QWORD PTR xb$[rsp], rax
$LN4@cmp:

; 919  :     for(;;) {
; 920  :         if (*--xa != *--xb)

  00116	48 8b 44 24 38	 mov	 rax, QWORD PTR xa$[rsp]
  0011b	48 83 e8 04	 sub	 rax, 4
  0011f	48 89 44 24 38	 mov	 QWORD PTR xa$[rsp], rax
  00124	48 8b 44 24 30	 mov	 rax, QWORD PTR xb$[rsp]
  00129	48 83 e8 04	 sub	 rax, 4
  0012d	48 89 44 24 30	 mov	 QWORD PTR xb$[rsp], rax
  00132	48 8b 44 24 38	 mov	 rax, QWORD PTR xa$[rsp]
  00137	48 8b 4c 24 30	 mov	 rcx, QWORD PTR xb$[rsp]
  0013c	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0013e	39 08		 cmp	 DWORD PTR [rax], ecx
  00140	74 28		 je	 SHORT $LN2@cmp

; 921  :             return *xa < *xb ? -1 : 1;

  00142	48 8b 44 24 38	 mov	 rax, QWORD PTR xa$[rsp]
  00147	48 8b 4c 24 30	 mov	 rcx, QWORD PTR xb$[rsp]
  0014c	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0014e	39 08		 cmp	 DWORD PTR [rax], ecx
  00150	73 0a		 jae	 SHORT $LN10@cmp
  00152	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR tv138[rsp], -1
  0015a	eb 08		 jmp	 SHORT $LN11@cmp
$LN10@cmp:
  0015c	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
$LN11@cmp:
  00164	8b 44 24 50	 mov	 eax, DWORD PTR tv138[rsp]
  00168	eb 12		 jmp	 SHORT $LN8@cmp
$LN2@cmp:

; 922  :         if (xa <= xa0)

  0016a	48 8b 44 24 28	 mov	 rax, QWORD PTR xa0$[rsp]
  0016f	48 39 44 24 38	 cmp	 QWORD PTR xa$[rsp], rax
  00174	77 02		 ja	 SHORT $LN1@cmp

; 923  :             break;

  00176	eb 02		 jmp	 SHORT $LN3@cmp
$LN1@cmp:

; 924  :     }

  00178	eb 9c		 jmp	 SHORT $LN4@cmp
$LN3@cmp:

; 925  :     return 0;

  0017a	33 c0		 xor	 eax, eax
$LN8@cmp:
$LN9@cmp:

; 926  : }

  0017c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00180	c3		 ret	 0
cmp	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$diff DD	imagerel diff
	DD	imagerel diff+633
	DD	imagerel $unwind$diff
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$diff DD	021101H
	DD	0110111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT diff
_TEXT	SEGMENT
y$ = 32
i$ = 40
xbe$ = 48
xb$ = 56
xa$ = 64
wa$ = 72
borrow$ = 80
xc$ = 88
xae$ = 96
wb$ = 104
c$ = 112
a$ = 144
b$ = 152
diff	PROC						; COMDAT

; 934  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 935  :     Bigint *c;
; 936  :     int i, wa, wb;
; 937  :     ULong *xa, *xae, *xb, *xbe, *xc;
; 938  : #ifdef ULLong
; 939  :     ULLong borrow, y;
; 940  : #else
; 941  :     ULong borrow, y;
; 942  :     ULong z;
; 943  : #endif
; 944  : 
; 945  :     i = cmp(a,b);

  00011	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00021	e8 00 00 00 00	 call	 cmp
  00026	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax

; 946  :     if (!i) {

  0002a	83 7c 24 28 00	 cmp	 DWORD PTR i$[rsp], 0
  0002f	75 3d		 jne	 SHORT $LN12@diff

; 947  :         c = Balloc(0);

  00031	33 c9		 xor	 ecx, ecx
  00033	e8 00 00 00 00	 call	 Balloc
  00038	48 89 44 24 70	 mov	 QWORD PTR c$[rsp], rax

; 948  :         if (c == NULL)

  0003d	48 83 7c 24 70
	00		 cmp	 QWORD PTR c$[rsp], 0
  00043	75 07		 jne	 SHORT $LN11@diff

; 949  :             return NULL;

  00045	33 c0		 xor	 eax, eax
  00047	e9 25 02 00 00	 jmp	 $LN13@diff
$LN11@diff:

; 950  :         c->wds = 1;

  0004c	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00051	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 951  :         c->x[0] = 0;

  00058	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0005d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 952  :         return c;

  00064	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00069	e9 03 02 00 00	 jmp	 $LN13@diff
$LN12@diff:

; 953  :     }
; 954  :     if (i < 0) {

  0006e	83 7c 24 28 00	 cmp	 DWORD PTR i$[rsp], 0
  00073	7d 34		 jge	 SHORT $LN10@diff

; 955  :         c = a;

  00075	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0007d	48 89 44 24 70	 mov	 QWORD PTR c$[rsp], rax

; 956  :         a = b;

  00082	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0008a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR a$[rsp], rax

; 957  :         b = c;

  00092	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00097	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 958  :         i = 1;

  0009f	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1

; 959  :     }
; 960  :     else

  000a7	eb 08		 jmp	 SHORT $LN9@diff
$LN10@diff:

; 961  :         i = 0;

  000a9	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN9@diff:

; 962  :     c = Balloc(a->k);

  000b1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000b9	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  000bc	e8 00 00 00 00	 call	 Balloc
  000c1	48 89 44 24 70	 mov	 QWORD PTR c$[rsp], rax

; 963  :     if (c == NULL)

  000c6	48 83 7c 24 70
	00		 cmp	 QWORD PTR c$[rsp], 0
  000cc	75 07		 jne	 SHORT $LN8@diff

; 964  :         return NULL;

  000ce	33 c0		 xor	 eax, eax
  000d0	e9 9c 01 00 00	 jmp	 $LN13@diff
$LN8@diff:

; 965  :     c->sign = i;

  000d5	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  000da	8b 4c 24 28	 mov	 ecx, DWORD PTR i$[rsp]
  000de	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 966  :     wa = a->wds;

  000e1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000e9	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ec	89 44 24 48	 mov	 DWORD PTR wa$[rsp], eax

; 967  :     xa = a->x;

  000f0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000f8	48 83 c0 18	 add	 rax, 24
  000fc	48 89 44 24 40	 mov	 QWORD PTR xa$[rsp], rax

; 968  :     xae = xa + wa;

  00101	48 63 44 24 48	 movsxd	 rax, DWORD PTR wa$[rsp]
  00106	48 8b 4c 24 40	 mov	 rcx, QWORD PTR xa$[rsp]
  0010b	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  0010f	48 89 44 24 60	 mov	 QWORD PTR xae$[rsp], rax

; 969  :     wb = b->wds;

  00114	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0011c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0011f	89 44 24 68	 mov	 DWORD PTR wb$[rsp], eax

; 970  :     xb = b->x;

  00123	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0012b	48 83 c0 18	 add	 rax, 24
  0012f	48 89 44 24 38	 mov	 QWORD PTR xb$[rsp], rax

; 971  :     xbe = xb + wb;

  00134	48 63 44 24 68	 movsxd	 rax, DWORD PTR wb$[rsp]
  00139	48 8b 4c 24 38	 mov	 rcx, QWORD PTR xb$[rsp]
  0013e	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00142	48 89 44 24 30	 mov	 QWORD PTR xbe$[rsp], rax

; 972  :     xc = c->x;

  00147	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0014c	48 83 c0 18	 add	 rax, 24
  00150	48 89 44 24 58	 mov	 QWORD PTR xc$[rsp], rax

; 973  :     borrow = 0;

  00155	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR borrow$[rsp], 0
$LN7@diff:

; 974  : #ifdef ULLong
; 975  :     do {
; 976  :         y = (ULLong)*xa++ - *xb++ - borrow;

  0015e	48 8b 44 24 40	 mov	 rax, QWORD PTR xa$[rsp]
  00163	8b 00		 mov	 eax, DWORD PTR [rax]
  00165	48 8b 4c 24 38	 mov	 rcx, QWORD PTR xb$[rsp]
  0016a	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0016c	48 2b c1	 sub	 rax, rcx
  0016f	48 2b 44 24 50	 sub	 rax, QWORD PTR borrow$[rsp]
  00174	48 89 44 24 20	 mov	 QWORD PTR y$[rsp], rax
  00179	48 8b 44 24 38	 mov	 rax, QWORD PTR xb$[rsp]
  0017e	48 83 c0 04	 add	 rax, 4
  00182	48 89 44 24 38	 mov	 QWORD PTR xb$[rsp], rax
  00187	48 8b 44 24 40	 mov	 rax, QWORD PTR xa$[rsp]
  0018c	48 83 c0 04	 add	 rax, 4
  00190	48 89 44 24 40	 mov	 QWORD PTR xa$[rsp], rax

; 977  :         borrow = y >> 32 & (ULong)1;

  00195	48 8b 44 24 20	 mov	 rax, QWORD PTR y$[rsp]
  0019a	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0019e	48 83 e0 01	 and	 rax, 1
  001a2	48 89 44 24 50	 mov	 QWORD PTR borrow$[rsp], rax

; 978  :         *xc++ = (ULong)(y & FFFFFFFF);

  001a7	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  001ac	48 8b 4c 24 20	 mov	 rcx, QWORD PTR y$[rsp]
  001b1	48 23 c8	 and	 rcx, rax
  001b4	48 8b c1	 mov	 rax, rcx
  001b7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR xc$[rsp]
  001bc	89 01		 mov	 DWORD PTR [rcx], eax
  001be	48 8b 44 24 58	 mov	 rax, QWORD PTR xc$[rsp]
  001c3	48 83 c0 04	 add	 rax, 4
  001c7	48 89 44 24 58	 mov	 QWORD PTR xc$[rsp], rax

; 979  :     }
; 980  :     while(xb < xbe);

  001cc	48 8b 44 24 30	 mov	 rax, QWORD PTR xbe$[rsp]
  001d1	48 39 44 24 38	 cmp	 QWORD PTR xb$[rsp], rax
  001d6	72 86		 jb	 SHORT $LN7@diff
$LN4@diff:

; 981  :     while(xa < xae) {

  001d8	48 8b 44 24 60	 mov	 rax, QWORD PTR xae$[rsp]
  001dd	48 39 44 24 40	 cmp	 QWORD PTR xa$[rsp], rax
  001e2	73 58		 jae	 SHORT $LN3@diff

; 982  :         y = *xa++ - borrow;

  001e4	48 8b 44 24 40	 mov	 rax, QWORD PTR xa$[rsp]
  001e9	8b 00		 mov	 eax, DWORD PTR [rax]
  001eb	48 2b 44 24 50	 sub	 rax, QWORD PTR borrow$[rsp]
  001f0	48 89 44 24 20	 mov	 QWORD PTR y$[rsp], rax
  001f5	48 8b 44 24 40	 mov	 rax, QWORD PTR xa$[rsp]
  001fa	48 83 c0 04	 add	 rax, 4
  001fe	48 89 44 24 40	 mov	 QWORD PTR xa$[rsp], rax

; 983  :         borrow = y >> 32 & (ULong)1;

  00203	48 8b 44 24 20	 mov	 rax, QWORD PTR y$[rsp]
  00208	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0020c	48 83 e0 01	 and	 rax, 1
  00210	48 89 44 24 50	 mov	 QWORD PTR borrow$[rsp], rax

; 984  :         *xc++ = (ULong)(y & FFFFFFFF);

  00215	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0021a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR y$[rsp]
  0021f	48 23 c8	 and	 rcx, rax
  00222	48 8b c1	 mov	 rax, rcx
  00225	48 8b 4c 24 58	 mov	 rcx, QWORD PTR xc$[rsp]
  0022a	89 01		 mov	 DWORD PTR [rcx], eax
  0022c	48 8b 44 24 58	 mov	 rax, QWORD PTR xc$[rsp]
  00231	48 83 c0 04	 add	 rax, 4
  00235	48 89 44 24 58	 mov	 QWORD PTR xc$[rsp], rax

; 985  :     }

  0023a	eb 9c		 jmp	 SHORT $LN4@diff
$LN3@diff:
$LN2@diff:

; 986  : #else
; 987  :     do {
; 988  :         y = (*xa & 0xffff) - (*xb & 0xffff) - borrow;
; 989  :         borrow = (y & 0x10000) >> 16;
; 990  :         z = (*xa++ >> 16) - (*xb++ >> 16) - borrow;
; 991  :         borrow = (z & 0x10000) >> 16;
; 992  :         Storeinc(xc, z, y);
; 993  :     }
; 994  :     while(xb < xbe);
; 995  :     while(xa < xae) {
; 996  :         y = (*xa & 0xffff) - borrow;
; 997  :         borrow = (y & 0x10000) >> 16;
; 998  :         z = (*xa++ >> 16) - borrow;
; 999  :         borrow = (z & 0x10000) >> 16;
; 1000 :         Storeinc(xc, z, y);
; 1001 :     }
; 1002 : #endif
; 1003 :     while(!*--xc)

  0023c	48 8b 44 24 58	 mov	 rax, QWORD PTR xc$[rsp]
  00241	48 83 e8 04	 sub	 rax, 4
  00245	48 89 44 24 58	 mov	 QWORD PTR xc$[rsp], rax
  0024a	48 8b 44 24 58	 mov	 rax, QWORD PTR xc$[rsp]
  0024f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00252	75 0c		 jne	 SHORT $LN1@diff

; 1004 :         wa--;

  00254	8b 44 24 48	 mov	 eax, DWORD PTR wa$[rsp]
  00258	ff c8		 dec	 eax
  0025a	89 44 24 48	 mov	 DWORD PTR wa$[rsp], eax
  0025e	eb dc		 jmp	 SHORT $LN2@diff
$LN1@diff:

; 1005 :     c->wds = wa;

  00260	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00265	8b 4c 24 48	 mov	 ecx, DWORD PTR wa$[rsp]
  00269	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 1006 :     return c;

  0026c	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
$LN13@diff:

; 1007 : }

  00271	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00278	c3		 ret	 0
diff	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ulp DD	imagerel ulp
	DD	imagerel ulp+56
	DD	imagerel $unwind$ulp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ulp DD	010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ulp
_TEXT	SEGMENT
u$ = 0
L$ = 8
x$ = 32
ulp	PROC						; COMDAT

; 1014 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1015 :     Long L;
; 1016 :     U u;
; 1017 : 
; 1018 :     L = (word0(x) & Exp_mask) - (P-1)*Exp_msk1;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  0000e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00011	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00016	2d 00 00 40 03	 sub	 eax, 54525952		; 03400000H
  0001b	89 44 24 08	 mov	 DWORD PTR L$[rsp], eax

; 1019 :     word0(&u) = L;

  0001f	8b 44 24 08	 mov	 eax, DWORD PTR L$[rsp]
  00023	89 44 24 04	 mov	 DWORD PTR u$[rsp+4], eax

; 1020 :     word1(&u) = 0;

  00027	c7 04 24 00 00
	00 00		 mov	 DWORD PTR u$[rsp], 0

; 1021 :     return dval(&u);

  0002e	f2 0f 10 04 24	 movsdx	 xmm0, QWORD PTR u$[rsp]

; 1022 : }

  00033	48 83 c4 18	 add	 rsp, 24
  00037	c3		 ret	 0
ulp	ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DK@PLLKEGNK@?$AAb?$AA?9?$AA?$DO?$AAx?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AA?$CI?$AA3?$AA2?$AA?5?$AA?9?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@BGAOAFHM@?$AAb?$AA?9?$AA?$DO?$AAx?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@LEBJIFOE@?$AA0?$AA?5?$AA?$DM?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AA?5?$AA?9?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@KIKCLEHO@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAd?$AAt?$AAo?$AAa?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$sd2b DD	imagerel sd2b
	DD	imagerel sd2b+601
	DD	imagerel $unwind$sd2b
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sd2b DD	011201H
	DD	08212H
xdata	ENDS
;	COMDAT ??_C@_1DK@PLLKEGNK@?$AAb?$AA?9?$AA?$DO?$AAx?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AA?$CI?$AA3?$AA2?$AA?5?$AA?9?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@PLLKEGNK@?$AAb?$AA?9?$AA?$DO?$AAx?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AA?$CI?$AA3?$AA2?$AA?5?$AA?9?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'b'
	DB	00H, '-', 00H, '>', 00H, 'x', 00H, '[', 00H, '0', 00H, ']', 00H
	DB	' ', 00H, '<', 00H, '<', 00H, ' ', 00H, '(', 00H, '3', 00H, '2'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, 's', 00H, 'c', 00H, 'a', 00H
	DB	'l', 00H, 'e', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@BGAOAFHM@?$AAb?$AA?9?$AA?$DO?$AAx?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@BGAOAFHM@?$AAb?$AA?9?$AA?$DO?$AAx?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'b'
	DB	00H, '-', 00H, '>', 00H, 'x', 00H, '[', 00H, '0', 00H, ']', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@LEBJIFOE@?$AA0?$AA?5?$AA?$DM?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AA?5?$AA?9?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@LEBJIFOE@?$AA0?$AA?5?$AA?$DM?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AA?5?$AA?9?$AA?5?$AA1?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 's', 00H, 'c', 00H, 'a', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 's'
	DB	00H, 'c', 00H, 'a', 00H, 'l', 00H, 'e', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, 'P', 00H, ' ', 00H, '-', 00H, ' ', 00H, '1'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@KIKCLEHO@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAd?$AAt?$AAo?$AAa?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@KIKCLEHO@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAd?$AAt?$AAo?$AAa?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'y', 00H, 't', 00H, 'h', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'd', 00H, 't', 00H, 'o', 00H, 'a'
	DB	00H, '.', 00H, 'c', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT sd2b
_TEXT	SEGMENT
b$ = 32
tv221 = 40
tv225 = 48
tv235 = 56
d$ = 80
scale$ = 88
e$ = 96
sd2b	PROC						; COMDAT

; 1084 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1085 :     Bigint *b;
; 1086 : 
; 1087 :     b = Balloc(1);

  00012	b9 01 00 00 00	 mov	 ecx, 1
  00017	e8 00 00 00 00	 call	 Balloc
  0001c	48 89 44 24 20	 mov	 QWORD PTR b$[rsp], rax

; 1088 :     if (b == NULL)

  00021	48 83 7c 24 20
	00		 cmp	 QWORD PTR b$[rsp], 0
  00027	75 07		 jne	 SHORT $LN9@sd2b

; 1089 :         return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	e9 24 02 00 00	 jmp	 $LN10@sd2b
$LN9@sd2b:

; 1090 :     
; 1091 :     /* First construct b and e assuming that scale == 0. */
; 1092 :     b->wds = 2;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  00035	c7 40 14 02 00
	00 00		 mov	 DWORD PTR [rax+20], 2

; 1093 :     b->x[0] = word1(d);

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  00041	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d$[rsp]
  00046	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00048	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 1094 :     b->x[1] = word0(d) & Frac_mask;

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR d$[rsp]
  00050	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00053	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  0005d	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1095 :     *e = Etiny - 1 + (int)((word0(d) & Exp_mask) >> Exp_shift);

  00060	48 8b 44 24 50	 mov	 rax, QWORD PTR d$[rsp]
  00065	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00068	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  0006d	c1 e8 14	 shr	 eax, 20
  00070	2d 33 04 00 00	 sub	 eax, 1075		; 00000433H
  00075	48 8b 4c 24 60	 mov	 rcx, QWORD PTR e$[rsp]
  0007a	89 01		 mov	 DWORD PTR [rcx], eax

; 1096 :     if (*e < Etiny)

  0007c	48 8b 44 24 60	 mov	 rax, QWORD PTR e$[rsp]
  00081	81 38 ce fb ff
	ff		 cmp	 DWORD PTR [rax], -1074	; fffffffffffffbceH
  00087	7d 0d		 jge	 SHORT $LN8@sd2b

; 1097 :         *e = Etiny;

  00089	48 8b 44 24 60	 mov	 rax, QWORD PTR e$[rsp]
  0008e	c7 00 ce fb ff
	ff		 mov	 DWORD PTR [rax], -1074	; fffffffffffffbceH

; 1098 :     else

  00094	eb 14		 jmp	 SHORT $LN7@sd2b
$LN8@sd2b:

; 1099 :         b->x[1] |= Exp_msk1;

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  0009b	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0009e	0f ba e8 14	 bts	 eax, 20
  000a2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  000a7	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
$LN7@sd2b:

; 1100 : 
; 1101 :     /* Now adjust for scale, provided that b != 0. */
; 1102 :     if (scale && (b->x[0] || b->x[1])) {

  000aa	83 7c 24 58 00	 cmp	 DWORD PTR scale$[rsp], 0
  000af	0f 84 83 01 00
	00		 je	 $LN6@sd2b
  000b5	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  000ba	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  000be	75 0f		 jne	 SHORT $LN5@sd2b
  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  000c5	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  000c9	0f 84 69 01 00
	00		 je	 $LN6@sd2b
$LN5@sd2b:

; 1103 :         *e -= scale;

  000cf	48 8b 44 24 60	 mov	 rax, QWORD PTR e$[rsp]
  000d4	8b 4c 24 58	 mov	 ecx, DWORD PTR scale$[rsp]
  000d8	8b 00		 mov	 eax, DWORD PTR [rax]
  000da	2b c1		 sub	 eax, ecx
  000dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR e$[rsp]
  000e1	89 01		 mov	 DWORD PTR [rcx], eax

; 1104 :         if (*e < Etiny) {

  000e3	48 8b 44 24 60	 mov	 rax, QWORD PTR e$[rsp]
  000e8	81 38 ce fb ff
	ff		 cmp	 DWORD PTR [rax], -1074	; fffffffffffffbceH
  000ee	0f 8d 44 01 00
	00		 jge	 $LN4@sd2b

; 1105 :             scale = Etiny - *e;

  000f4	48 8b 44 24 60	 mov	 rax, QWORD PTR e$[rsp]
  000f9	b9 ce fb ff ff	 mov	 ecx, -1074		; fffffffffffffbceH
  000fe	2b 08		 sub	 ecx, DWORD PTR [rax]
  00100	8b c1		 mov	 eax, ecx
  00102	89 44 24 58	 mov	 DWORD PTR scale$[rsp], eax

; 1106 :             *e = Etiny;

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR e$[rsp]
  0010b	c7 00 ce fb ff
	ff		 mov	 DWORD PTR [rax], -1074	; fffffffffffffbceH

; 1107 :             /* We can't shift more than P-1 bits without shifting out a 1. */
; 1108 :             assert(0 < scale && scale <= P - 1);

  00111	83 7c 24 58 00	 cmp	 DWORD PTR scale$[rsp], 0
  00116	7e 07		 jle	 SHORT $LN12@sd2b
  00118	83 7c 24 58 34	 cmp	 DWORD PTR scale$[rsp], 52 ; 00000034H
  0011d	7e 1c		 jle	 SHORT $LN13@sd2b
$LN12@sd2b:
  0011f	41 b8 54 04 00
	00		 mov	 r8d, 1108		; 00000454H
  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@KIKCLEHO@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAd?$AAt?$AAo?$AAa?$AA?4?$AAc?$AA?$AA@
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@LEBJIFOE@?$AA0?$AA?5?$AA?$DM?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AA?5?$AA?9?$AA?5?$AA1?$AA?$AA@
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00139	33 c0		 xor	 eax, eax
$LN13@sd2b:

; 1109 :             if (scale >= 32) {

  0013b	83 7c 24 58 20	 cmp	 DWORD PTR scale$[rsp], 32 ; 00000020H
  00140	7c 4e		 jl	 SHORT $LN3@sd2b

; 1110 :                 /* The bits shifted out should all be zero. */
; 1111 :                 assert(b->x[0] == 0);

  00142	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  00147	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0014b	74 1c		 je	 SHORT $LN14@sd2b
  0014d	41 b8 57 04 00
	00		 mov	 r8d, 1111		; 00000457H
  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@KIKCLEHO@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAd?$AAt?$AAo?$AAa?$AA?4?$AAc?$AA?$AA@
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@BGAOAFHM@?$AAb?$AA?9?$AA?$DO?$AAx?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00161	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00167	33 c0		 xor	 eax, eax
$LN14@sd2b:

; 1112 :                 b->x[0] = b->x[1];

  00169	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  0016e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  00173	8b 49 1c	 mov	 ecx, DWORD PTR [rcx+28]
  00176	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 1113 :                 b->x[1] = 0;

  00179	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  0017e	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 1114 :                 scale -= 32;

  00185	8b 44 24 58	 mov	 eax, DWORD PTR scale$[rsp]
  00189	83 e8 20	 sub	 eax, 32			; 00000020H
  0018c	89 44 24 58	 mov	 DWORD PTR scale$[rsp], eax
$LN3@sd2b:

; 1115 :             }
; 1116 :             if (scale) {

  00190	83 7c 24 58 00	 cmp	 DWORD PTR scale$[rsp], 0
  00195	0f 84 9d 00 00
	00		 je	 $LN2@sd2b

; 1117 :                 /* The bits shifted out should all be zero. */
; 1118 :                 assert(b->x[0] << (32 - scale) == 0);

  0019b	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  001a0	2b 44 24 58	 sub	 eax, DWORD PTR scale$[rsp]
  001a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  001a9	48 89 4c 24 28	 mov	 QWORD PTR tv221[rsp], rcx
  001ae	0f b6 c8	 movzx	 ecx, al
  001b1	48 8b 44 24 28	 mov	 rax, QWORD PTR tv221[rsp]
  001b6	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001b9	d3 e0		 shl	 eax, cl
  001bb	85 c0		 test	 eax, eax
  001bd	74 1c		 je	 SHORT $LN15@sd2b
  001bf	41 b8 5e 04 00
	00		 mov	 r8d, 1118		; 0000045eH
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@KIKCLEHO@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAd?$AAt?$AAo?$AAa?$AA?4?$AAc?$AA?$AA@
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@PLLKEGNK@?$AAb?$AA?9?$AA?$DO?$AAx?$AA?$FL?$AA0?$AA?$FN?$AA?5?$AA?$DM?$AA?$DM?$AA?5?$AA?$CI?$AA3?$AA2?$AA?5?$AA?9?$AA?5?$AAs?$AAc?$AAa?$AAl?$AAe?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d9	33 c0		 xor	 eax, eax
$LN15@sd2b:

; 1119 :                 b->x[0] = (b->x[0] >> scale) | (b->x[1] << (32 - scale));

  001db	8b 44 24 58	 mov	 eax, DWORD PTR scale$[rsp]
  001df	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  001e4	48 89 4c 24 30	 mov	 QWORD PTR tv225[rsp], rcx
  001e9	0f b6 c8	 movzx	 ecx, al
  001ec	48 8b 44 24 30	 mov	 rax, QWORD PTR tv225[rsp]
  001f1	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001f4	d3 e8		 shr	 eax, cl
  001f6	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001fb	2b 4c 24 58	 sub	 ecx, DWORD PTR scale$[rsp]
  001ff	48 8b 54 24 20	 mov	 rdx, QWORD PTR b$[rsp]
  00204	8b 52 1c	 mov	 edx, DWORD PTR [rdx+28]
  00207	d3 e2		 shl	 edx, cl
  00209	8b ca		 mov	 ecx, edx
  0020b	0b c1		 or	 eax, ecx
  0020d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  00212	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 1120 :                 b->x[1] >>= scale;

  00215	8b 44 24 58	 mov	 eax, DWORD PTR scale$[rsp]
  00219	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  0021e	48 89 4c 24 38	 mov	 QWORD PTR tv235[rsp], rcx
  00223	0f b6 c8	 movzx	 ecx, al
  00226	48 8b 44 24 38	 mov	 rax, QWORD PTR tv235[rsp]
  0022b	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0022e	d3 e8		 shr	 eax, cl
  00230	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  00235	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
$LN2@sd2b:
$LN4@sd2b:
$LN6@sd2b:

; 1121 :             }
; 1122 :         }
; 1123 :     }
; 1124 :     /* Ensure b is normalized. */
; 1125 :     if (!b->x[1])

  00238	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  0023d	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  00241	75 0c		 jne	 SHORT $LN1@sd2b

; 1126 :         b->wds = 1;

  00243	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  00248	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1
$LN1@sd2b:

; 1127 : 
; 1128 :     return b;

  0024f	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
$LN10@sd2b:

; 1129 : }

  00254	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00258	c3		 ret	 0
sd2b	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ratio DD	imagerel ratio
	DD	imagerel ratio+175
	DD	imagerel $unwind$ratio
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ratio DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ratio
_TEXT	SEGMENT
db$ = 32
kb$ = 40
ka$ = 44
k$ = 48
da$ = 56
a$ = 80
b$ = 88
ratio	PROC						; COMDAT

; 1190 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1191 :     U da, db;
; 1192 :     int k, ka, kb;
; 1193 : 
; 1194 :     dval(&da) = b2d(a, &ka);

  0000e	48 8d 54 24 2c	 lea	 rdx, QWORD PTR ka$[rsp]
  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00018	e8 00 00 00 00	 call	 b2d
  0001d	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR da$[rsp], xmm0

; 1195 :     dval(&db) = b2d(b, &kb);

  00023	48 8d 54 24 28	 lea	 rdx, QWORD PTR kb$[rsp]
  00028	48 8b 4c 24 58	 mov	 rcx, QWORD PTR b$[rsp]
  0002d	e8 00 00 00 00	 call	 b2d
  00032	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR db$[rsp], xmm0

; 1196 :     k = ka - kb + 32*(a->wds - b->wds);

  00038	8b 44 24 28	 mov	 eax, DWORD PTR kb$[rsp]
  0003c	8b 4c 24 2c	 mov	 ecx, DWORD PTR ka$[rsp]
  00040	2b c8		 sub	 ecx, eax
  00042	8b c1		 mov	 eax, ecx
  00044	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00049	48 8b 54 24 58	 mov	 rdx, QWORD PTR b$[rsp]
  0004e	8b 52 14	 mov	 edx, DWORD PTR [rdx+20]
  00051	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00054	2b ca		 sub	 ecx, edx
  00056	6b c9 20	 imul	 ecx, 32			; 00000020H
  00059	03 c1		 add	 eax, ecx
  0005b	89 44 24 30	 mov	 DWORD PTR k$[rsp], eax

; 1197 :     if (k > 0)

  0005f	83 7c 24 30 00	 cmp	 DWORD PTR k$[rsp], 0
  00064	7e 18		 jle	 SHORT $LN2@ratio

; 1198 :         word0(&da) += k*Exp_msk1;

  00066	8b 44 24 30	 mov	 eax, DWORD PTR k$[rsp]
  0006a	69 c0 00 00 10
	00		 imul	 eax, 1048576		; 00100000H
  00070	8b 4c 24 3c	 mov	 ecx, DWORD PTR da$[rsp+4]
  00074	03 c8		 add	 ecx, eax
  00076	8b c1		 mov	 eax, ecx
  00078	89 44 24 3c	 mov	 DWORD PTR da$[rsp+4], eax

; 1199 :     else {

  0007c	eb 20		 jmp	 SHORT $LN1@ratio
$LN2@ratio:

; 1200 :         k = -k;

  0007e	8b 44 24 30	 mov	 eax, DWORD PTR k$[rsp]
  00082	f7 d8		 neg	 eax
  00084	89 44 24 30	 mov	 DWORD PTR k$[rsp], eax

; 1201 :         word0(&db) += k*Exp_msk1;

  00088	8b 44 24 30	 mov	 eax, DWORD PTR k$[rsp]
  0008c	69 c0 00 00 10
	00		 imul	 eax, 1048576		; 00100000H
  00092	8b 4c 24 24	 mov	 ecx, DWORD PTR db$[rsp+4]
  00096	03 c8		 add	 ecx, eax
  00098	8b c1		 mov	 eax, ecx
  0009a	89 44 24 24	 mov	 DWORD PTR db$[rsp+4], eax
$LN1@ratio:

; 1202 :     }
; 1203 :     return dval(&da) / dval(&db);

  0009e	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR da$[rsp]
  000a4	f2 0f 5e 44 24
	20		 divsd	 xmm0, QWORD PTR db$[rsp]

; 1204 : }

  000aa	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ae	c3		 ret	 0
ratio	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@LOPGAHPL@zero?5y?5in?5b2d?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$b2d DD	imagerel b2d
	DD	imagerel b2d+532
	DD	imagerel $unwind$b2d
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$b2d DD	010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0O@LOPGAHPL@zero?5y?5in?5b2d?$AA@
CONST	SEGMENT
??_C@_0O@LOPGAHPL@zero?5y?5in?5b2d?$AA@ DB 'zero y in b2d', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT b2d
_TEXT	SEGMENT
w$ = 32
y$ = 36
xa0$ = 40
xa$ = 48
k$ = 56
z$ = 60
d$ = 64
tv87 = 72
tv95 = 76
tv138 = 80
a$ = 112
e$ = 120
b2d	PROC						; COMDAT

; 1028 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1029 :     ULong *xa, *xa0, w, y, z;
; 1030 :     int k;
; 1031 :     U d;
; 1032 : 
; 1033 :     xa0 = a->x;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 83 c0 18	 add	 rax, 24
  00017	48 89 44 24 28	 mov	 QWORD PTR xa0$[rsp], rax

; 1034 :     xa = xa0 + a->wds;

  0001c	48 8b 44 24 70	 mov	 rax, QWORD PTR a$[rsp]
  00021	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  00025	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xa0$[rsp]
  0002a	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  0002e	48 89 44 24 30	 mov	 QWORD PTR xa$[rsp], rax

; 1035 :     y = *--xa;

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR xa$[rsp]
  00038	48 83 e8 04	 sub	 rax, 4
  0003c	48 89 44 24 30	 mov	 QWORD PTR xa$[rsp], rax
  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR xa$[rsp]
  00046	8b 00		 mov	 eax, DWORD PTR [rax]
  00048	89 44 24 24	 mov	 DWORD PTR y$[rsp], eax

; 1036 : #ifdef DEBUG
; 1037 :     if (!y) Bug("zero y in b2d");

  0004c	83 7c 24 24 00	 cmp	 DWORD PTR y$[rsp], 0
  00051	75 2c		 jne	 SHORT $LN4@b2d
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00059	48 83 c0 60	 add	 rax, 96			; 00000060H
  0005d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@LOPGAHPL@zero?5y?5in?5b2d?$AA@
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6?$AA@
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
  00074	b9 01 00 00 00	 mov	 ecx, 1
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN4@b2d:

; 1038 : #endif
; 1039 :     k = hi0bits(y);

  0007f	8b 4c 24 24	 mov	 ecx, DWORD PTR y$[rsp]
  00083	e8 00 00 00 00	 call	 hi0bits
  00088	89 44 24 38	 mov	 DWORD PTR k$[rsp], eax

; 1040 :     *e = 32 - k;

  0008c	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00091	2b 44 24 38	 sub	 eax, DWORD PTR k$[rsp]
  00095	48 8b 4c 24 78	 mov	 rcx, QWORD PTR e$[rsp]
  0009a	89 01		 mov	 DWORD PTR [rcx], eax

; 1041 :     if (k < Ebits) {

  0009c	83 7c 24 38 0b	 cmp	 DWORD PTR k$[rsp], 11
  000a1	7d 7e		 jge	 SHORT $LN3@b2d

; 1042 :         word0(&d) = Exp_1 | y >> (Ebits - k);

  000a3	b8 0b 00 00 00	 mov	 eax, 11
  000a8	2b 44 24 38	 sub	 eax, DWORD PTR k$[rsp]
  000ac	0f b6 c8	 movzx	 ecx, al
  000af	8b 44 24 24	 mov	 eax, DWORD PTR y$[rsp]
  000b3	d3 e8		 shr	 eax, cl
  000b5	0d 00 00 f0 3f	 or	 eax, 1072693248		; 3ff00000H
  000ba	89 44 24 44	 mov	 DWORD PTR d$[rsp+4], eax

; 1043 :         w = xa > xa0 ? *--xa : 0;

  000be	48 8b 44 24 28	 mov	 rax, QWORD PTR xa0$[rsp]
  000c3	48 39 44 24 30	 cmp	 QWORD PTR xa$[rsp], rax
  000c8	76 1b		 jbe	 SHORT $LN7@b2d
  000ca	48 8b 44 24 30	 mov	 rax, QWORD PTR xa$[rsp]
  000cf	48 83 e8 04	 sub	 rax, 4
  000d3	48 89 44 24 30	 mov	 QWORD PTR xa$[rsp], rax
  000d8	48 8b 44 24 30	 mov	 rax, QWORD PTR xa$[rsp]
  000dd	8b 00		 mov	 eax, DWORD PTR [rax]
  000df	89 44 24 48	 mov	 DWORD PTR tv87[rsp], eax
  000e3	eb 08		 jmp	 SHORT $LN8@b2d
$LN7@b2d:
  000e5	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN8@b2d:
  000ed	8b 44 24 48	 mov	 eax, DWORD PTR tv87[rsp]
  000f1	89 44 24 20	 mov	 DWORD PTR w$[rsp], eax

; 1044 :         word1(&d) = y << ((32-Ebits) + k) | w >> (Ebits - k);

  000f5	8b 44 24 38	 mov	 eax, DWORD PTR k$[rsp]
  000f9	83 c0 15	 add	 eax, 21
  000fc	0f b6 c8	 movzx	 ecx, al
  000ff	8b 44 24 24	 mov	 eax, DWORD PTR y$[rsp]
  00103	d3 e0		 shl	 eax, cl
  00105	b9 0b 00 00 00	 mov	 ecx, 11
  0010a	2b 4c 24 38	 sub	 ecx, DWORD PTR k$[rsp]
  0010e	8b 54 24 20	 mov	 edx, DWORD PTR w$[rsp]
  00112	d3 ea		 shr	 edx, cl
  00114	8b ca		 mov	 ecx, edx
  00116	0b c1		 or	 eax, ecx
  00118	89 44 24 40	 mov	 DWORD PTR d$[rsp], eax

; 1045 :         goto ret_d;

  0011c	e9 e8 00 00 00	 jmp	 $ret_d$20681
$LN3@b2d:

; 1046 :     }
; 1047 :     z = xa > xa0 ? *--xa : 0;

  00121	48 8b 44 24 28	 mov	 rax, QWORD PTR xa0$[rsp]
  00126	48 39 44 24 30	 cmp	 QWORD PTR xa$[rsp], rax
  0012b	76 1b		 jbe	 SHORT $LN9@b2d
  0012d	48 8b 44 24 30	 mov	 rax, QWORD PTR xa$[rsp]
  00132	48 83 e8 04	 sub	 rax, 4
  00136	48 89 44 24 30	 mov	 QWORD PTR xa$[rsp], rax
  0013b	48 8b 44 24 30	 mov	 rax, QWORD PTR xa$[rsp]
  00140	8b 00		 mov	 eax, DWORD PTR [rax]
  00142	89 44 24 4c	 mov	 DWORD PTR tv95[rsp], eax
  00146	eb 08		 jmp	 SHORT $LN10@b2d
$LN9@b2d:
  00148	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN10@b2d:
  00150	8b 44 24 4c	 mov	 eax, DWORD PTR tv95[rsp]
  00154	89 44 24 3c	 mov	 DWORD PTR z$[rsp], eax

; 1048 :     if (k -= Ebits) {

  00158	8b 44 24 38	 mov	 eax, DWORD PTR k$[rsp]
  0015c	83 e8 0b	 sub	 eax, 11
  0015f	89 44 24 38	 mov	 DWORD PTR k$[rsp], eax
  00163	83 7c 24 38 00	 cmp	 DWORD PTR k$[rsp], 0
  00168	0f 84 86 00 00
	00		 je	 $LN2@b2d

; 1049 :         word0(&d) = Exp_1 | y << k | z >> (32 - k);

  0016e	8b 44 24 38	 mov	 eax, DWORD PTR k$[rsp]
  00172	0f b6 c8	 movzx	 ecx, al
  00175	8b 44 24 24	 mov	 eax, DWORD PTR y$[rsp]
  00179	d3 e0		 shl	 eax, cl
  0017b	0d 00 00 f0 3f	 or	 eax, 1072693248		; 3ff00000H
  00180	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00185	2b 4c 24 38	 sub	 ecx, DWORD PTR k$[rsp]
  00189	8b 54 24 3c	 mov	 edx, DWORD PTR z$[rsp]
  0018d	d3 ea		 shr	 edx, cl
  0018f	8b ca		 mov	 ecx, edx
  00191	0b c1		 or	 eax, ecx
  00193	89 44 24 44	 mov	 DWORD PTR d$[rsp+4], eax

; 1050 :         y = xa > xa0 ? *--xa : 0;

  00197	48 8b 44 24 28	 mov	 rax, QWORD PTR xa0$[rsp]
  0019c	48 39 44 24 30	 cmp	 QWORD PTR xa$[rsp], rax
  001a1	76 1b		 jbe	 SHORT $LN11@b2d
  001a3	48 8b 44 24 30	 mov	 rax, QWORD PTR xa$[rsp]
  001a8	48 83 e8 04	 sub	 rax, 4
  001ac	48 89 44 24 30	 mov	 QWORD PTR xa$[rsp], rax
  001b1	48 8b 44 24 30	 mov	 rax, QWORD PTR xa$[rsp]
  001b6	8b 00		 mov	 eax, DWORD PTR [rax]
  001b8	89 44 24 50	 mov	 DWORD PTR tv138[rsp], eax
  001bc	eb 08		 jmp	 SHORT $LN12@b2d
$LN11@b2d:
  001be	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN12@b2d:
  001c6	8b 44 24 50	 mov	 eax, DWORD PTR tv138[rsp]
  001ca	89 44 24 24	 mov	 DWORD PTR y$[rsp], eax

; 1051 :         word1(&d) = z << k | y >> (32 - k);

  001ce	8b 44 24 38	 mov	 eax, DWORD PTR k$[rsp]
  001d2	0f b6 c8	 movzx	 ecx, al
  001d5	8b 44 24 3c	 mov	 eax, DWORD PTR z$[rsp]
  001d9	d3 e0		 shl	 eax, cl
  001db	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001e0	2b 4c 24 38	 sub	 ecx, DWORD PTR k$[rsp]
  001e4	8b 54 24 24	 mov	 edx, DWORD PTR y$[rsp]
  001e8	d3 ea		 shr	 edx, cl
  001ea	8b ca		 mov	 ecx, edx
  001ec	0b c1		 or	 eax, ecx
  001ee	89 44 24 40	 mov	 DWORD PTR d$[rsp], eax

; 1052 :     }
; 1053 :     else {

  001f2	eb 15		 jmp	 SHORT $LN1@b2d
$LN2@b2d:

; 1054 :         word0(&d) = Exp_1 | y;

  001f4	8b 44 24 24	 mov	 eax, DWORD PTR y$[rsp]
  001f8	0d 00 00 f0 3f	 or	 eax, 1072693248		; 3ff00000H
  001fd	89 44 24 44	 mov	 DWORD PTR d$[rsp+4], eax

; 1055 :         word1(&d) = z;

  00201	8b 44 24 3c	 mov	 eax, DWORD PTR z$[rsp]
  00205	89 44 24 40	 mov	 DWORD PTR d$[rsp], eax
$LN1@b2d:
$ret_d$20681:

; 1056 :     }
; 1057 :   ret_d:
; 1058 :     return dval(&d);

  00209	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR d$[rsp]
$LN6@b2d:

; 1059 : }

  0020f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00213	c3		 ret	 0
b2d	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$hi0bits DD imagerel hi0bits
	DD	imagerel hi0bits+194
	DD	imagerel $unwind$hi0bits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hi0bits DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hi0bits
_TEXT	SEGMENT
k$ = 0
x$ = 32
hi0bits	PROC						; COMDAT

; 547  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 548  :     int k = 0;

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR k$[rsp], 0

; 549  : 
; 550  :     if (!(x & 0xffff0000)) {

  0000f	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00013	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  00018	85 c0		 test	 eax, eax
  0001a	75 12		 jne	 SHORT $LN6@hi0bits

; 551  :         k = 16;

  0001c	c7 04 24 10 00
	00 00		 mov	 DWORD PTR k$[rsp], 16

; 552  :         x <<= 16;

  00023	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00027	c1 e0 10	 shl	 eax, 16
  0002a	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
$LN6@hi0bits:

; 553  :     }
; 554  :     if (!(x & 0xff000000)) {

  0002e	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00032	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00037	85 c0		 test	 eax, eax
  00039	75 14		 jne	 SHORT $LN5@hi0bits

; 555  :         k += 8;

  0003b	8b 04 24	 mov	 eax, DWORD PTR k$[rsp]
  0003e	83 c0 08	 add	 eax, 8
  00041	89 04 24	 mov	 DWORD PTR k$[rsp], eax

; 556  :         x <<= 8;

  00044	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00048	c1 e0 08	 shl	 eax, 8
  0004b	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
$LN5@hi0bits:

; 557  :     }
; 558  :     if (!(x & 0xf0000000)) {

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00053	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  00058	85 c0		 test	 eax, eax
  0005a	75 14		 jne	 SHORT $LN4@hi0bits

; 559  :         k += 4;

  0005c	8b 04 24	 mov	 eax, DWORD PTR k$[rsp]
  0005f	83 c0 04	 add	 eax, 4
  00062	89 04 24	 mov	 DWORD PTR k$[rsp], eax

; 560  :         x <<= 4;

  00065	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00069	c1 e0 04	 shl	 eax, 4
  0006c	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
$LN4@hi0bits:

; 561  :     }
; 562  :     if (!(x & 0xc0000000)) {

  00070	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00074	25 00 00 00 c0	 and	 eax, -1073741824	; c0000000H
  00079	85 c0		 test	 eax, eax
  0007b	75 14		 jne	 SHORT $LN3@hi0bits

; 563  :         k += 2;

  0007d	8b 04 24	 mov	 eax, DWORD PTR k$[rsp]
  00080	83 c0 02	 add	 eax, 2
  00083	89 04 24	 mov	 DWORD PTR k$[rsp], eax

; 564  :         x <<= 2;

  00086	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  0008a	c1 e0 02	 shl	 eax, 2
  0008d	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
$LN3@hi0bits:

; 565  :     }
; 566  :     if (!(x & 0x80000000)) {

  00091	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00095	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0009a	85 c0		 test	 eax, eax
  0009c	75 1c		 jne	 SHORT $LN2@hi0bits

; 567  :         k++;

  0009e	8b 04 24	 mov	 eax, DWORD PTR k$[rsp]
  000a1	ff c0		 inc	 eax
  000a3	89 04 24	 mov	 DWORD PTR k$[rsp], eax

; 568  :         if (!(x & 0x40000000))

  000a6	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  000aa	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  000af	85 c0		 test	 eax, eax
  000b1	75 07		 jne	 SHORT $LN1@hi0bits

; 569  :             return 32;

  000b3	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000b8	eb 03		 jmp	 SHORT $LN7@hi0bits
$LN1@hi0bits:
$LN2@hi0bits:

; 570  :     }
; 571  :     return k;

  000ba	8b 04 24	 mov	 eax, DWORD PTR k$[rsp]
$LN7@hi0bits:

; 572  : }

  000bd	48 83 c4 18	 add	 rsp, 24
  000c1	c3		 ret	 0
hi0bits	ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@JLIEBIJG@?$AAw?$AAo?$AAr?$AAd?$AA0?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAw?$AAo?$AAr?$AAd?$AA1?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$sulp DD	imagerel sulp
	DD	imagerel sulp+136
	DD	imagerel $unwind$sulp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sulp DD	010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1CK@JLIEBIJG@?$AAw?$AAo?$AAr?$AAd?$AA0?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAw?$AAo?$AAr?$AAd?$AA1?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@JLIEBIJG@?$AAw?$AAo?$AAr?$AAd?$AA0?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAw?$AAo?$AAr?$AAd?$AA1?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ DB 'w'
	DB	00H, 'o', 00H, 'r', 00H, 'd', 00H, '0', 00H, '(', 00H, 'x', 00H
	DB	')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'w', 00H, 'o'
	DB	00H, 'r', 00H, 'd', 00H, '1', 00H, '(', 00H, 'x', 00H, ')', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT sulp
_TEXT	SEGMENT
u$ = 32
x$ = 64
bc$ = 72
sulp	PROC						; COMDAT

; 1345 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1346 :     U u;
; 1347 : 
; 1348 :     if (bc->scale && 2*P + 1 > (int)((word0(x) & Exp_mask) >> Exp_shift)) {

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR bc$[rsp]
  00013	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  00017	74 2f		 je	 SHORT $LN2@sulp
  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR x$[rsp]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00021	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00026	c1 e8 14	 shr	 eax, 20
  00029	83 f8 6b	 cmp	 eax, 107		; 0000006bH
  0002c	7d 1a		 jge	 SHORT $LN2@sulp

; 1349 :         /* rv/2^bc->scale is subnormal */
; 1350 :         word0(&u) = (P+2)*Exp_msk1;

  0002e	c7 44 24 24 00
	00 70 03	 mov	 DWORD PTR u$[rsp+4], 57671680 ; 03700000H

; 1351 :         word1(&u) = 0;

  00036	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR u$[rsp], 0

; 1352 :         return u.d;

  0003e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00044	eb 3d		 jmp	 SHORT $LN3@sulp

; 1353 :     }
; 1354 :     else {

  00046	eb 3b		 jmp	 SHORT $LN1@sulp
$LN2@sulp:

; 1355 :         assert(word0(x) || word1(x)); /* x != 0.0 */

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR x$[rsp]
  0004d	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00051	75 26		 jne	 SHORT $LN5@sulp
  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR x$[rsp]
  00058	83 38 00	 cmp	 DWORD PTR [rax], 0
  0005b	75 1c		 jne	 SHORT $LN5@sulp
  0005d	41 b8 4b 05 00
	00		 mov	 r8d, 1355		; 0000054bH
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@KIKCLEHO@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAd?$AAt?$AAo?$AAa?$AA?4?$AAc?$AA?$AA@
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JLIEBIJG@?$AAw?$AAo?$AAr?$AAd?$AA0?$AA?$CI?$AAx?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAw?$AAo?$AAr?$AAd?$AA1?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00077	33 c0		 xor	 eax, eax
$LN5@sulp:

; 1356 :         return ulp(x);

  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR x$[rsp]
  0007e	e8 00 00 00 00	 call	 ulp
$LN1@sulp:
$LN3@sulp:

; 1357 :     }
; 1358 : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
sulp	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bigcomp DD imagerel bigcomp
	DD	imagerel bigcomp+956
	DD	imagerel $unwind$bigcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bigcomp DD 011301H
	DD	0e213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bigcomp
_TEXT	SEGMENT
nd$ = 32
i$ = 36
odd$ = 40
p2$ = 44
b2$ = 48
d2$ = 52
dd$ = 56
b$ = 64
nd0$ = 72
p5$ = 76
d$ = 80
tv166 = 88
tv170 = 92
tv183 = 96
rv$ = 128
s0$ = 136
bc$ = 144
bigcomp	PROC						; COMDAT

; 1408 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1409 :     Bigint *b, *d;
; 1410 :     int b2, d2, dd, i, nd, nd0, odd, p2, p5;
; 1411 : 
; 1412 :     nd = bc->nd;

  00013	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR bc$[rsp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0001e	89 44 24 20	 mov	 DWORD PTR nd$[rsp], eax

; 1413 :     nd0 = bc->nd0;

  00022	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR bc$[rsp]
  0002a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002d	89 44 24 48	 mov	 DWORD PTR nd0$[rsp], eax

; 1414 :     p5 = nd + bc->e0;

  00031	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR bc$[rsp]
  00039	8b 00		 mov	 eax, DWORD PTR [rax]
  0003b	8b 4c 24 20	 mov	 ecx, DWORD PTR nd$[rsp]
  0003f	03 c8		 add	 ecx, eax
  00041	8b c1		 mov	 eax, ecx
  00043	89 44 24 4c	 mov	 DWORD PTR p5$[rsp], eax

; 1415 :     b = sd2b(rv, bc->scale, &p2);

  00047	4c 8d 44 24 2c	 lea	 r8, QWORD PTR p2$[rsp]
  0004c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR bc$[rsp]
  00054	8b 50 0c	 mov	 edx, DWORD PTR [rax+12]
  00057	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  0005f	e8 00 00 00 00	 call	 sd2b
  00064	48 89 44 24 40	 mov	 QWORD PTR b$[rsp], rax

; 1416 :     if (b == NULL)

  00069	48 83 7c 24 40
	00		 cmp	 QWORD PTR b$[rsp], 0
  0006f	75 0a		 jne	 SHORT $LN24@bigcomp

; 1417 :         return -1;

  00071	b8 ff ff ff ff	 mov	 eax, -1
  00076	e9 3c 03 00 00	 jmp	 $LN25@bigcomp
$LN24@bigcomp:

; 1418 : 
; 1419 :     /* record whether the lsb of rv/2^(bc->scale) is odd:  in the exact halfway
; 1420 :        case, this is used for round to even. */
; 1421 :     odd = b->x[0] & 1;

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  00080	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00083	83 e0 01	 and	 eax, 1
  00086	89 44 24 28	 mov	 DWORD PTR odd$[rsp], eax

; 1422 : 
; 1423 :     /* left shift b by 1 bit and or a 1 into the least significant bit;
; 1424 :        this gives us b * 2**p2 = rv/2^(bc->scale) + 0.5 ulp. */
; 1425 :     b = lshift(b, 1);

  0008a	ba 01 00 00 00	 mov	 edx, 1
  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  00094	e8 00 00 00 00	 call	 lshift
  00099	48 89 44 24 40	 mov	 QWORD PTR b$[rsp], rax

; 1426 :     if (b == NULL)

  0009e	48 83 7c 24 40
	00		 cmp	 QWORD PTR b$[rsp], 0
  000a4	75 0a		 jne	 SHORT $LN23@bigcomp

; 1427 :         return -1;

  000a6	b8 ff ff ff ff	 mov	 eax, -1
  000ab	e9 07 03 00 00	 jmp	 $LN25@bigcomp
$LN23@bigcomp:

; 1428 :     b->x[0] |= 1;

  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  000b5	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000b8	83 c8 01	 or	 eax, 1
  000bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  000c0	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 1429 :     p2--;

  000c3	8b 44 24 2c	 mov	 eax, DWORD PTR p2$[rsp]
  000c7	ff c8		 dec	 eax
  000c9	89 44 24 2c	 mov	 DWORD PTR p2$[rsp], eax

; 1430 : 
; 1431 :     p2 -= p5;

  000cd	8b 44 24 4c	 mov	 eax, DWORD PTR p5$[rsp]
  000d1	8b 4c 24 2c	 mov	 ecx, DWORD PTR p2$[rsp]
  000d5	2b c8		 sub	 ecx, eax
  000d7	8b c1		 mov	 eax, ecx
  000d9	89 44 24 2c	 mov	 DWORD PTR p2$[rsp], eax

; 1432 :     d = i2b(1);

  000dd	b9 01 00 00 00	 mov	 ecx, 1
  000e2	e8 00 00 00 00	 call	 i2b
  000e7	48 89 44 24 50	 mov	 QWORD PTR d$[rsp], rax

; 1433 :     if (d == NULL) {

  000ec	48 83 7c 24 50
	00		 cmp	 QWORD PTR d$[rsp], 0
  000f2	75 14		 jne	 SHORT $LN22@bigcomp

; 1434 :         Bfree(b);

  000f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  000f9	e8 00 00 00 00	 call	 Bfree

; 1435 :         return -1;

  000fe	b8 ff ff ff ff	 mov	 eax, -1
  00103	e9 af 02 00 00	 jmp	 $LN25@bigcomp
$LN22@bigcomp:

; 1436 :     }
; 1437 :     /* Arrange for convenient computation of quotients:
; 1438 :      * shift left if necessary so divisor has 4 leading 0 bits.
; 1439 :      */
; 1440 :     if (p5 > 0) {

  00108	83 7c 24 4c 00	 cmp	 DWORD PTR p5$[rsp], 0
  0010d	7e 31		 jle	 SHORT $LN21@bigcomp

; 1441 :         d = pow5mult(d, p5);

  0010f	8b 54 24 4c	 mov	 edx, DWORD PTR p5$[rsp]
  00113	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d$[rsp]
  00118	e8 00 00 00 00	 call	 pow5mult
  0011d	48 89 44 24 50	 mov	 QWORD PTR d$[rsp], rax

; 1442 :         if (d == NULL) {

  00122	48 83 7c 24 50
	00		 cmp	 QWORD PTR d$[rsp], 0
  00128	75 14		 jne	 SHORT $LN20@bigcomp

; 1443 :             Bfree(b);

  0012a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0012f	e8 00 00 00 00	 call	 Bfree

; 1444 :             return -1;

  00134	b8 ff ff ff ff	 mov	 eax, -1
  00139	e9 79 02 00 00	 jmp	 $LN25@bigcomp
$LN20@bigcomp:

; 1445 :         }

  0013e	eb 3a		 jmp	 SHORT $LN19@bigcomp
$LN21@bigcomp:

; 1446 :     }
; 1447 :     else if (p5 < 0) {

  00140	83 7c 24 4c 00	 cmp	 DWORD PTR p5$[rsp], 0
  00145	7d 33		 jge	 SHORT $LN18@bigcomp

; 1448 :         b = pow5mult(b, -p5);

  00147	8b 44 24 4c	 mov	 eax, DWORD PTR p5$[rsp]
  0014b	f7 d8		 neg	 eax
  0014d	8b d0		 mov	 edx, eax
  0014f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  00154	e8 00 00 00 00	 call	 pow5mult
  00159	48 89 44 24 40	 mov	 QWORD PTR b$[rsp], rax

; 1449 :         if (b == NULL) {

  0015e	48 83 7c 24 40
	00		 cmp	 QWORD PTR b$[rsp], 0
  00164	75 14		 jne	 SHORT $LN17@bigcomp

; 1450 :             Bfree(d);

  00166	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d$[rsp]
  0016b	e8 00 00 00 00	 call	 Bfree

; 1451 :             return -1;

  00170	b8 ff ff ff ff	 mov	 eax, -1
  00175	e9 3d 02 00 00	 jmp	 $LN25@bigcomp
$LN17@bigcomp:
$LN18@bigcomp:
$LN19@bigcomp:

; 1452 :         }
; 1453 :     }
; 1454 :     if (p2 > 0) {

  0017a	83 7c 24 2c 00	 cmp	 DWORD PTR p2$[rsp], 0
  0017f	7e 12		 jle	 SHORT $LN16@bigcomp

; 1455 :         b2 = p2;

  00181	8b 44 24 2c	 mov	 eax, DWORD PTR p2$[rsp]
  00185	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax

; 1456 :         d2 = 0;

  00189	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR d2$[rsp], 0

; 1457 :     }
; 1458 :     else {

  00191	eb 12		 jmp	 SHORT $LN15@bigcomp
$LN16@bigcomp:

; 1459 :         b2 = 0;

  00193	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR b2$[rsp], 0

; 1460 :         d2 = -p2;

  0019b	8b 44 24 2c	 mov	 eax, DWORD PTR p2$[rsp]
  0019f	f7 d8		 neg	 eax
  001a1	89 44 24 34	 mov	 DWORD PTR d2$[rsp], eax
$LN15@bigcomp:

; 1461 :     }
; 1462 :     i = dshift(d, d2);

  001a5	8b 54 24 34	 mov	 edx, DWORD PTR d2$[rsp]
  001a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d$[rsp]
  001ae	e8 00 00 00 00	 call	 dshift
  001b3	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax

; 1463 :     if ((b2 += i) > 0) {

  001b7	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  001bb	8b 4c 24 30	 mov	 ecx, DWORD PTR b2$[rsp]
  001bf	03 c8		 add	 ecx, eax
  001c1	8b c1		 mov	 eax, ecx
  001c3	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  001c7	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  001cc	7e 2f		 jle	 SHORT $LN14@bigcomp

; 1464 :         b = lshift(b, b2);

  001ce	8b 54 24 30	 mov	 edx, DWORD PTR b2$[rsp]
  001d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  001d7	e8 00 00 00 00	 call	 lshift
  001dc	48 89 44 24 40	 mov	 QWORD PTR b$[rsp], rax

; 1465 :         if (b == NULL) {

  001e1	48 83 7c 24 40
	00		 cmp	 QWORD PTR b$[rsp], 0
  001e7	75 14		 jne	 SHORT $LN13@bigcomp

; 1466 :             Bfree(d);

  001e9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d$[rsp]
  001ee	e8 00 00 00 00	 call	 Bfree

; 1467 :             return -1;

  001f3	b8 ff ff ff ff	 mov	 eax, -1
  001f8	e9 ba 01 00 00	 jmp	 $LN25@bigcomp
$LN13@bigcomp:
$LN14@bigcomp:

; 1468 :         }
; 1469 :     }
; 1470 :     if ((d2 += i) > 0) {

  001fd	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00201	8b 4c 24 34	 mov	 ecx, DWORD PTR d2$[rsp]
  00205	03 c8		 add	 ecx, eax
  00207	8b c1		 mov	 eax, ecx
  00209	89 44 24 34	 mov	 DWORD PTR d2$[rsp], eax
  0020d	83 7c 24 34 00	 cmp	 DWORD PTR d2$[rsp], 0
  00212	7e 2f		 jle	 SHORT $LN12@bigcomp

; 1471 :         d = lshift(d, d2);

  00214	8b 54 24 34	 mov	 edx, DWORD PTR d2$[rsp]
  00218	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d$[rsp]
  0021d	e8 00 00 00 00	 call	 lshift
  00222	48 89 44 24 50	 mov	 QWORD PTR d$[rsp], rax

; 1472 :         if (d == NULL) {

  00227	48 83 7c 24 50
	00		 cmp	 QWORD PTR d$[rsp], 0
  0022d	75 14		 jne	 SHORT $LN11@bigcomp

; 1473 :             Bfree(b);

  0022f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  00234	e8 00 00 00 00	 call	 Bfree

; 1474 :             return -1;

  00239	b8 ff ff ff ff	 mov	 eax, -1
  0023e	e9 74 01 00 00	 jmp	 $LN25@bigcomp
$LN11@bigcomp:
$LN12@bigcomp:

; 1475 :         }
; 1476 :     }
; 1477 : 
; 1478 :     /* Compare s0 with b/d: set dd to -1, 0, or 1 according as s0 < b/d, s0 ==
; 1479 :      * b/d, or s0 > b/d.  Here the digits of s0 are thought of as representing
; 1480 :      * a number in the range [0.1, 1). */
; 1481 :     if (cmp(b, d) >= 0)

  00243	48 8b 54 24 50	 mov	 rdx, QWORD PTR d$[rsp]
  00248	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0024d	e8 00 00 00 00	 call	 cmp
  00252	85 c0		 test	 eax, eax
  00254	7c 0d		 jl	 SHORT $LN10@bigcomp

; 1482 :         /* b/d >= 1 */
; 1483 :         dd = -1;

  00256	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR dd$[rsp], -1

; 1484 :     else {

  0025e	e9 f4 00 00 00	 jmp	 $LN9@bigcomp
$LN10@bigcomp:

; 1485 :         i = 0;

  00263	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN8@bigcomp:

; 1486 :         for(;;) {
; 1487 :             b = multadd(b, 10, 0);

  0026b	45 33 c0	 xor	 r8d, r8d
  0026e	ba 0a 00 00 00	 mov	 edx, 10
  00273	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  00278	e8 00 00 00 00	 call	 multadd
  0027d	48 89 44 24 40	 mov	 QWORD PTR b$[rsp], rax

; 1488 :             if (b == NULL) {

  00282	48 83 7c 24 40
	00		 cmp	 QWORD PTR b$[rsp], 0
  00288	75 14		 jne	 SHORT $LN6@bigcomp

; 1489 :                 Bfree(d);

  0028a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d$[rsp]
  0028f	e8 00 00 00 00	 call	 Bfree

; 1490 :                 return -1;

  00294	b8 ff ff ff ff	 mov	 eax, -1
  00299	e9 19 01 00 00	 jmp	 $LN25@bigcomp
$LN6@bigcomp:

; 1491 :             }
; 1492 :             dd = s0[i < nd0 ? i : i+1] - '0' - quorem(b, d);

  0029e	8b 44 24 48	 mov	 eax, DWORD PTR nd0$[rsp]
  002a2	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  002a6	7d 0a		 jge	 SHORT $LN27@bigcomp
  002a8	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  002ac	89 44 24 58	 mov	 DWORD PTR tv166[rsp], eax
  002b0	eb 0a		 jmp	 SHORT $LN28@bigcomp
$LN27@bigcomp:
  002b2	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  002b6	ff c0		 inc	 eax
  002b8	89 44 24 58	 mov	 DWORD PTR tv166[rsp], eax
$LN28@bigcomp:
  002bc	48 63 44 24 58	 movsxd	 rax, DWORD PTR tv166[rsp]
  002c1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR s0$[rsp]
  002c9	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  002cd	83 e8 30	 sub	 eax, 48			; 00000030H
  002d0	89 44 24 5c	 mov	 DWORD PTR tv170[rsp], eax
  002d4	48 8b 54 24 50	 mov	 rdx, QWORD PTR d$[rsp]
  002d9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  002de	e8 00 00 00 00	 call	 quorem
  002e3	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv170[rsp]
  002e7	2b c8		 sub	 ecx, eax
  002e9	8b c1		 mov	 eax, ecx
  002eb	89 44 24 38	 mov	 DWORD PTR dd$[rsp], eax

; 1493 :             i++;

  002ef	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  002f3	ff c0		 inc	 eax
  002f5	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax

; 1494 : 
; 1495 :             if (dd)

  002f9	83 7c 24 38 00	 cmp	 DWORD PTR dd$[rsp], 0
  002fe	74 02		 je	 SHORT $LN5@bigcomp

; 1496 :                 break;

  00300	eb 55		 jmp	 SHORT $LN7@bigcomp
$LN5@bigcomp:

; 1497 :             if (!b->x[0] && b->wds == 1) {

  00302	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  00307	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0030b	75 31		 jne	 SHORT $LN4@bigcomp
  0030d	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  00312	83 78 14 01	 cmp	 DWORD PTR [rax+20], 1
  00316	75 26		 jne	 SHORT $LN4@bigcomp

; 1498 :                 /* b/d == 0 */
; 1499 :                 dd = i < nd;

  00318	8b 44 24 20	 mov	 eax, DWORD PTR nd$[rsp]
  0031c	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00320	7d 0a		 jge	 SHORT $LN29@bigcomp
  00322	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv183[rsp], 1
  0032a	eb 08		 jmp	 SHORT $LN30@bigcomp
$LN29@bigcomp:
  0032c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv183[rsp], 0
$LN30@bigcomp:
  00334	8b 44 24 60	 mov	 eax, DWORD PTR tv183[rsp]
  00338	89 44 24 38	 mov	 DWORD PTR dd$[rsp], eax

; 1500 :                 break;

  0033c	eb 19		 jmp	 SHORT $LN7@bigcomp
$LN4@bigcomp:

; 1501 :             }
; 1502 :             if (!(i < nd)) {

  0033e	8b 44 24 20	 mov	 eax, DWORD PTR nd$[rsp]
  00342	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00346	7c 0a		 jl	 SHORT $LN3@bigcomp

; 1503 :                 /* b/d != 0, but digits of s0 exhausted */
; 1504 :                 dd = -1;

  00348	c7 44 24 38 ff
	ff ff ff	 mov	 DWORD PTR dd$[rsp], -1

; 1505 :                 break;

  00350	eb 05		 jmp	 SHORT $LN7@bigcomp
$LN3@bigcomp:

; 1506 :             }
; 1507 :         }

  00352	e9 14 ff ff ff	 jmp	 $LN8@bigcomp
$LN7@bigcomp:
$LN9@bigcomp:

; 1508 :     }
; 1509 :     Bfree(b);

  00357	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0035c	e8 00 00 00 00	 call	 Bfree

; 1510 :     Bfree(d);

  00361	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d$[rsp]
  00366	e8 00 00 00 00	 call	 Bfree

; 1511 :     if (dd > 0 || (dd == 0 && odd))

  0036b	83 7c 24 38 00	 cmp	 DWORD PTR dd$[rsp], 0
  00370	7f 0e		 jg	 SHORT $LN1@bigcomp
  00372	83 7c 24 38 00	 cmp	 DWORD PTR dd$[rsp], 0
  00377	75 3c		 jne	 SHORT $LN2@bigcomp
  00379	83 7c 24 28 00	 cmp	 DWORD PTR odd$[rsp], 0
  0037e	74 35		 je	 SHORT $LN2@bigcomp
$LN1@bigcomp:

; 1512 :         dval(rv) += sulp(rv, bc);

  00380	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR bc$[rsp]
  00388	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00390	e8 00 00 00 00	 call	 sulp
  00395	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  0039d	f2 0f 10 08	 movsdx	 xmm1, QWORD PTR [rax]
  003a1	f2 0f 58 c8	 addsd	 xmm1, xmm0
  003a5	66 0f 28 c1	 movapd	 xmm0, xmm1
  003a9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  003b1	f2 0f 11 00	 movsdx	 QWORD PTR [rax], xmm0
$LN2@bigcomp:

; 1513 :     return 0;

  003b5	33 c0		 xor	 eax, eax
$LN25@bigcomp:

; 1514 : }

  003b7	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003bb	c3		 ret	 0
bigcomp	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dshift DD imagerel dshift
	DD	imagerel dshift+81
	DD	imagerel $unwind$dshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dshift DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT dshift
_TEXT	SEGMENT
rv$ = 32
b$ = 64
p2$ = 72
dshift	PROC						; COMDAT

; 1231 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1232 :     int rv = hi0bits(b->x[b->wds-1]) - 4;

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR b$[rsp]
  00012	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00015	ff c8		 dec	 eax
  00017	48 98		 cdqe
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR b$[rsp]
  0001e	8b 4c 81 18	 mov	 ecx, DWORD PTR [rcx+rax*4+24]
  00022	e8 00 00 00 00	 call	 hi0bits
  00027	83 e8 04	 sub	 eax, 4
  0002a	89 44 24 20	 mov	 DWORD PTR rv$[rsp], eax

; 1233 :     if (p2 > 0)

  0002e	83 7c 24 48 00	 cmp	 DWORD PTR p2$[rsp], 0
  00033	7e 10		 jle	 SHORT $LN1@dshift

; 1234 :         rv -= p2;

  00035	8b 44 24 48	 mov	 eax, DWORD PTR p2$[rsp]
  00039	8b 4c 24 20	 mov	 ecx, DWORD PTR rv$[rsp]
  0003d	2b c8		 sub	 ecx, eax
  0003f	8b c1		 mov	 eax, ecx
  00041	89 44 24 20	 mov	 DWORD PTR rv$[rsp], eax
$LN1@dshift:

; 1235 :     return rv & kmask;

  00045	8b 44 24 20	 mov	 eax, DWORD PTR rv$[rsp]
  00049	83 e0 1f	 and	 eax, 31

; 1236 : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
dshift	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@IMJJBOEB@oversized?5quotient?5in?5quorem?$AA@ ; `string'
PUBLIC	??_C@_0BF@BNOAFBKL@oversize?5b?5in?5quorem?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$quorem DD imagerel quorem
	DD	imagerel quorem+919
	DD	imagerel $unwind$quorem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$quorem DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0BN@IMJJBOEB@oversized?5quotient?5in?5quorem?$AA@
CONST	SEGMENT
??_C@_0BN@IMJJBOEB@oversized?5quotient?5in?5quorem?$AA@ DB 'oversized quo'
	DB	'tient in quorem', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@BNOAFBKL@oversize?5b?5in?5quorem?$AA@
CONST	SEGMENT
??_C@_0BF@BNOAFBKL@oversize?5b?5in?5quorem?$AA@ DB 'oversize b in quorem', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT quorem
_TEXT	SEGMENT
y$ = 32
sxe$ = 40
sx$ = 48
n$ = 56
q$ = 60
bx$ = 64
carry$ = 72
ys$ = 80
bxe$ = 88
borrow$ = 96
tv84 = 104
b$ = 128
S$ = 136
quorem	PROC						; COMDAT

; 1244 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1245 :     int n;
; 1246 :     ULong *bx, *bxe, q, *sx, *sxe;
; 1247 : #ifdef ULLong
; 1248 :     ULLong borrow, carry, y, ys;
; 1249 : #else
; 1250 :     ULong borrow, carry, y, ys;
; 1251 :     ULong si, z, zs;
; 1252 : #endif
; 1253 : 
; 1254 :     n = S->wds;

  0000e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR S$[rsp]
  00016	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00019	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax

; 1255 : #ifdef DEBUG
; 1256 :     /*debug*/ if (b->wds > n)

  0001d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00025	8b 4c 24 38	 mov	 ecx, DWORD PTR n$[rsp]
  00029	39 48 14	 cmp	 DWORD PTR [rax+20], ecx
  0002c	7e 2c		 jle	 SHORT $LN17@quorem

; 1257 :         /*debug*/       Bug("oversize b in quorem");

  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00034	48 83 c0 60	 add	 rax, 96			; 00000060H
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BF@BNOAFBKL@oversize?5b?5in?5quorem?$AA@
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6?$AA@
  00046	48 8b c8	 mov	 rcx, rax
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
  0004f	b9 01 00 00 00	 mov	 ecx, 1
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN17@quorem:

; 1258 : #endif
; 1259 :     if (b->wds < n)

  0005a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00062	8b 4c 24 38	 mov	 ecx, DWORD PTR n$[rsp]
  00066	39 48 14	 cmp	 DWORD PTR [rax+20], ecx
  00069	7d 07		 jge	 SHORT $LN16@quorem

; 1260 :         return 0;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 20 03 00 00	 jmp	 $LN18@quorem
$LN16@quorem:

; 1261 :     sx = S->x;

  00072	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR S$[rsp]
  0007a	48 83 c0 18	 add	 rax, 24
  0007e	48 89 44 24 30	 mov	 QWORD PTR sx$[rsp], rax

; 1262 :     sxe = sx + --n;

  00083	8b 44 24 38	 mov	 eax, DWORD PTR n$[rsp]
  00087	ff c8		 dec	 eax
  00089	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax
  0008d	48 63 44 24 38	 movsxd	 rax, DWORD PTR n$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sx$[rsp]
  00097	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  0009b	48 89 44 24 28	 mov	 QWORD PTR sxe$[rsp], rax

; 1263 :     bx = b->x;

  000a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  000a8	48 83 c0 18	 add	 rax, 24
  000ac	48 89 44 24 40	 mov	 QWORD PTR bx$[rsp], rax

; 1264 :     bxe = bx + n;

  000b1	48 63 44 24 38	 movsxd	 rax, DWORD PTR n$[rsp]
  000b6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bx$[rsp]
  000bb	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000bf	48 89 44 24 58	 mov	 QWORD PTR bxe$[rsp], rax

; 1265 :     q = *bxe / (*sxe + 1);      /* ensure q <= true quotient */

  000c4	48 8b 44 24 28	 mov	 rax, QWORD PTR sxe$[rsp]
  000c9	8b 00		 mov	 eax, DWORD PTR [rax]
  000cb	ff c0		 inc	 eax
  000cd	89 44 24 68	 mov	 DWORD PTR tv84[rsp], eax
  000d1	33 d2		 xor	 edx, edx
  000d3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bxe$[rsp]
  000d8	8b 01		 mov	 eax, DWORD PTR [rcx]
  000da	8b 4c 24 68	 mov	 ecx, DWORD PTR tv84[rsp]
  000de	f7 f1		 div	 ecx
  000e0	89 44 24 3c	 mov	 DWORD PTR q$[rsp], eax

; 1266 : #ifdef DEBUG
; 1267 :     /*debug*/ if (q > 9)

  000e4	83 7c 24 3c 09	 cmp	 DWORD PTR q$[rsp], 9
  000e9	76 2c		 jbe	 SHORT $LN15@quorem

; 1268 :         /*debug*/       Bug("oversized quotient in quorem");

  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  000f1	48 83 c0 60	 add	 rax, 96			; 00000060H
  000f5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BN@IMJJBOEB@oversized?5quotient?5in?5quorem?$AA@
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6?$AA@
  00103	48 8b c8	 mov	 rcx, rax
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
  0010c	b9 01 00 00 00	 mov	 ecx, 1
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN15@quorem:

; 1269 : #endif
; 1270 :     if (q) {

  00117	83 7c 24 3c 00	 cmp	 DWORD PTR q$[rsp], 0
  0011c	0f 84 0c 01 00
	00		 je	 $LN14@quorem

; 1271 :         borrow = 0;

  00122	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR borrow$[rsp], 0

; 1272 :         carry = 0;

  0012b	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR carry$[rsp], 0
$LN13@quorem:

; 1273 :         do {
; 1274 : #ifdef ULLong
; 1275 :             ys = *sx++ * (ULLong)q + carry;

  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR sx$[rsp]
  00139	8b 00		 mov	 eax, DWORD PTR [rax]
  0013b	8b 4c 24 3c	 mov	 ecx, DWORD PTR q$[rsp]
  0013f	48 0f af c1	 imul	 rax, rcx
  00143	48 03 44 24 48	 add	 rax, QWORD PTR carry$[rsp]
  00148	48 89 44 24 50	 mov	 QWORD PTR ys$[rsp], rax
  0014d	48 8b 44 24 30	 mov	 rax, QWORD PTR sx$[rsp]
  00152	48 83 c0 04	 add	 rax, 4
  00156	48 89 44 24 30	 mov	 QWORD PTR sx$[rsp], rax

; 1276 :             carry = ys >> 32;

  0015b	48 8b 44 24 50	 mov	 rax, QWORD PTR ys$[rsp]
  00160	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00164	48 89 44 24 48	 mov	 QWORD PTR carry$[rsp], rax

; 1277 :             y = *bx - (ys & FFFFFFFF) - borrow;

  00169	48 8b 44 24 40	 mov	 rax, QWORD PTR bx$[rsp]
  0016e	8b 00		 mov	 eax, DWORD PTR [rax]
  00170	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00175	48 8b 54 24 50	 mov	 rdx, QWORD PTR ys$[rsp]
  0017a	48 23 d1	 and	 rdx, rcx
  0017d	48 8b ca	 mov	 rcx, rdx
  00180	48 2b c1	 sub	 rax, rcx
  00183	48 2b 44 24 60	 sub	 rax, QWORD PTR borrow$[rsp]
  00188	48 89 44 24 20	 mov	 QWORD PTR y$[rsp], rax

; 1278 :             borrow = y >> 32 & (ULong)1;

  0018d	48 8b 44 24 20	 mov	 rax, QWORD PTR y$[rsp]
  00192	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00196	48 83 e0 01	 and	 rax, 1
  0019a	48 89 44 24 60	 mov	 QWORD PTR borrow$[rsp], rax

; 1279 :             *bx++ = (ULong)(y & FFFFFFFF);

  0019f	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  001a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR y$[rsp]
  001a9	48 23 c8	 and	 rcx, rax
  001ac	48 8b c1	 mov	 rax, rcx
  001af	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bx$[rsp]
  001b4	89 01		 mov	 DWORD PTR [rcx], eax
  001b6	48 8b 44 24 40	 mov	 rax, QWORD PTR bx$[rsp]
  001bb	48 83 c0 04	 add	 rax, 4
  001bf	48 89 44 24 40	 mov	 QWORD PTR bx$[rsp], rax

; 1280 : #else
; 1281 :             si = *sx++;
; 1282 :             ys = (si & 0xffff) * q + carry;
; 1283 :             zs = (si >> 16) * q + (ys >> 16);
; 1284 :             carry = zs >> 16;
; 1285 :             y = (*bx & 0xffff) - (ys & 0xffff) - borrow;
; 1286 :             borrow = (y & 0x10000) >> 16;
; 1287 :             z = (*bx >> 16) - (zs & 0xffff) - borrow;
; 1288 :             borrow = (z & 0x10000) >> 16;
; 1289 :             Storeinc(bx, z, y);
; 1290 : #endif
; 1291 :         }
; 1292 :         while(sx <= sxe);

  001c4	48 8b 44 24 28	 mov	 rax, QWORD PTR sxe$[rsp]
  001c9	48 39 44 24 30	 cmp	 QWORD PTR sx$[rsp], rax
  001ce	0f 86 60 ff ff
	ff		 jbe	 $LN13@quorem

; 1293 :         if (!*bxe) {

  001d4	48 8b 44 24 58	 mov	 rax, QWORD PTR bxe$[rsp]
  001d9	83 38 00	 cmp	 DWORD PTR [rax], 0
  001dc	75 50		 jne	 SHORT $LN10@quorem

; 1294 :             bx = b->x;

  001de	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  001e6	48 83 c0 18	 add	 rax, 24
  001ea	48 89 44 24 40	 mov	 QWORD PTR bx$[rsp], rax
$LN9@quorem:

; 1295 :             while(--bxe > bx && !*bxe)

  001ef	48 8b 44 24 58	 mov	 rax, QWORD PTR bxe$[rsp]
  001f4	48 83 e8 04	 sub	 rax, 4
  001f8	48 89 44 24 58	 mov	 QWORD PTR bxe$[rsp], rax
  001fd	48 8b 44 24 40	 mov	 rax, QWORD PTR bx$[rsp]
  00202	48 39 44 24 58	 cmp	 QWORD PTR bxe$[rsp], rax
  00207	76 16		 jbe	 SHORT $LN8@quorem
  00209	48 8b 44 24 58	 mov	 rax, QWORD PTR bxe$[rsp]
  0020e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00211	75 0c		 jne	 SHORT $LN8@quorem

; 1296 :                 --n;

  00213	8b 44 24 38	 mov	 eax, DWORD PTR n$[rsp]
  00217	ff c8		 dec	 eax
  00219	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax
  0021d	eb d0		 jmp	 SHORT $LN9@quorem
$LN8@quorem:

; 1297 :             b->wds = n;

  0021f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00227	8b 4c 24 38	 mov	 ecx, DWORD PTR n$[rsp]
  0022b	89 48 14	 mov	 DWORD PTR [rax+20], ecx
$LN10@quorem:
$LN14@quorem:

; 1298 :         }
; 1299 :     }
; 1300 :     if (cmp(b, S) >= 0) {

  0022e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR S$[rsp]
  00236	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0023e	e8 00 00 00 00	 call	 cmp
  00243	85 c0		 test	 eax, eax
  00245	0f 8c 43 01 00
	00		 jl	 $LN7@quorem

; 1301 :         q++;

  0024b	8b 44 24 3c	 mov	 eax, DWORD PTR q$[rsp]
  0024f	ff c0		 inc	 eax
  00251	89 44 24 3c	 mov	 DWORD PTR q$[rsp], eax

; 1302 :         borrow = 0;

  00255	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR borrow$[rsp], 0

; 1303 :         carry = 0;

  0025e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR carry$[rsp], 0

; 1304 :         bx = b->x;

  00267	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0026f	48 83 c0 18	 add	 rax, 24
  00273	48 89 44 24 40	 mov	 QWORD PTR bx$[rsp], rax

; 1305 :         sx = S->x;

  00278	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR S$[rsp]
  00280	48 83 c0 18	 add	 rax, 24
  00284	48 89 44 24 30	 mov	 QWORD PTR sx$[rsp], rax
$LN6@quorem:

; 1306 :         do {
; 1307 : #ifdef ULLong
; 1308 :             ys = *sx++ + carry;

  00289	48 8b 44 24 30	 mov	 rax, QWORD PTR sx$[rsp]
  0028e	8b 00		 mov	 eax, DWORD PTR [rax]
  00290	48 03 44 24 48	 add	 rax, QWORD PTR carry$[rsp]
  00295	48 89 44 24 50	 mov	 QWORD PTR ys$[rsp], rax
  0029a	48 8b 44 24 30	 mov	 rax, QWORD PTR sx$[rsp]
  0029f	48 83 c0 04	 add	 rax, 4
  002a3	48 89 44 24 30	 mov	 QWORD PTR sx$[rsp], rax

; 1309 :             carry = ys >> 32;

  002a8	48 8b 44 24 50	 mov	 rax, QWORD PTR ys$[rsp]
  002ad	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  002b1	48 89 44 24 48	 mov	 QWORD PTR carry$[rsp], rax

; 1310 :             y = *bx - (ys & FFFFFFFF) - borrow;

  002b6	48 8b 44 24 40	 mov	 rax, QWORD PTR bx$[rsp]
  002bb	8b 00		 mov	 eax, DWORD PTR [rax]
  002bd	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  002c2	48 8b 54 24 50	 mov	 rdx, QWORD PTR ys$[rsp]
  002c7	48 23 d1	 and	 rdx, rcx
  002ca	48 8b ca	 mov	 rcx, rdx
  002cd	48 2b c1	 sub	 rax, rcx
  002d0	48 2b 44 24 60	 sub	 rax, QWORD PTR borrow$[rsp]
  002d5	48 89 44 24 20	 mov	 QWORD PTR y$[rsp], rax

; 1311 :             borrow = y >> 32 & (ULong)1;

  002da	48 8b 44 24 20	 mov	 rax, QWORD PTR y$[rsp]
  002df	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  002e3	48 83 e0 01	 and	 rax, 1
  002e7	48 89 44 24 60	 mov	 QWORD PTR borrow$[rsp], rax

; 1312 :             *bx++ = (ULong)(y & FFFFFFFF);

  002ec	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  002f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR y$[rsp]
  002f6	48 23 c8	 and	 rcx, rax
  002f9	48 8b c1	 mov	 rax, rcx
  002fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bx$[rsp]
  00301	89 01		 mov	 DWORD PTR [rcx], eax
  00303	48 8b 44 24 40	 mov	 rax, QWORD PTR bx$[rsp]
  00308	48 83 c0 04	 add	 rax, 4
  0030c	48 89 44 24 40	 mov	 QWORD PTR bx$[rsp], rax

; 1313 : #else
; 1314 :             si = *sx++;
; 1315 :             ys = (si & 0xffff) + carry;
; 1316 :             zs = (si >> 16) + (ys >> 16);
; 1317 :             carry = zs >> 16;
; 1318 :             y = (*bx & 0xffff) - (ys & 0xffff) - borrow;
; 1319 :             borrow = (y & 0x10000) >> 16;
; 1320 :             z = (*bx >> 16) - (zs & 0xffff) - borrow;
; 1321 :             borrow = (z & 0x10000) >> 16;
; 1322 :             Storeinc(bx, z, y);
; 1323 : #endif
; 1324 :         }
; 1325 :         while(sx <= sxe);

  00311	48 8b 44 24 28	 mov	 rax, QWORD PTR sxe$[rsp]
  00316	48 39 44 24 30	 cmp	 QWORD PTR sx$[rsp], rax
  0031b	0f 86 68 ff ff
	ff		 jbe	 $LN6@quorem

; 1326 :         bx = b->x;

  00321	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00329	48 83 c0 18	 add	 rax, 24
  0032d	48 89 44 24 40	 mov	 QWORD PTR bx$[rsp], rax

; 1327 :         bxe = bx + n;

  00332	48 63 44 24 38	 movsxd	 rax, DWORD PTR n$[rsp]
  00337	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bx$[rsp]
  0033c	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00340	48 89 44 24 58	 mov	 QWORD PTR bxe$[rsp], rax

; 1328 :         if (!*bxe) {

  00345	48 8b 44 24 58	 mov	 rax, QWORD PTR bxe$[rsp]
  0034a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0034d	75 3f		 jne	 SHORT $LN3@quorem
$LN2@quorem:

; 1329 :             while(--bxe > bx && !*bxe)

  0034f	48 8b 44 24 58	 mov	 rax, QWORD PTR bxe$[rsp]
  00354	48 83 e8 04	 sub	 rax, 4
  00358	48 89 44 24 58	 mov	 QWORD PTR bxe$[rsp], rax
  0035d	48 8b 44 24 40	 mov	 rax, QWORD PTR bx$[rsp]
  00362	48 39 44 24 58	 cmp	 QWORD PTR bxe$[rsp], rax
  00367	76 16		 jbe	 SHORT $LN1@quorem
  00369	48 8b 44 24 58	 mov	 rax, QWORD PTR bxe$[rsp]
  0036e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00371	75 0c		 jne	 SHORT $LN1@quorem

; 1330 :                 --n;

  00373	8b 44 24 38	 mov	 eax, DWORD PTR n$[rsp]
  00377	ff c8		 dec	 eax
  00379	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax
  0037d	eb d0		 jmp	 SHORT $LN2@quorem
$LN1@quorem:

; 1331 :             b->wds = n;

  0037f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00387	8b 4c 24 38	 mov	 ecx, DWORD PTR n$[rsp]
  0038b	89 48 14	 mov	 DWORD PTR [rax+20], ecx
$LN3@quorem:
$LN7@quorem:

; 1332 :         }
; 1333 :     }
; 1334 :     return q;

  0038e	8b 44 24 3c	 mov	 eax, DWORD PTR q$[rsp]
$LN18@quorem:
$LN19@quorem:

; 1335 : }

  00392	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00396	c3		 ret	 0
quorem	ENDP
_TEXT	ENDS
PUBLIC	_Py_dg_freedtoa
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_dg_freedtoa DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$_Py_dg_freedtoa
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_dg_freedtoa DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_dg_freedtoa
_TEXT	SEGMENT
b$ = 32
tv77 = 40
s$ = 64
_Py_dg_freedtoa PROC					; COMDAT

; 2340 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2341 :     Bigint *b = (Bigint *)((int *)s - 1);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 83 e8 04	 sub	 rax, 4
  00012	48 89 44 24 20	 mov	 QWORD PTR b$[rsp], rax

; 2342 :     b->maxwds = 1 << (b->k = *(int*)b);

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  0001c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  00021	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00023	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  00026	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  0002b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0002e	b9 01 00 00 00	 mov	 ecx, 1
  00033	89 4c 24 28	 mov	 DWORD PTR tv77[rsp], ecx
  00037	0f b6 c8	 movzx	 ecx, al
  0003a	8b 44 24 28	 mov	 eax, DWORD PTR tv77[rsp]
  0003e	d3 e0		 shl	 eax, cl
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  00045	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 2343 :     Bfree(b);

  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR b$[rsp]
  0004d	e8 00 00 00 00	 call	 Bfree

; 2344 : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
_Py_dg_freedtoa ENDP
_TEXT	ENDS
PUBLIC	__real@4014000000000000
PUBLIC	__real@401c000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@3fd34413509f79fb
PUBLIC	__real@3fc68a288b60c8b3
PUBLIC	__real@3fd287a7636f4361
PUBLIC	__real@3ff8000000000000
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_03ICJPMMHB@NaN?$AA@			; `string'
PUBLIC	??_C@_08KEBCLIFP@Infinity?$AA@			; `string'
PUBLIC	_Py_dg_dtoa
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_dg_dtoa DD imagerel $LN176
	DD	imagerel $LN176+6368
	DD	imagerel $unwind$_Py_dg_dtoa
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_dg_dtoa DD 021b01H
	DD	027011bH
xdata	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@401c000000000000
CONST	SEGMENT
__real@401c000000000000 DQ 0401c000000000000r	; 7
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3fd34413509f79fb
CONST	SEGMENT
__real@3fd34413509f79fb DQ 03fd34413509f79fbr	; 0.30103
CONST	ENDS
;	COMDAT __real@3fc68a288b60c8b3
CONST	SEGMENT
__real@3fc68a288b60c8b3 DQ 03fc68a288b60c8b3r	; 0.176091
CONST	ENDS
;	COMDAT __real@3fd287a7636f4361
CONST	SEGMENT
__real@3fd287a7636f4361 DQ 03fd287a7636f4361r	; 0.28953
CONST	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICJPMMHB@NaN?$AA@
CONST	SEGMENT
??_C@_03ICJPMMHB@NaN?$AA@ DB 'NaN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KEBCLIFP@Infinity?$AA@
CONST	SEGMENT
??_C@_08KEBCLIFP@Infinity?$AA@ DB 'Infinity', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_dg_dtoa
_TEXT	SEGMENT
dig$ = 32
b5$ = 36
spec_case$ = 40
m5$ = 44
mhi$ = 48
x$ = 56
s0$ = 64
i$ = 72
s$ = 80
u$ = 88
eps$ = 96
k0$ = 104
S$ = 112
leftright$ = 120
be$ = 124
b2$ = 128
d2$ = 136
ilim1$ = 144
ds$ = 152
b$ = 160
ieps$ = 168
denorm$ = 172
s5$ = 176
m2$ = 180
j1$ = 184
try_quick$ = 188
s2$ = 192
k$ = 196
k_check$ = 200
delta$ = 208
bbits$ = 216
mlo$ = 224
ilim$ = 232
b1$ = 240
L$ = 248
j$ = 252
ilim0$ = 256
tv149 = 260
tv186 = 264
tv373 = 268
tv382 = 272
tv495 = 280
tv517 = 288
dd$ = 320
mode$ = 328
ndigits$ = 336
decpt$ = 344
sign$ = 352
rve$ = 360
_Py_dg_dtoa PROC					; COMDAT

; 2387 : {

$LN176:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00014	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 2388 :     /*  Arguments ndigits, decpt, sign are similar to those
; 2389 :         of ecvt and fcvt; trailing zeros are suppressed from
; 2390 :         the returned string.  If not null, *rve is set to point
; 2391 :         to the end of the return value.  If d is +-Infinity or NaN,
; 2392 :         then *decpt is set to 9999.
; 2393 : 
; 2394 :         mode:
; 2395 :         0 ==> shortest string that yields d when read in
; 2396 :         and rounded to nearest.
; 2397 :         1 ==> like 0, but with Steele & White stopping rule;
; 2398 :         e.g. with IEEE P754 arithmetic , mode 0 gives
; 2399 :         1e23 whereas mode 1 gives 9.999999999999999e22.
; 2400 :         2 ==> max(1,ndigits) significant digits.  This gives a
; 2401 :         return value similar to that of ecvt, except
; 2402 :         that trailing zeros are suppressed.
; 2403 :         3 ==> through ndigits past the decimal point.  This
; 2404 :         gives a return value similar to that from fcvt,
; 2405 :         except that trailing zeros are suppressed, and
; 2406 :         ndigits can be negative.
; 2407 :         4,5 ==> similar to 2 and 3, respectively, but (in
; 2408 :         round-nearest mode) with the tests of mode 0 to
; 2409 :         possibly return a shorter string that rounds to d.
; 2410 :         With IEEE arithmetic and compilation with
; 2411 :         -DHonor_FLT_ROUNDS, modes 4 and 5 behave the same
; 2412 :         as modes 2 and 3 when FLT_ROUNDS != 1.
; 2413 :         6-9 ==> Debugging modes similar to mode - 4:  don't try
; 2414 :         fast floating-point estimate (if applicable).
; 2415 : 
; 2416 :         Values of mode other than 0-9 are treated as mode 0.
; 2417 : 
; 2418 :         Sufficient space is allocated to the return value
; 2419 :         to hold the suppressed trailing zeros.
; 2420 :     */
; 2421 : 
; 2422 :     int bbits, b2, b5, be, dig, i, ieps, ilim, ilim0, ilim1,
; 2423 :         j, j1, k, k0, k_check, leftright, m2, m5, s2, s5,
; 2424 :         spec_case, try_quick;
; 2425 :     Long L;
; 2426 :     int denorm;
; 2427 :     ULong x;
; 2428 :     Bigint *b, *b1, *delta, *mlo, *mhi, *S;
; 2429 :     U d2, eps, u;
; 2430 :     double ds;
; 2431 :     char *s, *s0;
; 2432 : 
; 2433 :     /* set pointers to NULL, to silence gcc compiler warnings and make
; 2434 :        cleanup easier on error */
; 2435 :     mlo = mhi = S = 0;

  0001b	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR S$[rsp], 0
  00024	48 8b 44 24 70	 mov	 rax, QWORD PTR S$[rsp]
  00029	48 89 44 24 30	 mov	 QWORD PTR mhi$[rsp], rax
  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR mhi$[rsp]
  00033	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR mlo$[rsp], rax

; 2436 :     s0 = 0;

  0003b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR s0$[rsp], 0

; 2437 : 
; 2438 :     u.d = dd;

  00044	f2 0f 10 84 24
	40 01 00 00	 movsdx	 xmm0, QWORD PTR dd$[rsp]
  0004d	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0

; 2439 :     if (word0(&u) & Sign_bit) {

  00053	8b 44 24 5c	 mov	 eax, DWORD PTR u$[rsp+4]
  00057	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 1c		 je	 SHORT $LN163@Py_dg_dtoa

; 2440 :         /* set sign for everything, including 0's and NaNs */
; 2441 :         *sign = 1;

  00060	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR sign$[rsp]
  00068	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 2442 :         word0(&u) &= ~Sign_bit; /* clear sign bit */

  0006e	8b 44 24 5c	 mov	 eax, DWORD PTR u$[rsp+4]
  00072	0f ba f0 1f	 btr	 eax, 31
  00076	89 44 24 5c	 mov	 DWORD PTR u$[rsp+4], eax

; 2443 :     }
; 2444 :     else

  0007a	eb 0e		 jmp	 SHORT $LN162@Py_dg_dtoa
$LN163@Py_dg_dtoa:

; 2445 :         *sign = 0;

  0007c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR sign$[rsp]
  00084	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN162@Py_dg_dtoa:

; 2446 : 
; 2447 :     /* quick return for Infinities, NaNs and zeros */
; 2448 :     if ((word0(&u) & Exp_mask) == Exp_mask)

  0008a	8b 44 24 5c	 mov	 eax, DWORD PTR u$[rsp+4]
  0008e	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00093	3d 00 00 f0 7f	 cmp	 eax, 2146435072		; 7ff00000H
  00098	75 60		 jne	 SHORT $LN161@Py_dg_dtoa

; 2449 :     {
; 2450 :         /* Infinity or NaN */
; 2451 :         *decpt = 9999;

  0009a	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR decpt$[rsp]
  000a2	c7 00 0f 27 00
	00		 mov	 DWORD PTR [rax], 9999	; 0000270fH

; 2452 :         if (!word1(&u) && !(word0(&u) & 0xfffff))

  000a8	83 7c 24 58 00	 cmp	 DWORD PTR u$[rsp], 0
  000ad	75 2c		 jne	 SHORT $LN160@Py_dg_dtoa
  000af	8b 44 24 5c	 mov	 eax, DWORD PTR u$[rsp+4]
  000b3	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  000b8	85 c0		 test	 eax, eax
  000ba	75 1f		 jne	 SHORT $LN160@Py_dg_dtoa

; 2453 :             return nrv_alloc("Infinity", rve, 8);

  000bc	41 b8 08 00 00
	00		 mov	 r8d, 8
  000c2	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR rve$[rsp]
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KEBCLIFP@Infinity?$AA@
  000d1	e8 00 00 00 00	 call	 nrv_alloc
  000d6	e9 e2 17 00 00	 jmp	 $LN164@Py_dg_dtoa
$LN160@Py_dg_dtoa:

; 2454 :         return nrv_alloc("NaN", rve, 3);

  000db	41 b8 03 00 00
	00		 mov	 r8d, 3
  000e1	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR rve$[rsp]
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03ICJPMMHB@NaN?$AA@
  000f0	e8 00 00 00 00	 call	 nrv_alloc
  000f5	e9 c3 17 00 00	 jmp	 $LN164@Py_dg_dtoa
$LN161@Py_dg_dtoa:

; 2455 :     }
; 2456 :     if (!dval(&u)) {

  000fa	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00100	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00108	7a 2f		 jp	 SHORT $LN159@Py_dg_dtoa
  0010a	75 2d		 jne	 SHORT $LN159@Py_dg_dtoa

; 2457 :         *decpt = 1;

  0010c	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR decpt$[rsp]
  00114	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 2458 :         return nrv_alloc("0", rve, 1);

  0011a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00120	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR rve$[rsp]
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  0012f	e8 00 00 00 00	 call	 nrv_alloc
  00134	e9 84 17 00 00	 jmp	 $LN164@Py_dg_dtoa
$LN159@Py_dg_dtoa:

; 2459 :     }
; 2460 : 
; 2461 :     /* compute k = floor(log10(d)).  The computation may leave k
; 2462 :        one too large, but should never leave k too small. */
; 2463 :     b = d2b(&u, &be, &bbits);

  00139	4c 8d 84 24 d8
	00 00 00	 lea	 r8, QWORD PTR bbits$[rsp]
  00141	48 8d 54 24 7c	 lea	 rdx, QWORD PTR be$[rsp]
  00146	48 8d 4c 24 58	 lea	 rcx, QWORD PTR u$[rsp]
  0014b	e8 00 00 00 00	 call	 d2b
  00150	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2464 :     if (b == NULL)

  00158	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  00161	75 05		 jne	 SHORT $LN158@Py_dg_dtoa

; 2465 :         goto failed_malloc;

  00163	e9 de 16 00 00	 jmp	 $failed_malloc$21255
$LN158@Py_dg_dtoa:

; 2466 :     if ((i = (int)(word0(&u) >> Exp_shift1 & (Exp_mask>>Exp_shift1)))) {

  00168	8b 44 24 5c	 mov	 eax, DWORD PTR u$[rsp+4]
  0016c	c1 e8 14	 shr	 eax, 20
  0016f	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00174	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
  00178	83 7c 24 48 00	 cmp	 DWORD PTR i$[rsp], 0
  0017d	74 52		 je	 SHORT $LN157@Py_dg_dtoa

; 2467 :         dval(&d2) = dval(&u);

  0017f	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00185	f2 0f 11 84 24
	88 00 00 00	 movsdx	 QWORD PTR d2$[rsp], xmm0

; 2468 :         word0(&d2) &= Frac_mask1;

  0018e	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR d2$[rsp+4]
  00195	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  0019a	89 84 24 8c 00
	00 00		 mov	 DWORD PTR d2$[rsp+4], eax

; 2469 :         word0(&d2) |= Exp_11;

  001a1	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR d2$[rsp+4]
  001a8	0d 00 00 f0 3f	 or	 eax, 1072693248		; 3ff00000H
  001ad	89 84 24 8c 00
	00 00		 mov	 DWORD PTR d2$[rsp+4], eax

; 2470 : 
; 2471 :         /* log(x)       ~=~ log(1.5) + (x-1.5)/1.5
; 2472 :          * log10(x)      =  log(x) / log(10)
; 2473 :          *              ~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10))
; 2474 :          * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2)
; 2475 :          *
; 2476 :          * This suggests computing an approximation k to log10(d) by
; 2477 :          *
; 2478 :          * k = (i - Bias)*0.301029995663981
; 2479 :          *      + ( (d2-1.5)*0.289529654602168 + 0.176091259055681 );
; 2480 :          *
; 2481 :          * We want k to be too large rather than too small.
; 2482 :          * The error in the first-order Taylor series approximation
; 2483 :          * is in our favor, so we just round up the constant enough
; 2484 :          * to compensate for any error in the multiplication of
; 2485 :          * (i - Bias) by 0.301029995663981; since |i - Bias| <= 1077,
; 2486 :          * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14,
; 2487 :          * adding 1e-13 to the constant term more than suffices.
; 2488 :          * Hence we adjust the constant term to 0.1760912590558.
; 2489 :          * (We could get a more accurate k by invoking log10,
; 2490 :          *  but this is probably not worthwhile.)
; 2491 :          */
; 2492 : 
; 2493 :         i -= Bias;

  001b4	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  001b8	2d ff 03 00 00	 sub	 eax, 1023		; 000003ffH
  001bd	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax

; 2494 :         denorm = 0;

  001c1	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR denorm$[rsp], 0

; 2495 :     }
; 2496 :     else {

  001cc	e9 ae 00 00 00	 jmp	 $LN156@Py_dg_dtoa
$LN157@Py_dg_dtoa:

; 2497 :         /* d is denormalized */
; 2498 : 
; 2499 :         i = bbits + be + (Bias + (P-1) - 1);

  001d1	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR bbits$[rsp]
  001d8	8b 4c 24 7c	 mov	 ecx, DWORD PTR be$[rsp]
  001dc	8d 84 08 32 04
	00 00		 lea	 eax, DWORD PTR [rax+rcx+1074]
  001e3	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax

; 2500 :         x = i > 32  ? word0(&u) << (64 - i) | word1(&u) >> (i - 32)
; 2501 :             : word1(&u) << (32 - i);

  001e7	83 7c 24 48 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  001ec	7e 2c		 jle	 SHORT $LN166@Py_dg_dtoa
  001ee	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  001f3	2b 44 24 48	 sub	 eax, DWORD PTR i$[rsp]
  001f7	0f b6 c8	 movzx	 ecx, al
  001fa	8b 44 24 5c	 mov	 eax, DWORD PTR u$[rsp+4]
  001fe	d3 e0		 shl	 eax, cl
  00200	8b 4c 24 48	 mov	 ecx, DWORD PTR i$[rsp]
  00204	83 e9 20	 sub	 ecx, 32			; 00000020H
  00207	8b 54 24 58	 mov	 edx, DWORD PTR u$[rsp]
  0020b	d3 ea		 shr	 edx, cl
  0020d	8b ca		 mov	 ecx, edx
  0020f	0b c1		 or	 eax, ecx
  00211	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv149[rsp], eax
  00218	eb 19		 jmp	 SHORT $LN167@Py_dg_dtoa
$LN166@Py_dg_dtoa:
  0021a	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0021f	2b 44 24 48	 sub	 eax, DWORD PTR i$[rsp]
  00223	0f b6 c8	 movzx	 ecx, al
  00226	8b 44 24 58	 mov	 eax, DWORD PTR u$[rsp]
  0022a	d3 e0		 shl	 eax, cl
  0022c	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv149[rsp], eax
$LN167@Py_dg_dtoa:
  00233	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR tv149[rsp]
  0023a	89 44 24 38	 mov	 DWORD PTR x$[rsp], eax

; 2502 :         dval(&d2) = x;

  0023e	8b 44 24 38	 mov	 eax, DWORD PTR x$[rsp]
  00242	66 0f ef c0	 pxor	 xmm0, xmm0
  00246	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0024b	f2 0f 11 84 24
	88 00 00 00	 movsdx	 QWORD PTR d2$[rsp], xmm0

; 2503 :         word0(&d2) -= 31*Exp_msk1; /* adjust exponent */

  00254	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR d2$[rsp+4]
  0025b	2d 00 00 f0 01	 sub	 eax, 32505856		; 01f00000H
  00260	89 84 24 8c 00
	00 00		 mov	 DWORD PTR d2$[rsp+4], eax

; 2504 :         i -= (Bias + (P-1) - 1) + 1;

  00267	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  0026b	2d 33 04 00 00	 sub	 eax, 1075		; 00000433H
  00270	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax

; 2505 :         denorm = 1;

  00274	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR denorm$[rsp], 1
$LN156@Py_dg_dtoa:

; 2506 :     }
; 2507 :     ds = (dval(&d2)-1.5)*0.289529654602168 + 0.1760912590558 +
; 2508 :         i*0.301029995663981;

  0027f	f2 0f 10 84 24
	88 00 00 00	 movsdx	 xmm0, QWORD PTR d2$[rsp]
  00288	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff8000000000000
  00290	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fd287a7636f4361
  00298	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fc68a288b60c8b3
  002a0	66 0f 6e 4c 24
	48		 movd	 xmm1, DWORD PTR i$[rsp]
  002a6	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  002aa	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3fd34413509f79fb
  002b2	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002b6	f2 0f 11 84 24
	98 00 00 00	 movsdx	 QWORD PTR ds$[rsp], xmm0

; 2509 :     k = (int)ds;

  002bf	f2 0f 2c 84 24
	98 00 00 00	 cvttsd2si eax, QWORD PTR ds$[rsp]
  002c8	89 84 24 c4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 2510 :     if (ds < 0. && ds != k)

  002cf	66 0f 57 c0	 xorpd	 xmm0, xmm0
  002d3	66 0f 2f 84 24
	98 00 00 00	 comisd	 xmm0, QWORD PTR ds$[rsp]
  002dc	76 2e		 jbe	 SHORT $LN155@Py_dg_dtoa
  002de	66 0f 6e 84 24
	c4 00 00 00	 movd	 xmm0, DWORD PTR k$[rsp]
  002e7	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  002eb	f2 0f 10 8c 24
	98 00 00 00	 movsdx	 xmm1, QWORD PTR ds$[rsp]
  002f4	66 0f 2e c8	 ucomisd xmm1, xmm0
  002f8	7a 02		 jp	 SHORT $LN175@Py_dg_dtoa
  002fa	74 10		 je	 SHORT $LN155@Py_dg_dtoa
$LN175@Py_dg_dtoa:

; 2511 :         k--;    /* want k = floor(ds) */

  002fc	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00303	ff c8		 dec	 eax
  00305	89 84 24 c4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax
$LN155@Py_dg_dtoa:

; 2512 :     k_check = 1;

  0030c	c7 84 24 c8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR k_check$[rsp], 1

; 2513 :     if (k >= 0 && k <= Ten_pmax) {

  00317	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR k$[rsp], 0
  0031f	7c 41		 jl	 SHORT $LN154@Py_dg_dtoa
  00321	83 bc 24 c4 00
	00 00 16	 cmp	 DWORD PTR k$[rsp], 22
  00329	7f 37		 jg	 SHORT $LN154@Py_dg_dtoa

; 2514 :         if (dval(&u) < tens[k])

  0032b	48 63 84 24 c4
	00 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  0033a	f2 0f 10 04 c1	 movsdx	 xmm0, QWORD PTR [rcx+rax*8]
  0033f	66 0f 2f 44 24
	58		 comisd	 xmm0, QWORD PTR u$[rsp]
  00345	76 10		 jbe	 SHORT $LN153@Py_dg_dtoa

; 2515 :             k--;

  00347	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  0034e	ff c8		 dec	 eax
  00350	89 84 24 c4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax
$LN153@Py_dg_dtoa:

; 2516 :         k_check = 0;

  00357	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR k_check$[rsp], 0
$LN154@Py_dg_dtoa:

; 2517 :     }
; 2518 :     j = bbits - i - 1;

  00362	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00366	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR bbits$[rsp]
  0036d	2b c8		 sub	 ecx, eax
  0036f	8b c1		 mov	 eax, ecx
  00371	ff c8		 dec	 eax
  00373	89 84 24 fc 00
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 2519 :     if (j >= 0) {

  0037a	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  00382	7c 1b		 jl	 SHORT $LN152@Py_dg_dtoa

; 2520 :         b2 = 0;

  00384	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR b2$[rsp], 0

; 2521 :         s2 = j;

  0038f	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00396	89 84 24 c0 00
	00 00		 mov	 DWORD PTR s2$[rsp], eax

; 2522 :     }
; 2523 :     else {

  0039d	eb 1b		 jmp	 SHORT $LN151@Py_dg_dtoa
$LN152@Py_dg_dtoa:

; 2524 :         b2 = -j;

  0039f	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  003a6	f7 d8		 neg	 eax
  003a8	89 84 24 80 00
	00 00		 mov	 DWORD PTR b2$[rsp], eax

; 2525 :         s2 = 0;

  003af	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR s2$[rsp], 0
$LN151@Py_dg_dtoa:

; 2526 :     }
; 2527 :     if (k >= 0) {

  003ba	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR k$[rsp], 0
  003c2	7c 31		 jl	 SHORT $LN150@Py_dg_dtoa

; 2528 :         b5 = 0;

  003c4	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR b5$[rsp], 0

; 2529 :         s5 = k;

  003cc	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  003d3	89 84 24 b0 00
	00 00		 mov	 DWORD PTR s5$[rsp], eax

; 2530 :         s2 += k;

  003da	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  003e1	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR s2$[rsp]
  003e8	03 c8		 add	 ecx, eax
  003ea	8b c1		 mov	 eax, ecx
  003ec	89 84 24 c0 00
	00 00		 mov	 DWORD PTR s2$[rsp], eax

; 2531 :     }
; 2532 :     else {

  003f3	eb 31		 jmp	 SHORT $LN149@Py_dg_dtoa
$LN150@Py_dg_dtoa:

; 2533 :         b2 -= k;

  003f5	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  003fc	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR b2$[rsp]
  00403	2b c8		 sub	 ecx, eax
  00405	8b c1		 mov	 eax, ecx
  00407	89 84 24 80 00
	00 00		 mov	 DWORD PTR b2$[rsp], eax

; 2534 :         b5 = -k;

  0040e	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00415	f7 d8		 neg	 eax
  00417	89 44 24 24	 mov	 DWORD PTR b5$[rsp], eax

; 2535 :         s5 = 0;

  0041b	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR s5$[rsp], 0
$LN149@Py_dg_dtoa:

; 2536 :     }
; 2537 :     if (mode < 0 || mode > 9)

  00426	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR mode$[rsp], 0
  0042e	7c 0a		 jl	 SHORT $LN147@Py_dg_dtoa
  00430	83 bc 24 48 01
	00 00 09	 cmp	 DWORD PTR mode$[rsp], 9
  00438	7e 0b		 jle	 SHORT $LN148@Py_dg_dtoa
$LN147@Py_dg_dtoa:

; 2538 :         mode = 0;

  0043a	c7 84 24 48 01
	00 00 00 00 00
	00		 mov	 DWORD PTR mode$[rsp], 0
$LN148@Py_dg_dtoa:

; 2539 : 
; 2540 :     try_quick = 1;

  00445	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR try_quick$[rsp], 1

; 2541 : 
; 2542 :     if (mode > 5) {

  00450	83 bc 24 48 01
	00 00 05	 cmp	 DWORD PTR mode$[rsp], 5
  00458	7e 1c		 jle	 SHORT $LN146@Py_dg_dtoa

; 2543 :         mode -= 4;

  0045a	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR mode$[rsp]
  00461	83 e8 04	 sub	 eax, 4
  00464	89 84 24 48 01
	00 00		 mov	 DWORD PTR mode$[rsp], eax

; 2544 :         try_quick = 0;

  0046b	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR try_quick$[rsp], 0
$LN146@Py_dg_dtoa:

; 2545 :     }
; 2546 :     leftright = 1;

  00476	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR leftright$[rsp], 1

; 2547 :     ilim = ilim1 = -1;  /* Values for cases 0 and 1; done here to */

  0047e	c7 84 24 90 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ilim1$[rsp], -1
  00489	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR ilim1$[rsp]
  00490	89 84 24 e8 00
	00 00		 mov	 DWORD PTR ilim$[rsp], eax

; 2548 :     /* silence erroneous "gcc -Wall" warning. */
; 2549 :     switch(mode) {

  00497	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR mode$[rsp]
  0049e	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv186[rsp], eax
  004a5	83 bc 24 08 01
	00 00 05	 cmp	 DWORD PTR tv186[rsp], 5
  004ad	0f 87 bb 00 00
	00		 ja	 $LN144@Py_dg_dtoa
  004b3	48 63 84 24 08
	01 00 00	 movsxd	 rax, DWORD PTR tv186[rsp]
  004bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  004c2	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN174@Py_dg_dtoa[rcx+rax*4]
  004c9	48 03 c1	 add	 rax, rcx
  004cc	ff e0		 jmp	 rax
$LN143@Py_dg_dtoa:

; 2550 :     case 0:
; 2551 :     case 1:
; 2552 :         i = 18;

  004ce	c7 44 24 48 12
	00 00 00	 mov	 DWORD PTR i$[rsp], 18

; 2553 :         ndigits = 0;

  004d6	c7 84 24 50 01
	00 00 00 00 00
	00		 mov	 DWORD PTR ndigits$[rsp], 0

; 2554 :         break;

  004e1	e9 88 00 00 00	 jmp	 $LN144@Py_dg_dtoa
$LN142@Py_dg_dtoa:

; 2555 :     case 2:
; 2556 :         leftright = 0;

  004e6	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR leftright$[rsp], 0
$LN141@Py_dg_dtoa:

; 2557 :         /* no break */
; 2558 :     case 4:
; 2559 :         if (ndigits <= 0)

  004ee	83 bc 24 50 01
	00 00 00	 cmp	 DWORD PTR ndigits$[rsp], 0
  004f6	7f 0b		 jg	 SHORT $LN140@Py_dg_dtoa

; 2560 :             ndigits = 1;

  004f8	c7 84 24 50 01
	00 00 01 00 00
	00		 mov	 DWORD PTR ndigits$[rsp], 1
$LN140@Py_dg_dtoa:

; 2561 :         ilim = ilim1 = i = ndigits;

  00503	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR ndigits$[rsp]
  0050a	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
  0050e	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00512	89 84 24 90 00
	00 00		 mov	 DWORD PTR ilim1$[rsp], eax
  00519	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR ilim1$[rsp]
  00520	89 84 24 e8 00
	00 00		 mov	 DWORD PTR ilim$[rsp], eax

; 2562 :         break;

  00527	eb 45		 jmp	 SHORT $LN144@Py_dg_dtoa
$LN139@Py_dg_dtoa:

; 2563 :     case 3:
; 2564 :         leftright = 0;

  00529	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR leftright$[rsp], 0
$LN138@Py_dg_dtoa:

; 2565 :         /* no break */
; 2566 :     case 5:
; 2567 :         i = ndigits + k + 1;

  00531	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR ndigits$[rsp]
  00538	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR k$[rsp]
  0053f	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00543	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax

; 2568 :         ilim = i;

  00547	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  0054b	89 84 24 e8 00
	00 00		 mov	 DWORD PTR ilim$[rsp], eax

; 2569 :         ilim1 = i - 1;

  00552	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00556	ff c8		 dec	 eax
  00558	89 84 24 90 00
	00 00		 mov	 DWORD PTR ilim1$[rsp], eax

; 2570 :         if (i <= 0)

  0055f	83 7c 24 48 00	 cmp	 DWORD PTR i$[rsp], 0
  00564	7f 08		 jg	 SHORT $LN137@Py_dg_dtoa

; 2571 :             i = 1;

  00566	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
$LN137@Py_dg_dtoa:
$LN144@Py_dg_dtoa:

; 2572 :     }
; 2573 :     s0 = rv_alloc(i);

  0056e	8b 4c 24 48	 mov	 ecx, DWORD PTR i$[rsp]
  00572	e8 00 00 00 00	 call	 rv_alloc
  00577	48 89 44 24 40	 mov	 QWORD PTR s0$[rsp], rax

; 2574 :     if (s0 == NULL)

  0057c	48 83 7c 24 40
	00		 cmp	 QWORD PTR s0$[rsp], 0
  00582	75 05		 jne	 SHORT $LN136@Py_dg_dtoa

; 2575 :         goto failed_malloc;

  00584	e9 bd 12 00 00	 jmp	 $failed_malloc$21255
$LN136@Py_dg_dtoa:

; 2576 :     s = s0;

  00589	48 8b 44 24 40	 mov	 rax, QWORD PTR s0$[rsp]
  0058e	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2577 : 
; 2578 : 
; 2579 :     if (ilim >= 0 && ilim <= Quick_max && try_quick) {

  00593	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR ilim$[rsp], 0
  0059b	0f 8c 80 05 00
	00		 jl	 $LN135@Py_dg_dtoa
  005a1	83 bc 24 e8 00
	00 00 0e	 cmp	 DWORD PTR ilim$[rsp], 14
  005a9	0f 8f 72 05 00
	00		 jg	 $LN135@Py_dg_dtoa
  005af	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR try_quick$[rsp], 0
  005b7	0f 84 64 05 00
	00		 je	 $LN135@Py_dg_dtoa

; 2580 : 
; 2581 :         /* Try to get by with floating-point arithmetic. */
; 2582 : 
; 2583 :         i = 0;

  005bd	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 2584 :         dval(&d2) = dval(&u);

  005c5	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  005cb	f2 0f 11 84 24
	88 00 00 00	 movsdx	 QWORD PTR d2$[rsp], xmm0

; 2585 :         k0 = k;

  005d4	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  005db	89 44 24 68	 mov	 DWORD PTR k0$[rsp], eax

; 2586 :         ilim0 = ilim;

  005df	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR ilim$[rsp]
  005e6	89 84 24 00 01
	00 00		 mov	 DWORD PTR ilim0$[rsp], eax

; 2587 :         ieps = 2; /* conservative */

  005ed	c7 84 24 a8 00
	00 00 02 00 00
	00		 mov	 DWORD PTR ieps$[rsp], 2

; 2588 :         if (k > 0) {

  005f8	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR k$[rsp], 0
  00600	0f 8e f8 00 00
	00		 jle	 $LN134@Py_dg_dtoa

; 2589 :             ds = tens[k&0xf];

  00606	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  0060d	83 e0 0f	 and	 eax, 15
  00610	48 98		 cdqe
  00612	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  00619	f2 0f 10 04 c1	 movsdx	 xmm0, QWORD PTR [rcx+rax*8]
  0061e	f2 0f 11 84 24
	98 00 00 00	 movsdx	 QWORD PTR ds$[rsp], xmm0

; 2590 :             j = k >> 4;

  00627	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  0062e	c1 f8 04	 sar	 eax, 4
  00631	89 84 24 fc 00
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 2591 :             if (j & Bletch) {

  00638	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  0063f	83 e0 10	 and	 eax, 16
  00642	85 c0		 test	 eax, eax
  00644	74 35		 je	 SHORT $LN133@Py_dg_dtoa

; 2592 :                 /* prevent overflows */
; 2593 :                 j &= Bletch - 1;

  00646	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  0064d	83 e0 0f	 and	 eax, 15
  00650	89 84 24 fc 00
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 2594 :                 dval(&u) /= bigtens[n_bigtens-1];

  00657	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  0065d	f2 0f 5e 05 20
	00 00 00	 divsd	 xmm0, QWORD PTR bigtens+32
  00665	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0

; 2595 :                 ieps++;

  0066b	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ieps$[rsp]
  00672	ff c0		 inc	 eax
  00674	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ieps$[rsp], eax
$LN133@Py_dg_dtoa:

; 2596 :             }
; 2597 :             for(; j; j >>= 1, i++)

  0067b	eb 1a		 jmp	 SHORT $LN132@Py_dg_dtoa
$LN131@Py_dg_dtoa:
  0067d	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00684	d1 f8		 sar	 eax, 1
  00686	89 84 24 fc 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
  0068d	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00691	ff c0		 inc	 eax
  00693	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN132@Py_dg_dtoa:
  00697	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  0069f	74 43		 je	 SHORT $LN130@Py_dg_dtoa

; 2598 :                 if (j & 1) {

  006a1	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  006a8	83 e0 01	 and	 eax, 1
  006ab	85 c0		 test	 eax, eax
  006ad	74 33		 je	 SHORT $LN129@Py_dg_dtoa

; 2599 :                     ieps++;

  006af	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ieps$[rsp]
  006b6	ff c0		 inc	 eax
  006b8	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ieps$[rsp], eax

; 2600 :                     ds *= bigtens[i];

  006bf	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  006c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bigtens
  006cb	f2 0f 10 84 24
	98 00 00 00	 movsdx	 xmm0, QWORD PTR ds$[rsp]
  006d4	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  006d9	f2 0f 11 84 24
	98 00 00 00	 movsdx	 QWORD PTR ds$[rsp], xmm0
$LN129@Py_dg_dtoa:

; 2601 :                 }

  006e2	eb 99		 jmp	 SHORT $LN131@Py_dg_dtoa
$LN130@Py_dg_dtoa:

; 2602 :             dval(&u) /= ds;

  006e4	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  006ea	f2 0f 5e 84 24
	98 00 00 00	 divsd	 xmm0, QWORD PTR ds$[rsp]
  006f3	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0
  006f9	e9 b6 00 00 00	 jmp	 $LN128@Py_dg_dtoa
$LN134@Py_dg_dtoa:

; 2603 :         }
; 2604 :         else if ((j1 = -k)) {

  006fe	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00705	f7 d8		 neg	 eax
  00707	89 84 24 b8 00
	00 00		 mov	 DWORD PTR j1$[rsp], eax
  0070e	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR j1$[rsp], 0
  00716	0f 84 98 00 00
	00		 je	 $LN127@Py_dg_dtoa

; 2605 :             dval(&u) *= tens[j1 & 0xf];

  0071c	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR j1$[rsp]
  00723	83 e0 0f	 and	 eax, 15
  00726	48 98		 cdqe
  00728	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  0072f	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00735	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  0073a	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0

; 2606 :             for(j = j1 >> 4; j; j >>= 1, i++)

  00740	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR j1$[rsp]
  00747	c1 f8 04	 sar	 eax, 4
  0074a	89 84 24 fc 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
  00751	eb 1a		 jmp	 SHORT $LN126@Py_dg_dtoa
$LN125@Py_dg_dtoa:
  00753	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  0075a	d1 f8		 sar	 eax, 1
  0075c	89 84 24 fc 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
  00763	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00767	ff c0		 inc	 eax
  00769	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN126@Py_dg_dtoa:
  0076d	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  00775	74 3d		 je	 SHORT $LN124@Py_dg_dtoa

; 2607 :                 if (j & 1) {

  00777	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  0077e	83 e0 01	 and	 eax, 1
  00781	85 c0		 test	 eax, eax
  00783	74 2d		 je	 SHORT $LN123@Py_dg_dtoa

; 2608 :                     ieps++;

  00785	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ieps$[rsp]
  0078c	ff c0		 inc	 eax
  0078e	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ieps$[rsp], eax

; 2609 :                     dval(&u) *= bigtens[i];

  00795	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  0079a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:bigtens
  007a1	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  007a7	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  007ac	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0
$LN123@Py_dg_dtoa:

; 2610 :                 }
; 2611 :         }

  007b2	eb 9f		 jmp	 SHORT $LN125@Py_dg_dtoa
$LN124@Py_dg_dtoa:
$LN127@Py_dg_dtoa:
$LN128@Py_dg_dtoa:

; 2612 :         if (k_check && dval(&u) < 1. && ilim > 0) {

  007b4	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR k_check$[rsp], 0
  007bc	74 6b		 je	 SHORT $LN122@Py_dg_dtoa
  007be	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  007c6	66 0f 2f 44 24
	58		 comisd	 xmm0, QWORD PTR u$[rsp]
  007cc	76 5b		 jbe	 SHORT $LN122@Py_dg_dtoa
  007ce	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR ilim$[rsp], 0
  007d6	7e 51		 jle	 SHORT $LN122@Py_dg_dtoa

; 2613 :             if (ilim1 <= 0)

  007d8	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR ilim1$[rsp], 0
  007e0	7f 05		 jg	 SHORT $LN121@Py_dg_dtoa

; 2614 :                 goto fast_failed;

  007e2	e9 08 03 00 00	 jmp	 $fast_failed$21298
$LN121@Py_dg_dtoa:

; 2615 :             ilim = ilim1;

  007e7	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR ilim1$[rsp]
  007ee	89 84 24 e8 00
	00 00		 mov	 DWORD PTR ilim$[rsp], eax

; 2616 :             k--;

  007f5	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  007fc	ff c8		 dec	 eax
  007fe	89 84 24 c4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 2617 :             dval(&u) *= 10.;

  00805	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  0080b	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4024000000000000
  00813	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0

; 2618 :             ieps++;

  00819	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ieps$[rsp]
  00820	ff c0		 inc	 eax
  00822	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ieps$[rsp], eax
$LN122@Py_dg_dtoa:

; 2619 :         }
; 2620 :         dval(&eps) = ieps*dval(&u) + 7.;

  00829	66 0f 6e 84 24
	a8 00 00 00	 movd	 xmm0, DWORD PTR ieps$[rsp]
  00832	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00836	f2 0f 59 44 24
	58		 mulsd	 xmm0, QWORD PTR u$[rsp]
  0083c	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@401c000000000000
  00844	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR eps$[rsp], xmm0

; 2621 :         word0(&eps) -= (P-1)*Exp_msk1;

  0084a	8b 44 24 64	 mov	 eax, DWORD PTR eps$[rsp+4]
  0084e	2d 00 00 40 03	 sub	 eax, 54525952		; 03400000H
  00853	89 44 24 64	 mov	 DWORD PTR eps$[rsp+4], eax

; 2622 :         if (ilim == 0) {

  00857	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR ilim$[rsp], 0
  0085f	75 5a		 jne	 SHORT $LN120@Py_dg_dtoa

; 2623 :             S = mhi = 0;

  00861	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR mhi$[rsp], 0
  0086a	48 8b 44 24 30	 mov	 rax, QWORD PTR mhi$[rsp]
  0086f	48 89 44 24 70	 mov	 QWORD PTR S$[rsp], rax

; 2624 :             dval(&u) -= 5.;

  00874	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  0087a	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@4014000000000000
  00882	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0

; 2625 :             if (dval(&u) > dval(&eps))

  00888	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  0088e	66 0f 2f 44 24
	60		 comisd	 xmm0, QWORD PTR eps$[rsp]
  00894	76 05		 jbe	 SHORT $LN119@Py_dg_dtoa

; 2626 :                 goto one_digit;

  00896	e9 25 09 00 00	 jmp	 $one_digit$21301
$LN119@Py_dg_dtoa:

; 2627 :             if (dval(&u) < -dval(&eps))

  0089b	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR eps$[rsp]
  008a1	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  008a9	66 0f 2f 44 24
	58		 comisd	 xmm0, QWORD PTR u$[rsp]
  008af	76 05		 jbe	 SHORT $LN118@Py_dg_dtoa

; 2628 :                 goto no_digits;

  008b1	e9 b4 08 00 00	 jmp	 $no_digits$21303
$LN118@Py_dg_dtoa:

; 2629 :             goto fast_failed;

  008b6	e9 34 02 00 00	 jmp	 $fast_failed$21298
$LN120@Py_dg_dtoa:

; 2630 :         }
; 2631 :         if (leftright) {

  008bb	83 7c 24 78 00	 cmp	 DWORD PTR leftright$[rsp], 0
  008c0	0f 84 fc 00 00
	00		 je	 $LN117@Py_dg_dtoa

; 2632 :             /* Use Steele & White method of only
; 2633 :              * generating digits needed.
; 2634 :              */
; 2635 :             dval(&eps) = 0.5/tens[ilim-1] - dval(&eps);

  008c6	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR ilim$[rsp]
  008cd	ff c8		 dec	 eax
  008cf	48 98		 cdqe
  008d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  008d8	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3fe0000000000000
  008e0	f2 0f 5e 04 c1	 divsd	 xmm0, QWORD PTR [rcx+rax*8]
  008e5	f2 0f 5c 44 24
	60		 subsd	 xmm0, QWORD PTR eps$[rsp]
  008eb	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR eps$[rsp], xmm0

; 2636 :             for(i = 0;;) {

  008f1	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN116@Py_dg_dtoa:

; 2637 :                 L = (Long)dval(&u);

  008f9	f2 0f 2c 44 24
	58		 cvttsd2si eax, QWORD PTR u$[rsp]
  008ff	89 84 24 f8 00
	00 00		 mov	 DWORD PTR L$[rsp], eax

; 2638 :                 dval(&u) -= L;

  00906	66 0f 6e 84 24
	f8 00 00 00	 movd	 xmm0, DWORD PTR L$[rsp]
  0090f	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00913	f2 0f 10 4c 24
	58		 movsdx	 xmm1, QWORD PTR u$[rsp]
  00919	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0091d	66 0f 28 c1	 movapd	 xmm0, xmm1
  00921	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0

; 2639 :                 *s++ = '0' + (int)L;

  00927	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR L$[rsp]
  0092e	83 c0 30	 add	 eax, 48			; 00000030H
  00931	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00936	88 01		 mov	 BYTE PTR [rcx], al
  00938	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0093d	48 ff c0	 inc	 rax
  00940	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2640 :                 if (dval(&u) < dval(&eps))

  00945	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR eps$[rsp]
  0094b	66 0f 2f 44 24
	58		 comisd	 xmm0, QWORD PTR u$[rsp]
  00951	76 05		 jbe	 SHORT $LN114@Py_dg_dtoa

; 2641 :                     goto ret1;

  00953	e9 a4 0e 00 00	 jmp	 $ret1$21311
$LN114@Py_dg_dtoa:

; 2642 :                 if (1. - dval(&u) < dval(&eps))

  00958	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00960	f2 0f 5c 44 24
	58		 subsd	 xmm0, QWORD PTR u$[rsp]
  00966	f2 0f 10 4c 24
	60		 movsdx	 xmm1, QWORD PTR eps$[rsp]
  0096c	66 0f 2f c8	 comisd	 xmm1, xmm0
  00970	76 05		 jbe	 SHORT $LN113@Py_dg_dtoa

; 2643 :                     goto bump_up;

  00972	e9 2a 03 00 00	 jmp	 $bump_up$21313
$LN113@Py_dg_dtoa:

; 2644 :                 if (++i >= ilim)

  00977	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  0097b	ff c0		 inc	 eax
  0097d	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
  00981	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR ilim$[rsp]
  00988	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  0098c	7c 02		 jl	 SHORT $LN112@Py_dg_dtoa

; 2645 :                     break;

  0098e	eb 2d		 jmp	 SHORT $LN115@Py_dg_dtoa
$LN112@Py_dg_dtoa:

; 2646 :                 dval(&eps) *= 10.;

  00990	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR eps$[rsp]
  00996	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4024000000000000
  0099e	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR eps$[rsp], xmm0

; 2647 :                 dval(&u) *= 10.;

  009a4	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  009aa	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4024000000000000
  009b2	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0

; 2648 :             }

  009b8	e9 3c ff ff ff	 jmp	 $LN116@Py_dg_dtoa
$LN115@Py_dg_dtoa:

; 2649 :         }
; 2650 :         else {

  009bd	e9 2d 01 00 00	 jmp	 $LN111@Py_dg_dtoa
$LN117@Py_dg_dtoa:

; 2651 :             /* Generate ilim digits, then fix them up. */
; 2652 :             dval(&eps) *= tens[ilim-1];

  009c2	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR ilim$[rsp]
  009c9	ff c8		 dec	 eax
  009cb	48 98		 cdqe
  009cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  009d4	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR eps$[rsp]
  009da	f2 0f 59 04 c1	 mulsd	 xmm0, QWORD PTR [rcx+rax*8]
  009df	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR eps$[rsp], xmm0

; 2653 :             for(i = 1;; i++, dval(&u) *= 10.) {

  009e5	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  009ed	eb 1e		 jmp	 SHORT $LN110@Py_dg_dtoa
$LN109@Py_dg_dtoa:
  009ef	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  009f3	ff c0		 inc	 eax
  009f5	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
  009f9	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  009ff	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4024000000000000
  00a07	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0
$LN110@Py_dg_dtoa:

; 2654 :                 L = (Long)(dval(&u));

  00a0d	f2 0f 2c 44 24
	58		 cvttsd2si eax, QWORD PTR u$[rsp]
  00a13	89 84 24 f8 00
	00 00		 mov	 DWORD PTR L$[rsp], eax

; 2655 :                 if (!(dval(&u) -= L))

  00a1a	66 0f 6e 84 24
	f8 00 00 00	 movd	 xmm0, DWORD PTR L$[rsp]
  00a23	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00a27	f2 0f 10 4c 24
	58		 movsdx	 xmm1, QWORD PTR u$[rsp]
  00a2d	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00a31	66 0f 28 c1	 movapd	 xmm0, xmm1
  00a35	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0
  00a3b	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00a41	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00a49	7a 0d		 jp	 SHORT $LN107@Py_dg_dtoa
  00a4b	75 0b		 jne	 SHORT $LN107@Py_dg_dtoa

; 2656 :                     ilim = i;

  00a4d	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00a51	89 84 24 e8 00
	00 00		 mov	 DWORD PTR ilim$[rsp], eax
$LN107@Py_dg_dtoa:

; 2657 :                 *s++ = '0' + (int)L;

  00a58	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR L$[rsp]
  00a5f	83 c0 30	 add	 eax, 48			; 00000030H
  00a62	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00a67	88 01		 mov	 BYTE PTR [rcx], al
  00a69	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00a6e	48 ff c0	 inc	 rax
  00a71	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2658 :                 if (i == ilim) {

  00a76	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR ilim$[rsp]
  00a7d	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  00a81	75 67		 jne	 SHORT $LN106@Py_dg_dtoa

; 2659 :                     if (dval(&u) > 0.5 + dval(&eps))

  00a83	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3fe0000000000000
  00a8b	f2 0f 58 44 24
	60		 addsd	 xmm0, QWORD PTR eps$[rsp]
  00a91	f2 0f 10 4c 24
	58		 movsdx	 xmm1, QWORD PTR u$[rsp]
  00a97	66 0f 2f c8	 comisd	 xmm1, xmm0
  00a9b	76 07		 jbe	 SHORT $LN105@Py_dg_dtoa

; 2660 :                         goto bump_up;

  00a9d	e9 ff 01 00 00	 jmp	 $bump_up$21313
  00aa2	eb 44		 jmp	 SHORT $LN104@Py_dg_dtoa
$LN105@Py_dg_dtoa:

; 2661 :                     else if (dval(&u) < 0.5 - dval(&eps)) {

  00aa4	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3fe0000000000000
  00aac	f2 0f 5c 44 24
	60		 subsd	 xmm0, QWORD PTR eps$[rsp]
  00ab2	66 0f 2f 44 24
	58		 comisd	 xmm0, QWORD PTR u$[rsp]
  00ab8	76 2e		 jbe	 SHORT $LN103@Py_dg_dtoa
$LN102@Py_dg_dtoa:

; 2662 :                         while(*--s == '0');

  00aba	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00abf	48 ff c8	 dec	 rax
  00ac2	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax
  00ac7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00acc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00acf	83 f8 30	 cmp	 eax, 48			; 00000030H
  00ad2	75 02		 jne	 SHORT $LN101@Py_dg_dtoa
  00ad4	eb e4		 jmp	 SHORT $LN102@Py_dg_dtoa
$LN101@Py_dg_dtoa:

; 2663 :                         s++;

  00ad6	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00adb	48 ff c0	 inc	 rax
  00ade	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2664 :                         goto ret1;

  00ae3	e9 14 0d 00 00	 jmp	 $ret1$21311
$LN103@Py_dg_dtoa:
$LN104@Py_dg_dtoa:

; 2665 :                     }
; 2666 :                     break;

  00ae8	eb 05		 jmp	 SHORT $LN108@Py_dg_dtoa
$LN106@Py_dg_dtoa:

; 2667 :                 }
; 2668 :             }

  00aea	e9 00 ff ff ff	 jmp	 $LN109@Py_dg_dtoa
$LN108@Py_dg_dtoa:
$LN111@Py_dg_dtoa:
$fast_failed$21298:

; 2669 :         }
; 2670 :       fast_failed:
; 2671 :         s = s0;

  00aef	48 8b 44 24 40	 mov	 rax, QWORD PTR s0$[rsp]
  00af4	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2672 :         dval(&u) = dval(&d2);

  00af9	f2 0f 10 84 24
	88 00 00 00	 movsdx	 xmm0, QWORD PTR d2$[rsp]
  00b02	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0

; 2673 :         k = k0;

  00b08	8b 44 24 68	 mov	 eax, DWORD PTR k0$[rsp]
  00b0c	89 84 24 c4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 2674 :         ilim = ilim0;

  00b13	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR ilim0$[rsp]
  00b1a	89 84 24 e8 00
	00 00		 mov	 DWORD PTR ilim$[rsp], eax
$LN135@Py_dg_dtoa:

; 2675 :     }
; 2676 : 
; 2677 :     /* Do we have a "small" integer? */
; 2678 : 
; 2679 :     if (be >= 0 && k <= Int_max) {

  00b21	83 7c 24 7c 00	 cmp	 DWORD PTR be$[rsp], 0
  00b26	0f 8c e1 01 00
	00		 jl	 $LN100@Py_dg_dtoa
  00b2c	83 bc 24 c4 00
	00 00 0e	 cmp	 DWORD PTR k$[rsp], 14
  00b34	0f 8f d3 01 00
	00		 jg	 $LN100@Py_dg_dtoa

; 2680 :         /* Yes. */
; 2681 :         ds = tens[k];

  00b3a	48 63 84 24 c4
	00 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  00b42	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tens
  00b49	f2 0f 10 04 c1	 movsdx	 xmm0, QWORD PTR [rcx+rax*8]
  00b4e	f2 0f 11 84 24
	98 00 00 00	 movsdx	 QWORD PTR ds$[rsp], xmm0

; 2682 :         if (ndigits < 0 && ilim <= 0) {

  00b57	83 bc 24 50 01
	00 00 00	 cmp	 DWORD PTR ndigits$[rsp], 0
  00b5f	7d 4a		 jge	 SHORT $LN99@Py_dg_dtoa
  00b61	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR ilim$[rsp], 0
  00b69	7f 40		 jg	 SHORT $LN99@Py_dg_dtoa

; 2683 :             S = mhi = 0;

  00b6b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR mhi$[rsp], 0
  00b74	48 8b 44 24 30	 mov	 rax, QWORD PTR mhi$[rsp]
  00b79	48 89 44 24 70	 mov	 QWORD PTR S$[rsp], rax

; 2684 :             if (ilim < 0 || dval(&u) <= 5*ds)

  00b7e	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR ilim$[rsp], 0
  00b86	7c 19		 jl	 SHORT $LN97@Py_dg_dtoa
  00b88	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4014000000000000
  00b90	f2 0f 59 84 24
	98 00 00 00	 mulsd	 xmm0, QWORD PTR ds$[rsp]
  00b99	66 0f 2f 44 24
	58		 comisd	 xmm0, QWORD PTR u$[rsp]
  00b9f	72 05		 jb	 SHORT $LN98@Py_dg_dtoa
$LN97@Py_dg_dtoa:

; 2685 :                 goto no_digits;

  00ba1	e9 c4 05 00 00	 jmp	 $no_digits$21303
$LN98@Py_dg_dtoa:

; 2686 :             goto one_digit;

  00ba6	e9 15 06 00 00	 jmp	 $one_digit$21301
$LN99@Py_dg_dtoa:

; 2687 :         }
; 2688 :         for(i = 1;; i++, dval(&u) *= 10.) {

  00bab	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00bb3	eb 1e		 jmp	 SHORT $LN96@Py_dg_dtoa
$LN95@Py_dg_dtoa:
  00bb5	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00bb9	ff c0		 inc	 eax
  00bbb	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
  00bbf	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00bc5	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4024000000000000
  00bcd	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0
$LN96@Py_dg_dtoa:

; 2689 :             L = (Long)(dval(&u) / ds);

  00bd3	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00bd9	f2 0f 5e 84 24
	98 00 00 00	 divsd	 xmm0, QWORD PTR ds$[rsp]
  00be2	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00be6	89 84 24 f8 00
	00 00		 mov	 DWORD PTR L$[rsp], eax

; 2690 :             dval(&u) -= L*ds;

  00bed	66 0f 6e 84 24
	f8 00 00 00	 movd	 xmm0, DWORD PTR L$[rsp]
  00bf6	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00bfa	f2 0f 59 84 24
	98 00 00 00	 mulsd	 xmm0, QWORD PTR ds$[rsp]
  00c03	f2 0f 10 4c 24
	58		 movsdx	 xmm1, QWORD PTR u$[rsp]
  00c09	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00c0d	66 0f 28 c1	 movapd	 xmm0, xmm1
  00c11	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0

; 2691 :             *s++ = '0' + (int)L;

  00c17	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR L$[rsp]
  00c1e	83 c0 30	 add	 eax, 48			; 00000030H
  00c21	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00c26	88 01		 mov	 BYTE PTR [rcx], al
  00c28	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00c2d	48 ff c0	 inc	 rax
  00c30	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2692 :             if (!dval(&u)) {

  00c35	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00c3b	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00c43	7a 07		 jp	 SHORT $LN93@Py_dg_dtoa
  00c45	75 05		 jne	 SHORT $LN93@Py_dg_dtoa

; 2693 :                 break;

  00c47	e9 bc 00 00 00	 jmp	 $LN94@Py_dg_dtoa
$LN93@Py_dg_dtoa:

; 2694 :             }
; 2695 :             if (i == ilim) {

  00c4c	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR ilim$[rsp]
  00c53	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  00c57	0f 85 a6 00 00
	00		 jne	 $LN92@Py_dg_dtoa

; 2696 :                 dval(&u) += dval(&u);

  00c5d	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00c63	f2 0f 58 44 24
	58		 addsd	 xmm0, QWORD PTR u$[rsp]
  00c69	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR u$[rsp], xmm0

; 2697 :                 if (dval(&u) > ds || (dval(&u) == ds && L & 1)) {

  00c6f	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00c75	66 0f 2f 84 24
	98 00 00 00	 comisd	 xmm0, QWORD PTR ds$[rsp]
  00c7e	77 21		 ja	 SHORT $LN90@Py_dg_dtoa
  00c80	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR u$[rsp]
  00c86	66 0f 2e 84 24
	98 00 00 00	 ucomisd xmm0, QWORD PTR ds$[rsp]
  00c8f	7a 70		 jp	 SHORT $LN91@Py_dg_dtoa
  00c91	75 6e		 jne	 SHORT $LN91@Py_dg_dtoa
  00c93	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR L$[rsp]
  00c9a	83 e0 01	 and	 eax, 1
  00c9d	85 c0		 test	 eax, eax
  00c9f	74 60		 je	 SHORT $LN91@Py_dg_dtoa
$LN90@Py_dg_dtoa:
$bump_up$21313:
$LN89@Py_dg_dtoa:

; 2698 :                   bump_up:
; 2699 :                     while(*--s == '9')

  00ca1	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00ca6	48 ff c8	 dec	 rax
  00ca9	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax
  00cae	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00cb3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00cb6	83 f8 39	 cmp	 eax, 57			; 00000039H
  00cb9	75 28		 jne	 SHORT $LN88@Py_dg_dtoa

; 2700 :                         if (s == s0) {

  00cbb	48 8b 44 24 40	 mov	 rax, QWORD PTR s0$[rsp]
  00cc0	48 39 44 24 50	 cmp	 QWORD PTR s$[rsp], rax
  00cc5	75 1a		 jne	 SHORT $LN87@Py_dg_dtoa

; 2701 :                             k++;

  00cc7	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00cce	ff c0		 inc	 eax
  00cd0	89 84 24 c4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 2702 :                             *s = '0';

  00cd7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00cdc	c6 00 30	 mov	 BYTE PTR [rax], 48	; 00000030H

; 2703 :                             break;

  00cdf	eb 02		 jmp	 SHORT $LN88@Py_dg_dtoa
$LN87@Py_dg_dtoa:

; 2704 :                         }

  00ce1	eb be		 jmp	 SHORT $LN89@Py_dg_dtoa
$LN88@Py_dg_dtoa:

; 2705 :                     ++*s++;

  00ce3	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00ce8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00ceb	fe c0		 inc	 al
  00ced	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00cf2	88 01		 mov	 BYTE PTR [rcx], al
  00cf4	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00cf9	48 ff c0	 inc	 rax
  00cfc	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax
$LN91@Py_dg_dtoa:

; 2706 :                 }
; 2707 :                 break;

  00d01	eb 05		 jmp	 SHORT $LN94@Py_dg_dtoa
$LN92@Py_dg_dtoa:

; 2708 :             }
; 2709 :         }

  00d03	e9 ad fe ff ff	 jmp	 $LN95@Py_dg_dtoa
$LN94@Py_dg_dtoa:

; 2710 :         goto ret1;

  00d08	e9 ef 0a 00 00	 jmp	 $ret1$21311
$LN100@Py_dg_dtoa:

; 2711 :     }
; 2712 : 
; 2713 :     m2 = b2;

  00d0d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR b2$[rsp]
  00d14	89 84 24 b4 00
	00 00		 mov	 DWORD PTR m2$[rsp], eax

; 2714 :     m5 = b5;

  00d1b	8b 44 24 24	 mov	 eax, DWORD PTR b5$[rsp]
  00d1f	89 44 24 2c	 mov	 DWORD PTR m5$[rsp], eax

; 2715 :     if (leftright) {

  00d23	83 7c 24 78 00	 cmp	 DWORD PTR leftright$[rsp], 0
  00d28	0f 84 82 00 00
	00		 je	 $LN86@Py_dg_dtoa

; 2716 :         i =
; 2717 :             denorm ? be + (Bias + (P-1) - 1 + 1) :
; 2718 :             1 + P - bbits;

  00d2e	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR denorm$[rsp], 0
  00d36	74 12		 je	 SHORT $LN168@Py_dg_dtoa
  00d38	8b 44 24 7c	 mov	 eax, DWORD PTR be$[rsp]
  00d3c	05 33 04 00 00	 add	 eax, 1075		; 00000433H
  00d41	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv373[rsp], eax
  00d48	eb 13		 jmp	 SHORT $LN169@Py_dg_dtoa
$LN168@Py_dg_dtoa:
  00d4a	b8 36 00 00 00	 mov	 eax, 54			; 00000036H
  00d4f	2b 84 24 d8 00
	00 00		 sub	 eax, DWORD PTR bbits$[rsp]
  00d56	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv373[rsp], eax
$LN169@Py_dg_dtoa:
  00d5d	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR tv373[rsp]
  00d64	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax

; 2719 :         b2 += i;

  00d68	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00d6c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR b2$[rsp]
  00d73	03 c8		 add	 ecx, eax
  00d75	8b c1		 mov	 eax, ecx
  00d77	89 84 24 80 00
	00 00		 mov	 DWORD PTR b2$[rsp], eax

; 2720 :         s2 += i;

  00d7e	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00d82	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR s2$[rsp]
  00d89	03 c8		 add	 ecx, eax
  00d8b	8b c1		 mov	 eax, ecx
  00d8d	89 84 24 c0 00
	00 00		 mov	 DWORD PTR s2$[rsp], eax

; 2721 :         mhi = i2b(1);

  00d94	b9 01 00 00 00	 mov	 ecx, 1
  00d99	e8 00 00 00 00	 call	 i2b
  00d9e	48 89 44 24 30	 mov	 QWORD PTR mhi$[rsp], rax

; 2722 :         if (mhi == NULL)

  00da3	48 83 7c 24 30
	00		 cmp	 QWORD PTR mhi$[rsp], 0
  00da9	75 05		 jne	 SHORT $LN85@Py_dg_dtoa

; 2723 :             goto failed_malloc;

  00dab	e9 96 0a 00 00	 jmp	 $failed_malloc$21255
$LN85@Py_dg_dtoa:
$LN86@Py_dg_dtoa:

; 2724 :     }
; 2725 :     if (m2 > 0 && s2 > 0) {

  00db0	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR m2$[rsp], 0
  00db8	0f 8e 85 00 00
	00		 jle	 $LN84@Py_dg_dtoa
  00dbe	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR s2$[rsp], 0
  00dc6	7e 7b		 jle	 SHORT $LN84@Py_dg_dtoa

; 2726 :         i = m2 < s2 ? m2 : s2;

  00dc8	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR s2$[rsp]
  00dcf	39 84 24 b4 00
	00 00		 cmp	 DWORD PTR m2$[rsp], eax
  00dd6	7d 10		 jge	 SHORT $LN170@Py_dg_dtoa
  00dd8	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR m2$[rsp]
  00ddf	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv382[rsp], eax
  00de6	eb 0e		 jmp	 SHORT $LN171@Py_dg_dtoa
$LN170@Py_dg_dtoa:
  00de8	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR s2$[rsp]
  00def	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv382[rsp], eax
$LN171@Py_dg_dtoa:
  00df6	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR tv382[rsp]
  00dfd	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax

; 2727 :         b2 -= i;

  00e01	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00e05	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR b2$[rsp]
  00e0c	2b c8		 sub	 ecx, eax
  00e0e	8b c1		 mov	 eax, ecx
  00e10	89 84 24 80 00
	00 00		 mov	 DWORD PTR b2$[rsp], eax

; 2728 :         m2 -= i;

  00e17	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00e1b	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR m2$[rsp]
  00e22	2b c8		 sub	 ecx, eax
  00e24	8b c1		 mov	 eax, ecx
  00e26	89 84 24 b4 00
	00 00		 mov	 DWORD PTR m2$[rsp], eax

; 2729 :         s2 -= i;

  00e2d	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00e31	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR s2$[rsp]
  00e38	2b c8		 sub	 ecx, eax
  00e3a	8b c1		 mov	 eax, ecx
  00e3c	89 84 24 c0 00
	00 00		 mov	 DWORD PTR s2$[rsp], eax
$LN84@Py_dg_dtoa:

; 2730 :     }
; 2731 :     if (b5 > 0) {

  00e43	83 7c 24 24 00	 cmp	 DWORD PTR b5$[rsp], 0
  00e48	0f 8e ed 00 00
	00		 jle	 $LN83@Py_dg_dtoa

; 2732 :         if (leftright) {

  00e4e	83 7c 24 78 00	 cmp	 DWORD PTR leftright$[rsp], 0
  00e53	0f 84 b9 00 00
	00		 je	 $LN82@Py_dg_dtoa

; 2733 :             if (m5 > 0) {

  00e59	83 7c 24 2c 00	 cmp	 DWORD PTR m5$[rsp], 0
  00e5e	7e 67		 jle	 SHORT $LN81@Py_dg_dtoa

; 2734 :                 mhi = pow5mult(mhi, m5);

  00e60	8b 54 24 2c	 mov	 edx, DWORD PTR m5$[rsp]
  00e64	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mhi$[rsp]
  00e69	e8 00 00 00 00	 call	 pow5mult
  00e6e	48 89 44 24 30	 mov	 QWORD PTR mhi$[rsp], rax

; 2735 :                 if (mhi == NULL)

  00e73	48 83 7c 24 30
	00		 cmp	 QWORD PTR mhi$[rsp], 0
  00e79	75 05		 jne	 SHORT $LN80@Py_dg_dtoa

; 2736 :                     goto failed_malloc;

  00e7b	e9 c6 09 00 00	 jmp	 $failed_malloc$21255
$LN80@Py_dg_dtoa:

; 2737 :                 b1 = mult(mhi, b);

  00e80	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  00e88	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mhi$[rsp]
  00e8d	e8 00 00 00 00	 call	 mult
  00e92	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR b1$[rsp], rax

; 2738 :                 Bfree(b);

  00e9a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00ea2	e8 00 00 00 00	 call	 Bfree

; 2739 :                 b = b1;

  00ea7	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR b1$[rsp]
  00eaf	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2740 :                 if (b == NULL)

  00eb7	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  00ec0	75 05		 jne	 SHORT $LN79@Py_dg_dtoa

; 2741 :                     goto failed_malloc;

  00ec2	e9 7f 09 00 00	 jmp	 $failed_malloc$21255
$LN79@Py_dg_dtoa:
$LN81@Py_dg_dtoa:

; 2742 :             }
; 2743 :             if ((j = b5 - m5)) {

  00ec7	8b 44 24 2c	 mov	 eax, DWORD PTR m5$[rsp]
  00ecb	8b 4c 24 24	 mov	 ecx, DWORD PTR b5$[rsp]
  00ecf	2b c8		 sub	 ecx, eax
  00ed1	8b c1		 mov	 eax, ecx
  00ed3	89 84 24 fc 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
  00eda	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  00ee2	74 2c		 je	 SHORT $LN78@Py_dg_dtoa

; 2744 :                 b = pow5mult(b, j);

  00ee4	8b 94 24 fc 00
	00 00		 mov	 edx, DWORD PTR j$[rsp]
  00eeb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00ef3	e8 00 00 00 00	 call	 pow5mult
  00ef8	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2745 :                 if (b == NULL)

  00f00	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  00f09	75 05		 jne	 SHORT $LN77@Py_dg_dtoa

; 2746 :                     goto failed_malloc;

  00f0b	e9 36 09 00 00	 jmp	 $failed_malloc$21255
$LN77@Py_dg_dtoa:
$LN78@Py_dg_dtoa:

; 2747 :             }
; 2748 :         }
; 2749 :         else {

  00f10	eb 29		 jmp	 SHORT $LN76@Py_dg_dtoa
$LN82@Py_dg_dtoa:

; 2750 :             b = pow5mult(b, b5);

  00f12	8b 54 24 24	 mov	 edx, DWORD PTR b5$[rsp]
  00f16	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  00f1e	e8 00 00 00 00	 call	 pow5mult
  00f23	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2751 :             if (b == NULL)

  00f2b	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  00f34	75 05		 jne	 SHORT $LN75@Py_dg_dtoa

; 2752 :                 goto failed_malloc;

  00f36	e9 0b 09 00 00	 jmp	 $failed_malloc$21255
$LN75@Py_dg_dtoa:
$LN76@Py_dg_dtoa:
$LN83@Py_dg_dtoa:

; 2753 :         }
; 2754 :     }
; 2755 :     S = i2b(1);

  00f3b	b9 01 00 00 00	 mov	 ecx, 1
  00f40	e8 00 00 00 00	 call	 i2b
  00f45	48 89 44 24 70	 mov	 QWORD PTR S$[rsp], rax

; 2756 :     if (S == NULL)

  00f4a	48 83 7c 24 70
	00		 cmp	 QWORD PTR S$[rsp], 0
  00f50	75 05		 jne	 SHORT $LN74@Py_dg_dtoa

; 2757 :         goto failed_malloc;

  00f52	e9 ef 08 00 00	 jmp	 $failed_malloc$21255
$LN74@Py_dg_dtoa:

; 2758 :     if (s5 > 0) {

  00f57	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR s5$[rsp], 0
  00f5f	7e 23		 jle	 SHORT $LN73@Py_dg_dtoa

; 2759 :         S = pow5mult(S, s5);

  00f61	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR s5$[rsp]
  00f68	48 8b 4c 24 70	 mov	 rcx, QWORD PTR S$[rsp]
  00f6d	e8 00 00 00 00	 call	 pow5mult
  00f72	48 89 44 24 70	 mov	 QWORD PTR S$[rsp], rax

; 2760 :         if (S == NULL)

  00f77	48 83 7c 24 70
	00		 cmp	 QWORD PTR S$[rsp], 0
  00f7d	75 05		 jne	 SHORT $LN72@Py_dg_dtoa

; 2761 :             goto failed_malloc;

  00f7f	e9 c2 08 00 00	 jmp	 $failed_malloc$21255
$LN72@Py_dg_dtoa:
$LN73@Py_dg_dtoa:

; 2762 :     }
; 2763 : 
; 2764 :     /* Check for special case that d is a normalized power of 2. */
; 2765 : 
; 2766 :     spec_case = 0;

  00f84	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR spec_case$[rsp], 0

; 2767 :     if ((mode < 2 || leftright)
; 2768 :         ) {

  00f8c	83 bc 24 48 01
	00 00 02	 cmp	 DWORD PTR mode$[rsp], 2
  00f94	7c 07		 jl	 SHORT $LN70@Py_dg_dtoa
  00f96	83 7c 24 78 00	 cmp	 DWORD PTR leftright$[rsp], 0
  00f9b	74 49		 je	 SHORT $LN71@Py_dg_dtoa
$LN70@Py_dg_dtoa:

; 2769 :         if (!word1(&u) && !(word0(&u) & Bndry_mask)
; 2770 :             && word0(&u) & (Exp_mask & ~Exp_msk1)
; 2771 :             ) {

  00f9d	83 7c 24 58 00	 cmp	 DWORD PTR u$[rsp], 0
  00fa2	75 42		 jne	 SHORT $LN69@Py_dg_dtoa
  00fa4	8b 44 24 5c	 mov	 eax, DWORD PTR u$[rsp+4]
  00fa8	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  00fad	85 c0		 test	 eax, eax
  00faf	75 35		 jne	 SHORT $LN69@Py_dg_dtoa
  00fb1	8b 44 24 5c	 mov	 eax, DWORD PTR u$[rsp+4]
  00fb5	25 00 00 e0 7f	 and	 eax, 2145386496		; 7fe00000H
  00fba	85 c0		 test	 eax, eax
  00fbc	74 28		 je	 SHORT $LN69@Py_dg_dtoa

; 2772 :             /* The special case */
; 2773 :             b2 += Log2P;

  00fbe	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR b2$[rsp]
  00fc5	ff c0		 inc	 eax
  00fc7	89 84 24 80 00
	00 00		 mov	 DWORD PTR b2$[rsp], eax

; 2774 :             s2 += Log2P;

  00fce	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR s2$[rsp]
  00fd5	ff c0		 inc	 eax
  00fd7	89 84 24 c0 00
	00 00		 mov	 DWORD PTR s2$[rsp], eax

; 2775 :             spec_case = 1;

  00fde	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR spec_case$[rsp], 1
$LN69@Py_dg_dtoa:
$LN71@Py_dg_dtoa:

; 2776 :         }
; 2777 :     }
; 2778 : 
; 2779 :     /* Arrange for convenient computation of quotients:
; 2780 :      * shift left if necessary so divisor has 4 leading 0 bits.
; 2781 :      *
; 2782 :      * Perhaps we should just compute leading 28 bits of S once
; 2783 :      * and for all and pass them and a shift to quorem, so it
; 2784 :      * can do shifts and ors to compute the numerator for q.
; 2785 :      */
; 2786 : #define iInc 28
; 2787 :     i = dshift(S, s2);

  00fe6	8b 94 24 c0 00
	00 00		 mov	 edx, DWORD PTR s2$[rsp]
  00fed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR S$[rsp]
  00ff2	e8 00 00 00 00	 call	 dshift
  00ff7	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax

; 2788 :     b2 += i;

  00ffb	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00fff	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR b2$[rsp]
  01006	03 c8		 add	 ecx, eax
  01008	8b c1		 mov	 eax, ecx
  0100a	89 84 24 80 00
	00 00		 mov	 DWORD PTR b2$[rsp], eax

; 2789 :     m2 += i;

  01011	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  01015	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR m2$[rsp]
  0101c	03 c8		 add	 ecx, eax
  0101e	8b c1		 mov	 eax, ecx
  01020	89 84 24 b4 00
	00 00		 mov	 DWORD PTR m2$[rsp], eax

; 2790 :     s2 += i;

  01027	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  0102b	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR s2$[rsp]
  01032	03 c8		 add	 ecx, eax
  01034	8b c1		 mov	 eax, ecx
  01036	89 84 24 c0 00
	00 00		 mov	 DWORD PTR s2$[rsp], eax

; 2791 :     if (b2 > 0) {

  0103d	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR b2$[rsp], 0
  01045	7e 2c		 jle	 SHORT $LN68@Py_dg_dtoa

; 2792 :         b = lshift(b, b2);

  01047	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  0104e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  01056	e8 00 00 00 00	 call	 lshift
  0105b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2793 :         if (b == NULL)

  01063	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  0106c	75 05		 jne	 SHORT $LN67@Py_dg_dtoa

; 2794 :             goto failed_malloc;

  0106e	e9 d3 07 00 00	 jmp	 $failed_malloc$21255
$LN67@Py_dg_dtoa:
$LN68@Py_dg_dtoa:

; 2795 :     }
; 2796 :     if (s2 > 0) {

  01073	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR s2$[rsp], 0
  0107b	7e 23		 jle	 SHORT $LN66@Py_dg_dtoa

; 2797 :         S = lshift(S, s2);

  0107d	8b 94 24 c0 00
	00 00		 mov	 edx, DWORD PTR s2$[rsp]
  01084	48 8b 4c 24 70	 mov	 rcx, QWORD PTR S$[rsp]
  01089	e8 00 00 00 00	 call	 lshift
  0108e	48 89 44 24 70	 mov	 QWORD PTR S$[rsp], rax

; 2798 :         if (S == NULL)

  01093	48 83 7c 24 70
	00		 cmp	 QWORD PTR S$[rsp], 0
  01099	75 05		 jne	 SHORT $LN65@Py_dg_dtoa

; 2799 :             goto failed_malloc;

  0109b	e9 a6 07 00 00	 jmp	 $failed_malloc$21255
$LN65@Py_dg_dtoa:
$LN66@Py_dg_dtoa:

; 2800 :     }
; 2801 :     if (k_check) {

  010a0	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR k_check$[rsp], 0
  010a8	0f 84 8c 00 00
	00		 je	 $LN64@Py_dg_dtoa

; 2802 :         if (cmp(b,S) < 0) {

  010ae	48 8b 54 24 70	 mov	 rdx, QWORD PTR S$[rsp]
  010b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  010bb	e8 00 00 00 00	 call	 cmp
  010c0	85 c0		 test	 eax, eax
  010c2	7d 76		 jge	 SHORT $LN63@Py_dg_dtoa

; 2803 :             k--;

  010c4	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  010cb	ff c8		 dec	 eax
  010cd	89 84 24 c4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 2804 :             b = multadd(b, 10, 0);      /* we botched the k estimate */

  010d4	45 33 c0	 xor	 r8d, r8d
  010d7	ba 0a 00 00 00	 mov	 edx, 10
  010dc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  010e4	e8 00 00 00 00	 call	 multadd
  010e9	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2805 :             if (b == NULL)

  010f1	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  010fa	75 05		 jne	 SHORT $LN62@Py_dg_dtoa

; 2806 :                 goto failed_malloc;

  010fc	e9 45 07 00 00	 jmp	 $failed_malloc$21255
$LN62@Py_dg_dtoa:

; 2807 :             if (leftright) {

  01101	83 7c 24 78 00	 cmp	 DWORD PTR leftright$[rsp], 0
  01106	74 24		 je	 SHORT $LN61@Py_dg_dtoa

; 2808 :                 mhi = multadd(mhi, 10, 0);

  01108	45 33 c0	 xor	 r8d, r8d
  0110b	ba 0a 00 00 00	 mov	 edx, 10
  01110	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mhi$[rsp]
  01115	e8 00 00 00 00	 call	 multadd
  0111a	48 89 44 24 30	 mov	 QWORD PTR mhi$[rsp], rax

; 2809 :                 if (mhi == NULL)

  0111f	48 83 7c 24 30
	00		 cmp	 QWORD PTR mhi$[rsp], 0
  01125	75 05		 jne	 SHORT $LN60@Py_dg_dtoa

; 2810 :                     goto failed_malloc;

  01127	e9 1a 07 00 00	 jmp	 $failed_malloc$21255
$LN60@Py_dg_dtoa:
$LN61@Py_dg_dtoa:

; 2811 :             }
; 2812 :             ilim = ilim1;

  0112c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR ilim1$[rsp]
  01133	89 84 24 e8 00
	00 00		 mov	 DWORD PTR ilim$[rsp], eax
$LN63@Py_dg_dtoa:
$LN64@Py_dg_dtoa:

; 2813 :         }
; 2814 :     }
; 2815 :     if (ilim <= 0 && (mode == 3 || mode == 5)) {

  0113a	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR ilim$[rsp], 0
  01142	0f 8f a2 00 00
	00		 jg	 $LN59@Py_dg_dtoa
  01148	83 bc 24 48 01
	00 00 03	 cmp	 DWORD PTR mode$[rsp], 3
  01150	74 0e		 je	 SHORT $LN58@Py_dg_dtoa
  01152	83 bc 24 48 01
	00 00 05	 cmp	 DWORD PTR mode$[rsp], 5
  0115a	0f 85 8a 00 00
	00		 jne	 $LN59@Py_dg_dtoa
$LN58@Py_dg_dtoa:

; 2816 :         if (ilim < 0) {

  01160	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR ilim$[rsp], 0
  01168	7d 1a		 jge	 SHORT $LN57@Py_dg_dtoa
$no_digits$21303:

; 2817 :             /* no digits, fcvt style */
; 2818 :           no_digits:
; 2819 :             k = -1 - ndigits;

  0116a	b8 ff ff ff ff	 mov	 eax, -1
  0116f	2b 84 24 50 01
	00 00		 sub	 eax, DWORD PTR ndigits$[rsp]
  01176	89 84 24 c4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 2820 :             goto ret;

  0117d	e9 37 06 00 00	 jmp	 $ret$21388

; 2821 :         }
; 2822 :         else {

  01182	eb 3c		 jmp	 SHORT $LN56@Py_dg_dtoa
$LN57@Py_dg_dtoa:

; 2823 :             S = multadd(S, 5, 0);

  01184	45 33 c0	 xor	 r8d, r8d
  01187	ba 05 00 00 00	 mov	 edx, 5
  0118c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR S$[rsp]
  01191	e8 00 00 00 00	 call	 multadd
  01196	48 89 44 24 70	 mov	 QWORD PTR S$[rsp], rax

; 2824 :             if (S == NULL)

  0119b	48 83 7c 24 70
	00		 cmp	 QWORD PTR S$[rsp], 0
  011a1	75 05		 jne	 SHORT $LN55@Py_dg_dtoa

; 2825 :                 goto failed_malloc;

  011a3	e9 9e 06 00 00	 jmp	 $failed_malloc$21255
$LN55@Py_dg_dtoa:

; 2826 :             if (cmp(b, S) <= 0)

  011a8	48 8b 54 24 70	 mov	 rdx, QWORD PTR S$[rsp]
  011ad	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  011b5	e8 00 00 00 00	 call	 cmp
  011ba	85 c0		 test	 eax, eax
  011bc	7f 02		 jg	 SHORT $LN54@Py_dg_dtoa

; 2827 :                 goto no_digits;

  011be	eb aa		 jmp	 SHORT $no_digits$21303
$LN54@Py_dg_dtoa:
$LN56@Py_dg_dtoa:
$one_digit$21301:

; 2828 :         }
; 2829 :       one_digit:
; 2830 :         *s++ = '1';

  011c0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  011c5	c6 00 31	 mov	 BYTE PTR [rax], 49	; 00000031H
  011c8	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  011cd	48 ff c0	 inc	 rax
  011d0	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2831 :         k++;

  011d5	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  011dc	ff c0		 inc	 eax
  011de	89 84 24 c4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 2832 :         goto ret;

  011e5	e9 cf 05 00 00	 jmp	 $ret$21388
$LN59@Py_dg_dtoa:

; 2833 :     }
; 2834 :     if (leftright) {

  011ea	83 7c 24 78 00	 cmp	 DWORD PTR leftright$[rsp], 0
  011ef	0f 84 22 04 00
	00		 je	 $LN53@Py_dg_dtoa

; 2835 :         if (m2 > 0) {

  011f5	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR m2$[rsp], 0
  011fd	7e 23		 jle	 SHORT $LN52@Py_dg_dtoa

; 2836 :             mhi = lshift(mhi, m2);

  011ff	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR m2$[rsp]
  01206	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mhi$[rsp]
  0120b	e8 00 00 00 00	 call	 lshift
  01210	48 89 44 24 30	 mov	 QWORD PTR mhi$[rsp], rax

; 2837 :             if (mhi == NULL)

  01215	48 83 7c 24 30
	00		 cmp	 QWORD PTR mhi$[rsp], 0
  0121b	75 05		 jne	 SHORT $LN51@Py_dg_dtoa

; 2838 :                 goto failed_malloc;

  0121d	e9 24 06 00 00	 jmp	 $failed_malloc$21255
$LN51@Py_dg_dtoa:
$LN52@Py_dg_dtoa:

; 2839 :         }
; 2840 : 
; 2841 :         /* Compute mlo -- check for special case
; 2842 :          * that d is a normalized power of 2.
; 2843 :          */
; 2844 : 
; 2845 :         mlo = mhi;

  01222	48 8b 44 24 30	 mov	 rax, QWORD PTR mhi$[rsp]
  01227	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR mlo$[rsp], rax

; 2846 :         if (spec_case) {

  0122f	83 7c 24 28 00	 cmp	 DWORD PTR spec_case$[rsp], 0
  01234	0f 84 87 00 00
	00		 je	 $LN50@Py_dg_dtoa

; 2847 :             mhi = Balloc(mhi->k);

  0123a	48 8b 44 24 30	 mov	 rax, QWORD PTR mhi$[rsp]
  0123f	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  01242	e8 00 00 00 00	 call	 Balloc
  01247	48 89 44 24 30	 mov	 QWORD PTR mhi$[rsp], rax

; 2848 :             if (mhi == NULL)

  0124c	48 83 7c 24 30
	00		 cmp	 QWORD PTR mhi$[rsp], 0
  01252	75 05		 jne	 SHORT $LN49@Py_dg_dtoa

; 2849 :                 goto failed_malloc;

  01254	e9 ed 05 00 00	 jmp	 $failed_malloc$21255
$LN49@Py_dg_dtoa:

; 2850 :             Bcopy(mhi, mlo);

  01259	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR mlo$[rsp]
  01261	48 63 40 14	 movsxd	 rax, DWORD PTR [rax+20]
  01265	48 8d 04 85 08
	00 00 00	 lea	 rax, QWORD PTR [rax*4+8]
  0126d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR mlo$[rsp]
  01275	48 83 c1 10	 add	 rcx, 16
  01279	48 8b 54 24 30	 mov	 rdx, QWORD PTR mhi$[rsp]
  0127e	48 83 c2 10	 add	 rdx, 16
  01282	48 89 94 24 18
	01 00 00	 mov	 QWORD PTR tv495[rsp], rdx
  0128a	4c 8b c0	 mov	 r8, rax
  0128d	48 8b d1	 mov	 rdx, rcx
  01290	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tv495[rsp]
  01298	48 8b c8	 mov	 rcx, rax
  0129b	e8 00 00 00 00	 call	 memcpy

; 2851 :             mhi = lshift(mhi, Log2P);

  012a0	ba 01 00 00 00	 mov	 edx, 1
  012a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mhi$[rsp]
  012aa	e8 00 00 00 00	 call	 lshift
  012af	48 89 44 24 30	 mov	 QWORD PTR mhi$[rsp], rax

; 2852 :             if (mhi == NULL)

  012b4	48 83 7c 24 30
	00		 cmp	 QWORD PTR mhi$[rsp], 0
  012ba	75 05		 jne	 SHORT $LN48@Py_dg_dtoa

; 2853 :                 goto failed_malloc;

  012bc	e9 85 05 00 00	 jmp	 $failed_malloc$21255
$LN48@Py_dg_dtoa:
$LN50@Py_dg_dtoa:

; 2854 :         }
; 2855 : 
; 2856 :         for(i = 1;;i++) {

  012c1	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  012c9	eb 0a		 jmp	 SHORT $LN47@Py_dg_dtoa
$LN46@Py_dg_dtoa:
  012cb	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  012cf	ff c0		 inc	 eax
  012d1	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN47@Py_dg_dtoa:

; 2857 :             dig = quorem(b,S) + '0';

  012d5	48 8b 54 24 70	 mov	 rdx, QWORD PTR S$[rsp]
  012da	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  012e2	e8 00 00 00 00	 call	 quorem
  012e7	83 c0 30	 add	 eax, 48			; 00000030H
  012ea	89 44 24 20	 mov	 DWORD PTR dig$[rsp], eax

; 2858 :             /* Do we yet have the shortest decimal string
; 2859 :              * that will round to d?
; 2860 :              */
; 2861 :             j = cmp(b, mlo);

  012ee	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR mlo$[rsp]
  012f6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  012fe	e8 00 00 00 00	 call	 cmp
  01303	89 84 24 fc 00
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 2862 :             delta = diff(S, mhi);

  0130a	48 8b 54 24 30	 mov	 rdx, QWORD PTR mhi$[rsp]
  0130f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR S$[rsp]
  01314	e8 00 00 00 00	 call	 diff
  01319	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR delta$[rsp], rax

; 2863 :             if (delta == NULL)

  01321	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR delta$[rsp], 0
  0132a	75 05		 jne	 SHORT $LN44@Py_dg_dtoa

; 2864 :                 goto failed_malloc;

  0132c	e9 15 05 00 00	 jmp	 $failed_malloc$21255
$LN44@Py_dg_dtoa:

; 2865 :             j1 = delta->sign ? 1 : cmp(b, delta);

  01331	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR delta$[rsp]
  01339	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  0133d	74 0d		 je	 SHORT $LN172@Py_dg_dtoa
  0133f	c7 84 24 20 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv517[rsp], 1
  0134a	eb 1c		 jmp	 SHORT $LN173@Py_dg_dtoa
$LN172@Py_dg_dtoa:
  0134c	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR delta$[rsp]
  01354	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0135c	e8 00 00 00 00	 call	 cmp
  01361	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv517[rsp], eax
$LN173@Py_dg_dtoa:
  01368	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR tv517[rsp]
  0136f	89 84 24 b8 00
	00 00		 mov	 DWORD PTR j1$[rsp], eax

; 2866 :             Bfree(delta);

  01376	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR delta$[rsp]
  0137e	e8 00 00 00 00	 call	 Bfree

; 2867 :             if (j1 == 0 && mode != 1 && !(word1(&u) & 1)
; 2868 :                 ) {

  01383	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR j1$[rsp], 0
  0138b	75 53		 jne	 SHORT $LN43@Py_dg_dtoa
  0138d	83 bc 24 48 01
	00 00 01	 cmp	 DWORD PTR mode$[rsp], 1
  01395	74 49		 je	 SHORT $LN43@Py_dg_dtoa
  01397	8b 44 24 58	 mov	 eax, DWORD PTR u$[rsp]
  0139b	83 e0 01	 and	 eax, 1
  0139e	85 c0		 test	 eax, eax
  013a0	75 3e		 jne	 SHORT $LN43@Py_dg_dtoa

; 2869 :                 if (dig == '9')

  013a2	83 7c 24 20 39	 cmp	 DWORD PTR dig$[rsp], 57	; 00000039H
  013a7	75 05		 jne	 SHORT $LN42@Py_dg_dtoa

; 2870 :                     goto round_9_up;

  013a9	e9 38 01 00 00	 jmp	 $round_9_up$21413
$LN42@Py_dg_dtoa:

; 2871 :                 if (j > 0)

  013ae	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  013b6	7e 0a		 jle	 SHORT $LN41@Py_dg_dtoa

; 2872 :                     dig++;

  013b8	8b 44 24 20	 mov	 eax, DWORD PTR dig$[rsp]
  013bc	ff c0		 inc	 eax
  013be	89 44 24 20	 mov	 DWORD PTR dig$[rsp], eax
$LN41@Py_dg_dtoa:

; 2873 :                 *s++ = dig;

  013c2	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  013c7	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR dig$[rsp]
  013cc	88 08		 mov	 BYTE PTR [rax], cl
  013ce	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  013d3	48 ff c0	 inc	 rax
  013d6	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2874 :                 goto ret;

  013db	e9 d9 03 00 00	 jmp	 $ret$21388
$LN43@Py_dg_dtoa:

; 2875 :             }
; 2876 :             if (j < 0 || (j == 0 && mode != 1
; 2877 :                           && !(word1(&u) & 1)
; 2878 :                     )) {

  013e0	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  013e8	7c 2b		 jl	 SHORT $LN39@Py_dg_dtoa
  013ea	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  013f2	0f 85 dd 00 00
	00		 jne	 $LN40@Py_dg_dtoa
  013f8	83 bc 24 48 01
	00 00 01	 cmp	 DWORD PTR mode$[rsp], 1
  01400	0f 84 cf 00 00
	00		 je	 $LN40@Py_dg_dtoa
  01406	8b 44 24 58	 mov	 eax, DWORD PTR u$[rsp]
  0140a	83 e0 01	 and	 eax, 1
  0140d	85 c0		 test	 eax, eax
  0140f	0f 85 c0 00 00
	00		 jne	 $LN40@Py_dg_dtoa
$LN39@Py_dg_dtoa:

; 2879 :                 if (!b->x[0] && b->wds <= 1) {

  01415	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0141d	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  01421	75 13		 jne	 SHORT $LN38@Py_dg_dtoa
  01423	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0142b	83 78 14 01	 cmp	 DWORD PTR [rax+20], 1
  0142f	7f 05		 jg	 SHORT $LN38@Py_dg_dtoa

; 2880 :                     goto accept_dig;

  01431	e9 81 00 00 00	 jmp	 $accept_dig$21418
$LN38@Py_dg_dtoa:

; 2881 :                 }
; 2882 :                 if (j1 > 0) {

  01436	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR j1$[rsp], 0
  0143e	7e 77		 jle	 SHORT $LN37@Py_dg_dtoa

; 2883 :                     b = lshift(b, 1);

  01440	ba 01 00 00 00	 mov	 edx, 1
  01445	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0144d	e8 00 00 00 00	 call	 lshift
  01452	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2884 :                     if (b == NULL)

  0145a	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  01463	75 05		 jne	 SHORT $LN36@Py_dg_dtoa

; 2885 :                         goto failed_malloc;

  01465	e9 dc 03 00 00	 jmp	 $failed_malloc$21255
$LN36@Py_dg_dtoa:

; 2886 :                     j1 = cmp(b, S);

  0146a	48 8b 54 24 70	 mov	 rdx, QWORD PTR S$[rsp]
  0146f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  01477	e8 00 00 00 00	 call	 cmp
  0147c	89 84 24 b8 00
	00 00		 mov	 DWORD PTR j1$[rsp], eax

; 2887 :                     if ((j1 > 0 || (j1 == 0 && dig & 1))
; 2888 :                         && dig++ == '9')

  01483	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR j1$[rsp], 0
  0148b	7f 15		 jg	 SHORT $LN34@Py_dg_dtoa
  0148d	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR j1$[rsp], 0
  01495	75 20		 jne	 SHORT $LN35@Py_dg_dtoa
  01497	8b 44 24 20	 mov	 eax, DWORD PTR dig$[rsp]
  0149b	83 e0 01	 and	 eax, 1
  0149e	85 c0		 test	 eax, eax
  014a0	74 15		 je	 SHORT $LN35@Py_dg_dtoa
$LN34@Py_dg_dtoa:
  014a2	8b 44 24 20	 mov	 eax, DWORD PTR dig$[rsp]
  014a6	8b 4c 24 20	 mov	 ecx, DWORD PTR dig$[rsp]
  014aa	ff c1		 inc	 ecx
  014ac	89 4c 24 20	 mov	 DWORD PTR dig$[rsp], ecx
  014b0	83 f8 39	 cmp	 eax, 57			; 00000039H
  014b3	75 02		 jne	 SHORT $LN35@Py_dg_dtoa

; 2889 :                         goto round_9_up;

  014b5	eb 2f		 jmp	 SHORT $round_9_up$21413
$LN35@Py_dg_dtoa:
$LN37@Py_dg_dtoa:
$accept_dig$21418:

; 2890 :                 }
; 2891 :               accept_dig:
; 2892 :                 *s++ = dig;

  014b7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  014bc	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR dig$[rsp]
  014c1	88 08		 mov	 BYTE PTR [rax], cl
  014c3	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  014c8	48 ff c0	 inc	 rax
  014cb	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2893 :                 goto ret;

  014d0	e9 e4 02 00 00	 jmp	 $ret$21388
$LN40@Py_dg_dtoa:

; 2894 :             }
; 2895 :             if (j1 > 0) {

  014d5	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR j1$[rsp], 0
  014dd	7e 40		 jle	 SHORT $LN33@Py_dg_dtoa

; 2896 :                 if (dig == '9') { /* possible if i == 1 */

  014df	83 7c 24 20 39	 cmp	 DWORD PTR dig$[rsp], 57	; 00000039H
  014e4	75 1a		 jne	 SHORT $LN32@Py_dg_dtoa
$round_9_up$21413:

; 2897 :                   round_9_up:
; 2898 :                     *s++ = '9';

  014e6	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  014eb	c6 00 39	 mov	 BYTE PTR [rax], 57	; 00000039H
  014ee	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  014f3	48 ff c0	 inc	 rax
  014f6	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2899 :                     goto roundoff;

  014fb	e9 21 02 00 00	 jmp	 $roundoff$21426
$LN32@Py_dg_dtoa:

; 2900 :                 }
; 2901 :                 *s++ = dig + 1;

  01500	8b 44 24 20	 mov	 eax, DWORD PTR dig$[rsp]
  01504	ff c0		 inc	 eax
  01506	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0150b	88 01		 mov	 BYTE PTR [rcx], al
  0150d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  01512	48 ff c0	 inc	 rax
  01515	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2902 :                 goto ret;

  0151a	e9 9a 02 00 00	 jmp	 $ret$21388
$LN33@Py_dg_dtoa:

; 2903 :             }
; 2904 :             *s++ = dig;

  0151f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  01524	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR dig$[rsp]
  01529	88 08		 mov	 BYTE PTR [rax], cl
  0152b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  01530	48 ff c0	 inc	 rax
  01533	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2905 :             if (i == ilim)

  01538	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR ilim$[rsp]
  0153f	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  01543	75 05		 jne	 SHORT $LN31@Py_dg_dtoa

; 2906 :                 break;

  01545	e9 c8 00 00 00	 jmp	 $LN45@Py_dg_dtoa
$LN31@Py_dg_dtoa:

; 2907 :             b = multadd(b, 10, 0);

  0154a	45 33 c0	 xor	 r8d, r8d
  0154d	ba 0a 00 00 00	 mov	 edx, 10
  01552	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0155a	e8 00 00 00 00	 call	 multadd
  0155f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2908 :             if (b == NULL)

  01567	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  01570	75 05		 jne	 SHORT $LN30@Py_dg_dtoa

; 2909 :                 goto failed_malloc;

  01572	e9 cf 02 00 00	 jmp	 $failed_malloc$21255
$LN30@Py_dg_dtoa:

; 2910 :             if (mlo == mhi) {

  01577	48 8b 44 24 30	 mov	 rax, QWORD PTR mhi$[rsp]
  0157c	48 39 84 24 e0
	00 00 00	 cmp	 QWORD PTR mlo$[rsp], rax
  01584	75 36		 jne	 SHORT $LN29@Py_dg_dtoa

; 2911 :                 mlo = mhi = multadd(mhi, 10, 0);

  01586	45 33 c0	 xor	 r8d, r8d
  01589	ba 0a 00 00 00	 mov	 edx, 10
  0158e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mhi$[rsp]
  01593	e8 00 00 00 00	 call	 multadd
  01598	48 89 44 24 30	 mov	 QWORD PTR mhi$[rsp], rax
  0159d	48 8b 44 24 30	 mov	 rax, QWORD PTR mhi$[rsp]
  015a2	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR mlo$[rsp], rax

; 2912 :                 if (mlo == NULL)

  015aa	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR mlo$[rsp], 0
  015b3	75 05		 jne	 SHORT $LN28@Py_dg_dtoa

; 2913 :                     goto failed_malloc;

  015b5	e9 8c 02 00 00	 jmp	 $failed_malloc$21255
$LN28@Py_dg_dtoa:

; 2914 :             }
; 2915 :             else {

  015ba	eb 51		 jmp	 SHORT $LN27@Py_dg_dtoa
$LN29@Py_dg_dtoa:

; 2916 :                 mlo = multadd(mlo, 10, 0);

  015bc	45 33 c0	 xor	 r8d, r8d
  015bf	ba 0a 00 00 00	 mov	 edx, 10
  015c4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR mlo$[rsp]
  015cc	e8 00 00 00 00	 call	 multadd
  015d1	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR mlo$[rsp], rax

; 2917 :                 if (mlo == NULL)

  015d9	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR mlo$[rsp], 0
  015e2	75 05		 jne	 SHORT $LN26@Py_dg_dtoa

; 2918 :                     goto failed_malloc;

  015e4	e9 5d 02 00 00	 jmp	 $failed_malloc$21255
$LN26@Py_dg_dtoa:

; 2919 :                 mhi = multadd(mhi, 10, 0);

  015e9	45 33 c0	 xor	 r8d, r8d
  015ec	ba 0a 00 00 00	 mov	 edx, 10
  015f1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mhi$[rsp]
  015f6	e8 00 00 00 00	 call	 multadd
  015fb	48 89 44 24 30	 mov	 QWORD PTR mhi$[rsp], rax

; 2920 :                 if (mhi == NULL)

  01600	48 83 7c 24 30
	00		 cmp	 QWORD PTR mhi$[rsp], 0
  01606	75 05		 jne	 SHORT $LN25@Py_dg_dtoa

; 2921 :                     goto failed_malloc;

  01608	e9 39 02 00 00	 jmp	 $failed_malloc$21255
$LN25@Py_dg_dtoa:
$LN27@Py_dg_dtoa:

; 2922 :             }
; 2923 :         }

  0160d	e9 b9 fc ff ff	 jmp	 $LN46@Py_dg_dtoa
$LN45@Py_dg_dtoa:

; 2924 :     }
; 2925 :     else

  01612	e9 a8 00 00 00	 jmp	 $LN24@Py_dg_dtoa
$LN53@Py_dg_dtoa:

; 2926 :         for(i = 1;; i++) {

  01617	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0161f	eb 0a		 jmp	 SHORT $LN23@Py_dg_dtoa
$LN22@Py_dg_dtoa:
  01621	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  01625	ff c0		 inc	 eax
  01627	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN23@Py_dg_dtoa:

; 2927 :             *s++ = dig = quorem(b,S) + '0';

  0162b	48 8b 54 24 70	 mov	 rdx, QWORD PTR S$[rsp]
  01630	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  01638	e8 00 00 00 00	 call	 quorem
  0163d	83 c0 30	 add	 eax, 48			; 00000030H
  01640	89 44 24 20	 mov	 DWORD PTR dig$[rsp], eax
  01644	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  01649	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR dig$[rsp]
  0164e	88 08		 mov	 BYTE PTR [rax], cl
  01650	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  01655	48 ff c0	 inc	 rax
  01658	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2928 :             if (!b->x[0] && b->wds <= 1) {

  0165d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  01665	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  01669	75 13		 jne	 SHORT $LN20@Py_dg_dtoa
  0166b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  01673	83 78 14 01	 cmp	 DWORD PTR [rax+20], 1
  01677	7f 05		 jg	 SHORT $LN20@Py_dg_dtoa

; 2929 :                 goto ret;

  01679	e9 3b 01 00 00	 jmp	 $ret$21388
$LN20@Py_dg_dtoa:

; 2930 :             }
; 2931 :             if (i >= ilim)

  0167e	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR ilim$[rsp]
  01685	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  01689	7c 02		 jl	 SHORT $LN19@Py_dg_dtoa

; 2932 :                 break;

  0168b	eb 32		 jmp	 SHORT $LN21@Py_dg_dtoa
$LN19@Py_dg_dtoa:

; 2933 :             b = multadd(b, 10, 0);

  0168d	45 33 c0	 xor	 r8d, r8d
  01690	ba 0a 00 00 00	 mov	 edx, 10
  01695	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  0169d	e8 00 00 00 00	 call	 multadd
  016a2	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2934 :             if (b == NULL)

  016aa	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  016b3	75 05		 jne	 SHORT $LN18@Py_dg_dtoa

; 2935 :                 goto failed_malloc;

  016b5	e9 8c 01 00 00	 jmp	 $failed_malloc$21255
$LN18@Py_dg_dtoa:

; 2936 :         }

  016ba	e9 62 ff ff ff	 jmp	 $LN22@Py_dg_dtoa
$LN21@Py_dg_dtoa:
$LN24@Py_dg_dtoa:

; 2937 : 
; 2938 :     /* Round off last digit */
; 2939 : 
; 2940 :     b = lshift(b, 1);

  016bf	ba 01 00 00 00	 mov	 edx, 1
  016c4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  016cc	e8 00 00 00 00	 call	 lshift
  016d1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR b$[rsp], rax

; 2941 :     if (b == NULL)

  016d9	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  016e2	75 05		 jne	 SHORT $LN17@Py_dg_dtoa

; 2942 :         goto failed_malloc;

  016e4	e9 5d 01 00 00	 jmp	 $failed_malloc$21255
$LN17@Py_dg_dtoa:

; 2943 :     j = cmp(b, S);

  016e9	48 8b 54 24 70	 mov	 rdx, QWORD PTR S$[rsp]
  016ee	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  016f6	e8 00 00 00 00	 call	 cmp
  016fb	89 84 24 fc 00
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 2944 :     if (j > 0 || (j == 0 && dig & 1)) {

  01702	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  0170a	7f 15		 jg	 SHORT $LN15@Py_dg_dtoa
  0170c	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR j$[rsp], 0
  01714	75 7a		 jne	 SHORT $LN16@Py_dg_dtoa
  01716	8b 44 24 20	 mov	 eax, DWORD PTR dig$[rsp]
  0171a	83 e0 01	 and	 eax, 1
  0171d	85 c0		 test	 eax, eax
  0171f	74 6f		 je	 SHORT $LN16@Py_dg_dtoa
$LN15@Py_dg_dtoa:
$roundoff$21426:
$LN14@Py_dg_dtoa:

; 2945 :       roundoff:
; 2946 :         while(*--s == '9')

  01721	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  01726	48 ff c8	 dec	 rax
  01729	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax
  0172e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  01733	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01736	83 f8 39	 cmp	 eax, 57			; 00000039H
  01739	75 35		 jne	 SHORT $LN13@Py_dg_dtoa

; 2947 :             if (s == s0) {

  0173b	48 8b 44 24 40	 mov	 rax, QWORD PTR s0$[rsp]
  01740	48 39 44 24 50	 cmp	 QWORD PTR s$[rsp], rax
  01745	75 27		 jne	 SHORT $LN12@Py_dg_dtoa

; 2948 :                 k++;

  01747	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  0174e	ff c0		 inc	 eax
  01750	89 84 24 c4 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 2949 :                 *s++ = '1';

  01757	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0175c	c6 00 31	 mov	 BYTE PTR [rax], 49	; 00000031H
  0175f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  01764	48 ff c0	 inc	 rax
  01767	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2950 :                 goto ret;

  0176c	eb 4b		 jmp	 SHORT $ret$21388
$LN12@Py_dg_dtoa:

; 2951 :             }

  0176e	eb b1		 jmp	 SHORT $LN14@Py_dg_dtoa
$LN13@Py_dg_dtoa:

; 2952 :         ++*s++;

  01770	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  01775	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01778	fe c0		 inc	 al
  0177a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0177f	88 01		 mov	 BYTE PTR [rcx], al
  01781	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  01786	48 ff c0	 inc	 rax
  01789	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 2953 :     }
; 2954 :     else {

  0178e	eb 29		 jmp	 SHORT $LN11@Py_dg_dtoa
$LN16@Py_dg_dtoa:
$LN10@Py_dg_dtoa:

; 2955 :         while(*--s == '0');

  01790	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  01795	48 ff c8	 dec	 rax
  01798	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax
  0179d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  017a2	0f be 00	 movsx	 eax, BYTE PTR [rax]
  017a5	83 f8 30	 cmp	 eax, 48			; 00000030H
  017a8	75 02		 jne	 SHORT $LN9@Py_dg_dtoa
  017aa	eb e4		 jmp	 SHORT $LN10@Py_dg_dtoa
$LN9@Py_dg_dtoa:

; 2956 :         s++;

  017ac	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  017b1	48 ff c0	 inc	 rax
  017b4	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax
$LN11@Py_dg_dtoa:
$ret$21388:

; 2957 :     }
; 2958 :   ret:
; 2959 :     Bfree(S);

  017b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR S$[rsp]
  017be	e8 00 00 00 00	 call	 Bfree

; 2960 :     if (mhi) {

  017c3	48 83 7c 24 30
	00		 cmp	 QWORD PTR mhi$[rsp], 0
  017c9	74 31		 je	 SHORT $LN8@Py_dg_dtoa

; 2961 :         if (mlo && mlo != mhi)

  017cb	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR mlo$[rsp], 0
  017d4	74 1c		 je	 SHORT $LN7@Py_dg_dtoa
  017d6	48 8b 44 24 30	 mov	 rax, QWORD PTR mhi$[rsp]
  017db	48 39 84 24 e0
	00 00 00	 cmp	 QWORD PTR mlo$[rsp], rax
  017e3	74 0d		 je	 SHORT $LN7@Py_dg_dtoa

; 2962 :             Bfree(mlo);

  017e5	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR mlo$[rsp]
  017ed	e8 00 00 00 00	 call	 Bfree
$LN7@Py_dg_dtoa:

; 2963 :         Bfree(mhi);

  017f2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mhi$[rsp]
  017f7	e8 00 00 00 00	 call	 Bfree
$LN8@Py_dg_dtoa:
$ret1$21311:

; 2964 :     }
; 2965 :   ret1:
; 2966 :     Bfree(b);

  017fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  01804	e8 00 00 00 00	 call	 Bfree

; 2967 :     *s = 0;

  01809	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0180e	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2968 :     *decpt = k + 1;

  01811	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  01818	ff c0		 inc	 eax
  0181a	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR decpt$[rsp]
  01822	89 01		 mov	 DWORD PTR [rcx], eax

; 2969 :     if (rve)

  01824	48 83 bc 24 68
	01 00 00 00	 cmp	 QWORD PTR rve$[rsp], 0
  0182d	74 10		 je	 SHORT $LN6@Py_dg_dtoa

; 2970 :         *rve = s;

  0182f	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR rve$[rsp]
  01837	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0183c	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN6@Py_dg_dtoa:

; 2971 :     return s0;

  0183f	48 8b 44 24 40	 mov	 rax, QWORD PTR s0$[rsp]
  01844	eb 77		 jmp	 SHORT $LN164@Py_dg_dtoa
$failed_malloc$21255:

; 2972 :   failed_malloc:
; 2973 :     if (S)

  01846	48 83 7c 24 70
	00		 cmp	 QWORD PTR S$[rsp], 0
  0184c	74 0a		 je	 SHORT $LN5@Py_dg_dtoa

; 2974 :         Bfree(S);

  0184e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR S$[rsp]
  01853	e8 00 00 00 00	 call	 Bfree
$LN5@Py_dg_dtoa:

; 2975 :     if (mlo && mlo != mhi)

  01858	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR mlo$[rsp], 0
  01861	74 1c		 je	 SHORT $LN4@Py_dg_dtoa
  01863	48 8b 44 24 30	 mov	 rax, QWORD PTR mhi$[rsp]
  01868	48 39 84 24 e0
	00 00 00	 cmp	 QWORD PTR mlo$[rsp], rax
  01870	74 0d		 je	 SHORT $LN4@Py_dg_dtoa

; 2976 :         Bfree(mlo);

  01872	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR mlo$[rsp]
  0187a	e8 00 00 00 00	 call	 Bfree
$LN4@Py_dg_dtoa:

; 2977 :     if (mhi)

  0187f	48 83 7c 24 30
	00		 cmp	 QWORD PTR mhi$[rsp], 0
  01885	74 0a		 je	 SHORT $LN3@Py_dg_dtoa

; 2978 :         Bfree(mhi);

  01887	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mhi$[rsp]
  0188c	e8 00 00 00 00	 call	 Bfree
$LN3@Py_dg_dtoa:

; 2979 :     if (b)

  01891	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR b$[rsp], 0
  0189a	74 0d		 je	 SHORT $LN2@Py_dg_dtoa

; 2980 :         Bfree(b);

  0189c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR b$[rsp]
  018a4	e8 00 00 00 00	 call	 Bfree
$LN2@Py_dg_dtoa:

; 2981 :     if (s0)

  018a9	48 83 7c 24 40
	00		 cmp	 QWORD PTR s0$[rsp], 0
  018af	74 0a		 je	 SHORT $LN1@Py_dg_dtoa

; 2982 :         _Py_dg_freedtoa(s0);

  018b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s0$[rsp]
  018b6	e8 00 00 00 00	 call	 _Py_dg_freedtoa
$LN1@Py_dg_dtoa:

; 2983 :     return NULL;

  018bb	33 c0		 xor	 eax, eax
$LN164@Py_dg_dtoa:

; 2984 : }

  018bd	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  018c4	c3		 ret	 0
  018c5	0f 1f 00	 npad	 3
$LN174@Py_dg_dtoa:
  018c8	00 00 00 00	 DD	 $LN143@Py_dg_dtoa
  018cc	00 00 00 00	 DD	 $LN143@Py_dg_dtoa
  018d0	00 00 00 00	 DD	 $LN142@Py_dg_dtoa
  018d4	00 00 00 00	 DD	 $LN139@Py_dg_dtoa
  018d8	00 00 00 00	 DD	 $LN141@Py_dg_dtoa
  018dc	00 00 00 00	 DD	 $LN138@Py_dg_dtoa
_Py_dg_dtoa ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$d2b DD	imagerel d2b
	DD	imagerel d2b+482
	DD	imagerel $unwind$d2b
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$d2b DD	011301H
	DD	0a213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT d2b
_TEXT	SEGMENT
de$ = 32
y$ = 36
x$ = 40
i$ = 48
b$ = 56
z$ = 64
k$ = 68
tv88 = 72
tv134 = 76
d$ = 96
e$ = 104
bits$ = 112
d2b	PROC						; COMDAT

; 1142 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1143 :     Bigint *b;
; 1144 :     int de, k;
; 1145 :     ULong *x, y, z;
; 1146 :     int i;
; 1147 : 
; 1148 :     b = Balloc(1);

  00013	b9 01 00 00 00	 mov	 ecx, 1
  00018	e8 00 00 00 00	 call	 Balloc
  0001d	48 89 44 24 38	 mov	 QWORD PTR b$[rsp], rax

; 1149 :     if (b == NULL)

  00022	48 83 7c 24 38
	00		 cmp	 QWORD PTR b$[rsp], 0
  00028	75 07		 jne	 SHORT $LN8@d2b

; 1150 :         return NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	e9 ac 01 00 00	 jmp	 $LN9@d2b
$LN8@d2b:

; 1151 :     x = b->x;

  00031	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00036	48 83 c0 18	 add	 rax, 24
  0003a	48 89 44 24 28	 mov	 QWORD PTR x$[rsp], rax

; 1152 : 
; 1153 :     z = word0(d) & Frac_mask;

  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR d$[rsp]
  00044	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00047	25 ff ff 0f 00	 and	 eax, 1048575		; 000fffffH
  0004c	89 44 24 40	 mov	 DWORD PTR z$[rsp], eax

; 1154 :     word0(d) &= 0x7fffffff;   /* clear sign bit, which we ignore */

  00050	48 8b 44 24 60	 mov	 rax, QWORD PTR d$[rsp]
  00055	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00058	0f ba f0 1f	 btr	 eax, 31
  0005c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  00061	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1155 :     if ((de = (int)(word0(d) >> Exp_shift)))

  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR d$[rsp]
  00069	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0006c	c1 e8 14	 shr	 eax, 20
  0006f	89 44 24 20	 mov	 DWORD PTR de$[rsp], eax
  00073	83 7c 24 20 00	 cmp	 DWORD PTR de$[rsp], 0
  00078	74 0c		 je	 SHORT $LN7@d2b

; 1156 :         z |= Exp_msk1;

  0007a	8b 44 24 40	 mov	 eax, DWORD PTR z$[rsp]
  0007e	0f ba e8 14	 bts	 eax, 20
  00082	89 44 24 40	 mov	 DWORD PTR z$[rsp], eax
$LN7@d2b:

; 1157 :     if ((y = word1(d))) {

  00086	48 8b 44 24 60	 mov	 rax, QWORD PTR d$[rsp]
  0008b	8b 00		 mov	 eax, DWORD PTR [rax]
  0008d	89 44 24 24	 mov	 DWORD PTR y$[rsp], eax
  00091	83 7c 24 24 00	 cmp	 DWORD PTR y$[rsp], 0
  00096	0f 84 8f 00 00
	00		 je	 $LN6@d2b

; 1158 :         if ((k = lo0bits(&y))) {

  0009c	48 8d 4c 24 24	 lea	 rcx, QWORD PTR y$[rsp]
  000a1	e8 00 00 00 00	 call	 lo0bits
  000a6	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
  000aa	83 7c 24 44 00	 cmp	 DWORD PTR k$[rsp], 0
  000af	74 34		 je	 SHORT $LN5@d2b

; 1159 :             x[0] = y | z << (32 - k);

  000b1	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000b6	2b 44 24 44	 sub	 eax, DWORD PTR k$[rsp]
  000ba	0f b6 c8	 movzx	 ecx, al
  000bd	8b 44 24 40	 mov	 eax, DWORD PTR z$[rsp]
  000c1	d3 e0		 shl	 eax, cl
  000c3	8b 4c 24 24	 mov	 ecx, DWORD PTR y$[rsp]
  000c7	0b c8		 or	 ecx, eax
  000c9	8b c1		 mov	 eax, ecx
  000cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x$[rsp]
  000d0	89 01		 mov	 DWORD PTR [rcx], eax

; 1160 :             z >>= k;

  000d2	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  000d6	0f b6 c8	 movzx	 ecx, al
  000d9	8b 44 24 40	 mov	 eax, DWORD PTR z$[rsp]
  000dd	d3 e8		 shr	 eax, cl
  000df	89 44 24 40	 mov	 DWORD PTR z$[rsp], eax

; 1161 :         }
; 1162 :         else

  000e3	eb 0b		 jmp	 SHORT $LN4@d2b
$LN5@d2b:

; 1163 :             x[0] = y;

  000e5	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  000ea	8b 4c 24 24	 mov	 ecx, DWORD PTR y$[rsp]
  000ee	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@d2b:

; 1164 :         i =
; 1165 :             b->wds = (x[1] = z) ? 2 : 1;

  000f0	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  000f5	8b 4c 24 40	 mov	 ecx, DWORD PTR z$[rsp]
  000f9	89 48 04	 mov	 DWORD PTR [rax+4], ecx
  000fc	83 7c 24 40 00	 cmp	 DWORD PTR z$[rsp], 0
  00101	74 0a		 je	 SHORT $LN11@d2b
  00103	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv88[rsp], 2
  0010b	eb 08		 jmp	 SHORT $LN12@d2b
$LN11@d2b:
  0010d	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
$LN12@d2b:
  00115	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  0011a	8b 4c 24 48	 mov	 ecx, DWORD PTR tv88[rsp]
  0011e	89 48 14	 mov	 DWORD PTR [rax+20], ecx
  00121	8b 44 24 48	 mov	 eax, DWORD PTR tv88[rsp]
  00125	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax

; 1166 :     }
; 1167 :     else {

  00129	eb 38		 jmp	 SHORT $LN3@d2b
$LN6@d2b:

; 1168 :         k = lo0bits(&z);

  0012b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR z$[rsp]
  00130	e8 00 00 00 00	 call	 lo0bits
  00135	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax

; 1169 :         x[0] = z;

  00139	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  0013e	8b 4c 24 40	 mov	 ecx, DWORD PTR z$[rsp]
  00142	89 08		 mov	 DWORD PTR [rax], ecx

; 1170 :         i =
; 1171 :             b->wds = 1;

  00144	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00149	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1
  00150	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1

; 1172 :         k += 32;

  00158	8b 44 24 44	 mov	 eax, DWORD PTR k$[rsp]
  0015c	83 c0 20	 add	 eax, 32			; 00000020H
  0015f	89 44 24 44	 mov	 DWORD PTR k$[rsp], eax
$LN3@d2b:

; 1173 :     }
; 1174 :     if (de) {

  00163	83 7c 24 20 00	 cmp	 DWORD PTR de$[rsp], 0
  00168	74 28		 je	 SHORT $LN2@d2b

; 1175 :         *e = de - Bias - (P-1) + k;

  0016a	8b 44 24 20	 mov	 eax, DWORD PTR de$[rsp]
  0016e	8b 4c 24 44	 mov	 ecx, DWORD PTR k$[rsp]
  00172	8d 84 08 cd fb
	ff ff		 lea	 eax, DWORD PTR [rax+rcx-1075]
  00179	48 8b 4c 24 68	 mov	 rcx, QWORD PTR e$[rsp]
  0017e	89 01		 mov	 DWORD PTR [rcx], eax

; 1176 :         *bits = P - k;

  00180	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00185	2b 44 24 44	 sub	 eax, DWORD PTR k$[rsp]
  00189	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bits$[rsp]
  0018e	89 01		 mov	 DWORD PTR [rcx], eax

; 1177 :     }
; 1178 :     else {

  00190	eb 46		 jmp	 SHORT $LN1@d2b
$LN2@d2b:

; 1179 :         *e = de - Bias - (P-1) + 1 + k;

  00192	8b 44 24 20	 mov	 eax, DWORD PTR de$[rsp]
  00196	8b 4c 24 44	 mov	 ecx, DWORD PTR k$[rsp]
  0019a	8d 84 08 ce fb
	ff ff		 lea	 eax, DWORD PTR [rax+rcx-1074]
  001a1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR e$[rsp]
  001a6	89 01		 mov	 DWORD PTR [rcx], eax

; 1180 :         *bits = 32*i - hi0bits(x[i-1]);

  001a8	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  001ac	6b c0 20	 imul	 eax, 32			; 00000020H
  001af	89 44 24 4c	 mov	 DWORD PTR tv134[rsp], eax
  001b3	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  001b7	ff c9		 dec	 ecx
  001b9	48 63 c9	 movsxd	 rcx, ecx
  001bc	48 8b 54 24 28	 mov	 rdx, QWORD PTR x$[rsp]
  001c1	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  001c4	e8 00 00 00 00	 call	 hi0bits
  001c9	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv134[rsp]
  001cd	2b c8		 sub	 ecx, eax
  001cf	8b c1		 mov	 eax, ecx
  001d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bits$[rsp]
  001d6	89 01		 mov	 DWORD PTR [rcx], eax
$LN1@d2b:

; 1181 :     }
; 1182 :     return b;

  001d8	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
$LN9@d2b:

; 1183 : }

  001dd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e1	c3		 ret	 0
d2b	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lo0bits DD imagerel lo0bits
	DD	imagerel lo0bits+290
	DD	imagerel $unwind$lo0bits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lo0bits DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lo0bits
_TEXT	SEGMENT
x$ = 0
k$ = 4
y$ = 32
lo0bits	PROC						; COMDAT

; 579  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 580  :     int k;
; 581  :     ULong x = *y;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR y$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR x$[rsp], eax

; 582  : 
; 583  :     if (x & 7) {

  00013	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  00016	83 e0 07	 and	 eax, 7
  00019	85 c0		 test	 eax, eax
  0001b	74 48		 je	 SHORT $LN9@lo0bits

; 584  :         if (x & 1)

  0001d	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  00020	83 e0 01	 and	 eax, 1
  00023	85 c0		 test	 eax, eax
  00025	74 07		 je	 SHORT $LN8@lo0bits

; 585  :             return 0;

  00027	33 c0		 xor	 eax, eax
  00029	e9 ef 00 00 00	 jmp	 $LN10@lo0bits
$LN8@lo0bits:

; 586  :         if (x & 2) {

  0002e	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  00031	83 e0 02	 and	 eax, 2
  00034	85 c0		 test	 eax, eax
  00036	74 16		 je	 SHORT $LN7@lo0bits

; 587  :             *y = x >> 1;

  00038	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  0003b	d1 e8		 shr	 eax, 1
  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR y$[rsp]
  00042	89 01		 mov	 DWORD PTR [rcx], eax

; 588  :             return 1;

  00044	b8 01 00 00 00	 mov	 eax, 1
  00049	e9 cf 00 00 00	 jmp	 $LN10@lo0bits
$LN7@lo0bits:

; 589  :         }
; 590  :         *y = x >> 2;

  0004e	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  00051	c1 e8 02	 shr	 eax, 2
  00054	48 8b 4c 24 20	 mov	 rcx, QWORD PTR y$[rsp]
  00059	89 01		 mov	 DWORD PTR [rcx], eax

; 591  :         return 2;

  0005b	b8 02 00 00 00	 mov	 eax, 2
  00060	e9 b8 00 00 00	 jmp	 $LN10@lo0bits
$LN9@lo0bits:

; 592  :     }
; 593  :     k = 0;

  00065	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 594  :     if (!(x & 0xffff)) {

  0006d	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  00070	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00075	85 c0		 test	 eax, eax
  00077	75 11		 jne	 SHORT $LN6@lo0bits

; 595  :         k = 16;

  00079	c7 44 24 04 10
	00 00 00	 mov	 DWORD PTR k$[rsp], 16

; 596  :         x >>= 16;

  00081	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  00084	c1 e8 10	 shr	 eax, 16
  00087	89 04 24	 mov	 DWORD PTR x$[rsp], eax
$LN6@lo0bits:

; 597  :     }
; 598  :     if (!(x & 0xff)) {

  0008a	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  0008d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00092	85 c0		 test	 eax, eax
  00094	75 14		 jne	 SHORT $LN5@lo0bits

; 599  :         k += 8;

  00096	8b 44 24 04	 mov	 eax, DWORD PTR k$[rsp]
  0009a	83 c0 08	 add	 eax, 8
  0009d	89 44 24 04	 mov	 DWORD PTR k$[rsp], eax

; 600  :         x >>= 8;

  000a1	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  000a4	c1 e8 08	 shr	 eax, 8
  000a7	89 04 24	 mov	 DWORD PTR x$[rsp], eax
$LN5@lo0bits:

; 601  :     }
; 602  :     if (!(x & 0xf)) {

  000aa	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  000ad	83 e0 0f	 and	 eax, 15
  000b0	85 c0		 test	 eax, eax
  000b2	75 14		 jne	 SHORT $LN4@lo0bits

; 603  :         k += 4;

  000b4	8b 44 24 04	 mov	 eax, DWORD PTR k$[rsp]
  000b8	83 c0 04	 add	 eax, 4
  000bb	89 44 24 04	 mov	 DWORD PTR k$[rsp], eax

; 604  :         x >>= 4;

  000bf	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  000c2	c1 e8 04	 shr	 eax, 4
  000c5	89 04 24	 mov	 DWORD PTR x$[rsp], eax
$LN4@lo0bits:

; 605  :     }
; 606  :     if (!(x & 0x3)) {

  000c8	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  000cb	83 e0 03	 and	 eax, 3
  000ce	85 c0		 test	 eax, eax
  000d0	75 14		 jne	 SHORT $LN3@lo0bits

; 607  :         k += 2;

  000d2	8b 44 24 04	 mov	 eax, DWORD PTR k$[rsp]
  000d6	83 c0 02	 add	 eax, 2
  000d9	89 44 24 04	 mov	 DWORD PTR k$[rsp], eax

; 608  :         x >>= 2;

  000dd	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  000e0	c1 e8 02	 shr	 eax, 2
  000e3	89 04 24	 mov	 DWORD PTR x$[rsp], eax
$LN3@lo0bits:

; 609  :     }
; 610  :     if (!(x & 1)) {

  000e6	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  000e9	83 e0 01	 and	 eax, 1
  000ec	85 c0		 test	 eax, eax
  000ee	75 1f		 jne	 SHORT $LN2@lo0bits

; 611  :         k++;

  000f0	8b 44 24 04	 mov	 eax, DWORD PTR k$[rsp]
  000f4	ff c0		 inc	 eax
  000f6	89 44 24 04	 mov	 DWORD PTR k$[rsp], eax

; 612  :         x >>= 1;

  000fa	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  000fd	d1 e8		 shr	 eax, 1
  000ff	89 04 24	 mov	 DWORD PTR x$[rsp], eax

; 613  :         if (!x)

  00102	83 3c 24 00	 cmp	 DWORD PTR x$[rsp], 0
  00106	75 07		 jne	 SHORT $LN1@lo0bits

; 614  :             return 32;

  00108	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0010d	eb 0e		 jmp	 SHORT $LN10@lo0bits
$LN1@lo0bits:
$LN2@lo0bits:

; 615  :     }
; 616  :     *y = x;

  0010f	48 8b 44 24 20	 mov	 rax, QWORD PTR y$[rsp]
  00114	8b 0c 24	 mov	 ecx, DWORD PTR x$[rsp]
  00117	89 08		 mov	 DWORD PTR [rax], ecx

; 617  :     return k;

  00119	8b 44 24 04	 mov	 eax, DWORD PTR k$[rsp]
$LN10@lo0bits:

; 618  : }

  0011d	48 83 c4 18	 add	 rsp, 24
  00121	c3		 ret	 0
lo0bits	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rv_alloc DD imagerel rv_alloc
	DD	imagerel rv_alloc+117
	DD	imagerel $unwind$rv_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rv_alloc DD 010801H
	DD	08208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT rv_alloc
_TEXT	SEGMENT
k$ = 32
r$ = 40
j$ = 48
i$ = 80
rv_alloc PROC						; COMDAT

; 2302 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2303 :     int j, k, *r;
; 2304 : 
; 2305 :     j = sizeof(ULong);

  00008	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR j$[rsp], 4

; 2306 :     for(k = 0;
; 2307 :         sizeof(Bigint) - sizeof(ULong) - sizeof(int) + j <= (unsigned)i;
; 2308 :         j <<= 1)

  00010	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00018	eb 0a		 jmp	 SHORT $LN4@rv_alloc
$LN3@rv_alloc:
  0001a	8b 44 24 30	 mov	 eax, DWORD PTR j$[rsp]
  0001e	d1 e0		 shl	 eax, 1
  00020	89 44 24 30	 mov	 DWORD PTR j$[rsp], eax
$LN4@rv_alloc:
  00024	48 63 44 24 30	 movsxd	 rax, DWORD PTR j$[rsp]
  00029	48 83 c0 18	 add	 rax, 24
  0002d	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  00031	48 3b c1	 cmp	 rax, rcx
  00034	77 0c		 ja	 SHORT $LN2@rv_alloc

; 2309 :         k++;

  00036	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  0003a	ff c0		 inc	 eax
  0003c	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  00040	eb d8		 jmp	 SHORT $LN3@rv_alloc
$LN2@rv_alloc:

; 2310 :     r = (int*)Balloc(k);

  00042	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00046	e8 00 00 00 00	 call	 Balloc
  0004b	48 89 44 24 28	 mov	 QWORD PTR r$[rsp], rax

; 2311 :     if (r == NULL)

  00050	48 83 7c 24 28
	00		 cmp	 QWORD PTR r$[rsp], 0
  00056	75 04		 jne	 SHORT $LN1@rv_alloc

; 2312 :         return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	eb 14		 jmp	 SHORT $LN5@rv_alloc
$LN1@rv_alloc:

; 2313 :     *r = k;

  0005c	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  00061	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00065	89 08		 mov	 DWORD PTR [rax], ecx

; 2314 :     return (char *)(r+1);

  00067	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  0006c	48 83 c0 04	 add	 rax, 4
$LN5@rv_alloc:

; 2315 : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
rv_alloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$nrv_alloc DD imagerel nrv_alloc
	DD	imagerel nrv_alloc+141
	DD	imagerel $unwind$nrv_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$nrv_alloc DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT nrv_alloc
_TEXT	SEGMENT
rv$ = 32
t$ = 40
s$ = 64
rve$ = 72
n$ = 80
nrv_alloc PROC						; COMDAT

; 2319 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2320 :     char *rv, *t;
; 2321 : 
; 2322 :     rv = rv_alloc(n);

  00013	8b 4c 24 50	 mov	 ecx, DWORD PTR n$[rsp]
  00017	e8 00 00 00 00	 call	 rv_alloc
  0001c	48 89 44 24 20	 mov	 QWORD PTR rv$[rsp], rax

; 2323 :     if (rv == NULL)

  00021	48 83 7c 24 20
	00		 cmp	 QWORD PTR rv$[rsp], 0
  00027	75 04		 jne	 SHORT $LN4@nrv_alloc

; 2324 :         return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 5b		 jmp	 SHORT $LN5@nrv_alloc
$LN4@nrv_alloc:

; 2325 :     t = rv;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR rv$[rsp]
  00032	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax
$LN3@nrv_alloc:

; 2326 :     while((*t = *s++)) t++;

  00037	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00041	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00044	88 08		 mov	 BYTE PTR [rax], cl
  00046	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  0004b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	48 ff c1	 inc	 rcx
  00056	48 89 4c 24 40	 mov	 QWORD PTR s$[rsp], rcx
  0005b	85 c0		 test	 eax, eax
  0005d	74 0f		 je	 SHORT $LN2@nrv_alloc
  0005f	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00064	48 ff c0	 inc	 rax
  00067	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax
  0006c	eb c9		 jmp	 SHORT $LN3@nrv_alloc
$LN2@nrv_alloc:

; 2327 :     if (rve)

  0006e	48 83 7c 24 48
	00		 cmp	 QWORD PTR rve$[rsp], 0
  00074	74 0d		 je	 SHORT $LN1@nrv_alloc

; 2328 :         *rve = t;

  00076	48 8b 44 24 48	 mov	 rax, QWORD PTR rve$[rsp]
  0007b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  00080	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN1@nrv_alloc:

; 2329 :     return rv;

  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR rv$[rsp]
$LN5@nrv_alloc:

; 2330 : }

  00088	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008c	c3		 ret	 0
nrv_alloc ENDP
_TEXT	ENDS
END
