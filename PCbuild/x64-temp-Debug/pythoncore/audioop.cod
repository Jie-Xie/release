; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_07DAHKDFPB@audioop?$AA@			; `string'
PUBLIC	??_C@_06OJJCNHEL@ratecv?$AA@			; `string'
PUBLIC	??_C@_07KOIEOCCE@reverse?$AA@			; `string'
PUBLIC	??_C@_09FMFCHLIO@getsample?$AA@			; `string'
PUBLIC	??_C@_08MMNMKAHH@tostereo?$AA@			; `string'
PUBLIC	??_C@_06CBNNKMNN@tomono?$AA@			; `string'
PUBLIC	??_C@_09IDBEIPAH@lin2adpcm?$AA@			; `string'
PUBLIC	??_C@_09JHNCOGNI@adpcm2lin?$AA@			; `string'
PUBLIC	??_C@_07CHCAOHKF@lin2lin?$AA@			; `string'
PUBLIC	??_C@_08CPHOLAP@lin2alaw?$AA@			; `string'
PUBLIC	??_C@_08PICFKELB@alaw2lin?$AA@			; `string'
PUBLIC	??_C@_08JHJHNKEN@lin2ulaw?$AA@			; `string'
PUBLIC	??_C@_08JAJLHMM@ulaw2lin?$AA@			; `string'
PUBLIC	??_C@_04NBAGBPGE@bias?$AA@			; `string'
PUBLIC	??_C@_03BDGOHNNK@add?$AA@			; `string'
PUBLIC	??_C@_03IMIFIBCN@mul?$AA@			; `string'
PUBLIC	??_C@_05HCKPILGO@cross?$AA@			; `string'
PUBLIC	??_C@_0L@IOGIMBLK@findfactor?$AA@		; `string'
PUBLIC	??_C@_07KLIEECAM@findmax?$AA@			; `string'
PUBLIC	??_C@_07NOCDNLLJ@findfit?$AA@			; `string'
PUBLIC	??_C@_03FLJADKLC@rms?$AA@			; `string'
PUBLIC	??_C@_05CGDIEJNA@avgpp?$AA@			; `string'
PUBLIC	??_C@_05ILEAIFPA@maxpp?$AA@			; `string'
PUBLIC	??_C@_03CHOBFJAH@avg?$AA@			; `string'
PUBLIC	??_C@_06OGLEOHCN@minmax?$AA@			; `string'
PUBLIC	??_C@_03LJAEFNNE@max?$AA@			; `string'
;	COMDAT ??_C@_07DAHKDFPB@audioop?$AA@
CONST	SEGMENT
??_C@_07DAHKDFPB@audioop?$AA@ DB 'audioop', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OJJCNHEL@ratecv?$AA@
CONST	SEGMENT
??_C@_06OJJCNHEL@ratecv?$AA@ DB 'ratecv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KOIEOCCE@reverse?$AA@
CONST	SEGMENT
??_C@_07KOIEOCCE@reverse?$AA@ DB 'reverse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FMFCHLIO@getsample?$AA@
CONST	SEGMENT
??_C@_09FMFCHLIO@getsample?$AA@ DB 'getsample', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MMNMKAHH@tostereo?$AA@
CONST	SEGMENT
??_C@_08MMNMKAHH@tostereo?$AA@ DB 'tostereo', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CBNNKMNN@tomono?$AA@
CONST	SEGMENT
??_C@_06CBNNKMNN@tomono?$AA@ DB 'tomono', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09IDBEIPAH@lin2adpcm?$AA@
CONST	SEGMENT
??_C@_09IDBEIPAH@lin2adpcm?$AA@ DB 'lin2adpcm', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JHNCOGNI@adpcm2lin?$AA@
CONST	SEGMENT
??_C@_09JHNCOGNI@adpcm2lin?$AA@ DB 'adpcm2lin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CHCAOHKF@lin2lin?$AA@
CONST	SEGMENT
??_C@_07CHCAOHKF@lin2lin?$AA@ DB 'lin2lin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CPHOLAP@lin2alaw?$AA@
CONST	SEGMENT
??_C@_08CPHOLAP@lin2alaw?$AA@ DB 'lin2alaw', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08PICFKELB@alaw2lin?$AA@
CONST	SEGMENT
??_C@_08PICFKELB@alaw2lin?$AA@ DB 'alaw2lin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JHJHNKEN@lin2ulaw?$AA@
CONST	SEGMENT
??_C@_08JHJHNKEN@lin2ulaw?$AA@ DB 'lin2ulaw', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JAJLHMM@ulaw2lin?$AA@
CONST	SEGMENT
??_C@_08JAJLHMM@ulaw2lin?$AA@ DB 'ulaw2lin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04NBAGBPGE@bias?$AA@
CONST	SEGMENT
??_C@_04NBAGBPGE@bias?$AA@ DB 'bias', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDGOHNNK@add?$AA@
CONST	SEGMENT
??_C@_03BDGOHNNK@add?$AA@ DB 'add', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IMIFIBCN@mul?$AA@
CONST	SEGMENT
??_C@_03IMIFIBCN@mul?$AA@ DB 'mul', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HCKPILGO@cross?$AA@
CONST	SEGMENT
??_C@_05HCKPILGO@cross?$AA@ DB 'cross', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IOGIMBLK@findfactor?$AA@
CONST	SEGMENT
??_C@_0L@IOGIMBLK@findfactor?$AA@ DB 'findfactor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KLIEECAM@findmax?$AA@
CONST	SEGMENT
??_C@_07KLIEECAM@findmax?$AA@ DB 'findmax', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07NOCDNLLJ@findfit?$AA@
CONST	SEGMENT
??_C@_07NOCDNLLJ@findfit?$AA@ DB 'findfit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FLJADKLC@rms?$AA@
CONST	SEGMENT
??_C@_03FLJADKLC@rms?$AA@ DB 'rms', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CGDIEJNA@avgpp?$AA@
CONST	SEGMENT
??_C@_05CGDIEJNA@avgpp?$AA@ DB 'avgpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ILEAIFPA@maxpp?$AA@
CONST	SEGMENT
??_C@_05ILEAIFPA@maxpp?$AA@ DB 'maxpp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CHOBFJAH@avg?$AA@
CONST	SEGMENT
??_C@_03CHOBFJAH@avg?$AA@ DB 'avg', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OGLEOHCN@minmax?$AA@
CONST	SEGMENT
??_C@_06OGLEOHCN@minmax?$AA@ DB 'minmax', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJAEFNNE@max?$AA@
CONST	SEGMENT
??_C@_03LJAEFNNE@max?$AA@ DB 'max', 00H			; `string'
CONST	ENDS
_DATA	SEGMENT
seg_aend DW	01fH
	DW	03fH
	DW	07fH
	DW	0ffH
	DW	01ffH
	DW	03ffH
	DW	07ffH
	DW	0fffH
seg_uend DW	03fH
	DW	07fH
	DW	0ffH
	DW	01ffH
	DW	03ffH
	DW	07ffH
	DW	0fffH
	DW	01fffH
_st_ulaw2linear16 DW 08284H
	DW	08684H
	DW	08a84H
	DW	08e84H
	DW	09284H
	DW	09684H
	DW	09a84H
	DW	09e84H
	DW	0a284H
	DW	0a684H
	DW	0aa84H
	DW	0ae84H
	DW	0b284H
	DW	0b684H
	DW	0ba84H
	DW	0be84H
	DW	0c184H
	DW	0c384H
	DW	0c584H
	DW	0c784H
	DW	0c984H
	DW	0cb84H
	DW	0cd84H
	DW	0cf84H
	DW	0d184H
	DW	0d384H
	DW	0d584H
	DW	0d784H
	DW	0d984H
	DW	0db84H
	DW	0dd84H
	DW	0df84H
	DW	0e104H
	DW	0e204H
	DW	0e304H
	DW	0e404H
	DW	0e504H
	DW	0e604H
	DW	0e704H
	DW	0e804H
	DW	0e904H
	DW	0ea04H
	DW	0eb04H
	DW	0ec04H
	DW	0ed04H
	DW	0ee04H
	DW	0ef04H
	DW	0f004H
	DW	0f0c4H
	DW	0f144H
	DW	0f1c4H
	DW	0f244H
	DW	0f2c4H
	DW	0f344H
	DW	0f3c4H
	DW	0f444H
	DW	0f4c4H
	DW	0f544H
	DW	0f5c4H
	DW	0f644H
	DW	0f6c4H
	DW	0f744H
	DW	0f7c4H
	DW	0f844H
	DW	0f8a4H
	DW	0f8e4H
	DW	0f924H
	DW	0f964H
	DW	0f9a4H
	DW	0f9e4H
	DW	0fa24H
	DW	0fa64H
	DW	0faa4H
	DW	0fae4H
	DW	0fb24H
	DW	0fb64H
	DW	0fba4H
	DW	0fbe4H
	DW	0fc24H
	DW	0fc64H
	DW	0fc94H
	DW	0fcb4H
	DW	0fcd4H
	DW	0fcf4H
	DW	0fd14H
	DW	0fd34H
	DW	0fd54H
	DW	0fd74H
	DW	0fd94H
	DW	0fdb4H
	DW	0fdd4H
	DW	0fdf4H
	DW	0fe14H
	DW	0fe34H
	DW	0fe54H
	DW	0fe74H
	DW	0fe8cH
	DW	0fe9cH
	DW	0feacH
	DW	0febcH
	DW	0feccH
	DW	0fedcH
	DW	0feecH
	DW	0fefcH
	DW	0ff0cH
	DW	0ff1cH
	DW	0ff2cH
	DW	0ff3cH
	DW	0ff4cH
	DW	0ff5cH
	DW	0ff6cH
	DW	0ff7cH
	DW	0ff88H
	DW	0ff90H
	DW	0ff98H
	DW	0ffa0H
	DW	0ffa8H
	DW	0ffb0H
	DW	0ffb8H
	DW	0ffc0H
	DW	0ffc8H
	DW	0ffd0H
	DW	0ffd8H
	DW	0ffe0H
	DW	0ffe8H
	DW	0fff0H
	DW	0fff8H
	DW	00H
	DW	07d7cH
	DW	0797cH
	DW	0757cH
	DW	0717cH
	DW	06d7cH
	DW	0697cH
	DW	0657cH
	DW	0617cH
	DW	05d7cH
	DW	0597cH
	DW	0557cH
	DW	0517cH
	DW	04d7cH
	DW	0497cH
	DW	0457cH
	DW	0417cH
	DW	03e7cH
	DW	03c7cH
	DW	03a7cH
	DW	0387cH
	DW	0367cH
	DW	0347cH
	DW	0327cH
	DW	0307cH
	DW	02e7cH
	DW	02c7cH
	DW	02a7cH
	DW	0287cH
	DW	0267cH
	DW	0247cH
	DW	0227cH
	DW	0207cH
	DW	01efcH
	DW	01dfcH
	DW	01cfcH
	DW	01bfcH
	DW	01afcH
	DW	019fcH
	DW	018fcH
	DW	017fcH
	DW	016fcH
	DW	015fcH
	DW	014fcH
	DW	013fcH
	DW	012fcH
	DW	011fcH
	DW	010fcH
	DW	0ffcH
	DW	0f3cH
	DW	0ebcH
	DW	0e3cH
	DW	0dbcH
	DW	0d3cH
	DW	0cbcH
	DW	0c3cH
	DW	0bbcH
	DW	0b3cH
	DW	0abcH
	DW	0a3cH
	DW	09bcH
	DW	093cH
	DW	08bcH
	DW	083cH
	DW	07bcH
	DW	075cH
	DW	071cH
	DW	06dcH
	DW	069cH
	DW	065cH
	DW	061cH
	DW	05dcH
	DW	059cH
	DW	055cH
	DW	051cH
	DW	04dcH
	DW	049cH
	DW	045cH
	DW	041cH
	DW	03dcH
	DW	039cH
	DW	036cH
	DW	034cH
	DW	032cH
	DW	030cH
	DW	02ecH
	DW	02ccH
	DW	02acH
	DW	028cH
	DW	026cH
	DW	024cH
	DW	022cH
	DW	020cH
	DW	01ecH
	DW	01ccH
	DW	01acH
	DW	018cH
	DW	0174H
	DW	0164H
	DW	0154H
	DW	0144H
	DW	0134H
	DW	0124H
	DW	0114H
	DW	0104H
	DW	0f4H
	DW	0e4H
	DW	0d4H
	DW	0c4H
	DW	0b4H
	DW	0a4H
	DW	094H
	DW	084H
	DW	078H
	DW	070H
	DW	068H
	DW	060H
	DW	058H
	DW	050H
	DW	048H
	DW	040H
	DW	038H
	DW	030H
	DW	028H
	DW	020H
	DW	018H
	DW	010H
	DW	08H
	DW	00H
_st_alaw2linear16 DW 0ea80H
	DW	0eb80H
	DW	0e880H
	DW	0e980H
	DW	0ee80H
	DW	0ef80H
	DW	0ec80H
	DW	0ed80H
	DW	0e280H
	DW	0e380H
	DW	0e080H
	DW	0e180H
	DW	0e680H
	DW	0e780H
	DW	0e480H
	DW	0e580H
	DW	0f540H
	DW	0f5c0H
	DW	0f440H
	DW	0f4c0H
	DW	0f740H
	DW	0f7c0H
	DW	0f640H
	DW	0f6c0H
	DW	0f140H
	DW	0f1c0H
	DW	0f040H
	DW	0f0c0H
	DW	0f340H
	DW	0f3c0H
	DW	0f240H
	DW	0f2c0H
	DW	0aa00H
	DW	0ae00H
	DW	0a200H
	DW	0a600H
	DW	0ba00H
	DW	0be00H
	DW	0b200H
	DW	0b600H
	DW	08a00H
	DW	08e00H
	DW	08200H
	DW	08600H
	DW	09a00H
	DW	09e00H
	DW	09200H
	DW	09600H
	DW	0d500H
	DW	0d700H
	DW	0d100H
	DW	0d300H
	DW	0dd00H
	DW	0df00H
	DW	0d900H
	DW	0db00H
	DW	0c500H
	DW	0c700H
	DW	0c100H
	DW	0c300H
	DW	0cd00H
	DW	0cf00H
	DW	0c900H
	DW	0cb00H
	DW	0fea8H
	DW	0feb8H
	DW	0fe88H
	DW	0fe98H
	DW	0fee8H
	DW	0fef8H
	DW	0fec8H
	DW	0fed8H
	DW	0fe28H
	DW	0fe38H
	DW	0fe08H
	DW	0fe18H
	DW	0fe68H
	DW	0fe78H
	DW	0fe48H
	DW	0fe58H
	DW	0ffa8H
	DW	0ffb8H
	DW	0ff88H
	DW	0ff98H
	DW	0ffe8H
	DW	0fff8H
	DW	0ffc8H
	DW	0ffd8H
	DW	0ff28H
	DW	0ff38H
	DW	0ff08H
	DW	0ff18H
	DW	0ff68H
	DW	0ff78H
	DW	0ff48H
	DW	0ff58H
	DW	0faa0H
	DW	0fae0H
	DW	0fa20H
	DW	0fa60H
	DW	0fba0H
	DW	0fbe0H
	DW	0fb20H
	DW	0fb60H
	DW	0f8a0H
	DW	0f8e0H
	DW	0f820H
	DW	0f860H
	DW	0f9a0H
	DW	0f9e0H
	DW	0f920H
	DW	0f960H
	DW	0fd50H
	DW	0fd70H
	DW	0fd10H
	DW	0fd30H
	DW	0fdd0H
	DW	0fdf0H
	DW	0fd90H
	DW	0fdb0H
	DW	0fc50H
	DW	0fc70H
	DW	0fc10H
	DW	0fc30H
	DW	0fcd0H
	DW	0fcf0H
	DW	0fc90H
	DW	0fcb0H
	DW	01580H
	DW	01480H
	DW	01780H
	DW	01680H
	DW	01180H
	DW	01080H
	DW	01380H
	DW	01280H
	DW	01d80H
	DW	01c80H
	DW	01f80H
	DW	01e80H
	DW	01980H
	DW	01880H
	DW	01b80H
	DW	01a80H
	DW	0ac0H
	DW	0a40H
	DW	0bc0H
	DW	0b40H
	DW	08c0H
	DW	0840H
	DW	09c0H
	DW	0940H
	DW	0ec0H
	DW	0e40H
	DW	0fc0H
	DW	0f40H
	DW	0cc0H
	DW	0c40H
	DW	0dc0H
	DW	0d40H
	DW	05600H
	DW	05200H
	DW	05e00H
	DW	05a00H
	DW	04600H
	DW	04200H
	DW	04e00H
	DW	04a00H
	DW	07600H
	DW	07200H
	DW	07e00H
	DW	07a00H
	DW	06600H
	DW	06200H
	DW	06e00H
	DW	06a00H
	DW	02b00H
	DW	02900H
	DW	02f00H
	DW	02d00H
	DW	02300H
	DW	02100H
	DW	02700H
	DW	02500H
	DW	03b00H
	DW	03900H
	DW	03f00H
	DW	03d00H
	DW	03300H
	DW	03100H
	DW	03700H
	DW	03500H
	DW	0158H
	DW	0148H
	DW	0178H
	DW	0168H
	DW	0118H
	DW	0108H
	DW	0138H
	DW	0128H
	DW	01d8H
	DW	01c8H
	DW	01f8H
	DW	01e8H
	DW	0198H
	DW	0188H
	DW	01b8H
	DW	01a8H
	DW	058H
	DW	048H
	DW	078H
	DW	068H
	DW	018H
	DW	08H
	DW	038H
	DW	028H
	DW	0d8H
	DW	0c8H
	DW	0f8H
	DW	0e8H
	DW	098H
	DW	088H
	DW	0b8H
	DW	0a8H
	DW	0560H
	DW	0520H
	DW	05e0H
	DW	05a0H
	DW	0460H
	DW	0420H
	DW	04e0H
	DW	04a0H
	DW	0760H
	DW	0720H
	DW	07e0H
	DW	07a0H
	DW	0660H
	DW	0620H
	DW	06e0H
	DW	06a0H
	DW	02b0H
	DW	0290H
	DW	02f0H
	DW	02d0H
	DW	0230H
	DW	0210H
	DW	0270H
	DW	0250H
	DW	03b0H
	DW	0390H
	DW	03f0H
	DW	03d0H
	DW	0330H
	DW	0310H
	DW	0370H
	DW	0350H
indexTable DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02H
	DD	04H
	DD	06H
	DD	08H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	02H
	DD	04H
	DD	06H
	DD	08H
stepsizeTable DD 07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	010H
	DD	011H
	DD	013H
	DD	015H
	DD	017H
	DD	019H
	DD	01cH
	DD	01fH
	DD	022H
	DD	025H
	DD	029H
	DD	02dH
	DD	032H
	DD	037H
	DD	03cH
	DD	042H
	DD	049H
	DD	050H
	DD	058H
	DD	061H
	DD	06bH
	DD	076H
	DD	082H
	DD	08fH
	DD	09dH
	DD	0adH
	DD	0beH
	DD	0d1H
	DD	0e6H
	DD	0fdH
	DD	0117H
	DD	0133H
	DD	0151H
	DD	0173H
	DD	0198H
	DD	01c1H
	DD	01eeH
	DD	0220H
	DD	0256H
	DD	0292H
	DD	02d4H
	DD	031cH
	DD	036cH
	DD	03c3H
	DD	0424H
	DD	048eH
	DD	0502H
	DD	0583H
	DD	0610H
	DD	06abH
	DD	0756H
	DD	0812H
	DD	08e0H
	DD	09c3H
	DD	0abdH
	DD	0bd0H
	DD	0cffH
	DD	0e4cH
	DD	0fbaH
	DD	0114cH
	DD	01307H
	DD	014eeH
	DD	01706H
	DD	01954H
	DD	01bdcH
	DD	01ea5H
	DD	021b6H
	DD	02515H
	DD	028caH
	DD	02cdfH
	DD	0315bH
	DD	0364bH
	DD	03bb9H
	DD	041b2H
	DD	04844H
	DD	04f7eH
	DD	05771H
	DD	0602fH
	DD	069ceH
	DD	07462H
	DD	07fffH
	ORG $+12
audioop_methods DQ FLAT:??_C@_03LJAEFNNE@max?$AA@
	DQ	FLAT:audioop_max
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06OGLEOHCN@minmax?$AA@
	DQ	FLAT:audioop_minmax
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_03CHOBFJAH@avg?$AA@
	DQ	FLAT:audioop_avg
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05ILEAIFPA@maxpp?$AA@
	DQ	FLAT:audioop_maxpp
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05CGDIEJNA@avgpp?$AA@
	DQ	FLAT:audioop_avgpp
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_03FLJADKLC@rms?$AA@
	DQ	FLAT:audioop_rms
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_07NOCDNLLJ@findfit?$AA@
	DQ	FLAT:audioop_findfit
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_07KLIEECAM@findmax?$AA@
	DQ	FLAT:audioop_findmax
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0L@IOGIMBLK@findfactor?$AA@
	DQ	FLAT:audioop_findfactor
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05HCKPILGO@cross?$AA@
	DQ	FLAT:audioop_cross
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_03IMIFIBCN@mul?$AA@
	DQ	FLAT:audioop_mul
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_03BDGOHNNK@add?$AA@
	DQ	FLAT:audioop_add
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_04NBAGBPGE@bias?$AA@
	DQ	FLAT:audioop_bias
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08JAJLHMM@ulaw2lin?$AA@
	DQ	FLAT:audioop_ulaw2lin
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08JHJHNKEN@lin2ulaw?$AA@
	DQ	FLAT:audioop_lin2ulaw
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08PICFKELB@alaw2lin?$AA@
	DQ	FLAT:audioop_alaw2lin
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08CPHOLAP@lin2alaw?$AA@
	DQ	FLAT:audioop_lin2alaw
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_07CHCAOHKF@lin2lin?$AA@
	DQ	FLAT:audioop_lin2lin
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_09JHNCOGNI@adpcm2lin?$AA@
	DQ	FLAT:audioop_adpcm2lin
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_09IDBEIPAH@lin2adpcm?$AA@
	DQ	FLAT:audioop_lin2adpcm
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06CBNNKMNN@tomono?$AA@
	DQ	FLAT:audioop_tomono
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08MMNMKAHH@tostereo?$AA@
	DQ	FLAT:audioop_tostereo
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_09FMFCHLIO@getsample?$AA@
	DQ	FLAT:audioop_getsample
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_07KOIEOCCE@reverse?$AA@
	DQ	FLAT:audioop_reverse
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06OJJCNHEL@ratecv?$AA@
	DQ	FLAT:audioop_ratecv
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
audioopmodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_07DAHKDFPB@audioop?$AA@
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	FLAT:audioop_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
CONST	SEGMENT
maxvals	DD	00H
	DD	07fH
	DD	07fffH
	DD	07fffffH
	DD	07fffffffH
	ORG $+4
minvals	DD	00H
	DD	0ffffff80H
	DD	0ffff8000H
	DD	0ff800000H
	DD	080000000H
	ORG $+4
masks	DD	00H
	DD	0ffH
	DD	0ffffH
	DD	0ffffffH
	DD	0ffffffffH
CONST	ENDS
PUBLIC	??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@	; `string'
PUBLIC	??_C@_0P@EMOPIBPB@s?$CDin?3getsample?$AA@	; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
_BSS	SEGMENT
AudioopError DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\audioop.c
pdata	SEGMENT
$pdata$audioop_getsample DD imagerel audioop_getsample
	DD	imagerel audioop_getsample+265
	DD	imagerel $unwind$audioop_getsample
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_getsample DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@ DB 'Index out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMOPIBPB@s?$CDin?3getsample?$AA@
CONST	SEGMENT
??_C@_0P@EMOPIBPB@s?$CDin?3getsample?$AA@ DB 's#in:getsample', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_getsample
_TEXT	SEGMENT
cp$ = 48
i$ = 56
size$ = 64
len$ = 72
val$ = 80
tv77 = 88
self$ = 112
args$ = 120
audioop_getsample PROC					; COMDAT

; 341  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 342  :     signed char *cp;
; 343  :     Py_ssize_t len, i;
; 344  :     int size, val = 0;

  0000e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 345  : 
; 346  :     if ( !PyArg_ParseTuple(args, "s#in:getsample", &cp, &len, &size, &i) )

  00016	48 8d 44 24 38	 lea	 rax, QWORD PTR i$[rsp]
  0001b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00020	48 8d 44 24 40	 lea	 rax, QWORD PTR size$[rsp]
  00025	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002a	4c 8d 4c 24 48	 lea	 r9, QWORD PTR len$[rsp]
  0002f	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@EMOPIBPB@s?$CDin?3getsample?$AA@
  0003b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00040	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00045	85 c0		 test	 eax, eax
  00047	75 07		 jne	 SHORT $LN9@audioop_ge

; 347  :         return 0;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 b4 00 00 00	 jmp	 $LN10@audioop_ge
$LN9@audioop_ge:

; 348  :     if (!audioop_check_parameters(len, size))

  00050	8b 54 24 40	 mov	 edx, DWORD PTR size$[rsp]
  00054	48 8b 4c 24 48	 mov	 rcx, QWORD PTR len$[rsp]
  00059	e8 00 00 00 00	 call	 audioop_check_parameters
  0005e	85 c0		 test	 eax, eax
  00060	75 07		 jne	 SHORT $LN8@audioop_ge

; 349  :         return NULL;

  00062	33 c0		 xor	 eax, eax
  00064	e9 9b 00 00 00	 jmp	 $LN10@audioop_ge
$LN8@audioop_ge:

; 350  :     if ( i < 0 || i >= len/size ) {

  00069	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  0006f	7c 20		 jl	 SHORT $LN6@audioop_ge
  00071	48 63 44 24 40	 movsxd	 rax, DWORD PTR size$[rsp]
  00076	48 89 44 24 58	 mov	 QWORD PTR tv77[rsp], rax
  0007b	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00080	48 99		 cdq
  00082	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv77[rsp]
  00087	48 f7 f9	 idiv	 rcx
  0008a	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  0008f	7c 17		 jl	 SHORT $LN7@audioop_ge
$LN6@audioop_ge:

; 351  :         PyErr_SetString(AudioopError, "Index out of range");

  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@
  00098	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  0009f	e8 00 00 00 00	 call	 PyErr_SetString

; 352  :         return 0;

  000a4	33 c0		 xor	 eax, eax
  000a6	eb 5c		 jmp	 SHORT $LN10@audioop_ge
$LN7@audioop_ge:

; 353  :     }
; 354  :     if ( size == 1 )      val = (int)*CHARP(cp, i);

  000a8	83 7c 24 40 01	 cmp	 DWORD PTR size$[rsp], 1
  000ad	75 19		 jne	 SHORT $LN5@audioop_ge
  000af	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000b4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000b9	48 03 c8	 add	 rcx, rax
  000bc	48 8b c1	 mov	 rax, rcx
  000bf	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c2	89 44 24 50	 mov	 DWORD PTR val$[rsp], eax
  000c6	eb 33		 jmp	 SHORT $LN4@audioop_ge
$LN5@audioop_ge:

; 355  :     else if ( size == 2 ) val = (int)*SHORTP(cp, i*2);

  000c8	83 7c 24 40 02	 cmp	 DWORD PTR size$[rsp], 2
  000cd	75 14		 jne	 SHORT $LN3@audioop_ge
  000cf	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000d4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000d9	0f bf 04 48	 movsx	 eax, WORD PTR [rax+rcx*2]
  000dd	89 44 24 50	 mov	 DWORD PTR val$[rsp], eax
  000e1	eb 18		 jmp	 SHORT $LN2@audioop_ge
$LN3@audioop_ge:

; 356  :     else if ( size == 4 ) val = (int)*LONGP(cp, i*4);

  000e3	83 7c 24 40 04	 cmp	 DWORD PTR size$[rsp], 4
  000e8	75 11		 jne	 SHORT $LN1@audioop_ge
  000ea	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000f4	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  000f7	89 44 24 50	 mov	 DWORD PTR val$[rsp], eax
$LN1@audioop_ge:
$LN2@audioop_ge:
$LN4@audioop_ge:

; 357  :     return PyLong_FromLong(val);

  000fb	8b 4c 24 50	 mov	 ecx, DWORD PTR val$[rsp]
  000ff	e8 00 00 00 00	 call	 PyLong_FromLong
$LN10@audioop_ge:

; 358  : }

  00104	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00108	c3		 ret	 0
audioop_getsample ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_check_parameters DD imagerel audioop_check_parameters
	DD	imagerel audioop_check_parameters+96
	DD	imagerel $unwind$audioop_check_parameters
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_check_parameters DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT ??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@
CONST	SEGMENT
??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@ DB 'not a whole'
	DB	' number of frames', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_check_parameters
_TEXT	SEGMENT
tv67 = 32
len$ = 64
size$ = 72
audioop_check_parameters PROC				; COMDAT

; 329  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 330  :     if (!audioop_check_size(size))

  0000d	8b 4c 24 48	 mov	 ecx, DWORD PTR size$[rsp]
  00011	e8 00 00 00 00	 call	 audioop_check_size
  00016	85 c0		 test	 eax, eax
  00018	75 04		 jne	 SHORT $LN2@audioop_ch

; 331  :         return 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	eb 3d		 jmp	 SHORT $LN3@audioop_ch
$LN2@audioop_ch:

; 332  :     if (len % size != 0) {

  0001e	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  00023	48 89 44 24 20	 mov	 QWORD PTR tv67[rsp], rax
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR len$[rsp]
  0002d	48 99		 cdq
  0002f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv67[rsp]
  00034	48 f7 f9	 idiv	 rcx
  00037	48 8b c2	 mov	 rax, rdx
  0003a	48 85 c0	 test	 rax, rax
  0003d	74 17		 je	 SHORT $LN1@audioop_ch

; 333  :         PyErr_SetString(AudioopError, "not a whole number of frames");

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@
  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  0004d	e8 00 00 00 00	 call	 PyErr_SetString

; 334  :         return 0;

  00052	33 c0		 xor	 eax, eax
  00054	eb 05		 jmp	 SHORT $LN3@audioop_ch
$LN1@audioop_ch:

; 335  :     }
; 336  :     return 1;

  00056	b8 01 00 00 00	 mov	 eax, 1
$LN3@audioop_ch:

; 337  : }

  0005b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005f	c3		 ret	 0
audioop_check_parameters ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@FKJJCKC@Size?5should?5be?51?0?52?5or?54?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_check_size DD imagerel audioop_check_size
	DD	imagerel audioop_check_size+64
	DD	imagerel $unwind$audioop_check_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_check_size DD 010801H
	DD	04208H
xdata	ENDS
;	COMDAT ??_C@_0BJ@FKJJCKC@Size?5should?5be?51?0?52?5or?54?$AA@
CONST	SEGMENT
??_C@_0BJ@FKJJCKC@Size?5should?5be?51?0?52?5or?54?$AA@ DB 'Size should be'
	DB	' 1, 2 or 4', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_check_size
_TEXT	SEGMENT
size$ = 48
audioop_check_size PROC					; COMDAT

; 318  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 319  :     if (size != 1 && size != 2 && size != 4) {

  00008	83 7c 24 30 01	 cmp	 DWORD PTR size$[rsp], 1
  0000d	74 27		 je	 SHORT $LN2@audioop_ch@2
  0000f	83 7c 24 30 02	 cmp	 DWORD PTR size$[rsp], 2
  00014	74 20		 je	 SHORT $LN2@audioop_ch@2
  00016	83 7c 24 30 04	 cmp	 DWORD PTR size$[rsp], 4
  0001b	74 19		 je	 SHORT $LN2@audioop_ch@2

; 320  :         PyErr_SetString(AudioopError, "Size should be 1, 2 or 4");

  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@FKJJCKC@Size?5should?5be?51?0?52?5or?54?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString

; 321  :         return 0;

  00030	33 c0		 xor	 eax, eax
  00032	eb 07		 jmp	 SHORT $LN3@audioop_ch@2

; 322  :     }
; 323  :     else

  00034	eb 05		 jmp	 SHORT $LN1@audioop_ch@2
$LN2@audioop_ch@2:

; 324  :         return 1;

  00036	b8 01 00 00 00	 mov	 eax, 1
$LN1@audioop_ch@2:
$LN3@audioop_ch@2:

; 325  : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
audioop_check_size ENDP
_TEXT	ENDS
PUBLIC	??_C@_07OFICBGGG@s?$CDi?3max?$AA@		; `string'
EXTRN	PyLong_FromUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_max DD imagerel audioop_max
	DD	imagerel audioop_max+308
	DD	imagerel $unwind$audioop_max
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_max DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_07OFICBGGG@s?$CDi?3max?$AA@
CONST	SEGMENT
??_C@_07OFICBGGG@s?$CDi?3max?$AA@ DB 's#i:max', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_max
_TEXT	SEGMENT
cp$ = 48
i$ = 56
absval$ = 64
size$ = 68
len$ = 72
val$ = 80
max$ = 84
self$ = 112
args$ = 120
audioop_max PROC					; COMDAT

; 362  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 363  :     signed char *cp;
; 364  :     Py_ssize_t len, i;
; 365  :     int size, val = 0;

  0000e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 366  :     unsigned int absval, max = 0;

  00016	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR max$[rsp], 0

; 367  : 
; 368  :     if ( !PyArg_ParseTuple(args, "s#i:max", &cp, &len, &size) )

  0001e	48 8d 44 24 44	 lea	 rax, QWORD PTR size$[rsp]
  00023	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00028	4c 8d 4c 24 48	 lea	 r9, QWORD PTR len$[rsp]
  0002d	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07OFICBGGG@s?$CDi?3max?$AA@
  00039	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  0003e	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00043	85 c0		 test	 eax, eax
  00045	75 07		 jne	 SHORT $LN13@audioop_ma

; 369  :         return 0;

  00047	33 c0		 xor	 eax, eax
  00049	e9 e1 00 00 00	 jmp	 $LN14@audioop_ma
$LN13@audioop_ma:

; 370  :     if (!audioop_check_parameters(len, size))

  0004e	8b 54 24 44	 mov	 edx, DWORD PTR size$[rsp]
  00052	48 8b 4c 24 48	 mov	 rcx, QWORD PTR len$[rsp]
  00057	e8 00 00 00 00	 call	 audioop_check_parameters
  0005c	85 c0		 test	 eax, eax
  0005e	75 07		 jne	 SHORT $LN12@audioop_ma

; 371  :         return NULL;

  00060	33 c0		 xor	 eax, eax
  00062	e9 c8 00 00 00	 jmp	 $LN14@audioop_ma
$LN12@audioop_ma:

; 372  :     for ( i=0; i<len; i+= size) {

  00067	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00070	eb 15		 jmp	 SHORT $LN11@audioop_ma
$LN10@audioop_ma:
  00072	48 63 44 24 44	 movsxd	 rax, DWORD PTR size$[rsp]
  00077	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0007c	48 03 c8	 add	 rcx, rax
  0007f	48 8b c1	 mov	 rax, rcx
  00082	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN11@audioop_ma:
  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  0008c	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00091	0f 8d 8f 00 00
	00		 jge	 $LN9@audioop_ma

; 373  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  00097	83 7c 24 44 01	 cmp	 DWORD PTR size$[rsp], 1
  0009c	75 19		 jne	 SHORT $LN8@audioop_ma
  0009e	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000a3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000a8	48 03 c8	 add	 rcx, rax
  000ab	48 8b c1	 mov	 rax, rcx
  000ae	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b1	89 44 24 50	 mov	 DWORD PTR val$[rsp], eax
  000b5	eb 3d		 jmp	 SHORT $LN7@audioop_ma
$LN8@audioop_ma:

; 374  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  000b7	83 7c 24 44 02	 cmp	 DWORD PTR size$[rsp], 2
  000bc	75 19		 jne	 SHORT $LN6@audioop_ma
  000be	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000c8	48 03 c8	 add	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000d1	89 44 24 50	 mov	 DWORD PTR val$[rsp], eax
  000d5	eb 1d		 jmp	 SHORT $LN5@audioop_ma
$LN6@audioop_ma:

; 375  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  000d7	83 7c 24 44 04	 cmp	 DWORD PTR size$[rsp], 4
  000dc	75 16		 jne	 SHORT $LN4@audioop_ma
  000de	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000e3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000e8	48 03 c8	 add	 rcx, rax
  000eb	48 8b c1	 mov	 rax, rcx
  000ee	8b 00		 mov	 eax, DWORD PTR [rax]
  000f0	89 44 24 50	 mov	 DWORD PTR val$[rsp], eax
$LN4@audioop_ma:
$LN5@audioop_ma:
$LN7@audioop_ma:

; 376  :         if (val < 0) absval = (-val);

  000f4	83 7c 24 50 00	 cmp	 DWORD PTR val$[rsp], 0
  000f9	7d 0c		 jge	 SHORT $LN3@audioop_ma
  000fb	8b 44 24 50	 mov	 eax, DWORD PTR val$[rsp]
  000ff	f7 d8		 neg	 eax
  00101	89 44 24 40	 mov	 DWORD PTR absval$[rsp], eax
  00105	eb 08		 jmp	 SHORT $LN2@audioop_ma
$LN3@audioop_ma:

; 377  :         else absval = val;

  00107	8b 44 24 50	 mov	 eax, DWORD PTR val$[rsp]
  0010b	89 44 24 40	 mov	 DWORD PTR absval$[rsp], eax
$LN2@audioop_ma:

; 378  :         if (absval > max) max = absval;

  0010f	8b 44 24 54	 mov	 eax, DWORD PTR max$[rsp]
  00113	39 44 24 40	 cmp	 DWORD PTR absval$[rsp], eax
  00117	76 08		 jbe	 SHORT $LN1@audioop_ma
  00119	8b 44 24 40	 mov	 eax, DWORD PTR absval$[rsp]
  0011d	89 44 24 54	 mov	 DWORD PTR max$[rsp], eax
$LN1@audioop_ma:

; 379  :     }

  00121	e9 4c ff ff ff	 jmp	 $LN10@audioop_ma
$LN9@audioop_ma:

; 380  :     return PyLong_FromUnsignedLong(max);

  00126	8b 4c 24 54	 mov	 ecx, DWORD PTR max$[rsp]
  0012a	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
$LN14@audioop_ma:

; 381  : }

  0012f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00133	c3		 ret	 0
audioop_max ENDP
_TEXT	ENDS
PUBLIC	??_C@_04INACLLOK@?$CIii?$CJ?$AA@		; `string'
PUBLIC	??_C@_0L@DHDIHNNE@s?$CDi?3minmax?$AA@		; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_minmax DD imagerel audioop_minmax
	DD	imagerel audioop_minmax+319
	DD	imagerel $unwind$audioop_minmax
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_minmax DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
CONST	SEGMENT
??_C@_04INACLLOK@?$CIii?$CJ?$AA@ DB '(ii)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DHDIHNNE@s?$CDi?3minmax?$AA@
CONST	SEGMENT
??_C@_0L@DHDIHNNE@s?$CDi?3minmax?$AA@ DB 's#i:minmax', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_minmax
_TEXT	SEGMENT
cp$ = 48
i$ = 56
min$ = 64
size$ = 68
len$ = 72
val$ = 80
max$ = 84
self$ = 112
args$ = 120
audioop_minmax PROC					; COMDAT

; 385  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 386  :     signed char *cp;
; 387  :     Py_ssize_t len, i;
; 388  :     int size, val = 0;

  0000e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 389  :     /* -1 trick below is needed on Windows to support -0x80000000 without
; 390  :     a warning */
; 391  :     int min = 0x7fffffff, max = -0x7FFFFFFF-1;

  00016	c7 44 24 40 ff
	ff ff 7f	 mov	 DWORD PTR min$[rsp], 2147483647 ; 7fffffffH
  0001e	c7 44 24 54 00
	00 00 80	 mov	 DWORD PTR max$[rsp], -2147483648 ; ffffffff80000000H

; 392  : 
; 393  :     if (!PyArg_ParseTuple(args, "s#i:minmax", &cp, &len, &size))

  00026	48 8d 44 24 44	 lea	 rax, QWORD PTR size$[rsp]
  0002b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00030	4c 8d 4c 24 48	 lea	 r9, QWORD PTR len$[rsp]
  00035	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@DHDIHNNE@s?$CDi?3minmax?$AA@
  00041	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00046	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0004b	85 c0		 test	 eax, eax
  0004d	75 07		 jne	 SHORT $LN12@audioop_mi

; 394  :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 e4 00 00 00	 jmp	 $LN13@audioop_mi
$LN12@audioop_mi:

; 395  :     if (!audioop_check_parameters(len, size))

  00056	8b 54 24 44	 mov	 edx, DWORD PTR size$[rsp]
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR len$[rsp]
  0005f	e8 00 00 00 00	 call	 audioop_check_parameters
  00064	85 c0		 test	 eax, eax
  00066	75 07		 jne	 SHORT $LN11@audioop_mi

; 396  :         return NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 cb 00 00 00	 jmp	 $LN13@audioop_mi
$LN11@audioop_mi:

; 397  :     for (i = 0; i < len; i += size) {

  0006f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00078	eb 15		 jmp	 SHORT $LN10@audioop_mi
$LN9@audioop_mi:
  0007a	48 63 44 24 44	 movsxd	 rax, DWORD PTR size$[rsp]
  0007f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN10@audioop_mi:
  0008f	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00094	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00099	0f 8d 86 00 00
	00		 jge	 $LN8@audioop_mi

; 398  :         if (size == 1) val = (int) *CHARP(cp, i);

  0009f	83 7c 24 44 01	 cmp	 DWORD PTR size$[rsp], 1
  000a4	75 19		 jne	 SHORT $LN7@audioop_mi
  000a6	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000b0	48 03 c8	 add	 rcx, rax
  000b3	48 8b c1	 mov	 rax, rcx
  000b6	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b9	89 44 24 50	 mov	 DWORD PTR val$[rsp], eax
  000bd	eb 3d		 jmp	 SHORT $LN6@audioop_mi
$LN7@audioop_mi:

; 399  :         else if (size == 2) val = (int) *SHORTP(cp, i);

  000bf	83 7c 24 44 02	 cmp	 DWORD PTR size$[rsp], 2
  000c4	75 19		 jne	 SHORT $LN5@audioop_mi
  000c6	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000cb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000d0	48 03 c8	 add	 rcx, rax
  000d3	48 8b c1	 mov	 rax, rcx
  000d6	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000d9	89 44 24 50	 mov	 DWORD PTR val$[rsp], eax
  000dd	eb 1d		 jmp	 SHORT $LN4@audioop_mi
$LN5@audioop_mi:

; 400  :         else if (size == 4) val = (int) *LONGP(cp, i);

  000df	83 7c 24 44 04	 cmp	 DWORD PTR size$[rsp], 4
  000e4	75 16		 jne	 SHORT $LN3@audioop_mi
  000e6	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000eb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000f0	48 03 c8	 add	 rcx, rax
  000f3	48 8b c1	 mov	 rax, rcx
  000f6	8b 00		 mov	 eax, DWORD PTR [rax]
  000f8	89 44 24 50	 mov	 DWORD PTR val$[rsp], eax
$LN3@audioop_mi:
$LN4@audioop_mi:
$LN6@audioop_mi:

; 401  :         if (val > max) max = val;

  000fc	8b 44 24 54	 mov	 eax, DWORD PTR max$[rsp]
  00100	39 44 24 50	 cmp	 DWORD PTR val$[rsp], eax
  00104	7e 08		 jle	 SHORT $LN2@audioop_mi
  00106	8b 44 24 50	 mov	 eax, DWORD PTR val$[rsp]
  0010a	89 44 24 54	 mov	 DWORD PTR max$[rsp], eax
$LN2@audioop_mi:

; 402  :         if (val < min) min = val;

  0010e	8b 44 24 40	 mov	 eax, DWORD PTR min$[rsp]
  00112	39 44 24 50	 cmp	 DWORD PTR val$[rsp], eax
  00116	7d 08		 jge	 SHORT $LN1@audioop_mi
  00118	8b 44 24 50	 mov	 eax, DWORD PTR val$[rsp]
  0011c	89 44 24 40	 mov	 DWORD PTR min$[rsp], eax
$LN1@audioop_mi:

; 403  :     }

  00120	e9 55 ff ff ff	 jmp	 $LN9@audioop_mi
$LN8@audioop_mi:

; 404  :     return Py_BuildValue("(ii)", min, max);

  00125	44 8b 44 24 54	 mov	 r8d, DWORD PTR max$[rsp]
  0012a	8b 54 24 40	 mov	 edx, DWORD PTR min$[rsp]
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  00135	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
$LN13@audioop_mi:

; 405  : }

  0013a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0013e	c3		 ret	 0
audioop_minmax ENDP
_TEXT	ENDS
PUBLIC	??_C@_07HLGHBCLF@s?$CDi?3avg?$AA@		; `string'
EXTRN	__imp_floor:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_avg DD imagerel audioop_avg
	DD	imagerel audioop_avg+378
	DD	imagerel $unwind$audioop_avg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_avg DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_07HLGHBCLF@s?$CDi?3avg?$AA@
CONST	SEGMENT
??_C@_07HLGHBCLF@s?$CDi?3avg?$AA@ DB 's#i:avg', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_avg
_TEXT	SEGMENT
cp$ = 48
i$ = 56
avg$ = 64
size$ = 72
len$ = 80
val$ = 88
tv90 = 96
self$ = 128
args$ = 136
audioop_avg PROC					; COMDAT

; 409  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 410  :     signed char *cp;
; 411  :     Py_ssize_t len, i;
; 412  :     int size, val = 0;

  0000e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 413  :     double avg = 0.0;

  00016	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0001a	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR avg$[rsp], xmm0

; 414  : 
; 415  :     if ( !PyArg_ParseTuple(args, "s#i:avg", &cp, &len, &size) )

  00020	48 8d 44 24 48	 lea	 rax, QWORD PTR size$[rsp]
  00025	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002a	4c 8d 4c 24 50	 lea	 r9, QWORD PTR len$[rsp]
  0002f	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07HLGHBCLF@s?$CDi?3avg?$AA@
  0003b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00043	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00048	85 c0		 test	 eax, eax
  0004a	75 07		 jne	 SHORT $LN12@audioop_av

; 416  :         return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 22 01 00 00	 jmp	 $LN13@audioop_av
$LN12@audioop_av:

; 417  :     if (!audioop_check_parameters(len, size))

  00053	8b 54 24 48	 mov	 edx, DWORD PTR size$[rsp]
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  0005c	e8 00 00 00 00	 call	 audioop_check_parameters
  00061	85 c0		 test	 eax, eax
  00063	75 07		 jne	 SHORT $LN11@audioop_av

; 418  :         return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	e9 09 01 00 00	 jmp	 $LN13@audioop_av
$LN11@audioop_av:

; 419  :     for ( i=0; i<len; i+= size) {

  0006c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00075	eb 15		 jmp	 SHORT $LN10@audioop_av
$LN9@audioop_av:
  00077	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  0007c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN10@audioop_av:
  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00091	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00096	0f 8d 80 00 00
	00		 jge	 $LN8@audioop_av

; 420  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  0009c	83 7c 24 48 01	 cmp	 DWORD PTR size$[rsp], 1
  000a1	75 19		 jne	 SHORT $LN7@audioop_av
  000a3	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b6	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  000ba	eb 3d		 jmp	 SHORT $LN6@audioop_av
$LN7@audioop_av:

; 421  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  000bc	83 7c 24 48 02	 cmp	 DWORD PTR size$[rsp], 2
  000c1	75 19		 jne	 SHORT $LN5@audioop_av
  000c3	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000c8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000cd	48 03 c8	 add	 rcx, rax
  000d0	48 8b c1	 mov	 rax, rcx
  000d3	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000d6	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  000da	eb 1d		 jmp	 SHORT $LN4@audioop_av
$LN5@audioop_av:

; 422  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  000dc	83 7c 24 48 04	 cmp	 DWORD PTR size$[rsp], 4
  000e1	75 16		 jne	 SHORT $LN3@audioop_av
  000e3	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000ed	48 03 c8	 add	 rcx, rax
  000f0	48 8b c1	 mov	 rax, rcx
  000f3	8b 00		 mov	 eax, DWORD PTR [rax]
  000f5	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
$LN3@audioop_av:
$LN4@audioop_av:
$LN6@audioop_av:

; 423  :         avg += val;

  000f9	66 0f 6e 44 24
	58		 movd	 xmm0, DWORD PTR val$[rsp]
  000ff	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00103	f2 0f 10 4c 24
	40		 movsdx	 xmm1, QWORD PTR avg$[rsp]
  00109	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0010d	66 0f 28 c1	 movapd	 xmm0, xmm1
  00111	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR avg$[rsp], xmm0

; 424  :     }

  00117	e9 5b ff ff ff	 jmp	 $LN9@audioop_av
$LN8@audioop_av:

; 425  :     if ( len == 0 )

  0011c	48 83 7c 24 50
	00		 cmp	 QWORD PTR len$[rsp], 0
  00122	75 0a		 jne	 SHORT $LN2@audioop_av

; 426  :         val = 0;

  00124	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 427  :     else

  0012c	eb 3e		 jmp	 SHORT $LN1@audioop_av
$LN2@audioop_av:

; 428  :         val = (int)floor(avg / (double)(len/size));

  0012e	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  00133	48 89 44 24 60	 mov	 QWORD PTR tv90[rsp], rax
  00138	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  0013d	48 99		 cdq
  0013f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv90[rsp]
  00144	48 f7 f9	 idiv	 rcx
  00147	66 0f ef c0	 pxor	 xmm0, xmm0
  0014b	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00150	f2 0f 10 4c 24
	40		 movsdx	 xmm1, QWORD PTR avg$[rsp]
  00156	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0015a	66 0f 28 c1	 movapd	 xmm0, xmm1
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  00164	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00168	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
$LN1@audioop_av:

; 429  :     return PyLong_FromLong(val);

  0016c	8b 4c 24 58	 mov	 ecx, DWORD PTR val$[rsp]
  00170	e8 00 00 00 00	 call	 PyLong_FromLong
$LN13@audioop_av:

; 430  : }

  00175	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00179	c3		 ret	 0
audioop_avg ENDP
_TEXT	ENDS
PUBLIC	??_C@_07HBGHBAA@s?$CDi?3rms?$AA@		; `string'
EXTRN	sqrt:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_rms DD imagerel audioop_rms
	DD	imagerel audioop_rms+392
	DD	imagerel $unwind$audioop_rms
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_rms DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_07HBGHBAA@s?$CDi?3rms?$AA@
CONST	SEGMENT
??_C@_07HBGHBAA@s?$CDi?3rms?$AA@ DB 's#i:rms', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_rms
_TEXT	SEGMENT
res$ = 48
cp$ = 56
i$ = 64
sum_squares$ = 72
size$ = 80
len$ = 88
val$ = 96
tv92 = 104
self$ = 128
args$ = 136
audioop_rms PROC					; COMDAT

; 434  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 435  :     signed char *cp;
; 436  :     Py_ssize_t len, i;
; 437  :     int size, val = 0;

  0000e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 438  :     unsigned int res;
; 439  :     double sum_squares = 0.0;

  00016	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0001a	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR sum_squares$[rsp], xmm0

; 440  : 
; 441  :     if ( !PyArg_ParseTuple(args, "s#i:rms", &cp, &len, &size) )

  00020	48 8d 44 24 50	 lea	 rax, QWORD PTR size$[rsp]
  00025	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002a	4c 8d 4c 24 58	 lea	 r9, QWORD PTR len$[rsp]
  0002f	4c 8d 44 24 38	 lea	 r8, QWORD PTR cp$[rsp]
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07HBGHBAA@s?$CDi?3rms?$AA@
  0003b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00043	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00048	85 c0		 test	 eax, eax
  0004a	75 07		 jne	 SHORT $LN12@audioop_rm

; 442  :         return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 30 01 00 00	 jmp	 $LN13@audioop_rm
$LN12@audioop_rm:

; 443  :     if (!audioop_check_parameters(len, size))

  00053	8b 54 24 50	 mov	 edx, DWORD PTR size$[rsp]
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR len$[rsp]
  0005c	e8 00 00 00 00	 call	 audioop_check_parameters
  00061	85 c0		 test	 eax, eax
  00063	75 07		 jne	 SHORT $LN11@audioop_rm

; 444  :         return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	e9 17 01 00 00	 jmp	 $LN13@audioop_rm
$LN11@audioop_rm:

; 445  :     for ( i=0; i<len; i+= size) {

  0006c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00075	eb 15		 jmp	 SHORT $LN10@audioop_rm
$LN9@audioop_rm:
  00077	48 63 44 24 50	 movsxd	 rax, DWORD PTR size$[rsp]
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN10@audioop_rm:
  0008c	48 8b 44 24 58	 mov	 rax, QWORD PTR len$[rsp]
  00091	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  00096	0f 8d 8e 00 00
	00		 jge	 $LN8@audioop_rm

; 446  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  0009c	83 7c 24 50 01	 cmp	 DWORD PTR size$[rsp], 1
  000a1	75 19		 jne	 SHORT $LN7@audioop_rm
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b6	89 44 24 60	 mov	 DWORD PTR val$[rsp], eax
  000ba	eb 3d		 jmp	 SHORT $LN6@audioop_rm
$LN7@audioop_rm:

; 447  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  000bc	83 7c 24 50 02	 cmp	 DWORD PTR size$[rsp], 2
  000c1	75 19		 jne	 SHORT $LN5@audioop_rm
  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  000c8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  000cd	48 03 c8	 add	 rcx, rax
  000d0	48 8b c1	 mov	 rax, rcx
  000d3	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000d6	89 44 24 60	 mov	 DWORD PTR val$[rsp], eax
  000da	eb 1d		 jmp	 SHORT $LN4@audioop_rm
$LN5@audioop_rm:

; 448  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  000dc	83 7c 24 50 04	 cmp	 DWORD PTR size$[rsp], 4
  000e1	75 16		 jne	 SHORT $LN3@audioop_rm
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  000e8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  000ed	48 03 c8	 add	 rcx, rax
  000f0	48 8b c1	 mov	 rax, rcx
  000f3	8b 00		 mov	 eax, DWORD PTR [rax]
  000f5	89 44 24 60	 mov	 DWORD PTR val$[rsp], eax
$LN3@audioop_rm:
$LN4@audioop_rm:
$LN6@audioop_rm:

; 449  :         sum_squares += (double)val*(double)val;

  000f9	66 0f 6e 44 24
	60		 movd	 xmm0, DWORD PTR val$[rsp]
  000ff	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00103	66 0f 6e 4c 24
	60		 movd	 xmm1, DWORD PTR val$[rsp]
  00109	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0010d	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00111	f2 0f 10 4c 24
	48		 movsdx	 xmm1, QWORD PTR sum_squares$[rsp]
  00117	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0011b	66 0f 28 c1	 movapd	 xmm0, xmm1
  0011f	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR sum_squares$[rsp], xmm0

; 450  :     }

  00125	e9 4d ff ff ff	 jmp	 $LN9@audioop_rm
$LN8@audioop_rm:

; 451  :     if ( len == 0 )

  0012a	48 83 7c 24 58
	00		 cmp	 QWORD PTR len$[rsp], 0
  00130	75 0a		 jne	 SHORT $LN2@audioop_rm

; 452  :         res = 0;

  00132	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR res$[rsp], 0

; 453  :     else

  0013a	eb 3e		 jmp	 SHORT $LN1@audioop_rm
$LN2@audioop_rm:

; 454  :         res = (unsigned int)sqrt(sum_squares / (double)(len/size));

  0013c	48 63 44 24 50	 movsxd	 rax, DWORD PTR size$[rsp]
  00141	48 89 44 24 68	 mov	 QWORD PTR tv92[rsp], rax
  00146	48 8b 44 24 58	 mov	 rax, QWORD PTR len$[rsp]
  0014b	48 99		 cdq
  0014d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv92[rsp]
  00152	48 f7 f9	 idiv	 rcx
  00155	66 0f ef c0	 pxor	 xmm0, xmm0
  00159	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0015e	f2 0f 10 4c 24
	48		 movsdx	 xmm1, QWORD PTR sum_squares$[rsp]
  00164	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00168	66 0f 28 c1	 movapd	 xmm0, xmm1
  0016c	e8 00 00 00 00	 call	 sqrt
  00171	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  00176	89 44 24 30	 mov	 DWORD PTR res$[rsp], eax
$LN1@audioop_rm:

; 455  :     return PyLong_FromUnsignedLong(res);

  0017a	8b 4c 24 30	 mov	 ecx, DWORD PTR res$[rsp]
  0017e	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
$LN13@audioop_rm:

; 456  : }

  00183	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00187	c3		 ret	 0
audioop_rms ENDP
_TEXT	ENDS
PUBLIC	??_C@_04BLIJMEGO@?$CInf?$CJ?$AA@		; `string'
PUBLIC	??_C@_0BO@KHIJGMKO@First?5sample?5should?5be?5longer?$AA@ ; `string'
PUBLIC	??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@ ; `string'
PUBLIC	??_C@_0N@KEFBJNHN@s?$CDs?$CD?3findfit?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_findfit DD imagerel audioop_findfit
	DD	imagerel audioop_findfit+768
	DD	imagerel $unwind$audioop_findfit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_findfit DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_04BLIJMEGO@?$CInf?$CJ?$AA@
CONST	SEGMENT
??_C@_04BLIJMEGO@?$CInf?$CJ?$AA@ DB '(nf)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KHIJGMKO@First?5sample?5should?5be?5longer?$AA@
CONST	SEGMENT
??_C@_0BO@KHIJGMKO@First?5sample?5should?5be?5longer?$AA@ DB 'First sampl'
	DB	'e should be longer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@
CONST	SEGMENT
??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@ DB 'Strings shou'
	DB	'ld be even-sized', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KEFBJNHN@s?$CDs?$CD?3findfit?$AA@
CONST	SEGMENT
??_C@_0N@KEFBJNHN@s?$CDs?$CD?3findfit?$AA@ DB 's#s#:findfit', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_findfit
_TEXT	SEGMENT
sum_aij_2$ = 48
best_j$ = 56
len1$ = 64
cp1$ = 72
factor$ = 80
aj_m1$ = 88
sum_aij_ri$ = 96
best_result$ = 104
sum_ri_2$ = 112
len2$ = 120
aj_lm1$ = 128
cp2$ = 136
result$ = 144
j$ = 152
self$ = 176
args$ = 184
audioop_findfit PROC					; COMDAT

; 503  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 504  :     short *cp1, *cp2;
; 505  :     Py_ssize_t len1, len2;
; 506  :     Py_ssize_t j, best_j;
; 507  :     double aj_m1, aj_lm1;
; 508  :     double sum_ri_2, sum_aij_2, sum_aij_ri, result, best_result, factor;
; 509  : 
; 510  :     /* Passing a short** for an 's' argument is correct only
; 511  :        if the string contents is aligned for interpretation
; 512  :        as short[]. Due to the definition of PyBytesObject,
; 513  :        this is currently (Python 2.6) the case. */
; 514  :     if ( !PyArg_ParseTuple(args, "s#s#:findfit",
; 515  :                            (char**)&cp1, &len1, (char**)&cp2, &len2) )

  00011	48 8d 44 24 78	 lea	 rax, QWORD PTR len2$[rsp]
  00016	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0001b	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR cp2$[rsp]
  00023	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00028	4c 8d 4c 24 40	 lea	 r9, QWORD PTR len1$[rsp]
  0002d	4c 8d 44 24 48	 lea	 r8, QWORD PTR cp1$[rsp]
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KEFBJNHN@s?$CDs?$CD?3findfit?$AA@
  00039	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00041	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00046	85 c0		 test	 eax, eax
  00048	75 07		 jne	 SHORT $LN8@audioop_fi

; 516  :         return 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 a7 02 00 00	 jmp	 $LN9@audioop_fi
$LN8@audioop_fi:

; 517  :     if ( len1 & 1 || len2 & 1 ) {

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR len1$[rsp]
  00056	48 83 e0 01	 and	 rax, 1
  0005a	48 85 c0	 test	 rax, rax
  0005d	75 0e		 jne	 SHORT $LN6@audioop_fi
  0005f	48 8b 44 24 78	 mov	 rax, QWORD PTR len2$[rsp]
  00064	48 83 e0 01	 and	 rax, 1
  00068	48 85 c0	 test	 rax, rax
  0006b	74 1a		 je	 SHORT $LN7@audioop_fi
$LN6@audioop_fi:

; 518  :         PyErr_SetString(AudioopError, "Strings should be even-sized");

  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@
  00074	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  0007b	e8 00 00 00 00	 call	 PyErr_SetString

; 519  :         return 0;

  00080	33 c0		 xor	 eax, eax
  00082	e9 71 02 00 00	 jmp	 $LN9@audioop_fi
$LN7@audioop_fi:

; 520  :     }
; 521  :     len1 >>= 1;

  00087	48 8b 44 24 40	 mov	 rax, QWORD PTR len1$[rsp]
  0008c	48 d1 f8	 sar	 rax, 1
  0008f	48 89 44 24 40	 mov	 QWORD PTR len1$[rsp], rax

; 522  :     len2 >>= 1;

  00094	48 8b 44 24 78	 mov	 rax, QWORD PTR len2$[rsp]
  00099	48 d1 f8	 sar	 rax, 1
  0009c	48 89 44 24 78	 mov	 QWORD PTR len2$[rsp], rax

; 523  : 
; 524  :     if ( len1 < len2 ) {

  000a1	48 8b 44 24 78	 mov	 rax, QWORD PTR len2$[rsp]
  000a6	48 39 44 24 40	 cmp	 QWORD PTR len1$[rsp], rax
  000ab	7d 1a		 jge	 SHORT $LN5@audioop_fi

; 525  :         PyErr_SetString(AudioopError, "First sample should be longer");

  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@KHIJGMKO@First?5sample?5should?5be?5longer?$AA@
  000b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  000bb	e8 00 00 00 00	 call	 PyErr_SetString

; 526  :         return 0;

  000c0	33 c0		 xor	 eax, eax
  000c2	e9 31 02 00 00	 jmp	 $LN9@audioop_fi
$LN5@audioop_fi:

; 527  :     }
; 528  :     sum_ri_2 = _sum2(cp2, cp2, len2);

  000c7	4c 8b 44 24 78	 mov	 r8, QWORD PTR len2$[rsp]
  000cc	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR cp2$[rsp]
  000d4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cp2$[rsp]
  000dc	e8 00 00 00 00	 call	 _sum2
  000e1	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR sum_ri_2$[rsp], xmm0

; 529  :     sum_aij_2 = _sum2(cp1, cp1, len2);

  000e7	4c 8b 44 24 78	 mov	 r8, QWORD PTR len2$[rsp]
  000ec	48 8b 54 24 48	 mov	 rdx, QWORD PTR cp1$[rsp]
  000f1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cp1$[rsp]
  000f6	e8 00 00 00 00	 call	 _sum2
  000fb	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR sum_aij_2$[rsp], xmm0

; 530  :     sum_aij_ri = _sum2(cp1, cp2, len2);

  00101	4c 8b 44 24 78	 mov	 r8, QWORD PTR len2$[rsp]
  00106	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR cp2$[rsp]
  0010e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cp1$[rsp]
  00113	e8 00 00 00 00	 call	 _sum2
  00118	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR sum_aij_ri$[rsp], xmm0

; 531  : 
; 532  :     result = (sum_ri_2*sum_aij_2 - sum_aij_ri*sum_aij_ri) / sum_aij_2;

  0011e	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR sum_ri_2$[rsp]
  00124	f2 0f 59 44 24
	30		 mulsd	 xmm0, QWORD PTR sum_aij_2$[rsp]
  0012a	f2 0f 10 4c 24
	60		 movsdx	 xmm1, QWORD PTR sum_aij_ri$[rsp]
  00130	f2 0f 59 4c 24
	60		 mulsd	 xmm1, QWORD PTR sum_aij_ri$[rsp]
  00136	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0013a	f2 0f 5e 44 24
	30		 divsd	 xmm0, QWORD PTR sum_aij_2$[rsp]
  00140	f2 0f 11 84 24
	90 00 00 00	 movsdx	 QWORD PTR result$[rsp], xmm0

; 533  : 
; 534  :     best_result = result;

  00149	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR result$[rsp]
  00152	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR best_result$[rsp], xmm0

; 535  :     best_j = 0;

  00158	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR best_j$[rsp], 0

; 536  : 
; 537  :     for ( j=1; j<=len1-len2; j++) {

  00161	48 c7 84 24 98
	00 00 00 01 00
	00 00		 mov	 QWORD PTR j$[rsp], 1
  0016d	eb 13		 jmp	 SHORT $LN4@audioop_fi
$LN3@audioop_fi:
  0016f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00177	48 ff c0	 inc	 rax
  0017a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR j$[rsp], rax
$LN4@audioop_fi:
  00182	48 8b 44 24 78	 mov	 rax, QWORD PTR len2$[rsp]
  00187	48 8b 4c 24 40	 mov	 rcx, QWORD PTR len1$[rsp]
  0018c	48 2b c8	 sub	 rcx, rax
  0018f	48 8b c1	 mov	 rax, rcx
  00192	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR j$[rsp], rax
  0019a	0f 8f 0d 01 00
	00		 jg	 $LN2@audioop_fi

; 538  :         aj_m1 = (double)cp1[j-1];

  001a0	48 8b 44 24 48	 mov	 rax, QWORD PTR cp1$[rsp]
  001a5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  001ad	0f bf 44 48 fe	 movsx	 eax, WORD PTR [rax+rcx*2-2]
  001b2	66 0f 6e c0	 movd	 xmm0, eax
  001b6	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001ba	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR aj_m1$[rsp], xmm0

; 539  :         aj_lm1 = (double)cp1[j+len2-1];

  001c0	48 8b 44 24 78	 mov	 rax, QWORD PTR len2$[rsp]
  001c5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  001cd	48 03 c8	 add	 rcx, rax
  001d0	48 8b c1	 mov	 rax, rcx
  001d3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cp1$[rsp]
  001d8	0f bf 44 41 fe	 movsx	 eax, WORD PTR [rcx+rax*2-2]
  001dd	66 0f 6e c0	 movd	 xmm0, eax
  001e1	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001e5	f2 0f 11 84 24
	80 00 00 00	 movsdx	 QWORD PTR aj_lm1$[rsp], xmm0

; 540  : 
; 541  :         sum_aij_2 = sum_aij_2 + aj_lm1*aj_lm1 - aj_m1*aj_m1;

  001ee	f2 0f 10 84 24
	80 00 00 00	 movsdx	 xmm0, QWORD PTR aj_lm1$[rsp]
  001f7	f2 0f 59 84 24
	80 00 00 00	 mulsd	 xmm0, QWORD PTR aj_lm1$[rsp]
  00200	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR sum_aij_2$[rsp]
  00206	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0020a	66 0f 28 c1	 movapd	 xmm0, xmm1
  0020e	f2 0f 10 4c 24
	58		 movsdx	 xmm1, QWORD PTR aj_m1$[rsp]
  00214	f2 0f 59 4c 24
	58		 mulsd	 xmm1, QWORD PTR aj_m1$[rsp]
  0021a	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0021e	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR sum_aij_2$[rsp], xmm0

; 542  :         sum_aij_ri = _sum2(cp1+j, cp2, len2);

  00224	48 8b 44 24 48	 mov	 rax, QWORD PTR cp1$[rsp]
  00229	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00231	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00235	4c 8b 44 24 78	 mov	 r8, QWORD PTR len2$[rsp]
  0023a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR cp2$[rsp]
  00242	48 8b c8	 mov	 rcx, rax
  00245	e8 00 00 00 00	 call	 _sum2
  0024a	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR sum_aij_ri$[rsp], xmm0

; 543  : 
; 544  :         result = (sum_ri_2*sum_aij_2 - sum_aij_ri*sum_aij_ri)
; 545  :             / sum_aij_2;

  00250	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR sum_ri_2$[rsp]
  00256	f2 0f 59 44 24
	30		 mulsd	 xmm0, QWORD PTR sum_aij_2$[rsp]
  0025c	f2 0f 10 4c 24
	60		 movsdx	 xmm1, QWORD PTR sum_aij_ri$[rsp]
  00262	f2 0f 59 4c 24
	60		 mulsd	 xmm1, QWORD PTR sum_aij_ri$[rsp]
  00268	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0026c	f2 0f 5e 44 24
	30		 divsd	 xmm0, QWORD PTR sum_aij_2$[rsp]
  00272	f2 0f 11 84 24
	90 00 00 00	 movsdx	 QWORD PTR result$[rsp], xmm0

; 546  : 
; 547  :         if ( result < best_result ) {

  0027b	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR best_result$[rsp]
  00281	66 0f 2f 84 24
	90 00 00 00	 comisd	 xmm0, QWORD PTR result$[rsp]
  0028a	76 1c		 jbe	 SHORT $LN1@audioop_fi

; 548  :             best_result = result;

  0028c	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR result$[rsp]
  00295	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR best_result$[rsp], xmm0

; 549  :             best_j = j;

  0029b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  002a3	48 89 44 24 38	 mov	 QWORD PTR best_j$[rsp], rax
$LN1@audioop_fi:

; 550  :         }
; 551  : 
; 552  :     }

  002a8	e9 c2 fe ff ff	 jmp	 $LN3@audioop_fi
$LN2@audioop_fi:

; 553  : 
; 554  :     factor = _sum2(cp1+best_j, cp2, len2) / sum_ri_2;

  002ad	48 8b 44 24 48	 mov	 rax, QWORD PTR cp1$[rsp]
  002b2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR best_j$[rsp]
  002b7	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  002bb	4c 8b 44 24 78	 mov	 r8, QWORD PTR len2$[rsp]
  002c0	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR cp2$[rsp]
  002c8	48 8b c8	 mov	 rcx, rax
  002cb	e8 00 00 00 00	 call	 _sum2
  002d0	f2 0f 5e 44 24
	70		 divsd	 xmm0, QWORD PTR sum_ri_2$[rsp]
  002d6	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR factor$[rsp], xmm0

; 555  : 
; 556  :     return Py_BuildValue("(nf)", best_j, factor);

  002dc	f2 0f 10 54 24
	50		 movsdx	 xmm2, QWORD PTR factor$[rsp]
  002e2	66 49 0f 7e d0	 movd	 r8, xmm2
  002e7	48 8b 54 24 38	 mov	 rdx, QWORD PTR best_j$[rsp]
  002ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BLIJMEGO@?$CInf?$CJ?$AA@
  002f3	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
$LN9@audioop_fi:

; 557  : }

  002f8	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002ff	c3		 ret	 0
audioop_findfit ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_sum2 DD	imagerel _sum2
	DD	imagerel _sum2+140
	DD	imagerel $unwind$_sum2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_sum2 DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _sum2
_TEXT	SEGMENT
i$ = 0
sum$ = 8
a$ = 32
b$ = 40
len$ = 48
_sum2	PROC						; COMDAT

; 459  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 460  :     Py_ssize_t i;
; 461  :     double sum = 0.0;

  00013	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00017	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR sum$[rsp], xmm0

; 462  : 
; 463  :     for( i=0; i<len; i++) {

  0001d	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00025	eb 0b		 jmp	 SHORT $LN3@sum2
$LN2@sum2:
  00027	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  0002b	48 ff c0	 inc	 rax
  0002e	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN3@sum2:
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00037	48 39 04 24	 cmp	 QWORD PTR i$[rsp], rax
  0003b	7d 44		 jge	 SHORT $LN1@sum2

; 464  :         sum = sum + (double)a[i]*(double)b[i];

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR a$[rsp]
  00042	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  00046	0f bf 04 48	 movsx	 eax, WORD PTR [rax+rcx*2]
  0004a	66 0f 6e c0	 movd	 xmm0, eax
  0004e	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR b$[rsp]
  00057	48 8b 0c 24	 mov	 rcx, QWORD PTR i$[rsp]
  0005b	0f bf 04 48	 movsx	 eax, WORD PTR [rax+rcx*2]
  0005f	66 0f 6e c8	 movd	 xmm1, eax
  00063	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00067	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0006b	f2 0f 10 4c 24
	08		 movsdx	 xmm1, QWORD PTR sum$[rsp]
  00071	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00075	66 0f 28 c1	 movapd	 xmm0, xmm1
  00079	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR sum$[rsp], xmm0

; 465  :     }

  0007f	eb a6		 jmp	 SHORT $LN2@sum2
$LN1@sum2:

; 466  :     return sum;

  00081	f2 0f 10 44 24
	08		 movsdx	 xmm0, QWORD PTR sum$[rsp]

; 467  : }

  00087	48 83 c4 18	 add	 rsp, 24
  0008b	c3		 ret	 0
_sum2	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@HLOOEGLO@Samples?5should?5be?5same?5size?$AA@ ; `string'
PUBLIC	??_C@_0BA@OGAHMP@s?$CDs?$CD?3findfactor?$AA@	; `string'
EXTRN	PyFloat_FromDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_findfactor DD imagerel audioop_findfactor
	DD	imagerel audioop_findfactor+263
	DD	imagerel $unwind$audioop_findfactor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_findfactor DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0BM@HLOOEGLO@Samples?5should?5be?5same?5size?$AA@
CONST	SEGMENT
??_C@_0BM@HLOOEGLO@Samples?5should?5be?5same?5size?$AA@ DB 'Samples shoul'
	DB	'd be same size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@OGAHMP@s?$CDs?$CD?3findfactor?$AA@
CONST	SEGMENT
??_C@_0BA@OGAHMP@s?$CDs?$CD?3findfactor?$AA@ DB 's#s#:findfactor', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_findfactor
_TEXT	SEGMENT
len1$ = 48
cp1$ = 56
sum_aij_ri$ = 64
sum_ri_2$ = 72
len2$ = 80
cp2$ = 88
result$ = 96
self$ = 128
args$ = 136
audioop_findfactor PROC					; COMDAT

; 565  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 566  :     short *cp1, *cp2;
; 567  :     Py_ssize_t len1, len2;
; 568  :     double sum_ri_2, sum_aij_ri, result;
; 569  : 
; 570  :     if ( !PyArg_ParseTuple(args, "s#s#:findfactor",
; 571  :                            (char**)&cp1, &len1, (char**)&cp2, &len2) )

  0000e	48 8d 44 24 50	 lea	 rax, QWORD PTR len2$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00018	48 8d 44 24 58	 lea	 rax, QWORD PTR cp2$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8d 4c 24 30	 lea	 r9, QWORD PTR len1$[rsp]
  00027	4c 8d 44 24 38	 lea	 r8, QWORD PTR cp1$[rsp]
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@OGAHMP@s?$CDs?$CD?3findfactor?$AA@
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0003b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00040	85 c0		 test	 eax, eax
  00042	75 07		 jne	 SHORT $LN4@audioop_fi@2

; 572  :         return 0;

  00044	33 c0		 xor	 eax, eax
  00046	e9 b7 00 00 00	 jmp	 $LN5@audioop_fi@2
$LN4@audioop_fi@2:

; 573  :     if ( len1 & 1 || len2 & 1 ) {

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR len1$[rsp]
  00050	48 83 e0 01	 and	 rax, 1
  00054	48 85 c0	 test	 rax, rax
  00057	75 0e		 jne	 SHORT $LN2@audioop_fi@2
  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR len2$[rsp]
  0005e	48 83 e0 01	 and	 rax, 1
  00062	48 85 c0	 test	 rax, rax
  00065	74 1a		 je	 SHORT $LN3@audioop_fi@2
$LN2@audioop_fi@2:

; 574  :         PyErr_SetString(AudioopError, "Strings should be even-sized");

  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@
  0006e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  00075	e8 00 00 00 00	 call	 PyErr_SetString

; 575  :         return 0;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 81 00 00 00	 jmp	 $LN5@audioop_fi@2
$LN3@audioop_fi@2:

; 576  :     }
; 577  :     if ( len1 != len2 ) {

  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR len2$[rsp]
  00086	48 39 44 24 30	 cmp	 QWORD PTR len1$[rsp], rax
  0008b	74 17		 je	 SHORT $LN1@audioop_fi@2

; 578  :         PyErr_SetString(AudioopError, "Samples should be same size");

  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@HLOOEGLO@Samples?5should?5be?5same?5size?$AA@
  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  0009b	e8 00 00 00 00	 call	 PyErr_SetString

; 579  :         return 0;

  000a0	33 c0		 xor	 eax, eax
  000a2	eb 5e		 jmp	 SHORT $LN5@audioop_fi@2
$LN1@audioop_fi@2:

; 580  :     }
; 581  :     len2 >>= 1;

  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR len2$[rsp]
  000a9	48 d1 f8	 sar	 rax, 1
  000ac	48 89 44 24 50	 mov	 QWORD PTR len2$[rsp], rax

; 582  :     sum_ri_2 = _sum2(cp2, cp2, len2);

  000b1	4c 8b 44 24 50	 mov	 r8, QWORD PTR len2$[rsp]
  000b6	48 8b 54 24 58	 mov	 rdx, QWORD PTR cp2$[rsp]
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cp2$[rsp]
  000c0	e8 00 00 00 00	 call	 _sum2
  000c5	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR sum_ri_2$[rsp], xmm0

; 583  :     sum_aij_ri = _sum2(cp1, cp2, len2);

  000cb	4c 8b 44 24 50	 mov	 r8, QWORD PTR len2$[rsp]
  000d0	48 8b 54 24 58	 mov	 rdx, QWORD PTR cp2$[rsp]
  000d5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp1$[rsp]
  000da	e8 00 00 00 00	 call	 _sum2
  000df	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR sum_aij_ri$[rsp], xmm0

; 584  : 
; 585  :     result = sum_aij_ri / sum_ri_2;

  000e5	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR sum_aij_ri$[rsp]
  000eb	f2 0f 5e 44 24
	48		 divsd	 xmm0, QWORD PTR sum_ri_2$[rsp]
  000f1	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR result$[rsp], xmm0

; 586  : 
; 587  :     return PyFloat_FromDouble(result);

  000f7	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR result$[rsp]
  000fd	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN5@audioop_fi@2:

; 588  : }

  00102	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00106	c3		 ret	 0
audioop_findfactor ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@GHIJHFNH@Input?5sample?5should?5be?5longer?$AA@ ; `string'
PUBLIC	??_C@_0M@INOIJPFH@s?$CDn?3findmax?$AA@		; `string'
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_findmax DD imagerel audioop_findmax
	DD	imagerel audioop_findmax+441
	DD	imagerel $unwind$audioop_findmax
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_findmax DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_0BO@GHIJHFNH@Input?5sample?5should?5be?5longer?$AA@
CONST	SEGMENT
??_C@_0BO@GHIJHFNH@Input?5sample?5should?5be?5longer?$AA@ DB 'Input sampl'
	DB	'e should be longer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@INOIJPFH@s?$CDn?3findmax?$AA@
CONST	SEGMENT
??_C@_0M@INOIJPFH@s?$CDn?3findmax?$AA@ DB 's#n:findmax', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_findmax
_TEXT	SEGMENT
best_j$ = 48
len1$ = 56
cp1$ = 64
aj_m1$ = 72
best_result$ = 80
len2$ = 88
aj_lm1$ = 96
result$ = 104
j$ = 112
self$ = 144
args$ = 152
audioop_findmax PROC					; COMDAT

; 596  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 597  :     short *cp1;
; 598  :     Py_ssize_t len1, len2;
; 599  :     Py_ssize_t j, best_j;
; 600  :     double aj_m1, aj_lm1;
; 601  :     double result, best_result;
; 602  : 
; 603  :     if ( !PyArg_ParseTuple(args, "s#n:findmax",
; 604  :                            (char**)&cp1, &len1, &len2) )

  00011	48 8d 44 24 58	 lea	 rax, QWORD PTR len2$[rsp]
  00016	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001b	4c 8d 4c 24 38	 lea	 r9, QWORD PTR len1$[rsp]
  00020	4c 8d 44 24 40	 lea	 r8, QWORD PTR cp1$[rsp]
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@INOIJPFH@s?$CDn?3findmax?$AA@
  0002c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00034	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00039	85 c0		 test	 eax, eax
  0003b	75 07		 jne	 SHORT $LN8@audioop_fi@3

; 605  :         return 0;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 6d 01 00 00	 jmp	 $LN9@audioop_fi@3
$LN8@audioop_fi@3:

; 606  :     if ( len1 & 1 ) {

  00044	48 8b 44 24 38	 mov	 rax, QWORD PTR len1$[rsp]
  00049	48 83 e0 01	 and	 rax, 1
  0004d	48 85 c0	 test	 rax, rax
  00050	74 1a		 je	 SHORT $LN7@audioop_fi@3

; 607  :         PyErr_SetString(AudioopError, "Strings should be even-sized");

  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@CKECEMBI@Strings?5should?5be?5even?9sized?$AA@
  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  00060	e8 00 00 00 00	 call	 PyErr_SetString

; 608  :         return 0;

  00065	33 c0		 xor	 eax, eax
  00067	e9 45 01 00 00	 jmp	 $LN9@audioop_fi@3
$LN7@audioop_fi@3:

; 609  :     }
; 610  :     len1 >>= 1;

  0006c	48 8b 44 24 38	 mov	 rax, QWORD PTR len1$[rsp]
  00071	48 d1 f8	 sar	 rax, 1
  00074	48 89 44 24 38	 mov	 QWORD PTR len1$[rsp], rax

; 611  : 
; 612  :     if ( len2 < 0 || len1 < len2 ) {

  00079	48 83 7c 24 58
	00		 cmp	 QWORD PTR len2$[rsp], 0
  0007f	7c 0c		 jl	 SHORT $LN5@audioop_fi@3
  00081	48 8b 44 24 58	 mov	 rax, QWORD PTR len2$[rsp]
  00086	48 39 44 24 38	 cmp	 QWORD PTR len1$[rsp], rax
  0008b	7d 1a		 jge	 SHORT $LN6@audioop_fi@3
$LN5@audioop_fi@3:

; 613  :         PyErr_SetString(AudioopError, "Input sample should be longer");

  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@GHIJHFNH@Input?5sample?5should?5be?5longer?$AA@
  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  0009b	e8 00 00 00 00	 call	 PyErr_SetString

; 614  :         return 0;

  000a0	33 c0		 xor	 eax, eax
  000a2	e9 0a 01 00 00	 jmp	 $LN9@audioop_fi@3
$LN6@audioop_fi@3:

; 615  :     }
; 616  : 
; 617  :     result = _sum2(cp1, cp1, len2);

  000a7	4c 8b 44 24 58	 mov	 r8, QWORD PTR len2$[rsp]
  000ac	48 8b 54 24 40	 mov	 rdx, QWORD PTR cp1$[rsp]
  000b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cp1$[rsp]
  000b6	e8 00 00 00 00	 call	 _sum2
  000bb	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR result$[rsp], xmm0

; 618  : 
; 619  :     best_result = result;

  000c1	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR result$[rsp]
  000c7	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR best_result$[rsp], xmm0

; 620  :     best_j = 0;

  000cd	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR best_j$[rsp], 0

; 621  : 
; 622  :     for ( j=1; j<=len1-len2; j++) {

  000d6	48 c7 44 24 70
	01 00 00 00	 mov	 QWORD PTR j$[rsp], 1
  000df	eb 0d		 jmp	 SHORT $LN4@audioop_fi@3
$LN3@audioop_fi@3:
  000e1	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  000e6	48 ff c0	 inc	 rax
  000e9	48 89 44 24 70	 mov	 QWORD PTR j$[rsp], rax
$LN4@audioop_fi@3:
  000ee	48 8b 44 24 58	 mov	 rax, QWORD PTR len2$[rsp]
  000f3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR len1$[rsp]
  000f8	48 2b c8	 sub	 rcx, rax
  000fb	48 8b c1	 mov	 rax, rcx
  000fe	48 39 44 24 70	 cmp	 QWORD PTR j$[rsp], rax
  00103	0f 8f 9e 00 00
	00		 jg	 $LN2@audioop_fi@3

; 623  :         aj_m1 = (double)cp1[j-1];

  00109	48 8b 44 24 40	 mov	 rax, QWORD PTR cp1$[rsp]
  0010e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR j$[rsp]
  00113	0f bf 44 48 fe	 movsx	 eax, WORD PTR [rax+rcx*2-2]
  00118	66 0f 6e c0	 movd	 xmm0, eax
  0011c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00120	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR aj_m1$[rsp], xmm0

; 624  :         aj_lm1 = (double)cp1[j+len2-1];

  00126	48 8b 44 24 58	 mov	 rax, QWORD PTR len2$[rsp]
  0012b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR j$[rsp]
  00130	48 03 c8	 add	 rcx, rax
  00133	48 8b c1	 mov	 rax, rcx
  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cp1$[rsp]
  0013b	0f bf 44 41 fe	 movsx	 eax, WORD PTR [rcx+rax*2-2]
  00140	66 0f 6e c0	 movd	 xmm0, eax
  00144	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00148	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR aj_lm1$[rsp], xmm0

; 625  : 
; 626  :         result = result + aj_lm1*aj_lm1 - aj_m1*aj_m1;

  0014e	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR aj_lm1$[rsp]
  00154	f2 0f 59 44 24
	60		 mulsd	 xmm0, QWORD PTR aj_lm1$[rsp]
  0015a	f2 0f 10 4c 24
	68		 movsdx	 xmm1, QWORD PTR result$[rsp]
  00160	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00164	66 0f 28 c1	 movapd	 xmm0, xmm1
  00168	f2 0f 10 4c 24
	48		 movsdx	 xmm1, QWORD PTR aj_m1$[rsp]
  0016e	f2 0f 59 4c 24
	48		 mulsd	 xmm1, QWORD PTR aj_m1$[rsp]
  00174	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00178	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR result$[rsp], xmm0

; 627  : 
; 628  :         if ( result > best_result ) {

  0017e	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR result$[rsp]
  00184	66 0f 2f 44 24
	50		 comisd	 xmm0, QWORD PTR best_result$[rsp]
  0018a	76 16		 jbe	 SHORT $LN1@audioop_fi@3

; 629  :             best_result = result;

  0018c	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR result$[rsp]
  00192	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR best_result$[rsp], xmm0

; 630  :             best_j = j;

  00198	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  0019d	48 89 44 24 30	 mov	 QWORD PTR best_j$[rsp], rax
$LN1@audioop_fi@3:

; 631  :         }
; 632  : 
; 633  :     }

  001a2	e9 3a ff ff ff	 jmp	 $LN3@audioop_fi@3
$LN2@audioop_fi@3:

; 634  : 
; 635  :     return PyLong_FromSsize_t(best_j);

  001a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR best_j$[rsp]
  001ac	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN9@audioop_fi@3:

; 636  : }

  001b1	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001b8	c3		 ret	 0
audioop_findmax ENDP
_TEXT	ENDS
PUBLIC	??_C@_09BBMFEBHE@s?$CDi?3avgpp?$AA@		; `string'
EXTRN	fabs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_avgpp DD imagerel audioop_avgpp
	DD	imagerel audioop_avgpp+632
	DD	imagerel $unwind$audioop_avgpp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_avgpp DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_09BBMFEBHE@s?$CDi?3avgpp?$AA@
CONST	SEGMENT
??_C@_09BBMFEBHE@s?$CDi?3avgpp?$AA@ DB 's#i:avgpp', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_avgpp
_TEXT	SEGMENT
cp$ = 48
i$ = 56
nextreme$ = 64
avg$ = 68
prevextreme$ = 72
size$ = 76
len$ = 80
val$ = 88
sum$ = 96
prevextremevalid$ = 104
prevdiff$ = 108
prevval$ = 112
diff$ = 116
tv130 = 120
tv132 = 124
self$ = 144
args$ = 152
audioop_avgpp PROC					; COMDAT

; 640  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 641  :     signed char *cp;
; 642  :     Py_ssize_t len, i;
; 643  :     int size, val = 0, prevval = 0, prevextremevalid = 0,

  00011	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0
  00019	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR prevval$[rsp], 0
  00021	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR prevextremevalid$[rsp], 0

; 644  :         prevextreme = 0;

  00029	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR prevextreme$[rsp], 0

; 645  :     double sum = 0.0;

  00031	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00035	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR sum$[rsp], xmm0

; 646  :     unsigned int avg;
; 647  :     int diff, prevdiff, nextreme = 0;

  0003b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR nextreme$[rsp], 0

; 648  : 
; 649  :     if ( !PyArg_ParseTuple(args, "s#i:avgpp", &cp, &len, &size) )

  00043	48 8d 44 24 4c	 lea	 rax, QWORD PTR size$[rsp]
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	4c 8d 4c 24 50	 lea	 r9, QWORD PTR len$[rsp]
  00052	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09BBMFEBHE@s?$CDi?3avgpp?$AA@
  0005e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00066	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0006b	85 c0		 test	 eax, eax
  0006d	75 07		 jne	 SHORT $LN21@audioop_av@2

; 650  :         return 0;

  0006f	33 c0		 xor	 eax, eax
  00071	e9 fa 01 00 00	 jmp	 $LN22@audioop_av@2
$LN21@audioop_av@2:

; 651  :     if (!audioop_check_parameters(len, size))

  00076	8b 54 24 4c	 mov	 edx, DWORD PTR size$[rsp]
  0007a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  0007f	e8 00 00 00 00	 call	 audioop_check_parameters
  00084	85 c0		 test	 eax, eax
  00086	75 07		 jne	 SHORT $LN20@audioop_av@2

; 652  :         return NULL;

  00088	33 c0		 xor	 eax, eax
  0008a	e9 e1 01 00 00	 jmp	 $LN22@audioop_av@2
$LN20@audioop_av@2:

; 653  :     if (len <= size)

  0008f	48 63 44 24 4c	 movsxd	 rax, DWORD PTR size$[rsp]
  00094	48 39 44 24 50	 cmp	 QWORD PTR len$[rsp], rax
  00099	7f 0c		 jg	 SHORT $LN19@audioop_av@2

; 654  :         return PyLong_FromLong(0);

  0009b	33 c9		 xor	 ecx, ecx
  0009d	e8 00 00 00 00	 call	 PyLong_FromLong
  000a2	e9 c9 01 00 00	 jmp	 $LN22@audioop_av@2
$LN19@audioop_av@2:

; 655  :     if ( size == 1 )      prevval = (int)*CHARP(cp, 0);

  000a7	83 7c 24 4c 01	 cmp	 DWORD PTR size$[rsp], 1
  000ac	75 0e		 jne	 SHORT $LN18@audioop_av@2
  000ae	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000b3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000b6	89 44 24 70	 mov	 DWORD PTR prevval$[rsp], eax
  000ba	eb 27		 jmp	 SHORT $LN17@audioop_av@2
$LN18@audioop_av@2:

; 656  :     else if ( size == 2 ) prevval = (int)*SHORTP(cp, 0);

  000bc	83 7c 24 4c 02	 cmp	 DWORD PTR size$[rsp], 2
  000c1	75 0e		 jne	 SHORT $LN16@audioop_av@2
  000c3	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000c8	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000cb	89 44 24 70	 mov	 DWORD PTR prevval$[rsp], eax
  000cf	eb 12		 jmp	 SHORT $LN15@audioop_av@2
$LN16@audioop_av@2:

; 657  :     else if ( size == 4 ) prevval = (int)*LONGP(cp, 0);

  000d1	83 7c 24 4c 04	 cmp	 DWORD PTR size$[rsp], 4
  000d6	75 0b		 jne	 SHORT $LN14@audioop_av@2
  000d8	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000dd	8b 00		 mov	 eax, DWORD PTR [rax]
  000df	89 44 24 70	 mov	 DWORD PTR prevval$[rsp], eax
$LN14@audioop_av@2:
$LN15@audioop_av@2:
$LN17@audioop_av@2:

; 658  :     prevdiff = 17; /* Anything != 0, 1 */

  000e3	c7 44 24 6c 11
	00 00 00	 mov	 DWORD PTR prevdiff$[rsp], 17

; 659  :     for ( i=size; i<len; i+= size) {

  000eb	48 63 44 24 4c	 movsxd	 rax, DWORD PTR size$[rsp]
  000f0	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
  000f5	eb 15		 jmp	 SHORT $LN13@audioop_av@2
$LN12@audioop_av@2:
  000f7	48 63 44 24 4c	 movsxd	 rax, DWORD PTR size$[rsp]
  000fc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00101	48 03 c8	 add	 rcx, rax
  00104	48 8b c1	 mov	 rax, rcx
  00107	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN13@audioop_av@2:
  0010c	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00111	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00116	0f 8d 19 01 00
	00		 jge	 $LN11@audioop_av@2

; 660  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  0011c	83 7c 24 4c 01	 cmp	 DWORD PTR size$[rsp], 1
  00121	75 19		 jne	 SHORT $LN10@audioop_av@2
  00123	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00128	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  0012d	48 03 c8	 add	 rcx, rax
  00130	48 8b c1	 mov	 rax, rcx
  00133	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00136	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  0013a	eb 3d		 jmp	 SHORT $LN9@audioop_av@2
$LN10@audioop_av@2:

; 661  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  0013c	83 7c 24 4c 02	 cmp	 DWORD PTR size$[rsp], 2
  00141	75 19		 jne	 SHORT $LN8@audioop_av@2
  00143	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00148	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  0014d	48 03 c8	 add	 rcx, rax
  00150	48 8b c1	 mov	 rax, rcx
  00153	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00156	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  0015a	eb 1d		 jmp	 SHORT $LN7@audioop_av@2
$LN8@audioop_av@2:

; 662  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  0015c	83 7c 24 4c 04	 cmp	 DWORD PTR size$[rsp], 4
  00161	75 16		 jne	 SHORT $LN6@audioop_av@2
  00163	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00168	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  0016d	48 03 c8	 add	 rcx, rax
  00170	48 8b c1	 mov	 rax, rcx
  00173	8b 00		 mov	 eax, DWORD PTR [rax]
  00175	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
$LN6@audioop_av@2:
$LN7@audioop_av@2:
$LN9@audioop_av@2:

; 663  :         if (val != prevval) {

  00179	8b 44 24 70	 mov	 eax, DWORD PTR prevval$[rsp]
  0017d	39 44 24 58	 cmp	 DWORD PTR val$[rsp], eax
  00181	0f 84 a9 00 00
	00		 je	 $LN5@audioop_av@2

; 664  :             diff = val < prevval;

  00187	8b 44 24 70	 mov	 eax, DWORD PTR prevval$[rsp]
  0018b	39 44 24 58	 cmp	 DWORD PTR val$[rsp], eax
  0018f	7d 0a		 jge	 SHORT $LN24@audioop_av@2
  00191	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  00199	eb 08		 jmp	 SHORT $LN25@audioop_av@2
$LN24@audioop_av@2:
  0019b	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN25@audioop_av@2:
  001a3	8b 44 24 78	 mov	 eax, DWORD PTR tv130[rsp]
  001a7	89 44 24 74	 mov	 DWORD PTR diff$[rsp], eax

; 665  :             if (prevdiff == !diff) {

  001ab	83 7c 24 74 00	 cmp	 DWORD PTR diff$[rsp], 0
  001b0	75 0a		 jne	 SHORT $LN26@audioop_av@2
  001b2	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  001ba	eb 08		 jmp	 SHORT $LN27@audioop_av@2
$LN26@audioop_av@2:
  001bc	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN27@audioop_av@2:
  001c4	8b 44 24 7c	 mov	 eax, DWORD PTR tv132[rsp]
  001c8	39 44 24 6c	 cmp	 DWORD PTR prevdiff$[rsp], eax
  001cc	75 52		 jne	 SHORT $LN4@audioop_av@2

; 666  :                 /* Derivative changed sign. Compute difference to last
; 667  :                 ** extreme value and remember.
; 668  :                 */
; 669  :                 if (prevextremevalid) {

  001ce	83 7c 24 68 00	 cmp	 DWORD PTR prevextremevalid$[rsp], 0
  001d3	74 3b		 je	 SHORT $LN3@audioop_av@2

; 670  :                     sum += fabs((double)prevval - (double)prevextreme);

  001d5	66 0f 6e 44 24
	70		 movd	 xmm0, DWORD PTR prevval$[rsp]
  001db	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001df	66 0f 6e 4c 24
	48		 movd	 xmm1, DWORD PTR prevextreme$[rsp]
  001e5	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  001e9	f2 0f 5c c1	 subsd	 xmm0, xmm1
  001ed	e8 00 00 00 00	 call	 fabs
  001f2	f2 0f 10 4c 24
	60		 movsdx	 xmm1, QWORD PTR sum$[rsp]
  001f8	f2 0f 58 c8	 addsd	 xmm1, xmm0
  001fc	66 0f 28 c1	 movapd	 xmm0, xmm1
  00200	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR sum$[rsp], xmm0

; 671  :                     nextreme++;

  00206	8b 44 24 40	 mov	 eax, DWORD PTR nextreme$[rsp]
  0020a	ff c0		 inc	 eax
  0020c	89 44 24 40	 mov	 DWORD PTR nextreme$[rsp], eax
$LN3@audioop_av@2:

; 672  :                 }
; 673  :                 prevextremevalid = 1;

  00210	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR prevextremevalid$[rsp], 1

; 674  :                 prevextreme = prevval;

  00218	8b 44 24 70	 mov	 eax, DWORD PTR prevval$[rsp]
  0021c	89 44 24 48	 mov	 DWORD PTR prevextreme$[rsp], eax
$LN4@audioop_av@2:

; 675  :             }
; 676  :             prevval = val;

  00220	8b 44 24 58	 mov	 eax, DWORD PTR val$[rsp]
  00224	89 44 24 70	 mov	 DWORD PTR prevval$[rsp], eax

; 677  :             prevdiff = diff;

  00228	8b 44 24 74	 mov	 eax, DWORD PTR diff$[rsp]
  0022c	89 44 24 6c	 mov	 DWORD PTR prevdiff$[rsp], eax
$LN5@audioop_av@2:

; 678  :         }
; 679  :     }

  00230	e9 c2 fe ff ff	 jmp	 $LN12@audioop_av@2
$LN11@audioop_av@2:

; 680  :     if ( nextreme == 0 )

  00235	83 7c 24 40 00	 cmp	 DWORD PTR nextreme$[rsp], 0
  0023a	75 0a		 jne	 SHORT $LN2@audioop_av@2

; 681  :         avg = 0;

  0023c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR avg$[rsp], 0

; 682  :     else

  00244	eb 21		 jmp	 SHORT $LN1@audioop_av@2
$LN2@audioop_av@2:

; 683  :         avg = (unsigned int)(sum / (double)nextreme);

  00246	66 0f 6e 44 24
	40		 movd	 xmm0, DWORD PTR nextreme$[rsp]
  0024c	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00250	f2 0f 10 4c 24
	60		 movsdx	 xmm1, QWORD PTR sum$[rsp]
  00256	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0025a	66 0f 28 c1	 movapd	 xmm0, xmm1
  0025e	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  00263	89 44 24 44	 mov	 DWORD PTR avg$[rsp], eax
$LN1@audioop_av@2:

; 684  :     return PyLong_FromUnsignedLong(avg);

  00267	8b 4c 24 44	 mov	 ecx, DWORD PTR avg$[rsp]
  0026b	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
$LN22@audioop_av@2:

; 685  : }

  00270	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00277	c3		 ret	 0
audioop_avgpp ENDP
_TEXT	ENDS
PUBLIC	??_C@_09LMLNINFE@s?$CDi?3maxpp?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_maxpp DD imagerel audioop_maxpp
	DD	imagerel audioop_maxpp+575
	DD	imagerel $unwind$audioop_maxpp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_maxpp DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_09LMLNINFE@s?$CDi?3maxpp?$AA@
CONST	SEGMENT
??_C@_09LMLNINFE@s?$CDi?3maxpp?$AA@ DB 's#i:maxpp', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_maxpp
_TEXT	SEGMENT
cp$ = 48
i$ = 56
prevextreme$ = 64
size$ = 68
len$ = 72
extremediff$ = 80
val$ = 84
prevextremevalid$ = 88
prevdiff$ = 92
prevval$ = 96
diff$ = 100
max$ = 104
tv130 = 108
tv132 = 112
self$ = 144
args$ = 152
audioop_maxpp PROC					; COMDAT

; 689  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 690  :     signed char *cp;
; 691  :     Py_ssize_t len, i;
; 692  :     int size, val = 0, prevval = 0, prevextremevalid = 0,

  00011	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0
  00019	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR prevval$[rsp], 0
  00021	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR prevextremevalid$[rsp], 0

; 693  :         prevextreme = 0;

  00029	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR prevextreme$[rsp], 0

; 694  :     unsigned int max = 0, extremediff;

  00031	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR max$[rsp], 0

; 695  :     int diff, prevdiff;
; 696  : 
; 697  :     if ( !PyArg_ParseTuple(args, "s#i:maxpp", &cp, &len, &size) )

  00039	48 8d 44 24 44	 lea	 rax, QWORD PTR size$[rsp]
  0003e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00043	4c 8d 4c 24 48	 lea	 r9, QWORD PTR len$[rsp]
  00048	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LMLNINFE@s?$CDi?3maxpp?$AA@
  00054	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0005c	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00061	85 c0		 test	 eax, eax
  00063	75 07		 jne	 SHORT $LN22@audioop_ma@2

; 698  :         return 0;

  00065	33 c0		 xor	 eax, eax
  00067	e9 cb 01 00 00	 jmp	 $LN23@audioop_ma@2
$LN22@audioop_ma@2:

; 699  :     if (!audioop_check_parameters(len, size))

  0006c	8b 54 24 44	 mov	 edx, DWORD PTR size$[rsp]
  00070	48 8b 4c 24 48	 mov	 rcx, QWORD PTR len$[rsp]
  00075	e8 00 00 00 00	 call	 audioop_check_parameters
  0007a	85 c0		 test	 eax, eax
  0007c	75 07		 jne	 SHORT $LN21@audioop_ma@2

; 700  :         return NULL;

  0007e	33 c0		 xor	 eax, eax
  00080	e9 b2 01 00 00	 jmp	 $LN23@audioop_ma@2
$LN21@audioop_ma@2:

; 701  :     if (len <= size)

  00085	48 63 44 24 44	 movsxd	 rax, DWORD PTR size$[rsp]
  0008a	48 39 44 24 48	 cmp	 QWORD PTR len$[rsp], rax
  0008f	7f 0c		 jg	 SHORT $LN20@audioop_ma@2

; 702  :         return PyLong_FromLong(0);

  00091	33 c9		 xor	 ecx, ecx
  00093	e8 00 00 00 00	 call	 PyLong_FromLong
  00098	e9 9a 01 00 00	 jmp	 $LN23@audioop_ma@2
$LN20@audioop_ma@2:

; 703  :     if ( size == 1 )      prevval = (int)*CHARP(cp, 0);

  0009d	83 7c 24 44 01	 cmp	 DWORD PTR size$[rsp], 1
  000a2	75 0e		 jne	 SHORT $LN19@audioop_ma@2
  000a4	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000a9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ac	89 44 24 60	 mov	 DWORD PTR prevval$[rsp], eax
  000b0	eb 27		 jmp	 SHORT $LN18@audioop_ma@2
$LN19@audioop_ma@2:

; 704  :     else if ( size == 2 ) prevval = (int)*SHORTP(cp, 0);

  000b2	83 7c 24 44 02	 cmp	 DWORD PTR size$[rsp], 2
  000b7	75 0e		 jne	 SHORT $LN17@audioop_ma@2
  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000be	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000c1	89 44 24 60	 mov	 DWORD PTR prevval$[rsp], eax
  000c5	eb 12		 jmp	 SHORT $LN16@audioop_ma@2
$LN17@audioop_ma@2:

; 705  :     else if ( size == 4 ) prevval = (int)*LONGP(cp, 0);

  000c7	83 7c 24 44 04	 cmp	 DWORD PTR size$[rsp], 4
  000cc	75 0b		 jne	 SHORT $LN15@audioop_ma@2
  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  000d3	8b 00		 mov	 eax, DWORD PTR [rax]
  000d5	89 44 24 60	 mov	 DWORD PTR prevval$[rsp], eax
$LN15@audioop_ma@2:
$LN16@audioop_ma@2:
$LN18@audioop_ma@2:

; 706  :     prevdiff = 17; /* Anything != 0, 1 */

  000d9	c7 44 24 5c 11
	00 00 00	 mov	 DWORD PTR prevdiff$[rsp], 17

; 707  :     for ( i=size; i<len; i+= size) {

  000e1	48 63 44 24 44	 movsxd	 rax, DWORD PTR size$[rsp]
  000e6	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
  000eb	eb 15		 jmp	 SHORT $LN14@audioop_ma@2
$LN13@audioop_ma@2:
  000ed	48 63 44 24 44	 movsxd	 rax, DWORD PTR size$[rsp]
  000f2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000f7	48 03 c8	 add	 rcx, rax
  000fa	48 8b c1	 mov	 rax, rcx
  000fd	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN14@audioop_ma@2:
  00102	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00107	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  0010c	0f 8d 1c 01 00
	00		 jge	 $LN12@audioop_ma@2

; 708  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  00112	83 7c 24 44 01	 cmp	 DWORD PTR size$[rsp], 1
  00117	75 19		 jne	 SHORT $LN11@audioop_ma@2
  00119	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0011e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  00123	48 03 c8	 add	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0012c	89 44 24 54	 mov	 DWORD PTR val$[rsp], eax
  00130	eb 3d		 jmp	 SHORT $LN10@audioop_ma@2
$LN11@audioop_ma@2:

; 709  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  00132	83 7c 24 44 02	 cmp	 DWORD PTR size$[rsp], 2
  00137	75 19		 jne	 SHORT $LN9@audioop_ma@2
  00139	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0013e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  00143	48 03 c8	 add	 rcx, rax
  00146	48 8b c1	 mov	 rax, rcx
  00149	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0014c	89 44 24 54	 mov	 DWORD PTR val$[rsp], eax
  00150	eb 1d		 jmp	 SHORT $LN8@audioop_ma@2
$LN9@audioop_ma@2:

; 710  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  00152	83 7c 24 44 04	 cmp	 DWORD PTR size$[rsp], 4
  00157	75 16		 jne	 SHORT $LN7@audioop_ma@2
  00159	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0015e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  00163	48 03 c8	 add	 rcx, rax
  00166	48 8b c1	 mov	 rax, rcx
  00169	8b 00		 mov	 eax, DWORD PTR [rax]
  0016b	89 44 24 54	 mov	 DWORD PTR val$[rsp], eax
$LN7@audioop_ma@2:
$LN8@audioop_ma@2:
$LN10@audioop_ma@2:

; 711  :         if (val != prevval) {

  0016f	8b 44 24 60	 mov	 eax, DWORD PTR prevval$[rsp]
  00173	39 44 24 54	 cmp	 DWORD PTR val$[rsp], eax
  00177	0f 84 ac 00 00
	00		 je	 $LN6@audioop_ma@2

; 712  :             diff = val < prevval;

  0017d	8b 44 24 60	 mov	 eax, DWORD PTR prevval$[rsp]
  00181	39 44 24 54	 cmp	 DWORD PTR val$[rsp], eax
  00185	7d 0a		 jge	 SHORT $LN25@audioop_ma@2
  00187	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  0018f	eb 08		 jmp	 SHORT $LN26@audioop_ma@2
$LN25@audioop_ma@2:
  00191	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN26@audioop_ma@2:
  00199	8b 44 24 6c	 mov	 eax, DWORD PTR tv130[rsp]
  0019d	89 44 24 64	 mov	 DWORD PTR diff$[rsp], eax

; 713  :             if (prevdiff == !diff) {

  001a1	83 7c 24 64 00	 cmp	 DWORD PTR diff$[rsp], 0
  001a6	75 0a		 jne	 SHORT $LN27@audioop_ma@2
  001a8	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv132[rsp], 1
  001b0	eb 08		 jmp	 SHORT $LN28@audioop_ma@2
$LN27@audioop_ma@2:
  001b2	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN28@audioop_ma@2:
  001ba	8b 44 24 70	 mov	 eax, DWORD PTR tv132[rsp]
  001be	39 44 24 5c	 cmp	 DWORD PTR prevdiff$[rsp], eax
  001c2	75 55		 jne	 SHORT $LN5@audioop_ma@2

; 714  :                 /* Derivative changed sign. Compute difference to
; 715  :                 ** last extreme value and remember.
; 716  :                 */
; 717  :                 if (prevextremevalid) {

  001c4	83 7c 24 58 00	 cmp	 DWORD PTR prevextremevalid$[rsp], 0
  001c9	74 3e		 je	 SHORT $LN4@audioop_ma@2

; 718  :                     if (prevval < prevextreme)

  001cb	8b 44 24 40	 mov	 eax, DWORD PTR prevextreme$[rsp]
  001cf	39 44 24 60	 cmp	 DWORD PTR prevval$[rsp], eax
  001d3	7d 12		 jge	 SHORT $LN3@audioop_ma@2

; 719  :                         extremediff = (unsigned int)prevextreme -
; 720  :                                       (unsigned int)prevval;

  001d5	8b 44 24 60	 mov	 eax, DWORD PTR prevval$[rsp]
  001d9	8b 4c 24 40	 mov	 ecx, DWORD PTR prevextreme$[rsp]
  001dd	2b c8		 sub	 ecx, eax
  001df	8b c1		 mov	 eax, ecx
  001e1	89 44 24 50	 mov	 DWORD PTR extremediff$[rsp], eax

; 721  :                     else

  001e5	eb 10		 jmp	 SHORT $LN2@audioop_ma@2
$LN3@audioop_ma@2:

; 722  :                         extremediff = (unsigned int)prevval -
; 723  :                                       (unsigned int)prevextreme;

  001e7	8b 44 24 40	 mov	 eax, DWORD PTR prevextreme$[rsp]
  001eb	8b 4c 24 60	 mov	 ecx, DWORD PTR prevval$[rsp]
  001ef	2b c8		 sub	 ecx, eax
  001f1	8b c1		 mov	 eax, ecx
  001f3	89 44 24 50	 mov	 DWORD PTR extremediff$[rsp], eax
$LN2@audioop_ma@2:

; 724  :                     if ( extremediff > max )

  001f7	8b 44 24 68	 mov	 eax, DWORD PTR max$[rsp]
  001fb	39 44 24 50	 cmp	 DWORD PTR extremediff$[rsp], eax
  001ff	76 08		 jbe	 SHORT $LN1@audioop_ma@2

; 725  :                         max = extremediff;

  00201	8b 44 24 50	 mov	 eax, DWORD PTR extremediff$[rsp]
  00205	89 44 24 68	 mov	 DWORD PTR max$[rsp], eax
$LN1@audioop_ma@2:
$LN4@audioop_ma@2:

; 726  :                 }
; 727  :                 prevextremevalid = 1;

  00209	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR prevextremevalid$[rsp], 1

; 728  :                 prevextreme = prevval;

  00211	8b 44 24 60	 mov	 eax, DWORD PTR prevval$[rsp]
  00215	89 44 24 40	 mov	 DWORD PTR prevextreme$[rsp], eax
$LN5@audioop_ma@2:

; 729  :             }
; 730  :             prevval = val;

  00219	8b 44 24 54	 mov	 eax, DWORD PTR val$[rsp]
  0021d	89 44 24 60	 mov	 DWORD PTR prevval$[rsp], eax

; 731  :             prevdiff = diff;

  00221	8b 44 24 64	 mov	 eax, DWORD PTR diff$[rsp]
  00225	89 44 24 5c	 mov	 DWORD PTR prevdiff$[rsp], eax
$LN6@audioop_ma@2:

; 732  :         }
; 733  :     }

  00229	e9 bf fe ff ff	 jmp	 $LN13@audioop_ma@2
$LN12@audioop_ma@2:

; 734  :     return PyLong_FromUnsignedLong(max);

  0022e	8b 4c 24 68	 mov	 ecx, DWORD PTR max$[rsp]
  00232	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
$LN23@audioop_ma@2:

; 735  : }

  00237	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0023e	c3		 ret	 0
audioop_maxpp ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EFFCIDMK@s?$CDi?3cross?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_cross DD imagerel audioop_cross
	DD	imagerel audioop_cross+324
	DD	imagerel $unwind$audioop_cross
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_cross DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_09EFFCIDMK@s?$CDi?3cross?$AA@
CONST	SEGMENT
??_C@_09EFFCIDMK@s?$CDi?3cross?$AA@ DB 's#i:cross', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_cross
_TEXT	SEGMENT
cp$ = 48
i$ = 56
ncross$ = 64
size$ = 72
len$ = 80
val$ = 88
prevval$ = 92
self$ = 112
args$ = 120
audioop_cross PROC					; COMDAT

; 739  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 740  :     signed char *cp;
; 741  :     Py_ssize_t len, i;
; 742  :     int size, val = 0;

  0000e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 743  :     int prevval;
; 744  :     Py_ssize_t ncross;
; 745  : 
; 746  :     if ( !PyArg_ParseTuple(args, "s#i:cross", &cp, &len, &size) )

  00016	48 8d 44 24 48	 lea	 rax, QWORD PTR size$[rsp]
  0001b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00020	4c 8d 4c 24 50	 lea	 r9, QWORD PTR len$[rsp]
  00025	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EFFCIDMK@s?$CDi?3cross?$AA@
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00036	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003b	85 c0		 test	 eax, eax
  0003d	75 07		 jne	 SHORT $LN11@audioop_cr

; 747  :         return 0;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 f9 00 00 00	 jmp	 $LN12@audioop_cr
$LN11@audioop_cr:

; 748  :     if (!audioop_check_parameters(len, size))

  00046	8b 54 24 48	 mov	 edx, DWORD PTR size$[rsp]
  0004a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  0004f	e8 00 00 00 00	 call	 audioop_check_parameters
  00054	85 c0		 test	 eax, eax
  00056	75 07		 jne	 SHORT $LN10@audioop_cr

; 749  :         return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 e0 00 00 00	 jmp	 $LN12@audioop_cr
$LN10@audioop_cr:

; 750  :     ncross = -1;

  0005f	48 c7 44 24 40
	ff ff ff ff	 mov	 QWORD PTR ncross$[rsp], -1

; 751  :     prevval = 17; /* Anything <> 0,1 */

  00068	c7 44 24 5c 11
	00 00 00	 mov	 DWORD PTR prevval$[rsp], 17

; 752  :     for ( i=0; i<len; i+= size) {

  00070	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00079	eb 15		 jmp	 SHORT $LN9@audioop_cr
$LN8@audioop_cr:
  0007b	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  00080	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00085	48 03 c8	 add	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN9@audioop_cr:
  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00095	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  0009a	0f 8d 95 00 00
	00		 jge	 $LN7@audioop_cr

; 753  :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) >> 7;

  000a0	83 7c 24 48 01	 cmp	 DWORD PTR size$[rsp], 1
  000a5	75 1c		 jne	 SHORT $LN6@audioop_cr
  000a7	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000ac	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000b1	48 03 c8	 add	 rcx, rax
  000b4	48 8b c1	 mov	 rax, rcx
  000b7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ba	c1 f8 07	 sar	 eax, 7
  000bd	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  000c1	eb 43		 jmp	 SHORT $LN5@audioop_cr
$LN6@audioop_cr:

; 754  :         else if ( size == 2 ) val = ((int)*SHORTP(cp, i)) >> 15;

  000c3	83 7c 24 48 02	 cmp	 DWORD PTR size$[rsp], 2
  000c8	75 1c		 jne	 SHORT $LN4@audioop_cr
  000ca	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000d4	48 03 c8	 add	 rcx, rax
  000d7	48 8b c1	 mov	 rax, rcx
  000da	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000dd	c1 f8 0f	 sar	 eax, 15
  000e0	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  000e4	eb 20		 jmp	 SHORT $LN3@audioop_cr
$LN4@audioop_cr:

; 755  :         else if ( size == 4 ) val = ((int)*LONGP(cp, i)) >> 31;

  000e6	83 7c 24 48 04	 cmp	 DWORD PTR size$[rsp], 4
  000eb	75 19		 jne	 SHORT $LN2@audioop_cr
  000ed	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000f2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000f7	48 03 c8	 add	 rcx, rax
  000fa	48 8b c1	 mov	 rax, rcx
  000fd	8b 00		 mov	 eax, DWORD PTR [rax]
  000ff	c1 f8 1f	 sar	 eax, 31
  00102	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
$LN2@audioop_cr:
$LN3@audioop_cr:
$LN5@audioop_cr:

; 756  :         val = val & 1;

  00106	8b 44 24 58	 mov	 eax, DWORD PTR val$[rsp]
  0010a	83 e0 01	 and	 eax, 1
  0010d	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax

; 757  :         if ( val != prevval ) ncross++;

  00111	8b 44 24 5c	 mov	 eax, DWORD PTR prevval$[rsp]
  00115	39 44 24 58	 cmp	 DWORD PTR val$[rsp], eax
  00119	74 0d		 je	 SHORT $LN1@audioop_cr
  0011b	48 8b 44 24 40	 mov	 rax, QWORD PTR ncross$[rsp]
  00120	48 ff c0	 inc	 rax
  00123	48 89 44 24 40	 mov	 QWORD PTR ncross$[rsp], rax
$LN1@audioop_cr:

; 758  :         prevval = val;

  00128	8b 44 24 58	 mov	 eax, DWORD PTR val$[rsp]
  0012c	89 44 24 5c	 mov	 DWORD PTR prevval$[rsp], eax

; 759  :     }

  00130	e9 46 ff ff ff	 jmp	 $LN8@audioop_cr
$LN7@audioop_cr:

; 760  :     return PyLong_FromSsize_t(ncross);

  00135	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ncross$[rsp]
  0013a	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN12@audioop_cr:

; 761  : }

  0013f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00143	c3		 ret	 0
audioop_cross ENDP
_TEXT	ENDS
PUBLIC	??_C@_08JDMFDEGH@s?$CDid?3mul?$AA@		; `string'
EXTRN	PyBytes_AsString:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_mul DD imagerel audioop_mul
	DD	imagerel audioop_mul+538
	DD	imagerel $unwind$audioop_mul
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_mul DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_08JDMFDEGH@s?$CDid?3mul?$AA@
CONST	SEGMENT
??_C@_08JDMFDEGH@s?$CDid?3mul?$AA@ DB 's#id:mul', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_mul
_TEXT	SEGMENT
fval$ = 48
cp$ = 56
i$ = 64
ncp$ = 72
minval$ = 80
factor$ = 88
size$ = 96
len$ = 104
val$ = 112
rv$ = 120
maxval$ = 128
self$ = 160
args$ = 168
audioop_mul PROC					; COMDAT

; 765  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 766  :     signed char *cp, *ncp;
; 767  :     Py_ssize_t len, i;
; 768  :     int size, val = 0;

  00011	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 769  :     double factor, fval, maxval, minval;
; 770  :     PyObject *rv;
; 771  : 
; 772  :     if ( !PyArg_ParseTuple(args, "s#id:mul", &cp, &len, &size, &factor ) )

  00019	48 8d 44 24 58	 lea	 rax, QWORD PTR factor$[rsp]
  0001e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00023	48 8d 44 24 60	 lea	 rax, QWORD PTR size$[rsp]
  00028	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002d	4c 8d 4c 24 68	 lea	 r9, QWORD PTR len$[rsp]
  00032	4c 8d 44 24 38	 lea	 r8, QWORD PTR cp$[rsp]
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08JDMFDEGH@s?$CDid?3mul?$AA@
  0003e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00046	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0004b	85 c0		 test	 eax, eax
  0004d	75 07		 jne	 SHORT $LN16@audioop_mu

; 773  :         return 0;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 bc 01 00 00	 jmp	 $LN17@audioop_mu
$LN16@audioop_mu:

; 774  :     if (!audioop_check_parameters(len, size))

  00056	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  0005a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$[rsp]
  0005f	e8 00 00 00 00	 call	 audioop_check_parameters
  00064	85 c0		 test	 eax, eax
  00066	75 07		 jne	 SHORT $LN15@audioop_mu

; 775  :         return NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 a3 01 00 00	 jmp	 $LN17@audioop_mu
$LN15@audioop_mu:

; 776  : 
; 777  :     maxval = (double) maxvals[size];

  0006f	48 63 44 24 60	 movsxd	 rax, DWORD PTR size$[rsp]
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:maxvals
  0007b	66 0f 6e 04 81	 movd	 xmm0, DWORD PTR [rcx+rax*4]
  00080	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00084	f2 0f 11 84 24
	80 00 00 00	 movsdx	 QWORD PTR maxval$[rsp], xmm0

; 778  :     minval = (double) minvals[size];

  0008d	48 63 44 24 60	 movsxd	 rax, DWORD PTR size$[rsp]
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:minvals
  00099	66 0f 6e 04 81	 movd	 xmm0, DWORD PTR [rcx+rax*4]
  0009e	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000a2	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR minval$[rsp], xmm0

; 779  : 
; 780  :     rv = PyBytes_FromStringAndSize(NULL, len);

  000a8	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  000ad	33 c9		 xor	 ecx, ecx
  000af	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000b4	48 89 44 24 78	 mov	 QWORD PTR rv$[rsp], rax

; 781  :     if ( rv == 0 )

  000b9	48 83 7c 24 78
	00		 cmp	 QWORD PTR rv$[rsp], 0
  000bf	75 07		 jne	 SHORT $LN14@audioop_mu

; 782  :         return 0;

  000c1	33 c0		 xor	 eax, eax
  000c3	e9 4a 01 00 00	 jmp	 $LN17@audioop_mu
$LN14@audioop_mu:

; 783  :     ncp = (signed char *)PyBytes_AsString(rv);

  000c8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rv$[rsp]
  000cd	e8 00 00 00 00	 call	 PyBytes_AsString
  000d2	48 89 44 24 48	 mov	 QWORD PTR ncp$[rsp], rax

; 784  : 
; 785  : 
; 786  :     for ( i=0; i < len; i += size ) {

  000d7	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000e0	eb 15		 jmp	 SHORT $LN13@audioop_mu
$LN12@audioop_mu:
  000e2	48 63 44 24 60	 movsxd	 rax, DWORD PTR size$[rsp]
  000e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  000ec	48 03 c8	 add	 rcx, rax
  000ef	48 8b c1	 mov	 rax, rcx
  000f2	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN13@audioop_mu:
  000f7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  000fc	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  00101	0f 8d 06 01 00
	00		 jge	 $LN11@audioop_mu

; 787  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  00107	83 7c 24 60 01	 cmp	 DWORD PTR size$[rsp], 1
  0010c	75 19		 jne	 SHORT $LN10@audioop_mu
  0010e	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00113	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  00118	48 03 c8	 add	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00121	89 44 24 70	 mov	 DWORD PTR val$[rsp], eax
  00125	eb 3d		 jmp	 SHORT $LN9@audioop_mu
$LN10@audioop_mu:

; 788  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  00127	83 7c 24 60 02	 cmp	 DWORD PTR size$[rsp], 2
  0012c	75 19		 jne	 SHORT $LN8@audioop_mu
  0012e	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00133	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  00138	48 03 c8	 add	 rcx, rax
  0013b	48 8b c1	 mov	 rax, rcx
  0013e	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00141	89 44 24 70	 mov	 DWORD PTR val$[rsp], eax
  00145	eb 1d		 jmp	 SHORT $LN7@audioop_mu
$LN8@audioop_mu:

; 789  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  00147	83 7c 24 60 04	 cmp	 DWORD PTR size$[rsp], 4
  0014c	75 16		 jne	 SHORT $LN6@audioop_mu
  0014e	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00153	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  00158	48 03 c8	 add	 rcx, rax
  0015b	48 8b c1	 mov	 rax, rcx
  0015e	8b 00		 mov	 eax, DWORD PTR [rax]
  00160	89 44 24 70	 mov	 DWORD PTR val$[rsp], eax
$LN6@audioop_mu:
$LN7@audioop_mu:
$LN9@audioop_mu:

; 790  :         fval = (double)val*factor;

  00164	66 0f 6e 44 24
	70		 movd	 xmm0, DWORD PTR val$[rsp]
  0016a	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0016e	f2 0f 59 44 24
	58		 mulsd	 xmm0, QWORD PTR factor$[rsp]
  00174	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR fval$[rsp], xmm0

; 791  :         val = (int)floor(fbound(fval, minval, maxval));

  0017a	f2 0f 10 94 24
	80 00 00 00	 movsdx	 xmm2, QWORD PTR maxval$[rsp]
  00183	f2 0f 10 4c 24
	50		 movsdx	 xmm1, QWORD PTR minval$[rsp]
  00189	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR fval$[rsp]
  0018f	e8 00 00 00 00	 call	 fbound
  00194	66 0f 6e c0	 movd	 xmm0, eax
  00198	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  001a2	f2 0f 2c c0	 cvttsd2si eax, xmm0
  001a6	89 44 24 70	 mov	 DWORD PTR val$[rsp], eax

; 792  :         if ( size == 1 )      *CHARP(ncp, i) = (signed char)val;

  001aa	83 7c 24 60 01	 cmp	 DWORD PTR size$[rsp], 1
  001af	75 19		 jne	 SHORT $LN5@audioop_mu
  001b1	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001b6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  001bb	48 03 c8	 add	 rcx, rax
  001be	48 8b c1	 mov	 rax, rcx
  001c1	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR val$[rsp]
  001c6	88 08		 mov	 BYTE PTR [rax], cl
  001c8	eb 3e		 jmp	 SHORT $LN4@audioop_mu
$LN5@audioop_mu:

; 793  :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)val;

  001ca	83 7c 24 60 02	 cmp	 DWORD PTR size$[rsp], 2
  001cf	75 1a		 jne	 SHORT $LN3@audioop_mu
  001d1	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001d6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  001db	48 03 c8	 add	 rcx, rax
  001de	48 8b c1	 mov	 rax, rcx
  001e1	0f b7 4c 24 70	 movzx	 ecx, WORD PTR val$[rsp]
  001e6	66 89 08	 mov	 WORD PTR [rax], cx
  001e9	eb 1d		 jmp	 SHORT $LN2@audioop_mu
$LN3@audioop_mu:

; 794  :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)val;

  001eb	83 7c 24 60 04	 cmp	 DWORD PTR size$[rsp], 4
  001f0	75 16		 jne	 SHORT $LN1@audioop_mu
  001f2	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001f7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  001fc	48 03 c8	 add	 rcx, rax
  001ff	48 8b c1	 mov	 rax, rcx
  00202	8b 4c 24 70	 mov	 ecx, DWORD PTR val$[rsp]
  00206	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@audioop_mu:
$LN2@audioop_mu:
$LN4@audioop_mu:

; 795  :     }

  00208	e9 d5 fe ff ff	 jmp	 $LN12@audioop_mu
$LN11@audioop_mu:

; 796  :     return rv;

  0020d	48 8b 44 24 78	 mov	 rax, QWORD PTR rv$[rsp]
$LN17@audioop_mu:

; 797  : }

  00212	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00219	c3		 ret	 0
audioop_mul ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fbound
_TEXT	SEGMENT
val$ = 8
minval$ = 16
maxval$ = 24
fbound	PROC						; COMDAT

; 36   : {

  00000	f2 0f 11 54 24
	18		 movsdx	 QWORD PTR [rsp+24], xmm2
  00006	f2 0f 11 4c 24
	10		 movsdx	 QWORD PTR [rsp+16], xmm1
  0000c	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0

; 37   :     if (val > maxval)

  00012	f2 0f 10 44 24
	08		 movsdx	 xmm0, QWORD PTR val$[rsp]
  00018	66 0f 2f 44 24
	18		 comisd	 xmm0, QWORD PTR maxval$[rsp]
  0001e	76 0e		 jbe	 SHORT $LN3@fbound

; 38   :         val = maxval;

  00020	f2 0f 10 44 24
	18		 movsdx	 xmm0, QWORD PTR maxval$[rsp]
  00026	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR val$[rsp], xmm0
  0002c	eb 22		 jmp	 SHORT $LN2@fbound
$LN3@fbound:

; 39   :     else if (val < minval + 1)

  0002e	f2 0f 10 44 24
	10		 movsdx	 xmm0, QWORD PTR minval$[rsp]
  00034	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0003c	66 0f 2f 44 24
	08		 comisd	 xmm0, QWORD PTR val$[rsp]
  00042	76 0c		 jbe	 SHORT $LN1@fbound

; 40   :         val = minval;

  00044	f2 0f 10 44 24
	10		 movsdx	 xmm0, QWORD PTR minval$[rsp]
  0004a	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR val$[rsp], xmm0
$LN1@fbound:
$LN2@fbound:

; 41   :     return val;

  00050	f2 0f 2c 44 24
	08		 cvttsd2si eax, QWORD PTR val$[rsp]

; 42   : }

  00056	c3		 ret	 0
fbound	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@KAOKIFFI@s?$CKidd?3tomono?$AA@		; `string'
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_tomono DD imagerel audioop_tomono
	DD	imagerel audioop_tomono+943
	DD	imagerel $unwind$audioop_tomono
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_tomono DD 021101H
	DD	01f0111H
xdata	ENDS
;	COMDAT ??_C@_0N@KAOKIFFI@s?$CKidd?3tomono?$AA@
CONST	SEGMENT
??_C@_0N@KAOKIFFI@s?$CKidd?3tomono?$AA@ DB 's*idd:tomono', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_tomono
_TEXT	SEGMENT
fval$ = 48
cp$ = 56
i$ = 64
ncp$ = 72
pcp$ = 80
minval$ = 160
fac2$ = 168
size$ = 176
len$ = 184
val2$ = 192
fac1$ = 200
rv$ = 208
maxval$ = 216
val1$ = 224
tv77 = 232
self$ = 256
args$ = 264
audioop_tomono PROC					; COMDAT

; 801  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 802  :     Py_buffer pcp;
; 803  :     signed char *cp, *ncp;
; 804  :     Py_ssize_t len, i;
; 805  :     int size, val1 = 0, val2 = 0;

  00011	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR val1$[rsp], 0
  0001c	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR val2$[rsp], 0

; 806  :     double fac1, fac2, fval, maxval, minval;
; 807  :     PyObject *rv;
; 808  : 
; 809  :     if ( !PyArg_ParseTuple(args, "s*idd:tomono",
; 810  :                            &pcp, &size, &fac1, &fac2 ) )

  00027	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR fac2$[rsp]
  0002f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00034	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR fac1$[rsp]
  0003c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00041	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR size$[rsp]
  00049	4c 8d 44 24 50	 lea	 r8, QWORD PTR pcp$[rsp]
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KAOKIFFI@s?$CKidd?3tomono?$AA@
  00055	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0005d	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00062	85 c0		 test	 eax, eax
  00064	75 07		 jne	 SHORT $LN22@audioop_to

; 811  :         return 0;

  00066	33 c0		 xor	 eax, eax
  00068	e9 3a 03 00 00	 jmp	 $LN23@audioop_to
$LN22@audioop_to:

; 812  :     cp = pcp.buf;

  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR pcp$[rsp]
  00072	48 89 44 24 38	 mov	 QWORD PTR cp$[rsp], rax

; 813  :     len = pcp.len;

  00077	48 8b 44 24 60	 mov	 rax, QWORD PTR pcp$[rsp+16]
  0007c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 814  :     if (!audioop_check_parameters(len, size)) {

  00084	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR size$[rsp]
  0008b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00093	e8 00 00 00 00	 call	 audioop_check_parameters
  00098	85 c0		 test	 eax, eax
  0009a	75 11		 jne	 SHORT $LN21@audioop_to

; 815  :         PyBuffer_Release(&pcp);

  0009c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pcp$[rsp]
  000a1	e8 00 00 00 00	 call	 PyBuffer_Release

; 816  :         return NULL;

  000a6	33 c0		 xor	 eax, eax
  000a8	e9 fa 02 00 00	 jmp	 $LN23@audioop_to
$LN21@audioop_to:

; 817  :     }
; 818  :     if (((len / size) & 1) != 0) {

  000ad	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR size$[rsp]
  000b5	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
  000bd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  000c5	48 99		 cdq
  000c7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv77[rsp]
  000cf	48 f7 f9	 idiv	 rcx
  000d2	48 83 e0 01	 and	 rax, 1
  000d6	48 85 c0	 test	 rax, rax
  000d9	74 24		 je	 SHORT $LN20@audioop_to

; 819  :         PyErr_SetString(AudioopError, "not a whole number of frames");

  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@
  000e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  000e9	e8 00 00 00 00	 call	 PyErr_SetString

; 820  :         PyBuffer_Release(&pcp);

  000ee	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pcp$[rsp]
  000f3	e8 00 00 00 00	 call	 PyBuffer_Release

; 821  :         return NULL;

  000f8	33 c0		 xor	 eax, eax
  000fa	e9 a8 02 00 00	 jmp	 $LN23@audioop_to
$LN20@audioop_to:

; 822  :     }
; 823  : 
; 824  :     maxval = (double) maxvals[size];

  000ff	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR size$[rsp]
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:maxvals
  0010e	66 0f 6e 04 81	 movd	 xmm0, DWORD PTR [rcx+rax*4]
  00113	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00117	f2 0f 11 84 24
	d8 00 00 00	 movsdx	 QWORD PTR maxval$[rsp], xmm0

; 825  :     minval = (double) minvals[size];

  00120	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR size$[rsp]
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:minvals
  0012f	66 0f 6e 04 81	 movd	 xmm0, DWORD PTR [rcx+rax*4]
  00134	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00138	f2 0f 11 84 24
	a0 00 00 00	 movsdx	 QWORD PTR minval$[rsp], xmm0

; 826  : 
; 827  :     rv = PyBytes_FromStringAndSize(NULL, len/2);

  00141	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  00149	48 99		 cdq
  0014b	48 2b c2	 sub	 rax, rdx
  0014e	48 d1 f8	 sar	 rax, 1
  00151	48 8b d0	 mov	 rdx, rax
  00154	33 c9		 xor	 ecx, ecx
  00156	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0015b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax

; 828  :     if ( rv == 0 ) {

  00163	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR rv$[rsp], 0
  0016c	75 11		 jne	 SHORT $LN19@audioop_to

; 829  :         PyBuffer_Release(&pcp);

  0016e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pcp$[rsp]
  00173	e8 00 00 00 00	 call	 PyBuffer_Release

; 830  :         return 0;

  00178	33 c0		 xor	 eax, eax
  0017a	e9 28 02 00 00	 jmp	 $LN23@audioop_to
$LN19@audioop_to:

; 831  :     }
; 832  :     ncp = (signed char *)PyBytes_AsString(rv);

  0017f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00187	e8 00 00 00 00	 call	 PyBytes_AsString
  0018c	48 89 44 24 48	 mov	 QWORD PTR ncp$[rsp], rax

; 833  : 
; 834  : 
; 835  :     for ( i=0; i < len; i += size*2 ) {

  00191	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0019a	eb 1b		 jmp	 SHORT $LN18@audioop_to
$LN17@audioop_to:
  0019c	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  001a3	d1 e0		 shl	 eax, 1
  001a5	48 98		 cdqe
  001a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  001ac	48 03 c8	 add	 rcx, rax
  001af	48 8b c1	 mov	 rax, rcx
  001b2	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN18@audioop_to:
  001b7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  001bf	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  001c4	0f 8d cb 01 00
	00		 jge	 $LN16@audioop_to

; 836  :         if ( size == 1 )      val1 = (int)*CHARP(cp, i);

  001ca	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR size$[rsp], 1
  001d2	75 1c		 jne	 SHORT $LN15@audioop_to
  001d4	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001d9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  001de	48 03 c8	 add	 rcx, rax
  001e1	48 8b c1	 mov	 rax, rcx
  001e4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001e7	89 84 24 e0 00
	00 00		 mov	 DWORD PTR val1$[rsp], eax
  001ee	eb 49		 jmp	 SHORT $LN14@audioop_to
$LN15@audioop_to:

; 837  :         else if ( size == 2 ) val1 = (int)*SHORTP(cp, i);

  001f0	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR size$[rsp], 2
  001f8	75 1c		 jne	 SHORT $LN13@audioop_to
  001fa	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001ff	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  00204	48 03 c8	 add	 rcx, rax
  00207	48 8b c1	 mov	 rax, rcx
  0020a	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0020d	89 84 24 e0 00
	00 00		 mov	 DWORD PTR val1$[rsp], eax
  00214	eb 23		 jmp	 SHORT $LN12@audioop_to
$LN13@audioop_to:

; 838  :         else if ( size == 4 ) val1 = (int)*LONGP(cp, i);

  00216	83 bc 24 b0 00
	00 00 04	 cmp	 DWORD PTR size$[rsp], 4
  0021e	75 19		 jne	 SHORT $LN11@audioop_to
  00220	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00225	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  0022a	48 03 c8	 add	 rcx, rax
  0022d	48 8b c1	 mov	 rax, rcx
  00230	8b 00		 mov	 eax, DWORD PTR [rax]
  00232	89 84 24 e0 00
	00 00		 mov	 DWORD PTR val1$[rsp], eax
$LN11@audioop_to:
$LN12@audioop_to:
$LN14@audioop_to:

; 839  :         if ( size == 1 )      val2 = (int)*CHARP(cp, i+1);

  00239	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR size$[rsp], 1
  00241	75 1d		 jne	 SHORT $LN10@audioop_to
  00243	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00248	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  0024d	48 03 c8	 add	 rcx, rax
  00250	48 8b c1	 mov	 rax, rcx
  00253	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00257	89 84 24 c0 00
	00 00		 mov	 DWORD PTR val2$[rsp], eax
  0025e	eb 4b		 jmp	 SHORT $LN9@audioop_to
$LN10@audioop_to:

; 840  :         else if ( size == 2 ) val2 = (int)*SHORTP(cp, i+2);

  00260	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR size$[rsp], 2
  00268	75 1d		 jne	 SHORT $LN8@audioop_to
  0026a	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0026f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  00274	48 03 c8	 add	 rcx, rax
  00277	48 8b c1	 mov	 rax, rcx
  0027a	0f bf 40 02	 movsx	 eax, WORD PTR [rax+2]
  0027e	89 84 24 c0 00
	00 00		 mov	 DWORD PTR val2$[rsp], eax
  00285	eb 24		 jmp	 SHORT $LN7@audioop_to
$LN8@audioop_to:

; 841  :         else if ( size == 4 ) val2 = (int)*LONGP(cp, i+4);

  00287	83 bc 24 b0 00
	00 00 04	 cmp	 DWORD PTR size$[rsp], 4
  0028f	75 1a		 jne	 SHORT $LN6@audioop_to
  00291	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00296	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  0029b	48 03 c8	 add	 rcx, rax
  0029e	48 8b c1	 mov	 rax, rcx
  002a1	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  002a4	89 84 24 c0 00
	00 00		 mov	 DWORD PTR val2$[rsp], eax
$LN6@audioop_to:
$LN7@audioop_to:
$LN9@audioop_to:

; 842  :         fval = (double)val1*fac1 + (double)val2*fac2;

  002ab	66 0f 6e 84 24
	e0 00 00 00	 movd	 xmm0, DWORD PTR val1$[rsp]
  002b4	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  002b8	f2 0f 59 84 24
	c8 00 00 00	 mulsd	 xmm0, QWORD PTR fac1$[rsp]
  002c1	66 0f 6e 8c 24
	c0 00 00 00	 movd	 xmm1, DWORD PTR val2$[rsp]
  002ca	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  002ce	f2 0f 59 8c 24
	a8 00 00 00	 mulsd	 xmm1, QWORD PTR fac2$[rsp]
  002d7	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002db	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR fval$[rsp], xmm0

; 843  :         val1 = (int)floor(fbound(fval, minval, maxval));

  002e1	f2 0f 10 94 24
	d8 00 00 00	 movsdx	 xmm2, QWORD PTR maxval$[rsp]
  002ea	f2 0f 10 8c 24
	a0 00 00 00	 movsdx	 xmm1, QWORD PTR minval$[rsp]
  002f3	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR fval$[rsp]
  002f9	e8 00 00 00 00	 call	 fbound
  002fe	66 0f 6e c0	 movd	 xmm0, eax
  00302	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00306	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  0030c	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00310	89 84 24 e0 00
	00 00		 mov	 DWORD PTR val1$[rsp], eax

; 844  :         if ( size == 1 )      *CHARP(ncp, i/2) = (signed char)val1;

  00317	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR size$[rsp], 1
  0031f	75 1f		 jne	 SHORT $LN5@audioop_to
  00321	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00326	48 99		 cdq
  00328	48 2b c2	 sub	 rax, rdx
  0032b	48 d1 f8	 sar	 rax, 1
  0032e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  00333	0f b6 94 24 e0
	00 00 00	 movzx	 edx, BYTE PTR val1$[rsp]
  0033b	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0033e	eb 50		 jmp	 SHORT $LN4@audioop_to
$LN5@audioop_to:

; 845  :         else if ( size == 2 ) *SHORTP(ncp, i/2) = (short)val1;

  00340	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR size$[rsp], 2
  00348	75 20		 jne	 SHORT $LN3@audioop_to
  0034a	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  0034f	48 99		 cdq
  00351	48 2b c2	 sub	 rax, rdx
  00354	48 d1 f8	 sar	 rax, 1
  00357	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  0035c	0f b7 94 24 e0
	00 00 00	 movzx	 edx, WORD PTR val1$[rsp]
  00364	66 89 14 01	 mov	 WORD PTR [rcx+rax], dx
  00368	eb 26		 jmp	 SHORT $LN2@audioop_to
$LN3@audioop_to:

; 846  :         else if ( size == 4 ) *LONGP(ncp, i/2)= (Py_Int32)val1;

  0036a	83 bc 24 b0 00
	00 00 04	 cmp	 DWORD PTR size$[rsp], 4
  00372	75 1c		 jne	 SHORT $LN1@audioop_to
  00374	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00379	48 99		 cdq
  0037b	48 2b c2	 sub	 rax, rdx
  0037e	48 d1 f8	 sar	 rax, 1
  00381	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  00386	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR val1$[rsp]
  0038d	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
$LN1@audioop_to:
$LN2@audioop_to:
$LN4@audioop_to:

; 847  :     }

  00390	e9 07 fe ff ff	 jmp	 $LN17@audioop_to
$LN16@audioop_to:

; 848  :     PyBuffer_Release(&pcp);

  00395	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pcp$[rsp]
  0039a	e8 00 00 00 00	 call	 PyBuffer_Release

; 849  :     return rv;

  0039f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN23@audioop_to:

; 850  : }

  003a7	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  003ae	c3		 ret	 0
audioop_tomono ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@ ; `string'
PUBLIC	??_C@_0P@GGMMCKGC@s?$CDidd?3tostereo?$AA@	; `string'
EXTRN	PyExc_MemoryError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_tostereo DD imagerel audioop_tostereo
	DD	imagerel audioop_tostereo+794
	DD	imagerel $unwind$audioop_tostereo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_tostereo DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
CONST	SEGMENT
??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@ DB 'not enough '
	DB	'memory for output buffer', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GGMMCKGC@s?$CDidd?3tostereo?$AA@
CONST	SEGMENT
??_C@_0P@GGMMCKGC@s?$CDidd?3tostereo?$AA@ DB 's#idd:tostereo', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_tostereo
_TEXT	SEGMENT
fval$ = 64
cp$ = 72
i$ = 80
ncp$ = 88
minval$ = 96
fac2$ = 104
size$ = 112
len$ = 120
val2$ = 128
fac1$ = 136
val$ = 144
rv$ = 152
maxval$ = 160
val1$ = 168
self$ = 192
args$ = 200
audioop_tostereo PROC					; COMDAT

; 854  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 855  :     signed char *cp, *ncp;
; 856  :     Py_ssize_t len, i;
; 857  :     int size, val1, val2, val = 0;

  00011	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR val$[rsp], 0

; 858  :     double fac1, fac2, fval, maxval, minval;
; 859  :     PyObject *rv;
; 860  : 
; 861  :     if ( !PyArg_ParseTuple(args, "s#idd:tostereo",
; 862  :                            &cp, &len, &size, &fac1, &fac2 ) )

  0001c	48 8d 44 24 68	 lea	 rax, QWORD PTR fac2$[rsp]
  00021	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00026	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR fac1$[rsp]
  0002e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00033	48 8d 44 24 70	 lea	 rax, QWORD PTR size$[rsp]
  00038	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003d	4c 8d 4c 24 78	 lea	 r9, QWORD PTR len$[rsp]
  00042	4c 8d 44 24 48	 lea	 r8, QWORD PTR cp$[rsp]
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@GGMMCKGC@s?$CDidd?3tostereo?$AA@
  0004e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00056	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0005b	85 c0		 test	 eax, eax
  0005d	75 07		 jne	 SHORT $LN22@audioop_to@2

; 863  :         return 0;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 ac 02 00 00	 jmp	 $LN23@audioop_to@2
$LN22@audioop_to@2:

; 864  :     if (!audioop_check_parameters(len, size))

  00066	8b 54 24 70	 mov	 edx, DWORD PTR size$[rsp]
  0006a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR len$[rsp]
  0006f	e8 00 00 00 00	 call	 audioop_check_parameters
  00074	85 c0		 test	 eax, eax
  00076	75 07		 jne	 SHORT $LN21@audioop_to@2

; 865  :         return NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	e9 93 02 00 00	 jmp	 $LN23@audioop_to@2
$LN21@audioop_to@2:

; 866  : 
; 867  :     maxval = (double) maxvals[size];

  0007f	48 63 44 24 70	 movsxd	 rax, DWORD PTR size$[rsp]
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:maxvals
  0008b	66 0f 6e 04 81	 movd	 xmm0, DWORD PTR [rcx+rax*4]
  00090	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00094	f2 0f 11 84 24
	a0 00 00 00	 movsdx	 QWORD PTR maxval$[rsp], xmm0

; 868  :     minval = (double) minvals[size];

  0009d	48 63 44 24 70	 movsxd	 rax, DWORD PTR size$[rsp]
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:minvals
  000a9	66 0f 6e 04 81	 movd	 xmm0, DWORD PTR [rcx+rax*4]
  000ae	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000b2	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR minval$[rsp], xmm0

; 869  : 
; 870  :     if (len > PY_SSIZE_T_MAX/2) {

  000b8	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  000c2	48 39 44 24 78	 cmp	 QWORD PTR len$[rsp], rax
  000c7	7e 1a		 jle	 SHORT $LN20@audioop_to@2

; 871  :         PyErr_SetString(PyExc_MemoryError,
; 872  :                         "not enough memory for output buffer");

  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  000d7	e8 00 00 00 00	 call	 PyErr_SetString

; 873  :         return 0;

  000dc	33 c0		 xor	 eax, eax
  000de	e9 2f 02 00 00	 jmp	 $LN23@audioop_to@2
$LN20@audioop_to@2:

; 874  :     }
; 875  : 
; 876  :     rv = PyBytes_FromStringAndSize(NULL, len*2);

  000e3	48 8b 44 24 78	 mov	 rax, QWORD PTR len$[rsp]
  000e8	48 d1 e0	 shl	 rax, 1
  000eb	48 8b d0	 mov	 rdx, rax
  000ee	33 c9		 xor	 ecx, ecx
  000f0	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000f5	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax

; 877  :     if ( rv == 0 )

  000fd	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR rv$[rsp], 0
  00106	75 07		 jne	 SHORT $LN19@audioop_to@2

; 878  :         return 0;

  00108	33 c0		 xor	 eax, eax
  0010a	e9 03 02 00 00	 jmp	 $LN23@audioop_to@2
$LN19@audioop_to@2:

; 879  :     ncp = (signed char *)PyBytes_AsString(rv);

  0010f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00117	e8 00 00 00 00	 call	 PyBytes_AsString
  0011c	48 89 44 24 58	 mov	 QWORD PTR ncp$[rsp], rax

; 880  : 
; 881  : 
; 882  :     for ( i=0; i < len; i += size ) {

  00121	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0012a	eb 15		 jmp	 SHORT $LN18@audioop_to@2
$LN17@audioop_to@2:
  0012c	48 63 44 24 70	 movsxd	 rax, DWORD PTR size$[rsp]
  00131	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$[rsp]
  00136	48 03 c8	 add	 rcx, rax
  00139	48 8b c1	 mov	 rax, rcx
  0013c	48 89 44 24 50	 mov	 QWORD PTR i$[rsp], rax
$LN18@audioop_to@2:
  00141	48 8b 44 24 78	 mov	 rax, QWORD PTR len$[rsp]
  00146	48 39 44 24 50	 cmp	 QWORD PTR i$[rsp], rax
  0014b	0f 8d b9 01 00
	00		 jge	 $LN16@audioop_to@2

; 883  :         if ( size == 1 )      val = (int)*CHARP(cp, i);

  00151	83 7c 24 70 01	 cmp	 DWORD PTR size$[rsp], 1
  00156	75 1c		 jne	 SHORT $LN15@audioop_to@2
  00158	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  0015d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cp$[rsp]
  00162	48 03 c8	 add	 rcx, rax
  00165	48 8b c1	 mov	 rax, rcx
  00168	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0016b	89 84 24 90 00
	00 00		 mov	 DWORD PTR val$[rsp], eax
  00172	eb 43		 jmp	 SHORT $LN14@audioop_to@2
$LN15@audioop_to@2:

; 884  :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  00174	83 7c 24 70 02	 cmp	 DWORD PTR size$[rsp], 2
  00179	75 1c		 jne	 SHORT $LN13@audioop_to@2
  0017b	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  00180	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cp$[rsp]
  00185	48 03 c8	 add	 rcx, rax
  00188	48 8b c1	 mov	 rax, rcx
  0018b	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0018e	89 84 24 90 00
	00 00		 mov	 DWORD PTR val$[rsp], eax
  00195	eb 20		 jmp	 SHORT $LN12@audioop_to@2
$LN13@audioop_to@2:

; 885  :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  00197	83 7c 24 70 04	 cmp	 DWORD PTR size$[rsp], 4
  0019c	75 19		 jne	 SHORT $LN11@audioop_to@2
  0019e	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  001a3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cp$[rsp]
  001a8	48 03 c8	 add	 rcx, rax
  001ab	48 8b c1	 mov	 rax, rcx
  001ae	8b 00		 mov	 eax, DWORD PTR [rax]
  001b0	89 84 24 90 00
	00 00		 mov	 DWORD PTR val$[rsp], eax
$LN11@audioop_to@2:
$LN12@audioop_to@2:
$LN14@audioop_to@2:

; 886  : 
; 887  :         fval = (double)val*fac1;

  001b7	66 0f 6e 84 24
	90 00 00 00	 movd	 xmm0, DWORD PTR val$[rsp]
  001c0	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001c4	f2 0f 59 84 24
	88 00 00 00	 mulsd	 xmm0, QWORD PTR fac1$[rsp]
  001cd	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR fval$[rsp], xmm0

; 888  :         val1 = (int)floor(fbound(fval, minval, maxval));

  001d3	f2 0f 10 94 24
	a0 00 00 00	 movsdx	 xmm2, QWORD PTR maxval$[rsp]
  001dc	f2 0f 10 4c 24
	60		 movsdx	 xmm1, QWORD PTR minval$[rsp]
  001e2	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR fval$[rsp]
  001e8	e8 00 00 00 00	 call	 fbound
  001ed	66 0f 6e c0	 movd	 xmm0, eax
  001f1	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  001fb	f2 0f 2c c0	 cvttsd2si eax, xmm0
  001ff	89 84 24 a8 00
	00 00		 mov	 DWORD PTR val1$[rsp], eax

; 889  : 
; 890  :         fval = (double)val*fac2;

  00206	66 0f 6e 84 24
	90 00 00 00	 movd	 xmm0, DWORD PTR val$[rsp]
  0020f	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00213	f2 0f 59 44 24
	68		 mulsd	 xmm0, QWORD PTR fac2$[rsp]
  00219	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR fval$[rsp], xmm0

; 891  :         val2 = (int)floor(fbound(fval, minval, maxval));

  0021f	f2 0f 10 94 24
	a0 00 00 00	 movsdx	 xmm2, QWORD PTR maxval$[rsp]
  00228	f2 0f 10 4c 24
	60		 movsdx	 xmm1, QWORD PTR minval$[rsp]
  0022e	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR fval$[rsp]
  00234	e8 00 00 00 00	 call	 fbound
  00239	66 0f 6e c0	 movd	 xmm0, eax
  0023d	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  00247	f2 0f 2c c0	 cvttsd2si eax, xmm0
  0024b	89 84 24 80 00
	00 00		 mov	 DWORD PTR val2$[rsp], eax

; 892  : 
; 893  :         if ( size == 1 )      *CHARP(ncp, i*2) = (signed char)val1;

  00252	83 7c 24 70 01	 cmp	 DWORD PTR size$[rsp], 1
  00257	75 17		 jne	 SHORT $LN10@audioop_to@2
  00259	48 8b 44 24 58	 mov	 rax, QWORD PTR ncp$[rsp]
  0025e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$[rsp]
  00263	0f b6 94 24 a8
	00 00 00	 movzx	 edx, BYTE PTR val1$[rsp]
  0026b	88 14 48	 mov	 BYTE PTR [rax+rcx*2], dl
  0026e	eb 3a		 jmp	 SHORT $LN9@audioop_to@2
$LN10@audioop_to@2:

; 894  :         else if ( size == 2 ) *SHORTP(ncp, i*2) = (short)val1;

  00270	83 7c 24 70 02	 cmp	 DWORD PTR size$[rsp], 2
  00275	75 18		 jne	 SHORT $LN8@audioop_to@2
  00277	48 8b 44 24 58	 mov	 rax, QWORD PTR ncp$[rsp]
  0027c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$[rsp]
  00281	0f b7 94 24 a8
	00 00 00	 movzx	 edx, WORD PTR val1$[rsp]
  00289	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
  0028d	eb 1b		 jmp	 SHORT $LN7@audioop_to@2
$LN8@audioop_to@2:

; 895  :         else if ( size == 4 ) *LONGP(ncp, i*2) = (Py_Int32)val1;

  0028f	83 7c 24 70 04	 cmp	 DWORD PTR size$[rsp], 4
  00294	75 14		 jne	 SHORT $LN6@audioop_to@2
  00296	48 8b 44 24 58	 mov	 rax, QWORD PTR ncp$[rsp]
  0029b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$[rsp]
  002a0	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR val1$[rsp]
  002a7	89 14 48	 mov	 DWORD PTR [rax+rcx*2], edx
$LN6@audioop_to@2:
$LN7@audioop_to@2:
$LN9@audioop_to@2:

; 896  : 
; 897  :         if ( size == 1 )      *CHARP(ncp, i*2+1) = (signed char)val2;

  002aa	83 7c 24 70 01	 cmp	 DWORD PTR size$[rsp], 1
  002af	75 18		 jne	 SHORT $LN5@audioop_to@2
  002b1	48 8b 44 24 58	 mov	 rax, QWORD PTR ncp$[rsp]
  002b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$[rsp]
  002bb	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR val2$[rsp]
  002c3	88 54 48 01	 mov	 BYTE PTR [rax+rcx*2+1], dl
  002c7	eb 3c		 jmp	 SHORT $LN4@audioop_to@2
$LN5@audioop_to@2:

; 898  :         else if ( size == 2 ) *SHORTP(ncp, i*2+2) = (short)val2;

  002c9	83 7c 24 70 02	 cmp	 DWORD PTR size$[rsp], 2
  002ce	75 19		 jne	 SHORT $LN3@audioop_to@2
  002d0	48 8b 44 24 58	 mov	 rax, QWORD PTR ncp$[rsp]
  002d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$[rsp]
  002da	0f b7 94 24 80
	00 00 00	 movzx	 edx, WORD PTR val2$[rsp]
  002e2	66 89 54 48 02	 mov	 WORD PTR [rax+rcx*2+2], dx
  002e7	eb 1c		 jmp	 SHORT $LN2@audioop_to@2
$LN3@audioop_to@2:

; 899  :         else if ( size == 4 ) *LONGP(ncp, i*2+4) = (Py_Int32)val2;

  002e9	83 7c 24 70 04	 cmp	 DWORD PTR size$[rsp], 4
  002ee	75 15		 jne	 SHORT $LN1@audioop_to@2
  002f0	48 8b 44 24 58	 mov	 rax, QWORD PTR ncp$[rsp]
  002f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR i$[rsp]
  002fa	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR val2$[rsp]
  00301	89 54 48 04	 mov	 DWORD PTR [rax+rcx*2+4], edx
$LN1@audioop_to@2:
$LN2@audioop_to@2:
$LN4@audioop_to@2:

; 900  :     }

  00305	e9 22 fe ff ff	 jmp	 $LN17@audioop_to@2
$LN16@audioop_to@2:

; 901  :     return rv;

  0030a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN23@audioop_to@2:

; 902  : }

  00312	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00319	c3		 ret	 0
audioop_tostereo ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@NGDJONDO@Lengths?5should?5be?5the?5same?$AA@ ; `string'
PUBLIC	??_C@_09GPECABIK@s?$CDs?$CDi?3add?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_add DD imagerel audioop_add
	DD	imagerel audioop_add+823
	DD	imagerel $unwind$audioop_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_add DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_0BL@NGDJONDO@Lengths?5should?5be?5the?5same?$AA@
CONST	SEGMENT
??_C@_0BL@NGDJONDO@Lengths?5should?5be?5the?5same?$AA@ DB 'Lengths should'
	DB	' be the same', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09GPECABIK@s?$CDs?$CDi?3add?$AA@
CONST	SEGMENT
??_C@_09GPECABIK@s?$CDs?$CDi?3add?$AA@ DB 's#s#i:add', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_add
_TEXT	SEGMENT
i$ = 64
ncp$ = 72
minval$ = 80
len1$ = 88
cp1$ = 96
size$ = 104
val2$ = 108
len2$ = 112
rv$ = 120
maxval$ = 128
cp2$ = 136
newval$ = 144
val1$ = 148
fval$21055 = 152
self$ = 176
args$ = 184
audioop_add PROC					; COMDAT

; 906  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 907  :     signed char *cp1, *cp2, *ncp;
; 908  :     Py_ssize_t len1, len2, i;
; 909  :     int size, val1 = 0, val2 = 0, minval, maxval, newval;

  00011	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR val1$[rsp], 0
  0001c	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR val2$[rsp], 0

; 910  :     PyObject *rv;
; 911  : 
; 912  :     if ( !PyArg_ParseTuple(args, "s#s#i:add",
; 913  :                       &cp1, &len1, &cp2, &len2, &size ) )

  00024	48 8d 44 24 68	 lea	 rax, QWORD PTR size$[rsp]
  00029	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0002e	48 8d 44 24 70	 lea	 rax, QWORD PTR len2$[rsp]
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR cp2$[rsp]
  00040	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00045	4c 8d 4c 24 58	 lea	 r9, QWORD PTR len1$[rsp]
  0004a	4c 8d 44 24 60	 lea	 r8, QWORD PTR cp1$[rsp]
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09GPECABIK@s?$CDs?$CDi?3add?$AA@
  00056	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0005e	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00063	85 c0		 test	 eax, eax
  00065	75 07		 jne	 SHORT $LN27@audioop_ad

; 914  :         return 0;

  00067	33 c0		 xor	 eax, eax
  00069	e9 c1 02 00 00	 jmp	 $LN28@audioop_ad
$LN27@audioop_ad:

; 915  :     if (!audioop_check_parameters(len1, size))

  0006e	8b 54 24 68	 mov	 edx, DWORD PTR size$[rsp]
  00072	48 8b 4c 24 58	 mov	 rcx, QWORD PTR len1$[rsp]
  00077	e8 00 00 00 00	 call	 audioop_check_parameters
  0007c	85 c0		 test	 eax, eax
  0007e	75 07		 jne	 SHORT $LN26@audioop_ad

; 916  :         return NULL;

  00080	33 c0		 xor	 eax, eax
  00082	e9 a8 02 00 00	 jmp	 $LN28@audioop_ad
$LN26@audioop_ad:

; 917  :     if ( len1 != len2 ) {

  00087	48 8b 44 24 70	 mov	 rax, QWORD PTR len2$[rsp]
  0008c	48 39 44 24 58	 cmp	 QWORD PTR len1$[rsp], rax
  00091	74 1a		 je	 SHORT $LN25@audioop_ad

; 918  :         PyErr_SetString(AudioopError, "Lengths should be the same");

  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@NGDJONDO@Lengths?5should?5be?5the?5same?$AA@
  0009a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  000a1	e8 00 00 00 00	 call	 PyErr_SetString

; 919  :         return 0;

  000a6	33 c0		 xor	 eax, eax
  000a8	e9 82 02 00 00	 jmp	 $LN28@audioop_ad
$LN25@audioop_ad:

; 920  :     }
; 921  : 
; 922  :     maxval = maxvals[size];

  000ad	48 63 44 24 68	 movsxd	 rax, DWORD PTR size$[rsp]
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:maxvals
  000b9	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000bc	89 84 24 80 00
	00 00		 mov	 DWORD PTR maxval$[rsp], eax

; 923  :     minval = minvals[size];

  000c3	48 63 44 24 68	 movsxd	 rax, DWORD PTR size$[rsp]
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:minvals
  000cf	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000d2	89 44 24 50	 mov	 DWORD PTR minval$[rsp], eax

; 924  : 
; 925  :     rv = PyBytes_FromStringAndSize(NULL, len1);

  000d6	48 8b 54 24 58	 mov	 rdx, QWORD PTR len1$[rsp]
  000db	33 c9		 xor	 ecx, ecx
  000dd	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000e2	48 89 44 24 78	 mov	 QWORD PTR rv$[rsp], rax

; 926  :     if ( rv == 0 )

  000e7	48 83 7c 24 78
	00		 cmp	 QWORD PTR rv$[rsp], 0
  000ed	75 07		 jne	 SHORT $LN24@audioop_ad

; 927  :         return 0;

  000ef	33 c0		 xor	 eax, eax
  000f1	e9 39 02 00 00	 jmp	 $LN28@audioop_ad
$LN24@audioop_ad:

; 928  :     ncp = (signed char *)PyBytes_AsString(rv);

  000f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rv$[rsp]
  000fb	e8 00 00 00 00	 call	 PyBytes_AsString
  00100	48 89 44 24 48	 mov	 QWORD PTR ncp$[rsp], rax

; 929  : 
; 930  :     for ( i=0; i < len1; i += size ) {

  00105	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0010e	eb 15		 jmp	 SHORT $LN23@audioop_ad
$LN22@audioop_ad:
  00110	48 63 44 24 68	 movsxd	 rax, DWORD PTR size$[rsp]
  00115	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  0011a	48 03 c8	 add	 rcx, rax
  0011d	48 8b c1	 mov	 rax, rcx
  00120	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN23@audioop_ad:
  00125	48 8b 44 24 58	 mov	 rax, QWORD PTR len1$[rsp]
  0012a	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  0012f	0f 8d f5 01 00
	00		 jge	 $LN21@audioop_ad

; 931  :         if ( size == 1 )      val1 = (int)*CHARP(cp1, i);

  00135	83 7c 24 68 01	 cmp	 DWORD PTR size$[rsp], 1
  0013a	75 1c		 jne	 SHORT $LN20@audioop_ad
  0013c	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00141	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cp1$[rsp]
  00146	48 03 c8	 add	 rcx, rax
  00149	48 8b c1	 mov	 rax, rcx
  0014c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0014f	89 84 24 94 00
	00 00		 mov	 DWORD PTR val1$[rsp], eax
  00156	eb 43		 jmp	 SHORT $LN19@audioop_ad
$LN20@audioop_ad:

; 932  :         else if ( size == 2 ) val1 = (int)*SHORTP(cp1, i);

  00158	83 7c 24 68 02	 cmp	 DWORD PTR size$[rsp], 2
  0015d	75 1c		 jne	 SHORT $LN18@audioop_ad
  0015f	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00164	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cp1$[rsp]
  00169	48 03 c8	 add	 rcx, rax
  0016c	48 8b c1	 mov	 rax, rcx
  0016f	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00172	89 84 24 94 00
	00 00		 mov	 DWORD PTR val1$[rsp], eax
  00179	eb 20		 jmp	 SHORT $LN17@audioop_ad
$LN18@audioop_ad:

; 933  :         else if ( size == 4 ) val1 = (int)*LONGP(cp1, i);

  0017b	83 7c 24 68 04	 cmp	 DWORD PTR size$[rsp], 4
  00180	75 19		 jne	 SHORT $LN16@audioop_ad
  00182	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00187	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cp1$[rsp]
  0018c	48 03 c8	 add	 rcx, rax
  0018f	48 8b c1	 mov	 rax, rcx
  00192	8b 00		 mov	 eax, DWORD PTR [rax]
  00194	89 84 24 94 00
	00 00		 mov	 DWORD PTR val1$[rsp], eax
$LN16@audioop_ad:
$LN17@audioop_ad:
$LN19@audioop_ad:

; 934  : 
; 935  :         if ( size == 1 )      val2 = (int)*CHARP(cp2, i);

  0019b	83 7c 24 68 01	 cmp	 DWORD PTR size$[rsp], 1
  001a0	75 1c		 jne	 SHORT $LN15@audioop_ad
  001a2	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001a7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cp2$[rsp]
  001af	48 03 c8	 add	 rcx, rax
  001b2	48 8b c1	 mov	 rax, rcx
  001b5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001b8	89 44 24 6c	 mov	 DWORD PTR val2$[rsp], eax
  001bc	eb 43		 jmp	 SHORT $LN14@audioop_ad
$LN15@audioop_ad:

; 936  :         else if ( size == 2 ) val2 = (int)*SHORTP(cp2, i);

  001be	83 7c 24 68 02	 cmp	 DWORD PTR size$[rsp], 2
  001c3	75 1c		 jne	 SHORT $LN13@audioop_ad
  001c5	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001ca	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cp2$[rsp]
  001d2	48 03 c8	 add	 rcx, rax
  001d5	48 8b c1	 mov	 rax, rcx
  001d8	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001db	89 44 24 6c	 mov	 DWORD PTR val2$[rsp], eax
  001df	eb 20		 jmp	 SHORT $LN12@audioop_ad
$LN13@audioop_ad:

; 937  :         else if ( size == 4 ) val2 = (int)*LONGP(cp2, i);

  001e1	83 7c 24 68 04	 cmp	 DWORD PTR size$[rsp], 4
  001e6	75 19		 jne	 SHORT $LN11@audioop_ad
  001e8	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001ed	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cp2$[rsp]
  001f5	48 03 c8	 add	 rcx, rax
  001f8	48 8b c1	 mov	 rax, rcx
  001fb	8b 00		 mov	 eax, DWORD PTR [rax]
  001fd	89 44 24 6c	 mov	 DWORD PTR val2$[rsp], eax
$LN11@audioop_ad:
$LN12@audioop_ad:
$LN14@audioop_ad:

; 938  : 
; 939  :         if (size < 4) {

  00201	83 7c 24 68 04	 cmp	 DWORD PTR size$[rsp], 4
  00206	7d 50		 jge	 SHORT $LN10@audioop_ad

; 940  :             newval = val1 + val2;

  00208	8b 44 24 6c	 mov	 eax, DWORD PTR val2$[rsp]
  0020c	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR val1$[rsp]
  00213	03 c8		 add	 ecx, eax
  00215	8b c1		 mov	 eax, ecx
  00217	89 84 24 90 00
	00 00		 mov	 DWORD PTR newval$[rsp], eax

; 941  :             /* truncate in case of overflow */
; 942  :             if (newval > maxval)

  0021e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR maxval$[rsp]
  00225	39 84 24 90 00
	00 00		 cmp	 DWORD PTR newval$[rsp], eax
  0022c	7e 10		 jle	 SHORT $LN9@audioop_ad

; 943  :                 newval = maxval;

  0022e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR maxval$[rsp]
  00235	89 84 24 90 00
	00 00		 mov	 DWORD PTR newval$[rsp], eax
  0023c	eb 18		 jmp	 SHORT $LN8@audioop_ad
$LN9@audioop_ad:

; 944  :             else if (newval < minval)

  0023e	8b 44 24 50	 mov	 eax, DWORD PTR minval$[rsp]
  00242	39 84 24 90 00
	00 00		 cmp	 DWORD PTR newval$[rsp], eax
  00249	7d 0b		 jge	 SHORT $LN7@audioop_ad

; 945  :                 newval = minval;

  0024b	8b 44 24 50	 mov	 eax, DWORD PTR minval$[rsp]
  0024f	89 84 24 90 00
	00 00		 mov	 DWORD PTR newval$[rsp], eax
$LN7@audioop_ad:
$LN8@audioop_ad:

; 946  :         }
; 947  :         else {

  00256	eb 66		 jmp	 SHORT $LN6@audioop_ad
$LN10@audioop_ad:

; 948  :             double fval = (double)val1 + (double)val2;

  00258	66 0f 6e 84 24
	94 00 00 00	 movd	 xmm0, DWORD PTR val1$[rsp]
  00261	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00265	66 0f 6e 4c 24
	6c		 movd	 xmm1, DWORD PTR val2$[rsp]
  0026b	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0026f	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00273	f2 0f 11 84 24
	98 00 00 00	 movsdx	 QWORD PTR fval$21055[rsp], xmm0

; 949  :             /* truncate in case of overflow */
; 950  :             newval = (int)floor(fbound(fval, minval, maxval));

  0027c	66 0f 6e 84 24
	80 00 00 00	 movd	 xmm0, DWORD PTR maxval$[rsp]
  00285	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00289	66 0f 6e 4c 24
	50		 movd	 xmm1, DWORD PTR minval$[rsp]
  0028f	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00293	66 0f 28 d0	 movapd	 xmm2, xmm0
  00297	f2 0f 10 84 24
	98 00 00 00	 movsdx	 xmm0, QWORD PTR fval$21055[rsp]
  002a0	e8 00 00 00 00	 call	 fbound
  002a5	66 0f 6e c0	 movd	 xmm0, eax
  002a9	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  002b3	f2 0f 2c c0	 cvttsd2si eax, xmm0
  002b7	89 84 24 90 00
	00 00		 mov	 DWORD PTR newval$[rsp], eax
$LN6@audioop_ad:

; 951  :         }
; 952  : 
; 953  :         if ( size == 1 )      *CHARP(ncp, i) = (signed char)newval;

  002be	83 7c 24 68 01	 cmp	 DWORD PTR size$[rsp], 1
  002c3	75 1c		 jne	 SHORT $LN5@audioop_ad
  002c5	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  002ca	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  002cf	48 03 c8	 add	 rcx, rax
  002d2	48 8b c1	 mov	 rax, rcx
  002d5	0f b6 8c 24 90
	00 00 00	 movzx	 ecx, BYTE PTR newval$[rsp]
  002dd	88 08		 mov	 BYTE PTR [rax], cl
  002df	eb 44		 jmp	 SHORT $LN4@audioop_ad
$LN5@audioop_ad:

; 954  :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)newval;

  002e1	83 7c 24 68 02	 cmp	 DWORD PTR size$[rsp], 2
  002e6	75 1d		 jne	 SHORT $LN3@audioop_ad
  002e8	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  002ed	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  002f2	48 03 c8	 add	 rcx, rax
  002f5	48 8b c1	 mov	 rax, rcx
  002f8	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR newval$[rsp]
  00300	66 89 08	 mov	 WORD PTR [rax], cx
  00303	eb 20		 jmp	 SHORT $LN2@audioop_ad
$LN3@audioop_ad:

; 955  :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)newval;

  00305	83 7c 24 68 04	 cmp	 DWORD PTR size$[rsp], 4
  0030a	75 19		 jne	 SHORT $LN1@audioop_ad
  0030c	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00311	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  00316	48 03 c8	 add	 rcx, rax
  00319	48 8b c1	 mov	 rax, rcx
  0031c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR newval$[rsp]
  00323	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@audioop_ad:
$LN2@audioop_ad:
$LN4@audioop_ad:

; 956  :     }

  00325	e9 e6 fd ff ff	 jmp	 $LN22@audioop_ad
$LN21@audioop_ad:

; 957  :     return rv;

  0032a	48 8b 44 24 78	 mov	 rax, QWORD PTR rv$[rsp]
$LN28@audioop_ad:

; 958  : }

  0032f	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00336	c3		 ret	 0
audioop_add ENDP
_TEXT	ENDS
PUBLIC	??_C@_09CGMHJGJP@s?$CDii?3bias?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_bias DD imagerel audioop_bias
	DD	imagerel audioop_bias+456
	DD	imagerel $unwind$audioop_bias
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_bias DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_09CGMHJGJP@s?$CDii?3bias?$AA@
CONST	SEGMENT
??_C@_09CGMHJGJP@s?$CDii?3bias?$AA@ DB 's#ii:bias', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_bias
_TEXT	SEGMENT
cp$ = 48
i$ = 56
bias$ = 64
mask$ = 68
ncp$ = 72
size$ = 80
len$ = 88
val$ = 96
rv$ = 104
self$ = 128
args$ = 136
audioop_bias PROC					; COMDAT

; 962  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 963  :     signed char *cp, *ncp;
; 964  :     Py_ssize_t len, i;
; 965  :     int size, bias;
; 966  :     unsigned int val = 0, mask;

  0000e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 967  :     PyObject *rv;
; 968  : 
; 969  :     if ( !PyArg_ParseTuple(args, "s#ii:bias",
; 970  :                       &cp, &len, &size , &bias) )

  00016	48 8d 44 24 40	 lea	 rax, QWORD PTR bias$[rsp]
  0001b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00020	48 8d 44 24 50	 lea	 rax, QWORD PTR size$[rsp]
  00025	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002a	4c 8d 4c 24 58	 lea	 r9, QWORD PTR len$[rsp]
  0002f	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09CGMHJGJP@s?$CDii?3bias?$AA@
  0003b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00043	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00048	85 c0		 test	 eax, eax
  0004a	75 07		 jne	 SHORT $LN16@audioop_bi

; 971  :         return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 70 01 00 00	 jmp	 $LN17@audioop_bi
$LN16@audioop_bi:

; 972  : 
; 973  :     if (!audioop_check_parameters(len, size))

  00053	8b 54 24 50	 mov	 edx, DWORD PTR size$[rsp]
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR len$[rsp]
  0005c	e8 00 00 00 00	 call	 audioop_check_parameters
  00061	85 c0		 test	 eax, eax
  00063	75 07		 jne	 SHORT $LN15@audioop_bi

; 974  :         return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	e9 57 01 00 00	 jmp	 $LN17@audioop_bi
$LN15@audioop_bi:

; 975  : 
; 976  :     rv = PyBytes_FromStringAndSize(NULL, len);

  0006c	48 8b 54 24 58	 mov	 rdx, QWORD PTR len$[rsp]
  00071	33 c9		 xor	 ecx, ecx
  00073	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00078	48 89 44 24 68	 mov	 QWORD PTR rv$[rsp], rax

; 977  :     if ( rv == 0 )

  0007d	48 83 7c 24 68
	00		 cmp	 QWORD PTR rv$[rsp], 0
  00083	75 07		 jne	 SHORT $LN14@audioop_bi

; 978  :         return 0;

  00085	33 c0		 xor	 eax, eax
  00087	e9 37 01 00 00	 jmp	 $LN17@audioop_bi
$LN14@audioop_bi:

; 979  :     ncp = (signed char *)PyBytes_AsString(rv);

  0008c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rv$[rsp]
  00091	e8 00 00 00 00	 call	 PyBytes_AsString
  00096	48 89 44 24 48	 mov	 QWORD PTR ncp$[rsp], rax

; 980  : 
; 981  :     mask = masks[size];

  0009b	48 63 44 24 50	 movsxd	 rax, DWORD PTR size$[rsp]
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:masks
  000a7	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000aa	89 44 24 44	 mov	 DWORD PTR mask$[rsp], eax

; 982  : 
; 983  :     for ( i=0; i < len; i += size ) {

  000ae	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000b7	eb 15		 jmp	 SHORT $LN13@audioop_bi
$LN12@audioop_bi:
  000b9	48 63 44 24 50	 movsxd	 rax, DWORD PTR size$[rsp]
  000be	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000c3	48 03 c8	 add	 rcx, rax
  000c6	48 8b c1	 mov	 rax, rcx
  000c9	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN13@audioop_bi:
  000ce	48 8b 44 24 58	 mov	 rax, QWORD PTR len$[rsp]
  000d3	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  000d8	0f 8d e0 00 00
	00		 jge	 $LN11@audioop_bi

; 984  :         if ( size == 1 )      val = (unsigned int)(unsigned char)*CHARP(cp, i);

  000de	83 7c 24 50 01	 cmp	 DWORD PTR size$[rsp], 1
  000e3	75 19		 jne	 SHORT $LN10@audioop_bi
  000e5	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000ea	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000ef	48 03 c8	 add	 rcx, rax
  000f2	48 8b c1	 mov	 rax, rcx
  000f5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f8	89 44 24 60	 mov	 DWORD PTR val$[rsp], eax
  000fc	eb 3d		 jmp	 SHORT $LN9@audioop_bi
$LN10@audioop_bi:

; 985  :         else if ( size == 2 ) val = (unsigned int)(unsigned short)*SHORTP(cp, i);

  000fe	83 7c 24 50 02	 cmp	 DWORD PTR size$[rsp], 2
  00103	75 19		 jne	 SHORT $LN8@audioop_bi
  00105	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0010a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  0010f	48 03 c8	 add	 rcx, rax
  00112	48 8b c1	 mov	 rax, rcx
  00115	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00118	89 44 24 60	 mov	 DWORD PTR val$[rsp], eax
  0011c	eb 1d		 jmp	 SHORT $LN7@audioop_bi
$LN8@audioop_bi:

; 986  :         else if ( size == 4 ) val = (unsigned int)(Py_UInt32)*LONGP(cp, i);

  0011e	83 7c 24 50 04	 cmp	 DWORD PTR size$[rsp], 4
  00123	75 16		 jne	 SHORT $LN6@audioop_bi
  00125	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0012a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  0012f	48 03 c8	 add	 rcx, rax
  00132	48 8b c1	 mov	 rax, rcx
  00135	8b 00		 mov	 eax, DWORD PTR [rax]
  00137	89 44 24 60	 mov	 DWORD PTR val$[rsp], eax
$LN6@audioop_bi:
$LN7@audioop_bi:
$LN9@audioop_bi:

; 987  : 
; 988  :         val += (unsigned int)bias;

  0013b	8b 44 24 40	 mov	 eax, DWORD PTR bias$[rsp]
  0013f	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00143	03 c8		 add	 ecx, eax
  00145	8b c1		 mov	 eax, ecx
  00147	89 44 24 60	 mov	 DWORD PTR val$[rsp], eax

; 989  :         /* wrap around in case of overflow */
; 990  :         val &= mask;

  0014b	8b 44 24 44	 mov	 eax, DWORD PTR mask$[rsp]
  0014f	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00153	23 c8		 and	 ecx, eax
  00155	8b c1		 mov	 eax, ecx
  00157	89 44 24 60	 mov	 DWORD PTR val$[rsp], eax

; 991  : 
; 992  :         if ( size == 1 )      *CHARP(ncp, i) = (signed char)(unsigned char)val;

  0015b	83 7c 24 50 01	 cmp	 DWORD PTR size$[rsp], 1
  00160	75 19		 jne	 SHORT $LN5@audioop_bi
  00162	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00167	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  0016c	48 03 c8	 add	 rcx, rax
  0016f	48 8b c1	 mov	 rax, rcx
  00172	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR val$[rsp]
  00177	88 08		 mov	 BYTE PTR [rax], cl
  00179	eb 3e		 jmp	 SHORT $LN4@audioop_bi
$LN5@audioop_bi:

; 993  :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)(unsigned short)val;

  0017b	83 7c 24 50 02	 cmp	 DWORD PTR size$[rsp], 2
  00180	75 1a		 jne	 SHORT $LN3@audioop_bi
  00182	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00187	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  0018c	48 03 c8	 add	 rcx, rax
  0018f	48 8b c1	 mov	 rax, rcx
  00192	0f b7 4c 24 60	 movzx	 ecx, WORD PTR val$[rsp]
  00197	66 89 08	 mov	 WORD PTR [rax], cx
  0019a	eb 1d		 jmp	 SHORT $LN2@audioop_bi
$LN3@audioop_bi:

; 994  :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)(Py_UInt32)val;

  0019c	83 7c 24 50 04	 cmp	 DWORD PTR size$[rsp], 4
  001a1	75 16		 jne	 SHORT $LN1@audioop_bi
  001a3	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  001a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ncp$[rsp]
  001ad	48 03 c8	 add	 rcx, rax
  001b0	48 8b c1	 mov	 rax, rcx
  001b3	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  001b7	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@audioop_bi:
$LN2@audioop_bi:
$LN4@audioop_bi:

; 995  :     }

  001b9	e9 fb fe ff ff	 jmp	 $LN12@audioop_bi
$LN11@audioop_bi:

; 996  :     return rv;

  001be	48 8b 44 24 68	 mov	 rax, QWORD PTR rv$[rsp]
$LN17@audioop_bi:

; 997  : }

  001c3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001c7	c3		 ret	 0
audioop_bias ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@GKDECEAG@s?$CDi?3reverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_reverse DD imagerel audioop_reverse
	DD	imagerel audioop_reverse+434
	DD	imagerel $unwind$audioop_reverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_reverse DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0M@GKDECEAG@s?$CDi?3reverse?$AA@
CONST	SEGMENT
??_C@_0M@GKDECEAG@s?$CDi?3reverse?$AA@ DB 's#i:reverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_reverse
_TEXT	SEGMENT
cp$ = 48
i$ = 56
ncp$ = 64
size$ = 72
len$ = 80
val$ = 88
rv$ = 96
j$ = 104
self$ = 128
args$ = 136
audioop_reverse PROC					; COMDAT

; 1001 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1002 :     signed char *cp;
; 1003 :     unsigned char *ncp;
; 1004 :     Py_ssize_t len, i, j;
; 1005 :     int size, val = 0;

  0000e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 1006 :     PyObject *rv;
; 1007 : 
; 1008 :     if ( !PyArg_ParseTuple(args, "s#i:reverse",
; 1009 :                       &cp, &len, &size) )

  00016	48 8d 44 24 48	 lea	 rax, QWORD PTR size$[rsp]
  0001b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00020	4c 8d 4c 24 50	 lea	 r9, QWORD PTR len$[rsp]
  00025	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GKDECEAG@s?$CDi?3reverse?$AA@
  00031	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00039	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003e	85 c0		 test	 eax, eax
  00040	75 07		 jne	 SHORT $LN16@audioop_re

; 1010 :         return 0;

  00042	33 c0		 xor	 eax, eax
  00044	e9 64 01 00 00	 jmp	 $LN17@audioop_re
$LN16@audioop_re:

; 1011 : 
; 1012 :     if (!audioop_check_parameters(len, size))

  00049	8b 54 24 48	 mov	 edx, DWORD PTR size$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  00052	e8 00 00 00 00	 call	 audioop_check_parameters
  00057	85 c0		 test	 eax, eax
  00059	75 07		 jne	 SHORT $LN15@audioop_re

; 1013 :         return NULL;

  0005b	33 c0		 xor	 eax, eax
  0005d	e9 4b 01 00 00	 jmp	 $LN17@audioop_re
$LN15@audioop_re:

; 1014 : 
; 1015 :     rv = PyBytes_FromStringAndSize(NULL, len);

  00062	48 8b 54 24 50	 mov	 rdx, QWORD PTR len$[rsp]
  00067	33 c9		 xor	 ecx, ecx
  00069	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0006e	48 89 44 24 60	 mov	 QWORD PTR rv$[rsp], rax

; 1016 :     if ( rv == 0 )

  00073	48 83 7c 24 60
	00		 cmp	 QWORD PTR rv$[rsp], 0
  00079	75 07		 jne	 SHORT $LN14@audioop_re

; 1017 :         return 0;

  0007b	33 c0		 xor	 eax, eax
  0007d	e9 2b 01 00 00	 jmp	 $LN17@audioop_re
$LN14@audioop_re:

; 1018 :     ncp = (unsigned char *)PyBytes_AsString(rv);

  00082	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rv$[rsp]
  00087	e8 00 00 00 00	 call	 PyBytes_AsString
  0008c	48 89 44 24 40	 mov	 QWORD PTR ncp$[rsp], rax

; 1019 : 
; 1020 :     for ( i=0; i < len; i += size ) {

  00091	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0009a	eb 15		 jmp	 SHORT $LN13@audioop_re
$LN12@audioop_re:
  0009c	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  000a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000a6	48 03 c8	 add	 rcx, rax
  000a9	48 8b c1	 mov	 rax, rcx
  000ac	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN13@audioop_re:
  000b1	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  000b6	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  000bb	0f 8d e7 00 00
	00		 jge	 $LN11@audioop_re

; 1021 :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 24;

  000c1	83 7c 24 48 01	 cmp	 DWORD PTR size$[rsp], 1
  000c6	75 1c		 jne	 SHORT $LN10@audioop_re
  000c8	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000d2	48 03 c8	 add	 rcx, rax
  000d5	48 8b c1	 mov	 rax, rcx
  000d8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000db	c1 e0 18	 shl	 eax, 24
  000de	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  000e2	eb 40		 jmp	 SHORT $LN9@audioop_re
$LN10@audioop_re:

; 1022 :         else if ( size == 2 ) val = ((int)*SHORTP(cp, i)) << 16;

  000e4	83 7c 24 48 02	 cmp	 DWORD PTR size$[rsp], 2
  000e9	75 1c		 jne	 SHORT $LN8@audioop_re
  000eb	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000f0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000f5	48 03 c8	 add	 rcx, rax
  000f8	48 8b c1	 mov	 rax, rcx
  000fb	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000fe	c1 e0 10	 shl	 eax, 16
  00101	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  00105	eb 1d		 jmp	 SHORT $LN7@audioop_re
$LN8@audioop_re:

; 1023 :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  00107	83 7c 24 48 04	 cmp	 DWORD PTR size$[rsp], 4
  0010c	75 16		 jne	 SHORT $LN6@audioop_re
  0010e	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00113	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  00118	48 03 c8	 add	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	8b 00		 mov	 eax, DWORD PTR [rax]
  00120	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
$LN6@audioop_re:
$LN7@audioop_re:
$LN9@audioop_re:

; 1024 : 
; 1025 :         j = len - i - size;

  00124	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00129	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  0012e	48 2b c8	 sub	 rcx, rax
  00131	48 8b c1	 mov	 rax, rcx
  00134	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR size$[rsp]
  00139	48 2b c1	 sub	 rax, rcx
  0013c	48 89 44 24 68	 mov	 QWORD PTR j$[rsp], rax

; 1026 : 
; 1027 :         if ( size == 1 )      *CHARP(ncp, j) = (signed char)(val >> 24);

  00141	83 7c 24 48 01	 cmp	 DWORD PTR size$[rsp], 1
  00146	75 1b		 jne	 SHORT $LN5@audioop_re
  00148	8b 44 24 58	 mov	 eax, DWORD PTR val$[rsp]
  0014c	c1 f8 18	 sar	 eax, 24
  0014f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR j$[rsp]
  00154	48 8b 54 24 40	 mov	 rdx, QWORD PTR ncp$[rsp]
  00159	48 03 d1	 add	 rdx, rcx
  0015c	48 8b ca	 mov	 rcx, rdx
  0015f	88 01		 mov	 BYTE PTR [rcx], al
  00161	eb 40		 jmp	 SHORT $LN4@audioop_re
$LN5@audioop_re:

; 1028 :         else if ( size == 2 ) *SHORTP(ncp, j) = (short)(val >> 16);

  00163	83 7c 24 48 02	 cmp	 DWORD PTR size$[rsp], 2
  00168	75 1c		 jne	 SHORT $LN3@audioop_re
  0016a	8b 44 24 58	 mov	 eax, DWORD PTR val$[rsp]
  0016e	c1 f8 10	 sar	 eax, 16
  00171	48 8b 4c 24 68	 mov	 rcx, QWORD PTR j$[rsp]
  00176	48 8b 54 24 40	 mov	 rdx, QWORD PTR ncp$[rsp]
  0017b	48 03 d1	 add	 rdx, rcx
  0017e	48 8b ca	 mov	 rcx, rdx
  00181	66 89 01	 mov	 WORD PTR [rcx], ax
  00184	eb 1d		 jmp	 SHORT $LN2@audioop_re
$LN3@audioop_re:

; 1029 :         else if ( size == 4 ) *LONGP(ncp, j) = (Py_Int32)val;

  00186	83 7c 24 48 04	 cmp	 DWORD PTR size$[rsp], 4
  0018b	75 16		 jne	 SHORT $LN1@audioop_re
  0018d	48 8b 44 24 68	 mov	 rax, QWORD PTR j$[rsp]
  00192	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ncp$[rsp]
  00197	48 03 c8	 add	 rcx, rax
  0019a	48 8b c1	 mov	 rax, rcx
  0019d	8b 4c 24 58	 mov	 ecx, DWORD PTR val$[rsp]
  001a1	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@audioop_re:
$LN2@audioop_re:
$LN4@audioop_re:

; 1030 :     }

  001a3	e9 f4 fe ff ff	 jmp	 $LN12@audioop_re
$LN11@audioop_re:

; 1031 :     return rv;

  001a8	48 8b 44 24 60	 mov	 rax, QWORD PTR rv$[rsp]
$LN17@audioop_re:

; 1032 : }

  001ad	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001b1	c3		 ret	 0
audioop_reverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@JIJDKKEH@s?$CDii?3lin2lin?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_lin2lin DD imagerel audioop_lin2lin
	DD	imagerel audioop_lin2lin+598
	DD	imagerel $unwind$audioop_lin2lin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_lin2lin DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0N@JIJDKKEH@s?$CDii?3lin2lin?$AA@
CONST	SEGMENT
??_C@_0N@JIJDKKEH@s?$CDii?3lin2lin?$AA@ DB 's#ii:lin2lin', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_lin2lin
_TEXT	SEGMENT
cp$ = 48
i$ = 56
ncp$ = 64
size$ = 72
len$ = 80
val$ = 88
size2$ = 92
rv$ = 96
j$ = 104
tv79 = 112
tv80 = 120
tv87 = 128
self$ = 160
args$ = 168
audioop_lin2lin PROC					; COMDAT

; 1036 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1037 :     signed char *cp;
; 1038 :     unsigned char *ncp;
; 1039 :     Py_ssize_t len, i, j;
; 1040 :     int size, size2, val = 0;

  00011	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 1041 :     PyObject *rv;
; 1042 : 
; 1043 :     if ( !PyArg_ParseTuple(args, "s#ii:lin2lin",
; 1044 :                       &cp, &len, &size, &size2) )

  00019	48 8d 44 24 5c	 lea	 rax, QWORD PTR size2$[rsp]
  0001e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00023	48 8d 44 24 48	 lea	 rax, QWORD PTR size$[rsp]
  00028	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002d	4c 8d 4c 24 50	 lea	 r9, QWORD PTR len$[rsp]
  00032	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JIJDKKEH@s?$CDii?3lin2lin?$AA@
  0003e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00046	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0004b	85 c0		 test	 eax, eax
  0004d	75 07		 jne	 SHORT $LN18@audioop_li

; 1045 :         return 0;

  0004f	33 c0		 xor	 eax, eax
  00051	e9 f8 01 00 00	 jmp	 $LN19@audioop_li
$LN18@audioop_li:

; 1046 : 
; 1047 :     if (!audioop_check_parameters(len, size))

  00056	8b 54 24 48	 mov	 edx, DWORD PTR size$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  0005f	e8 00 00 00 00	 call	 audioop_check_parameters
  00064	85 c0		 test	 eax, eax
  00066	75 07		 jne	 SHORT $LN17@audioop_li

; 1048 :         return NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 df 01 00 00	 jmp	 $LN19@audioop_li
$LN17@audioop_li:

; 1049 :     if (!audioop_check_size(size2))

  0006f	8b 4c 24 5c	 mov	 ecx, DWORD PTR size2$[rsp]
  00073	e8 00 00 00 00	 call	 audioop_check_size
  00078	85 c0		 test	 eax, eax
  0007a	75 07		 jne	 SHORT $LN16@audioop_li

; 1050 :         return NULL;

  0007c	33 c0		 xor	 eax, eax
  0007e	e9 cb 01 00 00	 jmp	 $LN19@audioop_li
$LN16@audioop_li:

; 1051 : 
; 1052 :     if (len/size > PY_SSIZE_T_MAX/size2) {

  00083	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  00088	48 89 44 24 70	 mov	 QWORD PTR tv79[rsp], rax
  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00092	48 99		 cdq
  00094	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv79[rsp]
  00099	48 f7 f9	 idiv	 rcx
  0009c	48 89 44 24 78	 mov	 QWORD PTR tv80[rsp], rax
  000a1	48 63 4c 24 5c	 movsxd	 rcx, DWORD PTR size2$[rsp]
  000a6	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  000b0	48 8b c2	 mov	 rax, rdx
  000b3	48 99		 cdq
  000b5	48 f7 f9	 idiv	 rcx
  000b8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv80[rsp]
  000bd	48 3b c8	 cmp	 rcx, rax
  000c0	7e 1a		 jle	 SHORT $LN15@audioop_li

; 1053 :         PyErr_SetString(PyExc_MemoryError,
; 1054 :                         "not enough memory for output buffer");

  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  000c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  000d0	e8 00 00 00 00	 call	 PyErr_SetString

; 1055 :         return 0;

  000d5	33 c0		 xor	 eax, eax
  000d7	e9 72 01 00 00	 jmp	 $LN19@audioop_li
$LN15@audioop_li:

; 1056 :     }
; 1057 :     rv = PyBytes_FromStringAndSize(NULL, (len/size)*size2);

  000dc	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  000e1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv87[rsp], rax
  000e9	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  000ee	48 99		 cdq
  000f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv87[rsp]
  000f8	48 f7 f9	 idiv	 rcx
  000fb	48 63 4c 24 5c	 movsxd	 rcx, DWORD PTR size2$[rsp]
  00100	48 0f af c1	 imul	 rax, rcx
  00104	48 8b d0	 mov	 rdx, rax
  00107	33 c9		 xor	 ecx, ecx
  00109	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0010e	48 89 44 24 60	 mov	 QWORD PTR rv$[rsp], rax

; 1058 :     if ( rv == 0 )

  00113	48 83 7c 24 60
	00		 cmp	 QWORD PTR rv$[rsp], 0
  00119	75 07		 jne	 SHORT $LN14@audioop_li

; 1059 :         return 0;

  0011b	33 c0		 xor	 eax, eax
  0011d	e9 2c 01 00 00	 jmp	 $LN19@audioop_li
$LN14@audioop_li:

; 1060 :     ncp = (unsigned char *)PyBytes_AsString(rv);

  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rv$[rsp]
  00127	e8 00 00 00 00	 call	 PyBytes_AsString
  0012c	48 89 44 24 40	 mov	 QWORD PTR ncp$[rsp], rax

; 1061 : 
; 1062 :     for ( i=0, j=0; i < len; i += size, j += size2 ) {

  00131	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0013a	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  00143	eb 2a		 jmp	 SHORT $LN13@audioop_li
$LN12@audioop_li:
  00145	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  0014a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0014f	48 03 c8	 add	 rcx, rax
  00152	48 8b c1	 mov	 rax, rcx
  00155	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
  0015a	48 63 44 24 5c	 movsxd	 rax, DWORD PTR size2$[rsp]
  0015f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR j$[rsp]
  00164	48 03 c8	 add	 rcx, rax
  00167	48 8b c1	 mov	 rax, rcx
  0016a	48 89 44 24 68	 mov	 QWORD PTR j$[rsp], rax
$LN13@audioop_li:
  0016f	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00174	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00179	0f 8d ca 00 00
	00		 jge	 $LN11@audioop_li

; 1063 :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 24;

  0017f	83 7c 24 48 01	 cmp	 DWORD PTR size$[rsp], 1
  00184	75 1c		 jne	 SHORT $LN10@audioop_li
  00186	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0018b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  00190	48 03 c8	 add	 rcx, rax
  00193	48 8b c1	 mov	 rax, rcx
  00196	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00199	c1 e0 18	 shl	 eax, 24
  0019c	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  001a0	eb 40		 jmp	 SHORT $LN9@audioop_li
$LN10@audioop_li:

; 1064 :         else if ( size == 2 ) val = ((int)*SHORTP(cp, i)) << 16;

  001a2	83 7c 24 48 02	 cmp	 DWORD PTR size$[rsp], 2
  001a7	75 1c		 jne	 SHORT $LN8@audioop_li
  001a9	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  001ae	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  001b3	48 03 c8	 add	 rcx, rax
  001b6	48 8b c1	 mov	 rax, rcx
  001b9	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001bc	c1 e0 10	 shl	 eax, 16
  001bf	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  001c3	eb 1d		 jmp	 SHORT $LN7@audioop_li
$LN8@audioop_li:

; 1065 :         else if ( size == 4 ) val = (int)*LONGP(cp, i);

  001c5	83 7c 24 48 04	 cmp	 DWORD PTR size$[rsp], 4
  001ca	75 16		 jne	 SHORT $LN6@audioop_li
  001cc	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  001d1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  001d6	48 03 c8	 add	 rcx, rax
  001d9	48 8b c1	 mov	 rax, rcx
  001dc	8b 00		 mov	 eax, DWORD PTR [rax]
  001de	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
$LN6@audioop_li:
$LN7@audioop_li:
$LN9@audioop_li:

; 1066 : 
; 1067 :         if ( size2 == 1 )  *CHARP(ncp, j) = (signed char)(val >> 24);

  001e2	83 7c 24 5c 01	 cmp	 DWORD PTR size2$[rsp], 1
  001e7	75 1b		 jne	 SHORT $LN5@audioop_li
  001e9	8b 44 24 58	 mov	 eax, DWORD PTR val$[rsp]
  001ed	c1 f8 18	 sar	 eax, 24
  001f0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR j$[rsp]
  001f5	48 8b 54 24 40	 mov	 rdx, QWORD PTR ncp$[rsp]
  001fa	48 03 d1	 add	 rdx, rcx
  001fd	48 8b ca	 mov	 rcx, rdx
  00200	88 01		 mov	 BYTE PTR [rcx], al
  00202	eb 40		 jmp	 SHORT $LN4@audioop_li
$LN5@audioop_li:

; 1068 :         else if ( size2 == 2 ) *SHORTP(ncp, j) = (short)(val >> 16);

  00204	83 7c 24 5c 02	 cmp	 DWORD PTR size2$[rsp], 2
  00209	75 1c		 jne	 SHORT $LN3@audioop_li
  0020b	8b 44 24 58	 mov	 eax, DWORD PTR val$[rsp]
  0020f	c1 f8 10	 sar	 eax, 16
  00212	48 8b 4c 24 68	 mov	 rcx, QWORD PTR j$[rsp]
  00217	48 8b 54 24 40	 mov	 rdx, QWORD PTR ncp$[rsp]
  0021c	48 03 d1	 add	 rdx, rcx
  0021f	48 8b ca	 mov	 rcx, rdx
  00222	66 89 01	 mov	 WORD PTR [rcx], ax
  00225	eb 1d		 jmp	 SHORT $LN2@audioop_li
$LN3@audioop_li:

; 1069 :         else if ( size2 == 4 ) *LONGP(ncp, j) = (Py_Int32)val;

  00227	83 7c 24 5c 04	 cmp	 DWORD PTR size2$[rsp], 4
  0022c	75 16		 jne	 SHORT $LN1@audioop_li
  0022e	48 8b 44 24 68	 mov	 rax, QWORD PTR j$[rsp]
  00233	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ncp$[rsp]
  00238	48 03 c8	 add	 rcx, rax
  0023b	48 8b c1	 mov	 rax, rcx
  0023e	8b 4c 24 58	 mov	 ecx, DWORD PTR val$[rsp]
  00242	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@audioop_li:
$LN2@audioop_li:
$LN4@audioop_li:

; 1070 :     }

  00244	e9 fc fe ff ff	 jmp	 $LN12@audioop_li
$LN11@audioop_li:

; 1071 :     return rv;

  00249	48 8b 44 24 60	 mov	 rax, QWORD PTR rv$[rsp]
$LN19@audioop_li:

; 1072 : }

  0024e	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00255	c3		 ret	 0
audioop_lin2lin ENDP
_TEXT	ENDS
PUBLIC	??_C@_07MNHNGEGN@?$CIO?$CIiO?$CJ?$CJ?$AA@	; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_09FOELDHLD@ii?3ratecv?$AA@		; `string'
PUBLIC	??_C@_0BH@JEAKACJA@illegal?5state?5argument?$AA@ ; `string'
PUBLIC	??_C@_0CL@PFJFNEKM@iO?$CB?$DLaudioop?4ratecv?3?5illegal?5stat@ ; `string'
PUBLIC	??_C@_0BG@PAJABLDG@sampling?5rate?5not?5?$DO?50?$AA@ ; `string'
PUBLIC	??_C@_0CP@EJCKHCJP@weightA?5should?5be?5?$DO?$DN?51?0?5weightB?5@ ; `string'
PUBLIC	??_C@_0CG@JEDJKHJA@width?5?$CK?5nchannels?5too?5big?5for?5a?5@ ; `string'
PUBLIC	??_C@_0BN@DCAKCCGC@?$CD?5of?5channels?5should?5be?5?$DO?$DN?51?$AA@ ; `string'
PUBLIC	??_C@_0BC@EJFJCJGD@s?$CDiiiiO?$HMii?3ratecv?$AA@ ; `string'
EXTRN	__imp_free:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyTuple_SetItem:PROC
EXTRN	PyTuple_New:PROC
EXTRN	PyTuple_GetItem:PROC
EXTRN	PyTuple_Size:PROC
EXTRN	PyTuple_Type:BYTE
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyErr_NoMemory:PROC
EXTRN	__imp_malloc:PROC
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_ratecv DD imagerel audioop_ratecv
	DD	imagerel audioop_ratecv+2669
	DD	imagerel $unwind$audioop_ratecv
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_ratecv DD 021101H
	DD	0230111H
xdata	ENDS
;	COMDAT ??_C@_07MNHNGEGN@?$CIO?$CIiO?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_07MNHNGEGN@?$CIO?$CIiO?$CJ?$CJ?$AA@ DB '(O(iO))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FOELDHLD@ii?3ratecv?$AA@
CONST	SEGMENT
??_C@_09FOELDHLD@ii?3ratecv?$AA@ DB 'ii:ratecv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JEAKACJA@illegal?5state?5argument?$AA@
CONST	SEGMENT
??_C@_0BH@JEAKACJA@illegal?5state?5argument?$AA@ DB 'illegal state argume'
	DB	'nt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PFJFNEKM@iO?$CB?$DLaudioop?4ratecv?3?5illegal?5stat@
CONST	SEGMENT
??_C@_0CL@PFJFNEKM@iO?$CB?$DLaudioop?4ratecv?3?5illegal?5stat@ DB 'iO!;au'
	DB	'dioop.ratecv: illegal state argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PAJABLDG@sampling?5rate?5not?5?$DO?50?$AA@
CONST	SEGMENT
??_C@_0BG@PAJABLDG@sampling?5rate?5not?5?$DO?50?$AA@ DB 'sampling rate no'
	DB	't > 0', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@EJCKHCJP@weightA?5should?5be?5?$DO?$DN?51?0?5weightB?5@
CONST	SEGMENT
??_C@_0CP@EJCKHCJP@weightA?5should?5be?5?$DO?$DN?51?0?5weightB?5@ DB 'wei'
	DB	'ghtA should be >= 1, weightB should be >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JEDJKHJA@width?5?$CK?5nchannels?5too?5big?5for?5a?5@
CONST	SEGMENT
??_C@_0CG@JEDJKHJA@width?5?$CK?5nchannels?5too?5big?5for?5a?5@ DB 'width '
	DB	'* nchannels too big for a C int', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DCAKCCGC@?$CD?5of?5channels?5should?5be?5?$DO?$DN?51?$AA@
CONST	SEGMENT
??_C@_0BN@DCAKCCGC@?$CD?5of?5channels?5should?5be?5?$DO?$DN?51?$AA@ DB '#'
	DB	' of channels should be >= 1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EJFJCJGD@s?$CDiiiiO?$HMii?3ratecv?$AA@
CONST	SEGMENT
??_C@_0BC@EJFJCJGD@s?$CDiiiiO?$HMii?3ratecv?$AA@ DB 's#iiiiO|ii:ratecv', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_ratecv
_TEXT	SEGMENT
prev_i$ = 96
cp$ = 104
nchannels$ = 112
ncp$ = 120
cur_i$ = 128
size$ = 136
len$ = 144
cur_o$ = 152
outrate$ = 156
rv$ = 160
samps$ = 168
chan$ = 176
bytes_per_frame$ = 180
d$ = 184
weightA$ = 188
inrate$ = 192
weightB$ = 196
str$ = 200
state$ = 208
q$21309 = 216
tv92 = 224
tv157 = 232
tv187 = 240
tv191 = 248
tv209 = 256
tv210 = 264
self$ = 288
args$ = 296
audioop_ratecv PROC					; COMDAT

; 1087 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 1088 :     char *cp, *ncp;
; 1089 :     Py_ssize_t len;
; 1090 :     int size, nchannels, inrate, outrate, weightA, weightB;
; 1091 :     int chan, d, *prev_i, *cur_i, cur_o;
; 1092 :     PyObject *state, *samps, *str, *rv = NULL;

  00011	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0

; 1093 :     int bytes_per_frame;
; 1094 : 
; 1095 :     weightA = 1;

  0001d	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR weightA$[rsp], 1

; 1096 :     weightB = 0;

  00028	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR weightB$[rsp], 0

; 1097 :     if (!PyArg_ParseTuple(args, "s#iiiiO|ii:ratecv", &cp, &len, &size,
; 1098 :                           &nchannels, &inrate, &outrate, &state,
; 1099 :                           &weightA, &weightB))

  00033	48 8d 84 24 c4
	00 00 00	 lea	 rax, QWORD PTR weightB$[rsp]
  0003b	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00040	48 8d 84 24 bc
	00 00 00	 lea	 rax, QWORD PTR weightA$[rsp]
  00048	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0004d	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR state$[rsp]
  00055	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0005a	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR outrate$[rsp]
  00062	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00067	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR inrate$[rsp]
  0006f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00074	48 8d 44 24 70	 lea	 rax, QWORD PTR nchannels$[rsp]
  00079	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007e	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR size$[rsp]
  00086	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008b	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR len$[rsp]
  00093	4c 8d 44 24 68	 lea	 r8, QWORD PTR cp$[rsp]
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EJFJCJGD@s?$CDiiiiO?$HMii?3ratecv?$AA@
  0009f	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000a7	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000ac	85 c0		 test	 eax, eax
  000ae	75 07		 jne	 SHORT $LN59@audioop_ra

; 1100 :         return NULL;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 ae 09 00 00	 jmp	 $LN60@audioop_ra
$LN59@audioop_ra:

; 1101 :     if (!audioop_check_size(size))

  000b7	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR size$[rsp]
  000be	e8 00 00 00 00	 call	 audioop_check_size
  000c3	85 c0		 test	 eax, eax
  000c5	75 07		 jne	 SHORT $LN58@audioop_ra

; 1102 :         return NULL;

  000c7	33 c0		 xor	 eax, eax
  000c9	e9 97 09 00 00	 jmp	 $LN60@audioop_ra
$LN58@audioop_ra:

; 1103 :     if (nchannels < 1) {

  000ce	83 7c 24 70 01	 cmp	 DWORD PTR nchannels$[rsp], 1
  000d3	7d 1a		 jge	 SHORT $LN57@audioop_ra

; 1104 :         PyErr_SetString(AudioopError, "# of channels should be >= 1");

  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DCAKCCGC@?$CD?5of?5channels?5should?5be?5?$DO?$DN?51?$AA@
  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  000e3	e8 00 00 00 00	 call	 PyErr_SetString

; 1105 :         return NULL;

  000e8	33 c0		 xor	 eax, eax
  000ea	e9 76 09 00 00	 jmp	 $LN60@audioop_ra
$LN57@audioop_ra:

; 1106 :     }
; 1107 :     if (size > INT_MAX / nchannels) {

  000ef	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000f4	99		 cdq
  000f5	f7 7c 24 70	 idiv	 DWORD PTR nchannels$[rsp]
  000f9	39 84 24 88 00
	00 00		 cmp	 DWORD PTR size$[rsp], eax
  00100	7e 1a		 jle	 SHORT $LN56@audioop_ra

; 1108 :         /* This overflow test is rigorously correct because
; 1109 :            both multiplicands are >= 1.  Use the argument names
; 1110 :            from the docs for the error msg. */
; 1111 :         PyErr_SetString(PyExc_OverflowError,
; 1112 :                         "width * nchannels too big for a C int");

  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@JEDJKHJA@width?5?$CK?5nchannels?5too?5big?5for?5a?5@
  00109	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00110	e8 00 00 00 00	 call	 PyErr_SetString

; 1113 :         return NULL;

  00115	33 c0		 xor	 eax, eax
  00117	e9 49 09 00 00	 jmp	 $LN60@audioop_ra
$LN56@audioop_ra:

; 1114 :     }
; 1115 :     bytes_per_frame = size * nchannels;

  0011c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  00123	0f af 44 24 70	 imul	 eax, DWORD PTR nchannels$[rsp]
  00128	89 84 24 b4 00
	00 00		 mov	 DWORD PTR bytes_per_frame$[rsp], eax

; 1116 :     if (weightA < 1 || weightB < 0) {

  0012f	83 bc 24 bc 00
	00 00 01	 cmp	 DWORD PTR weightA$[rsp], 1
  00137	7c 0a		 jl	 SHORT $LN54@audioop_ra
  00139	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR weightB$[rsp], 0
  00141	7d 1a		 jge	 SHORT $LN55@audioop_ra
$LN54@audioop_ra:

; 1117 :         PyErr_SetString(AudioopError,
; 1118 :             "weightA should be >= 1, weightB should be >= 0");

  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@EJCKHCJP@weightA?5should?5be?5?$DO?$DN?51?0?5weightB?5@
  0014a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  00151	e8 00 00 00 00	 call	 PyErr_SetString

; 1119 :         return NULL;

  00156	33 c0		 xor	 eax, eax
  00158	e9 08 09 00 00	 jmp	 $LN60@audioop_ra
$LN55@audioop_ra:

; 1120 :     }
; 1121 :     if (len % bytes_per_frame != 0) {

  0015d	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR bytes_per_frame$[rsp]
  00165	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv92[rsp], rax
  0016d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  00175	48 99		 cdq
  00177	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv92[rsp]
  0017f	48 f7 f9	 idiv	 rcx
  00182	48 8b c2	 mov	 rax, rdx
  00185	48 85 c0	 test	 rax, rax
  00188	74 1a		 je	 SHORT $LN53@audioop_ra

; 1122 :         PyErr_SetString(AudioopError, "not a whole number of frames");

  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PBNONLCD@not?5a?5whole?5number?5of?5frames?$AA@
  00191	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  00198	e8 00 00 00 00	 call	 PyErr_SetString

; 1123 :         return NULL;

  0019d	33 c0		 xor	 eax, eax
  0019f	e9 c1 08 00 00	 jmp	 $LN60@audioop_ra
$LN53@audioop_ra:

; 1124 :     }
; 1125 :     if (inrate <= 0 || outrate <= 0) {

  001a4	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR inrate$[rsp], 0
  001ac	7e 0a		 jle	 SHORT $LN51@audioop_ra
  001ae	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR outrate$[rsp], 0
  001b6	7f 1a		 jg	 SHORT $LN52@audioop_ra
$LN51@audioop_ra:

; 1126 :         PyErr_SetString(AudioopError, "sampling rate not > 0");

  001b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PAJABLDG@sampling?5rate?5not?5?$DO?50?$AA@
  001bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  001c6	e8 00 00 00 00	 call	 PyErr_SetString

; 1127 :         return NULL;

  001cb	33 c0		 xor	 eax, eax
  001cd	e9 93 08 00 00	 jmp	 $LN60@audioop_ra
$LN52@audioop_ra:

; 1128 :     }
; 1129 :     /* divide inrate and outrate by their greatest common divisor */
; 1130 :     d = gcd(inrate, outrate);

  001d2	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR outrate$[rsp]
  001d9	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR inrate$[rsp]
  001e0	e8 00 00 00 00	 call	 gcd
  001e5	89 84 24 b8 00
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 1131 :     inrate /= d;

  001ec	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR inrate$[rsp]
  001f3	99		 cdq
  001f4	f7 bc 24 b8 00
	00 00		 idiv	 DWORD PTR d$[rsp]
  001fb	89 84 24 c0 00
	00 00		 mov	 DWORD PTR inrate$[rsp], eax

; 1132 :     outrate /= d;

  00202	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR outrate$[rsp]
  00209	99		 cdq
  0020a	f7 bc 24 b8 00
	00 00		 idiv	 DWORD PTR d$[rsp]
  00211	89 84 24 9c 00
	00 00		 mov	 DWORD PTR outrate$[rsp], eax

; 1133 :     /* divide weightA and weightB by their greatest common divisor */
; 1134 :     d = gcd(weightA, weightB);

  00218	8b 94 24 c4 00
	00 00		 mov	 edx, DWORD PTR weightB$[rsp]
  0021f	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR weightA$[rsp]
  00226	e8 00 00 00 00	 call	 gcd
  0022b	89 84 24 b8 00
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 1135 :     weightA /= d;

  00232	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR weightA$[rsp]
  00239	99		 cdq
  0023a	f7 bc 24 b8 00
	00 00		 idiv	 DWORD PTR d$[rsp]
  00241	89 84 24 bc 00
	00 00		 mov	 DWORD PTR weightA$[rsp], eax

; 1136 :     weightA /= d;

  00248	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR weightA$[rsp]
  0024f	99		 cdq
  00250	f7 bc 24 b8 00
	00 00		 idiv	 DWORD PTR d$[rsp]
  00257	89 84 24 bc 00
	00 00		 mov	 DWORD PTR weightA$[rsp], eax

; 1137 : 
; 1138 :     if ((size_t)nchannels > PY_SIZE_MAX/sizeof(int)) {

  0025e	48 63 44 24 70	 movsxd	 rax, DWORD PTR nchannels$[rsp]
  00263	48 b9 ff ff ff
	ff ff ff ff 3f	 mov	 rcx, 4611686018427387903 ; 3fffffffffffffffH
  0026d	48 3b c1	 cmp	 rax, rcx
  00270	76 1a		 jbe	 SHORT $LN50@audioop_ra

; 1139 :         PyErr_SetString(PyExc_MemoryError,
; 1140 :                         "not enough memory for output buffer");

  00272	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  00279	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  00280	e8 00 00 00 00	 call	 PyErr_SetString

; 1141 :         return 0;

  00285	33 c0		 xor	 eax, eax
  00287	e9 d9 07 00 00	 jmp	 $LN60@audioop_ra
$LN50@audioop_ra:

; 1142 :     }
; 1143 :     prev_i = (int *) malloc(nchannels * sizeof(int));

  0028c	48 63 44 24 70	 movsxd	 rax, DWORD PTR nchannels$[rsp]
  00291	48 c1 e0 02	 shl	 rax, 2
  00295	48 8b c8	 mov	 rcx, rax
  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0029e	48 89 44 24 60	 mov	 QWORD PTR prev_i$[rsp], rax

; 1144 :     cur_i = (int *) malloc(nchannels * sizeof(int));

  002a3	48 63 44 24 70	 movsxd	 rax, DWORD PTR nchannels$[rsp]
  002a8	48 c1 e0 02	 shl	 rax, 2
  002ac	48 8b c8	 mov	 rcx, rax
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  002b5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR cur_i$[rsp], rax

; 1145 :     if (prev_i == NULL || cur_i == NULL) {

  002bd	48 83 7c 24 60
	00		 cmp	 QWORD PTR prev_i$[rsp], 0
  002c3	74 0b		 je	 SHORT $LN48@audioop_ra
  002c5	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR cur_i$[rsp], 0
  002ce	75 0a		 jne	 SHORT $LN49@audioop_ra
$LN48@audioop_ra:

; 1146 :         (void) PyErr_NoMemory();

  002d0	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1147 :         goto exit;

  002d5	e9 57 07 00 00	 jmp	 $exit$21291
$LN49@audioop_ra:

; 1148 :     }
; 1149 : 
; 1150 :     len /= bytes_per_frame; /* # of frames */

  002da	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR bytes_per_frame$[rsp]
  002e2	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv157[rsp], rax
  002ea	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  002f2	48 99		 cdq
  002f4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv157[rsp]
  002fc	48 f7 f9	 idiv	 rcx
  002ff	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 1151 : 
; 1152 :     if (state == Py_None) {

  00307	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0030e	48 39 84 24 d0
	00 00 00	 cmp	 QWORD PTR state$[rsp], rax
  00316	75 6c		 jne	 SHORT $LN47@audioop_ra

; 1153 :         d = -outrate;

  00318	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR outrate$[rsp]
  0031f	f7 d8		 neg	 eax
  00321	89 84 24 b8 00
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 1154 :         for (chan = 0; chan < nchannels; chan++)

  00328	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR chan$[rsp], 0
  00333	eb 10		 jmp	 SHORT $LN46@audioop_ra
$LN45@audioop_ra:
  00335	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR chan$[rsp]
  0033c	ff c0		 inc	 eax
  0033e	89 84 24 b0 00
	00 00		 mov	 DWORD PTR chan$[rsp], eax
$LN46@audioop_ra:
  00345	8b 44 24 70	 mov	 eax, DWORD PTR nchannels$[rsp]
  00349	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR chan$[rsp], eax
  00350	7d 2d		 jge	 SHORT $LN44@audioop_ra

; 1155 :             prev_i[chan] = cur_i[chan] = 0;

  00352	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR chan$[rsp]
  0035a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur_i$[rsp]
  00362	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0
  00369	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR chan$[rsp]
  00371	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prev_i$[rsp]
  00376	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0
  0037d	eb b6		 jmp	 SHORT $LN45@audioop_ra
$LN44@audioop_ra:

; 1156 :     }
; 1157 :     else {

  0037f	e9 0f 01 00 00	 jmp	 $LN43@audioop_ra
$LN47@audioop_ra:

; 1158 :         if (!PyArg_ParseTuple(state,
; 1159 :                         "iO!;audioop.ratecv: illegal state argument",
; 1160 :                         &d, &PyTuple_Type, &samps))

  00384	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR samps$[rsp]
  0038c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00391	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyTuple_Type
  00398	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR d$[rsp]
  003a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@PFJFNEKM@iO?$CB?$DLaudioop?4ratecv?3?5illegal?5stat@
  003a7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  003af	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  003b4	85 c0		 test	 eax, eax
  003b6	75 05		 jne	 SHORT $LN42@audioop_ra

; 1161 :             goto exit;

  003b8	e9 74 06 00 00	 jmp	 $exit$21291
$LN42@audioop_ra:

; 1162 :         if (PyTuple_Size(samps) != nchannels) {

  003bd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR samps$[rsp]
  003c5	e8 00 00 00 00	 call	 PyTuple_Size
  003ca	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR nchannels$[rsp]
  003cf	48 3b c1	 cmp	 rax, rcx
  003d2	74 18		 je	 SHORT $LN41@audioop_ra

; 1163 :             PyErr_SetString(AudioopError,
; 1164 :                             "illegal state argument");

  003d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JEAKACJA@illegal?5state?5argument?$AA@
  003db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AudioopError
  003e2	e8 00 00 00 00	 call	 PyErr_SetString

; 1165 :             goto exit;

  003e7	e9 45 06 00 00	 jmp	 $exit$21291
$LN41@audioop_ra:

; 1166 :         }
; 1167 :         for (chan = 0; chan < nchannels; chan++) {

  003ec	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR chan$[rsp], 0
  003f7	eb 10		 jmp	 SHORT $LN40@audioop_ra
$LN39@audioop_ra:
  003f9	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR chan$[rsp]
  00400	ff c0		 inc	 eax
  00402	89 84 24 b0 00
	00 00		 mov	 DWORD PTR chan$[rsp], eax
$LN40@audioop_ra:
  00409	8b 44 24 70	 mov	 eax, DWORD PTR nchannels$[rsp]
  0040d	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR chan$[rsp], eax
  00414	7d 7d		 jge	 SHORT $LN38@audioop_ra

; 1168 :             if (!PyArg_ParseTuple(PyTuple_GetItem(samps, chan),
; 1169 :                                   "ii:ratecv", &prev_i[chan],
; 1170 :                                                &cur_i[chan]))

  00416	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR chan$[rsp]
  0041e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur_i$[rsp]
  00426	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  0042a	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv187[rsp], rax
  00432	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR chan$[rsp]
  0043a	48 8b 54 24 60	 mov	 rdx, QWORD PTR prev_i$[rsp]
  0043f	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  00443	48 89 8c 24 f8
	00 00 00	 mov	 QWORD PTR tv191[rsp], rcx
  0044b	48 63 94 24 b0
	00 00 00	 movsxd	 rdx, DWORD PTR chan$[rsp]
  00453	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR samps$[rsp]
  0045b	e8 00 00 00 00	 call	 PyTuple_GetItem
  00460	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv187[rsp]
  00468	4c 8b c9	 mov	 r9, rcx
  0046b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv191[rsp]
  00473	4c 8b c1	 mov	 r8, rcx
  00476	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09FOELDHLD@ii?3ratecv?$AA@
  0047d	48 8b c8	 mov	 rcx, rax
  00480	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00485	85 c0		 test	 eax, eax
  00487	75 05		 jne	 SHORT $LN37@audioop_ra

; 1171 :                 goto exit;

  00489	e9 a3 05 00 00	 jmp	 $exit$21291
$LN37@audioop_ra:

; 1172 :         }

  0048e	e9 66 ff ff ff	 jmp	 $LN39@audioop_ra
$LN38@audioop_ra:
$LN43@audioop_ra:

; 1173 :     }
; 1174 : 
; 1175 :     /* str <- Space for the output buffer. */
; 1176 :     if (len == 0)

  00493	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR len$[rsp], 0
  0049c	75 16		 jne	 SHORT $LN36@audioop_ra

; 1177 :         str = PyBytes_FromStringAndSize(NULL, 0);

  0049e	33 d2		 xor	 edx, edx
  004a0	33 c9		 xor	 ecx, ecx
  004a2	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  004a7	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR str$[rsp], rax

; 1178 :     else {

  004af	e9 d0 00 00 00	 jmp	 $LN35@audioop_ra
$LN36@audioop_ra:

; 1179 :         /* There are len input frames, so we need (mathematically)
; 1180 :            ceiling(len*outrate/inrate) output frames, and each frame
; 1181 :            requires bytes_per_frame bytes.  Computing this
; 1182 :            without spurious overflow is the challenge; we can
; 1183 :            settle for a reasonable upper bound, though, in this
; 1184 :            case ceiling(len/inrate) * outrate. */
; 1185 : 
; 1186 :         /* compute ceiling(len/inrate) without overflow */
; 1187 :         Py_ssize_t q = len > 0 ? 1 + (len - 1) / inrate : 0;

  004b4	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR len$[rsp], 0
  004bd	7e 25		 jle	 SHORT $LN62@audioop_ra
  004bf	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  004c7	48 ff c8	 dec	 rax
  004ca	48 63 8c 24 c0
	00 00 00	 movsxd	 rcx, DWORD PTR inrate$[rsp]
  004d2	48 99		 cdq
  004d4	48 f7 f9	 idiv	 rcx
  004d7	48 ff c0	 inc	 rax
  004da	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv209[rsp], rax
  004e2	eb 0c		 jmp	 SHORT $LN63@audioop_ra
$LN62@audioop_ra:
  004e4	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv209[rsp], 0
$LN63@audioop_ra:
  004f0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv209[rsp]
  004f8	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR q$21309[rsp], rax

; 1188 :         if (outrate > PY_SSIZE_T_MAX / q / bytes_per_frame)

  00500	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR outrate$[rsp]
  00508	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv210[rsp], rax
  00510	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0051a	48 8b c1	 mov	 rax, rcx
  0051d	48 99		 cdq
  0051f	48 f7 bc 24 d8
	00 00 00	 idiv	 QWORD PTR q$21309[rsp]
  00527	48 63 8c 24 b4
	00 00 00	 movsxd	 rcx, DWORD PTR bytes_per_frame$[rsp]
  0052f	48 99		 cdq
  00531	48 f7 f9	 idiv	 rcx
  00534	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv210[rsp]
  0053c	48 3b c8	 cmp	 rcx, rax
  0053f	7e 0e		 jle	 SHORT $LN34@audioop_ra

; 1189 :             str = NULL;

  00541	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR str$[rsp], 0

; 1190 :         else

  0054d	eb 35		 jmp	 SHORT $LN33@audioop_ra
$LN34@audioop_ra:

; 1191 :             str = PyBytes_FromStringAndSize(NULL,
; 1192 :                                             q * outrate * bytes_per_frame);

  0054f	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR outrate$[rsp]
  00557	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR q$21309[rsp]
  0055f	48 0f af c8	 imul	 rcx, rax
  00563	48 8b c1	 mov	 rax, rcx
  00566	48 63 8c 24 b4
	00 00 00	 movsxd	 rcx, DWORD PTR bytes_per_frame$[rsp]
  0056e	48 0f af c1	 imul	 rax, rcx
  00572	48 8b d0	 mov	 rdx, rax
  00575	33 c9		 xor	 ecx, ecx
  00577	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0057c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR str$[rsp], rax
$LN33@audioop_ra:
$LN35@audioop_ra:

; 1193 :     }
; 1194 :     if (str == NULL) {

  00584	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR str$[rsp], 0
  0058d	75 18		 jne	 SHORT $LN32@audioop_ra

; 1195 :         PyErr_SetString(PyExc_MemoryError,
; 1196 :             "not enough memory for output buffer");

  0058f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  00596	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  0059d	e8 00 00 00 00	 call	 PyErr_SetString

; 1197 :         goto exit;

  005a2	e9 8a 04 00 00	 jmp	 $exit$21291
$LN32@audioop_ra:

; 1198 :     }
; 1199 :     ncp = PyBytes_AsString(str);

  005a7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  005af	e8 00 00 00 00	 call	 PyBytes_AsString
  005b4	48 89 44 24 78	 mov	 QWORD PTR ncp$[rsp], rax
$LN31@audioop_ra:
$LN29@audioop_ra:

; 1200 : 
; 1201 :     for (;;) {
; 1202 :         while (d < 0) {

  005b9	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR d$[rsp], 0
  005c1	0f 8d 1d 03 00
	00		 jge	 $LN28@audioop_ra

; 1203 :             if (len == 0) {

  005c7	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR len$[rsp], 0
  005d0	0f 85 68 01 00
	00		 jne	 $LN27@audioop_ra

; 1204 :                 samps = PyTuple_New(nchannels);

  005d6	48 63 44 24 70	 movsxd	 rax, DWORD PTR nchannels$[rsp]
  005db	48 8b c8	 mov	 rcx, rax
  005de	e8 00 00 00 00	 call	 PyTuple_New
  005e3	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR samps$[rsp], rax

; 1205 :                 if (samps == NULL)

  005eb	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR samps$[rsp], 0
  005f4	75 05		 jne	 SHORT $LN26@audioop_ra

; 1206 :                     goto exit;

  005f6	e9 36 04 00 00	 jmp	 $exit$21291
$LN26@audioop_ra:

; 1207 :                 for (chan = 0; chan < nchannels; chan++)

  005fb	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR chan$[rsp], 0
  00606	eb 10		 jmp	 SHORT $LN25@audioop_ra
$LN24@audioop_ra:
  00608	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR chan$[rsp]
  0060f	ff c0		 inc	 eax
  00611	89 84 24 b0 00
	00 00		 mov	 DWORD PTR chan$[rsp], eax
$LN25@audioop_ra:
  00618	8b 44 24 70	 mov	 eax, DWORD PTR nchannels$[rsp]
  0061c	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR chan$[rsp], eax
  00623	7d 4d		 jge	 SHORT $LN23@audioop_ra

; 1208 :                     PyTuple_SetItem(samps, chan,
; 1209 :                         Py_BuildValue("(ii)",
; 1210 :                                       prev_i[chan],
; 1211 :                                       cur_i[chan]));

  00625	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR chan$[rsp]
  0062d	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR chan$[rsp]
  00635	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR cur_i$[rsp]
  0063d	44 8b 04 82	 mov	 r8d, DWORD PTR [rdx+rax*4]
  00641	48 8b 44 24 60	 mov	 rax, QWORD PTR prev_i$[rsp]
  00646	8b 14 88	 mov	 edx, DWORD PTR [rax+rcx*4]
  00649	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  00650	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00655	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR chan$[rsp]
  0065d	4c 8b c0	 mov	 r8, rax
  00660	48 8b d1	 mov	 rdx, rcx
  00663	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR samps$[rsp]
  0066b	e8 00 00 00 00	 call	 PyTuple_SetItem
  00670	eb 96		 jmp	 SHORT $LN24@audioop_ra
$LN23@audioop_ra:

; 1212 :                 if (PyErr_Occurred())

  00672	e8 00 00 00 00	 call	 PyErr_Occurred
  00677	48 85 c0	 test	 rax, rax
  0067a	74 05		 je	 SHORT $LN22@audioop_ra

; 1213 :                     goto exit;

  0067c	e9 b0 03 00 00	 jmp	 $exit$21291
$LN22@audioop_ra:

; 1214 :                 /* We have checked before that the length
; 1215 :                  * of the string fits into int. */
; 1216 :                 len = (Py_ssize_t)(ncp - PyBytes_AsString(str));

  00681	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  00689	e8 00 00 00 00	 call	 PyBytes_AsString
  0068e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ncp$[rsp]
  00693	48 2b c8	 sub	 rcx, rax
  00696	48 8b c1	 mov	 rax, rcx
  00699	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 1217 :                 rv = PyBytes_FromStringAndSize
; 1218 :                     (PyBytes_AsString(str), len);

  006a1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  006a9	e8 00 00 00 00	 call	 PyBytes_AsString
  006ae	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR len$[rsp]
  006b6	48 8b c8	 mov	 rcx, rax
  006b9	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  006be	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax

; 1219 :                 Py_DECREF(str);

  006c6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  006ce	e8 00 00 00 00	 call	 _Py_DecRef

; 1220 :                 str = rv;

  006d3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  006db	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR str$[rsp], rax

; 1221 :                 if (str == NULL)

  006e3	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR str$[rsp], 0
  006ec	75 05		 jne	 SHORT $LN21@audioop_ra

; 1222 :                     goto exit;

  006ee	e9 3e 03 00 00	 jmp	 $exit$21291
$LN21@audioop_ra:

; 1223 :                 rv = Py_BuildValue("(O(iO))", str, d, samps);

  006f3	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR samps$[rsp]
  006fb	44 8b 84 24 b8
	00 00 00	 mov	 r8d, DWORD PTR d$[rsp]
  00703	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  0070b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07MNHNGEGN@?$CIO?$CIiO?$CJ?$CJ?$AA@
  00712	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00717	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax

; 1224 :                 Py_DECREF(samps);

  0071f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR samps$[rsp]
  00727	e8 00 00 00 00	 call	 _Py_DecRef

; 1225 :                 Py_DECREF(str);

  0072c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  00734	e8 00 00 00 00	 call	 _Py_DecRef

; 1226 :                 goto exit; /* return rv */

  00739	e9 f3 02 00 00	 jmp	 $exit$21291
$LN27@audioop_ra:

; 1227 :             }
; 1228 :             for (chan = 0; chan < nchannels; chan++) {

  0073e	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR chan$[rsp], 0
  00749	eb 10		 jmp	 SHORT $LN20@audioop_ra
$LN19@audioop_ra:
  0074b	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR chan$[rsp]
  00752	ff c0		 inc	 eax
  00754	89 84 24 b0 00
	00 00		 mov	 DWORD PTR chan$[rsp], eax
$LN20@audioop_ra:
  0075b	8b 44 24 70	 mov	 eax, DWORD PTR nchannels$[rsp]
  0075f	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR chan$[rsp], eax
  00766	0f 8d 47 01 00
	00		 jge	 $LN18@audioop_ra

; 1229 :                 prev_i[chan] = cur_i[chan];

  0076c	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR chan$[rsp]
  00774	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR chan$[rsp]
  0077c	48 8b 54 24 60	 mov	 rdx, QWORD PTR prev_i$[rsp]
  00781	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR cur_i$[rsp]
  00789	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  0078d	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 1230 :                 if (size == 1)

  00790	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR size$[rsp], 1
  00798	75 20		 jne	 SHORT $LN17@audioop_ra

; 1231 :                     cur_i[chan] = ((int)*CHARP(cp, 0)) << 24;

  0079a	48 8b 44 24 68	 mov	 rax, QWORD PTR cp$[rsp]
  0079f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  007a2	c1 e0 18	 shl	 eax, 24
  007a5	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR chan$[rsp]
  007ad	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR cur_i$[rsp]
  007b5	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  007b8	eb 4e		 jmp	 SHORT $LN16@audioop_ra
$LN17@audioop_ra:

; 1232 :                 else if (size == 2)

  007ba	83 bc 24 88 00
	00 00 02	 cmp	 DWORD PTR size$[rsp], 2
  007c2	75 20		 jne	 SHORT $LN15@audioop_ra

; 1233 :                     cur_i[chan] = ((int)*SHORTP(cp, 0)) << 16;

  007c4	48 8b 44 24 68	 mov	 rax, QWORD PTR cp$[rsp]
  007c9	0f bf 00	 movsx	 eax, WORD PTR [rax]
  007cc	c1 e0 10	 shl	 eax, 16
  007cf	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR chan$[rsp]
  007d7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR cur_i$[rsp]
  007df	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  007e2	eb 24		 jmp	 SHORT $LN14@audioop_ra
$LN15@audioop_ra:

; 1234 :                 else if (size == 4)

  007e4	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR size$[rsp], 4
  007ec	75 1a		 jne	 SHORT $LN13@audioop_ra

; 1235 :                     cur_i[chan] = (int)*LONGP(cp, 0);

  007ee	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR chan$[rsp]
  007f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur_i$[rsp]
  007fe	48 8b 54 24 68	 mov	 rdx, QWORD PTR cp$[rsp]
  00803	8b 12		 mov	 edx, DWORD PTR [rdx]
  00805	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN13@audioop_ra:
$LN14@audioop_ra:
$LN16@audioop_ra:

; 1236 :                 cp += size;

  00808	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR size$[rsp]
  00810	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cp$[rsp]
  00815	48 03 c8	 add	 rcx, rax
  00818	48 8b c1	 mov	 rax, rcx
  0081b	48 89 44 24 68	 mov	 QWORD PTR cp$[rsp], rax

; 1237 :                 /* implements a simple digital filter */
; 1238 :                 cur_i[chan] = (int)(
; 1239 :                     ((double)weightA * (double)cur_i[chan] +
; 1240 :                      (double)weightB * (double)prev_i[chan]) /
; 1241 :                     ((double)weightA + (double)weightB));

  00820	66 0f 6e 84 24
	bc 00 00 00	 movd	 xmm0, DWORD PTR weightA$[rsp]
  00829	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0082d	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR chan$[rsp]
  00835	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur_i$[rsp]
  0083d	66 0f 6e 0c 81	 movd	 xmm1, DWORD PTR [rcx+rax*4]
  00842	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00846	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0084a	66 0f 6e 8c 24
	c4 00 00 00	 movd	 xmm1, DWORD PTR weightB$[rsp]
  00853	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00857	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR chan$[rsp]
  0085f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prev_i$[rsp]
  00864	66 0f 6e 14 81	 movd	 xmm2, DWORD PTR [rcx+rax*4]
  00869	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  0086d	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  00871	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00875	66 0f 6e 8c 24
	bc 00 00 00	 movd	 xmm1, DWORD PTR weightA$[rsp]
  0087e	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00882	66 0f 6e 94 24
	c4 00 00 00	 movd	 xmm2, DWORD PTR weightB$[rsp]
  0088b	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  0088f	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00893	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00897	f2 0f 2c c0	 cvttsd2si eax, xmm0
  0089b	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR chan$[rsp]
  008a3	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR cur_i$[rsp]
  008ab	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 1242 :             }

  008ae	e9 98 fe ff ff	 jmp	 $LN19@audioop_ra
$LN18@audioop_ra:

; 1243 :             len--;

  008b3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  008bb	48 ff c8	 dec	 rax
  008be	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 1244 :             d += outrate;

  008c6	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR outrate$[rsp]
  008cd	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  008d4	03 c8		 add	 ecx, eax
  008d6	8b c1		 mov	 eax, ecx
  008d8	89 84 24 b8 00
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 1245 :         }

  008df	e9 d5 fc ff ff	 jmp	 $LN29@audioop_ra
$LN28@audioop_ra:
$LN12@audioop_ra:

; 1246 :         while (d >= 0) {

  008e4	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR d$[rsp], 0
  008ec	0f 8c 3a 01 00
	00		 jl	 $LN11@audioop_ra

; 1247 :             for (chan = 0; chan < nchannels; chan++) {

  008f2	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR chan$[rsp], 0
  008fd	eb 10		 jmp	 SHORT $LN10@audioop_ra
$LN9@audioop_ra:
  008ff	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR chan$[rsp]
  00906	ff c0		 inc	 eax
  00908	89 84 24 b0 00
	00 00		 mov	 DWORD PTR chan$[rsp], eax
$LN10@audioop_ra:
  0090f	8b 44 24 70	 mov	 eax, DWORD PTR nchannels$[rsp]
  00913	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR chan$[rsp], eax
  0091a	0f 8d ee 00 00
	00		 jge	 $LN8@audioop_ra

; 1248 :                 cur_o = (int)(((double)prev_i[chan] * (double)d +
; 1249 :                          (double)cur_i[chan] * (double)(outrate - d)) /
; 1250 :                     (double)outrate);

  00920	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR chan$[rsp]
  00928	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prev_i$[rsp]
  0092d	66 0f 6e 04 81	 movd	 xmm0, DWORD PTR [rcx+rax*4]
  00932	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00936	66 0f 6e 8c 24
	b8 00 00 00	 movd	 xmm1, DWORD PTR d$[rsp]
  0093f	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00943	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00947	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR chan$[rsp]
  0094f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur_i$[rsp]
  00957	66 0f 6e 0c 81	 movd	 xmm1, DWORD PTR [rcx+rax*4]
  0095c	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00960	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR d$[rsp]
  00967	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR outrate$[rsp]
  0096e	2b c8		 sub	 ecx, eax
  00970	8b c1		 mov	 eax, ecx
  00972	66 0f 6e d0	 movd	 xmm2, eax
  00976	f3 0f e6 d2	 cvtdq2pd xmm2, xmm2
  0097a	f2 0f 59 ca	 mulsd	 xmm1, xmm2
  0097e	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00982	66 0f 6e 8c 24
	9c 00 00 00	 movd	 xmm1, DWORD PTR outrate$[rsp]
  0098b	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0098f	f2 0f 5e c1	 divsd	 xmm0, xmm1
  00993	f2 0f 2c c0	 cvttsd2si eax, xmm0
  00997	89 84 24 98 00
	00 00		 mov	 DWORD PTR cur_o$[rsp], eax

; 1251 :                 if (size == 1)

  0099e	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR size$[rsp], 1
  009a6	75 13		 jne	 SHORT $LN7@audioop_ra

; 1252 :                     *CHARP(ncp, 0) = (signed char)(cur_o >> 24);

  009a8	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cur_o$[rsp]
  009af	c1 f8 18	 sar	 eax, 24
  009b2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ncp$[rsp]
  009b7	88 01		 mov	 BYTE PTR [rcx], al
  009b9	eb 36		 jmp	 SHORT $LN6@audioop_ra
$LN7@audioop_ra:

; 1253 :                 else if (size == 2)

  009bb	83 bc 24 88 00
	00 00 02	 cmp	 DWORD PTR size$[rsp], 2
  009c3	75 14		 jne	 SHORT $LN5@audioop_ra

; 1254 :                     *SHORTP(ncp, 0) = (short)(cur_o >> 16);

  009c5	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR cur_o$[rsp]
  009cc	c1 f8 10	 sar	 eax, 16
  009cf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ncp$[rsp]
  009d4	66 89 01	 mov	 WORD PTR [rcx], ax
  009d7	eb 18		 jmp	 SHORT $LN4@audioop_ra
$LN5@audioop_ra:

; 1255 :                 else if (size == 4)

  009d9	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR size$[rsp], 4
  009e1	75 0e		 jne	 SHORT $LN3@audioop_ra

; 1256 :                     *LONGP(ncp, 0) = (Py_Int32)(cur_o);

  009e3	48 8b 44 24 78	 mov	 rax, QWORD PTR ncp$[rsp]
  009e8	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR cur_o$[rsp]
  009ef	89 08		 mov	 DWORD PTR [rax], ecx
$LN3@audioop_ra:
$LN4@audioop_ra:
$LN6@audioop_ra:

; 1257 :                 ncp += size;

  009f1	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR size$[rsp]
  009f9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ncp$[rsp]
  009fe	48 03 c8	 add	 rcx, rax
  00a01	48 8b c1	 mov	 rax, rcx
  00a04	48 89 44 24 78	 mov	 QWORD PTR ncp$[rsp], rax

; 1258 :             }

  00a09	e9 f1 fe ff ff	 jmp	 $LN9@audioop_ra
$LN8@audioop_ra:

; 1259 :             d -= inrate;

  00a0e	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR inrate$[rsp]
  00a15	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  00a1c	2b c8		 sub	 ecx, eax
  00a1e	8b c1		 mov	 eax, ecx
  00a20	89 84 24 b8 00
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 1260 :         }

  00a27	e9 b8 fe ff ff	 jmp	 $LN12@audioop_ra
$LN11@audioop_ra:

; 1261 :     }

  00a2c	e9 88 fb ff ff	 jmp	 $LN31@audioop_ra
$exit$21291:

; 1262 :   exit:
; 1263 :     if (prev_i != NULL)

  00a31	48 83 7c 24 60
	00		 cmp	 QWORD PTR prev_i$[rsp], 0
  00a37	74 0b		 je	 SHORT $LN2@audioop_ra

; 1264 :         free(prev_i);

  00a39	48 8b 4c 24 60	 mov	 rcx, QWORD PTR prev_i$[rsp]
  00a3e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@audioop_ra:

; 1265 :     if (cur_i != NULL)

  00a44	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR cur_i$[rsp], 0
  00a4d	74 0e		 je	 SHORT $LN1@audioop_ra

; 1266 :         free(cur_i);

  00a4f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur_i$[rsp]
  00a57	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@audioop_ra:

; 1267 :     return rv;

  00a5d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN60@audioop_ra:

; 1268 : }

  00a65	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00a6c	c3		 ret	 0
audioop_ratecv ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\audioop.c
pdata	SEGMENT
$pdata$gcd DD	imagerel gcd
	DD	imagerel gcd+59
	DD	imagerel $unwind$gcd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gcd DD	010c01H
	DD	0220cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gcd
_TEXT	SEGMENT
tmp$21231 = 0
a$ = 32
b$ = 40
gcd	PROC						; COMDAT

; 1076 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24
$LN2@gcd:

; 1077 :     while (b > 0) {

  0000c	83 7c 24 28 00	 cmp	 DWORD PTR b$[rsp], 0
  00011	7e 1f		 jle	 SHORT $LN1@gcd

; 1078 :         int tmp = a % b;

  00013	8b 44 24 20	 mov	 eax, DWORD PTR a$[rsp]
  00017	99		 cdq
  00018	f7 7c 24 28	 idiv	 DWORD PTR b$[rsp]
  0001c	8b c2		 mov	 eax, edx
  0001e	89 04 24	 mov	 DWORD PTR tmp$21231[rsp], eax

; 1079 :         a = b;

  00021	8b 44 24 28	 mov	 eax, DWORD PTR b$[rsp]
  00025	89 44 24 20	 mov	 DWORD PTR a$[rsp], eax

; 1080 :         b = tmp;

  00029	8b 04 24	 mov	 eax, DWORD PTR tmp$21231[rsp]
  0002c	89 44 24 28	 mov	 DWORD PTR b$[rsp], eax

; 1081 :     }

  00030	eb da		 jmp	 SHORT $LN2@gcd
$LN1@gcd:

; 1082 :     return a;

  00032	8b 44 24 20	 mov	 eax, DWORD PTR a$[rsp]

; 1083 : }

  00036	48 83 c4 18	 add	 rsp, 24
  0003a	c3		 ret	 0
gcd	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@ECDDCLGP@s?$CDi?3lin2ulaw?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_lin2ulaw DD imagerel audioop_lin2ulaw
	DD	imagerel audioop_lin2ulaw+360
	DD	imagerel $unwind$audioop_lin2ulaw
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_lin2ulaw DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0N@ECDDCLGP@s?$CDi?3lin2ulaw?$AA@
CONST	SEGMENT
??_C@_0N@ECDDCLGP@s?$CDi?3lin2ulaw?$AA@ DB 's#i:lin2ulaw', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_lin2ulaw
_TEXT	SEGMENT
cp$ = 48
i$ = 56
ncp$ = 64
size$ = 72
len$ = 80
val$ = 88
rv$ = 96
tv76 = 104
self$ = 128
args$ = 136
audioop_lin2ulaw PROC					; COMDAT

; 1272 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1273 :     signed char *cp;
; 1274 :     unsigned char *ncp;
; 1275 :     Py_ssize_t len, i;
; 1276 :     int size, val = 0;

  0000e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 1277 :     PyObject *rv;
; 1278 : 
; 1279 :     if ( !PyArg_ParseTuple(args, "s#i:lin2ulaw",
; 1280 :                            &cp, &len, &size) )

  00016	48 8d 44 24 48	 lea	 rax, QWORD PTR size$[rsp]
  0001b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00020	4c 8d 4c 24 50	 lea	 r9, QWORD PTR len$[rsp]
  00025	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@ECDDCLGP@s?$CDi?3lin2ulaw?$AA@
  00031	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00039	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003e	85 c0		 test	 eax, eax
  00040	75 07		 jne	 SHORT $LN11@audioop_li@2

; 1281 :         return 0 ;

  00042	33 c0		 xor	 eax, eax
  00044	e9 1a 01 00 00	 jmp	 $LN12@audioop_li@2
$LN11@audioop_li@2:

; 1282 : 
; 1283 :     if (!audioop_check_parameters(len, size))

  00049	8b 54 24 48	 mov	 edx, DWORD PTR size$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  00052	e8 00 00 00 00	 call	 audioop_check_parameters
  00057	85 c0		 test	 eax, eax
  00059	75 07		 jne	 SHORT $LN10@audioop_li@2

; 1284 :         return NULL;

  0005b	33 c0		 xor	 eax, eax
  0005d	e9 01 01 00 00	 jmp	 $LN12@audioop_li@2
$LN10@audioop_li@2:

; 1285 : 
; 1286 :     rv = PyBytes_FromStringAndSize(NULL, len/size);

  00062	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  00067	48 89 44 24 68	 mov	 QWORD PTR tv76[rsp], rax
  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00071	48 99		 cdq
  00073	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv76[rsp]
  00078	48 f7 f9	 idiv	 rcx
  0007b	48 8b d0	 mov	 rdx, rax
  0007e	33 c9		 xor	 ecx, ecx
  00080	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00085	48 89 44 24 60	 mov	 QWORD PTR rv$[rsp], rax

; 1287 :     if ( rv == 0 )

  0008a	48 83 7c 24 60
	00		 cmp	 QWORD PTR rv$[rsp], 0
  00090	75 07		 jne	 SHORT $LN9@audioop_li@2

; 1288 :         return 0;

  00092	33 c0		 xor	 eax, eax
  00094	e9 ca 00 00 00	 jmp	 $LN12@audioop_li@2
$LN9@audioop_li@2:

; 1289 :     ncp = (unsigned char *)PyBytes_AsString(rv);

  00099	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rv$[rsp]
  0009e	e8 00 00 00 00	 call	 PyBytes_AsString
  000a3	48 89 44 24 40	 mov	 QWORD PTR ncp$[rsp], rax

; 1290 : 
; 1291 :     for ( i=0; i < len; i += size ) {

  000a8	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000b1	eb 15		 jmp	 SHORT $LN8@audioop_li@2
$LN7@audioop_li@2:
  000b3	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  000b8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000bd	48 03 c8	 add	 rcx, rax
  000c0	48 8b c1	 mov	 rax, rcx
  000c3	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN8@audioop_li@2:
  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  000cd	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  000d2	0f 8d 86 00 00
	00		 jge	 $LN6@audioop_li@2

; 1292 :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 8;

  000d8	83 7c 24 48 01	 cmp	 DWORD PTR size$[rsp], 1
  000dd	75 1c		 jne	 SHORT $LN5@audioop_li@2
  000df	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000e4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000e9	48 03 c8	 add	 rcx, rax
  000ec	48 8b c1	 mov	 rax, rcx
  000ef	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f2	c1 e0 08	 shl	 eax, 8
  000f5	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  000f9	eb 40		 jmp	 SHORT $LN4@audioop_li@2
$LN5@audioop_li@2:

; 1293 :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  000fb	83 7c 24 48 02	 cmp	 DWORD PTR size$[rsp], 2
  00100	75 19		 jne	 SHORT $LN3@audioop_li@2
  00102	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00107	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  0010c	48 03 c8	 add	 rcx, rax
  0010f	48 8b c1	 mov	 rax, rcx
  00112	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00115	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  00119	eb 20		 jmp	 SHORT $LN2@audioop_li@2
$LN3@audioop_li@2:

; 1294 :         else if ( size == 4 ) val = ((int)*LONGP(cp, i)) >> 16;

  0011b	83 7c 24 48 04	 cmp	 DWORD PTR size$[rsp], 4
  00120	75 19		 jne	 SHORT $LN1@audioop_li@2
  00122	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00127	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  0012c	48 03 c8	 add	 rcx, rax
  0012f	48 8b c1	 mov	 rax, rcx
  00132	8b 00		 mov	 eax, DWORD PTR [rax]
  00134	c1 f8 10	 sar	 eax, 16
  00137	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
$LN1@audioop_li@2:
$LN2@audioop_li@2:
$LN4@audioop_li@2:

; 1295 : 
; 1296 :         *ncp++ = st_14linear2ulaw(val);

  0013b	0f b7 4c 24 58	 movzx	 ecx, WORD PTR val$[rsp]
  00140	e8 00 00 00 00	 call	 st_14linear2ulaw
  00145	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ncp$[rsp]
  0014a	88 01		 mov	 BYTE PTR [rcx], al
  0014c	48 8b 44 24 40	 mov	 rax, QWORD PTR ncp$[rsp]
  00151	48 ff c0	 inc	 rax
  00154	48 89 44 24 40	 mov	 QWORD PTR ncp$[rsp], rax

; 1297 :     }

  00159	e9 55 ff ff ff	 jmp	 $LN7@audioop_li@2
$LN6@audioop_li@2:

; 1298 :     return rv;

  0015e	48 8b 44 24 60	 mov	 rax, QWORD PTR rv$[rsp]
$LN12@audioop_li@2:

; 1299 : }

  00163	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00167	c3		 ret	 0
audioop_lin2ulaw ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$st_14linear2ulaw DD imagerel st_14linear2ulaw
	DD	imagerel st_14linear2ulaw+214
	DD	imagerel $unwind$st_14linear2ulaw
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$st_14linear2ulaw DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT st_14linear2ulaw
_TEXT	SEGMENT
uval$ = 32
mask$ = 36
seg$ = 40
tv90 = 44
pcm_val$ = 64
st_14linear2ulaw PROC					; COMDAT

; 159  : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 160  :     PyInt16         mask;
; 161  :     PyInt16         seg;
; 162  :     unsigned char   uval;
; 163  : 
; 164  :     /* The original sox code does this in the calling function, not here */
; 165  :     pcm_val = pcm_val >> 2;

  00009	0f bf 44 24 40	 movsx	 eax, WORD PTR pcm_val$[rsp]
  0000e	c1 f8 02	 sar	 eax, 2
  00011	66 89 44 24 40	 mov	 WORD PTR pcm_val$[rsp], ax

; 166  : 
; 167  :     /* u-law inverts all bits */
; 168  :     /* Get the sign and the magnitude of the value. */
; 169  :     if (pcm_val < 0) {

  00016	0f bf 44 24 40	 movsx	 eax, WORD PTR pcm_val$[rsp]
  0001b	85 c0		 test	 eax, eax
  0001d	7d 18		 jge	 SHORT $LN5@st_14linea

; 170  :         pcm_val = -pcm_val;

  0001f	0f bf 44 24 40	 movsx	 eax, WORD PTR pcm_val$[rsp]
  00024	f7 d8		 neg	 eax
  00026	66 89 44 24 40	 mov	 WORD PTR pcm_val$[rsp], ax

; 171  :         mask = 0x7F;

  0002b	b8 7f 00 00 00	 mov	 eax, 127		; 0000007fH
  00030	66 89 44 24 24	 mov	 WORD PTR mask$[rsp], ax

; 172  :     } else {

  00035	eb 0a		 jmp	 SHORT $LN4@st_14linea
$LN5@st_14linea:

; 173  :         mask = 0xFF;

  00037	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0003c	66 89 44 24 24	 mov	 WORD PTR mask$[rsp], ax
$LN4@st_14linea:

; 174  :     }
; 175  :     if ( pcm_val > CLIP ) pcm_val = CLIP;           /* clip the magnitude */

  00041	0f bf 44 24 40	 movsx	 eax, WORD PTR pcm_val$[rsp]
  00046	3d 7b 7f 00 00	 cmp	 eax, 32635		; 00007f7bH
  0004b	7e 0a		 jle	 SHORT $LN3@st_14linea
  0004d	b8 7b 7f 00 00	 mov	 eax, 32635		; 00007f7bH
  00052	66 89 44 24 40	 mov	 WORD PTR pcm_val$[rsp], ax
$LN3@st_14linea:

; 176  :     pcm_val += (BIAS >> 2);

  00057	0f bf 44 24 40	 movsx	 eax, WORD PTR pcm_val$[rsp]
  0005c	83 c0 21	 add	 eax, 33			; 00000021H
  0005f	66 89 44 24 40	 mov	 WORD PTR pcm_val$[rsp], ax

; 177  : 
; 178  :     /* Convert the scaled magnitude to segment number. */
; 179  :     seg = search(pcm_val, seg_uend, 8);

  00064	41 b8 08 00 00
	00		 mov	 r8d, 8
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:seg_uend
  00071	0f b7 4c 24 40	 movzx	 ecx, WORD PTR pcm_val$[rsp]
  00076	e8 00 00 00 00	 call	 search
  0007b	66 89 44 24 28	 mov	 WORD PTR seg$[rsp], ax

; 180  : 
; 181  :     /*
; 182  :      * Combine the sign, segment, quantization bits;
; 183  :      * and complement the code word.
; 184  :      */
; 185  :     if (seg >= 8)           /* out of range, return maximum value. */

  00080	0f bf 44 24 28	 movsx	 eax, WORD PTR seg$[rsp]
  00085	83 f8 08	 cmp	 eax, 8
  00088	7c 0c		 jl	 SHORT $LN2@st_14linea

; 186  :         return (unsigned char) (0x7F ^ mask);

  0008a	0f bf 44 24 24	 movsx	 eax, WORD PTR mask$[rsp]
  0008f	83 f0 7f	 xor	 eax, 127		; 0000007fH
  00092	eb 3d		 jmp	 SHORT $LN6@st_14linea

; 187  :     else {

  00094	eb 3b		 jmp	 SHORT $LN1@st_14linea
$LN2@st_14linea:

; 188  :         uval = (unsigned char) (seg << 4) | ((pcm_val >> (seg + 1)) & 0xF);

  00096	0f bf 44 24 28	 movsx	 eax, WORD PTR seg$[rsp]
  0009b	c1 e0 04	 shl	 eax, 4
  0009e	0f b6 c0	 movzx	 eax, al
  000a1	0f bf 4c 24 40	 movsx	 ecx, WORD PTR pcm_val$[rsp]
  000a6	89 4c 24 2c	 mov	 DWORD PTR tv90[rsp], ecx
  000aa	0f bf 54 24 28	 movsx	 edx, WORD PTR seg$[rsp]
  000af	ff c2		 inc	 edx
  000b1	0f b6 ca	 movzx	 ecx, dl
  000b4	8b 54 24 2c	 mov	 edx, DWORD PTR tv90[rsp]
  000b8	d3 fa		 sar	 edx, cl
  000ba	8b ca		 mov	 ecx, edx
  000bc	83 e1 0f	 and	 ecx, 15
  000bf	0b c1		 or	 eax, ecx
  000c1	88 44 24 20	 mov	 BYTE PTR uval$[rsp], al

; 189  :         return (uval ^ mask);

  000c5	0f b6 44 24 20	 movzx	 eax, BYTE PTR uval$[rsp]
  000ca	0f bf 4c 24 24	 movsx	 ecx, WORD PTR mask$[rsp]
  000cf	33 c1		 xor	 eax, ecx
$LN1@st_14linea:
$LN6@st_14linea:

; 190  :     }
; 191  : 
; 192  : }

  000d1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d5	c3		 ret	 0
st_14linear2ulaw ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$search DD imagerel search
	DD	imagerel search+94
	DD	imagerel $unwind$search
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$search DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT search
_TEXT	SEGMENT
i$ = 0
val$ = 32
table$ = 40
size$ = 48
search	PROC						; COMDAT

; 73   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 74   :     int i;
; 75   : 
; 76   :     for (i = 0; i < size; i++) {

  00013	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 08		 jmp	 SHORT $LN4@search
$LN3@search:
  0001c	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001f	ff c0		 inc	 eax
  00021	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@search:
  00024	8b 44 24 30	 mov	 eax, DWORD PTR size$[rsp]
  00028	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0002b	7d 27		 jge	 SHORT $LN2@search

; 77   :         if (val <= *table++)

  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR table$[rsp]
  00032	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00035	0f bf 4c 24 20	 movsx	 ecx, WORD PTR val$[rsp]
  0003a	48 8b 54 24 28	 mov	 rdx, QWORD PTR table$[rsp]
  0003f	48 83 c2 02	 add	 rdx, 2
  00043	48 89 54 24 28	 mov	 QWORD PTR table$[rsp], rdx
  00048	3b c8		 cmp	 ecx, eax
  0004a	7f 06		 jg	 SHORT $LN1@search

; 78   :             return (i);

  0004c	0f b7 04 24	 movzx	 eax, WORD PTR i$[rsp]
  00050	eb 07		 jmp	 SHORT $LN5@search
$LN1@search:

; 79   :     }

  00052	eb c8		 jmp	 SHORT $LN3@search
$LN2@search:

; 80   :     return (size);

  00054	0f b7 44 24 30	 movzx	 eax, WORD PTR size$[rsp]
$LN5@search:

; 81   : }

  00059	48 83 c4 18	 add	 rsp, 24
  0005d	c3		 ret	 0
search	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NMKNEGOO@s?$CDi?3ulaw2lin?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_ulaw2lin DD imagerel audioop_ulaw2lin
	DD	imagerel audioop_ulaw2lin+438
	DD	imagerel $unwind$audioop_ulaw2lin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_ulaw2lin DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_0N@NMKNEGOO@s?$CDi?3ulaw2lin?$AA@
CONST	SEGMENT
??_C@_0N@NMKNEGOO@s?$CDi?3ulaw2lin?$AA@ DB 's#i:ulaw2lin', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_ulaw2lin
_TEXT	SEGMENT
cp$ = 48
i$ = 56
ncp$ = 64
size$ = 72
len$ = 80
val$ = 88
rv$ = 96
cval$ = 104
tv74 = 112
self$ = 144
args$ = 152
audioop_ulaw2lin PROC					; COMDAT

; 1303 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1304 :     unsigned char *cp;
; 1305 :     unsigned char cval;
; 1306 :     signed char *ncp;
; 1307 :     Py_ssize_t len, i;
; 1308 :     int size, val;
; 1309 :     PyObject *rv;
; 1310 : 
; 1311 :     if ( !PyArg_ParseTuple(args, "s#i:ulaw2lin",
; 1312 :                            &cp, &len, &size) )

  00011	48 8d 44 24 48	 lea	 rax, QWORD PTR size$[rsp]
  00016	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001b	4c 8d 4c 24 50	 lea	 r9, QWORD PTR len$[rsp]
  00020	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NMKNEGOO@s?$CDi?3ulaw2lin?$AA@
  0002c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00034	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00039	85 c0		 test	 eax, eax
  0003b	75 07		 jne	 SHORT $LN12@audioop_ul

; 1313 :         return 0;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 6a 01 00 00	 jmp	 $LN13@audioop_ul
$LN12@audioop_ul:

; 1314 : 
; 1315 :     if (!audioop_check_size(size))

  00044	8b 4c 24 48	 mov	 ecx, DWORD PTR size$[rsp]
  00048	e8 00 00 00 00	 call	 audioop_check_size
  0004d	85 c0		 test	 eax, eax
  0004f	75 07		 jne	 SHORT $LN11@audioop_ul

; 1316 :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	e9 56 01 00 00	 jmp	 $LN13@audioop_ul
$LN11@audioop_ul:

; 1317 : 
; 1318 :     if (len > PY_SSIZE_T_MAX/size) {

  00058	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  0005d	48 89 44 24 70	 mov	 QWORD PTR tv74[rsp], rax
  00062	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0006c	48 8b c1	 mov	 rax, rcx
  0006f	48 99		 cdq
  00071	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv74[rsp]
  00076	48 f7 f9	 idiv	 rcx
  00079	48 39 44 24 50	 cmp	 QWORD PTR len$[rsp], rax
  0007e	7e 1a		 jle	 SHORT $LN10@audioop_ul

; 1319 :         PyErr_SetString(PyExc_MemoryError,
; 1320 :                         "not enough memory for output buffer");

  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  0008e	e8 00 00 00 00	 call	 PyErr_SetString

; 1321 :         return 0;

  00093	33 c0		 xor	 eax, eax
  00095	e9 14 01 00 00	 jmp	 $LN13@audioop_ul
$LN10@audioop_ul:

; 1322 :     }
; 1323 :     rv = PyBytes_FromStringAndSize(NULL, len*size);

  0009a	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  000a4	48 0f af c8	 imul	 rcx, rax
  000a8	48 8b c1	 mov	 rax, rcx
  000ab	48 8b d0	 mov	 rdx, rax
  000ae	33 c9		 xor	 ecx, ecx
  000b0	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000b5	48 89 44 24 60	 mov	 QWORD PTR rv$[rsp], rax

; 1324 :     if ( rv == 0 )

  000ba	48 83 7c 24 60
	00		 cmp	 QWORD PTR rv$[rsp], 0
  000c0	75 07		 jne	 SHORT $LN9@audioop_ul

; 1325 :         return 0;

  000c2	33 c0		 xor	 eax, eax
  000c4	e9 e5 00 00 00	 jmp	 $LN13@audioop_ul
$LN9@audioop_ul:

; 1326 :     ncp = (signed char *)PyBytes_AsString(rv);

  000c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rv$[rsp]
  000ce	e8 00 00 00 00	 call	 PyBytes_AsString
  000d3	48 89 44 24 40	 mov	 QWORD PTR ncp$[rsp], rax

; 1327 : 
; 1328 :     for ( i=0; i < len*size; i += size ) {

  000d8	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000e1	eb 15		 jmp	 SHORT $LN8@audioop_ul
$LN7@audioop_ul:
  000e3	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  000e8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000ed	48 03 c8	 add	 rcx, rax
  000f0	48 8b c1	 mov	 rax, rcx
  000f3	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN8@audioop_ul:
  000f8	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  000fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  00102	48 0f af c8	 imul	 rcx, rax
  00106	48 8b c1	 mov	 rax, rcx
  00109	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  0010e	0f 8d 95 00 00
	00		 jge	 $LN6@audioop_ul

; 1329 :         cval = *cp++;

  00114	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  00119	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0011c	88 44 24 68	 mov	 BYTE PTR cval$[rsp], al
  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  00125	48 ff c0	 inc	 rax
  00128	48 89 44 24 30	 mov	 QWORD PTR cp$[rsp], rax

; 1330 :         val = st_ulaw2linear16(cval);

  0012d	0f b6 44 24 68	 movzx	 eax, BYTE PTR cval$[rsp]
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_st_ulaw2linear16
  00139	0f bf 04 41	 movsx	 eax, WORD PTR [rcx+rax*2]
  0013d	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax

; 1331 : 
; 1332 :         if ( size == 1 )      *CHARP(ncp, i) = (signed char)(val >> 8);

  00141	83 7c 24 48 01	 cmp	 DWORD PTR size$[rsp], 1
  00146	75 1b		 jne	 SHORT $LN5@audioop_ul
  00148	8b 44 24 58	 mov	 eax, DWORD PTR val$[rsp]
  0014c	c1 f8 08	 sar	 eax, 8
  0014f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00154	48 8b 54 24 40	 mov	 rdx, QWORD PTR ncp$[rsp]
  00159	48 03 d1	 add	 rdx, rcx
  0015c	48 8b ca	 mov	 rcx, rdx
  0015f	88 01		 mov	 BYTE PTR [rcx], al
  00161	eb 41		 jmp	 SHORT $LN4@audioop_ul
$LN5@audioop_ul:

; 1333 :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)(val);

  00163	83 7c 24 48 02	 cmp	 DWORD PTR size$[rsp], 2
  00168	75 1a		 jne	 SHORT $LN3@audioop_ul
  0016a	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0016f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ncp$[rsp]
  00174	48 03 c8	 add	 rcx, rax
  00177	48 8b c1	 mov	 rax, rcx
  0017a	0f b7 4c 24 58	 movzx	 ecx, WORD PTR val$[rsp]
  0017f	66 89 08	 mov	 WORD PTR [rax], cx
  00182	eb 20		 jmp	 SHORT $LN2@audioop_ul
$LN3@audioop_ul:

; 1334 :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)(val<<16);

  00184	83 7c 24 48 04	 cmp	 DWORD PTR size$[rsp], 4
  00189	75 19		 jne	 SHORT $LN1@audioop_ul
  0018b	8b 44 24 58	 mov	 eax, DWORD PTR val$[rsp]
  0018f	c1 e0 10	 shl	 eax, 16
  00192	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00197	48 8b 54 24 40	 mov	 rdx, QWORD PTR ncp$[rsp]
  0019c	48 03 d1	 add	 rdx, rcx
  0019f	48 8b ca	 mov	 rcx, rdx
  001a2	89 01		 mov	 DWORD PTR [rcx], eax
$LN1@audioop_ul:
$LN2@audioop_ul:
$LN4@audioop_ul:

; 1335 :     }

  001a4	e9 3a ff ff ff	 jmp	 $LN7@audioop_ul
$LN6@audioop_ul:

; 1336 :     return rv;

  001a9	48 8b 44 24 60	 mov	 rax, QWORD PTR rv$[rsp]
$LN13@audioop_ul:

; 1337 : }

  001ae	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001b5	c3		 ret	 0
audioop_ulaw2lin ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NHFDBKCN@s?$CDi?3lin2alaw?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_lin2alaw DD imagerel audioop_lin2alaw
	DD	imagerel audioop_lin2alaw+360
	DD	imagerel $unwind$audioop_lin2alaw
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_lin2alaw DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0N@NHFDBKCN@s?$CDi?3lin2alaw?$AA@
CONST	SEGMENT
??_C@_0N@NHFDBKCN@s?$CDi?3lin2alaw?$AA@ DB 's#i:lin2alaw', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_lin2alaw
_TEXT	SEGMENT
cp$ = 48
i$ = 56
ncp$ = 64
size$ = 72
len$ = 80
val$ = 88
rv$ = 96
tv76 = 104
self$ = 128
args$ = 136
audioop_lin2alaw PROC					; COMDAT

; 1341 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1342 :     signed char *cp;
; 1343 :     unsigned char *ncp;
; 1344 :     Py_ssize_t len, i;
; 1345 :     int size, val = 0;

  0000e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 1346 :     PyObject *rv;
; 1347 : 
; 1348 :     if ( !PyArg_ParseTuple(args, "s#i:lin2alaw",
; 1349 :                            &cp, &len, &size) )

  00016	48 8d 44 24 48	 lea	 rax, QWORD PTR size$[rsp]
  0001b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00020	4c 8d 4c 24 50	 lea	 r9, QWORD PTR len$[rsp]
  00025	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NHFDBKCN@s?$CDi?3lin2alaw?$AA@
  00031	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00039	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003e	85 c0		 test	 eax, eax
  00040	75 07		 jne	 SHORT $LN11@audioop_li@3

; 1350 :         return 0;

  00042	33 c0		 xor	 eax, eax
  00044	e9 1a 01 00 00	 jmp	 $LN12@audioop_li@3
$LN11@audioop_li@3:

; 1351 : 
; 1352 :     if (!audioop_check_parameters(len, size))

  00049	8b 54 24 48	 mov	 edx, DWORD PTR size$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  00052	e8 00 00 00 00	 call	 audioop_check_parameters
  00057	85 c0		 test	 eax, eax
  00059	75 07		 jne	 SHORT $LN10@audioop_li@3

; 1353 :         return NULL;

  0005b	33 c0		 xor	 eax, eax
  0005d	e9 01 01 00 00	 jmp	 $LN12@audioop_li@3
$LN10@audioop_li@3:

; 1354 : 
; 1355 :     rv = PyBytes_FromStringAndSize(NULL, len/size);

  00062	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  00067	48 89 44 24 68	 mov	 QWORD PTR tv76[rsp], rax
  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00071	48 99		 cdq
  00073	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv76[rsp]
  00078	48 f7 f9	 idiv	 rcx
  0007b	48 8b d0	 mov	 rdx, rax
  0007e	33 c9		 xor	 ecx, ecx
  00080	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00085	48 89 44 24 60	 mov	 QWORD PTR rv$[rsp], rax

; 1356 :     if ( rv == 0 )

  0008a	48 83 7c 24 60
	00		 cmp	 QWORD PTR rv$[rsp], 0
  00090	75 07		 jne	 SHORT $LN9@audioop_li@3

; 1357 :         return 0;

  00092	33 c0		 xor	 eax, eax
  00094	e9 ca 00 00 00	 jmp	 $LN12@audioop_li@3
$LN9@audioop_li@3:

; 1358 :     ncp = (unsigned char *)PyBytes_AsString(rv);

  00099	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rv$[rsp]
  0009e	e8 00 00 00 00	 call	 PyBytes_AsString
  000a3	48 89 44 24 40	 mov	 QWORD PTR ncp$[rsp], rax

; 1359 : 
; 1360 :     for ( i=0; i < len; i += size ) {

  000a8	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000b1	eb 15		 jmp	 SHORT $LN8@audioop_li@3
$LN7@audioop_li@3:
  000b3	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  000b8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000bd	48 03 c8	 add	 rcx, rax
  000c0	48 8b c1	 mov	 rax, rcx
  000c3	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN8@audioop_li@3:
  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  000cd	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  000d2	0f 8d 86 00 00
	00		 jge	 $LN6@audioop_li@3

; 1361 :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 8;

  000d8	83 7c 24 48 01	 cmp	 DWORD PTR size$[rsp], 1
  000dd	75 1c		 jne	 SHORT $LN5@audioop_li@3
  000df	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000e4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  000e9	48 03 c8	 add	 rcx, rax
  000ec	48 8b c1	 mov	 rax, rcx
  000ef	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f2	c1 e0 08	 shl	 eax, 8
  000f5	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  000f9	eb 40		 jmp	 SHORT $LN4@audioop_li@3
$LN5@audioop_li@3:

; 1362 :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  000fb	83 7c 24 48 02	 cmp	 DWORD PTR size$[rsp], 2
  00100	75 19		 jne	 SHORT $LN3@audioop_li@3
  00102	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00107	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  0010c	48 03 c8	 add	 rcx, rax
  0010f	48 8b c1	 mov	 rax, rcx
  00112	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00115	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
  00119	eb 20		 jmp	 SHORT $LN2@audioop_li@3
$LN3@audioop_li@3:

; 1363 :         else if ( size == 4 ) val = ((int)*LONGP(cp, i)) >> 16;

  0011b	83 7c 24 48 04	 cmp	 DWORD PTR size$[rsp], 4
  00120	75 19		 jne	 SHORT $LN1@audioop_li@3
  00122	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00127	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cp$[rsp]
  0012c	48 03 c8	 add	 rcx, rax
  0012f	48 8b c1	 mov	 rax, rcx
  00132	8b 00		 mov	 eax, DWORD PTR [rax]
  00134	c1 f8 10	 sar	 eax, 16
  00137	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax
$LN1@audioop_li@3:
$LN2@audioop_li@3:
$LN4@audioop_li@3:

; 1364 : 
; 1365 :         *ncp++ = st_linear2alaw(val);

  0013b	0f b7 4c 24 58	 movzx	 ecx, WORD PTR val$[rsp]
  00140	e8 00 00 00 00	 call	 st_linear2alaw
  00145	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ncp$[rsp]
  0014a	88 01		 mov	 BYTE PTR [rcx], al
  0014c	48 8b 44 24 40	 mov	 rax, QWORD PTR ncp$[rsp]
  00151	48 ff c0	 inc	 rax
  00154	48 89 44 24 40	 mov	 QWORD PTR ncp$[rsp], rax

; 1366 :     }

  00159	e9 55 ff ff ff	 jmp	 $LN7@audioop_li@3
$LN6@audioop_li@3:

; 1367 :     return rv;

  0015e	48 8b 44 24 60	 mov	 rax, QWORD PTR rv$[rsp]
$LN12@audioop_li@3:

; 1368 : }

  00163	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00167	c3		 ret	 0
audioop_lin2alaw ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$st_linear2alaw DD imagerel st_linear2alaw
	DD	imagerel st_linear2alaw+209
	DD	imagerel $unwind$st_linear2alaw
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$st_linear2alaw DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT st_linear2alaw
_TEXT	SEGMENT
aval$ = 32
mask$ = 36
seg$ = 40
pcm_val$ = 64
st_linear2alaw PROC					; COMDAT

; 256  : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 257  :     PyInt16         mask;
; 258  :     short           seg;
; 259  :     unsigned char   aval;
; 260  : 
; 261  :     /* The original sox code does this in the calling function, not here */
; 262  :     pcm_val = pcm_val >> 3;

  00009	0f bf 44 24 40	 movsx	 eax, WORD PTR pcm_val$[rsp]
  0000e	c1 f8 03	 sar	 eax, 3
  00011	66 89 44 24 40	 mov	 WORD PTR pcm_val$[rsp], ax

; 263  : 
; 264  :     /* A-law using even bit inversion */
; 265  :     if (pcm_val >= 0) {

  00016	0f bf 44 24 40	 movsx	 eax, WORD PTR pcm_val$[rsp]
  0001b	85 c0		 test	 eax, eax
  0001d	7c 0c		 jl	 SHORT $LN6@st_linear2

; 266  :         mask = 0xD5;            /* sign (7th) bit = 1 */

  0001f	b8 d5 00 00 00	 mov	 eax, 213		; 000000d5H
  00024	66 89 44 24 24	 mov	 WORD PTR mask$[rsp], ax

; 267  :     } else {

  00029	eb 18		 jmp	 SHORT $LN5@st_linear2
$LN6@st_linear2:

; 268  :         mask = 0x55;            /* sign bit = 0 */

  0002b	b8 55 00 00 00	 mov	 eax, 85			; 00000055H
  00030	66 89 44 24 24	 mov	 WORD PTR mask$[rsp], ax

; 269  :         pcm_val = -pcm_val - 1;

  00035	0f bf 44 24 40	 movsx	 eax, WORD PTR pcm_val$[rsp]
  0003a	f7 d8		 neg	 eax
  0003c	ff c8		 dec	 eax
  0003e	66 89 44 24 40	 mov	 WORD PTR pcm_val$[rsp], ax
$LN5@st_linear2:

; 270  :     }
; 271  : 
; 272  :     /* Convert the scaled magnitude to segment number. */
; 273  :     seg = search(pcm_val, seg_aend, 8);

  00043	41 b8 08 00 00
	00		 mov	 r8d, 8
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:seg_aend
  00050	0f b7 4c 24 40	 movzx	 ecx, WORD PTR pcm_val$[rsp]
  00055	e8 00 00 00 00	 call	 search
  0005a	66 89 44 24 28	 mov	 WORD PTR seg$[rsp], ax

; 274  : 
; 275  :     /* Combine the sign, segment, and quantization bits. */
; 276  : 
; 277  :     if (seg >= 8)           /* out of range, return maximum value. */

  0005f	0f bf 44 24 28	 movsx	 eax, WORD PTR seg$[rsp]
  00064	83 f8 08	 cmp	 eax, 8
  00067	7c 0c		 jl	 SHORT $LN4@st_linear2

; 278  :         return (unsigned char) (0x7F ^ mask);

  00069	0f bf 44 24 24	 movsx	 eax, WORD PTR mask$[rsp]
  0006e	83 f0 7f	 xor	 eax, 127		; 0000007fH
  00071	eb 59		 jmp	 SHORT $LN7@st_linear2

; 279  :     else {

  00073	eb 57		 jmp	 SHORT $LN3@st_linear2
$LN4@st_linear2:

; 280  :         aval = (unsigned char) seg << SEG_SHIFT;

  00075	0f b6 44 24 28	 movzx	 eax, BYTE PTR seg$[rsp]
  0007a	c1 e0 04	 shl	 eax, 4
  0007d	88 44 24 20	 mov	 BYTE PTR aval$[rsp], al

; 281  :         if (seg < 2)

  00081	0f bf 44 24 28	 movsx	 eax, WORD PTR seg$[rsp]
  00086	83 f8 02	 cmp	 eax, 2
  00089	7d 19		 jge	 SHORT $LN2@st_linear2

; 282  :             aval |= (pcm_val >> 1) & QUANT_MASK;

  0008b	0f bf 44 24 40	 movsx	 eax, WORD PTR pcm_val$[rsp]
  00090	d1 f8		 sar	 eax, 1
  00092	83 e0 0f	 and	 eax, 15
  00095	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR aval$[rsp]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	88 44 24 20	 mov	 BYTE PTR aval$[rsp], al

; 283  :         else

  000a2	eb 1c		 jmp	 SHORT $LN1@st_linear2
$LN2@st_linear2:

; 284  :             aval |= (pcm_val >> seg) & QUANT_MASK;

  000a4	0f bf 44 24 40	 movsx	 eax, WORD PTR pcm_val$[rsp]
  000a9	0f bf 4c 24 28	 movsx	 ecx, WORD PTR seg$[rsp]
  000ae	d3 f8		 sar	 eax, cl
  000b0	83 e0 0f	 and	 eax, 15
  000b3	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR aval$[rsp]
  000b8	0b c8		 or	 ecx, eax
  000ba	8b c1		 mov	 eax, ecx
  000bc	88 44 24 20	 mov	 BYTE PTR aval$[rsp], al
$LN1@st_linear2:

; 285  :         return (aval ^ mask);

  000c0	0f b6 44 24 20	 movzx	 eax, BYTE PTR aval$[rsp]
  000c5	0f bf 4c 24 24	 movsx	 ecx, WORD PTR mask$[rsp]
  000ca	33 c1		 xor	 eax, ecx
$LN3@st_linear2:
$LN7@st_linear2:

; 286  :     }
; 287  : }

  000cc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d0	c3		 ret	 0
st_linear2alaw ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@CNIBFFJD@s?$CDi?3alaw2lin?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_alaw2lin DD imagerel audioop_alaw2lin
	DD	imagerel audioop_alaw2lin+438
	DD	imagerel $unwind$audioop_alaw2lin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_alaw2lin DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_0N@CNIBFFJD@s?$CDi?3alaw2lin?$AA@
CONST	SEGMENT
??_C@_0N@CNIBFFJD@s?$CDi?3alaw2lin?$AA@ DB 's#i:alaw2lin', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_alaw2lin
_TEXT	SEGMENT
cp$ = 48
i$ = 56
ncp$ = 64
size$ = 72
len$ = 80
val$ = 88
rv$ = 96
cval$ = 104
tv74 = 112
self$ = 144
args$ = 152
audioop_alaw2lin PROC					; COMDAT

; 1372 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1373 :     unsigned char *cp;
; 1374 :     unsigned char cval;
; 1375 :     signed char *ncp;
; 1376 :     Py_ssize_t len, i;
; 1377 :     int size, val;
; 1378 :     PyObject *rv;
; 1379 : 
; 1380 :     if ( !PyArg_ParseTuple(args, "s#i:alaw2lin",
; 1381 :                            &cp, &len, &size) )

  00011	48 8d 44 24 48	 lea	 rax, QWORD PTR size$[rsp]
  00016	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001b	4c 8d 4c 24 50	 lea	 r9, QWORD PTR len$[rsp]
  00020	4c 8d 44 24 30	 lea	 r8, QWORD PTR cp$[rsp]
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@CNIBFFJD@s?$CDi?3alaw2lin?$AA@
  0002c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00034	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00039	85 c0		 test	 eax, eax
  0003b	75 07		 jne	 SHORT $LN12@audioop_al

; 1382 :         return 0;

  0003d	33 c0		 xor	 eax, eax
  0003f	e9 6a 01 00 00	 jmp	 $LN13@audioop_al
$LN12@audioop_al:

; 1383 : 
; 1384 :     if (!audioop_check_size(size))

  00044	8b 4c 24 48	 mov	 ecx, DWORD PTR size$[rsp]
  00048	e8 00 00 00 00	 call	 audioop_check_size
  0004d	85 c0		 test	 eax, eax
  0004f	75 07		 jne	 SHORT $LN11@audioop_al

; 1385 :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	e9 56 01 00 00	 jmp	 $LN13@audioop_al
$LN11@audioop_al:

; 1386 : 
; 1387 :     if (len > PY_SSIZE_T_MAX/size) {

  00058	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  0005d	48 89 44 24 70	 mov	 QWORD PTR tv74[rsp], rax
  00062	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0006c	48 8b c1	 mov	 rax, rcx
  0006f	48 99		 cdq
  00071	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv74[rsp]
  00076	48 f7 f9	 idiv	 rcx
  00079	48 39 44 24 50	 cmp	 QWORD PTR len$[rsp], rax
  0007e	7e 1a		 jle	 SHORT $LN10@audioop_al

; 1388 :         PyErr_SetString(PyExc_MemoryError,
; 1389 :                         "not enough memory for output buffer");

  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  0008e	e8 00 00 00 00	 call	 PyErr_SetString

; 1390 :         return 0;

  00093	33 c0		 xor	 eax, eax
  00095	e9 14 01 00 00	 jmp	 $LN13@audioop_al
$LN10@audioop_al:

; 1391 :     }
; 1392 :     rv = PyBytes_FromStringAndSize(NULL, len*size);

  0009a	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  000a4	48 0f af c8	 imul	 rcx, rax
  000a8	48 8b c1	 mov	 rax, rcx
  000ab	48 8b d0	 mov	 rdx, rax
  000ae	33 c9		 xor	 ecx, ecx
  000b0	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000b5	48 89 44 24 60	 mov	 QWORD PTR rv$[rsp], rax

; 1393 :     if ( rv == 0 )

  000ba	48 83 7c 24 60
	00		 cmp	 QWORD PTR rv$[rsp], 0
  000c0	75 07		 jne	 SHORT $LN9@audioop_al

; 1394 :         return 0;

  000c2	33 c0		 xor	 eax, eax
  000c4	e9 e5 00 00 00	 jmp	 $LN13@audioop_al
$LN9@audioop_al:

; 1395 :     ncp = (signed char *)PyBytes_AsString(rv);

  000c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rv$[rsp]
  000ce	e8 00 00 00 00	 call	 PyBytes_AsString
  000d3	48 89 44 24 40	 mov	 QWORD PTR ncp$[rsp], rax

; 1396 : 
; 1397 :     for ( i=0; i < len*size; i += size ) {

  000d8	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000e1	eb 15		 jmp	 SHORT $LN8@audioop_al
$LN7@audioop_al:
  000e3	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  000e8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000ed	48 03 c8	 add	 rcx, rax
  000f0	48 8b c1	 mov	 rax, rcx
  000f3	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN8@audioop_al:
  000f8	48 63 44 24 48	 movsxd	 rax, DWORD PTR size$[rsp]
  000fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  00102	48 0f af c8	 imul	 rcx, rax
  00106	48 8b c1	 mov	 rax, rcx
  00109	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  0010e	0f 8d 95 00 00
	00		 jge	 $LN6@audioop_al

; 1398 :         cval = *cp++;

  00114	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  00119	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0011c	88 44 24 68	 mov	 BYTE PTR cval$[rsp], al
  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR cp$[rsp]
  00125	48 ff c0	 inc	 rax
  00128	48 89 44 24 30	 mov	 QWORD PTR cp$[rsp], rax

; 1399 :         val = st_alaw2linear16(cval);

  0012d	0f b6 44 24 68	 movzx	 eax, BYTE PTR cval$[rsp]
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_st_alaw2linear16
  00139	0f bf 04 41	 movsx	 eax, WORD PTR [rcx+rax*2]
  0013d	89 44 24 58	 mov	 DWORD PTR val$[rsp], eax

; 1400 : 
; 1401 :         if ( size == 1 )      *CHARP(ncp, i) = (signed char)(val >> 8);

  00141	83 7c 24 48 01	 cmp	 DWORD PTR size$[rsp], 1
  00146	75 1b		 jne	 SHORT $LN5@audioop_al
  00148	8b 44 24 58	 mov	 eax, DWORD PTR val$[rsp]
  0014c	c1 f8 08	 sar	 eax, 8
  0014f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00154	48 8b 54 24 40	 mov	 rdx, QWORD PTR ncp$[rsp]
  00159	48 03 d1	 add	 rdx, rcx
  0015c	48 8b ca	 mov	 rcx, rdx
  0015f	88 01		 mov	 BYTE PTR [rcx], al
  00161	eb 41		 jmp	 SHORT $LN4@audioop_al
$LN5@audioop_al:

; 1402 :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)(val);

  00163	83 7c 24 48 02	 cmp	 DWORD PTR size$[rsp], 2
  00168	75 1a		 jne	 SHORT $LN3@audioop_al
  0016a	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0016f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ncp$[rsp]
  00174	48 03 c8	 add	 rcx, rax
  00177	48 8b c1	 mov	 rax, rcx
  0017a	0f b7 4c 24 58	 movzx	 ecx, WORD PTR val$[rsp]
  0017f	66 89 08	 mov	 WORD PTR [rax], cx
  00182	eb 20		 jmp	 SHORT $LN2@audioop_al
$LN3@audioop_al:

; 1403 :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)(val<<16);

  00184	83 7c 24 48 04	 cmp	 DWORD PTR size$[rsp], 4
  00189	75 19		 jne	 SHORT $LN1@audioop_al
  0018b	8b 44 24 58	 mov	 eax, DWORD PTR val$[rsp]
  0018f	c1 e0 10	 shl	 eax, 16
  00192	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00197	48 8b 54 24 40	 mov	 rdx, QWORD PTR ncp$[rsp]
  0019c	48 03 d1	 add	 rdx, rcx
  0019f	48 8b ca	 mov	 rcx, rdx
  001a2	89 01		 mov	 DWORD PTR [rcx], eax
$LN1@audioop_al:
$LN2@audioop_al:
$LN4@audioop_al:

; 1404 :     }

  001a4	e9 3a ff ff ff	 jmp	 $LN7@audioop_al
$LN6@audioop_al:

; 1405 :     return rv;

  001a9	48 8b 44 24 60	 mov	 rax, QWORD PTR rv$[rsp]
$LN13@audioop_al:

; 1406 : }

  001ae	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001b5	c3		 ret	 0
audioop_alaw2lin ENDP
_TEXT	ENDS
PUBLIC	??_C@_07EICEJEIP@?$CIO?$CIii?$CJ?$CJ?$AA@	; `string'
PUBLIC	??_C@_02PDIHAGKM@ii?$AA@			; `string'
PUBLIC	??_C@_0P@BADNOCOP@s?$CDiO?3lin2adpcm?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_lin2adpcm DD imagerel audioop_lin2adpcm
	DD	imagerel audioop_lin2adpcm+1121
	DD	imagerel $unwind$audioop_lin2adpcm
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_lin2adpcm DD 021101H
	DD	0190111H
xdata	ENDS
;	COMDAT ??_C@_07EICEJEIP@?$CIO?$CIii?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_07EICEJEIP@?$CIO?$CIii?$CJ?$CJ?$AA@ DB '(O(ii))', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDIHAGKM@ii?$AA@
CONST	SEGMENT
??_C@_02PDIHAGKM@ii?$AA@ DB 'ii', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BADNOCOP@s?$CDiO?3lin2adpcm?$AA@
CONST	SEGMENT
??_C@_0P@BADNOCOP@s?$CDiO?3lin2adpcm?$AA@ DB 's#iO:lin2adpcm', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_lin2adpcm
_TEXT	SEGMENT
outputbuffer$ = 48
cp$ = 56
i$ = 64
bufferstep$ = 72
index$ = 76
ncp$ = 80
step$ = 88
vpdiff$ = 92
size$ = 96
len$ = 104
sign$ = 112
valpred$ = 116
val$ = 120
rv$ = 128
delta$ = 136
str$ = 144
state$ = 152
diff$ = 160
tv78 = 168
tv142 = 176
tv181 = 180
self$ = 208
args$ = 216
audioop_lin2adpcm PROC					; COMDAT

; 1410 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1411 :     signed char *cp;
; 1412 :     signed char *ncp;
; 1413 :     Py_ssize_t len, i;
; 1414 :     int size, val = 0, step, valpred, delta,

  00011	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0

; 1415 :         index, sign, vpdiff, diff;
; 1416 :     PyObject *rv, *state, *str;
; 1417 :     int outputbuffer = 0, bufferstep;

  00019	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR outputbuffer$[rsp], 0

; 1418 : 
; 1419 :     if ( !PyArg_ParseTuple(args, "s#iO:lin2adpcm",
; 1420 :                            &cp, &len, &size, &state) )

  00021	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR state$[rsp]
  00029	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002e	48 8d 44 24 60	 lea	 rax, QWORD PTR size$[rsp]
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	4c 8d 4c 24 68	 lea	 r9, QWORD PTR len$[rsp]
  0003d	4c 8d 44 24 38	 lea	 r8, QWORD PTR cp$[rsp]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@BADNOCOP@s?$CDiO?3lin2adpcm?$AA@
  00049	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00051	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00056	85 c0		 test	 eax, eax
  00058	75 07		 jne	 SHORT $LN27@audioop_li@4

; 1421 :         return 0;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 f8 03 00 00	 jmp	 $LN28@audioop_li@4
$LN27@audioop_li@4:

; 1422 : 
; 1423 :     if (!audioop_check_parameters(len, size))

  00061	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  00065	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$[rsp]
  0006a	e8 00 00 00 00	 call	 audioop_check_parameters
  0006f	85 c0		 test	 eax, eax
  00071	75 07		 jne	 SHORT $LN26@audioop_li@4

; 1424 :         return NULL;

  00073	33 c0		 xor	 eax, eax
  00075	e9 df 03 00 00	 jmp	 $LN28@audioop_li@4
$LN26@audioop_li@4:

; 1425 : 
; 1426 :     str = PyBytes_FromStringAndSize(NULL, len/(size*2));

  0007a	8b 44 24 60	 mov	 eax, DWORD PTR size$[rsp]
  0007e	d1 e0		 shl	 eax, 1
  00080	48 98		 cdqe
  00082	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv78[rsp], rax
  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  0008f	48 99		 cdq
  00091	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv78[rsp]
  00099	48 f7 f9	 idiv	 rcx
  0009c	48 8b d0	 mov	 rdx, rax
  0009f	33 c9		 xor	 ecx, ecx
  000a1	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000a6	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR str$[rsp], rax

; 1427 :     if ( str == 0 )

  000ae	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR str$[rsp], 0
  000b7	75 07		 jne	 SHORT $LN25@audioop_li@4

; 1428 :         return 0;

  000b9	33 c0		 xor	 eax, eax
  000bb	e9 99 03 00 00	 jmp	 $LN28@audioop_li@4
$LN25@audioop_li@4:

; 1429 :     ncp = (signed char *)PyBytes_AsString(str);

  000c0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  000c8	e8 00 00 00 00	 call	 PyBytes_AsString
  000cd	48 89 44 24 50	 mov	 QWORD PTR ncp$[rsp], rax

; 1430 : 
; 1431 :     /* Decode state, should have (value, step) */
; 1432 :     if ( state == Py_None ) {

  000d2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000d9	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR state$[rsp], rax
  000e1	75 12		 jne	 SHORT $LN24@audioop_li@4

; 1433 :         /* First time, it seems. Set defaults */
; 1434 :         valpred = 0;

  000e3	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR valpred$[rsp], 0

; 1435 :         index = 0;

  000eb	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR index$[rsp], 0
  000f3	eb 29		 jmp	 SHORT $LN23@audioop_li@4
$LN24@audioop_li@4:

; 1436 :     } else if ( !PyArg_ParseTuple(state, "ii", &valpred, &index) )

  000f5	4c 8d 4c 24 4c	 lea	 r9, QWORD PTR index$[rsp]
  000fa	4c 8d 44 24 74	 lea	 r8, QWORD PTR valpred$[rsp]
  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PDIHAGKM@ii?$AA@
  00106	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0010e	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00113	85 c0		 test	 eax, eax
  00115	75 07		 jne	 SHORT $LN22@audioop_li@4

; 1437 :         return 0;

  00117	33 c0		 xor	 eax, eax
  00119	e9 3b 03 00 00	 jmp	 $LN28@audioop_li@4
$LN22@audioop_li@4:
$LN23@audioop_li@4:

; 1438 : 
; 1439 :     step = stepsizeTable[index];

  0011e	48 63 44 24 4c	 movsxd	 rax, DWORD PTR index$[rsp]
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stepsizeTable
  0012a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0012d	89 44 24 58	 mov	 DWORD PTR step$[rsp], eax

; 1440 :     bufferstep = 1;

  00131	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR bufferstep$[rsp], 1

; 1441 : 
; 1442 :     for ( i=0; i < len; i += size ) {

  00139	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00142	eb 15		 jmp	 SHORT $LN21@audioop_li@4
$LN20@audioop_li@4:
  00144	48 63 44 24 60	 movsxd	 rax, DWORD PTR size$[rsp]
  00149	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  0014e	48 03 c8	 add	 rcx, rax
  00151	48 8b c1	 mov	 rax, rcx
  00154	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN21@audioop_li@4:
  00159	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  0015e	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  00163	0f 8d b5 02 00
	00		 jge	 $LN19@audioop_li@4

; 1443 :         if ( size == 1 )      val = ((int)*CHARP(cp, i)) << 8;

  00169	83 7c 24 60 01	 cmp	 DWORD PTR size$[rsp], 1
  0016e	75 1c		 jne	 SHORT $LN18@audioop_li@4
  00170	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00175	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  0017a	48 03 c8	 add	 rcx, rax
  0017d	48 8b c1	 mov	 rax, rcx
  00180	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00183	c1 e0 08	 shl	 eax, 8
  00186	89 44 24 78	 mov	 DWORD PTR val$[rsp], eax
  0018a	eb 40		 jmp	 SHORT $LN17@audioop_li@4
$LN18@audioop_li@4:

; 1444 :         else if ( size == 2 ) val = (int)*SHORTP(cp, i);

  0018c	83 7c 24 60 02	 cmp	 DWORD PTR size$[rsp], 2
  00191	75 19		 jne	 SHORT $LN16@audioop_li@4
  00193	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00198	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  0019d	48 03 c8	 add	 rcx, rax
  001a0	48 8b c1	 mov	 rax, rcx
  001a3	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001a6	89 44 24 78	 mov	 DWORD PTR val$[rsp], eax
  001aa	eb 20		 jmp	 SHORT $LN15@audioop_li@4
$LN16@audioop_li@4:

; 1445 :         else if ( size == 4 ) val = ((int)*LONGP(cp, i)) >> 16;

  001ac	83 7c 24 60 04	 cmp	 DWORD PTR size$[rsp], 4
  001b1	75 19		 jne	 SHORT $LN14@audioop_li@4
  001b3	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  001b8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cp$[rsp]
  001bd	48 03 c8	 add	 rcx, rax
  001c0	48 8b c1	 mov	 rax, rcx
  001c3	8b 00		 mov	 eax, DWORD PTR [rax]
  001c5	c1 f8 10	 sar	 eax, 16
  001c8	89 44 24 78	 mov	 DWORD PTR val$[rsp], eax
$LN14@audioop_li@4:
$LN15@audioop_li@4:
$LN17@audioop_li@4:

; 1446 : 
; 1447 :         /* Step 1 - compute difference with previous value */
; 1448 :         diff = val - valpred;

  001cc	8b 44 24 74	 mov	 eax, DWORD PTR valpred$[rsp]
  001d0	8b 4c 24 78	 mov	 ecx, DWORD PTR val$[rsp]
  001d4	2b c8		 sub	 ecx, eax
  001d6	8b c1		 mov	 eax, ecx
  001d8	89 84 24 a0 00
	00 00		 mov	 DWORD PTR diff$[rsp], eax

; 1449 :         sign = (diff < 0) ? 8 : 0;

  001df	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR diff$[rsp], 0
  001e7	7d 0d		 jge	 SHORT $LN30@audioop_li@4
  001e9	c7 84 24 b0 00
	00 00 08 00 00
	00		 mov	 DWORD PTR tv142[rsp], 8
  001f4	eb 0b		 jmp	 SHORT $LN31@audioop_li@4
$LN30@audioop_li@4:
  001f6	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv142[rsp], 0
$LN31@audioop_li@4:
  00201	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv142[rsp]
  00208	89 44 24 70	 mov	 DWORD PTR sign$[rsp], eax

; 1450 :         if ( sign ) diff = (-diff);

  0020c	83 7c 24 70 00	 cmp	 DWORD PTR sign$[rsp], 0
  00211	74 10		 je	 SHORT $LN13@audioop_li@4
  00213	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR diff$[rsp]
  0021a	f7 d8		 neg	 eax
  0021c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR diff$[rsp], eax
$LN13@audioop_li@4:

; 1451 : 
; 1452 :         /* Step 2 - Divide and clamp */
; 1453 :         /* Note:
; 1454 :         ** This code *approximately* computes:
; 1455 :         **    delta = diff*4/step;
; 1456 :         **    vpdiff = (delta+0.5)*step/4;
; 1457 :         ** but in shift step bits are dropped. The net result of this
; 1458 :         ** is that even if you have fast mul/div hardware you cannot
; 1459 :         ** put it to good use since the fixup would be too expensive.
; 1460 :         */
; 1461 :         delta = 0;

  00223	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR delta$[rsp], 0

; 1462 :         vpdiff = (step >> 3);

  0022e	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  00232	c1 f8 03	 sar	 eax, 3
  00235	89 44 24 5c	 mov	 DWORD PTR vpdiff$[rsp], eax

; 1463 : 
; 1464 :         if ( diff >= step ) {

  00239	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  0023d	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR diff$[rsp], eax
  00244	7c 31		 jl	 SHORT $LN12@audioop_li@4

; 1465 :             delta = 4;

  00246	c7 84 24 88 00
	00 00 04 00 00
	00		 mov	 DWORD PTR delta$[rsp], 4

; 1466 :             diff -= step;

  00251	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  00255	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR diff$[rsp]
  0025c	2b c8		 sub	 ecx, eax
  0025e	8b c1		 mov	 eax, ecx
  00260	89 84 24 a0 00
	00 00		 mov	 DWORD PTR diff$[rsp], eax

; 1467 :             vpdiff += step;

  00267	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  0026b	8b 4c 24 5c	 mov	 ecx, DWORD PTR vpdiff$[rsp]
  0026f	03 c8		 add	 ecx, eax
  00271	8b c1		 mov	 eax, ecx
  00273	89 44 24 5c	 mov	 DWORD PTR vpdiff$[rsp], eax
$LN12@audioop_li@4:

; 1468 :         }
; 1469 :         step >>= 1;

  00277	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  0027b	d1 f8		 sar	 eax, 1
  0027d	89 44 24 58	 mov	 DWORD PTR step$[rsp], eax

; 1470 :         if ( diff >= step  ) {

  00281	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  00285	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR diff$[rsp], eax
  0028c	7c 37		 jl	 SHORT $LN11@audioop_li@4

; 1471 :             delta |= 2;

  0028e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR delta$[rsp]
  00295	83 c8 02	 or	 eax, 2
  00298	89 84 24 88 00
	00 00		 mov	 DWORD PTR delta$[rsp], eax

; 1472 :             diff -= step;

  0029f	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  002a3	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR diff$[rsp]
  002aa	2b c8		 sub	 ecx, eax
  002ac	8b c1		 mov	 eax, ecx
  002ae	89 84 24 a0 00
	00 00		 mov	 DWORD PTR diff$[rsp], eax

; 1473 :             vpdiff += step;

  002b5	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  002b9	8b 4c 24 5c	 mov	 ecx, DWORD PTR vpdiff$[rsp]
  002bd	03 c8		 add	 ecx, eax
  002bf	8b c1		 mov	 eax, ecx
  002c1	89 44 24 5c	 mov	 DWORD PTR vpdiff$[rsp], eax
$LN11@audioop_li@4:

; 1474 :         }
; 1475 :         step >>= 1;

  002c5	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  002c9	d1 f8		 sar	 eax, 1
  002cb	89 44 24 58	 mov	 DWORD PTR step$[rsp], eax

; 1476 :         if ( diff >= step ) {

  002cf	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  002d3	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR diff$[rsp], eax
  002da	7c 21		 jl	 SHORT $LN10@audioop_li@4

; 1477 :             delta |= 1;

  002dc	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR delta$[rsp]
  002e3	83 c8 01	 or	 eax, 1
  002e6	89 84 24 88 00
	00 00		 mov	 DWORD PTR delta$[rsp], eax

; 1478 :             vpdiff += step;

  002ed	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  002f1	8b 4c 24 5c	 mov	 ecx, DWORD PTR vpdiff$[rsp]
  002f5	03 c8		 add	 ecx, eax
  002f7	8b c1		 mov	 eax, ecx
  002f9	89 44 24 5c	 mov	 DWORD PTR vpdiff$[rsp], eax
$LN10@audioop_li@4:

; 1479 :         }
; 1480 : 
; 1481 :         /* Step 3 - Update previous value */
; 1482 :         if ( sign )

  002fd	83 7c 24 70 00	 cmp	 DWORD PTR sign$[rsp], 0
  00302	74 12		 je	 SHORT $LN9@audioop_li@4

; 1483 :             valpred -= vpdiff;

  00304	8b 44 24 5c	 mov	 eax, DWORD PTR vpdiff$[rsp]
  00308	8b 4c 24 74	 mov	 ecx, DWORD PTR valpred$[rsp]
  0030c	2b c8		 sub	 ecx, eax
  0030e	8b c1		 mov	 eax, ecx
  00310	89 44 24 74	 mov	 DWORD PTR valpred$[rsp], eax

; 1484 :         else

  00314	eb 10		 jmp	 SHORT $LN8@audioop_li@4
$LN9@audioop_li@4:

; 1485 :             valpred += vpdiff;

  00316	8b 44 24 5c	 mov	 eax, DWORD PTR vpdiff$[rsp]
  0031a	8b 4c 24 74	 mov	 ecx, DWORD PTR valpred$[rsp]
  0031e	03 c8		 add	 ecx, eax
  00320	8b c1		 mov	 eax, ecx
  00322	89 44 24 74	 mov	 DWORD PTR valpred$[rsp], eax
$LN8@audioop_li@4:

; 1486 : 
; 1487 :         /* Step 4 - Clamp previous value to 16 bits */
; 1488 :         if ( valpred > 32767 )

  00326	81 7c 24 74 ff
	7f 00 00	 cmp	 DWORD PTR valpred$[rsp], 32767 ; 00007fffH
  0032e	7e 0a		 jle	 SHORT $LN7@audioop_li@4

; 1489 :             valpred = 32767;

  00330	c7 44 24 74 ff
	7f 00 00	 mov	 DWORD PTR valpred$[rsp], 32767 ; 00007fffH
  00338	eb 12		 jmp	 SHORT $LN6@audioop_li@4
$LN7@audioop_li@4:

; 1490 :         else if ( valpred < -32768 )

  0033a	81 7c 24 74 00
	80 ff ff	 cmp	 DWORD PTR valpred$[rsp], -32768 ; ffffffffffff8000H
  00342	7d 08		 jge	 SHORT $LN5@audioop_li@4

; 1491 :             valpred = -32768;

  00344	c7 44 24 74 00
	80 ff ff	 mov	 DWORD PTR valpred$[rsp], -32768 ; ffffffffffff8000H
$LN5@audioop_li@4:
$LN6@audioop_li@4:

; 1492 : 
; 1493 :         /* Step 5 - Assemble value, update index and step values */
; 1494 :         delta |= sign;

  0034c	8b 44 24 70	 mov	 eax, DWORD PTR sign$[rsp]
  00350	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR delta$[rsp]
  00357	0b c8		 or	 ecx, eax
  00359	8b c1		 mov	 eax, ecx
  0035b	89 84 24 88 00
	00 00		 mov	 DWORD PTR delta$[rsp], eax

; 1495 : 
; 1496 :         index += indexTable[delta];

  00362	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR delta$[rsp]
  0036a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:indexTable
  00371	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00374	8b 4c 24 4c	 mov	 ecx, DWORD PTR index$[rsp]
  00378	03 c8		 add	 ecx, eax
  0037a	8b c1		 mov	 eax, ecx
  0037c	89 44 24 4c	 mov	 DWORD PTR index$[rsp], eax

; 1497 :         if ( index < 0 ) index = 0;

  00380	83 7c 24 4c 00	 cmp	 DWORD PTR index$[rsp], 0
  00385	7d 08		 jge	 SHORT $LN4@audioop_li@4
  00387	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR index$[rsp], 0
$LN4@audioop_li@4:

; 1498 :         if ( index > 88 ) index = 88;

  0038f	83 7c 24 4c 58	 cmp	 DWORD PTR index$[rsp], 88 ; 00000058H
  00394	7e 08		 jle	 SHORT $LN3@audioop_li@4
  00396	c7 44 24 4c 58
	00 00 00	 mov	 DWORD PTR index$[rsp], 88 ; 00000058H
$LN3@audioop_li@4:

; 1499 :         step = stepsizeTable[index];

  0039e	48 63 44 24 4c	 movsxd	 rax, DWORD PTR index$[rsp]
  003a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stepsizeTable
  003aa	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  003ad	89 44 24 58	 mov	 DWORD PTR step$[rsp], eax

; 1500 : 
; 1501 :         /* Step 6 - Output value */
; 1502 :         if ( bufferstep ) {

  003b1	83 7c 24 48 00	 cmp	 DWORD PTR bufferstep$[rsp], 0
  003b6	74 15		 je	 SHORT $LN2@audioop_li@4

; 1503 :             outputbuffer = (delta << 4) & 0xf0;

  003b8	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR delta$[rsp]
  003bf	c1 e0 04	 shl	 eax, 4
  003c2	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  003c7	89 44 24 30	 mov	 DWORD PTR outputbuffer$[rsp], eax

; 1504 :         } else {

  003cb	eb 22		 jmp	 SHORT $LN1@audioop_li@4
$LN2@audioop_li@4:

; 1505 :             *ncp++ = (delta & 0x0f) | outputbuffer;

  003cd	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR delta$[rsp]
  003d4	83 e0 0f	 and	 eax, 15
  003d7	0b 44 24 30	 or	 eax, DWORD PTR outputbuffer$[rsp]
  003db	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ncp$[rsp]
  003e0	88 01		 mov	 BYTE PTR [rcx], al
  003e2	48 8b 44 24 50	 mov	 rax, QWORD PTR ncp$[rsp]
  003e7	48 ff c0	 inc	 rax
  003ea	48 89 44 24 50	 mov	 QWORD PTR ncp$[rsp], rax
$LN1@audioop_li@4:

; 1506 :         }
; 1507 :         bufferstep = !bufferstep;

  003ef	83 7c 24 48 00	 cmp	 DWORD PTR bufferstep$[rsp], 0
  003f4	75 0d		 jne	 SHORT $LN32@audioop_li@4
  003f6	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv181[rsp], 1
  00401	eb 0b		 jmp	 SHORT $LN33@audioop_li@4
$LN32@audioop_li@4:
  00403	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv181[rsp], 0
$LN33@audioop_li@4:
  0040e	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv181[rsp]
  00415	89 44 24 48	 mov	 DWORD PTR bufferstep$[rsp], eax

; 1508 :     }

  00419	e9 26 fd ff ff	 jmp	 $LN20@audioop_li@4
$LN19@audioop_li@4:

; 1509 :     rv = Py_BuildValue("(O(ii))", str, valpred, index);

  0041e	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR index$[rsp]
  00423	44 8b 44 24 74	 mov	 r8d, DWORD PTR valpred$[rsp]
  00428	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  00430	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EICEJEIP@?$CIO?$CIii?$CJ?$CJ?$AA@
  00437	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  0043c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax

; 1510 :     Py_DECREF(str);

  00444	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  0044c	e8 00 00 00 00	 call	 _Py_DecRef

; 1511 :     return rv;

  00451	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN28@audioop_li@4:

; 1512 : }

  00459	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00460	c3		 ret	 0
audioop_lin2adpcm ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@EPLILDA@s?$CDiO?3adpcm2lin?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$audioop_adpcm2lin DD imagerel audioop_adpcm2lin
	DD	imagerel audioop_adpcm2lin+988
	DD	imagerel $unwind$audioop_adpcm2lin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$audioop_adpcm2lin DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_0P@EPLILDA@s?$CDiO?3adpcm2lin?$AA@
CONST	SEGMENT
??_C@_0P@EPLILDA@s?$CDiO?3adpcm2lin?$AA@ DB 's#iO:adpcm2lin', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT audioop_adpcm2lin
_TEXT	SEGMENT
inputbuffer$ = 48
cp$ = 56
i$ = 64
bufferstep$ = 72
index$ = 76
ncp$ = 80
step$ = 88
vpdiff$ = 92
size$ = 96
len$ = 104
sign$ = 112
valpred$ = 116
rv$ = 120
delta$ = 128
state$ = 136
str$ = 144
tv82 = 152
tv144 = 160
self$ = 192
args$ = 200
audioop_adpcm2lin PROC					; COMDAT

; 1516 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1517 :     signed char *cp;
; 1518 :     signed char *ncp;
; 1519 :     Py_ssize_t len, i;
; 1520 :     int size, valpred, step, delta, index, sign, vpdiff;
; 1521 :     PyObject *rv, *str, *state;
; 1522 :     int inputbuffer = 0, bufferstep;

  00011	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR inputbuffer$[rsp], 0

; 1523 : 
; 1524 :     if ( !PyArg_ParseTuple(args, "s#iO:adpcm2lin",
; 1525 :                            &cp, &len, &size, &state) )

  00019	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR state$[rsp]
  00021	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00026	48 8d 44 24 60	 lea	 rax, QWORD PTR size$[rsp]
  0002b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00030	4c 8d 4c 24 68	 lea	 r9, QWORD PTR len$[rsp]
  00035	4c 8d 44 24 38	 lea	 r8, QWORD PTR cp$[rsp]
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@EPLILDA@s?$CDiO?3adpcm2lin?$AA@
  00041	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00049	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0004e	85 c0		 test	 eax, eax
  00050	75 07		 jne	 SHORT $LN27@audioop_ad@2

; 1526 :         return 0;

  00052	33 c0		 xor	 eax, eax
  00054	e9 7b 03 00 00	 jmp	 $LN28@audioop_ad@2
$LN27@audioop_ad@2:

; 1527 : 
; 1528 :     if (!audioop_check_size(size))

  00059	8b 4c 24 60	 mov	 ecx, DWORD PTR size$[rsp]
  0005d	e8 00 00 00 00	 call	 audioop_check_size
  00062	85 c0		 test	 eax, eax
  00064	75 07		 jne	 SHORT $LN26@audioop_ad@2

; 1529 :         return NULL;

  00066	33 c0		 xor	 eax, eax
  00068	e9 67 03 00 00	 jmp	 $LN28@audioop_ad@2
$LN26@audioop_ad@2:

; 1530 : 
; 1531 :     /* Decode state, should have (value, step) */
; 1532 :     if ( state == Py_None ) {

  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00074	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR state$[rsp], rax
  0007c	75 12		 jne	 SHORT $LN25@audioop_ad@2

; 1533 :         /* First time, it seems. Set defaults */
; 1534 :         valpred = 0;

  0007e	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR valpred$[rsp], 0

; 1535 :         index = 0;

  00086	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR index$[rsp], 0
  0008e	eb 29		 jmp	 SHORT $LN24@audioop_ad@2
$LN25@audioop_ad@2:

; 1536 :     } else if ( !PyArg_ParseTuple(state, "ii", &valpred, &index) )

  00090	4c 8d 4c 24 4c	 lea	 r9, QWORD PTR index$[rsp]
  00095	4c 8d 44 24 74	 lea	 r8, QWORD PTR valpred$[rsp]
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PDIHAGKM@ii?$AA@
  000a1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  000a9	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000ae	85 c0		 test	 eax, eax
  000b0	75 07		 jne	 SHORT $LN23@audioop_ad@2

; 1537 :         return 0;

  000b2	33 c0		 xor	 eax, eax
  000b4	e9 1b 03 00 00	 jmp	 $LN28@audioop_ad@2
$LN23@audioop_ad@2:
$LN24@audioop_ad@2:

; 1538 : 
; 1539 :     if (len > (PY_SSIZE_T_MAX/2)/size) {

  000b9	48 63 44 24 60	 movsxd	 rax, DWORD PTR size$[rsp]
  000be	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
  000c6	48 b9 ff ff ff
	ff ff ff ff 3f	 mov	 rcx, 4611686018427387903 ; 3fffffffffffffffH
  000d0	48 8b c1	 mov	 rax, rcx
  000d3	48 99		 cdq
  000d5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv82[rsp]
  000dd	48 f7 f9	 idiv	 rcx
  000e0	48 39 44 24 68	 cmp	 QWORD PTR len$[rsp], rax
  000e5	7e 1a		 jle	 SHORT $LN22@audioop_ad@2

; 1540 :         PyErr_SetString(PyExc_MemoryError,
; 1541 :                         "not enough memory for output buffer");

  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KMCIFBLB@not?5enough?5memory?5for?5output?5buf@
  000ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  000f5	e8 00 00 00 00	 call	 PyErr_SetString

; 1542 :         return 0;

  000fa	33 c0		 xor	 eax, eax
  000fc	e9 d3 02 00 00	 jmp	 $LN28@audioop_ad@2
$LN22@audioop_ad@2:

; 1543 :     }
; 1544 :     str = PyBytes_FromStringAndSize(NULL, len*size*2);

  00101	48 63 44 24 60	 movsxd	 rax, DWORD PTR size$[rsp]
  00106	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$[rsp]
  0010b	48 0f af c8	 imul	 rcx, rax
  0010f	48 8b c1	 mov	 rax, rcx
  00112	48 d1 e0	 shl	 rax, 1
  00115	48 8b d0	 mov	 rdx, rax
  00118	33 c9		 xor	 ecx, ecx
  0011a	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0011f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR str$[rsp], rax

; 1545 :     if ( str == 0 )

  00127	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR str$[rsp], 0
  00130	75 07		 jne	 SHORT $LN21@audioop_ad@2

; 1546 :         return 0;

  00132	33 c0		 xor	 eax, eax
  00134	e9 9b 02 00 00	 jmp	 $LN28@audioop_ad@2
$LN21@audioop_ad@2:

; 1547 :     ncp = (signed char *)PyBytes_AsString(str);

  00139	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  00141	e8 00 00 00 00	 call	 PyBytes_AsString
  00146	48 89 44 24 50	 mov	 QWORD PTR ncp$[rsp], rax

; 1548 : 
; 1549 :     step = stepsizeTable[index];

  0014b	48 63 44 24 4c	 movsxd	 rax, DWORD PTR index$[rsp]
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stepsizeTable
  00157	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0015a	89 44 24 58	 mov	 DWORD PTR step$[rsp], eax

; 1550 :     bufferstep = 0;

  0015e	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bufferstep$[rsp], 0

; 1551 : 
; 1552 :     for ( i=0; i < len*size*2; i += size ) {

  00166	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0016f	eb 15		 jmp	 SHORT $LN20@audioop_ad@2
$LN19@audioop_ad@2:
  00171	48 63 44 24 60	 movsxd	 rax, DWORD PTR size$[rsp]
  00176	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  0017b	48 03 c8	 add	 rcx, rax
  0017e	48 8b c1	 mov	 rax, rcx
  00181	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN20@audioop_ad@2:
  00186	48 63 44 24 60	 movsxd	 rax, DWORD PTR size$[rsp]
  0018b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$[rsp]
  00190	48 0f af c8	 imul	 rcx, rax
  00194	48 8b c1	 mov	 rax, rcx
  00197	48 d1 e0	 shl	 rax, 1
  0019a	48 39 44 24 40	 cmp	 QWORD PTR i$[rsp], rax
  0019f	0f 8d fa 01 00
	00		 jge	 $LN18@audioop_ad@2

; 1553 :         /* Step 1 - get the delta value and compute next index */
; 1554 :         if ( bufferstep ) {

  001a5	83 7c 24 48 00	 cmp	 DWORD PTR bufferstep$[rsp], 0
  001aa	74 10		 je	 SHORT $LN17@audioop_ad@2

; 1555 :             delta = inputbuffer & 0xf;

  001ac	8b 44 24 30	 mov	 eax, DWORD PTR inputbuffer$[rsp]
  001b0	83 e0 0f	 and	 eax, 15
  001b3	89 84 24 80 00
	00 00		 mov	 DWORD PTR delta$[rsp], eax

; 1556 :         } else {

  001ba	eb 2a		 jmp	 SHORT $LN16@audioop_ad@2
$LN17@audioop_ad@2:

; 1557 :             inputbuffer = *cp++;

  001bc	48 8b 44 24 38	 mov	 rax, QWORD PTR cp$[rsp]
  001c1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001c4	89 44 24 30	 mov	 DWORD PTR inputbuffer$[rsp], eax
  001c8	48 8b 44 24 38	 mov	 rax, QWORD PTR cp$[rsp]
  001cd	48 ff c0	 inc	 rax
  001d0	48 89 44 24 38	 mov	 QWORD PTR cp$[rsp], rax

; 1558 :             delta = (inputbuffer >> 4) & 0xf;

  001d5	8b 44 24 30	 mov	 eax, DWORD PTR inputbuffer$[rsp]
  001d9	c1 f8 04	 sar	 eax, 4
  001dc	83 e0 0f	 and	 eax, 15
  001df	89 84 24 80 00
	00 00		 mov	 DWORD PTR delta$[rsp], eax
$LN16@audioop_ad@2:

; 1559 :         }
; 1560 : 
; 1561 :         bufferstep = !bufferstep;

  001e6	83 7c 24 48 00	 cmp	 DWORD PTR bufferstep$[rsp], 0
  001eb	75 0d		 jne	 SHORT $LN30@audioop_ad@2
  001ed	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv144[rsp], 1
  001f8	eb 0b		 jmp	 SHORT $LN31@audioop_ad@2
$LN30@audioop_ad@2:
  001fa	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv144[rsp], 0
$LN31@audioop_ad@2:
  00205	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv144[rsp]
  0020c	89 44 24 48	 mov	 DWORD PTR bufferstep$[rsp], eax

; 1562 : 
; 1563 :         /* Step 2 - Find new index value (for later) */
; 1564 :         index += indexTable[delta];

  00210	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR delta$[rsp]
  00218	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:indexTable
  0021f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00222	8b 4c 24 4c	 mov	 ecx, DWORD PTR index$[rsp]
  00226	03 c8		 add	 ecx, eax
  00228	8b c1		 mov	 eax, ecx
  0022a	89 44 24 4c	 mov	 DWORD PTR index$[rsp], eax

; 1565 :         if ( index < 0 ) index = 0;

  0022e	83 7c 24 4c 00	 cmp	 DWORD PTR index$[rsp], 0
  00233	7d 08		 jge	 SHORT $LN15@audioop_ad@2
  00235	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR index$[rsp], 0
$LN15@audioop_ad@2:

; 1566 :         if ( index > 88 ) index = 88;

  0023d	83 7c 24 4c 58	 cmp	 DWORD PTR index$[rsp], 88 ; 00000058H
  00242	7e 08		 jle	 SHORT $LN14@audioop_ad@2
  00244	c7 44 24 4c 58
	00 00 00	 mov	 DWORD PTR index$[rsp], 88 ; 00000058H
$LN14@audioop_ad@2:

; 1567 : 
; 1568 :         /* Step 3 - Separate sign and magnitude */
; 1569 :         sign = delta & 8;

  0024c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR delta$[rsp]
  00253	83 e0 08	 and	 eax, 8
  00256	89 44 24 70	 mov	 DWORD PTR sign$[rsp], eax

; 1570 :         delta = delta & 7;

  0025a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR delta$[rsp]
  00261	83 e0 07	 and	 eax, 7
  00264	89 84 24 80 00
	00 00		 mov	 DWORD PTR delta$[rsp], eax

; 1571 : 
; 1572 :         /* Step 4 - Compute difference and new predicted value */
; 1573 :         /*
; 1574 :         ** Computes 'vpdiff = (delta+0.5)*step/4', but see comment
; 1575 :         ** in adpcm_coder.
; 1576 :         */
; 1577 :         vpdiff = step >> 3;

  0026b	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  0026f	c1 f8 03	 sar	 eax, 3
  00272	89 44 24 5c	 mov	 DWORD PTR vpdiff$[rsp], eax

; 1578 :         if ( delta & 4 ) vpdiff += step;

  00276	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR delta$[rsp]
  0027d	83 e0 04	 and	 eax, 4
  00280	85 c0		 test	 eax, eax
  00282	74 10		 je	 SHORT $LN13@audioop_ad@2
  00284	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  00288	8b 4c 24 5c	 mov	 ecx, DWORD PTR vpdiff$[rsp]
  0028c	03 c8		 add	 ecx, eax
  0028e	8b c1		 mov	 eax, ecx
  00290	89 44 24 5c	 mov	 DWORD PTR vpdiff$[rsp], eax
$LN13@audioop_ad@2:

; 1579 :         if ( delta & 2 ) vpdiff += step>>1;

  00294	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR delta$[rsp]
  0029b	83 e0 02	 and	 eax, 2
  0029e	85 c0		 test	 eax, eax
  002a0	74 12		 je	 SHORT $LN12@audioop_ad@2
  002a2	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  002a6	d1 f8		 sar	 eax, 1
  002a8	8b 4c 24 5c	 mov	 ecx, DWORD PTR vpdiff$[rsp]
  002ac	03 c8		 add	 ecx, eax
  002ae	8b c1		 mov	 eax, ecx
  002b0	89 44 24 5c	 mov	 DWORD PTR vpdiff$[rsp], eax
$LN12@audioop_ad@2:

; 1580 :         if ( delta & 1 ) vpdiff += step>>2;

  002b4	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR delta$[rsp]
  002bb	83 e0 01	 and	 eax, 1
  002be	85 c0		 test	 eax, eax
  002c0	74 13		 je	 SHORT $LN11@audioop_ad@2
  002c2	8b 44 24 58	 mov	 eax, DWORD PTR step$[rsp]
  002c6	c1 f8 02	 sar	 eax, 2
  002c9	8b 4c 24 5c	 mov	 ecx, DWORD PTR vpdiff$[rsp]
  002cd	03 c8		 add	 ecx, eax
  002cf	8b c1		 mov	 eax, ecx
  002d1	89 44 24 5c	 mov	 DWORD PTR vpdiff$[rsp], eax
$LN11@audioop_ad@2:

; 1581 : 
; 1582 :         if ( sign )

  002d5	83 7c 24 70 00	 cmp	 DWORD PTR sign$[rsp], 0
  002da	74 12		 je	 SHORT $LN10@audioop_ad@2

; 1583 :             valpred -= vpdiff;

  002dc	8b 44 24 5c	 mov	 eax, DWORD PTR vpdiff$[rsp]
  002e0	8b 4c 24 74	 mov	 ecx, DWORD PTR valpred$[rsp]
  002e4	2b c8		 sub	 ecx, eax
  002e6	8b c1		 mov	 eax, ecx
  002e8	89 44 24 74	 mov	 DWORD PTR valpred$[rsp], eax

; 1584 :         else

  002ec	eb 10		 jmp	 SHORT $LN9@audioop_ad@2
$LN10@audioop_ad@2:

; 1585 :             valpred += vpdiff;

  002ee	8b 44 24 5c	 mov	 eax, DWORD PTR vpdiff$[rsp]
  002f2	8b 4c 24 74	 mov	 ecx, DWORD PTR valpred$[rsp]
  002f6	03 c8		 add	 ecx, eax
  002f8	8b c1		 mov	 eax, ecx
  002fa	89 44 24 74	 mov	 DWORD PTR valpred$[rsp], eax
$LN9@audioop_ad@2:

; 1586 : 
; 1587 :         /* Step 5 - clamp output value */
; 1588 :         if ( valpred > 32767 )

  002fe	81 7c 24 74 ff
	7f 00 00	 cmp	 DWORD PTR valpred$[rsp], 32767 ; 00007fffH
  00306	7e 0a		 jle	 SHORT $LN8@audioop_ad@2

; 1589 :             valpred = 32767;

  00308	c7 44 24 74 ff
	7f 00 00	 mov	 DWORD PTR valpred$[rsp], 32767 ; 00007fffH
  00310	eb 12		 jmp	 SHORT $LN7@audioop_ad@2
$LN8@audioop_ad@2:

; 1590 :         else if ( valpred < -32768 )

  00312	81 7c 24 74 00
	80 ff ff	 cmp	 DWORD PTR valpred$[rsp], -32768 ; ffffffffffff8000H
  0031a	7d 08		 jge	 SHORT $LN6@audioop_ad@2

; 1591 :             valpred = -32768;

  0031c	c7 44 24 74 00
	80 ff ff	 mov	 DWORD PTR valpred$[rsp], -32768 ; ffffffffffff8000H
$LN6@audioop_ad@2:
$LN7@audioop_ad@2:

; 1592 : 
; 1593 :         /* Step 6 - Update step value */
; 1594 :         step = stepsizeTable[index];

  00324	48 63 44 24 4c	 movsxd	 rax, DWORD PTR index$[rsp]
  00329	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:stepsizeTable
  00330	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00333	89 44 24 58	 mov	 DWORD PTR step$[rsp], eax

; 1595 : 
; 1596 :         /* Step 6 - Output value */
; 1597 :         if ( size == 1 ) *CHARP(ncp, i) = (signed char)(valpred >> 8);

  00337	83 7c 24 60 01	 cmp	 DWORD PTR size$[rsp], 1
  0033c	75 1b		 jne	 SHORT $LN5@audioop_ad@2
  0033e	8b 44 24 74	 mov	 eax, DWORD PTR valpred$[rsp]
  00342	c1 f8 08	 sar	 eax, 8
  00345	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  0034a	48 8b 54 24 50	 mov	 rdx, QWORD PTR ncp$[rsp]
  0034f	48 03 d1	 add	 rdx, rcx
  00352	48 8b ca	 mov	 rcx, rdx
  00355	88 01		 mov	 BYTE PTR [rcx], al
  00357	eb 41		 jmp	 SHORT $LN4@audioop_ad@2
$LN5@audioop_ad@2:

; 1598 :         else if ( size == 2 ) *SHORTP(ncp, i) = (short)(valpred);

  00359	83 7c 24 60 02	 cmp	 DWORD PTR size$[rsp], 2
  0035e	75 1a		 jne	 SHORT $LN3@audioop_ad@2
  00360	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  00365	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ncp$[rsp]
  0036a	48 03 c8	 add	 rcx, rax
  0036d	48 8b c1	 mov	 rax, rcx
  00370	0f b7 4c 24 74	 movzx	 ecx, WORD PTR valpred$[rsp]
  00375	66 89 08	 mov	 WORD PTR [rax], cx
  00378	eb 20		 jmp	 SHORT $LN2@audioop_ad@2
$LN3@audioop_ad@2:

; 1599 :         else if ( size == 4 ) *LONGP(ncp, i) = (Py_Int32)(valpred<<16);

  0037a	83 7c 24 60 04	 cmp	 DWORD PTR size$[rsp], 4
  0037f	75 19		 jne	 SHORT $LN1@audioop_ad@2
  00381	8b 44 24 74	 mov	 eax, DWORD PTR valpred$[rsp]
  00385	c1 e0 10	 shl	 eax, 16
  00388	48 8b 4c 24 40	 mov	 rcx, QWORD PTR i$[rsp]
  0038d	48 8b 54 24 50	 mov	 rdx, QWORD PTR ncp$[rsp]
  00392	48 03 d1	 add	 rdx, rcx
  00395	48 8b ca	 mov	 rcx, rdx
  00398	89 01		 mov	 DWORD PTR [rcx], eax
$LN1@audioop_ad@2:
$LN2@audioop_ad@2:
$LN4@audioop_ad@2:

; 1600 :     }

  0039a	e9 d2 fd ff ff	 jmp	 $LN19@audioop_ad@2
$LN18@audioop_ad@2:

; 1601 : 
; 1602 :     rv = Py_BuildValue("(O(ii))", str, valpred, index);

  0039f	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR index$[rsp]
  003a4	44 8b 44 24 74	 mov	 r8d, DWORD PTR valpred$[rsp]
  003a9	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR str$[rsp]
  003b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EICEJEIP@?$CIO?$CIii?$CJ?$CJ?$AA@
  003b8	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  003bd	48 89 44 24 78	 mov	 QWORD PTR rv$[rsp], rax

; 1603 :     Py_DECREF(str);

  003c2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR str$[rsp]
  003ca	e8 00 00 00 00	 call	 _Py_DecRef

; 1604 :     return rv;

  003cf	48 8b 44 24 78	 mov	 rax, QWORD PTR rv$[rsp]
$LN28@audioop_ad@2:

; 1605 : }

  003d4	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003db	c3		 ret	 0
audioop_adpcm2lin ENDP
_TEXT	ENDS
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	??_C@_0O@EMPLMINL@audioop?4error?$AA@		; `string'
PUBLIC	PyInit_audioop
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyErr_NewException:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_audioop DD imagerel $LN6
	DD	imagerel $LN6+133
	DD	imagerel $unwind$PyInit_audioop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_audioop DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EMPLMINL@audioop?4error?$AA@
CONST	SEGMENT
??_C@_0O@EMPLMINL@audioop?4error?$AA@ DB 'audioop.error', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit_audioop
_TEXT	SEGMENT
d$ = 32
m$ = 40
PyInit_audioop PROC					; COMDAT

; 1651 : {

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1652 :     PyObject *m, *d;
; 1653 :     m = PyModule_Create(&audioopmodule);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:audioopmodule
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00015	48 89 44 24 28	 mov	 QWORD PTR m$[rsp], rax

; 1654 :     if (m == NULL)

  0001a	48 83 7c 24 28
	00		 cmp	 QWORD PTR m$[rsp], 0
  00020	75 04		 jne	 SHORT $LN3@PyInit_aud

; 1655 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	eb 5a		 jmp	 SHORT $LN4@PyInit_aud
$LN3@PyInit_aud:

; 1656 :     d = PyModule_GetDict(m);

  00026	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  0002b	e8 00 00 00 00	 call	 PyModule_GetDict
  00030	48 89 44 24 20	 mov	 QWORD PTR d$[rsp], rax

; 1657 :     if (d == NULL)

  00035	48 83 7c 24 20
	00		 cmp	 QWORD PTR d$[rsp], 0
  0003b	75 04		 jne	 SHORT $LN2@PyInit_aud

; 1658 :         return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	eb 3f		 jmp	 SHORT $LN4@PyInit_aud
$LN2@PyInit_aud:

; 1659 :     AudioopError = PyErr_NewException("audioop.error", NULL, NULL);

  00041	45 33 c0	 xor	 r8d, r8d
  00044	33 d2		 xor	 edx, edx
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@EMPLMINL@audioop?4error?$AA@
  0004d	e8 00 00 00 00	 call	 PyErr_NewException
  00052	48 89 05 00 00
	00 00		 mov	 QWORD PTR AudioopError, rax

; 1660 :     if (AudioopError != NULL)

  00059	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR AudioopError, 0
  00061	74 18		 je	 SHORT $LN1@PyInit_aud

; 1661 :          PyDict_SetItemString(d,"error",AudioopError);

  00063	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR AudioopError
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  00071	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00076	e8 00 00 00 00	 call	 PyDict_SetItemString
$LN1@PyInit_aud:

; 1662 :     return m;

  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR m$[rsp]
$LN4@PyInit_aud:

; 1663 : }

  00080	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00084	c3		 ret	 0
PyInit_audioop ENDP
_TEXT	ENDS
END
