; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04CFDJAKFL@math?$AA@			; `string'
PUBLIC	??_C@_05NOECMME@trunc?$AA@			; `string'
PUBLIC	??_C@_04FJHINJAO@tanh?$AA@			; `string'
PUBLIC	??_C@_03IIINPABG@tan?$AA@			; `string'
PUBLIC	??_C@_04EIAKFFMI@sqrt?$AA@			; `string'
PUBLIC	??_C@_04COOMCNPB@sinh?$AA@			; `string'
PUBLIC	??_C@_03BLEJJJBH@sin?$AA@			; `string'
PUBLIC	??_C@_07JLOPPFCD@radians?$AA@			; `string'
PUBLIC	??_C@_03JGHBODFD@pow?$AA@			; `string'
PUBLIC	??_C@_04EHEDPDJG@modf?$AA@			; `string'
PUBLIC	??_C@_04KGLCPMCP@log2?$AA@			; `string'
PUBLIC	??_C@_05HGHHAHAP@log10?$AA@			; `string'
PUBLIC	??_C@_05IGAOEIAK@log1p?$AA@			; `string'
PUBLIC	??_C@_03MGHMBJCF@log?$AA@			; `string'
PUBLIC	??_C@_06GKIDEKEE@lgamma?$AA@			; `string'
PUBLIC	??_C@_05CEJMAHNP@ldexp?$AA@			; `string'
PUBLIC	??_C@_05LGCGPNNP@isnan?$AA@			; `string'
PUBLIC	??_C@_05OIHEAIFD@isinf?$AA@			; `string'
PUBLIC	??_C@_08CHCKEDFL@isfinite?$AA@			; `string'
PUBLIC	??_C@_05DNLPMBKG@hypot?$AA@			; `string'
PUBLIC	??_C@_05KDLBCAI@gamma?$AA@			; `string'
PUBLIC	??_C@_04NEEMDKCM@fsum?$AA@			; `string'
PUBLIC	??_C@_05GKKHEGJL@frexp?$AA@			; `string'
PUBLIC	??_C@_04KEPJIHGP@fmod?$AA@			; `string'
PUBLIC	??_C@_05PBJFFIGL@floor?$AA@			; `string'
PUBLIC	??_C@_09HBBEBGCM@factorial?$AA@			; `string'
PUBLIC	??_C@_04ODHECPBC@fabs?$AA@			; `string'
PUBLIC	??_C@_05DCMLJEOG@expm1?$AA@			; `string'
PUBLIC	??_C@_03KHJOGHMM@exp?$AA@			; `string'
PUBLIC	??_C@_04KLLDBHDO@erfc?$AA@			; `string'
PUBLIC	??_C@_03LGJBFHMN@erf?$AA@			; `string'
PUBLIC	??_C@_07MHOHEFBH@degrees?$AA@			; `string'
PUBLIC	??_C@_04HPJJNFIM@cosh?$AA@			; `string'
PUBLIC	??_C@_03LALBNOCG@cos?$AA@			; `string'
PUBLIC	??_C@_08PLCMNBBP@copysign?$AA@			; `string'
PUBLIC	??_C@_04GFPJNGEK@ceil?$AA@			; `string'
PUBLIC	??_C@_05ONDAFDEP@atanh?$AA@			; `string'
PUBLIC	??_C@_05KNGEOGJB@atan2?$AA@			; `string'
PUBLIC	??_C@_04MLLJIGOK@atan?$AA@			; `string'
PUBLIC	??_C@_05JKKEKHLA@asinh?$AA@			; `string'
PUBLIC	??_C@_04FIHNOPOL@asin?$AA@			; `string'
PUBLIC	??_C@_05MLNBFPMN@acosh?$AA@			; `string'
PUBLIC	??_C@_04PDIFKINK@acos?$AA@			; `string'
PUBLIC	??_C@_09KENBLPCG@__trunc__?$AA@			; `string'
PUBLIC	??_C@_09NKCGFGFE@__floor__?$AA@			; `string'
PUBLIC	??_C@_08GFGNDJJM@__ceil__?$AA@			; `string'
;	COMDAT ??_C@_04CFDJAKFL@math?$AA@
CONST	SEGMENT
??_C@_04CFDJAKFL@math?$AA@ DB 'math', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NOECMME@trunc?$AA@
CONST	SEGMENT
??_C@_05NOECMME@trunc?$AA@ DB 'trunc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FJHINJAO@tanh?$AA@
CONST	SEGMENT
??_C@_04FJHINJAO@tanh?$AA@ DB 'tanh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IIINPABG@tan?$AA@
CONST	SEGMENT
??_C@_03IIINPABG@tan?$AA@ DB 'tan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EIAKFFMI@sqrt?$AA@
CONST	SEGMENT
??_C@_04EIAKFFMI@sqrt?$AA@ DB 'sqrt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COOMCNPB@sinh?$AA@
CONST	SEGMENT
??_C@_04COOMCNPB@sinh?$AA@ DB 'sinh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BLEJJJBH@sin?$AA@
CONST	SEGMENT
??_C@_03BLEJJJBH@sin?$AA@ DB 'sin', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07JLOPPFCD@radians?$AA@
CONST	SEGMENT
??_C@_07JLOPPFCD@radians?$AA@ DB 'radians', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JGHBODFD@pow?$AA@
CONST	SEGMENT
??_C@_03JGHBODFD@pow?$AA@ DB 'pow', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EHEDPDJG@modf?$AA@
CONST	SEGMENT
??_C@_04EHEDPDJG@modf?$AA@ DB 'modf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KGLCPMCP@log2?$AA@
CONST	SEGMENT
??_C@_04KGLCPMCP@log2?$AA@ DB 'log2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HGHHAHAP@log10?$AA@
CONST	SEGMENT
??_C@_05HGHHAHAP@log10?$AA@ DB 'log10', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IGAOEIAK@log1p?$AA@
CONST	SEGMENT
??_C@_05IGAOEIAK@log1p?$AA@ DB 'log1p', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGHMBJCF@log?$AA@
CONST	SEGMENT
??_C@_03MGHMBJCF@log?$AA@ DB 'log', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKIDEKEE@lgamma?$AA@
CONST	SEGMENT
??_C@_06GKIDEKEE@lgamma?$AA@ DB 'lgamma', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CEJMAHNP@ldexp?$AA@
CONST	SEGMENT
??_C@_05CEJMAHNP@ldexp?$AA@ DB 'ldexp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LGCGPNNP@isnan?$AA@
CONST	SEGMENT
??_C@_05LGCGPNNP@isnan?$AA@ DB 'isnan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OIHEAIFD@isinf?$AA@
CONST	SEGMENT
??_C@_05OIHEAIFD@isinf?$AA@ DB 'isinf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CHCKEDFL@isfinite?$AA@
CONST	SEGMENT
??_C@_08CHCKEDFL@isfinite?$AA@ DB 'isfinite', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNLPMBKG@hypot?$AA@
CONST	SEGMENT
??_C@_05DNLPMBKG@hypot?$AA@ DB 'hypot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KDLBCAI@gamma?$AA@
CONST	SEGMENT
??_C@_05KDLBCAI@gamma?$AA@ DB 'gamma', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEEMDKCM@fsum?$AA@
CONST	SEGMENT
??_C@_04NEEMDKCM@fsum?$AA@ DB 'fsum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GKKHEGJL@frexp?$AA@
CONST	SEGMENT
??_C@_05GKKHEGJL@frexp?$AA@ DB 'frexp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KEPJIHGP@fmod?$AA@
CONST	SEGMENT
??_C@_04KEPJIHGP@fmod?$AA@ DB 'fmod', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PBJFFIGL@floor?$AA@
CONST	SEGMENT
??_C@_05PBJFFIGL@floor?$AA@ DB 'floor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09HBBEBGCM@factorial?$AA@
CONST	SEGMENT
??_C@_09HBBEBGCM@factorial?$AA@ DB 'factorial', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04ODHECPBC@fabs?$AA@
CONST	SEGMENT
??_C@_04ODHECPBC@fabs?$AA@ DB 'fabs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DCMLJEOG@expm1?$AA@
CONST	SEGMENT
??_C@_05DCMLJEOG@expm1?$AA@ DB 'expm1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KHJOGHMM@exp?$AA@
CONST	SEGMENT
??_C@_03KHJOGHMM@exp?$AA@ DB 'exp', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KLLDBHDO@erfc?$AA@
CONST	SEGMENT
??_C@_04KLLDBHDO@erfc?$AA@ DB 'erfc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LGJBFHMN@erf?$AA@
CONST	SEGMENT
??_C@_03LGJBFHMN@erf?$AA@ DB 'erf', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHOHEFBH@degrees?$AA@
CONST	SEGMENT
??_C@_07MHOHEFBH@degrees?$AA@ DB 'degrees', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPJJNFIM@cosh?$AA@
CONST	SEGMENT
??_C@_04HPJJNFIM@cosh?$AA@ DB 'cosh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03LALBNOCG@cos?$AA@
CONST	SEGMENT
??_C@_03LALBNOCG@cos?$AA@ DB 'cos', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08PLCMNBBP@copysign?$AA@
CONST	SEGMENT
??_C@_08PLCMNBBP@copysign?$AA@ DB 'copysign', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GFPJNGEK@ceil?$AA@
CONST	SEGMENT
??_C@_04GFPJNGEK@ceil?$AA@ DB 'ceil', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ONDAFDEP@atanh?$AA@
CONST	SEGMENT
??_C@_05ONDAFDEP@atanh?$AA@ DB 'atanh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KNGEOGJB@atan2?$AA@
CONST	SEGMENT
??_C@_05KNGEOGJB@atan2?$AA@ DB 'atan2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLJIGOK@atan?$AA@
CONST	SEGMENT
??_C@_04MLLJIGOK@atan?$AA@ DB 'atan', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKKEKHLA@asinh?$AA@
CONST	SEGMENT
??_C@_05JKKEKHLA@asinh?$AA@ DB 'asinh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FIHNOPOL@asin?$AA@
CONST	SEGMENT
??_C@_04FIHNOPOL@asin?$AA@ DB 'asin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MLNBFPMN@acosh?$AA@
CONST	SEGMENT
??_C@_05MLNBFPMN@acosh?$AA@ DB 'acosh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PDIFKINK@acos?$AA@
CONST	SEGMENT
??_C@_04PDIFKINK@acos?$AA@ DB 'acos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KENBLPCG@__trunc__?$AA@
CONST	SEGMENT
??_C@_09KENBLPCG@__trunc__?$AA@ DB '__trunc__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NKCGFGFE@__floor__?$AA@
CONST	SEGMENT
??_C@_09NKCGFGFE@__floor__?$AA@ DB '__floor__', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___trunc__@?1??math_trunc@@9@9 DQ 0000000000000000H ; `math_trunc'::`2'::PyId___trunc__
	DQ	FLAT:??_C@_09KENBLPCG@__trunc__?$AA@
	DQ	0000000000000000H
?PyId___floor__@?1??math_floor@@9@9 DQ 0000000000000000H ; `math_floor'::`2'::PyId___floor__
	DQ	FLAT:??_C@_09NKCGFGFE@__floor__?$AA@
	DQ	0000000000000000H
?PyId___ceil__@?1??math_ceil@@9@9 DQ 0000000000000000H	; `math_ceil'::`2'::PyId___ceil__
	DQ	FLAT:??_C@_08GFGNDJJM@__ceil__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_08GFGNDJJM@__ceil__?$AA@
CONST	SEGMENT
??_C@_08GFGNDJJM@__ceil__?$AA@ DB '__ceil__', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
math_acos_doc DB 'acos(x)', 0aH, 0aH, 'Return the arc cosine (measured in'
	DB	' radians) of x.', 00H
	ORG $+5
math_acosh_doc DB 'acosh(x)', 0aH, 0aH, 'Return the hyperbolic arc cosine'
	DB	' (measured in radians) of x.', 00H
	ORG $+1
math_asin_doc DB 'asin(x)', 0aH, 0aH, 'Return the arc sine (measured in r'
	DB	'adians) of x.', 00H
	ORG $+15
math_asinh_doc DB 'asinh(x)', 0aH, 0aH, 'Return the hyperbolic arc sine ('
	DB	'measured in radians) of x.', 00H
	ORG $+3
math_atan_doc DB 'atan(x)', 0aH, 0aH, 'Return the arc tangent (measured i'
	DB	'n radians) of x.', 00H
	ORG $+12
math_atan2_doc DB 'atan2(y, x)', 0aH, 0aH, 'Return the arc tangent (measu'
	DB	'red in radians) of y/x.', 0aH, 'Unlike atan(y/x), the signs o'
	DB	'f both x and y are considered.', 00H
	ORG $+2
math_atanh_doc DB 'atanh(x)', 0aH, 0aH, 'Return the hyperbolic arc tangen'
	DB	't (measured in radians) of x.', 00H
	ORG $+8
math_ceil_doc DB 'ceil(x)', 0aH, 0aH, 'Return the ceiling of x as an int.'
	DB	0aH, 'This is the smallest integral value >= x.', 00H
	ORG $+10
math_copysign_doc DB 'copysign(x, y)', 0aH, 0aH, 'Return a float with the'
	DB	' magnitude (absolute value) of x but the sign ', 0aH, 'of y. '
	DB	'On platforms that support signed zeros, copysign(1.0, -0.0) ', 0aH
	DB	'returns -1.0.', 0aH, 00H
math_cos_doc DB	'cos(x)', 0aH, 0aH, 'Return the cosine of x (measured in '
	DB	'radians).', 00H
	ORG $+2
math_cosh_doc DB 'cosh(x)', 0aH, 0aH, 'Return the hyperbolic cosine of x.'
	DB	00H
	ORG $+4
math_erf_doc DB	'erf(x)', 0aH, 0aH, 'Error function at x.', 00H
	ORG $+3
math_erfc_doc DB 'erfc(x)', 0aH, 0aH, 'Complementary error function at x.'
	DB	00H
	ORG $+4
math_exp_doc DB	'exp(x)', 0aH, 0aH, 'Return e raised to the power of x.', 00H
	ORG $+5
math_expm1_doc DB 'expm1(x)', 0aH, 0aH, 'Return exp(x)-1.', 0aH, 'This fu'
	DB	'nction avoids the loss of precision involved in the direct ev'
	DB	'aluation of exp(x)-1 for small x.', 00H
	ORG $+7
math_fabs_doc DB 'fabs(x)', 0aH, 0aH, 'Return the absolute value of the f'
	DB	'loat x.', 00H
	ORG $+5
math_floor_doc DB 'floor(x)', 0aH, 0aH, 'Return the floor of x as an int.'
	DB	0aH, 'This is the largest integral value <= x.', 00H
	ORG $+4
math_gamma_doc DB 'gamma(x)', 0aH, 0aH, 'Gamma function at x.', 00H
	ORG $+9
math_lgamma_doc DB 'lgamma(x)', 0aH, 0aH, 'Natural logarithm of absolute '
	DB	'value of Gamma function at x.', 00H
	ORG $+9
math_log1p_doc DB 'log1p(x)', 0aH, 0aH, 'Return the natural logarithm of '
	DB	'1+x (base e).', 0aH, 'The result is computed in a way which i'
	DB	's accurate for x near zero.', 00H
	ORG $+5
math_sin_doc DB	'sin(x)', 0aH, 0aH, 'Return the sine of x (measured in ra'
	DB	'dians).', 00H
	ORG $+4
math_sinh_doc DB 'sinh(x)', 0aH, 0aH, 'Return the hyperbolic sine of x.', 00H
	ORG $+6
math_sqrt_doc DB 'sqrt(x)', 0aH, 0aH, 'Return the square root of x.', 00H
	ORG $+2
math_tan_doc DB	'tan(x)', 0aH, 0aH, 'Return the tangent of x (measured in'
	DB	' radians).', 00H
	ORG $+1
math_tanh_doc DB 'tanh(x)', 0aH, 0aH, 'Return the hyperbolic tangent of x'
	DB	'.', 00H
	ORG $+11
math_fsum_doc DB 'fsum(iterable)', 0aH, 0aH, 'Return an accurate floating'
	DB	' point sum of values in the iterable.', 0aH, 'Assumes IEEE-75'
	DB	'4 floating point arithmetic.', 00H
	ORG $+3
math_factorial_doc DB 'factorial(x) -> Integral', 0aH, 0aH, 'Find x!. Rai'
	DB	'se a ValueError if x is negative or non-integral.', 00H
	ORG $+8
math_trunc_doc DB 'trunc(x:Real) -> Integral', 0aH, 0aH, 'Truncates x to '
	DB	'the nearest Integral toward 0. Uses the __trunc__ magic metho'
	DB	'd.', 00H
	ORG $+6
math_frexp_doc DB 'frexp(x)', 0aH, 0aH, 'Return the mantissa and exponent'
	DB	' of x, as pair (m, e).', 0aH, 'm is a float and e is an int, '
	DB	'such that x = m * 2.**e.', 0aH, 'If x is 0, m and e are both '
	DB	'0.  Else 0.5 <= abs(m) < 1.0.', 00H
	ORG $+6
math_ldexp_doc DB 'ldexp(x, i)', 0aH, 0aH, 'Return x * (2**i).', 00H
	ORG $+8
math_modf_doc DB 'modf(x)', 0aH, 0aH, 'Return the fractional and integer '
	DB	'parts of x.  Both results carry the sign', 0aH, 'of x and are'
	DB	' floats.', 00H
	ORG $+7
math_log_doc DB	'log(x[, base])', 0aH, 0aH, 'Return the logarithm of x to'
	DB	' the given base.', 0aH, 'If the base not specified, returns t'
	DB	'he natural logarithm (base e) of x.', 00H
	ORG $+3
math_log2_doc DB 'log2(x)', 0aH, 0aH, 'Return the base 2 logarithm of x.', 00H
	ORG $+5
math_log10_doc DB 'log10(x)', 0aH, 0aH, 'Return the base 10 logarithm of '
	DB	'x.', 00H
	ORG $+11
math_fmod_doc DB 'fmod(x, y)', 0aH, 0aH, 'Return fmod(x, y), according to'
	DB	' platform C.  x % y may differ.', 00H
	ORG $+5
math_hypot_doc DB 'hypot(x, y)', 0aH, 0aH, 'Return the Euclidean distance'
	DB	', sqrt(x*x + y*y).', 00H
	ORG $+3
math_pow_doc DB	'pow(x, y)', 0aH, 0aH, 'Return x**y (x to the power of y)'
	DB	'.', 00H
	ORG $+2
math_degrees_doc DB 'degrees(x)', 0aH, 0aH, 'Convert angle x from radians'
	DB	' to degrees.', 00H
	ORG $+3
math_radians_doc DB 'radians(x)', 0aH, 0aH, 'Convert angle x from degrees'
	DB	' to radians.', 00H
	ORG $+3
math_isfinite_doc DB 'isfinite(x) -> bool', 0aH, 0aH, 'Return True if x i'
	DB	's neither an infinity nor a NaN, and False otherwise.', 00H
	ORG $+3
math_isnan_doc DB 'isnan(x) -> bool', 0aH, 0aH, 'Return True if x is a Na'
	DB	'N (not a number), and False otherwise.', 00H
	ORG $+15
math_isinf_doc DB 'isinf(x) -> bool', 0aH, 0aH, 'Return True if x is a po'
	DB	'sitive or negative infinity, and False otherwise.', 00H
	ORG $+4
math_methods DQ	FLAT:??_C@_04PDIFKINK@acos?$AA@
	DQ	FLAT:math_acos
	DD	08H
	ORG $+4
	DQ	FLAT:math_acos_doc
	DQ	FLAT:??_C@_05MLNBFPMN@acosh?$AA@
	DQ	FLAT:math_acosh
	DD	08H
	ORG $+4
	DQ	FLAT:math_acosh_doc
	DQ	FLAT:??_C@_04FIHNOPOL@asin?$AA@
	DQ	FLAT:math_asin
	DD	08H
	ORG $+4
	DQ	FLAT:math_asin_doc
	DQ	FLAT:??_C@_05JKKEKHLA@asinh?$AA@
	DQ	FLAT:math_asinh
	DD	08H
	ORG $+4
	DQ	FLAT:math_asinh_doc
	DQ	FLAT:??_C@_04MLLJIGOK@atan?$AA@
	DQ	FLAT:math_atan
	DD	08H
	ORG $+4
	DQ	FLAT:math_atan_doc
	DQ	FLAT:??_C@_05KNGEOGJB@atan2?$AA@
	DQ	FLAT:math_atan2
	DD	01H
	ORG $+4
	DQ	FLAT:math_atan2_doc
	DQ	FLAT:??_C@_05ONDAFDEP@atanh?$AA@
	DQ	FLAT:math_atanh
	DD	08H
	ORG $+4
	DQ	FLAT:math_atanh_doc
	DQ	FLAT:??_C@_04GFPJNGEK@ceil?$AA@
	DQ	FLAT:math_ceil
	DD	08H
	ORG $+4
	DQ	FLAT:math_ceil_doc
	DQ	FLAT:??_C@_08PLCMNBBP@copysign?$AA@
	DQ	FLAT:math_copysign
	DD	01H
	ORG $+4
	DQ	FLAT:math_copysign_doc
	DQ	FLAT:??_C@_03LALBNOCG@cos?$AA@
	DQ	FLAT:math_cos
	DD	08H
	ORG $+4
	DQ	FLAT:math_cos_doc
	DQ	FLAT:??_C@_04HPJJNFIM@cosh?$AA@
	DQ	FLAT:math_cosh
	DD	08H
	ORG $+4
	DQ	FLAT:math_cosh_doc
	DQ	FLAT:??_C@_07MHOHEFBH@degrees?$AA@
	DQ	FLAT:math_degrees
	DD	08H
	ORG $+4
	DQ	FLAT:math_degrees_doc
	DQ	FLAT:??_C@_03LGJBFHMN@erf?$AA@
	DQ	FLAT:math_erf
	DD	08H
	ORG $+4
	DQ	FLAT:math_erf_doc
	DQ	FLAT:??_C@_04KLLDBHDO@erfc?$AA@
	DQ	FLAT:math_erfc
	DD	08H
	ORG $+4
	DQ	FLAT:math_erfc_doc
	DQ	FLAT:??_C@_03KHJOGHMM@exp?$AA@
	DQ	FLAT:math_exp
	DD	08H
	ORG $+4
	DQ	FLAT:math_exp_doc
	DQ	FLAT:??_C@_05DCMLJEOG@expm1?$AA@
	DQ	FLAT:math_expm1
	DD	08H
	ORG $+4
	DQ	FLAT:math_expm1_doc
	DQ	FLAT:??_C@_04ODHECPBC@fabs?$AA@
	DQ	FLAT:math_fabs
	DD	08H
	ORG $+4
	DQ	FLAT:math_fabs_doc
	DQ	FLAT:??_C@_09HBBEBGCM@factorial?$AA@
	DQ	FLAT:math_factorial
	DD	08H
	ORG $+4
	DQ	FLAT:math_factorial_doc
	DQ	FLAT:??_C@_05PBJFFIGL@floor?$AA@
	DQ	FLAT:math_floor
	DD	08H
	ORG $+4
	DQ	FLAT:math_floor_doc
	DQ	FLAT:??_C@_04KEPJIHGP@fmod?$AA@
	DQ	FLAT:math_fmod
	DD	01H
	ORG $+4
	DQ	FLAT:math_fmod_doc
	DQ	FLAT:??_C@_05GKKHEGJL@frexp?$AA@
	DQ	FLAT:math_frexp
	DD	08H
	ORG $+4
	DQ	FLAT:math_frexp_doc
	DQ	FLAT:??_C@_04NEEMDKCM@fsum?$AA@
	DQ	FLAT:math_fsum
	DD	08H
	ORG $+4
	DQ	FLAT:math_fsum_doc
	DQ	FLAT:??_C@_05KDLBCAI@gamma?$AA@
	DQ	FLAT:math_gamma
	DD	08H
	ORG $+4
	DQ	FLAT:math_gamma_doc
	DQ	FLAT:??_C@_05DNLPMBKG@hypot?$AA@
	DQ	FLAT:math_hypot
	DD	01H
	ORG $+4
	DQ	FLAT:math_hypot_doc
	DQ	FLAT:??_C@_08CHCKEDFL@isfinite?$AA@
	DQ	FLAT:math_isfinite
	DD	08H
	ORG $+4
	DQ	FLAT:math_isfinite_doc
	DQ	FLAT:??_C@_05OIHEAIFD@isinf?$AA@
	DQ	FLAT:math_isinf
	DD	08H
	ORG $+4
	DQ	FLAT:math_isinf_doc
	DQ	FLAT:??_C@_05LGCGPNNP@isnan?$AA@
	DQ	FLAT:math_isnan
	DD	08H
	ORG $+4
	DQ	FLAT:math_isnan_doc
	DQ	FLAT:??_C@_05CEJMAHNP@ldexp?$AA@
	DQ	FLAT:math_ldexp
	DD	01H
	ORG $+4
	DQ	FLAT:math_ldexp_doc
	DQ	FLAT:??_C@_06GKIDEKEE@lgamma?$AA@
	DQ	FLAT:math_lgamma
	DD	08H
	ORG $+4
	DQ	FLAT:math_lgamma_doc
	DQ	FLAT:??_C@_03MGHMBJCF@log?$AA@
	DQ	FLAT:math_log
	DD	01H
	ORG $+4
	DQ	FLAT:math_log_doc
	DQ	FLAT:??_C@_05IGAOEIAK@log1p?$AA@
	DQ	FLAT:math_log1p
	DD	08H
	ORG $+4
	DQ	FLAT:math_log1p_doc
	DQ	FLAT:??_C@_05HGHHAHAP@log10?$AA@
	DQ	FLAT:math_log10
	DD	08H
	ORG $+4
	DQ	FLAT:math_log10_doc
	DQ	FLAT:??_C@_04KGLCPMCP@log2?$AA@
	DQ	FLAT:math_log2
	DD	08H
	ORG $+4
	DQ	FLAT:math_log2_doc
	DQ	FLAT:??_C@_04EHEDPDJG@modf?$AA@
	DQ	FLAT:math_modf
	DD	08H
	ORG $+4
	DQ	FLAT:math_modf_doc
	DQ	FLAT:??_C@_03JGHBODFD@pow?$AA@
	DQ	FLAT:math_pow
	DD	01H
	ORG $+4
	DQ	FLAT:math_pow_doc
	DQ	FLAT:??_C@_07JLOPPFCD@radians?$AA@
	DQ	FLAT:math_radians
	DD	08H
	ORG $+4
	DQ	FLAT:math_radians_doc
	DQ	FLAT:??_C@_03BLEJJJBH@sin?$AA@
	DQ	FLAT:math_sin
	DD	08H
	ORG $+4
	DQ	FLAT:math_sin_doc
	DQ	FLAT:??_C@_04COOMCNPB@sinh?$AA@
	DQ	FLAT:math_sinh
	DD	08H
	ORG $+4
	DQ	FLAT:math_sinh_doc
	DQ	FLAT:??_C@_04EIAKFFMI@sqrt?$AA@
	DQ	FLAT:math_sqrt
	DD	08H
	ORG $+4
	DQ	FLAT:math_sqrt_doc
	DQ	FLAT:??_C@_03IIINPABG@tan?$AA@
	DQ	FLAT:math_tan
	DD	08H
	ORG $+4
	DQ	FLAT:math_tan_doc
	DQ	FLAT:??_C@_04FJHINJAO@tanh?$AA@
	DQ	FLAT:math_tanh
	DD	08H
	ORG $+4
	DQ	FLAT:math_tanh_doc
	DQ	FLAT:??_C@_05NOECMME@trunc?$AA@
	DQ	FLAT:math_trunc
	DD	08H
	ORG $+4
	DQ	FLAT:math_trunc_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_doc DB	'This module is always available.  It provides access to '
	DB	'the', 0aH, 'mathematical functions defined by the C standard.'
	DB	00H
	ORG $+2
mathmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_04CFDJAKFL@math?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:math_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
CONST	SEGMENT
pi	DQ	0400921fb54442d18r		; 3.14159
sqrtpi	DQ	03ffc5bf891b4ef6br		; 1.77245
logpi	DQ	03ff250d048e7a1bdr		; 1.14473
lanczos_g DQ	040181945b9800000r		; 6.02468
lanczos_g_minus_half DQ 040161945b9800000r	; 5.52468
SmallFactorials DD 01H
	DD	01H
	DD	02H
	DD	06H
	DD	018H
	DD	078H
	DD	02d0H
	DD	013b0H
	DD	09d80H
	DD	058980H
	DD	0375f00H
	DD	02611500H
	DD	01c8cfc00H
	ORG $+4
lanczos_num_coeffs DQ 04215ea5143c1a49er	; 2.35314e+010
	DQ	04223fc7075f54c57r		; 4.29198e+010
	DQ	04220a132818ab61ar		; 3.5712e+010
	DQ	04210b0b522e8261ar		; 1.7921e+010
	DQ	041f67fc1b3a5a1e8r		; 6.03954e+009
	DQ	041d57418f5d3f33fr		; 1.43972e+009
	DQ	041adab0c7bb95f2ar		; 2.48875e+008
	DQ	0417df876f95dcc98r		; 3.14264e+007
	DQ	04145f1e95080f44cr		; 2.87637e+006
	DQ	04106b6421f8787ebr		; 186056
	DQ	040bf87ac0858d804r		; 8071.67
	DQ	0406a5a607bbc3b52r		; 210.824
	DQ	040040d931ff62705r		; 2.50663
degToRad DQ	03f91df46a2529d39r		; 0.0174533
lanczos_den_coeffs DQ 00000000000000000r	; 0
	DQ	0418308a800000000r		; 3.99168e+007
	DQ	0419cbd6980000000r		; 1.20544e+008
	DQ	041a1fda6b0000000r		; 1.50918e+008
	DQ	04199187170000000r		; 1.05258e+008
	DQ	04185eeb690000000r		; 4.59957e+007
	DQ	041697171e0000000r		; 1.33395e+007
	DQ	041441f7b00000000r		; 2.63756e+006
	DQ	04115d0bc00000000r		; 357423
	DQ	040dfe78000000000r		; 32670
	DQ	0409e140000000000r		; 1925
	DQ	04050800000000000r		; 66
	DQ	03ff0000000000000r		; 1
radToDeg DQ	0404ca5dc1a63c1f8r		; 57.2958
gamma_integral DQ 03ff0000000000000r		; 1
	DQ	03ff0000000000000r		; 1
	DQ	04000000000000000r		; 2
	DQ	04018000000000000r		; 6
	DQ	04038000000000000r		; 24
	DQ	0405e000000000000r		; 120
	DQ	04086800000000000r		; 720
	DQ	040b3b00000000000r		; 5040
	DQ	040e3b00000000000r		; 40320
	DQ	04116260000000000r		; 362880
	DQ	0414baf8000000000r		; 3.6288e+006
	DQ	0418308a800000000r		; 3.99168e+007
	DQ	041bc8cfc00000000r		; 4.79002e+008
	DQ	041f7328cc0000000r		; 6.22702e+009
	DQ	042344c3b28000000r		; 8.71783e+010
	DQ	04273077775800000r		; 1.30767e+012
	DQ	042b3077775800000r		; 2.09228e+013
	DQ	042f437eeecd80000r		; 3.55687e+014
	DQ	04336beecca730000r		; 6.40237e+015
	DQ	0437b02b930689000r		; 1.21645e+017
	DQ	043c0e1b3be415a00r		; 2.4329e+018
	DQ	04406283be9b5c620r		; 5.10909e+019
	DQ	0444e77526159f06cr		; 1.124e+021
CONST	ENDS
EXTRN	acos:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\mathmodule.c
pdata	SEGMENT
$pdata$math_acos DD imagerel math_acos
	DD	imagerel math_acos+39
	DD	imagerel $unwind$math_acos
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_acos DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_acos
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_acos PROC						; COMDAT

; 874  :       "acos(x)\n\nReturn the arc cosine (measured in radians) of x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:acos
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_acos ENDP
_TEXT	ENDS
EXTRN	PyFloat_FromDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_1 DD imagerel math_1
	DD	imagerel math_1+51
	DD	imagerel $unwind$math_1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_1 DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_1
_TEXT	SEGMENT
arg$ = 48
func$ = 56
can_overflow$ = 64
math_1	PROC						; COMDAT

; 812  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 813  :     return math_1_to_whatever(arg, func, PyFloat_FromDouble, can_overflow);

  00013	44 8b 4c 24 40	 mov	 r9d, DWORD PTR can_overflow$[rsp]
  00018	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyFloat_FromDouble
  0001f	48 8b 54 24 38	 mov	 rdx, QWORD PTR func$[rsp]
  00024	48 8b 4c 24 30	 mov	 rcx, QWORD PTR arg$[rsp]
  00029	e8 00 00 00 00	 call	 math_1_to_whatever

; 814  : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
math_1	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@PNJGEICL@math?5range?5error?$AA@	; `string'
PUBLIC	??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@	; `string'
PUBLIC	__real@bff0000000000000
EXTRN	PyExc_OverflowError:QWORD
EXTRN	__imp__finite:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	__imp__isnan:PROC
EXTRN	__imp__errno:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyFloat_AsDouble:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_1_to_whatever DD imagerel math_1_to_whatever
	DD	imagerel math_1_to_whatever+321
	DD	imagerel $unwind$math_1_to_whatever
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_1_to_whatever DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT ??_C@_0BB@PNJGEICL@math?5range?5error?$AA@
CONST	SEGMENT
??_C@_0BB@PNJGEICL@math?5range?5error?$AA@ DB 'math range error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@
CONST	SEGMENT
??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@ DB 'math domain error', 00H ; `string'
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT math_1_to_whatever
_TEXT	SEGMENT
x$ = 32
r$ = 40
arg$ = 64
func$ = 72
from_double_func$ = 80
can_overflow$ = 88
math_1_to_whatever PROC					; COMDAT

; 733  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 734  :     double x, r;
; 735  :     x = PyFloat_AsDouble(arg);

  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR arg$[rsp]
  0001d	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00022	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 736  :     if (x == -1.0 && PyErr_Occurred())

  00028	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0002e	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00036	7a 13		 jp	 SHORT $LN6@math_1_to_
  00038	75 11		 jne	 SHORT $LN6@math_1_to_
  0003a	e8 00 00 00 00	 call	 PyErr_Occurred
  0003f	48 85 c0	 test	 rax, rax
  00042	74 07		 je	 SHORT $LN6@math_1_to_

; 737  :         return NULL;

  00044	33 c0		 xor	 eax, eax
  00046	e9 f1 00 00 00	 jmp	 $LN7@math_1_to_
$LN6@math_1_to_:

; 738  :     errno = 0;

  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 739  :     PyFPE_START_PROTECT("in math_1", return 0);
; 740  :     r = (*func)(x);

  00057	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0005d	ff 54 24 48	 call	 QWORD PTR func$[rsp]
  00061	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR r$[rsp], xmm0

; 741  :     PyFPE_END_PROTECT(r);
; 742  :     if (Py_IS_NAN(r) && !Py_IS_NAN(x)) {

  00067	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00073	85 c0		 test	 eax, eax
  00075	74 2a		 je	 SHORT $LN5@math_1_to_
  00077	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00083	85 c0		 test	 eax, eax
  00085	75 1a		 jne	 SHORT $LN5@math_1_to_

; 743  :         PyErr_SetString(PyExc_ValueError,
; 744  :                         "math domain error"); /* invalid arg */

  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@
  0008e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00095	e8 00 00 00 00	 call	 PyErr_SetString

; 745  :         return NULL;

  0009a	33 c0		 xor	 eax, eax
  0009c	e9 9b 00 00 00	 jmp	 $LN7@math_1_to_
$LN5@math_1_to_:

; 746  :     }
; 747  :     if (Py_IS_INFINITY(r) && Py_IS_FINITE(x)) {

  000a1	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR r$[rsp]
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000ad	85 c0		 test	 eax, eax
  000af	75 53		 jne	 SHORT $LN4@math_1_to_
  000b1	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR r$[rsp]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000bd	85 c0		 test	 eax, eax
  000bf	75 43		 jne	 SHORT $LN4@math_1_to_
  000c1	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000cd	85 c0		 test	 eax, eax
  000cf	74 33		 je	 SHORT $LN4@math_1_to_

; 748  :         if (can_overflow)

  000d1	83 7c 24 58 00	 cmp	 DWORD PTR can_overflow$[rsp], 0
  000d6	74 15		 je	 SHORT $LN3@math_1_to_

; 749  :             PyErr_SetString(PyExc_OverflowError,
; 750  :                             "math range error"); /* overflow */

  000d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@PNJGEICL@math?5range?5error?$AA@
  000df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000e6	e8 00 00 00 00	 call	 PyErr_SetString

; 751  :         else

  000eb	eb 13		 jmp	 SHORT $LN2@math_1_to_
$LN3@math_1_to_:

; 752  :             PyErr_SetString(PyExc_ValueError,
; 753  :                             "math domain error"); /* singularity */

  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@
  000f4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000fb	e8 00 00 00 00	 call	 PyErr_SetString
$LN2@math_1_to_:

; 754  :         return NULL;

  00100	33 c0		 xor	 eax, eax
  00102	eb 38		 jmp	 SHORT $LN7@math_1_to_
$LN4@math_1_to_:

; 755  :     }
; 756  :     if (Py_IS_FINITE(r) && errno && is_error(r))

  00104	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00110	85 c0		 test	 eax, eax
  00112	74 1e		 je	 SHORT $LN1@math_1_to_
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0011a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0011d	74 13		 je	 SHORT $LN1@math_1_to_
  0011f	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR r$[rsp]
  00125	e8 00 00 00 00	 call	 is_error
  0012a	85 c0		 test	 eax, eax
  0012c	74 04		 je	 SHORT $LN1@math_1_to_

; 757  :         /* this branch unnecessary on most platforms */
; 758  :         return NULL;

  0012e	33 c0		 xor	 eax, eax
  00130	eb 0a		 jmp	 SHORT $LN7@math_1_to_
$LN1@math_1_to_:

; 759  : 
; 760  :     return (*from_double_func)(r);

  00132	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR r$[rsp]
  00138	ff 54 24 50	 call	 QWORD PTR from_double_func$[rsp]
$LN7@math_1_to_:

; 761  : }

  0013c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00140	c3		 ret	 0
math_1_to_whatever ENDP
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	??_C@_1M@HJKJGILP@?$AAe?$AAr?$AAr?$AAn?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@BGHOHNN@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAa?$AAt?$AAh?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	fabs:PROC
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_error DD imagerel is_error
	DD	imagerel is_error+177
	DD	imagerel $unwind$is_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_error DD 010a01H
	DD	0620aH
xdata	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT ??_C@_1M@HJKJGILP@?$AAe?$AAr?$AAr?$AAn?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1M@HJKJGILP@?$AAe?$AAr?$AAr?$AAn?$AAo?$AA?$AA@ DB 'e', 00H, 'r', 00H
	DB	'r', 00H, 'n', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@BGHOHNN@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAa?$AAt?$AAh?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@BGHOHNN@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAa?$AAt?$AAh?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 'm', 00H, 'a', 00H, 't'
	DB	00H, 'h', 00H, 'm', 00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H
	DB	'e', 00H, '.', 00H, 'c', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT is_error
_TEXT	SEGMENT
result$ = 32
x$ = 64
is_error PROC						; COMDAT

; 665  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 666  :     int result = 1;     /* presumption of guilt */

  0000a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR result$[rsp], 1

; 667  :     assert(errno);      /* non-zero errno is a precondition for calling */

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00018	83 38 00	 cmp	 DWORD PTR [rax], 0
  0001b	75 1c		 jne	 SHORT $LN9@is_error
  0001d	41 b8 9b 02 00
	00		 mov	 r8d, 667		; 0000029bH
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@BGHOHNN@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAa?$AAt?$AAh?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1M@HJKJGILP@?$AAe?$AAr?$AAr?$AAn?$AAo?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN9@is_error:

; 668  :     if (errno == EDOM)

  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0003f	83 38 21	 cmp	 DWORD PTR [rax], 33	; 00000021H
  00042	75 15		 jne	 SHORT $LN6@is_error

; 669  :         PyErr_SetString(PyExc_ValueError, "math domain error");

  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@
  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00052	e8 00 00 00 00	 call	 PyErr_SetString
  00057	eb 4f		 jmp	 SHORT $LN5@is_error
$LN6@is_error:

; 670  : 
; 671  :     else if (errno == ERANGE) {

  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005f	83 38 22	 cmp	 DWORD PTR [rax], 34	; 00000022H
  00062	75 38		 jne	 SHORT $LN4@is_error

; 672  :         /* ANSI C generally requires libm functions to set ERANGE
; 673  :          * on overflow, but also generally *allows* them to set
; 674  :          * ERANGE on underflow too.  There's no consistency about
; 675  :          * the latter across platforms.
; 676  :          * Alas, C99 never requires that errno be set.
; 677  :          * Here we suppress the underflow errors (libm functions
; 678  :          * should return a zero on underflow, and +- HUGE_VAL on
; 679  :          * overflow, so testing the result for zero suffices to
; 680  :          * distinguish the cases).
; 681  :          *
; 682  :          * On some platforms (Ubuntu/ia64) it seems that errno can be
; 683  :          * set to ERANGE for subnormal results that do *not* underflow
; 684  :          * to zero.  So to be safe, we'll ignore ERANGE whenever the
; 685  :          * function result is less than one in absolute value.
; 686  :          */
; 687  :         if (fabs(x) < 1.0)

  00064	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0006a	e8 00 00 00 00	 call	 fabs
  0006f	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@3ff0000000000000
  00077	66 0f 2f c8	 comisd	 xmm1, xmm0
  0007b	76 0a		 jbe	 SHORT $LN3@is_error

; 688  :             result = 0;

  0007d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 689  :         else

  00085	eb 13		 jmp	 SHORT $LN2@is_error
$LN3@is_error:

; 690  :             PyErr_SetString(PyExc_OverflowError,
; 691  :                             "math range error");

  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@PNJGEICL@math?5range?5error?$AA@
  0008e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00095	e8 00 00 00 00	 call	 PyErr_SetString
$LN2@is_error:

; 692  :     }
; 693  :     else

  0009a	eb 0c		 jmp	 SHORT $LN1@is_error
$LN4@is_error:

; 694  :         /* Unexpected math error */
; 695  :         PyErr_SetFromErrno(PyExc_ValueError);

  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a3	e8 00 00 00 00	 call	 PyErr_SetFromErrno
$LN1@is_error:
$LN5@is_error:

; 696  :     return result;

  000a8	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]

; 697  : }

  000ac	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b0	c3		 ret	 0
is_error ENDP
_TEXT	ENDS
EXTRN	_Py_acosh:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_acosh DD imagerel math_acosh
	DD	imagerel math_acosh+39
	DD	imagerel $unwind$math_acosh
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_acosh DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_acosh
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_acosh PROC						; COMDAT

; 876  :       "acosh(x)\n\nReturn the hyperbolic arc cosine (measured in radians) of x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_acosh
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_acosh ENDP
_TEXT	ENDS
EXTRN	asin:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_asin DD imagerel math_asin
	DD	imagerel math_asin+39
	DD	imagerel $unwind$math_asin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_asin DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_asin
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_asin PROC						; COMDAT

; 878  :       "asin(x)\n\nReturn the arc sine (measured in radians) of x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:asin
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_asin ENDP
_TEXT	ENDS
EXTRN	_Py_asinh:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_asinh DD imagerel math_asinh
	DD	imagerel math_asinh+39
	DD	imagerel $unwind$math_asinh
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_asinh DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_asinh
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_asinh PROC						; COMDAT

; 880  :       "asinh(x)\n\nReturn the hyperbolic arc sine (measured in radians) of x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_asinh
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_asinh ENDP
_TEXT	ENDS
EXTRN	atan:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_atan DD imagerel math_atan
	DD	imagerel math_atan+39
	DD	imagerel $unwind$math_atan
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_atan DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_atan
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_atan PROC						; COMDAT

; 882  :       "atan(x)\n\nReturn the arc tangent (measured in radians) of x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:atan
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_atan ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_atan2 DD imagerel math_atan2
	DD	imagerel math_atan2+43
	DD	imagerel $unwind$math_atan2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_atan2 DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_atan2
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_atan2 PROC						; COMDAT

; 885  :       "Unlike atan(y/x), the signs of both x and y are considered.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05KNGEOGJB@atan2?$AA@
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_atan2
  0001c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  00021	e8 00 00 00 00	 call	 math_2
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
math_atan2 ENDP
_TEXT	ENDS
PUBLIC	__real@400921fb54442d18
PUBLIC	__real@3ff921fb54442d18
PUBLIC	__real@4002d97c7f3321d2
PUBLIC	__real@3fe921fb54442d18
PUBLIC	__real@0000000000000000
EXTRN	atan2:PROC
EXTRN	__imp__copysign:PROC
EXTRN	__imp__HUGE:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_atan2 DD imagerel m_atan2
	DD	imagerel m_atan2+399
	DD	imagerel $unwind$m_atan2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_atan2 DD 011001H
	DD	04210H
xdata	ENDS
;	COMDAT __real@400921fb54442d18
CONST	SEGMENT
__real@400921fb54442d18 DQ 0400921fb54442d18r	; 3.14159
CONST	ENDS
;	COMDAT __real@3ff921fb54442d18
CONST	SEGMENT
__real@3ff921fb54442d18 DQ 03ff921fb54442d18r	; 1.5708
CONST	ENDS
;	COMDAT __real@4002d97c7f3321d2
CONST	SEGMENT
__real@4002d97c7f3321d2 DQ 04002d97c7f3321d2r	; 2.35619
CONST	ENDS
;	COMDAT __real@3fe921fb54442d18
CONST	SEGMENT
__real@3fe921fb54442d18 DQ 03fe921fb54442d18r	; 0.785398
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT m_atan2
_TEXT	SEGMENT
y$ = 48
x$ = 56
m_atan2	PROC						; COMDAT

; 526  : {

  00000	f2 0f 11 4c 24
	10		 movsdx	 QWORD PTR [rsp+16], xmm1
  00006	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 527  :     if (Py_IS_NAN(x) || Py_IS_NAN(y))

  00010	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0001c	85 c0		 test	 eax, eax
  0001e	75 10		 jne	 SHORT $LN10@m_atan2
  00020	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0002c	85 c0		 test	 eax, eax
  0002e	74 18		 je	 SHORT $LN11@m_atan2
$LN10@m_atan2:

; 528  :         return Py_NAN;

  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00037	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0003b	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@0000000000000000
  00043	e9 42 01 00 00	 jmp	 $LN12@m_atan2
$LN11@m_atan2:

; 529  :     if (Py_IS_INFINITY(y)) {

  00048	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00054	85 c0		 test	 eax, eax
  00056	0f 85 a1 00 00
	00		 jne	 $LN9@m_atan2
  0005c	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00068	85 c0		 test	 eax, eax
  0006a	0f 85 8d 00 00
	00		 jne	 $LN9@m_atan2

; 530  :         if (Py_IS_INFINITY(x)) {

  00070	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0007c	85 c0		 test	 eax, eax
  0007e	75 64		 jne	 SHORT $LN8@m_atan2
  00080	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0008c	85 c0		 test	 eax, eax
  0008e	75 54		 jne	 SHORT $LN8@m_atan2

; 531  :             if (copysign(1., x) == 1.)

  00090	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR x$[rsp]
  00096	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000a4	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  000ac	7a 1d		 jp	 SHORT $LN7@m_atan2
  000ae	75 1b		 jne	 SHORT $LN7@m_atan2

; 532  :                 /* atan2(+-inf, +inf) == +-pi/4 */
; 533  :                 return copysign(0.25*Py_MATH_PI, y);

  000b0	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR y$[rsp]
  000b6	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3fe921fb54442d18
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000c4	e9 c1 00 00 00	 jmp	 $LN12@m_atan2

; 534  :             else

  000c9	eb 19		 jmp	 SHORT $LN6@m_atan2
$LN7@m_atan2:

; 535  :                 /* atan2(+-inf, -inf) == +-pi*3/4 */
; 536  :                 return copysign(0.75*Py_MATH_PI, y);

  000cb	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR y$[rsp]
  000d1	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4002d97c7f3321d2
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000df	e9 a6 00 00 00	 jmp	 $LN12@m_atan2
$LN6@m_atan2:
$LN8@m_atan2:

; 537  :         }
; 538  :         /* atan2(+-inf, x) == +-pi/2 for finite x */
; 539  :         return copysign(0.5*Py_MATH_PI, y);

  000e4	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR y$[rsp]
  000ea	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff921fb54442d18
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000f8	e9 8d 00 00 00	 jmp	 $LN12@m_atan2
$LN9@m_atan2:

; 540  :     }
; 541  :     if (Py_IS_INFINITY(x) || y == 0.) {

  000fd	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00109	85 c0		 test	 eax, eax
  0010b	75 10		 jne	 SHORT $LN3@m_atan2
  0010d	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00119	85 c0		 test	 eax, eax
  0011b	74 12		 je	 SHORT $LN4@m_atan2
$LN3@m_atan2:
  0011d	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00123	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0012b	7a 4c		 jp	 SHORT $LN5@m_atan2
  0012d	75 4a		 jne	 SHORT $LN5@m_atan2
$LN4@m_atan2:

; 542  :         if (copysign(1., x) == 1.)

  0012f	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR x$[rsp]
  00135	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00143	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  0014b	7a 16		 jp	 SHORT $LN2@m_atan2
  0014d	75 14		 jne	 SHORT $LN2@m_atan2

; 543  :             /* atan2(+-y, +inf) = atan2(+-0, +x) = +-0. */
; 544  :             return copysign(0., y);

  0014f	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR y$[rsp]
  00155	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  0015f	eb 29		 jmp	 SHORT $LN12@m_atan2

; 545  :         else

  00161	eb 16		 jmp	 SHORT $LN1@m_atan2
$LN2@m_atan2:

; 546  :             /* atan2(+-y, -inf) = atan2(+-0., -x) = +-pi. */
; 547  :             return copysign(Py_MATH_PI, y);

  00163	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR y$[rsp]
  00169	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@400921fb54442d18
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00177	eb 11		 jmp	 SHORT $LN12@m_atan2
$LN1@m_atan2:
$LN5@m_atan2:

; 548  :     }
; 549  :     return atan2(y, x);

  00179	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR x$[rsp]
  0017f	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00185	e8 00 00 00 00	 call	 atan2
$LN12@m_atan2:

; 550  : }

  0018a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0018e	c3		 ret	 0
m_atan2	ENDP
_TEXT	ENDS
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_2 DD imagerel math_2
	DD	imagerel math_2+413
	DD	imagerel $unwind$math_2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_2 DD 011301H
	DD	0c213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_2
_TEXT	SEGMENT
y$ = 48
x$ = 56
ox$ = 64
oy$ = 72
r$ = 80
args$ = 112
func$ = 120
funcname$ = 128
math_2	PROC						; COMDAT

; 824  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 825  :     PyObject *ox, *oy;
; 826  :     double x, y, r;
; 827  :     if (! PyArg_UnpackTuple(args, funcname, 2, 2, &ox, &oy))

  00013	48 8d 44 24 48	 lea	 rax, QWORD PTR oy$[rsp]
  00018	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0001d	48 8d 44 24 40	 lea	 rax, QWORD PTR ox$[rsp]
  00022	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00027	41 b9 02 00 00
	00		 mov	 r9d, 2
  0002d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00033	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR funcname$[rsp]
  0003b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR args$[rsp]
  00040	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00045	85 c0		 test	 eax, eax
  00047	75 07		 jne	 SHORT $LN12@math_2

; 828  :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 48 01 00 00	 jmp	 $LN13@math_2
$LN12@math_2:

; 829  :     x = PyFloat_AsDouble(ox);

  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ox$[rsp]
  00055	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0005a	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR x$[rsp], xmm0

; 830  :     y = PyFloat_AsDouble(oy);

  00060	48 8b 4c 24 48	 mov	 rcx, QWORD PTR oy$[rsp]
  00065	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0006a	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR y$[rsp], xmm0

; 831  :     if ((x == -1.0 || y == -1.0) && PyErr_Occurred())

  00070	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00076	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0007e	7a 02		 jp	 SHORT $LN15@math_2
  00080	74 12		 je	 SHORT $LN10@math_2
$LN15@math_2:
  00082	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00088	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00090	7a 13		 jp	 SHORT $LN11@math_2
  00092	75 11		 jne	 SHORT $LN11@math_2
$LN10@math_2:
  00094	e8 00 00 00 00	 call	 PyErr_Occurred
  00099	48 85 c0	 test	 rax, rax
  0009c	74 07		 je	 SHORT $LN11@math_2

; 832  :         return NULL;

  0009e	33 c0		 xor	 eax, eax
  000a0	e9 f3 00 00 00	 jmp	 $LN13@math_2
$LN11@math_2:

; 833  :     errno = 0;

  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ab	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 834  :     PyFPE_START_PROTECT("in math_2", return 0);
; 835  :     r = (*func)(x, y);

  000b1	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR y$[rsp]
  000b7	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000bd	ff 54 24 78	 call	 QWORD PTR func$[rsp]
  000c1	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR r$[rsp], xmm0

; 836  :     PyFPE_END_PROTECT(r);
; 837  :     if (Py_IS_NAN(r)) {

  000c7	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000d3	85 c0		 test	 eax, eax
  000d5	74 3c		 je	 SHORT $LN9@math_2

; 838  :         if (!Py_IS_NAN(x) && !Py_IS_NAN(y))

  000d7	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000e3	85 c0		 test	 eax, eax
  000e5	75 1e		 jne	 SHORT $LN8@math_2
  000e7	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000f3	85 c0		 test	 eax, eax
  000f5	75 0e		 jne	 SHORT $LN8@math_2

; 839  :             errno = EDOM;

  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000fd	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 840  :         else

  00103	eb 0c		 jmp	 SHORT $LN7@math_2
$LN8@math_2:

; 841  :             errno = 0;

  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0010b	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN7@math_2:

; 842  :     }
; 843  :     else if (Py_IS_INFINITY(r)) {

  00111	eb 5a		 jmp	 SHORT $LN6@math_2
$LN9@math_2:
  00113	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0011f	85 c0		 test	 eax, eax
  00121	75 4a		 jne	 SHORT $LN5@math_2
  00123	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0012f	85 c0		 test	 eax, eax
  00131	75 3a		 jne	 SHORT $LN5@math_2

; 844  :         if (Py_IS_FINITE(x) && Py_IS_FINITE(y))

  00133	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0013f	85 c0		 test	 eax, eax
  00141	74 1e		 je	 SHORT $LN4@math_2
  00143	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0014f	85 c0		 test	 eax, eax
  00151	74 0e		 je	 SHORT $LN4@math_2

; 845  :             errno = ERANGE;

  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00159	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 846  :         else

  0015f	eb 0c		 jmp	 SHORT $LN3@math_2
$LN4@math_2:

; 847  :             errno = 0;

  00161	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00167	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN3@math_2:
$LN5@math_2:
$LN6@math_2:

; 848  :     }
; 849  :     if (errno && is_error(r))

  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00173	83 38 00	 cmp	 DWORD PTR [rax], 0
  00176	74 15		 je	 SHORT $LN2@math_2
  00178	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0017e	e8 00 00 00 00	 call	 is_error
  00183	85 c0		 test	 eax, eax
  00185	74 06		 je	 SHORT $LN2@math_2

; 850  :         return NULL;

  00187	33 c0		 xor	 eax, eax
  00189	eb 0d		 jmp	 SHORT $LN13@math_2

; 851  :     else

  0018b	eb 0b		 jmp	 SHORT $LN1@math_2
$LN2@math_2:

; 852  :         return PyFloat_FromDouble(r);

  0018d	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  00193	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN1@math_2:
$LN13@math_2:

; 853  : }

  00198	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0019c	c3		 ret	 0
math_2	ENDP
_TEXT	ENDS
EXTRN	_Py_atanh:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_atanh DD imagerel math_atanh
	DD	imagerel math_atanh+39
	DD	imagerel $unwind$math_atanh
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_atanh DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_atanh
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_atanh PROC						; COMDAT

; 887  :       "atanh(x)\n\nReturn the hyperbolic arc tangent (measured in radians) of x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_atanh
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_atanh ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	__imp_ceil:PROC
EXTRN	_PyObject_LookupSpecial:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_ceil DD imagerel math_ceil
	DD	imagerel math_ceil+139
	DD	imagerel $unwind$math_ceil
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_ceil DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_ceil
_TEXT	SEGMENT
method$ = 32
result$ = 40
self$ = 64
number$ = 72
math_ceil PROC						; COMDAT

; 889  : static PyObject * math_ceil(PyObject *self, PyObject *number) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 890  :     _Py_IDENTIFIER(__ceil__);
; 891  :     PyObject *method, *result;
; 892  : 
; 893  :     method = _PyObject_LookupSpecial(number, &PyId___ceil__);

  0000e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___ceil__@?1??math_ceil@@9@9
  00013	8b c0		 mov	 eax, eax
  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0001b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00024	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00028	48 8b d0	 mov	 rdx, rax
  0002b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR number$[rsp]
  00030	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00035	48 89 44 24 20	 mov	 QWORD PTR method$[rsp], rax

; 894  :     if (method == NULL) {

  0003a	48 83 7c 24 20
	00		 cmp	 QWORD PTR method$[rsp], 0
  00040	75 24		 jne	 SHORT $LN2@math_ceil

; 895  :         if (PyErr_Occurred())

  00042	e8 00 00 00 00	 call	 PyErr_Occurred
  00047	48 85 c0	 test	 rax, rax
  0004a	74 04		 je	 SHORT $LN1@math_ceil

; 896  :             return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 36		 jmp	 SHORT $LN3@math_ceil
$LN1@math_ceil:

; 897  :         return math_1_to_int(number, ceil, 0);

  00050	45 33 c0	 xor	 r8d, r8d
  00053	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_ceil
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR number$[rsp]
  0005f	e8 00 00 00 00	 call	 math_1_to_int
  00064	eb 20		 jmp	 SHORT $LN3@math_ceil
$LN2@math_ceil:

; 898  :     }
; 899  :     result = PyObject_CallFunctionObjArgs(method, NULL);

  00066	33 d2		 xor	 edx, edx
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR method$[rsp]
  0006d	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  00072	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 900  :     Py_DECREF(method);

  00077	48 8b 4c 24 20	 mov	 rcx, QWORD PTR method$[rsp]
  0007c	e8 00 00 00 00	 call	 _Py_DecRef

; 901  :     return result;

  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN3@math_ceil:

; 902  : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
math_ceil ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyLong_FromDouble:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\mathmodule.c
pdata	SEGMENT
$pdata$math_1_to_int DD imagerel math_1_to_int
	DD	imagerel math_1_to_int+51
	DD	imagerel $unwind$math_1_to_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_1_to_int DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_1_to_int
_TEXT	SEGMENT
arg$ = 48
func$ = 56
can_overflow$ = 64
math_1_to_int PROC					; COMDAT

; 818  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 819  :     return math_1_to_whatever(arg, func, PyLong_FromDouble, can_overflow);

  00013	44 8b 4c 24 40	 mov	 r9d, DWORD PTR can_overflow$[rsp]
  00018	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyLong_FromDouble
  0001f	48 8b 54 24 38	 mov	 rdx, QWORD PTR func$[rsp]
  00024	48 8b 4c 24 30	 mov	 rcx, QWORD PTR arg$[rsp]
  00029	e8 00 00 00 00	 call	 math_1_to_whatever

; 820  : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
math_1_to_int ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_copysign DD imagerel math_copysign
	DD	imagerel math_copysign+43
	DD	imagerel $unwind$math_copysign
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_copysign DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_copysign
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_copysign PROC					; COMDAT

; 911  :       "copysign(1.0, -0.0) \nreturns -1.0.\n")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08PLCMNBBP@copysign?$AA@
  00015	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp__copysign
  0001c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  00021	e8 00 00 00 00	 call	 math_2
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
math_copysign ENDP
_TEXT	ENDS
EXTRN	cos:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_cos DD imagerel math_cos
	DD	imagerel math_cos+39
	DD	imagerel $unwind$math_cos
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_cos DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_cos
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_cos PROC						; COMDAT

; 913  :       "cos(x)\n\nReturn the cosine of x (measured in radians).")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cos
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_cos ENDP
_TEXT	ENDS
EXTRN	cosh:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_cosh DD imagerel math_cosh
	DD	imagerel math_cosh+42
	DD	imagerel $unwind$math_cosh
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_cosh DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_cosh
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_cosh PROC						; COMDAT

; 915  :       "cosh(x)\n\nReturn the hyperbolic cosine of x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cosh
  0001b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  00020	e8 00 00 00 00	 call	 math_1
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
math_cosh ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_erf DD imagerel math_erf
	DD	imagerel math_erf+36
	DD	imagerel $unwind$math_erf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_erf DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_erf
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_erf PROC						; COMDAT

; 917  :        "erf(x)\n\nError function at x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_erf
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001a	e8 00 00 00 00	 call	 math_1a
  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
math_erf ENDP
_TEXT	ENDS
PUBLIC	__real@3ff8000000000000
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_erf DD	imagerel m_erf
	DD	imagerel m_erf+171
	DD	imagerel $unwind$m_erf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_erf DD 010a01H
	DD	0820aH
xdata	ENDS
;	COMDAT __real@3ff8000000000000
CONST	SEGMENT
__real@3ff8000000000000 DQ 03ff8000000000000r	; 1.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT m_erf
_TEXT	SEGMENT
cf$ = 32
absx$ = 40
tv77 = 48
x$ = 80
m_erf	PROC						; COMDAT

; 484  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 485  :     double absx, cf;
; 486  : 
; 487  :     if (Py_IS_NAN(x))

  0000a	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00016	85 c0		 test	 eax, eax
  00018	74 0b		 je	 SHORT $LN3@m_erf

; 488  :         return x;

  0001a	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00020	e9 81 00 00 00	 jmp	 $LN4@m_erf
$LN3@m_erf:

; 489  :     absx = fabs(x);

  00025	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0002b	e8 00 00 00 00	 call	 fabs
  00030	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR absx$[rsp], xmm0

; 490  :     if (absx < ERF_SERIES_CUTOFF)

  00036	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff8000000000000
  0003e	66 0f 2f 44 24
	28		 comisd	 xmm0, QWORD PTR absx$[rsp]
  00044	76 0f		 jbe	 SHORT $LN2@m_erf

; 491  :         return m_erf_series(x);

  00046	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0004c	e8 00 00 00 00	 call	 m_erf_series
  00051	eb 53		 jmp	 SHORT $LN4@m_erf

; 492  :     else {

  00053	eb 51		 jmp	 SHORT $LN1@m_erf
$LN2@m_erf:

; 493  :         cf = m_erfc_contfrac(absx);

  00055	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  0005b	e8 00 00 00 00	 call	 m_erfc_contfrac
  00060	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR cf$[rsp], xmm0

; 494  :         return x > 0.0 ? 1.0 - cf : cf - 1.0;

  00066	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0006c	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00074	76 16		 jbe	 SHORT $LN6@m_erf
  00076	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0007e	f2 0f 5c 44 24
	20		 subsd	 xmm0, QWORD PTR cf$[rsp]
  00084	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR tv77[rsp], xmm0
  0008a	eb 14		 jmp	 SHORT $LN7@m_erf
$LN6@m_erf:
  0008c	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR cf$[rsp]
  00092	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0009a	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR tv77[rsp], xmm0
$LN7@m_erf:
  000a0	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR tv77[rsp]
$LN1@m_erf:
$LN4@m_erf:

; 495  :     }
; 496  : }

  000a6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000aa	c3		 ret	 0
m_erf	ENDP
_TEXT	ENDS
PUBLIC	__mask@@NegDouble@
PUBLIC	__real@4000000000000000
PUBLIC	__real@4039800000000000
EXTRN	exp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_erf_series DD imagerel m_erf_series
	DD	imagerel m_erf_series+245
	DD	imagerel $unwind$m_erf_series
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_erf_series DD 010a01H
	DD	0a20aH
xdata	ENDS
;	COMDAT __mask@@NegDouble@
CONST	SEGMENT
__mask@@NegDouble@ DB 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@4039800000000000
CONST	SEGMENT
__real@4039800000000000 DQ 04039800000000000r	; 25.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT m_erf_series
_TEXT	SEGMENT
x2$ = 32
i$ = 40
saved_errno$ = 44
acc$ = 48
fk$ = 56
result$ = 64
tv72 = 72
x$ = 96
m_erf_series PROC					; COMDAT

; 422  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 423  :     double x2, acc, fk, result;
; 424  :     int i, saved_errno;
; 425  : 
; 426  :     x2 = x * x;

  0000a	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00010	f2 0f 59 44 24
	60		 mulsd	 xmm0, QWORD PTR x$[rsp]
  00016	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x2$[rsp], xmm0

; 427  :     acc = 0.0;

  0001c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00020	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR acc$[rsp], xmm0

; 428  :     fk = (double)ERF_SERIES_TERMS + 0.5;

  00026	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4039800000000000
  0002e	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR fk$[rsp], xmm0

; 429  :     for (i = 0; i < ERF_SERIES_TERMS; i++) {

  00034	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0003c	eb 0a		 jmp	 SHORT $LN3@m_erf_seri
$LN2@m_erf_seri:
  0003e	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00042	ff c0		 inc	 eax
  00044	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN3@m_erf_seri:
  00048	83 7c 24 28 19	 cmp	 DWORD PTR i$[rsp], 25
  0004d	7d 3e		 jge	 SHORT $LN1@m_erf_seri

; 430  :         acc = 2.0 + x2 * acc / fk;

  0004f	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x2$[rsp]
  00055	f2 0f 59 44 24
	30		 mulsd	 xmm0, QWORD PTR acc$[rsp]
  0005b	f2 0f 5e 44 24
	38		 divsd	 xmm0, QWORD PTR fk$[rsp]
  00061	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  00069	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0006d	66 0f 28 c1	 movapd	 xmm0, xmm1
  00071	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR acc$[rsp], xmm0

; 431  :         fk -= 1.0;

  00077	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR fk$[rsp]
  0007d	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00085	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR fk$[rsp], xmm0

; 432  :     }

  0008b	eb b1		 jmp	 SHORT $LN2@m_erf_seri
$LN1@m_erf_seri:

; 433  :     /* Make sure the exp call doesn't affect errno;
; 434  :        see m_erfc_contfrac for more. */
; 435  :     saved_errno = errno;

  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00093	8b 00		 mov	 eax, DWORD PTR [rax]
  00095	89 44 24 2c	 mov	 DWORD PTR saved_errno$[rsp], eax

; 436  :     result = acc * x * exp(-x2) / sqrtpi;

  00099	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR acc$[rsp]
  0009f	f2 0f 59 44 24
	60		 mulsd	 xmm0, QWORD PTR x$[rsp]
  000a5	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR tv72[rsp], xmm0
  000ab	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR x2$[rsp]
  000b1	66 0f 57 0d 00
	00 00 00	 xorpd	 xmm1, QWORD PTR __mask@@NegDouble@
  000b9	66 0f 28 c1	 movapd	 xmm0, xmm1
  000bd	e8 00 00 00 00	 call	 exp
  000c2	f2 0f 10 4c 24
	48		 movsdx	 xmm1, QWORD PTR tv72[rsp]
  000c8	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  000cc	66 0f 28 c1	 movapd	 xmm0, xmm1
  000d0	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR sqrtpi
  000d8	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR result$[rsp], xmm0

; 437  :     errno = saved_errno;

  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e4	8b 4c 24 2c	 mov	 ecx, DWORD PTR saved_errno$[rsp]
  000e8	89 08		 mov	 DWORD PTR [rax], ecx

; 438  :     return result;

  000ea	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR result$[rsp]

; 439  : }

  000f0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f4	c3		 ret	 0
m_erf_series ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@403e000000000000
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_erfc_contfrac DD imagerel m_erfc_contfrac
	DD	imagerel m_erfc_contfrac+469
	DD	imagerel $unwind$m_erfc_contfrac
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_erfc_contfrac DD 020d01H
	DD	011010dH
xdata	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@403e000000000000
CONST	SEGMENT
__real@403e000000000000 DQ 0403e000000000000r	; 30
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT m_erfc_contfrac
_TEXT	SEGMENT
p$ = 32
a$ = 40
x2$ = 48
i$ = 56
saved_errno$ = 60
p_last$ = 64
q_last$ = 72
q$ = 80
b$ = 88
result$ = 96
da$ = 104
temp$20446 = 112
tv80 = 120
x$ = 144
m_erfc_contfrac PROC					; COMDAT

; 452  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 453  :     double x2, a, da, p, p_last, q, q_last, b, result;
; 454  :     int i, saved_errno;
; 455  : 
; 456  :     if (x >= ERFC_CONTFRAC_CUTOFF)

  0000d	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00016	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@403e000000000000
  0001e	72 09		 jb	 SHORT $LN4@m_erfc_con

; 457  :         return 0.0;

  00020	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00024	e9 a4 01 00 00	 jmp	 $LN5@m_erfc_con
$LN4@m_erfc_con:

; 458  : 
; 459  :     x2 = x*x;

  00029	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00032	f2 0f 59 84 24
	90 00 00 00	 mulsd	 xmm0, QWORD PTR x$[rsp]
  0003b	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR x2$[rsp], xmm0

; 460  :     a = 0.0;

  00041	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00045	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR a$[rsp], xmm0

; 461  :     da = 0.5;

  0004b	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3fe0000000000000
  00053	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR da$[rsp], xmm0

; 462  :     p = 1.0; p_last = 0.0;

  00059	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00061	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR p$[rsp], xmm0
  00067	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0006b	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR p_last$[rsp], xmm0

; 463  :     q = da + x2; q_last = 1.0;

  00071	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR da$[rsp]
  00077	f2 0f 58 44 24
	30		 addsd	 xmm0, QWORD PTR x2$[rsp]
  0007d	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR q$[rsp], xmm0
  00083	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0008b	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR q_last$[rsp], xmm0

; 464  :     for (i = 0; i < ERFC_CONTFRAC_TERMS; i++) {

  00091	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00099	eb 0a		 jmp	 SHORT $LN3@m_erfc_con
$LN2@m_erfc_con:
  0009b	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0009f	ff c0		 inc	 eax
  000a1	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN3@m_erfc_con:
  000a5	83 7c 24 38 32	 cmp	 DWORD PTR i$[rsp], 50	; 00000032H
  000aa	0f 8d b1 00 00
	00		 jge	 $LN1@m_erfc_con

; 465  :         double temp;
; 466  :         a += da;

  000b0	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR a$[rsp]
  000b6	f2 0f 58 44 24
	68		 addsd	 xmm0, QWORD PTR da$[rsp]
  000bc	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR a$[rsp], xmm0

; 467  :         da += 2.0;

  000c2	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR da$[rsp]
  000c8	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@4000000000000000
  000d0	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR da$[rsp], xmm0

; 468  :         b = da + x2;

  000d6	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR da$[rsp]
  000dc	f2 0f 58 44 24
	30		 addsd	 xmm0, QWORD PTR x2$[rsp]
  000e2	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR b$[rsp], xmm0

; 469  :         temp = p; p = b*p - a*p_last; p_last = temp;

  000e8	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR p$[rsp]
  000ee	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR temp$20446[rsp], xmm0
  000f4	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR b$[rsp]
  000fa	f2 0f 59 44 24
	20		 mulsd	 xmm0, QWORD PTR p$[rsp]
  00100	f2 0f 10 4c 24
	28		 movsdx	 xmm1, QWORD PTR a$[rsp]
  00106	f2 0f 59 4c 24
	40		 mulsd	 xmm1, QWORD PTR p_last$[rsp]
  0010c	f2 0f 5c c1	 subsd	 xmm0, xmm1
  00110	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR p$[rsp], xmm0
  00116	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR temp$20446[rsp]
  0011c	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR p_last$[rsp], xmm0

; 470  :         temp = q; q = b*q - a*q_last; q_last = temp;

  00122	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR q$[rsp]
  00128	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR temp$20446[rsp], xmm0
  0012e	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR b$[rsp]
  00134	f2 0f 59 44 24
	50		 mulsd	 xmm0, QWORD PTR q$[rsp]
  0013a	f2 0f 10 4c 24
	28		 movsdx	 xmm1, QWORD PTR a$[rsp]
  00140	f2 0f 59 4c 24
	48		 mulsd	 xmm1, QWORD PTR q_last$[rsp]
  00146	f2 0f 5c c1	 subsd	 xmm0, xmm1
  0014a	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR q$[rsp], xmm0
  00150	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR temp$20446[rsp]
  00156	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR q_last$[rsp], xmm0

; 471  :     }

  0015c	e9 3a ff ff ff	 jmp	 $LN2@m_erfc_con
$LN1@m_erfc_con:

; 472  :     /* Issue #8986: On some platforms, exp sets errno on underflow to zero;
; 473  :        save the current errno value so that we can restore it later. */
; 474  :     saved_errno = errno;

  00161	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00167	8b 00		 mov	 eax, DWORD PTR [rax]
  00169	89 44 24 3c	 mov	 DWORD PTR saved_errno$[rsp], eax

; 475  :     result = p / q * x * exp(-x2) / sqrtpi;

  0016d	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR p$[rsp]
  00173	f2 0f 5e 44 24
	50		 divsd	 xmm0, QWORD PTR q$[rsp]
  00179	f2 0f 59 84 24
	90 00 00 00	 mulsd	 xmm0, QWORD PTR x$[rsp]
  00182	f2 0f 11 44 24
	78		 movsdx	 QWORD PTR tv80[rsp], xmm0
  00188	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR x2$[rsp]
  0018e	66 0f 57 0d 00
	00 00 00	 xorpd	 xmm1, QWORD PTR __mask@@NegDouble@
  00196	66 0f 28 c1	 movapd	 xmm0, xmm1
  0019a	e8 00 00 00 00	 call	 exp
  0019f	f2 0f 10 4c 24
	78		 movsdx	 xmm1, QWORD PTR tv80[rsp]
  001a5	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  001a9	66 0f 28 c1	 movapd	 xmm0, xmm1
  001ad	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR sqrtpi
  001b5	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR result$[rsp], xmm0

; 476  :     errno = saved_errno;

  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001c1	8b 4c 24 3c	 mov	 ecx, DWORD PTR saved_errno$[rsp]
  001c5	89 08		 mov	 DWORD PTR [rax], ecx

; 477  :     return result;

  001c7	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR result$[rsp]
$LN5@m_erfc_con:

; 478  : }

  001cd	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001d4	c3		 ret	 0
m_erfc_contfrac ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_1a DD imagerel math_1a
	DD	imagerel math_1a+136
	DD	imagerel $unwind$math_1a
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_1a DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_1a
_TEXT	SEGMENT
x$ = 32
r$ = 40
arg$ = 64
func$ = 72
math_1a	PROC						; COMDAT

; 769  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 770  :     double x, r;
; 771  :     x = PyFloat_AsDouble(arg);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR arg$[rsp]
  00013	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00018	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 772  :     if (x == -1.0 && PyErr_Occurred())

  0001e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00024	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0002c	7a 10		 jp	 SHORT $LN2@math_1a
  0002e	75 0e		 jne	 SHORT $LN2@math_1a
  00030	e8 00 00 00 00	 call	 PyErr_Occurred
  00035	48 85 c0	 test	 rax, rax
  00038	74 04		 je	 SHORT $LN2@math_1a

; 773  :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 45		 jmp	 SHORT $LN3@math_1a
$LN2@math_1a:

; 774  :     errno = 0;

  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00044	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 775  :     PyFPE_START_PROTECT("in math_1a", return 0);
; 776  :     r = (*func)(x);

  0004a	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00050	ff 54 24 48	 call	 QWORD PTR func$[rsp]
  00054	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR r$[rsp], xmm0

; 777  :     PyFPE_END_PROTECT(r);
; 778  :     if (errno && is_error(r))

  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00060	83 38 00	 cmp	 DWORD PTR [rax], 0
  00063	74 13		 je	 SHORT $LN1@math_1a
  00065	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0006b	e8 00 00 00 00	 call	 is_error
  00070	85 c0		 test	 eax, eax
  00072	74 04		 je	 SHORT $LN1@math_1a

; 779  :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	eb 0b		 jmp	 SHORT $LN3@math_1a
$LN1@math_1a:

; 780  :     return PyFloat_FromDouble(r);

  00078	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0007e	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN3@math_1a:

; 781  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
math_1a	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_erfc DD imagerel math_erfc
	DD	imagerel math_erfc+36
	DD	imagerel $unwind$math_erfc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_erfc DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_erfc
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_erfc PROC						; COMDAT

; 919  :        "erfc(x)\n\nComplementary error function at x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_erfc
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001a	e8 00 00 00 00	 call	 math_1a
  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
math_erfc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_erfc DD imagerel m_erfc
	DD	imagerel m_erfc+179
	DD	imagerel $unwind$m_erfc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_erfc DD 010a01H
	DD	0820aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT m_erfc
_TEXT	SEGMENT
cf$ = 32
absx$ = 40
tv77 = 48
x$ = 80
m_erfc	PROC						; COMDAT

; 502  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 503  :     double absx, cf;
; 504  : 
; 505  :     if (Py_IS_NAN(x))

  0000a	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00016	85 c0		 test	 eax, eax
  00018	74 0b		 je	 SHORT $LN3@m_erfc

; 506  :         return x;

  0001a	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00020	e9 89 00 00 00	 jmp	 $LN4@m_erfc
$LN3@m_erfc:

; 507  :     absx = fabs(x);

  00025	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0002b	e8 00 00 00 00	 call	 fabs
  00030	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR absx$[rsp], xmm0

; 508  :     if (absx < ERF_SERIES_CUTOFF)

  00036	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff8000000000000
  0003e	66 0f 2f 44 24
	28		 comisd	 xmm0, QWORD PTR absx$[rsp]
  00044	76 1f		 jbe	 SHORT $LN2@m_erfc

; 509  :         return 1.0 - m_erf_series(x);

  00046	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0004c	e8 00 00 00 00	 call	 m_erf_series
  00051	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@3ff0000000000000
  00059	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0005d	66 0f 28 c1	 movapd	 xmm0, xmm1
  00061	eb 4b		 jmp	 SHORT $LN4@m_erfc

; 510  :     else {

  00063	eb 49		 jmp	 SHORT $LN1@m_erfc
$LN2@m_erfc:

; 511  :         cf = m_erfc_contfrac(absx);

  00065	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  0006b	e8 00 00 00 00	 call	 m_erfc_contfrac
  00070	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR cf$[rsp], xmm0

; 512  :         return x > 0.0 ? cf : 2.0 - cf;

  00076	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0007c	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00084	76 0e		 jbe	 SHORT $LN6@m_erfc
  00086	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR cf$[rsp]
  0008c	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR tv77[rsp], xmm0
  00092	eb 14		 jmp	 SHORT $LN7@m_erfc
$LN6@m_erfc:
  00094	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  0009c	f2 0f 5c 44 24
	20		 subsd	 xmm0, QWORD PTR cf$[rsp]
  000a2	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR tv77[rsp], xmm0
$LN7@m_erfc:
  000a8	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR tv77[rsp]
$LN1@m_erfc:
$LN4@m_erfc:

; 513  :     }
; 514  : }

  000ae	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b2	c3		 ret	 0
m_erfc	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_exp DD imagerel math_exp
	DD	imagerel math_exp+42
	DD	imagerel $unwind$math_exp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_exp DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_exp
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_exp PROC						; COMDAT

; 921  :       "exp(x)\n\nReturn e raised to the power of x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:exp
  0001b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  00020	e8 00 00 00 00	 call	 math_1
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
math_exp ENDP
_TEXT	ENDS
EXTRN	_Py_expm1:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_expm1 DD imagerel math_expm1
	DD	imagerel math_expm1+42
	DD	imagerel $unwind$math_expm1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_expm1 DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_expm1
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_expm1 PROC						; COMDAT

; 925  :       "evaluation of exp(x)-1 for small x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_expm1
  0001b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  00020	e8 00 00 00 00	 call	 math_1
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
math_expm1 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_fabs DD imagerel math_fabs
	DD	imagerel math_fabs+39
	DD	imagerel $unwind$math_fabs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_fabs DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_fabs
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_fabs PROC						; COMDAT

; 927  :       "fabs(x)\n\nReturn the absolute value of the float x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fabs
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_fabs ENDP
_TEXT	ENDS
EXTRN	__imp_floor:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_floor DD imagerel math_floor
	DD	imagerel math_floor+139
	DD	imagerel $unwind$math_floor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_floor DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_floor
_TEXT	SEGMENT
method$ = 32
result$ = 40
self$ = 64
number$ = 72
math_floor PROC						; COMDAT

; 929  : static PyObject * math_floor(PyObject *self, PyObject *number) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 930  :     _Py_IDENTIFIER(__floor__);
; 931  :     PyObject *method, *result;
; 932  : 
; 933  :     method = _PyObject_LookupSpecial(number, &PyId___floor__);

  0000e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___floor__@?1??math_floor@@9@9
  00013	8b c0		 mov	 eax, eax
  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0001b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00024	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00028	48 8b d0	 mov	 rdx, rax
  0002b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR number$[rsp]
  00030	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00035	48 89 44 24 20	 mov	 QWORD PTR method$[rsp], rax

; 934  :     if (method == NULL) {

  0003a	48 83 7c 24 20
	00		 cmp	 QWORD PTR method$[rsp], 0
  00040	75 24		 jne	 SHORT $LN2@math_floor

; 935  :         if (PyErr_Occurred())

  00042	e8 00 00 00 00	 call	 PyErr_Occurred
  00047	48 85 c0	 test	 rax, rax
  0004a	74 04		 je	 SHORT $LN1@math_floor

; 936  :             return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 36		 jmp	 SHORT $LN3@math_floor
$LN1@math_floor:

; 937  :         return math_1_to_int(number, floor, 0);

  00050	45 33 c0	 xor	 r8d, r8d
  00053	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_floor
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR number$[rsp]
  0005f	e8 00 00 00 00	 call	 math_1_to_int
  00064	eb 20		 jmp	 SHORT $LN3@math_floor
$LN2@math_floor:

; 938  :     }
; 939  :     result = PyObject_CallFunctionObjArgs(method, NULL);

  00066	33 d2		 xor	 edx, edx
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR method$[rsp]
  0006d	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  00072	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 940  :     Py_DECREF(method);

  00077	48 8b 4c 24 20	 mov	 rcx, QWORD PTR method$[rsp]
  0007c	e8 00 00 00 00	 call	 _Py_DecRef

; 941  :     return result;

  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN3@math_floor:

; 942  : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
math_floor ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_gamma DD imagerel math_gamma
	DD	imagerel math_gamma+36
	DD	imagerel $unwind$math_gamma
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_gamma DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_gamma
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_gamma PROC						; COMDAT

; 949  :       "gamma(x)\n\nGamma function at x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_tgamma
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001a	e8 00 00 00 00	 call	 math_1a
  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
math_gamma ENDP
_TEXT	ENDS
PUBLIC	__real@3fd0000000000000
PUBLIC	__real@4061800000000000
PUBLIC	__real@4069000000000000
PUBLIC	__real@3bc79ca10c924223
PUBLIC	__real@4037000000000000
EXTRN	pow:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_tgamma DD imagerel m_tgamma
	DD	imagerel m_tgamma+1271
	DD	imagerel $unwind$m_tgamma
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_tgamma DD 020d01H
	DD	011010dH
xdata	ENDS
;	COMDAT __real@3fd0000000000000
CONST	SEGMENT
__real@3fd0000000000000 DQ 03fd0000000000000r	; 0.25
CONST	ENDS
;	COMDAT __real@4061800000000000
CONST	SEGMENT
__real@4061800000000000 DQ 04061800000000000r	; 140
CONST	ENDS
;	COMDAT __real@4069000000000000
CONST	SEGMENT
__real@4069000000000000 DQ 04069000000000000r	; 200
CONST	ENDS
;	COMDAT __real@3bc79ca10c924223
CONST	SEGMENT
__real@3bc79ca10c924223 DQ 03bc79ca10c924223r	; 1e-020
CONST	ENDS
;	COMDAT __real@4037000000000000
CONST	SEGMENT
__real@4037000000000000 DQ 04037000000000000r	; 23
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT m_tgamma
_TEXT	SEGMENT
y$ = 32
z$ = 40
sqrtpow$ = 48
r$ = 56
absx$ = 64
q$20384 = 72
q$20386 = 80
tv150 = 88
tv154 = 96
tv157 = 104
tv176 = 112
x$ = 144
m_tgamma PROC						; COMDAT

; 228  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 229  :     double absx, r, y, z, sqrtpow;
; 230  : 
; 231  :     /* special cases */
; 232  :     if (!Py_IS_FINITE(x)) {

  0000d	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0001c	85 c0		 test	 eax, eax
  0001e	75 5a		 jne	 SHORT $LN22@m_tgamma

; 233  :         if (Py_IS_NAN(x) || x > 0.0)

  00020	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0002f	85 c0		 test	 eax, eax
  00031	75 13		 jne	 SHORT $LN20@m_tgamma
  00033	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  0003c	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00044	76 10		 jbe	 SHORT $LN21@m_tgamma
$LN20@m_tgamma:

; 234  :             return x;  /* tgamma(nan) = nan, tgamma(inf) = inf */

  00046	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  0004f	e9 9b 04 00 00	 jmp	 $LN23@m_tgamma

; 235  :         else {

  00054	eb 24		 jmp	 SHORT $LN19@m_tgamma
$LN21@m_tgamma:

; 236  :             errno = EDOM;

  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005c	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 237  :             return Py_NAN;  /* tgamma(-inf) = nan, invalid */

  00062	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00069	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0006d	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@0000000000000000
  00075	e9 75 04 00 00	 jmp	 $LN23@m_tgamma
$LN19@m_tgamma:
$LN22@m_tgamma:

; 238  :         }
; 239  :     }
; 240  :     if (x == 0.0) {

  0007a	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00083	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0008b	7a 2d		 jp	 SHORT $LN18@m_tgamma
  0008d	75 2b		 jne	 SHORT $LN18@m_tgamma

; 241  :         errno = EDOM;

  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00095	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 242  :         /* tgamma(+-0.0) = +-inf, divide-by-zero */
; 243  :         return copysign(Py_HUGE_VAL, x);

  0009b	f2 0f 10 8c 24
	90 00 00 00	 movsdx	 xmm1, QWORD PTR x$[rsp]
  000a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  000ab	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  000b5	e9 35 04 00 00	 jmp	 $LN23@m_tgamma
$LN18@m_tgamma:

; 244  :     }
; 245  : 
; 246  :     /* integer arguments */
; 247  :     if (x == floor(x)) {

  000ba	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  000c9	f2 0f 10 8c 24
	90 00 00 00	 movsdx	 xmm1, QWORD PTR x$[rsp]
  000d2	66 0f 2e c8	 ucomisd xmm1, xmm0
  000d6	7a 66		 jp	 SHORT $LN17@m_tgamma
  000d8	75 64		 jne	 SHORT $LN17@m_tgamma

; 248  :         if (x < 0.0) {

  000da	66 0f 57 c0	 xorpd	 xmm0, xmm0
  000de	66 0f 2f 84 24
	90 00 00 00	 comisd	 xmm0, QWORD PTR x$[rsp]
  000e7	76 24		 jbe	 SHORT $LN16@m_tgamma

; 249  :             errno = EDOM;  /* tgamma(n) = nan, invalid for */

  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ef	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 250  :             return Py_NAN; /* negative integers n */

  000f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  000fc	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  00100	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@0000000000000000
  00108	e9 e2 03 00 00	 jmp	 $LN23@m_tgamma
$LN16@m_tgamma:

; 251  :         }
; 252  :         if (x <= NGAMMA_INTEGRAL)

  0010d	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4037000000000000
  00115	66 0f 2f 84 24
	90 00 00 00	 comisd	 xmm0, QWORD PTR x$[rsp]
  0011e	72 1e		 jb	 SHORT $LN15@m_tgamma

; 253  :             return gamma_integral[(int)x - 1];

  00120	f2 0f 2c 84 24
	90 00 00 00	 cvttsd2si eax, QWORD PTR x$[rsp]
  00129	ff c8		 dec	 eax
  0012b	48 98		 cdqe
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gamma_integral
  00134	f2 0f 10 04 c1	 movsdx	 xmm0, QWORD PTR [rcx+rax*8]
  00139	e9 b1 03 00 00	 jmp	 $LN23@m_tgamma
$LN15@m_tgamma:
$LN17@m_tgamma:

; 254  :     }
; 255  :     absx = fabs(x);

  0013e	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00147	e8 00 00 00 00	 call	 fabs
  0014c	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR absx$[rsp], xmm0

; 256  : 
; 257  :     /* tiny arguments:  tgamma(x) ~ 1/x for x near 0 */
; 258  :     if (absx < 1e-20) {

  00152	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3bc79ca10c924223
  0015a	66 0f 2f 44 24
	40		 comisd	 xmm0, QWORD PTR absx$[rsp]
  00160	76 4e		 jbe	 SHORT $LN14@m_tgamma

; 259  :         r = 1.0/x;

  00162	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  0016a	f2 0f 5e 84 24
	90 00 00 00	 divsd	 xmm0, QWORD PTR x$[rsp]
  00173	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 260  :         if (Py_IS_INFINITY(r))

  00179	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0017f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00185	85 c0		 test	 eax, eax
  00187	75 1c		 jne	 SHORT $LN13@m_tgamma
  00189	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00195	85 c0		 test	 eax, eax
  00197	75 0c		 jne	 SHORT $LN13@m_tgamma

; 261  :             errno = ERANGE;

  00199	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0019f	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
$LN13@m_tgamma:

; 262  :         return r;

  001a5	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  001ab	e9 3f 03 00 00	 jmp	 $LN23@m_tgamma
$LN14@m_tgamma:

; 263  :     }
; 264  : 
; 265  :     /* large arguments: assuming IEEE 754 doubles, tgamma(x) overflows for
; 266  :        x > 200, and underflows to +-0.0 for x < -200, not a negative
; 267  :        integer. */
; 268  :     if (absx > 200.0) {

  001b0	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  001b6	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4069000000000000
  001be	76 4c		 jbe	 SHORT $LN12@m_tgamma

; 269  :         if (x < 0.0) {

  001c0	66 0f 57 c0	 xorpd	 xmm0, xmm0
  001c4	66 0f 2f 84 24
	90 00 00 00	 comisd	 xmm0, QWORD PTR x$[rsp]
  001cd	76 21		 jbe	 SHORT $LN11@m_tgamma

; 270  :             return 0.0/sinpi(x);

  001cf	f2 0f 10 84 24
	90 00 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  001d8	e8 00 00 00 00	 call	 sinpi
  001dd	66 0f 57 c9	 xorpd	 xmm1, xmm1
  001e1	f2 0f 5e c8	 divsd	 xmm1, xmm0
  001e5	66 0f 28 c1	 movapd	 xmm0, xmm1
  001e9	e9 01 03 00 00	 jmp	 $LN23@m_tgamma

; 271  :         }
; 272  :         else {

  001ee	eb 1c		 jmp	 SHORT $LN10@m_tgamma
$LN11@m_tgamma:

; 273  :             errno = ERANGE;

  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001f6	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 274  :             return Py_HUGE_VAL;

  001fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00203	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  00207	e9 e3 02 00 00	 jmp	 $LN23@m_tgamma
$LN10@m_tgamma:
$LN12@m_tgamma:

; 275  :         }
; 276  :     }
; 277  : 
; 278  :     y = absx + lanczos_g_minus_half;

  0020c	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  00212	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR lanczos_g_minus_half
  0021a	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR y$[rsp], xmm0

; 279  :     /* compute error in sum */
; 280  :     if (absx > lanczos_g_minus_half) {

  00220	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  00226	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR lanczos_g_minus_half
  0022e	76 28		 jbe	 SHORT $LN9@m_tgamma

; 281  :         /* note: the correction can be foiled by an optimizing
; 282  :            compiler that (incorrectly) thinks that an expression like
; 283  :            a + b - a - b can be optimized to 0.0.  This shouldn't
; 284  :            happen in a standards-conforming compiler. */
; 285  :         double q = y - absx;

  00230	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00236	f2 0f 5c 44 24
	40		 subsd	 xmm0, QWORD PTR absx$[rsp]
  0023c	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR q$20384[rsp], xmm0

; 286  :         z = q - lanczos_g_minus_half;

  00242	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR q$20384[rsp]
  00248	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR lanczos_g_minus_half
  00250	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR z$[rsp], xmm0

; 287  :     }
; 288  :     else {

  00256	eb 26		 jmp	 SHORT $LN8@m_tgamma
$LN9@m_tgamma:

; 289  :         double q = y - lanczos_g_minus_half;

  00258	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR y$[rsp]
  0025e	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR lanczos_g_minus_half
  00266	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR q$20386[rsp], xmm0

; 290  :         z = q - absx;

  0026c	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR q$20386[rsp]
  00272	f2 0f 5c 44 24
	40		 subsd	 xmm0, QWORD PTR absx$[rsp]
  00278	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR z$[rsp], xmm0
$LN8@m_tgamma:

; 291  :     }
; 292  :     z = z * lanczos_g / y;

  0027e	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR z$[rsp]
  00284	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR lanczos_g
  0028c	f2 0f 5e 44 24
	20		 divsd	 xmm0, QWORD PTR y$[rsp]
  00292	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR z$[rsp], xmm0

; 293  :     if (x < 0.0) {

  00298	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0029c	66 0f 2f 84 24
	90 00 00 00	 comisd	 xmm0, QWORD PTR x$[rsp]
  002a5	0f 86 30 01 00
	00		 jbe	 $LN7@m_tgamma

; 294  :         r = -pi / sinpi(absx) / absx * exp(y) / lanczos_sum(absx);

  002ab	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR pi
  002b3	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  002bb	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR tv150[rsp], xmm0
  002c1	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  002c7	e8 00 00 00 00	 call	 sinpi
  002cc	f2 0f 10 4c 24
	58		 movsdx	 xmm1, QWORD PTR tv150[rsp]
  002d2	f2 0f 5e c8	 divsd	 xmm1, xmm0
  002d6	66 0f 28 c1	 movapd	 xmm0, xmm1
  002da	f2 0f 5e 44 24
	40		 divsd	 xmm0, QWORD PTR absx$[rsp]
  002e0	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR tv154[rsp], xmm0
  002e6	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR y$[rsp]
  002ec	e8 00 00 00 00	 call	 exp
  002f1	f2 0f 10 4c 24
	60		 movsdx	 xmm1, QWORD PTR tv154[rsp]
  002f7	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  002fb	66 0f 28 c1	 movapd	 xmm0, xmm1
  002ff	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR tv157[rsp], xmm0
  00305	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  0030b	e8 00 00 00 00	 call	 lanczos_sum
  00310	f2 0f 10 4c 24
	68		 movsdx	 xmm1, QWORD PTR tv157[rsp]
  00316	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0031a	66 0f 28 c1	 movapd	 xmm0, xmm1
  0031e	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 295  :         r -= z * r;

  00324	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR z$[rsp]
  0032a	f2 0f 59 44 24
	38		 mulsd	 xmm0, QWORD PTR r$[rsp]
  00330	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR r$[rsp]
  00336	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0033a	66 0f 28 c1	 movapd	 xmm0, xmm1
  0033e	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 296  :         if (absx < 140.0) {

  00344	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4061800000000000
  0034c	66 0f 2f 44 24
	40		 comisd	 xmm0, QWORD PTR absx$[rsp]
  00352	76 33		 jbe	 SHORT $LN6@m_tgamma

; 297  :             r /= pow(y, absx - 0.5);

  00354	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  0035a	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00362	66 0f 28 c8	 movapd	 xmm1, xmm0
  00366	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR y$[rsp]
  0036c	e8 00 00 00 00	 call	 pow
  00371	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR r$[rsp]
  00377	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0037b	66 0f 28 c1	 movapd	 xmm0, xmm1
  0037f	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 298  :         }
; 299  :         else {

  00385	eb 4f		 jmp	 SHORT $LN5@m_tgamma
$LN6@m_tgamma:

; 300  :             sqrtpow = pow(y, absx / 2.0 - 0.25);

  00387	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  0038d	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  00395	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fd0000000000000
  0039d	66 0f 28 c8	 movapd	 xmm1, xmm0
  003a1	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR y$[rsp]
  003a7	e8 00 00 00 00	 call	 pow
  003ac	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR sqrtpow$[rsp], xmm0

; 301  :             r /= sqrtpow;

  003b2	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  003b8	f2 0f 5e 44 24
	30		 divsd	 xmm0, QWORD PTR sqrtpow$[rsp]
  003be	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 302  :             r /= sqrtpow;

  003c4	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  003ca	f2 0f 5e 44 24
	30		 divsd	 xmm0, QWORD PTR sqrtpow$[rsp]
  003d0	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0
$LN5@m_tgamma:

; 303  :         }
; 304  :     }
; 305  :     else {

  003d6	e9 e2 00 00 00	 jmp	 $LN4@m_tgamma
$LN7@m_tgamma:

; 306  :         r = lanczos_sum(absx) / exp(y);

  003db	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  003e1	e8 00 00 00 00	 call	 lanczos_sum
  003e6	f2 0f 11 44 24
	70		 movsdx	 QWORD PTR tv176[rsp], xmm0
  003ec	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR y$[rsp]
  003f2	e8 00 00 00 00	 call	 exp
  003f7	f2 0f 10 4c 24
	70		 movsdx	 xmm1, QWORD PTR tv176[rsp]
  003fd	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00401	66 0f 28 c1	 movapd	 xmm0, xmm1
  00405	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 307  :         r += z * r;

  0040b	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR z$[rsp]
  00411	f2 0f 59 44 24
	38		 mulsd	 xmm0, QWORD PTR r$[rsp]
  00417	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR r$[rsp]
  0041d	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00421	66 0f 28 c1	 movapd	 xmm0, xmm1
  00425	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 308  :         if (absx < 140.0) {

  0042b	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4061800000000000
  00433	66 0f 2f 44 24
	40		 comisd	 xmm0, QWORD PTR absx$[rsp]
  00439	76 33		 jbe	 SHORT $LN3@m_tgamma

; 309  :             r *= pow(y, absx - 0.5);

  0043b	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  00441	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00449	66 0f 28 c8	 movapd	 xmm1, xmm0
  0044d	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00453	e8 00 00 00 00	 call	 pow
  00458	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR r$[rsp]
  0045e	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00462	66 0f 28 c1	 movapd	 xmm0, xmm1
  00466	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 310  :         }
; 311  :         else {

  0046c	eb 4f		 jmp	 SHORT $LN2@m_tgamma
$LN3@m_tgamma:

; 312  :             sqrtpow = pow(y, absx / 2.0 - 0.25);

  0046e	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  00474	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@4000000000000000
  0047c	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fd0000000000000
  00484	66 0f 28 c8	 movapd	 xmm1, xmm0
  00488	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR y$[rsp]
  0048e	e8 00 00 00 00	 call	 pow
  00493	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR sqrtpow$[rsp], xmm0

; 313  :             r *= sqrtpow;

  00499	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0049f	f2 0f 59 44 24
	30		 mulsd	 xmm0, QWORD PTR sqrtpow$[rsp]
  004a5	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 314  :             r *= sqrtpow;

  004ab	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  004b1	f2 0f 59 44 24
	30		 mulsd	 xmm0, QWORD PTR sqrtpow$[rsp]
  004b7	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0
$LN2@m_tgamma:
$LN4@m_tgamma:

; 315  :         }
; 316  :     }
; 317  :     if (Py_IS_INFINITY(r))

  004bd	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  004c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  004c9	85 c0		 test	 eax, eax
  004cb	75 1c		 jne	 SHORT $LN1@m_tgamma
  004cd	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  004d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  004d9	85 c0		 test	 eax, eax
  004db	75 0c		 jne	 SHORT $LN1@m_tgamma

; 318  :         errno = ERANGE;

  004dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004e3	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
$LN1@m_tgamma:

; 319  :     return r;

  004e9	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
$LN23@m_tgamma:

; 320  : }

  004ef	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  004f6	c3		 ret	 0
m_tgamma ENDP
_TEXT	ENDS
PUBLIC	__real@e979b5d96fe285c6
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_1CC@LJDFJEPK@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA4?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@PBLIOKNO@?$AAP?$AAy?$AA_?$AAI?$AAS?$AA_?$AAF?$AAI?$AAN?$AAI?$AAT?$AAE?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	sin:PROC
EXTRN	round:PROC
EXTRN	fmod:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$sinpi DD	imagerel sinpi
	DD	imagerel sinpi+504
	DD	imagerel $unwind$sinpi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sinpi DD 010a01H
	DD	0820aH
xdata	ENDS
;	COMDAT __real@e979b5d96fe285c6
CONST	SEGMENT
__real@e979b5d96fe285c6 DQ 0e979b5d96fe285c6r	; -1.23e+200
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@LJDFJEPK@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA4?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@LJDFJEPK@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA4?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'n', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'n', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, '4', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@PBLIOKNO@?$AAP?$AAy?$AA_?$AAI?$AAS?$AA_?$AAF?$AAI?$AAN?$AAI?$AAT?$AAE?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@PBLIOKNO@?$AAP?$AAy?$AA_?$AAI?$AAS?$AA_?$AAF?$AAI?$AAN?$AAI?$AAT?$AAE?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'F', 00H
	DB	'I', 00H, 'N', 00H, 'I', 00H, 'T', 00H, 'E', 00H, '(', 00H, 'x'
	DB	00H, ')', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT sinpi
_TEXT	SEGMENT
y$ = 32
n$ = 40
r$ = 48
tv86 = 56
x$ = 80
sinpi	PROC						; COMDAT

; 71   : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 72   :     double y, r;
; 73   :     int n;
; 74   :     /* this function should only ever be called for finite arguments */
; 75   :     assert(Py_IS_FINITE(x));

  0000a	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00016	85 c0		 test	 eax, eax
  00018	75 1c		 jne	 SHORT $LN11@sinpi
  0001a	41 b8 4b 00 00
	00		 mov	 r8d, 75			; 0000004bH
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@BGHOHNN@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAa?$AAt?$AAh?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@PBLIOKNO@?$AAP?$AAy?$AA_?$AAI?$AAS?$AA_?$AAF?$AAI?$AAN?$AAI?$AAT?$AAE?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00034	33 c0		 xor	 eax, eax
$LN11@sinpi:

; 76   :     y = fmod(fabs(x), 2.0);

  00036	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0003c	e8 00 00 00 00	 call	 fabs
  00041	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  00049	e8 00 00 00 00	 call	 fmod
  0004e	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR y$[rsp], xmm0

; 77   :     n = (int)round(2.0*y);

  00054	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  0005c	f2 0f 59 44 24
	20		 mulsd	 xmm0, QWORD PTR y$[rsp]
  00062	e8 00 00 00 00	 call	 round
  00067	f2 0f 2c c0	 cvttsd2si eax, xmm0
  0006b	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 78   :     assert(0 <= n && n <= 4);

  0006f	83 7c 24 28 00	 cmp	 DWORD PTR n$[rsp], 0
  00074	7c 07		 jl	 SHORT $LN12@sinpi
  00076	83 7c 24 28 04	 cmp	 DWORD PTR n$[rsp], 4
  0007b	7e 1c		 jle	 SHORT $LN13@sinpi
$LN12@sinpi:
  0007d	41 b8 4e 00 00
	00		 mov	 r8d, 78			; 0000004eH
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@BGHOHNN@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAa?$AAt?$AAh?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@LJDFJEPK@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA4?$AA?$AA@
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00097	33 c0		 xor	 eax, eax
$LN13@sinpi:

; 79   :     switch (n) {

  00099	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  0009d	89 44 24 38	 mov	 DWORD PTR tv86[rsp], eax
  000a1	83 7c 24 38 00	 cmp	 DWORD PTR tv86[rsp], 0
  000a6	74 29		 je	 SHORT $LN6@sinpi
  000a8	83 7c 24 38 01	 cmp	 DWORD PTR tv86[rsp], 1
  000ad	74 40		 je	 SHORT $LN5@sinpi
  000af	83 7c 24 38 02	 cmp	 DWORD PTR tv86[rsp], 2
  000b4	74 67		 je	 SHORT $LN4@sinpi
  000b6	83 7c 24 38 03	 cmp	 DWORD PTR tv86[rsp], 3
  000bb	0f 84 8a 00 00
	00		 je	 $LN3@sinpi
  000c1	83 7c 24 38 04	 cmp	 DWORD PTR tv86[rsp], 4
  000c6	0f 84 b2 00 00
	00		 je	 $LN2@sinpi
  000cc	e9 d8 00 00 00	 jmp	 $LN1@sinpi
$LN6@sinpi:

; 80   :     case 0:
; 81   :         r = sin(pi*y);

  000d1	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR pi
  000d9	f2 0f 59 44 24
	20		 mulsd	 xmm0, QWORD PTR y$[rsp]
  000df	e8 00 00 00 00	 call	 sin
  000e4	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR r$[rsp], xmm0

; 82   :         break;

  000ea	e9 ea 00 00 00	 jmp	 $LN7@sinpi
$LN5@sinpi:

; 83   :     case 1:
; 84   :         r = cos(pi*(y-0.5));

  000ef	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR y$[rsp]
  000f5	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fe0000000000000
  000fd	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR pi
  00105	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00109	66 0f 28 c1	 movapd	 xmm0, xmm1
  0010d	e8 00 00 00 00	 call	 cos
  00112	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR r$[rsp], xmm0

; 85   :         break;

  00118	e9 bc 00 00 00	 jmp	 $LN7@sinpi
$LN4@sinpi:

; 86   :     case 2:
; 87   :         /* N.B. -sin(pi*(y-1.0)) is *not* equivalent: it would give
; 88   :            -0.0 instead of 0.0 when y == 1.0. */
; 89   :         r = sin(pi*(1.0-y));

  0011d	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00125	f2 0f 5c 44 24
	20		 subsd	 xmm0, QWORD PTR y$[rsp]
  0012b	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR pi
  00133	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00137	66 0f 28 c1	 movapd	 xmm0, xmm1
  0013b	e8 00 00 00 00	 call	 sin
  00140	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR r$[rsp], xmm0

; 90   :         break;

  00146	e9 8e 00 00 00	 jmp	 $LN7@sinpi
$LN3@sinpi:

; 91   :     case 3:
; 92   :         r = -cos(pi*(y-1.5));

  0014b	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00151	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff8000000000000
  00159	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR pi
  00161	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00165	66 0f 28 c1	 movapd	 xmm0, xmm1
  00169	e8 00 00 00 00	 call	 cos
  0016e	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00176	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR r$[rsp], xmm0

; 93   :         break;

  0017c	eb 5b		 jmp	 SHORT $LN7@sinpi
$LN2@sinpi:

; 94   :     case 4:
; 95   :         r = sin(pi*(y-2.0));

  0017e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00184	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@4000000000000000
  0018c	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR pi
  00194	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00198	66 0f 28 c1	 movapd	 xmm0, xmm1
  0019c	e8 00 00 00 00	 call	 sin
  001a1	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR r$[rsp], xmm0

; 96   :         break;

  001a7	eb 30		 jmp	 SHORT $LN7@sinpi
$LN1@sinpi:

; 97   :     default:
; 98   :         assert(0);  /* should never get here */

  001a9	33 c0		 xor	 eax, eax
  001ab	85 c0		 test	 eax, eax
  001ad	75 1c		 jne	 SHORT $LN14@sinpi
  001af	41 b8 62 00 00
	00		 mov	 r8d, 98			; 00000062H
  001b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@BGHOHNN@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAa?$AAt?$AAh?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001c9	33 c0		 xor	 eax, eax
$LN14@sinpi:

; 99   :         r = -1.23e200; /* silence gcc warning */

  001cb	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@e979b5d96fe285c6
  001d3	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR r$[rsp], xmm0
$LN7@sinpi:

; 100  :     }
; 101  :     return copysign(1.0, x)*r;

  001d9	f2 0f 10 4c 24
	50		 movsdx	 xmm1, QWORD PTR x$[rsp]
  001df	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  001ed	f2 0f 59 44 24
	30		 mulsd	 xmm0, QWORD PTR r$[rsp]

; 102  : }

  001f3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f7	c3		 ret	 0
sinpi	ENDP
_TEXT	ENDS
PUBLIC	__real@4014000000000000
PUBLIC	??_C@_1BA@IIFAMJHE@?$AAx?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$lanczos_sum DD imagerel lanczos_sum
	DD	imagerel lanczos_sum+305
	DD	imagerel $unwind$lanczos_sum
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lanczos_sum DD 010a01H
	DD	0820aH
xdata	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT ??_C@_1BA@IIFAMJHE@?$AAx?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BA@IIFAMJHE@?$AAx?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AA?$AA@ DB 'x'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, '.', 00H, '0', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT lanczos_sum
_TEXT	SEGMENT
den$ = 32
i$ = 40
num$ = 48
x$ = 80
lanczos_sum PROC					; COMDAT

; 199  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 200  :     double num = 0.0, den = 0.0;

  0000a	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0000e	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR num$[rsp], xmm0
  00014	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00018	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR den$[rsp], xmm0

; 201  :     int i;
; 202  :     assert(x > 0.0);

  0001e	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00024	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  0002c	77 1c		 ja	 SHORT $LN10@lanczos_su
  0002e	41 b8 ca 00 00
	00		 mov	 r8d, 202		; 000000caH
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@BGHOHNN@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAa?$AAt?$AAh?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BA@IIFAMJHE@?$AAx?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?4?$AA0?$AA?$AA@
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00048	33 c0		 xor	 eax, eax
$LN10@lanczos_su:

; 203  :     /* evaluate the rational function lanczos_sum(x).  For large
; 204  :        x, the obvious algorithm risks overflow, so we instead
; 205  :        rescale the denominator and numerator of the rational
; 206  :        function by x**(1-LANCZOS_N) and treat this as a
; 207  :        rational function in 1/x.  This also reduces the error for
; 208  :        larger x values.  The choice of cutoff point (5.0 below) is
; 209  :        somewhat arbitrary; in tests, smaller cutoff values than
; 210  :        this resulted in lower accuracy. */
; 211  :     if (x < 5.0) {

  0004a	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4014000000000000
  00052	66 0f 2f 44 24
	50		 comisd	 xmm0, QWORD PTR x$[rsp]
  00058	76 63		 jbe	 SHORT $LN7@lanczos_su

; 212  :         for (i = LANCZOS_N; --i >= 0; ) {

  0005a	c7 44 24 28 0d
	00 00 00	 mov	 DWORD PTR i$[rsp], 13
$LN6@lanczos_su:
  00062	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00066	ff c8		 dec	 eax
  00068	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  0006c	83 7c 24 28 00	 cmp	 DWORD PTR i$[rsp], 0
  00071	7c 48		 jl	 SHORT $LN5@lanczos_su

; 213  :             num = num * x + lanczos_num_coeffs[i];

  00073	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR num$[rsp]
  00079	f2 0f 59 44 24
	50		 mulsd	 xmm0, QWORD PTR x$[rsp]
  0007f	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lanczos_num_coeffs
  0008b	f2 0f 58 04 c1	 addsd	 xmm0, QWORD PTR [rcx+rax*8]
  00090	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR num$[rsp], xmm0

; 214  :             den = den * x + lanczos_den_coeffs[i];

  00096	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR den$[rsp]
  0009c	f2 0f 59 44 24
	50		 mulsd	 xmm0, QWORD PTR x$[rsp]
  000a2	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lanczos_den_coeffs
  000ae	f2 0f 58 04 c1	 addsd	 xmm0, QWORD PTR [rcx+rax*8]
  000b3	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR den$[rsp], xmm0

; 215  :         }

  000b9	eb a7		 jmp	 SHORT $LN6@lanczos_su
$LN5@lanczos_su:

; 216  :     }
; 217  :     else {

  000bb	eb 63		 jmp	 SHORT $LN4@lanczos_su
$LN7@lanczos_su:

; 218  :         for (i = 0; i < LANCZOS_N; i++) {

  000bd	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000c5	eb 0a		 jmp	 SHORT $LN3@lanczos_su
$LN2@lanczos_su:
  000c7	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000cb	ff c0		 inc	 eax
  000cd	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN3@lanczos_su:
  000d1	83 7c 24 28 0d	 cmp	 DWORD PTR i$[rsp], 13
  000d6	7d 48		 jge	 SHORT $LN1@lanczos_su

; 219  :             num = num / x + lanczos_num_coeffs[i];

  000d8	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR num$[rsp]
  000de	f2 0f 5e 44 24
	50		 divsd	 xmm0, QWORD PTR x$[rsp]
  000e4	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lanczos_num_coeffs
  000f0	f2 0f 58 04 c1	 addsd	 xmm0, QWORD PTR [rcx+rax*8]
  000f5	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR num$[rsp], xmm0

; 220  :             den = den / x + lanczos_den_coeffs[i];

  000fb	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR den$[rsp]
  00101	f2 0f 5e 44 24
	50		 divsd	 xmm0, QWORD PTR x$[rsp]
  00107	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lanczos_den_coeffs
  00113	f2 0f 58 04 c1	 addsd	 xmm0, QWORD PTR [rcx+rax*8]
  00118	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR den$[rsp], xmm0

; 221  :         }

  0011e	eb a7		 jmp	 SHORT $LN2@lanczos_su
$LN1@lanczos_su:
$LN4@lanczos_su:

; 222  :     }
; 223  :     return num/den;

  00120	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR num$[rsp]
  00126	f2 0f 5e 44 24
	20		 divsd	 xmm0, QWORD PTR den$[rsp]

; 224  : }

  0012c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00130	c3		 ret	 0
lanczos_sum ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_lgamma DD imagerel math_lgamma
	DD	imagerel math_lgamma+36
	DD	imagerel $unwind$math_lgamma
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_lgamma DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_lgamma
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_lgamma PROC					; COMDAT

; 951  :       "lgamma(x)\n\nNatural logarithm of absolute value of Gamma function at x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_lgamma
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001a	e8 00 00 00 00	 call	 math_1a
  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
math_lgamma ENDP
_TEXT	ENDS
EXTRN	log:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_lgamma DD imagerel m_lgamma
	DD	imagerel m_lgamma+491
	DD	imagerel $unwind$m_lgamma
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_lgamma DD 010a01H
	DD	0820aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT m_lgamma
_TEXT	SEGMENT
r$ = 32
absx$ = 40
tv88 = 48
tv136 = 56
x$ = 80
m_lgamma PROC						; COMDAT

; 329  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 330  :     double r, absx;
; 331  : 
; 332  :     /* special cases */
; 333  :     if (!Py_IS_FINITE(x)) {

  0000a	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00016	85 c0		 test	 eax, eax
  00018	75 2d		 jne	 SHORT $LN9@m_lgamma

; 334  :         if (Py_IS_NAN(x))

  0001a	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00026	85 c0		 test	 eax, eax
  00028	74 0d		 je	 SHORT $LN8@m_lgamma

; 335  :             return x;  /* lgamma(nan) = nan */

  0002a	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00030	e9 b1 01 00 00	 jmp	 $LN10@m_lgamma

; 336  :         else

  00035	eb 10		 jmp	 SHORT $LN7@m_lgamma
$LN8@m_lgamma:

; 337  :             return Py_HUGE_VAL; /* lgamma(+-inf) = +inf */

  00037	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  0003e	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  00042	e9 9f 01 00 00	 jmp	 $LN10@m_lgamma
$LN7@m_lgamma:
$LN9@m_lgamma:

; 338  :     }
; 339  : 
; 340  :     /* integer arguments */
; 341  :     if (x == floor(x) && x <= 2.0) {

  00047	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  00053	f2 0f 10 4c 24
	50		 movsdx	 xmm1, QWORD PTR x$[rsp]
  00059	66 0f 2e c8	 ucomisd xmm1, xmm0
  0005d	7a 45		 jp	 SHORT $LN6@m_lgamma
  0005f	75 43		 jne	 SHORT $LN6@m_lgamma
  00061	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  00069	66 0f 2f 44 24
	50		 comisd	 xmm0, QWORD PTR x$[rsp]
  0006f	72 33		 jb	 SHORT $LN6@m_lgamma

; 342  :         if (x <= 0.0) {

  00071	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00075	66 0f 2f 44 24
	50		 comisd	 xmm0, QWORD PTR x$[rsp]
  0007b	72 1e		 jb	 SHORT $LN5@m_lgamma

; 343  :             errno = EDOM;  /* lgamma(n) = inf, divide-by-zero for */

  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00083	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 344  :             return Py_HUGE_VAL; /* integers n <= 0 */

  00089	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00090	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  00094	e9 4d 01 00 00	 jmp	 $LN10@m_lgamma

; 345  :         }
; 346  :         else {

  00099	eb 09		 jmp	 SHORT $LN4@m_lgamma
$LN5@m_lgamma:

; 347  :             return 0.0; /* lgamma(1) = lgamma(2) = 0.0 */

  0009b	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0009f	e9 42 01 00 00	 jmp	 $LN10@m_lgamma
$LN4@m_lgamma:
$LN6@m_lgamma:

; 348  :         }
; 349  :     }
; 350  : 
; 351  :     absx = fabs(x);

  000a4	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000aa	e8 00 00 00 00	 call	 fabs
  000af	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR absx$[rsp], xmm0

; 352  :     /* tiny arguments: lgamma(x) ~ -log(fabs(x)) for small x */
; 353  :     if (absx < 1e-20)

  000b5	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3bc79ca10c924223
  000bd	66 0f 2f 44 24
	28		 comisd	 xmm0, QWORD PTR absx$[rsp]
  000c3	76 18		 jbe	 SHORT $LN3@m_lgamma

; 354  :         return -log(absx);

  000c5	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  000cb	e8 00 00 00 00	 call	 log
  000d0	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  000d8	e9 09 01 00 00	 jmp	 $LN10@m_lgamma
$LN3@m_lgamma:

; 355  : 
; 356  :     /* Lanczos' formula.  We could save a fraction of a ulp in accuracy by
; 357  :        having a second set of numerator coefficients for lanczos_sum that
; 358  :        absorbed the exp(-lanczos_g) term, and throwing out the lanczos_g
; 359  :        subtraction below; it's probably not worth it. */
; 360  :     r = log(lanczos_sum(absx)) - lanczos_g;

  000dd	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  000e3	e8 00 00 00 00	 call	 lanczos_sum
  000e8	e8 00 00 00 00	 call	 log
  000ed	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR lanczos_g
  000f5	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR r$[rsp], xmm0

; 361  :     r += (absx - 0.5) * (log(absx + lanczos_g - 0.5) - 1);

  000fb	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  00101	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00109	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR tv88[rsp], xmm0
  0010f	f2 0f 10 4c 24
	28		 movsdx	 xmm1, QWORD PTR absx$[rsp]
  00115	f2 0f 58 0d 00
	00 00 00	 addsd	 xmm1, QWORD PTR lanczos_g
  0011d	f2 0f 5c 0d 00
	00 00 00	 subsd	 xmm1, QWORD PTR __real@3fe0000000000000
  00125	66 0f 28 c1	 movapd	 xmm0, xmm1
  00129	e8 00 00 00 00	 call	 log
  0012e	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3ff0000000000000
  00136	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR tv88[rsp]
  0013c	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  00140	66 0f 28 c1	 movapd	 xmm0, xmm1
  00144	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR r$[rsp]
  0014a	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0014e	66 0f 28 c1	 movapd	 xmm0, xmm1
  00152	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR r$[rsp], xmm0

; 362  :     if (x < 0.0)

  00158	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0015c	66 0f 2f 44 24
	50		 comisd	 xmm0, QWORD PTR x$[rsp]
  00162	76 50		 jbe	 SHORT $LN2@m_lgamma

; 363  :         /* Use reflection formula to get value for negative x. */
; 364  :         r = logpi - log(fabs(sinpi(absx))) - log(absx) - r;

  00164	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  0016a	e8 00 00 00 00	 call	 sinpi
  0016f	e8 00 00 00 00	 call	 fabs
  00174	e8 00 00 00 00	 call	 log
  00179	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR logpi
  00181	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00185	66 0f 28 c1	 movapd	 xmm0, xmm1
  00189	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR tv136[rsp], xmm0
  0018f	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR absx$[rsp]
  00195	e8 00 00 00 00	 call	 log
  0019a	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR tv136[rsp]
  001a0	f2 0f 5c c8	 subsd	 xmm1, xmm0
  001a4	66 0f 28 c1	 movapd	 xmm0, xmm1
  001a8	f2 0f 5c 44 24
	20		 subsd	 xmm0, QWORD PTR r$[rsp]
  001ae	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR r$[rsp], xmm0
$LN2@m_lgamma:

; 365  :     if (Py_IS_INFINITY(r))

  001b4	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR r$[rsp]
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  001c0	85 c0		 test	 eax, eax
  001c2	75 1c		 jne	 SHORT $LN1@m_lgamma
  001c4	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR r$[rsp]
  001ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  001d0	85 c0		 test	 eax, eax
  001d2	75 0c		 jne	 SHORT $LN1@m_lgamma

; 366  :         errno = ERANGE;

  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001da	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
$LN1@m_lgamma:

; 367  :     return r;

  001e0	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR r$[rsp]
$LN10@m_lgamma:

; 368  : }

  001e6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ea	c3		 ret	 0
m_lgamma ENDP
_TEXT	ENDS
EXTRN	_Py_log1p:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_log1p DD imagerel math_log1p
	DD	imagerel math_log1p+39
	DD	imagerel $unwind$math_log1p
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_log1p DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_log1p
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_log1p PROC						; COMDAT

; 954  :       "The result is computed in a way which is accurate for x near zero.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_log1p
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_log1p ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_sin DD imagerel math_sin
	DD	imagerel math_sin+39
	DD	imagerel $unwind$math_sin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_sin DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_sin
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_sin PROC						; COMDAT

; 956  :       "sin(x)\n\nReturn the sine of x (measured in radians).")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sin
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_sin ENDP
_TEXT	ENDS
EXTRN	sinh:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_sinh DD imagerel math_sinh
	DD	imagerel math_sinh+42
	DD	imagerel $unwind$math_sinh
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_sinh DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_sinh
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_sinh PROC						; COMDAT

; 958  :       "sinh(x)\n\nReturn the hyperbolic sine of x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sinh
  0001b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  00020	e8 00 00 00 00	 call	 math_1
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
math_sinh ENDP
_TEXT	ENDS
EXTRN	sqrt:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_sqrt DD imagerel math_sqrt
	DD	imagerel math_sqrt+39
	DD	imagerel $unwind$math_sqrt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_sqrt DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_sqrt
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_sqrt PROC						; COMDAT

; 960  :       "sqrt(x)\n\nReturn the square root of x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sqrt
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_sqrt ENDP
_TEXT	ENDS
EXTRN	tan:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_tan DD imagerel math_tan
	DD	imagerel math_tan+39
	DD	imagerel $unwind$math_tan
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_tan DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_tan
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_tan PROC						; COMDAT

; 962  :       "tan(x)\n\nReturn the tangent of x (measured in radians).")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:tan
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_tan ENDP
_TEXT	ENDS
EXTRN	tanh:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_tanh DD imagerel math_tanh
	DD	imagerel math_tanh+39
	DD	imagerel $unwind$math_tanh
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_tanh DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_tanh
_TEXT	SEGMENT
self$ = 48
args$ = 56
math_tanh PROC						; COMDAT

; 964  :       "tanh(x)\n\nReturn the hyperbolic tangent of x.")

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:tanh
  00018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001d	e8 00 00 00 00	 call	 math_1
  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
math_tanh ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@LOHCFCIC@?$AAf?$AAa?$AAb?$AAs?$AA?$CI?$AAy?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAf?$AAa?$AAb?$AAs?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BD@NNCHNLEA@?9inf?5?$CL?5inf?5in?5fsum?$AA@ ; `string'
PUBLIC	??_C@_0BO@ICLMANFM@intermediate?5overflow?5in?5fsum?$AA@ ; `string'
PUBLIC	??_C@_1IE@MMDCAPAA@?$AA?$CI?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAM?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAA?$AAL?$AAS?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$HM@ ; `string'
PUBLIC	??_C@_1CC@PDANENC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AA?$AA@ ; `string'
EXTRN	PyMem_Free:PROC
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_GetIter:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_fsum DD imagerel math_fsum
	DD	imagerel math_fsum+1798
	DD	imagerel $unwind$math_fsum
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_fsum DD 021101H
	DD	0390111H
xdata	ENDS
;	COMDAT ??_C@_1CE@LOHCFCIC@?$AAf?$AAa?$AAb?$AAs?$AA?$CI?$AAy?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAf?$AAa?$AAb?$AAs?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@LOHCFCIC@?$AAf?$AAa?$AAb?$AAs?$AA?$CI?$AAy?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAf?$AAa?$AAb?$AAs?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@ DB 'f'
	DB	00H, 'a', 00H, 'b', 00H, 's', 00H, '(', 00H, 'y', 00H, ')', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'b', 00H, 's'
	DB	00H, '(', 00H, 'x', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NNCHNLEA@?9inf?5?$CL?5inf?5in?5fsum?$AA@
CONST	SEGMENT
??_C@_0BD@NNCHNLEA@?9inf?5?$CL?5inf?5in?5fsum?$AA@ DB '-inf + inf in fsum'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ICLMANFM@intermediate?5overflow?5in?5fsum?$AA@
CONST	SEGMENT
??_C@_0BO@ICLMANFM@intermediate?5overflow?5in?5fsum?$AA@ DB 'intermediate'
	DB	' overflow in fsum', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1IE@MMDCAPAA@?$AA?$CI?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAM?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAA?$AAL?$AAS?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$HM@
CONST	SEGMENT
??_C@_1IE@MMDCAPAA@?$AA?$CI?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAM?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAA?$AAL?$AAS?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$HM@ DB '('
	DB	00H, 'm', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'M', 00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H, 'T'
	DB	00H, 'I', 00H, 'A', 00H, 'L', 00H, 'S', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 'p', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'p', 00H, 's', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, '(', 00H, 'm', 00H, ' ', 00H, '>', 00H, ' ', 00H, 'N'
	DB	00H, 'U', 00H, 'M', 00H, '_', 00H, 'P', 00H, 'A', 00H, 'R', 00H
	DB	'T', 00H, 'I', 00H, 'A', 00H, 'L', 00H, 'S', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'p', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@PDANENC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@PDANENC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'n', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'n', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, 'm', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT math_fsum
_TEXT	SEGMENT
lo$ = 32
p$ = 40
xsave$ = 48
ps$ = 64
y$ = 320
x$ = 328
iter$ = 336
n$ = 344
i$ = 352
special_sum$ = 360
inf_sum$ = 368
yr$ = 376
sum$ = 384
hi$ = 392
t$ = 400
item$ = 408
m$ = 416
j$ = 424
tv95 = 432
tv188 = 440
self$ = 464
seq$ = 472
math_fsum PROC						; COMDAT

; 1064 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H

; 1065 :     PyObject *item, *iter, *sum = NULL;

  00011	48 c7 84 24 80
	01 00 00 00 00
	00 00		 mov	 QWORD PTR sum$[rsp], 0

; 1066 :     Py_ssize_t i, j, n = 0, m = NUM_PARTIALS;

  0001d	48 c7 84 24 58
	01 00 00 00 00
	00 00		 mov	 QWORD PTR n$[rsp], 0
  00029	48 c7 84 24 a0
	01 00 00 20 00
	00 00		 mov	 QWORD PTR m$[rsp], 32	; 00000020H

; 1067 :     double x, y, t, ps[NUM_PARTIALS], *p = ps;

  00035	48 8d 44 24 40	 lea	 rax, QWORD PTR ps$[rsp]
  0003a	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 1068 :     double xsave, special_sum = 0.0, inf_sum = 0.0;

  0003f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00043	f2 0f 11 84 24
	68 01 00 00	 movsdx	 QWORD PTR special_sum$[rsp], xmm0
  0004c	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00050	f2 0f 11 84 24
	70 01 00 00	 movsdx	 QWORD PTR inf_sum$[rsp], xmm0

; 1069 :     volatile double hi, yr, lo;
; 1070 : 
; 1071 :     iter = PyObject_GetIter(seq);

  00059	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR seq$[rsp]
  00061	e8 00 00 00 00	 call	 PyObject_GetIter
  00066	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR iter$[rsp], rax

; 1072 :     if (iter == NULL)

  0006e	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR iter$[rsp], 0
  00077	75 07		 jne	 SHORT $LN30@math_fsum

; 1073 :         return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 7e 06 00 00	 jmp	 $LN31@math_fsum
$LN30@math_fsum:
$LN29@math_fsum:

; 1074 : 
; 1075 :     PyFPE_START_PROTECT("fsum", Py_DECREF(iter); return NULL)
; 1076 : 
; 1077 :     for(;;) {           /* for x in iterable */
; 1078 :         assert(0 <= n && n <= m);

  00080	48 83 bc 24 58
	01 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  00089	7c 12		 jl	 SHORT $LN33@math_fsum
  0008b	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00093	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR n$[rsp], rax
  0009b	7e 1c		 jle	 SHORT $LN34@math_fsum
$LN33@math_fsum:
  0009d	41 b8 36 04 00
	00		 mov	 r8d, 1078		; 00000436H
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@BGHOHNN@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAa?$AAt?$AAh?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@PDANENC@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AA?$AA@
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b7	33 c0		 xor	 eax, eax
$LN34@math_fsum:

; 1079 :         assert((m == NUM_PARTIALS && p == ps) ||
; 1080 :                (m >  NUM_PARTIALS && p != NULL));

  000b9	48 83 bc 24 a0
	01 00 00 20	 cmp	 QWORD PTR m$[rsp], 32	; 00000020H
  000c2	75 0c		 jne	 SHORT $LN35@math_fsum
  000c4	48 8d 44 24 40	 lea	 rax, QWORD PTR ps$[rsp]
  000c9	48 39 44 24 28	 cmp	 QWORD PTR p$[rsp], rax
  000ce	74 2f		 je	 SHORT $LN37@math_fsum
$LN35@math_fsum:
  000d0	48 83 bc 24 a0
	01 00 00 20	 cmp	 QWORD PTR m$[rsp], 32	; 00000020H
  000d9	7e 08		 jle	 SHORT $LN36@math_fsum
  000db	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$[rsp], 0
  000e1	75 1c		 jne	 SHORT $LN37@math_fsum
$LN36@math_fsum:
  000e3	41 b8 38 04 00
	00		 mov	 r8d, 1080		; 00000438H
  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@BGHOHNN@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAa?$AAt?$AAh?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1IE@MMDCAPAA@?$AA?$CI?$AAm?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAM?$AA_?$AAP?$AAA?$AAR?$AAT?$AAI?$AAA?$AAL?$AAS?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAp?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$HM@
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000fd	33 c0		 xor	 eax, eax
$LN37@math_fsum:

; 1081 : 
; 1082 :         item = PyIter_Next(iter);

  000ff	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  00107	e8 00 00 00 00	 call	 PyIter_Next
  0010c	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR item$[rsp], rax

; 1083 :         if (item == NULL) {

  00114	48 83 bc 24 98
	01 00 00 00	 cmp	 QWORD PTR item$[rsp], 0
  0011d	75 14		 jne	 SHORT $LN27@math_fsum

; 1084 :             if (PyErr_Occurred())

  0011f	e8 00 00 00 00	 call	 PyErr_Occurred
  00124	48 85 c0	 test	 rax, rax
  00127	74 05		 je	 SHORT $LN26@math_fsum

; 1085 :                 goto _fsum_error;

  00129	e9 a5 05 00 00	 jmp	 $_fsum_error$20896
$LN26@math_fsum:

; 1086 :             break;

  0012e	e9 ec 02 00 00	 jmp	 $LN28@math_fsum
$LN27@math_fsum:

; 1087 :         }
; 1088 :         x = PyFloat_AsDouble(item);

  00133	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  0013b	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00140	f2 0f 11 84 24
	48 01 00 00	 movsdx	 QWORD PTR x$[rsp], xmm0

; 1089 :         Py_DECREF(item);

  00149	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00151	e8 00 00 00 00	 call	 _Py_DecRef

; 1090 :         if (PyErr_Occurred())

  00156	e8 00 00 00 00	 call	 PyErr_Occurred
  0015b	48 85 c0	 test	 rax, rax
  0015e	74 05		 je	 SHORT $LN25@math_fsum

; 1091 :             goto _fsum_error;

  00160	e9 6e 05 00 00	 jmp	 $_fsum_error$20896
$LN25@math_fsum:

; 1092 : 
; 1093 :         xsave = x;

  00165	f2 0f 10 84 24
	48 01 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  0016e	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR xsave$[rsp], xmm0

; 1094 :         for (i = j = 0; j < n; j++) {       /* for y in partials */

  00174	48 c7 84 24 a8
	01 00 00 00 00
	00 00		 mov	 QWORD PTR j$[rsp], 0
  00180	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00188	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR i$[rsp], rax
  00190	eb 13		 jmp	 SHORT $LN24@math_fsum
$LN23@math_fsum:
  00192	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0019a	48 ff c0	 inc	 rax
  0019d	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR j$[rsp], rax
$LN24@math_fsum:
  001a5	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001ad	48 39 84 24 a8
	01 00 00	 cmp	 QWORD PTR j$[rsp], rax
  001b5	0f 8d 2f 01 00
	00		 jge	 $LN22@math_fsum

; 1095 :             y = p[j];

  001bb	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  001c0	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  001c8	f2 0f 10 04 c8	 movsdx	 xmm0, QWORD PTR [rax+rcx*8]
  001cd	f2 0f 11 84 24
	40 01 00 00	 movsdx	 QWORD PTR y$[rsp], xmm0

; 1096 :             if (fabs(x) < fabs(y)) {

  001d6	f2 0f 10 84 24
	48 01 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  001df	e8 00 00 00 00	 call	 fabs
  001e4	f2 0f 11 84 24
	b0 01 00 00	 movsdx	 QWORD PTR tv95[rsp], xmm0
  001ed	f2 0f 10 84 24
	40 01 00 00	 movsdx	 xmm0, QWORD PTR y$[rsp]
  001f6	e8 00 00 00 00	 call	 fabs
  001fb	f2 0f 10 8c 24
	b0 01 00 00	 movsdx	 xmm1, QWORD PTR tv95[rsp]
  00204	66 0f 2f c1	 comisd	 xmm0, xmm1
  00208	76 36		 jbe	 SHORT $LN21@math_fsum

; 1097 :                 t = x; x = y; y = t;

  0020a	f2 0f 10 84 24
	48 01 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00213	f2 0f 11 84 24
	90 01 00 00	 movsdx	 QWORD PTR t$[rsp], xmm0
  0021c	f2 0f 10 84 24
	40 01 00 00	 movsdx	 xmm0, QWORD PTR y$[rsp]
  00225	f2 0f 11 84 24
	48 01 00 00	 movsdx	 QWORD PTR x$[rsp], xmm0
  0022e	f2 0f 10 84 24
	90 01 00 00	 movsdx	 xmm0, QWORD PTR t$[rsp]
  00237	f2 0f 11 84 24
	40 01 00 00	 movsdx	 QWORD PTR y$[rsp], xmm0
$LN21@math_fsum:

; 1098 :             }
; 1099 :             hi = x + y;

  00240	f2 0f 10 84 24
	48 01 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00249	f2 0f 58 84 24
	40 01 00 00	 addsd	 xmm0, QWORD PTR y$[rsp]
  00252	f2 0f 11 84 24
	88 01 00 00	 movsdx	 QWORD PTR hi$[rsp], xmm0

; 1100 :             yr = hi - x;

  0025b	f2 0f 10 84 24
	88 01 00 00	 movsdx	 xmm0, QWORD PTR hi$[rsp]
  00264	f2 0f 5c 84 24
	48 01 00 00	 subsd	 xmm0, QWORD PTR x$[rsp]
  0026d	f2 0f 11 84 24
	78 01 00 00	 movsdx	 QWORD PTR yr$[rsp], xmm0

; 1101 :             lo = y - yr;

  00276	f2 0f 10 84 24
	78 01 00 00	 movsdx	 xmm0, QWORD PTR yr$[rsp]
  0027f	f2 0f 10 8c 24
	40 01 00 00	 movsdx	 xmm1, QWORD PTR y$[rsp]
  00288	f2 0f 5c c8	 subsd	 xmm1, xmm0
  0028c	66 0f 28 c1	 movapd	 xmm0, xmm1
  00290	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR lo$[rsp], xmm0

; 1102 :             if (lo != 0.0)

  00296	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR lo$[rsp]
  0029c	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  002a4	7a 02		 jp	 SHORT $LN42@math_fsum
  002a6	74 2b		 je	 SHORT $LN20@math_fsum
$LN42@math_fsum:

; 1103 :                 p[i++] = lo;

  002a8	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  002ad	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  002b5	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR lo$[rsp]
  002bb	f2 0f 11 04 c8	 movsdx	 QWORD PTR [rax+rcx*8], xmm0
  002c0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR i$[rsp]
  002c8	48 ff c0	 inc	 rax
  002cb	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR i$[rsp], rax
$LN20@math_fsum:

; 1104 :             x = hi;

  002d3	f2 0f 10 84 24
	88 01 00 00	 movsdx	 xmm0, QWORD PTR hi$[rsp]
  002dc	f2 0f 11 84 24
	48 01 00 00	 movsdx	 QWORD PTR x$[rsp], xmm0

; 1105 :         }

  002e5	e9 a8 fe ff ff	 jmp	 $LN23@math_fsum
$LN22@math_fsum:

; 1106 : 
; 1107 :         n = i;                              /* ps[i:] = [x] */

  002ea	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR i$[rsp]
  002f2	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR n$[rsp], rax

; 1108 :         if (x != 0.0) {

  002fa	f2 0f 10 84 24
	48 01 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00303	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0030b	7a 06		 jp	 SHORT $LN41@math_fsum
  0030d	0f 84 07 01 00
	00		 je	 $LN19@math_fsum
$LN41@math_fsum:

; 1109 :             if (! Py_IS_FINITE(x)) {

  00313	f2 0f 10 84 24
	48 01 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  0031c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00322	85 c0		 test	 eax, eax
  00324	0f 85 86 00 00
	00		 jne	 $LN18@math_fsum

; 1110 :                 /* a nonfinite x could arise either as
; 1111 :                    a result of intermediate overflow, or
; 1112 :                    as a result of a nan or inf in the
; 1113 :                    summands */
; 1114 :                 if (Py_IS_FINITE(xsave)) {

  0032a	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR xsave$[rsp]
  00330	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00336	85 c0		 test	 eax, eax
  00338	74 18		 je	 SHORT $LN17@math_fsum

; 1115 :                     PyErr_SetString(PyExc_OverflowError,
; 1116 :                           "intermediate overflow in fsum");

  0033a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@ICLMANFM@intermediate?5overflow?5in?5fsum?$AA@
  00341	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00348	e8 00 00 00 00	 call	 PyErr_SetString

; 1117 :                     goto _fsum_error;

  0034d	e9 81 03 00 00	 jmp	 $_fsum_error$20896
$LN17@math_fsum:

; 1118 :                 }
; 1119 :                 if (Py_IS_INFINITY(xsave))

  00352	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR xsave$[rsp]
  00358	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0035e	85 c0		 test	 eax, eax
  00360	75 28		 jne	 SHORT $LN16@math_fsum
  00362	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR xsave$[rsp]
  00368	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0036e	85 c0		 test	 eax, eax
  00370	75 18		 jne	 SHORT $LN16@math_fsum

; 1120 :                     inf_sum += xsave;

  00372	f2 0f 10 84 24
	70 01 00 00	 movsdx	 xmm0, QWORD PTR inf_sum$[rsp]
  0037b	f2 0f 58 44 24
	30		 addsd	 xmm0, QWORD PTR xsave$[rsp]
  00381	f2 0f 11 84 24
	70 01 00 00	 movsdx	 QWORD PTR inf_sum$[rsp], xmm0
$LN16@math_fsum:

; 1121 :                 special_sum += xsave;

  0038a	f2 0f 10 84 24
	68 01 00 00	 movsdx	 xmm0, QWORD PTR special_sum$[rsp]
  00393	f2 0f 58 44 24
	30		 addsd	 xmm0, QWORD PTR xsave$[rsp]
  00399	f2 0f 11 84 24
	68 01 00 00	 movsdx	 QWORD PTR special_sum$[rsp], xmm0

; 1122 :                 /* reset partials */
; 1123 :                 n = 0;

  003a2	48 c7 84 24 58
	01 00 00 00 00
	00 00		 mov	 QWORD PTR n$[rsp], 0
  003ae	eb 6a		 jmp	 SHORT $LN15@math_fsum
$LN18@math_fsum:

; 1124 :             }
; 1125 :             else if (n >= m && _fsum_realloc(&p, n, ps, &m))

  003b0	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR m$[rsp]
  003b8	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR n$[rsp], rax
  003c0	7c 2a		 jl	 SHORT $LN14@math_fsum
  003c2	4c 8d 8c 24 a0
	01 00 00	 lea	 r9, QWORD PTR m$[rsp]
  003ca	4c 8d 44 24 40	 lea	 r8, QWORD PTR ps$[rsp]
  003cf	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  003d7	48 8d 4c 24 28	 lea	 rcx, QWORD PTR p$[rsp]
  003dc	e8 00 00 00 00	 call	 _fsum_realloc
  003e1	85 c0		 test	 eax, eax
  003e3	74 07		 je	 SHORT $LN14@math_fsum

; 1126 :                 goto _fsum_error;

  003e5	e9 e9 02 00 00	 jmp	 $_fsum_error$20896

; 1127 :             else

  003ea	eb 2e		 jmp	 SHORT $LN13@math_fsum
$LN14@math_fsum:

; 1128 :                 p[n++] = x;

  003ec	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  003f1	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  003f9	f2 0f 10 84 24
	48 01 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00402	f2 0f 11 04 c8	 movsdx	 QWORD PTR [rax+rcx*8], xmm0
  00407	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0040f	48 ff c0	 inc	 rax
  00412	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR n$[rsp], rax
$LN13@math_fsum:
$LN15@math_fsum:
$LN19@math_fsum:

; 1129 :         }
; 1130 :     }

  0041a	e9 61 fc ff ff	 jmp	 $LN29@math_fsum
$LN28@math_fsum:

; 1131 : 
; 1132 :     if (special_sum != 0.0) {

  0041f	f2 0f 10 84 24
	68 01 00 00	 movsdx	 xmm0, QWORD PTR special_sum$[rsp]
  00428	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00430	7a 02		 jp	 SHORT $LN40@math_fsum
  00432	74 43		 je	 SHORT $LN12@math_fsum
$LN40@math_fsum:

; 1133 :         if (Py_IS_NAN(inf_sum))

  00434	f2 0f 10 84 24
	70 01 00 00	 movsdx	 xmm0, QWORD PTR inf_sum$[rsp]
  0043d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00443	85 c0		 test	 eax, eax
  00445	74 15		 je	 SHORT $LN11@math_fsum

; 1134 :             PyErr_SetString(PyExc_ValueError,
; 1135 :                             "-inf + inf in fsum");

  00447	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@NNCHNLEA@?9inf?5?$CL?5inf?5in?5fsum?$AA@
  0044e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00455	e8 00 00 00 00	 call	 PyErr_SetString

; 1136 :         else

  0045a	eb 16		 jmp	 SHORT $LN10@math_fsum
$LN11@math_fsum:

; 1137 :             sum = PyFloat_FromDouble(special_sum);

  0045c	f2 0f 10 84 24
	68 01 00 00	 movsdx	 xmm0, QWORD PTR special_sum$[rsp]
  00465	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0046a	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR sum$[rsp], rax
$LN10@math_fsum:

; 1138 :         goto _fsum_error;

  00472	e9 5c 02 00 00	 jmp	 $_fsum_error$20896
$LN12@math_fsum:

; 1139 :     }
; 1140 : 
; 1141 :     hi = 0.0;

  00477	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0047b	f2 0f 11 84 24
	88 01 00 00	 movsdx	 QWORD PTR hi$[rsp], xmm0

; 1142 :     if (n > 0) {

  00484	48 83 bc 24 58
	01 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  0048d	0f 8e 2a 02 00
	00		 jle	 $LN9@math_fsum

; 1143 :         hi = p[--n];

  00493	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0049b	48 ff c8	 dec	 rax
  0049e	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR n$[rsp], rax
  004a6	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  004ab	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  004b3	f2 0f 10 04 c8	 movsdx	 xmm0, QWORD PTR [rax+rcx*8]
  004b8	f2 0f 11 84 24
	88 01 00 00	 movsdx	 QWORD PTR hi$[rsp], xmm0
$LN8@math_fsum:

; 1144 :         /* sum_exact(ps, hi) from the top, stop when the sum becomes
; 1145 :            inexact. */
; 1146 :         while (n > 0) {

  004c1	48 83 bc 24 58
	01 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  004ca	0f 8e ff 00 00
	00		 jle	 $LN7@math_fsum

; 1147 :             x = hi;

  004d0	f2 0f 10 84 24
	88 01 00 00	 movsdx	 xmm0, QWORD PTR hi$[rsp]
  004d9	f2 0f 11 84 24
	48 01 00 00	 movsdx	 QWORD PTR x$[rsp], xmm0

; 1148 :             y = p[--n];

  004e2	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  004ea	48 ff c8	 dec	 rax
  004ed	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR n$[rsp], rax
  004f5	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  004fa	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00502	f2 0f 10 04 c8	 movsdx	 xmm0, QWORD PTR [rax+rcx*8]
  00507	f2 0f 11 84 24
	40 01 00 00	 movsdx	 QWORD PTR y$[rsp], xmm0

; 1149 :             assert(fabs(y) < fabs(x));

  00510	f2 0f 10 84 24
	40 01 00 00	 movsdx	 xmm0, QWORD PTR y$[rsp]
  00519	e8 00 00 00 00	 call	 fabs
  0051e	f2 0f 11 84 24
	b8 01 00 00	 movsdx	 QWORD PTR tv188[rsp], xmm0
  00527	f2 0f 10 84 24
	48 01 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00530	e8 00 00 00 00	 call	 fabs
  00535	f2 0f 10 8c 24
	b8 01 00 00	 movsdx	 xmm1, QWORD PTR tv188[rsp]
  0053e	66 0f 2f c1	 comisd	 xmm0, xmm1
  00542	77 1c		 ja	 SHORT $LN38@math_fsum
  00544	41 b8 7d 04 00
	00		 mov	 r8d, 1149		; 0000047dH
  0054a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@BGHOHNN@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAa?$AAt?$AAh?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00551	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@LOHCFCIC@?$AAf?$AAa?$AAb?$AAs?$AA?$CI?$AAy?$AA?$CJ?$AA?5?$AA?$DM?$AA?5?$AAf?$AAa?$AAb?$AAs?$AA?$CI?$AAx?$AA?$CJ?$AA?$AA@
  00558	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0055e	33 c0		 xor	 eax, eax
$LN38@math_fsum:

; 1150 :             hi = x + y;

  00560	f2 0f 10 84 24
	48 01 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  00569	f2 0f 58 84 24
	40 01 00 00	 addsd	 xmm0, QWORD PTR y$[rsp]
  00572	f2 0f 11 84 24
	88 01 00 00	 movsdx	 QWORD PTR hi$[rsp], xmm0

; 1151 :             yr = hi - x;

  0057b	f2 0f 10 84 24
	88 01 00 00	 movsdx	 xmm0, QWORD PTR hi$[rsp]
  00584	f2 0f 5c 84 24
	48 01 00 00	 subsd	 xmm0, QWORD PTR x$[rsp]
  0058d	f2 0f 11 84 24
	78 01 00 00	 movsdx	 QWORD PTR yr$[rsp], xmm0

; 1152 :             lo = y - yr;

  00596	f2 0f 10 84 24
	78 01 00 00	 movsdx	 xmm0, QWORD PTR yr$[rsp]
  0059f	f2 0f 10 8c 24
	40 01 00 00	 movsdx	 xmm1, QWORD PTR y$[rsp]
  005a8	f2 0f 5c c8	 subsd	 xmm1, xmm0
  005ac	66 0f 28 c1	 movapd	 xmm0, xmm1
  005b0	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR lo$[rsp], xmm0

; 1153 :             if (lo != 0.0)

  005b6	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR lo$[rsp]
  005bc	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  005c4	7a 02		 jp	 SHORT $LN39@math_fsum
  005c6	74 02		 je	 SHORT $LN6@math_fsum
$LN39@math_fsum:

; 1154 :                 break;

  005c8	eb 05		 jmp	 SHORT $LN7@math_fsum
$LN6@math_fsum:

; 1155 :         }

  005ca	e9 f2 fe ff ff	 jmp	 $LN8@math_fsum
$LN7@math_fsum:

; 1156 :         /* Make half-even rounding work across multiple partials.
; 1157 :            Needed so that sum([1e-16, 1, 1e16]) will round-up the last
; 1158 :            digit to two instead of down to zero (the 1e-16 makes the 1
; 1159 :            slightly closer to two).  With a potential 1 ULP rounding
; 1160 :            error fixed-up, math.fsum() can guarantee commutativity. */
; 1161 :         if (n > 0 && ((lo < 0.0 && p[n-1] < 0.0) ||
; 1162 :                       (lo > 0.0 && p[n-1] > 0.0))) {

  005cf	48 83 bc 24 58
	01 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  005d8	0f 8e df 00 00
	00		 jle	 $LN5@math_fsum
  005de	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR lo$[rsp]
  005e4	66 0f 57 c9	 xorpd	 xmm1, xmm1
  005e8	66 0f 2f c8	 comisd	 xmm1, xmm0
  005ec	76 19		 jbe	 SHORT $LN3@math_fsum
  005ee	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  005f3	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  005fb	66 0f 57 c0	 xorpd	 xmm0, xmm0
  005ff	66 0f 2f 44 c8
	f8		 comisd	 xmm0, QWORD PTR [rax+rcx*8-8]
  00605	77 35		 ja	 SHORT $LN4@math_fsum
$LN3@math_fsum:
  00607	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR lo$[rsp]
  0060d	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00615	0f 86 a2 00 00
	00		 jbe	 $LN5@math_fsum
  0061b	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00620	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00628	f2 0f 10 44 c8
	f8		 movsdx	 xmm0, QWORD PTR [rax+rcx*8-8]
  0062e	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00636	0f 86 81 00 00
	00		 jbe	 $LN5@math_fsum
$LN4@math_fsum:

; 1163 :             y = lo * 2.0;

  0063c	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR lo$[rsp]
  00642	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4000000000000000
  0064a	f2 0f 11 84 24
	40 01 00 00	 movsdx	 QWORD PTR y$[rsp], xmm0

; 1164 :             x = hi + y;

  00653	f2 0f 10 84 24
	88 01 00 00	 movsdx	 xmm0, QWORD PTR hi$[rsp]
  0065c	f2 0f 58 84 24
	40 01 00 00	 addsd	 xmm0, QWORD PTR y$[rsp]
  00665	f2 0f 11 84 24
	48 01 00 00	 movsdx	 QWORD PTR x$[rsp], xmm0

; 1165 :             yr = x - hi;

  0066e	f2 0f 10 84 24
	88 01 00 00	 movsdx	 xmm0, QWORD PTR hi$[rsp]
  00677	f2 0f 10 8c 24
	48 01 00 00	 movsdx	 xmm1, QWORD PTR x$[rsp]
  00680	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00684	66 0f 28 c1	 movapd	 xmm0, xmm1
  00688	f2 0f 11 84 24
	78 01 00 00	 movsdx	 QWORD PTR yr$[rsp], xmm0

; 1166 :             if (y == yr)

  00691	f2 0f 10 84 24
	78 01 00 00	 movsdx	 xmm0, QWORD PTR yr$[rsp]
  0069a	f2 0f 10 8c 24
	40 01 00 00	 movsdx	 xmm1, QWORD PTR y$[rsp]
  006a3	66 0f 2e c8	 ucomisd xmm1, xmm0
  006a7	7a 14		 jp	 SHORT $LN2@math_fsum
  006a9	75 12		 jne	 SHORT $LN2@math_fsum

; 1167 :                 hi = x;

  006ab	f2 0f 10 84 24
	48 01 00 00	 movsdx	 xmm0, QWORD PTR x$[rsp]
  006b4	f2 0f 11 84 24
	88 01 00 00	 movsdx	 QWORD PTR hi$[rsp], xmm0
$LN2@math_fsum:
$LN5@math_fsum:
$LN9@math_fsum:

; 1168 :         }
; 1169 :     }
; 1170 :     sum = PyFloat_FromDouble(hi);

  006bd	f2 0f 10 84 24
	88 01 00 00	 movsdx	 xmm0, QWORD PTR hi$[rsp]
  006c6	e8 00 00 00 00	 call	 PyFloat_FromDouble
  006cb	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR sum$[rsp], rax
$_fsum_error$20896:

; 1171 : 
; 1172 : _fsum_error:
; 1173 :     PyFPE_END_PROTECT(hi)
; 1174 :     Py_DECREF(iter);

  006d3	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR iter$[rsp]
  006db	e8 00 00 00 00	 call	 _Py_DecRef

; 1175 :     if (p != ps)

  006e0	48 8d 44 24 40	 lea	 rax, QWORD PTR ps$[rsp]
  006e5	48 39 44 24 28	 cmp	 QWORD PTR p$[rsp], rax
  006ea	74 0a		 je	 SHORT $LN1@math_fsum

; 1176 :         PyMem_Free(p);

  006ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  006f1	e8 00 00 00 00	 call	 PyMem_Free
$LN1@math_fsum:

; 1177 :     return sum;

  006f6	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR sum$[rsp]
$LN31@math_fsum:

; 1178 : }

  006fe	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  00705	c3		 ret	 0
math_fsum ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@HIFBFGN@math?4fsum?5partials?$AA@	; `string'
EXTRN	PyExc_MemoryError:QWORD
EXTRN	PyMem_Realloc:PROC
EXTRN	memcpy:PROC
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_fsum_realloc DD imagerel _fsum_realloc
	DD	imagerel _fsum_realloc+278
	DD	imagerel $unwind$_fsum_realloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_fsum_realloc DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT ??_C@_0BD@HIFBFGN@math?4fsum?5partials?$AA@
CONST	SEGMENT
??_C@_0BD@HIFBFGN@math?4fsum?5partials?$AA@ DB 'math.fsum partials', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _fsum_realloc
_TEXT	SEGMENT
v$ = 32
m$ = 40
p$20845 = 48
p_ptr$ = 80
n$ = 88
ps$ = 96
m_ptr$ = 104
_fsum_realloc PROC					; COMDAT

; 1008 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1009 :     void *v = NULL;

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR v$[rsp], 0

; 1010 :     Py_ssize_t m = *m_ptr;

  00021	48 8b 44 24 68	 mov	 rax, QWORD PTR m_ptr$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 44 24 28	 mov	 QWORD PTR m$[rsp], rax

; 1011 : 
; 1012 :     m += m;  /* double */

  0002e	48 8b 44 24 28	 mov	 rax, QWORD PTR m$[rsp]
  00033	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  00038	48 03 c8	 add	 rcx, rax
  0003b	48 8b c1	 mov	 rax, rcx
  0003e	48 89 44 24 28	 mov	 QWORD PTR m$[rsp], rax

; 1013 :     if (n < m && m < (PY_SSIZE_T_MAX / sizeof(double))) {

  00043	48 8b 44 24 28	 mov	 rax, QWORD PTR m$[rsp]
  00048	48 39 44 24 58	 cmp	 QWORD PTR n$[rsp], rax
  0004d	0f 8d 80 00 00
	00		 jge	 $LN5@fsum_reall
  00053	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  0005d	48 39 44 24 28	 cmp	 QWORD PTR m$[rsp], rax
  00062	73 6f		 jae	 SHORT $LN5@fsum_reall

; 1014 :         double *p = *p_ptr;

  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR p_ptr$[rsp]
  00069	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006c	48 89 44 24 30	 mov	 QWORD PTR p$20845[rsp], rax

; 1015 :         if (p == ps) {

  00071	48 8b 44 24 60	 mov	 rax, QWORD PTR ps$[rsp]
  00076	48 39 44 24 30	 cmp	 QWORD PTR p$20845[rsp], rax
  0007b	75 3b		 jne	 SHORT $LN4@fsum_reall

; 1016 :             v = PyMem_Malloc(sizeof(double) * m);

  0007d	48 8b 44 24 28	 mov	 rax, QWORD PTR m$[rsp]
  00082	48 c1 e0 03	 shl	 rax, 3
  00086	48 8b c8	 mov	 rcx, rax
  00089	e8 00 00 00 00	 call	 PyMem_Malloc
  0008e	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 1017 :             if (v != NULL)

  00093	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00099	74 1b		 je	 SHORT $LN3@fsum_reall

; 1018 :                 memcpy(v, ps, sizeof(double) * n);

  0009b	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000a0	48 c1 e0 03	 shl	 rax, 3
  000a4	4c 8b c0	 mov	 r8, rax
  000a7	48 8b 54 24 60	 mov	 rdx, QWORD PTR ps$[rsp]
  000ac	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  000b1	e8 00 00 00 00	 call	 memcpy
$LN3@fsum_reall:

; 1019 :         }
; 1020 :         else

  000b6	eb 1b		 jmp	 SHORT $LN2@fsum_reall
$LN4@fsum_reall:

; 1021 :             v = PyMem_Realloc(p, sizeof(double) * m);

  000b8	48 8b 44 24 28	 mov	 rax, QWORD PTR m$[rsp]
  000bd	48 c1 e0 03	 shl	 rax, 3
  000c1	48 8b d0	 mov	 rdx, rax
  000c4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$20845[rsp]
  000c9	e8 00 00 00 00	 call	 PyMem_Realloc
  000ce	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax
$LN2@fsum_reall:
$LN5@fsum_reall:

; 1022 :     }
; 1023 :     if (v == NULL) {        /* size overflow or no memory */

  000d3	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  000d9	75 1a		 jne	 SHORT $LN1@fsum_reall

; 1024 :         PyErr_SetString(PyExc_MemoryError, "math.fsum partials");

  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@HIFBFGN@math?4fsum?5partials?$AA@
  000e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_MemoryError
  000e9	e8 00 00 00 00	 call	 PyErr_SetString

; 1025 :         return 1;

  000ee	b8 01 00 00 00	 mov	 eax, 1
  000f3	eb 1c		 jmp	 SHORT $LN6@fsum_reall
$LN1@fsum_reall:

; 1026 :     }
; 1027 :     *p_ptr = (double*) v;

  000f5	48 8b 44 24 50	 mov	 rax, QWORD PTR p_ptr$[rsp]
  000fa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  000ff	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1028 :     *m_ptr = m;

  00102	48 8b 44 24 68	 mov	 rax, QWORD PTR m_ptr$[rsp]
  00107	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  0010c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1029 :     return 0;

  0010f	33 c0		 xor	 eax, eax
$LN6@fsum_reall:

; 1030 : }

  00111	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00115	c3		 ret	 0
_fsum_realloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@EELIBPBN@factorial?$CI?$CJ?5not?5defined?5for?5nega@ ; `string'
PUBLIC	??_C@_0CJ@FBGIBGEO@factorial?$CI?$CJ?5only?5accepts?5integra@ ; `string'
EXTRN	PyNumber_Lshift:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyLong_FromUnsignedLong:PROC
EXTRN	PyLong_AsLong:PROC
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyFloat_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_factorial DD imagerel math_factorial
	DD	imagerel math_factorial+429
	DD	imagerel $unwind$math_factorial
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_factorial DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0CM@EELIBPBN@factorial?$CI?$CJ?5not?5defined?5for?5nega@
CONST	SEGMENT
??_C@_0CM@EELIBPBN@factorial?$CI?$CJ?5not?5defined?5for?5nega@ DB 'factor'
	DB	'ial() not defined for negative values', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@FBGIBGEO@factorial?$CI?$CJ?5only?5accepts?5integra@
CONST	SEGMENT
??_C@_0CJ@FBGIBGEO@factorial?$CI?$CJ?5only?5accepts?5integra@ DB 'factori'
	DB	'al() only accepts integral values', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT math_factorial
_TEXT	SEGMENT
x$ = 32
odd_part$ = 40
two_valuation$ = 48
result$ = 56
lx$21032 = 64
dx$21033 = 72
self$ = 96
arg$ = 104
math_factorial PROC					; COMDAT

; 1409 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1410 :     long x;
; 1411 :     PyObject *result, *odd_part, *two_valuation;
; 1412 : 
; 1413 :     if (PyFloat_Check(arg)) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00015	48 8b 4c 24 68	 mov	 rcx, QWORD PTR arg$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 1d		 je	 SHORT $LN10@math_facto
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00027	48 8b 44 24 68	 mov	 rax, QWORD PTR arg$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	0f 84 8d 00 00
	00		 je	 $LN11@math_facto
$LN10@math_facto:

; 1414 :         PyObject *lx;
; 1415 :         double dx = PyFloat_AS_DOUBLE((PyFloatObject *)arg);

  0003d	48 8b 44 24 68	 mov	 rax, QWORD PTR arg$[rsp]
  00042	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00047	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR dx$21033[rsp], xmm0

; 1416 :         if (!(Py_IS_FINITE(dx) && dx == floor(dx))) {

  0004d	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR dx$21033[rsp]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00059	85 c0		 test	 eax, eax
  0005b	74 1a		 je	 SHORT $LN8@math_facto
  0005d	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR dx$21033[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  00069	f2 0f 10 4c 24
	48		 movsdx	 xmm1, QWORD PTR dx$21033[rsp]
  0006f	66 0f 2e c8	 ucomisd xmm1, xmm0
  00073	7a 02		 jp	 SHORT $LN14@math_facto
  00075	74 1a		 je	 SHORT $LN9@math_facto
$LN14@math_facto:
$LN8@math_facto:

; 1417 :             PyErr_SetString(PyExc_ValueError,
; 1418 :                             "factorial() only accepts integral values");

  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@FBGIBGEO@factorial?$CI?$CJ?5only?5accepts?5integra@
  0007e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00085	e8 00 00 00 00	 call	 PyErr_SetString

; 1419 :             return NULL;

  0008a	33 c0		 xor	 eax, eax
  0008c	e9 17 01 00 00	 jmp	 $LN12@math_facto
$LN9@math_facto:

; 1420 :         }
; 1421 :         lx = PyLong_FromDouble(dx);

  00091	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR dx$21033[rsp]
  00097	e8 00 00 00 00	 call	 PyLong_FromDouble
  0009c	48 89 44 24 40	 mov	 QWORD PTR lx$21032[rsp], rax

; 1422 :         if (lx == NULL)

  000a1	48 83 7c 24 40
	00		 cmp	 QWORD PTR lx$21032[rsp], 0
  000a7	75 07		 jne	 SHORT $LN7@math_facto

; 1423 :             return NULL;

  000a9	33 c0		 xor	 eax, eax
  000ab	e9 f8 00 00 00	 jmp	 $LN12@math_facto
$LN7@math_facto:

; 1424 :         x = PyLong_AsLong(lx);

  000b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lx$21032[rsp]
  000b5	e8 00 00 00 00	 call	 PyLong_AsLong
  000ba	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 1425 :         Py_DECREF(lx);

  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lx$21032[rsp]
  000c3	e8 00 00 00 00	 call	 _Py_DecRef

; 1426 :     }
; 1427 :     else

  000c8	eb 0e		 jmp	 SHORT $LN6@math_facto
$LN11@math_facto:

; 1428 :         x = PyLong_AsLong(arg);

  000ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR arg$[rsp]
  000cf	e8 00 00 00 00	 call	 PyLong_AsLong
  000d4	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
$LN6@math_facto:

; 1429 : 
; 1430 :     if (x == -1 && PyErr_Occurred())

  000d8	83 7c 24 20 ff	 cmp	 DWORD PTR x$[rsp], -1
  000dd	75 11		 jne	 SHORT $LN5@math_facto
  000df	e8 00 00 00 00	 call	 PyErr_Occurred
  000e4	48 85 c0	 test	 rax, rax
  000e7	74 07		 je	 SHORT $LN5@math_facto

; 1431 :         return NULL;

  000e9	33 c0		 xor	 eax, eax
  000eb	e9 b8 00 00 00	 jmp	 $LN12@math_facto
$LN5@math_facto:

; 1432 :     if (x < 0) {

  000f0	83 7c 24 20 00	 cmp	 DWORD PTR x$[rsp], 0
  000f5	7d 1a		 jge	 SHORT $LN4@math_facto

; 1433 :         PyErr_SetString(PyExc_ValueError,
; 1434 :                         "factorial() not defined for negative values");

  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@EELIBPBN@factorial?$CI?$CJ?5not?5defined?5for?5nega@
  000fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00105	e8 00 00 00 00	 call	 PyErr_SetString

; 1435 :         return NULL;

  0010a	33 c0		 xor	 eax, eax
  0010c	e9 97 00 00 00	 jmp	 $LN12@math_facto
$LN4@math_facto:

; 1436 :     }
; 1437 : 
; 1438 :     /* use lookup table if x is small */
; 1439 :     if (x < (long)Py_ARRAY_LENGTH(SmallFactorials))

  00111	83 7c 24 20 0d	 cmp	 DWORD PTR x$[rsp], 13
  00116	7d 16		 jge	 SHORT $LN3@math_facto

; 1440 :         return PyLong_FromUnsignedLong(SmallFactorials[x]);

  00118	48 63 44 24 20	 movsxd	 rax, DWORD PTR x$[rsp]
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SmallFactorials
  00124	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
  00127	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  0012c	eb 7a		 jmp	 SHORT $LN12@math_facto
$LN3@math_facto:

; 1441 : 
; 1442 :     /* else express in the form odd_part * 2**two_valuation, and compute as
; 1443 :        odd_part << two_valuation. */
; 1444 :     odd_part = factorial_odd_part(x);

  0012e	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00132	e8 00 00 00 00	 call	 factorial_odd_part
  00137	48 89 44 24 28	 mov	 QWORD PTR odd_part$[rsp], rax

; 1445 :     if (odd_part == NULL)

  0013c	48 83 7c 24 28
	00		 cmp	 QWORD PTR odd_part$[rsp], 0
  00142	75 04		 jne	 SHORT $LN2@math_facto

; 1446 :         return NULL;

  00144	33 c0		 xor	 eax, eax
  00146	eb 60		 jmp	 SHORT $LN12@math_facto
$LN2@math_facto:

; 1447 :     two_valuation = PyLong_FromLong(x - count_set_bits(x));

  00148	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  0014c	e8 00 00 00 00	 call	 count_set_bits
  00151	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00155	2b c8		 sub	 ecx, eax
  00157	8b c1		 mov	 eax, ecx
  00159	8b c8		 mov	 ecx, eax
  0015b	e8 00 00 00 00	 call	 PyLong_FromLong
  00160	48 89 44 24 30	 mov	 QWORD PTR two_valuation$[rsp], rax

; 1448 :     if (two_valuation == NULL) {

  00165	48 83 7c 24 30
	00		 cmp	 QWORD PTR two_valuation$[rsp], 0
  0016b	75 0e		 jne	 SHORT $LN1@math_facto

; 1449 :         Py_DECREF(odd_part);

  0016d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR odd_part$[rsp]
  00172	e8 00 00 00 00	 call	 _Py_DecRef

; 1450 :         return NULL;

  00177	33 c0		 xor	 eax, eax
  00179	eb 2d		 jmp	 SHORT $LN12@math_facto
$LN1@math_facto:

; 1451 :     }
; 1452 :     result = PyNumber_Lshift(odd_part, two_valuation);

  0017b	48 8b 54 24 30	 mov	 rdx, QWORD PTR two_valuation$[rsp]
  00180	48 8b 4c 24 28	 mov	 rcx, QWORD PTR odd_part$[rsp]
  00185	e8 00 00 00 00	 call	 PyNumber_Lshift
  0018a	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 1453 :     Py_DECREF(two_valuation);

  0018f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR two_valuation$[rsp]
  00194	e8 00 00 00 00	 call	 _Py_DecRef

; 1454 :     Py_DECREF(odd_part);

  00199	48 8b 4c 24 28	 mov	 rcx, QWORD PTR odd_part$[rsp]
  0019e	e8 00 00 00 00	 call	 _Py_DecRef

; 1455 :     return result;

  001a3	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN12@math_facto:

; 1456 : }

  001a8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ac	c3		 ret	 0
math_factorial ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_set_bits DD imagerel count_set_bits
	DD	imagerel count_set_bits+58
	DD	imagerel $unwind$count_set_bits
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_set_bits DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT count_set_bits
_TEXT	SEGMENT
count$ = 0
n$ = 32
count_set_bits PROC					; COMDAT

; 1211 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 1212 :     unsigned long count = 0;

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR count$[rsp], 0
$LN2@count_set_:

; 1213 :     while (n != 0) {

  0000f	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  00014	74 1c		 je	 SHORT $LN1@count_set_

; 1214 :         ++count;

  00016	8b 04 24	 mov	 eax, DWORD PTR count$[rsp]
  00019	ff c0		 inc	 eax
  0001b	89 04 24	 mov	 DWORD PTR count$[rsp], eax

; 1215 :         n &= n - 1; /* clear least significant bit */

  0001e	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00022	ff c8		 dec	 eax
  00024	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00028	23 c8		 and	 ecx, eax
  0002a	8b c1		 mov	 eax, ecx
  0002c	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 1216 :     }

  00030	eb dd		 jmp	 SHORT $LN2@count_set_
$LN1@count_set_:

; 1217 :     return count;

  00032	8b 04 24	 mov	 eax, DWORD PTR count$[rsp]

; 1218 : }

  00035	48 83 c4 18	 add	 rsp, 24
  00039	c3		 ret	 0
count_set_bits ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
EXTRN	PyNumber_Multiply:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$factorial_odd_part DD imagerel factorial_odd_part
	DD	imagerel factorial_odd_part+359
	DD	imagerel $unwind$factorial_odd_part
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$factorial_odd_part DD 010801H
	DD	0c208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT factorial_odd_part
_TEXT	SEGMENT
partial$ = 32
v$ = 40
i$ = 44
tmp$ = 48
upper$ = 56
inner$ = 64
outer$ = 72
lower$ = 80
n$ = 112
factorial_odd_part PROC					; COMDAT

; 1344 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1345 :     long i;
; 1346 :     unsigned long v, lower, upper;
; 1347 :     PyObject *partial, *tmp, *inner, *outer;
; 1348 : 
; 1349 :     inner = PyLong_FromLong(1);

  00008	b9 01 00 00 00	 mov	 ecx, 1
  0000d	e8 00 00 00 00	 call	 PyLong_FromLong
  00012	48 89 44 24 40	 mov	 QWORD PTR inner$[rsp], rax

; 1350 :     if (inner == NULL)

  00017	48 83 7c 24 40
	00		 cmp	 QWORD PTR inner$[rsp], 0
  0001d	75 07		 jne	 SHORT $LN8@factorial_

; 1351 :         return NULL;

  0001f	33 c0		 xor	 eax, eax
  00021	e9 3c 01 00 00	 jmp	 $LN9@factorial_
$LN8@factorial_:

; 1352 :     outer = inner;

  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR inner$[rsp]
  0002b	48 89 44 24 48	 mov	 QWORD PTR outer$[rsp], rax

; 1353 :     Py_INCREF(outer);

  00030	48 8b 4c 24 48	 mov	 rcx, QWORD PTR outer$[rsp]
  00035	e8 00 00 00 00	 call	 _Py_IncRef

; 1354 : 
; 1355 :     upper = 3;

  0003a	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR upper$[rsp], 3

; 1356 :     for (i = bit_length(n) - 2; i >= 0; i--) {

  00042	8b 4c 24 70	 mov	 ecx, DWORD PTR n$[rsp]
  00046	e8 00 00 00 00	 call	 bit_length
  0004b	83 e8 02	 sub	 eax, 2
  0004e	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
  00052	eb 0a		 jmp	 SHORT $LN7@factorial_
$LN6@factorial_:
  00054	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  00058	ff c8		 dec	 eax
  0005a	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN7@factorial_:
  0005e	83 7c 24 2c 00	 cmp	 DWORD PTR i$[rsp], 0
  00063	0f 8c d2 00 00
	00		 jl	 $LN5@factorial_

; 1357 :         v = n >> i;

  00069	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  0006d	0f b6 c8	 movzx	 ecx, al
  00070	8b 44 24 70	 mov	 eax, DWORD PTR n$[rsp]
  00074	d3 e8		 shr	 eax, cl
  00076	89 44 24 28	 mov	 DWORD PTR v$[rsp], eax

; 1358 :         if (v <= 2)

  0007a	83 7c 24 28 02	 cmp	 DWORD PTR v$[rsp], 2
  0007f	77 02		 ja	 SHORT $LN4@factorial_

; 1359 :             continue;

  00081	eb d1		 jmp	 SHORT $LN6@factorial_
$LN4@factorial_:

; 1360 :         lower = upper;

  00083	8b 44 24 38	 mov	 eax, DWORD PTR upper$[rsp]
  00087	89 44 24 50	 mov	 DWORD PTR lower$[rsp], eax

; 1361 :         /* (v + 1) | 1 = least odd integer strictly larger than n / 2**i */
; 1362 :         upper = (v + 1) | 1;

  0008b	8b 44 24 28	 mov	 eax, DWORD PTR v$[rsp]
  0008f	ff c0		 inc	 eax
  00091	83 c8 01	 or	 eax, 1
  00094	89 44 24 38	 mov	 DWORD PTR upper$[rsp], eax

; 1363 :         /* Here inner is the product of all odd integers j in the range (0,
; 1364 :            n/2**(i+1)].  The factorial_partial_product call below gives the
; 1365 :            product of all odd integers j in the range (n/2**(i+1), n/2**i]. */
; 1366 :         partial = factorial_partial_product(lower, upper, bit_length(upper-2));

  00098	8b 44 24 38	 mov	 eax, DWORD PTR upper$[rsp]
  0009c	83 e8 02	 sub	 eax, 2
  0009f	8b c8		 mov	 ecx, eax
  000a1	e8 00 00 00 00	 call	 bit_length
  000a6	44 8b c0	 mov	 r8d, eax
  000a9	8b 54 24 38	 mov	 edx, DWORD PTR upper$[rsp]
  000ad	8b 4c 24 50	 mov	 ecx, DWORD PTR lower$[rsp]
  000b1	e8 00 00 00 00	 call	 factorial_partial_product
  000b6	48 89 44 24 20	 mov	 QWORD PTR partial$[rsp], rax

; 1367 :         /* inner *= partial */
; 1368 :         if (partial == NULL)

  000bb	48 83 7c 24 20
	00		 cmp	 QWORD PTR partial$[rsp], 0
  000c1	75 05		 jne	 SHORT $LN3@factorial_

; 1369 :             goto error;

  000c3	e9 84 00 00 00	 jmp	 $error$21005
$LN3@factorial_:

; 1370 :         tmp = PyNumber_Multiply(inner, partial);

  000c8	48 8b 54 24 20	 mov	 rdx, QWORD PTR partial$[rsp]
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inner$[rsp]
  000d2	e8 00 00 00 00	 call	 PyNumber_Multiply
  000d7	48 89 44 24 30	 mov	 QWORD PTR tmp$[rsp], rax

; 1371 :         Py_DECREF(partial);

  000dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR partial$[rsp]
  000e1	e8 00 00 00 00	 call	 _Py_DecRef

; 1372 :         if (tmp == NULL)

  000e6	48 83 7c 24 30
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  000ec	75 02		 jne	 SHORT $LN2@factorial_

; 1373 :             goto error;

  000ee	eb 5c		 jmp	 SHORT $error$21005
$LN2@factorial_:

; 1374 :         Py_DECREF(inner);

  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inner$[rsp]
  000f5	e8 00 00 00 00	 call	 _Py_DecRef

; 1375 :         inner = tmp;

  000fa	48 8b 44 24 30	 mov	 rax, QWORD PTR tmp$[rsp]
  000ff	48 89 44 24 40	 mov	 QWORD PTR inner$[rsp], rax

; 1376 :         /* Now inner is the product of all odd integers j in the range (0,
; 1377 :            n/2**i], giving the inner product in the formula above. */
; 1378 : 
; 1379 :         /* outer *= inner; */
; 1380 :         tmp = PyNumber_Multiply(outer, inner);

  00104	48 8b 54 24 40	 mov	 rdx, QWORD PTR inner$[rsp]
  00109	48 8b 4c 24 48	 mov	 rcx, QWORD PTR outer$[rsp]
  0010e	e8 00 00 00 00	 call	 PyNumber_Multiply
  00113	48 89 44 24 30	 mov	 QWORD PTR tmp$[rsp], rax

; 1381 :         if (tmp == NULL)

  00118	48 83 7c 24 30
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0011e	75 02		 jne	 SHORT $LN1@factorial_

; 1382 :             goto error;

  00120	eb 2a		 jmp	 SHORT $error$21005
$LN1@factorial_:

; 1383 :         Py_DECREF(outer);

  00122	48 8b 4c 24 48	 mov	 rcx, QWORD PTR outer$[rsp]
  00127	e8 00 00 00 00	 call	 _Py_DecRef

; 1384 :         outer = tmp;

  0012c	48 8b 44 24 30	 mov	 rax, QWORD PTR tmp$[rsp]
  00131	48 89 44 24 48	 mov	 QWORD PTR outer$[rsp], rax

; 1385 :     }

  00136	e9 19 ff ff ff	 jmp	 $LN6@factorial_
$LN5@factorial_:

; 1386 :     Py_DECREF(inner);

  0013b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inner$[rsp]
  00140	e8 00 00 00 00	 call	 _Py_DecRef

; 1387 :     return outer;

  00145	48 8b 44 24 48	 mov	 rax, QWORD PTR outer$[rsp]
  0014a	eb 16		 jmp	 SHORT $LN9@factorial_
$error$21005:

; 1388 : 
; 1389 :   error:
; 1390 :     Py_DECREF(outer);

  0014c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR outer$[rsp]
  00151	e8 00 00 00 00	 call	 _Py_DecRef

; 1391 :     Py_DECREF(inner);

  00156	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inner$[rsp]
  0015b	e8 00 00 00 00	 call	 _Py_DecRef

; 1392 :     return NULL;

  00160	33 c0		 xor	 eax, eax
$LN9@factorial_:

; 1393 : }

  00162	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00166	c3		 ret	 0
factorial_odd_part ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\mathmodule.c
pdata	SEGMENT
$pdata$bit_length DD imagerel bit_length
	DD	imagerel bit_length+50
	DD	imagerel $unwind$bit_length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bit_length DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT bit_length
_TEXT	SEGMENT
len$ = 0
n$ = 32
bit_length PROC						; COMDAT

; 1200 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 1201 :     unsigned long len = 0;

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR len$[rsp], 0
$LN2@bit_length:

; 1202 :     while (n != 0) {

  0000f	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  00014	74 14		 je	 SHORT $LN1@bit_length

; 1203 :         ++len;

  00016	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]
  00019	ff c0		 inc	 eax
  0001b	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 1204 :         n >>= 1;

  0001e	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00022	d1 e8		 shr	 eax, 1
  00024	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 1205 :     }

  00028	eb e5		 jmp	 SHORT $LN2@bit_length
$LN1@bit_length:

; 1206 :     return len;

  0002a	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]

; 1207 : }

  0002d	48 83 c4 18	 add	 rsp, 24
  00031	c3		 ret	 0
bit_length ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$factorial_partial_product DD imagerel factorial_partial_product
	DD	imagerel factorial_partial_product+336
	DD	imagerel $unwind$factorial_partial_product
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$factorial_partial_product DD 011101H
	DD	0a211H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT factorial_partial_product
_TEXT	SEGMENT
left$ = 32
right$ = 40
num_operands$ = 48
result$ = 56
midpoint$ = 64
total$20964 = 68
j$20963 = 72
start$ = 96
stop$ = 104
max_bits$ = 112
factorial_partial_product PROC				; COMDAT

; 1292 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1293 :     unsigned long midpoint, num_operands;
; 1294 :     PyObject *left = NULL, *right = NULL, *result = NULL;

  00011	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR left$[rsp], 0
  0001a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR right$[rsp], 0
  00023	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 1295 : 
; 1296 :     /* If the return value will fit an unsigned long, then we can
; 1297 :      * multiply in a tight, fast loop where each multiply is O(1).
; 1298 :      * Compute an upper bound on the number of bits required to store
; 1299 :      * the answer.
; 1300 :      *
; 1301 :      * Storing some integer z requires floor(lg(z))+1 bits, which is
; 1302 :      * conveniently the value returned by bit_length(z).  The
; 1303 :      * product x*y will require at most
; 1304 :      * bit_length(x) + bit_length(y) bits to store, based
; 1305 :      * on the idea that lg product = lg x + lg y.
; 1306 :      *
; 1307 :      * We know that stop - 2 is the largest number to be multiplied.  From
; 1308 :      * there, we have: bit_length(answer) <= num_operands *
; 1309 :      * bit_length(stop - 2)
; 1310 :      */
; 1311 : 
; 1312 :     num_operands = (stop - start) / 2;

  0002c	8b 44 24 60	 mov	 eax, DWORD PTR start$[rsp]
  00030	8b 4c 24 68	 mov	 ecx, DWORD PTR stop$[rsp]
  00034	2b c8		 sub	 ecx, eax
  00036	8b c1		 mov	 eax, ecx
  00038	33 d2		 xor	 edx, edx
  0003a	b9 02 00 00 00	 mov	 ecx, 2
  0003f	f7 f1		 div	 ecx
  00041	89 44 24 30	 mov	 DWORD PTR num_operands$[rsp], eax

; 1313 :     /* The "num_operands <= 8 * SIZEOF_LONG" check guards against the
; 1314 :      * unlikely case of an overflow in num_operands * max_bits. */
; 1315 :     if (num_operands <= 8 * SIZEOF_LONG &&
; 1316 :         num_operands * max_bits <= 8 * SIZEOF_LONG) {

  00045	83 7c 24 30 20	 cmp	 DWORD PTR num_operands$[rsp], 32 ; 00000020H
  0004a	77 55		 ja	 SHORT $LN14@factorial_@2
  0004c	8b 44 24 30	 mov	 eax, DWORD PTR num_operands$[rsp]
  00050	0f af 44 24 70	 imul	 eax, DWORD PTR max_bits$[rsp]
  00055	83 f8 20	 cmp	 eax, 32			; 00000020H
  00058	77 47		 ja	 SHORT $LN14@factorial_@2

; 1317 :         unsigned long j, total;
; 1318 :         for (total = start, j = start + 2; j < stop; j += 2)

  0005a	8b 44 24 60	 mov	 eax, DWORD PTR start$[rsp]
  0005e	89 44 24 44	 mov	 DWORD PTR total$20964[rsp], eax
  00062	8b 44 24 60	 mov	 eax, DWORD PTR start$[rsp]
  00066	83 c0 02	 add	 eax, 2
  00069	89 44 24 48	 mov	 DWORD PTR j$20963[rsp], eax
  0006d	eb 0b		 jmp	 SHORT $LN13@factorial_@2
$LN12@factorial_@2:
  0006f	8b 44 24 48	 mov	 eax, DWORD PTR j$20963[rsp]
  00073	83 c0 02	 add	 eax, 2
  00076	89 44 24 48	 mov	 DWORD PTR j$20963[rsp], eax
$LN13@factorial_@2:
  0007a	8b 44 24 68	 mov	 eax, DWORD PTR stop$[rsp]
  0007e	39 44 24 48	 cmp	 DWORD PTR j$20963[rsp], eax
  00082	73 0f		 jae	 SHORT $LN11@factorial_@2

; 1319 :             total *= j;

  00084	8b 44 24 44	 mov	 eax, DWORD PTR total$20964[rsp]
  00088	0f af 44 24 48	 imul	 eax, DWORD PTR j$20963[rsp]
  0008d	89 44 24 44	 mov	 DWORD PTR total$20964[rsp], eax
  00091	eb dc		 jmp	 SHORT $LN12@factorial_@2
$LN11@factorial_@2:

; 1320 :         return PyLong_FromUnsignedLong(total);

  00093	8b 4c 24 44	 mov	 ecx, DWORD PTR total$20964[rsp]
  00097	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  0009c	e9 aa 00 00 00	 jmp	 $LN15@factorial_@2
$LN14@factorial_@2:

; 1321 :     }
; 1322 : 
; 1323 :     /* find midpoint of range(start, stop), rounded up to next odd number. */
; 1324 :     midpoint = (start + num_operands) | 1;

  000a1	8b 44 24 30	 mov	 eax, DWORD PTR num_operands$[rsp]
  000a5	8b 4c 24 60	 mov	 ecx, DWORD PTR start$[rsp]
  000a9	03 c8		 add	 ecx, eax
  000ab	8b c1		 mov	 eax, ecx
  000ad	83 c8 01	 or	 eax, 1
  000b0	89 44 24 40	 mov	 DWORD PTR midpoint$[rsp], eax

; 1325 :     left = factorial_partial_product(start, midpoint,
; 1326 :                                      bit_length(midpoint - 2));

  000b4	8b 44 24 40	 mov	 eax, DWORD PTR midpoint$[rsp]
  000b8	83 e8 02	 sub	 eax, 2
  000bb	8b c8		 mov	 ecx, eax
  000bd	e8 00 00 00 00	 call	 bit_length
  000c2	44 8b c0	 mov	 r8d, eax
  000c5	8b 54 24 40	 mov	 edx, DWORD PTR midpoint$[rsp]
  000c9	8b 4c 24 60	 mov	 ecx, DWORD PTR start$[rsp]
  000cd	e8 00 00 00 00	 call	 factorial_partial_product
  000d2	48 89 44 24 20	 mov	 QWORD PTR left$[rsp], rax

; 1327 :     if (left == NULL)

  000d7	48 83 7c 24 20
	00		 cmp	 QWORD PTR left$[rsp], 0
  000dd	75 02		 jne	 SHORT $LN10@factorial_@2

; 1328 :         goto error;

  000df	eb 35		 jmp	 SHORT $error$20970
$LN10@factorial_@2:

; 1329 :     right = factorial_partial_product(midpoint, stop, max_bits);

  000e1	44 8b 44 24 70	 mov	 r8d, DWORD PTR max_bits$[rsp]
  000e6	8b 54 24 68	 mov	 edx, DWORD PTR stop$[rsp]
  000ea	8b 4c 24 40	 mov	 ecx, DWORD PTR midpoint$[rsp]
  000ee	e8 00 00 00 00	 call	 factorial_partial_product
  000f3	48 89 44 24 28	 mov	 QWORD PTR right$[rsp], rax

; 1330 :     if (right == NULL)

  000f8	48 83 7c 24 28
	00		 cmp	 QWORD PTR right$[rsp], 0
  000fe	75 02		 jne	 SHORT $LN9@factorial_@2

; 1331 :         goto error;

  00100	eb 14		 jmp	 SHORT $error$20970
$LN9@factorial_@2:

; 1332 :     result = PyNumber_Multiply(left, right);

  00102	48 8b 54 24 28	 mov	 rdx, QWORD PTR right$[rsp]
  00107	48 8b 4c 24 20	 mov	 rcx, QWORD PTR left$[rsp]
  0010c	e8 00 00 00 00	 call	 PyNumber_Multiply
  00111	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax
$error$20970:
$LN8@factorial_@2:

; 1333 : 
; 1334 :   error:
; 1335 :     Py_XDECREF(left);

  00116	48 83 7c 24 20
	00		 cmp	 QWORD PTR left$[rsp], 0
  0011c	74 0a		 je	 SHORT $LN5@factorial_@2
  0011e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR left$[rsp]
  00123	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@factorial_@2:
  00128	33 c0		 xor	 eax, eax
  0012a	85 c0		 test	 eax, eax
  0012c	75 e8		 jne	 SHORT $LN8@factorial_@2
$LN4@factorial_@2:

; 1336 :     Py_XDECREF(right);

  0012e	48 83 7c 24 28
	00		 cmp	 QWORD PTR right$[rsp], 0
  00134	74 0a		 je	 SHORT $LN1@factorial_@2
  00136	48 8b 4c 24 28	 mov	 rcx, QWORD PTR right$[rsp]
  0013b	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@factorial_@2:
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 e8		 jne	 SHORT $LN4@factorial_@2

; 1337 :     return result;

  00146	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN15@factorial_@2:

; 1338 : }

  0014b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0014f	c3		 ret	 0
factorial_partial_product ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@KPKNMKGJ@type?5?$CF?4100s?5doesn?8t?5define?5__tru@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_trunc DD imagerel math_trunc
	DD	imagerel math_trunc+193
	DD	imagerel $unwind$math_trunc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_trunc DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CM@KPKNMKGJ@type?5?$CF?4100s?5doesn?8t?5define?5__tru@
CONST	SEGMENT
??_C@_0CM@KPKNMKGJ@type?5?$CF?4100s?5doesn?8t?5define?5__tru@ DB 'type %.'
	DB	'100s doesn''t define __trunc__ method', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT math_trunc
_TEXT	SEGMENT
trunc$ = 32
result$ = 40
self$ = 64
number$ = 72
math_trunc PROC						; COMDAT

; 1465 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1466 :     _Py_IDENTIFIER(__trunc__);
; 1467 :     PyObject *trunc, *result;
; 1468 : 
; 1469 :     if (Py_TYPE(number)->tp_dict == NULL) {

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR number$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	48 83 b8 60 01
	00 00 00	 cmp	 QWORD PTR [rax+352], 0
  0001f	75 19		 jne	 SHORT $LN4@math_trunc

; 1470 :         if (PyType_Ready(Py_TYPE(number)) < 0)

  00021	48 8b 44 24 48	 mov	 rax, QWORD PTR number$[rsp]
  00026	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002a	e8 00 00 00 00	 call	 PyType_Ready
  0002f	85 c0		 test	 eax, eax
  00031	7d 07		 jge	 SHORT $LN3@math_trunc

; 1471 :             return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	e9 82 00 00 00	 jmp	 $LN5@math_trunc
$LN3@math_trunc:
$LN4@math_trunc:

; 1472 :     }
; 1473 : 
; 1474 :     trunc = _PyObject_LookupSpecial(number, &PyId___trunc__);

  0003a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___trunc__@?1??math_trunc@@9@9
  0003f	8b c0		 mov	 eax, eax
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00047	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00050	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00054	48 8b d0	 mov	 rdx, rax
  00057	48 8b 4c 24 48	 mov	 rcx, QWORD PTR number$[rsp]
  0005c	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00061	48 89 44 24 20	 mov	 QWORD PTR trunc$[rsp], rax

; 1475 :     if (trunc == NULL) {

  00066	48 83 7c 24 20
	00		 cmp	 QWORD PTR trunc$[rsp], 0
  0006c	75 2e		 jne	 SHORT $LN2@math_trunc

; 1476 :         if (!PyErr_Occurred())

  0006e	e8 00 00 00 00	 call	 PyErr_Occurred
  00073	48 85 c0	 test	 rax, rax
  00076	75 20		 jne	 SHORT $LN1@math_trunc

; 1477 :             PyErr_Format(PyExc_TypeError,
; 1478 :                          "type %.100s doesn't define __trunc__ method",
; 1479 :                          Py_TYPE(number)->tp_name);

  00078	48 8b 44 24 48	 mov	 rax, QWORD PTR number$[rsp]
  0007d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00081	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@KPKNMKGJ@type?5?$CF?4100s?5doesn?8t?5define?5__tru@
  0008c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00093	e8 00 00 00 00	 call	 PyErr_Format
$LN1@math_trunc:

; 1480 :         return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	eb 20		 jmp	 SHORT $LN5@math_trunc
$LN2@math_trunc:

; 1481 :     }
; 1482 :     result = PyObject_CallFunctionObjArgs(trunc, NULL);

  0009c	33 d2		 xor	 edx, edx
  0009e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR trunc$[rsp]
  000a3	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  000a8	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1483 :     Py_DECREF(trunc);

  000ad	48 8b 4c 24 20	 mov	 rcx, QWORD PTR trunc$[rsp]
  000b2	e8 00 00 00 00	 call	 _Py_DecRef

; 1484 :     return result;

  000b7	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN5@math_trunc:

; 1485 : }

  000bc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c0	c3		 ret	 0
math_trunc ENDP
_TEXT	ENDS
PUBLIC	??_C@_04HPGIGDDH@?$CIdi?$CJ?$AA@		; `string'
EXTRN	Py_BuildValue:PROC
EXTRN	__imp_frexp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_frexp DD imagerel math_frexp
	DD	imagerel math_frexp+194
	DD	imagerel $unwind$math_frexp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_frexp DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_04HPGIGDDH@?$CIdi?$CJ?$AA@
CONST	SEGMENT
??_C@_04HPGIGDDH@?$CIdi?$CJ?$AA@ DB '(di)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT math_frexp
_TEXT	SEGMENT
x$ = 32
i$ = 40
self$ = 64
arg$ = 72
math_frexp PROC						; COMDAT

; 1494 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1495 :     int i;
; 1496 :     double x = PyFloat_AsDouble(arg);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00013	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00018	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1497 :     if (x == -1.0 && PyErr_Occurred())

  0001e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00024	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0002c	7a 10		 jp	 SHORT $LN5@math_frexp
  0002e	75 0e		 jne	 SHORT $LN5@math_frexp
  00030	e8 00 00 00 00	 call	 PyErr_Occurred
  00035	48 85 c0	 test	 rax, rax
  00038	74 04		 je	 SHORT $LN5@math_frexp

; 1498 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 7f		 jmp	 SHORT $LN6@math_frexp
$LN5@math_frexp:

; 1499 :     /* deal with special cases directly, to sidestep platform
; 1500 :        differences */
; 1501 :     if (Py_IS_NAN(x) || Py_IS_INFINITY(x) || !x) {

  0003e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0004a	85 c0		 test	 eax, eax
  0004c	75 32		 jne	 SHORT $LN3@math_frexp
  0004e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0005a	85 c0		 test	 eax, eax
  0005c	75 10		 jne	 SHORT $LN2@math_frexp
  0005e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0006a	85 c0		 test	 eax, eax
  0006c	74 12		 je	 SHORT $LN3@math_frexp
$LN2@math_frexp:
  0006e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00074	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0007c	7a 0c		 jp	 SHORT $LN4@math_frexp
  0007e	75 0a		 jne	 SHORT $LN4@math_frexp
$LN3@math_frexp:

; 1502 :         i = 0;

  00080	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 1503 :     }
; 1504 :     else {

  00088	eb 17		 jmp	 SHORT $LN1@math_frexp
$LN4@math_frexp:

; 1505 :         PyFPE_START_PROTECT("in math_frexp", return 0);
; 1506 :         x = frexp(x, &i);

  0008a	48 8d 54 24 28	 lea	 rdx, QWORD PTR i$[rsp]
  0008f	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp
  0009b	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0
$LN1@math_frexp:

; 1507 :         PyFPE_END_PROTECT(x);
; 1508 :     }
; 1509 :     return Py_BuildValue("(di)", x, i);

  000a1	44 8b 44 24 28	 mov	 r8d, DWORD PTR i$[rsp]
  000a6	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR x$[rsp]
  000ac	66 48 0f 7e ca	 movd	 rdx, xmm1
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04HPGIGDDH@?$CIdi?$CJ?$AA@
  000b8	e8 00 00 00 00	 call	 Py_BuildValue
$LN6@math_frexp:

; 1510 : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
math_frexp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@JFFMAKJH@Expected?5an?5int?5as?5second?5argume@ ; `string'
PUBLIC	??_C@_08IOHGEICH@dO?3ldexp?$AA@			; `string'
EXTRN	__imp_ldexp:PROC
EXTRN	PyLong_AsLongAndOverflow:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_ldexp DD imagerel math_ldexp
	DD	imagerel math_ldexp+473
	DD	imagerel $unwind$math_ldexp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_ldexp DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0CN@JFFMAKJH@Expected?5an?5int?5as?5second?5argume@
CONST	SEGMENT
??_C@_0CN@JFFMAKJH@Expected?5an?5int?5as?5second?5argume@ DB 'Expected an'
	DB	' int as second argument to ldexp.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IOHGEICH@dO?3ldexp?$AA@
CONST	SEGMENT
??_C@_08IOHGEICH@dO?3ldexp?$AA@ DB 'dO:ldexp', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT math_ldexp
_TEXT	SEGMENT
x$ = 32
exp$ = 40
overflow$ = 44
oexp$ = 48
r$ = 56
tv82 = 64
self$ = 96
args$ = 104
math_ldexp PROC						; COMDAT

; 1521 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1522 :     double x, r;
; 1523 :     PyObject *oexp;
; 1524 :     long exp;
; 1525 :     int overflow;
; 1526 :     if (! PyArg_ParseTuple(args, "dO:ldexp", &x, &oexp))

  0000e	4c 8d 4c 24 30	 lea	 r9, QWORD PTR oexp$[rsp]
  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08IOHGEICH@dO?3ldexp?$AA@
  0001f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN14@math_ldexp

; 1527 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 a0 01 00 00	 jmp	 $LN15@math_ldexp
$LN14@math_ldexp:

; 1528 : 
; 1529 :     if (PyLong_Check(oexp)) {

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR oexp$[rsp]
  00039	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00043	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00048	85 c0		 test	 eax, eax
  0004a	74 55		 je	 SHORT $LN13@math_ldexp

; 1530 :         /* on overflow, replace exponent with either LONG_MAX
; 1531 :            or LONG_MIN, depending on the sign. */
; 1532 :         exp = PyLong_AsLongAndOverflow(oexp, &overflow);

  0004c	48 8d 54 24 2c	 lea	 rdx, QWORD PTR overflow$[rsp]
  00051	48 8b 4c 24 30	 mov	 rcx, QWORD PTR oexp$[rsp]
  00056	e8 00 00 00 00	 call	 PyLong_AsLongAndOverflow
  0005b	89 44 24 28	 mov	 DWORD PTR exp$[rsp], eax

; 1533 :         if (exp == -1 && PyErr_Occurred())

  0005f	83 7c 24 28 ff	 cmp	 DWORD PTR exp$[rsp], -1
  00064	75 11		 jne	 SHORT $LN12@math_ldexp
  00066	e8 00 00 00 00	 call	 PyErr_Occurred
  0006b	48 85 c0	 test	 rax, rax
  0006e	74 07		 je	 SHORT $LN12@math_ldexp

; 1534 :             return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	e9 5d 01 00 00	 jmp	 $LN15@math_ldexp
$LN12@math_ldexp:

; 1535 :         if (overflow)

  00077	83 7c 24 2c 00	 cmp	 DWORD PTR overflow$[rsp], 0
  0007c	74 21		 je	 SHORT $LN11@math_ldexp

; 1536 :             exp = overflow < 0 ? LONG_MIN : LONG_MAX;

  0007e	83 7c 24 2c 00	 cmp	 DWORD PTR overflow$[rsp], 0
  00083	7d 0a		 jge	 SHORT $LN17@math_ldexp
  00085	c7 44 24 40 00
	00 00 80	 mov	 DWORD PTR tv82[rsp], -2147483648 ; ffffffff80000000H
  0008d	eb 08		 jmp	 SHORT $LN18@math_ldexp
$LN17@math_ldexp:
  0008f	c7 44 24 40 ff
	ff ff 7f	 mov	 DWORD PTR tv82[rsp], 2147483647 ; 7fffffffH
$LN18@math_ldexp:
  00097	8b 44 24 40	 mov	 eax, DWORD PTR tv82[rsp]
  0009b	89 44 24 28	 mov	 DWORD PTR exp$[rsp], eax
$LN11@math_ldexp:

; 1537 :     }
; 1538 :     else {

  0009f	eb 1a		 jmp	 SHORT $LN10@math_ldexp
$LN13@math_ldexp:

; 1539 :         PyErr_SetString(PyExc_TypeError,
; 1540 :                         "Expected an int as second argument to ldexp.");

  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@JFFMAKJH@Expected?5an?5int?5as?5second?5argume@
  000a8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000af	e8 00 00 00 00	 call	 PyErr_SetString

; 1541 :         return NULL;

  000b4	33 c0		 xor	 eax, eax
  000b6	e9 19 01 00 00	 jmp	 $LN15@math_ldexp
$LN10@math_ldexp:

; 1542 :     }
; 1543 : 
; 1544 :     if (x == 0. || !Py_IS_FINITE(x)) {

  000bb	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000c1	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000c9	7a 02		 jp	 SHORT $LN19@math_ldexp
  000cb	74 10		 je	 SHORT $LN8@math_ldexp
$LN19@math_ldexp:
  000cd	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000d9	85 c0		 test	 eax, eax
  000db	75 1d		 jne	 SHORT $LN9@math_ldexp
$LN8@math_ldexp:

; 1545 :         /* NaNs, zeros and infinities are returned unchanged */
; 1546 :         r = x;

  000dd	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000e3	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 1547 :         errno = 0;

  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ef	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  000f5	e9 b1 00 00 00	 jmp	 $LN7@math_ldexp
$LN9@math_ldexp:

; 1548 :     } else if (exp > INT_MAX) {

  000fa	81 7c 24 28 ff
	ff ff 7f	 cmp	 DWORD PTR exp$[rsp], 2147483647 ; 7fffffffH
  00102	7e 2b		 jle	 SHORT $LN6@math_ldexp

; 1549 :         /* overflow */
; 1550 :         r = copysign(Py_HUGE_VAL, x);

  00104	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR x$[rsp]
  0010a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00111	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  0011b	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 1551 :         errno = ERANGE;

  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00127	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
  0012d	eb 7c		 jmp	 SHORT $LN5@math_ldexp
$LN6@math_ldexp:

; 1552 :     } else if (exp < INT_MIN) {

  0012f	81 7c 24 28 00
	00 00 80	 cmp	 DWORD PTR exp$[rsp], -2147483648 ; ffffffff80000000H
  00137	7d 24		 jge	 SHORT $LN4@math_ldexp

; 1553 :         /* underflow to +-0 */
; 1554 :         r = copysign(0., x);

  00139	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR x$[rsp]
  0013f	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00149	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 1555 :         errno = 0;

  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00155	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1556 :     } else {

  0015b	eb 4e		 jmp	 SHORT $LN3@math_ldexp
$LN4@math_ldexp:

; 1557 :         errno = 0;

  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00163	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1558 :         PyFPE_START_PROTECT("in math_ldexp", return 0);
; 1559 :         r = ldexp(x, (int)exp);

  00169	8b 54 24 28	 mov	 edx, DWORD PTR exp$[rsp]
  0016d	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  00179	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR r$[rsp], xmm0

; 1560 :         PyFPE_END_PROTECT(r);
; 1561 :         if (Py_IS_INFINITY(r))

  0017f	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0018b	85 c0		 test	 eax, eax
  0018d	75 1c		 jne	 SHORT $LN2@math_ldexp
  0018f	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0019b	85 c0		 test	 eax, eax
  0019d	75 0c		 jne	 SHORT $LN2@math_ldexp

; 1562 :             errno = ERANGE;

  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001a5	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
$LN2@math_ldexp:
$LN3@math_ldexp:
$LN5@math_ldexp:
$LN7@math_ldexp:

; 1563 :     }
; 1564 : 
; 1565 :     if (errno && is_error(r))

  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001b1	83 38 00	 cmp	 DWORD PTR [rax], 0
  001b4	74 13		 je	 SHORT $LN1@math_ldexp
  001b6	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  001bc	e8 00 00 00 00	 call	 is_error
  001c1	85 c0		 test	 eax, eax
  001c3	74 04		 je	 SHORT $LN1@math_ldexp

; 1566 :         return NULL;

  001c5	33 c0		 xor	 eax, eax
  001c7	eb 0b		 jmp	 SHORT $LN15@math_ldexp
$LN1@math_ldexp:

; 1567 :     return PyFloat_FromDouble(r);

  001c9	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR r$[rsp]
  001cf	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN15@math_ldexp:

; 1568 : }

  001d4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d8	c3		 ret	 0
math_ldexp ENDP
_TEXT	ENDS
PUBLIC	??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@		; `string'
EXTRN	__imp_modf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_modf DD imagerel math_modf
	DD	imagerel math_modf+295
	DD	imagerel $unwind$math_modf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_modf DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
CONST	SEGMENT
??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@ DB '(dd)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT math_modf
_TEXT	SEGMENT
x$ = 32
y$ = 40
self$ = 64
arg$ = 72
math_modf PROC						; COMDAT

; 1576 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1577 :     double y, x = PyFloat_AsDouble(arg);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00013	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00018	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1578 :     if (x == -1.0 && PyErr_Occurred())

  0001e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00024	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0002c	7a 13		 jp	 SHORT $LN5@math_modf
  0002e	75 11		 jne	 SHORT $LN5@math_modf
  00030	e8 00 00 00 00	 call	 PyErr_Occurred
  00035	48 85 c0	 test	 rax, rax
  00038	74 07		 je	 SHORT $LN5@math_modf

; 1579 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 e1 00 00 00	 jmp	 $LN6@math_modf
$LN5@math_modf:

; 1580 :     /* some platforms don't do the right thing for NaNs and
; 1581 :        infinities, so we take care of special cases directly. */
; 1582 :     if (!Py_IS_FINITE(x)) {

  00041	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0004d	85 c0		 test	 eax, eax
  0004f	0f 85 88 00 00
	00		 jne	 $LN4@math_modf

; 1583 :         if (Py_IS_INFINITY(x))

  00055	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00061	85 c0		 test	 eax, eax
  00063	75 44		 jne	 SHORT $LN3@math_modf
  00065	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00071	85 c0		 test	 eax, eax
  00073	75 34		 jne	 SHORT $LN3@math_modf

; 1584 :             return Py_BuildValue("(dd)", copysign(0., x), x);

  00075	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR x$[rsp]
  0007b	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00085	f2 0f 10 54 24
	20		 movsdx	 xmm2, QWORD PTR x$[rsp]
  0008b	66 49 0f 7e d0	 movd	 r8, xmm2
  00090	66 0f 28 c8	 movapd	 xmm1, xmm0
  00094	66 48 0f 7e ca	 movd	 rdx, xmm1
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
  000a0	e8 00 00 00 00	 call	 Py_BuildValue
  000a5	eb 7b		 jmp	 SHORT $LN6@math_modf
  000a7	eb 34		 jmp	 SHORT $LN2@math_modf
$LN3@math_modf:

; 1585 :         else if (Py_IS_NAN(x))

  000a9	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000b5	85 c0		 test	 eax, eax
  000b7	74 24		 je	 SHORT $LN1@math_modf

; 1586 :             return Py_BuildValue("(dd)", x, x);

  000b9	f2 0f 10 54 24
	20		 movsdx	 xmm2, QWORD PTR x$[rsp]
  000bf	66 49 0f 7e d0	 movd	 r8, xmm2
  000c4	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR x$[rsp]
  000ca	66 48 0f 7e ca	 movd	 rdx, xmm1
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
  000d6	e8 00 00 00 00	 call	 Py_BuildValue
  000db	eb 45		 jmp	 SHORT $LN6@math_modf
$LN1@math_modf:
$LN2@math_modf:
$LN4@math_modf:

; 1587 :     }
; 1588 : 
; 1589 :     errno = 0;

  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e3	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1590 :     PyFPE_START_PROTECT("in math_modf", return 0);
; 1591 :     x = modf(x, &y);

  000e9	48 8d 54 24 28	 lea	 rdx, QWORD PTR y$[rsp]
  000ee	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf
  000fa	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1592 :     PyFPE_END_PROTECT(x);
; 1593 :     return Py_BuildValue("(dd)", x, y);

  00100	f2 0f 10 54 24
	28		 movsdx	 xmm2, QWORD PTR y$[rsp]
  00106	66 49 0f 7e d0	 movd	 r8, xmm2
  0010b	f2 0f 10 4c 24
	20		 movsdx	 xmm1, QWORD PTR x$[rsp]
  00111	66 48 0f 7e ca	 movd	 rdx, xmm1
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04HHLAPAGE@?$CIdd?$CJ?$AA@
  0011d	e8 00 00 00 00	 call	 Py_BuildValue
$LN6@math_modf:

; 1594 : }

  00122	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00126	c3		 ret	 0
math_modf ENDP
_TEXT	ENDS
EXTRN	PyNumber_TrueDivide:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_log DD imagerel math_log
	DD	imagerel math_log+236
	DD	imagerel $unwind$math_log
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_log DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_log
_TEXT	SEGMENT
den$ = 48
arg$ = 56
num$ = 64
base$ = 72
ans$ = 80
self$ = 112
args$ = 120
math_log PROC						; COMDAT

; 1651 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1652 :     PyObject *arg;
; 1653 :     PyObject *base = NULL;

  0000e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR base$[rsp], 0

; 1654 :     PyObject *num, *den;
; 1655 :     PyObject *ans;
; 1656 : 
; 1657 :     if (!PyArg_UnpackTuple(args, "log", 1, 2, &arg, &base))

  00017	48 8d 44 24 48	 lea	 rax, QWORD PTR base$[rsp]
  0001c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00021	48 8d 44 24 38	 lea	 rax, QWORD PTR arg$[rsp]
  00026	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00031	41 b8 01 00 00
	00		 mov	 r8d, 1
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03MGHMBJCF@log?$AA@
  0003e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00043	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00048	85 c0		 test	 eax, eax
  0004a	75 07		 jne	 SHORT $LN4@math_log

; 1658 :         return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 94 00 00 00	 jmp	 $LN5@math_log
$LN4@math_log:

; 1659 : 
; 1660 :     num = loghelper(arg, m_log, "log");

  00053	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03MGHMBJCF@log?$AA@
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_log
  00061	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arg$[rsp]
  00066	e8 00 00 00 00	 call	 loghelper
  0006b	48 89 44 24 40	 mov	 QWORD PTR num$[rsp], rax

; 1661 :     if (num == NULL || base == NULL)

  00070	48 83 7c 24 40
	00		 cmp	 QWORD PTR num$[rsp], 0
  00076	74 08		 je	 SHORT $LN2@math_log
  00078	48 83 7c 24 48
	00		 cmp	 QWORD PTR base$[rsp], 0
  0007e	75 07		 jne	 SHORT $LN3@math_log
$LN2@math_log:

; 1662 :         return num;

  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR num$[rsp]
  00085	eb 60		 jmp	 SHORT $LN5@math_log
$LN3@math_log:

; 1663 : 
; 1664 :     den = loghelper(base, m_log, "log");

  00087	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03MGHMBJCF@log?$AA@
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_log
  00095	48 8b 4c 24 48	 mov	 rcx, QWORD PTR base$[rsp]
  0009a	e8 00 00 00 00	 call	 loghelper
  0009f	48 89 44 24 30	 mov	 QWORD PTR den$[rsp], rax

; 1665 :     if (den == NULL) {

  000a4	48 83 7c 24 30
	00		 cmp	 QWORD PTR den$[rsp], 0
  000aa	75 0e		 jne	 SHORT $LN1@math_log

; 1666 :         Py_DECREF(num);

  000ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num$[rsp]
  000b1	e8 00 00 00 00	 call	 _Py_DecRef

; 1667 :         return NULL;

  000b6	33 c0		 xor	 eax, eax
  000b8	eb 2d		 jmp	 SHORT $LN5@math_log
$LN1@math_log:

; 1668 :     }
; 1669 : 
; 1670 :     ans = PyNumber_TrueDivide(num, den);

  000ba	48 8b 54 24 30	 mov	 rdx, QWORD PTR den$[rsp]
  000bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num$[rsp]
  000c4	e8 00 00 00 00	 call	 PyNumber_TrueDivide
  000c9	48 89 44 24 50	 mov	 QWORD PTR ans$[rsp], rax

; 1671 :     Py_DECREF(num);

  000ce	48 8b 4c 24 40	 mov	 rcx, QWORD PTR num$[rsp]
  000d3	e8 00 00 00 00	 call	 _Py_DecRef

; 1672 :     Py_DECREF(den);

  000d8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR den$[rsp]
  000dd	e8 00 00 00 00	 call	 _Py_DecRef

; 1673 :     return ans;

  000e2	48 8b 44 24 50	 mov	 rax, QWORD PTR ans$[rsp]
$LN5@math_log:

; 1674 : }

  000e7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000eb	c3		 ret	 0
math_log ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_log DD	imagerel m_log
	DD	imagerel m_log+222
	DD	imagerel $unwind$m_log
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_log DD 010a01H
	DD	0420aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT m_log
_TEXT	SEGMENT
x$ = 48
m_log	PROC						; COMDAT

; 561  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 562  :     if (Py_IS_FINITE(x)) {

  0000a	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00016	85 c0		 test	 eax, eax
  00018	74 6c		 je	 SHORT $LN9@m_log

; 563  :         if (x > 0.0)

  0001a	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00020	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00028	76 10		 jbe	 SHORT $LN8@m_log

; 564  :             return log(x);

  0002a	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00030	e8 00 00 00 00	 call	 log
  00035	e9 9f 00 00 00	 jmp	 $LN10@m_log
$LN8@m_log:

; 565  :         errno = EDOM;

  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00040	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 566  :         if (x == 0.0)

  00046	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0004c	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00054	7a 19		 jp	 SHORT $LN7@m_log
  00056	75 17		 jne	 SHORT $LN7@m_log

; 567  :             return -Py_HUGE_VAL; /* log(0) = -inf */

  00058	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  0005f	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  00063	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  0006b	eb 6c		 jmp	 SHORT $LN10@m_log

; 568  :         else

  0006d	eb 15		 jmp	 SHORT $LN6@m_log
$LN7@m_log:

; 569  :             return Py_NAN; /* log(-ve) = nan */

  0006f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00076	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0007a	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@0000000000000000
  00082	eb 55		 jmp	 SHORT $LN10@m_log
$LN6@m_log:

; 570  :     }
; 571  :     else if (Py_IS_NAN(x))

  00084	eb 53		 jmp	 SHORT $LN5@m_log
$LN9@m_log:
  00086	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00092	85 c0		 test	 eax, eax
  00094	74 0a		 je	 SHORT $LN4@m_log

; 572  :         return x; /* log(nan) = nan */

  00096	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0009c	eb 3b		 jmp	 SHORT $LN10@m_log
  0009e	eb 39		 jmp	 SHORT $LN3@m_log
$LN4@m_log:

; 573  :     else if (x > 0.0)

  000a0	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000a6	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  000ae	76 0a		 jbe	 SHORT $LN2@m_log

; 574  :         return x; /* log(inf) = inf */

  000b0	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000b6	eb 21		 jmp	 SHORT $LN10@m_log

; 575  :     else {

  000b8	eb 1f		 jmp	 SHORT $LN1@m_log
$LN2@m_log:

; 576  :         errno = EDOM;

  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c0	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 577  :         return Py_NAN; /* log(-inf) = nan */

  000c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  000cd	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  000d1	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@0000000000000000
$LN1@m_log:
$LN3@m_log:
$LN5@m_log:
$LN10@m_log:

; 578  :     }
; 579  : }

  000d9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000dd	c3		 ret	 0
m_log	ENDP
_TEXT	ENDS
EXTRN	_PyLong_Frexp:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyLong_AsDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$loghelper DD imagerel loghelper
	DD	imagerel loghelper+339
	DD	imagerel $unwind$loghelper
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$loghelper DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT loghelper
_TEXT	SEGMENT
x$21165 = 32
result$21166 = 40
e$21167 = 48
tv86 = 56
arg$ = 80
func$ = 88
funcname$ = 96
loghelper PROC						; COMDAT

; 1613 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1614 :     /* If it is int, do it ourselves. */
; 1615 :     if (PyLong_Check(arg)) {

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00027	85 c0		 test	 eax, eax
  00029	0f 84 0d 01 00
	00		 je	 $LN6@loghelper

; 1616 :         double x, result;
; 1617 :         Py_ssize_t e;
; 1618 : 
; 1619 :         /* Negative or zero inputs give a ValueError. */
; 1620 :         if (Py_SIZE(arg) <= 0) {

  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  00034	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00039	7f 1a		 jg	 SHORT $LN5@loghelper

; 1621 :             PyErr_SetString(PyExc_ValueError,
; 1622 :                             "math domain error");

  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@LMCJDMHE@math?5domain?5error?$AA@
  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00049	e8 00 00 00 00	 call	 PyErr_SetString

; 1623 :             return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 f9 00 00 00	 jmp	 $LN7@loghelper
$LN5@loghelper:

; 1624 :         }
; 1625 : 
; 1626 :         x = PyLong_AsDouble(arg);

  00055	48 8b 4c 24 50	 mov	 rcx, QWORD PTR arg$[rsp]
  0005a	e8 00 00 00 00	 call	 PyLong_AsDouble
  0005f	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21165[rsp], xmm0

; 1627 :         if (x == -1.0 && PyErr_Occurred()) {

  00065	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21165[rsp]
  0006b	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00073	0f 8a a6 00 00
	00		 jp	 $LN4@loghelper
  00079	0f 85 a0 00 00
	00		 jne	 $LN4@loghelper
  0007f	e8 00 00 00 00	 call	 PyErr_Occurred
  00084	48 85 c0	 test	 rax, rax
  00087	0f 84 92 00 00
	00		 je	 $LN4@loghelper

; 1628 :             if (!PyErr_ExceptionMatches(PyExc_OverflowError))

  0008d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00094	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00099	85 c0		 test	 eax, eax
  0009b	75 07		 jne	 SHORT $LN3@loghelper

; 1629 :                 return NULL;

  0009d	33 c0		 xor	 eax, eax
  0009f	e9 aa 00 00 00	 jmp	 $LN7@loghelper
$LN3@loghelper:

; 1630 :             /* Here the conversion to double overflowed, but it's possible
; 1631 :                to compute the log anyway.  Clear the exception and continue. */
; 1632 :             PyErr_Clear();

  000a4	e8 00 00 00 00	 call	 PyErr_Clear

; 1633 :             x = _PyLong_Frexp((PyLongObject *)arg, &e);

  000a9	48 8d 54 24 30	 lea	 rdx, QWORD PTR e$21167[rsp]
  000ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR arg$[rsp]
  000b3	e8 00 00 00 00	 call	 _PyLong_Frexp
  000b8	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$21165[rsp], xmm0

; 1634 :             if (x == -1.0 && PyErr_Occurred())

  000be	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21165[rsp]
  000c4	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  000cc	7a 10		 jp	 SHORT $LN2@loghelper
  000ce	75 0e		 jne	 SHORT $LN2@loghelper
  000d0	e8 00 00 00 00	 call	 PyErr_Occurred
  000d5	48 85 c0	 test	 rax, rax
  000d8	74 04		 je	 SHORT $LN2@loghelper

; 1635 :                 return NULL;

  000da	33 c0		 xor	 eax, eax
  000dc	eb 70		 jmp	 SHORT $LN7@loghelper
$LN2@loghelper:

; 1636 :             /* Value is ~= x * 2**e, so the log ~= log(x) + log(2) * e. */
; 1637 :             result = func(x) + func(2.0) * e;

  000de	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21165[rsp]
  000e4	ff 54 24 58	 call	 QWORD PTR func$[rsp]
  000e8	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR tv86[rsp], xmm0
  000ee	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  000f6	ff 54 24 58	 call	 QWORD PTR func$[rsp]
  000fa	66 0f ef c9	 pxor	 xmm1, xmm1
  000fe	f2 48 0f 2a 4c
	24 30		 cvtsi2sd xmm1, QWORD PTR e$21167[rsp]
  00105	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00109	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR tv86[rsp]
  0010f	f2 0f 58 c8	 addsd	 xmm1, xmm0
  00113	66 0f 28 c1	 movapd	 xmm0, xmm1
  00117	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR result$21166[rsp], xmm0

; 1638 :         }
; 1639 :         else

  0011d	eb 10		 jmp	 SHORT $LN1@loghelper
$LN4@loghelper:

; 1640 :             /* Successfully converted x to a double. */
; 1641 :             result = func(x);

  0011f	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$21165[rsp]
  00125	ff 54 24 58	 call	 QWORD PTR func$[rsp]
  00129	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR result$21166[rsp], xmm0
$LN1@loghelper:

; 1642 :         return PyFloat_FromDouble(result);

  0012f	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR result$21166[rsp]
  00135	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0013a	eb 12		 jmp	 SHORT $LN7@loghelper
$LN6@loghelper:

; 1643 :     }
; 1644 : 
; 1645 :     /* Else let libm handle it by itself. */
; 1646 :     return math_1(arg, func, 0);

  0013c	45 33 c0	 xor	 r8d, r8d
  0013f	48 8b 54 24 58	 mov	 rdx, QWORD PTR func$[rsp]
  00144	48 8b 4c 24 50	 mov	 rcx, QWORD PTR arg$[rsp]
  00149	e8 00 00 00 00	 call	 math_1
$LN7@loghelper:

; 1647 : }

  0014e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00152	c3		 ret	 0
loghelper ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_log2 DD imagerel math_log2
	DD	imagerel math_log2+43
	DD	imagerel $unwind$math_log2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_log2 DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_log2
_TEXT	SEGMENT
self$ = 48
arg$ = 56
math_log2 PROC						; COMDAT

; 1683 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1684 :     return loghelper(arg, m_log2, "log2");

  0000e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04KGLCPMCP@log2?$AA@
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_log2
  0001c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arg$[rsp]
  00021	e8 00 00 00 00	 call	 loghelper

; 1685 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
math_log2 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_log2 DD imagerel m_log2
	DD	imagerel m_log2+407
	DD	imagerel $unwind$m_log2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_log2 DD 010a01H
	DD	0820aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT m_log2
_TEXT	SEGMENT
e$20506 = 32
m$20505 = 40
tv79 = 48
tv88 = 56
x$ = 80
m_log2	PROC						; COMDAT

; 593  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 594  :     if (!Py_IS_FINITE(x)) {

  0000a	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00016	85 c0		 test	 eax, eax
  00018	75 5e		 jne	 SHORT $LN11@m_log2

; 595  :         if (Py_IS_NAN(x))

  0001a	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00026	85 c0		 test	 eax, eax
  00028	74 0d		 je	 SHORT $LN10@m_log2

; 596  :             return x; /* log2(nan) = nan */

  0002a	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00030	e9 5d 01 00 00	 jmp	 $LN12@m_log2
  00035	eb 41		 jmp	 SHORT $LN9@m_log2
$LN10@m_log2:

; 597  :         else if (x > 0.0)

  00037	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0003d	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00045	76 0d		 jbe	 SHORT $LN8@m_log2

; 598  :             return x; /* log2(+inf) = +inf */

  00047	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0004d	e9 40 01 00 00	 jmp	 $LN12@m_log2

; 599  :         else {

  00052	eb 24		 jmp	 SHORT $LN7@m_log2
$LN8@m_log2:

; 600  :             errno = EDOM;

  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005a	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 601  :             return Py_NAN; /* log2(-inf) = nan, invalid-operation */

  00060	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00067	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0006b	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@0000000000000000
  00073	e9 1a 01 00 00	 jmp	 $LN12@m_log2
$LN7@m_log2:
$LN9@m_log2:
$LN11@m_log2:

; 602  :         }
; 603  :     }
; 604  : 
; 605  :     if (x > 0.0) {

  00078	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0007e	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00086	0f 86 b2 00 00
	00		 jbe	 $LN6@m_log2

; 606  : #ifdef HAVE_LOG2
; 607  :         return log2(x);
; 608  : #else
; 609  :         double m;
; 610  :         int e;
; 611  :         m = frexp(x, &e);

  0008c	48 8d 54 24 20	 lea	 rdx, QWORD PTR e$20506[rsp]
  00091	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_frexp
  0009d	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR m$20505[rsp], xmm0

; 612  :         /* We want log2(m * 2**e) == log(m) / log(2) + e.  Care is needed when
; 613  :          * x is just greater than 1.0: in that case e is 1, log(m) is negative,
; 614  :          * and we get significant cancellation error from the addition of
; 615  :          * log(m) / log(2) to e.  The slight rewrite of the expression below
; 616  :          * avoids this problem.
; 617  :          */
; 618  :         if (x >= 1.0) {

  000a3	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000a9	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  000b1	72 4d		 jb	 SHORT $LN5@m_log2

; 619  :             return log(2.0 * m) / log(2.0) + (e - 1);

  000b3	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  000bb	f2 0f 59 44 24
	28		 mulsd	 xmm0, QWORD PTR m$20505[rsp]
  000c1	e8 00 00 00 00	 call	 log
  000c6	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR tv79[rsp], xmm0
  000cc	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  000d4	e8 00 00 00 00	 call	 log
  000d9	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR tv79[rsp]
  000df	f2 0f 5e c8	 divsd	 xmm1, xmm0
  000e3	66 0f 28 c1	 movapd	 xmm0, xmm1
  000e7	8b 44 24 20	 mov	 eax, DWORD PTR e$20506[rsp]
  000eb	ff c8		 dec	 eax
  000ed	66 0f 6e c8	 movd	 xmm1, eax
  000f1	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  000f5	f2 0f 58 c1	 addsd	 xmm0, xmm1
  000f9	e9 94 00 00 00	 jmp	 $LN12@m_log2

; 620  :         }
; 621  :         else {

  000fe	eb 3c		 jmp	 SHORT $LN4@m_log2
$LN5@m_log2:

; 622  :             return log(m) / log(2.0) + e;

  00100	f2 0f 10 44 24
	28		 movsdx	 xmm0, QWORD PTR m$20505[rsp]
  00106	e8 00 00 00 00	 call	 log
  0010b	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR tv88[rsp], xmm0
  00111	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4000000000000000
  00119	e8 00 00 00 00	 call	 log
  0011e	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR tv88[rsp]
  00124	f2 0f 5e c8	 divsd	 xmm1, xmm0
  00128	66 0f 28 c1	 movapd	 xmm0, xmm1
  0012c	66 0f 6e 4c 24
	20		 movd	 xmm1, DWORD PTR e$20506[rsp]
  00132	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  00136	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0013a	eb 56		 jmp	 SHORT $LN12@m_log2
$LN4@m_log2:

; 623  :         }

  0013c	eb 54		 jmp	 SHORT $LN3@m_log2
$LN6@m_log2:

; 624  : #endif
; 625  :     }
; 626  :     else if (x == 0.0) {

  0013e	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00144	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  0014c	7a 25		 jp	 SHORT $LN2@m_log2
  0014e	75 23		 jne	 SHORT $LN2@m_log2

; 627  :         errno = EDOM;

  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00156	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 628  :         return -Py_HUGE_VAL; /* log2(0) = -inf, divide-by-zero */

  0015c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00163	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  00167	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  0016f	eb 21		 jmp	 SHORT $LN12@m_log2

; 629  :     }
; 630  :     else {

  00171	eb 1f		 jmp	 SHORT $LN1@m_log2
$LN2@m_log2:

; 631  :         errno = EDOM;

  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00179	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 632  :         return Py_NAN; /* log2(-inf) = nan, invalid-operation */

  0017f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00186	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0018a	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@0000000000000000
$LN1@m_log2:
$LN3@m_log2:
$LN12@m_log2:

; 633  :     }
; 634  : }

  00192	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00196	c3		 ret	 0
m_log2	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_log10 DD imagerel math_log10
	DD	imagerel math_log10+43
	DD	imagerel $unwind$math_log10
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_log10 DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_log10
_TEXT	SEGMENT
self$ = 48
arg$ = 56
math_log10 PROC						; COMDAT

; 1692 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1693 :     return loghelper(arg, m_log10, "log10");

  0000e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05HGHHAHAP@log10?$AA@
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:m_log10
  0001c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arg$[rsp]
  00021	e8 00 00 00 00	 call	 loghelper

; 1694 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
math_log10 ENDP
_TEXT	ENDS
EXTRN	log10:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$m_log10 DD imagerel m_log10
	DD	imagerel m_log10+222
	DD	imagerel $unwind$m_log10
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$m_log10 DD 010a01H
	DD	0420aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT m_log10
_TEXT	SEGMENT
x$ = 48
m_log10	PROC						; COMDAT

; 638  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 639  :     if (Py_IS_FINITE(x)) {

  0000a	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00016	85 c0		 test	 eax, eax
  00018	74 6c		 je	 SHORT $LN9@m_log10

; 640  :         if (x > 0.0)

  0001a	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00020	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00028	76 10		 jbe	 SHORT $LN8@m_log10

; 641  :             return log10(x);

  0002a	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00030	e8 00 00 00 00	 call	 log10
  00035	e9 9f 00 00 00	 jmp	 $LN10@m_log10
$LN8@m_log10:

; 642  :         errno = EDOM;

  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00040	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 643  :         if (x == 0.0)

  00046	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0004c	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00054	7a 19		 jp	 SHORT $LN7@m_log10
  00056	75 17		 jne	 SHORT $LN7@m_log10

; 644  :             return -Py_HUGE_VAL; /* log10(0) = -inf */

  00058	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  0005f	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  00063	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  0006b	eb 6c		 jmp	 SHORT $LN10@m_log10

; 645  :         else

  0006d	eb 15		 jmp	 SHORT $LN6@m_log10
$LN7@m_log10:

; 646  :             return Py_NAN; /* log10(-ve) = nan */

  0006f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  00076	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  0007a	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@0000000000000000
  00082	eb 55		 jmp	 SHORT $LN10@m_log10
$LN6@m_log10:

; 647  :     }
; 648  :     else if (Py_IS_NAN(x))

  00084	eb 53		 jmp	 SHORT $LN5@m_log10
$LN9@m_log10:
  00086	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00092	85 c0		 test	 eax, eax
  00094	74 0a		 je	 SHORT $LN4@m_log10

; 649  :         return x; /* log10(nan) = nan */

  00096	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0009c	eb 3b		 jmp	 SHORT $LN10@m_log10
  0009e	eb 39		 jmp	 SHORT $LN3@m_log10
$LN4@m_log10:

; 650  :     else if (x > 0.0)

  000a0	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000a6	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  000ae	76 0a		 jbe	 SHORT $LN2@m_log10

; 651  :         return x; /* log10(inf) = inf */

  000b0	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000b6	eb 21		 jmp	 SHORT $LN10@m_log10

; 652  :     else {

  000b8	eb 1f		 jmp	 SHORT $LN1@m_log10
$LN2@m_log10:

; 653  :         errno = EDOM;

  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c0	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 654  :         return Py_NAN; /* log10(-inf) = nan */

  000c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__HUGE
  000cd	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  000d1	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@0000000000000000
$LN1@m_log10:
$LN3@m_log10:
$LN5@m_log10:
$LN10@m_log10:

; 655  :     }
; 656  : }

  000d9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000dd	c3		 ret	 0
m_log10	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_fmod DD imagerel math_fmod
	DD	imagerel math_fmod+380
	DD	imagerel $unwind$math_fmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_fmod DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_fmod
_TEXT	SEGMENT
y$ = 48
x$ = 56
ox$ = 64
oy$ = 72
r$ = 80
self$ = 112
args$ = 120
math_fmod PROC						; COMDAT

; 1701 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1702 :     PyObject *ox, *oy;
; 1703 :     double r, x, y;
; 1704 :     if (! PyArg_UnpackTuple(args, "fmod", 2, 2, &ox, &oy))

  0000e	48 8d 44 24 48	 lea	 rax, QWORD PTR oy$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00018	48 8d 44 24 40	 lea	 rax, QWORD PTR ox$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	41 b9 02 00 00
	00		 mov	 r9d, 2
  00028	41 b8 02 00 00
	00		 mov	 r8d, 2
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04KEPJIHGP@fmod?$AA@
  00035	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  0003a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003f	85 c0		 test	 eax, eax
  00041	75 07		 jne	 SHORT $LN9@math_fmod

; 1705 :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 2d 01 00 00	 jmp	 $LN10@math_fmod
$LN9@math_fmod:

; 1706 :     x = PyFloat_AsDouble(ox);

  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ox$[rsp]
  0004f	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00054	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1707 :     y = PyFloat_AsDouble(oy);

  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR oy$[rsp]
  0005f	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00064	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR y$[rsp], xmm0

; 1708 :     if ((x == -1.0 || y == -1.0) && PyErr_Occurred())

  0006a	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00070	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00078	7a 02		 jp	 SHORT $LN12@math_fmod
  0007a	74 12		 je	 SHORT $LN7@math_fmod
$LN12@math_fmod:
  0007c	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00082	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0008a	7a 13		 jp	 SHORT $LN8@math_fmod
  0008c	75 11		 jne	 SHORT $LN8@math_fmod
$LN7@math_fmod:
  0008e	e8 00 00 00 00	 call	 PyErr_Occurred
  00093	48 85 c0	 test	 rax, rax
  00096	74 07		 je	 SHORT $LN8@math_fmod

; 1709 :         return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	e9 d8 00 00 00	 jmp	 $LN10@math_fmod
$LN8@math_fmod:

; 1710 :     /* fmod(x, +/-Inf) returns x for finite x. */
; 1711 :     if (Py_IS_INFINITY(y) && Py_IS_FINITE(x))

  0009f	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000ab	85 c0		 test	 eax, eax
  000ad	75 30		 jne	 SHORT $LN6@math_fmod
  000af	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000bb	85 c0		 test	 eax, eax
  000bd	75 20		 jne	 SHORT $LN6@math_fmod
  000bf	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000cb	85 c0		 test	 eax, eax
  000cd	74 10		 je	 SHORT $LN6@math_fmod

; 1712 :         return PyFloat_FromDouble(x);

  000cf	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000d5	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000da	e9 98 00 00 00	 jmp	 $LN10@math_fmod
$LN6@math_fmod:

; 1713 :     errno = 0;

  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e5	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1714 :     PyFPE_START_PROTECT("in math_fmod", return 0);
; 1715 :     r = fmod(x, y);

  000eb	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR y$[rsp]
  000f1	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000f7	e8 00 00 00 00	 call	 fmod
  000fc	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR r$[rsp], xmm0

; 1716 :     PyFPE_END_PROTECT(r);
; 1717 :     if (Py_IS_NAN(r)) {

  00102	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0010e	85 c0		 test	 eax, eax
  00110	74 3a		 je	 SHORT $LN5@math_fmod

; 1718 :         if (!Py_IS_NAN(x) && !Py_IS_NAN(y))

  00112	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0011e	85 c0		 test	 eax, eax
  00120	75 1e		 jne	 SHORT $LN4@math_fmod
  00122	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0012e	85 c0		 test	 eax, eax
  00130	75 0e		 jne	 SHORT $LN4@math_fmod

; 1719 :             errno = EDOM;

  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00138	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 1720 :         else

  0013e	eb 0c		 jmp	 SHORT $LN3@math_fmod
$LN4@math_fmod:

; 1721 :             errno = 0;

  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00146	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN3@math_fmod:
$LN5@math_fmod:

; 1722 :     }
; 1723 :     if (errno && is_error(r))

  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00152	83 38 00	 cmp	 DWORD PTR [rax], 0
  00155	74 15		 je	 SHORT $LN2@math_fmod
  00157	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0015d	e8 00 00 00 00	 call	 is_error
  00162	85 c0		 test	 eax, eax
  00164	74 06		 je	 SHORT $LN2@math_fmod

; 1724 :         return NULL;

  00166	33 c0		 xor	 eax, eax
  00168	eb 0d		 jmp	 SHORT $LN10@math_fmod

; 1725 :     else

  0016a	eb 0b		 jmp	 SHORT $LN1@math_fmod
$LN2@math_fmod:

; 1726 :         return PyFloat_FromDouble(r);

  0016c	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  00172	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN1@math_fmod:
$LN10@math_fmod:

; 1727 : }

  00177	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0017b	c3		 ret	 0
math_fmod ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_hypot DD imagerel math_hypot
	DD	imagerel math_hypot+514
	DD	imagerel $unwind$math_hypot
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_hypot DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_hypot
_TEXT	SEGMENT
y$ = 48
x$ = 56
ox$ = 64
oy$ = 72
r$ = 80
self$ = 112
args$ = 120
math_hypot PROC						; COMDAT

; 1735 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1736 :     PyObject *ox, *oy;
; 1737 :     double r, x, y;
; 1738 :     if (! PyArg_UnpackTuple(args, "hypot", 2, 2, &ox, &oy))

  0000e	48 8d 44 24 48	 lea	 rax, QWORD PTR oy$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00018	48 8d 44 24 40	 lea	 rax, QWORD PTR ox$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	41 b9 02 00 00
	00		 mov	 r9d, 2
  00028	41 b8 02 00 00
	00		 mov	 r8d, 2
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05DNLPMBKG@hypot?$AA@
  00035	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  0003a	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003f	85 c0		 test	 eax, eax
  00041	75 07		 jne	 SHORT $LN14@math_hypot

; 1739 :         return NULL;

  00043	33 c0		 xor	 eax, eax
  00045	e9 b3 01 00 00	 jmp	 $LN15@math_hypot
$LN14@math_hypot:

; 1740 :     x = PyFloat_AsDouble(ox);

  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ox$[rsp]
  0004f	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00054	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1741 :     y = PyFloat_AsDouble(oy);

  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR oy$[rsp]
  0005f	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00064	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR y$[rsp], xmm0

; 1742 :     if ((x == -1.0 || y == -1.0) && PyErr_Occurred())

  0006a	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00070	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00078	7a 02		 jp	 SHORT $LN17@math_hypot
  0007a	74 12		 je	 SHORT $LN12@math_hypot
$LN17@math_hypot:
  0007c	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00082	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0008a	7a 13		 jp	 SHORT $LN13@math_hypot
  0008c	75 11		 jne	 SHORT $LN13@math_hypot
$LN12@math_hypot:
  0008e	e8 00 00 00 00	 call	 PyErr_Occurred
  00093	48 85 c0	 test	 rax, rax
  00096	74 07		 je	 SHORT $LN13@math_hypot

; 1743 :         return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	e9 5e 01 00 00	 jmp	 $LN15@math_hypot
$LN13@math_hypot:

; 1744 :     /* hypot(x, +/-Inf) returns Inf, even if x is a NaN. */
; 1745 :     if (Py_IS_INFINITY(x))

  0009f	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000ab	85 c0		 test	 eax, eax
  000ad	75 25		 jne	 SHORT $LN11@math_hypot
  000af	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000bb	85 c0		 test	 eax, eax
  000bd	75 15		 jne	 SHORT $LN11@math_hypot

; 1746 :         return PyFloat_FromDouble(fabs(x));

  000bf	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000c5	e8 00 00 00 00	 call	 fabs
  000ca	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000cf	e9 29 01 00 00	 jmp	 $LN15@math_hypot
$LN11@math_hypot:

; 1747 :     if (Py_IS_INFINITY(y))

  000d4	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000e0	85 c0		 test	 eax, eax
  000e2	75 25		 jne	 SHORT $LN10@math_hypot
  000e4	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000f0	85 c0		 test	 eax, eax
  000f2	75 15		 jne	 SHORT $LN10@math_hypot

; 1748 :         return PyFloat_FromDouble(fabs(y));

  000f4	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  000fa	e8 00 00 00 00	 call	 fabs
  000ff	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00104	e9 f4 00 00 00	 jmp	 $LN15@math_hypot
$LN10@math_hypot:

; 1749 :     errno = 0;

  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0010f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1750 :     PyFPE_START_PROTECT("in math_hypot", return 0);
; 1751 :     r = hypot(x, y);

  00115	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR y$[rsp]
  0011b	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00121	e8 00 00 00 00	 call	 hypot
  00126	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR r$[rsp], xmm0

; 1752 :     PyFPE_END_PROTECT(r);
; 1753 :     if (Py_IS_NAN(r)) {

  0012c	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00138	85 c0		 test	 eax, eax
  0013a	74 3c		 je	 SHORT $LN9@math_hypot

; 1754 :         if (!Py_IS_NAN(x) && !Py_IS_NAN(y))

  0013c	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00148	85 c0		 test	 eax, eax
  0014a	75 1e		 jne	 SHORT $LN8@math_hypot
  0014c	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00158	85 c0		 test	 eax, eax
  0015a	75 0e		 jne	 SHORT $LN8@math_hypot

; 1755 :             errno = EDOM;

  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00162	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 1756 :         else

  00168	eb 0c		 jmp	 SHORT $LN7@math_hypot
$LN8@math_hypot:

; 1757 :             errno = 0;

  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00170	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN7@math_hypot:

; 1758 :     }
; 1759 :     else if (Py_IS_INFINITY(r)) {

  00176	eb 5a		 jmp	 SHORT $LN6@math_hypot
$LN9@math_hypot:
  00178	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00184	85 c0		 test	 eax, eax
  00186	75 4a		 jne	 SHORT $LN5@math_hypot
  00188	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  00194	85 c0		 test	 eax, eax
  00196	75 3a		 jne	 SHORT $LN5@math_hypot

; 1760 :         if (Py_IS_FINITE(x) && Py_IS_FINITE(y))

  00198	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  001a4	85 c0		 test	 eax, eax
  001a6	74 1e		 je	 SHORT $LN4@math_hypot
  001a8	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  001b4	85 c0		 test	 eax, eax
  001b6	74 0e		 je	 SHORT $LN4@math_hypot

; 1761 :             errno = ERANGE;

  001b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001be	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H

; 1762 :         else

  001c4	eb 0c		 jmp	 SHORT $LN3@math_hypot
$LN4@math_hypot:

; 1763 :             errno = 0;

  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001cc	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN3@math_hypot:
$LN5@math_hypot:
$LN6@math_hypot:

; 1764 :     }
; 1765 :     if (errno && is_error(r))

  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001d8	83 38 00	 cmp	 DWORD PTR [rax], 0
  001db	74 15		 je	 SHORT $LN2@math_hypot
  001dd	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  001e3	e8 00 00 00 00	 call	 is_error
  001e8	85 c0		 test	 eax, eax
  001ea	74 06		 je	 SHORT $LN2@math_hypot

; 1766 :         return NULL;

  001ec	33 c0		 xor	 eax, eax
  001ee	eb 0d		 jmp	 SHORT $LN15@math_hypot

; 1767 :     else

  001f0	eb 0b		 jmp	 SHORT $LN1@math_hypot
$LN2@math_hypot:

; 1768 :         return PyFloat_FromDouble(r);

  001f2	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR r$[rsp]
  001f8	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN1@math_hypot:
$LN15@math_hypot:

; 1769 : }

  001fd	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00201	c3		 ret	 0
math_hypot ENDP
_TEXT	ENDS
EXTRN	__imp__hypot:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
pdata	SEGMENT
$pdata$hypot DD	imagerel hypot
	DD	imagerel hypot+39
	DD	imagerel $unwind$hypot
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hypot DD 011001H
	DD	04210H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT hypot
_TEXT	SEGMENT
_X$ = 48
_Y$ = 56
hypot	PROC						; COMDAT

; 162  : {

  00000	f2 0f 11 4c 24
	10		 movsdx	 QWORD PTR [rsp+16], xmm1
  00006	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 163  :     return _hypot(_X, _Y);

  00010	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR _Y$[rsp]
  00016	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR _X$[rsp]
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__hypot

; 164  : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
hypot	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\mathmodule.c
pdata	SEGMENT
$pdata$math_pow DD imagerel math_pow
	DD	imagerel math_pow+1113
	DD	imagerel $unwind$math_pow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_pow DD 021101H
	DD	0130111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_pow
_TEXT	SEGMENT
y$ = 48
x$ = 56
ox$ = 64
oy$ = 72
odd_y$ = 80
r$ = 88
tv91 = 96
tv128 = 104
tv144 = 112
tv149 = 120
tv155 = 128
self$ = 160
args$ = 168
math_pow PROC						; COMDAT

; 1782 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1783 :     PyObject *ox, *oy;
; 1784 :     double r, x, y;
; 1785 :     int odd_y;
; 1786 : 
; 1787 :     if (! PyArg_UnpackTuple(args, "pow", 2, 2, &ox, &oy))

  00011	48 8d 44 24 48	 lea	 rax, QWORD PTR oy$[rsp]
  00016	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0001b	48 8d 44 24 40	 lea	 rax, QWORD PTR ox$[rsp]
  00020	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00025	41 b9 02 00 00
	00		 mov	 r9d, 2
  0002b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JGHBODFD@pow?$AA@
  00038	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00040	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00045	85 c0		 test	 eax, eax
  00047	75 07		 jne	 SHORT $LN32@math_pow

; 1788 :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 01 04 00 00	 jmp	 $LN33@math_pow
$LN32@math_pow:

; 1789 :     x = PyFloat_AsDouble(ox);

  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ox$[rsp]
  00055	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0005a	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1790 :     y = PyFloat_AsDouble(oy);

  00060	48 8b 4c 24 48	 mov	 rcx, QWORD PTR oy$[rsp]
  00065	e8 00 00 00 00	 call	 PyFloat_AsDouble
  0006a	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR y$[rsp], xmm0

; 1791 :     if ((x == -1.0 || y == -1.0) && PyErr_Occurred())

  00070	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00076	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0007e	7a 02		 jp	 SHORT $LN45@math_pow
  00080	74 12		 je	 SHORT $LN30@math_pow
$LN45@math_pow:
  00082	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00088	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00090	7a 13		 jp	 SHORT $LN31@math_pow
  00092	75 11		 jne	 SHORT $LN31@math_pow
$LN30@math_pow:
  00094	e8 00 00 00 00	 call	 PyErr_Occurred
  00099	48 85 c0	 test	 rax, rax
  0009c	74 07		 je	 SHORT $LN31@math_pow

; 1792 :         return NULL;

  0009e	33 c0		 xor	 eax, eax
  000a0	e9 ac 03 00 00	 jmp	 $LN33@math_pow
$LN31@math_pow:

; 1793 : 
; 1794 :     /* deal directly with IEEE specials, to cope with problems on various
; 1795 :        platforms whose semantics don't exactly match C99 */
; 1796 :     r = 0.; /* silence compiler warning */

  000a5	66 0f 57 c0	 xorpd	 xmm0, xmm0
  000a9	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR r$[rsp], xmm0

; 1797 :     if (!Py_IS_FINITE(x) || !Py_IS_FINITE(y)) {

  000af	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000bb	85 c0		 test	 eax, eax
  000bd	74 14		 je	 SHORT $LN28@math_pow
  000bf	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  000cb	85 c0		 test	 eax, eax
  000cd	0f 85 b6 02 00
	00		 jne	 $LN29@math_pow
$LN28@math_pow:

; 1798 :         errno = 0;

  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d9	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1799 :         if (Py_IS_NAN(x))

  000df	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  000eb	85 c0		 test	 eax, eax
  000ed	74 3f		 je	 SHORT $LN27@math_pow

; 1800 :             r = y == 0. ? 1. : x; /* NaN**0 = 1 */

  000ef	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  000f5	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  000fd	7a 12		 jp	 SHORT $LN35@math_pow
  000ff	75 10		 jne	 SHORT $LN35@math_pow
  00101	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00109	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR tv91[rsp], xmm0
  0010f	eb 0c		 jmp	 SHORT $LN36@math_pow
$LN35@math_pow:
  00111	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00117	f2 0f 11 44 24
	60		 movsdx	 QWORD PTR tv91[rsp], xmm0
$LN36@math_pow:
  0011d	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR tv91[rsp]
  00123	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR r$[rsp], xmm0
  00129	e9 56 02 00 00	 jmp	 $LN26@math_pow
$LN27@math_pow:

; 1801 :         else if (Py_IS_NAN(y))

  0012e	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0013a	85 c0		 test	 eax, eax
  0013c	74 3f		 je	 SHORT $LN25@math_pow

; 1802 :             r = x == 1. ? 1. : y; /* 1**NaN = 1 */

  0013e	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00144	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  0014c	7a 12		 jp	 SHORT $LN37@math_pow
  0014e	75 10		 jne	 SHORT $LN37@math_pow
  00150	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00158	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR tv128[rsp], xmm0
  0015e	eb 0c		 jmp	 SHORT $LN38@math_pow
$LN37@math_pow:
  00160	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00166	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR tv128[rsp], xmm0
$LN38@math_pow:
  0016c	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR tv128[rsp]
  00172	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR r$[rsp], xmm0
  00178	e9 07 02 00 00	 jmp	 $LN24@math_pow
$LN25@math_pow:

; 1803 :         else if (Py_IS_INFINITY(x)) {

  0017d	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  00189	85 c0		 test	 eax, eax
  0018b	0f 85 0b 01 00
	00		 jne	 $LN23@math_pow
  00191	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0019d	85 c0		 test	 eax, eax
  0019f	0f 85 f7 00 00
	00		 jne	 $LN23@math_pow

; 1804 :             odd_y = Py_IS_FINITE(y) && fmod(fabs(y), 2.0) == 1.0;

  001a5	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  001b1	85 c0		 test	 eax, eax
  001b3	74 2e		 je	 SHORT $LN39@math_pow
  001b5	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  001bb	e8 00 00 00 00	 call	 fabs
  001c0	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@4000000000000000
  001c8	e8 00 00 00 00	 call	 fmod
  001cd	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  001d5	7a 0c		 jp	 SHORT $LN39@math_pow
  001d7	75 0a		 jne	 SHORT $LN39@math_pow
  001d9	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv144[rsp], 1
  001e1	eb 08		 jmp	 SHORT $LN40@math_pow
$LN39@math_pow:
  001e3	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
$LN40@math_pow:
  001eb	8b 44 24 70	 mov	 eax, DWORD PTR tv144[rsp]
  001ef	89 44 24 50	 mov	 DWORD PTR odd_y$[rsp], eax

; 1805 :             if (y > 0.)

  001f3	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  001f9	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00201	76 34		 jbe	 SHORT $LN22@math_pow

; 1806 :                 r = odd_y ? x : fabs(x);

  00203	83 7c 24 50 00	 cmp	 DWORD PTR odd_y$[rsp], 0
  00208	74 0e		 je	 SHORT $LN41@math_pow
  0020a	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00210	f2 0f 11 44 24
	78		 movsdx	 QWORD PTR tv149[rsp], xmm0
  00216	eb 11		 jmp	 SHORT $LN42@math_pow
$LN41@math_pow:
  00218	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0021e	e8 00 00 00 00	 call	 fabs
  00223	f2 0f 11 44 24
	78		 movsdx	 QWORD PTR tv149[rsp], xmm0
$LN42@math_pow:
  00229	f2 0f 10 44 24
	78		 movsdx	 xmm0, QWORD PTR tv149[rsp]
  0022f	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR r$[rsp], xmm0
  00235	eb 60		 jmp	 SHORT $LN21@math_pow
$LN22@math_pow:

; 1807 :             else if (y == 0.)

  00237	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  0023d	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00245	7a 12		 jp	 SHORT $LN20@math_pow
  00247	75 10		 jne	 SHORT $LN20@math_pow

; 1808 :                 r = 1.;

  00249	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  00251	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR r$[rsp], xmm0

; 1809 :             else /* y < 0. */

  00257	eb 3e		 jmp	 SHORT $LN19@math_pow
$LN20@math_pow:

; 1810 :                 r = odd_y ? copysign(0., x) : 0.;

  00259	83 7c 24 50 00	 cmp	 DWORD PTR odd_y$[rsp], 0
  0025e	74 1b		 je	 SHORT $LN43@math_pow
  00260	f2 0f 10 4c 24
	38		 movsdx	 xmm1, QWORD PTR x$[rsp]
  00266	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0026a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__copysign
  00270	f2 0f 11 84 24
	80 00 00 00	 movsdx	 QWORD PTR tv155[rsp], xmm0
  00279	eb 0d		 jmp	 SHORT $LN44@math_pow
$LN43@math_pow:
  0027b	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0027f	f2 0f 11 84 24
	80 00 00 00	 movsdx	 QWORD PTR tv155[rsp], xmm0
$LN44@math_pow:
  00288	f2 0f 10 84 24
	80 00 00 00	 movsdx	 xmm0, QWORD PTR tv155[rsp]
  00291	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR r$[rsp], xmm0
$LN19@math_pow:
$LN21@math_pow:

; 1811 :         }
; 1812 :         else if (Py_IS_INFINITY(y)) {

  00297	e9 e8 00 00 00	 jmp	 $LN18@math_pow
$LN23@math_pow:
  0029c	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  002a8	85 c0		 test	 eax, eax
  002aa	0f 85 d4 00 00
	00		 jne	 $LN17@math_pow
  002b0	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  002b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  002bc	85 c0		 test	 eax, eax
  002be	0f 85 c0 00 00
	00		 jne	 $LN17@math_pow

; 1813 :             if (fabs(x) == 1.0)

  002c4	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  002ca	e8 00 00 00 00	 call	 fabs
  002cf	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@3ff0000000000000
  002d7	7a 15		 jp	 SHORT $LN16@math_pow
  002d9	75 13		 jne	 SHORT $LN16@math_pow

; 1814 :                 r = 1.;

  002db	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@3ff0000000000000
  002e3	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR r$[rsp], xmm0
  002e9	e9 96 00 00 00	 jmp	 $LN15@math_pow
$LN16@math_pow:

; 1815 :             else if (y > 0. && fabs(x) > 1.0)

  002ee	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  002f4	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  002fc	76 23		 jbe	 SHORT $LN14@math_pow
  002fe	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00304	e8 00 00 00 00	 call	 fabs
  00309	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  00311	76 0e		 jbe	 SHORT $LN14@math_pow

; 1816 :                 r = y;

  00313	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  00319	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR r$[rsp], xmm0
  0031f	eb 63		 jmp	 SHORT $LN13@math_pow
$LN14@math_pow:

; 1817 :             else if (y < 0. && fabs(x) < 1.0) {

  00321	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00325	66 0f 2f 44 24
	30		 comisd	 xmm0, QWORD PTR y$[rsp]
  0032b	76 4d		 jbe	 SHORT $LN12@math_pow
  0032d	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00333	e8 00 00 00 00	 call	 fabs
  00338	f2 0f 10 0d 00
	00 00 00	 movsdx	 xmm1, QWORD PTR __real@3ff0000000000000
  00340	66 0f 2f c8	 comisd	 xmm1, xmm0
  00344	76 34		 jbe	 SHORT $LN12@math_pow

; 1818 :                 r = -y; /* result is +inf */

  00346	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR y$[rsp]
  0034c	66 0f 57 05 00
	00 00 00	 xorpd	 xmm0, QWORD PTR __mask@@NegDouble@
  00354	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR r$[rsp], xmm0

; 1819 :                 if (x == 0.) /* 0**-inf: divide-by-zero */

  0035a	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00360	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00368	7a 0e		 jp	 SHORT $LN11@math_pow
  0036a	75 0c		 jne	 SHORT $LN11@math_pow

; 1820 :                     errno = EDOM;

  0036c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00372	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H
$LN11@math_pow:

; 1821 :             }
; 1822 :             else

  00378	eb 0a		 jmp	 SHORT $LN10@math_pow
$LN12@math_pow:

; 1823 :                 r = 0.;

  0037a	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0037e	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR r$[rsp], xmm0
$LN10@math_pow:
$LN13@math_pow:
$LN15@math_pow:
$LN17@math_pow:
$LN18@math_pow:
$LN24@math_pow:
$LN26@math_pow:

; 1824 :         }
; 1825 :     }
; 1826 :     else {

  00384	e9 9d 00 00 00	 jmp	 $LN9@math_pow
$LN29@math_pow:

; 1827 :         /* let libm handle finite**finite */
; 1828 :         errno = 0;

  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0038f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1829 :         PyFPE_START_PROTECT("in math_pow", return 0);
; 1830 :         r = pow(x, y);

  00395	f2 0f 10 4c 24
	30		 movsdx	 xmm1, QWORD PTR y$[rsp]
  0039b	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  003a1	e8 00 00 00 00	 call	 pow
  003a6	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR r$[rsp], xmm0

; 1831 :         PyFPE_END_PROTECT(r);
; 1832 :         /* a NaN result should arise only from (-ve)**(finite
; 1833 :            non-integer); in this case we want to raise ValueError. */
; 1834 :         if (!Py_IS_FINITE(r)) {

  003ac	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR r$[rsp]
  003b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  003b8	85 c0		 test	 eax, eax
  003ba	75 6a		 jne	 SHORT $LN8@math_pow

; 1835 :             if (Py_IS_NAN(r)) {

  003bc	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR r$[rsp]
  003c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  003c8	85 c0		 test	 eax, eax
  003ca	74 0e		 je	 SHORT $LN7@math_pow

; 1836 :                 errno = EDOM;

  003cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003d2	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H
  003d8	eb 4c		 jmp	 SHORT $LN6@math_pow
$LN7@math_pow:

; 1837 :             }
; 1838 :             /*
; 1839 :                an infinite result here arises either from:
; 1840 :                (A) (+/-0.)**negative (-> divide-by-zero)
; 1841 :                (B) overflow of x**y with x and y finite
; 1842 :             */
; 1843 :             else if (Py_IS_INFINITY(r)) {

  003da	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR r$[rsp]
  003e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  003e6	85 c0		 test	 eax, eax
  003e8	75 3c		 jne	 SHORT $LN5@math_pow
  003ea	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR r$[rsp]
  003f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  003f6	85 c0		 test	 eax, eax
  003f8	75 2c		 jne	 SHORT $LN5@math_pow

; 1844 :                 if (x == 0.)

  003fa	f2 0f 10 44 24
	38		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00400	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  00408	7a 10		 jp	 SHORT $LN4@math_pow
  0040a	75 0e		 jne	 SHORT $LN4@math_pow

; 1845 :                     errno = EDOM;

  0040c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00412	c7 00 21 00 00
	00		 mov	 DWORD PTR [rax], 33	; 00000021H

; 1846 :                 else

  00418	eb 0c		 jmp	 SHORT $LN3@math_pow
$LN4@math_pow:

; 1847 :                     errno = ERANGE;

  0041a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00420	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
$LN3@math_pow:
$LN5@math_pow:
$LN6@math_pow:
$LN8@math_pow:
$LN9@math_pow:

; 1848 :             }
; 1849 :         }
; 1850 :     }
; 1851 : 
; 1852 :     if (errno && is_error(r))

  00426	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0042c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0042f	74 15		 je	 SHORT $LN2@math_pow
  00431	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR r$[rsp]
  00437	e8 00 00 00 00	 call	 is_error
  0043c	85 c0		 test	 eax, eax
  0043e	74 06		 je	 SHORT $LN2@math_pow

; 1853 :         return NULL;

  00440	33 c0		 xor	 eax, eax
  00442	eb 0d		 jmp	 SHORT $LN33@math_pow

; 1854 :     else

  00444	eb 0b		 jmp	 SHORT $LN1@math_pow
$LN2@math_pow:

; 1855 :         return PyFloat_FromDouble(r);

  00446	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR r$[rsp]
  0044c	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN1@math_pow:
$LN33@math_pow:

; 1856 : }

  00451	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00458	c3		 ret	 0
math_pow ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_degrees DD imagerel math_degrees
	DD	imagerel math_degrees+86
	DD	imagerel $unwind$math_degrees
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_degrees DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_degrees
_TEXT	SEGMENT
x$ = 32
self$ = 64
arg$ = 72
math_degrees PROC					; COMDAT

; 1866 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1867 :     double x = PyFloat_AsDouble(arg);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00013	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00018	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1868 :     if (x == -1.0 && PyErr_Occurred())

  0001e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00024	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0002c	7a 10		 jp	 SHORT $LN1@math_degre
  0002e	75 0e		 jne	 SHORT $LN1@math_degre
  00030	e8 00 00 00 00	 call	 PyErr_Occurred
  00035	48 85 c0	 test	 rax, rax
  00038	74 04		 je	 SHORT $LN1@math_degre

; 1869 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 13		 jmp	 SHORT $LN2@math_degre
$LN1@math_degre:

; 1870 :     return PyFloat_FromDouble(x * radToDeg);

  0003e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00044	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR radToDeg
  0004c	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN2@math_degre:

; 1871 : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
math_degrees ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_radians DD imagerel math_radians
	DD	imagerel math_radians+86
	DD	imagerel $unwind$math_radians
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_radians DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_radians
_TEXT	SEGMENT
x$ = 32
self$ = 64
arg$ = 72
math_radians PROC					; COMDAT

; 1879 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1880 :     double x = PyFloat_AsDouble(arg);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00013	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00018	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1881 :     if (x == -1.0 && PyErr_Occurred())

  0001e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00024	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0002c	7a 10		 jp	 SHORT $LN1@math_radia
  0002e	75 0e		 jne	 SHORT $LN1@math_radia
  00030	e8 00 00 00 00	 call	 PyErr_Occurred
  00035	48 85 c0	 test	 rax, rax
  00038	74 04		 je	 SHORT $LN1@math_radia

; 1882 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 13		 jmp	 SHORT $LN2@math_radia
$LN1@math_radia:

; 1883 :     return PyFloat_FromDouble(x * degToRad);

  0003e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00044	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR degToRad
  0004c	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN2@math_radia:

; 1884 : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
math_radians ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_isfinite DD imagerel math_isfinite
	DD	imagerel math_isfinite+86
	DD	imagerel $unwind$math_isfinite
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_isfinite DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_isfinite
_TEXT	SEGMENT
x$ = 32
self$ = 64
arg$ = 72
math_isfinite PROC					; COMDAT

; 1892 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1893 :     double x = PyFloat_AsDouble(arg);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00013	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00018	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1894 :     if (x == -1.0 && PyErr_Occurred())

  0001e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00024	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0002c	7a 10		 jp	 SHORT $LN1@math_isfin
  0002e	75 0e		 jne	 SHORT $LN1@math_isfin
  00030	e8 00 00 00 00	 call	 PyErr_Occurred
  00035	48 85 c0	 test	 rax, rax
  00038	74 04		 je	 SHORT $LN1@math_isfin

; 1895 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 13		 jmp	 SHORT $LN2@math_isfin
$LN1@math_isfin:

; 1896 :     return PyBool_FromLong((long)Py_IS_FINITE(x));

  0003e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0004a	8b c8		 mov	 ecx, eax
  0004c	e8 00 00 00 00	 call	 PyBool_FromLong
$LN2@math_isfin:

; 1897 : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
math_isfinite ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_isnan DD imagerel math_isnan
	DD	imagerel math_isnan+86
	DD	imagerel $unwind$math_isnan
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_isnan DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_isnan
_TEXT	SEGMENT
x$ = 32
self$ = 64
arg$ = 72
math_isnan PROC						; COMDAT

; 1905 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1906 :     double x = PyFloat_AsDouble(arg);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00013	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00018	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1907 :     if (x == -1.0 && PyErr_Occurred())

  0001e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00024	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0002c	7a 10		 jp	 SHORT $LN1@math_isnan
  0002e	75 0e		 jne	 SHORT $LN1@math_isnan
  00030	e8 00 00 00 00	 call	 PyErr_Occurred
  00035	48 85 c0	 test	 rax, rax
  00038	74 04		 je	 SHORT $LN1@math_isnan

; 1908 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 13		 jmp	 SHORT $LN2@math_isnan
$LN1@math_isnan:

; 1909 :     return PyBool_FromLong((long)Py_IS_NAN(x));

  0003e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0004a	8b c8		 mov	 ecx, eax
  0004c	e8 00 00 00 00	 call	 PyBool_FromLong
$LN2@math_isnan:

; 1910 : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
math_isnan ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$math_isinf DD imagerel math_isinf
	DD	imagerel math_isinf+126
	DD	imagerel $unwind$math_isinf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$math_isinf DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT math_isinf
_TEXT	SEGMENT
x$ = 32
tv76 = 40
self$ = 64
arg$ = 72
math_isinf PROC						; COMDAT

; 1918 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1919 :     double x = PyFloat_AsDouble(arg);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00013	e8 00 00 00 00	 call	 PyFloat_AsDouble
  00018	f2 0f 11 44 24
	20		 movsdx	 QWORD PTR x$[rsp], xmm0

; 1920 :     if (x == -1.0 && PyErr_Occurred())

  0001e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00024	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  0002c	7a 10		 jp	 SHORT $LN1@math_isinf
  0002e	75 0e		 jne	 SHORT $LN1@math_isinf
  00030	e8 00 00 00 00	 call	 PyErr_Occurred
  00035	48 85 c0	 test	 rax, rax
  00038	74 04		 je	 SHORT $LN1@math_isinf

; 1921 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 3b		 jmp	 SHORT $LN2@math_isinf
$LN1@math_isinf:

; 1922 :     return PyBool_FromLong((long)Py_IS_INFINITY(x));

  0003e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__finite
  0004a	85 c0		 test	 eax, eax
  0004c	75 1a		 jne	 SHORT $LN4@math_isinf
  0004e	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__isnan
  0005a	85 c0		 test	 eax, eax
  0005c	75 0a		 jne	 SHORT $LN4@math_isinf
  0005e	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00066	eb 08		 jmp	 SHORT $LN5@math_isinf
$LN4@math_isinf:
  00068	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN5@math_isinf:
  00070	8b 4c 24 28	 mov	 ecx, DWORD PTR tv76[rsp]
  00074	e8 00 00 00 00	 call	 PyBool_FromLong
$LN2@math_isinf:

; 1923 : }

  00079	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007d	c3		 ret	 0
math_isinf ENDP
_TEXT	ENDS
PUBLIC	??_C@_01KGKMHCOC@e?$AA@				; `string'
PUBLIC	__real@4005bf0a8b145769
PUBLIC	??_C@_02OAHAJOFD@pi?$AA@			; `string'
PUBLIC	PyInit_math
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_math DD imagerel $LN4
	DD	imagerel $LN4+112
	DD	imagerel $unwind$PyInit_math
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_math DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_01KGKMHCOC@e?$AA@
CONST	SEGMENT
??_C@_01KGKMHCOC@e?$AA@ DB 'e', 00H			; `string'
CONST	ENDS
;	COMDAT __real@4005bf0a8b145769
CONST	SEGMENT
__real@4005bf0a8b145769 DQ 04005bf0a8b145769r	; 2.71828
CONST	ENDS
;	COMDAT ??_C@_02OAHAJOFD@pi?$AA@
CONST	SEGMENT
??_C@_02OAHAJOFD@pi?$AA@ DB 'pi', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit_math
_TEXT	SEGMENT
m$ = 32
PyInit_math PROC					; COMDAT

; 1995 : {

$LN4:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1996 :     PyObject *m;
; 1997 : 
; 1998 :     m = PyModule_Create(&mathmodule);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mathmodule
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00015	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1999 :     if (m == NULL)

  0001a	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00020	75 02		 jne	 SHORT $LN1@PyInit_mat

; 2000 :         goto finally;

  00022	eb 42		 jmp	 SHORT $finally$21444
$LN1@PyInit_mat:

; 2001 : 
; 2002 :     PyModule_AddObject(m, "pi", PyFloat_FromDouble(Py_MATH_PI));

  00024	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@400921fb54442d18
  0002c	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00031	4c 8b c0	 mov	 r8, rax
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02OAHAJOFD@pi?$AA@
  0003b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  00040	e8 00 00 00 00	 call	 PyModule_AddObject

; 2003 :     PyModule_AddObject(m, "e", PyFloat_FromDouble(Py_MATH_E));

  00045	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@4005bf0a8b145769
  0004d	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00052	4c 8b c0	 mov	 r8, rax
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KGKMHCOC@e?$AA@
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR m$[rsp]
  00061	e8 00 00 00 00	 call	 PyModule_AddObject
$finally$21444:

; 2004 : 
; 2005 :     finally:
; 2006 :     return m;

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]

; 2007 : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
PyInit_math ENDP
_TEXT	ENDS
END
