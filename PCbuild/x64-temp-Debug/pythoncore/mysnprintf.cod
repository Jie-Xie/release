; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	PyOS_vsnprintf
PUBLIC	PyOS_snprintf
;	COMDAT pdata
; File c:\src\pyparallel\python\mysnprintf.c
pdata	SEGMENT
$pdata$PyOS_snprintf DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$PyOS_snprintf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_snprintf DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyOS_snprintf
_TEXT	SEGMENT
rc$ = 32
va$ = 40
str$ = 64
size$ = 72
format$ = 80
PyOS_snprintf PROC					; COMDAT

; 42   : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 43   :     int rc;
; 44   :     va_list va;
; 45   : 
; 46   :     va_start(va, format);

  00018	48 8d 44 24 58	 lea	 rax, QWORD PTR format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR va$[rsp], rax

; 47   :     rc = PyOS_vsnprintf(str, size, format, va);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR va$[rsp]
  00027	4c 8b 44 24 50	 mov	 r8, QWORD PTR format$[rsp]
  0002c	48 8b 54 24 48	 mov	 rdx, QWORD PTR size$[rsp]
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  00036	e8 00 00 00 00	 call	 PyOS_vsnprintf
  0003b	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 48   :     va_end(va);

  0003f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 49   :     return rc;

  00048	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 50   : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
PyOS_snprintf ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BO@MLMCMBKN@?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BC@PPAEDHAP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@MFCLPIBM@?$AAs?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@LDNPIIIK@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAm?$AAy?$AAs?$AAn?$AAp?$AAr?$AAi?$AAn?$AAt?$AAf?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	__imp__vsnprintf:PROC
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_vsnprintf DD imagerel $LN8
	DD	imagerel $LN8+220
	DD	imagerel $unwind$PyOS_vsnprintf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_vsnprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT ??_C@_1BO@MLMCMBKN@?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MLMCMBKN@?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'f'
	DB	00H, 'o', 00H, 'r', 00H, 'm', 00H, 'a', 00H, 't', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@PPAEDHAP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@PPAEDHAP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@MFCLPIBM@?$AAs?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@MFCLPIBM@?$AAs?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'r', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@LDNPIIIK@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAm?$AAy?$AAs?$AAn?$AAp?$AAr?$AAi?$AAn?$AAt?$AAf?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@LDNPIIIK@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAm?$AAy?$AAs?$AAn?$AAp?$AAr?$AAi?$AAn?$AAt?$AAf?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'y', 00H, 't', 00H, 'h', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'm', 00H, 'y', 00H, 's', 00H, 'n'
	DB	00H, 'p', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'f', 00H
	DB	'.', 00H, 'c', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyOS_vsnprintf
_TEXT	SEGMENT
len$ = 32
str$ = 64
size$ = 72
format$ = 80
va$ = 88
PyOS_vsnprintf PROC					; COMDAT

; 54   : {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 55   :     int len;  /* # bytes written, excluding \0 */
; 56   : #ifdef HAVE_SNPRINTF
; 57   : #define _PyOS_vsnprintf_EXTRA_SPACE 1
; 58   : #else
; 59   : #define _PyOS_vsnprintf_EXTRA_SPACE 512
; 60   :     char *buffer;
; 61   : #endif
; 62   :     assert(str != NULL);

  00018	48 83 7c 24 40
	00		 cmp	 QWORD PTR str$[rsp], 0
  0001e	75 1c		 jne	 SHORT $LN5@PyOS_vsnpr
  00020	41 b8 3e 00 00
	00		 mov	 r8d, 62			; 0000003eH
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@LDNPIIIK@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAm?$AAy?$AAs?$AAn?$AAp?$AAr?$AAi?$AAn?$AAt?$AAf?$AA?4?$AAc?$AA?$AA@
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@MFCLPIBM@?$AAs?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003a	33 c0		 xor	 eax, eax
$LN5@PyOS_vsnpr:

; 63   :     assert(size > 0);

  0003c	48 83 7c 24 48
	00		 cmp	 QWORD PTR size$[rsp], 0
  00042	77 1c		 ja	 SHORT $LN6@PyOS_vsnpr
  00044	41 b8 3f 00 00
	00		 mov	 r8d, 63			; 0000003fH
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@LDNPIIIK@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAm?$AAy?$AAs?$AAn?$AAp?$AAr?$AAi?$AAn?$AAt?$AAf?$AA?4?$AAc?$AA?$AA@
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@PPAEDHAP@?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005e	33 c0		 xor	 eax, eax
$LN6@PyOS_vsnpr:

; 64   :     assert(format != NULL);

  00060	48 83 7c 24 50
	00		 cmp	 QWORD PTR format$[rsp], 0
  00066	75 1c		 jne	 SHORT $LN7@PyOS_vsnpr
  00068	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CO@LDNPIIIK@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAm?$AAy?$AAs?$AAn?$AAp?$AAr?$AAi?$AAn?$AAt?$AAf?$AA?4?$AAc?$AA?$AA@
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@MLMCMBKN@?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00082	33 c0		 xor	 eax, eax
$LN7@PyOS_vsnpr:

; 65   :     /* We take a size_t as input but return an int.  Sanity check
; 66   :      * our input so that it won't cause an overflow in the
; 67   :      * vsnprintf return value or the buffer malloc size.  */
; 68   :     if (size > INT_MAX - _PyOS_vsnprintf_EXTRA_SPACE) {

  00084	48 81 7c 24 48
	fe ff ff 7f	 cmp	 QWORD PTR size$[rsp], 2147483646 ; 7ffffffeH
  0008d	76 0a		 jbe	 SHORT $LN2@PyOS_vsnpr

; 69   :         len = -666;

  0008f	c7 44 24 20 66
	fd ff ff	 mov	 DWORD PTR len$[rsp], -666 ; fffffffffffffd66H

; 70   :         goto Done;

  00097	eb 1e		 jmp	 SHORT $Done$20319
$LN2@PyOS_vsnpr:

; 71   :     }
; 72   : 
; 73   : #ifdef HAVE_SNPRINTF
; 74   :     len = vsnprintf(str, size, format, va);

  00099	4c 8b 4c 24 58	 mov	 r9, QWORD PTR va$[rsp]
  0009e	4c 8b 44 24 50	 mov	 r8, QWORD PTR format$[rsp]
  000a3	48 8b 54 24 48	 mov	 rdx, QWORD PTR size$[rsp]
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__vsnprintf
  000b3	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$Done$20319:

; 75   : #else
; 76   :     /* Emulate it. */
; 77   :     buffer = PyMem_MALLOC(size + _PyOS_vsnprintf_EXTRA_SPACE);
; 78   :     if (buffer == NULL) {
; 79   :         len = -666;
; 80   :         goto Done;
; 81   :     }
; 82   : 
; 83   :     len = vsprintf(buffer, format, va);
; 84   :     if (len < 0)
; 85   :         /* ignore the error */;
; 86   : 
; 87   :     else if ((size_t)len >= size + _PyOS_vsnprintf_EXTRA_SPACE)
; 88   :         Py_FatalError("Buffer overflow in PyOS_snprintf/PyOS_vsnprintf");
; 89   : 
; 90   :     else {
; 91   :         const size_t to_copy = (size_t)len < size ?
; 92   :                                 (size_t)len : size - 1;
; 93   :         assert(to_copy < size);
; 94   :         memcpy(str, buffer, to_copy);
; 95   :         str[to_copy] = '\0';
; 96   :     }
; 97   :     PyMem_FREE(buffer);
; 98   : #endif
; 99   : Done:
; 100  :     if (size > 0)

  000b7	48 83 7c 24 48
	00		 cmp	 QWORD PTR size$[rsp], 0
  000bd	76 14		 jbe	 SHORT $LN1@PyOS_vsnpr

; 101  :         str[size-1] = '\0';

  000bf	48 8b 44 24 48	 mov	 rax, QWORD PTR size$[rsp]
  000c4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR str$[rsp]
  000c9	48 03 c8	 add	 rcx, rax
  000cc	48 8b c1	 mov	 rax, rcx
  000cf	c6 40 ff 00	 mov	 BYTE PTR [rax-1], 0
$LN1@PyOS_vsnpr:

; 102  :     return len;

  000d3	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]

; 103  : #undef _PyOS_vsnprintf_EXTRA_SPACE
; 104  : }

  000d7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000db	c3		 ret	 0
PyOS_vsnprintf ENDP
_TEXT	ENDS
END
