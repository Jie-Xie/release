; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05HIFJDKLD@array?$AA@			; `string'
PUBLIC	??_C@_0CF@GMIJNGPM@Internal?4?5Used?5for?5pickling?5supp@ ; `string'
PUBLIC	??_C@_0O@OPHKEACL@arrayiterator?$AA@		; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_0M@DCMOJOBC@array?4array?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0L@HOGGIPGN@__sizeof__?$AA@		; `string'
PUBLIC	??_C@_09JKEMBMBG@tounicode?$AA@			; `string'
PUBLIC	??_C@_07NAJELLCK@tobytes?$AA@			; `string'
PUBLIC	??_C@_08FNIIFOJC@tostring?$AA@			; `string'
PUBLIC	??_C@_06IEBOCBAI@tolist?$AA@			; `string'
PUBLIC	??_C@_06IKANPOPE@tofile?$AA@			; `string'
PUBLIC	??_C@_07KOIEOCCE@reverse?$AA@			; `string'
PUBLIC	??_C@_06LEMKAMD@remove?$AA@			; `string'
PUBLIC	??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@		; `string'
PUBLIC	??_C@_03NJDAHFJE@pop?$AA@			; `string'
PUBLIC	??_C@_06OAOPNKHP@insert?$AA@			; `string'
PUBLIC	??_C@_05FKHKFDID@index?$AA@			; `string'
PUBLIC	??_C@_0M@JCIKMCEM@fromunicode?$AA@		; `string'
PUBLIC	??_C@_09OCNOKPAF@frombytes?$AA@			; `string'
PUBLIC	??_C@_0L@PGGLCJNP@fromstring?$AA@		; `string'
PUBLIC	??_C@_08BGGGONCE@fromlist?$AA@			; `string'
PUBLIC	??_C@_08BIHFDCNI@fromfile?$AA@			; `string'
PUBLIC	??_C@_06BPBOMFNI@extend?$AA@			; `string'
PUBLIC	??_C@_0N@LCDCNIJ@__deepcopy__?$AA@		; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_08MOMBEIKE@__copy__?$AA@			; `string'
PUBLIC	??_C@_08LGNCHIMC@byteswap?$AA@			; `string'
PUBLIC	??_C@_0M@MDHGDJKG@buffer_info?$AA@		; `string'
PUBLIC	??_C@_06PCICMFGG@append?$AA@			; `string'
PUBLIC	??_C@_0CG@DALNPKGO@the?5size?0?5in?5bytes?0?5of?5one?5array@ ; `string'
PUBLIC	??_C@_08BFHIGMPA@itemsize?$AA@			; `string'
PUBLIC	??_C@_0DA@HJNMFPLE@the?5typecode?5character?5used?5to?5c@ ; `string'
PUBLIC	??_C@_08FJHEKLCH@typecode?$AA@			; `string'
PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_0BF@FHDBJGA@_array_reconstructor?$AA@	; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	??_C@_01INIBCBCB@f?$AA@				; `string'
PUBLIC	??_C@_01BNIGIBBF@Q?$AA@				; `string'
PUBLIC	??_C@_01IIACKFLH@q?$AA@				; `string'
PUBLIC	??_C@_01OCOKONAJ@L?$AA@				; `string'
PUBLIC	??_C@_01HHGOMJKL@l?$AA@				; `string'
PUBLIC	??_C@_01JPJNBJEM@I?$AA@				; `string'
PUBLIC	??_C@_01KBJDNOO@i?$AA@				; `string'
PUBLIC	??_C@_01IGIGCIAN@H?$AA@				; `string'
PUBLIC	??_C@_01BDACAMKP@h?$AA@				; `string'
PUBLIC	??_C@_01OMGOGALD@u?$AA@				; `string'
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	??_C@_01OJONOECF@b?$AA@				; `string'
EXTRN	PyObject_SelfIter:PROC
EXTRN	_PyObject_DebugFree:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericGetAttr:PROC
_BSS	SEGMENT
?array_reconstructor@?1??array_reduce_ex@@9@9 DQ 01H DUP (?) ; `array_reduce_ex'::`2'::array_reconstructor
_BSS	ENDS
;	COMDAT ??_C@_05HIFJDKLD@array?$AA@
CONST	SEGMENT
??_C@_05HIFJDKLD@array?$AA@ DB 'array', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GMIJNGPM@Internal?4?5Used?5for?5pickling?5supp@
CONST	SEGMENT
??_C@_0CF@GMIJNGPM@Internal?4?5Used?5for?5pickling?5supp@ DB 'Internal. U'
	DB	'sed for pickling support.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OPHKEACL@arrayiterator?$AA@
CONST	SEGMENT
??_C@_0O@OPHKEACL@arrayiterator?$AA@ DB 'arrayiterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DCMOJOBC@array?4array?$AA@
CONST	SEGMENT
??_C@_0M@DCMOJOBC@array?4array?$AA@ DB 'array.array', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HOGGIPGN@__sizeof__?$AA@
CONST	SEGMENT
??_C@_0L@HOGGIPGN@__sizeof__?$AA@ DB '__sizeof__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JKEMBMBG@tounicode?$AA@
CONST	SEGMENT
??_C@_09JKEMBMBG@tounicode?$AA@ DB 'tounicode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NAJELLCK@tobytes?$AA@
CONST	SEGMENT
??_C@_07NAJELLCK@tobytes?$AA@ DB 'tobytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FNIIFOJC@tostring?$AA@
CONST	SEGMENT
??_C@_08FNIIFOJC@tostring?$AA@ DB 'tostring', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IEBOCBAI@tolist?$AA@
CONST	SEGMENT
??_C@_06IEBOCBAI@tolist?$AA@ DB 'tolist', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKANPOPE@tofile?$AA@
CONST	SEGMENT
??_C@_06IKANPOPE@tofile?$AA@ DB 'tofile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KOIEOCCE@reverse?$AA@
CONST	SEGMENT
??_C@_07KOIEOCCE@reverse?$AA@ DB 'reverse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEMKAMD@remove?$AA@
CONST	SEGMENT
??_C@_06LEMKAMD@remove?$AA@ DB 'remove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
CONST	SEGMENT
??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@ DB '__reduce_ex__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJDAHFJE@pop?$AA@
CONST	SEGMENT
??_C@_03NJDAHFJE@pop?$AA@ DB 'pop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06OAOPNKHP@insert?$AA@
CONST	SEGMENT
??_C@_06OAOPNKHP@insert?$AA@ DB 'insert', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FKHKFDID@index?$AA@
CONST	SEGMENT
??_C@_05FKHKFDID@index?$AA@ DB 'index', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JCIKMCEM@fromunicode?$AA@
CONST	SEGMENT
??_C@_0M@JCIKMCEM@fromunicode?$AA@ DB 'fromunicode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OCNOKPAF@frombytes?$AA@
CONST	SEGMENT
??_C@_09OCNOKPAF@frombytes?$AA@ DB 'frombytes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGGLCJNP@fromstring?$AA@
CONST	SEGMENT
??_C@_0L@PGGLCJNP@fromstring?$AA@ DB 'fromstring', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BGGGONCE@fromlist?$AA@
CONST	SEGMENT
??_C@_08BGGGONCE@fromlist?$AA@ DB 'fromlist', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BIHFDCNI@fromfile?$AA@
CONST	SEGMENT
??_C@_08BIHFDCNI@fromfile?$AA@ DB 'fromfile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPBOMFNI@extend?$AA@
CONST	SEGMENT
??_C@_06BPBOMFNI@extend?$AA@ DB 'extend', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCDCNIJ@__deepcopy__?$AA@
CONST	SEGMENT
??_C@_0N@LCDCNIJ@__deepcopy__?$AA@ DB '__deepcopy__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MOMBEIKE@__copy__?$AA@
CONST	SEGMENT
??_C@_08MOMBEIKE@__copy__?$AA@ DB '__copy__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08LGNCHIMC@byteswap?$AA@
CONST	SEGMENT
??_C@_08LGNCHIMC@byteswap?$AA@ DB 'byteswap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MDHGDJKG@buffer_info?$AA@
CONST	SEGMENT
??_C@_0M@MDHGDJKG@buffer_info?$AA@ DB 'buffer_info', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PCICMFGG@append?$AA@
CONST	SEGMENT
??_C@_06PCICMFGG@append?$AA@ DB 'append', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DALNPKGO@the?5size?0?5in?5bytes?0?5of?5one?5array@
CONST	SEGMENT
??_C@_0CG@DALNPKGO@the?5size?0?5in?5bytes?0?5of?5one?5array@ DB 'the size'
	DB	', in bytes, of one array item', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BFHIGMPA@itemsize?$AA@
CONST	SEGMENT
??_C@_08BFHIGMPA@itemsize?$AA@ DB 'itemsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@HJNMFPLE@the?5typecode?5character?5used?5to?5c@
CONST	SEGMENT
??_C@_0DA@HJNMFPLE@the?5typecode?5character?5used?5to?5c@ DB 'the typecod'
	DB	'e character used to create the array', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJHEKLCH@typecode?$AA@
CONST	SEGMENT
??_C@_08FJHEKLCH@typecode?$AA@ DB 'typecode', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FHDBJGA@_array_reconstructor?$AA@
CONST	SEGMENT
??_C@_0BF@FHDBJGA@_array_reconstructor?$AA@ DB '_array_reconstructor', 00H ; `string'
CONST	ENDS
CONST	SEGMENT
mformat_descriptors DQ 0000000000000001H
	DD	00H
	DD	00H
	DQ	0000000000000001H
	DD	01H
	DD	00H
	DQ	0000000000000002H
	DD	00H
	DD	00H
	DQ	0000000000000002H
	DD	00H
	DD	01H
	DQ	0000000000000002H
	DD	01H
	DD	00H
	DQ	0000000000000002H
	DD	01H
	DD	01H
	DQ	0000000000000004H
	DD	00H
	DD	00H
	DQ	0000000000000004H
	DD	00H
	DD	01H
	DQ	0000000000000004H
	DD	01H
	DD	00H
	DQ	0000000000000004H
	DD	01H
	DD	01H
	DQ	0000000000000008H
	DD	00H
	DD	00H
	DQ	0000000000000008H
	DD	00H
	DD	01H
	DQ	0000000000000008H
	DD	01H
	DD	00H
	DQ	0000000000000008H
	DD	01H
	DD	01H
	DQ	0000000000000004H
	DD	00H
	DD	00H
	DQ	0000000000000004H
	DD	00H
	DD	01H
	DQ	0000000000000008H
	DD	00H
	DD	00H
	DQ	0000000000000008H
	DD	00H
	DD	01H
	DQ	0000000000000004H
	DD	00H
	DD	00H
	DQ	0000000000000004H
	DD	00H
	DD	01H
	DQ	0000000000000008H
	DD	00H
	DD	00H
	DQ	0000000000000008H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___dict__@?1??array_reduce_ex@@9@9 DQ 0000000000000000H ; `array_reduce_ex'::`2'::PyId___dict__
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	0000000000000000H
?PyId__array_reconstructor@?1??array_reduce_ex@@9@9 DQ 0000000000000000H ; `array_reduce_ex'::`2'::PyId__array_reconstructor
	DQ	FLAT:??_C@_0BF@FHDBJGA@_array_reconstructor?$AA@
	DQ	0000000000000000H
?PyId_write@?2??array_tofile@@9@9 DQ 0000000000000000H	; `array_tofile'::`3'::PyId_write
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	0000000000000000H
?PyId_read@?1??array_fromfile@@9@9 DQ 0000000000000000H	; `array_fromfile'::`2'::PyId_read
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
descriptors DB	062H
	ORG $+3
	DD	01H
	DQ	FLAT:b_getitem
	DQ	FLAT:b_setitem
	DQ	FLAT:??_C@_01OJONOECF@b?$AA@
	DD	01H
	DD	01H
	DB	042H
	ORG $+3
	DD	01H
	DQ	FLAT:BB_getitem
	DQ	FLAT:BB_setitem
	DQ	FLAT:??_C@_01HMGJMAIH@B?$AA@
	DD	01H
	DD	00H
	DB	075H
	ORG $+3
	DD	02H
	DQ	FLAT:u_getitem
	DQ	FLAT:u_setitem
	DQ	FLAT:??_C@_01OMGOGALD@u?$AA@
	DD	00H
	DD	00H
	DB	068H
	ORG $+3
	DD	02H
	DQ	FLAT:h_getitem
	DQ	FLAT:h_setitem
	DQ	FLAT:??_C@_01BDACAMKP@h?$AA@
	DD	01H
	DD	01H
	DB	048H
	ORG $+3
	DD	02H
	DQ	FLAT:HH_getitem
	DQ	FLAT:HH_setitem
	DQ	FLAT:??_C@_01IGIGCIAN@H?$AA@
	DD	01H
	DD	00H
	DB	069H
	ORG $+3
	DD	04H
	DQ	FLAT:i_getitem
	DQ	FLAT:i_setitem
	DQ	FLAT:??_C@_01KBJDNOO@i?$AA@
	DD	01H
	DD	01H
	DB	049H
	ORG $+3
	DD	04H
	DQ	FLAT:II_getitem
	DQ	FLAT:II_setitem
	DQ	FLAT:??_C@_01JPJNBJEM@I?$AA@
	DD	01H
	DD	00H
	DB	06cH
	ORG $+3
	DD	04H
	DQ	FLAT:l_getitem
	DQ	FLAT:l_setitem
	DQ	FLAT:??_C@_01HHGOMJKL@l?$AA@
	DD	01H
	DD	01H
	DB	04cH
	ORG $+3
	DD	04H
	DQ	FLAT:LL_getitem
	DQ	FLAT:LL_setitem
	DQ	FLAT:??_C@_01OCOKONAJ@L?$AA@
	DD	01H
	DD	00H
	DB	071H
	ORG $+3
	DD	08H
	DQ	FLAT:q_getitem
	DQ	FLAT:q_setitem
	DQ	FLAT:??_C@_01IIACKFLH@q?$AA@
	DD	01H
	DD	01H
	DB	051H
	ORG $+3
	DD	08H
	DQ	FLAT:QQ_getitem
	DQ	FLAT:QQ_setitem
	DQ	FLAT:??_C@_01BNIGIBBF@Q?$AA@
	DD	01H
	DD	00H
	DB	066H
	ORG $+3
	DD	04H
	DQ	FLAT:f_getitem
	DQ	FLAT:f_setitem
	DQ	FLAT:??_C@_01INIBCBCB@f?$AA@
	DD	00H
	DD	00H
	DB	064H
	ORG $+3
	DD	08H
	DQ	FLAT:d_getitem
	DQ	FLAT:d_setitem
	DQ	FLAT:??_C@_01LPLHEDKD@d?$AA@
	DD	00H
	DD	00H
	DB	00H
	ORG $+3
	DD	00H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	00H
	DD	00H
copy_doc DB	'copy(array)', 0aH, 0aH, ' Return a copy of the array.', 00H
	ORG $+6
count_doc DB	'count(x)', 0aH, 0aH, 'Return number of occurrences of x '
	DB	'in the array.', 00H
	ORG $+6
index_doc DB	'index(x)', 0aH, 0aH, 'Return index of first occurrence o'
	DB	'f x in the array.', 00H
	ORG $+2
remove_doc DB	'remove(x)', 0aH, 0aH, 'Remove the first occurrence of x '
	DB	'in the array.', 00H
	ORG $+6
pop_doc	DB	'pop([i])', 0aH, 0aH, 'Return the i-th element and delete'
	DB	' it from the array. i defaults to -1.', 00H
	ORG $+6
append_doc DB	'append(x)', 0aH, 0aH, 'Append new value x to the end of '
	DB	'the array.', 00H
	ORG $+1
extend_doc DB	'extend(array or iterable)', 0aH, 0aH, ' Append items to '
	DB	'the end of the array.', 00H
	ORG $+6
reverse_doc DB	'reverse()', 0aH, 0aH, 'Reverse the order of the items in'
	DB	' the array.', 00H
insert_doc DB	'insert(i,x)', 0aH, 0aH, 'Insert a new item x into the ar'
	DB	'ray before position i.', 00H
	ORG $+5
fromlist_doc DB	'fromlist(list)', 0aH, 0aH, 'Append items to array from l'
	DB	'ist.', 00H
	ORG $+7
buffer_info_doc DB 'buffer_info() -> (address, length)', 0aH, 0aH, 'Retur'
	DB	'n a tuple (address, length) giving the current memory address'
	DB	' and', 0aH, 'the length in items of the buffer used to hold a'
	DB	'rray''s contents', 0aH, 'The length should be multiplied by t'
	DB	'he itemsize attribute to calculate', 0aH, 'the buffer length '
	DB	'in bytes.', 00H
	ORG $+2
byteswap_doc DB	'byteswap()', 0aH, 0aH, 'Byteswap all items of the array.'
	DB	'  If the items in the array are not 1, 2,', 0aH, '4, or 8 byt'
	DB	'es in size, RuntimeError is raised.', 00H
	ORG $+3
reduce_doc DB	'Return state information for pickling.', 00H
	ORG $+1
fromfile_doc DB	'fromfile(f, n)', 0aH, 0aH, 'Read n objects from the file'
	DB	' object f and append them to the end of the', 0aH, 'array.', 00H
	ORG $+1
tofile_doc DB	'tofile(f)', 0aH, 0aH, 'Write all items (as machine value'
	DB	's) to the file object f.', 00H
	ORG $+3
array_as_mapping DQ FLAT:array_length
	DQ	FLAT:array_subscr
	DQ	FLAT:array_ass_subscr
tolist_doc DB	'tolist() -> list', 0aH, 0aH, 'Convert array to an ordina'
	DB	'ry list with the same items.', 00H
	ORG $+7
fromstring_doc DB 'fromstring(string)', 0aH, 0aH, 'Appends items from the'
	DB	' string, interpreting it as an array of machine', 0aH, 'value'
	DB	's, as if it had been read from a file using the fromfile() me'
	DB	'thod).', 0aH, 0aH, 'This method is deprecated. Use frombytes '
	DB	'instead.', 00H
	ORG $+2
emptybuf DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
frombytes_doc DB 'frombytes(bytestring)', 0aH, 0aH, 'Appends items from t'
	DB	'he string, interpreting it as an array of machine', 0aH, 'val'
	DB	'ues, as if it had been read from a file using the fromfile() '
	DB	'method).', 00H
	ORG $+2
array_as_buffer DQ FLAT:array_buffer_getbuf
	DQ	FLAT:array_buffer_relbuf
setstate_doc DB	'Set state information for unpickling.', 00H
	ORG $+2
tobytes_doc DB	'tobytes() -> bytes', 0aH, 0aH, 'Convert the array to an '
	DB	'array of machine values and return the bytes', 0aH, 'represen'
	DB	'tation.', 00H
	ORG $+7
tostring_doc DB	'tostring() -> bytes', 0aH, 0aH, 'Convert the array to an'
	DB	' array of machine values and return the bytes', 0aH, 'represe'
	DB	'ntation.', 0aH, 0aH, 'This method is deprecated. Use tobytes '
	DB	'instead.', 00H
	ORG $+5
fromunicode_doc DB 'fromunicode(ustr)', 0aH, 0aH, 'Extends this array wit'
	DB	'h data from the unicode string ustr.', 0aH, 'The array must b'
	DB	'e a unicode type array; otherwise a ValueError', 0aH, 'is rai'
	DB	'sed.  Use array.frombytes(ustr.encode(...)) to', 0aH, 'append'
	DB	' Unicode data to an array of some other type.', 00H
	ORG $+10
tounicode_doc DB 'tounicode() -> unicode', 0aH, 0aH, 'Convert the array t'
	DB	'o a unicode string.  The array must be', 0aH, 'a unicode type'
	DB	' array; otherwise a ValueError is raised.  Use', 0aH, 'array.'
	DB	'tobytes().decode() to obtain a unicode string from', 0aH, 'an'
	DB	' array of some other type.', 00H
	ORG $+3
sizeof_doc DB	'__sizeof__() -> int', 0aH, 0aH, 'Size of the array in me'
	DB	'mory, in bytes.', 00H
	ORG $+12
array_getsets DQ FLAT:??_C@_08FJHEKLCH@typecode?$AA@
	DQ	FLAT:array_get_typecode
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0DA@HJNMFPLE@the?5typecode?5character?5used?5to?5c@
	ORG $+8
	DQ	FLAT:??_C@_08BFHIGMPA@itemsize?$AA@
	DQ	FLAT:array_get_itemsize
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CG@DALNPKGO@the?5size?0?5in?5bytes?0?5of?5one?5array@
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
array_methods DQ FLAT:??_C@_06PCICMFGG@append?$AA@
	DQ	FLAT:array_append
	DD	08H
	ORG $+4
	DQ	FLAT:append_doc
	DQ	FLAT:??_C@_0M@MDHGDJKG@buffer_info?$AA@
	DQ	FLAT:array_buffer_info
	DD	04H
	ORG $+4
	DQ	FLAT:buffer_info_doc
	DQ	FLAT:??_C@_08LGNCHIMC@byteswap?$AA@
	DQ	FLAT:array_byteswap
	DD	04H
	ORG $+4
	DQ	FLAT:byteswap_doc
	DQ	FLAT:??_C@_08MOMBEIKE@__copy__?$AA@
	DQ	FLAT:array_copy
	DD	04H
	ORG $+4
	DQ	FLAT:copy_doc
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	FLAT:array_count
	DD	08H
	ORG $+4
	DQ	FLAT:count_doc
	DQ	FLAT:??_C@_0N@LCDCNIJ@__deepcopy__?$AA@
	DQ	FLAT:array_copy
	DD	08H
	ORG $+4
	DQ	FLAT:copy_doc
	DQ	FLAT:??_C@_06BPBOMFNI@extend?$AA@
	DQ	FLAT:array_extend
	DD	08H
	ORG $+4
	DQ	FLAT:extend_doc
	DQ	FLAT:??_C@_08BIHFDCNI@fromfile?$AA@
	DQ	FLAT:array_fromfile
	DD	01H
	ORG $+4
	DQ	FLAT:fromfile_doc
	DQ	FLAT:??_C@_08BGGGONCE@fromlist?$AA@
	DQ	FLAT:array_fromlist
	DD	08H
	ORG $+4
	DQ	FLAT:fromlist_doc
	DQ	FLAT:??_C@_0L@PGGLCJNP@fromstring?$AA@
	DQ	FLAT:array_fromstring
	DD	01H
	ORG $+4
	DQ	FLAT:fromstring_doc
	DQ	FLAT:??_C@_09OCNOKPAF@frombytes?$AA@
	DQ	FLAT:array_frombytes
	DD	01H
	ORG $+4
	DQ	FLAT:frombytes_doc
	DQ	FLAT:??_C@_0M@JCIKMCEM@fromunicode?$AA@
	DQ	FLAT:array_fromunicode
	DD	01H
	ORG $+4
	DQ	FLAT:fromunicode_doc
	DQ	FLAT:??_C@_05FKHKFDID@index?$AA@
	DQ	FLAT:array_index
	DD	08H
	ORG $+4
	DQ	FLAT:index_doc
	DQ	FLAT:??_C@_06OAOPNKHP@insert?$AA@
	DQ	FLAT:array_insert
	DD	01H
	ORG $+4
	DQ	FLAT:insert_doc
	DQ	FLAT:??_C@_03NJDAHFJE@pop?$AA@
	DQ	FLAT:array_pop
	DD	01H
	ORG $+4
	DQ	FLAT:pop_doc
	DQ	FLAT:??_C@_0O@CFEDDKPG@__reduce_ex__?$AA@
	DQ	FLAT:array_reduce_ex
	DD	08H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_06LEMKAMD@remove?$AA@
	DQ	FLAT:array_remove
	DD	08H
	ORG $+4
	DQ	FLAT:remove_doc
	DQ	FLAT:??_C@_07KOIEOCCE@reverse?$AA@
	DQ	FLAT:array_reverse
	DD	04H
	ORG $+4
	DQ	FLAT:reverse_doc
	DQ	FLAT:??_C@_06IKANPOPE@tofile?$AA@
	DQ	FLAT:array_tofile
	DD	08H
	ORG $+4
	DQ	FLAT:tofile_doc
	DQ	FLAT:??_C@_06IEBOCBAI@tolist?$AA@
	DQ	FLAT:array_tolist
	DD	04H
	ORG $+4
	DQ	FLAT:tolist_doc
	DQ	FLAT:??_C@_08FNIIFOJC@tostring?$AA@
	DQ	FLAT:array_tostring
	DD	04H
	ORG $+4
	DQ	FLAT:tostring_doc
	DQ	FLAT:??_C@_07NAJELLCK@tobytes?$AA@
	DQ	FLAT:array_tobytes
	DD	04H
	ORG $+4
	DQ	FLAT:tobytes_doc
	DQ	FLAT:??_C@_09JKEMBMBG@tounicode?$AA@
	DQ	FLAT:array_tounicode
	DD	04H
	ORG $+4
	DQ	FLAT:tounicode_doc
	DQ	FLAT:??_C@_0L@HOGGIPGN@__sizeof__?$AA@
	DQ	FLAT:array_sizeof
	DD	04H
	ORG $+4
	DQ	FLAT:sizeof_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
array_as_sequence DQ FLAT:array_length
	DQ	FLAT:array_concat
	DQ	FLAT:array_repeat
	DQ	FLAT:array_item
	DQ	0000000000000000H
	DQ	FLAT:array_ass_item
	DQ	0000000000000000H
	DQ	FLAT:array_contains
	DQ	FLAT:array_inplace_concat
	DQ	FLAT:array_inplace_repeat
module_doc DB	'This module defines an object type which can efficiently'
	DB	' represent', 0aH, 'an array of basic values: characters, inte'
	DB	'gers, floating point', 0aH, 'numbers.  Arrays are sequence ty'
	DB	'pes and behave very much like lists,', 0aH, 'except that the '
	DB	'type of objects stored in them is constrained.  The', 0aH, 't'
	DB	'ype is specified at object creation time by using a type code'
	DB	', which', 0aH, 'is a single character.  The following type co'
	DB	'des are defined:', 0aH, 0aH, '    Type code   C Type         '
	DB	'    Minimum size in bytes ', 0aH, '    ''b''         signed i'
	DB	'nteger     1 ', 0aH, '    ''B''         unsigned integer   1 '
	DB	0aH, '    ''u''         Unicode character  2 (see note) ', 0aH
	DB	'    ''h''         signed integer     2 ', 0aH, '    ''H''    '
	DB	'     unsigned integer   2 ', 0aH, '    ''i''         signed i'
	DB	'nteger     2 ', 0aH, '    ''I''         unsigned integer   2 '
	DB	0aH, '    ''l''         signed integer     4 ', 0aH, '    ''L'''
	DB	'         unsigned integer   4 ', 0aH, '    ''q''         sign'
	DB	'ed integer     8 (see note) ', 0aH, '    ''Q''         unsign'
	DB	'ed integer   8 (see note) ', 0aH, '    ''f''         floating'
	DB	' point     4 ', 0aH, '    ''d''         floating point     8 '
	DB	0aH, 0aH, 'NOTE: The ''u'' typecode corresponds to Python''s u'
	DB	'nicode character. On ', 0aH, 'narrow builds this is 2-bytes o'
	DB	'n wide builds this is 4-bytes.', 0aH, 0aH, 'NOTE: The ''q'' a'
	DB	'nd ''Q'' type codes are only available if the platform ', 0aH
	DB	'C compiler used to build Python supports ''long long'', or, o'
	DB	'n Windows, ', 0aH, '''__int64''.', 0aH, 0aH, 'The constructor'
	DB	' is:', 0aH, 0aH, 'array(typecode [, initializer]) -- create a'
	DB	' new array', 0aH, 00H
	ORG $+13
arraytype_doc DB 'array(typecode [, initializer]) -> array', 0aH, 0aH, 'R'
	DB	'eturn a new array whose items are restricted by typecode, and'
	DB	0aH, 'initialized from the optional initializer value, which m'
	DB	'ust be a list,', 0aH, 'string or iterable over elements of th'
	DB	'e appropriate type.', 0aH, 0aH, 'Arrays represent basic value'
	DB	's and behave very much like lists, except', 0aH, 'the type of'
	DB	' objects stored in them is constrained.', 0aH, 0aH, 'Methods:'
	DB	0aH, 0aH, 'append() -- append a new item to the end of the arr'
	DB	'ay', 0aH, 'buffer_info() -- return information giving the cur'
	DB	'rent memory info', 0aH, 'byteswap() -- byteswap all the items'
	DB	' of the array', 0aH, 'count() -- return number of occurrences'
	DB	' of an object', 0aH, 'extend() -- extend array by appending m'
	DB	'ultiple elements from an iterable', 0aH, 'fromfile() -- read '
	DB	'items from a file object', 0aH, 'fromlist() -- append items f'
	DB	'rom the list', 0aH, 'frombytes() -- append items from the str'
	DB	'ing', 0aH, 'index() -- return index of first occurrence of an'
	DB	' object', 0aH, 'insert() -- insert a new item into the array '
	DB	'at a provided position', 0aH, 'pop() -- remove and return ite'
	DB	'm (default last)', 0aH, 'remove() -- remove first occurrence '
	DB	'of an object', 0aH, 'reverse() -- reverse the order of the it'
	DB	'ems in the array', 0aH, 'tofile() -- write all items to a fil'
	DB	'e object', 0aH, 'tolist() -- return the array converted to an'
	DB	' ordinary list', 0aH, 'tobytes() -- return the array converte'
	DB	'd to a string', 0aH, 0aH, 'Attributes:', 0aH, 0aH, 'typecode '
	DB	'-- the typecode character used to create the array', 0aH, 'it'
	DB	'emsize -- the length in bytes of one array item', 0aH, 00H
	ORG $+8
Arraytype DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0M@DCMOJOBC@array?4array?$AA@
	DQ	00000000000000a0H
	DQ	0000000000000000H
	DQ	FLAT:array_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:array_repr
	DQ	0000000000000000H
	DQ	FLAT:array_as_sequence
	DQ	FLAT:array_as_mapping
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	FLAT:array_as_buffer
	DD	040400H
	ORG $+4
	DQ	FLAT:arraytype_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:array_richcompare
	DQ	0000000000000088H
	DQ	FLAT:array_iter
	DQ	0000000000000000H
	DQ	FLAT:array_methods
	DQ	0000000000000000H
	DQ	FLAT:array_getsets
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:array_new
	DQ	FLAT:_PyObject_DebugFree
	ORG $+64
arrayiter_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:arrayiter_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:arrayiter_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
PyArrayIter_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@OPHKEACL@arrayiterator?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:arrayiter_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:arrayiter_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:arrayiter_next
	DQ	FLAT:arrayiter_methods
	ORG $+152
a_methods DQ	FLAT:??_C@_0BF@FHDBJGA@_array_reconstructor?$AA@
	DQ	FLAT:array_reconstructor
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CF@GMIJNGPM@Internal?4?5Used?5for?5pickling?5supp@
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
arraymodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_05HIFJDKLD@array?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:a_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01INIBCBCB@f?$AA@
CONST	SEGMENT
??_C@_01INIBCBCB@f?$AA@ DB 'f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BNIGIBBF@Q?$AA@
CONST	SEGMENT
??_C@_01BNIGIBBF@Q?$AA@ DB 'Q', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IIACKFLH@q?$AA@
CONST	SEGMENT
??_C@_01IIACKFLH@q?$AA@ DB 'q', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OCOKONAJ@L?$AA@
CONST	SEGMENT
??_C@_01OCOKONAJ@L?$AA@ DB 'L', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HHGOMJKL@l?$AA@
CONST	SEGMENT
??_C@_01HHGOMJKL@l?$AA@ DB 'l', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JPJNBJEM@I?$AA@
CONST	SEGMENT
??_C@_01JPJNBJEM@I?$AA@ DB 'I', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KBJDNOO@i?$AA@
CONST	SEGMENT
??_C@_01KBJDNOO@i?$AA@ DB 'i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IGIGCIAN@H?$AA@
CONST	SEGMENT
??_C@_01IGIGCIAN@H?$AA@ DB 'H', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BDACAMKP@h?$AA@
CONST	SEGMENT
??_C@_01BDACAMKP@h?$AA@ DB 'h', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OMGOGALD@u?$AA@
CONST	SEGMENT
??_C@_01OMGOGALD@u?$AA@ DB 'u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OJONOECF@b?$AA@
CONST	SEGMENT
??_C@_01OJONOECF@b?$AA@ DB 'b', 00H			; `string'
CONST	ENDS
EXTRN	PyLong_FromLong:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\arraymodule.c
pdata	SEGMENT
$pdata$b_getitem DD imagerel b_getitem
	DD	imagerel b_getitem+73
	DD	imagerel $unwind$b_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$b_getitem DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT b_getitem
_TEXT	SEGMENT
x$ = 32
ap$ = 64
i$ = 72
b_getitem PROC						; COMDAT

; 124  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 125  :     long x = ((char *)ap->ob_item)[i];

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00020	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 126  :     if (x >= 128)

  00024	81 7c 24 20 80
	00 00 00	 cmp	 DWORD PTR x$[rsp], 128	; 00000080H
  0002c	7c 0d		 jl	 SHORT $LN1@b_getitem

; 127  :         x -= 256;

  0002e	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00032	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  00037	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
$LN1@b_getitem:

; 128  :     return PyLong_FromLong(x);

  0003b	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  0003f	e8 00 00 00 00	 call	 PyLong_FromLong

; 129  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
b_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@LPIDPKAF@signed?5char?5is?5greater?5than?5maxi@ ; `string'
PUBLIC	??_C@_0CB@KFFPLEPD@signed?5char?5is?5less?5than?5minimum@ ; `string'
PUBLIC	??_C@_0BN@IIFFHIEL@h?$DLarray?5item?5must?5be?5integer?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	_PyArg_Parse_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$b_setitem DD imagerel b_setitem
	DD	imagerel b_setitem+165
	DD	imagerel $unwind$b_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$b_setitem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CE@LPIDPKAF@signed?5char?5is?5greater?5than?5maxi@
CONST	SEGMENT
??_C@_0CE@LPIDPKAF@signed?5char?5is?5greater?5than?5maxi@ DB 'signed char'
	DB	' is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KFFPLEPD@signed?5char?5is?5less?5than?5minimum@
CONST	SEGMENT
??_C@_0CB@KFFPLEPD@signed?5char?5is?5less?5than?5minimum@ DB 'signed char'
	DB	' is less than minimum', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IIFFHIEL@h?$DLarray?5item?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BN@IIFFHIEL@h?$DLarray?5item?5must?5be?5integer?$AA@ DB 'h;array i'
	DB	'tem must be integer', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT b_setitem
_TEXT	SEGMENT
x$ = 32
ap$ = 64
i$ = 72
v$ = 80
b_setitem PROC						; COMDAT

; 133  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 134  :     short x;
; 135  :     /* PyArg_Parse's 'b' formatter is for an unsigned char, therefore
; 136  :        must use the next size up that is signed ('h') and manually do
; 137  :        the overflow checking */
; 138  :     if (!PyArg_Parse(v, "h;array item must be integer", &x))

  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@IIFFHIEL@h?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 09		 jne	 SHORT $LN6@b_setitem

; 139  :         return -1;

  0002d	b8 ff ff ff ff	 mov	 eax, -1
  00032	eb 6c		 jmp	 SHORT $LN7@b_setitem
  00034	eb 4a		 jmp	 SHORT $LN5@b_setitem
$LN6@b_setitem:

; 140  :     else if (x < -128) {

  00036	0f bf 44 24 20	 movsx	 eax, WORD PTR x$[rsp]
  0003b	83 f8 80	 cmp	 eax, -128		; ffffffffffffff80H
  0003e	7d 1c		 jge	 SHORT $LN4@b_setitem

; 141  :         PyErr_SetString(PyExc_OverflowError,
; 142  :             "signed char is less than minimum");

  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@KFFPLEPD@signed?5char?5is?5less?5than?5minimum@
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0004e	e8 00 00 00 00	 call	 PyErr_SetString

; 143  :         return -1;

  00053	b8 ff ff ff ff	 mov	 eax, -1
  00058	eb 46		 jmp	 SHORT $LN7@b_setitem
  0005a	eb 24		 jmp	 SHORT $LN3@b_setitem
$LN4@b_setitem:

; 144  :     }
; 145  :     else if (x > 127) {

  0005c	0f bf 44 24 20	 movsx	 eax, WORD PTR x$[rsp]
  00061	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00064	7e 1a		 jle	 SHORT $LN2@b_setitem

; 146  :         PyErr_SetString(PyExc_OverflowError,
; 147  :             "signed char is greater than maximum");

  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@LPIDPKAF@signed?5char?5is?5greater?5than?5maxi@
  0006d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00074	e8 00 00 00 00	 call	 PyErr_SetString

; 148  :         return -1;

  00079	b8 ff ff ff ff	 mov	 eax, -1
  0007e	eb 20		 jmp	 SHORT $LN7@b_setitem
$LN2@b_setitem:
$LN3@b_setitem:
$LN5@b_setitem:

; 149  :     }
; 150  :     if (i >= 0)

  00080	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  00086	7c 16		 jl	 SHORT $LN1@b_setitem

; 151  :         ((char *)ap->ob_item)[i] = (char)x;

  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  0008d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00091	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  00096	0f b6 54 24 20	 movzx	 edx, BYTE PTR x$[rsp]
  0009b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
$LN1@b_setitem:

; 152  :     return 0;

  0009e	33 c0		 xor	 eax, eax
$LN7@b_setitem:

; 153  : }

  000a0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a4	c3		 ret	 0
b_setitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$BB_getitem DD imagerel BB_getitem
	DD	imagerel BB_getitem+50
	DD	imagerel $unwind$BB_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BB_getitem DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT BB_getitem
_TEXT	SEGMENT
x$ = 32
ap$ = 64
i$ = 72
BB_getitem PROC						; COMDAT

; 157  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 158  :     long x = ((unsigned char *)ap->ob_item)[i];

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00020	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 159  :     return PyLong_FromLong(x);

  00024	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00028	e8 00 00 00 00	 call	 PyLong_FromLong

; 160  : }

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	c3		 ret	 0
BB_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@OAIGAPKB@b?$DLarray?5item?5must?5be?5integer?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$BB_setitem DD imagerel BB_setitem
	DD	imagerel BB_setitem+89
	DD	imagerel $unwind$BB_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$BB_setitem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BN@OAIGAPKB@b?$DLarray?5item?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BN@OAIGAPKB@b?$DLarray?5item?5must?5be?5integer?$AA@ DB 'b;array i'
	DB	'tem must be integer', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT BB_setitem
_TEXT	SEGMENT
x$ = 32
ap$ = 64
i$ = 72
v$ = 80
BB_setitem PROC						; COMDAT

; 164  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 165  :     unsigned char x;
; 166  :     /* 'B' == unsigned char, maps to PyArg_Parse's 'b' formatter */
; 167  :     if (!PyArg_Parse(v, "b;array item must be integer", &x))

  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OAIGAPKB@b?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN2@BB_setitem

; 168  :         return -1;

  0002d	b8 ff ff ff ff	 mov	 eax, -1
  00032	eb 20		 jmp	 SHORT $LN3@BB_setitem
$LN2@BB_setitem:

; 169  :     if (i >= 0)

  00034	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  0003a	7c 16		 jl	 SHORT $LN1@BB_setitem

; 170  :         ((char *)ap->ob_item)[i] = x;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  00041	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0004a	0f b6 54 24 20	 movzx	 edx, BYTE PTR x$[rsp]
  0004f	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
$LN1@BB_setitem:

; 171  :     return 0;

  00052	33 c0		 xor	 eax, eax
$LN3@BB_setitem:

; 172  : }

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
BB_setitem ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromUnicode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$u_getitem DD imagerel u_getitem
	DD	imagerel u_getitem+50
	DD	imagerel $unwind$u_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$u_getitem DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT u_getitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
u_getitem PROC						; COMDAT

; 176  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 177  :     return PyUnicode_FromUnicode(&((Py_UNICODE *) ap->ob_item)[i], 1);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00020	ba 01 00 00 00	 mov	 edx, 1
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 PyUnicode_FromUnicode

; 178  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
u_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@JPMPNLNP@array?5item?5must?5be?5unicode?5chara@ ; `string'
PUBLIC	??_C@_0CI@MFMIOCHL@u?$CD?$DLarray?5item?5must?5be?5unicode?5ch@ ; `string'
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$u_setitem DD imagerel u_setitem
	DD	imagerel u_setitem+132
	DD	imagerel $unwind$u_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$u_setitem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CF@JPMPNLNP@array?5item?5must?5be?5unicode?5chara@
CONST	SEGMENT
??_C@_0CF@JPMPNLNP@array?5item?5must?5be?5unicode?5chara@ DB 'array item '
	DB	'must be unicode character', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MFMIOCHL@u?$CD?$DLarray?5item?5must?5be?5unicode?5ch@
CONST	SEGMENT
??_C@_0CI@MFMIOCHL@u?$CD?$DLarray?5item?5must?5be?5unicode?5ch@ DB 'u#;ar'
	DB	'ray item must be unicode character', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT u_setitem
_TEXT	SEGMENT
p$ = 32
len$ = 40
ap$ = 64
i$ = 72
v$ = 80
u_setitem PROC						; COMDAT

; 182  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 183  :     Py_UNICODE *p;
; 184  :     Py_ssize_t len;
; 185  : 
; 186  :     if (!PyArg_Parse(v, "u#;array item must be unicode character", &p, &len))

  00013	4c 8d 4c 24 28	 lea	 r9, QWORD PTR len$[rsp]
  00018	4c 8d 44 24 20	 lea	 r8, QWORD PTR p$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@MFMIOCHL@u?$CD?$DLarray?5item?5must?5be?5unicode?5ch@
  00024	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00029	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  0002e	85 c0		 test	 eax, eax
  00030	75 07		 jne	 SHORT $LN3@u_setitem

; 187  :         return -1;

  00032	b8 ff ff ff ff	 mov	 eax, -1
  00037	eb 46		 jmp	 SHORT $LN4@u_setitem
$LN3@u_setitem:

; 188  :     if (len != 1) {

  00039	48 83 7c 24 28
	01		 cmp	 QWORD PTR len$[rsp], 1
  0003f	74 1a		 je	 SHORT $LN2@u_setitem

; 189  :         PyErr_SetString(PyExc_TypeError,
; 190  :                         "array item must be unicode character");

  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@JPMPNLNP@array?5item?5must?5be?5unicode?5chara@
  00048	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0004f	e8 00 00 00 00	 call	 PyErr_SetString

; 191  :         return -1;

  00054	b8 ff ff ff ff	 mov	 eax, -1
  00059	eb 24		 jmp	 SHORT $LN4@u_setitem
$LN2@u_setitem:

; 192  :     }
; 193  :     if (i >= 0)

  0005b	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  00061	7c 1a		 jl	 SHORT $LN1@u_setitem

; 194  :         ((Py_UNICODE *)ap->ob_item)[i] = p[0];

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  00068	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0006c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  00071	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  00076	0f b7 12	 movzx	 edx, WORD PTR [rdx]
  00079	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
$LN1@u_setitem:

; 195  :     return 0;

  0007d	33 c0		 xor	 eax, eax
$LN4@u_setitem:

; 196  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
u_setitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$h_getitem DD imagerel h_getitem
	DD	imagerel h_getitem+44
	DD	imagerel $unwind$h_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$h_getitem DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT h_getitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
h_getitem PROC						; COMDAT

; 201  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 202  :     return PyLong_FromLong((long) ((short *)ap->ob_item)[i]);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	0f bf 04 48	 movsx	 eax, WORD PTR [rax+rcx*2]
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 PyLong_FromLong

; 203  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
h_getitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$h_setitem DD imagerel h_setitem
	DD	imagerel h_setitem+90
	DD	imagerel $unwind$h_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$h_setitem DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT h_setitem
_TEXT	SEGMENT
x$ = 32
ap$ = 64
i$ = 72
v$ = 80
h_setitem PROC						; COMDAT

; 208  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 209  :     short x;
; 210  :     /* 'h' == signed short, maps to PyArg_Parse's 'h' formatter */
; 211  :     if (!PyArg_Parse(v, "h;array item must be integer", &x))

  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@IIFFHIEL@h?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN2@h_setitem

; 212  :         return -1;

  0002d	b8 ff ff ff ff	 mov	 eax, -1
  00032	eb 21		 jmp	 SHORT $LN3@h_setitem
$LN2@h_setitem:

; 213  :     if (i >= 0)

  00034	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  0003a	7c 17		 jl	 SHORT $LN1@h_setitem

; 214  :                  ((short *)ap->ob_item)[i] = x;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  00041	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0004a	0f b7 54 24 20	 movzx	 edx, WORD PTR x$[rsp]
  0004f	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
$LN1@h_setitem:

; 215  :     return 0;

  00053	33 c0		 xor	 eax, eax
$LN3@h_setitem:

; 216  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
h_setitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$HH_getitem DD imagerel HH_getitem
	DD	imagerel HH_getitem+44
	DD	imagerel $unwind$HH_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HH_getitem DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT HH_getitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
HH_getitem PROC						; COMDAT

; 220  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 221  :     return PyLong_FromLong((long) ((unsigned short *)ap->ob_item)[i]);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00020	8b c8		 mov	 ecx, eax
  00022	e8 00 00 00 00	 call	 PyLong_FromLong

; 222  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
HH_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@FGIAJPNJ@unsigned?5short?5is?5greater?5than?5m@ ; `string'
PUBLIC	??_C@_0CE@KIHIKEPG@unsigned?5short?5is?5less?5than?5mini@ ; `string'
PUBLIC	??_C@_0BN@OLFCKBGP@i?$DLarray?5item?5must?5be?5integer?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$HH_setitem DD imagerel HH_setitem
	DD	imagerel HH_setitem+163
	DD	imagerel $unwind$HH_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$HH_setitem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CH@FGIAJPNJ@unsigned?5short?5is?5greater?5than?5m@
CONST	SEGMENT
??_C@_0CH@FGIAJPNJ@unsigned?5short?5is?5greater?5than?5m@ DB 'unsigned sh'
	DB	'ort is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KIHIKEPG@unsigned?5short?5is?5less?5than?5mini@
CONST	SEGMENT
??_C@_0CE@KIHIKEPG@unsigned?5short?5is?5less?5than?5mini@ DB 'unsigned sh'
	DB	'ort is less than minimum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OLFCKBGP@i?$DLarray?5item?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BN@OLFCKBGP@i?$DLarray?5item?5must?5be?5integer?$AA@ DB 'i;array i'
	DB	'tem must be integer', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT HH_setitem
_TEXT	SEGMENT
x$ = 32
ap$ = 64
i$ = 72
v$ = 80
HH_setitem PROC						; COMDAT

; 226  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 227  :     int x;
; 228  :     /* PyArg_Parse's 'h' formatter is for a signed short, therefore
; 229  :        must use the next size up and manually do the overflow checking */
; 230  :     if (!PyArg_Parse(v, "i;array item must be integer", &x))

  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OLFCKBGP@i?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 09		 jne	 SHORT $LN6@HH_setitem

; 231  :         return -1;

  0002d	b8 ff ff ff ff	 mov	 eax, -1
  00032	eb 6a		 jmp	 SHORT $LN7@HH_setitem
  00034	eb 47		 jmp	 SHORT $LN5@HH_setitem
$LN6@HH_setitem:

; 232  :     else if (x < 0) {

  00036	83 7c 24 20 00	 cmp	 DWORD PTR x$[rsp], 0
  0003b	7d 1c		 jge	 SHORT $LN4@HH_setitem

; 233  :         PyErr_SetString(PyExc_OverflowError,
; 234  :             "unsigned short is less than minimum");

  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KIHIKEPG@unsigned?5short?5is?5less?5than?5mini@
  00044	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0004b	e8 00 00 00 00	 call	 PyErr_SetString

; 235  :         return -1;

  00050	b8 ff ff ff ff	 mov	 eax, -1
  00055	eb 47		 jmp	 SHORT $LN7@HH_setitem
  00057	eb 24		 jmp	 SHORT $LN3@HH_setitem
$LN4@HH_setitem:

; 236  :     }
; 237  :     else if (x > USHRT_MAX) {

  00059	81 7c 24 20 ff
	ff 00 00	 cmp	 DWORD PTR x$[rsp], 65535 ; 0000ffffH
  00061	7e 1a		 jle	 SHORT $LN2@HH_setitem

; 238  :         PyErr_SetString(PyExc_OverflowError,
; 239  :             "unsigned short is greater than maximum");

  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@FGIAJPNJ@unsigned?5short?5is?5greater?5than?5m@
  0006a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00071	e8 00 00 00 00	 call	 PyErr_SetString

; 240  :         return -1;

  00076	b8 ff ff ff ff	 mov	 eax, -1
  0007b	eb 21		 jmp	 SHORT $LN7@HH_setitem
$LN2@HH_setitem:
$LN3@HH_setitem:
$LN5@HH_setitem:

; 241  :     }
; 242  :     if (i >= 0)

  0007d	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  00083	7c 17		 jl	 SHORT $LN1@HH_setitem

; 243  :         ((short *)ap->ob_item)[i] = (short)x;

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  0008a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0008e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  00093	0f b7 54 24 20	 movzx	 edx, WORD PTR x$[rsp]
  00098	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
$LN1@HH_setitem:

; 244  :     return 0;

  0009c	33 c0		 xor	 eax, eax
$LN7@HH_setitem:

; 245  : }

  0009e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a2	c3		 ret	 0
HH_setitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$i_getitem DD imagerel i_getitem
	DD	imagerel i_getitem+41
	DD	imagerel $unwind$i_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$i_getitem DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT i_getitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
i_getitem PROC						; COMDAT

; 249  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 250  :     return PyLong_FromLong((long) ((int *)ap->ob_item)[i]);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  0001f	e8 00 00 00 00	 call	 PyLong_FromLong

; 251  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
i_getitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$i_setitem DD imagerel i_setitem
	DD	imagerel i_setitem+88
	DD	imagerel $unwind$i_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$i_setitem DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT i_setitem
_TEXT	SEGMENT
x$ = 32
ap$ = 64
i$ = 72
v$ = 80
i_setitem PROC						; COMDAT

; 255  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 256  :     int x;
; 257  :     /* 'i' == signed int, maps to PyArg_Parse's 'i' formatter */
; 258  :     if (!PyArg_Parse(v, "i;array item must be integer", &x))

  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OLFCKBGP@i?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN2@i_setitem

; 259  :         return -1;

  0002d	b8 ff ff ff ff	 mov	 eax, -1
  00032	eb 1f		 jmp	 SHORT $LN3@i_setitem
$LN2@i_setitem:

; 260  :     if (i >= 0)

  00034	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  0003a	7c 15		 jl	 SHORT $LN1@i_setitem

; 261  :                  ((int *)ap->ob_item)[i] = x;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  00041	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0004a	8b 54 24 20	 mov	 edx, DWORD PTR x$[rsp]
  0004e	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx
$LN1@i_setitem:

; 262  :     return 0;

  00051	33 c0		 xor	 eax, eax
$LN3@i_setitem:

; 263  : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
i_setitem ENDP
_TEXT	ENDS
EXTRN	PyLong_FromUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$II_getitem DD imagerel II_getitem
	DD	imagerel II_getitem+41
	DD	imagerel $unwind$II_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$II_getitem DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT II_getitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
II_getitem PROC						; COMDAT

; 267  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 268  :     return PyLong_FromUnsignedLong(
; 269  :         (unsigned long) ((unsigned int *)ap->ob_item)[i]);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  0001f	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong

; 270  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
II_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@FJOCEHKO@unsigned?5int?5is?5greater?5than?5max@ ; `string'
PUBLIC	??_C@_0CC@EPGGIEKN@unsigned?5int?5is?5less?5than?5minimu@ ; `string'
PUBLIC	??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@ ; `string'
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$II_setitem DD imagerel II_setitem
	DD	imagerel II_setitem+229
	DD	imagerel $unwind$II_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$II_setitem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CF@FJOCEHKO@unsigned?5int?5is?5greater?5than?5max@
CONST	SEGMENT
??_C@_0CF@FJOCEHKO@unsigned?5int?5is?5greater?5than?5max@ DB 'unsigned in'
	DB	't is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@EPGGIEKN@unsigned?5int?5is?5less?5than?5minimu@
CONST	SEGMENT
??_C@_0CC@EPGGIEKN@unsigned?5int?5is?5less?5than?5minimu@ DB 'unsigned in'
	DB	't is less than minimum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@ DB 'l;array i'
	DB	'tem must be integer', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT II_setitem
_TEXT	SEGMENT
x$ = 32
y$20551 = 36
ap$ = 64
i$ = 72
v$ = 80
II_setitem PROC						; COMDAT

; 274  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 275  :     unsigned long x;
; 276  :     if (PyLong_Check(v)) {

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00027	85 c0		 test	 eax, eax
  00029	74 2b		 je	 SHORT $LN7@II_setitem@2

; 277  :         x = PyLong_AsUnsignedLong(v);

  0002b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  00035	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 278  :         if (x == (unsigned long) -1 && PyErr_Occurred())

  00039	83 7c 24 20 ff	 cmp	 DWORD PTR x$[rsp], -1	; ffffffffH
  0003e	75 14		 jne	 SHORT $LN6@II_setitem@2
  00040	e8 00 00 00 00	 call	 PyErr_Occurred
  00045	48 85 c0	 test	 rax, rax
  00048	74 0a		 je	 SHORT $LN6@II_setitem@2

; 279  :             return -1;

  0004a	b8 ff ff ff ff	 mov	 eax, -1
  0004f	e9 8c 00 00 00	 jmp	 $LN8@II_setitem@2
$LN6@II_setitem@2:

; 280  :     }
; 281  :     else {

  00054	eb 4a		 jmp	 SHORT $LN5@II_setitem@2
$LN7@II_setitem@2:

; 282  :         long y;
; 283  :         if (!PyArg_Parse(v, "l;array item must be integer", &y))

  00056	4c 8d 44 24 24	 lea	 r8, QWORD PTR y$20551[rsp]
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00067	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  0006c	85 c0		 test	 eax, eax
  0006e	75 07		 jne	 SHORT $LN4@II_setitem@2

; 284  :             return -1;

  00070	b8 ff ff ff ff	 mov	 eax, -1
  00075	eb 69		 jmp	 SHORT $LN8@II_setitem@2
$LN4@II_setitem@2:

; 285  :         if (y < 0) {

  00077	83 7c 24 24 00	 cmp	 DWORD PTR y$20551[rsp], 0
  0007c	7d 1a		 jge	 SHORT $LN3@II_setitem@2

; 286  :             PyErr_SetString(PyExc_OverflowError,
; 287  :                 "unsigned int is less than minimum");

  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@EPGGIEKN@unsigned?5int?5is?5less?5than?5minimu@
  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0008c	e8 00 00 00 00	 call	 PyErr_SetString

; 288  :             return -1;

  00091	b8 ff ff ff ff	 mov	 eax, -1
  00096	eb 48		 jmp	 SHORT $LN8@II_setitem@2
$LN3@II_setitem@2:

; 289  :         }
; 290  :         x = (unsigned long)y;

  00098	8b 44 24 24	 mov	 eax, DWORD PTR y$20551[rsp]
  0009c	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
$LN5@II_setitem@2:

; 291  : 
; 292  :     }
; 293  :     if (x > UINT_MAX) {

  000a0	83 7c 24 20 ff	 cmp	 DWORD PTR x$[rsp], -1	; ffffffffH
  000a5	76 1a		 jbe	 SHORT $LN2@II_setitem@2

; 294  :         PyErr_SetString(PyExc_OverflowError,
; 295  :             "unsigned int is greater than maximum");

  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@FJOCEHKO@unsigned?5int?5is?5greater?5than?5max@
  000ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000b5	e8 00 00 00 00	 call	 PyErr_SetString

; 296  :         return -1;

  000ba	b8 ff ff ff ff	 mov	 eax, -1
  000bf	eb 1f		 jmp	 SHORT $LN8@II_setitem@2
$LN2@II_setitem@2:

; 297  :     }
; 298  : 
; 299  :     if (i >= 0)

  000c1	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  000c7	7c 15		 jl	 SHORT $LN1@II_setitem@2

; 300  :         ((unsigned int *)ap->ob_item)[i] = (unsigned int)x;

  000c9	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  000ce	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000d2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  000d7	8b 54 24 20	 mov	 edx, DWORD PTR x$[rsp]
  000db	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx
$LN1@II_setitem@2:

; 301  :     return 0;

  000de	33 c0		 xor	 eax, eax
$LN8@II_setitem@2:

; 302  : }

  000e0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e4	c3		 ret	 0
II_setitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$l_getitem DD imagerel l_getitem
	DD	imagerel l_getitem+41
	DD	imagerel $unwind$l_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$l_getitem DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT l_getitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
l_getitem PROC						; COMDAT

; 306  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 307  :     return PyLong_FromLong(((long *)ap->ob_item)[i]);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  0001f	e8 00 00 00 00	 call	 PyLong_FromLong

; 308  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
l_getitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$l_setitem DD imagerel l_setitem
	DD	imagerel l_setitem+88
	DD	imagerel $unwind$l_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$l_setitem DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT l_setitem
_TEXT	SEGMENT
x$ = 32
ap$ = 64
i$ = 72
v$ = 80
l_setitem PROC						; COMDAT

; 312  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 313  :     long x;
; 314  :     if (!PyArg_Parse(v, "l;array item must be integer", &x))

  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN2@l_setitem

; 315  :         return -1;

  0002d	b8 ff ff ff ff	 mov	 eax, -1
  00032	eb 1f		 jmp	 SHORT $LN3@l_setitem
$LN2@l_setitem:

; 316  :     if (i >= 0)

  00034	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  0003a	7c 15		 jl	 SHORT $LN1@l_setitem

; 317  :                  ((long *)ap->ob_item)[i] = x;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  00041	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0004a	8b 54 24 20	 mov	 edx, DWORD PTR x$[rsp]
  0004e	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx
$LN1@l_setitem:

; 318  :     return 0;

  00051	33 c0		 xor	 eax, eax
$LN3@l_setitem:

; 319  : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
l_setitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$LL_getitem DD imagerel LL_getitem
	DD	imagerel LL_getitem+41
	DD	imagerel $unwind$LL_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LL_getitem DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT LL_getitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
LL_getitem PROC						; COMDAT

; 323  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 324  :     return PyLong_FromUnsignedLong(((unsigned long *)ap->ob_item)[i]);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	8b 0c 88	 mov	 ecx, DWORD PTR [rax+rcx*4]
  0001f	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong

; 325  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
LL_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@PFKJNNEL@unsigned?5long?5is?5greater?5than?5ma@ ; `string'
PUBLIC	??_C@_0CD@GGGBBGOM@unsigned?5long?5is?5less?5than?5minim@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$LL_setitem DD imagerel LL_setitem
	DD	imagerel LL_setitem+229
	DD	imagerel $unwind$LL_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$LL_setitem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CG@PFKJNNEL@unsigned?5long?5is?5greater?5than?5ma@
CONST	SEGMENT
??_C@_0CG@PFKJNNEL@unsigned?5long?5is?5greater?5than?5ma@ DB 'unsigned lo'
	DB	'ng is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GGGBBGOM@unsigned?5long?5is?5less?5than?5minim@
CONST	SEGMENT
??_C@_0CD@GGGBBGOM@unsigned?5long?5is?5less?5than?5minim@ DB 'unsigned lo'
	DB	'ng is less than minimum', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT LL_setitem
_TEXT	SEGMENT
x$ = 32
y$20602 = 36
ap$ = 64
i$ = 72
v$ = 80
LL_setitem PROC						; COMDAT

; 329  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 330  :     unsigned long x;
; 331  :     if (PyLong_Check(v)) {

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00027	85 c0		 test	 eax, eax
  00029	74 2b		 je	 SHORT $LN7@LL_setitem@3

; 332  :         x = PyLong_AsUnsignedLong(v);

  0002b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  00035	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 333  :         if (x == (unsigned long) -1 && PyErr_Occurred())

  00039	83 7c 24 20 ff	 cmp	 DWORD PTR x$[rsp], -1	; ffffffffH
  0003e	75 14		 jne	 SHORT $LN6@LL_setitem@3
  00040	e8 00 00 00 00	 call	 PyErr_Occurred
  00045	48 85 c0	 test	 rax, rax
  00048	74 0a		 je	 SHORT $LN6@LL_setitem@3

; 334  :             return -1;

  0004a	b8 ff ff ff ff	 mov	 eax, -1
  0004f	e9 8c 00 00 00	 jmp	 $LN8@LL_setitem@3
$LN6@LL_setitem@3:

; 335  :     }
; 336  :     else {

  00054	eb 4a		 jmp	 SHORT $LN5@LL_setitem@3
$LN7@LL_setitem@3:

; 337  :         long y;
; 338  :         if (!PyArg_Parse(v, "l;array item must be integer", &y))

  00056	4c 8d 44 24 24	 lea	 r8, QWORD PTR y$20602[rsp]
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@NPDLBKJK@l?$DLarray?5item?5must?5be?5integer?$AA@
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00067	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  0006c	85 c0		 test	 eax, eax
  0006e	75 07		 jne	 SHORT $LN4@LL_setitem@3

; 339  :             return -1;

  00070	b8 ff ff ff ff	 mov	 eax, -1
  00075	eb 69		 jmp	 SHORT $LN8@LL_setitem@3
$LN4@LL_setitem@3:

; 340  :         if (y < 0) {

  00077	83 7c 24 24 00	 cmp	 DWORD PTR y$20602[rsp], 0
  0007c	7d 1a		 jge	 SHORT $LN3@LL_setitem@3

; 341  :             PyErr_SetString(PyExc_OverflowError,
; 342  :                 "unsigned long is less than minimum");

  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@GGGBBGOM@unsigned?5long?5is?5less?5than?5minim@
  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0008c	e8 00 00 00 00	 call	 PyErr_SetString

; 343  :             return -1;

  00091	b8 ff ff ff ff	 mov	 eax, -1
  00096	eb 48		 jmp	 SHORT $LN8@LL_setitem@3
$LN3@LL_setitem@3:

; 344  :         }
; 345  :         x = (unsigned long)y;

  00098	8b 44 24 24	 mov	 eax, DWORD PTR y$20602[rsp]
  0009c	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
$LN5@LL_setitem@3:

; 346  : 
; 347  :     }
; 348  :     if (x > ULONG_MAX) {

  000a0	83 7c 24 20 ff	 cmp	 DWORD PTR x$[rsp], -1	; ffffffffH
  000a5	76 1a		 jbe	 SHORT $LN2@LL_setitem@3

; 349  :         PyErr_SetString(PyExc_OverflowError,
; 350  :             "unsigned long is greater than maximum");

  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@PFKJNNEL@unsigned?5long?5is?5greater?5than?5ma@
  000ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000b5	e8 00 00 00 00	 call	 PyErr_SetString

; 351  :         return -1;

  000ba	b8 ff ff ff ff	 mov	 eax, -1
  000bf	eb 1f		 jmp	 SHORT $LN8@LL_setitem@3
$LN2@LL_setitem@3:

; 352  :     }
; 353  : 
; 354  :     if (i >= 0)

  000c1	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  000c7	7c 15		 jl	 SHORT $LN1@LL_setitem@3

; 355  :         ((unsigned long *)ap->ob_item)[i] = x;

  000c9	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  000ce	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000d2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  000d7	8b 54 24 20	 mov	 edx, DWORD PTR x$[rsp]
  000db	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx
$LN1@LL_setitem@3:

; 356  :     return 0;

  000de	33 c0		 xor	 eax, eax
$LN8@LL_setitem@3:

; 357  : }

  000e0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e4	c3		 ret	 0
LL_setitem ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$q_getitem DD imagerel q_getitem
	DD	imagerel q_getitem+42
	DD	imagerel $unwind$q_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$q_getitem DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT q_getitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
q_getitem PROC						; COMDAT

; 363  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 364  :     return PyLong_FromLongLong(((PY_LONG_LONG *)ap->ob_item)[i]);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00020	e8 00 00 00 00	 call	 PyLong_FromLongLong

; 365  : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
q_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@JNLAGNB@L?$DLarray?5item?5must?5be?5integer?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$q_setitem DD imagerel q_setitem
	DD	imagerel q_setitem+90
	DD	imagerel $unwind$q_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$q_setitem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BN@JNLAGNB@L?$DLarray?5item?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BN@JNLAGNB@L?$DLarray?5item?5must?5be?5integer?$AA@ DB 'L;array it'
	DB	'em must be integer', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT q_setitem
_TEXT	SEGMENT
x$ = 32
ap$ = 64
i$ = 72
v$ = 80
q_setitem PROC						; COMDAT

; 369  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 370  :     PY_LONG_LONG x;
; 371  :     if (!PyArg_Parse(v, "L;array item must be integer", &x))

  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@JNLAGNB@L?$DLarray?5item?5must?5be?5integer?$AA@
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN2@q_setitem

; 372  :         return -1;

  0002d	b8 ff ff ff ff	 mov	 eax, -1
  00032	eb 21		 jmp	 SHORT $LN3@q_setitem
$LN2@q_setitem:

; 373  :     if (i >= 0)

  00034	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  0003a	7c 17		 jl	 SHORT $LN1@q_setitem

; 374  :         ((PY_LONG_LONG *)ap->ob_item)[i] = x;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  00041	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0004a	48 8b 54 24 20	 mov	 rdx, QWORD PTR x$[rsp]
  0004f	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
$LN1@q_setitem:

; 375  :     return 0;

  00053	33 c0		 xor	 eax, eax
$LN3@q_setitem:

; 376  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
q_setitem ENDP
_TEXT	ENDS
EXTRN	PyLong_FromUnsignedLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$QQ_getitem DD imagerel QQ_getitem
	DD	imagerel QQ_getitem+42
	DD	imagerel $unwind$QQ_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$QQ_getitem DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT QQ_getitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
QQ_getitem PROC						; COMDAT

; 380  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 381  :     return PyLong_FromUnsignedLongLong(
; 382  :         ((unsigned PY_LONG_LONG *)ap->ob_item)[i]);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00020	e8 00 00 00 00	 call	 PyLong_FromUnsignedLongLong

; 383  : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
QQ_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@CLOIAIHO@unsigned?5long?5long?5is?5less?5than?5@ ; `string'
EXTRN	PyLong_AsUnsignedLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$QQ_setitem DD imagerel QQ_setitem
	DD	imagerel QQ_setitem+200
	DD	imagerel $unwind$QQ_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$QQ_setitem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CI@CLOIAIHO@unsigned?5long?5long?5is?5less?5than?5@
CONST	SEGMENT
??_C@_0CI@CLOIAIHO@unsigned?5long?5long?5is?5less?5than?5@ DB 'unsigned l'
	DB	'ong long is less than minimum', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT QQ_setitem
_TEXT	SEGMENT
x$ = 32
y$20652 = 40
ap$ = 64
i$ = 72
v$ = 80
QQ_setitem PROC						; COMDAT

; 387  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 388  :     unsigned PY_LONG_LONG x;
; 389  :     if (PyLong_Check(v)) {

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00022	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00027	85 c0		 test	 eax, eax
  00029	74 2a		 je	 SHORT $LN6@QQ_setitem@2

; 390  :         x = PyLong_AsUnsignedLongLong(v);

  0002b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 PyLong_AsUnsignedLongLong
  00035	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 391  :         if (x == (unsigned PY_LONG_LONG) -1 && PyErr_Occurred())

  0003a	48 83 7c 24 20
	ff		 cmp	 QWORD PTR x$[rsp], -1
  00040	75 11		 jne	 SHORT $LN5@QQ_setitem@2
  00042	e8 00 00 00 00	 call	 PyErr_Occurred
  00047	48 85 c0	 test	 rax, rax
  0004a	74 07		 je	 SHORT $LN5@QQ_setitem@2

; 392  :             return -1;

  0004c	b8 ff ff ff ff	 mov	 eax, -1
  00051	eb 70		 jmp	 SHORT $LN7@QQ_setitem@2
$LN5@QQ_setitem@2:

; 393  :     }
; 394  :     else {

  00053	eb 4d		 jmp	 SHORT $LN4@QQ_setitem@2
$LN6@QQ_setitem@2:

; 395  :         PY_LONG_LONG y;
; 396  :         if (!PyArg_Parse(v, "L;array item must be integer", &y))

  00055	4c 8d 44 24 28	 lea	 r8, QWORD PTR y$20652[rsp]
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@JNLAGNB@L?$DLarray?5item?5must?5be?5integer?$AA@
  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00066	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  0006b	85 c0		 test	 eax, eax
  0006d	75 07		 jne	 SHORT $LN3@QQ_setitem@2

; 397  :             return -1;

  0006f	b8 ff ff ff ff	 mov	 eax, -1
  00074	eb 4d		 jmp	 SHORT $LN7@QQ_setitem@2
$LN3@QQ_setitem@2:

; 398  :         if (y < 0) {

  00076	48 83 7c 24 28
	00		 cmp	 QWORD PTR y$20652[rsp], 0
  0007c	7d 1a		 jge	 SHORT $LN2@QQ_setitem@2

; 399  :             PyErr_SetString(PyExc_OverflowError,
; 400  :                 "unsigned long long is less than minimum");

  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@CLOIAIHO@unsigned?5long?5long?5is?5less?5than?5@
  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0008c	e8 00 00 00 00	 call	 PyErr_SetString

; 401  :             return -1;

  00091	b8 ff ff ff ff	 mov	 eax, -1
  00096	eb 2b		 jmp	 SHORT $LN7@QQ_setitem@2
$LN2@QQ_setitem@2:

; 402  :         }
; 403  :         x = (unsigned PY_LONG_LONG)y;

  00098	48 8b 44 24 28	 mov	 rax, QWORD PTR y$20652[rsp]
  0009d	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax
$LN4@QQ_setitem@2:

; 404  :     }
; 405  : 
; 406  :     if (i >= 0)

  000a2	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  000a8	7c 17		 jl	 SHORT $LN1@QQ_setitem@2

; 407  :         ((unsigned PY_LONG_LONG *)ap->ob_item)[i] = x;

  000aa	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  000af	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000b3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  000b8	48 8b 54 24 20	 mov	 rdx, QWORD PTR x$[rsp]
  000bd	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
$LN1@QQ_setitem@2:

; 408  :     return 0;

  000c1	33 c0		 xor	 eax, eax
$LN7@QQ_setitem@2:

; 409  : }

  000c3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c7	c3		 ret	 0
QQ_setitem ENDP
_TEXT	ENDS
EXTRN	PyFloat_FromDouble:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$f_getitem DD imagerel f_getitem
	DD	imagerel f_getitem+46
	DD	imagerel $unwind$f_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$f_getitem DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT f_getitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
f_getitem PROC						; COMDAT

; 414  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 415  :     return PyFloat_FromDouble((double) ((float *)ap->ob_item)[i]);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	66 0f 6e 04 88	 movd	 xmm0, DWORD PTR [rax+rcx*4]
  00021	0f 5a c0	 cvtps2pd xmm0, xmm0
  00024	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 416  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
f_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@GDNNBMHH@f?$DLarray?5item?5must?5be?5float?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$f_setitem DD imagerel f_setitem
	DD	imagerel f_setitem+92
	DD	imagerel $unwind$f_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$f_setitem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BL@GDNNBMHH@f?$DLarray?5item?5must?5be?5float?$AA@
CONST	SEGMENT
??_C@_0BL@GDNNBMHH@f?$DLarray?5item?5must?5be?5float?$AA@ DB 'f;array ite'
	DB	'm must be float', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT f_setitem
_TEXT	SEGMENT
x$ = 32
ap$ = 64
i$ = 72
v$ = 80
f_setitem PROC						; COMDAT

; 420  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 421  :     float x;
; 422  :     if (!PyArg_Parse(v, "f;array item must be float", &x))

  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@GDNNBMHH@f?$DLarray?5item?5must?5be?5float?$AA@
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN2@f_setitem

; 423  :         return -1;

  0002d	b8 ff ff ff ff	 mov	 eax, -1
  00032	eb 23		 jmp	 SHORT $LN3@f_setitem
$LN2@f_setitem:

; 424  :     if (i >= 0)

  00034	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  0003a	7c 19		 jl	 SHORT $LN1@f_setitem

; 425  :                  ((float *)ap->ob_item)[i] = x;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  00041	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0004a	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR x$[rsp]
  00050	f3 0f 11 04 88	 movss	 DWORD PTR [rax+rcx*4], xmm0
$LN1@f_setitem:

; 426  :     return 0;

  00055	33 c0		 xor	 eax, eax
$LN3@f_setitem:

; 427  : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
f_setitem ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$d_getitem DD imagerel d_getitem
	DD	imagerel d_getitem+43
	DD	imagerel $unwind$d_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$d_getitem DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT d_getitem
_TEXT	SEGMENT
ap$ = 48
i$ = 56
d_getitem PROC						; COMDAT

; 431  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 432  :     return PyFloat_FromDouble(((double *)ap->ob_item)[i]);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR ap$[rsp]
  00013	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00017	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  0001c	f2 0f 10 04 c8	 movsdx	 xmm0, QWORD PTR [rax+rcx*8]
  00021	e8 00 00 00 00	 call	 PyFloat_FromDouble

; 433  : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
d_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@LOMFCKPF@d?$DLarray?5item?5must?5be?5float?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$d_setitem DD imagerel d_setitem
	DD	imagerel d_setitem+92
	DD	imagerel $unwind$d_setitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$d_setitem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BL@LOMFCKPF@d?$DLarray?5item?5must?5be?5float?$AA@
CONST	SEGMENT
??_C@_0BL@LOMFCKPF@d?$DLarray?5item?5must?5be?5float?$AA@ DB 'd;array ite'
	DB	'm must be float', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT d_setitem
_TEXT	SEGMENT
x$ = 32
ap$ = 64
i$ = 72
v$ = 80
d_setitem PROC						; COMDAT

; 437  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 438  :     double x;
; 439  :     if (!PyArg_Parse(v, "d;array item must be float", &x))

  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR x$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LOMFCKPF@d?$DLarray?5item?5must?5be?5float?$AA@
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_Parse_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN2@d_setitem

; 440  :         return -1;

  0002d	b8 ff ff ff ff	 mov	 eax, -1
  00032	eb 23		 jmp	 SHORT $LN3@d_setitem
$LN2@d_setitem:

; 441  :     if (i >= 0)

  00034	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  0003a	7c 19		 jl	 SHORT $LN1@d_setitem

; 442  :                  ((double *)ap->ob_item)[i] = x;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR ap$[rsp]
  00041	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0004a	f2 0f 10 44 24
	20		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00050	f2 0f 11 04 c8	 movsdx	 QWORD PTR [rax+rcx*8], xmm0
$LN1@d_setitem:

; 443  :     return 0;

  00055	33 c0		 xor	 eax, eax
$LN3@d_setitem:

; 444  : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
d_setitem ENDP
_TEXT	ENDS
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	_Py_PXCTX:PROC
EXTRN	PyObject_ClearWeakRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_dealloc DD imagerel array_dealloc
	DD	imagerel array_dealloc+126
	DD	imagerel $unwind$array_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_dealloc DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_dealloc
_TEXT	SEGMENT
tv75 = 32
op$ = 64
array_dealloc PROC					; COMDAT

; 557  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 558  :     if (op->weakreflist != NULL)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0000e	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00016	74 0a		 je	 SHORT $LN2@array_deal

; 559  :         PyObject_ClearWeakRefs((PyObject *) op);

  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0001d	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN2@array_deal:

; 560  :     if (op->ob_item != NULL)

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00027	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0002c	74 37		 je	 SHORT $LN1@array_deal

; 561  :         PyMem_DEL(op->ob_item);

  0002e	e8 00 00 00 00	 call	 _Py_PXCTX
  00033	85 c0		 test	 eax, eax
  00035	74 18		 je	 SHORT $LN5@array_deal
  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0003c	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00040	e8 00 00 00 00	 call	 _PxMem_Free
  00045	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  0004d	eb 16		 jmp	 SHORT $LN6@array_deal
$LN5@array_deal:
  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00054	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00058	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0005d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN6@array_deal:
$LN1@array_deal:

; 562  :     Py_TYPE(op)->tp_free((PyObject *)op);

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  00073	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 563  : }

  00079	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007d	c3		 ret	 0
array_dealloc ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	_Py_IncRef
EXTRN	PyObject_RichCompare:PROC
EXTRN	__ImageBase:BYTE
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_NotImplementedStruct:BYTE
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_richcompare DD imagerel array_richcompare
	DD	imagerel array_richcompare+1120
	DD	imagerel $unwind$array_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_richcompare DD 021601H
	DD	0130116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_richcompare
_TEXT	SEGMENT
res$ = 32
wi$ = 40
i$ = 48
vi$ = 56
va$ = 64
wa$ = 72
k$ = 80
vs$20872 = 88
ws$20874 = 96
cmp$20876 = 104
tv149 = 108
tv151 = 112
tv153 = 116
tv155 = 120
tv157 = 124
tv159 = 128
tv161 = 132
v$ = 160
w$ = 168
op$ = 176
array_richcompare PROC					; COMDAT

; 567  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 568  :     arrayobject *va, *wa;
; 569  :     PyObject *vi = NULL;

  00016	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR vi$[rsp], 0

; 570  :     PyObject *wi = NULL;

  0001f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR wi$[rsp], 0

; 571  :     Py_ssize_t i, k;
; 572  :     PyObject *res;
; 573  : 
; 574  :     if (!array_Check(v) || !array_Check(w))

  00028	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  0002f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00037	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003b	74 1c		 je	 SHORT $LN36@array_rich
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00044	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  0004c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00050	e8 00 00 00 00	 call	 PyType_IsSubtype
  00055	85 c0		 test	 eax, eax
  00057	74 31		 je	 SHORT $LN37@array_rich
$LN36@array_rich:
  00059	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  00060	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR w$[rsp]
  00068	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0006c	74 34		 je	 SHORT $LN38@array_rich
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00075	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  0007d	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00081	e8 00 00 00 00	 call	 PyType_IsSubtype
  00086	85 c0		 test	 eax, eax
  00088	75 18		 jne	 SHORT $LN38@array_rich
$LN37@array_rich:

; 575  :         Py_RETURN_NOTIMPLEMENTED;

  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00091	e8 00 00 00 00	 call	 _Py_IncRef
  00096	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0009d	e9 9d 03 00 00	 jmp	 $LN39@array_rich
$LN38@array_rich:

; 576  : 
; 577  :     va = (arrayobject *)v;

  000a2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  000aa	48 89 44 24 40	 mov	 QWORD PTR va$[rsp], rax

; 578  :     wa = (arrayobject *)w;

  000af	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  000b7	48 89 44 24 48	 mov	 QWORD PTR wa$[rsp], rax

; 579  : 
; 580  :     if (Py_SIZE(va) != Py_SIZE(wa) && (op == Py_EQ || op == Py_NE)) {

  000bc	48 8b 44 24 40	 mov	 rax, QWORD PTR va$[rsp]
  000c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR wa$[rsp]
  000c6	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000ca	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  000ce	74 4c		 je	 SHORT $LN35@array_rich
  000d0	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  000d8	74 0a		 je	 SHORT $LN34@array_rich
  000da	83 bc 24 b0 00
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  000e2	75 38		 jne	 SHORT $LN35@array_rich
$LN34@array_rich:

; 581  :         /* Shortcut: if the lengths differ, the arrays differ */
; 582  :         if (op == Py_EQ)

  000e4	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  000ec	75 0e		 jne	 SHORT $LN33@array_rich

; 583  :             res = Py_False;

  000ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000f5	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 584  :         else

  000fa	eb 0c		 jmp	 SHORT $LN32@array_rich
$LN33@array_rich:

; 585  :             res = Py_True;

  000fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00103	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax
$LN32@array_rich:

; 586  :         Py_INCREF(res);

  00108	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  0010d	e8 00 00 00 00	 call	 _Py_IncRef

; 587  :         return res;

  00112	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
  00117	e9 23 03 00 00	 jmp	 $LN39@array_rich
$LN35@array_rich:

; 588  :     }
; 589  : 
; 590  :     /* Search for the first index where items are different */
; 591  :     k = 1;

  0011c	48 c7 44 24 50
	01 00 00 00	 mov	 QWORD PTR k$[rsp], 1

; 592  :     for (i = 0; i < Py_SIZE(va) && i < Py_SIZE(wa); i++) {

  00125	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0012e	eb 0d		 jmp	 SHORT $LN31@array_rich
$LN30@array_rich:
  00130	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00135	48 ff c0	 inc	 rax
  00138	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN31@array_rich:
  0013d	48 8b 44 24 40	 mov	 rax, QWORD PTR va$[rsp]
  00142	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00146	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0014b	0f 8d d7 00 00
	00		 jge	 $LN29@array_rich
  00151	48 8b 44 24 48	 mov	 rax, QWORD PTR wa$[rsp]
  00156	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0015a	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0015f	0f 8d c3 00 00
	00		 jge	 $LN29@array_rich

; 593  :         vi = getarrayitem(v, i);

  00165	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  0016a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00172	e8 00 00 00 00	 call	 getarrayitem
  00177	48 89 44 24 38	 mov	 QWORD PTR vi$[rsp], rax

; 594  :         wi = getarrayitem(w, i);

  0017c	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  00181	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR w$[rsp]
  00189	e8 00 00 00 00	 call	 getarrayitem
  0018e	48 89 44 24 28	 mov	 QWORD PTR wi$[rsp], rax

; 595  :         if (vi == NULL || wi == NULL) {

  00193	48 83 7c 24 38
	00		 cmp	 QWORD PTR vi$[rsp], 0
  00199	74 08		 je	 SHORT $LN27@array_rich
  0019b	48 83 7c 24 28
	00		 cmp	 QWORD PTR wi$[rsp], 0
  001a1	75 37		 jne	 SHORT $LN28@array_rich
$LN27@array_rich:
$LN26@array_rich:

; 596  :             Py_XDECREF(vi);

  001a3	48 83 7c 24 38
	00		 cmp	 QWORD PTR vi$[rsp], 0
  001a9	74 0a		 je	 SHORT $LN23@array_rich
  001ab	48 8b 4c 24 38	 mov	 rcx, QWORD PTR vi$[rsp]
  001b0	e8 00 00 00 00	 call	 _Py_DecRef
$LN23@array_rich:
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 e8		 jne	 SHORT $LN26@array_rich
$LN22@array_rich:

; 597  :             Py_XDECREF(wi);

  001bb	48 83 7c 24 28
	00		 cmp	 QWORD PTR wi$[rsp], 0
  001c1	74 0a		 je	 SHORT $LN19@array_rich
  001c3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR wi$[rsp]
  001c8	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@array_rich:
  001cd	33 c0		 xor	 eax, eax
  001cf	85 c0		 test	 eax, eax
  001d1	75 e8		 jne	 SHORT $LN22@array_rich

; 598  :             return NULL;

  001d3	33 c0		 xor	 eax, eax
  001d5	e9 65 02 00 00	 jmp	 $LN39@array_rich
$LN28@array_rich:

; 599  :         }
; 600  :         k = PyObject_RichCompareBool(vi, wi, Py_EQ);

  001da	41 b8 02 00 00
	00		 mov	 r8d, 2
  001e0	48 8b 54 24 28	 mov	 rdx, QWORD PTR wi$[rsp]
  001e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR vi$[rsp]
  001ea	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  001ef	48 98		 cdqe
  001f1	48 89 44 24 50	 mov	 QWORD PTR k$[rsp], rax

; 601  :         if (k == 0)

  001f6	48 83 7c 24 50
	00		 cmp	 QWORD PTR k$[rsp], 0
  001fc	75 02		 jne	 SHORT $LN18@array_rich

; 602  :             break; /* Keeping vi and wi alive! */

  001fe	eb 28		 jmp	 SHORT $LN29@array_rich
$LN18@array_rich:

; 603  :         Py_DECREF(vi);

  00200	48 8b 4c 24 38	 mov	 rcx, QWORD PTR vi$[rsp]
  00205	e8 00 00 00 00	 call	 _Py_DecRef

; 604  :         Py_DECREF(wi);

  0020a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR wi$[rsp]
  0020f	e8 00 00 00 00	 call	 _Py_DecRef

; 605  :         if (k < 0)

  00214	48 83 7c 24 50
	00		 cmp	 QWORD PTR k$[rsp], 0
  0021a	7d 07		 jge	 SHORT $LN17@array_rich

; 606  :             return NULL;

  0021c	33 c0		 xor	 eax, eax
  0021e	e9 1c 02 00 00	 jmp	 $LN39@array_rich
$LN17@array_rich:

; 607  :     }

  00223	e9 08 ff ff ff	 jmp	 $LN30@array_rich
$LN29@array_rich:

; 608  : 
; 609  :     if (k) {

  00228	48 83 7c 24 50
	00		 cmp	 QWORD PTR k$[rsp], 0
  0022e	0f 84 8e 01 00
	00		 je	 $LN16@array_rich

; 610  :         /* No more items to compare -- compare sizes */
; 611  :         Py_ssize_t vs = Py_SIZE(va);

  00234	48 8b 44 24 40	 mov	 rax, QWORD PTR va$[rsp]
  00239	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0023d	48 89 44 24 58	 mov	 QWORD PTR vs$20872[rsp], rax

; 612  :         Py_ssize_t ws = Py_SIZE(wa);

  00242	48 8b 44 24 48	 mov	 rax, QWORD PTR wa$[rsp]
  00247	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0024b	48 89 44 24 60	 mov	 QWORD PTR ws$20874[rsp], rax

; 613  :         int cmp;
; 614  :         switch (op) {

  00250	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR op$[rsp]
  00257	89 44 24 6c	 mov	 DWORD PTR tv149[rsp], eax
  0025b	83 7c 24 6c 05	 cmp	 DWORD PTR tv149[rsp], 5
  00260	0f 87 23 01 00
	00		 ja	 $LN7@array_rich
  00266	48 63 44 24 6c	 movsxd	 rax, DWORD PTR tv149[rsp]
  0026b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00272	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN53@array_rich[rcx+rax*4]
  00279	48 03 c1	 add	 rax, rcx
  0027c	ff e0		 jmp	 rax
$LN13@array_rich:

; 615  :         case Py_LT: cmp = vs <  ws; break;

  0027e	48 8b 44 24 60	 mov	 rax, QWORD PTR ws$20874[rsp]
  00283	48 39 44 24 58	 cmp	 QWORD PTR vs$20872[rsp], rax
  00288	7d 0a		 jge	 SHORT $LN41@array_rich
  0028a	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00292	eb 08		 jmp	 SHORT $LN42@array_rich
$LN41@array_rich:
  00294	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN42@array_rich:
  0029c	8b 44 24 70	 mov	 eax, DWORD PTR tv151[rsp]
  002a0	89 44 24 68	 mov	 DWORD PTR cmp$20876[rsp], eax
  002a4	e9 e7 00 00 00	 jmp	 $LN14@array_rich
$LN12@array_rich:

; 616  :         case Py_LE: cmp = vs <= ws; break;

  002a9	48 8b 44 24 60	 mov	 rax, QWORD PTR ws$20874[rsp]
  002ae	48 39 44 24 58	 cmp	 QWORD PTR vs$20872[rsp], rax
  002b3	7f 0a		 jg	 SHORT $LN43@array_rich
  002b5	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  002bd	eb 08		 jmp	 SHORT $LN44@array_rich
$LN43@array_rich:
  002bf	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN44@array_rich:
  002c7	8b 44 24 74	 mov	 eax, DWORD PTR tv153[rsp]
  002cb	89 44 24 68	 mov	 DWORD PTR cmp$20876[rsp], eax
  002cf	e9 bc 00 00 00	 jmp	 $LN14@array_rich
$LN11@array_rich:

; 617  :         case Py_EQ: cmp = vs == ws; break;

  002d4	48 8b 44 24 60	 mov	 rax, QWORD PTR ws$20874[rsp]
  002d9	48 39 44 24 58	 cmp	 QWORD PTR vs$20872[rsp], rax
  002de	75 0a		 jne	 SHORT $LN45@array_rich
  002e0	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  002e8	eb 08		 jmp	 SHORT $LN46@array_rich
$LN45@array_rich:
  002ea	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN46@array_rich:
  002f2	8b 44 24 78	 mov	 eax, DWORD PTR tv155[rsp]
  002f6	89 44 24 68	 mov	 DWORD PTR cmp$20876[rsp], eax
  002fa	e9 91 00 00 00	 jmp	 $LN14@array_rich
$LN10@array_rich:

; 618  :         case Py_NE: cmp = vs != ws; break;

  002ff	48 8b 44 24 60	 mov	 rax, QWORD PTR ws$20874[rsp]
  00304	48 39 44 24 58	 cmp	 QWORD PTR vs$20872[rsp], rax
  00309	74 0a		 je	 SHORT $LN47@array_rich
  0030b	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  00313	eb 08		 jmp	 SHORT $LN48@array_rich
$LN47@array_rich:
  00315	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN48@array_rich:
  0031d	8b 44 24 7c	 mov	 eax, DWORD PTR tv157[rsp]
  00321	89 44 24 68	 mov	 DWORD PTR cmp$20876[rsp], eax
  00325	eb 69		 jmp	 SHORT $LN14@array_rich
$LN9@array_rich:

; 619  :         case Py_GT: cmp = vs >  ws; break;

  00327	48 8b 44 24 60	 mov	 rax, QWORD PTR ws$20874[rsp]
  0032c	48 39 44 24 58	 cmp	 QWORD PTR vs$20872[rsp], rax
  00331	7e 0d		 jle	 SHORT $LN49@array_rich
  00333	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv159[rsp], 1
  0033e	eb 0b		 jmp	 SHORT $LN50@array_rich
$LN49@array_rich:
  00340	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv159[rsp], 0
$LN50@array_rich:
  0034b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv159[rsp]
  00352	89 44 24 68	 mov	 DWORD PTR cmp$20876[rsp], eax
  00356	eb 38		 jmp	 SHORT $LN14@array_rich
$LN8@array_rich:

; 620  :         case Py_GE: cmp = vs >= ws; break;

  00358	48 8b 44 24 60	 mov	 rax, QWORD PTR ws$20874[rsp]
  0035d	48 39 44 24 58	 cmp	 QWORD PTR vs$20872[rsp], rax
  00362	7c 0d		 jl	 SHORT $LN51@array_rich
  00364	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv161[rsp], 1
  0036f	eb 0b		 jmp	 SHORT $LN52@array_rich
$LN51@array_rich:
  00371	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv161[rsp], 0
$LN52@array_rich:
  0037c	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv161[rsp]
  00383	89 44 24 68	 mov	 DWORD PTR cmp$20876[rsp], eax
  00387	eb 07		 jmp	 SHORT $LN14@array_rich
$LN7@array_rich:

; 621  :         default: return NULL; /* cannot happen */

  00389	33 c0		 xor	 eax, eax
  0038b	e9 af 00 00 00	 jmp	 $LN39@array_rich
$LN14@array_rich:

; 622  :         }
; 623  :         if (cmp)

  00390	83 7c 24 68 00	 cmp	 DWORD PTR cmp$20876[rsp], 0
  00395	74 0e		 je	 SHORT $LN6@array_rich

; 624  :             res = Py_True;

  00397	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0039e	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 625  :         else

  003a3	eb 0c		 jmp	 SHORT $LN5@array_rich
$LN6@array_rich:

; 626  :             res = Py_False;

  003a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  003ac	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax
$LN5@array_rich:

; 627  :         Py_INCREF(res);

  003b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  003b6	e8 00 00 00 00	 call	 _Py_IncRef

; 628  :         return res;

  003bb	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
  003c0	eb 7d		 jmp	 SHORT $LN39@array_rich
$LN16@array_rich:

; 629  :     }
; 630  : 
; 631  :     /* We have an item that differs.  First, shortcuts for EQ/NE */
; 632  :     if (op == Py_EQ) {

  003c2	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  003ca	75 1a		 jne	 SHORT $LN4@array_rich

; 633  :         Py_INCREF(Py_False);

  003cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  003d3	e8 00 00 00 00	 call	 _Py_IncRef

; 634  :         res = Py_False;

  003d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  003df	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax
  003e4	eb 40		 jmp	 SHORT $LN3@array_rich
$LN4@array_rich:

; 635  :     }
; 636  :     else if (op == Py_NE) {

  003e6	83 bc 24 b0 00
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  003ee	75 1a		 jne	 SHORT $LN2@array_rich

; 637  :         Py_INCREF(Py_True);

  003f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  003f7	e8 00 00 00 00	 call	 _Py_IncRef

; 638  :         res = Py_True;

  003fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00403	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 639  :     }
; 640  :     else {

  00408	eb 1c		 jmp	 SHORT $LN1@array_rich
$LN2@array_rich:

; 641  :         /* Compare the final item again using the proper operator */
; 642  :         res = PyObject_RichCompare(vi, wi, op);

  0040a	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR op$[rsp]
  00412	48 8b 54 24 28	 mov	 rdx, QWORD PTR wi$[rsp]
  00417	48 8b 4c 24 38	 mov	 rcx, QWORD PTR vi$[rsp]
  0041c	e8 00 00 00 00	 call	 PyObject_RichCompare
  00421	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax
$LN1@array_rich:
$LN3@array_rich:

; 643  :     }
; 644  :     Py_DECREF(vi);

  00426	48 8b 4c 24 38	 mov	 rcx, QWORD PTR vi$[rsp]
  0042b	e8 00 00 00 00	 call	 _Py_DecRef

; 645  :     Py_DECREF(wi);

  00430	48 8b 4c 24 28	 mov	 rcx, QWORD PTR wi$[rsp]
  00435	e8 00 00 00 00	 call	 _Py_DecRef

; 646  :     return res;

  0043a	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
$LN39@array_rich:

; 647  : }

  0043f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00446	c3		 ret	 0
  00447	90		 npad	 1
$LN53@array_rich:
  00448	00 00 00 00	 DD	 $LN13@array_rich
  0044c	00 00 00 00	 DD	 $LN12@array_rich
  00450	00 00 00 00	 DD	 $LN11@array_rich
  00454	00 00 00 00	 DD	 $LN10@array_rich
  00458	00 00 00 00	 DD	 $LN9@array_rich
  0045c	00 00 00 00	 DD	 $LN8@array_rich
array_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@HMEDAJIH@?$AAi?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?$DM?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAa?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@OLGPFNA@?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\arraymodule.c
pdata	SEGMENT
$pdata$getarrayitem DD imagerel getarrayitem
	DD	imagerel getarrayitem+177
	DD	imagerel $unwind$getarrayitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getarrayitem DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1CM@HMEDAJIH@?$AAi?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?$DM?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAa?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@HMEDAJIH@?$AAi?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?$DM?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAa?$AAp?$AA?$CJ?$AA?$AA@ DB 'i'
	DB	00H, '>', 00H, '=', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 'i', 00H, '<', 00H, 'P', 00H, 'y', 00H, '_', 00H, 'S'
	DB	00H, 'I', 00H, 'Z', 00H, 'E', 00H, '(', 00H, 'a', 00H, 'p', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@OLGPFNA@?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@OLGPFNA@?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ DB 'a'
	DB	00H, 'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H
	DB	'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'o', 00H, 'p'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 'a', 00H, 'r', 00H, 'r'
	DB	00H, 'a', 00H, 'y', 00H, 'm', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT getarrayitem
_TEXT	SEGMENT
ap$ = 32
op$ = 64
i$ = 72
getarrayitem PROC					; COMDAT

; 515  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 516  :     register arrayobject *ap;
; 517  :     assert(array_Check(op));

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  00015	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 35		 je	 SHORT $LN3@getarrayit
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 1c		 jne	 SHORT $LN3@getarrayit
  00039	41 b8 05 02 00
	00		 mov	 r8d, 517		; 00000205H
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@OLGPFNA@?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00053	33 c0		 xor	 eax, eax
$LN3@getarrayit:

; 518  :     ap = (arrayobject *)op;

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0005a	48 89 44 24 20	 mov	 QWORD PTR ap$[rsp], rax

; 519  :     assert(i>=0 && i<Py_SIZE(ap));

  0005f	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  00065	7c 10		 jl	 SHORT $LN4@getarrayit
  00067	48 8b 44 24 20	 mov	 rax, QWORD PTR ap$[rsp]
  0006c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00070	48 39 44 24 48	 cmp	 QWORD PTR i$[rsp], rax
  00075	7c 1c		 jl	 SHORT $LN5@getarrayit
$LN4@getarrayit:
  00077	41 b8 07 02 00
	00		 mov	 r8d, 519		; 00000207H
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@HMEDAJIH@?$AAi?$AA?$DO?$AA?$DN?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAi?$AA?$DM?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAa?$AAp?$AA?$CJ?$AA?$AA@
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00091	33 c0		 xor	 eax, eax
$LN5@getarrayit:

; 520  :     return (*ap->ob_descr->getitem)(ap, i);

  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR ap$[rsp]
  00098	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0009f	48 8b 54 24 48	 mov	 rdx, QWORD PTR i$[rsp]
  000a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ap$[rsp]
  000a9	ff 50 08	 call	 QWORD PTR [rax+8]

; 521  : }

  000ac	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b0	c3		 ret	 0
getarrayitem ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT array_length
_TEXT	SEGMENT
a$ = 8
array_length PROC					; COMDAT

; 651  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 652  :     return Py_SIZE(a);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR a$[rsp]
  0000a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]

; 653  : }

  0000e	c3		 ret	 0
array_length ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@FONIJAGJ@array?5index?5out?5of?5range?$AA@ ; `string'
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_item DD imagerel array_item
	DD	imagerel array_item+81
	DD	imagerel $unwind$array_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_item DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0BJ@FONIJAGJ@array?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BJ@FONIJAGJ@array?5index?5out?5of?5range?$AA@ DB 'array index out '
	DB	'of range', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_item
_TEXT	SEGMENT
a$ = 48
i$ = 56
array_item PROC						; COMDAT

; 657  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 658  :     if (i < 0 || i >= Py_SIZE(a)) {

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  00014	7c 10		 jl	 SHORT $LN1@array_item
  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0001b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001f	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00024	7c 17		 jl	 SHORT $LN2@array_item
$LN1@array_item:

; 659  :         PyErr_SetString(PyExc_IndexError, "array index out of range");

  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@FONIJAGJ@array?5index?5out?5of?5range?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00034	e8 00 00 00 00	 call	 PyErr_SetString

; 660  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 0f		 jmp	 SHORT $LN3@array_item
$LN2@array_item:

; 661  :     }
; 662  :     return getarrayitem((PyObject *)a, i);

  0003d	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  00042	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00047	e8 00 00 00 00	 call	 getarrayitem
$LN3@array_item:

; 663  : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
array_item ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_copy DD imagerel array_copy
	DD	imagerel array_copy+40
	DD	imagerel $unwind$array_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_copy DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_copy
_TEXT	SEGMENT
a$ = 48
unused$ = 56
array_copy PROC						; COMDAT

; 689  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 690  :     return array_slice(a, 0, Py_SIZE(a));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00013	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00017	33 d2		 xor	 edx, edx
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  0001e	e8 00 00 00 00	 call	 array_slice

; 691  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
array_copy ENDP
_TEXT	ENDS
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_slice DD imagerel array_slice
	DD	imagerel array_slice+302
	DD	imagerel $unwind$array_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_slice DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_slice
_TEXT	SEGMENT
np$ = 32
a$ = 64
ilow$ = 72
ihigh$ = 80
array_slice PROC					; COMDAT

; 667  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 668  :     arrayobject *np;
; 669  :     if (ilow < 0)

  00013	48 83 7c 24 48
	00		 cmp	 QWORD PTR ilow$[rsp], 0
  00019	7d 0b		 jge	 SHORT $LN8@array_slic

; 670  :         ilow = 0;

  0001b	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR ilow$[rsp], 0
  00024	eb 1e		 jmp	 SHORT $LN7@array_slic
$LN8@array_slic:

; 671  :     else if (ilow > Py_SIZE(a))

  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0002b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002f	48 39 44 24 48	 cmp	 QWORD PTR ilow$[rsp], rax
  00034	7e 0e		 jle	 SHORT $LN6@array_slic

; 672  :         ilow = Py_SIZE(a);

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0003b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003f	48 89 44 24 48	 mov	 QWORD PTR ilow$[rsp], rax
$LN6@array_slic:
$LN7@array_slic:

; 673  :     if (ihigh < 0)

  00044	48 83 7c 24 50
	00		 cmp	 QWORD PTR ihigh$[rsp], 0
  0004a	7d 09		 jge	 SHORT $LN5@array_slic

; 674  :         ihigh = 0;

  0004c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR ihigh$[rsp], 0
$LN5@array_slic:

; 675  :     if (ihigh < ilow)

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR ilow$[rsp]
  0005a	48 39 44 24 50	 cmp	 QWORD PTR ihigh$[rsp], rax
  0005f	7d 0c		 jge	 SHORT $LN4@array_slic

; 676  :         ihigh = ilow;

  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR ilow$[rsp]
  00066	48 89 44 24 50	 mov	 QWORD PTR ihigh$[rsp], rax
  0006b	eb 1e		 jmp	 SHORT $LN3@array_slic
$LN4@array_slic:

; 677  :     else if (ihigh > Py_SIZE(a))

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00072	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00076	48 39 44 24 50	 cmp	 QWORD PTR ihigh$[rsp], rax
  0007b	7e 0e		 jle	 SHORT $LN2@array_slic

; 678  :         ihigh = Py_SIZE(a);

  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00082	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00086	48 89 44 24 50	 mov	 QWORD PTR ihigh$[rsp], rax
$LN2@array_slic:
$LN3@array_slic:

; 679  :     np = (arrayobject *) newarrayobject(&Arraytype, ihigh - ilow, a->ob_descr);

  0008b	48 8b 44 24 48	 mov	 rax, QWORD PTR ilow$[rsp]
  00090	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ihigh$[rsp]
  00095	48 2b c8	 sub	 rcx, rax
  00098	48 8b c1	 mov	 rax, rcx
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  000a0	4c 8b 81 80 00
	00 00		 mov	 r8, QWORD PTR [rcx+128]
  000a7	48 8b d0	 mov	 rdx, rax
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  000b1	e8 00 00 00 00	 call	 newarrayobject
  000b6	48 89 44 24 20	 mov	 QWORD PTR np$[rsp], rax

; 680  :     if (np == NULL)

  000bb	48 83 7c 24 20
	00		 cmp	 QWORD PTR np$[rsp], 0
  000c1	75 04		 jne	 SHORT $LN1@array_slic

; 681  :         return NULL;

  000c3	33 c0		 xor	 eax, eax
  000c5	eb 62		 jmp	 SHORT $LN9@array_slic
$LN1@array_slic:

; 682  :     memcpy(np->ob_item, a->ob_item + ilow * a->ob_descr->itemsize,
; 683  :            (ihigh-ilow) * a->ob_descr->itemsize);

  000c7	48 8b 44 24 48	 mov	 rax, QWORD PTR ilow$[rsp]
  000cc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ihigh$[rsp]
  000d1	48 2b c8	 sub	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  000dc	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000e3	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  000e7	48 0f af c1	 imul	 rax, rcx
  000eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  000f0	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000f7	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  000fb	48 8b 54 24 48	 mov	 rdx, QWORD PTR ilow$[rsp]
  00100	48 0f af d1	 imul	 rdx, rcx
  00104	48 8b ca	 mov	 rcx, rdx
  00107	48 8b 54 24 40	 mov	 rdx, QWORD PTR a$[rsp]
  0010c	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  00110	4c 8b c0	 mov	 r8, rax
  00113	48 8b d1	 mov	 rdx, rcx
  00116	48 8b 44 24 20	 mov	 rax, QWORD PTR np$[rsp]
  0011b	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0011f	e8 00 00 00 00	 call	 memcpy

; 684  :     return (PyObject *)np;

  00124	48 8b 44 24 20	 mov	 rax, QWORD PTR np$[rsp]
$LN9@array_slic:

; 685  : }

  00129	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012d	c3		 ret	 0
array_slice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@ ; `string'
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyErr_BadInternalCall:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$newarrayobject DD imagerel newarrayobject
	DD	imagerel newarrayobject+400
	DD	imagerel $unwind$newarrayobject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newarrayobject DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@
CONST	SEGMENT
??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@ DB '..\Modules\arra'
	DB	'ymodule.c', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT newarrayobject
_TEXT	SEGMENT
nbytes$ = 32
op$ = 40
tv68 = 48
tv95 = 56
tv94 = 64
type$ = 96
size$ = 104
descr$ = 112
newarrayobject PROC					; COMDAT

; 477  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 478  :     arrayobject *op;
; 479  :     size_t nbytes;
; 480  : 
; 481  :     if (size < 0) {

  00013	48 83 7c 24 68
	00		 cmp	 QWORD PTR size$[rsp], 0
  00019	7d 18		 jge	 SHORT $LN6@newarrayob

; 482  :         PyErr_BadInternalCall();

  0001b	ba e2 01 00 00	 mov	 edx, 482		; 000001e2H
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@
  00027	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 483  :         return NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 58 01 00 00	 jmp	 $LN7@newarrayob
$LN6@newarrayob:

; 484  :     }
; 485  : 
; 486  :     /* Check for overflow */
; 487  :     if (size > PY_SSIZE_T_MAX / descr->itemsize) {

  00033	48 8b 44 24 70	 mov	 rax, QWORD PTR descr$[rsp]
  00038	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0003c	48 89 44 24 30	 mov	 QWORD PTR tv68[rsp], rax
  00041	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0004b	48 8b c1	 mov	 rax, rcx
  0004e	48 99		 cdq
  00050	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv68[rsp]
  00055	48 f7 f9	 idiv	 rcx
  00058	48 39 44 24 68	 cmp	 QWORD PTR size$[rsp], rax
  0005d	7e 0a		 jle	 SHORT $LN5@newarrayob

; 488  :         return PyErr_NoMemory();

  0005f	e8 00 00 00 00	 call	 PyErr_NoMemory
  00064	e9 22 01 00 00	 jmp	 $LN7@newarrayob
$LN5@newarrayob:

; 489  :     }
; 490  :     nbytes = size * descr->itemsize;

  00069	48 8b 44 24 70	 mov	 rax, QWORD PTR descr$[rsp]
  0006e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00072	48 8b 4c 24 68	 mov	 rcx, QWORD PTR size$[rsp]
  00077	48 0f af c8	 imul	 rcx, rax
  0007b	48 8b c1	 mov	 rax, rcx
  0007e	48 89 44 24 20	 mov	 QWORD PTR nbytes$[rsp], rax

; 491  :     op = (arrayobject *) type->tp_alloc(type, 0);

  00083	33 d2		 xor	 edx, edx
  00085	48 8b 4c 24 60	 mov	 rcx, QWORD PTR type$[rsp]
  0008a	48 8b 44 24 60	 mov	 rax, QWORD PTR type$[rsp]
  0008f	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00095	48 89 44 24 28	 mov	 QWORD PTR op$[rsp], rax

; 492  :     if (op == NULL) {

  0009a	48 83 7c 24 28
	00		 cmp	 QWORD PTR op$[rsp], 0
  000a0	75 07		 jne	 SHORT $LN4@newarrayob

; 493  :         return NULL;

  000a2	33 c0		 xor	 eax, eax
  000a4	e9 e2 00 00 00	 jmp	 $LN7@newarrayob
$LN4@newarrayob:

; 494  :     }
; 495  :     op->ob_descr = descr;

  000a9	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  000ae	48 8b 4c 24 70	 mov	 rcx, QWORD PTR descr$[rsp]
  000b3	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 496  :     op->allocated = size;

  000ba	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  000bf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR size$[rsp]
  000c4	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 497  :     op->weakreflist = NULL;

  000c8	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  000cd	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 498  :     Py_SIZE(op) = size;

  000d8	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  000dd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR size$[rsp]
  000e2	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 499  :     if (size <= 0) {

  000e6	48 83 7c 24 68
	00		 cmp	 QWORD PTR size$[rsp], 0
  000ec	7f 0f		 jg	 SHORT $LN3@newarrayob

; 500  :         op->ob_item = NULL;

  000ee	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  000f3	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 501  :     }
; 502  :     else {

  000fb	eb 7a		 jmp	 SHORT $LN2@newarrayob
$LN3@newarrayob:

; 503  :         op->ob_item = PyMem_NEW(char, nbytes);

  000fd	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00107	48 39 44 24 20	 cmp	 QWORD PTR nbytes$[rsp], rax
  0010c	76 0b		 jbe	 SHORT $LN11@newarrayob
  0010e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv95[rsp], 0
  00117	eb 33		 jmp	 SHORT $LN12@newarrayob
$LN11@newarrayob:
  00119	e8 00 00 00 00	 call	 _Py_PXCTX
  0011e	85 c0		 test	 eax, eax
  00120	74 11		 je	 SHORT $LN9@newarrayob
  00122	48 8b 4c 24 20	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00127	e8 00 00 00 00	 call	 _PxMem_Malloc
  0012c	48 89 44 24 40	 mov	 QWORD PTR tv94[rsp], rax
  00131	eb 0f		 jmp	 SHORT $LN10@newarrayob
$LN9@newarrayob:
  00133	48 8b 4c 24 20	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00138	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0013d	48 89 44 24 40	 mov	 QWORD PTR tv94[rsp], rax
$LN10@newarrayob:
  00142	48 8b 44 24 40	 mov	 rax, QWORD PTR tv94[rsp]
  00147	48 89 44 24 38	 mov	 QWORD PTR tv95[rsp], rax
$LN12@newarrayob:
  0014c	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  00151	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv95[rsp]
  00156	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 504  :         if (op->ob_item == NULL) {

  0015a	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  0015f	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00164	75 11		 jne	 SHORT $LN1@newarrayob

; 505  :             Py_DECREF(op);

  00166	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op$[rsp]
  0016b	e8 00 00 00 00	 call	 _Py_DecRef

; 506  :             return PyErr_NoMemory();

  00170	e8 00 00 00 00	 call	 PyErr_NoMemory
  00175	eb 14		 jmp	 SHORT $LN7@newarrayob
$LN1@newarrayob:
$LN2@newarrayob:

; 507  :         }
; 508  :     }
; 509  :     op->ob_exports = 0;

  00177	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
  0017c	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 510  :     return (PyObject *) op;

  00186	48 8b 44 24 28	 mov	 rax, QWORD PTR op$[rsp]
$LN7@newarrayob:

; 511  : }

  0018b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018f	c3		 ret	 0
newarrayobject ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@HGBNJIFC@can?5only?5append?5array?5?$CInot?5?$CC?$CF?420@ ; `string'
EXTRN	PyErr_BadArgument:PROC
EXTRN	PyErr_Format:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_concat DD imagerel array_concat
	DD	imagerel array_concat+404
	DD	imagerel $unwind$array_concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_concat DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CO@HGBNJIFC@can?5only?5append?5array?5?$CInot?5?$CC?$CF?420@
CONST	SEGMENT
??_C@_0CO@HGBNJIFC@can?5only?5append?5array?5?$CInot?5?$CC?$CF?420@ DB 'c'
	DB	'an only append array (not "%.200s") to array', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_concat
_TEXT	SEGMENT
size$ = 32
np$ = 40
a$ = 64
bb$ = 72
array_concat PROC					; COMDAT

; 700  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 701  :     Py_ssize_t size;
; 702  :     arrayobject *np;
; 703  :     if (!array_Check(bb)) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  00015	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bb$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 40		 je	 SHORT $LN4@array_conc
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00027	48 8b 44 24 48	 mov	 rax, QWORD PTR bb$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 27		 jne	 SHORT $LN4@array_conc

; 704  :         PyErr_Format(PyExc_TypeError,
; 705  :              "can only append array (not \"%.200s\") to array",
; 706  :                  Py_TYPE(bb)->tp_name);

  00039	48 8b 44 24 48	 mov	 rax, QWORD PTR bb$[rsp]
  0003e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00042	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@HGBNJIFC@can?5only?5append?5array?5?$CInot?5?$CC?$CF?420@
  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00054	e8 00 00 00 00	 call	 PyErr_Format

; 707  :         return NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 2f 01 00 00	 jmp	 $LN5@array_conc
$LN4@array_conc:

; 708  :     }
; 709  : #define b ((arrayobject *)bb)
; 710  :     if (a->ob_descr != b->ob_descr) {

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00065	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bb$[rsp]
  0006a	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00071	48 39 88 80 00
	00 00		 cmp	 QWORD PTR [rax+128], rcx
  00078	74 0c		 je	 SHORT $LN3@array_conc

; 711  :         PyErr_BadArgument();

  0007a	e8 00 00 00 00	 call	 PyErr_BadArgument

; 712  :         return NULL;

  0007f	33 c0		 xor	 eax, eax
  00081	e9 09 01 00 00	 jmp	 $LN5@array_conc
$LN3@array_conc:

; 713  :     }
; 714  :     if (Py_SIZE(a) > PY_SSIZE_T_MAX - Py_SIZE(b)) {

  00086	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00090	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bb$[rsp]
  00095	48 2b 41 60	 sub	 rax, QWORD PTR [rcx+96]
  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0009e	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  000a2	7e 0a		 jle	 SHORT $LN2@array_conc

; 715  :         return PyErr_NoMemory();

  000a4	e8 00 00 00 00	 call	 PyErr_NoMemory
  000a9	e9 e1 00 00 00	 jmp	 $LN5@array_conc
$LN2@array_conc:

; 716  :     }
; 717  :     size = Py_SIZE(a) + Py_SIZE(b);

  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  000b3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000b7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bb$[rsp]
  000bc	48 03 41 60	 add	 rax, QWORD PTR [rcx+96]
  000c0	48 89 44 24 20	 mov	 QWORD PTR size$[rsp], rax

; 718  :     np = (arrayobject *) newarrayobject(&Arraytype, size, a->ob_descr);

  000c5	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  000ca	4c 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [rax+128]
  000d1	48 8b 54 24 20	 mov	 rdx, QWORD PTR size$[rsp]
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  000dd	e8 00 00 00 00	 call	 newarrayobject
  000e2	48 89 44 24 28	 mov	 QWORD PTR np$[rsp], rax

; 719  :     if (np == NULL) {

  000e7	48 83 7c 24 28
	00		 cmp	 QWORD PTR np$[rsp], 0
  000ed	75 07		 jne	 SHORT $LN1@array_conc

; 720  :         return NULL;

  000ef	33 c0		 xor	 eax, eax
  000f1	e9 99 00 00 00	 jmp	 $LN5@array_conc
$LN1@array_conc:

; 721  :     }
; 722  :     memcpy(np->ob_item, a->ob_item, Py_SIZE(a)*a->ob_descr->itemsize);

  000f6	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  000fb	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00102	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00106	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0010b	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0010f	48 0f af c8	 imul	 rcx, rax
  00113	48 8b c1	 mov	 rax, rcx
  00116	4c 8b c0	 mov	 r8, rax
  00119	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0011e	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00122	48 8b 44 24 28	 mov	 rax, QWORD PTR np$[rsp]
  00127	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0012b	e8 00 00 00 00	 call	 memcpy

; 723  :     memcpy(np->ob_item + Py_SIZE(a)*a->ob_descr->itemsize,
; 724  :            b->ob_item, Py_SIZE(b)*b->ob_descr->itemsize);

  00130	48 8b 44 24 48	 mov	 rax, QWORD PTR bb$[rsp]
  00135	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0013c	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00140	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bb$[rsp]
  00145	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00149	48 0f af c8	 imul	 rcx, rax
  0014d	48 8b c1	 mov	 rax, rcx
  00150	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00155	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0015c	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  00160	48 8b 54 24 40	 mov	 rdx, QWORD PTR a$[rsp]
  00165	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  00169	48 0f af d1	 imul	 rdx, rcx
  0016d	48 8b ca	 mov	 rcx, rdx
  00170	48 8b 54 24 28	 mov	 rdx, QWORD PTR np$[rsp]
  00175	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  00179	4c 8b c0	 mov	 r8, rax
  0017c	48 8b 44 24 48	 mov	 rax, QWORD PTR bb$[rsp]
  00181	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00185	e8 00 00 00 00	 call	 memcpy

; 725  :     return (PyObject *)np;

  0018a	48 8b 44 24 28	 mov	 rax, QWORD PTR np$[rsp]
$LN5@array_conc:

; 726  : #undef b
; 727  : }

  0018f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00193	c3		 ret	 0
array_concat ENDP
_TEXT	ENDS
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_repeat DD imagerel array_repeat
	DD	imagerel array_repeat+793
	DD	imagerel $unwind$array_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_repeat DD 021101H
	DD	0150111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_repeat
_TEXT	SEGMENT
newbytes$ = 32
size$ = 40
oldbytes$ = 48
np$ = 56
done$21020 = 64
t_$21026 = 72
s_$21028 = 80
i_$21024 = 88
n_$21025 = 96
ncopy$21038 = 104
t_$21044 = 112
s_$21046 = 120
i_$21042 = 128
n_$21043 = 136
tv141 = 144
a$ = 176
n$ = 184
array_repeat PROC					; COMDAT

; 731  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 732  :     Py_ssize_t size;
; 733  :     arrayobject *np;
; 734  :     Py_ssize_t oldbytes, newbytes;
; 735  :     if (n < 0)

  00011	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  0001a	7d 0c		 jge	 SHORT $LN24@array_repe

; 736  :         n = 0;

  0001c	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR n$[rsp], 0
$LN24@array_repe:

; 737  :     if ((Py_SIZE(a) != 0) && (n > PY_SSIZE_T_MAX / Py_SIZE(a))) {

  00028	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00030	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00035	74 2c		 je	 SHORT $LN23@array_repe
  00037	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00041	48 99		 cdq
  00043	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0004b	48 f7 79 60	 idiv	 QWORD PTR [rcx+96]
  0004f	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR n$[rsp], rax
  00057	7e 0a		 jle	 SHORT $LN23@array_repe

; 738  :         return PyErr_NoMemory();

  00059	e8 00 00 00 00	 call	 PyErr_NoMemory
  0005e	e9 ae 02 00 00	 jmp	 $LN25@array_repe
$LN23@array_repe:

; 739  :     }
; 740  :     size = Py_SIZE(a) * n;

  00063	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0006b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006f	48 0f af 84 24
	b8 00 00 00	 imul	 rax, QWORD PTR n$[rsp]
  00078	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 741  :     np = (arrayobject *) newarrayobject(&Arraytype, size, a->ob_descr);

  0007d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00085	4c 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [rax+128]
  0008c	48 8b 54 24 28	 mov	 rdx, QWORD PTR size$[rsp]
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  00098	e8 00 00 00 00	 call	 newarrayobject
  0009d	48 89 44 24 38	 mov	 QWORD PTR np$[rsp], rax

; 742  :     if (np == NULL)

  000a2	48 83 7c 24 38
	00		 cmp	 QWORD PTR np$[rsp], 0
  000a8	75 07		 jne	 SHORT $LN22@array_repe

; 743  :         return NULL;

  000aa	33 c0		 xor	 eax, eax
  000ac	e9 60 02 00 00	 jmp	 $LN25@array_repe
$LN22@array_repe:

; 744  :     if (n == 0)

  000b1	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  000ba	75 0a		 jne	 SHORT $LN21@array_repe

; 745  :         return (PyObject *)np;

  000bc	48 8b 44 24 38	 mov	 rax, QWORD PTR np$[rsp]
  000c1	e9 4b 02 00 00	 jmp	 $LN25@array_repe
$LN21@array_repe:

; 746  :     oldbytes = Py_SIZE(a) * a->ob_descr->itemsize;

  000c6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000ce	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000d5	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000d9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000e1	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000e5	48 0f af c8	 imul	 rcx, rax
  000e9	48 8b c1	 mov	 rax, rcx
  000ec	48 89 44 24 30	 mov	 QWORD PTR oldbytes$[rsp], rax

; 747  :     newbytes = oldbytes * n;

  000f1	48 8b 44 24 30	 mov	 rax, QWORD PTR oldbytes$[rsp]
  000f6	48 0f af 84 24
	b8 00 00 00	 imul	 rax, QWORD PTR n$[rsp]
  000ff	48 89 44 24 20	 mov	 QWORD PTR newbytes$[rsp], rax

; 748  :     /* this follows the code in unicode_repeat */
; 749  :     if (oldbytes == 1) {

  00104	48 83 7c 24 30
	01		 cmp	 QWORD PTR oldbytes$[rsp], 1
  0010a	75 29		 jne	 SHORT $LN20@array_repe

; 750  :         memset(np->ob_item, a->ob_item[0], newbytes);

  0010c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00114	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00118	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0011b	4c 8b 44 24 20	 mov	 r8, QWORD PTR newbytes$[rsp]
  00120	8b d0		 mov	 edx, eax
  00122	48 8b 44 24 38	 mov	 rax, QWORD PTR np$[rsp]
  00127	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0012b	e8 00 00 00 00	 call	 memset

; 751  :     } else {

  00130	e9 d7 01 00 00	 jmp	 $LN19@array_repe
$LN20@array_repe:

; 752  :         Py_ssize_t done = oldbytes;

  00135	48 8b 44 24 30	 mov	 rax, QWORD PTR oldbytes$[rsp]
  0013a	48 89 44 24 40	 mov	 QWORD PTR done$21020[rsp], rax
$LN18@array_repe:

; 753  :         Py_MEMCPY(np->ob_item, a->ob_item, oldbytes);

  0013f	48 8b 44 24 30	 mov	 rax, QWORD PTR oldbytes$[rsp]
  00144	48 89 44 24 60	 mov	 QWORD PTR n_$21025[rsp], rax
  00149	48 8b 44 24 38	 mov	 rax, QWORD PTR np$[rsp]
  0014e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00152	48 89 44 24 48	 mov	 QWORD PTR t_$21026[rsp], rax
  00157	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0015f	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00163	48 89 44 24 50	 mov	 QWORD PTR s_$21028[rsp], rax
  00168	48 83 7c 24 60
	10		 cmp	 QWORD PTR n_$21025[rsp], 16
  0016e	72 16		 jb	 SHORT $LN15@array_repe
  00170	4c 8b 44 24 60	 mov	 r8, QWORD PTR n_$21025[rsp]
  00175	48 8b 54 24 50	 mov	 rdx, QWORD PTR s_$21028[rsp]
  0017a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR t_$21026[rsp]
  0017f	e8 00 00 00 00	 call	 memcpy
  00184	eb 4b		 jmp	 SHORT $LN14@array_repe
$LN15@array_repe:
  00186	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR i_$21024[rsp], 0
  0018f	eb 0d		 jmp	 SHORT $LN13@array_repe
$LN12@array_repe:
  00191	48 8b 44 24 58	 mov	 rax, QWORD PTR i_$21024[rsp]
  00196	48 ff c0	 inc	 rax
  00199	48 89 44 24 58	 mov	 QWORD PTR i_$21024[rsp], rax
$LN13@array_repe:
  0019e	48 8b 44 24 60	 mov	 rax, QWORD PTR n_$21025[rsp]
  001a3	48 39 44 24 58	 cmp	 QWORD PTR i_$21024[rsp], rax
  001a8	73 27		 jae	 SHORT $LN11@array_repe
  001aa	48 8b 44 24 58	 mov	 rax, QWORD PTR i_$21024[rsp]
  001af	48 8b 4c 24 48	 mov	 rcx, QWORD PTR t_$21026[rsp]
  001b4	48 03 c8	 add	 rcx, rax
  001b7	48 8b c1	 mov	 rax, rcx
  001ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR i_$21024[rsp]
  001bf	48 8b 54 24 50	 mov	 rdx, QWORD PTR s_$21028[rsp]
  001c4	48 03 d1	 add	 rdx, rcx
  001c7	48 8b ca	 mov	 rcx, rdx
  001ca	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  001cd	88 08		 mov	 BYTE PTR [rax], cl
  001cf	eb c0		 jmp	 SHORT $LN12@array_repe
$LN11@array_repe:
$LN14@array_repe:
  001d1	33 c0		 xor	 eax, eax
  001d3	85 c0		 test	 eax, eax
  001d5	0f 85 64 ff ff
	ff		 jne	 $LN18@array_repe
$LN10@array_repe:

; 754  :         while (done < newbytes) {

  001db	48 8b 44 24 20	 mov	 rax, QWORD PTR newbytes$[rsp]
  001e0	48 39 44 24 40	 cmp	 QWORD PTR done$21020[rsp], rax
  001e5	0f 8d 21 01 00
	00		 jge	 $LN9@array_repe

; 755  :             Py_ssize_t ncopy = (done <= newbytes-done) ? done : newbytes-done;

  001eb	48 8b 44 24 40	 mov	 rax, QWORD PTR done$21020[rsp]
  001f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newbytes$[rsp]
  001f5	48 2b c8	 sub	 rcx, rax
  001f8	48 8b c1	 mov	 rax, rcx
  001fb	48 39 44 24 40	 cmp	 QWORD PTR done$21020[rsp], rax
  00200	7f 0f		 jg	 SHORT $LN27@array_repe
  00202	48 8b 44 24 40	 mov	 rax, QWORD PTR done$21020[rsp]
  00207	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv141[rsp], rax
  0020f	eb 18		 jmp	 SHORT $LN28@array_repe
$LN27@array_repe:
  00211	48 8b 44 24 40	 mov	 rax, QWORD PTR done$21020[rsp]
  00216	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newbytes$[rsp]
  0021b	48 2b c8	 sub	 rcx, rax
  0021e	48 8b c1	 mov	 rax, rcx
  00221	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv141[rsp], rax
$LN28@array_repe:
  00229	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv141[rsp]
  00231	48 89 44 24 68	 mov	 QWORD PTR ncopy$21038[rsp], rax
$LN8@array_repe:

; 756  :             Py_MEMCPY(np->ob_item+done, np->ob_item, ncopy);

  00236	48 8b 44 24 68	 mov	 rax, QWORD PTR ncopy$21038[rsp]
  0023b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR n_$21043[rsp], rax
  00243	48 8b 44 24 38	 mov	 rax, QWORD PTR np$[rsp]
  00248	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0024c	48 03 44 24 40	 add	 rax, QWORD PTR done$21020[rsp]
  00251	48 89 44 24 70	 mov	 QWORD PTR t_$21044[rsp], rax
  00256	48 8b 44 24 38	 mov	 rax, QWORD PTR np$[rsp]
  0025b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0025f	48 89 44 24 78	 mov	 QWORD PTR s_$21046[rsp], rax
  00264	48 83 bc 24 88
	00 00 00 10	 cmp	 QWORD PTR n_$21043[rsp], 16
  0026d	72 19		 jb	 SHORT $LN5@array_repe
  0026f	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR n_$21043[rsp]
  00277	48 8b 54 24 78	 mov	 rdx, QWORD PTR s_$21046[rsp]
  0027c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR t_$21044[rsp]
  00281	e8 00 00 00 00	 call	 memcpy
  00286	eb 60		 jmp	 SHORT $LN4@array_repe
$LN5@array_repe:
  00288	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i_$21042[rsp], 0
  00294	eb 13		 jmp	 SHORT $LN3@array_repe
$LN2@array_repe:
  00296	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR i_$21042[rsp]
  0029e	48 ff c0	 inc	 rax
  002a1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR i_$21042[rsp], rax
$LN3@array_repe:
  002a9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR n_$21043[rsp]
  002b1	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR i_$21042[rsp], rax
  002b9	73 2d		 jae	 SHORT $LN1@array_repe
  002bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR i_$21042[rsp]
  002c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR t_$21044[rsp]
  002c8	48 03 c8	 add	 rcx, rax
  002cb	48 8b c1	 mov	 rax, rcx
  002ce	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR i_$21042[rsp]
  002d6	48 8b 54 24 78	 mov	 rdx, QWORD PTR s_$21046[rsp]
  002db	48 03 d1	 add	 rdx, rcx
  002de	48 8b ca	 mov	 rcx, rdx
  002e1	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002e4	88 08		 mov	 BYTE PTR [rax], cl
  002e6	eb ae		 jmp	 SHORT $LN2@array_repe
$LN1@array_repe:
$LN4@array_repe:
  002e8	33 c0		 xor	 eax, eax
  002ea	85 c0		 test	 eax, eax
  002ec	0f 85 44 ff ff
	ff		 jne	 $LN8@array_repe

; 757  :             done += ncopy;

  002f2	48 8b 44 24 68	 mov	 rax, QWORD PTR ncopy$21038[rsp]
  002f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR done$21020[rsp]
  002fc	48 03 c8	 add	 rcx, rax
  002ff	48 8b c1	 mov	 rax, rcx
  00302	48 89 44 24 40	 mov	 QWORD PTR done$21020[rsp], rax

; 758  :         }

  00307	e9 cf fe ff ff	 jmp	 $LN10@array_repe
$LN9@array_repe:
$LN19@array_repe:

; 759  :     }
; 760  :     return (PyObject *)np;

  0030c	48 8b 44 24 38	 mov	 rax, QWORD PTR np$[rsp]
$LN25@array_repe:

; 761  : }

  00311	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00318	c3		 ret	 0
array_repeat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@DDILIBCI@array?5assignment?5index?5out?5of?5ra@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_ass_item DD imagerel array_ass_item
	DD	imagerel array_ass_item+145
	DD	imagerel $unwind$array_ass_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_ass_item DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_0CE@DDILIBCI@array?5assignment?5index?5out?5of?5ra@
CONST	SEGMENT
??_C@_0CE@DDILIBCI@array?5assignment?5index?5out?5of?5ra@ DB 'array assig'
	DB	'nment index out of range', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_ass_item
_TEXT	SEGMENT
a$ = 48
i$ = 56
v$ = 64
array_ass_item PROC					; COMDAT

; 838  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 839  :     if (i < 0 || i >= Py_SIZE(a)) {

  00013	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  00019	7c 10		 jl	 SHORT $LN2@array_ass_
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00020	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00024	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00029	7c 1a		 jl	 SHORT $LN3@array_ass_
$LN2@array_ass_:

; 840  :         PyErr_SetString(PyExc_IndexError,
; 841  :                          "array assignment index out of range");

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@DDILIBCI@array?5assignment?5index?5out?5of?5ra@
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00039	e8 00 00 00 00	 call	 PyErr_SetString

; 842  :         return -1;

  0003e	b8 ff ff ff ff	 mov	 eax, -1
  00043	eb 47		 jmp	 SHORT $LN4@array_ass_
$LN3@array_ass_:

; 843  :     }
; 844  :     if (v == NULL)

  00045	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$[rsp], 0
  0004b	75 21		 jne	 SHORT $LN1@array_ass_

; 845  :         return array_ass_slice(a, i, i+1, v);

  0004d	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00052	48 ff c0	 inc	 rax
  00055	4c 8b 4c 24 40	 mov	 r9, QWORD PTR v$[rsp]
  0005a	4c 8b c0	 mov	 r8, rax
  0005d	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  00062	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00067	e8 00 00 00 00	 call	 array_ass_slice
  0006c	eb 1e		 jmp	 SHORT $LN4@array_ass_
$LN1@array_ass_:

; 846  :     return (*a->ob_descr->setitem)(a, i, v);

  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00073	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0007a	4c 8b 44 24 40	 mov	 r8, QWORD PTR v$[rsp]
  0007f	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  00084	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00089	ff 50 10	 call	 QWORD PTR [rax+16]
$LN4@array_ass_:

; 847  : }

  0008c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00090	c3		 ret	 0
array_ass_item ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@ ; `string'
PUBLIC	??_C@_0DE@JBAHFOA@can?5only?5assign?5array?5?$CInot?5?$CC?$CF?420@ ; `string'
EXTRN	__imp_memmove:PROC
EXTRN	PyExc_BufferError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_ass_slice DD imagerel array_ass_slice
	DD	imagerel array_ass_slice+1016
	DD	imagerel $unwind$array_ass_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_ass_slice DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT ??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@
CONST	SEGMENT
??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@ DB 'cannot res'
	DB	'ize an array that is exporting buffers', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@JBAHFOA@can?5only?5assign?5array?5?$CInot?5?$CC?$CF?420@
CONST	SEGMENT
??_C@_0DE@JBAHFOA@can?5only?5assign?5array?5?$CInot?5?$CC?$CF?420@ DB 'ca'
	DB	'n only assign array (not "%.200s") to array slice', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_ass_slice
_TEXT	SEGMENT
n$ = 32
d$ = 40
item$ = 48
ret$21079 = 56
tv162 = 64
tv195 = 72
a$ = 96
ilow$ = 104
ihigh$ = 112
v$ = 120
array_ass_slice PROC					; COMDAT

; 765  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 766  :     char *item;
; 767  :     Py_ssize_t n; /* Size of replacement array */
; 768  :     Py_ssize_t d; /* Change in size */
; 769  : #define b ((arrayobject *)v)
; 770  :     if (v == NULL)

  00018	48 83 7c 24 78
	00		 cmp	 QWORD PTR v$[rsp], 0
  0001e	75 0e		 jne	 SHORT $LN22@array_ass_@2

; 771  :         n = 0;

  00020	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0
  00029	e9 f6 00 00 00	 jmp	 $LN21@array_ass_@2
$LN22@array_ass_@2:

; 772  :     else if (array_Check(v)) {

  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  00035	48 8b 4c 24 78	 mov	 rcx, QWORD PTR v$[rsp]
  0003a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003e	74 1d		 je	 SHORT $LN19@array_ass_@2
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00047	48 8b 44 24 78	 mov	 rax, QWORD PTR v$[rsp]
  0004c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00050	e8 00 00 00 00	 call	 PyType_IsSubtype
  00055	85 c0		 test	 eax, eax
  00057	0f 84 9d 00 00
	00		 je	 $LN20@array_ass_@2
$LN19@array_ass_@2:

; 773  :         n = Py_SIZE(b);

  0005d	48 8b 44 24 78	 mov	 rax, QWORD PTR v$[rsp]
  00062	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00066	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 774  :         if (a == b) {

  0006b	48 8b 44 24 78	 mov	 rax, QWORD PTR v$[rsp]
  00070	48 39 44 24 60	 cmp	 QWORD PTR a$[rsp], rax
  00075	75 58		 jne	 SHORT $LN18@array_ass_@2

; 775  :             /* Special case "a[i:j] = a" -- copy b first */
; 776  :             int ret;
; 777  :             v = array_slice(b, 0, n);

  00077	4c 8b 44 24 20	 mov	 r8, QWORD PTR n$[rsp]
  0007c	33 d2		 xor	 edx, edx
  0007e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR v$[rsp]
  00083	e8 00 00 00 00	 call	 array_slice
  00088	48 89 44 24 78	 mov	 QWORD PTR v$[rsp], rax

; 778  :             if (!v)

  0008d	48 83 7c 24 78
	00		 cmp	 QWORD PTR v$[rsp], 0
  00093	75 0a		 jne	 SHORT $LN17@array_ass_@2

; 779  :                 return -1;

  00095	b8 ff ff ff ff	 mov	 eax, -1
  0009a	e9 54 03 00 00	 jmp	 $LN23@array_ass_@2
$LN17@array_ass_@2:

; 780  :             ret = array_ass_slice(a, ilow, ihigh, v);

  0009f	4c 8b 4c 24 78	 mov	 r9, QWORD PTR v$[rsp]
  000a4	4c 8b 44 24 70	 mov	 r8, QWORD PTR ihigh$[rsp]
  000a9	48 8b 54 24 68	 mov	 rdx, QWORD PTR ilow$[rsp]
  000ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  000b3	e8 00 00 00 00	 call	 array_ass_slice
  000b8	89 44 24 38	 mov	 DWORD PTR ret$21079[rsp], eax

; 781  :             Py_DECREF(v);

  000bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR v$[rsp]
  000c1	e8 00 00 00 00	 call	 _Py_DecRef

; 782  :             return ret;

  000c6	8b 44 24 38	 mov	 eax, DWORD PTR ret$21079[rsp]
  000ca	e9 24 03 00 00	 jmp	 $LN23@array_ass_@2
$LN18@array_ass_@2:

; 783  :         }
; 784  :         if (b->ob_descr != a->ob_descr) {

  000cf	48 8b 44 24 78	 mov	 rax, QWORD PTR v$[rsp]
  000d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  000d9	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000e0	48 39 88 80 00
	00 00		 cmp	 QWORD PTR [rax+128], rcx
  000e7	74 0f		 je	 SHORT $LN16@array_ass_@2

; 785  :             PyErr_BadArgument();

  000e9	e8 00 00 00 00	 call	 PyErr_BadArgument

; 786  :             return -1;

  000ee	b8 ff ff ff ff	 mov	 eax, -1
  000f3	e9 fb 02 00 00	 jmp	 $LN23@array_ass_@2
$LN16@array_ass_@2:

; 787  :         }
; 788  :     }
; 789  :     else {

  000f8	eb 2a		 jmp	 SHORT $LN15@array_ass_@2
$LN20@array_ass_@2:

; 790  :         PyErr_Format(PyExc_TypeError,
; 791  :          "can only assign array (not \"%.200s\") to array slice",
; 792  :                          Py_TYPE(v)->tp_name);

  000fa	48 8b 44 24 78	 mov	 rax, QWORD PTR v$[rsp]
  000ff	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00103	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@JBAHFOA@can?5only?5assign?5array?5?$CInot?5?$CC?$CF?420@
  0010e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00115	e8 00 00 00 00	 call	 PyErr_Format

; 793  :         return -1;

  0011a	b8 ff ff ff ff	 mov	 eax, -1
  0011f	e9 cf 02 00 00	 jmp	 $LN23@array_ass_@2
$LN15@array_ass_@2:
$LN21@array_ass_@2:

; 794  :     }
; 795  :     if (ilow < 0)

  00124	48 83 7c 24 68
	00		 cmp	 QWORD PTR ilow$[rsp], 0
  0012a	7d 0b		 jge	 SHORT $LN14@array_ass_@2

; 796  :         ilow = 0;

  0012c	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR ilow$[rsp], 0
  00135	eb 1e		 jmp	 SHORT $LN13@array_ass_@2
$LN14@array_ass_@2:

; 797  :     else if (ilow > Py_SIZE(a))

  00137	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0013c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00140	48 39 44 24 68	 cmp	 QWORD PTR ilow$[rsp], rax
  00145	7e 0e		 jle	 SHORT $LN12@array_ass_@2

; 798  :         ilow = Py_SIZE(a);

  00147	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0014c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00150	48 89 44 24 68	 mov	 QWORD PTR ilow$[rsp], rax
$LN12@array_ass_@2:
$LN13@array_ass_@2:

; 799  :     if (ihigh < 0)

  00155	48 83 7c 24 70
	00		 cmp	 QWORD PTR ihigh$[rsp], 0
  0015b	7d 09		 jge	 SHORT $LN11@array_ass_@2

; 800  :         ihigh = 0;

  0015d	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR ihigh$[rsp], 0
$LN11@array_ass_@2:

; 801  :     if (ihigh < ilow)

  00166	48 8b 44 24 68	 mov	 rax, QWORD PTR ilow$[rsp]
  0016b	48 39 44 24 70	 cmp	 QWORD PTR ihigh$[rsp], rax
  00170	7d 0c		 jge	 SHORT $LN10@array_ass_@2

; 802  :         ihigh = ilow;

  00172	48 8b 44 24 68	 mov	 rax, QWORD PTR ilow$[rsp]
  00177	48 89 44 24 70	 mov	 QWORD PTR ihigh$[rsp], rax
  0017c	eb 1e		 jmp	 SHORT $LN9@array_ass_@2
$LN10@array_ass_@2:

; 803  :     else if (ihigh > Py_SIZE(a))

  0017e	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00183	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00187	48 39 44 24 70	 cmp	 QWORD PTR ihigh$[rsp], rax
  0018c	7e 0e		 jle	 SHORT $LN8@array_ass_@2

; 804  :         ihigh = Py_SIZE(a);

  0018e	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00193	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00197	48 89 44 24 70	 mov	 QWORD PTR ihigh$[rsp], rax
$LN8@array_ass_@2:
$LN9@array_ass_@2:

; 805  :     item = a->ob_item;

  0019c	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  001a1	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  001a5	48 89 44 24 30	 mov	 QWORD PTR item$[rsp], rax

; 806  :     d = n - (ihigh-ilow);

  001aa	48 8b 44 24 68	 mov	 rax, QWORD PTR ilow$[rsp]
  001af	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ihigh$[rsp]
  001b4	48 2b c8	 sub	 rcx, rax
  001b7	48 8b c1	 mov	 rax, rcx
  001ba	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  001bf	48 2b c8	 sub	 rcx, rax
  001c2	48 8b c1	 mov	 rax, rcx
  001c5	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax

; 807  :     /* Issue #4509: If the array has exported buffers and the slice
; 808  :        assignment would change the size of the array, fail early to make
; 809  :        sure we don't modify it. */
; 810  :     if (d != 0 && a->ob_exports > 0) {

  001ca	48 83 7c 24 28
	00		 cmp	 QWORD PTR d$[rsp], 0
  001d0	74 2b		 je	 SHORT $LN7@array_ass_@2
  001d2	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  001d7	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  001de	7e 1d		 jle	 SHORT $LN7@array_ass_@2

; 811  :         PyErr_SetString(PyExc_BufferError,
; 812  :             "cannot resize an array that is exporting buffers");

  001e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@
  001e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  001ee	e8 00 00 00 00	 call	 PyErr_SetString

; 813  :         return -1;

  001f3	b8 ff ff ff ff	 mov	 eax, -1
  001f8	e9 f6 01 00 00	 jmp	 $LN23@array_ass_@2
$LN7@array_ass_@2:

; 814  :     }
; 815  :     if (d < 0) { /* Delete -d items */

  001fd	48 83 7c 24 28
	00		 cmp	 QWORD PTR d$[rsp], 0
  00203	0f 8d c3 00 00
	00		 jge	 $LN6@array_ass_@2

; 816  :         memmove(item + (ihigh+d)*a->ob_descr->itemsize,
; 817  :             item + ihigh*a->ob_descr->itemsize,
; 818  :             (Py_SIZE(a)-ihigh)*a->ob_descr->itemsize);

  00209	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0020e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ihigh$[rsp]
  00213	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00217	48 2b c1	 sub	 rax, rcx
  0021a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  0021f	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00226	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  0022a	48 0f af c1	 imul	 rax, rcx
  0022e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00233	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0023a	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  0023e	48 8b 54 24 70	 mov	 rdx, QWORD PTR ihigh$[rsp]
  00243	48 0f af d1	 imul	 rdx, rcx
  00247	48 8b ca	 mov	 rcx, rdx
  0024a	48 8b 54 24 30	 mov	 rdx, QWORD PTR item$[rsp]
  0024f	48 03 d1	 add	 rdx, rcx
  00252	48 8b ca	 mov	 rcx, rdx
  00255	48 8b 54 24 28	 mov	 rdx, QWORD PTR d$[rsp]
  0025a	4c 8b 44 24 70	 mov	 r8, QWORD PTR ihigh$[rsp]
  0025f	4c 03 c2	 add	 r8, rdx
  00262	49 8b d0	 mov	 rdx, r8
  00265	4c 8b 44 24 60	 mov	 r8, QWORD PTR a$[rsp]
  0026a	4d 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [r8+128]
  00271	4d 63 40 04	 movsxd	 r8, DWORD PTR [r8+4]
  00275	49 0f af d0	 imul	 rdx, r8
  00279	4c 8b 44 24 30	 mov	 r8, QWORD PTR item$[rsp]
  0027e	4c 03 c2	 add	 r8, rdx
  00281	49 8b d0	 mov	 rdx, r8
  00284	48 89 54 24 40	 mov	 QWORD PTR tv162[rsp], rdx
  00289	4c 8b c0	 mov	 r8, rax
  0028c	48 8b d1	 mov	 rdx, rcx
  0028f	48 8b 44 24 40	 mov	 rax, QWORD PTR tv162[rsp]
  00294	48 8b c8	 mov	 rcx, rax
  00297	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 819  :         if (array_resize(a, Py_SIZE(a) + d) == -1)

  0029d	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  002a2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002a6	48 03 44 24 28	 add	 rax, QWORD PTR d$[rsp]
  002ab	48 8b d0	 mov	 rdx, rax
  002ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  002b3	e8 00 00 00 00	 call	 array_resize
  002b8	83 f8 ff	 cmp	 eax, -1
  002bb	75 0a		 jne	 SHORT $LN5@array_ass_@2

; 820  :             return -1;

  002bd	b8 ff ff ff ff	 mov	 eax, -1
  002c2	e9 2c 01 00 00	 jmp	 $LN23@array_ass_@2
$LN5@array_ass_@2:

; 821  :     }
; 822  :     else if (d > 0) { /* Insert d items */

  002c7	e9 c9 00 00 00	 jmp	 $LN4@array_ass_@2
$LN6@array_ass_@2:
  002cc	48 83 7c 24 28
	00		 cmp	 QWORD PTR d$[rsp], 0
  002d2	0f 8e bd 00 00
	00		 jle	 $LN3@array_ass_@2

; 823  :         if (array_resize(a, Py_SIZE(a) + d))

  002d8	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  002dd	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002e1	48 03 44 24 28	 add	 rax, QWORD PTR d$[rsp]
  002e6	48 8b d0	 mov	 rdx, rax
  002e9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  002ee	e8 00 00 00 00	 call	 array_resize
  002f3	85 c0		 test	 eax, eax
  002f5	74 0a		 je	 SHORT $LN2@array_ass_@2

; 824  :             return -1;

  002f7	b8 ff ff ff ff	 mov	 eax, -1
  002fc	e9 f2 00 00 00	 jmp	 $LN23@array_ass_@2
$LN2@array_ass_@2:

; 825  :         memmove(item + (ihigh+d)*a->ob_descr->itemsize,
; 826  :             item + ihigh*a->ob_descr->itemsize,
; 827  :             (Py_SIZE(a)-ihigh)*a->ob_descr->itemsize);

  00301	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00306	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ihigh$[rsp]
  0030b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0030f	48 2b c1	 sub	 rax, rcx
  00312	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00317	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0031e	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  00322	48 0f af c1	 imul	 rax, rcx
  00326	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  0032b	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00332	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  00336	48 8b 54 24 70	 mov	 rdx, QWORD PTR ihigh$[rsp]
  0033b	48 0f af d1	 imul	 rdx, rcx
  0033f	48 8b ca	 mov	 rcx, rdx
  00342	48 8b 54 24 30	 mov	 rdx, QWORD PTR item$[rsp]
  00347	48 03 d1	 add	 rdx, rcx
  0034a	48 8b ca	 mov	 rcx, rdx
  0034d	48 8b 54 24 28	 mov	 rdx, QWORD PTR d$[rsp]
  00352	4c 8b 44 24 70	 mov	 r8, QWORD PTR ihigh$[rsp]
  00357	4c 03 c2	 add	 r8, rdx
  0035a	49 8b d0	 mov	 rdx, r8
  0035d	4c 8b 44 24 60	 mov	 r8, QWORD PTR a$[rsp]
  00362	4d 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [r8+128]
  00369	4d 63 40 04	 movsxd	 r8, DWORD PTR [r8+4]
  0036d	49 0f af d0	 imul	 rdx, r8
  00371	4c 8b 44 24 30	 mov	 r8, QWORD PTR item$[rsp]
  00376	4c 03 c2	 add	 r8, rdx
  00379	49 8b d0	 mov	 rdx, r8
  0037c	48 89 54 24 48	 mov	 QWORD PTR tv195[rsp], rdx
  00381	4c 8b c0	 mov	 r8, rax
  00384	48 8b d1	 mov	 rdx, rcx
  00387	48 8b 44 24 48	 mov	 rax, QWORD PTR tv195[rsp]
  0038c	48 8b c8	 mov	 rcx, rax
  0038f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN3@array_ass_@2:
$LN4@array_ass_@2:

; 828  :     }
; 829  :     if (n > 0)

  00395	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  0039b	7e 54		 jle	 SHORT $LN1@array_ass_@2

; 830  :         memcpy(item + ilow*a->ob_descr->itemsize, b->ob_item,
; 831  :                n*b->ob_descr->itemsize);

  0039d	48 8b 44 24 78	 mov	 rax, QWORD PTR v$[rsp]
  003a2	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  003a9	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  003ad	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  003b2	48 0f af c8	 imul	 rcx, rax
  003b6	48 8b c1	 mov	 rax, rcx
  003b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  003be	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  003c5	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  003c9	48 8b 54 24 68	 mov	 rdx, QWORD PTR ilow$[rsp]
  003ce	48 0f af d1	 imul	 rdx, rcx
  003d2	48 8b ca	 mov	 rcx, rdx
  003d5	48 8b 54 24 30	 mov	 rdx, QWORD PTR item$[rsp]
  003da	48 03 d1	 add	 rdx, rcx
  003dd	48 8b ca	 mov	 rcx, rdx
  003e0	4c 8b c0	 mov	 r8, rax
  003e3	48 8b 44 24 78	 mov	 rax, QWORD PTR v$[rsp]
  003e8	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  003ec	e8 00 00 00 00	 call	 memcpy
$LN1@array_ass_@2:

; 832  :     return 0;

  003f1	33 c0		 xor	 eax, eax
$LN23@array_ass_@2:

; 833  : #undef b
; 834  : }

  003f3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003f7	c3		 ret	 0
array_ass_slice ENDP
_TEXT	ENDS
EXTRN	_PyMem_DebugRealloc:PROC
EXTRN	_PxMem_Realloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_resize DD imagerel array_resize
	DD	imagerel array_resize+637
	DD	imagerel $unwind$array_resize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_resize DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_resize
_TEXT	SEGMENT
_new_size$ = 32
items$ = 40
tv85 = 48
tv92 = 52
tv131 = 56
tv156 = 64
tv155 = 72
self$ = 96
newsize$ = 104
array_resize PROC					; COMDAT

; 50   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 51   :     char *items;
; 52   :     size_t _new_size;
; 53   : 
; 54   :     if (self->ob_exports > 0 && newsize != Py_SIZE(self)) {

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00013	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  0001a	7e 2d		 jle	 SHORT $LN6@array_resi
  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00021	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00025	48 39 44 24 68	 cmp	 QWORD PTR newsize$[rsp], rax
  0002a	74 1d		 je	 SHORT $LN6@array_resi

; 55   :         PyErr_SetString(PyExc_BufferError,
; 56   :             "cannot resize an array that is exporting buffers");

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@
  00033	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0003a	e8 00 00 00 00	 call	 PyErr_SetString

; 57   :         return -1;

  0003f	b8 ff ff ff ff	 mov	 eax, -1
  00044	e9 2f 02 00 00	 jmp	 $LN7@array_resi
$LN6@array_resi:

; 58   :     }
; 59   : 
; 60   :     /* Bypass realloc() when a previous overallocation is large enough
; 61   :        to accommodate the newsize.  If the newsize is 16 smaller than the
; 62   :        current size, then proceed with the realloc() to shrink the array.
; 63   :     */
; 64   : 
; 65   :     if (self->allocated >= newsize &&
; 66   :         Py_SIZE(self) < newsize + 16 &&
; 67   :         self->ob_item != NULL) {

  00049	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR newsize$[rsp]
  00053	48 39 48 78	 cmp	 QWORD PTR [rax+120], rcx
  00057	7c 35		 jl	 SHORT $LN5@array_resi
  00059	48 8b 44 24 68	 mov	 rax, QWORD PTR newsize$[rsp]
  0005e	48 83 c0 10	 add	 rax, 16
  00062	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00067	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  0006b	7d 21		 jge	 SHORT $LN5@array_resi
  0006d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00072	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00077	74 15		 je	 SHORT $LN5@array_resi

; 68   :         Py_SIZE(self) = newsize;

  00079	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0007e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR newsize$[rsp]
  00083	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 69   :         return 0;

  00087	33 c0		 xor	 eax, eax
  00089	e9 ea 01 00 00	 jmp	 $LN7@array_resi
$LN5@array_resi:

; 70   :     }
; 71   : 
; 72   :     if (newsize == 0) {

  0008e	48 83 7c 24 68
	00		 cmp	 QWORD PTR newsize$[rsp], 0
  00094	75 65		 jne	 SHORT $LN4@array_resi

; 73   :         PyMem_FREE(self->ob_item);

  00096	e8 00 00 00 00	 call	 _Py_PXCTX
  0009b	85 c0		 test	 eax, eax
  0009d	74 18		 je	 SHORT $LN9@array_resi
  0009f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000a4	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000a8	e8 00 00 00 00	 call	 _PxMem_Free
  000ad	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
  000b5	eb 16		 jmp	 SHORT $LN10@array_resi
$LN9@array_resi:
  000b7	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000bc	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000c0	e8 00 00 00 00	 call	 _PyMem_DebugFree
  000c5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN10@array_resi:

; 74   :         self->ob_item = NULL;

  000cd	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000d2	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 75   :         Py_SIZE(self) = 0;

  000da	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000df	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 76   :         self->allocated = 0;

  000e7	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000ec	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 77   :         return 0;

  000f4	33 c0		 xor	 eax, eax
  000f6	e9 7d 01 00 00	 jmp	 $LN7@array_resi
$LN4@array_resi:

; 78   :     }
; 79   : 
; 80   :     /* This over-allocates proportional to the array size, making room
; 81   :      * for additional growth.  The over-allocation is mild, but is
; 82   :      * enough to give linear-time amortized behavior over a long
; 83   :      * sequence of appends() in the presence of a poorly-performing
; 84   :      * system realloc().
; 85   :      * The growth pattern is:  0, 4, 8, 16, 25, 34, 46, 56, 67, 79, ...
; 86   :      * Note, the pattern starts out the same as for lists but then
; 87   :      * grows at a smaller rate so that larger arrays only overallocate
; 88   :      * by about 1/16th -- this is done because arrays are presumed to be more
; 89   :      * memory critical.
; 90   :      */
; 91   : 
; 92   :     _new_size = (newsize >> 4) + (Py_SIZE(self) < 8 ? 3 : 7) + newsize;

  000fb	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00100	48 83 78 60 08	 cmp	 QWORD PTR [rax+96], 8
  00105	7d 0a		 jge	 SHORT $LN11@array_resi
  00107	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv92[rsp], 3
  0010f	eb 08		 jmp	 SHORT $LN12@array_resi
$LN11@array_resi:
  00111	c7 44 24 34 07
	00 00 00	 mov	 DWORD PTR tv92[rsp], 7
$LN12@array_resi:
  00119	48 8b 44 24 68	 mov	 rax, QWORD PTR newsize$[rsp]
  0011e	48 c1 f8 04	 sar	 rax, 4
  00122	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR tv92[rsp]
  00127	48 8b 54 24 68	 mov	 rdx, QWORD PTR newsize$[rsp]
  0012c	48 03 d0	 add	 rdx, rax
  0012f	48 8b c2	 mov	 rax, rdx
  00132	48 03 c8	 add	 rcx, rax
  00135	48 8b c1	 mov	 rax, rcx
  00138	48 89 44 24 20	 mov	 QWORD PTR _new_size$[rsp], rax

; 93   :     items = self->ob_item;

  0013d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00142	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00146	48 89 44 24 28	 mov	 QWORD PTR items$[rsp], rax

; 94   :     /* XXX The following multiplication and division does not optimize away
; 95   :        like it does for lists since the size is not known at compile time */
; 96   :     if (_new_size <= ((~(size_t)0) / self->ob_descr->itemsize))

  0014b	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00150	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00157	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0015b	48 89 44 24 38	 mov	 QWORD PTR tv131[rsp], rax
  00160	33 d2		 xor	 edx, edx
  00162	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00169	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv131[rsp]
  0016e	48 f7 f1	 div	 rcx
  00171	48 39 44 24 20	 cmp	 QWORD PTR _new_size$[rsp], rax
  00176	0f 87 b3 00 00
	00		 ja	 $LN3@array_resi

; 97   :         PyMem_RESIZE(items, char, (_new_size * self->ob_descr->itemsize));

  0017c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00181	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00188	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0018c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _new_size$[rsp]
  00191	48 0f af c8	 imul	 rcx, rax
  00195	48 8b c1	 mov	 rax, rcx
  00198	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  001a2	48 3b c1	 cmp	 rax, rcx
  001a5	76 0b		 jbe	 SHORT $LN15@array_resi
  001a7	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv156[rsp], 0
  001b0	eb 71		 jmp	 SHORT $LN16@array_resi
$LN15@array_resi:
  001b2	e8 00 00 00 00	 call	 _Py_PXCTX
  001b7	85 c0		 test	 eax, eax
  001b9	74 30		 je	 SHORT $LN13@array_resi
  001bb	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001c0	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  001c7	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  001cb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _new_size$[rsp]
  001d0	48 0f af c8	 imul	 rcx, rax
  001d4	48 8b c1	 mov	 rax, rcx
  001d7	48 8b d0	 mov	 rdx, rax
  001da	48 8b 4c 24 28	 mov	 rcx, QWORD PTR items$[rsp]
  001df	e8 00 00 00 00	 call	 _PxMem_Realloc
  001e4	48 89 44 24 48	 mov	 QWORD PTR tv155[rsp], rax
  001e9	eb 2e		 jmp	 SHORT $LN14@array_resi
$LN13@array_resi:
  001eb	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001f0	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  001f7	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  001fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _new_size$[rsp]
  00200	48 0f af c8	 imul	 rcx, rax
  00204	48 8b c1	 mov	 rax, rcx
  00207	48 8b d0	 mov	 rdx, rax
  0020a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR items$[rsp]
  0020f	e8 00 00 00 00	 call	 _PyMem_DebugRealloc
  00214	48 89 44 24 48	 mov	 QWORD PTR tv155[rsp], rax
$LN14@array_resi:
  00219	48 8b 44 24 48	 mov	 rax, QWORD PTR tv155[rsp]
  0021e	48 89 44 24 40	 mov	 QWORD PTR tv156[rsp], rax
$LN16@array_resi:
  00223	48 8b 44 24 40	 mov	 rax, QWORD PTR tv156[rsp]
  00228	48 89 44 24 28	 mov	 QWORD PTR items$[rsp], rax

; 98   :     else

  0022d	eb 09		 jmp	 SHORT $LN2@array_resi
$LN3@array_resi:

; 99   :         items = NULL;

  0022f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR items$[rsp], 0
$LN2@array_resi:

; 100  :     if (items == NULL) {

  00238	48 83 7c 24 28
	00		 cmp	 QWORD PTR items$[rsp], 0
  0023e	75 0c		 jne	 SHORT $LN1@array_resi

; 101  :         PyErr_NoMemory();

  00240	e8 00 00 00 00	 call	 PyErr_NoMemory

; 102  :         return -1;

  00245	b8 ff ff ff ff	 mov	 eax, -1
  0024a	eb 2c		 jmp	 SHORT $LN7@array_resi
$LN1@array_resi:

; 103  :     }
; 104  :     self->ob_item = items;

  0024c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00251	48 8b 4c 24 28	 mov	 rcx, QWORD PTR items$[rsp]
  00256	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 105  :     Py_SIZE(self) = newsize;

  0025a	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0025f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR newsize$[rsp]
  00264	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 106  :     self->allocated = _new_size;

  00268	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0026d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _new_size$[rsp]
  00272	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 107  :     return 0;

  00276	33 c0		 xor	 eax, eax
$LN7@array_resi:

; 108  : }

  00278	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0027c	c3		 ret	 0
array_resize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@CFHNCMNJ@can?5only?5extend?5array?5with?5array@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_inplace_concat DD imagerel array_inplace_concat
	DD	imagerel array_inplace_concat+137
	DD	imagerel $unwind$array_inplace_concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_inplace_concat DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0DA@CFHNCMNJ@can?5only?5extend?5array?5with?5array@
CONST	SEGMENT
??_C@_0DA@CFHNCMNJ@can?5only?5extend?5array?5with?5array@ DB 'can only ex'
	DB	'tend array with array (not "%.200s")', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_inplace_concat
_TEXT	SEGMENT
self$ = 48
bb$ = 56
array_inplace_concat PROC				; COMDAT

; 912  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 913  :     if (!array_Check(bb)) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bb$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 3d		 je	 SHORT $LN2@array_inpl
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00027	48 8b 44 24 38	 mov	 rax, QWORD PTR bb$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 24		 jne	 SHORT $LN2@array_inpl

; 914  :         PyErr_Format(PyExc_TypeError,
; 915  :             "can only extend array with array (not \"%.200s\")",
; 916  :             Py_TYPE(bb)->tp_name);

  00039	48 8b 44 24 38	 mov	 rax, QWORD PTR bb$[rsp]
  0003e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00042	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@CFHNCMNJ@can?5only?5extend?5array?5with?5array@
  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00054	e8 00 00 00 00	 call	 PyErr_Format

; 917  :         return NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	eb 27		 jmp	 SHORT $LN3@array_inpl
$LN2@array_inpl:

; 918  :     }
; 919  :     if (array_do_extend(self, bb) == -1)

  0005d	48 8b 54 24 38	 mov	 rdx, QWORD PTR bb$[rsp]
  00062	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00067	e8 00 00 00 00	 call	 array_do_extend
  0006c	83 f8 ff	 cmp	 eax, -1
  0006f	75 04		 jne	 SHORT $LN1@array_inpl

; 920  :         return NULL;

  00071	33 c0		 xor	 eax, eax
  00073	eb 0f		 jmp	 SHORT $LN3@array_inpl
$LN1@array_inpl:

; 921  :     Py_INCREF(self);

  00075	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0007a	e8 00 00 00 00	 call	 _Py_IncRef

; 922  :     return (PyObject *)self;

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
$LN3@array_inpl:

; 923  : }

  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
array_inplace_concat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@PPGDJIHM@can?5only?5extend?5with?5array?5of?5sa@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_do_extend DD imagerel array_do_extend
	DD	imagerel array_do_extend+413
	DD	imagerel $unwind$array_do_extend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_do_extend DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0CI@PPGDJIHM@can?5only?5extend?5with?5array?5of?5sa@
CONST	SEGMENT
??_C@_0CI@PPGDJIHM@can?5only?5extend?5with?5array?5of?5sa@ DB 'can only e'
	DB	'xtend with array of same kind', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_do_extend
_TEXT	SEGMENT
oldsize$ = 32
bbsize$ = 40
size$ = 48
tv85 = 56
self$ = 80
bb$ = 88
array_do_extend PROC					; COMDAT

; 881  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 882  :     Py_ssize_t size, oldsize, bbsize;
; 883  : 
; 884  :     if (!array_Check(bb))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  00015	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bb$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 2d		 je	 SHORT $LN5@array_do_e
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00027	48 8b 44 24 58	 mov	 rax, QWORD PTR bb$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 14		 jne	 SHORT $LN5@array_do_e

; 885  :         return array_iter_extend(self, bb);

  00039	48 8b 54 24 58	 mov	 rdx, QWORD PTR bb$[rsp]
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00043	e8 00 00 00 00	 call	 array_iter_extend
  00048	e9 4b 01 00 00	 jmp	 $LN6@array_do_e
$LN5@array_do_e:

; 886  : #define b ((arrayobject *)bb)
; 887  :     if (self->ob_descr != b->ob_descr) {

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00052	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bb$[rsp]
  00057	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0005e	48 39 88 80 00
	00 00		 cmp	 QWORD PTR [rax+128], rcx
  00065	74 1d		 je	 SHORT $LN4@array_do_e

; 888  :         PyErr_SetString(PyExc_TypeError,
; 889  :                      "can only extend with array of same kind");

  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@PPGDJIHM@can?5only?5extend?5with?5array?5of?5sa@
  0006e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00075	e8 00 00 00 00	 call	 PyErr_SetString

; 890  :         return -1;

  0007a	b8 ff ff ff ff	 mov	 eax, -1
  0007f	e9 14 01 00 00	 jmp	 $LN6@array_do_e
$LN4@array_do_e:

; 891  :     }
; 892  :     if ((Py_SIZE(self) > PY_SSIZE_T_MAX - Py_SIZE(b)) ||
; 893  :         ((Py_SIZE(self) + Py_SIZE(b)) > PY_SSIZE_T_MAX / self->ob_descr->itemsize)) {

  00084	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0008e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bb$[rsp]
  00093	48 2b 41 60	 sub	 rax, QWORD PTR [rcx+96]
  00097	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0009c	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  000a0	7f 43		 jg	 SHORT $LN2@array_do_e
  000a2	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000a7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ab	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bb$[rsp]
  000b0	48 03 41 60	 add	 rax, QWORD PTR [rcx+96]
  000b4	48 89 44 24 38	 mov	 QWORD PTR tv85[rsp], rax
  000b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000be	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000c5	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  000c9	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  000d3	48 8b c2	 mov	 rax, rdx
  000d6	48 99		 cdq
  000d8	48 f7 f9	 idiv	 rcx
  000db	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv85[rsp]
  000e0	48 3b c8	 cmp	 rcx, rax
  000e3	7e 0f		 jle	 SHORT $LN3@array_do_e
$LN2@array_do_e:

; 894  :         PyErr_NoMemory();

  000e5	e8 00 00 00 00	 call	 PyErr_NoMemory

; 895  :         return -1;

  000ea	b8 ff ff ff ff	 mov	 eax, -1
  000ef	e9 a4 00 00 00	 jmp	 $LN6@array_do_e
$LN3@array_do_e:

; 896  :     }
; 897  :     oldsize = Py_SIZE(self);

  000f4	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000f9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000fd	48 89 44 24 20	 mov	 QWORD PTR oldsize$[rsp], rax

; 898  :     /* Get the size of bb before resizing the array since bb could be self. */
; 899  :     bbsize = Py_SIZE(bb);

  00102	48 8b 44 24 58	 mov	 rax, QWORD PTR bb$[rsp]
  00107	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0010b	48 89 44 24 28	 mov	 QWORD PTR bbsize$[rsp], rax

; 900  :     size = oldsize + Py_SIZE(b);

  00110	48 8b 44 24 58	 mov	 rax, QWORD PTR bb$[rsp]
  00115	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00119	48 8b 4c 24 20	 mov	 rcx, QWORD PTR oldsize$[rsp]
  0011e	48 03 c8	 add	 rcx, rax
  00121	48 8b c1	 mov	 rax, rcx
  00124	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 901  :     if (array_resize(self, size) == -1)

  00129	48 8b 54 24 30	 mov	 rdx, QWORD PTR size$[rsp]
  0012e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00133	e8 00 00 00 00	 call	 array_resize
  00138	83 f8 ff	 cmp	 eax, -1
  0013b	75 07		 jne	 SHORT $LN1@array_do_e

; 902  :         return -1;

  0013d	b8 ff ff ff ff	 mov	 eax, -1
  00142	eb 54		 jmp	 SHORT $LN6@array_do_e
$LN1@array_do_e:

; 903  :     memcpy(self->ob_item + oldsize * self->ob_descr->itemsize,
; 904  :         b->ob_item, bbsize * b->ob_descr->itemsize);

  00144	48 8b 44 24 58	 mov	 rax, QWORD PTR bb$[rsp]
  00149	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00150	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00154	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bbsize$[rsp]
  00159	48 0f af c8	 imul	 rcx, rax
  0015d	48 8b c1	 mov	 rax, rcx
  00160	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00165	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0016c	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  00170	48 8b 54 24 20	 mov	 rdx, QWORD PTR oldsize$[rsp]
  00175	48 0f af d1	 imul	 rdx, rcx
  00179	48 8b ca	 mov	 rcx, rdx
  0017c	48 8b 54 24 50	 mov	 rdx, QWORD PTR self$[rsp]
  00181	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  00185	4c 8b c0	 mov	 r8, rax
  00188	48 8b 44 24 58	 mov	 rax, QWORD PTR bb$[rsp]
  0018d	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00191	e8 00 00 00 00	 call	 memcpy

; 905  : 
; 906  :     return 0;

  00196	33 c0		 xor	 eax, eax
$LN6@array_do_e:

; 907  : #undef b
; 908  : }

  00198	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0019c	c3		 ret	 0
array_do_extend ENDP
_TEXT	ENDS
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_GetIter:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_iter_extend DD imagerel array_iter_extend
	DD	imagerel array_iter_extend+168
	DD	imagerel $unwind$array_iter_extend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_iter_extend DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_iter_extend
_TEXT	SEGMENT
it$ = 32
v$ = 40
self$ = 64
bb$ = 72
array_iter_extend PROC					; COMDAT

; 858  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 859  :     PyObject *it, *v;
; 860  : 
; 861  :     it = PyObject_GetIter(bb);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bb$[rsp]
  00013	e8 00 00 00 00	 call	 PyObject_GetIter
  00018	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 862  :     if (it == NULL)

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00023	75 07		 jne	 SHORT $LN5@array_iter

; 863  :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	eb 77		 jmp	 SHORT $LN6@array_iter
$LN5@array_iter:
$LN4@array_iter:

; 864  : 
; 865  :     while ((v = PyIter_Next(it)) != NULL) {

  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00031	e8 00 00 00 00	 call	 PyIter_Next
  00036	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax
  0003b	48 83 7c 24 28
	00		 cmp	 QWORD PTR v$[rsp], 0
  00041	74 43		 je	 SHORT $LN3@array_iter

; 866  :         if (ins1(self, Py_SIZE(self), v) != 0) {

  00043	4c 8b 44 24 28	 mov	 r8, QWORD PTR v$[rsp]
  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004d	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00056	e8 00 00 00 00	 call	 ins1
  0005b	85 c0		 test	 eax, eax
  0005d	74 1b		 je	 SHORT $LN2@array_iter

; 867  :             Py_DECREF(v);

  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  00064	e8 00 00 00 00	 call	 _Py_DecRef

; 868  :             Py_DECREF(it);

  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0006e	e8 00 00 00 00	 call	 _Py_DecRef

; 869  :             return -1;

  00073	b8 ff ff ff ff	 mov	 eax, -1
  00078	eb 29		 jmp	 SHORT $LN6@array_iter
$LN2@array_iter:

; 870  :         }
; 871  :         Py_DECREF(v);

  0007a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR v$[rsp]
  0007f	e8 00 00 00 00	 call	 _Py_DecRef

; 872  :     }

  00084	eb a6		 jmp	 SHORT $LN4@array_iter
$LN3@array_iter:

; 873  :     Py_DECREF(it);

  00086	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0008b	e8 00 00 00 00	 call	 _Py_DecRef

; 874  :     if (PyErr_Occurred())

  00090	e8 00 00 00 00	 call	 PyErr_Occurred
  00095	48 85 c0	 test	 rax, rax
  00098	74 07		 je	 SHORT $LN1@array_iter

; 875  :         return -1;

  0009a	b8 ff ff ff ff	 mov	 eax, -1
  0009f	eb 02		 jmp	 SHORT $LN6@array_iter
$LN1@array_iter:

; 876  :     return 0;

  000a1	33 c0		 xor	 eax, eax
$LN6@array_iter:

; 877  : }

  000a3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a7	c3		 ret	 0
array_iter_extend ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ins1 DD	imagerel ins1
	DD	imagerel ins1+422
	DD	imagerel $unwind$ins1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ins1 DD	011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ins1
_TEXT	SEGMENT
n$ = 32
items$ = 40
tv136 = 48
self$ = 80
where$ = 88
v$ = 96
ins1	PROC						; COMDAT

; 525  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 526  :     char *items;
; 527  :     Py_ssize_t n = Py_SIZE(self);

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001c	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 528  :     if (v == NULL) {

  00021	48 83 7c 24 60
	00		 cmp	 QWORD PTR v$[rsp], 0
  00027	75 1b		 jne	 SHORT $LN7@ins1

; 529  :         PyErr_BadInternalCall();

  00029	ba 11 02 00 00	 mov	 edx, 529		; 00000211H
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@
  00035	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 530  :         return -1;

  0003a	b8 ff ff ff ff	 mov	 eax, -1
  0003f	e9 5d 01 00 00	 jmp	 $LN8@ins1
$LN7@ins1:

; 531  :     }
; 532  :     if ((*self->ob_descr->setitem)(self, -1, v) < 0)

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00049	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00050	4c 8b 44 24 60	 mov	 r8, QWORD PTR v$[rsp]
  00055	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  0005c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00061	ff 50 10	 call	 QWORD PTR [rax+16]
  00064	85 c0		 test	 eax, eax
  00066	7d 0a		 jge	 SHORT $LN6@ins1

; 533  :         return -1;

  00068	b8 ff ff ff ff	 mov	 eax, -1
  0006d	e9 2f 01 00 00	 jmp	 $LN8@ins1
$LN6@ins1:

; 534  : 
; 535  :     if (array_resize(self, n+1) == -1)

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00077	48 ff c0	 inc	 rax
  0007a	48 8b d0	 mov	 rdx, rax
  0007d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00082	e8 00 00 00 00	 call	 array_resize
  00087	83 f8 ff	 cmp	 eax, -1
  0008a	75 0a		 jne	 SHORT $LN5@ins1

; 536  :         return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
  00091	e9 0b 01 00 00	 jmp	 $LN8@ins1
$LN5@ins1:

; 537  :     items = self->ob_item;

  00096	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0009b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0009f	48 89 44 24 28	 mov	 QWORD PTR items$[rsp], rax

; 538  :     if (where < 0) {

  000a4	48 83 7c 24 58
	00		 cmp	 QWORD PTR where$[rsp], 0
  000aa	7d 26		 jge	 SHORT $LN4@ins1

; 539  :         where += n;

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000b1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR where$[rsp]
  000b6	48 03 c8	 add	 rcx, rax
  000b9	48 8b c1	 mov	 rax, rcx
  000bc	48 89 44 24 58	 mov	 QWORD PTR where$[rsp], rax

; 540  :         if (where < 0)

  000c1	48 83 7c 24 58
	00		 cmp	 QWORD PTR where$[rsp], 0
  000c7	7d 09		 jge	 SHORT $LN3@ins1

; 541  :             where = 0;

  000c9	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR where$[rsp], 0
$LN3@ins1:
$LN4@ins1:

; 542  :     }
; 543  :     if (where > n)

  000d2	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000d7	48 39 44 24 58	 cmp	 QWORD PTR where$[rsp], rax
  000dc	7e 0a		 jle	 SHORT $LN2@ins1

; 544  :         where = n;

  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000e3	48 89 44 24 58	 mov	 QWORD PTR where$[rsp], rax
$LN2@ins1:

; 545  :     /* appends don't need to call memmove() */
; 546  :     if (where != n)

  000e8	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000ed	48 39 44 24 58	 cmp	 QWORD PTR where$[rsp], rax
  000f2	0f 84 8b 00 00
	00		 je	 $LN1@ins1

; 547  :         memmove(items + (where+1)*self->ob_descr->itemsize,
; 548  :             items + where*self->ob_descr->itemsize,
; 549  :             (n-where)*self->ob_descr->itemsize);

  000f8	48 8b 44 24 58	 mov	 rax, QWORD PTR where$[rsp]
  000fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  00102	48 2b c8	 sub	 rcx, rax
  00105	48 8b c1	 mov	 rax, rcx
  00108	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0010d	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00114	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  00118	48 0f af c1	 imul	 rax, rcx
  0011c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00121	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00128	48 63 49 04	 movsxd	 rcx, DWORD PTR [rcx+4]
  0012c	48 8b 54 24 58	 mov	 rdx, QWORD PTR where$[rsp]
  00131	48 0f af d1	 imul	 rdx, rcx
  00135	48 8b ca	 mov	 rcx, rdx
  00138	48 8b 54 24 28	 mov	 rdx, QWORD PTR items$[rsp]
  0013d	48 03 d1	 add	 rdx, rcx
  00140	48 8b ca	 mov	 rcx, rdx
  00143	48 8b 54 24 58	 mov	 rdx, QWORD PTR where$[rsp]
  00148	48 ff c2	 inc	 rdx
  0014b	4c 8b 44 24 50	 mov	 r8, QWORD PTR self$[rsp]
  00150	4d 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [r8+128]
  00157	4d 63 40 04	 movsxd	 r8, DWORD PTR [r8+4]
  0015b	49 0f af d0	 imul	 rdx, r8
  0015f	4c 8b 44 24 28	 mov	 r8, QWORD PTR items$[rsp]
  00164	4c 03 c2	 add	 r8, rdx
  00167	49 8b d0	 mov	 rdx, r8
  0016a	48 89 54 24 30	 mov	 QWORD PTR tv136[rsp], rdx
  0016f	4c 8b c0	 mov	 r8, rax
  00172	48 8b d1	 mov	 rdx, rcx
  00175	48 8b 44 24 30	 mov	 rax, QWORD PTR tv136[rsp]
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN1@ins1:

; 550  :     return (*self->ob_descr->setitem)(self, where, v);

  00183	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00188	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0018f	4c 8b 44 24 60	 mov	 r8, QWORD PTR v$[rsp]
  00194	48 8b 54 24 58	 mov	 rdx, QWORD PTR where$[rsp]
  00199	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0019e	ff 50 10	 call	 QWORD PTR [rax+16]
$LN8@ins1:

; 551  : }

  001a1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a5	c3		 ret	 0
ins1	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_inplace_repeat DD imagerel array_inplace_repeat
	DD	imagerel array_inplace_repeat+372
	DD	imagerel $unwind$array_inplace_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_inplace_repeat DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_inplace_repeat
_TEXT	SEGMENT
p$ = 32
i$ = 40
size$ = 48
items$ = 56
tv73 = 64
self$ = 96
n$ = 104
array_inplace_repeat PROC				; COMDAT

; 927  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 928  :     char *items, *p;
; 929  :     Py_ssize_t size, i;
; 930  : 
; 931  :     if (Py_SIZE(self) > 0) {

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00018	0f 8e 42 01 00
	00		 jle	 $LN8@array_inpl@2

; 932  :         if (n < 0)

  0001e	48 83 7c 24 68
	00		 cmp	 QWORD PTR n$[rsp], 0
  00024	7d 09		 jge	 SHORT $LN7@array_inpl@2

; 933  :             n = 0;

  00026	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0
$LN7@array_inpl@2:

; 934  :         if ((self->ob_descr->itemsize != 0) &&
; 935  :             (Py_SIZE(self) > PY_SSIZE_T_MAX / self->ob_descr->itemsize)) {

  0002f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00034	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0003b	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0003f	74 41		 je	 SHORT $LN6@array_inpl@2
  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00046	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0004d	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00051	48 89 44 24 40	 mov	 QWORD PTR tv73[rsp], rax
  00056	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00060	48 8b c1	 mov	 rax, rcx
  00063	48 99		 cdq
  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv73[rsp]
  0006a	48 f7 f9	 idiv	 rcx
  0006d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00072	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00076	7e 0a		 jle	 SHORT $LN6@array_inpl@2

; 936  :             return PyErr_NoMemory();

  00078	e8 00 00 00 00	 call	 PyErr_NoMemory
  0007d	e9 ed 00 00 00	 jmp	 $LN9@array_inpl@2
$LN6@array_inpl@2:

; 937  :         }
; 938  :         size = Py_SIZE(self) * self->ob_descr->itemsize;

  00082	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00087	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0008e	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00092	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00097	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0009b	48 0f af c8	 imul	 rcx, rax
  0009f	48 8b c1	 mov	 rax, rcx
  000a2	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax

; 939  :         if (n > 0 && size > PY_SSIZE_T_MAX / n) {

  000a7	48 83 7c 24 68
	00		 cmp	 QWORD PTR n$[rsp], 0
  000ad	7e 22		 jle	 SHORT $LN5@array_inpl@2
  000af	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000b9	48 99		 cdq
  000bb	48 f7 7c 24 68	 idiv	 QWORD PTR n$[rsp]
  000c0	48 39 44 24 30	 cmp	 QWORD PTR size$[rsp], rax
  000c5	7e 0a		 jle	 SHORT $LN5@array_inpl@2

; 940  :             return PyErr_NoMemory();

  000c7	e8 00 00 00 00	 call	 PyErr_NoMemory
  000cc	e9 9e 00 00 00	 jmp	 $LN9@array_inpl@2
$LN5@array_inpl@2:

; 941  :         }
; 942  :         if (array_resize(self, n * Py_SIZE(self)) == -1)

  000d1	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000d6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR n$[rsp]
  000db	48 0f af 48 60	 imul	 rcx, QWORD PTR [rax+96]
  000e0	48 8b c1	 mov	 rax, rcx
  000e3	48 8b d0	 mov	 rdx, rax
  000e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000eb	e8 00 00 00 00	 call	 array_resize
  000f0	83 f8 ff	 cmp	 eax, -1
  000f3	75 04		 jne	 SHORT $LN4@array_inpl@2

; 943  :             return NULL;

  000f5	33 c0		 xor	 eax, eax
  000f7	eb 76		 jmp	 SHORT $LN9@array_inpl@2
$LN4@array_inpl@2:

; 944  :         items = p = self->ob_item;

  000f9	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000fe	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00102	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00107	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0010c	48 89 44 24 38	 mov	 QWORD PTR items$[rsp], rax

; 945  :         for (i = 1; i < n; i++) {

  00111	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR i$[rsp], 1
  0011a	eb 0d		 jmp	 SHORT $LN3@array_inpl@2
$LN2@array_inpl@2:
  0011c	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00121	48 ff c0	 inc	 rax
  00124	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN3@array_inpl@2:
  00129	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0012e	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00133	7d 2b		 jge	 SHORT $LN1@array_inpl@2

; 946  :             p += size;

  00135	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  0013a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0013f	48 03 c8	 add	 rcx, rax
  00142	48 8b c1	 mov	 rax, rcx
  00145	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 947  :             memcpy(p, items, size);

  0014a	4c 8b 44 24 30	 mov	 r8, QWORD PTR size$[rsp]
  0014f	48 8b 54 24 38	 mov	 rdx, QWORD PTR items$[rsp]
  00154	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00159	e8 00 00 00 00	 call	 memcpy

; 948  :         }

  0015e	eb bc		 jmp	 SHORT $LN2@array_inpl@2
$LN1@array_inpl@2:
$LN8@array_inpl@2:

; 949  :     }
; 950  :     Py_INCREF(self);

  00160	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00165	e8 00 00 00 00	 call	 _Py_IncRef

; 951  :     return (PyObject *)self;

  0016a	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
$LN9@array_inpl@2:

; 952  : }

  0016f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00173	c3		 ret	 0
array_inplace_repeat ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_count DD imagerel array_count
	DD	imagerel array_count+168
	DD	imagerel $unwind$array_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_count DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_count
_TEXT	SEGMENT
count$ = 32
i$ = 40
selfi$21263 = 48
cmp$21265 = 56
self$ = 80
v$ = 88
array_count PROC					; COMDAT

; 966  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 967  :     Py_ssize_t count = 0;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR count$[rsp], 0

; 968  :     Py_ssize_t i;
; 969  : 
; 970  :     for (i = 0; i < Py_SIZE(self); i++) {

  00017	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00020	eb 0d		 jmp	 SHORT $LN6@array_coun
$LN5@array_coun:
  00022	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00027	48 ff c0	 inc	 rax
  0002a	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN6@array_coun:
  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00034	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00038	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0003d	7d 5a		 jge	 SHORT $LN4@array_coun

; 971  :         PyObject *selfi = getarrayitem((PyObject *)self, i);

  0003f	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00044	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00049	e8 00 00 00 00	 call	 getarrayitem
  0004e	48 89 44 24 30	 mov	 QWORD PTR selfi$21263[rsp], rax

; 972  :         int cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);

  00053	41 b8 02 00 00
	00		 mov	 r8d, 2
  00059	48 8b 54 24 58	 mov	 rdx, QWORD PTR v$[rsp]
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR selfi$21263[rsp]
  00063	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00068	89 44 24 38	 mov	 DWORD PTR cmp$21265[rsp], eax

; 973  :         Py_DECREF(selfi);

  0006c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR selfi$21263[rsp]
  00071	e8 00 00 00 00	 call	 _Py_DecRef

; 974  :         if (cmp > 0)

  00076	83 7c 24 38 00	 cmp	 DWORD PTR cmp$21265[rsp], 0
  0007b	7e 0f		 jle	 SHORT $LN3@array_coun

; 975  :             count++;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR count$[rsp]
  00082	48 ff c0	 inc	 rax
  00085	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax
  0008a	eb 0b		 jmp	 SHORT $LN2@array_coun
$LN3@array_coun:

; 976  :         else if (cmp < 0)

  0008c	83 7c 24 38 00	 cmp	 DWORD PTR cmp$21265[rsp], 0
  00091	7d 04		 jge	 SHORT $LN1@array_coun

; 977  :             return NULL;

  00093	33 c0		 xor	 eax, eax
  00095	eb 0c		 jmp	 SHORT $LN7@array_coun
$LN1@array_coun:
$LN2@array_coun:

; 978  :     }

  00097	eb 89		 jmp	 SHORT $LN5@array_coun
$LN4@array_coun:

; 979  :     return PyLong_FromSsize_t(count);

  00099	48 8b 4c 24 20	 mov	 rcx, QWORD PTR count$[rsp]
  0009e	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN7@array_coun:

; 980  : }

  000a3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a7	c3		 ret	 0
array_count ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@LMBGGMKK@array?4index?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ ; `string'
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_index DD imagerel array_index
	DD	imagerel array_index+168
	DD	imagerel $unwind$array_index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_index DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BO@LMBGGMKK@array?4index?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BO@LMBGGMKK@array?4index?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ DB 'arr'
	DB	'ay.index(x): x not in list', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_index
_TEXT	SEGMENT
i$ = 32
selfi$21283 = 40
cmp$21285 = 48
self$ = 80
v$ = 88
array_index PROC					; COMDAT

; 989  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 990  :     Py_ssize_t i;
; 991  : 
; 992  :     for (i = 0; i < Py_SIZE(self); i++) {

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	eb 0d		 jmp	 SHORT $LN6@array_inde
$LN5@array_inde:
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0001e	48 ff c0	 inc	 rax
  00021	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@array_inde:
  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0002b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002f	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00034	7d 58		 jge	 SHORT $LN4@array_inde

; 993  :         PyObject *selfi = getarrayitem((PyObject *)self, i);

  00036	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00040	e8 00 00 00 00	 call	 getarrayitem
  00045	48 89 44 24 28	 mov	 QWORD PTR selfi$21283[rsp], rax

; 994  :         int cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);

  0004a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00050	48 8b 54 24 58	 mov	 rdx, QWORD PTR v$[rsp]
  00055	48 8b 4c 24 28	 mov	 rcx, QWORD PTR selfi$21283[rsp]
  0005a	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0005f	89 44 24 30	 mov	 DWORD PTR cmp$21285[rsp], eax

; 995  :         Py_DECREF(selfi);

  00063	48 8b 4c 24 28	 mov	 rcx, QWORD PTR selfi$21283[rsp]
  00068	e8 00 00 00 00	 call	 _Py_DecRef

; 996  :         if (cmp > 0) {

  0006d	83 7c 24 30 00	 cmp	 DWORD PTR cmp$21285[rsp], 0
  00072	7e 0d		 jle	 SHORT $LN3@array_inde

; 997  :             return PyLong_FromLong((long)i);

  00074	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00078	e8 00 00 00 00	 call	 PyLong_FromLong
  0007d	eb 24		 jmp	 SHORT $LN7@array_inde
  0007f	eb 0b		 jmp	 SHORT $LN2@array_inde
$LN3@array_inde:

; 998  :         }
; 999  :         else if (cmp < 0)

  00081	83 7c 24 30 00	 cmp	 DWORD PTR cmp$21285[rsp], 0
  00086	7d 04		 jge	 SHORT $LN1@array_inde

; 1000 :             return NULL;

  00088	33 c0		 xor	 eax, eax
  0008a	eb 17		 jmp	 SHORT $LN7@array_inde
$LN1@array_inde:
$LN2@array_inde:

; 1001 :     }

  0008c	eb 8b		 jmp	 SHORT $LN5@array_inde
$LN4@array_inde:

; 1002 :     PyErr_SetString(PyExc_ValueError, "array.index(x): x not in list");

  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@LMBGGMKK@array?4index?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
  00095	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0009c	e8 00 00 00 00	 call	 PyErr_SetString

; 1003 :     return NULL;

  000a1	33 c0		 xor	 eax, eax
$LN7@array_inde:

; 1004 : }

  000a3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a7	c3		 ret	 0
array_index ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_contains DD imagerel array_contains
	DD	imagerel array_contains+135
	DD	imagerel $unwind$array_contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_contains DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_contains
_TEXT	SEGMENT
i$ = 32
cmp$ = 40
selfi$21307 = 48
self$ = 80
v$ = 88
array_contains PROC					; COMDAT

; 1013 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1014 :     Py_ssize_t i;
; 1015 :     int cmp;
; 1016 : 
; 1017 :     for (i = 0, cmp = 0 ; cmp == 0 && i < Py_SIZE(self); i++) {

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR cmp$[rsp], 0
  0001f	eb 0d		 jmp	 SHORT $LN3@array_cont
$LN2@array_cont:
  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00026	48 ff c0	 inc	 rax
  00029	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@array_cont:
  0002e	83 7c 24 28 00	 cmp	 DWORD PTR cmp$[rsp], 0
  00033	75 49		 jne	 SHORT $LN1@array_cont
  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0003a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003e	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00043	7d 39		 jge	 SHORT $LN1@array_cont

; 1018 :         PyObject *selfi = getarrayitem((PyObject *)self, i);

  00045	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0004a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0004f	e8 00 00 00 00	 call	 getarrayitem
  00054	48 89 44 24 30	 mov	 QWORD PTR selfi$21307[rsp], rax

; 1019 :         cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);

  00059	41 b8 02 00 00
	00		 mov	 r8d, 2
  0005f	48 8b 54 24 58	 mov	 rdx, QWORD PTR v$[rsp]
  00064	48 8b 4c 24 30	 mov	 rcx, QWORD PTR selfi$21307[rsp]
  00069	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  0006e	89 44 24 28	 mov	 DWORD PTR cmp$[rsp], eax

; 1020 :         Py_DECREF(selfi);

  00072	48 8b 4c 24 30	 mov	 rcx, QWORD PTR selfi$21307[rsp]
  00077	e8 00 00 00 00	 call	 _Py_DecRef

; 1021 :     }

  0007c	eb a3		 jmp	 SHORT $LN2@array_cont
$LN1@array_cont:

; 1022 :     return cmp;

  0007e	8b 44 24 28	 mov	 eax, DWORD PTR cmp$[rsp]

; 1023 : }

  00082	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00086	c3		 ret	 0
array_contains ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@MLCNIPFC@array?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ ; `string'
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_remove DD imagerel array_remove
	DD	imagerel array_remove+224
	DD	imagerel $unwind$array_remove
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_remove DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BP@MLCNIPFC@array?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
CONST	SEGMENT
??_C@_0BP@MLCNIPFC@array?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@ DB 'ar'
	DB	'ray.remove(x): x not in list', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_remove
_TEXT	SEGMENT
i$ = 32
selfi$21321 = 40
cmp$21323 = 48
self$ = 80
v$ = 88
array_remove PROC					; COMDAT

; 1027 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1028 :     int i;
; 1029 : 
; 1030 :     for (i = 0; i < Py_SIZE(self); i++) {

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 0a		 jmp	 SHORT $LN7@array_remo
$LN6@array_remo:
  00018	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001c	ff c0		 inc	 eax
  0001e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@array_remo:
  00022	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0002c	48 3b 41 60	 cmp	 rax, QWORD PTR [rcx+96]
  00030	0f 8d 90 00 00
	00		 jge	 $LN5@array_remo

; 1031 :         PyObject *selfi = getarrayitem((PyObject *)self,i);

  00036	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0003b	48 8b d0	 mov	 rdx, rax
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00043	e8 00 00 00 00	 call	 getarrayitem
  00048	48 89 44 24 28	 mov	 QWORD PTR selfi$21321[rsp], rax

; 1032 :         int cmp = PyObject_RichCompareBool(selfi, v, Py_EQ);

  0004d	41 b8 02 00 00
	00		 mov	 r8d, 2
  00053	48 8b 54 24 58	 mov	 rdx, QWORD PTR v$[rsp]
  00058	48 8b 4c 24 28	 mov	 rcx, QWORD PTR selfi$21321[rsp]
  0005d	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00062	89 44 24 30	 mov	 DWORD PTR cmp$21323[rsp], eax

; 1033 :         Py_DECREF(selfi);

  00066	48 8b 4c 24 28	 mov	 rcx, QWORD PTR selfi$21321[rsp]
  0006b	e8 00 00 00 00	 call	 _Py_DecRef

; 1034 :         if (cmp > 0) {

  00070	83 7c 24 30 00	 cmp	 DWORD PTR cmp$21323[rsp], 0
  00075	7e 3f		 jle	 SHORT $LN4@array_remo

; 1035 :             if (array_ass_slice(self, i, i+1,
; 1036 :                                (PyObject *)NULL) != 0)

  00077	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0007b	ff c0		 inc	 eax
  0007d	48 98		 cdqe
  0007f	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00084	45 33 c9	 xor	 r9d, r9d
  00087	4c 8b c0	 mov	 r8, rax
  0008a	48 8b d1	 mov	 rdx, rcx
  0008d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00092	e8 00 00 00 00	 call	 array_ass_slice
  00097	85 c0		 test	 eax, eax
  00099	74 04		 je	 SHORT $LN3@array_remo

; 1037 :                 return NULL;

  0009b	33 c0		 xor	 eax, eax
  0009d	eb 3c		 jmp	 SHORT $LN8@array_remo
$LN3@array_remo:

; 1038 :             Py_INCREF(Py_None);

  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000a6	e8 00 00 00 00	 call	 _Py_IncRef

; 1039 :             return Py_None;

  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000b2	eb 27		 jmp	 SHORT $LN8@array_remo
  000b4	eb 0b		 jmp	 SHORT $LN2@array_remo
$LN4@array_remo:

; 1040 :         }
; 1041 :         else if (cmp < 0)

  000b6	83 7c 24 30 00	 cmp	 DWORD PTR cmp$21323[rsp], 0
  000bb	7d 04		 jge	 SHORT $LN1@array_remo

; 1042 :             return NULL;

  000bd	33 c0		 xor	 eax, eax
  000bf	eb 1a		 jmp	 SHORT $LN8@array_remo
$LN1@array_remo:
$LN2@array_remo:

; 1043 :     }

  000c1	e9 52 ff ff ff	 jmp	 $LN6@array_remo
$LN5@array_remo:

; 1044 :     PyErr_SetString(PyExc_ValueError, "array.remove(x): x not in list");

  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@MLCNIPFC@array?4remove?$CIx?$CJ?3?5x?5not?5in?5list?$AA@
  000cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000d4	e8 00 00 00 00	 call	 PyErr_SetString

; 1045 :     return NULL;

  000d9	33 c0		 xor	 eax, eax
$LN8@array_remo:

; 1046 : }

  000db	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000df	c3		 ret	 0
array_remove ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0BF@MIKMJNKA@pop?5from?5empty?5array?$AA@	; `string'
PUBLIC	??_C@_06JHLPABKE@?$HMn?3pop?$AA@		; `string'
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_pop DD imagerel array_pop
	DD	imagerel array_pop+251
	DD	imagerel $unwind$array_pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_pop DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@ DB 'pop index out of r'
	DB	'ange', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MIKMJNKA@pop?5from?5empty?5array?$AA@
CONST	SEGMENT
??_C@_0BF@MIKMJNKA@pop?5from?5empty?5array?$AA@ DB 'pop from empty array', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JHLPABKE@?$HMn?3pop?$AA@
CONST	SEGMENT
??_C@_06JHLPABKE@?$HMn?3pop?$AA@ DB '|n:pop', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_pop
_TEXT	SEGMENT
v$ = 32
i$ = 40
self$ = 64
args$ = 72
array_pop PROC						; COMDAT

; 1055 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1056 :     Py_ssize_t i = -1;

  0000e	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR i$[rsp], -1

; 1057 :     PyObject *v;
; 1058 :     if (!PyArg_ParseTuple(args, "|n:pop", &i))

  00017	4c 8d 44 24 28	 lea	 r8, QWORD PTR i$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JHLPABKE@?$HMn?3pop?$AA@
  00023	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002d	85 c0		 test	 eax, eax
  0002f	75 07		 jne	 SHORT $LN6@array_pop

; 1059 :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	e9 be 00 00 00	 jmp	 $LN7@array_pop
$LN6@array_pop:

; 1060 :     if (Py_SIZE(self) == 0) {

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	75 1a		 jne	 SHORT $LN5@array_pop

; 1061 :         /* Special-case most common failure cause */
; 1062 :         PyErr_SetString(PyExc_IndexError, "pop from empty array");

  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@MIKMJNKA@pop?5from?5empty?5array?$AA@
  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00052	e8 00 00 00 00	 call	 PyErr_SetString

; 1063 :         return NULL;

  00057	33 c0		 xor	 eax, eax
  00059	e9 98 00 00 00	 jmp	 $LN7@array_pop
$LN5@array_pop:

; 1064 :     }
; 1065 :     if (i < 0)

  0005e	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00064	7d 19		 jge	 SHORT $LN4@array_pop

; 1066 :         i += Py_SIZE(self);

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00074	48 03 c8	 add	 rcx, rax
  00077	48 8b c1	 mov	 rax, rcx
  0007a	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN4@array_pop:

; 1067 :     if (i < 0 || i >= Py_SIZE(self)) {

  0007f	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00085	7c 10		 jl	 SHORT $LN2@array_pop
  00087	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0008c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00090	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00095	7c 17		 jl	 SHORT $LN3@array_pop
$LN2@array_pop:

; 1068 :         PyErr_SetString(PyExc_IndexError, "pop index out of range");

  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@IJGJGNPF@pop?5index?5out?5of?5range?$AA@
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000a5	e8 00 00 00 00	 call	 PyErr_SetString

; 1069 :         return NULL;

  000aa	33 c0		 xor	 eax, eax
  000ac	eb 48		 jmp	 SHORT $LN7@array_pop
$LN3@array_pop:

; 1070 :     }
; 1071 :     v = getarrayitem((PyObject *)self,i);

  000ae	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000b8	e8 00 00 00 00	 call	 getarrayitem
  000bd	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 1072 :     if (array_ass_slice(self, i, i+1, (PyObject *)NULL) != 0) {

  000c2	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000c7	48 ff c0	 inc	 rax
  000ca	45 33 c9	 xor	 r9d, r9d
  000cd	4c 8b c0	 mov	 r8, rax
  000d0	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  000d5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000da	e8 00 00 00 00	 call	 array_ass_slice
  000df	85 c0		 test	 eax, eax
  000e1	74 0e		 je	 SHORT $LN1@array_pop

; 1073 :         Py_DECREF(v);

  000e3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  000e8	e8 00 00 00 00	 call	 _Py_DecRef

; 1074 :         return NULL;

  000ed	33 c0		 xor	 eax, eax
  000ef	eb 05		 jmp	 SHORT $LN7@array_pop
$LN1@array_pop:

; 1075 :     }
; 1076 :     return v;

  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN7@array_pop:

; 1077 : }

  000f6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fa	c3		 ret	 0
array_pop ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_extend DD imagerel array_extend
	DD	imagerel array_extend+62
	DD	imagerel $unwind$array_extend
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_extend DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_extend
_TEXT	SEGMENT
self$ = 48
bb$ = 56
array_extend PROC					; COMDAT

; 1086 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1087 :     if (array_do_extend(self, bb) == -1)

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR bb$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00018	e8 00 00 00 00	 call	 array_do_extend
  0001d	83 f8 ff	 cmp	 eax, -1
  00020	75 04		 jne	 SHORT $LN1@array_exte

; 1088 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	eb 13		 jmp	 SHORT $LN2@array_exte
$LN1@array_exte:

; 1089 :     Py_INCREF(Py_None);

  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0002d	e8 00 00 00 00	 call	 _Py_IncRef

; 1090 :     return Py_None;

  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@array_exte:

; 1091 : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
array_extend ENDP
_TEXT	ENDS
PUBLIC	??_C@_09EEABNKNH@nO?3insert?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_insert DD imagerel array_insert
	DD	imagerel array_insert+74
	DD	imagerel $unwind$array_insert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_insert DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_09EEABNKNH@nO?3insert?$AA@
CONST	SEGMENT
??_C@_09EEABNKNH@nO?3insert?$AA@ DB 'nO:insert', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_insert
_TEXT	SEGMENT
v$ = 32
i$ = 40
self$ = 64
args$ = 72
array_insert PROC					; COMDAT

; 1100 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1101 :     Py_ssize_t i;
; 1102 :     PyObject *v;
; 1103 :     if (!PyArg_ParseTuple(args, "nO:insert", &i, &v))

  0000e	4c 8d 4c 24 20	 lea	 r9, QWORD PTR v$[rsp]
  00013	4c 8d 44 24 28	 lea	 r8, QWORD PTR i$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09EEABNKNH@nO?3insert?$AA@
  0001f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN1@array_inse

; 1104 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 14		 jmp	 SHORT $LN2@array_inse
$LN1@array_inse:

; 1105 :     return ins(self, i, v);

  00031	4c 8b 44 24 20	 mov	 r8, QWORD PTR v$[rsp]
  00036	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00040	e8 00 00 00 00	 call	 ins
$LN2@array_inse:

; 1106 : }

  00045	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00049	c3		 ret	 0
array_insert ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ins DD	imagerel ins
	DD	imagerel ins+71
	DD	imagerel $unwind$ins
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ins DD	011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ins
_TEXT	SEGMENT
self$ = 48
where$ = 56
v$ = 64
ins	PROC						; COMDAT

; 957  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 958  :     if (ins1(self, where, v) != 0)

  00013	4c 8b 44 24 40	 mov	 r8, QWORD PTR v$[rsp]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR where$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00022	e8 00 00 00 00	 call	 ins1
  00027	85 c0		 test	 eax, eax
  00029	74 04		 je	 SHORT $LN1@ins

; 959  :         return NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 13		 jmp	 SHORT $LN2@ins
$LN1@ins:

; 960  :     Py_INCREF(Py_None);

  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00036	e8 00 00 00 00	 call	 _Py_IncRef

; 961  :     return Py_None;

  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@ins:

; 962  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
ins	ENDP
_TEXT	ENDS
EXTRN	PyLong_FromVoidPtr:PROC
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_buffer_info DD imagerel array_buffer_info
	DD	imagerel array_buffer_info+105
	DD	imagerel $unwind$array_buffer_info
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_buffer_info DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_buffer_info
_TEXT	SEGMENT
retval$ = 32
self$ = 64
unused$ = 72
array_buffer_info PROC					; COMDAT

; 1116 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1117 :     PyObject* retval = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR retval$[rsp], 0

; 1118 :     retval = PyTuple_New(2);

  00017	b9 02 00 00 00	 mov	 ecx, 2
  0001c	e8 00 00 00 00	 call	 PyTuple_New
  00021	48 89 44 24 20	 mov	 QWORD PTR retval$[rsp], rax

; 1119 :     if (!retval)

  00026	48 83 7c 24 20
	00		 cmp	 QWORD PTR retval$[rsp], 0
  0002c	75 04		 jne	 SHORT $LN1@array_buff

; 1120 :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 32		 jmp	 SHORT $LN2@array_buff
$LN1@array_buff:

; 1121 : 
; 1122 :     PyTuple_SET_ITEM(retval, 0, PyLong_FromVoidPtr(self->ob_item));

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00037	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0003b	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR retval$[rsp]
  00045	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 1123 :     PyTuple_SET_ITEM(retval, 1, PyLong_FromLong((long)(Py_SIZE(self))));

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004e	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  00051	e8 00 00 00 00	 call	 PyLong_FromLong
  00056	48 8b 4c 24 20	 mov	 rcx, QWORD PTR retval$[rsp]
  0005b	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax

; 1124 : 
; 1125 :     return retval;

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR retval$[rsp]
$LN2@array_buff:

; 1126 : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
array_buffer_info ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_append DD imagerel array_append
	DD	imagerel array_append+43
	DD	imagerel $unwind$array_append
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_append DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_append
_TEXT	SEGMENT
self$ = 48
v$ = 56
array_append PROC					; COMDAT

; 1139 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1140 :     return ins(self, Py_SIZE(self), v);

  0000e	4c 8b 44 24 38	 mov	 r8, QWORD PTR v$[rsp]
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00021	e8 00 00 00 00	 call	 ins

; 1141 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
array_append ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@PDOKFCDD@don?8t?5know?5how?5to?5byteswap?5this?5@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_byteswap DD imagerel array_byteswap
	DD	imagerel array_byteswap+641
	DD	imagerel $unwind$array_byteswap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_byteswap DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0CL@PDOKFCDD@don?8t?5know?5how?5to?5byteswap?5this?5@
CONST	SEGMENT
??_C@_0CL@PDOKFCDD@don?8t?5know?5how?5to?5byteswap?5this?5@ DB 'don''t kn'
	DB	'ow how to byteswap this array type', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_byteswap
_TEXT	SEGMENT
p$ = 32
i$ = 40
p0$21429 = 48
p0$21435 = 49
p1$21436 = 50
p0$21442 = 51
p2$21444 = 52
p3$21445 = 53
p1$21443 = 54
tv66 = 56
self$ = 80
unused$ = 88
array_byteswap PROC					; COMDAT

; 1151 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1152 :     char *p;
; 1153 :     Py_ssize_t i;
; 1154 : 
; 1155 :     switch (self->ob_descr->itemsize) {

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0001a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0001d	89 44 24 38	 mov	 DWORD PTR tv66[rsp], eax
  00021	83 7c 24 38 01	 cmp	 DWORD PTR tv66[rsp], 1
  00026	74 22		 je	 SHORT $LN14@array_byte
  00028	83 7c 24 38 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002d	74 20		 je	 SHORT $LN13@array_byte
  0002f	83 7c 24 38 04	 cmp	 DWORD PTR tv66[rsp], 4
  00034	0f 84 86 00 00
	00		 je	 $LN9@array_byte
  0003a	83 7c 24 38 08	 cmp	 DWORD PTR tv66[rsp], 8
  0003f	0f 84 17 01 00
	00		 je	 $LN5@array_byte
  00045	e9 08 02 00 00	 jmp	 $LN1@array_byte
$LN14@array_byte:

; 1156 :     case 1:
; 1157 :         break;

  0004a	e9 1a 02 00 00	 jmp	 $LN15@array_byte
$LN13@array_byte:

; 1158 :     case 2:
; 1159 :         for (p = self->ob_item, i = Py_SIZE(self); --i >= 0; p += 2) {

  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00054	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00058	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00062	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00066	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0006b	eb 0e		 jmp	 SHORT $LN12@array_byte
$LN11@array_byte:
  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00072	48 83 c0 02	 add	 rax, 2
  00076	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN12@array_byte:
  0007b	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00080	48 ff c8	 dec	 rax
  00083	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00088	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  0008e	7c 2b		 jl	 SHORT $LN10@array_byte

; 1160 :             char p0 = p[0];

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00095	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00098	88 44 24 30	 mov	 BYTE PTR p0$21429[rsp], al

; 1161 :             p[0] = p[1];

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000a6	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  000aa	88 08		 mov	 BYTE PTR [rax], cl

; 1162 :             p[1] = p0;

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000b1	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR p0$21429[rsp]
  000b6	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 1163 :         }

  000b9	eb b2		 jmp	 SHORT $LN11@array_byte
$LN10@array_byte:

; 1164 :         break;

  000bb	e9 a9 01 00 00	 jmp	 $LN15@array_byte
$LN9@array_byte:

; 1165 :     case 4:
; 1166 :         for (p = self->ob_item, i = Py_SIZE(self); --i >= 0; p += 4) {

  000c0	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c5	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000c9	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d7	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  000dc	eb 0e		 jmp	 SHORT $LN8@array_byte
$LN7@array_byte:
  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000e3	48 83 c0 04	 add	 rax, 4
  000e7	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN8@array_byte:
  000ec	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000f1	48 ff c8	 dec	 rax
  000f4	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  000f9	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  000ff	7c 56		 jl	 SHORT $LN6@array_byte

; 1167 :             char p0 = p[0];

  00101	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00106	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00109	88 44 24 31	 mov	 BYTE PTR p0$21435[rsp], al

; 1168 :             char p1 = p[1];

  0010d	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00112	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00116	88 44 24 32	 mov	 BYTE PTR p1$21436[rsp], al

; 1169 :             p[0] = p[3];

  0011a	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0011f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00124	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  00128	88 08		 mov	 BYTE PTR [rax], cl

; 1170 :             p[1] = p[2];

  0012a	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0012f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00134	0f b6 49 02	 movzx	 ecx, BYTE PTR [rcx+2]
  00138	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 1171 :             p[2] = p1;

  0013b	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00140	0f b6 4c 24 32	 movzx	 ecx, BYTE PTR p1$21436[rsp]
  00145	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 1172 :             p[3] = p0;

  00148	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0014d	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR p0$21435[rsp]
  00152	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 1173 :         }

  00155	eb 87		 jmp	 SHORT $LN7@array_byte
$LN6@array_byte:

; 1174 :         break;

  00157	e9 0d 01 00 00	 jmp	 $LN15@array_byte
$LN5@array_byte:

; 1175 :     case 8:
; 1176 :         for (p = self->ob_item, i = Py_SIZE(self); --i >= 0; p += 8) {

  0015c	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00161	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00165	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  0016a	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0016f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00173	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00178	eb 0e		 jmp	 SHORT $LN4@array_byte
$LN3@array_byte:
  0017a	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0017f	48 83 c0 08	 add	 rax, 8
  00183	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN4@array_byte:
  00188	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0018d	48 ff c8	 dec	 rax
  00190	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00195	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  0019b	0f 8c af 00 00
	00		 jl	 $LN2@array_byte

; 1177 :             char p0 = p[0];

  001a1	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001a6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a9	88 44 24 33	 mov	 BYTE PTR p0$21442[rsp], al

; 1178 :             char p1 = p[1];

  001ad	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001b2	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001b6	88 44 24 36	 mov	 BYTE PTR p1$21443[rsp], al

; 1179 :             char p2 = p[2];

  001ba	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001bf	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001c3	88 44 24 34	 mov	 BYTE PTR p2$21444[rsp], al

; 1180 :             char p3 = p[3];

  001c7	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001cc	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001d0	88 44 24 35	 mov	 BYTE PTR p3$21445[rsp], al

; 1181 :             p[0] = p[7];

  001d4	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001d9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001de	0f b6 49 07	 movzx	 ecx, BYTE PTR [rcx+7]
  001e2	88 08		 mov	 BYTE PTR [rax], cl

; 1182 :             p[1] = p[6];

  001e4	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001e9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001ee	0f b6 49 06	 movzx	 ecx, BYTE PTR [rcx+6]
  001f2	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 1183 :             p[2] = p[5];

  001f5	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001fa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001ff	0f b6 49 05	 movzx	 ecx, BYTE PTR [rcx+5]
  00203	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 1184 :             p[3] = p[4];

  00206	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0020b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00210	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00214	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 1185 :             p[4] = p3;

  00217	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0021c	0f b6 4c 24 35	 movzx	 ecx, BYTE PTR p3$21445[rsp]
  00221	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 1186 :             p[5] = p2;

  00224	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00229	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR p2$21444[rsp]
  0022e	88 48 05	 mov	 BYTE PTR [rax+5], cl

; 1187 :             p[6] = p1;

  00231	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00236	0f b6 4c 24 36	 movzx	 ecx, BYTE PTR p1$21443[rsp]
  0023b	88 48 06	 mov	 BYTE PTR [rax+6], cl

; 1188 :             p[7] = p0;

  0023e	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00243	0f b6 4c 24 33	 movzx	 ecx, BYTE PTR p0$21442[rsp]
  00248	88 48 07	 mov	 BYTE PTR [rax+7], cl

; 1189 :         }

  0024b	e9 2a ff ff ff	 jmp	 $LN3@array_byte
$LN2@array_byte:

; 1190 :         break;

  00250	eb 17		 jmp	 SHORT $LN15@array_byte
$LN1@array_byte:

; 1191 :     default:
; 1192 :         PyErr_SetString(PyExc_RuntimeError,
; 1193 :                    "don't know how to byteswap this array type");

  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@PDOKFCDD@don?8t?5know?5how?5to?5byteswap?5this?5@
  00259	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00260	e8 00 00 00 00	 call	 PyErr_SetString

; 1194 :         return NULL;

  00265	33 c0		 xor	 eax, eax
  00267	eb 13		 jmp	 SHORT $LN17@array_byte
$LN15@array_byte:

; 1195 :     }
; 1196 :     Py_INCREF(Py_None);

  00269	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00270	e8 00 00 00 00	 call	 _Py_IncRef

; 1197 :     return Py_None;

  00275	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN17@array_byte:

; 1198 : }

  0027c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00280	c3		 ret	 0
array_byteswap ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EA@FAJCDDFK@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AAi?$AAt?$AAe?$AAm?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_reverse DD imagerel array_reverse
	DD	imagerel array_reverse+320
	DD	imagerel $unwind$array_reverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_reverse DD 021101H
	DD	0290111H
xdata	ENDS
;	COMDAT ??_C@_1EA@FAJCDDFK@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AAi?$AAt?$AAe?$AAm?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@FAJCDDFK@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AAi?$AAt?$AAe?$AAm?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@ DB '('
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	')', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'm', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H
	DB	's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '('
	DB	00H, 't', 00H, 'm', 00H, 'p', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_reverse
_TEXT	SEGMENT
p$ = 32
itemsize$ = 40
tmp$ = 48
q$ = 304
self$ = 336
unused$ = 344
array_reverse PROC					; COMDAT

; 1208 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H

; 1209 :     register Py_ssize_t itemsize = self->ob_descr->itemsize;

  00011	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00019	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00020	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00024	48 89 44 24 28	 mov	 QWORD PTR itemsize$[rsp], rax

; 1210 :     register char *p, *q;
; 1211 :     /* little buffer to hold items while swapping */
; 1212 :     char tmp[256];      /* 8 is probably enough -- but why skimp */
; 1213 :     assert((size_t)itemsize <= sizeof(tmp));

  00029	48 81 7c 24 28
	00 01 00 00	 cmp	 QWORD PTR itemsize$[rsp], 256 ; 00000100H
  00032	76 1c		 jbe	 SHORT $LN7@array_reve
  00034	41 b8 bd 04 00
	00		 mov	 r8d, 1213		; 000004bdH
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@FAJCDDFK@?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AAi?$AAt?$AAe?$AAm?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAt?$AAm?$AAp?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN7@array_reve:

; 1214 : 
; 1215 :     if (Py_SIZE(self) > 1) {

  00050	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00058	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  0005d	0f 8e c2 00 00
	00		 jle	 $LN4@array_reve

; 1216 :         for (p = self->ob_item,
; 1217 :              q = self->ob_item + (Py_SIZE(self) - 1)*itemsize;
; 1218 :              p < q;
; 1219 :              p += itemsize, q -= itemsize) {

  00063	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0006b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0006f	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00074	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0007c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00080	48 ff c8	 dec	 rax
  00083	48 0f af 44 24
	28		 imul	 rax, QWORD PTR itemsize$[rsp]
  00089	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00091	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  00095	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR q$[rsp], rax
  0009d	eb 30		 jmp	 SHORT $LN3@array_reve
$LN2@array_reve:
  0009f	48 8b 44 24 28	 mov	 rax, QWORD PTR itemsize$[rsp]
  000a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000a9	48 03 c8	 add	 rcx, rax
  000ac	48 8b c1	 mov	 rax, rcx
  000af	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  000b4	48 8b 44 24 28	 mov	 rax, QWORD PTR itemsize$[rsp]
  000b9	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR q$[rsp]
  000c1	48 2b c8	 sub	 rcx, rax
  000c4	48 8b c1	 mov	 rax, rcx
  000c7	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR q$[rsp], rax
$LN3@array_reve:
  000cf	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR q$[rsp]
  000d7	48 39 44 24 20	 cmp	 QWORD PTR p$[rsp], rax
  000dc	73 47		 jae	 SHORT $LN1@array_reve

; 1220 :             /* memory areas guaranteed disjoint, so memcpy
; 1221 :              * is safe (& memmove may be slower).
; 1222 :              */
; 1223 :             memcpy(tmp, p, itemsize);

  000de	4c 8b 44 24 28	 mov	 r8, QWORD PTR itemsize$[rsp]
  000e3	48 8b 54 24 20	 mov	 rdx, QWORD PTR p$[rsp]
  000e8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR tmp$[rsp]
  000ed	e8 00 00 00 00	 call	 memcpy

; 1224 :             memcpy(p, q, itemsize);

  000f2	4c 8b 44 24 28	 mov	 r8, QWORD PTR itemsize$[rsp]
  000f7	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR q$[rsp]
  000ff	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00104	e8 00 00 00 00	 call	 memcpy

; 1225 :             memcpy(q, tmp, itemsize);

  00109	4c 8b 44 24 28	 mov	 r8, QWORD PTR itemsize$[rsp]
  0010e	48 8d 54 24 30	 lea	 rdx, QWORD PTR tmp$[rsp]
  00113	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR q$[rsp]
  0011b	e8 00 00 00 00	 call	 memcpy

; 1226 :         }

  00120	e9 7a ff ff ff	 jmp	 $LN2@array_reve
$LN1@array_reve:
$LN4@array_reve:

; 1227 :     }
; 1228 : 
; 1229 :     Py_INCREF(Py_None);

  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0012c	e8 00 00 00 00	 call	 _Py_IncRef

; 1230 :     return Py_None;

  00131	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 1231 : }

  00138	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  0013f	c3		 ret	 0
array_reverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@GIMCCOCP@read?$CI?$CJ?5didn?8t?5return?5enough?5byte@ ; `string'
PUBLIC	??_C@_03IELNPCCE@?$CIO?$CJ?$AA@			; `string'
PUBLIC	??_C@_1CC@DHEDCFGE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BL@MCBECLD@read?$CI?$CJ?5didn?8t?5return?5bytes?$AA@ ; `string'
PUBLIC	??_C@_01EFFIKLCJ@n?$AA@				; `string'
PUBLIC	??_C@_0P@DIJHAIGC@negative?5count?$AA@		; `string'
PUBLIC	??_C@_0M@LKCNGHFH@On?3fromfile?$AA@		; `string'
EXTRN	PyExc_EOFError:QWORD
EXTRN	_Py_BuildValue_SizeT:PROC
EXTRN	_PyObject_CallMethodId_SizeT:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_fromfile DD imagerel array_fromfile
	DD	imagerel array_fromfile+520
	DD	imagerel $unwind$array_fromfile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_fromfile DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0CC@GIMCCOCP@read?$CI?$CJ?5didn?8t?5return?5enough?5byte@
CONST	SEGMENT
??_C@_0CC@GIMCCOCP@read?$CI?$CJ?5didn?8t?5return?5enough?5byte@ DB 'read('
	DB	') didn''t return enough bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_03IELNPCCE@?$CIO?$CJ?$AA@ DB '(O)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DHEDCFGE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@DHEDCFGE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'b', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MCBECLD@read?$CI?$CJ?5didn?8t?5return?5bytes?$AA@
CONST	SEGMENT
??_C@_0BL@MCBECLD@read?$CI?$CJ?5didn?8t?5return?5bytes?$AA@ DB 'read() di'
	DB	'dn''t return bytes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n?$AA@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n?$AA@ DB 'n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DIJHAIGC@negative?5count?$AA@
CONST	SEGMENT
??_C@_0P@DIJHAIGC@negative?5count?$AA@ DB 'negative count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LKCNGHFH@On?3fromfile?$AA@
CONST	SEGMENT
??_C@_0M@LKCNGHFH@On?3fromfile?$AA@ DB 'On:fromfile', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_fromfile
_TEXT	SEGMENT
res$ = 32
itemsize$ = 40
n$ = 48
f$ = 56
not_enough_bytes$ = 64
b$ = 72
nbytes$ = 80
tv140 = 88
self$ = 112
args$ = 120
array_fromfile PROC					; COMDAT

; 1244 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1245 :     PyObject *f, *b, *res;
; 1246 :     Py_ssize_t itemsize = self->ob_descr->itemsize;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0001a	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001e	48 89 44 24 28	 mov	 QWORD PTR itemsize$[rsp], rax

; 1247 :     Py_ssize_t n, nbytes;
; 1248 :     _Py_IDENTIFIER(read);
; 1249 :     int not_enough_bytes;
; 1250 : 
; 1251 :     if (!PyArg_ParseTuple(args, "On:fromfile", &f, &n))

  00023	4c 8d 4c 24 30	 lea	 r9, QWORD PTR n$[rsp]
  00028	4c 8d 44 24 38	 lea	 r8, QWORD PTR f$[rsp]
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@LKCNGHFH@On?3fromfile?$AA@
  00034	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00039	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003e	85 c0		 test	 eax, eax
  00040	75 07		 jne	 SHORT $LN8@array_from

; 1252 :         return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	e9 ba 01 00 00	 jmp	 $LN9@array_from
$LN8@array_from:

; 1253 : 
; 1254 :     if (n < 0) {

  00049	48 83 7c 24 30
	00		 cmp	 QWORD PTR n$[rsp], 0
  0004f	7d 1a		 jge	 SHORT $LN7@array_from

; 1255 :         PyErr_SetString(PyExc_ValueError, "negative count");

  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DIJHAIGC@negative?5count?$AA@
  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0005f	e8 00 00 00 00	 call	 PyErr_SetString

; 1256 :         return NULL;

  00064	33 c0		 xor	 eax, eax
  00066	e9 98 01 00 00	 jmp	 $LN9@array_from
$LN7@array_from:

; 1257 :     }
; 1258 :     if (n > PY_SSIZE_T_MAX / itemsize) {

  0006b	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00075	48 99		 cdq
  00077	48 f7 7c 24 28	 idiv	 QWORD PTR itemsize$[rsp]
  0007c	48 39 44 24 30	 cmp	 QWORD PTR n$[rsp], rax
  00081	7e 0c		 jle	 SHORT $LN6@array_from

; 1259 :         PyErr_NoMemory();

  00083	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1260 :         return NULL;

  00088	33 c0		 xor	 eax, eax
  0008a	e9 74 01 00 00	 jmp	 $LN9@array_from
$LN6@array_from:

; 1261 :     }
; 1262 :     nbytes = n * itemsize;

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00094	48 0f af 44 24
	28		 imul	 rax, QWORD PTR itemsize$[rsp]
  0009a	48 89 44 24 50	 mov	 QWORD PTR nbytes$[rsp], rax

; 1263 : 
; 1264 :     b = _PyObject_CallMethodId(f, &PyId_read, "n", nbytes);

  0009f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_read@?1??array_fromfile@@9@9
  000a4	8b c0		 mov	 eax, eax
  000a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000ac	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000b5	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000b9	4c 8b 4c 24 50	 mov	 r9, QWORD PTR nbytes$[rsp]
  000be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01EFFIKLCJ@n?$AA@
  000c5	48 8b d0	 mov	 rdx, rax
  000c8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  000cd	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  000d2	48 89 44 24 48	 mov	 QWORD PTR b$[rsp], rax

; 1265 :     if (b == NULL)

  000d7	48 83 7c 24 48
	00		 cmp	 QWORD PTR b$[rsp], 0
  000dd	75 07		 jne	 SHORT $LN5@array_from

; 1266 :         return NULL;

  000df	33 c0		 xor	 eax, eax
  000e1	e9 1d 01 00 00	 jmp	 $LN9@array_from
$LN5@array_from:

; 1267 : 
; 1268 :     if (!PyBytes_Check(b)) {

  000e6	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  000eb	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ef	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f5	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000fa	85 c0		 test	 eax, eax
  000fc	75 24		 jne	 SHORT $LN4@array_from

; 1269 :         PyErr_SetString(PyExc_TypeError,
; 1270 :                         "read() didn't return bytes");

  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@MCBECLD@read?$CI?$CJ?5didn?8t?5return?5bytes?$AA@
  00105	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0010c	e8 00 00 00 00	 call	 PyErr_SetString

; 1271 :         Py_DECREF(b);

  00111	48 8b 4c 24 48	 mov	 rcx, QWORD PTR b$[rsp]
  00116	e8 00 00 00 00	 call	 _Py_DecRef

; 1272 :         return NULL;

  0011b	33 c0		 xor	 eax, eax
  0011d	e9 e1 00 00 00	 jmp	 $LN9@array_from
$LN4@array_from:

; 1273 :     }
; 1274 : 
; 1275 :     not_enough_bytes = (PyBytes_GET_SIZE(b) != nbytes);

  00122	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  00127	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0012b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00131	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00136	85 c0		 test	 eax, eax
  00138	75 1c		 jne	 SHORT $LN11@array_from
  0013a	41 b8 fb 04 00
	00		 mov	 r8d, 1275		; 000004fbH
  00140	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@DHEDCFGE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AA?$CJ?$AA?$AA@
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00154	33 c0		 xor	 eax, eax
$LN11@array_from:
  00156	48 8b 44 24 48	 mov	 rax, QWORD PTR b$[rsp]
  0015b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00160	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00164	74 0a		 je	 SHORT $LN12@array_from
  00166	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv140[rsp], 1
  0016e	eb 08		 jmp	 SHORT $LN13@array_from
$LN12@array_from:
  00170	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
$LN13@array_from:
  00178	8b 44 24 58	 mov	 eax, DWORD PTR tv140[rsp]
  0017c	89 44 24 40	 mov	 DWORD PTR not_enough_bytes$[rsp], eax

; 1276 : 
; 1277 :     args = Py_BuildValue("(O)", b);

  00180	48 8b 54 24 48	 mov	 rdx, QWORD PTR b$[rsp]
  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  0018c	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00191	48 89 44 24 78	 mov	 QWORD PTR args$[rsp], rax

; 1278 :     Py_DECREF(b);

  00196	48 8b 4c 24 48	 mov	 rcx, QWORD PTR b$[rsp]
  0019b	e8 00 00 00 00	 call	 _Py_DecRef

; 1279 :     if (args == NULL)

  001a0	48 83 7c 24 78
	00		 cmp	 QWORD PTR args$[rsp], 0
  001a6	75 04		 jne	 SHORT $LN3@array_from

; 1280 :         return NULL;

  001a8	33 c0		 xor	 eax, eax
  001aa	eb 57		 jmp	 SHORT $LN9@array_from
$LN3@array_from:

; 1281 : 
; 1282 :     res = array_frombytes(self, args);

  001ac	48 8b 54 24 78	 mov	 rdx, QWORD PTR args$[rsp]
  001b1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001b6	e8 00 00 00 00	 call	 array_frombytes
  001bb	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 1283 :     Py_DECREF(args);

  001c0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  001c5	e8 00 00 00 00	 call	 _Py_DecRef

; 1284 :     if (res == NULL)

  001ca	48 83 7c 24 20
	00		 cmp	 QWORD PTR res$[rsp], 0
  001d0	75 04		 jne	 SHORT $LN2@array_from

; 1285 :         return NULL;

  001d2	33 c0		 xor	 eax, eax
  001d4	eb 2d		 jmp	 SHORT $LN9@array_from
$LN2@array_from:

; 1286 : 
; 1287 :     if (not_enough_bytes) {

  001d6	83 7c 24 40 00	 cmp	 DWORD PTR not_enough_bytes$[rsp], 0
  001db	74 21		 je	 SHORT $LN1@array_from

; 1288 :         PyErr_SetString(PyExc_EOFError,
; 1289 :                         "read() didn't return enough bytes");

  001dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@GIMCCOCP@read?$CI?$CJ?5didn?8t?5return?5enough?5byte@
  001e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_EOFError
  001eb	e8 00 00 00 00	 call	 PyErr_SetString

; 1290 :         Py_DECREF(res);

  001f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  001f5	e8 00 00 00 00	 call	 _Py_DecRef

; 1291 :         return NULL;

  001fa	33 c0		 xor	 eax, eax
  001fc	eb 05		 jmp	 SHORT $LN9@array_from
$LN1@array_from:

; 1292 :     }
; 1293 : 
; 1294 :     return res;

  001fe	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
$LN9@array_from:

; 1295 : }

  00203	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00207	c3		 ret	 0
array_fromfile ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_tofile DD imagerel array_tofile
	DD	imagerel array_tofile+398
	DD	imagerel $unwind$array_tofile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_tofile DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_tofile
_TEXT	SEGMENT
i$ = 32
nblocks$ = 40
BLOCKSIZE$ = 48
nbytes$ = 56
res$21550 = 64
ptr$21547 = 72
size$21548 = 80
bytes$21549 = 88
self$ = 112
f$ = 120
array_tofile PROC					; COMDAT

; 1306 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1307 :     Py_ssize_t nbytes = Py_SIZE(self) * self->ob_descr->itemsize;

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0001a	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00023	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00027	48 0f af c8	 imul	 rcx, rax
  0002b	48 8b c1	 mov	 rax, rcx
  0002e	48 89 44 24 38	 mov	 QWORD PTR nbytes$[rsp], rax

; 1308 :     /* Write 64K blocks at a time */
; 1309 :     /* XXX Make the block size settable */
; 1310 :     int BLOCKSIZE = 64*1024;

  00033	c7 44 24 30 00
	00 01 00	 mov	 DWORD PTR BLOCKSIZE$[rsp], 65536 ; 00010000H

; 1311 :     Py_ssize_t nblocks = (nbytes + BLOCKSIZE - 1) / BLOCKSIZE;

  0003b	48 63 44 24 30	 movsxd	 rax, DWORD PTR BLOCKSIZE$[rsp]
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00045	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0004a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR BLOCKSIZE$[rsp]
  0004f	48 99		 cdq
  00051	48 f7 f9	 idiv	 rcx
  00054	48 89 44 24 28	 mov	 QWORD PTR nblocks$[rsp], rax

; 1312 :     Py_ssize_t i;
; 1313 : 
; 1314 :     if (Py_SIZE(self) == 0)

  00059	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0005e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00063	75 05		 jne	 SHORT $LN7@array_tofi

; 1315 :         goto done;

  00065	e9 0c 01 00 00	 jmp	 $done$21543
$LN7@array_tofi:

; 1316 : 
; 1317 :     for (i = 0; i < nblocks; i++) {

  0006a	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00073	eb 0d		 jmp	 SHORT $LN6@array_tofi
$LN5@array_tofi:
  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0007a	48 ff c0	 inc	 rax
  0007d	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN6@array_tofi:
  00082	48 8b 44 24 28	 mov	 rax, QWORD PTR nblocks$[rsp]
  00087	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0008c	0f 8d e4 00 00
	00		 jge	 $LN4@array_tofi

; 1318 :         char* ptr = self->ob_item + i*BLOCKSIZE;

  00092	48 63 44 24 30	 movsxd	 rax, DWORD PTR BLOCKSIZE$[rsp]
  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0009c	48 0f af c8	 imul	 rcx, rax
  000a0	48 8b c1	 mov	 rax, rcx
  000a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000a8	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  000ac	48 89 44 24 48	 mov	 QWORD PTR ptr$21547[rsp], rax

; 1319 :         Py_ssize_t size = BLOCKSIZE;

  000b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR BLOCKSIZE$[rsp]
  000b6	48 89 44 24 50	 mov	 QWORD PTR size$21548[rsp], rax

; 1320 :         PyObject *bytes, *res;
; 1321 :         _Py_IDENTIFIER(write);
; 1322 : 
; 1323 :         if (i*BLOCKSIZE + size > nbytes)

  000bb	48 63 44 24 30	 movsxd	 rax, DWORD PTR BLOCKSIZE$[rsp]
  000c0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000c5	48 0f af c8	 imul	 rcx, rax
  000c9	48 8b c1	 mov	 rax, rcx
  000cc	48 03 44 24 50	 add	 rax, QWORD PTR size$21548[rsp]
  000d1	48 3b 44 24 38	 cmp	 rax, QWORD PTR nbytes$[rsp]
  000d6	7e 21		 jle	 SHORT $LN3@array_tofi

; 1324 :             size = nbytes - i*BLOCKSIZE;

  000d8	48 63 44 24 30	 movsxd	 rax, DWORD PTR BLOCKSIZE$[rsp]
  000dd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  000e2	48 0f af c8	 imul	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR nbytes$[rsp]
  000ee	48 2b c8	 sub	 rcx, rax
  000f1	48 8b c1	 mov	 rax, rcx
  000f4	48 89 44 24 50	 mov	 QWORD PTR size$21548[rsp], rax
$LN3@array_tofi:

; 1325 :         bytes = PyBytes_FromStringAndSize(ptr, size);

  000f9	48 8b 54 24 50	 mov	 rdx, QWORD PTR size$21548[rsp]
  000fe	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ptr$21547[rsp]
  00103	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00108	48 89 44 24 58	 mov	 QWORD PTR bytes$21549[rsp], rax

; 1326 :         if (bytes == NULL)

  0010d	48 83 7c 24 58
	00		 cmp	 QWORD PTR bytes$21549[rsp], 0
  00113	75 04		 jne	 SHORT $LN2@array_tofi

; 1327 :             return NULL;

  00115	33 c0		 xor	 eax, eax
  00117	eb 70		 jmp	 SHORT $LN8@array_tofi
$LN2@array_tofi:

; 1328 :         res = _PyObject_CallMethodId(f, &PyId_write, "O", bytes);

  00119	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_write@?2??array_tofile@@9@9
  0011e	8b c0		 mov	 eax, eax
  00120	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00126	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0012f	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00133	4c 8b 4c 24 58	 mov	 r9, QWORD PTR bytes$21549[rsp]
  00138	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  0013f	48 8b d0	 mov	 rdx, rax
  00142	48 8b 4c 24 78	 mov	 rcx, QWORD PTR f$[rsp]
  00147	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
  0014c	48 89 44 24 40	 mov	 QWORD PTR res$21550[rsp], rax

; 1329 :         Py_DECREF(bytes);

  00151	48 8b 4c 24 58	 mov	 rcx, QWORD PTR bytes$21549[rsp]
  00156	e8 00 00 00 00	 call	 _Py_DecRef

; 1330 :         if (res == NULL)

  0015b	48 83 7c 24 40
	00		 cmp	 QWORD PTR res$21550[rsp], 0
  00161	75 04		 jne	 SHORT $LN1@array_tofi

; 1331 :             return NULL;

  00163	33 c0		 xor	 eax, eax
  00165	eb 22		 jmp	 SHORT $LN8@array_tofi
$LN1@array_tofi:

; 1332 :         Py_DECREF(res); /* drop write result */

  00167	48 8b 4c 24 40	 mov	 rcx, QWORD PTR res$21550[rsp]
  0016c	e8 00 00 00 00	 call	 _Py_DecRef

; 1333 :     }

  00171	e9 ff fe ff ff	 jmp	 $LN5@array_tofi
$LN4@array_tofi:
$done$21543:

; 1334 : 
; 1335 :   done:
; 1336 :     Py_INCREF(Py_None);

  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0017d	e8 00 00 00 00	 call	 _Py_IncRef

; 1337 :     return Py_None;

  00182	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN8@array_tofi:

; 1338 : }

  00189	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018d	c3		 ret	 0
array_tofile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@CKIPGAKP@arg?5must?5be?5list?$AA@	; `string'
EXTRN	PyList_GetItem:PROC
EXTRN	PyList_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_fromlist DD imagerel array_fromlist
	DD	imagerel array_fromlist+314
	DD	imagerel $unwind$array_fromlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_fromlist DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0BB@CKIPGAKP@arg?5must?5be?5list?$AA@
CONST	SEGMENT
??_C@_0BB@CKIPGAKP@arg?5must?5be?5list?$AA@ DB 'arg must be list', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_fromlist
_TEXT	SEGMENT
n$ = 32
i$21578 = 40
old_size$21579 = 48
v$21586 = 56
tv130 = 64
self$ = 96
list$ = 104
array_fromlist PROC					; COMDAT

; 1348 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1349 :     Py_ssize_t n;
; 1350 : 
; 1351 :     if (!PyList_Check(list)) {

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR list$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00022	85 c0		 test	 eax, eax
  00024	75 1a		 jne	 SHORT $LN7@array_from@2

; 1352 :         PyErr_SetString(PyExc_TypeError, "arg must be list");

  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@CKIPGAKP@arg?5must?5be?5list?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00034	e8 00 00 00 00	 call	 PyErr_SetString

; 1353 :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 f5 00 00 00	 jmp	 $LN8@array_from@2
$LN7@array_from@2:

; 1354 :     }
; 1355 :     n = PyList_Size(list);

  00040	48 8b 4c 24 68	 mov	 rcx, QWORD PTR list$[rsp]
  00045	e8 00 00 00 00	 call	 PyList_Size
  0004a	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 1356 :     if (n > 0) {

  0004f	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  00055	0f 8e c7 00 00
	00		 jle	 $LN6@array_from@2

; 1357 :         Py_ssize_t i, old_size;
; 1358 :         old_size = Py_SIZE(self);

  0005b	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00060	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00064	48 89 44 24 30	 mov	 QWORD PTR old_size$21579[rsp], rax

; 1359 :         if (array_resize(self, old_size + n) == -1)

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR old_size$21579[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 8b d0	 mov	 rdx, rax
  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00081	e8 00 00 00 00	 call	 array_resize
  00086	83 f8 ff	 cmp	 eax, -1
  00089	75 07		 jne	 SHORT $LN5@array_from@2

; 1360 :             return NULL;

  0008b	33 c0		 xor	 eax, eax
  0008d	e9 a3 00 00 00	 jmp	 $LN8@array_from@2
$LN5@array_from@2:

; 1361 :         for (i = 0; i < n; i++) {

  00092	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$21578[rsp], 0
  0009b	eb 0d		 jmp	 SHORT $LN4@array_from@2
$LN3@array_from@2:
  0009d	48 8b 44 24 28	 mov	 rax, QWORD PTR i$21578[rsp]
  000a2	48 ff c0	 inc	 rax
  000a5	48 89 44 24 28	 mov	 QWORD PTR i$21578[rsp], rax
$LN4@array_from@2:
  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000af	48 39 44 24 28	 cmp	 QWORD PTR i$21578[rsp], rax
  000b4	7d 6c		 jge	 SHORT $LN2@array_from@2

; 1362 :             PyObject *v = PyList_GetItem(list, i);

  000b6	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$21578[rsp]
  000bb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR list$[rsp]
  000c0	e8 00 00 00 00	 call	 PyList_GetItem
  000c5	48 89 44 24 38	 mov	 QWORD PTR v$21586[rsp], rax

; 1363 :             if ((*self->ob_descr->setitem)(self,
; 1364 :                             Py_SIZE(self) - n + i, v) != 0) {

  000ca	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000cf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  000d4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d8	48 2b c1	 sub	 rax, rcx
  000db	48 03 44 24 28	 add	 rax, QWORD PTR i$21578[rsp]
  000e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000e5	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000ec	48 89 4c 24 40	 mov	 QWORD PTR tv130[rsp], rcx
  000f1	4c 8b 44 24 38	 mov	 r8, QWORD PTR v$21586[rsp]
  000f6	48 8b d0	 mov	 rdx, rax
  000f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000fe	48 8b 44 24 40	 mov	 rax, QWORD PTR tv130[rsp]
  00103	ff 50 10	 call	 QWORD PTR [rax+16]
  00106	85 c0		 test	 eax, eax
  00108	74 13		 je	 SHORT $LN1@array_from@2

; 1365 :                 array_resize(self, old_size);

  0010a	48 8b 54 24 30	 mov	 rdx, QWORD PTR old_size$21579[rsp]
  0010f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00114	e8 00 00 00 00	 call	 array_resize

; 1366 :                 return NULL;

  00119	33 c0		 xor	 eax, eax
  0011b	eb 18		 jmp	 SHORT $LN8@array_from@2
$LN1@array_from@2:

; 1367 :             }
; 1368 :         }

  0011d	e9 7b ff ff ff	 jmp	 $LN3@array_from@2
$LN2@array_from@2:
$LN6@array_from@2:

; 1369 :     }
; 1370 :     Py_INCREF(Py_None);

  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00129	e8 00 00 00 00	 call	 _Py_IncRef

; 1371 :     return Py_None;

  0012e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN8@array_from@2:

; 1372 : }

  00135	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00139	c3		 ret	 0
array_fromlist ENDP
_TEXT	ENDS
EXTRN	PyList_SetItem:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_tolist DD imagerel array_tolist
	DD	imagerel array_tolist+159
	DD	imagerel $unwind$array_tolist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_tolist DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_tolist
_TEXT	SEGMENT
i$ = 32
list$ = 40
v$21608 = 48
self$ = 80
unused$ = 88
array_tolist PROC					; COMDAT

; 1381 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1382 :     PyObject *list = PyList_New(Py_SIZE(self));

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00017	e8 00 00 00 00	 call	 PyList_New
  0001c	48 89 44 24 28	 mov	 QWORD PTR list$[rsp], rax

; 1383 :     Py_ssize_t i;
; 1384 : 
; 1385 :     if (list == NULL)

  00021	48 83 7c 24 28
	00		 cmp	 QWORD PTR list$[rsp], 0
  00027	75 04		 jne	 SHORT $LN5@array_toli

; 1386 :         return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 6d		 jmp	 SHORT $LN6@array_toli
$LN5@array_toli:

; 1387 :     for (i = 0; i < Py_SIZE(self); i++) {

  0002d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00036	eb 0d		 jmp	 SHORT $LN4@array_toli
$LN3@array_toli:
  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0003d	48 ff c0	 inc	 rax
  00040	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@array_toli:
  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004e	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00053	7d 40		 jge	 SHORT $LN2@array_toli

; 1388 :         PyObject *v = getarrayitem((PyObject *)self, i);

  00055	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0005f	e8 00 00 00 00	 call	 getarrayitem
  00064	48 89 44 24 30	 mov	 QWORD PTR v$21608[rsp], rax

; 1389 :         if (v == NULL) {

  00069	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$21608[rsp], 0
  0006f	75 0e		 jne	 SHORT $LN1@array_toli

; 1390 :             Py_DECREF(list);

  00071	48 8b 4c 24 28	 mov	 rcx, QWORD PTR list$[rsp]
  00076	e8 00 00 00 00	 call	 _Py_DecRef

; 1391 :             return NULL;

  0007b	33 c0		 xor	 eax, eax
  0007d	eb 1b		 jmp	 SHORT $LN6@array_toli
$LN1@array_toli:

; 1392 :         }
; 1393 :         PyList_SetItem(list, i, v);

  0007f	4c 8b 44 24 30	 mov	 r8, QWORD PTR v$21608[rsp]
  00084	48 8b 54 24 20	 mov	 rdx, QWORD PTR i$[rsp]
  00089	48 8b 4c 24 28	 mov	 rcx, QWORD PTR list$[rsp]
  0008e	e8 00 00 00 00	 call	 PyList_SetItem

; 1394 :     }

  00093	eb a3		 jmp	 SHORT $LN3@array_toli
$LN2@array_toli:

; 1395 :     return list;

  00095	48 8b 44 24 28	 mov	 rax, QWORD PTR list$[rsp]
$LN6@array_toli:

; 1396 : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
array_tolist ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@KNGGIENM@s?$CK?3fromstring?$AA@	; `string'
PUBLIC	??_C@_0DF@BOBJEIFM@fromstring?$CI?$CJ?5is?5deprecated?4?5Use?5@ ; `string'
EXTRN	PyErr_WarnEx:PROC
EXTRN	PyExc_DeprecationWarning:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_fromstring DD imagerel array_fromstring
	DD	imagerel array_fromstring+105
	DD	imagerel $unwind$array_fromstring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_fromstring DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0O@KNGGIENM@s?$CK?3fromstring?$AA@
CONST	SEGMENT
??_C@_0O@KNGGIENM@s?$CK?3fromstring?$AA@ DB 's*:fromstring', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@BOBJEIFM@fromstring?$CI?$CJ?5is?5deprecated?4?5Use?5@
CONST	SEGMENT
??_C@_0DF@BOBJEIFM@fromstring?$CI?$CJ?5is?5deprecated?4?5Use?5@ DB 'froms'
	DB	'tring() is deprecated. Use frombytes() instead.', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_fromstring
_TEXT	SEGMENT
buffer$ = 32
self$ = 128
args$ = 136
array_fromstring PROC					; COMDAT

; 1442 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1443 :     Py_buffer buffer;
; 1444 :     if (PyErr_WarnEx(PyExc_DeprecationWarning,
; 1445 :             "fromstring() is deprecated. Use frombytes() instead.", 2) != 0)

  0000e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@BOBJEIFM@fromstring?$CI?$CJ?5is?5deprecated?4?5Use?5@
  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_DeprecationWarning
  00022	e8 00 00 00 00	 call	 PyErr_WarnEx
  00027	85 c0		 test	 eax, eax
  00029	74 04		 je	 SHORT $LN3@array_from@3

; 1446 :         return NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 35		 jmp	 SHORT $LN4@array_from@3
$LN3@array_from@3:

; 1447 :     if (!PyArg_ParseTuple(args, "s*:fromstring", &buffer))

  0002f	4c 8d 44 24 20	 lea	 r8, QWORD PTR buffer$[rsp]
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@KNGGIENM@s?$CK?3fromstring?$AA@
  0003b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00043	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00048	85 c0		 test	 eax, eax
  0004a	75 06		 jne	 SHORT $LN2@array_from@3

; 1448 :         return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 14		 jmp	 SHORT $LN4@array_from@3

; 1449 :     else

  00050	eb 12		 jmp	 SHORT $LN1@array_from@3
$LN2@array_from@3:

; 1450 :         return frombytes(self, &buffer);

  00052	48 8d 54 24 20	 lea	 rdx, QWORD PTR buffer$[rsp]
  00057	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0005f	e8 00 00 00 00	 call	 frombytes
$LN1@array_from@3:
$LN4@array_from@3:

; 1451 : }

  00064	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00068	c3		 ret	 0
array_fromstring ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@CCOBPACL@string?5length?5not?5a?5multiple?5of?5@ ; `string'
PUBLIC	??_C@_0CB@DDGOLKLL@string?1buffer?5of?5bytes?5required?4@ ; `string'
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$frombytes DD imagerel frombytes
	DD	imagerel frombytes+457
	DD	imagerel $unwind$frombytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$frombytes DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0CK@CCOBPACL@string?5length?5not?5a?5multiple?5of?5@
CONST	SEGMENT
??_C@_0CK@CCOBPACL@string?5length?5not?5a?5multiple?5of?5@ DB 'string len'
	DB	'gth not a multiple of item size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@DDGOLKLL@string?1buffer?5of?5bytes?5required?4@
CONST	SEGMENT
??_C@_0CB@DDGOLKLL@string?1buffer?5of?5bytes?5required?4@ DB 'string/buff'
	DB	'er of bytes required.', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT frombytes
_TEXT	SEGMENT
itemsize$ = 32
n$ = 40
old_size$21630 = 48
tv72 = 56
tv78 = 64
tv84 = 72
self$ = 96
buffer$ = 104
frombytes PROC						; COMDAT

; 1405 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1406 :     int itemsize = self->ob_descr->itemsize;

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0001a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0001d	89 44 24 20	 mov	 DWORD PTR itemsize$[rsp], eax

; 1407 :     Py_ssize_t n;
; 1408 :     if (buffer->itemsize != 1) {

  00021	48 8b 44 24 68	 mov	 rax, QWORD PTR buffer$[rsp]
  00026	48 83 78 18 01	 cmp	 QWORD PTR [rax+24], 1
  0002b	74 24		 je	 SHORT $LN6@frombytes

; 1409 :         PyBuffer_Release(buffer);

  0002d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buffer$[rsp]
  00032	e8 00 00 00 00	 call	 PyBuffer_Release

; 1410 :         PyErr_SetString(PyExc_TypeError, "string/buffer of bytes required.");

  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@DDGOLKLL@string?1buffer?5of?5bytes?5required?4@
  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00045	e8 00 00 00 00	 call	 PyErr_SetString

; 1411 :         return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 73 01 00 00	 jmp	 $LN7@frombytes
$LN6@frombytes:

; 1412 :     }
; 1413 :     n = buffer->len;

  00051	48 8b 44 24 68	 mov	 rax, QWORD PTR buffer$[rsp]
  00056	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0005a	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 1414 :     if (n % itemsize != 0) {

  0005f	48 63 44 24 20	 movsxd	 rax, DWORD PTR itemsize$[rsp]
  00064	48 89 44 24 38	 mov	 QWORD PTR tv72[rsp], rax
  00069	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0006e	48 99		 cdq
  00070	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv72[rsp]
  00075	48 f7 f9	 idiv	 rcx
  00078	48 8b c2	 mov	 rax, rdx
  0007b	48 85 c0	 test	 rax, rax
  0007e	74 24		 je	 SHORT $LN5@frombytes

; 1415 :         PyBuffer_Release(buffer);

  00080	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buffer$[rsp]
  00085	e8 00 00 00 00	 call	 PyBuffer_Release

; 1416 :         PyErr_SetString(PyExc_ValueError,
; 1417 :                    "string length not a multiple of item size");

  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@CCOBPACL@string?5length?5not?5a?5multiple?5of?5@
  00091	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00098	e8 00 00 00 00	 call	 PyErr_SetString

; 1418 :         return NULL;

  0009d	33 c0		 xor	 eax, eax
  0009f	e9 20 01 00 00	 jmp	 $LN7@frombytes
$LN5@frombytes:

; 1419 :     }
; 1420 :     n = n / itemsize;

  000a4	48 63 44 24 20	 movsxd	 rax, DWORD PTR itemsize$[rsp]
  000a9	48 89 44 24 40	 mov	 QWORD PTR tv78[rsp], rax
  000ae	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  000b3	48 99		 cdq
  000b5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv78[rsp]
  000ba	48 f7 f9	 idiv	 rcx
  000bd	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 1421 :     if (n > 0) {

  000c2	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$[rsp], 0
  000c8	0f 8e d9 00 00
	00		 jle	 $LN4@frombytes

; 1422 :         Py_ssize_t old_size = Py_SIZE(self);

  000ce	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000d3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d7	48 89 44 24 30	 mov	 QWORD PTR old_size$21630[rsp], rax

; 1423 :         if ((n > PY_SSIZE_T_MAX - old_size) ||
; 1424 :             ((old_size + n) > PY_SSIZE_T_MAX / itemsize)) {

  000dc	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000e6	48 2b 44 24 30	 sub	 rax, QWORD PTR old_size$21630[rsp]
  000eb	48 39 44 24 28	 cmp	 QWORD PTR n$[rsp], rax
  000f0	7f 36		 jg	 SHORT $LN2@frombytes
  000f2	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  000f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR old_size$21630[rsp]
  000fc	48 03 c8	 add	 rcx, rax
  000ff	48 8b c1	 mov	 rax, rcx
  00102	48 89 44 24 48	 mov	 QWORD PTR tv84[rsp], rax
  00107	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR itemsize$[rsp]
  0010c	48 ba ff ff ff
	ff ff ff ff 7f	 mov	 rdx, 9223372036854775807 ; 7fffffffffffffffH
  00116	48 8b c2	 mov	 rax, rdx
  00119	48 99		 cdq
  0011b	48 f7 f9	 idiv	 rcx
  0011e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv84[rsp]
  00123	48 3b c8	 cmp	 rcx, rax
  00126	7e 14		 jle	 SHORT $LN3@frombytes
$LN2@frombytes:

; 1425 :                 PyBuffer_Release(buffer);

  00128	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buffer$[rsp]
  0012d	e8 00 00 00 00	 call	 PyBuffer_Release

; 1426 :                 return PyErr_NoMemory();

  00132	e8 00 00 00 00	 call	 PyErr_NoMemory
  00137	e9 88 00 00 00	 jmp	 $LN7@frombytes
$LN3@frombytes:

; 1427 :         }
; 1428 :         if (array_resize(self, old_size + n) == -1) {

  0013c	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00141	48 8b 4c 24 30	 mov	 rcx, QWORD PTR old_size$21630[rsp]
  00146	48 03 c8	 add	 rcx, rax
  00149	48 8b c1	 mov	 rax, rcx
  0014c	48 8b d0	 mov	 rdx, rax
  0014f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00154	e8 00 00 00 00	 call	 array_resize
  00159	83 f8 ff	 cmp	 eax, -1
  0015c	75 0e		 jne	 SHORT $LN1@frombytes

; 1429 :             PyBuffer_Release(buffer);

  0015e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buffer$[rsp]
  00163	e8 00 00 00 00	 call	 PyBuffer_Release

; 1430 :             return NULL;

  00168	33 c0		 xor	 eax, eax
  0016a	eb 58		 jmp	 SHORT $LN7@frombytes
$LN1@frombytes:

; 1431 :         }
; 1432 :         memcpy(self->ob_item + old_size * itemsize,
; 1433 :             buffer->buf, n * itemsize);

  0016c	48 63 44 24 20	 movsxd	 rax, DWORD PTR itemsize$[rsp]
  00171	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$[rsp]
  00176	48 0f af c8	 imul	 rcx, rax
  0017a	48 8b c1	 mov	 rax, rcx
  0017d	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR itemsize$[rsp]
  00182	48 8b 54 24 30	 mov	 rdx, QWORD PTR old_size$21630[rsp]
  00187	48 0f af d1	 imul	 rdx, rcx
  0018b	48 8b ca	 mov	 rcx, rdx
  0018e	48 8b 54 24 60	 mov	 rdx, QWORD PTR self$[rsp]
  00193	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  00197	4c 8b c0	 mov	 r8, rax
  0019a	48 8b 44 24 68	 mov	 rax, QWORD PTR buffer$[rsp]
  0019f	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001a2	e8 00 00 00 00	 call	 memcpy
$LN4@frombytes:

; 1434 :     }
; 1435 :     PyBuffer_Release(buffer);

  001a7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buffer$[rsp]
  001ac	e8 00 00 00 00	 call	 PyBuffer_Release

; 1436 :     Py_INCREF(Py_None);

  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  001b8	e8 00 00 00 00	 call	 _Py_IncRef

; 1437 :     return Py_None;

  001bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN7@frombytes:

; 1438 : }

  001c4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c8	c3		 ret	 0
frombytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@LICNHJM@y?$CK?3frombytes?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_frombytes DD imagerel array_frombytes
	DD	imagerel array_frombytes+72
	DD	imagerel $unwind$array_frombytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_frombytes DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0N@LICNHJM@y?$CK?3frombytes?$AA@
CONST	SEGMENT
??_C@_0N@LICNHJM@y?$CK?3frombytes?$AA@ DB 'y*:frombytes', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_frombytes
_TEXT	SEGMENT
buffer$ = 32
self$ = 128
args$ = 136
array_frombytes PROC					; COMDAT

; 1464 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1465 :     Py_buffer buffer;
; 1466 :     if (!PyArg_ParseTuple(args, "y*:frombytes", &buffer))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR buffer$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LICNHJM@y?$CK?3frombytes?$AA@
  0001a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00022	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00027	85 c0		 test	 eax, eax
  00029	75 06		 jne	 SHORT $LN2@array_from@4

; 1467 :         return NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 14		 jmp	 SHORT $LN3@array_from@4

; 1468 :     else

  0002f	eb 12		 jmp	 SHORT $LN1@array_from@4
$LN2@array_from@4:

; 1469 :         return frombytes(self, &buffer);

  00031	48 8d 54 24 20	 lea	 rdx, QWORD PTR buffer$[rsp]
  00036	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0003e	e8 00 00 00 00	 call	 frombytes
$LN1@array_from@4:
$LN3@array_from@4:

; 1470 : }

  00043	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00047	c3		 ret	 0
array_frombytes ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_tobytes DD imagerel array_tobytes
	DD	imagerel array_tobytes+132
	DD	imagerel $unwind$array_tobytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_tobytes DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_tobytes
_TEXT	SEGMENT
tv67 = 32
self$ = 64
unused$ = 72
array_tobytes PROC					; COMDAT

; 1481 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1482 :     if (Py_SIZE(self) <= PY_SSIZE_T_MAX / self->ob_descr->itemsize) {

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0001a	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001e	48 89 44 24 20	 mov	 QWORD PTR tv67[rsp], rax
  00023	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0002d	48 8b c1	 mov	 rax, rcx
  00030	48 99		 cdq
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv67[rsp]
  00037	48 f7 f9	 idiv	 rcx
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0003f	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00043	7f 35		 jg	 SHORT $LN2@array_toby

; 1483 :         return PyBytes_FromStringAndSize(self->ob_item,
; 1484 :                             Py_SIZE(self) * self->ob_descr->itemsize);

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00051	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005a	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0005e	48 0f af c8	 imul	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 8b d0	 mov	 rdx, rax
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006d	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00071	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00076	eb 07		 jmp	 SHORT $LN3@array_toby

; 1485 :     } else {

  00078	eb 05		 jmp	 SHORT $LN1@array_toby
$LN2@array_toby:

; 1486 :         return PyErr_NoMemory();

  0007a	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN1@array_toby:
$LN3@array_toby:

; 1487 :     }
; 1488 : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
array_tobytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@BGKCCGMJ@tostring?$CI?$CJ?5is?5deprecated?4?5Use?5to@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_tostring DD imagerel array_tostring
	DD	imagerel array_tostring+67
	DD	imagerel $unwind$array_tostring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_tostring DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0DB@BGKCCGMJ@tostring?$CI?$CJ?5is?5deprecated?4?5Use?5to@
CONST	SEGMENT
??_C@_0DB@BGKCCGMJ@tostring?$CI?$CJ?5is?5deprecated?4?5Use?5to@ DB 'tostr'
	DB	'ing() is deprecated. Use tobytes() instead.', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_tostring
_TEXT	SEGMENT
self$ = 48
unused$ = 56
array_tostring PROC					; COMDAT

; 1499 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1500 :     if (PyErr_WarnEx(PyExc_DeprecationWarning,
; 1501 :             "tostring() is deprecated. Use tobytes() instead.", 2) != 0)

  0000e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@BGKCCGMJ@tostring?$CI?$CJ?5is?5deprecated?4?5Use?5to@
  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_DeprecationWarning
  00022	e8 00 00 00 00	 call	 PyErr_WarnEx
  00027	85 c0		 test	 eax, eax
  00029	74 04		 je	 SHORT $LN1@array_tost

; 1502 :         return NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 0f		 jmp	 SHORT $LN2@array_tost
$LN1@array_tost:

; 1503 :     return array_tobytes(self, unused);

  0002f	48 8b 54 24 38	 mov	 rdx, QWORD PTR unused$[rsp]
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00039	e8 00 00 00 00	 call	 array_tobytes
$LN2@array_tost:

; 1504 : }

  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00042	c3		 ret	 0
array_tostring ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@MJAINOPC@fromunicode?$CI?$CJ?5may?5only?5be?5called@ ; `string'
PUBLIC	??_C@_0P@IHHELFOJ@u?$CD?3fromunicode?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_fromunicode DD imagerel array_fromunicode
	DD	imagerel array_fromunicode+227
	DD	imagerel $unwind$array_fromunicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_fromunicode DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0DI@MJAINOPC@fromunicode?$CI?$CJ?5may?5only?5be?5called@
CONST	SEGMENT
??_C@_0DI@MJAINOPC@fromunicode?$CI?$CJ?5may?5only?5be?5called@ DB 'fromun'
	DB	'icode() may only be called on unicode type arrays', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IHHELFOJ@u?$CD?3fromunicode?$AA@
CONST	SEGMENT
??_C@_0P@IHHELFOJ@u?$CD?3fromunicode?$AA@ DB 'u#:fromunicode', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_fromunicode
_TEXT	SEGMENT
ustr$ = 32
n$ = 40
typecode$ = 48
old_size$21706 = 56
self$ = 80
args$ = 88
array_fromunicode PROC					; COMDAT

; 1517 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1518 :     Py_UNICODE *ustr;
; 1519 :     Py_ssize_t n;
; 1520 :     char typecode;
; 1521 : 
; 1522 :     if (!PyArg_ParseTuple(args, "u#:fromunicode", &ustr, &n))

  0000e	4c 8d 4c 24 28	 lea	 r9, QWORD PTR n$[rsp]
  00013	4c 8d 44 24 20	 lea	 r8, QWORD PTR ustr$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@IHHELFOJ@u?$CD?3fromunicode?$AA@
  0001f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN4@array_from@5

; 1523 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 aa 00 00 00	 jmp	 $LN5@array_from@5
$LN4@array_from@5:

; 1524 :     typecode = self->ob_descr->typecode;

  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00039	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00040	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00043	88 44 24 30	 mov	 BYTE PTR typecode$[rsp], al

; 1525 :     if (typecode != 'u') {

  00047	0f be 44 24 30	 movsx	 eax, BYTE PTR typecode$[rsp]
  0004c	83 f8 75	 cmp	 eax, 117		; 00000075H
  0004f	74 17		 je	 SHORT $LN3@array_from@5

; 1526 :         PyErr_SetString(PyExc_ValueError,
; 1527 :             "fromunicode() may only be called on "
; 1528 :             "unicode type arrays");

  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@MJAINOPC@fromunicode?$CI?$CJ?5may?5only?5be?5called@
  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0005f	e8 00 00 00 00	 call	 PyErr_SetString

; 1529 :         return NULL;

  00064	33 c0		 xor	 eax, eax
  00066	eb 76		 jmp	 SHORT $LN5@array_from@5
$LN3@array_from@5:

; 1530 :     }
; 1531 :     if (n > 0) {

  00068	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$[rsp], 0
  0006e	7e 5b		 jle	 SHORT $LN2@array_from@5

; 1532 :         Py_ssize_t old_size = Py_SIZE(self);

  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00075	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00079	48 89 44 24 38	 mov	 QWORD PTR old_size$21706[rsp], rax

; 1533 :         if (array_resize(self, old_size + n) == -1)

  0007e	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00083	48 8b 4c 24 38	 mov	 rcx, QWORD PTR old_size$21706[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 8b d0	 mov	 rdx, rax
  00091	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00096	e8 00 00 00 00	 call	 array_resize
  0009b	83 f8 ff	 cmp	 eax, -1
  0009e	75 04		 jne	 SHORT $LN1@array_from@5

; 1534 :             return NULL;

  000a0	33 c0		 xor	 eax, eax
  000a2	eb 3a		 jmp	 SHORT $LN5@array_from@5
$LN1@array_from@5:

; 1535 :         memcpy(self->ob_item + old_size * sizeof(Py_UNICODE),
; 1536 :                ustr, n * sizeof(Py_UNICODE));

  000a4	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  000a9	48 d1 e0	 shl	 rax, 1
  000ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000b1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000b5	48 8b 54 24 38	 mov	 rdx, QWORD PTR old_size$21706[rsp]
  000ba	48 8d 0c 51	 lea	 rcx, QWORD PTR [rcx+rdx*2]
  000be	4c 8b c0	 mov	 r8, rax
  000c1	48 8b 54 24 20	 mov	 rdx, QWORD PTR ustr$[rsp]
  000c6	e8 00 00 00 00	 call	 memcpy
$LN2@array_from@5:

; 1537 :     }
; 1538 : 
; 1539 :     Py_INCREF(Py_None);

  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000d2	e8 00 00 00 00	 call	 _Py_IncRef

; 1540 :     return Py_None;

  000d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN5@array_from@5:

; 1541 : }

  000de	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e2	c3		 ret	 0
array_fromunicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@PJNLGLLC@tounicode?$CI?$CJ?5may?5only?5be?5called?5o@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_tounicode DD imagerel array_tounicode
	DD	imagerel array_tounicode+94
	DD	imagerel $unwind$array_tounicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_tounicode DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0DG@PJNLGLLC@tounicode?$CI?$CJ?5may?5only?5be?5called?5o@
CONST	SEGMENT
??_C@_0DG@PJNLGLLC@tounicode?$CI?$CJ?5may?5only?5be?5called?5o@ DB 'touni'
	DB	'code() may only be called on unicode type arrays', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_tounicode
_TEXT	SEGMENT
typecode$ = 32
self$ = 64
unused$ = 72
array_tounicode PROC					; COMDAT

; 1554 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1555 :     char typecode;
; 1556 :     typecode = self->ob_descr->typecode;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0001a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001d	88 44 24 20	 mov	 BYTE PTR typecode$[rsp], al

; 1557 :     if (typecode != 'u') {

  00021	0f be 44 24 20	 movsx	 eax, BYTE PTR typecode$[rsp]
  00026	83 f8 75	 cmp	 eax, 117		; 00000075H
  00029	74 17		 je	 SHORT $LN1@array_toun

; 1558 :         PyErr_SetString(PyExc_ValueError,
; 1559 :              "tounicode() may only be called on unicode type arrays");

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@PJNLGLLC@tounicode?$CI?$CJ?5may?5only?5be?5called?5o@
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00039	e8 00 00 00 00	 call	 PyErr_SetString

; 1560 :         return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 17		 jmp	 SHORT $LN2@array_toun
$LN1@array_toun:

; 1561 :     }
; 1562 :     return PyUnicode_FromUnicode((Py_UNICODE *) self->ob_item, Py_SIZE(self));

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00047	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00050	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00054	e8 00 00 00 00	 call	 PyUnicode_FromUnicode
$LN2@array_toun:

; 1563 : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
array_tounicode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_sizeof DD imagerel array_sizeof
	DD	imagerel array_sizeof+72
	DD	imagerel $unwind$array_sizeof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_sizeof DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_sizeof
_TEXT	SEGMENT
res$ = 32
self$ = 64
unused$ = 72
array_sizeof PROC					; COMDAT

; 1576 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1577 :     Py_ssize_t res;
; 1578 :     res = sizeof(arrayobject) + self->allocated * self->ob_descr->itemsize;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0001a	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00023	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00027	48 0f af c8	 imul	 rcx, rax
  0002b	48 8b c1	 mov	 rax, rcx
  0002e	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00034	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 1579 :     return PyLong_FromSsize_t(res);

  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  0003e	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 1580 : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
array_sizeof ENDP
_TEXT	ENDS
PUBLIC	$T23648
PUBLIC	??_C@_06OLFOGHEN@strict?$AA@			; `string'
PUBLIC	??_C@_1CK@JCKJCBKE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CM@KIFEFODB@fourth?5argument?5should?5be?5bytes?0@ ; `string'
PUBLIC	??_C@_0DE@LPGEONDD@third?5argument?5must?5be?5a?5valid?5m@ ; `string'
PUBLIC	??_C@_0CK@IOECFFFB@second?5argument?5must?5be?5a?5valid?5@ ; `string'
PUBLIC	??_C@_0CC@KBLJKDGE@?$CF?4200s?5is?5not?5a?5subtype?5of?5?$CF?4200@ ; `string'
PUBLIC	??_C@_0CO@GMHDDNBE@first?5argument?5must?5a?5type?5objec@ ; `string'
PUBLIC	??_C@_0CA@FLLPLEGM@OCiO?3array?4_array_reconstructor?$AA@ ; `string'
EXTRN	_PyLong_FromByteArray:PROC
EXTRN	PyUnicode_DecodeUTF32:PROC
EXTRN	PyUnicode_DecodeUTF16:PROC
EXTRN	_PyFloat_Unpack8:PROC
EXTRN	_PyFloat_Unpack4:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_reconstructor DD imagerel array_reconstructor
	DD	imagerel array_reconstructor+2210
	DD	imagerel $unwind$array_reconstructor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_reconstructor DD 041301H
	DD	0250113H
	DD	0600b700cH
xdata	ENDS
;	COMDAT ??_C@_06OLFOGHEN@strict?$AA@
CONST	SEGMENT
??_C@_06OLFOGHEN@strict?$AA@ DB 'strict', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@JCKJCBKE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@JCKJCBKE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'm', 00H, 's', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@KIFEFODB@fourth?5argument?5should?5be?5bytes?0@
CONST	SEGMENT
??_C@_0CM@KIFEFODB@fourth?5argument?5should?5be?5bytes?0@ DB 'fourth argu'
	DB	'ment should be bytes, not %.200s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@LPGEONDD@third?5argument?5must?5be?5a?5valid?5m@
CONST	SEGMENT
??_C@_0DE@LPGEONDD@third?5argument?5must?5be?5a?5valid?5m@ DB 'third argu'
	DB	'ment must be a valid machine format code.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IOECFFFB@second?5argument?5must?5be?5a?5valid?5@
CONST	SEGMENT
??_C@_0CK@IOECFFFB@second?5argument?5must?5be?5a?5valid?5@ DB 'second arg'
	DB	'ument must be a valid type code', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KBLJKDGE@?$CF?4200s?5is?5not?5a?5subtype?5of?5?$CF?4200@
CONST	SEGMENT
??_C@_0CC@KBLJKDGE@?$CF?4200s?5is?5not?5a?5subtype?5of?5?$CF?4200@ DB '%.'
	DB	'200s is not a subtype of %.200s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GMHDDNBE@first?5argument?5must?5a?5type?5objec@
CONST	SEGMENT
??_C@_0CO@GMHDDNBE@first?5argument?5must?5a?5type?5objec@ DB 'first argum'
	DB	'ent must a type object, not %.200s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FLLPLEGM@OCiO?3array?4_array_reconstructor?$AA@
CONST	SEGMENT
??_C@_0CA@FLLPLEGM@OCiO?3array?4_array_reconstructor?$AA@ DB 'OCiO:array.'
	DB	'_array_reconstructor', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_reconstructor
_TEXT	SEGMENT
descr$ = 48
mformat_code$ = 56
typecode$ = 60
converted_items$ = 64
arraytype$ = 72
result$ = 80
items$ = 88
le$21918 = 96
itemcount$21919 = 104
i$21917 = 112
memstr$21921 = 120
pyfloat$21933 = 128
le$21941 = 136
itemcount$21942 = 144
i$21940 = 152
memstr$21944 = 160
pyfloat$21955 = 168
byteorder$21962 = 176
byteorder$21972 = 180
descr$21990 = 184
itemcount$21983 = 192
i$21981 = 200
memstr$21985 = 208
mf_descr$21982 = 216
pylong$22001 = 232
$T23648 = 240
tv154 = 256
tv160 = 264
tv162 = 268
tv195 = 272
tv228 = 276
tv246 = 280
tv298 = 284
self$ = 320
args$ = 328
array_reconstructor PROC				; COMDAT

; 1809 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H

; 1810 :     PyTypeObject *arraytype;
; 1811 :     PyObject *items;
; 1812 :     PyObject *converted_items;
; 1813 :     PyObject *result;
; 1814 :     int typecode;
; 1815 :     enum machine_format_code mformat_code;
; 1816 :     struct arraydescr *descr;
; 1817 : 
; 1818 :     if (!PyArg_ParseTuple(args, "OCiO:array._array_reconstructor",
; 1819 :                     &arraytype, &typecode, &mformat_code, &items))

  00013	48 8d 44 24 58	 lea	 rax, QWORD PTR items$[rsp]
  00018	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0001d	48 8d 44 24 38	 lea	 rax, QWORD PTR mformat_code$[rsp]
  00022	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00027	4c 8d 4c 24 3c	 lea	 r9, QWORD PTR typecode$[rsp]
  0002c	4c 8d 44 24 48	 lea	 r8, QWORD PTR arraytype$[rsp]
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@FLLPLEGM@OCiO?3array?4_array_reconstructor?$AA@
  00038	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00040	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00045	85 c0		 test	 eax, eax
  00047	75 07		 jne	 SHORT $LN43@array_reco

; 1820 :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 1b 08 00 00	 jmp	 $LN44@array_reco
$LN43@array_reco:

; 1821 : 
; 1822 :     if (!PyType_Check(arraytype)) {

  00050	48 8b 44 24 48	 mov	 rax, QWORD PTR arraytype$[rsp]
  00055	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00059	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005f	25 00 00 00 80	 and	 eax, -2147483648	; ffffffff80000000H
  00064	85 c0		 test	 eax, eax
  00066	75 27		 jne	 SHORT $LN42@array_reco

; 1823 :         PyErr_Format(PyExc_TypeError,
; 1824 :             "first argument must a type object, not %.200s",
; 1825 :             Py_TYPE(arraytype)->tp_name);

  00068	48 8b 44 24 48	 mov	 rax, QWORD PTR arraytype$[rsp]
  0006d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00071	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@GMHDDNBE@first?5argument?5must?5a?5type?5objec@
  0007c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00083	e8 00 00 00 00	 call	 PyErr_Format

; 1826 :         return NULL;

  00088	33 c0		 xor	 eax, eax
  0008a	e9 dc 07 00 00	 jmp	 $LN44@array_reco
$LN42@array_reco:

; 1827 :     }
; 1828 :     if (!PyType_IsSubtype(arraytype, &Arraytype)) {

  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00096	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arraytype$[rsp]
  0009b	e8 00 00 00 00	 call	 PyType_IsSubtype
  000a0	85 c0		 test	 eax, eax
  000a2	75 2a		 jne	 SHORT $LN41@array_reco

; 1829 :         PyErr_Format(PyExc_TypeError,
; 1830 :             "%.200s is not a subtype of %.200s",
; 1831 :             arraytype->tp_name, Arraytype.tp_name);

  000a4	4c 8b 0d 70 00
	00 00		 mov	 r9, QWORD PTR Arraytype+112
  000ab	48 8b 44 24 48	 mov	 rax, QWORD PTR arraytype$[rsp]
  000b0	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@KBLJKDGE@?$CF?4200s?5is?5not?5a?5subtype?5of?5?$CF?4200@
  000bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c2	e8 00 00 00 00	 call	 PyErr_Format

; 1832 :         return NULL;

  000c7	33 c0		 xor	 eax, eax
  000c9	e9 9d 07 00 00	 jmp	 $LN44@array_reco
$LN41@array_reco:

; 1833 :     }
; 1834 :     for (descr = descriptors; descr->typecode != '\0'; descr++) {

  000ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:descriptors
  000d5	48 89 44 24 30	 mov	 QWORD PTR descr$[rsp], rax
  000da	eb 0e		 jmp	 SHORT $LN40@array_reco
$LN39@array_reco:
  000dc	48 8b 44 24 30	 mov	 rax, QWORD PTR descr$[rsp]
  000e1	48 83 c0 28	 add	 rax, 40			; 00000028H
  000e5	48 89 44 24 30	 mov	 QWORD PTR descr$[rsp], rax
$LN40@array_reco:
  000ea	48 8b 44 24 30	 mov	 rax, QWORD PTR descr$[rsp]
  000ef	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f2	85 c0		 test	 eax, eax
  000f4	74 12		 je	 SHORT $LN38@array_reco

; 1835 :         if ((int)descr->typecode == typecode)

  000f6	48 8b 44 24 30	 mov	 rax, QWORD PTR descr$[rsp]
  000fb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000fe	3b 44 24 3c	 cmp	 eax, DWORD PTR typecode$[rsp]
  00102	75 02		 jne	 SHORT $LN37@array_reco

; 1836 :             break;

  00104	eb 02		 jmp	 SHORT $LN38@array_reco
$LN37@array_reco:

; 1837 :     }

  00106	eb d4		 jmp	 SHORT $LN39@array_reco
$LN38@array_reco:

; 1838 :     if (descr->typecode == '\0') {

  00108	48 8b 44 24 30	 mov	 rax, QWORD PTR descr$[rsp]
  0010d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00110	85 c0		 test	 eax, eax
  00112	75 1a		 jne	 SHORT $LN36@array_reco

; 1839 :         PyErr_SetString(PyExc_ValueError,
; 1840 :                         "second argument must be a valid type code");

  00114	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@IOECFFFB@second?5argument?5must?5be?5a?5valid?5@
  0011b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00122	e8 00 00 00 00	 call	 PyErr_SetString

; 1841 :         return NULL;

  00127	33 c0		 xor	 eax, eax
  00129	e9 3d 07 00 00	 jmp	 $LN44@array_reco
$LN36@array_reco:

; 1842 :     }
; 1843 :     if (mformat_code < MACHINE_FORMAT_CODE_MIN ||
; 1844 :         mformat_code > MACHINE_FORMAT_CODE_MAX) {

  0012e	83 7c 24 38 00	 cmp	 DWORD PTR mformat_code$[rsp], 0
  00133	7c 07		 jl	 SHORT $LN34@array_reco
  00135	83 7c 24 38 15	 cmp	 DWORD PTR mformat_code$[rsp], 21
  0013a	7e 1a		 jle	 SHORT $LN35@array_reco
$LN34@array_reco:

; 1845 :         PyErr_SetString(PyExc_ValueError,
; 1846 :             "third argument must be a valid machine format code.");

  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@LPGEONDD@third?5argument?5must?5be?5a?5valid?5m@
  00143	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0014a	e8 00 00 00 00	 call	 PyErr_SetString

; 1847 :         return NULL;

  0014f	33 c0		 xor	 eax, eax
  00151	e9 15 07 00 00	 jmp	 $LN44@array_reco
$LN35@array_reco:

; 1848 :     }
; 1849 :     if (!PyBytes_Check(items)) {

  00156	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  0015b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0015f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00165	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0016a	85 c0		 test	 eax, eax
  0016c	75 27		 jne	 SHORT $LN33@array_reco

; 1850 :         PyErr_Format(PyExc_TypeError,
; 1851 :             "fourth argument should be bytes, not %.200s",
; 1852 :             Py_TYPE(items)->tp_name);

  0016e	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  00173	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00177	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0017b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@KIFEFODB@fourth?5argument?5should?5be?5bytes?0@
  00182	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00189	e8 00 00 00 00	 call	 PyErr_Format

; 1853 :         return NULL;

  0018e	33 c0		 xor	 eax, eax
  00190	e9 d6 06 00 00	 jmp	 $LN44@array_reco
$LN33@array_reco:

; 1854 :     }
; 1855 : 
; 1856 :     /* Fast path: No decoding has to be done. */
; 1857 :     if (mformat_code == typecode_to_mformat_code((char)typecode) ||
; 1858 :         mformat_code == UNKNOWN_FORMAT) {

  00195	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR typecode$[rsp]
  0019a	e8 00 00 00 00	 call	 typecode_to_mformat_code
  0019f	39 44 24 38	 cmp	 DWORD PTR mformat_code$[rsp], eax
  001a3	74 07		 je	 SHORT $LN31@array_reco
  001a5	83 7c 24 38 ff	 cmp	 DWORD PTR mformat_code$[rsp], -1
  001aa	75 19		 jne	 SHORT $LN32@array_reco
$LN31@array_reco:

; 1859 :         return make_array(arraytype, (char)typecode, items);

  001ac	4c 8b 44 24 58	 mov	 r8, QWORD PTR items$[rsp]
  001b1	0f b6 54 24 3c	 movzx	 edx, BYTE PTR typecode$[rsp]
  001b6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arraytype$[rsp]
  001bb	e8 00 00 00 00	 call	 make_array
  001c0	e9 a6 06 00 00	 jmp	 $LN44@array_reco
$LN32@array_reco:

; 1860 :     }
; 1861 : 
; 1862 :     /* Slow path: Decode the byte string according to the given machine
; 1863 :      * format code. This occurs when the computer unpickling the array
; 1864 :      * object is architecturally different from the one that pickled the
; 1865 :      * array.
; 1866 :      */
; 1867 :     if (Py_SIZE(items) % mformat_descriptors[mformat_code].size != 0) {

  001c5	48 63 44 24 38	 movsxd	 rax, DWORD PTR mformat_code$[rsp]
  001ca	48 6b c0 10	 imul	 rax, 16
  001ce	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv154[rsp], rax
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mformat_descriptors
  001dd	33 d2		 xor	 edx, edx
  001df	4c 8b 44 24 58	 mov	 r8, QWORD PTR items$[rsp]
  001e4	49 8b 40 60	 mov	 rax, QWORD PTR [r8+96]
  001e8	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR tv154[rsp]
  001f0	4a f7 34 01	 div	 QWORD PTR [rcx+r8]
  001f4	48 8b c2	 mov	 rax, rdx
  001f7	48 85 c0	 test	 rax, rax
  001fa	74 1a		 je	 SHORT $LN30@array_reco

; 1868 :         PyErr_SetString(PyExc_ValueError,
; 1869 :                         "string length not a multiple of item size");

  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@CCOBPACL@string?5length?5not?5a?5multiple?5of?5@
  00203	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0020a	e8 00 00 00 00	 call	 PyErr_SetString

; 1870 :         return NULL;

  0020f	33 c0		 xor	 eax, eax
  00211	e9 55 06 00 00	 jmp	 $LN44@array_reco
$LN30@array_reco:

; 1871 :     }
; 1872 :     switch (mformat_code) {

  00216	8b 44 24 38	 mov	 eax, DWORD PTR mformat_code$[rsp]
  0021a	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv160[rsp], eax
  00221	83 bc 24 08 01
	00 00 15	 cmp	 DWORD PTR tv160[rsp], 21
  00229	0f 87 0b 06 00
	00		 ja	 $LN1@array_reco
  0022f	48 63 84 24 08
	01 00 00	 movsxd	 rax, DWORD PTR tv160[rsp]
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0023e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN61@array_reco[rcx+rax]
  00246	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN62@array_reco[rcx+rax*4]
  0024d	48 03 c1	 add	 rax, rcx
  00250	ff e0		 jmp	 rax
$LN27@array_reco:

; 1873 :     case IEEE_754_FLOAT_LE:
; 1874 :     case IEEE_754_FLOAT_BE: {
; 1875 :         int i;
; 1876 :         int le = (mformat_code == IEEE_754_FLOAT_LE) ? 1 : 0;

  00252	83 7c 24 38 0e	 cmp	 DWORD PTR mformat_code$[rsp], 14
  00257	75 0d		 jne	 SHORT $LN46@array_reco
  00259	c7 84 24 0c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv162[rsp], 1
  00264	eb 0b		 jmp	 SHORT $LN47@array_reco
$LN46@array_reco:
  00266	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
$LN47@array_reco:
  00271	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR tv162[rsp]
  00278	89 44 24 60	 mov	 DWORD PTR le$21918[rsp], eax

; 1877 :         Py_ssize_t itemcount = Py_SIZE(items) / 4;

  0027c	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  00281	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00285	48 99		 cdq
  00287	48 83 e2 03	 and	 rdx, 3
  0028b	48 03 c2	 add	 rax, rdx
  0028e	48 c1 f8 02	 sar	 rax, 2
  00292	48 89 44 24 68	 mov	 QWORD PTR itemcount$21919[rsp], rax

; 1878 :         const unsigned char *memstr =
; 1879 :             (unsigned char *)PyBytes_AS_STRING(items);

  00297	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  0029c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002a0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002a6	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002ab	85 c0		 test	 eax, eax
  002ad	75 1c		 jne	 SHORT $LN48@array_reco
  002af	41 b8 57 07 00
	00		 mov	 r8d, 1879		; 00000757H
  002b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JCKJCBKE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?$AA@
  002c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002c9	33 c0		 xor	 eax, eax
$LN48@array_reco:
  002cb	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  002d0	48 83 c0 78	 add	 rax, 120		; 00000078H
  002d4	48 89 44 24 78	 mov	 QWORD PTR memstr$21921[rsp], rax

; 1880 : 
; 1881 :         converted_items = PyList_New(itemcount);

  002d9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR itemcount$21919[rsp]
  002de	e8 00 00 00 00	 call	 PyList_New
  002e3	48 89 44 24 40	 mov	 QWORD PTR converted_items$[rsp], rax

; 1882 :         if (converted_items == NULL)

  002e8	48 83 7c 24 40
	00		 cmp	 QWORD PTR converted_items$[rsp], 0
  002ee	75 07		 jne	 SHORT $LN26@array_reco

; 1883 :             return NULL;

  002f0	33 c0		 xor	 eax, eax
  002f2	e9 74 05 00 00	 jmp	 $LN44@array_reco
$LN26@array_reco:

; 1884 :         for (i = 0; i < itemcount; i++) {

  002f7	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$21917[rsp], 0
  002ff	eb 0a		 jmp	 SHORT $LN25@array_reco
$LN24@array_reco:
  00301	8b 44 24 70	 mov	 eax, DWORD PTR i$21917[rsp]
  00305	ff c0		 inc	 eax
  00307	89 44 24 70	 mov	 DWORD PTR i$21917[rsp], eax
$LN25@array_reco:
  0030b	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$21917[rsp]
  00310	48 3b 44 24 68	 cmp	 rax, QWORD PTR itemcount$21919[rsp]
  00315	7d 65		 jge	 SHORT $LN23@array_reco

; 1885 :             PyObject *pyfloat = PyFloat_FromDouble(
; 1886 :                 _PyFloat_Unpack4(&memstr[i * 4], le));

  00317	8b 44 24 70	 mov	 eax, DWORD PTR i$21917[rsp]
  0031b	c1 e0 02	 shl	 eax, 2
  0031e	48 98		 cdqe
  00320	48 8b 4c 24 78	 mov	 rcx, QWORD PTR memstr$21921[rsp]
  00325	48 03 c8	 add	 rcx, rax
  00328	48 8b c1	 mov	 rax, rcx
  0032b	8b 54 24 60	 mov	 edx, DWORD PTR le$21918[rsp]
  0032f	48 8b c8	 mov	 rcx, rax
  00332	e8 00 00 00 00	 call	 _PyFloat_Unpack4
  00337	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0033c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pyfloat$21933[rsp], rax

; 1887 :             if (pyfloat == NULL) {

  00344	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pyfloat$21933[rsp], 0
  0034d	75 11		 jne	 SHORT $LN22@array_reco

; 1888 :                 Py_DECREF(converted_items);

  0034f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR converted_items$[rsp]
  00354	e8 00 00 00 00	 call	 _Py_DecRef

; 1889 :                 return NULL;

  00359	33 c0		 xor	 eax, eax
  0035b	e9 0b 05 00 00	 jmp	 $LN44@array_reco
$LN22@array_reco:

; 1890 :             }
; 1891 :             PyList_SET_ITEM(converted_items, i, pyfloat);

  00360	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$21917[rsp]
  00365	48 8b 4c 24 40	 mov	 rcx, QWORD PTR converted_items$[rsp]
  0036a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0036e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pyfloat$21933[rsp]
  00376	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 1892 :         }

  0037a	eb 85		 jmp	 SHORT $LN24@array_reco
$LN23@array_reco:

; 1893 :         break;

  0037c	e9 c2 04 00 00	 jmp	 $LN28@array_reco
$LN21@array_reco:

; 1894 :     }
; 1895 :     case IEEE_754_DOUBLE_LE:
; 1896 :     case IEEE_754_DOUBLE_BE: {
; 1897 :         int i;
; 1898 :         int le = (mformat_code == IEEE_754_DOUBLE_LE) ? 1 : 0;

  00381	83 7c 24 38 10	 cmp	 DWORD PTR mformat_code$[rsp], 16
  00386	75 0d		 jne	 SHORT $LN49@array_reco
  00388	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv195[rsp], 1
  00393	eb 0b		 jmp	 SHORT $LN50@array_reco
$LN49@array_reco:
  00395	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv195[rsp], 0
$LN50@array_reco:
  003a0	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR tv195[rsp]
  003a7	89 84 24 88 00
	00 00		 mov	 DWORD PTR le$21941[rsp], eax

; 1899 :         Py_ssize_t itemcount = Py_SIZE(items) / 8;

  003ae	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  003b3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  003b7	48 99		 cdq
  003b9	48 83 e2 07	 and	 rdx, 7
  003bd	48 03 c2	 add	 rax, rdx
  003c0	48 c1 f8 03	 sar	 rax, 3
  003c4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR itemcount$21942[rsp], rax

; 1900 :         const unsigned char *memstr =
; 1901 :             (unsigned char *)PyBytes_AS_STRING(items);

  003cc	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  003d1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003d5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003db	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  003e0	85 c0		 test	 eax, eax
  003e2	75 1c		 jne	 SHORT $LN51@array_reco
  003e4	41 b8 6d 07 00
	00		 mov	 r8d, 1901		; 0000076dH
  003ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  003f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JCKJCBKE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?$AA@
  003f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003fe	33 c0		 xor	 eax, eax
$LN51@array_reco:
  00400	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  00405	48 83 c0 78	 add	 rax, 120		; 00000078H
  00409	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR memstr$21944[rsp], rax

; 1902 : 
; 1903 :         converted_items = PyList_New(itemcount);

  00411	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR itemcount$21942[rsp]
  00419	e8 00 00 00 00	 call	 PyList_New
  0041e	48 89 44 24 40	 mov	 QWORD PTR converted_items$[rsp], rax

; 1904 :         if (converted_items == NULL)

  00423	48 83 7c 24 40
	00		 cmp	 QWORD PTR converted_items$[rsp], 0
  00429	75 07		 jne	 SHORT $LN20@array_reco

; 1905 :             return NULL;

  0042b	33 c0		 xor	 eax, eax
  0042d	e9 39 04 00 00	 jmp	 $LN44@array_reco
$LN20@array_reco:

; 1906 :         for (i = 0; i < itemcount; i++) {

  00432	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$21940[rsp], 0
  0043d	eb 10		 jmp	 SHORT $LN19@array_reco
$LN18@array_reco:
  0043f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$21940[rsp]
  00446	ff c0		 inc	 eax
  00448	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$21940[rsp], eax
$LN19@array_reco:
  0044f	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$21940[rsp]
  00457	48 3b 84 24 90
	00 00 00	 cmp	 rax, QWORD PTR itemcount$21942[rsp]
  0045f	7d 74		 jge	 SHORT $LN17@array_reco

; 1907 :             PyObject *pyfloat = PyFloat_FromDouble(
; 1908 :                 _PyFloat_Unpack8(&memstr[i * 8], le));

  00461	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$21940[rsp]
  00468	c1 e0 03	 shl	 eax, 3
  0046b	48 98		 cdqe
  0046d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR memstr$21944[rsp]
  00475	48 03 c8	 add	 rcx, rax
  00478	48 8b c1	 mov	 rax, rcx
  0047b	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR le$21941[rsp]
  00482	48 8b c8	 mov	 rcx, rax
  00485	e8 00 00 00 00	 call	 _PyFloat_Unpack8
  0048a	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0048f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pyfloat$21955[rsp], rax

; 1909 :             if (pyfloat == NULL) {

  00497	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR pyfloat$21955[rsp], 0
  004a0	75 11		 jne	 SHORT $LN16@array_reco

; 1910 :                 Py_DECREF(converted_items);

  004a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR converted_items$[rsp]
  004a7	e8 00 00 00 00	 call	 _Py_DecRef

; 1911 :                 return NULL;

  004ac	33 c0		 xor	 eax, eax
  004ae	e9 b8 03 00 00	 jmp	 $LN44@array_reco
$LN16@array_reco:

; 1912 :             }
; 1913 :             PyList_SET_ITEM(converted_items, i, pyfloat);

  004b3	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$21940[rsp]
  004bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR converted_items$[rsp]
  004c0	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004c4	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pyfloat$21955[rsp]
  004cc	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 1914 :         }

  004d0	e9 6a ff ff ff	 jmp	 $LN18@array_reco
$LN17@array_reco:

; 1915 :         break;

  004d5	e9 69 03 00 00	 jmp	 $LN28@array_reco
$LN15@array_reco:

; 1916 :     }
; 1917 :     case UTF16_LE:
; 1918 :     case UTF16_BE: {
; 1919 :         int byteorder = (mformat_code == UTF16_LE) ? -1 : 1;

  004da	83 7c 24 38 12	 cmp	 DWORD PTR mformat_code$[rsp], 18
  004df	75 0d		 jne	 SHORT $LN52@array_reco
  004e1	c7 84 24 14 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv228[rsp], -1
  004ec	eb 0b		 jmp	 SHORT $LN53@array_reco
$LN52@array_reco:
  004ee	c7 84 24 14 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv228[rsp], 1
$LN53@array_reco:
  004f9	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR tv228[rsp]
  00500	89 84 24 b0 00
	00 00		 mov	 DWORD PTR byteorder$21962[rsp], eax

; 1920 :         converted_items = PyUnicode_DecodeUTF16(
; 1921 :             PyBytes_AS_STRING(items), Py_SIZE(items),
; 1922 :             "strict", &byteorder);

  00507	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  0050c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00510	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00516	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0051b	85 c0		 test	 eax, eax
  0051d	75 1c		 jne	 SHORT $LN54@array_reco
  0051f	41 b8 81 07 00
	00		 mov	 r8d, 1921		; 00000781H
  00525	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0052c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JCKJCBKE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?$AA@
  00533	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00539	33 c0		 xor	 eax, eax
$LN54@array_reco:
  0053b	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  00540	48 83 c0 78	 add	 rax, 120		; 00000078H
  00544	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR byteorder$21962[rsp]
  0054c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  00553	48 8b 4c 24 58	 mov	 rcx, QWORD PTR items$[rsp]
  00558	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0055c	48 8b c8	 mov	 rcx, rax
  0055f	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF16
  00564	48 89 44 24 40	 mov	 QWORD PTR converted_items$[rsp], rax

; 1923 :         if (converted_items == NULL)

  00569	48 83 7c 24 40
	00		 cmp	 QWORD PTR converted_items$[rsp], 0
  0056f	75 07		 jne	 SHORT $LN14@array_reco

; 1924 :             return NULL;

  00571	33 c0		 xor	 eax, eax
  00573	e9 f3 02 00 00	 jmp	 $LN44@array_reco
$LN14@array_reco:

; 1925 :         break;

  00578	e9 c6 02 00 00	 jmp	 $LN28@array_reco
$LN13@array_reco:

; 1926 :     }
; 1927 :     case UTF32_LE:
; 1928 :     case UTF32_BE: {
; 1929 :         int byteorder = (mformat_code == UTF32_LE) ? -1 : 1;

  0057d	83 7c 24 38 14	 cmp	 DWORD PTR mformat_code$[rsp], 20
  00582	75 0d		 jne	 SHORT $LN55@array_reco
  00584	c7 84 24 18 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv246[rsp], -1
  0058f	eb 0b		 jmp	 SHORT $LN56@array_reco
$LN55@array_reco:
  00591	c7 84 24 18 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv246[rsp], 1
$LN56@array_reco:
  0059c	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR tv246[rsp]
  005a3	89 84 24 b4 00
	00 00		 mov	 DWORD PTR byteorder$21972[rsp], eax

; 1930 :         converted_items = PyUnicode_DecodeUTF32(
; 1931 :             PyBytes_AS_STRING(items), Py_SIZE(items),
; 1932 :             "strict", &byteorder);

  005aa	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  005af	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005b3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005b9	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  005be	85 c0		 test	 eax, eax
  005c0	75 1c		 jne	 SHORT $LN57@array_reco
  005c2	41 b8 8b 07 00
	00		 mov	 r8d, 1931		; 0000078bH
  005c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  005cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JCKJCBKE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?$AA@
  005d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005dc	33 c0		 xor	 eax, eax
$LN57@array_reco:
  005de	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  005e3	48 83 c0 78	 add	 rax, 120		; 00000078H
  005e7	4c 8d 8c 24 b4
	00 00 00	 lea	 r9, QWORD PTR byteorder$21972[rsp]
  005ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06OLFOGHEN@strict?$AA@
  005f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR items$[rsp]
  005fb	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  005ff	48 8b c8	 mov	 rcx, rax
  00602	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF32
  00607	48 89 44 24 40	 mov	 QWORD PTR converted_items$[rsp], rax

; 1933 :         if (converted_items == NULL)

  0060c	48 83 7c 24 40
	00		 cmp	 QWORD PTR converted_items$[rsp], 0
  00612	75 07		 jne	 SHORT $LN12@array_reco

; 1934 :             return NULL;

  00614	33 c0		 xor	 eax, eax
  00616	e9 50 02 00 00	 jmp	 $LN44@array_reco
$LN12@array_reco:

; 1935 :         break;

  0061b	e9 23 02 00 00	 jmp	 $LN28@array_reco
$LN11@array_reco:

; 1936 :     }
; 1937 : 
; 1938 :     case UNSIGNED_INT8:
; 1939 :     case SIGNED_INT8:
; 1940 :     case UNSIGNED_INT16_LE:
; 1941 :     case UNSIGNED_INT16_BE:
; 1942 :     case SIGNED_INT16_LE:
; 1943 :     case SIGNED_INT16_BE:
; 1944 :     case UNSIGNED_INT32_LE:
; 1945 :     case UNSIGNED_INT32_BE:
; 1946 :     case SIGNED_INT32_LE:
; 1947 :     case SIGNED_INT32_BE:
; 1948 :     case UNSIGNED_INT64_LE:
; 1949 :     case UNSIGNED_INT64_BE:
; 1950 :     case SIGNED_INT64_LE:
; 1951 :     case SIGNED_INT64_BE: {
; 1952 :         int i;
; 1953 :         const struct mformatdescr mf_descr =
; 1954 :             mformat_descriptors[mformat_code];

  00620	48 63 44 24 38	 movsxd	 rax, DWORD PTR mformat_code$[rsp]
  00625	48 6b c0 10	 imul	 rax, 16
  00629	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mformat_descriptors
  00630	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR $T23648[rsp]
  00638	48 8b fa	 mov	 rdi, rdx
  0063b	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  0063f	b9 10 00 00 00	 mov	 ecx, 16
  00644	f3 a4		 rep movsb
  00646	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR mf_descr$21982[rsp]
  0064e	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T23648[rsp]
  00656	48 8b f8	 mov	 rdi, rax
  00659	48 8b f1	 mov	 rsi, rcx
  0065c	b9 10 00 00 00	 mov	 ecx, 16
  00661	f3 a4		 rep movsb

; 1955 :         Py_ssize_t itemcount = Py_SIZE(items) / mf_descr.size;

  00663	33 d2		 xor	 edx, edx
  00665	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  0066a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0066e	48 f7 b4 24 d8
	00 00 00	 div	 QWORD PTR mf_descr$21982[rsp]
  00676	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR itemcount$21983[rsp], rax

; 1956 :         const unsigned char *memstr =
; 1957 :             (unsigned char *)PyBytes_AS_STRING(items);

  0067e	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  00683	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00687	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0068d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00692	85 c0		 test	 eax, eax
  00694	75 1c		 jne	 SHORT $LN58@array_reco
  00696	41 b8 a5 07 00
	00		 mov	 r8d, 1957		; 000007a5H
  0069c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  006a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JCKJCBKE@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?$AA@
  006aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006b0	33 c0		 xor	 eax, eax
$LN58@array_reco:
  006b2	48 8b 44 24 58	 mov	 rax, QWORD PTR items$[rsp]
  006b7	48 83 c0 78	 add	 rax, 120		; 00000078H
  006bb	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR memstr$21985[rsp], rax

; 1958 :         struct arraydescr *descr;
; 1959 : 
; 1960 :         /* If possible, try to pack array's items using a data type
; 1961 :          * that fits better. This may result in an array with narrower
; 1962 :          * or wider elements.
; 1963 :          *
; 1964 :          * For example, if a 32-bit machine pickles a L-code array of
; 1965 :          * unsigned longs, then the array will be unpickled by 64-bit
; 1966 :          * machine as an I-code array of unsigned ints.
; 1967 :          *
; 1968 :          * XXX: Is it possible to write a unit test for this?
; 1969 :          */
; 1970 :         for (descr = descriptors; descr->typecode != '\0'; descr++) {

  006c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:descriptors
  006ca	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR descr$21990[rsp], rax
  006d2	eb 14		 jmp	 SHORT $LN10@array_reco
$LN9@array_reco:
  006d4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR descr$21990[rsp]
  006dc	48 83 c0 28	 add	 rax, 40			; 00000028H
  006e0	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR descr$21990[rsp], rax
$LN10@array_reco:
  006e8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR descr$21990[rsp]
  006f0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  006f3	85 c0		 test	 eax, eax
  006f5	74 49		 je	 SHORT $LN8@array_reco

; 1971 :             if (descr->is_integer_type &&
; 1972 :                 descr->itemsize == mf_descr.size &&
; 1973 :                 descr->is_signed == mf_descr.is_signed)

  006f7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR descr$21990[rsp]
  006ff	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00703	74 39		 je	 SHORT $LN7@array_reco
  00705	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR descr$21990[rsp]
  0070d	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00711	48 3b 84 24 d8
	00 00 00	 cmp	 rax, QWORD PTR mf_descr$21982[rsp]
  00719	75 23		 jne	 SHORT $LN7@array_reco
  0071b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR descr$21990[rsp]
  00723	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR mf_descr$21982[rsp+8]
  0072a	39 48 24	 cmp	 DWORD PTR [rax+36], ecx
  0072d	75 0f		 jne	 SHORT $LN7@array_reco

; 1974 :                 typecode = descr->typecode;

  0072f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR descr$21990[rsp]
  00737	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0073a	89 44 24 3c	 mov	 DWORD PTR typecode$[rsp], eax
$LN7@array_reco:

; 1975 :         }

  0073e	eb 94		 jmp	 SHORT $LN9@array_reco
$LN8@array_reco:

; 1976 : 
; 1977 :         converted_items = PyList_New(itemcount);

  00740	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR itemcount$21983[rsp]
  00748	e8 00 00 00 00	 call	 PyList_New
  0074d	48 89 44 24 40	 mov	 QWORD PTR converted_items$[rsp], rax

; 1978 :         if (converted_items == NULL)

  00752	48 83 7c 24 40
	00		 cmp	 QWORD PTR converted_items$[rsp], 0
  00758	75 07		 jne	 SHORT $LN6@array_reco

; 1979 :             return NULL;

  0075a	33 c0		 xor	 eax, eax
  0075c	e9 0a 01 00 00	 jmp	 $LN44@array_reco
$LN6@array_reco:

; 1980 :         for (i = 0; i < itemcount; i++) {

  00761	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$21981[rsp], 0
  0076c	eb 10		 jmp	 SHORT $LN5@array_reco
$LN4@array_reco:
  0076e	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR i$21981[rsp]
  00775	ff c0		 inc	 eax
  00777	89 84 24 c8 00
	00 00		 mov	 DWORD PTR i$21981[rsp], eax
$LN5@array_reco:
  0077e	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR i$21981[rsp]
  00786	48 3b 84 24 c0
	00 00 00	 cmp	 rax, QWORD PTR itemcount$21983[rsp]
  0078e	0f 8d a4 00 00
	00		 jge	 $LN3@array_reco

; 1981 :             PyObject *pylong;
; 1982 : 
; 1983 :             pylong = _PyLong_FromByteArray(
; 1984 :                 &memstr[i * mf_descr.size],
; 1985 :                 mf_descr.size,
; 1986 :                 !mf_descr.is_big_endian,
; 1987 :                 mf_descr.is_signed);

  00794	83 bc 24 e4 00
	00 00 00	 cmp	 DWORD PTR mf_descr$21982[rsp+12], 0
  0079c	75 0d		 jne	 SHORT $LN59@array_reco
  0079e	c7 84 24 1c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv298[rsp], 1
  007a9	eb 0b		 jmp	 SHORT $LN60@array_reco
$LN59@array_reco:
  007ab	c7 84 24 1c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv298[rsp], 0
$LN60@array_reco:
  007b6	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR i$21981[rsp]
  007be	48 0f af 84 24
	d8 00 00 00	 imul	 rax, QWORD PTR mf_descr$21982[rsp]
  007c7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR memstr$21985[rsp]
  007cf	48 03 c8	 add	 rcx, rax
  007d2	48 8b c1	 mov	 rax, rcx
  007d5	44 8b 8c 24 e0
	00 00 00	 mov	 r9d, DWORD PTR mf_descr$21982[rsp+8]
  007dd	44 8b 84 24 1c
	01 00 00	 mov	 r8d, DWORD PTR tv298[rsp]
  007e5	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR mf_descr$21982[rsp]
  007ed	48 8b c8	 mov	 rcx, rax
  007f0	e8 00 00 00 00	 call	 _PyLong_FromByteArray
  007f5	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pylong$22001[rsp], rax

; 1988 :             if (pylong == NULL) {

  007fd	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR pylong$22001[rsp], 0
  00806	75 0e		 jne	 SHORT $LN2@array_reco

; 1989 :                 Py_DECREF(converted_items);

  00808	48 8b 4c 24 40	 mov	 rcx, QWORD PTR converted_items$[rsp]
  0080d	e8 00 00 00 00	 call	 _Py_DecRef

; 1990 :                 return NULL;

  00812	33 c0		 xor	 eax, eax
  00814	eb 55		 jmp	 SHORT $LN44@array_reco
$LN2@array_reco:

; 1991 :             }
; 1992 :             PyList_SET_ITEM(converted_items, i, pylong);

  00816	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR i$21981[rsp]
  0081e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR converted_items$[rsp]
  00823	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00827	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR pylong$22001[rsp]
  0082f	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 1993 :         }

  00833	e9 36 ff ff ff	 jmp	 $LN4@array_reco
$LN3@array_reco:

; 1994 :         break;

  00838	eb 09		 jmp	 SHORT $LN28@array_reco
$LN1@array_reco:

; 1995 :     }
; 1996 :     case UNKNOWN_FORMAT:
; 1997 :         /* Impossible, but needed to shut up GCC about the unhandled
; 1998 :          * enumeration value.
; 1999 :          */
; 2000 :     default:
; 2001 :         PyErr_BadArgument();

  0083a	e8 00 00 00 00	 call	 PyErr_BadArgument

; 2002 :         return NULL;

  0083f	33 c0		 xor	 eax, eax
  00841	eb 28		 jmp	 SHORT $LN44@array_reco
$LN28@array_reco:

; 2003 :     }
; 2004 : 
; 2005 :     result = make_array(arraytype, (char)typecode, converted_items);

  00843	4c 8b 44 24 40	 mov	 r8, QWORD PTR converted_items$[rsp]
  00848	0f b6 54 24 3c	 movzx	 edx, BYTE PTR typecode$[rsp]
  0084d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arraytype$[rsp]
  00852	e8 00 00 00 00	 call	 make_array
  00857	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 2006 :     Py_DECREF(converted_items);

  0085c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR converted_items$[rsp]
  00861	e8 00 00 00 00	 call	 _Py_DecRef

; 2007 :     return result;

  00866	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
$LN44@array_reco:

; 2008 : }

  0086b	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00872	5f		 pop	 rdi
  00873	5e		 pop	 rsi
  00874	c3		 ret	 0
  00875	0f 1f 00	 npad	 3
$LN62@array_reco:
  00878	00 00 00 00	 DD	 $LN11@array_reco
  0087c	00 00 00 00	 DD	 $LN27@array_reco
  00880	00 00 00 00	 DD	 $LN21@array_reco
  00884	00 00 00 00	 DD	 $LN15@array_reco
  00888	00 00 00 00	 DD	 $LN13@array_reco
$LN61@array_reco:
  0088c	00		 DB	 0
  0088d	00		 DB	 0
  0088e	00		 DB	 0
  0088f	00		 DB	 0
  00890	00		 DB	 0
  00891	00		 DB	 0
  00892	00		 DB	 0
  00893	00		 DB	 0
  00894	00		 DB	 0
  00895	00		 DB	 0
  00896	00		 DB	 0
  00897	00		 DB	 0
  00898	00		 DB	 0
  00899	00		 DB	 0
  0089a	01		 DB	 1
  0089b	01		 DB	 1
  0089c	02		 DB	 2
  0089d	02		 DB	 2
  0089e	03		 DB	 3
  0089f	03		 DB	 3
  008a0	04		 DB	 4
  008a1	04		 DB	 4
array_reconstructor ENDP
_TEXT	ENDS
PUBLIC	??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@ ; `string'
PUBLIC	??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@ ; `string'
PUBLIC	__real@433fff0102030405
PUBLIC	??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@		; `string'
PUBLIC	??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@		; `string'
PUBLIC	__real@4b7f0102
EXTRN	memcmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$typecode_to_mformat_code DD imagerel typecode_to_mformat_code
	DD	imagerel typecode_to_mformat_code+712
	DD	imagerel $unwind$typecode_to_mformat_code
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$typecode_to_mformat_code DD 010801H
	DD	0a208H
xdata	ENDS
;	COMDAT ??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@
CONST	SEGMENT
??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@ DB 05H, 04H, 03H, 02H
	DB	01H, 0ffH, '?C', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@
CONST	SEGMENT
??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@ DB 'C?', 0ffH, 01H, 02H
	DB	03H, 04H, 05H, 00H				; `string'
CONST	ENDS
;	COMDAT __real@433fff0102030405
CONST	SEGMENT
__real@433fff0102030405 DQ 0433fff0102030405r	; 9.0061e+015
CONST	ENDS
;	COMDAT ??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@
CONST	SEGMENT
??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@ DB 02H, 01H, 07fH, 'K', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@
CONST	SEGMENT
??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@ DB 'K', 07fH, 01H, 02H, 00H ; `string'
CONST	ENDS
;	COMDAT __real@4b7f0102
CONST	SEGMENT
__real@4b7f0102 DD 04b7f0102r			; 1.67119e+007
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT typecode_to_mformat_code
_TEXT	SEGMENT
is_signed$ = 32
is_big_endian$ = 36
intsize$ = 40
y$21788 = 48
x$21796 = 56
tv65 = 64
tv94 = 72
typecode$ = 96
typecode_to_mformat_code PROC				; COMDAT

; 1666 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1667 : #ifdef WORDS_BIGENDIAN
; 1668 :     const int is_big_endian = 1;
; 1669 : #else
; 1670 :     const int is_big_endian = 0;

  00008	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR is_big_endian$[rsp], 0

; 1671 : #endif
; 1672 :     size_t intsize;
; 1673 :     int is_signed;
; 1674 : 
; 1675 :     switch (typecode) {

  00010	0f be 44 24 60	 movsx	 eax, BYTE PTR typecode$[rsp]
  00015	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  00019	8b 44 24 40	 mov	 eax, DWORD PTR tv65[rsp]
  0001d	83 e8 42	 sub	 eax, 66			; 00000042H
  00020	89 44 24 40	 mov	 DWORD PTR tv65[rsp], eax
  00024	83 7c 24 40 33	 cmp	 DWORD PTR tv65[rsp], 51	; 00000033H
  00029	0f 87 cd 01 00
	00		 ja	 $LN7@typecode_t
  0002f	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv65[rsp]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0003b	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN33@typecode_t[rcx+rax]
  00043	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN34@typecode_t[rcx+rax*4]
  0004a	48 03 c1	 add	 rax, rcx
  0004d	ff e0		 jmp	 rax
$LN28@typecode_t:

; 1676 :     case 'b':
; 1677 :         return SIGNED_INT8;

  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	e9 fd 01 00 00	 jmp	 $LN31@typecode_t
$LN27@typecode_t:

; 1678 :     case 'B':
; 1679 :         return UNSIGNED_INT8;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 f6 01 00 00	 jmp	 $LN31@typecode_t
$LN26@typecode_t:

; 1680 : 
; 1681 :     case 'u':
; 1682 :         if (sizeof(Py_UNICODE) == 2) {

  00060	33 c0		 xor	 eax, eax
  00062	83 f8 01	 cmp	 eax, 1
  00065	74 0c		 je	 SHORT $LN25@typecode_t

; 1683 :             return UTF16_LE + is_big_endian;

  00067	8b 44 24 24	 mov	 eax, DWORD PTR is_big_endian$[rsp]
  0006b	83 c0 12	 add	 eax, 18
  0006e	e9 e3 01 00 00	 jmp	 $LN31@typecode_t
$LN25@typecode_t:

; 1684 :         }
; 1685 :         if (sizeof(Py_UNICODE) == 4) {

  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	74 0c		 je	 SHORT $LN24@typecode_t

; 1686 :             return UTF32_LE + is_big_endian;

  00079	8b 44 24 24	 mov	 eax, DWORD PTR is_big_endian$[rsp]
  0007d	83 c0 14	 add	 eax, 20
  00080	e9 d1 01 00 00	 jmp	 $LN31@typecode_t
$LN24@typecode_t:

; 1687 :         }
; 1688 :         return UNKNOWN_FORMAT;

  00085	b8 ff ff ff ff	 mov	 eax, -1
  0008a	e9 c7 01 00 00	 jmp	 $LN31@typecode_t
$LN23@typecode_t:

; 1689 : 
; 1690 :     case 'f':
; 1691 :         if (sizeof(float) == 4) {

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 58		 je	 SHORT $LN22@typecode_t

; 1692 :             const float y = 16711938.0;

  00096	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@4b7f0102
  0009e	f3 0f 11 44 24
	30		 movss	 DWORD PTR y$21788[rsp], xmm0

; 1693 :             if (memcmp(&y, "\x4b\x7f\x01\x02", 4) == 0)

  000a4	41 b8 04 00 00
	00		 mov	 r8d, 4
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04BGFGNJMF@K?$HP?$AB?$AC?$AA@
  000b1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR y$21788[rsp]
  000b6	e8 00 00 00 00	 call	 memcmp
  000bb	85 c0		 test	 eax, eax
  000bd	75 0a		 jne	 SHORT $LN21@typecode_t

; 1694 :                 return IEEE_754_FLOAT_BE;

  000bf	b8 0f 00 00 00	 mov	 eax, 15
  000c4	e9 8d 01 00 00	 jmp	 $LN31@typecode_t
$LN21@typecode_t:

; 1695 :             if (memcmp(&y, "\x02\x01\x7f\x4b", 4) == 0)

  000c9	41 b8 04 00 00
	00		 mov	 r8d, 4
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04LHIBIFEE@?$AC?$AB?$HPK?$AA@
  000d6	48 8d 4c 24 30	 lea	 rcx, QWORD PTR y$21788[rsp]
  000db	e8 00 00 00 00	 call	 memcmp
  000e0	85 c0		 test	 eax, eax
  000e2	75 0a		 jne	 SHORT $LN20@typecode_t

; 1696 :                 return IEEE_754_FLOAT_LE;

  000e4	b8 0e 00 00 00	 mov	 eax, 14
  000e9	e9 68 01 00 00	 jmp	 $LN31@typecode_t
$LN20@typecode_t:
$LN22@typecode_t:

; 1697 :         }
; 1698 :         return UNKNOWN_FORMAT;

  000ee	b8 ff ff ff ff	 mov	 eax, -1
  000f3	e9 5e 01 00 00	 jmp	 $LN31@typecode_t
$LN19@typecode_t:

; 1699 : 
; 1700 :     case 'd':
; 1701 :         if (sizeof(double) == 8) {

  000f8	33 c0		 xor	 eax, eax
  000fa	83 f8 01	 cmp	 eax, 1
  000fd	74 58		 je	 SHORT $LN18@typecode_t

; 1702 :             const double x = 9006104071832581.0;

  000ff	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@433fff0102030405
  00107	f2 0f 11 44 24
	38		 movsdx	 QWORD PTR x$21796[rsp], xmm0

; 1703 :             if (memcmp(&x, "\x43\x3f\xff\x01\x02\x03\x04\x05", 8) == 0)

  0010d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00113	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OJGFKMMA@C?$DP?$PP?$AB?$AC?$AD?$AE?$AF?$AA@
  0011a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x$21796[rsp]
  0011f	e8 00 00 00 00	 call	 memcmp
  00124	85 c0		 test	 eax, eax
  00126	75 0a		 jne	 SHORT $LN17@typecode_t

; 1704 :                 return IEEE_754_DOUBLE_BE;

  00128	b8 11 00 00 00	 mov	 eax, 17
  0012d	e9 24 01 00 00	 jmp	 $LN31@typecode_t
$LN17@typecode_t:

; 1705 :             if (memcmp(&x, "\x05\x04\x03\x02\x01\xff\x3f\x43", 8) == 0)

  00132	41 b8 08 00 00
	00		 mov	 r8d, 8
  00138	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08LMANIKFI@?$AF?$AE?$AD?$AC?$AB?$PP?$DPC?$AA@
  0013f	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x$21796[rsp]
  00144	e8 00 00 00 00	 call	 memcmp
  00149	85 c0		 test	 eax, eax
  0014b	75 0a		 jne	 SHORT $LN16@typecode_t

; 1706 :                 return IEEE_754_DOUBLE_LE;

  0014d	b8 10 00 00 00	 mov	 eax, 16
  00152	e9 ff 00 00 00	 jmp	 $LN31@typecode_t
$LN16@typecode_t:
$LN18@typecode_t:

; 1707 :         }
; 1708 :         return UNKNOWN_FORMAT;

  00157	b8 ff ff ff ff	 mov	 eax, -1
  0015c	e9 f5 00 00 00	 jmp	 $LN31@typecode_t
$LN15@typecode_t:

; 1709 : 
; 1710 :     /* Integers */
; 1711 :     case 'h':
; 1712 :         intsize = sizeof(short);

  00161	48 c7 44 24 28
	02 00 00 00	 mov	 QWORD PTR intsize$[rsp], 2

; 1713 :         is_signed = 1;

  0016a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR is_signed$[rsp], 1

; 1714 :         break;

  00172	e9 8c 00 00 00	 jmp	 $LN29@typecode_t
$LN14@typecode_t:

; 1715 :     case 'H':
; 1716 :         intsize = sizeof(short);

  00177	48 c7 44 24 28
	02 00 00 00	 mov	 QWORD PTR intsize$[rsp], 2

; 1717 :         is_signed = 0;

  00180	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR is_signed$[rsp], 0

; 1718 :         break;

  00188	eb 79		 jmp	 SHORT $LN29@typecode_t
$LN13@typecode_t:

; 1719 :     case 'i':
; 1720 :         intsize = sizeof(int);

  0018a	48 c7 44 24 28
	04 00 00 00	 mov	 QWORD PTR intsize$[rsp], 4

; 1721 :         is_signed = 1;

  00193	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR is_signed$[rsp], 1

; 1722 :         break;

  0019b	eb 66		 jmp	 SHORT $LN29@typecode_t
$LN12@typecode_t:

; 1723 :     case 'I':
; 1724 :         intsize = sizeof(int);

  0019d	48 c7 44 24 28
	04 00 00 00	 mov	 QWORD PTR intsize$[rsp], 4

; 1725 :         is_signed = 0;

  001a6	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR is_signed$[rsp], 0

; 1726 :         break;

  001ae	eb 53		 jmp	 SHORT $LN29@typecode_t
$LN11@typecode_t:

; 1727 :     case 'l':
; 1728 :         intsize = sizeof(long);

  001b0	48 c7 44 24 28
	04 00 00 00	 mov	 QWORD PTR intsize$[rsp], 4

; 1729 :         is_signed = 1;

  001b9	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR is_signed$[rsp], 1

; 1730 :         break;

  001c1	eb 40		 jmp	 SHORT $LN29@typecode_t
$LN10@typecode_t:

; 1731 :     case 'L':
; 1732 :         intsize = sizeof(long);

  001c3	48 c7 44 24 28
	04 00 00 00	 mov	 QWORD PTR intsize$[rsp], 4

; 1733 :         is_signed = 0;

  001cc	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR is_signed$[rsp], 0

; 1734 :         break;

  001d4	eb 2d		 jmp	 SHORT $LN29@typecode_t
$LN9@typecode_t:

; 1735 : #if HAVE_LONG_LONG
; 1736 :     case 'q':
; 1737 :         intsize = sizeof(PY_LONG_LONG);

  001d6	48 c7 44 24 28
	08 00 00 00	 mov	 QWORD PTR intsize$[rsp], 8

; 1738 :         is_signed = 1;

  001df	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR is_signed$[rsp], 1

; 1739 :         break;

  001e7	eb 1a		 jmp	 SHORT $LN29@typecode_t
$LN8@typecode_t:

; 1740 :     case 'Q':
; 1741 :         intsize = sizeof(PY_LONG_LONG);

  001e9	48 c7 44 24 28
	08 00 00 00	 mov	 QWORD PTR intsize$[rsp], 8

; 1742 :         is_signed = 0;

  001f2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR is_signed$[rsp], 0

; 1743 :         break;

  001fa	eb 07		 jmp	 SHORT $LN29@typecode_t
$LN7@typecode_t:

; 1744 : #endif
; 1745 :     default:
; 1746 :         return UNKNOWN_FORMAT;

  001fc	b8 ff ff ff ff	 mov	 eax, -1
  00201	eb 53		 jmp	 SHORT $LN31@typecode_t
$LN29@typecode_t:

; 1747 :     }
; 1748 :     switch (intsize) {

  00203	48 8b 44 24 28	 mov	 rax, QWORD PTR intsize$[rsp]
  00208	48 89 44 24 48	 mov	 QWORD PTR tv94[rsp], rax
  0020d	48 83 7c 24 48
	02		 cmp	 QWORD PTR tv94[rsp], 2
  00213	74 12		 je	 SHORT $LN4@typecode_t
  00215	48 83 7c 24 48
	04		 cmp	 QWORD PTR tv94[rsp], 4
  0021b	74 18		 je	 SHORT $LN3@typecode_t
  0021d	48 83 7c 24 48
	08		 cmp	 QWORD PTR tv94[rsp], 8
  00223	74 1e		 je	 SHORT $LN2@typecode_t
  00225	eb 2a		 jmp	 SHORT $LN1@typecode_t
$LN4@typecode_t:

; 1749 :     case 2:
; 1750 :         return UNSIGNED_INT16_LE + is_big_endian + (2 * is_signed);

  00227	8b 44 24 24	 mov	 eax, DWORD PTR is_big_endian$[rsp]
  0022b	8b 4c 24 20	 mov	 ecx, DWORD PTR is_signed$[rsp]
  0022f	8d 44 48 02	 lea	 eax, DWORD PTR [rax+rcx*2+2]
  00233	eb 21		 jmp	 SHORT $LN31@typecode_t
$LN3@typecode_t:

; 1751 :     case 4:
; 1752 :         return UNSIGNED_INT32_LE + is_big_endian + (2 * is_signed);

  00235	8b 44 24 24	 mov	 eax, DWORD PTR is_big_endian$[rsp]
  00239	8b 4c 24 20	 mov	 ecx, DWORD PTR is_signed$[rsp]
  0023d	8d 44 48 06	 lea	 eax, DWORD PTR [rax+rcx*2+6]
  00241	eb 13		 jmp	 SHORT $LN31@typecode_t
$LN2@typecode_t:

; 1753 :     case 8:
; 1754 :         return UNSIGNED_INT64_LE + is_big_endian + (2 * is_signed);

  00243	8b 44 24 24	 mov	 eax, DWORD PTR is_big_endian$[rsp]
  00247	8b 4c 24 20	 mov	 ecx, DWORD PTR is_signed$[rsp]
  0024b	8d 44 48 0a	 lea	 eax, DWORD PTR [rax+rcx*2+10]
  0024f	eb 05		 jmp	 SHORT $LN31@typecode_t
$LN1@typecode_t:

; 1755 :     default:
; 1756 :         return UNKNOWN_FORMAT;

  00251	b8 ff ff ff ff	 mov	 eax, -1
$LN31@typecode_t:

; 1757 :     }
; 1758 : }

  00256	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0025a	c3		 ret	 0
  0025b	90		 npad	 1
$LN34@typecode_t:
  0025c	00 00 00 00	 DD	 $LN27@typecode_t
  00260	00 00 00 00	 DD	 $LN14@typecode_t
  00264	00 00 00 00	 DD	 $LN12@typecode_t
  00268	00 00 00 00	 DD	 $LN10@typecode_t
  0026c	00 00 00 00	 DD	 $LN8@typecode_t
  00270	00 00 00 00	 DD	 $LN28@typecode_t
  00274	00 00 00 00	 DD	 $LN19@typecode_t
  00278	00 00 00 00	 DD	 $LN23@typecode_t
  0027c	00 00 00 00	 DD	 $LN15@typecode_t
  00280	00 00 00 00	 DD	 $LN13@typecode_t
  00284	00 00 00 00	 DD	 $LN11@typecode_t
  00288	00 00 00 00	 DD	 $LN9@typecode_t
  0028c	00 00 00 00	 DD	 $LN26@typecode_t
  00290	00 00 00 00	 DD	 $LN7@typecode_t
$LN33@typecode_t:
  00294	00		 DB	 0
  00295	0d		 DB	 13
  00296	0d		 DB	 13
  00297	0d		 DB	 13
  00298	0d		 DB	 13
  00299	0d		 DB	 13
  0029a	01		 DB	 1
  0029b	02		 DB	 2
  0029c	0d		 DB	 13
  0029d	0d		 DB	 13
  0029e	03		 DB	 3
  0029f	0d		 DB	 13
  002a0	0d		 DB	 13
  002a1	0d		 DB	 13
  002a2	0d		 DB	 13
  002a3	04		 DB	 4
  002a4	0d		 DB	 13
  002a5	0d		 DB	 13
  002a6	0d		 DB	 13
  002a7	0d		 DB	 13
  002a8	0d		 DB	 13
  002a9	0d		 DB	 13
  002aa	0d		 DB	 13
  002ab	0d		 DB	 13
  002ac	0d		 DB	 13
  002ad	0d		 DB	 13
  002ae	0d		 DB	 13
  002af	0d		 DB	 13
  002b0	0d		 DB	 13
  002b1	0d		 DB	 13
  002b2	0d		 DB	 13
  002b3	0d		 DB	 13
  002b4	05		 DB	 5
  002b5	0d		 DB	 13
  002b6	06		 DB	 6
  002b7	0d		 DB	 13
  002b8	07		 DB	 7
  002b9	0d		 DB	 13
  002ba	08		 DB	 8
  002bb	09		 DB	 9
  002bc	0d		 DB	 13
  002bd	0d		 DB	 13
  002be	0a		 DB	 10
  002bf	0d		 DB	 13
  002c0	0d		 DB	 13
  002c1	0d		 DB	 13
  002c2	0d		 DB	 13
  002c3	0b		 DB	 11
  002c4	0d		 DB	 13
  002c5	0d		 DB	 13
  002c6	0d		 DB	 13
  002c7	0c		 DB	 12
typecode_to_mformat_code ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BM@NHCELAFO@?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@HMFFMBEL@?$AAa?$AAr?$AAr?$AAa?$AAy?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	PyUnicode_FromOrdinal:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$make_array DD imagerel make_array
	DD	imagerel make_array+239
	DD	imagerel $unwind$make_array
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_array DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT ??_C@_1BM@NHCELAFO@?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@NHCELAFO@?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'i'
	DB	00H, 't', 00H, 'e', 00H, 'm', 00H, 's', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@HMFFMBEL@?$AAa?$AAr?$AAr?$AAa?$AAy?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@HMFFMBEL@?$AAa?$AAr?$AAr?$AAa?$AAy?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'a'
	DB	00H, 'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N'
	DB	00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT make_array
_TEXT	SEGMENT
array_obj$ = 32
new_args$ = 40
typecode_obj$ = 48
arraytype$ = 80
typecode$ = 88
items$ = 96
make_array PROC						; COMDAT

; 1776 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1777 :     PyObject *new_args;
; 1778 :     PyObject *array_obj;
; 1779 :     PyObject *typecode_obj;
; 1780 : 
; 1781 :     assert(arraytype != NULL);

  00012	48 83 7c 24 50
	00		 cmp	 QWORD PTR arraytype$[rsp], 0
  00018	75 1c		 jne	 SHORT $LN6@make_array
  0001a	41 b8 f5 06 00
	00		 mov	 r8d, 1781		; 000006f5H
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@HMFFMBEL@?$AAa?$AAr?$AAr?$AAa?$AAy?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00034	33 c0		 xor	 eax, eax
$LN6@make_array:

; 1782 :     assert(items != NULL);

  00036	48 83 7c 24 60
	00		 cmp	 QWORD PTR items$[rsp], 0
  0003c	75 1c		 jne	 SHORT $LN7@make_array
  0003e	41 b8 f6 06 00
	00		 mov	 r8d, 1782		; 000006f6H
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@NHCELAFO@?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00058	33 c0		 xor	 eax, eax
$LN7@make_array:

; 1783 : 
; 1784 :     typecode_obj = PyUnicode_FromOrdinal(typecode);

  0005a	0f be 44 24 58	 movsx	 eax, BYTE PTR typecode$[rsp]
  0005f	8b c8		 mov	 ecx, eax
  00061	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal
  00066	48 89 44 24 30	 mov	 QWORD PTR typecode_obj$[rsp], rax

; 1785 :     if (typecode_obj == NULL)

  0006b	48 83 7c 24 30
	00		 cmp	 QWORD PTR typecode_obj$[rsp], 0
  00071	75 04		 jne	 SHORT $LN3@make_array

; 1786 :         return NULL;

  00073	33 c0		 xor	 eax, eax
  00075	eb 73		 jmp	 SHORT $LN4@make_array
$LN3@make_array:

; 1787 : 
; 1788 :     new_args = PyTuple_New(2);

  00077	b9 02 00 00 00	 mov	 ecx, 2
  0007c	e8 00 00 00 00	 call	 PyTuple_New
  00081	48 89 44 24 28	 mov	 QWORD PTR new_args$[rsp], rax

; 1789 :     if (new_args == NULL)

  00086	48 83 7c 24 28
	00		 cmp	 QWORD PTR new_args$[rsp], 0
  0008c	75 04		 jne	 SHORT $LN2@make_array

; 1790 :         return NULL;

  0008e	33 c0		 xor	 eax, eax
  00090	eb 58		 jmp	 SHORT $LN4@make_array
$LN2@make_array:

; 1791 :     Py_INCREF(items);

  00092	48 8b 4c 24 60	 mov	 rcx, QWORD PTR items$[rsp]
  00097	e8 00 00 00 00	 call	 _Py_IncRef

; 1792 :     PyTuple_SET_ITEM(new_args, 0, typecode_obj);

  0009c	48 8b 44 24 28	 mov	 rax, QWORD PTR new_args$[rsp]
  000a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR typecode_obj$[rsp]
  000a6	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 1793 :     PyTuple_SET_ITEM(new_args, 1, items);

  000aa	48 8b 44 24 28	 mov	 rax, QWORD PTR new_args$[rsp]
  000af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR items$[rsp]
  000b4	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 1794 : 
; 1795 :     array_obj = array_new(arraytype, new_args, NULL);

  000b8	45 33 c0	 xor	 r8d, r8d
  000bb	48 8b 54 24 28	 mov	 rdx, QWORD PTR new_args$[rsp]
  000c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR arraytype$[rsp]
  000c5	e8 00 00 00 00	 call	 array_new
  000ca	48 89 44 24 20	 mov	 QWORD PTR array_obj$[rsp], rax

; 1796 :     Py_DECREF(new_args);

  000cf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_args$[rsp]
  000d4	e8 00 00 00 00	 call	 _Py_DecRef

; 1797 :     if (array_obj == NULL)

  000d9	48 83 7c 24 20
	00		 cmp	 QWORD PTR array_obj$[rsp], 0
  000df	75 04		 jne	 SHORT $LN1@make_array

; 1798 :         return NULL;

  000e1	33 c0		 xor	 eax, eax
  000e3	eb 05		 jmp	 SHORT $LN4@make_array
$LN1@make_array:

; 1799 : 
; 1800 :     return array_obj;

  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR array_obj$[rsp]
$LN4@make_array:

; 1801 : }

  000ea	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ee	c3		 ret	 0
make_array ENDP
_TEXT	ENDS
PUBLIC	??_C@_08KGFFDHKB@O?$CIOCiN?$CJO?$AA@		; `string'
PUBLIC	??_C@_06KHHGOGBN@O?$CICO?$CJO?$AA@		; `string'
PUBLIC	??_C@_0CJ@JNEGJPIC@__reduce_ex__?5argument?5should?5an@ ; `string'
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_AttributeError:QWORD
EXTRN	PyLong_AsLong:PROC
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	PyImport_ImportModule:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_reduce_ex DD imagerel array_reduce_ex
	DD	imagerel array_reduce_ex+636
	DD	imagerel $unwind$array_reduce_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_reduce_ex DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_08KGFFDHKB@O?$CIOCiN?$CJO?$AA@
CONST	SEGMENT
??_C@_08KGFFDHKB@O?$CIOCiN?$CJO?$AA@ DB 'O(OCiN)O', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06KHHGOGBN@O?$CICO?$CJO?$AA@
CONST	SEGMENT
??_C@_06KHHGOGBN@O?$CICO?$CJO?$AA@ DB 'O(CO)O', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@JNEGJPIC@__reduce_ex__?5argument?5should?5an@
CONST	SEGMENT
??_C@_0CJ@JNEGJPIC@__reduce_ex__?5argument?5should?5an@ DB '__reduce_ex__'
	DB	' argument should an integer', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_reduce_ex
_TEXT	SEGMENT
array_str$ = 64
dict$ = 72
mformat_code$ = 80
typecode$ = 84
protocol$ = 88
result$ = 96
array_module$22034 = 104
list$22057 = 112
array$ = 144
value$ = 152
array_reduce_ex PROC					; COMDAT

; 2012 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2013 :     PyObject *dict;
; 2014 :     PyObject *result;
; 2015 :     PyObject *array_str;
; 2016 :     int typecode = array->ob_descr->typecode;

  00011	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR array$[rsp]
  00019	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00020	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00023	89 44 24 54	 mov	 DWORD PTR typecode$[rsp], eax

; 2017 :     int mformat_code;
; 2018 :     static PyObject *array_reconstructor = NULL;
; 2019 :     long protocol;
; 2020 :     _Py_IDENTIFIER(_array_reconstructor);
; 2021 :     _Py_IDENTIFIER(__dict__);
; 2022 : 
; 2023 :     if (array_reconstructor == NULL) {

  00027	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?array_reconstructor@?1??array_reduce_ex@@9@9, 0
  0002f	75 69		 jne	 SHORT $LN11@array_redu

; 2024 :         PyObject *array_module = PyImport_ImportModule("array");

  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HIFJDKLD@array?$AA@
  00038	e8 00 00 00 00	 call	 PyImport_ImportModule
  0003d	48 89 44 24 68	 mov	 QWORD PTR array_module$22034[rsp], rax

; 2025 :         if (array_module == NULL)

  00042	48 83 7c 24 68
	00		 cmp	 QWORD PTR array_module$22034[rsp], 0
  00048	75 07		 jne	 SHORT $LN10@array_redu

; 2026 :             return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 23 02 00 00	 jmp	 $LN12@array_redu
$LN10@array_redu:

; 2027 :         array_reconstructor = _PyObject_GetAttrId(
; 2028 :             array_module,
; 2029 :             &PyId__array_reconstructor);

  00051	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId__array_reconstructor@?1??array_reduce_ex@@9@9
  00056	8b c0		 mov	 eax, eax
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0005e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00067	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0006b	48 8b d0	 mov	 rdx, rax
  0006e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR array_module$22034[rsp]
  00073	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00078	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?array_reconstructor@?1??array_reduce_ex@@9@9, rax

; 2030 :         Py_DECREF(array_module);

  0007f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR array_module$22034[rsp]
  00084	e8 00 00 00 00	 call	 _Py_DecRef

; 2031 :         if (array_reconstructor == NULL)

  00089	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?array_reconstructor@?1??array_reduce_ex@@9@9, 0
  00091	75 07		 jne	 SHORT $LN9@array_redu

; 2032 :             return NULL;

  00093	33 c0		 xor	 eax, eax
  00095	e9 da 01 00 00	 jmp	 $LN12@array_redu
$LN9@array_redu:
$LN11@array_redu:

; 2033 :     }
; 2034 : 
; 2035 :     if (!PyLong_Check(value)) {

  0009a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR value$[rsp]
  000a2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a6	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000ac	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000b1	85 c0		 test	 eax, eax
  000b3	75 1a		 jne	 SHORT $LN8@array_redu

; 2036 :         PyErr_SetString(PyExc_TypeError,
; 2037 :                         "__reduce_ex__ argument should an integer");

  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@JNEGJPIC@__reduce_ex__?5argument?5should?5an@
  000bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c3	e8 00 00 00 00	 call	 PyErr_SetString

; 2038 :         return NULL;

  000c8	33 c0		 xor	 eax, eax
  000ca	e9 a5 01 00 00	 jmp	 $LN12@array_redu
$LN8@array_redu:

; 2039 :     }
; 2040 :     protocol = PyLong_AsLong(value);

  000cf	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  000d7	e8 00 00 00 00	 call	 PyLong_AsLong
  000dc	89 44 24 58	 mov	 DWORD PTR protocol$[rsp], eax

; 2041 :     if (protocol == -1 && PyErr_Occurred())

  000e0	83 7c 24 58 ff	 cmp	 DWORD PTR protocol$[rsp], -1
  000e5	75 11		 jne	 SHORT $LN7@array_redu
  000e7	e8 00 00 00 00	 call	 PyErr_Occurred
  000ec	48 85 c0	 test	 rax, rax
  000ef	74 07		 je	 SHORT $LN7@array_redu

; 2042 :         return NULL;

  000f1	33 c0		 xor	 eax, eax
  000f3	e9 7c 01 00 00	 jmp	 $LN12@array_redu
$LN7@array_redu:

; 2043 : 
; 2044 :     dict = _PyObject_GetAttrId((PyObject *)array, &PyId___dict__);

  000f8	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___dict__@?1??array_reduce_ex@@9@9
  000fd	8b c0		 mov	 eax, eax
  000ff	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00105	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0010e	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00112	48 8b d0	 mov	 rdx, rax
  00115	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR array$[rsp]
  0011d	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00122	48 89 44 24 48	 mov	 QWORD PTR dict$[rsp], rax

; 2045 :     if (dict == NULL) {

  00127	48 83 7c 24 48
	00		 cmp	 QWORD PTR dict$[rsp], 0
  0012d	75 32		 jne	 SHORT $LN6@array_redu

; 2046 :         if (!PyErr_ExceptionMatches(PyExc_AttributeError))

  0012f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00136	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0013b	85 c0		 test	 eax, eax
  0013d	75 07		 jne	 SHORT $LN5@array_redu

; 2047 :             return NULL;

  0013f	33 c0		 xor	 eax, eax
  00141	e9 2e 01 00 00	 jmp	 $LN12@array_redu
$LN5@array_redu:

; 2048 :         PyErr_Clear();

  00146	e8 00 00 00 00	 call	 PyErr_Clear

; 2049 :         dict = Py_None;

  0014b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00152	48 89 44 24 48	 mov	 QWORD PTR dict$[rsp], rax

; 2050 :         Py_INCREF(dict);

  00157	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dict$[rsp]
  0015c	e8 00 00 00 00	 call	 _Py_IncRef
$LN6@array_redu:

; 2051 :     }
; 2052 : 
; 2053 :     mformat_code = typecode_to_mformat_code(typecode);

  00161	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR typecode$[rsp]
  00166	e8 00 00 00 00	 call	 typecode_to_mformat_code
  0016b	89 44 24 50	 mov	 DWORD PTR mformat_code$[rsp], eax

; 2054 :     if (mformat_code == UNKNOWN_FORMAT || protocol < 3) {

  0016f	83 7c 24 50 ff	 cmp	 DWORD PTR mformat_code$[rsp], -1
  00174	74 07		 je	 SHORT $LN3@array_redu
  00176	83 7c 24 58 03	 cmp	 DWORD PTR protocol$[rsp], 3
  0017b	7d 79		 jge	 SHORT $LN4@array_redu
$LN3@array_redu:

; 2055 :         /* Convert the array to a list if we got something weird
; 2056 :          * (e.g., non-IEEE floats), or we are pickling the array using
; 2057 :          * a Python 2.x compatible protocol.
; 2058 :          *
; 2059 :          * It is necessary to use a list representation for Python 2.x
; 2060 :          * compatible pickle protocol, since Python 2's str objects
; 2061 :          * are unpickled as unicode by Python 3. Thus it is impossible
; 2062 :          * to make arrays unpicklable by Python 3 by using their memory
; 2063 :          * representation, unless we resort to ugly hacks such as
; 2064 :          * coercing unicode objects to bytes in array_reconstructor.
; 2065 :          */
; 2066 :         PyObject *list;
; 2067 :         list = array_tolist(array, NULL);

  0017d	33 d2		 xor	 edx, edx
  0017f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR array$[rsp]
  00187	e8 00 00 00 00	 call	 array_tolist
  0018c	48 89 44 24 70	 mov	 QWORD PTR list$22057[rsp], rax

; 2068 :         if (list == NULL) {

  00191	48 83 7c 24 70
	00		 cmp	 QWORD PTR list$22057[rsp], 0
  00197	75 11		 jne	 SHORT $LN2@array_redu

; 2069 :             Py_DECREF(dict);

  00199	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dict$[rsp]
  0019e	e8 00 00 00 00	 call	 _Py_DecRef

; 2070 :             return NULL;

  001a3	33 c0		 xor	 eax, eax
  001a5	e9 ca 00 00 00	 jmp	 $LN12@array_redu
$LN2@array_redu:

; 2071 :         }
; 2072 :         result = Py_BuildValue(
; 2073 :             "O(CO)O", Py_TYPE(array), typecode, list, dict);

  001aa	48 8b 44 24 48	 mov	 rax, QWORD PTR dict$[rsp]
  001af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b4	4c 8b 4c 24 70	 mov	 r9, QWORD PTR list$22057[rsp]
  001b9	44 8b 44 24 54	 mov	 r8d, DWORD PTR typecode$[rsp]
  001be	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR array$[rsp]
  001c6	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06KHHGOGBN@O?$CICO?$CJO?$AA@
  001d1	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  001d6	48 89 44 24 60	 mov	 QWORD PTR result$[rsp], rax

; 2074 :         Py_DECREF(list);

  001db	48 8b 4c 24 70	 mov	 rcx, QWORD PTR list$22057[rsp]
  001e0	e8 00 00 00 00	 call	 _Py_DecRef

; 2075 :         Py_DECREF(dict);

  001e5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dict$[rsp]
  001ea	e8 00 00 00 00	 call	 _Py_DecRef

; 2076 :         return result;

  001ef	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
  001f4	eb 7e		 jmp	 SHORT $LN12@array_redu
$LN4@array_redu:

; 2077 :     }
; 2078 : 
; 2079 :     array_str = array_tobytes(array, NULL);

  001f6	33 d2		 xor	 edx, edx
  001f8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR array$[rsp]
  00200	e8 00 00 00 00	 call	 array_tobytes
  00205	48 89 44 24 40	 mov	 QWORD PTR array_str$[rsp], rax

; 2080 :     if (array_str == NULL) {

  0020a	48 83 7c 24 40
	00		 cmp	 QWORD PTR array_str$[rsp], 0
  00210	75 0e		 jne	 SHORT $LN1@array_redu

; 2081 :         Py_DECREF(dict);

  00212	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dict$[rsp]
  00217	e8 00 00 00 00	 call	 _Py_DecRef

; 2082 :         return NULL;

  0021c	33 c0		 xor	 eax, eax
  0021e	eb 54		 jmp	 SHORT $LN12@array_redu
$LN1@array_redu:

; 2083 :     }
; 2084 :     result = Py_BuildValue(
; 2085 :         "O(OCiN)O", array_reconstructor, Py_TYPE(array), typecode,
; 2086 :         mformat_code, array_str, dict);

  00220	48 8b 44 24 48	 mov	 rax, QWORD PTR dict$[rsp]
  00225	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR array_str$[rsp]
  0022f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00234	8b 44 24 50	 mov	 eax, DWORD PTR mformat_code$[rsp]
  00238	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0023c	44 8b 4c 24 54	 mov	 r9d, DWORD PTR typecode$[rsp]
  00241	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR array$[rsp]
  00249	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  0024d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?array_reconstructor@?1??array_reduce_ex@@9@9
  00254	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08KGFFDHKB@O?$CIOCiN?$CJO?$AA@
  0025b	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00260	48 89 44 24 60	 mov	 QWORD PTR result$[rsp], rax

; 2087 :     Py_DECREF(dict);

  00265	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dict$[rsp]
  0026a	e8 00 00 00 00	 call	 _Py_DecRef

; 2088 :     return result;

  0026f	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
$LN12@array_redu:

; 2089 : }

  00274	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0027b	c3		 ret	 0
array_reduce_ex ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_get_typecode DD imagerel array_get_typecode
	DD	imagerel array_get_typecode+50
	DD	imagerel $unwind$array_get_typecode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_get_typecode DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_get_typecode
_TEXT	SEGMENT
typecode$ = 32
a$ = 64
closure$ = 72
array_get_typecode PROC					; COMDAT

; 2095 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2096 :     char typecode = a->ob_descr->typecode;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0001a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001d	88 44 24 20	 mov	 BYTE PTR typecode$[rsp], al

; 2097 :     return PyUnicode_FromOrdinal(typecode);

  00021	0f be 44 24 20	 movsx	 eax, BYTE PTR typecode$[rsp]
  00026	8b c8		 mov	 ecx, eax
  00028	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal

; 2098 : }

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	c3		 ret	 0
array_get_typecode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_get_itemsize DD imagerel array_get_itemsize
	DD	imagerel array_get_itemsize+39
	DD	imagerel $unwind$array_get_itemsize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_get_itemsize DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_get_itemsize
_TEXT	SEGMENT
a$ = 48
closure$ = 56
array_get_itemsize PROC					; COMDAT

; 2102 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2103 :     return PyLong_FromLong((long)a->ob_descr->itemsize);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00013	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  0001d	e8 00 00 00 00	 call	 PyLong_FromLong

; 2104 : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
array_get_itemsize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@ELMLMNDK@array?$CI?8?$CFc?8?0?5?$CFR?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0M@CECFMNFO@array?$CI?8?$CFc?8?$CJ?$AA@	; `string'
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_repr DD imagerel array_repr
	DD	imagerel array_repr+187
	DD	imagerel $unwind$array_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_repr DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BA@ELMLMNDK@array?$CI?8?$CFc?8?0?5?$CFR?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@ELMLMNDK@array?$CI?8?$CFc?8?0?5?$CFR?$CJ?$AA@ DB 'array(''%c'','
	DB	' %R)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CECFMNFO@array?$CI?8?$CFc?8?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@CECFMNFO@array?$CI?8?$CFc?8?$CJ?$AA@ DB 'array(''%c'')', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_repr
_TEXT	SEGMENT
v$ = 32
s$ = 40
typecode$ = 48
len$ = 56
a$ = 80
array_repr PROC						; COMDAT

; 2168 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2169 :     char typecode;
; 2170 :     PyObject *s, *v = NULL;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR v$[rsp], 0

; 2171 :     Py_ssize_t len;
; 2172 : 
; 2173 :     len = Py_SIZE(a);

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00017	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001b	48 89 44 24 38	 mov	 QWORD PTR len$[rsp], rax

; 2174 :     typecode = a->ob_descr->typecode;

  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00025	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0002c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002f	88 44 24 30	 mov	 BYTE PTR typecode$[rsp], al

; 2175 :     if (len == 0) {

  00033	48 83 7c 24 38
	00		 cmp	 QWORD PTR len$[rsp], 0
  00039	75 15		 jne	 SHORT $LN4@array_repr

; 2176 :         return PyUnicode_FromFormat("array('%c')", (int)typecode);

  0003b	0f be 44 24 30	 movsx	 eax, BYTE PTR typecode$[rsp]
  00040	8b d0		 mov	 edx, eax
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@CECFMNFO@array?$CI?8?$CFc?8?$CJ?$AA@
  00049	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0004e	eb 66		 jmp	 SHORT $LN5@array_repr
$LN4@array_repr:

; 2177 :     }
; 2178 :     if (typecode == 'u') {

  00050	0f be 44 24 30	 movsx	 eax, BYTE PTR typecode$[rsp]
  00055	83 f8 75	 cmp	 eax, 117		; 00000075H
  00058	75 13		 jne	 SHORT $LN3@array_repr

; 2179 :         v = array_tounicode(a, NULL);

  0005a	33 d2		 xor	 edx, edx
  0005c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00061	e8 00 00 00 00	 call	 array_tounicode
  00066	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2180 :     } else {

  0006b	eb 11		 jmp	 SHORT $LN2@array_repr
$LN3@array_repr:

; 2181 :         v = array_tolist(a, NULL);

  0006d	33 d2		 xor	 edx, edx
  0006f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00074	e8 00 00 00 00	 call	 array_tolist
  00079	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax
$LN2@array_repr:

; 2182 :     }
; 2183 :     if (v == NULL)

  0007e	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00084	75 04		 jne	 SHORT $LN1@array_repr

; 2184 :         return NULL;

  00086	33 c0		 xor	 eax, eax
  00088	eb 2c		 jmp	 SHORT $LN5@array_repr
$LN1@array_repr:

; 2185 : 
; 2186 :     s = PyUnicode_FromFormat("array('%c', %R)", (int)typecode, v);

  0008a	0f be 44 24 30	 movsx	 eax, BYTE PTR typecode$[rsp]
  0008f	4c 8b 44 24 20	 mov	 r8, QWORD PTR v$[rsp]
  00094	8b d0		 mov	 edx, eax
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@ELMLMNDK@array?$CI?8?$CFc?8?0?5?$CFR?$CJ?$AA@
  0009d	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000a2	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 2187 :     Py_DECREF(v);

  000a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  000ac	e8 00 00 00 00	 call	 _Py_DecRef

; 2188 :     return s;

  000b1	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
$LN5@array_repr:

; 2189 : }

  000b6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ba	c3		 ret	 0
array_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@MJNNCJGL@array?5indices?5must?5be?5integers?$AA@ ; `string'
EXTRN	PySlice_GetIndicesEx:PROC
EXTRN	PySlice_Type:BYTE
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_subscr DD imagerel array_subscr
	DD	imagerel array_subscr+765
	DD	imagerel $unwind$array_subscr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_subscr DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0BP@MJNNCJGL@array?5indices?5must?5be?5integers?$AA@
CONST	SEGMENT
??_C@_0BP@MJNNCJGL@array?5indices?5must?5be?5integers?$AA@ DB 'array indi'
	DB	'ces must be integers', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_subscr
_TEXT	SEGMENT
i$22183 = 48
ar$22198 = 56
itemsize$22199 = 64
i$22196 = 72
cur$22195 = 80
slicelength$22194 = 88
step$22193 = 96
stop$22192 = 104
start$22191 = 112
result$22197 = 120
result$22206 = 128
tv171 = 136
self$ = 160
item$ = 168
array_subscr PROC					; COMDAT

; 2193 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2194 :     if (PyIndex_Check(item)) {

  00011	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00019	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001d	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00025	0f 84 8f 00 00
	00		 je	 $LN16@array_subs
  0002b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00033	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00037	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0003e	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00046	74 72		 je	 SHORT $LN16@array_subs

; 2195 :         Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  00048	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  0004f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00057	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0005c	48 89 44 24 30	 mov	 QWORD PTR i$22183[rsp], rax

; 2196 :         if (i==-1 && PyErr_Occurred()) {

  00061	48 83 7c 24 30
	ff		 cmp	 QWORD PTR i$22183[rsp], -1
  00067	75 11		 jne	 SHORT $LN15@array_subs
  00069	e8 00 00 00 00	 call	 PyErr_Occurred
  0006e	48 85 c0	 test	 rax, rax
  00071	74 07		 je	 SHORT $LN15@array_subs

; 2197 :             return NULL;

  00073	33 c0		 xor	 eax, eax
  00075	e9 7b 02 00 00	 jmp	 $LN17@array_subs
$LN15@array_subs:

; 2198 :         }
; 2199 :         if (i < 0)

  0007a	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$22183[rsp], 0
  00080	7d 1c		 jge	 SHORT $LN14@array_subs

; 2200 :             i += Py_SIZE(self);

  00082	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0008a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$22183[rsp]
  00093	48 03 c8	 add	 rcx, rax
  00096	48 8b c1	 mov	 rax, rcx
  00099	48 89 44 24 30	 mov	 QWORD PTR i$22183[rsp], rax
$LN14@array_subs:

; 2201 :         return array_item(self, i);

  0009e	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$22183[rsp]
  000a3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000ab	e8 00 00 00 00	 call	 array_item
  000b0	e9 40 02 00 00	 jmp	 $LN17@array_subs
  000b5	e9 3b 02 00 00	 jmp	 $LN13@array_subs
$LN16@array_subs:

; 2202 :     }
; 2203 :     else if (PySlice_Check(item)) {

  000ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  000c1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  000c9	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000cd	0f 85 0d 02 00
	00		 jne	 $LN12@array_subs

; 2204 :         Py_ssize_t start, stop, step, slicelength, cur, i;
; 2205 :         PyObject* result;
; 2206 :         arrayobject* ar;
; 2207 :         int itemsize = self->ob_descr->itemsize;

  000d3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000db	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000e2	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000e5	89 44 24 40	 mov	 DWORD PTR itemsize$22199[rsp], eax

; 2208 : 
; 2209 :         if (PySlice_GetIndicesEx(item, Py_SIZE(self),
; 2210 :                          &start, &stop, &step, &slicelength) < 0) {

  000e9	48 8d 44 24 58	 lea	 rax, QWORD PTR slicelength$22194[rsp]
  000ee	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f3	48 8d 44 24 60	 lea	 rax, QWORD PTR step$22193[rsp]
  000f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fd	4c 8d 4c 24 68	 lea	 r9, QWORD PTR stop$22192[rsp]
  00102	4c 8d 44 24 70	 lea	 r8, QWORD PTR start$22191[rsp]
  00107	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0010f	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00113	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  0011b	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  00120	85 c0		 test	 eax, eax
  00122	7d 07		 jge	 SHORT $LN11@array_subs

; 2211 :             return NULL;

  00124	33 c0		 xor	 eax, eax
  00126	e9 ca 01 00 00	 jmp	 $LN17@array_subs
$LN11@array_subs:

; 2212 :         }
; 2213 : 
; 2214 :         if (slicelength <= 0) {

  0012b	48 83 7c 24 58
	00		 cmp	 QWORD PTR slicelength$22194[rsp], 0
  00131	7f 27		 jg	 SHORT $LN10@array_subs

; 2215 :             return newarrayobject(&Arraytype, 0, self->ob_descr);

  00133	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0013b	4c 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [rax+128]
  00142	33 d2		 xor	 edx, edx
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  0014b	e8 00 00 00 00	 call	 newarrayobject
  00150	e9 a0 01 00 00	 jmp	 $LN17@array_subs
  00155	e9 84 01 00 00	 jmp	 $LN9@array_subs
$LN10@array_subs:

; 2216 :         }
; 2217 :         else if (step == 1) {

  0015a	48 83 7c 24 60
	01		 cmp	 QWORD PTR step$22193[rsp], 1
  00160	0f 85 91 00 00
	00		 jne	 $LN8@array_subs

; 2218 :             PyObject *result = newarrayobject(&Arraytype,
; 2219 :                                     slicelength, self->ob_descr);

  00166	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0016e	4c 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [rax+128]
  00175	48 8b 54 24 58	 mov	 rdx, QWORD PTR slicelength$22194[rsp]
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  00181	e8 00 00 00 00	 call	 newarrayobject
  00186	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR result$22206[rsp], rax

; 2220 :             if (result == NULL)

  0018e	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR result$22206[rsp], 0
  00197	75 07		 jne	 SHORT $LN7@array_subs

; 2221 :                 return NULL;

  00199	33 c0		 xor	 eax, eax
  0019b	e9 55 01 00 00	 jmp	 $LN17@array_subs
$LN7@array_subs:

; 2222 :             memcpy(((arrayobject *)result)->ob_item,
; 2223 :                    self->ob_item + start * itemsize,
; 2224 :                    slicelength * itemsize);

  001a0	48 63 44 24 40	 movsxd	 rax, DWORD PTR itemsize$22199[rsp]
  001a5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slicelength$22194[rsp]
  001aa	48 0f af c8	 imul	 rcx, rax
  001ae	48 8b c1	 mov	 rax, rcx
  001b1	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR itemsize$22199[rsp]
  001b6	48 8b 54 24 70	 mov	 rdx, QWORD PTR start$22191[rsp]
  001bb	48 0f af d1	 imul	 rdx, rcx
  001bf	48 8b ca	 mov	 rcx, rdx
  001c2	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  001ca	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  001ce	4c 8b c0	 mov	 r8, rax
  001d1	48 8b d1	 mov	 rdx, rcx
  001d4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR result$22206[rsp]
  001dc	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  001e0	e8 00 00 00 00	 call	 memcpy

; 2225 :             return result;

  001e5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR result$22206[rsp]
  001ed	e9 03 01 00 00	 jmp	 $LN17@array_subs

; 2226 :         }
; 2227 :         else {

  001f2	e9 e7 00 00 00	 jmp	 $LN6@array_subs
$LN8@array_subs:

; 2228 :             result = newarrayobject(&Arraytype, slicelength, self->ob_descr);

  001f7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001ff	4c 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [rax+128]
  00206	48 8b 54 24 58	 mov	 rdx, QWORD PTR slicelength$22194[rsp]
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  00212	e8 00 00 00 00	 call	 newarrayobject
  00217	48 89 44 24 78	 mov	 QWORD PTR result$22197[rsp], rax

; 2229 :             if (!result) return NULL;

  0021c	48 83 7c 24 78
	00		 cmp	 QWORD PTR result$22197[rsp], 0
  00222	75 07		 jne	 SHORT $LN5@array_subs
  00224	33 c0		 xor	 eax, eax
  00226	e9 ca 00 00 00	 jmp	 $LN17@array_subs
$LN5@array_subs:

; 2230 : 
; 2231 :             ar = (arrayobject*)result;

  0022b	48 8b 44 24 78	 mov	 rax, QWORD PTR result$22197[rsp]
  00230	48 89 44 24 38	 mov	 QWORD PTR ar$22198[rsp], rax

; 2232 : 
; 2233 :             for (cur = start, i = 0; i < slicelength;
; 2234 :                  cur += step, i++) {

  00235	48 8b 44 24 70	 mov	 rax, QWORD PTR start$22191[rsp]
  0023a	48 89 44 24 50	 mov	 QWORD PTR cur$22195[rsp], rax
  0023f	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR i$22196[rsp], 0
  00248	eb 22		 jmp	 SHORT $LN4@array_subs
$LN3@array_subs:
  0024a	48 8b 44 24 60	 mov	 rax, QWORD PTR step$22193[rsp]
  0024f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cur$22195[rsp]
  00254	48 03 c8	 add	 rcx, rax
  00257	48 8b c1	 mov	 rax, rcx
  0025a	48 89 44 24 50	 mov	 QWORD PTR cur$22195[rsp], rax
  0025f	48 8b 44 24 48	 mov	 rax, QWORD PTR i$22196[rsp]
  00264	48 ff c0	 inc	 rax
  00267	48 89 44 24 48	 mov	 QWORD PTR i$22196[rsp], rax
$LN4@array_subs:
  0026c	48 8b 44 24 58	 mov	 rax, QWORD PTR slicelength$22194[rsp]
  00271	48 39 44 24 48	 cmp	 QWORD PTR i$22196[rsp], rax
  00276	7d 5f		 jge	 SHORT $LN2@array_subs

; 2235 :                 memcpy(ar->ob_item + i*itemsize,
; 2236 :                        self->ob_item + cur*itemsize,
; 2237 :                        itemsize);

  00278	48 63 44 24 40	 movsxd	 rax, DWORD PTR itemsize$22199[rsp]
  0027d	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR itemsize$22199[rsp]
  00282	48 8b 54 24 50	 mov	 rdx, QWORD PTR cur$22195[rsp]
  00287	48 0f af d1	 imul	 rdx, rcx
  0028b	48 8b ca	 mov	 rcx, rdx
  0028e	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  00296	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  0029a	48 63 54 24 40	 movsxd	 rdx, DWORD PTR itemsize$22199[rsp]
  0029f	4c 8b 44 24 48	 mov	 r8, QWORD PTR i$22196[rsp]
  002a4	4c 0f af c2	 imul	 r8, rdx
  002a8	49 8b d0	 mov	 rdx, r8
  002ab	4c 8b 44 24 38	 mov	 r8, QWORD PTR ar$22198[rsp]
  002b0	49 03 50 70	 add	 rdx, QWORD PTR [r8+112]
  002b4	48 89 94 24 88
	00 00 00	 mov	 QWORD PTR tv171[rsp], rdx
  002bc	4c 8b c0	 mov	 r8, rax
  002bf	48 8b d1	 mov	 rdx, rcx
  002c2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv171[rsp]
  002ca	48 8b c8	 mov	 rcx, rax
  002cd	e8 00 00 00 00	 call	 memcpy

; 2238 :             }

  002d2	e9 73 ff ff ff	 jmp	 $LN3@array_subs
$LN2@array_subs:

; 2239 : 
; 2240 :             return result;

  002d7	48 8b 44 24 78	 mov	 rax, QWORD PTR result$22197[rsp]
  002dc	eb 17		 jmp	 SHORT $LN17@array_subs
$LN6@array_subs:
$LN9@array_subs:

; 2241 :         }
; 2242 :     }
; 2243 :     else {

  002de	eb 15		 jmp	 SHORT $LN1@array_subs
$LN12@array_subs:

; 2244 :         PyErr_SetString(PyExc_TypeError,
; 2245 :                         "array indices must be integers");

  002e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@MJNNCJGL@array?5indices?5must?5be?5integers?$AA@
  002e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002ee	e8 00 00 00 00	 call	 PyErr_SetString

; 2246 :         return NULL;

  002f3	33 c0		 xor	 eax, eax
$LN1@array_subs:
$LN13@array_subs:
$LN17@array_subs:

; 2247 :     }
; 2248 : }

  002f5	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002fc	c3		 ret	 0
array_subscr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EC@CKGLHKPA@attempt?5to?5assign?5array?5of?5size?5@ ; `string'
PUBLIC	??_C@_0BO@BIAFMNPF@array?5indices?5must?5be?5integer?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_ass_subscr DD imagerel array_ass_subscr
	DD	imagerel array_ass_subscr+2274
	DD	imagerel $unwind$array_ass_subscr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_ass_subscr DD 021601H
	DD	01b0116H
xdata	ENDS
;	COMDAT ??_C@_0EC@CKGLHKPA@attempt?5to?5assign?5array?5of?5size?5@
CONST	SEGMENT
??_C@_0EC@CKGLHKPA@attempt?5to?5assign?5array?5of?5size?5@ DB 'attempt to'
	DB	' assign array of size %zd to extended slice of size %zd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BIAFMNPF@array?5indices?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BO@BIAFMNPF@array?5indices?5must?5be?5integer?$AA@ DB 'array indic'
	DB	'es must be integer', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_ass_subscr
_TEXT	SEGMENT
itemsize$ = 48
slicelength$ = 56
step$ = 64
stop$ = 72
other$ = 80
start$ = 88
needed$ = 96
i$22239 = 104
ret$22267 = 112
i$22293 = 120
cur$22292 = 128
lim$22298 = 136
i$22312 = 144
cur$22311 = 152
tv195 = 160
tv227 = 168
tv271 = 176
tv291 = 184
tv317 = 192
self$ = 224
item$ = 232
value$ = 240
array_ass_subscr PROC					; COMDAT

; 2252 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 2253 :     Py_ssize_t start, stop, step, slicelength, needed;
; 2254 :     arrayobject* other;
; 2255 :     int itemsize;
; 2256 : 
; 2257 :     if (PyIndex_Check(item)) {

  00016	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  0001e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00022	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  0002a	0f 84 16 01 00
	00		 je	 $LN45@array_ass_@3
  00030	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00038	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003c	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00043	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  0004b	0f 84 f5 00 00
	00		 je	 $LN45@array_ass_@3

; 2258 :         Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  00051	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00058	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00060	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00065	48 89 44 24 68	 mov	 QWORD PTR i$22239[rsp], rax

; 2259 : 
; 2260 :         if (i == -1 && PyErr_Occurred())

  0006a	48 83 7c 24 68
	ff		 cmp	 QWORD PTR i$22239[rsp], -1
  00070	75 14		 jne	 SHORT $LN44@array_ass_@3
  00072	e8 00 00 00 00	 call	 PyErr_Occurred
  00077	48 85 c0	 test	 rax, rax
  0007a	74 0a		 je	 SHORT $LN44@array_ass_@3

; 2261 :             return -1;

  0007c	b8 ff ff ff ff	 mov	 eax, -1
  00081	e9 54 08 00 00	 jmp	 $LN46@array_ass_@3
$LN44@array_ass_@3:

; 2262 :         if (i < 0)

  00086	48 83 7c 24 68
	00		 cmp	 QWORD PTR i$22239[rsp], 0
  0008c	7d 1c		 jge	 SHORT $LN43@array_ass_@3

; 2263 :             i += Py_SIZE(self);

  0008e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00096	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0009a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR i$22239[rsp]
  0009f	48 03 c8	 add	 rcx, rax
  000a2	48 8b c1	 mov	 rax, rcx
  000a5	48 89 44 24 68	 mov	 QWORD PTR i$22239[rsp], rax
$LN43@array_ass_@3:

; 2264 :         if (i < 0 || i >= Py_SIZE(self)) {

  000aa	48 83 7c 24 68
	00		 cmp	 QWORD PTR i$22239[rsp], 0
  000b0	7c 13		 jl	 SHORT $LN41@array_ass_@3
  000b2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000ba	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000be	48 39 44 24 68	 cmp	 QWORD PTR i$22239[rsp], rax
  000c3	7c 1d		 jl	 SHORT $LN42@array_ass_@3
$LN41@array_ass_@3:

; 2265 :             PyErr_SetString(PyExc_IndexError,
; 2266 :                 "array assignment index out of range");

  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@DDILIBCI@array?5assignment?5index?5out?5of?5ra@
  000cc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000d3	e8 00 00 00 00	 call	 PyErr_SetString

; 2267 :             return -1;

  000d8	b8 ff ff ff ff	 mov	 eax, -1
  000dd	e9 f8 07 00 00	 jmp	 $LN46@array_ass_@3
$LN42@array_ass_@3:

; 2268 :         }
; 2269 :         if (value == NULL) {

  000e2	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR value$[rsp], 0
  000eb	75 2b		 jne	 SHORT $LN40@array_ass_@3

; 2270 :             /* Fall through to slice assignment */
; 2271 :             start = i;

  000ed	48 8b 44 24 68	 mov	 rax, QWORD PTR i$22239[rsp]
  000f2	48 89 44 24 58	 mov	 QWORD PTR start$[rsp], rax

; 2272 :             stop = i + 1;

  000f7	48 8b 44 24 68	 mov	 rax, QWORD PTR i$22239[rsp]
  000fc	48 ff c0	 inc	 rax
  000ff	48 89 44 24 48	 mov	 QWORD PTR stop$[rsp], rax

; 2273 :             step = 1;

  00104	48 c7 44 24 40
	01 00 00 00	 mov	 QWORD PTR step$[rsp], 1

; 2274 :             slicelength = 1;

  0010d	48 c7 44 24 38
	01 00 00 00	 mov	 QWORD PTR slicelength$[rsp], 1

; 2275 :         }
; 2276 :         else

  00116	eb 2c		 jmp	 SHORT $LN39@array_ass_@3
$LN40@array_ass_@3:

; 2277 :             return (*self->ob_descr->setitem)(self, i, value);

  00118	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00120	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00127	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR value$[rsp]
  0012f	48 8b 54 24 68	 mov	 rdx, QWORD PTR i$22239[rsp]
  00134	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0013c	ff 50 10	 call	 QWORD PTR [rax+16]
  0013f	e9 96 07 00 00	 jmp	 $LN46@array_ass_@3
$LN39@array_ass_@3:

; 2278 :     }
; 2279 :     else if (PySlice_Check(item)) {

  00144	eb 79		 jmp	 SHORT $LN38@array_ass_@3
$LN45@array_ass_@3:
  00146	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  0014d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00155	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00159	75 47		 jne	 SHORT $LN37@array_ass_@3

; 2280 :         if (PySlice_GetIndicesEx(item,
; 2281 :                                  Py_SIZE(self), &start, &stop,
; 2282 :                                  &step, &slicelength) < 0) {

  0015b	48 8d 44 24 38	 lea	 rax, QWORD PTR slicelength$[rsp]
  00160	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00165	48 8d 44 24 40	 lea	 rax, QWORD PTR step$[rsp]
  0016a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016f	4c 8d 4c 24 48	 lea	 r9, QWORD PTR stop$[rsp]
  00174	4c 8d 44 24 58	 lea	 r8, QWORD PTR start$[rsp]
  00179	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00181	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00185	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  0018d	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  00192	85 c0		 test	 eax, eax
  00194	7d 0a		 jge	 SHORT $LN36@array_ass_@3

; 2283 :             return -1;

  00196	b8 ff ff ff ff	 mov	 eax, -1
  0019b	e9 3a 07 00 00	 jmp	 $LN46@array_ass_@3
$LN36@array_ass_@3:

; 2284 :         }
; 2285 :     }
; 2286 :     else {

  001a0	eb 1d		 jmp	 SHORT $LN35@array_ass_@3
$LN37@array_ass_@3:

; 2287 :         PyErr_SetString(PyExc_TypeError,
; 2288 :                         "array indices must be integer");

  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@BIAFMNPF@array?5indices?5must?5be?5integer?$AA@
  001a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001b0	e8 00 00 00 00	 call	 PyErr_SetString

; 2289 :         return -1;

  001b5	b8 ff ff ff ff	 mov	 eax, -1
  001ba	e9 1b 07 00 00	 jmp	 $LN46@array_ass_@3
$LN35@array_ass_@3:
$LN38@array_ass_@3:

; 2290 :     }
; 2291 :     if (value == NULL) {

  001bf	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR value$[rsp], 0
  001c8	75 17		 jne	 SHORT $LN34@array_ass_@3

; 2292 :         other = NULL;

  001ca	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR other$[rsp], 0

; 2293 :         needed = 0;

  001d3	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR needed$[rsp], 0
  001dc	e9 1f 01 00 00	 jmp	 $LN33@array_ass_@3
$LN34@array_ass_@3:

; 2294 :     }
; 2295 :     else if (array_Check(value)) {

  001e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  001e8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  001f0	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001f4	74 20		 je	 SHORT $LN31@array_ass_@3
  001f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  001fd	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR value$[rsp]
  00205	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00209	e8 00 00 00 00	 call	 PyType_IsSubtype
  0020e	85 c0		 test	 eax, eax
  00210	0f 84 bd 00 00
	00		 je	 $LN32@array_ass_@3
$LN31@array_ass_@3:

; 2296 :         other = (arrayobject *)value;

  00216	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR value$[rsp]
  0021e	48 89 44 24 50	 mov	 QWORD PTR other$[rsp], rax

; 2297 :         needed = Py_SIZE(other);

  00223	48 8b 44 24 50	 mov	 rax, QWORD PTR other$[rsp]
  00228	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0022c	48 89 44 24 60	 mov	 QWORD PTR needed$[rsp], rax

; 2298 :         if (self == other) {

  00231	48 8b 44 24 50	 mov	 rax, QWORD PTR other$[rsp]
  00236	48 39 84 24 e0
	00 00 00	 cmp	 QWORD PTR self$[rsp], rax
  0023e	75 65		 jne	 SHORT $LN30@array_ass_@3

; 2299 :             /* Special case "self[i:j] = self" -- copy self first */
; 2300 :             int ret;
; 2301 :             value = array_slice(other, 0, needed);

  00240	4c 8b 44 24 60	 mov	 r8, QWORD PTR needed$[rsp]
  00245	33 d2		 xor	 edx, edx
  00247	48 8b 4c 24 50	 mov	 rcx, QWORD PTR other$[rsp]
  0024c	e8 00 00 00 00	 call	 array_slice
  00251	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR value$[rsp], rax

; 2302 :             if (value == NULL)

  00259	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR value$[rsp], 0
  00262	75 0a		 jne	 SHORT $LN29@array_ass_@3

; 2303 :                 return -1;

  00264	b8 ff ff ff ff	 mov	 eax, -1
  00269	e9 6c 06 00 00	 jmp	 $LN46@array_ass_@3
$LN29@array_ass_@3:

; 2304 :             ret = array_ass_subscr(self, item, value);

  0026e	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR value$[rsp]
  00276	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR item$[rsp]
  0027e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00286	e8 00 00 00 00	 call	 array_ass_subscr
  0028b	89 44 24 70	 mov	 DWORD PTR ret$22267[rsp], eax

; 2305 :             Py_DECREF(value);

  0028f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  00297	e8 00 00 00 00	 call	 _Py_DecRef

; 2306 :             return ret;

  0029c	8b 44 24 70	 mov	 eax, DWORD PTR ret$22267[rsp]
  002a0	e9 35 06 00 00	 jmp	 $LN46@array_ass_@3
$LN30@array_ass_@3:

; 2307 :         }
; 2308 :         if (other->ob_descr != self->ob_descr) {

  002a5	48 8b 44 24 50	 mov	 rax, QWORD PTR other$[rsp]
  002aa	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  002b2	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  002b9	48 39 88 80 00
	00 00		 cmp	 QWORD PTR [rax+128], rcx
  002c0	74 0f		 je	 SHORT $LN28@array_ass_@3

; 2309 :             PyErr_BadArgument();

  002c2	e8 00 00 00 00	 call	 PyErr_BadArgument

; 2310 :             return -1;

  002c7	b8 ff ff ff ff	 mov	 eax, -1
  002cc	e9 09 06 00 00	 jmp	 $LN46@array_ass_@3
$LN28@array_ass_@3:

; 2311 :         }
; 2312 :     }
; 2313 :     else {

  002d1	eb 2d		 jmp	 SHORT $LN27@array_ass_@3
$LN32@array_ass_@3:

; 2314 :         PyErr_Format(PyExc_TypeError,
; 2315 :          "can only assign array (not \"%.200s\") to array slice",
; 2316 :                          Py_TYPE(value)->tp_name);

  002d3	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR value$[rsp]
  002db	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002df	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  002e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@JBAHFOA@can?5only?5assign?5array?5?$CInot?5?$CC?$CF?420@
  002ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002f1	e8 00 00 00 00	 call	 PyErr_Format

; 2317 :         return -1;

  002f6	b8 ff ff ff ff	 mov	 eax, -1
  002fb	e9 da 05 00 00	 jmp	 $LN46@array_ass_@3
$LN27@array_ass_@3:
$LN33@array_ass_@3:

; 2318 :     }
; 2319 :     itemsize = self->ob_descr->itemsize;

  00300	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00308	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0030f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00312	89 44 24 30	 mov	 DWORD PTR itemsize$[rsp], eax

; 2320 :     /* for 'a[2:1] = ...', the insertion point is 'start', not 'stop' */
; 2321 :     if ((step > 0 && stop < start) ||
; 2322 :         (step < 0 && stop > start))

  00316	48 83 7c 24 40
	00		 cmp	 QWORD PTR step$[rsp], 0
  0031c	7e 0c		 jle	 SHORT $LN24@array_ass_@3
  0031e	48 8b 44 24 58	 mov	 rax, QWORD PTR start$[rsp]
  00323	48 39 44 24 48	 cmp	 QWORD PTR stop$[rsp], rax
  00328	7c 14		 jl	 SHORT $LN25@array_ass_@3
$LN24@array_ass_@3:
  0032a	48 83 7c 24 40
	00		 cmp	 QWORD PTR step$[rsp], 0
  00330	7d 16		 jge	 SHORT $LN26@array_ass_@3
  00332	48 8b 44 24 58	 mov	 rax, QWORD PTR start$[rsp]
  00337	48 39 44 24 48	 cmp	 QWORD PTR stop$[rsp], rax
  0033c	7e 0a		 jle	 SHORT $LN26@array_ass_@3
$LN25@array_ass_@3:

; 2323 :         stop = start;

  0033e	48 8b 44 24 58	 mov	 rax, QWORD PTR start$[rsp]
  00343	48 89 44 24 48	 mov	 QWORD PTR stop$[rsp], rax
$LN26@array_ass_@3:

; 2324 : 
; 2325 :     /* Issue #4509: If the array has exported buffers and the slice
; 2326 :        assignment would change the size of the array, fail early to make
; 2327 :        sure we don't modify it. */
; 2328 :     if ((needed == 0 || slicelength != needed) && self->ob_exports > 0) {

  00348	48 83 7c 24 60
	00		 cmp	 QWORD PTR needed$[rsp], 0
  0034e	74 0c		 je	 SHORT $LN22@array_ass_@3
  00350	48 8b 44 24 60	 mov	 rax, QWORD PTR needed$[rsp]
  00355	48 39 44 24 38	 cmp	 QWORD PTR slicelength$[rsp], rax
  0035a	74 2e		 je	 SHORT $LN23@array_ass_@3
$LN22@array_ass_@3:
  0035c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00364	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  0036b	7e 1d		 jle	 SHORT $LN23@array_ass_@3

; 2329 :         PyErr_SetString(PyExc_BufferError,
; 2330 :             "cannot resize an array that is exporting buffers");

  0036d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@GJKGCBFK@cannot?5resize?5an?5array?5that?5is?5e@
  00374	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0037b	e8 00 00 00 00	 call	 PyErr_SetString

; 2331 :         return -1;

  00380	b8 ff ff ff ff	 mov	 eax, -1
  00385	e9 50 05 00 00	 jmp	 $LN46@array_ass_@3
$LN23@array_ass_@3:

; 2332 :     }
; 2333 : 
; 2334 :     if (step == 1) {

  0038a	48 83 7c 24 40
	01		 cmp	 QWORD PTR step$[rsp], 1
  00390	0f 85 e1 01 00
	00		 jne	 $LN21@array_ass_@3

; 2335 :         if (slicelength > needed) {

  00396	48 8b 44 24 60	 mov	 rax, QWORD PTR needed$[rsp]
  0039b	48 39 44 24 38	 cmp	 QWORD PTR slicelength$[rsp], rax
  003a0	0f 8e b7 00 00
	00		 jle	 $LN20@array_ass_@3

; 2336 :             memmove(self->ob_item + (start + needed) * itemsize,
; 2337 :                 self->ob_item + stop * itemsize,
; 2338 :                 (Py_SIZE(self) - stop) * itemsize);

  003a6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  003ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR stop$[rsp]
  003b3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  003b7	48 2b c1	 sub	 rax, rcx
  003ba	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR itemsize$[rsp]
  003bf	48 0f af c1	 imul	 rax, rcx
  003c3	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR itemsize$[rsp]
  003c8	48 8b 54 24 48	 mov	 rdx, QWORD PTR stop$[rsp]
  003cd	48 0f af d1	 imul	 rdx, rcx
  003d1	48 8b ca	 mov	 rcx, rdx
  003d4	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  003dc	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  003e0	48 8b 54 24 60	 mov	 rdx, QWORD PTR needed$[rsp]
  003e5	4c 8b 44 24 58	 mov	 r8, QWORD PTR start$[rsp]
  003ea	4c 03 c2	 add	 r8, rdx
  003ed	49 8b d0	 mov	 rdx, r8
  003f0	4c 63 44 24 30	 movsxd	 r8, DWORD PTR itemsize$[rsp]
  003f5	49 0f af d0	 imul	 rdx, r8
  003f9	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR self$[rsp]
  00401	49 03 50 70	 add	 rdx, QWORD PTR [r8+112]
  00405	48 89 94 24 a0
	00 00 00	 mov	 QWORD PTR tv195[rsp], rdx
  0040d	4c 8b c0	 mov	 r8, rax
  00410	48 8b d1	 mov	 rdx, rcx
  00413	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv195[rsp]
  0041b	48 8b c8	 mov	 rcx, rax
  0041e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 2339 :             if (array_resize(self, Py_SIZE(self) +
; 2340 :                 needed - slicelength) < 0)

  00424	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0042c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00430	48 03 44 24 60	 add	 rax, QWORD PTR needed$[rsp]
  00435	48 2b 44 24 38	 sub	 rax, QWORD PTR slicelength$[rsp]
  0043a	48 8b d0	 mov	 rdx, rax
  0043d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00445	e8 00 00 00 00	 call	 array_resize
  0044a	85 c0		 test	 eax, eax
  0044c	7d 0a		 jge	 SHORT $LN19@array_ass_@3

; 2341 :                 return -1;

  0044e	b8 ff ff ff ff	 mov	 eax, -1
  00453	e9 82 04 00 00	 jmp	 $LN46@array_ass_@3
$LN19@array_ass_@3:

; 2342 :         }
; 2343 :         else if (slicelength < needed) {

  00458	e9 c7 00 00 00	 jmp	 $LN18@array_ass_@3
$LN20@array_ass_@3:
  0045d	48 8b 44 24 60	 mov	 rax, QWORD PTR needed$[rsp]
  00462	48 39 44 24 38	 cmp	 QWORD PTR slicelength$[rsp], rax
  00467	0f 8d b7 00 00
	00		 jge	 $LN17@array_ass_@3

; 2344 :             if (array_resize(self, Py_SIZE(self) +
; 2345 :                 needed - slicelength) < 0)

  0046d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00475	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00479	48 03 44 24 60	 add	 rax, QWORD PTR needed$[rsp]
  0047e	48 2b 44 24 38	 sub	 rax, QWORD PTR slicelength$[rsp]
  00483	48 8b d0	 mov	 rdx, rax
  00486	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0048e	e8 00 00 00 00	 call	 array_resize
  00493	85 c0		 test	 eax, eax
  00495	7d 0a		 jge	 SHORT $LN16@array_ass_@3

; 2346 :                 return -1;

  00497	b8 ff ff ff ff	 mov	 eax, -1
  0049c	e9 39 04 00 00	 jmp	 $LN46@array_ass_@3
$LN16@array_ass_@3:

; 2347 :             memmove(self->ob_item + (start + needed) * itemsize,
; 2348 :                 self->ob_item + stop * itemsize,
; 2349 :                 (Py_SIZE(self) - start - needed) * itemsize);

  004a1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  004a9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR start$[rsp]
  004ae	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  004b2	48 2b c1	 sub	 rax, rcx
  004b5	48 2b 44 24 60	 sub	 rax, QWORD PTR needed$[rsp]
  004ba	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR itemsize$[rsp]
  004bf	48 0f af c1	 imul	 rax, rcx
  004c3	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR itemsize$[rsp]
  004c8	48 8b 54 24 48	 mov	 rdx, QWORD PTR stop$[rsp]
  004cd	48 0f af d1	 imul	 rdx, rcx
  004d1	48 8b ca	 mov	 rcx, rdx
  004d4	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  004dc	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  004e0	48 8b 54 24 60	 mov	 rdx, QWORD PTR needed$[rsp]
  004e5	4c 8b 44 24 58	 mov	 r8, QWORD PTR start$[rsp]
  004ea	4c 03 c2	 add	 r8, rdx
  004ed	49 8b d0	 mov	 rdx, r8
  004f0	4c 63 44 24 30	 movsxd	 r8, DWORD PTR itemsize$[rsp]
  004f5	49 0f af d0	 imul	 rdx, r8
  004f9	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR self$[rsp]
  00501	49 03 50 70	 add	 rdx, QWORD PTR [r8+112]
  00505	48 89 94 24 a8
	00 00 00	 mov	 QWORD PTR tv227[rsp], rdx
  0050d	4c 8b c0	 mov	 r8, rax
  00510	48 8b d1	 mov	 rdx, rcx
  00513	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv227[rsp]
  0051b	48 8b c8	 mov	 rcx, rax
  0051e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN17@array_ass_@3:
$LN18@array_ass_@3:

; 2350 :         }
; 2351 :         if (needed > 0)

  00524	48 83 7c 24 60
	00		 cmp	 QWORD PTR needed$[rsp], 0
  0052a	7e 3f		 jle	 SHORT $LN15@array_ass_@3

; 2352 :             memcpy(self->ob_item + start * itemsize,
; 2353 :                    other->ob_item, needed * itemsize);

  0052c	48 63 44 24 30	 movsxd	 rax, DWORD PTR itemsize$[rsp]
  00531	48 8b 4c 24 60	 mov	 rcx, QWORD PTR needed$[rsp]
  00536	48 0f af c8	 imul	 rcx, rax
  0053a	48 8b c1	 mov	 rax, rcx
  0053d	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR itemsize$[rsp]
  00542	48 8b 54 24 58	 mov	 rdx, QWORD PTR start$[rsp]
  00547	48 0f af d1	 imul	 rdx, rcx
  0054b	48 8b ca	 mov	 rcx, rdx
  0054e	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  00556	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  0055a	4c 8b c0	 mov	 r8, rax
  0055d	48 8b 44 24 50	 mov	 rax, QWORD PTR other$[rsp]
  00562	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00566	e8 00 00 00 00	 call	 memcpy
$LN15@array_ass_@3:

; 2354 :         return 0;

  0056b	33 c0		 xor	 eax, eax
  0056d	e9 68 03 00 00	 jmp	 $LN46@array_ass_@3
  00572	e9 63 03 00 00	 jmp	 $LN14@array_ass_@3
$LN21@array_ass_@3:

; 2355 :     }
; 2356 :     else if (needed == 0) {

  00577	48 83 7c 24 60
	00		 cmp	 QWORD PTR needed$[rsp], 0
  0057d	0f 85 65 02 00
	00		 jne	 $LN13@array_ass_@3

; 2357 :         /* Delete slice */
; 2358 :         size_t cur;
; 2359 :         Py_ssize_t i;
; 2360 : 
; 2361 :         if (step < 0) {

  00583	48 83 7c 24 40
	00		 cmp	 QWORD PTR step$[rsp], 0
  00589	7d 3d		 jge	 SHORT $LN12@array_ass_@3

; 2362 :             stop = start + 1;

  0058b	48 8b 44 24 58	 mov	 rax, QWORD PTR start$[rsp]
  00590	48 ff c0	 inc	 rax
  00593	48 89 44 24 48	 mov	 QWORD PTR stop$[rsp], rax

; 2363 :             start = stop + step * (slicelength - 1) - 1;

  00598	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$[rsp]
  0059d	48 ff c8	 dec	 rax
  005a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR step$[rsp]
  005a5	48 0f af c8	 imul	 rcx, rax
  005a9	48 8b c1	 mov	 rax, rcx
  005ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR stop$[rsp]
  005b1	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  005b6	48 89 44 24 58	 mov	 QWORD PTR start$[rsp], rax

; 2364 :             step = -step;

  005bb	48 8b 44 24 40	 mov	 rax, QWORD PTR step$[rsp]
  005c0	48 f7 d8	 neg	 rax
  005c3	48 89 44 24 40	 mov	 QWORD PTR step$[rsp], rax
$LN12@array_ass_@3:

; 2365 :         }
; 2366 :         for (cur = start, i = 0; i < slicelength;
; 2367 :              cur += step, i++) {

  005c8	48 8b 44 24 58	 mov	 rax, QWORD PTR start$[rsp]
  005cd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR cur$22292[rsp], rax
  005d5	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i$22293[rsp], 0
  005de	eb 28		 jmp	 SHORT $LN11@array_ass_@3
$LN10@array_ass_@3:
  005e0	48 8b 44 24 40	 mov	 rax, QWORD PTR step$[rsp]
  005e5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur$22292[rsp]
  005ed	48 03 c8	 add	 rcx, rax
  005f0	48 8b c1	 mov	 rax, rcx
  005f3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR cur$22292[rsp], rax
  005fb	48 8b 44 24 78	 mov	 rax, QWORD PTR i$22293[rsp]
  00600	48 ff c0	 inc	 rax
  00603	48 89 44 24 78	 mov	 QWORD PTR i$22293[rsp], rax
$LN11@array_ass_@3:
  00608	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$[rsp]
  0060d	48 39 44 24 78	 cmp	 QWORD PTR i$22293[rsp], rax
  00612	0f 8d d3 00 00
	00		 jge	 $LN9@array_ass_@3

; 2368 :             Py_ssize_t lim = step - 1;

  00618	48 8b 44 24 40	 mov	 rax, QWORD PTR step$[rsp]
  0061d	48 ff c8	 dec	 rax
  00620	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR lim$22298[rsp], rax

; 2369 : 
; 2370 :             if (cur + step >= (size_t)Py_SIZE(self))

  00628	48 8b 44 24 40	 mov	 rax, QWORD PTR step$[rsp]
  0062d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur$22292[rsp]
  00635	48 03 c8	 add	 rcx, rax
  00638	48 8b c1	 mov	 rax, rcx
  0063b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00643	48 3b 41 60	 cmp	 rax, QWORD PTR [rcx+96]
  00647	72 22		 jb	 SHORT $LN8@array_ass_@3

; 2371 :                 lim = Py_SIZE(self) - cur - 1;

  00649	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00651	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur$22292[rsp]
  00659	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0065d	48 2b c1	 sub	 rax, rcx
  00660	48 ff c8	 dec	 rax
  00663	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR lim$22298[rsp], rax
$LN8@array_ass_@3:

; 2372 :             memmove(self->ob_item + (cur - i) * itemsize,
; 2373 :                 self->ob_item + (cur + 1) * itemsize,
; 2374 :                 lim * itemsize);

  0066b	48 63 44 24 30	 movsxd	 rax, DWORD PTR itemsize$[rsp]
  00670	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR lim$22298[rsp]
  00678	48 0f af c8	 imul	 rcx, rax
  0067c	48 8b c1	 mov	 rax, rcx
  0067f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur$22292[rsp]
  00687	48 ff c1	 inc	 rcx
  0068a	48 63 54 24 30	 movsxd	 rdx, DWORD PTR itemsize$[rsp]
  0068f	48 0f af ca	 imul	 rcx, rdx
  00693	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  0069b	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  0069f	48 8b 54 24 78	 mov	 rdx, QWORD PTR i$22293[rsp]
  006a4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR cur$22292[rsp]
  006ac	4c 2b c2	 sub	 r8, rdx
  006af	49 8b d0	 mov	 rdx, r8
  006b2	4c 63 44 24 30	 movsxd	 r8, DWORD PTR itemsize$[rsp]
  006b7	49 0f af d0	 imul	 rdx, r8
  006bb	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR self$[rsp]
  006c3	49 03 50 70	 add	 rdx, QWORD PTR [r8+112]
  006c7	48 89 94 24 b0
	00 00 00	 mov	 QWORD PTR tv271[rsp], rdx
  006cf	4c 8b c0	 mov	 r8, rax
  006d2	48 8b d1	 mov	 rdx, rcx
  006d5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv271[rsp]
  006dd	48 8b c8	 mov	 rcx, rax
  006e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 2375 :         }

  006e6	e9 f5 fe ff ff	 jmp	 $LN10@array_ass_@3
$LN9@array_ass_@3:

; 2376 :         cur = start + (size_t)slicelength * step;

  006eb	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$[rsp]
  006f0	48 0f af 44 24
	40		 imul	 rax, QWORD PTR step$[rsp]
  006f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR start$[rsp]
  006fb	48 03 c8	 add	 rcx, rax
  006fe	48 8b c1	 mov	 rax, rcx
  00701	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR cur$22292[rsp], rax

; 2377 :         if (cur < (size_t)Py_SIZE(self)) {

  00709	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00711	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00715	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR cur$22292[rsp], rax
  0071d	0f 83 87 00 00
	00		 jae	 $LN7@array_ass_@3

; 2378 :             memmove(self->ob_item + (cur-slicelength) * itemsize,
; 2379 :                 self->ob_item + cur * itemsize,
; 2380 :                 (Py_SIZE(self) - cur) * itemsize);

  00723	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0072b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cur$22292[rsp]
  00733	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00737	48 2b c1	 sub	 rax, rcx
  0073a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR itemsize$[rsp]
  0073f	48 0f af c1	 imul	 rax, rcx
  00743	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR itemsize$[rsp]
  00748	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR cur$22292[rsp]
  00750	48 0f af d1	 imul	 rdx, rcx
  00754	48 8b ca	 mov	 rcx, rdx
  00757	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  0075f	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  00763	48 8b 54 24 38	 mov	 rdx, QWORD PTR slicelength$[rsp]
  00768	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR cur$22292[rsp]
  00770	4c 2b c2	 sub	 r8, rdx
  00773	49 8b d0	 mov	 rdx, r8
  00776	4c 63 44 24 30	 movsxd	 r8, DWORD PTR itemsize$[rsp]
  0077b	49 0f af d0	 imul	 rdx, r8
  0077f	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR self$[rsp]
  00787	49 03 50 70	 add	 rdx, QWORD PTR [r8+112]
  0078b	48 89 94 24 b8
	00 00 00	 mov	 QWORD PTR tv291[rsp], rdx
  00793	4c 8b c0	 mov	 r8, rax
  00796	48 8b d1	 mov	 rdx, rcx
  00799	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv291[rsp]
  007a1	48 8b c8	 mov	 rcx, rax
  007a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN7@array_ass_@3:

; 2381 :         }
; 2382 :         if (array_resize(self, Py_SIZE(self) - slicelength) < 0)

  007aa	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  007b2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR slicelength$[rsp]
  007b7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  007bb	48 2b c1	 sub	 rax, rcx
  007be	48 8b d0	 mov	 rdx, rax
  007c1	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  007c9	e8 00 00 00 00	 call	 array_resize
  007ce	85 c0		 test	 eax, eax
  007d0	7d 0a		 jge	 SHORT $LN6@array_ass_@3

; 2383 :             return -1;

  007d2	b8 ff ff ff ff	 mov	 eax, -1
  007d7	e9 fe 00 00 00	 jmp	 $LN46@array_ass_@3
$LN6@array_ass_@3:

; 2384 :         return 0;

  007dc	33 c0		 xor	 eax, eax
  007de	e9 f7 00 00 00	 jmp	 $LN46@array_ass_@3

; 2385 :     }
; 2386 :     else {

  007e3	e9 f2 00 00 00	 jmp	 $LN5@array_ass_@3
$LN13@array_ass_@3:

; 2387 :         Py_ssize_t cur, i;
; 2388 : 
; 2389 :         if (needed != slicelength) {

  007e8	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$[rsp]
  007ed	48 39 44 24 60	 cmp	 QWORD PTR needed$[rsp], rax
  007f2	74 27		 je	 SHORT $LN4@array_ass_@3

; 2390 :             PyErr_Format(PyExc_ValueError,
; 2391 :                 "attempt to assign array of size %zd "
; 2392 :                 "to extended slice of size %zd",
; 2393 :                 needed, slicelength);

  007f4	4c 8b 4c 24 38	 mov	 r9, QWORD PTR slicelength$[rsp]
  007f9	4c 8b 44 24 60	 mov	 r8, QWORD PTR needed$[rsp]
  007fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@CKGLHKPA@attempt?5to?5assign?5array?5of?5size?5@
  00805	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0080c	e8 00 00 00 00	 call	 PyErr_Format

; 2394 :             return -1;

  00811	b8 ff ff ff ff	 mov	 eax, -1
  00816	e9 bf 00 00 00	 jmp	 $LN46@array_ass_@3
$LN4@array_ass_@3:

; 2395 :         }
; 2396 :         for (cur = start, i = 0; i < slicelength;
; 2397 :              cur += step, i++) {

  0081b	48 8b 44 24 58	 mov	 rax, QWORD PTR start$[rsp]
  00820	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR cur$22311[rsp], rax
  00828	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$22312[rsp], 0
  00834	eb 2e		 jmp	 SHORT $LN3@array_ass_@3
$LN2@array_ass_@3:
  00836	48 8b 44 24 40	 mov	 rax, QWORD PTR step$[rsp]
  0083b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cur$22311[rsp]
  00843	48 03 c8	 add	 rcx, rax
  00846	48 8b c1	 mov	 rax, rcx
  00849	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR cur$22311[rsp], rax
  00851	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR i$22312[rsp]
  00859	48 ff c0	 inc	 rax
  0085c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR i$22312[rsp], rax
$LN3@array_ass_@3:
  00864	48 8b 44 24 38	 mov	 rax, QWORD PTR slicelength$[rsp]
  00869	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR i$22312[rsp], rax
  00871	7d 65		 jge	 SHORT $LN1@array_ass_@3

; 2398 :             memcpy(self->ob_item + cur * itemsize,
; 2399 :                    other->ob_item + i * itemsize,
; 2400 :                    itemsize);

  00873	48 63 44 24 30	 movsxd	 rax, DWORD PTR itemsize$[rsp]
  00878	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR itemsize$[rsp]
  0087d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR i$22312[rsp]
  00885	48 0f af d1	 imul	 rdx, rcx
  00889	48 8b ca	 mov	 rcx, rdx
  0088c	48 8b 54 24 50	 mov	 rdx, QWORD PTR other$[rsp]
  00891	48 03 4a 70	 add	 rcx, QWORD PTR [rdx+112]
  00895	48 63 54 24 30	 movsxd	 rdx, DWORD PTR itemsize$[rsp]
  0089a	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR cur$22311[rsp]
  008a2	4c 0f af c2	 imul	 r8, rdx
  008a6	49 8b d0	 mov	 rdx, r8
  008a9	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR self$[rsp]
  008b1	49 03 50 70	 add	 rdx, QWORD PTR [r8+112]
  008b5	48 89 94 24 c0
	00 00 00	 mov	 QWORD PTR tv317[rsp], rdx
  008bd	4c 8b c0	 mov	 r8, rax
  008c0	48 8b d1	 mov	 rdx, rcx
  008c3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv317[rsp]
  008cb	48 8b c8	 mov	 rcx, rax
  008ce	e8 00 00 00 00	 call	 memcpy

; 2401 :         }

  008d3	e9 5e ff ff ff	 jmp	 $LN2@array_ass_@3
$LN1@array_ass_@3:

; 2402 :         return 0;

  008d8	33 c0		 xor	 eax, eax
$LN5@array_ass_@3:
$LN14@array_ass_@3:
$LN46@array_ass_@3:

; 2403 :     }
; 2404 : }

  008da	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  008e1	c3		 ret	 0
array_ass_subscr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_buffer_getbuf DD imagerel array_buffer_getbuf
	DD	imagerel array_buffer_getbuf+382
	DD	imagerel $unwind$array_buffer_getbuf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_buffer_getbuf DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_buffer_getbuf
_TEXT	SEGMENT
self$ = 48
view$ = 56
flags$ = 64
array_buffer_getbuf PROC				; COMDAT

; 2417 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2418 :     if (view==NULL) goto finish;

  00013	48 83 7c 24 38
	00		 cmp	 QWORD PTR view$[rsp], 0
  00019	75 05		 jne	 SHORT $LN5@array_buff@2
  0001b	e9 3f 01 00 00	 jmp	 $finish$22334
$LN5@array_buff@2:

; 2419 : 
; 2420 :     view->buf = (void *)self->ob_item;

  00020	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0002a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0002e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2421 :     view->obj = (PyObject*)self;

  00031	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0003b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2422 :     Py_INCREF(self);

  0003f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00044	e8 00 00 00 00	 call	 _Py_IncRef

; 2423 :     if (view->buf == NULL)

  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  0004e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00052	75 0f		 jne	 SHORT $LN4@array_buff@2

; 2424 :         view->buf = (void *)emptybuf;

  00054	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR emptybuf
  00060	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN4@array_buff@2:

; 2425 :     view->len = (Py_SIZE(self)) * self->ob_descr->itemsize;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00068	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0006f	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  00073	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00078	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0007c	48 0f af c8	 imul	 rcx, rax
  00080	48 8b c1	 mov	 rax, rcx
  00083	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  00088	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 2426 :     view->readonly = 0;

  0008c	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00091	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 2427 :     view->ndim = 1;

  00098	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  0009d	c7 40 24 01 00
	00 00		 mov	 DWORD PTR [rax+36], 1

; 2428 :     view->itemsize = self->ob_descr->itemsize;

  000a4	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000a9	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000b0	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  000b4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  000b9	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 2429 :     view->suboffsets = NULL;

  000bd	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  000c2	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 2430 :     view->shape = NULL;

  000ca	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  000cf	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 2431 :     if ((flags & PyBUF_ND)==PyBUF_ND) {

  000d7	8b 44 24 40	 mov	 eax, DWORD PTR flags$[rsp]
  000db	83 e0 08	 and	 eax, 8
  000de	83 f8 08	 cmp	 eax, 8
  000e1	75 12		 jne	 SHORT $LN3@array_buff@2

; 2432 :         view->shape = &((Py_SIZE(self)));

  000e3	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000e8	48 83 c0 60	 add	 rax, 96			; 00000060H
  000ec	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  000f1	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN3@array_buff@2:

; 2433 :     }
; 2434 :     view->strides = NULL;

  000f5	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  000fa	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 2435 :     if ((flags & PyBUF_STRIDES)==PyBUF_STRIDES)

  00102	8b 44 24 40	 mov	 eax, DWORD PTR flags$[rsp]
  00106	83 e0 18	 and	 eax, 24
  00109	83 f8 18	 cmp	 eax, 24
  0010c	75 12		 jne	 SHORT $LN2@array_buff@2

; 2436 :         view->strides = &(view->itemsize);

  0010e	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00113	48 83 c0 18	 add	 rax, 24
  00117	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  0011c	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN2@array_buff@2:

; 2437 :     view->format = NULL;

  00120	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00125	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 2438 :     view->internal = NULL;

  0012d	48 8b 44 24 38	 mov	 rax, QWORD PTR view$[rsp]
  00132	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 2439 :     if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT) {

  0013a	8b 44 24 40	 mov	 eax, DWORD PTR flags$[rsp]
  0013e	83 e0 04	 and	 eax, 4
  00141	83 f8 04	 cmp	 eax, 4
  00144	75 19		 jne	 SHORT $LN1@array_buff@2

; 2440 :         view->format = self->ob_descr->formats;

  00146	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0014b	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00152	48 8b 4c 24 38	 mov	 rcx, QWORD PTR view$[rsp]
  00157	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0015b	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN1@array_buff@2:
$finish$22334:

; 2441 : #ifdef Py_UNICODE_WIDE
; 2442 :         if (self->ob_descr->typecode == 'u') {
; 2443 :             view->format = "w";
; 2444 :         }
; 2445 : #endif
; 2446 :     }
; 2447 : 
; 2448 :  finish:
; 2449 :     self->ob_exports++;

  0015f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00164	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0016a	ff c0		 inc	 eax
  0016c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00171	89 81 90 00 00
	00		 mov	 DWORD PTR [rcx+144], eax

; 2450 :     return 0;

  00177	33 c0		 xor	 eax, eax

; 2451 : }

  00179	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0017d	c3		 ret	 0
array_buffer_getbuf ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT array_buffer_relbuf
_TEXT	SEGMENT
self$ = 8
view$ = 16
array_buffer_relbuf PROC				; COMDAT

; 2455 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 2456 :     self->ob_exports--;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  0000f	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00015	ff c8		 dec	 eax
  00017	48 8b 4c 24 08	 mov	 rcx, QWORD PTR self$[rsp]
  0001c	89 81 90 00 00
	00		 mov	 DWORD PTR [rcx+144], eax

; 2457 : }

  00022	c3		 ret	 0
array_buffer_relbuf ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DP@FIAOOIAE@bad?5typecode?5?$CImust?5be?5b?0?5B?0?5u?0?5h@ ; `string'
PUBLIC	??_C@_1EG@PEMBEBFG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAA?$AAS?$AAC?$AAI?$AAI?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAw?$AAs@ ; `string'
PUBLIC	??_C@_1DC@HKMCIIOG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_09LFKFFFFJ@C?$HMO?3array?$AA@		; `string'
PUBLIC	??_C@_0O@BNFLHEON@array?4array?$CI?$CJ?$AA@	; `string'
EXTRN	PyMem_Realloc:PROC
EXTRN	PyUnicode_AsUnicode:PROC
EXTRN	PyTuple_Pack:PROC
EXTRN	PySequence_GetItem:PROC
EXTRN	PyByteArray_Type:BYTE
EXTRN	_PyArg_NoKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_new DD imagerel array_new
	DD	imagerel array_new+1930
	DD	imagerel $unwind$array_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_new DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_0DP@FIAOOIAE@bad?5typecode?5?$CImust?5be?5b?0?5B?0?5u?0?5h@
CONST	SEGMENT
??_C@_0DP@FIAOOIAE@bad?5typecode?5?$CImust?5be?5b?0?5B?0?5u?0?5h@ DB 'bad'
	DB	' typecode (must be b, B, u, h, H, i, I, l, L, q, Q, f or d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@PEMBEBFG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAA?$AAS?$AAC?$AAI?$AAI?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAw?$AAs@
CONST	SEGMENT
??_C@_1EG@PEMBEBFG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAA?$AAS?$AAC?$AAI?$AAI?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAw?$AAs@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'A', 00H, 'S', 00H, 'C', 00H
	DB	'I', 00H, 'I', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, ' ', 00H, '*', 00H, ')', 00H, '(', 00H, 'i', 00H
	DB	'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, ')'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'w', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@HKMCIIOG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@HKMCIIOG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 't', 00H
	DB	'i', 00H, 'a', 00H, 'l', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LFKFFFFJ@C?$HMO?3array?$AA@
CONST	SEGMENT
??_C@_09LFKFFFFJ@C?$HMO?3array?$AA@ DB 'C|O:array', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNFLHEON@array?4array?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@BNFLHEON@array?4array?$CI?$CJ?$AA@ DB 'array.array()', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT array_new
_TEXT	SEGMENT
it$ = 32
descr$ = 40
initial$ = 48
c$ = 56
a$22410 = 64
len$22411 = 72
i$22433 = 80
v$22437 = 88
v$22455 = 96
t_initial$22454 = 104
ustr$22471 = 112
n$22472 = 120
self$22495 = 128
item$22497 = 136
other$22514 = 144
self$22512 = 152
tv249 = 160
tv269 = 168
tv267 = 176
type$ = 208
args$ = 216
kwds$ = 224
array_new PROC						; COMDAT

; 2479 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 2480 :     int c;
; 2481 :     PyObject *initial = NULL, *it = NULL;

  00016	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR initial$[rsp], 0
  0001f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR it$[rsp], 0

; 2482 :     struct arraydescr *descr;
; 2483 : 
; 2484 :     if (type == &Arraytype && !_PyArg_NoKeywords("array.array()", kwds))

  00028	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  0002f	48 39 84 24 d0
	00 00 00	 cmp	 QWORD PTR type$[rsp], rax
  00037	75 1f		 jne	 SHORT $LN41@array_new
  00039	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@BNFLHEON@array?4array?$CI?$CJ?$AA@
  00048	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  0004d	85 c0		 test	 eax, eax
  0004f	75 07		 jne	 SHORT $LN41@array_new

; 2485 :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	e9 2a 07 00 00	 jmp	 $LN42@array_new
$LN41@array_new:

; 2486 : 
; 2487 :     if (!PyArg_ParseTuple(args, "C|O:array", &c, &initial))

  00058	4c 8d 4c 24 30	 lea	 r9, QWORD PTR initial$[rsp]
  0005d	4c 8d 44 24 38	 lea	 r8, QWORD PTR c$[rsp]
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LFKFFFFJ@C?$HMO?3array?$AA@
  00069	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00071	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00076	85 c0		 test	 eax, eax
  00078	75 07		 jne	 SHORT $LN40@array_new

; 2488 :         return NULL;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 01 07 00 00	 jmp	 $LN42@array_new
$LN40@array_new:

; 2489 : 
; 2490 :     if (!(initial == NULL || PyList_Check(initial)
; 2491 :           || PyByteArray_Check(initial)
; 2492 :           || PyBytes_Check(initial)
; 2493 :           || PyTuple_Check(initial)
; 2494 :           || ((c=='u') && PyUnicode_Check(initial))
; 2495 :           || (array_Check(initial)
; 2496 :               && c == ((arrayobject*)initial)->ob_descr->typecode))) {

  00081	48 83 7c 24 30
	00		 cmp	 QWORD PTR initial$[rsp], 0
  00087	0f 84 0d 01 00
	00		 je	 $LN39@array_new
  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  00092	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00096	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009c	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  000a1	85 c0		 test	 eax, eax
  000a3	0f 85 f1 00 00
	00		 jne	 $LN39@array_new
  000a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR initial$[rsp]
  000b5	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000b9	0f 84 db 00 00
	00		 je	 $LN39@array_new
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  000c6	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  000cb	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000cf	e8 00 00 00 00	 call	 PyType_IsSubtype
  000d4	85 c0		 test	 eax, eax
  000d6	0f 85 be 00 00
	00		 jne	 $LN39@array_new
  000dc	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  000e1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000e5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000eb	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000f0	85 c0		 test	 eax, eax
  000f2	0f 85 a2 00 00
	00		 jne	 $LN39@array_new
  000f8	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  000fd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00101	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00107	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0010c	85 c0		 test	 eax, eax
  0010e	0f 85 86 00 00
	00		 jne	 $LN39@array_new
  00114	83 7c 24 38 75	 cmp	 DWORD PTR c$[rsp], 117	; 00000075H
  00119	75 18		 jne	 SHORT $LN38@array_new
  0011b	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  00120	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00124	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0012a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0012f	85 c0		 test	 eax, eax
  00131	75 67		 jne	 SHORT $LN39@array_new
$LN38@array_new:
  00133	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  0013a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR initial$[rsp]
  0013f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00143	74 19		 je	 SHORT $LN36@array_new
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  0014c	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  00151	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00155	e8 00 00 00 00	 call	 PyType_IsSubtype
  0015a	85 c0		 test	 eax, eax
  0015c	74 15		 je	 SHORT $LN37@array_new
$LN36@array_new:
  0015e	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  00163	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0016a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0016d	39 44 24 38	 cmp	 DWORD PTR c$[rsp], eax
  00171	74 27		 je	 SHORT $LN39@array_new
$LN37@array_new:

; 2497 :         it = PyObject_GetIter(initial);

  00173	48 8b 4c 24 30	 mov	 rcx, QWORD PTR initial$[rsp]
  00178	e8 00 00 00 00	 call	 PyObject_GetIter
  0017d	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 2498 :         if (it == NULL)

  00182	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00188	75 07		 jne	 SHORT $LN35@array_new

; 2499 :             return NULL;

  0018a	33 c0		 xor	 eax, eax
  0018c	e9 f1 05 00 00	 jmp	 $LN42@array_new
$LN35@array_new:

; 2500 :         /* We set initial to NULL so that the subsequent code
; 2501 :            will create an empty array of the appropriate type
; 2502 :            and afterwards we can use array_iter_extend to populate
; 2503 :            the array.
; 2504 :         */
; 2505 :         initial = NULL;

  00191	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR initial$[rsp], 0
$LN39@array_new:

; 2506 :     }
; 2507 :     for (descr = descriptors; descr->typecode != '\0'; descr++) {

  0019a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:descriptors
  001a1	48 89 44 24 28	 mov	 QWORD PTR descr$[rsp], rax
  001a6	eb 0e		 jmp	 SHORT $LN34@array_new
$LN33@array_new:
  001a8	48 8b 44 24 28	 mov	 rax, QWORD PTR descr$[rsp]
  001ad	48 83 c0 28	 add	 rax, 40			; 00000028H
  001b1	48 89 44 24 28	 mov	 QWORD PTR descr$[rsp], rax
$LN34@array_new:
  001b6	48 8b 44 24 28	 mov	 rax, QWORD PTR descr$[rsp]
  001bb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001be	85 c0		 test	 eax, eax
  001c0	0f 84 a7 05 00
	00		 je	 $LN32@array_new

; 2508 :         if (descr->typecode == c) {

  001c6	48 8b 44 24 28	 mov	 rax, QWORD PTR descr$[rsp]
  001cb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001ce	3b 44 24 38	 cmp	 eax, DWORD PTR c$[rsp]
  001d2	0f 85 90 05 00
	00		 jne	 $LN31@array_new

; 2509 :             PyObject *a;
; 2510 :             Py_ssize_t len;
; 2511 : 
; 2512 :             if (initial == NULL)

  001d8	48 83 7c 24 30
	00		 cmp	 QWORD PTR initial$[rsp], 0
  001de	75 0e		 jne	 SHORT $LN30@array_new

; 2513 :                 len = 0;

  001e0	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR len$22411[rsp], 0
  001e9	e9 84 00 00 00	 jmp	 $LN29@array_new
$LN30@array_new:

; 2514 :             else if (PyList_Check(initial))

  001ee	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  001f3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001f7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001fd	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00202	85 c0		 test	 eax, eax
  00204	74 10		 je	 SHORT $LN28@array_new

; 2515 :                 len = PyList_GET_SIZE(initial);

  00206	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  0020b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0020f	48 89 44 24 48	 mov	 QWORD PTR len$22411[rsp], rax
  00214	eb 5c		 jmp	 SHORT $LN27@array_new
$LN28@array_new:

; 2516 :             else if (PyTuple_Check(initial) || array_Check(initial))

  00216	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  0021b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0021f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00225	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0022a	85 c0		 test	 eax, eax
  0022c	75 2b		 jne	 SHORT $LN25@array_new
  0022e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  00235	48 8b 4c 24 30	 mov	 rcx, QWORD PTR initial$[rsp]
  0023a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0023e	74 19		 je	 SHORT $LN24@array_new
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00247	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  0024c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00250	e8 00 00 00 00	 call	 PyType_IsSubtype
  00255	85 c0		 test	 eax, eax
  00257	74 10		 je	 SHORT $LN26@array_new
$LN24@array_new:
$LN25@array_new:

; 2517 :                 len = Py_SIZE(initial);

  00259	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  0025e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00262	48 89 44 24 48	 mov	 QWORD PTR len$22411[rsp], rax

; 2518 :             else

  00267	eb 09		 jmp	 SHORT $LN23@array_new
$LN26@array_new:

; 2519 :                 len = 0;

  00269	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR len$22411[rsp], 0
$LN23@array_new:
$LN27@array_new:
$LN29@array_new:

; 2520 : 
; 2521 :             a = newarrayobject(type, len, descr);

  00272	4c 8b 44 24 28	 mov	 r8, QWORD PTR descr$[rsp]
  00277	48 8b 54 24 48	 mov	 rdx, QWORD PTR len$22411[rsp]
  0027c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  00284	e8 00 00 00 00	 call	 newarrayobject
  00289	48 89 44 24 40	 mov	 QWORD PTR a$22410[rsp], rax

; 2522 :             if (a == NULL)

  0028e	48 83 7c 24 40
	00		 cmp	 QWORD PTR a$22410[rsp], 0
  00294	75 07		 jne	 SHORT $LN22@array_new

; 2523 :                 return NULL;

  00296	33 c0		 xor	 eax, eax
  00298	e9 e5 04 00 00	 jmp	 $LN42@array_new
$LN22@array_new:

; 2524 : 
; 2525 :             if (len > 0 && !array_Check(initial)) {

  0029d	48 83 7c 24 48
	00		 cmp	 QWORD PTR len$22411[rsp], 0
  002a3	0f 8e cb 00 00
	00		 jle	 $LN21@array_new
  002a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  002b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR initial$[rsp]
  002b5	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  002b9	0f 84 b5 00 00
	00		 je	 $LN21@array_new
  002bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  002c6	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  002cb	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  002cf	e8 00 00 00 00	 call	 PyType_IsSubtype
  002d4	85 c0		 test	 eax, eax
  002d6	0f 85 98 00 00
	00		 jne	 $LN21@array_new

; 2526 :                 Py_ssize_t i;
; 2527 :                 for (i = 0; i < len; i++) {

  002dc	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR i$22433[rsp], 0
  002e5	eb 0d		 jmp	 SHORT $LN20@array_new
$LN19@array_new:
  002e7	48 8b 44 24 50	 mov	 rax, QWORD PTR i$22433[rsp]
  002ec	48 ff c0	 inc	 rax
  002ef	48 89 44 24 50	 mov	 QWORD PTR i$22433[rsp], rax
$LN20@array_new:
  002f4	48 8b 44 24 48	 mov	 rax, QWORD PTR len$22411[rsp]
  002f9	48 39 44 24 50	 cmp	 QWORD PTR i$22433[rsp], rax
  002fe	7d 6f		 jge	 SHORT $LN18@array_new

; 2528 :                     PyObject *v =
; 2529 :                         PySequence_GetItem(initial, i);

  00300	48 8b 54 24 50	 mov	 rdx, QWORD PTR i$22433[rsp]
  00305	48 8b 4c 24 30	 mov	 rcx, QWORD PTR initial$[rsp]
  0030a	e8 00 00 00 00	 call	 PySequence_GetItem
  0030f	48 89 44 24 58	 mov	 QWORD PTR v$22437[rsp], rax

; 2530 :                     if (v == NULL) {

  00314	48 83 7c 24 58
	00		 cmp	 QWORD PTR v$22437[rsp], 0
  0031a	75 11		 jne	 SHORT $LN17@array_new

; 2531 :                         Py_DECREF(a);

  0031c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$22410[rsp]
  00321	e8 00 00 00 00	 call	 _Py_DecRef

; 2532 :                         return NULL;

  00326	33 c0		 xor	 eax, eax
  00328	e9 55 04 00 00	 jmp	 $LN42@array_new
$LN17@array_new:

; 2533 :                     }
; 2534 :                     if (setarrayitem(a, i, v) != 0) {

  0032d	4c 8b 44 24 58	 mov	 r8, QWORD PTR v$22437[rsp]
  00332	48 8b 54 24 50	 mov	 rdx, QWORD PTR i$22433[rsp]
  00337	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$22410[rsp]
  0033c	e8 00 00 00 00	 call	 setarrayitem
  00341	85 c0		 test	 eax, eax
  00343	74 1b		 je	 SHORT $LN16@array_new

; 2535 :                         Py_DECREF(v);

  00345	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$22437[rsp]
  0034a	e8 00 00 00 00	 call	 _Py_DecRef

; 2536 :                         Py_DECREF(a);

  0034f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$22410[rsp]
  00354	e8 00 00 00 00	 call	 _Py_DecRef

; 2537 :                         return NULL;

  00359	33 c0		 xor	 eax, eax
  0035b	e9 22 04 00 00	 jmp	 $LN42@array_new
$LN16@array_new:

; 2538 :                     }
; 2539 :                     Py_DECREF(v);

  00360	48 8b 4c 24 58	 mov	 rcx, QWORD PTR v$22437[rsp]
  00365	e8 00 00 00 00	 call	 _Py_DecRef

; 2540 :                 }

  0036a	e9 78 ff ff ff	 jmp	 $LN19@array_new
$LN18@array_new:

; 2541 :             }
; 2542 :             else if (initial != NULL && (PyByteArray_Check(initial) ||

  0036f	e9 af 03 00 00	 jmp	 $LN15@array_new
$LN21@array_new:

; 2543 :                                PyBytes_Check(initial))) {

  00374	48 83 7c 24 30
	00		 cmp	 QWORD PTR initial$[rsp], 0
  0037a	0f 84 b6 00 00
	00		 je	 $LN14@array_new
  00380	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyByteArray_Type
  00387	48 8b 4c 24 30	 mov	 rcx, QWORD PTR initial$[rsp]
  0038c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00390	74 31		 je	 SHORT $LN13@array_new
  00392	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyByteArray_Type
  00399	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  0039e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  003a2	e8 00 00 00 00	 call	 PyType_IsSubtype
  003a7	85 c0		 test	 eax, eax
  003a9	75 18		 jne	 SHORT $LN13@array_new
  003ab	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  003b0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003b4	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003ba	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  003bf	85 c0		 test	 eax, eax
  003c1	74 73		 je	 SHORT $LN14@array_new
$LN13@array_new:

; 2544 :                 PyObject *t_initial, *v;
; 2545 :                 t_initial = PyTuple_Pack(1, initial);

  003c3	48 8b 54 24 30	 mov	 rdx, QWORD PTR initial$[rsp]
  003c8	b9 01 00 00 00	 mov	 ecx, 1
  003cd	e8 00 00 00 00	 call	 PyTuple_Pack
  003d2	48 89 44 24 68	 mov	 QWORD PTR t_initial$22454[rsp], rax

; 2546 :                 if (t_initial == NULL) {

  003d7	48 83 7c 24 68
	00		 cmp	 QWORD PTR t_initial$22454[rsp], 0
  003dd	75 11		 jne	 SHORT $LN12@array_new

; 2547 :                     Py_DECREF(a);

  003df	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$22410[rsp]
  003e4	e8 00 00 00 00	 call	 _Py_DecRef

; 2548 :                     return NULL;

  003e9	33 c0		 xor	 eax, eax
  003eb	e9 92 03 00 00	 jmp	 $LN42@array_new
$LN12@array_new:

; 2549 :                 }
; 2550 :                 v = array_frombytes((arrayobject *)a,
; 2551 :                                          t_initial);

  003f0	48 8b 54 24 68	 mov	 rdx, QWORD PTR t_initial$22454[rsp]
  003f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$22410[rsp]
  003fa	e8 00 00 00 00	 call	 array_frombytes
  003ff	48 89 44 24 60	 mov	 QWORD PTR v$22455[rsp], rax

; 2552 :                 Py_DECREF(t_initial);

  00404	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t_initial$22454[rsp]
  00409	e8 00 00 00 00	 call	 _Py_DecRef

; 2553 :                 if (v == NULL) {

  0040e	48 83 7c 24 60
	00		 cmp	 QWORD PTR v$22455[rsp], 0
  00414	75 11		 jne	 SHORT $LN11@array_new

; 2554 :                     Py_DECREF(a);

  00416	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$22410[rsp]
  0041b	e8 00 00 00 00	 call	 _Py_DecRef

; 2555 :                     return NULL;

  00420	33 c0		 xor	 eax, eax
  00422	e9 5b 03 00 00	 jmp	 $LN42@array_new
$LN11@array_new:

; 2556 :                 }
; 2557 :                 Py_DECREF(v);

  00427	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$22455[rsp]
  0042c	e8 00 00 00 00	 call	 _Py_DecRef
  00431	e9 ed 02 00 00	 jmp	 $LN10@array_new
$LN14@array_new:

; 2558 :             }
; 2559 :             else if (initial != NULL && PyUnicode_Check(initial))  {

  00436	48 83 7c 24 30
	00		 cmp	 QWORD PTR initial$[rsp], 0
  0043c	0f 84 51 02 00
	00		 je	 $LN9@array_new
  00442	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  00447	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0044b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00451	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00456	85 c0		 test	 eax, eax
  00458	0f 84 35 02 00
	00		 je	 $LN9@array_new

; 2560 :                 Py_UNICODE *ustr;
; 2561 :                 Py_ssize_t n;
; 2562 : 
; 2563 :                 ustr = PyUnicode_AsUnicode(initial);

  0045e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR initial$[rsp]
  00463	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00468	48 89 44 24 70	 mov	 QWORD PTR ustr$22471[rsp], rax

; 2564 :                 if (ustr == NULL) {

  0046d	48 83 7c 24 70
	00		 cmp	 QWORD PTR ustr$22471[rsp], 0
  00473	75 16		 jne	 SHORT $LN8@array_new

; 2565 :                     PyErr_NoMemory();

  00475	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2566 :                     Py_DECREF(a);

  0047a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$22410[rsp]
  0047f	e8 00 00 00 00	 call	 _Py_DecRef

; 2567 :                     return NULL;

  00484	33 c0		 xor	 eax, eax
  00486	e9 f7 02 00 00	 jmp	 $LN42@array_new
$LN8@array_new:

; 2568 :                 }
; 2569 : 
; 2570 :                 n = PyUnicode_GET_DATA_SIZE(initial);

  0048b	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  00490	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00494	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0049a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0049f	85 c0		 test	 eax, eax
  004a1	75 1c		 jne	 SHORT $LN44@array_new
  004a3	41 b8 0a 0a 00
	00		 mov	 r8d, 2570		; 00000a0aH
  004a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  004b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@HKMCIIOG@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AA?$CJ?$AA?$AA@
  004b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004bd	33 c0		 xor	 eax, eax
$LN44@array_new:
  004bf	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  004c4	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  004c9	74 60		 je	 SHORT $LN50@array_new
  004cb	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  004d0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004d3	c1 e8 06	 shr	 eax, 6
  004d6	83 e0 01	 and	 eax, 1
  004d9	85 c0		 test	 eax, eax
  004db	74 25		 je	 SHORT $LN45@array_new
  004dd	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  004e2	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  004e5	c1 e8 05	 shr	 eax, 5
  004e8	83 e0 01	 and	 eax, 1
  004eb	85 c0		 test	 eax, eax
  004ed	74 13		 je	 SHORT $LN45@array_new
  004ef	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  004f4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  004f8	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
  00500	eb 14		 jmp	 SHORT $LN46@array_new
$LN45@array_new:
  00502	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  00507	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0050e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
$LN46@array_new:
  00516	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv249[rsp]
  0051e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv269[rsp], rax
  00526	e9 8d 00 00 00	 jmp	 $LN51@array_new
$LN50@array_new:
  0052b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR initial$[rsp]
  00530	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00535	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  0053a	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0053f	75 1c		 jne	 SHORT $LN47@array_new
  00541	41 b8 0a 0a 00
	00		 mov	 r8d, 2570		; 00000a0aH
  00547	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0054e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@PEMBEBFG@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAA?$AAS?$AAC?$AAI?$AAI?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAw?$AAs@
  00555	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0055b	33 c0		 xor	 eax, eax
$LN47@array_new:
  0055d	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  00562	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00565	c1 e8 06	 shr	 eax, 6
  00568	83 e0 01	 and	 eax, 1
  0056b	85 c0		 test	 eax, eax
  0056d	74 25		 je	 SHORT $LN48@array_new
  0056f	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  00574	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00577	c1 e8 05	 shr	 eax, 5
  0057a	83 e0 01	 and	 eax, 1
  0057d	85 c0		 test	 eax, eax
  0057f	74 13		 je	 SHORT $LN48@array_new
  00581	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  00586	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0058a	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv267[rsp], rax
  00592	eb 14		 jmp	 SHORT $LN49@array_new
$LN48@array_new:
  00594	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  00599	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  005a0	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv267[rsp], rax
$LN49@array_new:
  005a8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv267[rsp]
  005b0	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv269[rsp], rax
$LN51@array_new:
  005b8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv269[rsp]
  005c0	48 d1 e0	 shl	 rax, 1
  005c3	48 89 44 24 78	 mov	 QWORD PTR n$22472[rsp], rax

; 2571 :                 if (n > 0) {

  005c8	48 83 7c 24 78
	00		 cmp	 QWORD PTR n$22472[rsp], 0
  005ce	0f 8e ba 00 00
	00		 jle	 $LN7@array_new

; 2572 :                     arrayobject *self = (arrayobject *)a;

  005d4	48 8b 44 24 40	 mov	 rax, QWORD PTR a$22410[rsp]
  005d9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR self$22495[rsp], rax

; 2573 :                     char *item = self->ob_item;

  005e1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$22495[rsp]
  005e9	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  005ed	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR item$22497[rsp], rax

; 2574 :                     item = (char *)PyMem_Realloc(item, n);

  005f5	48 8b 54 24 78	 mov	 rdx, QWORD PTR n$22472[rsp]
  005fa	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR item$22497[rsp]
  00602	e8 00 00 00 00	 call	 PyMem_Realloc
  00607	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR item$22497[rsp], rax

; 2575 :                     if (item == NULL) {

  0060f	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR item$22497[rsp], 0
  00618	75 16		 jne	 SHORT $LN6@array_new

; 2576 :                         PyErr_NoMemory();

  0061a	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2577 :                         Py_DECREF(a);

  0061f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$22410[rsp]
  00624	e8 00 00 00 00	 call	 _Py_DecRef

; 2578 :                         return NULL;

  00629	33 c0		 xor	 eax, eax
  0062b	e9 52 01 00 00	 jmp	 $LN42@array_new
$LN6@array_new:

; 2579 :                     }
; 2580 :                     self->ob_item = item;

  00630	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$22495[rsp]
  00638	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR item$22497[rsp]
  00640	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2581 :                     Py_SIZE(self) = n / sizeof(Py_UNICODE);

  00644	33 d2		 xor	 edx, edx
  00646	48 8b 44 24 78	 mov	 rax, QWORD PTR n$22472[rsp]
  0064b	b9 02 00 00 00	 mov	 ecx, 2
  00650	48 f7 f1	 div	 rcx
  00653	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$22495[rsp]
  0065b	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 2582 :                     memcpy(item, ustr, n);

  0065f	4c 8b 44 24 78	 mov	 r8, QWORD PTR n$22472[rsp]
  00664	48 8b 54 24 70	 mov	 rdx, QWORD PTR ustr$22471[rsp]
  00669	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR item$22497[rsp]
  00671	e8 00 00 00 00	 call	 memcpy

; 2583 :                     self->allocated = Py_SIZE(self);

  00676	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$22495[rsp]
  0067e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$22495[rsp]
  00686	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0068a	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx
$LN7@array_new:

; 2584 :                 }

  0068e	e9 90 00 00 00	 jmp	 $LN5@array_new
$LN9@array_new:

; 2585 :             }
; 2586 :             else if (initial != NULL && array_Check(initial)) {

  00693	48 83 7c 24 30
	00		 cmp	 QWORD PTR initial$[rsp], 0
  00699	0f 84 84 00 00
	00		 je	 $LN4@array_new
  0069f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  006a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR initial$[rsp]
  006ab	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  006af	74 19		 je	 SHORT $LN3@array_new
  006b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  006b8	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  006bd	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  006c1	e8 00 00 00 00	 call	 PyType_IsSubtype
  006c6	85 c0		 test	 eax, eax
  006c8	74 59		 je	 SHORT $LN4@array_new
$LN3@array_new:

; 2587 :                 arrayobject *self = (arrayobject *)a;

  006ca	48 8b 44 24 40	 mov	 rax, QWORD PTR a$22410[rsp]
  006cf	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR self$22512[rsp], rax

; 2588 :                 arrayobject *other = (arrayobject *)initial;

  006d7	48 8b 44 24 30	 mov	 rax, QWORD PTR initial$[rsp]
  006dc	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR other$22514[rsp], rax

; 2589 :                 memcpy(self->ob_item, other->ob_item, len * other->ob_descr->itemsize);

  006e4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR other$22514[rsp]
  006ec	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  006f3	48 63 40 04	 movsxd	 rax, DWORD PTR [rax+4]
  006f7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR len$22411[rsp]
  006fc	48 0f af c8	 imul	 rcx, rax
  00700	48 8b c1	 mov	 rax, rcx
  00703	4c 8b c0	 mov	 r8, rax
  00706	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR other$22514[rsp]
  0070e	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00712	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR self$22512[rsp]
  0071a	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0071e	e8 00 00 00 00	 call	 memcpy
$LN4@array_new:
$LN5@array_new:
$LN10@array_new:
$LN15@array_new:

; 2590 :             }
; 2591 :             if (it != NULL) {

  00723	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00729	74 36		 je	 SHORT $LN2@array_new

; 2592 :                 if (array_iter_extend((arrayobject *)a, it) == -1) {

  0072b	48 8b 54 24 20	 mov	 rdx, QWORD PTR it$[rsp]
  00730	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$22410[rsp]
  00735	e8 00 00 00 00	 call	 array_iter_extend
  0073a	83 f8 ff	 cmp	 eax, -1
  0073d	75 18		 jne	 SHORT $LN1@array_new

; 2593 :                     Py_DECREF(it);

  0073f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00744	e8 00 00 00 00	 call	 _Py_DecRef

; 2594 :                     Py_DECREF(a);

  00749	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$22410[rsp]
  0074e	e8 00 00 00 00	 call	 _Py_DecRef

; 2595 :                     return NULL;

  00753	33 c0		 xor	 eax, eax
  00755	eb 2b		 jmp	 SHORT $LN42@array_new
$LN1@array_new:

; 2596 :                 }
; 2597 :                 Py_DECREF(it);

  00757	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0075c	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@array_new:

; 2598 :             }
; 2599 :             return a;

  00761	48 8b 44 24 40	 mov	 rax, QWORD PTR a$22410[rsp]
  00766	eb 1a		 jmp	 SHORT $LN42@array_new
$LN31@array_new:

; 2600 :         }
; 2601 :     }

  00768	e9 3b fa ff ff	 jmp	 $LN33@array_new
$LN32@array_new:

; 2602 :     PyErr_SetString(PyExc_ValueError,
; 2603 : #ifdef HAVE_LONG_LONG
; 2604 :         "bad typecode (must be b, B, u, h, H, i, I, l, L, q, Q, f or d)");

  0076d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DP@FIAOOIAE@bad?5typecode?5?$CImust?5be?5b?0?5B?0?5u?0?5h@
  00774	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0077b	e8 00 00 00 00	 call	 PyErr_SetString

; 2605 : #else
; 2606 :         "bad typecode (must be b, B, u, h, H, i, I, l, L, f or d)");
; 2607 : #endif
; 2608 :     return NULL;

  00780	33 c0		 xor	 eax, eax
$LN42@array_new:

; 2609 : }

  00782	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00789	c3		 ret	 0
array_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BO@GIEPFNKG@?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$setarrayitem DD imagerel setarrayitem
	DD	imagerel setarrayitem+115
	DD	imagerel $unwind$setarrayitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setarrayitem DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_1BO@GIEPFNKG@?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@GIEPFNKG@?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@ DB 'a'
	DB	00H, 'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 'C', 00H
	DB	'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'a', 00H, ')'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT setarrayitem
_TEXT	SEGMENT
a$ = 48
i$ = 56
v$ = 64
setarrayitem PROC					; COMDAT

; 851  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 852  :     assert(array_Check(a));

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  0001f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00023	74 35		 je	 SHORT $LN3@setarrayit
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00031	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00035	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003a	85 c0		 test	 eax, eax
  0003c	75 1c		 jne	 SHORT $LN3@setarrayit
  0003e	41 b8 54 03 00
	00		 mov	 r8d, 852		; 00000354H
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@GIEPFNKG@?$AAa?$AAr?$AAr?$AAa?$AAy?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AA?$CJ?$AA?$AA@
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00058	33 c0		 xor	 eax, eax
$LN3@setarrayit:

; 853  :     return array_ass_item((arrayobject *)a, i, v);

  0005a	4c 8b 44 24 40	 mov	 r8, QWORD PTR v$[rsp]
  0005f	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  00064	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00069	e8 00 00 00 00	 call	 array_ass_item

; 854  : }

  0006e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00072	c3		 ret	 0
setarrayitem ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_Track:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$array_iter DD imagerel array_iter
	DD	imagerel array_iter+225
	DD	imagerel $unwind$array_iter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$array_iter DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT array_iter
_TEXT	SEGMENT
it$ = 32
tv79 = 40
ao$ = 64
array_iter PROC						; COMDAT

; 2742 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2743 :     arrayiterobject *it;
; 2744 : 
; 2745 :     if (!array_Check(ao)) {

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Arraytype
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ao$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 31		 je	 SHORT $LN2@array_iter@2
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Arraytype
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR ao$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 18		 jne	 SHORT $LN2@array_iter@2

; 2746 :         PyErr_BadInternalCall();

  00034	ba ba 0a 00 00	 mov	 edx, 2746		; 00000abaH
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@
  00040	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 2747 :         return NULL;

  00045	33 c0		 xor	 eax, eax
  00047	e9 90 00 00 00	 jmp	 $LN3@array_iter@2
$LN2@array_iter@2:

; 2748 :     }
; 2749 : 
; 2750 :     it = PyObject_GC_New(arrayiterobject, &PyArrayIter_Type);

  0004c	e8 00 00 00 00	 call	 _Py_PXCTX
  00051	85 c0		 test	 eax, eax
  00053	74 13		 je	 SHORT $LN5@array_iter@2
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyArrayIter_Type
  0005c	e8 00 00 00 00	 call	 _PxObject_New
  00061	48 89 44 24 28	 mov	 QWORD PTR tv79[rsp], rax
  00066	eb 11		 jmp	 SHORT $LN6@array_iter@2
$LN5@array_iter@2:
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyArrayIter_Type
  0006f	e8 00 00 00 00	 call	 _PyObject_GC_New
  00074	48 89 44 24 28	 mov	 QWORD PTR tv79[rsp], rax
$LN6@array_iter@2:
  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR tv79[rsp]
  0007e	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 2751 :     if (it == NULL)

  00083	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00089	75 04		 jne	 SHORT $LN1@array_iter@2

; 2752 :         return NULL;

  0008b	33 c0		 xor	 eax, eax
  0008d	eb 4d		 jmp	 SHORT $LN3@array_iter@2
$LN1@array_iter@2:

; 2753 : 
; 2754 :     Py_INCREF(ao);

  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ao$[rsp]
  00094	e8 00 00 00 00	 call	 _Py_IncRef

; 2755 :     it->ao = ao;

  00099	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
  0009e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ao$[rsp]
  000a3	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 2756 :     it->index = 0;

  000a7	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
  000ac	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 2757 :     it->getitem = ao->ob_descr->getitem;

  000b4	48 8b 44 24 40	 mov	 rax, QWORD PTR ao$[rsp]
  000b9	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000c0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000c5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c9	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 2758 :     PyObject_GC_Track(it);

  000cd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000d2	e8 00 00 00 00	 call	 PyObject_GC_Track

; 2759 :     return (PyObject *)it;

  000d7	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
$LN3@array_iter@2:

; 2760 : }

  000dc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e0	c3		 ret	 0
array_iter ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@JMDFIOBD@?$AAP?$AAy?$AAA?$AAr?$AAr?$AAa?$AAy?$AAI?$AAt?$AAe?$AAr?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$arrayiter_next DD imagerel arrayiter_next
	DD	imagerel arrayiter_next+170
	DD	imagerel $unwind$arrayiter_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$arrayiter_next DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1CM@JMDFIOBD@?$AAP?$AAy?$AAA?$AAr?$AAr?$AAa?$AAy?$AAI?$AAt?$AAe?$AAr?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@JMDFIOBD@?$AAP?$AAy?$AAA?$AAr?$AAr?$AAa?$AAy?$AAI?$AAt?$AAe?$AAr?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'A', 00H, 'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H
	DB	'I', 00H, 't', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'C', 00H, 'h'
	DB	00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'i', 00H, 't', 00H
	DB	')', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT arrayiter_next
_TEXT	SEGMENT
tv85 = 32
it$ = 64
arrayiter_next PROC					; COMDAT

; 2764 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2765 :     assert(PyArrayIter_Check(it));

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyArrayIter_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 35		 je	 SHORT $LN4@arrayiter_
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyArrayIter_Type
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	75 1c		 jne	 SHORT $LN4@arrayiter_
  00034	41 b8 cd 0a 00
	00		 mov	 r8d, 2765		; 00000acdH
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@MOEMMJHJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAa?$AAr?$AAr?$AAa?$AAy?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@JMDFIOBD@?$AAP?$AAy?$AAA?$AAr?$AAr?$AAa?$AAy?$AAI?$AAt?$AAe?$AAr?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAt?$AA?$CJ?$AA?$AA@
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004e	33 c0		 xor	 eax, eax
$LN4@arrayiter_:

; 2766 :     if (it->index < Py_SIZE(it->ao))

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00055	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  0005e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00062	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00066	7d 3b		 jge	 SHORT $LN1@arrayiter_

; 2767 :         return (*it->getitem)(it->ao, it->index++);

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0006d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00071	48 89 44 24 20	 mov	 QWORD PTR tv85[rsp], rax
  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0007b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0007f	48 ff c0	 inc	 rax
  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  00087	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  0008b	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv85[rsp]
  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00095	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0009e	ff 50 70	 call	 QWORD PTR [rax+112]
  000a1	eb 02		 jmp	 SHORT $LN2@arrayiter_
$LN1@arrayiter_:

; 2768 :     return NULL;

  000a3	33 c0		 xor	 eax, eax
$LN2@arrayiter_:

; 2769 : }

  000a5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a9	c3		 ret	 0
arrayiter_next ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyObject_GC_UnTrack:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$arrayiter_dealloc DD imagerel arrayiter_dealloc
	DD	imagerel arrayiter_dealloc+66
	DD	imagerel $unwind$arrayiter_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$arrayiter_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT arrayiter_dealloc
_TEXT	SEGMENT
it$ = 48
arrayiter_dealloc PROC					; COMDAT

; 2773 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2774 :     PyObject_GC_UnTrack(it);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN4@arrayiter_@2:

; 2775 :     Py_XDECREF(it->ao);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  00018	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0001d	74 0e		 je	 SHORT $LN1@arrayiter_@2
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR it$[rsp]
  00024	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@arrayiter_@2:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN4@arrayiter_@2

; 2776 :     PyObject_GC_Del(it);

  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  00038	e8 00 00 00 00	 call	 PyObject_GC_Del

; 2777 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
arrayiter_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@GJJFGDLC@arrayiter_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$arrayiter_traverse DD imagerel arrayiter_traverse
	DD	imagerel arrayiter_traverse+116
	DD	imagerel $unwind$arrayiter_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$arrayiter_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BD@GJJFGDLC@arrayiter_traverse?$AA@
CONST	SEGMENT
??_C@_0BD@GJJFGDLC@arrayiter_traverse?$AA@ DB 'arrayiter_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT arrayiter_traverse
_TEXT	SEGMENT
vret$22611 = 32
it$ = 64
visit$ = 72
arg$ = 80
arrayiter_traverse PROC					; COMDAT

; 2781 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@arrayiter_@3:

; 2782 :     Py_VISIT(it->ao);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@arrayiter_@3
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 de 0a 00
	00		 mov	 r8d, 2782		; 00000adeH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@DMBOHOAP@?4?4?2Modules?2arraymodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@GJJFGDLC@arrayiter_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@arrayiter_@3:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0003d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00042	74 23		 je	 SHORT $LN2@arrayiter_@3
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  0004e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$22611[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$22611[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@arrayiter_@3
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$22611[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@arrayiter_@3
$LN1@arrayiter_@3:
$LN2@arrayiter_@3:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@arrayiter_@3

; 2783 :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@arrayiter_@3:

; 2784 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
arrayiter_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@		; `string'
PUBLIC	??_C@_04BKLHDIKK@iter?$AA@			; `string'
EXTRN	_PyObject_GetBuiltin:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$arrayiter_reduce DD imagerel arrayiter_reduce
	DD	imagerel arrayiter_reduce+59
	DD	imagerel $unwind$arrayiter_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$arrayiter_reduce DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
CONST	SEGMENT
??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@ DB 'N(O)n', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKLHDIKK@iter?$AA@
CONST	SEGMENT
??_C@_04BKLHDIKK@iter?$AA@ DB 'iter', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT arrayiter_reduce
_TEXT	SEGMENT
it$ = 48
arrayiter_reduce PROC					; COMDAT

; 2788 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2789 :     return Py_BuildValue("N(O)n", _PyObject_GetBuiltin("iter"),
; 2790 :                          it->ao, it->index);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04BKLHDIKK@iter?$AA@
  00010	e8 00 00 00 00	 call	 _PyObject_GetBuiltin
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  0001a	4c 8b 49 60	 mov	 r9, QWORD PTR [rcx+96]
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  00023	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  00027	48 8b d0	 mov	 rdx, rax
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IFELCCKI@N?$CIO?$CJn?$AA@
  00031	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 2791 : }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
arrayiter_reduce ENDP
_TEXT	ENDS
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$arrayiter_setstate DD imagerel arrayiter_setstate
	DD	imagerel arrayiter_setstate+106
	DD	imagerel $unwind$arrayiter_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$arrayiter_setstate DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT arrayiter_setstate
_TEXT	SEGMENT
index$ = 32
it$ = 64
state$ = 72
arrayiter_setstate PROC					; COMDAT

; 2795 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2796 :     Py_ssize_t index = PyLong_AsSsize_t(state);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00013	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00018	48 89 44 24 20	 mov	 QWORD PTR index$[rsp], rax

; 2797 :     if (index == -1 && PyErr_Occurred())

  0001d	48 83 7c 24 20
	ff		 cmp	 QWORD PTR index$[rsp], -1
  00023	75 0e		 jne	 SHORT $LN2@arrayiter_@4
  00025	e8 00 00 00 00	 call	 PyErr_Occurred
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 04		 je	 SHORT $LN2@arrayiter_@4

; 2798 :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 32		 jmp	 SHORT $LN3@arrayiter_@4
$LN2@arrayiter_@4:

; 2799 :     if (index < 0)

  00033	48 83 7c 24 20
	00		 cmp	 QWORD PTR index$[rsp], 0
  00039	7d 09		 jge	 SHORT $LN1@arrayiter_@4

; 2800 :         index = 0;

  0003b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR index$[rsp], 0
$LN1@arrayiter_@4:

; 2801 :     it->index = index;

  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR it$[rsp]
  00049	48 8b 4c 24 20	 mov	 rcx, QWORD PTR index$[rsp]
  0004e	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 2802 :     Py_RETURN_NONE;

  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00059	e8 00 00 00 00	 call	 _Py_IncRef
  0005e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@arrayiter_@4:

; 2803 : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
arrayiter_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_09KBEBOLPF@typecodes?$AA@			; `string'
PUBLIC	??_C@_09MLBOOMFO@ArrayType?$AA@			; `string'
PUBLIC	PyInit_array
EXTRN	PyUnicode_DecodeASCII:PROC
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
EXTRN	PyType_Type:BYTE
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_array DD imagerel $LN12
	DD	imagerel $LN12+392
	DD	imagerel $unwind$PyInit_array
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_array DD 010401H
	DD	0c204H
xdata	ENDS
;	COMDAT ??_C@_09KBEBOLPF@typecodes?$AA@
CONST	SEGMENT
??_C@_09KBEBOLPF@typecodes?$AA@ DB 'typecodes', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09MLBOOMFO@ArrayType?$AA@
CONST	SEGMENT
??_C@_09MLBOOMFO@ArrayType?$AA@ DB 'ArrayType', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit_array
_TEXT	SEGMENT
p$ = 32
typecodes$ = 40
descr$ = 48
size$ = 56
buffer$ = 64
m$ = 80
PyInit_array PROC					; COMDAT

; 2871 : {

$LN12:
  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2872 :     PyObject *m;
; 2873 :     char buffer[Py_ARRAY_LENGTH(descriptors)], *p;
; 2874 :     PyObject *typecodes;
; 2875 :     Py_ssize_t size = 0;

  00004	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR size$[rsp], 0

; 2876 :     struct arraydescr *descr;
; 2877 : 
; 2878 :     if (PyType_Ready(&Arraytype) < 0)

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  00014	e8 00 00 00 00	 call	 PyType_Ready
  00019	85 c0		 test	 eax, eax
  0001b	7d 07		 jge	 SHORT $LN9@PyInit_arr

; 2879 :         return NULL;

  0001d	33 c0		 xor	 eax, eax
  0001f	e9 5f 01 00 00	 jmp	 $LN10@PyInit_arr
$LN9@PyInit_arr:

; 2880 :     Py_TYPE(&PyArrayIter_Type) = &PyType_Type;

  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type
  0002b	48 89 05 58 00
	00 00		 mov	 QWORD PTR PyArrayIter_Type+88, rax

; 2881 :     m = PyModule_Create(&arraymodule);

  00032	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:arraymodule
  0003e	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00043	48 89 44 24 50	 mov	 QWORD PTR m$[rsp], rax

; 2882 :     if (m == NULL)

  00048	48 83 7c 24 50
	00		 cmp	 QWORD PTR m$[rsp], 0
  0004e	75 07		 jne	 SHORT $LN8@PyInit_arr

; 2883 :         return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	e9 2c 01 00 00	 jmp	 $LN10@PyInit_arr
$LN8@PyInit_arr:

; 2884 : 
; 2885 :     Py_INCREF((PyObject *)&Arraytype);

  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  0005e	e8 00 00 00 00	 call	 _Py_IncRef

; 2886 :     PyModule_AddObject(m, "ArrayType", (PyObject *)&Arraytype);

  00063	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Arraytype
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09MLBOOMFO@ArrayType?$AA@
  00071	48 8b 4c 24 50	 mov	 rcx, QWORD PTR m$[rsp]
  00076	e8 00 00 00 00	 call	 PyModule_AddObject

; 2887 :     Py_INCREF((PyObject *)&Arraytype);

  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Arraytype
  00082	e8 00 00 00 00	 call	 _Py_IncRef

; 2888 :     PyModule_AddObject(m, "array", (PyObject *)&Arraytype);

  00087	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:Arraytype
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05HIFJDKLD@array?$AA@
  00095	48 8b 4c 24 50	 mov	 rcx, QWORD PTR m$[rsp]
  0009a	e8 00 00 00 00	 call	 PyModule_AddObject

; 2889 : 
; 2890 :     for (descr=descriptors; descr->typecode != '\0'; descr++) {

  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:descriptors
  000a6	48 89 44 24 30	 mov	 QWORD PTR descr$[rsp], rax
  000ab	eb 0e		 jmp	 SHORT $LN7@PyInit_arr
$LN6@PyInit_arr:
  000ad	48 8b 44 24 30	 mov	 rax, QWORD PTR descr$[rsp]
  000b2	48 83 c0 28	 add	 rax, 40			; 00000028H
  000b6	48 89 44 24 30	 mov	 QWORD PTR descr$[rsp], rax
$LN7@PyInit_arr:
  000bb	48 8b 44 24 30	 mov	 rax, QWORD PTR descr$[rsp]
  000c0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c3	85 c0		 test	 eax, eax
  000c5	74 0f		 je	 SHORT $LN5@PyInit_arr

; 2891 :         size++;

  000c7	48 8b 44 24 38	 mov	 rax, QWORD PTR size$[rsp]
  000cc	48 ff c0	 inc	 rax
  000cf	48 89 44 24 38	 mov	 QWORD PTR size$[rsp], rax

; 2892 :     }

  000d4	eb d7		 jmp	 SHORT $LN6@PyInit_arr
$LN5@PyInit_arr:

; 2893 : 
; 2894 :     p = buffer;

  000d6	48 8d 44 24 40	 lea	 rax, QWORD PTR buffer$[rsp]
  000db	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 2895 :     for (descr = descriptors; descr->typecode != '\0'; descr++) {

  000e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:descriptors
  000e7	48 89 44 24 30	 mov	 QWORD PTR descr$[rsp], rax
  000ec	eb 0e		 jmp	 SHORT $LN4@PyInit_arr
$LN3@PyInit_arr:
  000ee	48 8b 44 24 30	 mov	 rax, QWORD PTR descr$[rsp]
  000f3	48 83 c0 28	 add	 rax, 40			; 00000028H
  000f7	48 89 44 24 30	 mov	 QWORD PTR descr$[rsp], rax
$LN4@PyInit_arr:
  000fc	48 8b 44 24 30	 mov	 rax, QWORD PTR descr$[rsp]
  00101	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00104	85 c0		 test	 eax, eax
  00106	74 1e		 je	 SHORT $LN2@PyInit_arr

; 2896 :         *p++ = (char)descr->typecode;

  00108	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0010d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR descr$[rsp]
  00112	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00115	88 08		 mov	 BYTE PTR [rax], cl
  00117	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0011c	48 ff c0	 inc	 rax
  0011f	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 2897 :     }

  00124	eb c8		 jmp	 SHORT $LN3@PyInit_arr
$LN2@PyInit_arr:

; 2898 :     typecodes = PyUnicode_DecodeASCII(buffer, p - buffer, NULL);

  00126	48 8d 44 24 40	 lea	 rax, QWORD PTR buffer$[rsp]
  0012b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00130	48 2b c8	 sub	 rcx, rax
  00133	48 8b c1	 mov	 rax, rcx
  00136	45 33 c0	 xor	 r8d, r8d
  00139	48 8b d0	 mov	 rdx, rax
  0013c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  00141	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  00146	48 89 44 24 28	 mov	 QWORD PTR typecodes$[rsp], rax

; 2899 : 
; 2900 :     PyModule_AddObject(m, "typecodes", typecodes);

  0014b	4c 8b 44 24 28	 mov	 r8, QWORD PTR typecodes$[rsp]
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09KBEBOLPF@typecodes?$AA@
  00157	48 8b 4c 24 50	 mov	 rcx, QWORD PTR m$[rsp]
  0015c	e8 00 00 00 00	 call	 PyModule_AddObject

; 2901 : 
; 2902 :     if (PyErr_Occurred()) {

  00161	e8 00 00 00 00	 call	 PyErr_Occurred
  00166	48 85 c0	 test	 rax, rax
  00169	74 13		 je	 SHORT $LN1@PyInit_arr

; 2903 :         Py_DECREF(m);

  0016b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR m$[rsp]
  00170	e8 00 00 00 00	 call	 _Py_DecRef

; 2904 :         m = NULL;

  00175	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR m$[rsp], 0
$LN1@PyInit_arr:

; 2905 :     }
; 2906 :     return m;

  0017e	48 8b 44 24 50	 mov	 rax, QWORD PTR m$[rsp]
$LN10@PyInit_arr:

; 2907 : }

  00183	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00187	c3		 ret	 0
PyInit_array ENDP
_TEXT	ENDS
END
