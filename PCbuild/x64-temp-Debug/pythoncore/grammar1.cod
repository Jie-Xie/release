; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_1CE@EFGDPCNF@?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@EALAHPJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAg?$AAr?$AAa?$AAm?$AAm?$AAa?$AAr?$AA1?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	PyGrammar_FindDFA
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
; File c:\src\pyparallel\parser\grammar1.c
pdata	SEGMENT
$pdata$PyGrammar_FindDFA DD imagerel $LN4
	DD	imagerel $LN4+93
	DD	imagerel $unwind$PyGrammar_FindDFA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyGrammar_FindDFA DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT ??_C@_1CE@EFGDPCNF@?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@EFGDPCNF@?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?$AA@ DB 'd'
	DB	00H, '-', 00H, '>', 00H, 'd', 00H, '_', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@EALAHPJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAg?$AAr?$AAa?$AAm?$AAm?$AAa?$AAr?$AA1?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@EALAHPJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAg?$AAr?$AAa?$AAm?$AAm?$AAa?$AAr?$AA1?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'a', 00H, 'r', 00H, 's', 00H
	DB	'e', 00H, 'r', 00H, '\', 00H, 'g', 00H, 'r', 00H, 'a', 00H, 'm'
	DB	00H, 'm', 00H, 'a', 00H, 'r', 00H, '1', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyGrammar_FindDFA
_TEXT	SEGMENT
d$ = 32
g$ = 64
type$ = 72
PyGrammar_FindDFA PROC					; COMDAT

; 13   : {

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 14   :     register dfa *d;
; 15   : #if 1
; 16   :     /* Massive speed-up */
; 17   :     d = &g->g_dfa[type - NT_OFFSET];

  0000d	8b 44 24 48	 mov	 eax, DWORD PTR type$[rsp]
  00011	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  00016	48 98		 cdqe
  00018	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$[rsp]
  00021	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00025	48 89 44 24 20	 mov	 QWORD PTR d$[rsp], rax

; 18   :     assert(d->d_type == type);

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR d$[rsp]
  0002f	8b 4c 24 48	 mov	 ecx, DWORD PTR type$[rsp]
  00033	39 08		 cmp	 DWORD PTR [rax], ecx
  00035	74 1c		 je	 SHORT $LN3@PyGrammar_
  00037	41 b8 12 00 00
	00		 mov	 r8d, 18
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@EALAHPJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAg?$AAr?$AAa?$AAm?$AAm?$AAa?$AAr?$AA1?$AA?4?$AAc?$AA?$AA@
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@EFGDPCNF@?$AAd?$AA?9?$AA?$DO?$AAd?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?$AA@
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00051	33 c0		 xor	 eax, eax
$LN3@PyGrammar_:

; 19   :     return d;

  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR d$[rsp]

; 20   : #else
; 21   :     /* Old, slow version */
; 22   :     register int i;
; 23   : 
; 24   :     for (i = g->g_ndfas, d = g->g_dfa; --i >= 0; d++) {
; 25   :         if (d->d_type == type)
; 26   :             return d;
; 27   :     }
; 28   :     assert(0);
; 29   :     /* NOTREACHED */
; 30   : #endif
; 31   : }

  00058	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005c	c3		 ret	 0
PyGrammar_FindDFA ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@MPOPIKLL@invalid?5label?$AA@		; `string'
PUBLIC	??_C@_0N@JPJIHJHF@?$CF?432s?$CI?$CF?432s?$CJ?$AA@ ; `string'
PUBLIC	??_C@_04KFGGFMJH@NT?$CFd?$AA@			; `string'
PUBLIC	??_C@_05HKAKDGKI@EMPTY?$AA@			; `string'
PUBLIC	PyGrammar_LabelRepr
EXTRN	Py_FatalError:PROC
EXTRN	_PyParser_TokenNames:BYTE
EXTRN	PyOS_snprintf:PROC
_BSS	SEGMENT
?buf@?1??PyGrammar_LabelRepr@@9@9 DB 064H DUP (?)	; `PyGrammar_LabelRepr'::`2'::buf
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyGrammar_LabelRepr DD imagerel $LN13
	DD	imagerel $LN13+255
	DD	imagerel $unwind$PyGrammar_LabelRepr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyGrammar_LabelRepr DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0O@MPOPIKLL@invalid?5label?$AA@
CONST	SEGMENT
??_C@_0O@MPOPIKLL@invalid?5label?$AA@ DB 'invalid label', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JPJIHJHF@?$CF?432s?$CI?$CF?432s?$CJ?$AA@
CONST	SEGMENT
??_C@_0N@JPJIHJHF@?$CF?432s?$CI?$CF?432s?$CJ?$AA@ DB '%.32s(%.32s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04KFGGFMJH@NT?$CFd?$AA@
CONST	SEGMENT
??_C@_04KFGGFMJH@NT?$CFd?$AA@ DB 'NT%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKAKDGKI@EMPTY?$AA@
CONST	SEGMENT
??_C@_05HKAKDGKI@EMPTY?$AA@ DB 'EMPTY', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyGrammar_LabelRepr
_TEXT	SEGMENT
lb$ = 64
PyGrammar_LabelRepr PROC				; COMDAT

; 35   : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 36   :     static char buf[100];
; 37   : 
; 38   :     if (lb->lb_type == ENDMARKER)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR lb$[rsp]
  0000e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00011	75 11		 jne	 SHORT $LN10@PyGrammar_@2

; 39   :         return "EMPTY";

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05HKAKDGKI@EMPTY?$AA@
  0001a	e9 db 00 00 00	 jmp	 $LN11@PyGrammar_@2
  0001f	e9 d6 00 00 00	 jmp	 $LN9@PyGrammar_@2
$LN10@PyGrammar_@2:

; 40   :     else if (ISNONTERMINAL(lb->lb_type)) {

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR lb$[rsp]
  00029	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  0002f	7c 4a		 jl	 SHORT $LN8@PyGrammar_@2

; 41   :         if (lb->lb_str == NULL) {

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR lb$[rsp]
  00036	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003b	75 2e		 jne	 SHORT $LN7@PyGrammar_@2

; 42   :             PyOS_snprintf(buf, sizeof(buf), "NT%d", lb->lb_type);

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR lb$[rsp]
  00042	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  00045	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04KFGGFMJH@NT?$CFd?$AA@
  0004c	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?buf@?1??PyGrammar_LabelRepr@@9@9
  00058	e8 00 00 00 00	 call	 PyOS_snprintf

; 43   :             return buf;

  0005d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?buf@?1??PyGrammar_LabelRepr@@9@9
  00064	e9 91 00 00 00	 jmp	 $LN11@PyGrammar_@2

; 44   :         }
; 45   :         else

  00069	eb 0e		 jmp	 SHORT $LN6@PyGrammar_@2
$LN7@PyGrammar_@2:

; 46   :             return lb->lb_str;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR lb$[rsp]
  00070	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00074	e9 81 00 00 00	 jmp	 $LN11@PyGrammar_@2
$LN6@PyGrammar_@2:

; 47   :     }
; 48   :     else if (lb->lb_type < N_TOKENS) {

  00079	eb 7f		 jmp	 SHORT $LN5@PyGrammar_@2
$LN8@PyGrammar_@2:
  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR lb$[rsp]
  00080	83 38 36	 cmp	 DWORD PTR [rax], 54	; 00000036H
  00083	7d 67		 jge	 SHORT $LN4@PyGrammar_@2

; 49   :         if (lb->lb_str == NULL)

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR lb$[rsp]
  0008a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0008f	75 17		 jne	 SHORT $LN3@PyGrammar_@2

; 50   :             return _PyParser_TokenNames[lb->lb_type];

  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR lb$[rsp]
  00096	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyParser_TokenNames
  000a0	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000a4	eb 54		 jmp	 SHORT $LN11@PyGrammar_@2

; 51   :         else {

  000a6	eb 42		 jmp	 SHORT $LN2@PyGrammar_@2
$LN3@PyGrammar_@2:

; 52   :             PyOS_snprintf(buf, sizeof(buf), "%.32s(%.32s)",
; 53   :                 _PyParser_TokenNames[lb->lb_type], lb->lb_str);

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR lb$[rsp]
  000ad	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyParser_TokenNames
  000b7	48 8b 54 24 40	 mov	 rdx, QWORD PTR lb$[rsp]
  000bc	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  000c0	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000c5	4c 8b 0c c1	 mov	 r9, QWORD PTR [rcx+rax*8]
  000c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@JPJIHJHF@?$CF?432s?$CI?$CF?432s?$CJ?$AA@
  000d0	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?buf@?1??PyGrammar_LabelRepr@@9@9
  000dc	e8 00 00 00 00	 call	 PyOS_snprintf

; 54   :             return buf;

  000e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?buf@?1??PyGrammar_LabelRepr@@9@9
  000e8	eb 10		 jmp	 SHORT $LN11@PyGrammar_@2
$LN2@PyGrammar_@2:

; 55   :         }
; 56   :     }
; 57   :     else {

  000ea	eb 0e		 jmp	 SHORT $LN1@PyGrammar_@2
$LN4@PyGrammar_@2:

; 58   :         Py_FatalError("invalid label");

  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@MPOPIKLL@invalid?5label?$AA@
  000f3	e8 00 00 00 00	 call	 Py_FatalError

; 59   :         return NULL;

  000f8	33 c0		 xor	 eax, eax
$LN1@PyGrammar_@2:
$LN5@PyGrammar_@2:
$LN9@PyGrammar_@2:
$LN11@PyGrammar_@2:

; 60   :     }
; 61   : }

  000fa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fe	c3		 ret	 0
PyGrammar_LabelRepr ENDP
_TEXT	ENDS
END
