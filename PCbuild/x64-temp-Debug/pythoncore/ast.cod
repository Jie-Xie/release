; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05MKDOIIA@False?$AA@			; `string'
PUBLIC	??_C@_04HPMIDMKH@True?$AA@			; `string'
PUBLIC	??_C@_04OHJIHAFH@None?$AA@			; `string'
_DATA	SEGMENT
FORBIDDEN DQ	FLAT:??_C@_04OHJIHAFH@None?$AA@
	DQ	FLAT:??_C@_04HPMIDMKH@True?$AA@
	DQ	FLAT:??_C@_05MKDOIIA@False?$AA@
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_05MKDOIIA@False?$AA@
CONST	SEGMENT
??_C@_05MKDOIIA@False?$AA@ DB 'False', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPMIDMKH@True?$AA@
CONST	SEGMENT
??_C@_04HPMIDMKH@True?$AA@ DB 'True', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHJIHAFH@None?$AA@
CONST	SEGMENT
??_C@_04OHJIHAFH@None?$AA@ DB 'None', 00H		; `string'
CONST	ENDS
PUBLIC	??_C@_0BH@GOGEICIH@impossible?5module?5node?$AA@ ; `string'
PUBLIC	??_C@_0CL@ECMMLFPD@Suite?5is?5not?5valid?5in?5the?5CPytho@ ; `string'
PUBLIC	PyAST_Validate
EXTRN	PyExc_SystemError:QWORD
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\python\ast.c
pdata	SEGMENT
$pdata$PyAST_Validate DD imagerel $LN10
	DD	imagerel $LN10+180
	DD	imagerel $unwind$PyAST_Validate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyAST_Validate DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0BH@GOGEICIH@impossible?5module?5node?$AA@
CONST	SEGMENT
??_C@_0BH@GOGEICIH@impossible?5module?5node?$AA@ DB 'impossible module no'
	DB	'de', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@ECMMLFPD@Suite?5is?5not?5valid?5in?5the?5CPytho@
CONST	SEGMENT
??_C@_0CL@ECMMLFPD@Suite?5is?5not?5valid?5in?5the?5CPytho@ DB 'Suite is n'
	DB	'ot valid in the CPython compiler', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyAST_Validate
_TEXT	SEGMENT
res$ = 32
tv64 = 36
mod$ = 64
PyAST_Validate PROC					; COMDAT

; 468  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 469  :     int res = 0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR res$[rsp], 0

; 470  : 
; 471  :     switch (mod->kind) {

  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR mod$[rsp]
  00016	8b 00		 mov	 eax, DWORD PTR [rax]
  00018	89 44 24 24	 mov	 DWORD PTR tv64[rsp], eax
  0001c	83 7c 24 24 01	 cmp	 DWORD PTR tv64[rsp], 1
  00021	74 17		 je	 SHORT $LN5@PyAST_Vali
  00023	83 7c 24 24 02	 cmp	 DWORD PTR tv64[rsp], 2
  00028	74 24		 je	 SHORT $LN4@PyAST_Vali
  0002a	83 7c 24 24 03	 cmp	 DWORD PTR tv64[rsp], 3
  0002f	74 31		 je	 SHORT $LN3@PyAST_Vali
  00031	83 7c 24 24 04	 cmp	 DWORD PTR tv64[rsp], 4
  00036	74 43		 je	 SHORT $LN2@PyAST_Vali
  00038	eb 56		 jmp	 SHORT $LN1@PyAST_Vali
$LN5@PyAST_Vali:

; 472  :     case Module_kind:
; 473  :         res = validate_stmts(mod->v.Module.body);

  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR mod$[rsp]
  0003f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00043	e8 00 00 00 00	 call	 validate_stmts
  00048	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 474  :         break;

  0004c	eb 5d		 jmp	 SHORT $LN6@PyAST_Vali
$LN4@PyAST_Vali:

; 475  :     case Interactive_kind:
; 476  :         res = validate_stmts(mod->v.Interactive.body);

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR mod$[rsp]
  00053	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00057	e8 00 00 00 00	 call	 validate_stmts
  0005c	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 477  :         break;

  00060	eb 49		 jmp	 SHORT $LN6@PyAST_Vali
$LN3@PyAST_Vali:

; 478  :     case Expression_kind:
; 479  :         res = validate_expr(mod->v.Expression.body, Load);

  00062	ba 01 00 00 00	 mov	 edx, 1
  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR mod$[rsp]
  0006c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00070	e8 00 00 00 00	 call	 validate_expr
  00075	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 480  :         break;

  00079	eb 30		 jmp	 SHORT $LN6@PyAST_Vali
$LN2@PyAST_Vali:

; 481  :     case Suite_kind:
; 482  :         PyErr_SetString(PyExc_ValueError, "Suite is not valid in the CPython compiler");

  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@ECMMLFPD@Suite?5is?5not?5valid?5in?5the?5CPytho@
  00082	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00089	e8 00 00 00 00	 call	 PyErr_SetString

; 483  :         break;

  0008e	eb 1b		 jmp	 SHORT $LN6@PyAST_Vali
$LN1@PyAST_Vali:

; 484  :     default:
; 485  :         PyErr_SetString(PyExc_SystemError, "impossible module node");

  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@GOGEICIH@impossible?5module?5node?$AA@
  00097	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0009e	e8 00 00 00 00	 call	 PyErr_SetString

; 486  :         res = 0;

  000a3	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR res$[rsp], 0
$LN6@PyAST_Vali:

; 487  :         break;
; 488  :     }
; 489  :     return res;

  000ab	8b 44 24 20	 mov	 eax, DWORD PTR res$[rsp]

; 490  : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
PyAST_Validate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@PAKLMHBH@unexpected?5expression?$AA@	; `string'
PUBLIC	??_C@_0BI@DPNNPPHI@non?9bytes?5type?5in?5Bytes?$AA@ ; `string'
PUBLIC	??_C@_0BH@JMHKCIPG@non?9string?5type?5in?5Str?$AA@ ; `string'
PUBLIC	??_C@_0BI@ECNBNEHA@non?9numeric?5type?5in?5Num?$AA@ ; `string'
PUBLIC	??_C@_0DL@IEHCCJP@Compare?5has?5a?5different?5number?5o@ ; `string'
PUBLIC	??_C@_0BM@HPPBDCNI@Compare?5with?5no?5comparators?$AA@ ; `string'
PUBLIC	??_C@_0DE@EGPJELGA@Dict?5doesn?8t?5have?5the?5same?5numbe@ ; `string'
PUBLIC	??_C@_0BP@DJACLLDP@BoolOp?5with?5less?5than?52?5values?$AA@ ; `string'
PUBLIC	??_C@_0DD@JOHDCPHG@expression?5must?5have?5?$CFs?5context?5@ ; `string'
PUBLIC	??_C@_0DE@FLEFGDAH@expression?5which?5can?8t?5be?5assign@ ; `string'
EXTRN	PyBytes_Type:BYTE
EXTRN	PyUnicode_Type:BYTE
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyComplex_Type:BYTE
EXTRN	PyFloat_Type:BYTE
EXTRN	PyLong_Type:BYTE
EXTRN	PyErr_Format:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_expr DD imagerel validate_expr
	DD	imagerel validate_expr+2628
	DD	imagerel $unwind$validate_expr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_expr DD 021001H
	DD	0190110H
xdata	ENDS
;	COMDAT ??_C@_0BG@PAKLMHBH@unexpected?5expression?$AA@
CONST	SEGMENT
??_C@_0BG@PAKLMHBH@unexpected?5expression?$AA@ DB 'unexpected expression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DPNNPPHI@non?9bytes?5type?5in?5Bytes?$AA@
CONST	SEGMENT
??_C@_0BI@DPNNPPHI@non?9bytes?5type?5in?5Bytes?$AA@ DB 'non-bytes type in'
	DB	' Bytes', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JMHKCIPG@non?9string?5type?5in?5Str?$AA@
CONST	SEGMENT
??_C@_0BH@JMHKCIPG@non?9string?5type?5in?5Str?$AA@ DB 'non-string type in'
	DB	' Str', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ECNBNEHA@non?9numeric?5type?5in?5Num?$AA@
CONST	SEGMENT
??_C@_0BI@ECNBNEHA@non?9numeric?5type?5in?5Num?$AA@ DB 'non-numeric type '
	DB	'in Num', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@IEHCCJP@Compare?5has?5a?5different?5number?5o@
CONST	SEGMENT
??_C@_0DL@IEHCCJP@Compare?5has?5a?5different?5number?5o@ DB 'Compare has '
	DB	'a different number of comparators and operands', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HPPBDCNI@Compare?5with?5no?5comparators?$AA@
CONST	SEGMENT
??_C@_0BM@HPPBDCNI@Compare?5with?5no?5comparators?$AA@ DB 'Compare with n'
	DB	'o comparators', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@EGPJELGA@Dict?5doesn?8t?5have?5the?5same?5numbe@
CONST	SEGMENT
??_C@_0DE@EGPJELGA@Dict?5doesn?8t?5have?5the?5same?5numbe@ DB 'Dict doesn'
	DB	'''t have the same number of keys as values', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DJACLLDP@BoolOp?5with?5less?5than?52?5values?$AA@
CONST	SEGMENT
??_C@_0BP@DJACLLDP@BoolOp?5with?5less?5than?52?5values?$AA@ DB 'BoolOp wi'
	DB	'th less than 2 values', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JOHDCPHG@expression?5must?5have?5?$CFs?5context?5@
CONST	SEGMENT
??_C@_0DD@JOHDCPHG@expression?5must?5have?5?$CFs?5context?5@ DB 'expressi'
	DB	'on must have %s context but has %s instead', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FLEFGDAH@expression?5which?5can?8t?5be?5assign@
CONST	SEGMENT
??_C@_0DE@FLEFGDAH@expression?5which?5can?8t?5be?5assign@ DB 'expression '
	DB	'which can''t be assigned to in %s context', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT validate_expr
_TEXT	SEGMENT
actual_ctx$ = 32
check_ctx$ = 36
n$21692 = 40
s$21699 = 48
b$21704 = 56
tv64 = 64
tv82 = 72
tv81 = 80
tv94 = 88
tv145 = 96
tv159 = 100
tv175 = 104
tv180 = 112
tv185 = 120
tv201 = 128
tv216 = 132
tv226 = 136
tv236 = 140
tv251 = 144
tv259 = 148
tv268 = 152
tv276 = 160
tv281 = 168
tv296 = 176
tv326 = 180
tv359 = 184
exp$ = 208
ctx$ = 216
validate_expr PROC					; COMDAT

; 144  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 145  :     int check_ctx = 1;

  00010	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR check_ctx$[rsp], 1

; 146  :     expr_context_ty actual_ctx;
; 147  : 
; 148  :     /* First check expression context. */
; 149  :     switch (exp->kind) {

  00018	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00020	8b 00		 mov	 eax, DWORD PTR [rax]
  00022	89 44 24 40	 mov	 DWORD PTR tv64[rsp], eax
  00026	8b 44 24 40	 mov	 eax, DWORD PTR tv64[rsp]
  0002a	83 e8 14	 sub	 eax, 20
  0002d	89 44 24 40	 mov	 DWORD PTR tv64[rsp], eax
  00031	83 7c 24 40 05	 cmp	 DWORD PTR tv64[rsp], 5
  00036	0f 87 81 00 00
	00		 ja	 $LN37@validate_e
  0003c	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv64[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00048	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN87@validate_e[rcx+rax*4]
  0004f	48 03 c1	 add	 rax, rcx
  00052	ff e0		 jmp	 rax
$LN43@validate_e:

; 150  :     case Attribute_kind:
; 151  :         actual_ctx = exp->v.Attribute.ctx;

  00054	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0005c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0005f	89 44 24 20	 mov	 DWORD PTR actual_ctx$[rsp], eax

; 152  :         break;

  00063	e9 90 00 00 00	 jmp	 $LN44@validate_e
$LN42@validate_e:

; 153  :     case Subscript_kind:
; 154  :         actual_ctx = exp->v.Subscript.ctx;

  00068	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00070	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00073	89 44 24 20	 mov	 DWORD PTR actual_ctx$[rsp], eax

; 155  :         break;

  00077	eb 7f		 jmp	 SHORT $LN44@validate_e
$LN41@validate_e:

; 156  :     case Starred_kind:
; 157  :         actual_ctx = exp->v.Starred.ctx;

  00079	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00081	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00084	89 44 24 20	 mov	 DWORD PTR actual_ctx$[rsp], eax

; 158  :         break;

  00088	eb 6e		 jmp	 SHORT $LN44@validate_e
$LN40@validate_e:

; 159  :     case Name_kind:
; 160  :         actual_ctx = exp->v.Name.ctx;

  0008a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00092	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00095	89 44 24 20	 mov	 DWORD PTR actual_ctx$[rsp], eax

; 161  :         break;

  00099	eb 5d		 jmp	 SHORT $LN44@validate_e
$LN39@validate_e:

; 162  :     case List_kind:
; 163  :         actual_ctx = exp->v.List.ctx;

  0009b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  000a3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000a6	89 44 24 20	 mov	 DWORD PTR actual_ctx$[rsp], eax

; 164  :         break;

  000aa	eb 4c		 jmp	 SHORT $LN44@validate_e
$LN38@validate_e:

; 165  :     case Tuple_kind:
; 166  :         actual_ctx = exp->v.Tuple.ctx;

  000ac	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  000b4	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000b7	89 44 24 20	 mov	 DWORD PTR actual_ctx$[rsp], eax

; 167  :         break;

  000bb	eb 3b		 jmp	 SHORT $LN44@validate_e
$LN37@validate_e:

; 168  :     default:
; 169  :         if (ctx != Load) {

  000bd	83 bc 24 d8 00
	00 00 01	 cmp	 DWORD PTR ctx$[rsp], 1
  000c5	74 29		 je	 SHORT $LN36@validate_e

; 170  :             PyErr_Format(PyExc_ValueError, "expression which can't be "
; 171  :                          "assigned to in %s context", expr_context_name(ctx));

  000c7	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR ctx$[rsp]
  000ce	e8 00 00 00 00	 call	 expr_context_name
  000d3	4c 8b c0	 mov	 r8, rax
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@FLEFGDAH@expression?5which?5can?8t?5be?5assign@
  000dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000e4	e8 00 00 00 00	 call	 PyErr_Format

; 172  :             return 0;

  000e9	33 c0		 xor	 eax, eax
  000eb	e9 cf 08 00 00	 jmp	 $LN46@validate_e
$LN36@validate_e:

; 173  :         }
; 174  :         check_ctx = 0;

  000f0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR check_ctx$[rsp], 0
$LN44@validate_e:

; 175  :     }
; 176  :     if (check_ctx && actual_ctx != ctx) {

  000f8	83 7c 24 24 00	 cmp	 DWORD PTR check_ctx$[rsp], 0
  000fd	74 4c		 je	 SHORT $LN35@validate_e
  000ff	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR ctx$[rsp]
  00106	39 44 24 20	 cmp	 DWORD PTR actual_ctx$[rsp], eax
  0010a	74 3f		 je	 SHORT $LN35@validate_e

; 177  :         PyErr_Format(PyExc_ValueError, "expression must have %s context but has %s instead",
; 178  :                      expr_context_name(ctx), expr_context_name(actual_ctx));

  0010c	8b 4c 24 20	 mov	 ecx, DWORD PTR actual_ctx$[rsp]
  00110	e8 00 00 00 00	 call	 expr_context_name
  00115	48 89 44 24 48	 mov	 QWORD PTR tv82[rsp], rax
  0011a	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR ctx$[rsp]
  00121	e8 00 00 00 00	 call	 expr_context_name
  00126	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv82[rsp]
  0012b	4c 8b c9	 mov	 r9, rcx
  0012e	4c 8b c0	 mov	 r8, rax
  00131	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@JOHDCPHG@expression?5must?5have?5?$CFs?5context?5@
  00138	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0013f	e8 00 00 00 00	 call	 PyErr_Format

; 179  :         return 0;

  00144	33 c0		 xor	 eax, eax
  00146	e9 74 08 00 00	 jmp	 $LN46@validate_e
$LN35@validate_e:

; 180  :     }
; 181  : 
; 182  :     /* Now validate expression. */
; 183  :     switch (exp->kind) {

  0014b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00153	8b 00		 mov	 eax, DWORD PTR [rax]
  00155	89 44 24 50	 mov	 DWORD PTR tv81[rsp], eax
  00159	8b 44 24 50	 mov	 eax, DWORD PTR tv81[rsp]
  0015d	ff c8		 dec	 eax
  0015f	89 44 24 50	 mov	 DWORD PTR tv81[rsp], eax
  00163	83 7c 24 50 18	 cmp	 DWORD PTR tv81[rsp], 24
  00168	0f 87 3c 08 00
	00		 ja	 $LN1@validate_e
  0016e	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv81[rsp]
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0017a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN86@validate_e[rcx+rax*4]
  00181	48 03 c1	 add	 rax, rcx
  00184	ff e0		 jmp	 rax
$LN32@validate_e:

; 184  :     case BoolOp_kind:
; 185  :         if (asdl_seq_LEN(exp->v.BoolOp.values) < 2) {

  00186	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0018e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00193	75 0b		 jne	 SHORT $LN48@validate_e
  00195	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv94[rsp], 0
  0019e	eb 14		 jmp	 SHORT $LN49@validate_e
$LN48@validate_e:
  001a0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  001a8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001ac	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001af	48 89 44 24 58	 mov	 QWORD PTR tv94[rsp], rax
$LN49@validate_e:
  001b4	48 83 7c 24 58
	02		 cmp	 QWORD PTR tv94[rsp], 2
  001ba	7d 1a		 jge	 SHORT $LN31@validate_e

; 186  :             PyErr_SetString(PyExc_ValueError, "BoolOp with less than 2 values");

  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@DJACLLDP@BoolOp?5with?5less?5than?52?5values?$AA@
  001c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001ca	e8 00 00 00 00	 call	 PyErr_SetString

; 187  :             return 0;

  001cf	33 c0		 xor	 eax, eax
  001d1	e9 e9 07 00 00	 jmp	 $LN46@validate_e
$LN31@validate_e:

; 188  :         }
; 189  :         return validate_exprs(exp->v.BoolOp.values, Load, 0);

  001d6	45 33 c0	 xor	 r8d, r8d
  001d9	ba 01 00 00 00	 mov	 edx, 1
  001de	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  001e6	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  001ea	e8 00 00 00 00	 call	 validate_exprs
  001ef	e9 cb 07 00 00	 jmp	 $LN46@validate_e
$LN30@validate_e:

; 190  :     case BinOp_kind:
; 191  :         return validate_expr(exp->v.BinOp.left, Load) &&
; 192  :             validate_expr(exp->v.BinOp.right, Load);

  001f4	ba 01 00 00 00	 mov	 edx, 1
  001f9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00201	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00205	e8 00 00 00 00	 call	 validate_expr
  0020a	85 c0		 test	 eax, eax
  0020c	74 24		 je	 SHORT $LN50@validate_e
  0020e	ba 01 00 00 00	 mov	 edx, 1
  00213	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0021b	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0021f	e8 00 00 00 00	 call	 validate_expr
  00224	85 c0		 test	 eax, eax
  00226	74 0a		 je	 SHORT $LN50@validate_e
  00228	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00230	eb 08		 jmp	 SHORT $LN51@validate_e
$LN50@validate_e:
  00232	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN51@validate_e:
  0023a	8b 44 24 60	 mov	 eax, DWORD PTR tv145[rsp]
  0023e	e9 7c 07 00 00	 jmp	 $LN46@validate_e
$LN29@validate_e:

; 193  :     case UnaryOp_kind:
; 194  :         return validate_expr(exp->v.UnaryOp.operand, Load);

  00243	ba 01 00 00 00	 mov	 edx, 1
  00248	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00250	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00254	e8 00 00 00 00	 call	 validate_expr
  00259	e9 61 07 00 00	 jmp	 $LN46@validate_e
$LN28@validate_e:

; 195  :     case Lambda_kind:
; 196  :         return validate_arguments(exp->v.Lambda.args) &&
; 197  :             validate_expr(exp->v.Lambda.body, Load);

  0025e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00266	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0026a	e8 00 00 00 00	 call	 validate_arguments
  0026f	85 c0		 test	 eax, eax
  00271	74 24		 je	 SHORT $LN52@validate_e
  00273	ba 01 00 00 00	 mov	 edx, 1
  00278	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00280	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00284	e8 00 00 00 00	 call	 validate_expr
  00289	85 c0		 test	 eax, eax
  0028b	74 0a		 je	 SHORT $LN52@validate_e
  0028d	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv159[rsp], 1
  00295	eb 08		 jmp	 SHORT $LN53@validate_e
$LN52@validate_e:
  00297	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN53@validate_e:
  0029f	8b 44 24 64	 mov	 eax, DWORD PTR tv159[rsp]
  002a3	e9 17 07 00 00	 jmp	 $LN46@validate_e
$LN27@validate_e:

; 198  :     case IfExp_kind:
; 199  :         return validate_expr(exp->v.IfExp.test, Load) &&
; 200  :             validate_expr(exp->v.IfExp.body, Load) &&
; 201  :             validate_expr(exp->v.IfExp.orelse, Load);

  002a8	ba 01 00 00 00	 mov	 edx, 1
  002ad	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  002b5	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  002b9	e8 00 00 00 00	 call	 validate_expr
  002be	85 c0		 test	 eax, eax
  002c0	74 3e		 je	 SHORT $LN54@validate_e
  002c2	ba 01 00 00 00	 mov	 edx, 1
  002c7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  002cf	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  002d3	e8 00 00 00 00	 call	 validate_expr
  002d8	85 c0		 test	 eax, eax
  002da	74 24		 je	 SHORT $LN54@validate_e
  002dc	ba 01 00 00 00	 mov	 edx, 1
  002e1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  002e9	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  002ed	e8 00 00 00 00	 call	 validate_expr
  002f2	85 c0		 test	 eax, eax
  002f4	74 0a		 je	 SHORT $LN54@validate_e
  002f6	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv175[rsp], 1
  002fe	eb 08		 jmp	 SHORT $LN55@validate_e
$LN54@validate_e:
  00300	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN55@validate_e:
  00308	8b 44 24 68	 mov	 eax, DWORD PTR tv175[rsp]
  0030c	e9 ae 06 00 00	 jmp	 $LN46@validate_e
$LN26@validate_e:

; 202  :     case Dict_kind:
; 203  :         if (asdl_seq_LEN(exp->v.Dict.keys) != asdl_seq_LEN(exp->v.Dict.values)) {

  00311	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00319	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0031e	75 0b		 jne	 SHORT $LN56@validate_e
  00320	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv180[rsp], 0
  00329	eb 14		 jmp	 SHORT $LN57@validate_e
$LN56@validate_e:
  0032b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00333	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00337	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0033a	48 89 44 24 70	 mov	 QWORD PTR tv180[rsp], rax
$LN57@validate_e:
  0033f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00347	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0034c	75 0b		 jne	 SHORT $LN58@validate_e
  0034e	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv185[rsp], 0
  00357	eb 14		 jmp	 SHORT $LN59@validate_e
$LN58@validate_e:
  00359	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00361	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00365	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00368	48 89 44 24 78	 mov	 QWORD PTR tv185[rsp], rax
$LN59@validate_e:
  0036d	48 8b 44 24 78	 mov	 rax, QWORD PTR tv185[rsp]
  00372	48 39 44 24 70	 cmp	 QWORD PTR tv180[rsp], rax
  00377	74 1a		 je	 SHORT $LN25@validate_e

; 204  :             PyErr_SetString(PyExc_ValueError,
; 205  :                             "Dict doesn't have the same number of keys as values");

  00379	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@EGPJELGA@Dict?5doesn?8t?5have?5the?5same?5numbe@
  00380	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00387	e8 00 00 00 00	 call	 PyErr_SetString

; 206  :             return 0;

  0038c	33 c0		 xor	 eax, eax
  0038e	e9 2c 06 00 00	 jmp	 $LN46@validate_e
$LN25@validate_e:

; 207  :         }
; 208  :         return validate_exprs(exp->v.Dict.keys, Load, 0) &&
; 209  :             validate_exprs(exp->v.Dict.values, Load, 0);

  00393	45 33 c0	 xor	 r8d, r8d
  00396	ba 01 00 00 00	 mov	 edx, 1
  0039b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  003a3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  003a7	e8 00 00 00 00	 call	 validate_exprs
  003ac	85 c0		 test	 eax, eax
  003ae	74 2a		 je	 SHORT $LN60@validate_e
  003b0	45 33 c0	 xor	 r8d, r8d
  003b3	ba 01 00 00 00	 mov	 edx, 1
  003b8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  003c0	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  003c4	e8 00 00 00 00	 call	 validate_exprs
  003c9	85 c0		 test	 eax, eax
  003cb	74 0d		 je	 SHORT $LN60@validate_e
  003cd	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv201[rsp], 1
  003d8	eb 0b		 jmp	 SHORT $LN61@validate_e
$LN60@validate_e:
  003da	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv201[rsp], 0
$LN61@validate_e:
  003e5	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv201[rsp]
  003ec	e9 ce 05 00 00	 jmp	 $LN46@validate_e
$LN24@validate_e:

; 210  :     case Set_kind:
; 211  :         return validate_exprs(exp->v.Set.elts, Load, 0);

  003f1	45 33 c0	 xor	 r8d, r8d
  003f4	ba 01 00 00 00	 mov	 edx, 1
  003f9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00401	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00405	e8 00 00 00 00	 call	 validate_exprs
  0040a	e9 b0 05 00 00	 jmp	 $LN46@validate_e
$LN23@validate_e:

; 212  : #define COMP(NAME) \
; 213  :         case NAME ## _kind: \
; 214  :             return validate_comprehension(exp->v.NAME.generators) && \
; 215  :                 validate_expr(exp->v.NAME.elt, Load);
; 216  :     COMP(ListComp)

  0040f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00417	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0041b	e8 00 00 00 00	 call	 validate_comprehension
  00420	85 c0		 test	 eax, eax
  00422	74 27		 je	 SHORT $LN62@validate_e
  00424	ba 01 00 00 00	 mov	 edx, 1
  00429	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00431	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00435	e8 00 00 00 00	 call	 validate_expr
  0043a	85 c0		 test	 eax, eax
  0043c	74 0d		 je	 SHORT $LN62@validate_e
  0043e	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv216[rsp], 1
  00449	eb 0b		 jmp	 SHORT $LN63@validate_e
$LN62@validate_e:
  0044b	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv216[rsp], 0
$LN63@validate_e:
  00456	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv216[rsp]
  0045d	e9 5d 05 00 00	 jmp	 $LN46@validate_e
$LN22@validate_e:

; 217  :     COMP(SetComp)

  00462	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0046a	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0046e	e8 00 00 00 00	 call	 validate_comprehension
  00473	85 c0		 test	 eax, eax
  00475	74 27		 je	 SHORT $LN64@validate_e
  00477	ba 01 00 00 00	 mov	 edx, 1
  0047c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00484	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00488	e8 00 00 00 00	 call	 validate_expr
  0048d	85 c0		 test	 eax, eax
  0048f	74 0d		 je	 SHORT $LN64@validate_e
  00491	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv226[rsp], 1
  0049c	eb 0b		 jmp	 SHORT $LN65@validate_e
$LN64@validate_e:
  0049e	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv226[rsp], 0
$LN65@validate_e:
  004a9	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv226[rsp]
  004b0	e9 0a 05 00 00	 jmp	 $LN46@validate_e
$LN21@validate_e:

; 218  :     COMP(GeneratorExp)

  004b5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  004bd	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  004c1	e8 00 00 00 00	 call	 validate_comprehension
  004c6	85 c0		 test	 eax, eax
  004c8	74 27		 je	 SHORT $LN66@validate_e
  004ca	ba 01 00 00 00	 mov	 edx, 1
  004cf	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  004d7	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  004db	e8 00 00 00 00	 call	 validate_expr
  004e0	85 c0		 test	 eax, eax
  004e2	74 0d		 je	 SHORT $LN66@validate_e
  004e4	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv236[rsp], 1
  004ef	eb 0b		 jmp	 SHORT $LN67@validate_e
$LN66@validate_e:
  004f1	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv236[rsp], 0
$LN67@validate_e:
  004fc	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv236[rsp]
  00503	e9 b7 04 00 00	 jmp	 $LN46@validate_e
$LN20@validate_e:

; 219  : #undef COMP
; 220  :     case DictComp_kind:
; 221  :         return validate_comprehension(exp->v.DictComp.generators) &&
; 222  :             validate_expr(exp->v.DictComp.key, Load) &&
; 223  :             validate_expr(exp->v.DictComp.value, Load);

  00508	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00510	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00514	e8 00 00 00 00	 call	 validate_comprehension
  00519	85 c0		 test	 eax, eax
  0051b	74 41		 je	 SHORT $LN68@validate_e
  0051d	ba 01 00 00 00	 mov	 edx, 1
  00522	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0052a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0052e	e8 00 00 00 00	 call	 validate_expr
  00533	85 c0		 test	 eax, eax
  00535	74 27		 je	 SHORT $LN68@validate_e
  00537	ba 01 00 00 00	 mov	 edx, 1
  0053c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00544	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00548	e8 00 00 00 00	 call	 validate_expr
  0054d	85 c0		 test	 eax, eax
  0054f	74 0d		 je	 SHORT $LN68@validate_e
  00551	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv251[rsp], 1
  0055c	eb 0b		 jmp	 SHORT $LN69@validate_e
$LN68@validate_e:
  0055e	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv251[rsp], 0
$LN69@validate_e:
  00569	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv251[rsp]
  00570	e9 4a 04 00 00	 jmp	 $LN46@validate_e
$LN19@validate_e:

; 224  :     case Yield_kind:
; 225  :         return !exp->v.Yield.value || validate_expr(exp->v.Yield.value, Load);

  00575	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0057d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00582	74 27		 je	 SHORT $LN70@validate_e
  00584	ba 01 00 00 00	 mov	 edx, 1
  00589	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00591	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00595	e8 00 00 00 00	 call	 validate_expr
  0059a	85 c0		 test	 eax, eax
  0059c	75 0d		 jne	 SHORT $LN70@validate_e
  0059e	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv259[rsp], 0
  005a9	eb 0b		 jmp	 SHORT $LN71@validate_e
$LN70@validate_e:
  005ab	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv259[rsp], 1
$LN71@validate_e:
  005b6	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv259[rsp]
  005bd	e9 fd 03 00 00	 jmp	 $LN46@validate_e
$LN18@validate_e:

; 226  :     case YieldFrom_kind:
; 227  :         return validate_expr(exp->v.YieldFrom.value, Load);

  005c2	ba 01 00 00 00	 mov	 edx, 1
  005c7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  005cf	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  005d3	e8 00 00 00 00	 call	 validate_expr
  005d8	e9 e2 03 00 00	 jmp	 $LN46@validate_e
$LN17@validate_e:

; 228  :     case Compare_kind:
; 229  :         if (!asdl_seq_LEN(exp->v.Compare.comparators)) {

  005dd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  005e5	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  005ea	75 0e		 jne	 SHORT $LN72@validate_e
  005ec	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv268[rsp], 0
  005f8	eb 17		 jmp	 SHORT $LN73@validate_e
$LN72@validate_e:
  005fa	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00602	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00606	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00609	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv268[rsp], rax
$LN73@validate_e:
  00611	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR tv268[rsp], 0
  0061a	75 1a		 jne	 SHORT $LN16@validate_e

; 230  :             PyErr_SetString(PyExc_ValueError, "Compare with no comparators");

  0061c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@HPPBDCNI@Compare?5with?5no?5comparators?$AA@
  00623	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0062a	e8 00 00 00 00	 call	 PyErr_SetString

; 231  :             return 0;

  0062f	33 c0		 xor	 eax, eax
  00631	e9 89 03 00 00	 jmp	 $LN46@validate_e
$LN16@validate_e:

; 232  :         }
; 233  :         if (asdl_seq_LEN(exp->v.Compare.comparators) !=
; 234  :             asdl_seq_LEN(exp->v.Compare.ops)) {

  00636	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0063e	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00643	75 0e		 jne	 SHORT $LN74@validate_e
  00645	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv276[rsp], 0
  00651	eb 17		 jmp	 SHORT $LN75@validate_e
$LN74@validate_e:
  00653	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0065b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0065f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00662	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv276[rsp], rax
$LN75@validate_e:
  0066a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00672	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00677	75 0e		 jne	 SHORT $LN76@validate_e
  00679	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv281[rsp], 0
  00685	eb 17		 jmp	 SHORT $LN77@validate_e
$LN76@validate_e:
  00687	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0068f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00693	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00696	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv281[rsp], rax
$LN77@validate_e:
  0069e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv281[rsp]
  006a6	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR tv276[rsp], rax
  006ae	74 1a		 je	 SHORT $LN15@validate_e

; 235  :             PyErr_SetString(PyExc_ValueError, "Compare has a different number "
; 236  :                             "of comparators and operands");

  006b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@IEHCCJP@Compare?5has?5a?5different?5number?5o@
  006b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  006be	e8 00 00 00 00	 call	 PyErr_SetString

; 237  :             return 0;

  006c3	33 c0		 xor	 eax, eax
  006c5	e9 f5 02 00 00	 jmp	 $LN46@validate_e
$LN15@validate_e:

; 238  :         }
; 239  :         return validate_exprs(exp->v.Compare.comparators, Load, 0) &&
; 240  :             validate_expr(exp->v.Compare.left, Load);

  006ca	45 33 c0	 xor	 r8d, r8d
  006cd	ba 01 00 00 00	 mov	 edx, 1
  006d2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  006da	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  006de	e8 00 00 00 00	 call	 validate_exprs
  006e3	85 c0		 test	 eax, eax
  006e5	74 27		 je	 SHORT $LN78@validate_e
  006e7	ba 01 00 00 00	 mov	 edx, 1
  006ec	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  006f4	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  006f8	e8 00 00 00 00	 call	 validate_expr
  006fd	85 c0		 test	 eax, eax
  006ff	74 0d		 je	 SHORT $LN78@validate_e
  00701	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv296[rsp], 1
  0070c	eb 0b		 jmp	 SHORT $LN79@validate_e
$LN78@validate_e:
  0070e	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv296[rsp], 0
$LN79@validate_e:
  00719	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv296[rsp]
  00720	e9 9a 02 00 00	 jmp	 $LN46@validate_e
$LN14@validate_e:

; 241  :     case Call_kind:
; 242  :         return validate_expr(exp->v.Call.func, Load) &&
; 243  :             validate_exprs(exp->v.Call.args, Load, 0) &&
; 244  :             validate_keywords(exp->v.Call.keywords) &&
; 245  :             (!exp->v.Call.starargs || validate_expr(exp->v.Call.starargs, Load)) &&
; 246  :             (!exp->v.Call.kwargs || validate_expr(exp->v.Call.kwargs, Load));

  00725	ba 01 00 00 00	 mov	 edx, 1
  0072a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00732	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00736	e8 00 00 00 00	 call	 validate_expr
  0073b	85 c0		 test	 eax, eax
  0073d	0f 84 91 00 00
	00		 je	 $LN80@validate_e
  00743	45 33 c0	 xor	 r8d, r8d
  00746	ba 01 00 00 00	 mov	 edx, 1
  0074b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00753	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00757	e8 00 00 00 00	 call	 validate_exprs
  0075c	85 c0		 test	 eax, eax
  0075e	74 74		 je	 SHORT $LN80@validate_e
  00760	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00768	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0076c	e8 00 00 00 00	 call	 validate_keywords
  00771	85 c0		 test	 eax, eax
  00773	74 5f		 je	 SHORT $LN80@validate_e
  00775	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0077d	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00782	74 1a		 je	 SHORT $LN81@validate_e
  00784	ba 01 00 00 00	 mov	 edx, 1
  00789	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00791	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00795	e8 00 00 00 00	 call	 validate_expr
  0079a	85 c0		 test	 eax, eax
  0079c	74 36		 je	 SHORT $LN80@validate_e
$LN81@validate_e:
  0079e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  007a6	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  007ab	74 1a		 je	 SHORT $LN82@validate_e
  007ad	ba 01 00 00 00	 mov	 edx, 1
  007b2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  007ba	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  007be	e8 00 00 00 00	 call	 validate_expr
  007c3	85 c0		 test	 eax, eax
  007c5	74 0d		 je	 SHORT $LN80@validate_e
$LN82@validate_e:
  007c7	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv326[rsp], 1
  007d2	eb 0b		 jmp	 SHORT $LN83@validate_e
$LN80@validate_e:
  007d4	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv326[rsp], 0
$LN83@validate_e:
  007df	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv326[rsp]
  007e6	e9 d4 01 00 00	 jmp	 $LN46@validate_e
$LN13@validate_e:

; 247  :     case Num_kind: {
; 248  :         PyObject *n = exp->v.Num.n;

  007eb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  007f3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  007f7	48 89 44 24 28	 mov	 QWORD PTR n$21692[rsp], rax

; 249  :         if (!PyLong_CheckExact(n) && !PyFloat_CheckExact(n) &&
; 250  :             !PyComplex_CheckExact(n)) {

  007fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  00803	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$21692[rsp]
  00808	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0080c	74 3e		 je	 SHORT $LN12@validate_e
  0080e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00815	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$21692[rsp]
  0081a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0081e	74 2c		 je	 SHORT $LN12@validate_e
  00820	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyComplex_Type
  00827	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$21692[rsp]
  0082c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00830	74 1a		 je	 SHORT $LN12@validate_e

; 251  :             PyErr_SetString(PyExc_TypeError, "non-numeric type in Num");

  00832	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@ECNBNEHA@non?9numeric?5type?5in?5Num?$AA@
  00839	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00840	e8 00 00 00 00	 call	 PyErr_SetString

; 252  :             return 0;

  00845	33 c0		 xor	 eax, eax
  00847	e9 73 01 00 00	 jmp	 $LN46@validate_e
$LN12@validate_e:

; 253  :         }
; 254  :         return 1;

  0084c	b8 01 00 00 00	 mov	 eax, 1
  00851	e9 69 01 00 00	 jmp	 $LN46@validate_e
$LN11@validate_e:

; 255  :     }
; 256  :     case Str_kind: {
; 257  :         PyObject *s = exp->v.Str.s;

  00856	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0085e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00862	48 89 44 24 30	 mov	 QWORD PTR s$21699[rsp], rax

; 258  :         if (!PyUnicode_CheckExact(s)) {

  00867	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  0086e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$21699[rsp]
  00873	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00877	74 1a		 je	 SHORT $LN10@validate_e

; 259  :             PyErr_SetString(PyExc_TypeError, "non-string type in Str");

  00879	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JMHKCIPG@non?9string?5type?5in?5Str?$AA@
  00880	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00887	e8 00 00 00 00	 call	 PyErr_SetString

; 260  :             return 0;

  0088c	33 c0		 xor	 eax, eax
  0088e	e9 2c 01 00 00	 jmp	 $LN46@validate_e
$LN10@validate_e:

; 261  :         }
; 262  :         return 1;

  00893	b8 01 00 00 00	 mov	 eax, 1
  00898	e9 22 01 00 00	 jmp	 $LN46@validate_e
$LN9@validate_e:

; 263  :     }
; 264  :     case Bytes_kind: {
; 265  :         PyObject *b = exp->v.Bytes.s;

  0089d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  008a5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  008a9	48 89 44 24 38	 mov	 QWORD PTR b$21704[rsp], rax

; 266  :         if (!PyBytes_CheckExact(b)) {

  008ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBytes_Type
  008b5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR b$21704[rsp]
  008ba	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  008be	74 1a		 je	 SHORT $LN8@validate_e

; 267  :             PyErr_SetString(PyExc_TypeError, "non-bytes type in Bytes");

  008c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DPNNPPHI@non?9bytes?5type?5in?5Bytes?$AA@
  008c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  008ce	e8 00 00 00 00	 call	 PyErr_SetString

; 268  :             return 0;

  008d3	33 c0		 xor	 eax, eax
  008d5	e9 e5 00 00 00	 jmp	 $LN46@validate_e
$LN8@validate_e:

; 269  :         }
; 270  :         return 1;

  008da	b8 01 00 00 00	 mov	 eax, 1
  008df	e9 db 00 00 00	 jmp	 $LN46@validate_e
$LN7@validate_e:

; 271  :     }
; 272  :     case Attribute_kind:
; 273  :         return validate_expr(exp->v.Attribute.value, Load);

  008e4	ba 01 00 00 00	 mov	 edx, 1
  008e9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  008f1	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  008f5	e8 00 00 00 00	 call	 validate_expr
  008fa	e9 c0 00 00 00	 jmp	 $LN46@validate_e
$LN6@validate_e:

; 274  :     case Subscript_kind:
; 275  :         return validate_slice(exp->v.Subscript.slice) &&
; 276  :             validate_expr(exp->v.Subscript.value, Load);

  008ff	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00907	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0090b	e8 00 00 00 00	 call	 validate_slice
  00910	85 c0		 test	 eax, eax
  00912	74 27		 je	 SHORT $LN84@validate_e
  00914	ba 01 00 00 00	 mov	 edx, 1
  00919	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00921	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00925	e8 00 00 00 00	 call	 validate_expr
  0092a	85 c0		 test	 eax, eax
  0092c	74 0d		 je	 SHORT $LN84@validate_e
  0092e	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv359[rsp], 1
  00939	eb 0b		 jmp	 SHORT $LN85@validate_e
$LN84@validate_e:
  0093b	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv359[rsp], 0
$LN85@validate_e:
  00946	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv359[rsp]
  0094d	eb 70		 jmp	 SHORT $LN46@validate_e
$LN5@validate_e:

; 277  :     case Starred_kind:
; 278  :         return validate_expr(exp->v.Starred.value, ctx);

  0094f	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR ctx$[rsp]
  00956	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0095e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00962	e8 00 00 00 00	 call	 validate_expr
  00967	eb 56		 jmp	 SHORT $LN46@validate_e
$LN4@validate_e:

; 279  :     case List_kind:
; 280  :         return validate_exprs(exp->v.List.elts, ctx, 0);

  00969	45 33 c0	 xor	 r8d, r8d
  0096c	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR ctx$[rsp]
  00973	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  0097b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0097f	e8 00 00 00 00	 call	 validate_exprs
  00984	eb 39		 jmp	 SHORT $LN46@validate_e
$LN3@validate_e:

; 281  :     case Tuple_kind:
; 282  :         return validate_exprs(exp->v.Tuple.elts, ctx, 0);

  00986	45 33 c0	 xor	 r8d, r8d
  00989	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR ctx$[rsp]
  00990	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR exp$[rsp]
  00998	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0099c	e8 00 00 00 00	 call	 validate_exprs
  009a1	eb 1c		 jmp	 SHORT $LN46@validate_e
$LN2@validate_e:

; 283  :     /* These last cases don't have any checking. */
; 284  :     case Name_kind:
; 285  :     case Ellipsis_kind:
; 286  :         return 1;

  009a3	b8 01 00 00 00	 mov	 eax, 1
  009a8	eb 15		 jmp	 SHORT $LN46@validate_e
$LN1@validate_e:

; 287  :     default:
; 288  :         PyErr_SetString(PyExc_SystemError, "unexpected expression");

  009aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PAKLMHBH@unexpected?5expression?$AA@
  009b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  009b8	e8 00 00 00 00	 call	 PyErr_SetString

; 289  :         return 0;

  009bd	33 c0		 xor	 eax, eax
$LN46@validate_e:

; 290  :     }
; 291  : }

  009bf	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  009c6	c3		 ret	 0
  009c7	90		 npad	 1
$LN87@validate_e:
  009c8	00 00 00 00	 DD	 $LN43@validate_e
  009cc	00 00 00 00	 DD	 $LN42@validate_e
  009d0	00 00 00 00	 DD	 $LN41@validate_e
  009d4	00 00 00 00	 DD	 $LN40@validate_e
  009d8	00 00 00 00	 DD	 $LN39@validate_e
  009dc	00 00 00 00	 DD	 $LN38@validate_e
$LN86@validate_e:
  009e0	00 00 00 00	 DD	 $LN32@validate_e
  009e4	00 00 00 00	 DD	 $LN30@validate_e
  009e8	00 00 00 00	 DD	 $LN29@validate_e
  009ec	00 00 00 00	 DD	 $LN28@validate_e
  009f0	00 00 00 00	 DD	 $LN27@validate_e
  009f4	00 00 00 00	 DD	 $LN26@validate_e
  009f8	00 00 00 00	 DD	 $LN24@validate_e
  009fc	00 00 00 00	 DD	 $LN23@validate_e
  00a00	00 00 00 00	 DD	 $LN22@validate_e
  00a04	00 00 00 00	 DD	 $LN20@validate_e
  00a08	00 00 00 00	 DD	 $LN21@validate_e
  00a0c	00 00 00 00	 DD	 $LN19@validate_e
  00a10	00 00 00 00	 DD	 $LN18@validate_e
  00a14	00 00 00 00	 DD	 $LN17@validate_e
  00a18	00 00 00 00	 DD	 $LN14@validate_e
  00a1c	00 00 00 00	 DD	 $LN13@validate_e
  00a20	00 00 00 00	 DD	 $LN11@validate_e
  00a24	00 00 00 00	 DD	 $LN9@validate_e
  00a28	00 00 00 00	 DD	 $LN2@validate_e
  00a2c	00 00 00 00	 DD	 $LN7@validate_e
  00a30	00 00 00 00	 DD	 $LN6@validate_e
  00a34	00 00 00 00	 DD	 $LN5@validate_e
  00a38	00 00 00 00	 DD	 $LN2@validate_e
  00a3c	00 00 00 00	 DD	 $LN4@validate_e
  00a40	00 00 00 00	 DD	 $LN3@validate_e
validate_expr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@FOMOKEA@comprehension?5with?5no?5generators@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_comprehension DD imagerel validate_comprehension
	DD	imagerel validate_comprehension+249
	DD	imagerel $unwind$validate_comprehension
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_comprehension DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0CB@FOMOKEA@comprehension?5with?5no?5generators@
CONST	SEGMENT
??_C@_0CB@FOMOKEA@comprehension?5with?5no?5generators@ DB 'comprehension '
	DB	'with no generators', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT validate_comprehension
_TEXT	SEGMENT
i$ = 32
comp$21541 = 40
tv65 = 48
tv72 = 56
gens$ = 80
validate_comprehension PROC				; COMDAT

; 22   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 23   :     int i;
; 24   :     if (!asdl_seq_LEN(gens)) {

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR gens$[rsp], 0
  0000f	75 0b		 jne	 SHORT $LN9@validate_c
  00011	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv65[rsp], 0
  0001a	eb 0d		 jmp	 SHORT $LN10@validate_c
$LN9@validate_c:
  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR gens$[rsp]
  00021	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00024	48 89 44 24 30	 mov	 QWORD PTR tv65[rsp], rax
$LN10@validate_c:
  00029	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv65[rsp], 0
  0002f	75 1a		 jne	 SHORT $LN6@validate_c

; 25   :         PyErr_SetString(PyExc_ValueError, "comprehension with no generators");

  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@FOMOKEA@comprehension?5with?5no?5generators@
  00038	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0003f	e8 00 00 00 00	 call	 PyErr_SetString

; 26   :         return 0;

  00044	33 c0		 xor	 eax, eax
  00046	e9 a9 00 00 00	 jmp	 $LN7@validate_c
$LN6@validate_c:

; 27   :     }
; 28   :     for (i = 0; i < asdl_seq_LEN(gens); i++) {

  0004b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00053	eb 0a		 jmp	 SHORT $LN5@validate_c
$LN4@validate_c:
  00055	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00059	ff c0		 inc	 eax
  0005b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN5@validate_c:
  0005f	48 83 7c 24 50
	00		 cmp	 QWORD PTR gens$[rsp], 0
  00065	75 0b		 jne	 SHORT $LN11@validate_c
  00067	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv72[rsp], 0
  00070	eb 0d		 jmp	 SHORT $LN12@validate_c
$LN11@validate_c:
  00072	48 8b 44 24 50	 mov	 rax, QWORD PTR gens$[rsp]
  00077	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007a	48 89 44 24 38	 mov	 QWORD PTR tv72[rsp], rax
$LN12@validate_c:
  0007f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00084	48 3b 44 24 38	 cmp	 rax, QWORD PTR tv72[rsp]
  00089	7d 64		 jge	 SHORT $LN3@validate_c

; 29   :         comprehension_ty comp = asdl_seq_GET(gens, i);

  0008b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00090	48 8b 4c 24 50	 mov	 rcx, QWORD PTR gens$[rsp]
  00095	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  0009a	48 89 44 24 28	 mov	 QWORD PTR comp$21541[rsp], rax

; 30   :         if (!validate_expr(comp->target, Store) ||
; 31   :             !validate_expr(comp->iter, Load) ||
; 32   :             !validate_exprs(comp->ifs, Load, 0))

  0009f	ba 02 00 00 00	 mov	 edx, 2
  000a4	48 8b 44 24 28	 mov	 rax, QWORD PTR comp$21541[rsp]
  000a9	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000ac	e8 00 00 00 00	 call	 validate_expr
  000b1	85 c0		 test	 eax, eax
  000b3	74 31		 je	 SHORT $LN1@validate_c
  000b5	ba 01 00 00 00	 mov	 edx, 1
  000ba	48 8b 44 24 28	 mov	 rax, QWORD PTR comp$21541[rsp]
  000bf	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000c3	e8 00 00 00 00	 call	 validate_expr
  000c8	85 c0		 test	 eax, eax
  000ca	74 1a		 je	 SHORT $LN1@validate_c
  000cc	45 33 c0	 xor	 r8d, r8d
  000cf	ba 01 00 00 00	 mov	 edx, 1
  000d4	48 8b 44 24 28	 mov	 rax, QWORD PTR comp$21541[rsp]
  000d9	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000dd	e8 00 00 00 00	 call	 validate_exprs
  000e2	85 c0		 test	 eax, eax
  000e4	75 04		 jne	 SHORT $LN2@validate_c
$LN1@validate_c:

; 33   :             return 0;

  000e6	33 c0		 xor	 eax, eax
  000e8	eb 0a		 jmp	 SHORT $LN7@validate_c
$LN2@validate_c:

; 34   :     }

  000ea	e9 66 ff ff ff	 jmp	 $LN4@validate_c
$LN3@validate_c:

; 35   :     return 1;

  000ef	b8 01 00 00 00	 mov	 eax, 1
$LN7@validate_c:

; 36   : }

  000f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f8	c3		 ret	 0
validate_comprehension ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@PJEHJOKI@unknown?5slice?5node?$AA@	; `string'
PUBLIC	??_C@_04FHFMBDKA@dims?$AA@			; `string'
PUBLIC	??_C@_08CIIMGBAD@ExtSlice?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_slice DD imagerel validate_slice
	DD	imagerel validate_slice+385
	DD	imagerel $unwind$validate_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_slice DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BD@PJEHJOKI@unknown?5slice?5node?$AA@
CONST	SEGMENT
??_C@_0BD@PJEHJOKI@unknown?5slice?5node?$AA@ DB 'unknown slice node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FHFMBDKA@dims?$AA@
CONST	SEGMENT
??_C@_04FHFMBDKA@dims?$AA@ DB 'dims', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CIIMGBAD@ExtSlice?$AA@
CONST	SEGMENT
??_C@_08CIIMGBAD@ExtSlice?$AA@ DB 'ExtSlice', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT validate_slice
_TEXT	SEGMENT
i$21554 = 32
tv64 = 36
tv86 = 40
tv131 = 48
slice$ = 80
validate_slice PROC					; COMDAT

; 40   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 41   :     switch (slice->kind) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 44 24 24	 mov	 DWORD PTR tv64[rsp], eax
  00014	83 7c 24 24 01	 cmp	 DWORD PTR tv64[rsp], 1
  00019	74 1b		 je	 SHORT $LN9@validate_s
  0001b	83 7c 24 24 02	 cmp	 DWORD PTR tv64[rsp], 2
  00020	0f 84 94 00 00
	00		 je	 $LN8@validate_s
  00026	83 7c 24 24 03	 cmp	 DWORD PTR tv64[rsp], 3
  0002b	0f 84 21 01 00
	00		 je	 $LN2@validate_s
  00031	e9 31 01 00 00	 jmp	 $LN1@validate_s
$LN9@validate_s:

; 42   :     case Slice_kind:
; 43   :         return (!slice->v.Slice.lower || validate_expr(slice->v.Slice.lower, Load)) &&
; 44   :             (!slice->v.Slice.upper || validate_expr(slice->v.Slice.upper, Load)) &&
; 45   :             (!slice->v.Slice.step || validate_expr(slice->v.Slice.step, Load));

  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  0003b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00040	74 17		 je	 SHORT $LN14@validate_s
  00042	ba 01 00 00 00	 mov	 edx, 1
  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  0004c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00050	e8 00 00 00 00	 call	 validate_expr
  00055	85 c0		 test	 eax, eax
  00057	74 50		 je	 SHORT $LN16@validate_s
$LN14@validate_s:
  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  0005e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00063	74 17		 je	 SHORT $LN15@validate_s
  00065	ba 01 00 00 00	 mov	 edx, 1
  0006a	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  0006f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00073	e8 00 00 00 00	 call	 validate_expr
  00078	85 c0		 test	 eax, eax
  0007a	74 2d		 je	 SHORT $LN16@validate_s
$LN15@validate_s:
  0007c	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  00081	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00086	74 17		 je	 SHORT $LN17@validate_s
  00088	ba 01 00 00 00	 mov	 edx, 1
  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  00092	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00096	e8 00 00 00 00	 call	 validate_expr
  0009b	85 c0		 test	 eax, eax
  0009d	74 0a		 je	 SHORT $LN16@validate_s
$LN17@validate_s:
  0009f	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  000a7	eb 08		 jmp	 SHORT $LN18@validate_s
$LN16@validate_s:
  000a9	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN18@validate_s:
  000b1	8b 44 24 28	 mov	 eax, DWORD PTR tv86[rsp]
  000b5	e9 c2 00 00 00	 jmp	 $LN12@validate_s
$LN8@validate_s:

; 46   :     case ExtSlice_kind: {
; 47   :         int i;
; 48   :         if (!validate_nonempty_seq(slice->v.ExtSlice.dims, "dims", "ExtSlice"))

  000ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08CIIMGBAD@ExtSlice?$AA@
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04FHFMBDKA@dims?$AA@
  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  000cd	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000d1	e8 00 00 00 00	 call	 validate_nonempty_seq
  000d6	85 c0		 test	 eax, eax
  000d8	75 07		 jne	 SHORT $LN7@validate_s

; 49   :             return 0;

  000da	33 c0		 xor	 eax, eax
  000dc	e9 9b 00 00 00	 jmp	 $LN12@validate_s
$LN7@validate_s:

; 50   :         for (i = 0; i < asdl_seq_LEN(slice->v.ExtSlice.dims); i++)

  000e1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$21554[rsp], 0
  000e9	eb 0a		 jmp	 SHORT $LN6@validate_s
$LN5@validate_s:
  000eb	8b 44 24 20	 mov	 eax, DWORD PTR i$21554[rsp]
  000ef	ff c0		 inc	 eax
  000f1	89 44 24 20	 mov	 DWORD PTR i$21554[rsp], eax
$LN6@validate_s:
  000f5	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  000fa	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000ff	75 0b		 jne	 SHORT $LN19@validate_s
  00101	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv131[rsp], 0
  0010a	eb 11		 jmp	 SHORT $LN20@validate_s
$LN19@validate_s:
  0010c	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  00111	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00115	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00118	48 89 44 24 30	 mov	 QWORD PTR tv131[rsp], rax
$LN20@validate_s:
  0011d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$21554[rsp]
  00122	48 3b 44 24 30	 cmp	 rax, QWORD PTR tv131[rsp]
  00127	7d 22		 jge	 SHORT $LN4@validate_s

; 51   :             if (!validate_slice(asdl_seq_GET(slice->v.ExtSlice.dims, i)))

  00129	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  0012e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00132	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$21554[rsp]
  00137	48 8b 4c c8 08	 mov	 rcx, QWORD PTR [rax+rcx*8+8]
  0013c	e8 00 00 00 00	 call	 validate_slice
  00141	85 c0		 test	 eax, eax
  00143	75 04		 jne	 SHORT $LN3@validate_s

; 52   :                 return 0;

  00145	33 c0		 xor	 eax, eax
  00147	eb 33		 jmp	 SHORT $LN12@validate_s
$LN3@validate_s:

; 53   :         return 1;

  00149	eb a0		 jmp	 SHORT $LN5@validate_s
$LN4@validate_s:
  0014b	b8 01 00 00 00	 mov	 eax, 1
  00150	eb 2a		 jmp	 SHORT $LN12@validate_s
$LN2@validate_s:

; 54   :     }
; 55   :     case Index_kind:
; 56   :         return validate_expr(slice->v.Index.value, Load);

  00152	ba 01 00 00 00	 mov	 edx, 1
  00157	48 8b 44 24 50	 mov	 rax, QWORD PTR slice$[rsp]
  0015c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00160	e8 00 00 00 00	 call	 validate_expr
  00165	eb 15		 jmp	 SHORT $LN12@validate_s
$LN1@validate_s:

; 57   :     default:
; 58   :         PyErr_SetString(PyExc_SystemError, "unknown slice node");

  00167	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@PJEHJOKI@unknown?5slice?5node?$AA@
  0016e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00175	e8 00 00 00 00	 call	 PyErr_SetString

; 59   :         return 0;

  0017a	33 c0		 xor	 eax, eax
$LN12@validate_s:

; 60   :     }
; 61   : }

  0017c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00180	c3		 ret	 0
validate_slice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_keywords DD imagerel validate_keywords
	DD	imagerel validate_keywords+122
	DD	imagerel $unwind$validate_keywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_keywords DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT validate_keywords
_TEXT	SEGMENT
i$ = 32
tv67 = 40
keywords$ = 64
validate_keywords PROC					; COMDAT

; 65   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 66   :     int i;
; 67   :     for (i = 0; i < asdl_seq_LEN(keywords); i++)

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@validate_k
$LN3@validate_k:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@validate_k:
  0001d	48 83 7c 24 40
	00		 cmp	 QWORD PTR keywords$[rsp], 0
  00023	75 0b		 jne	 SHORT $LN7@validate_k
  00025	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv67[rsp], 0
  0002e	eb 0d		 jmp	 SHORT $LN8@validate_k
$LN7@validate_k:
  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR keywords$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 89 44 24 28	 mov	 QWORD PTR tv67[rsp], rax
$LN8@validate_k:
  0003d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00042	48 3b 44 24 28	 cmp	 rax, QWORD PTR tv67[rsp]
  00047	7d 27		 jge	 SHORT $LN2@validate_k

; 68   :         if (!validate_expr(((keyword_ty)asdl_seq_GET(keywords, i))->value, Load))

  00049	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR keywords$[rsp]
  00053	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00058	ba 01 00 00 00	 mov	 edx, 1
  0005d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00061	e8 00 00 00 00	 call	 validate_expr
  00066	85 c0		 test	 eax, eax
  00068	75 04		 jne	 SHORT $LN1@validate_k

; 69   :             return 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	eb 07		 jmp	 SHORT $LN5@validate_k
$LN1@validate_k:

; 70   :     return 1;

  0006e	eb a3		 jmp	 SHORT $LN3@validate_k
$LN2@validate_k:
  00070	b8 01 00 00 00	 mov	 eax, 1
$LN5@validate_k:

; 71   : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
validate_keywords ENDP
_TEXT	ENDS
PUBLIC	??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@		; `string'
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	??_C@_05LOJBNELM@Param?$AA@			; `string'
PUBLIC	??_C@_08NAEMOJFF@AugStore?$AA@			; `string'
PUBLIC	??_C@_07GCIJHPCC@AugLoad?$AA@			; `string'
PUBLIC	??_C@_03ENJJMCOJ@Del?$AA@			; `string'
PUBLIC	??_C@_05OEMPKGID@Store?$AA@			; `string'
PUBLIC	??_C@_04IPBPFFEL@Load?$AA@			; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$expr_context_name DD imagerel expr_context_name
	DD	imagerel expr_context_name+184
	DD	imagerel $unwind$expr_context_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$expr_context_name DD 010801H
	DD	06208H
xdata	ENDS
;	COMDAT ??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@
CONST	SEGMENT
??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@ DB '(unknown)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'y', 00H, 't', 00H, 'h', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'a', 00H, 's', 00H, 't', 00H, '.'
	DB	00H, 'c', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LOJBNELM@Param?$AA@
CONST	SEGMENT
??_C@_05LOJBNELM@Param?$AA@ DB 'Param', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NAEMOJFF@AugStore?$AA@
CONST	SEGMENT
??_C@_08NAEMOJFF@AugStore?$AA@ DB 'AugStore', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GCIJHPCC@AugLoad?$AA@
CONST	SEGMENT
??_C@_07GCIJHPCC@AugLoad?$AA@ DB 'AugLoad', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03ENJJMCOJ@Del?$AA@
CONST	SEGMENT
??_C@_03ENJJMCOJ@Del?$AA@ DB 'Del', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OEMPKGID@Store?$AA@
CONST	SEGMENT
??_C@_05OEMPKGID@Store?$AA@ DB 'Store', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPBPFFEL@Load?$AA@
CONST	SEGMENT
??_C@_04IPBPFFEL@Load?$AA@ DB 'Load', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT expr_context_name
_TEXT	SEGMENT
tv64 = 32
ctx$ = 64
expr_context_name PROC					; COMDAT

; 87   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 88   :     switch (ctx) {

  00008	8b 44 24 40	 mov	 eax, DWORD PTR ctx$[rsp]
  0000c	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  00010	8b 44 24 20	 mov	 eax, DWORD PTR tv64[rsp]
  00014	ff c8		 dec	 eax
  00016	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0001a	83 7c 24 20 05	 cmp	 DWORD PTR tv64[rsp], 5
  0001f	77 4e		 ja	 SHORT $LN1@expr_conte
  00021	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv64[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0002d	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN13@expr_conte[rcx+rax*4]
  00034	48 03 c1	 add	 rax, rcx
  00037	ff e0		 jmp	 rax
$LN7@expr_conte:

; 89   :     case Load:
; 90   :         return "Load";

  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04IPBPFFEL@Load?$AA@
  00040	eb 56		 jmp	 SHORT $LN10@expr_conte
$LN6@expr_conte:

; 91   :     case Store:
; 92   :         return "Store";

  00042	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05OEMPKGID@Store?$AA@
  00049	eb 4d		 jmp	 SHORT $LN10@expr_conte
$LN5@expr_conte:

; 93   :     case Del:
; 94   :         return "Del";

  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03ENJJMCOJ@Del?$AA@
  00052	eb 44		 jmp	 SHORT $LN10@expr_conte
$LN4@expr_conte:

; 95   :     case AugLoad:
; 96   :         return "AugLoad";

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07GCIJHPCC@AugLoad?$AA@
  0005b	eb 3b		 jmp	 SHORT $LN10@expr_conte
$LN3@expr_conte:

; 97   :     case AugStore:
; 98   :         return "AugStore";

  0005d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08NAEMOJFF@AugStore?$AA@
  00064	eb 32		 jmp	 SHORT $LN10@expr_conte
$LN2@expr_conte:

; 99   :     case Param:
; 100  :         return "Param";

  00066	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05LOJBNELM@Param?$AA@
  0006d	eb 29		 jmp	 SHORT $LN10@expr_conte
$LN1@expr_conte:

; 101  :     default:
; 102  :         assert(0);

  0006f	33 c0		 xor	 eax, eax
  00071	85 c0		 test	 eax, eax
  00073	75 1c		 jne	 SHORT $LN12@expr_conte
  00075	41 b8 66 00 00
	00		 mov	 r8d, 102		; 00000066H
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008f	33 c0		 xor	 eax, eax
$LN12@expr_conte:

; 103  :         return "(unknown)";

  00091	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09GPGAJHPD@?$CIunknown?$CJ?$AA@
$LN10@expr_conte:

; 104  :     }
; 105  : }

  00098	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009c	c3		 ret	 0
  0009d	0f 1f 00	 npad	 3
$LN13@expr_conte:
  000a0	00 00 00 00	 DD	 $LN7@expr_conte
  000a4	00 00 00 00	 DD	 $LN6@expr_conte
  000a8	00 00 00 00	 DD	 $LN5@expr_conte
  000ac	00 00 00 00	 DD	 $LN4@expr_conte
  000b0	00 00 00 00	 DD	 $LN3@expr_conte
  000b4	00 00 00 00	 DD	 $LN2@expr_conte
expr_context_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EB@KMIALOCA@length?5of?5kwonlyargs?5is?5not?5the?5@ ; `string'
PUBLIC	??_C@_0DA@BMNOANML@more?5positional?5defaults?5than?5ar@ ; `string'
PUBLIC	??_C@_0CK@OLHMKKCI@kwargannotation?5but?5no?5kwarg?5on?5@ ; `string'
PUBLIC	??_C@_0CM@FFNDHJIA@varargannotation?5but?5no?5vararg?5o@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_arguments DD imagerel validate_arguments
	DD	imagerel validate_arguments+531
	DD	imagerel $unwind$validate_arguments
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_arguments DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0EB@KMIALOCA@length?5of?5kwonlyargs?5is?5not?5the?5@
CONST	SEGMENT
??_C@_0EB@KMIALOCA@length?5of?5kwonlyargs?5is?5not?5the?5@ DB 'length of '
	DB	'kwonlyargs is not the same as kw_defaults on arguments', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BMNOANML@more?5positional?5defaults?5than?5ar@
CONST	SEGMENT
??_C@_0DA@BMNOANML@more?5positional?5defaults?5than?5ar@ DB 'more positio'
	DB	'nal defaults than args on arguments', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@OLHMKKCI@kwargannotation?5but?5no?5kwarg?5on?5@
CONST	SEGMENT
??_C@_0CK@OLHMKKCI@kwargannotation?5but?5no?5kwarg?5on?5@ DB 'kwargannota'
	DB	'tion but no kwarg on arguments', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FFNDHJIA@varargannotation?5but?5no?5vararg?5o@
CONST	SEGMENT
??_C@_0CM@FFNDHJIA@varargannotation?5but?5no?5vararg?5o@ DB 'varargannota'
	DB	'tion but no vararg on arguments', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT validate_arguments
_TEXT	SEGMENT
tv129 = 32
tv132 = 40
tv140 = 48
tv145 = 56
tv161 = 64
args$ = 96
validate_arguments PROC					; COMDAT

; 109  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 110  :     if (!validate_args(args->args))

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  0000e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00011	e8 00 00 00 00	 call	 validate_args
  00016	85 c0		 test	 eax, eax
  00018	75 07		 jne	 SHORT $LN10@validate_a

; 111  :         return 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	e9 ed 01 00 00	 jmp	 $LN11@validate_a
$LN10@validate_a:

; 112  :     if (args->varargannotation) {

  00021	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  00026	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0002b	74 44		 je	 SHORT $LN9@validate_a

; 113  :         if (!args->vararg) {

  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  00032	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00037	75 1a		 jne	 SHORT $LN8@validate_a

; 114  :             PyErr_SetString(PyExc_ValueError, "varargannotation but no vararg on arguments");

  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@FFNDHJIA@varargannotation?5but?5no?5vararg?5o@
  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00047	e8 00 00 00 00	 call	 PyErr_SetString

; 115  :             return 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 bb 01 00 00	 jmp	 $LN11@validate_a
$LN8@validate_a:

; 116  :         }
; 117  :         if (!validate_expr(args->varargannotation, Load))

  00053	ba 01 00 00 00	 mov	 edx, 1
  00058	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  0005d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00061	e8 00 00 00 00	 call	 validate_expr
  00066	85 c0		 test	 eax, eax
  00068	75 07		 jne	 SHORT $LN7@validate_a

; 118  :             return 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 9d 01 00 00	 jmp	 $LN11@validate_a
$LN7@validate_a:
$LN9@validate_a:

; 119  :     }
; 120  :     if (!validate_args(args->kwonlyargs))

  00071	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  00076	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0007a	e8 00 00 00 00	 call	 validate_args
  0007f	85 c0		 test	 eax, eax
  00081	75 07		 jne	 SHORT $LN6@validate_a

; 121  :         return 0;

  00083	33 c0		 xor	 eax, eax
  00085	e9 84 01 00 00	 jmp	 $LN11@validate_a
$LN6@validate_a:

; 122  :     if (args->kwargannotation) {

  0008a	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  0008f	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00094	74 44		 je	 SHORT $LN5@validate_a

; 123  :         if (!args->kwarg) {

  00096	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  0009b	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  000a0	75 1a		 jne	 SHORT $LN4@validate_a

; 124  :             PyErr_SetString(PyExc_ValueError, "kwargannotation but no kwarg on arguments");

  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@OLHMKKCI@kwargannotation?5but?5no?5kwarg?5on?5@
  000a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000b0	e8 00 00 00 00	 call	 PyErr_SetString

; 125  :             return 0;

  000b5	33 c0		 xor	 eax, eax
  000b7	e9 52 01 00 00	 jmp	 $LN11@validate_a
$LN4@validate_a:

; 126  :         }
; 127  :         if (!validate_expr(args->kwargannotation, Load))

  000bc	ba 01 00 00 00	 mov	 edx, 1
  000c1	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  000c6	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000ca	e8 00 00 00 00	 call	 validate_expr
  000cf	85 c0		 test	 eax, eax
  000d1	75 07		 jne	 SHORT $LN3@validate_a

; 128  :             return 0;

  000d3	33 c0		 xor	 eax, eax
  000d5	e9 34 01 00 00	 jmp	 $LN11@validate_a
$LN3@validate_a:
$LN5@validate_a:

; 129  :     }
; 130  :     if (asdl_seq_LEN(args->defaults) > asdl_seq_LEN(args->args)) {

  000da	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  000df	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000e4	75 0b		 jne	 SHORT $LN13@validate_a
  000e6	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv129[rsp], 0
  000ef	eb 11		 jmp	 SHORT $LN14@validate_a
$LN13@validate_a:
  000f1	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  000f6	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000fa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fd	48 89 44 24 20	 mov	 QWORD PTR tv129[rsp], rax
$LN14@validate_a:
  00102	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  00107	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0010b	75 0b		 jne	 SHORT $LN15@validate_a
  0010d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv132[rsp], 0
  00116	eb 10		 jmp	 SHORT $LN16@validate_a
$LN15@validate_a:
  00118	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  0011d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00120	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00123	48 89 44 24 28	 mov	 QWORD PTR tv132[rsp], rax
$LN16@validate_a:
  00128	48 8b 44 24 28	 mov	 rax, QWORD PTR tv132[rsp]
  0012d	48 39 44 24 20	 cmp	 QWORD PTR tv129[rsp], rax
  00132	7e 1a		 jle	 SHORT $LN2@validate_a

; 131  :         PyErr_SetString(PyExc_ValueError, "more positional defaults than args on arguments");

  00134	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@BMNOANML@more?5positional?5defaults?5than?5ar@
  0013b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00142	e8 00 00 00 00	 call	 PyErr_SetString

; 132  :         return 0;

  00147	33 c0		 xor	 eax, eax
  00149	e9 c0 00 00 00	 jmp	 $LN11@validate_a
$LN2@validate_a:

; 133  :     }
; 134  :     if (asdl_seq_LEN(args->kw_defaults) != asdl_seq_LEN(args->kwonlyargs)) {

  0014e	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  00153	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00158	75 0b		 jne	 SHORT $LN17@validate_a
  0015a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv140[rsp], 0
  00163	eb 11		 jmp	 SHORT $LN18@validate_a
$LN17@validate_a:
  00165	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  0016a	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0016e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00171	48 89 44 24 30	 mov	 QWORD PTR tv140[rsp], rax
$LN18@validate_a:
  00176	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  0017b	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00180	75 0b		 jne	 SHORT $LN19@validate_a
  00182	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv145[rsp], 0
  0018b	eb 11		 jmp	 SHORT $LN20@validate_a
$LN19@validate_a:
  0018d	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  00192	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00196	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00199	48 89 44 24 38	 mov	 QWORD PTR tv145[rsp], rax
$LN20@validate_a:
  0019e	48 8b 44 24 38	 mov	 rax, QWORD PTR tv145[rsp]
  001a3	48 39 44 24 30	 cmp	 QWORD PTR tv140[rsp], rax
  001a8	74 17		 je	 SHORT $LN1@validate_a

; 135  :         PyErr_SetString(PyExc_ValueError, "length of kwonlyargs is not the same as "
; 136  :                         "kw_defaults on arguments");

  001aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@KMIALOCA@length?5of?5kwonlyargs?5is?5not?5the?5@
  001b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001b8	e8 00 00 00 00	 call	 PyErr_SetString

; 137  :         return 0;

  001bd	33 c0		 xor	 eax, eax
  001bf	eb 4d		 jmp	 SHORT $LN11@validate_a
$LN1@validate_a:

; 138  :     }
; 139  :     return validate_exprs(args->defaults, Load, 0) && validate_exprs(args->kw_defaults, Load, 1);

  001c1	45 33 c0	 xor	 r8d, r8d
  001c4	ba 01 00 00 00	 mov	 edx, 1
  001c9	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  001ce	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  001d2	e8 00 00 00 00	 call	 validate_exprs
  001d7	85 c0		 test	 eax, eax
  001d9	74 27		 je	 SHORT $LN21@validate_a
  001db	41 b8 01 00 00
	00		 mov	 r8d, 1
  001e1	ba 01 00 00 00	 mov	 edx, 1
  001e6	48 8b 44 24 60	 mov	 rax, QWORD PTR args$[rsp]
  001eb	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  001ef	e8 00 00 00 00	 call	 validate_exprs
  001f4	85 c0		 test	 eax, eax
  001f6	74 0a		 je	 SHORT $LN21@validate_a
  001f8	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  00200	eb 08		 jmp	 SHORT $LN22@validate_a
$LN21@validate_a:
  00202	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN22@validate_a:
  0020a	8b 44 24 40	 mov	 eax, DWORD PTR tv161[rsp]
$LN11@validate_a:

; 140  : }

  0020e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00212	c3		 ret	 0
validate_arguments ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_args DD imagerel validate_args
	DD	imagerel validate_args+144
	DD	imagerel $unwind$validate_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_args DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT validate_args
_TEXT	SEGMENT
i$ = 32
arg$21586 = 40
tv67 = 48
args$ = 80
validate_args PROC					; COMDAT

; 75   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 76   :     int i;
; 77   :     for (i = 0; i < asdl_seq_LEN(args); i++) {

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@validate_a@2
$LN3@validate_a@2:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@validate_a@2:
  0001d	48 83 7c 24 50
	00		 cmp	 QWORD PTR args$[rsp], 0
  00023	75 0b		 jne	 SHORT $LN7@validate_a@2
  00025	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv67[rsp], 0
  0002e	eb 0d		 jmp	 SHORT $LN8@validate_a@2
$LN7@validate_a@2:
  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR args$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 89 44 24 30	 mov	 QWORD PTR tv67[rsp], rax
$LN8@validate_a@2:
  0003d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00042	48 3b 44 24 30	 cmp	 rax, QWORD PTR tv67[rsp]
  00047	7d 3d		 jge	 SHORT $LN2@validate_a@2

; 78   :         arg_ty arg = asdl_seq_GET(args, i);

  00049	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR args$[rsp]
  00053	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00058	48 89 44 24 28	 mov	 QWORD PTR arg$21586[rsp], rax

; 79   :         if (arg->annotation && !validate_expr(arg->annotation, Load))

  0005d	48 8b 44 24 28	 mov	 rax, QWORD PTR arg$21586[rsp]
  00062	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00067	74 1b		 je	 SHORT $LN1@validate_a@2
  00069	ba 01 00 00 00	 mov	 edx, 1
  0006e	48 8b 44 24 28	 mov	 rax, QWORD PTR arg$21586[rsp]
  00073	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00077	e8 00 00 00 00	 call	 validate_expr
  0007c	85 c0		 test	 eax, eax
  0007e	75 04		 jne	 SHORT $LN1@validate_a@2

; 80   :             return 0;

  00080	33 c0		 xor	 eax, eax
  00082	eb 07		 jmp	 SHORT $LN5@validate_a@2
$LN1@validate_a@2:

; 81   :     }

  00084	eb 8d		 jmp	 SHORT $LN3@validate_a@2
$LN2@validate_a@2:

; 82   :     return 1;

  00086	b8 01 00 00 00	 mov	 eax, 1
$LN5@validate_a@2:

; 83   : }

  0008b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008f	c3		 ret	 0
validate_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@FFDKEMAL@empty?5?$CFs?5on?5?$CFs?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_nonempty_seq DD imagerel validate_nonempty_seq
	DD	imagerel validate_nonempty_seq+102
	DD	imagerel $unwind$validate_nonempty_seq
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_nonempty_seq DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0P@FFDKEMAL@empty?5?$CFs?5on?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0P@FFDKEMAL@empty?5?$CFs?5on?5?$CFs?$AA@ DB 'empty %s on %s', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT validate_nonempty_seq
_TEXT	SEGMENT
tv65 = 32
seq$ = 64
what$ = 72
owner$ = 80
validate_nonempty_seq PROC				; COMDAT

; 295  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 296  :     if (asdl_seq_LEN(seq))

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00019	75 0b		 jne	 SHORT $LN4@validate_n
  0001b	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv65[rsp], 0
  00024	eb 0d		 jmp	 SHORT $LN5@validate_n
$LN4@validate_n:
  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$[rsp]
  0002b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002e	48 89 44 24 20	 mov	 QWORD PTR tv65[rsp], rax
$LN5@validate_n:
  00033	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv65[rsp], 0
  00039	74 07		 je	 SHORT $LN1@validate_n

; 297  :         return 1;

  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	eb 1f		 jmp	 SHORT $LN2@validate_n
$LN1@validate_n:

; 298  :     PyErr_Format(PyExc_ValueError, "empty %s on %s", what, owner);

  00042	4c 8b 4c 24 50	 mov	 r9, QWORD PTR owner$[rsp]
  00047	4c 8b 44 24 48	 mov	 r8, QWORD PTR what$[rsp]
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FFDKEMAL@empty?5?$CFs?5on?5?$CFs?$AA@
  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0005a	e8 00 00 00 00	 call	 PyErr_Format

; 299  :     return 0;

  0005f	33 c0		 xor	 eax, eax
$LN2@validate_n:

; 300  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
validate_nonempty_seq ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@JCLOGNHN@None?5disallowed?5in?5statement?5lis@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_stmts DD imagerel validate_stmts
	DD	imagerel validate_stmts+156
	DD	imagerel $unwind$validate_stmts
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_stmts DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0CC@JCLOGNHN@None?5disallowed?5in?5statement?5lis@
CONST	SEGMENT
??_C@_0CC@JCLOGNHN@None?5disallowed?5in?5statement?5lis@ DB 'None disallo'
	DB	'wed in statement list', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT validate_stmts
_TEXT	SEGMENT
i$ = 32
stmt$21825 = 40
tv67 = 48
seq$ = 80
validate_stmts PROC					; COMDAT

; 429  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 430  :     int i;
; 431  :     for (i = 0; i < asdl_seq_LEN(seq); i++) {

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN6@validate_s@2
$LN5@validate_s@2:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN6@validate_s@2:
  0001d	48 83 7c 24 50
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00023	75 0b		 jne	 SHORT $LN9@validate_s@2
  00025	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv67[rsp], 0
  0002e	eb 0d		 jmp	 SHORT $LN10@validate_s@2
$LN9@validate_s@2:
  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR seq$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 89 44 24 30	 mov	 QWORD PTR tv67[rsp], rax
$LN10@validate_s@2:
  0003d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00042	48 3b 44 24 30	 cmp	 rax, QWORD PTR tv67[rsp]
  00047	7d 49		 jge	 SHORT $LN4@validate_s@2

; 432  :         stmt_ty stmt = asdl_seq_GET(seq, i);

  00049	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR seq$[rsp]
  00053	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00058	48 89 44 24 28	 mov	 QWORD PTR stmt$21825[rsp], rax

; 433  :         if (stmt) {

  0005d	48 83 7c 24 28
	00		 cmp	 QWORD PTR stmt$21825[rsp], 0
  00063	74 14		 je	 SHORT $LN3@validate_s@2

; 434  :             if (!validate_stmt(stmt))

  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR stmt$21825[rsp]
  0006a	e8 00 00 00 00	 call	 validate_stmt
  0006f	85 c0		 test	 eax, eax
  00071	75 04		 jne	 SHORT $LN2@validate_s@2

; 435  :                 return 0;

  00073	33 c0		 xor	 eax, eax
  00075	eb 20		 jmp	 SHORT $LN7@validate_s@2
$LN2@validate_s@2:

; 436  :         }
; 437  :         else {

  00077	eb 17		 jmp	 SHORT $LN1@validate_s@2
$LN3@validate_s@2:

; 438  :             PyErr_SetString(PyExc_ValueError,
; 439  :                             "None disallowed in statement list");

  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@JCLOGNHN@None?5disallowed?5in?5statement?5lis@
  00080	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00087	e8 00 00 00 00	 call	 PyErr_SetString

; 440  :             return 0;

  0008c	33 c0		 xor	 eax, eax
  0008e	eb 07		 jmp	 SHORT $LN7@validate_s@2
$LN1@validate_s@2:

; 441  :         }
; 442  :     }

  00090	eb 81		 jmp	 SHORT $LN5@validate_s@2
$LN4@validate_s@2:

; 443  :     return 1;

  00092	b8 01 00 00 00	 mov	 eax, 1
$LN7@validate_s@2:

; 444  : }

  00097	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009b	c3		 ret	 0
validate_stmts ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@BHMAOFEE@unexpected?5statement?$AA@	; `string'
PUBLIC	??_C@_08BAHOEEIH@Nonlocal?$AA@			; `string'
PUBLIC	??_C@_06JGBJPOPP@Global?$AA@			; `string'
PUBLIC	??_C@_0L@IKBFEFKH@ImportFrom?$AA@		; `string'
PUBLIC	??_C@_0BO@MEDGNNAA@ImportFrom?5level?5less?5than?5?91?$AA@ ; `string'
PUBLIC	??_C@_05FLNDGCKL@names?$AA@			; `string'
PUBLIC	??_C@_06IBNLALPJ@Import?$AA@			; `string'
PUBLIC	??_C@_0O@IFPAFICE@ExceptHandler?$AA@		; `string'
PUBLIC	??_C@_0CG@GECHCPK@Try?5has?5orelse?5but?5no?5except?5han@ ; `string'
PUBLIC	??_C@_0CO@FPIKDLC@Try?5has?5neither?5except?5handlers?5@ ; `string'
PUBLIC	??_C@_03DDFMMGJH@Try?$AA@			; `string'
PUBLIC	??_C@_0CC@OFNEJJFD@Raise?5with?5cause?5but?5no?5exceptio@ ; `string'
PUBLIC	??_C@_05CFHBDDLG@items?$AA@			; `string'
PUBLIC	??_C@_04LBMICJD@With?$AA@			; `string'
PUBLIC	??_C@_02EMFCFMID@If?$AA@			; `string'
PUBLIC	??_C@_05OJJNEPLA@While?$AA@			; `string'
PUBLIC	??_C@_03DOEGLAGL@For?$AA@			; `string'
PUBLIC	??_C@_08OGFMJMG@ClassDef?$AA@			; `string'
PUBLIC	??_C@_0M@POJILEOM@FunctionDef?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_stmt DD imagerel validate_stmt
	DD	imagerel validate_stmt+2564
	DD	imagerel $unwind$validate_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_stmt DD 020c01H
	DD	017010cH
xdata	ENDS
;	COMDAT ??_C@_0BF@BHMAOFEE@unexpected?5statement?$AA@
CONST	SEGMENT
??_C@_0BF@BHMAOFEE@unexpected?5statement?$AA@ DB 'unexpected statement', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08BAHOEEIH@Nonlocal?$AA@
CONST	SEGMENT
??_C@_08BAHOEEIH@Nonlocal?$AA@ DB 'Nonlocal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGBJPOPP@Global?$AA@
CONST	SEGMENT
??_C@_06JGBJPOPP@Global?$AA@ DB 'Global', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IKBFEFKH@ImportFrom?$AA@
CONST	SEGMENT
??_C@_0L@IKBFEFKH@ImportFrom?$AA@ DB 'ImportFrom', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MEDGNNAA@ImportFrom?5level?5less?5than?5?91?$AA@
CONST	SEGMENT
??_C@_0BO@MEDGNNAA@ImportFrom?5level?5less?5than?5?91?$AA@ DB 'ImportFrom'
	DB	' level less than -1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FLNDGCKL@names?$AA@
CONST	SEGMENT
??_C@_05FLNDGCKL@names?$AA@ DB 'names', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IBNLALPJ@Import?$AA@
CONST	SEGMENT
??_C@_06IBNLALPJ@Import?$AA@ DB 'Import', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IFPAFICE@ExceptHandler?$AA@
CONST	SEGMENT
??_C@_0O@IFPAFICE@ExceptHandler?$AA@ DB 'ExceptHandler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GECHCPK@Try?5has?5orelse?5but?5no?5except?5han@
CONST	SEGMENT
??_C@_0CG@GECHCPK@Try?5has?5orelse?5but?5no?5except?5han@ DB 'Try has ore'
	DB	'lse but no except handlers', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FPIKDLC@Try?5has?5neither?5except?5handlers?5@
CONST	SEGMENT
??_C@_0CO@FPIKDLC@Try?5has?5neither?5except?5handlers?5@ DB 'Try has neit'
	DB	'her except handlers nor finalbody', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03DDFMMGJH@Try?$AA@
CONST	SEGMENT
??_C@_03DDFMMGJH@Try?$AA@ DB 'Try', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OFNEJJFD@Raise?5with?5cause?5but?5no?5exceptio@
CONST	SEGMENT
??_C@_0CC@OFNEJJFD@Raise?5with?5cause?5but?5no?5exceptio@ DB 'Raise with '
	DB	'cause but no exception', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFHBDDLG@items?$AA@
CONST	SEGMENT
??_C@_05CFHBDDLG@items?$AA@ DB 'items', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBMICJD@With?$AA@
CONST	SEGMENT
??_C@_04LBMICJD@With?$AA@ DB 'With', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02EMFCFMID@If?$AA@
CONST	SEGMENT
??_C@_02EMFCFMID@If?$AA@ DB 'If', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OJJNEPLA@While?$AA@
CONST	SEGMENT
??_C@_05OJJNEPLA@While?$AA@ DB 'While', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DOEGLAGL@For?$AA@
CONST	SEGMENT
??_C@_03DOEGLAGL@For?$AA@ DB 'For', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08OGFMJMG@ClassDef?$AA@
CONST	SEGMENT
??_C@_08OGFMJMG@ClassDef?$AA@ DB 'ClassDef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@POJILEOM@FunctionDef?$AA@
CONST	SEGMENT
??_C@_0M@POJILEOM@FunctionDef?$AA@ DB 'FunctionDef', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT validate_stmt
_TEXT	SEGMENT
i$ = 32
item$21772 = 40
handler$21794 = 48
tv64 = 56
tv87 = 60
tv155 = 64
tv163 = 68
tv178 = 72
tv189 = 76
tv209 = 80
tv224 = 84
tv239 = 88
tv252 = 96
tv288 = 104
tv302 = 112
tv308 = 120
tv316 = 128
tv322 = 136
tv332 = 144
tv355 = 152
tv365 = 160
tv371 = 168
tv384 = 172
stmt$ = 192
validate_stmt PROC					; COMDAT

; 317  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 318  :     int i;
; 319  :     switch (stmt->kind) {

  0000c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00014	8b 00		 mov	 eax, DWORD PTR [rax]
  00016	89 44 24 38	 mov	 DWORD PTR tv64[rsp], eax
  0001a	8b 44 24 38	 mov	 eax, DWORD PTR tv64[rsp]
  0001e	ff c8		 dec	 eax
  00020	89 44 24 38	 mov	 DWORD PTR tv64[rsp], eax
  00024	83 7c 24 38 14	 cmp	 DWORD PTR tv64[rsp], 20
  00029	0f 87 64 09 00
	00		 ja	 $LN1@validate_s@3
  0002f	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv64[rsp]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0003b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN88@validate_s@3[rcx+rax*4]
  00042	48 03 c1	 add	 rax, rcx
  00045	ff e0		 jmp	 rax
$LN38@validate_s@3:

; 320  :     case FunctionDef_kind:
; 321  :         return validate_body(stmt->v.FunctionDef.body, "FunctionDef") &&
; 322  :             validate_arguments(stmt->v.FunctionDef.args) &&
; 323  :             validate_exprs(stmt->v.FunctionDef.decorator_list, Load, 0) &&
; 324  :             (!stmt->v.FunctionDef.returns ||
; 325  :              validate_expr(stmt->v.FunctionDef.returns, Load));

  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@POJILEOM@FunctionDef?$AA@
  0004e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00056	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0005a	e8 00 00 00 00	 call	 validate_body
  0005f	85 c0		 test	 eax, eax
  00061	74 65		 je	 SHORT $LN43@validate_s@3
  00063	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0006b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0006f	e8 00 00 00 00	 call	 validate_arguments
  00074	85 c0		 test	 eax, eax
  00076	74 50		 je	 SHORT $LN43@validate_s@3
  00078	45 33 c0	 xor	 r8d, r8d
  0007b	ba 01 00 00 00	 mov	 edx, 1
  00080	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00088	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0008c	e8 00 00 00 00	 call	 validate_exprs
  00091	85 c0		 test	 eax, eax
  00093	74 33		 je	 SHORT $LN43@validate_s@3
  00095	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0009d	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  000a2	74 1a		 je	 SHORT $LN44@validate_s@3
  000a4	ba 01 00 00 00	 mov	 edx, 1
  000a9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  000b1	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000b5	e8 00 00 00 00	 call	 validate_expr
  000ba	85 c0		 test	 eax, eax
  000bc	74 0a		 je	 SHORT $LN43@validate_s@3
$LN44@validate_s@3:
  000be	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv87[rsp], 1
  000c6	eb 08		 jmp	 SHORT $LN45@validate_s@3
$LN43@validate_s@3:
  000c8	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN45@validate_s@3:
  000d0	8b 44 24 3c	 mov	 eax, DWORD PTR tv87[rsp]
  000d4	e9 cf 08 00 00	 jmp	 $LN41@validate_s@3
$LN37@validate_s@3:

; 326  :     case ClassDef_kind:
; 327  :         return validate_body(stmt->v.ClassDef.body, "ClassDef") &&
; 328  :             validate_exprs(stmt->v.ClassDef.bases, Load, 0) &&
; 329  :             validate_keywords(stmt->v.ClassDef.keywords) &&
; 330  :             validate_exprs(stmt->v.ClassDef.decorator_list, Load, 0) &&
; 331  :             (!stmt->v.ClassDef.starargs || validate_expr(stmt->v.ClassDef.starargs, Load)) &&
; 332  :             (!stmt->v.ClassDef.kwargs || validate_expr(stmt->v.ClassDef.kwargs, Load));

  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGFMJMG@ClassDef?$AA@
  000e0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  000e8	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  000ec	e8 00 00 00 00	 call	 validate_body
  000f1	85 c0		 test	 eax, eax
  000f3	0f 84 af 00 00
	00		 je	 $LN46@validate_s@3
  000f9	45 33 c0	 xor	 r8d, r8d
  000fc	ba 01 00 00 00	 mov	 edx, 1
  00101	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00109	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0010d	e8 00 00 00 00	 call	 validate_exprs
  00112	85 c0		 test	 eax, eax
  00114	0f 84 8e 00 00
	00		 je	 $LN46@validate_s@3
  0011a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00122	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00126	e8 00 00 00 00	 call	 validate_keywords
  0012b	85 c0		 test	 eax, eax
  0012d	74 79		 je	 SHORT $LN46@validate_s@3
  0012f	45 33 c0	 xor	 r8d, r8d
  00132	ba 01 00 00 00	 mov	 edx, 1
  00137	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0013f	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00143	e8 00 00 00 00	 call	 validate_exprs
  00148	85 c0		 test	 eax, eax
  0014a	74 5c		 je	 SHORT $LN46@validate_s@3
  0014c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00154	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00159	74 1a		 je	 SHORT $LN47@validate_s@3
  0015b	ba 01 00 00 00	 mov	 edx, 1
  00160	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00168	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0016c	e8 00 00 00 00	 call	 validate_expr
  00171	85 c0		 test	 eax, eax
  00173	74 33		 je	 SHORT $LN46@validate_s@3
$LN47@validate_s@3:
  00175	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0017d	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00182	74 1a		 je	 SHORT $LN48@validate_s@3
  00184	ba 01 00 00 00	 mov	 edx, 1
  00189	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00191	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00195	e8 00 00 00 00	 call	 validate_expr
  0019a	85 c0		 test	 eax, eax
  0019c	74 0a		 je	 SHORT $LN46@validate_s@3
$LN48@validate_s@3:
  0019e	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  001a6	eb 08		 jmp	 SHORT $LN49@validate_s@3
$LN46@validate_s@3:
  001a8	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN49@validate_s@3:
  001b0	8b 44 24 40	 mov	 eax, DWORD PTR tv155[rsp]
  001b4	e9 ef 07 00 00	 jmp	 $LN41@validate_s@3
$LN36@validate_s@3:

; 333  :     case Return_kind:
; 334  :         return !stmt->v.Return.value || validate_expr(stmt->v.Return.value, Load);

  001b9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  001c1	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  001c6	74 24		 je	 SHORT $LN50@validate_s@3
  001c8	ba 01 00 00 00	 mov	 edx, 1
  001cd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  001d5	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001d9	e8 00 00 00 00	 call	 validate_expr
  001de	85 c0		 test	 eax, eax
  001e0	75 0a		 jne	 SHORT $LN50@validate_s@3
  001e2	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
  001ea	eb 08		 jmp	 SHORT $LN51@validate_s@3
$LN50@validate_s@3:
  001ec	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
$LN51@validate_s@3:
  001f4	8b 44 24 44	 mov	 eax, DWORD PTR tv163[rsp]
  001f8	e9 ab 07 00 00	 jmp	 $LN41@validate_s@3
$LN35@validate_s@3:

; 335  :     case Delete_kind:
; 336  :         return validate_assignlist(stmt->v.Delete.targets, Del);

  001fd	ba 03 00 00 00	 mov	 edx, 3
  00202	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0020a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0020e	e8 00 00 00 00	 call	 validate_assignlist
  00213	e9 90 07 00 00	 jmp	 $LN41@validate_s@3
$LN34@validate_s@3:

; 337  :     case Assign_kind:
; 338  :         return validate_assignlist(stmt->v.Assign.targets, Store) &&
; 339  :             validate_expr(stmt->v.Assign.value, Load);

  00218	ba 02 00 00 00	 mov	 edx, 2
  0021d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00225	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00229	e8 00 00 00 00	 call	 validate_assignlist
  0022e	85 c0		 test	 eax, eax
  00230	74 24		 je	 SHORT $LN52@validate_s@3
  00232	ba 01 00 00 00	 mov	 edx, 1
  00237	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0023f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00243	e8 00 00 00 00	 call	 validate_expr
  00248	85 c0		 test	 eax, eax
  0024a	74 0a		 je	 SHORT $LN52@validate_s@3
  0024c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  00254	eb 08		 jmp	 SHORT $LN53@validate_s@3
$LN52@validate_s@3:
  00256	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN53@validate_s@3:
  0025e	8b 44 24 48	 mov	 eax, DWORD PTR tv178[rsp]
  00262	e9 41 07 00 00	 jmp	 $LN41@validate_s@3
$LN33@validate_s@3:

; 340  :     case AugAssign_kind:
; 341  :         return validate_expr(stmt->v.AugAssign.target, Store) &&
; 342  :             validate_expr(stmt->v.AugAssign.value, Load);

  00267	ba 02 00 00 00	 mov	 edx, 2
  0026c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00274	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00278	e8 00 00 00 00	 call	 validate_expr
  0027d	85 c0		 test	 eax, eax
  0027f	74 24		 je	 SHORT $LN54@validate_s@3
  00281	ba 01 00 00 00	 mov	 edx, 1
  00286	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0028e	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00292	e8 00 00 00 00	 call	 validate_expr
  00297	85 c0		 test	 eax, eax
  00299	74 0a		 je	 SHORT $LN54@validate_s@3
  0029b	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv189[rsp], 1
  002a3	eb 08		 jmp	 SHORT $LN55@validate_s@3
$LN54@validate_s@3:
  002a5	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv189[rsp], 0
$LN55@validate_s@3:
  002ad	8b 44 24 4c	 mov	 eax, DWORD PTR tv189[rsp]
  002b1	e9 f2 06 00 00	 jmp	 $LN41@validate_s@3
$LN32@validate_s@3:

; 343  :     case For_kind:
; 344  :         return validate_expr(stmt->v.For.target, Store) &&
; 345  :             validate_expr(stmt->v.For.iter, Load) &&
; 346  :             validate_body(stmt->v.For.body, "For") &&
; 347  :             validate_stmts(stmt->v.For.orelse);

  002b6	ba 02 00 00 00	 mov	 edx, 2
  002bb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  002c3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  002c7	e8 00 00 00 00	 call	 validate_expr
  002cc	85 c0		 test	 eax, eax
  002ce	74 55		 je	 SHORT $LN56@validate_s@3
  002d0	ba 01 00 00 00	 mov	 edx, 1
  002d5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  002dd	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  002e1	e8 00 00 00 00	 call	 validate_expr
  002e6	85 c0		 test	 eax, eax
  002e8	74 3b		 je	 SHORT $LN56@validate_s@3
  002ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03DOEGLAGL@For?$AA@
  002f1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  002f9	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  002fd	e8 00 00 00 00	 call	 validate_body
  00302	85 c0		 test	 eax, eax
  00304	74 1f		 je	 SHORT $LN56@validate_s@3
  00306	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0030e	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00312	e8 00 00 00 00	 call	 validate_stmts
  00317	85 c0		 test	 eax, eax
  00319	74 0a		 je	 SHORT $LN56@validate_s@3
  0031b	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv209[rsp], 1
  00323	eb 08		 jmp	 SHORT $LN57@validate_s@3
$LN56@validate_s@3:
  00325	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv209[rsp], 0
$LN57@validate_s@3:
  0032d	8b 44 24 50	 mov	 eax, DWORD PTR tv209[rsp]
  00331	e9 72 06 00 00	 jmp	 $LN41@validate_s@3
$LN31@validate_s@3:

; 348  :     case While_kind:
; 349  :         return validate_expr(stmt->v.While.test, Load) &&
; 350  :             validate_body(stmt->v.While.body, "While") &&
; 351  :             validate_stmts(stmt->v.While.orelse);

  00336	ba 01 00 00 00	 mov	 edx, 1
  0033b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00343	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00347	e8 00 00 00 00	 call	 validate_expr
  0034c	85 c0		 test	 eax, eax
  0034e	74 3b		 je	 SHORT $LN58@validate_s@3
  00350	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05OJJNEPLA@While?$AA@
  00357	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0035f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00363	e8 00 00 00 00	 call	 validate_body
  00368	85 c0		 test	 eax, eax
  0036a	74 1f		 je	 SHORT $LN58@validate_s@3
  0036c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00374	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00378	e8 00 00 00 00	 call	 validate_stmts
  0037d	85 c0		 test	 eax, eax
  0037f	74 0a		 je	 SHORT $LN58@validate_s@3
  00381	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv224[rsp], 1
  00389	eb 08		 jmp	 SHORT $LN59@validate_s@3
$LN58@validate_s@3:
  0038b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv224[rsp], 0
$LN59@validate_s@3:
  00393	8b 44 24 54	 mov	 eax, DWORD PTR tv224[rsp]
  00397	e9 0c 06 00 00	 jmp	 $LN41@validate_s@3
$LN30@validate_s@3:

; 352  :     case If_kind:
; 353  :         return validate_expr(stmt->v.If.test, Load) &&
; 354  :             validate_body(stmt->v.If.body, "If") &&
; 355  :             validate_stmts(stmt->v.If.orelse);

  0039c	ba 01 00 00 00	 mov	 edx, 1
  003a1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  003a9	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  003ad	e8 00 00 00 00	 call	 validate_expr
  003b2	85 c0		 test	 eax, eax
  003b4	74 3b		 je	 SHORT $LN60@validate_s@3
  003b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02EMFCFMID@If?$AA@
  003bd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  003c5	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  003c9	e8 00 00 00 00	 call	 validate_body
  003ce	85 c0		 test	 eax, eax
  003d0	74 1f		 je	 SHORT $LN60@validate_s@3
  003d2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  003da	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  003de	e8 00 00 00 00	 call	 validate_stmts
  003e3	85 c0		 test	 eax, eax
  003e5	74 0a		 je	 SHORT $LN60@validate_s@3
  003e7	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv239[rsp], 1
  003ef	eb 08		 jmp	 SHORT $LN61@validate_s@3
$LN60@validate_s@3:
  003f1	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv239[rsp], 0
$LN61@validate_s@3:
  003f9	8b 44 24 58	 mov	 eax, DWORD PTR tv239[rsp]
  003fd	e9 a6 05 00 00	 jmp	 $LN41@validate_s@3
$LN29@validate_s@3:

; 356  :     case With_kind:
; 357  :         if (!validate_nonempty_seq(stmt->v.With.items, "items", "With"))

  00402	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04LBMICJD@With?$AA@
  00409	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CFHBDDLG@items?$AA@
  00410	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00418	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0041c	e8 00 00 00 00	 call	 validate_nonempty_seq
  00421	85 c0		 test	 eax, eax
  00423	75 07		 jne	 SHORT $LN28@validate_s@3

; 358  :             return 0;

  00425	33 c0		 xor	 eax, eax
  00427	e9 7c 05 00 00	 jmp	 $LN41@validate_s@3
$LN28@validate_s@3:

; 359  :         for (i = 0; i < asdl_seq_LEN(stmt->v.With.items); i++) {

  0042c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00434	eb 0a		 jmp	 SHORT $LN27@validate_s@3
$LN26@validate_s@3:
  00436	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0043a	ff c0		 inc	 eax
  0043c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN27@validate_s@3:
  00440	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00448	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0044d	75 0b		 jne	 SHORT $LN62@validate_s@3
  0044f	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv252[rsp], 0
  00458	eb 14		 jmp	 SHORT $LN63@validate_s@3
$LN62@validate_s@3:
  0045a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00462	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00466	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00469	48 89 44 24 60	 mov	 QWORD PTR tv252[rsp], rax
$LN63@validate_s@3:
  0046e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00473	48 3b 44 24 60	 cmp	 rax, QWORD PTR tv252[rsp]
  00478	7d 60		 jge	 SHORT $LN25@validate_s@3

; 360  :             withitem_ty item = asdl_seq_GET(stmt->v.With.items, i);

  0047a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00482	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00486	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0048b	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  00490	48 89 44 24 28	 mov	 QWORD PTR item$21772[rsp], rax

; 361  :             if (!validate_expr(item->context_expr, Load) ||
; 362  :                 (item->optional_vars && !validate_expr(item->optional_vars, Store)))

  00495	ba 01 00 00 00	 mov	 edx, 1
  0049a	48 8b 44 24 28	 mov	 rax, QWORD PTR item$21772[rsp]
  0049f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  004a2	e8 00 00 00 00	 call	 validate_expr
  004a7	85 c0		 test	 eax, eax
  004a9	74 23		 je	 SHORT $LN23@validate_s@3
  004ab	48 8b 44 24 28	 mov	 rax, QWORD PTR item$21772[rsp]
  004b0	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  004b5	74 1e		 je	 SHORT $LN24@validate_s@3
  004b7	ba 02 00 00 00	 mov	 edx, 2
  004bc	48 8b 44 24 28	 mov	 rax, QWORD PTR item$21772[rsp]
  004c1	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  004c5	e8 00 00 00 00	 call	 validate_expr
  004ca	85 c0		 test	 eax, eax
  004cc	75 07		 jne	 SHORT $LN24@validate_s@3
$LN23@validate_s@3:

; 363  :                 return 0;

  004ce	33 c0		 xor	 eax, eax
  004d0	e9 d3 04 00 00	 jmp	 $LN41@validate_s@3
$LN24@validate_s@3:

; 364  :         }

  004d5	e9 5c ff ff ff	 jmp	 $LN26@validate_s@3
$LN25@validate_s@3:

; 365  :         return validate_body(stmt->v.With.body, "With");

  004da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04LBMICJD@With?$AA@
  004e1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  004e9	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  004ed	e8 00 00 00 00	 call	 validate_body
  004f2	e9 b1 04 00 00	 jmp	 $LN41@validate_s@3
$LN22@validate_s@3:

; 366  :     case Raise_kind:
; 367  :         if (stmt->v.Raise.exc) {

  004f7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  004ff	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00504	74 5e		 je	 SHORT $LN21@validate_s@3

; 368  :             return validate_expr(stmt->v.Raise.exc, Load) &&
; 369  :                 (!stmt->v.Raise.cause || validate_expr(stmt->v.Raise.cause, Load));

  00506	ba 01 00 00 00	 mov	 edx, 1
  0050b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00513	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00517	e8 00 00 00 00	 call	 validate_expr
  0051c	85 c0		 test	 eax, eax
  0051e	74 33		 je	 SHORT $LN65@validate_s@3
  00520	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00528	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0052d	74 1a		 je	 SHORT $LN64@validate_s@3
  0052f	ba 01 00 00 00	 mov	 edx, 1
  00534	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0053c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00540	e8 00 00 00 00	 call	 validate_expr
  00545	85 c0		 test	 eax, eax
  00547	74 0a		 je	 SHORT $LN65@validate_s@3
$LN64@validate_s@3:
  00549	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv288[rsp], 1
  00551	eb 08		 jmp	 SHORT $LN66@validate_s@3
$LN65@validate_s@3:
  00553	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv288[rsp], 0
$LN66@validate_s@3:
  0055b	8b 44 24 68	 mov	 eax, DWORD PTR tv288[rsp]
  0055f	e9 44 04 00 00	 jmp	 $LN41@validate_s@3
$LN21@validate_s@3:

; 370  :         }
; 371  :         if (stmt->v.Raise.cause) {

  00564	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0056c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00571	74 1a		 je	 SHORT $LN20@validate_s@3

; 372  :             PyErr_SetString(PyExc_ValueError, "Raise with cause but no exception");

  00573	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@OFNEJJFD@Raise?5with?5cause?5but?5no?5exceptio@
  0057a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00581	e8 00 00 00 00	 call	 PyErr_SetString

; 373  :             return 0;

  00586	33 c0		 xor	 eax, eax
  00588	e9 1b 04 00 00	 jmp	 $LN41@validate_s@3
$LN20@validate_s@3:

; 374  :         }
; 375  :         return 1;

  0058d	b8 01 00 00 00	 mov	 eax, 1
  00592	e9 11 04 00 00	 jmp	 $LN41@validate_s@3
$LN19@validate_s@3:

; 376  :     case Try_kind:
; 377  :         if (!validate_body(stmt->v.Try.body, "Try"))

  00597	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03DDFMMGJH@Try?$AA@
  0059e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  005a6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  005aa	e8 00 00 00 00	 call	 validate_body
  005af	85 c0		 test	 eax, eax
  005b1	75 07		 jne	 SHORT $LN18@validate_s@3

; 378  :             return 0;

  005b3	33 c0		 xor	 eax, eax
  005b5	e9 ee 03 00 00	 jmp	 $LN41@validate_s@3
$LN18@validate_s@3:

; 379  :         if (!asdl_seq_LEN(stmt->v.Try.handlers) &&
; 380  :             !asdl_seq_LEN(stmt->v.Try.finalbody)) {

  005ba	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  005c2	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  005c7	75 0b		 jne	 SHORT $LN67@validate_s@3
  005c9	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv302[rsp], 0
  005d2	eb 14		 jmp	 SHORT $LN68@validate_s@3
$LN67@validate_s@3:
  005d4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  005dc	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  005e0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005e3	48 89 44 24 70	 mov	 QWORD PTR tv302[rsp], rax
$LN68@validate_s@3:
  005e8	48 83 7c 24 70
	00		 cmp	 QWORD PTR tv302[rsp], 0
  005ee	75 50		 jne	 SHORT $LN17@validate_s@3
  005f0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  005f8	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  005fd	75 0b		 jne	 SHORT $LN69@validate_s@3
  005ff	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv308[rsp], 0
  00608	eb 14		 jmp	 SHORT $LN70@validate_s@3
$LN69@validate_s@3:
  0060a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00612	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00616	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00619	48 89 44 24 78	 mov	 QWORD PTR tv308[rsp], rax
$LN70@validate_s@3:
  0061e	48 83 7c 24 78
	00		 cmp	 QWORD PTR tv308[rsp], 0
  00624	75 1a		 jne	 SHORT $LN17@validate_s@3

; 381  :             PyErr_SetString(PyExc_ValueError, "Try has neither except handlers nor finalbody");

  00626	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@FPIKDLC@Try?5has?5neither?5except?5handlers?5@
  0062d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00634	e8 00 00 00 00	 call	 PyErr_SetString

; 382  :             return 0;

  00639	33 c0		 xor	 eax, eax
  0063b	e9 68 03 00 00	 jmp	 $LN41@validate_s@3
$LN17@validate_s@3:

; 383  :         }
; 384  :         if (!asdl_seq_LEN(stmt->v.Try.handlers) &&
; 385  :             asdl_seq_LEN(stmt->v.Try.orelse)) {

  00640	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00648	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0064d	75 0e		 jne	 SHORT $LN71@validate_s@3
  0064f	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv316[rsp], 0
  0065b	eb 17		 jmp	 SHORT $LN72@validate_s@3
$LN71@validate_s@3:
  0065d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00665	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00669	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0066c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv316[rsp], rax
$LN72@validate_s@3:
  00674	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tv316[rsp], 0
  0067d	75 59		 jne	 SHORT $LN16@validate_s@3
  0067f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00687	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0068c	75 0e		 jne	 SHORT $LN73@validate_s@3
  0068e	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv322[rsp], 0
  0069a	eb 17		 jmp	 SHORT $LN74@validate_s@3
$LN73@validate_s@3:
  0069c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  006a4	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  006a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006ab	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv322[rsp], rax
$LN74@validate_s@3:
  006b3	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR tv322[rsp], 0
  006bc	74 1a		 je	 SHORT $LN16@validate_s@3

; 386  :             PyErr_SetString(PyExc_ValueError, "Try has orelse but no except handlers");

  006be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@GECHCPK@Try?5has?5orelse?5but?5no?5except?5han@
  006c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  006cc	e8 00 00 00 00	 call	 PyErr_SetString

; 387  :             return 0;

  006d1	33 c0		 xor	 eax, eax
  006d3	e9 d0 02 00 00	 jmp	 $LN41@validate_s@3
$LN16@validate_s@3:

; 388  :         }
; 389  :         for (i = 0; i < asdl_seq_LEN(stmt->v.Try.handlers); i++) {

  006d8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  006e0	eb 0a		 jmp	 SHORT $LN15@validate_s@3
$LN14@validate_s@3:
  006e2	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  006e6	ff c0		 inc	 eax
  006e8	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN15@validate_s@3:
  006ec	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  006f4	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  006f9	75 0e		 jne	 SHORT $LN75@validate_s@3
  006fb	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv332[rsp], 0
  00707	eb 17		 jmp	 SHORT $LN76@validate_s@3
$LN75@validate_s@3:
  00709	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00711	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00715	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00718	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv332[rsp], rax
$LN76@validate_s@3:
  00720	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00725	48 3b 84 24 90
	00 00 00	 cmp	 rax, QWORD PTR tv332[rsp]
  0072d	7d 63		 jge	 SHORT $LN13@validate_s@3

; 390  :             excepthandler_ty handler = asdl_seq_GET(stmt->v.Try.handlers, i);

  0072f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00737	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0073b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00740	48 8b 44 c8 08	 mov	 rax, QWORD PTR [rax+rcx*8+8]
  00745	48 89 44 24 30	 mov	 QWORD PTR handler$21794[rsp], rax

; 391  :             if ((handler->v.ExceptHandler.type &&
; 392  :                  !validate_expr(handler->v.ExceptHandler.type, Load)) ||
; 393  :                 !validate_body(handler->v.ExceptHandler.body, "ExceptHandler"))

  0074a	48 8b 44 24 30	 mov	 rax, QWORD PTR handler$21794[rsp]
  0074f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00754	74 17		 je	 SHORT $LN10@validate_s@3
  00756	ba 01 00 00 00	 mov	 edx, 1
  0075b	48 8b 44 24 30	 mov	 rax, QWORD PTR handler$21794[rsp]
  00760	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00764	e8 00 00 00 00	 call	 validate_expr
  00769	85 c0		 test	 eax, eax
  0076b	74 19		 je	 SHORT $LN11@validate_s@3
$LN10@validate_s@3:
  0076d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@IFPAFICE@ExceptHandler?$AA@
  00774	48 8b 44 24 30	 mov	 rax, QWORD PTR handler$21794[rsp]
  00779	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0077d	e8 00 00 00 00	 call	 validate_body
  00782	85 c0		 test	 eax, eax
  00784	75 07		 jne	 SHORT $LN12@validate_s@3
$LN11@validate_s@3:

; 394  :                 return 0;

  00786	33 c0		 xor	 eax, eax
  00788	e9 1b 02 00 00	 jmp	 $LN41@validate_s@3
$LN12@validate_s@3:

; 395  :         }

  0078d	e9 50 ff ff ff	 jmp	 $LN14@validate_s@3
$LN13@validate_s@3:

; 396  :         return (!asdl_seq_LEN(stmt->v.Try.finalbody) ||
; 397  :                 validate_stmts(stmt->v.Try.finalbody)) &&
; 398  :             (!asdl_seq_LEN(stmt->v.Try.orelse) ||
; 399  :              validate_stmts(stmt->v.Try.orelse));

  00792	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0079a	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0079f	75 0e		 jne	 SHORT $LN77@validate_s@3
  007a1	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv355[rsp], 0
  007ad	eb 17		 jmp	 SHORT $LN78@validate_s@3
$LN77@validate_s@3:
  007af	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  007b7	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  007bb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007be	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv355[rsp], rax
$LN78@validate_s@3:
  007c6	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR tv355[rsp], 0
  007cf	74 15		 je	 SHORT $LN79@validate_s@3
  007d1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  007d9	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  007dd	e8 00 00 00 00	 call	 validate_stmts
  007e2	85 c0		 test	 eax, eax
  007e4	74 61		 je	 SHORT $LN83@validate_s@3
$LN79@validate_s@3:
  007e6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  007ee	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  007f3	75 0e		 jne	 SHORT $LN80@validate_s@3
  007f5	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv365[rsp], 0
  00801	eb 17		 jmp	 SHORT $LN81@validate_s@3
$LN80@validate_s@3:
  00803	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0080b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0080f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00812	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv365[rsp], rax
$LN81@validate_s@3:
  0081a	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR tv365[rsp], 0
  00823	74 15		 je	 SHORT $LN82@validate_s@3
  00825	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0082d	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00831	e8 00 00 00 00	 call	 validate_stmts
  00836	85 c0		 test	 eax, eax
  00838	74 0d		 je	 SHORT $LN83@validate_s@3
$LN82@validate_s@3:
  0083a	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv371[rsp], 1
  00845	eb 0b		 jmp	 SHORT $LN84@validate_s@3
$LN83@validate_s@3:
  00847	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv371[rsp], 0
$LN84@validate_s@3:
  00852	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv371[rsp]
  00859	e9 4a 01 00 00	 jmp	 $LN41@validate_s@3
$LN9@validate_s@3:

; 400  :     case Assert_kind:
; 401  :         return validate_expr(stmt->v.Assert.test, Load) &&
; 402  :             (!stmt->v.Assert.msg || validate_expr(stmt->v.Assert.msg, Load));

  0085e	ba 01 00 00 00	 mov	 edx, 1
  00863	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  0086b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0086f	e8 00 00 00 00	 call	 validate_expr
  00874	85 c0		 test	 eax, eax
  00876	74 36		 je	 SHORT $LN86@validate_s@3
  00878	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00880	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00885	74 1a		 je	 SHORT $LN85@validate_s@3
  00887	ba 01 00 00 00	 mov	 edx, 1
  0088c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00894	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00898	e8 00 00 00 00	 call	 validate_expr
  0089d	85 c0		 test	 eax, eax
  0089f	74 0d		 je	 SHORT $LN86@validate_s@3
$LN85@validate_s@3:
  008a1	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv384[rsp], 1
  008ac	eb 0b		 jmp	 SHORT $LN87@validate_s@3
$LN86@validate_s@3:
  008ae	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv384[rsp], 0
$LN87@validate_s@3:
  008b9	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv384[rsp]
  008c0	e9 e3 00 00 00	 jmp	 $LN41@validate_s@3
$LN8@validate_s@3:

; 403  :     case Import_kind:
; 404  :         return validate_nonempty_seq(stmt->v.Import.names, "names", "Import");

  008c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06IBNLALPJ@Import?$AA@
  008cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FLNDGCKL@names?$AA@
  008d3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  008db	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  008df	e8 00 00 00 00	 call	 validate_nonempty_seq
  008e4	e9 bf 00 00 00	 jmp	 $LN41@validate_s@3
$LN7@validate_s@3:

; 405  :     case ImportFrom_kind:
; 406  :         if (stmt->v.ImportFrom.level < -1) {

  008e9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  008f1	83 78 18 ff	 cmp	 DWORD PTR [rax+24], -1
  008f5	7d 1a		 jge	 SHORT $LN6@validate_s@3

; 407  :             PyErr_SetString(PyExc_ValueError, "ImportFrom level less than -1");

  008f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@MEDGNNAA@ImportFrom?5level?5less?5than?5?91?$AA@
  008fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00905	e8 00 00 00 00	 call	 PyErr_SetString

; 408  :             return 0;

  0090a	33 c0		 xor	 eax, eax
  0090c	e9 97 00 00 00	 jmp	 $LN41@validate_s@3
$LN6@validate_s@3:

; 409  :         }
; 410  :         return validate_nonempty_seq(stmt->v.ImportFrom.names, "names", "ImportFrom");

  00911	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@IKBFEFKH@ImportFrom?$AA@
  00918	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FLNDGCKL@names?$AA@
  0091f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00927	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0092b	e8 00 00 00 00	 call	 validate_nonempty_seq
  00930	eb 76		 jmp	 SHORT $LN41@validate_s@3
$LN5@validate_s@3:

; 411  :     case Global_kind:
; 412  :         return validate_nonempty_seq(stmt->v.Global.names, "names", "Global");

  00932	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06JGBJPOPP@Global?$AA@
  00939	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FLNDGCKL@names?$AA@
  00940	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00948	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0094c	e8 00 00 00 00	 call	 validate_nonempty_seq
  00951	eb 55		 jmp	 SHORT $LN41@validate_s@3
$LN4@validate_s@3:

; 413  :     case Nonlocal_kind:
; 414  :         return validate_nonempty_seq(stmt->v.Nonlocal.names, "names", "Nonlocal");

  00953	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08BAHOEEIH@Nonlocal?$AA@
  0095a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FLNDGCKL@names?$AA@
  00961	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00969	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0096d	e8 00 00 00 00	 call	 validate_nonempty_seq
  00972	eb 34		 jmp	 SHORT $LN41@validate_s@3
$LN3@validate_s@3:

; 415  :     case Expr_kind:
; 416  :         return validate_expr(stmt->v.Expr.value, Load);

  00974	ba 01 00 00 00	 mov	 edx, 1
  00979	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  00981	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00985	e8 00 00 00 00	 call	 validate_expr
  0098a	eb 1c		 jmp	 SHORT $LN41@validate_s@3
$LN2@validate_s@3:

; 417  :     case Pass_kind:
; 418  :     case Break_kind:
; 419  :     case Continue_kind:
; 420  :         return 1;

  0098c	b8 01 00 00 00	 mov	 eax, 1
  00991	eb 15		 jmp	 SHORT $LN41@validate_s@3
$LN1@validate_s@3:

; 421  :     default:
; 422  :         PyErr_SetString(PyExc_SystemError, "unexpected statement");

  00993	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@BHMAOFEE@unexpected?5statement?$AA@
  0099a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  009a1	e8 00 00 00 00	 call	 PyErr_SetString

; 423  :         return 0;

  009a6	33 c0		 xor	 eax, eax
$LN41@validate_s@3:

; 424  :     }
; 425  : }

  009a8	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  009af	c3		 ret	 0
$LN88@validate_s@3:
  009b0	00 00 00 00	 DD	 $LN38@validate_s@3
  009b4	00 00 00 00	 DD	 $LN37@validate_s@3
  009b8	00 00 00 00	 DD	 $LN36@validate_s@3
  009bc	00 00 00 00	 DD	 $LN35@validate_s@3
  009c0	00 00 00 00	 DD	 $LN34@validate_s@3
  009c4	00 00 00 00	 DD	 $LN33@validate_s@3
  009c8	00 00 00 00	 DD	 $LN32@validate_s@3
  009cc	00 00 00 00	 DD	 $LN31@validate_s@3
  009d0	00 00 00 00	 DD	 $LN30@validate_s@3
  009d4	00 00 00 00	 DD	 $LN29@validate_s@3
  009d8	00 00 00 00	 DD	 $LN22@validate_s@3
  009dc	00 00 00 00	 DD	 $LN19@validate_s@3
  009e0	00 00 00 00	 DD	 $LN9@validate_s@3
  009e4	00 00 00 00	 DD	 $LN8@validate_s@3
  009e8	00 00 00 00	 DD	 $LN7@validate_s@3
  009ec	00 00 00 00	 DD	 $LN5@validate_s@3
  009f0	00 00 00 00	 DD	 $LN4@validate_s@3
  009f4	00 00 00 00	 DD	 $LN3@validate_s@3
  009f8	00 00 00 00	 DD	 $LN2@validate_s@3
  009fc	00 00 00 00	 DD	 $LN2@validate_s@3
  00a00	00 00 00 00	 DD	 $LN2@validate_s@3
validate_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_07KJOMBCLC@targets?$AA@			; `string'
PUBLIC	??_C@_06EDODJIDJ@Assign?$AA@			; `string'
PUBLIC	??_C@_06JBKGCNBB@Delete?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_assignlist DD imagerel validate_assignlist
	DD	imagerel validate_assignlist+120
	DD	imagerel $unwind$validate_assignlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_assignlist DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT ??_C@_07KJOMBCLC@targets?$AA@
CONST	SEGMENT
??_C@_07KJOMBCLC@targets?$AA@ DB 'targets', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EDODJIDJ@Assign?$AA@
CONST	SEGMENT
??_C@_06EDODJIDJ@Assign?$AA@ DB 'Assign', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JBKGCNBB@Delete?$AA@
CONST	SEGMENT
??_C@_06JBKGCNBB@Delete?$AA@ DB 'Delete', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT validate_assignlist
_TEXT	SEGMENT
tv66 = 32
tv76 = 40
targets$ = 64
ctx$ = 72
validate_assignlist PROC				; COMDAT

; 304  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 305  :     return validate_nonempty_seq(targets, "targets", ctx == Del ? "Delete" : "Assign") &&
; 306  :         validate_exprs(targets, ctx, 0);

  0000d	83 7c 24 48 03	 cmp	 DWORD PTR ctx$[rsp], 3
  00012	75 0e		 jne	 SHORT $LN3@validate_a@3
  00014	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06JBKGCNBB@Delete?$AA@
  0001b	48 89 44 24 20	 mov	 QWORD PTR tv66[rsp], rax
  00020	eb 0c		 jmp	 SHORT $LN4@validate_a@3
$LN3@validate_a@3:
  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06EDODJIDJ@Assign?$AA@
  00029	48 89 44 24 20	 mov	 QWORD PTR tv66[rsp], rax
$LN4@validate_a@3:
  0002e	4c 8b 44 24 20	 mov	 r8, QWORD PTR tv66[rsp]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KJOMBCLC@targets?$AA@
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR targets$[rsp]
  0003f	e8 00 00 00 00	 call	 validate_nonempty_seq
  00044	85 c0		 test	 eax, eax
  00046	74 1f		 je	 SHORT $LN5@validate_a@3
  00048	45 33 c0	 xor	 r8d, r8d
  0004b	8b 54 24 48	 mov	 edx, DWORD PTR ctx$[rsp]
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR targets$[rsp]
  00054	e8 00 00 00 00	 call	 validate_exprs
  00059	85 c0		 test	 eax, eax
  0005b	74 0a		 je	 SHORT $LN5@validate_a@3
  0005d	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00065	eb 08		 jmp	 SHORT $LN6@validate_a@3
$LN5@validate_a@3:
  00067	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN6@validate_a@3:
  0006f	8b 44 24 28	 mov	 eax, DWORD PTR tv76[rsp]

; 307  : }

  00073	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00077	c3		 ret	 0
validate_assignlist ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IEJGKNJ@body?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_body DD imagerel validate_body
	DD	imagerel validate_body+81
	DD	imagerel $unwind$validate_body
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_body DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_04IEJGKNJ@body?$AA@
CONST	SEGMENT
??_C@_04IEJGKNJ@body?$AA@ DB 'body', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT validate_body
_TEXT	SEGMENT
tv72 = 32
body$ = 64
owner$ = 72
validate_body PROC					; COMDAT

; 311  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 312  :     return validate_nonempty_seq(body, "body", owner) && validate_stmts(body);

  0000e	4c 8b 44 24 48	 mov	 r8, QWORD PTR owner$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04IEJGKNJ@body?$AA@
  0001a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR body$[rsp]
  0001f	e8 00 00 00 00	 call	 validate_nonempty_seq
  00024	85 c0		 test	 eax, eax
  00026	74 18		 je	 SHORT $LN3@validate_b
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR body$[rsp]
  0002d	e8 00 00 00 00	 call	 validate_stmts
  00032	85 c0		 test	 eax, eax
  00034	74 0a		 je	 SHORT $LN3@validate_b
  00036	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003e	eb 08		 jmp	 SHORT $LN4@validate_b
$LN3@validate_b:
  00040	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN4@validate_b:
  00048	8b 44 24 20	 mov	 eax, DWORD PTR tv72[rsp]

; 313  : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
validate_body ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@MDELEHKM@None?5disallowed?5in?5expression?5li@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$validate_exprs DD imagerel validate_exprs
	DD	imagerel validate_exprs+179
	DD	imagerel $unwind$validate_exprs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$validate_exprs DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT ??_C@_0CD@MDELEHKM@None?5disallowed?5in?5expression?5li@
CONST	SEGMENT
??_C@_0CD@MDELEHKM@None?5disallowed?5in?5expression?5li@ DB 'None disallo'
	DB	'wed in expression list', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT validate_exprs
_TEXT	SEGMENT
i$ = 32
expr$21842 = 40
tv67 = 48
exprs$ = 80
ctx$ = 88
null_ok$ = 96
validate_exprs PROC					; COMDAT

; 448  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 449  :     int i;
; 450  :     for (i = 0; i < asdl_seq_LEN(exprs); i++) {

  00012	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 0a		 jmp	 SHORT $LN7@validate_e@2
$LN6@validate_e@2:
  0001c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@validate_e@2:
  00026	48 83 7c 24 50
	00		 cmp	 QWORD PTR exprs$[rsp], 0
  0002c	75 0b		 jne	 SHORT $LN10@validate_e@2
  0002e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv67[rsp], 0
  00037	eb 0d		 jmp	 SHORT $LN11@validate_e@2
$LN10@validate_e@2:
  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR exprs$[rsp]
  0003e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00041	48 89 44 24 30	 mov	 QWORD PTR tv67[rsp], rax
$LN11@validate_e@2:
  00046	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004b	48 3b 44 24 30	 cmp	 rax, QWORD PTR tv67[rsp]
  00050	7d 57		 jge	 SHORT $LN5@validate_e@2

; 451  :         expr_ty expr = asdl_seq_GET(exprs, i);

  00052	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR exprs$[rsp]
  0005c	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  00061	48 89 44 24 28	 mov	 QWORD PTR expr$21842[rsp], rax

; 452  :         if (expr) {

  00066	48 83 7c 24 28
	00		 cmp	 QWORD PTR expr$21842[rsp], 0
  0006c	74 18		 je	 SHORT $LN4@validate_e@2

; 453  :             if (!validate_expr(expr, ctx))

  0006e	8b 54 24 58	 mov	 edx, DWORD PTR ctx$[rsp]
  00072	48 8b 4c 24 28	 mov	 rcx, QWORD PTR expr$21842[rsp]
  00077	e8 00 00 00 00	 call	 validate_expr
  0007c	85 c0		 test	 eax, eax
  0007e	75 04		 jne	 SHORT $LN3@validate_e@2

; 454  :                 return 0;

  00080	33 c0		 xor	 eax, eax
  00082	eb 2a		 jmp	 SHORT $LN8@validate_e@2
$LN3@validate_e@2:

; 455  :         }
; 456  :         else if (!null_ok) {

  00084	eb 1e		 jmp	 SHORT $LN2@validate_e@2
$LN4@validate_e@2:
  00086	83 7c 24 60 00	 cmp	 DWORD PTR null_ok$[rsp], 0
  0008b	75 17		 jne	 SHORT $LN1@validate_e@2

; 457  :             PyErr_SetString(PyExc_ValueError,
; 458  :                             "None disallowed in expression list");

  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@MDELEHKM@None?5disallowed?5in?5expression?5li@
  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0009b	e8 00 00 00 00	 call	 PyErr_SetString

; 459  :             return 0;

  000a0	33 c0		 xor	 eax, eax
  000a2	eb 0a		 jmp	 SHORT $LN8@validate_e@2
$LN1@validate_e@2:
$LN2@validate_e@2:

; 460  :         }
; 461  :             
; 462  :     }

  000a4	e9 73 ff ff ff	 jmp	 $LN6@validate_e@2
$LN5@validate_e@2:

; 463  :     return 1;

  000a9	b8 01 00 00 00	 mov	 eax, 1
$LN8@validate_e@2:

; 464  : }

  000ae	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b2	c3		 ret	 0
validate_exprs ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0CD@NFODNNNO@invalid?5node?5?$CFd?5for?5PyAST_FromNo@ ; `string'
PUBLIC	??_C@_1CC@MBELPIFO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA9?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@GEMHJBAF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA9?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@CBHLFNGD@?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@ ; `string'
PUBLIC	??_C@_1CE@KPJLECKA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA8?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_05CAMHEFLG@utf?98?$AA@			; `string'
PUBLIC	PyAST_FromNode
EXTRN	_Py_Interactive:PROC
EXTRN	_Py_Pass:PROC
EXTRN	_Py_Expression:PROC
EXTRN	_Py_Module:PROC
EXTRN	asdl_seq_new:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyAST_FromNode DD imagerel $LN54
	DD	imagerel $LN54+1851
	DD	imagerel $unwind$PyAST_FromNode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyAST_FromNode DD 021b01H
	DD	017011bH
xdata	ENDS
;	COMDAT ??_C@_0CD@NFODNNNO@invalid?5node?5?$CFd?5for?5PyAST_FromNo@
CONST	SEGMENT
??_C@_0CD@NFODNNNO@invalid?5node?5?$CFd?5for?5PyAST_FromNo@ DB 'invalid n'
	DB	'ode %d for PyAST_FromNode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@MBELPIFO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA9?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@MBELPIFO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA9?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '6'
	DB	00H, '9', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@GEMHJBAF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA9?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@GEMHJBAF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA9?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'c', 00H, 'h', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2'
	DB	00H, '6', 00H, '9', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@CBHLFNGD@?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@
CONST	SEGMENT
??_C@_1EG@CBHLFNGD@?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@ DB '('
	DB	00H, 's', 00H, 't', 00H, 'm', 00H, 't', 00H, 's', 00H, ')', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's'
	DB	00H, 'd', 00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, '(', 00H, 's', 00H, 't', 00H, 'm', 00H, 't', 00H, 's'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@KPJLECKA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA8?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@KPJLECKA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA8?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'c', 00H, 'h', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2'
	DB	00H, '6', 00H, '8', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CAMHEFLG@utf?98?$AA@
CONST	SEGMENT
??_C@_05CAMHEFLG@utf?98?$AA@ DB 'utf-8', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyAST_FromNode
_TEXT	SEGMENT
res$ = 32
i$ = 40
s$ = 48
num$ = 56
stmts$ = 64
k$ = 72
c$ = 80
ch$ = 120
j$ = 128
_asdl_i$22379 = 132
_asdl_i$22389 = 136
testlist_ast$22392 = 144
_asdl_i$22397 = 152
_asdl_i$22404 = 156
_asdl_i$22414 = 160
tv75 = 164
n$ = 192
flags$ = 200
filename$ = 208
arena$ = 216
PyAST_FromNode PROC					; COMDAT

; 682  : {

$LN54:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 683  :     int i, j, k, num;
; 684  :     asdl_seq *stmts = NULL;

  0001b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR stmts$[rsp], 0

; 685  :     stmt_ty s;
; 686  :     node *ch;
; 687  :     struct compiling c;
; 688  :     mod_ty res = NULL;

  00024	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR res$[rsp], 0

; 689  : 
; 690  :     c.c_arena = arena;

  0002d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR arena$[rsp]
  00035	48 89 44 24 58	 mov	 QWORD PTR c$[rsp+8], rax

; 691  :     c.c_filename = filename;

  0003a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR filename$[rsp]
  00042	48 89 44 24 60	 mov	 QWORD PTR c$[rsp+16], rax

; 692  :     c.c_normalize = c.c_normalize_args = NULL;

  00047	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR c$[rsp+32], 0
  00050	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp+32]
  00055	48 89 44 24 68	 mov	 QWORD PTR c$[rsp+24], rax

; 693  :     if (flags && flags->cf_flags & PyCF_SOURCE_IS_UTF8) {

  0005a	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR flags$[rsp], 0
  00063	74 47		 je	 SHORT $LN38@PyAST_From
  00065	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR flags$[rsp]
  0006d	8b 00		 mov	 eax, DWORD PTR [rax]
  0006f	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00074	85 c0		 test	 eax, eax
  00076	74 34		 je	 SHORT $LN38@PyAST_From

; 694  :         c.c_encoding = "utf-8";

  00078	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  0007f	48 89 44 24 50	 mov	 QWORD PTR c$[rsp], rax

; 695  :         if (TYPE(n) == encoding_decl) {

  00084	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0008c	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0008f	3d 4f 01 00 00	 cmp	 eax, 335		; 0000014fH
  00094	75 14		 jne	 SHORT $LN37@PyAST_From

; 696  : #if 0
; 697  :             ast_error(c, n, "encoding declaration in Unicode string");
; 698  :             goto out;
; 699  : #endif
; 700  :             n = CHILD(n, 0);

  00096	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0009e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000a2	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR n$[rsp], rax
$LN37@PyAST_From:

; 701  :         }

  000aa	eb 45		 jmp	 SHORT $LN36@PyAST_From
$LN38@PyAST_From:

; 702  :     } else if (TYPE(n) == encoding_decl) {

  000ac	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000b4	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000b7	3d 4f 01 00 00	 cmp	 eax, 335		; 0000014fH
  000bc	75 27		 jne	 SHORT $LN35@PyAST_From

; 703  :         c.c_encoding = STR(n);

  000be	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000c6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ca	48 89 44 24 50	 mov	 QWORD PTR c$[rsp], rax

; 704  :         n = CHILD(n, 0);

  000cf	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000d7	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000db	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 705  :     } else {

  000e3	eb 0c		 jmp	 SHORT $LN34@PyAST_From
$LN35@PyAST_From:

; 706  :         /* PEP 3120 */
; 707  :         c.c_encoding = "utf-8";

  000e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  000ec	48 89 44 24 50	 mov	 QWORD PTR c$[rsp], rax
$LN34@PyAST_From:
$LN36@PyAST_From:

; 708  :     }
; 709  : 
; 710  :     k = 0;

  000f1	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 711  :     switch (TYPE(n)) {

  000f9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00101	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00104	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv75[rsp], eax
  0010b	81 bc 24 a4 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR tv75[rsp], 256 ; 00000100H
  00116	0f 84 e7 02 00
	00		 je	 $LN16@PyAST_From
  0011c	81 bc 24 a4 00
	00 00 01 01 00
	00		 cmp	 DWORD PTR tv75[rsp], 257 ; 00000101H
  00127	74 16		 je	 SHORT $LN31@PyAST_From
  00129	81 bc 24 a4 00
	00 00 02 01 00
	00		 cmp	 DWORD PTR tv75[rsp], 258 ; 00000102H
  00134	0f 84 7c 02 00
	00		 je	 $LN18@PyAST_From
  0013a	e9 a5 05 00 00	 jmp	 $LN2@PyAST_From
$LN31@PyAST_From:

; 712  :         case file_input:
; 713  :             stmts = asdl_seq_new(num_stmts(n), arena);

  0013f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00147	e8 00 00 00 00	 call	 num_stmts
  0014c	48 98		 cdqe
  0014e	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR arena$[rsp]
  00156	48 8b c8	 mov	 rcx, rax
  00159	e8 00 00 00 00	 call	 asdl_seq_new
  0015e	48 89 44 24 40	 mov	 QWORD PTR stmts$[rsp], rax

; 714  :             if (!stmts)

  00163	48 83 7c 24 40
	00		 cmp	 QWORD PTR stmts$[rsp], 0
  00169	75 05		 jne	 SHORT $LN30@PyAST_From

; 715  :                 goto out;

  0016b	e9 95 05 00 00	 jmp	 $out$22370
$LN30@PyAST_From:

; 716  :             for (i = 0; i < NCH(n) - 1; i++) {

  00170	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00178	eb 0a		 jmp	 SHORT $LN29@PyAST_From
$LN28@PyAST_From:
  0017a	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0017e	ff c0		 inc	 eax
  00180	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN29@PyAST_From:
  00184	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0018c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0018f	ff c8		 dec	 eax
  00191	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00195	0f 8d ff 01 00
	00		 jge	 $LN27@PyAST_From

; 717  :                 ch = CHILD(n, i);

  0019b	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  001a0	48 6b c0 28	 imul	 rax, 40			; 00000028H
  001a4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  001ac	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  001b0	48 89 44 24 78	 mov	 QWORD PTR ch$[rsp], rax

; 718  :                 if (TYPE(ch) == NEWLINE)

  001b5	48 8b 44 24 78	 mov	 rax, QWORD PTR ch$[rsp]
  001ba	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001bd	83 f8 04	 cmp	 eax, 4
  001c0	75 02		 jne	 SHORT $LN26@PyAST_From

; 719  :                     continue;

  001c2	eb b6		 jmp	 SHORT $LN28@PyAST_From
$LN26@PyAST_From:

; 720  :                 REQ(ch, stmt);

  001c4	48 8b 44 24 78	 mov	 rax, QWORD PTR ch$[rsp]
  001c9	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001cc	3d 0c 01 00 00	 cmp	 eax, 268		; 0000010cH
  001d1	74 1c		 je	 SHORT $LN41@PyAST_From
  001d3	41 b8 d0 02 00
	00		 mov	 r8d, 720		; 000002d0H
  001d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@KPJLECKA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA8?$AA?$CJ?$AA?$AA@
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001ed	33 c0		 xor	 eax, eax
$LN41@PyAST_From:

; 721  :                 num = num_stmts(ch);

  001ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ch$[rsp]
  001f4	e8 00 00 00 00	 call	 num_stmts
  001f9	89 44 24 38	 mov	 DWORD PTR num$[rsp], eax

; 722  :                 if (num == 1) {

  001fd	83 7c 24 38 01	 cmp	 DWORD PTR num$[rsp], 1
  00202	0f 85 88 00 00
	00		 jne	 $LN25@PyAST_From

; 723  :                     s = ast_for_stmt(&c, ch);

  00208	48 8b 54 24 78	 mov	 rdx, QWORD PTR ch$[rsp]
  0020d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  00212	e8 00 00 00 00	 call	 ast_for_stmt
  00217	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 724  :                     if (!s)

  0021c	48 83 7c 24 30
	00		 cmp	 QWORD PTR s$[rsp], 0
  00222	75 05		 jne	 SHORT $LN24@PyAST_From

; 725  :                         goto out;

  00224	e9 dc 04 00 00	 jmp	 $out$22370
$LN24@PyAST_From:

; 726  :                     asdl_seq_SET(stmts, k++, s);

  00229	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  0022d	89 84 24 84 00
	00 00		 mov	 DWORD PTR _asdl_i$22379[rsp], eax
  00234	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  00238	ff c0		 inc	 eax
  0023a	89 44 24 48	 mov	 DWORD PTR k$[rsp], eax
  0023e	48 83 7c 24 40
	00		 cmp	 QWORD PTR stmts$[rsp], 0
  00244	74 12		 je	 SHORT $LN42@PyAST_From
  00246	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22379[rsp]
  0024e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  00253	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00256	7c 1c		 jl	 SHORT $LN43@PyAST_From
$LN42@PyAST_From:
  00258	41 b8 d6 02 00
	00		 mov	 r8d, 726		; 000002d6H
  0025e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00265	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@CBHLFNGD@?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00272	33 c0		 xor	 eax, eax
$LN43@PyAST_From:
  00274	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22379[rsp]
  0027c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  00281	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  00286	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 727  :                 }
; 728  :                 else {

  0028b	e9 05 01 00 00	 jmp	 $LN23@PyAST_From
$LN25@PyAST_From:

; 729  :                     ch = CHILD(ch, 0);

  00290	48 8b 44 24 78	 mov	 rax, QWORD PTR ch$[rsp]
  00295	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00299	48 89 44 24 78	 mov	 QWORD PTR ch$[rsp], rax

; 730  :                     REQ(ch, simple_stmt);

  0029e	48 8b 44 24 78	 mov	 rax, QWORD PTR ch$[rsp]
  002a3	0f bf 00	 movsx	 eax, WORD PTR [rax]
  002a6	3d 0d 01 00 00	 cmp	 eax, 269		; 0000010dH
  002ab	74 1c		 je	 SHORT $LN44@PyAST_From
  002ad	41 b8 da 02 00
	00		 mov	 r8d, 730		; 000002daH
  002b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  002ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@GEMHJBAF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA9?$AA?$CJ?$AA?$AA@
  002c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002c7	33 c0		 xor	 eax, eax
$LN44@PyAST_From:

; 731  :                     for (j = 0; j < num; j++) {

  002c9	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  002d4	eb 10		 jmp	 SHORT $LN22@PyAST_From
$LN21@PyAST_From:
  002d6	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  002dd	ff c0		 inc	 eax
  002df	89 84 24 80 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN22@PyAST_From:
  002e6	8b 44 24 38	 mov	 eax, DWORD PTR num$[rsp]
  002ea	39 84 24 80 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  002f1	0f 8d 9e 00 00
	00		 jge	 $LN20@PyAST_From

; 732  :                         s = ast_for_stmt(&c, CHILD(ch, j * 2));

  002f7	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  002fe	d1 e0		 shl	 eax, 1
  00300	48 98		 cdqe
  00302	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00306	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ch$[rsp]
  0030b	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0030f	48 8b d0	 mov	 rdx, rax
  00312	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  00317	e8 00 00 00 00	 call	 ast_for_stmt
  0031c	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 733  :                         if (!s)

  00321	48 83 7c 24 30
	00		 cmp	 QWORD PTR s$[rsp], 0
  00327	75 05		 jne	 SHORT $LN19@PyAST_From

; 734  :                             goto out;

  00329	e9 d7 03 00 00	 jmp	 $out$22370
$LN19@PyAST_From:

; 735  :                         asdl_seq_SET(stmts, k++, s);

  0032e	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  00332	89 84 24 88 00
	00 00		 mov	 DWORD PTR _asdl_i$22389[rsp], eax
  00339	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  0033d	ff c0		 inc	 eax
  0033f	89 44 24 48	 mov	 DWORD PTR k$[rsp], eax
  00343	48 83 7c 24 40
	00		 cmp	 QWORD PTR stmts$[rsp], 0
  00349	74 12		 je	 SHORT $LN45@PyAST_From
  0034b	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22389[rsp]
  00353	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  00358	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  0035b	7c 1c		 jl	 SHORT $LN46@PyAST_From
$LN45@PyAST_From:
  0035d	41 b8 df 02 00
	00		 mov	 r8d, 735		; 000002dfH
  00363	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0036a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@CBHLFNGD@?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@
  00371	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00377	33 c0		 xor	 eax, eax
$LN46@PyAST_From:
  00379	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22389[rsp]
  00381	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  00386	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  0038b	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 736  :                     }

  00390	e9 41 ff ff ff	 jmp	 $LN21@PyAST_From
$LN20@PyAST_From:
$LN23@PyAST_From:

; 737  :                 }
; 738  :             }

  00395	e9 e0 fd ff ff	 jmp	 $LN28@PyAST_From
$LN27@PyAST_From:

; 739  :             res = Module(stmts, arena);

  0039a	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR arena$[rsp]
  003a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  003a7	e8 00 00 00 00	 call	 _Py_Module
  003ac	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 740  :             break;

  003b1	e9 4f 03 00 00	 jmp	 $LN32@PyAST_From
$LN18@PyAST_From:

; 741  :         case eval_input: {
; 742  :             expr_ty testlist_ast;
; 743  : 
; 744  :             /* XXX Why not comp_for here? */
; 745  :             testlist_ast = ast_for_testlist(&c, CHILD(n, 0));

  003b6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003be	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  003c2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  003c7	e8 00 00 00 00	 call	 ast_for_testlist
  003cc	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR testlist_ast$22392[rsp], rax

; 746  :             if (!testlist_ast)

  003d4	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR testlist_ast$22392[rsp], 0
  003dd	75 05		 jne	 SHORT $LN17@PyAST_From

; 747  :                 goto out;

  003df	e9 21 03 00 00	 jmp	 $out$22370
$LN17@PyAST_From:

; 748  :             res = Expression(testlist_ast, arena);

  003e4	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR arena$[rsp]
  003ec	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR testlist_ast$22392[rsp]
  003f4	e8 00 00 00 00	 call	 _Py_Expression
  003f9	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 749  :             break;

  003fe	e9 02 03 00 00	 jmp	 $LN32@PyAST_From
$LN16@PyAST_From:

; 750  :         }
; 751  :         case single_input:
; 752  :             if (TYPE(CHILD(n, 0)) == NEWLINE) {

  00403	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0040b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0040f	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00412	83 f8 04	 cmp	 eax, 4
  00415	0f 85 c7 00 00
	00		 jne	 $LN15@PyAST_From

; 753  :                 stmts = asdl_seq_new(1, arena);

  0041b	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR arena$[rsp]
  00423	b9 01 00 00 00	 mov	 ecx, 1
  00428	e8 00 00 00 00	 call	 asdl_seq_new
  0042d	48 89 44 24 40	 mov	 QWORD PTR stmts$[rsp], rax

; 754  :                 if (!stmts)

  00432	48 83 7c 24 40
	00		 cmp	 QWORD PTR stmts$[rsp], 0
  00438	75 05		 jne	 SHORT $LN14@PyAST_From

; 755  :                     goto out;

  0043a	e9 c6 02 00 00	 jmp	 $out$22370
$LN14@PyAST_From:

; 756  :                 asdl_seq_SET(stmts, 0, Pass(n->n_lineno, n->n_col_offset,
; 757  :                                             arena));

  0043f	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _asdl_i$22397[rsp], 0
  0044a	48 83 7c 24 40
	00		 cmp	 QWORD PTR stmts$[rsp], 0
  00450	74 12		 je	 SHORT $LN47@PyAST_From
  00452	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22397[rsp]
  0045a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  0045f	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00462	7c 1c		 jl	 SHORT $LN48@PyAST_From
$LN47@PyAST_From:
  00464	41 b8 f5 02 00
	00		 mov	 r8d, 757		; 000002f5H
  0046a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00471	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@CBHLFNGD@?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@
  00478	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0047e	33 c0		 xor	 eax, eax
$LN48@PyAST_From:
  00480	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR arena$[rsp]
  00488	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00490	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00493	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0049b	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  0049e	e8 00 00 00 00	 call	 _Py_Pass
  004a3	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR _asdl_i$22397[rsp]
  004ab	48 8b 54 24 40	 mov	 rdx, QWORD PTR stmts$[rsp]
  004b0	48 89 44 ca 08	 mov	 QWORD PTR [rdx+rcx*8+8], rax

; 758  :                 if (!asdl_seq_GET(stmts, 0))

  004b5	48 8b 44 24 40	 mov	 rax, QWORD PTR stmts$[rsp]
  004ba	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  004bf	75 05		 jne	 SHORT $LN13@PyAST_From

; 759  :                     goto out;

  004c1	e9 3f 02 00 00	 jmp	 $out$22370
$LN13@PyAST_From:

; 760  :                 res = Interactive(stmts, arena);

  004c6	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR arena$[rsp]
  004ce	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  004d3	e8 00 00 00 00	 call	 _Py_Interactive
  004d8	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 761  :             }
; 762  :             else {

  004dd	e9 00 02 00 00	 jmp	 $LN12@PyAST_From
$LN15@PyAST_From:

; 763  :                 n = CHILD(n, 0);

  004e2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  004ea	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  004ee	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 764  :                 num = num_stmts(n);

  004f6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  004fe	e8 00 00 00 00	 call	 num_stmts
  00503	89 44 24 38	 mov	 DWORD PTR num$[rsp], eax

; 765  :                 stmts = asdl_seq_new(num, arena);

  00507	48 63 44 24 38	 movsxd	 rax, DWORD PTR num$[rsp]
  0050c	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR arena$[rsp]
  00514	48 8b c8	 mov	 rcx, rax
  00517	e8 00 00 00 00	 call	 asdl_seq_new
  0051c	48 89 44 24 40	 mov	 QWORD PTR stmts$[rsp], rax

; 766  :                 if (!stmts)

  00521	48 83 7c 24 40
	00		 cmp	 QWORD PTR stmts$[rsp], 0
  00527	75 05		 jne	 SHORT $LN11@PyAST_From

; 767  :                     goto out;

  00529	e9 d7 01 00 00	 jmp	 $out$22370
$LN11@PyAST_From:

; 768  :                 if (num == 1) {

  0052e	83 7c 24 38 01	 cmp	 DWORD PTR num$[rsp], 1
  00533	0f 85 81 00 00
	00		 jne	 $LN10@PyAST_From

; 769  :                     s = ast_for_stmt(&c, n);

  00539	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  00541	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  00546	e8 00 00 00 00	 call	 ast_for_stmt
  0054b	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 770  :                     if (!s)

  00550	48 83 7c 24 30
	00		 cmp	 QWORD PTR s$[rsp], 0
  00556	75 05		 jne	 SHORT $LN9@PyAST_From

; 771  :                         goto out;

  00558	e9 a8 01 00 00	 jmp	 $out$22370
$LN9@PyAST_From:

; 772  :                     asdl_seq_SET(stmts, 0, s);

  0055d	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _asdl_i$22404[rsp], 0
  00568	48 83 7c 24 40
	00		 cmp	 QWORD PTR stmts$[rsp], 0
  0056e	74 12		 je	 SHORT $LN49@PyAST_From
  00570	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22404[rsp]
  00578	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  0057d	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00580	7c 1c		 jl	 SHORT $LN50@PyAST_From
$LN49@PyAST_From:
  00582	41 b8 04 03 00
	00		 mov	 r8d, 772		; 00000304H
  00588	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0058f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@CBHLFNGD@?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@
  00596	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0059c	33 c0		 xor	 eax, eax
$LN50@PyAST_From:
  0059e	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22404[rsp]
  005a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  005ab	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  005b0	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 773  :                 }
; 774  :                 else {

  005b5	e9 11 01 00 00	 jmp	 $LN8@PyAST_From
$LN10@PyAST_From:

; 775  :                     /* Only a simple_stmt can contain multiple statements. */
; 776  :                     REQ(n, simple_stmt);

  005ba	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  005c2	0f bf 00	 movsx	 eax, WORD PTR [rax]
  005c5	3d 0d 01 00 00	 cmp	 eax, 269		; 0000010dH
  005ca	74 1c		 je	 SHORT $LN51@PyAST_From
  005cc	41 b8 08 03 00
	00		 mov	 r8d, 776		; 00000308H
  005d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  005d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MBELPIFO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA9?$AA?$CJ?$AA?$AA@
  005e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005e6	33 c0		 xor	 eax, eax
$LN51@PyAST_From:

; 777  :                     for (i = 0; i < NCH(n); i += 2) {

  005e8	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005f0	eb 0b		 jmp	 SHORT $LN7@PyAST_From
$LN6@PyAST_From:
  005f2	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  005f6	83 c0 02	 add	 eax, 2
  005f9	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN7@PyAST_From:
  005fd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00605	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00608	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0060c	0f 8d b9 00 00
	00		 jge	 $LN5@PyAST_From

; 778  :                         if (TYPE(CHILD(n, i)) == NEWLINE)

  00612	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00617	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0061b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00623	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00627	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0062b	83 f8 04	 cmp	 eax, 4
  0062e	75 05		 jne	 SHORT $LN4@PyAST_From

; 779  :                             break;

  00630	e9 96 00 00 00	 jmp	 $LN5@PyAST_From
$LN4@PyAST_From:

; 780  :                         s = ast_for_stmt(&c, CHILD(n, i));

  00635	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0063a	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0063e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00646	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0064a	48 8b d0	 mov	 rdx, rax
  0064d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  00652	e8 00 00 00 00	 call	 ast_for_stmt
  00657	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 781  :                         if (!s)

  0065c	48 83 7c 24 30
	00		 cmp	 QWORD PTR s$[rsp], 0
  00662	75 05		 jne	 SHORT $LN3@PyAST_From

; 782  :                             goto out;

  00664	e9 9c 00 00 00	 jmp	 $out$22370
$LN3@PyAST_From:

; 783  :                         asdl_seq_SET(stmts, i / 2, s);

  00669	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0066d	99		 cdq
  0066e	2b c2		 sub	 eax, edx
  00670	d1 f8		 sar	 eax, 1
  00672	89 84 24 a0 00
	00 00		 mov	 DWORD PTR _asdl_i$22414[rsp], eax
  00679	48 83 7c 24 40
	00		 cmp	 QWORD PTR stmts$[rsp], 0
  0067f	74 12		 je	 SHORT $LN52@PyAST_From
  00681	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22414[rsp]
  00689	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  0068e	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00691	7c 1c		 jl	 SHORT $LN53@PyAST_From
$LN52@PyAST_From:
  00693	41 b8 0f 03 00
	00		 mov	 r8d, 783		; 0000030fH
  00699	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  006a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@CBHLFNGD@?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@
  006a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006ad	33 c0		 xor	 eax, eax
$LN53@PyAST_From:
  006af	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22414[rsp]
  006b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  006bc	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  006c1	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 784  :                     }

  006c6	e9 27 ff ff ff	 jmp	 $LN6@PyAST_From
$LN5@PyAST_From:
$LN8@PyAST_From:

; 785  :                 }
; 786  : 
; 787  :                 res = Interactive(stmts, arena);

  006cb	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR arena$[rsp]
  006d3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stmts$[rsp]
  006d8	e8 00 00 00 00	 call	 _Py_Interactive
  006dd	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax
$LN12@PyAST_From:

; 788  :             }
; 789  :             break;

  006e2	eb 21		 jmp	 SHORT $LN32@PyAST_From
$LN2@PyAST_From:

; 790  :         default:
; 791  :             PyErr_Format(PyExc_SystemError,
; 792  :                          "invalid node %d for PyAST_FromNode", TYPE(n));

  006e4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  006ec	0f bf 00	 movsx	 eax, WORD PTR [rax]
  006ef	44 8b c0	 mov	 r8d, eax
  006f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@NFODNNNO@invalid?5node?5?$CFd?5for?5PyAST_FromNo@
  006f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00700	e8 00 00 00 00	 call	 PyErr_Format
$LN32@PyAST_From:
$out$22370:

; 793  :             goto out;
; 794  :     }
; 795  :  out:
; 796  :     if (c.c_normalize) {

  00705	48 83 7c 24 68
	00		 cmp	 QWORD PTR c$[rsp+24], 0
  0070b	74 21		 je	 SHORT $LN1@PyAST_From

; 797  :         Py_DECREF(c.c_normalize);

  0070d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR c$[rsp+24]
  00712	e8 00 00 00 00	 call	 _Py_DecRef

; 798  :         PyTuple_SET_ITEM(c.c_normalize_args, 1, NULL);

  00717	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp+32]
  0071c	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 799  :         Py_DECREF(c.c_normalize_args);

  00724	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp+32]
  00729	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyAST_From:

; 800  :     }
; 801  :     return res;

  0072e	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]

; 802  : }

  00733	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0073a	c3		 ret	 0
PyAST_FromNode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@JJDIMLMN@Non?9statement?5found?3?5?$CFd?5?$CFd?$AA@ ; `string'
EXTRN	Py_FatalError:PROC
EXTRN	__imp_sprintf:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\ast.c
pdata	SEGMENT
$pdata$num_stmts DD imagerel num_stmts
	DD	imagerel num_stmts+630
	DD	imagerel $unwind$num_stmts
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$num_stmts DD 020c01H
	DD	019010cH
xdata	ENDS
;	COMDAT ??_C@_0BL@JJDIMLMN@Non?9statement?5found?3?5?$CFd?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@JJDIMLMN@Non?9statement?5found?3?5?$CFd?5?$CFd?$AA@ DB 'Non-sta'
	DB	'tement found: %d %d', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT num_stmts
_TEXT	SEGMENT
i$ = 32
l$ = 36
ch$ = 40
buf$22334 = 48
tv65 = 176
n$ = 208
num_stmts PROC						; COMDAT

; 631  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 632  :     int i, l;
; 633  :     node *ch;
; 634  : 
; 635  :     switch (TYPE(n)) {

  0000c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00014	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00017	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  0001e	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv65[rsp]
  00025	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  0002a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00031	83 bc 24 b0 00
	00 00 2d	 cmp	 DWORD PTR tv65[rsp], 45	; 0000002dH
  00039	0f 87 88 01 00
	00		 ja	 $LN1@num_stmts
  0003f	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv65[rsp]
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0004e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN24@num_stmts[rcx+rax]
  00056	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN25@num_stmts[rcx+rax*4]
  0005d	48 03 c1	 add	 rax, rcx
  00060	ff e0		 jmp	 rax
$LN18@num_stmts:

; 636  :         case single_input:
; 637  :             if (TYPE(CHILD(n, 0)) == NEWLINE)

  00062	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0006a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0006e	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00071	83 f8 04	 cmp	 eax, 4
  00074	75 09		 jne	 SHORT $LN17@num_stmts

; 638  :                 return 0;

  00076	33 c0		 xor	 eax, eax
  00078	e9 a4 01 00 00	 jmp	 $LN21@num_stmts

; 639  :             else

  0007d	eb 16		 jmp	 SHORT $LN16@num_stmts
$LN17@num_stmts:

; 640  :                 return num_stmts(CHILD(n, 0));

  0007f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00087	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0008b	e8 00 00 00 00	 call	 num_stmts
  00090	e9 8c 01 00 00	 jmp	 $LN21@num_stmts
$LN16@num_stmts:
$LN15@num_stmts:

; 641  :         case file_input:
; 642  :             l = 0;

  00095	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR l$[rsp], 0

; 643  :             for (i = 0; i < NCH(n); i++) {

  0009d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000a5	eb 0a		 jmp	 SHORT $LN14@num_stmts
$LN13@num_stmts:
  000a7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000ab	ff c0		 inc	 eax
  000ad	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN14@num_stmts:
  000b1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000b9	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000bc	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000c0	7d 41		 jge	 SHORT $LN12@num_stmts

; 644  :                 ch = CHILD(n, i);

  000c2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000c7	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000cb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  000d3	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000d7	48 89 44 24 28	 mov	 QWORD PTR ch$[rsp], rax

; 645  :                 if (TYPE(ch) == stmt)

  000dc	48 8b 44 24 28	 mov	 rax, QWORD PTR ch$[rsp]
  000e1	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000e4	3d 0c 01 00 00	 cmp	 eax, 268		; 0000010cH
  000e9	75 16		 jne	 SHORT $LN11@num_stmts

; 646  :                     l += num_stmts(ch);

  000eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ch$[rsp]
  000f0	e8 00 00 00 00	 call	 num_stmts
  000f5	8b 4c 24 24	 mov	 ecx, DWORD PTR l$[rsp]
  000f9	03 c8		 add	 ecx, eax
  000fb	8b c1		 mov	 eax, ecx
  000fd	89 44 24 24	 mov	 DWORD PTR l$[rsp], eax
$LN11@num_stmts:

; 647  :             }

  00101	eb a4		 jmp	 SHORT $LN13@num_stmts
$LN12@num_stmts:

; 648  :             return l;

  00103	8b 44 24 24	 mov	 eax, DWORD PTR l$[rsp]
  00107	e9 15 01 00 00	 jmp	 $LN21@num_stmts
$LN10@num_stmts:

; 649  :         case stmt:
; 650  :             return num_stmts(CHILD(n, 0));

  0010c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00114	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00118	e8 00 00 00 00	 call	 num_stmts
  0011d	e9 ff 00 00 00	 jmp	 $LN21@num_stmts
$LN9@num_stmts:

; 651  :         case compound_stmt:
; 652  :             return 1;

  00122	b8 01 00 00 00	 mov	 eax, 1
  00127	e9 f5 00 00 00	 jmp	 $LN21@num_stmts
$LN8@num_stmts:

; 653  :         case simple_stmt:
; 654  :             return NCH(n) / 2; /* Divide by 2 to remove count of semi-colons */

  0012c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00134	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00137	99		 cdq
  00138	2b c2		 sub	 eax, edx
  0013a	d1 f8		 sar	 eax, 1
  0013c	e9 e0 00 00 00	 jmp	 $LN21@num_stmts
$LN7@num_stmts:

; 655  :         case suite:
; 656  :             if (NCH(n) == 1)

  00141	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00149	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  0014d	75 18		 jne	 SHORT $LN6@num_stmts

; 657  :                 return num_stmts(CHILD(n, 0));

  0014f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00157	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0015b	e8 00 00 00 00	 call	 num_stmts
  00160	e9 bc 00 00 00	 jmp	 $LN21@num_stmts

; 658  :             else {

  00165	eb 60		 jmp	 SHORT $LN5@num_stmts
$LN6@num_stmts:

; 659  :                 l = 0;

  00167	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR l$[rsp], 0

; 660  :                 for (i = 2; i < (NCH(n) - 1); i++)

  0016f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR i$[rsp], 2
  00177	eb 0a		 jmp	 SHORT $LN4@num_stmts
$LN3@num_stmts:
  00179	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0017d	ff c0		 inc	 eax
  0017f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@num_stmts:
  00183	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0018b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0018e	ff c8		 dec	 eax
  00190	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00194	7d 2b		 jge	 SHORT $LN2@num_stmts

; 661  :                     l += num_stmts(CHILD(n, i));

  00196	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0019b	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0019f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  001a7	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  001ab	48 8b c8	 mov	 rcx, rax
  001ae	e8 00 00 00 00	 call	 num_stmts
  001b3	8b 4c 24 24	 mov	 ecx, DWORD PTR l$[rsp]
  001b7	03 c8		 add	 ecx, eax
  001b9	8b c1		 mov	 eax, ecx
  001bb	89 44 24 24	 mov	 DWORD PTR l$[rsp], eax
  001bf	eb b8		 jmp	 SHORT $LN3@num_stmts
$LN2@num_stmts:

; 662  :                 return l;

  001c1	8b 44 24 24	 mov	 eax, DWORD PTR l$[rsp]
  001c5	eb 5a		 jmp	 SHORT $LN21@num_stmts
$LN5@num_stmts:
$LN1@num_stmts:

; 663  :             }
; 664  :         default: {
; 665  :             char buf[128];
; 666  : 
; 667  :             sprintf(buf, "Non-statement found: %d %d",
; 668  :                     TYPE(n), NCH(n));

  001c7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001cf	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001d2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  001da	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  001de	44 8b c0	 mov	 r8d, eax
  001e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@JJDIMLMN@Non?9statement?5found?3?5?$CFd?5?$CFd?$AA@
  001e8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$22334[rsp]
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 669  :             Py_FatalError(buf);

  001f3	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$22334[rsp]
  001f8	e8 00 00 00 00	 call	 Py_FatalError

; 670  :         }
; 671  :     }
; 672  :     assert(0);

  001fd	33 c0		 xor	 eax, eax
  001ff	85 c0		 test	 eax, eax
  00201	75 1c		 jne	 SHORT $LN23@num_stmts
  00203	41 b8 a0 02 00
	00		 mov	 r8d, 672		; 000002a0H
  00209	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  00217	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0021d	33 c0		 xor	 eax, eax
$LN23@num_stmts:

; 673  :     return 0;

  0021f	33 c0		 xor	 eax, eax
$LN21@num_stmts:

; 674  : }

  00221	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00228	c3		 ret	 0
  00229	0f 1f 00	 npad	 3
$LN25@num_stmts:
  0022c	00 00 00 00	 DD	 $LN18@num_stmts
  00230	00 00 00 00	 DD	 $LN15@num_stmts
  00234	00 00 00 00	 DD	 $LN10@num_stmts
  00238	00 00 00 00	 DD	 $LN8@num_stmts
  0023c	00 00 00 00	 DD	 $LN9@num_stmts
  00240	00 00 00 00	 DD	 $LN7@num_stmts
  00244	00 00 00 00	 DD	 $LN1@num_stmts
$LN24@num_stmts:
  00248	00		 DB	 0
  00249	01		 DB	 1
  0024a	06		 DB	 6
  0024b	06		 DB	 6
  0024c	06		 DB	 6
  0024d	06		 DB	 6
  0024e	06		 DB	 6
  0024f	06		 DB	 6
  00250	06		 DB	 6
  00251	06		 DB	 6
  00252	06		 DB	 6
  00253	06		 DB	 6
  00254	02		 DB	 2
  00255	03		 DB	 3
  00256	06		 DB	 6
  00257	06		 DB	 6
  00258	06		 DB	 6
  00259	06		 DB	 6
  0025a	06		 DB	 6
  0025b	06		 DB	 6
  0025c	06		 DB	 6
  0025d	06		 DB	 6
  0025e	06		 DB	 6
  0025f	06		 DB	 6
  00260	06		 DB	 6
  00261	06		 DB	 6
  00262	06		 DB	 6
  00263	06		 DB	 6
  00264	06		 DB	 6
  00265	06		 DB	 6
  00266	06		 DB	 6
  00267	06		 DB	 6
  00268	06		 DB	 6
  00269	06		 DB	 6
  0026a	06		 DB	 6
  0026b	06		 DB	 6
  0026c	06		 DB	 6
  0026d	04		 DB	 4
  0026e	06		 DB	 6
  0026f	06		 DB	 6
  00270	06		 DB	 6
  00271	06		 DB	 6
  00272	06		 DB	 6
  00273	06		 DB	 6
  00274	06		 DB	 6
  00275	05		 DB	 5
num_stmts ENDP
_TEXT	ENDS
PUBLIC	??_C@_1GK@PMMCKDID@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@ ; `string'
PUBLIC	??_C@_1DM@PIHOGFBG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAc?$AAo?$AAm?$AAp?$AA_?$AAf?$AAo?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@OPMIECBC@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
EXTRN	_Py_Tuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_testlist DD imagerel ast_for_testlist
	DD	imagerel ast_for_testlist+305
	DD	imagerel $unwind$ast_for_testlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_testlist DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1GK@PMMCKDID@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@
CONST	SEGMENT
??_C@_1GK@PMMCKDID@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't', 00H, 'e', 00H, 's'
	DB	00H, 't', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E'
	DB	00H, '(', 00H, 'n', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 't', 00H, 'e', 00H, 's', 00H, 't', 00H, 'l', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'r', 00H, '_', 00H, 'e', 00H, 'x', 00H, 'p', 00H, 'r', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@PIHOGFBG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAc?$AAo?$AAm?$AAp?$AA_?$AAf?$AAo?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@PIHOGFBG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAc?$AAo?$AAm?$AAp?$AA_?$AAf?$AAo?$AAr?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'C', 00H, 'H', 00H
	DB	'I', 00H, 'L', 00H, 'D', 00H, '(', 00H, 'n', 00H, ',', 00H, ' '
	DB	00H, '1', 00H, ')', 00H, ')', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, '_', 00H, 'f'
	DB	00H, 'o', 00H, 'r', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@OPMIECBC@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@OPMIECBC@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'N'
	DB	00H, 'C', 00H, 'H', 00H, '(', 00H, 'n', 00H, ')', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_testlist
_TEXT	SEGMENT
tmp$23686 = 48
c$ = 80
n$ = 88
ast_for_testlist PROC					; COMDAT

; 2536 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2537 :     /* testlist_comp: test (comp_for | (',' test)* [',']) */
; 2538 :     /* testlist: test (',' test)* [','] */
; 2539 :     assert(NCH(n) > 0);

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00013	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00017	7f 1c		 jg	 SHORT $LN9@ast_for_te
  00019	41 b8 eb 09 00
	00		 mov	 r8d, 2539		; 000009ebH
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@OPMIECBC@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00033	33 c0		 xor	 eax, eax
$LN9@ast_for_te:

; 2540 :     if (TYPE(n) == testlist_comp) {

  00035	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0003a	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0003d	3d 41 01 00 00	 cmp	 eax, 321		; 00000141H
  00042	75 3d		 jne	 SHORT $LN6@ast_for_te

; 2541 :         if (NCH(n) > 1)

  00044	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00049	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  0004d	7e 30		 jle	 SHORT $LN5@ast_for_te

; 2542 :             assert(TYPE(CHILD(n, 1)) != comp_for);

  0004f	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00054	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00058	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  0005c	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  00061	75 1c		 jne	 SHORT $LN10@ast_for_te
  00063	41 b8 ee 09 00
	00		 mov	 r8d, 2542		; 000009eeH
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@PIHOGFBG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAc?$AAo?$AAm?$AAp?$AA_?$AAf?$AAo?$AAr?$AA?$AA@
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007d	33 c0		 xor	 eax, eax
$LN10@ast_for_te:
$LN5@ast_for_te:

; 2543 :     }
; 2544 :     else {

  0007f	eb 3a		 jmp	 SHORT $LN4@ast_for_te
$LN6@ast_for_te:

; 2545 :         assert(TYPE(n) == testlist ||
; 2546 :                TYPE(n) == testlist_star_expr);

  00081	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00086	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00089	3d 47 01 00 00	 cmp	 eax, 327		; 00000147H
  0008e	74 2b		 je	 SHORT $LN11@ast_for_te
  00090	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00095	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00098	3d 10 01 00 00	 cmp	 eax, 272		; 00000110H
  0009d	74 1c		 je	 SHORT $LN11@ast_for_te
  0009f	41 b8 f2 09 00
	00		 mov	 r8d, 2546		; 000009f2H
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GK@PMMCKDID@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b9	33 c0		 xor	 eax, eax
$LN11@ast_for_te:
$LN4@ast_for_te:

; 2547 :     }
; 2548 :     if (NCH(n) == 1)

  000bb	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000c0	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  000c4	75 17		 jne	 SHORT $LN3@ast_for_te

; 2549 :         return ast_for_expr(c, CHILD(n, 0));

  000c6	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000cb	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  000cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000d4	e8 00 00 00 00	 call	 ast_for_expr
  000d9	eb 51		 jmp	 SHORT $LN7@ast_for_te

; 2550 :     else {

  000db	eb 4f		 jmp	 SHORT $LN2@ast_for_te
$LN3@ast_for_te:

; 2551 :         asdl_seq *tmp = seq_for_testlist(c, n);

  000dd	48 8b 54 24 58	 mov	 rdx, QWORD PTR n$[rsp]
  000e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000e7	e8 00 00 00 00	 call	 seq_for_testlist
  000ec	48 89 44 24 30	 mov	 QWORD PTR tmp$23686[rsp], rax

; 2552 :         if (!tmp)

  000f1	48 83 7c 24 30
	00		 cmp	 QWORD PTR tmp$23686[rsp], 0
  000f7	75 04		 jne	 SHORT $LN1@ast_for_te

; 2553 :             return NULL;

  000f9	33 c0		 xor	 eax, eax
  000fb	eb 2f		 jmp	 SHORT $LN7@ast_for_te
$LN1@ast_for_te:

; 2554 :         return Tuple(tmp, Load, LINENO(n), n->n_col_offset, c->c_arena);

  000fd	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  00102	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00106	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010b	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00110	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  00114	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00119	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  0011d	ba 01 00 00 00	 mov	 edx, 1
  00122	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp$23686[rsp]
  00127	e8 00 00 00 00	 call	 _Py_Tuple
$LN2@ast_for_te:
$LN7@ast_for_te:

; 2555 :     }
; 2556 : }

  0012c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00130	c3		 ret	 0
ast_for_testlist ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DO@GCGEEMDH@?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@GDDEIKJM@?$AAi?$AA?5?$AA?1?$AA?5?$AA2?$AA?5?$AA?$DM?$AA?5?$AAs?$AAe?$AAq?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1IK@OOGJNEEH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ ; `string'
PUBLIC	??_C@_1KC@EEMNIDCK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$seq_for_testlist DD imagerel seq_for_testlist
	DD	imagerel seq_for_testlist+459
	DD	imagerel $unwind$seq_for_testlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$seq_for_testlist DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1DO@GCGEEMDH@?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@GCGEEMDH@?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB '('
	DB	00H, 's', 00H, 'e', 00H, 'q', 00H, ')', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's', 00H, 'd', 00H, 'l'
	DB	00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H
	DB	's', 00H, 'e', 00H, 'q', 00H, ')', 00H, '-', 00H, '>', 00H, 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@GDDEIKJM@?$AAi?$AA?5?$AA?1?$AA?5?$AA2?$AA?5?$AA?$DM?$AA?5?$AAs?$AAe?$AAq?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@GDDEIKJM@?$AAi?$AA?5?$AA?1?$AA?5?$AA2?$AA?5?$AA?$DM?$AA?5?$AAs?$AAe?$AAq?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'i'
	DB	00H, ' ', 00H, '/', 00H, ' ', 00H, '2', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 's', 00H, 'e', 00H, 'q', 00H, '-', 00H, '>', 00H, 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1IK@OOGJNEEH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1IK@OOGJNEEH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'c', 00H, 'h', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H
	DB	'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'c', 00H, 'h'
	DB	00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't', 00H
	DB	'e', 00H, 's', 00H, 't', 00H, '_', 00H, 'n', 00H, 'o', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 'd', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'c'
	DB	00H, 'h', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	's', 00H, 't', 00H, 'a', 00H, 'r', 00H, '_', 00H, 'e', 00H, 'x'
	DB	00H, 'p', 00H, 'r', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1KC@EEMNIDCK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@
CONST	SEGMENT
??_C@_1KC@EEMNIDCK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't', 00H, 'e', 00H, 's'
	DB	00H, 't', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E'
	DB	00H, '(', 00H, 'n', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 't', 00H, 'e', 00H, 's', 00H, 't', 00H, 'l', 00H, 'i'
	DB	00H, 's', 00H, 't', 00H, '_', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'r', 00H, '_', 00H, 'e', 00H, 'x', 00H, 'p', 00H, 'r', 00H, ' '
	DB	00H, '|', 00H, '|', 00H, ' ', 00H, 'T', 00H, 'Y', 00H, 'P', 00H
	DB	'E', 00H, '(', 00H, 'n', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 't', 00H, 'e', 00H, 's', 00H, 't', 00H, 'l', 00H
	DB	'i', 00H, 's', 00H, 't', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm'
	DB	00H, 'p', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT seq_for_testlist
_TEXT	SEGMENT
i$ = 32
expression$ = 40
seq$ = 48
ch$22629 = 56
_asdl_i$22636 = 64
c$ = 96
n$ = 104
seq_for_testlist PROC					; COMDAT

; 1089 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1090 :     /* testlist: test (',' test)* [',']
; 1091 :        testlist_star_expr: test|star_expr (',' test|star_expr)* [',']
; 1092 :     */
; 1093 :     asdl_seq *seq;
; 1094 :     expr_ty expression;
; 1095 :     int i;
; 1096 :     assert(TYPE(n) == testlist || TYPE(n) == testlist_star_expr || TYPE(n) == testlist_comp);

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 47 01 00 00	 cmp	 eax, 327		; 00000147H
  0001b	74 3a		 je	 SHORT $LN8@seq_for_te
  0001d	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00022	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00025	3d 10 01 00 00	 cmp	 eax, 272		; 00000110H
  0002a	74 2b		 je	 SHORT $LN8@seq_for_te
  0002c	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00031	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00034	3d 41 01 00 00	 cmp	 eax, 321		; 00000141H
  00039	74 1c		 je	 SHORT $LN8@seq_for_te
  0003b	41 b8 48 04 00
	00		 mov	 r8d, 1096		; 00000448H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KC@EEMNIDCK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN@
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00055	33 c0		 xor	 eax, eax
$LN8@seq_for_te:

; 1097 : 
; 1098 :     seq = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);

  00057	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0005c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0005f	ff c0		 inc	 eax
  00061	99		 cdq
  00062	2b c2		 sub	 eax, edx
  00064	d1 f8		 sar	 eax, 1
  00066	48 98		 cdqe
  00068	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0006d	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00071	48 8b c8	 mov	 rcx, rax
  00074	e8 00 00 00 00	 call	 asdl_seq_new
  00079	48 89 44 24 30	 mov	 QWORD PTR seq$[rsp], rax

; 1099 :     if (!seq)

  0007e	48 83 7c 24 30
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00084	75 07		 jne	 SHORT $LN5@seq_for_te

; 1100 :         return NULL;

  00086	33 c0		 xor	 eax, eax
  00088	e9 39 01 00 00	 jmp	 $LN6@seq_for_te
$LN5@seq_for_te:

; 1101 : 
; 1102 :     for (i = 0; i < NCH(n); i += 2) {

  0008d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00095	eb 0b		 jmp	 SHORT $LN4@seq_for_te
$LN3@seq_for_te:
  00097	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0009b	83 c0 02	 add	 eax, 2
  0009e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@seq_for_te:
  000a2	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000a7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000aa	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000ae	0f 8d 0d 01 00
	00		 jge	 $LN2@seq_for_te

; 1103 :         const node *ch = CHILD(n, i);

  000b4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b9	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000bd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR n$[rsp]
  000c2	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000c6	48 89 44 24 38	 mov	 QWORD PTR ch$22629[rsp], rax

; 1104 :         assert(TYPE(ch) == test || TYPE(ch) == test_nocond || TYPE(ch) == star_expr);

  000cb	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$22629[rsp]
  000d0	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000d3	3d 2e 01 00 00	 cmp	 eax, 302		; 0000012eH
  000d8	74 3a		 je	 SHORT $LN9@seq_for_te
  000da	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$22629[rsp]
  000df	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000e2	3d 2f 01 00 00	 cmp	 eax, 303		; 0000012fH
  000e7	74 2b		 je	 SHORT $LN9@seq_for_te
  000e9	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$22629[rsp]
  000ee	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000f1	3d 37 01 00 00	 cmp	 eax, 311		; 00000137H
  000f6	74 1c		 je	 SHORT $LN9@seq_for_te
  000f8	41 b8 50 04 00
	00		 mov	 r8d, 1104		; 00000450H
  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1IK@OOGJNEEH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAe?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00112	33 c0		 xor	 eax, eax
$LN9@seq_for_te:

; 1105 : 
; 1106 :         expression = ast_for_expr(c, ch);

  00114	48 8b 54 24 38	 mov	 rdx, QWORD PTR ch$22629[rsp]
  00119	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0011e	e8 00 00 00 00	 call	 ast_for_expr
  00123	48 89 44 24 28	 mov	 QWORD PTR expression$[rsp], rax

; 1107 :         if (!expression)

  00128	48 83 7c 24 28
	00		 cmp	 QWORD PTR expression$[rsp], 0
  0012e	75 07		 jne	 SHORT $LN1@seq_for_te

; 1108 :             return NULL;

  00130	33 c0		 xor	 eax, eax
  00132	e9 8f 00 00 00	 jmp	 $LN6@seq_for_te
$LN1@seq_for_te:

; 1109 : 
; 1110 :         assert(i / 2 < seq->size);

  00137	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0013b	99		 cdq
  0013c	2b c2		 sub	 eax, edx
  0013e	d1 f8		 sar	 eax, 1
  00140	48 98		 cdqe
  00142	48 8b 4c 24 30	 mov	 rcx, QWORD PTR seq$[rsp]
  00147	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  0014a	7c 1c		 jl	 SHORT $LN10@seq_for_te
  0014c	41 b8 56 04 00
	00		 mov	 r8d, 1110		; 00000456H
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@GDDEIKJM@?$AAi?$AA?5?$AA?1?$AA?5?$AA2?$AA?5?$AA?$DM?$AA?5?$AAs?$AAe?$AAq?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00166	33 c0		 xor	 eax, eax
$LN10@seq_for_te:

; 1111 :         asdl_seq_SET(seq, i / 2, expression);

  00168	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0016c	99		 cdq
  0016d	2b c2		 sub	 eax, edx
  0016f	d1 f8		 sar	 eax, 1
  00171	89 44 24 40	 mov	 DWORD PTR _asdl_i$22636[rsp], eax
  00175	48 83 7c 24 30
	00		 cmp	 QWORD PTR seq$[rsp], 0
  0017b	74 0f		 je	 SHORT $LN11@seq_for_te
  0017d	48 63 44 24 40	 movsxd	 rax, DWORD PTR _asdl_i$22636[rsp]
  00182	48 8b 4c 24 30	 mov	 rcx, QWORD PTR seq$[rsp]
  00187	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  0018a	7c 1c		 jl	 SHORT $LN12@seq_for_te
$LN11@seq_for_te:
  0018c	41 b8 57 04 00
	00		 mov	 r8d, 1111		; 00000457H
  00192	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00199	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@GCGEEMDH@?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001a6	33 c0		 xor	 eax, eax
$LN12@seq_for_te:
  001a8	48 63 44 24 40	 movsxd	 rax, DWORD PTR _asdl_i$22636[rsp]
  001ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR seq$[rsp]
  001b2	48 8b 54 24 28	 mov	 rdx, QWORD PTR expression$[rsp]
  001b7	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 1112 :     }

  001bc	e9 d6 fe ff ff	 jmp	 $LN3@seq_for_te
$LN2@seq_for_te:

; 1113 :     return seq;

  001c1	48 8b 44 24 30	 mov	 rax, QWORD PTR seq$[rsp]
$LN6@seq_for_te:

; 1114 : }

  001c6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ca	c3		 ret	 0
seq_for_testlist ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@JJCKBAKO@unhandled?5expr?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_1EC@HLDPKHLK@?$AA?$CI?$AAc?$AAm?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAc?$AAm?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	??_C@_1DO@HAJJNCPB@?$AA?$CI?$AAo?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAo?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@DLDNABC@?$AA?$CB?$AAs?$AAt?$AAr?$AAc?$AAm?$AAp?$AA?$CI?$AAS?$AAT?$AAR?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?0?$AA?5?$AA?$CC?$AAo?$AAr?$AA?$CC?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_02FODMLBIE@or?$AA@			; `string'
PUBLIC	??_C@_03BOPJPIAM@and?$AA@			; `string'
EXTRN	_Py_Yield:PROC
EXTRN	_Py_YieldFrom:PROC
EXTRN	_Py_Compare:PROC
EXTRN	asdl_int_seq_new:PROC
EXTRN	_Py_UnaryOp:PROC
EXTRN	_Py_BoolOp:PROC
EXTRN	strcmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_expr DD imagerel ast_for_expr
	DD	imagerel ast_for_expr+2135
	DD	imagerel $unwind$ast_for_expr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_expr DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_0BD@JJCKBAKO@unhandled?5expr?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@JJCKBAKO@unhandled?5expr?3?5?$CFd?$AA@ DB 'unhandled expr: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@HLDPKHLK@?$AA?$CI?$AAc?$AAm?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAc?$AAm?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1EC@HLDPKHLK@?$AA?$CI?$AAc?$AAm?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAc?$AAm?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@ DB '('
	DB	00H, 'c', 00H, 'm', 00H, 'p', 00H, 's', 00H, ')', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's', 00H, 'd'
	DB	00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'(', 00H, 'c', 00H, 'm', 00H, 'p', 00H, 's', 00H, ')', 00H, '-'
	DB	00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@HAJJNCPB@?$AA?$CI?$AAo?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAo?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@HAJJNCPB@?$AA?$CI?$AAo?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAo?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB '('
	DB	00H, 'o', 00H, 'p', 00H, 's', 00H, ')', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's', 00H, 'd', 00H, 'l'
	DB	00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H
	DB	'o', 00H, 'p', 00H, 's', 00H, ')', 00H, '-', 00H, '>', 00H, 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@DLDNABC@?$AA?$CB?$AAs?$AAt?$AAr?$AAc?$AAm?$AAp?$AA?$CI?$AAS?$AAT?$AAR?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?0?$AA?5?$AA?$CC?$AAo?$AAr?$AA?$CC?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@DLDNABC@?$AA?$CB?$AAs?$AAt?$AAr?$AAc?$AAm?$AAp?$AA?$CI?$AAS?$AAT?$AAR?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?0?$AA?5?$AA?$CC?$AAo?$AAr?$AA?$CC?$AA?$CJ?$AA?$AA@ DB '!'
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'c', 00H, 'm', 00H, 'p', 00H
	DB	'(', 00H, 'S', 00H, 'T', 00H, 'R', 00H, '(', 00H, 'C', 00H, 'H'
	DB	00H, 'I', 00H, 'L', 00H, 'D', 00H, '(', 00H, 'n', 00H, ',', 00H
	DB	' ', 00H, '1', 00H, ')', 00H, ')', 00H, ',', 00H, ' ', 00H, '"'
	DB	00H, 'o', 00H, 'r', 00H, '"', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02FODMLBIE@or?$AA@
CONST	SEGMENT
??_C@_02FODMLBIE@or?$AA@ DB 'or', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BOPJPIAM@and?$AA@
CONST	SEGMENT
??_C@_03BOPJPIAM@and?$AA@ DB 'and', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_expr
_TEXT	SEGMENT
i$ = 48
seq$ = 56
e$23501 = 64
_asdl_i$23504 = 72
expression$23514 = 80
cmps$23522 = 88
ops$23521 = 96
expression$23520 = 104
newoperator$23530 = 112
_asdl_i$23535 = 116
_asdl_i$23538 = 120
en$23549 = 128
exp$23552 = 136
is_from$23551 = 144
an$23547 = 152
tv65 = 160
c$ = 192
n$ = 200
ast_for_expr PROC					; COMDAT

; 2241 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
$LN57@ast_for_ex:
$LN56@ast_for_ex:
$LN55@ast_for_ex:
$LN54@ast_for_ex:
$loop$23484:

; 2242 :     /* handle the full range of simple expressions
; 2243 :        test: or_test ['if' or_test 'else' test] | lambdef
; 2244 :        test_nocond: or_test | lambdef_nocond
; 2245 :        or_test: and_test ('or' and_test)*
; 2246 :        and_test: not_test ('and' not_test)*
; 2247 :        not_test: 'not' not_test | comparison
; 2248 :        comparison: expr (comp_op expr)*
; 2249 :        expr: xor_expr ('|' xor_expr)*
; 2250 :        xor_expr: and_expr ('^' and_expr)*
; 2251 :        and_expr: shift_expr ('&' shift_expr)*
; 2252 :        shift_expr: arith_expr (('<<'|'>>') arith_expr)*
; 2253 :        arith_expr: term (('+'|'-') term)*
; 2254 :        term: factor (('*'|'/'|'%'|'//') factor)*
; 2255 :        factor: ('+'|'-'|'~') factor | power
; 2256 :        power: atom trailer* ('**' factor)*
; 2257 :     */
; 2258 : 
; 2259 :     asdl_seq *seq;
; 2260 :     int i;
; 2261 : 
; 2262 :  loop:
; 2263 :     switch (TYPE(n)) {

  00011	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00019	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0001c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00023	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv65[rsp]
  0002a	2d 2e 01 00 00	 sub	 eax, 302		; 0000012eH
  0002f	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00036	83 bc 24 a0 00
	00 00 22	 cmp	 DWORD PTR tv65[rsp], 34	; 00000022H
  0003e	0f 87 98 07 00
	00		 ja	 $LN1@ast_for_ex
  00044	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR tv65[rsp]
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00053	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN58@ast_for_ex[rcx+rax]
  0005b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN59@ast_for_ex[rcx+rax*4]
  00062	48 03 c1	 add	 rax, rcx
  00065	ff e0		 jmp	 rax
$LN42@ast_for_ex:

; 2264 :         case test:
; 2265 :         case test_nocond:
; 2266 :             if (TYPE(CHILD(n, 0)) == lambdef ||
; 2267 :                 TYPE(CHILD(n, 0)) == lambdef_nocond)

  00067	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0006f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00073	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00076	3d 30 01 00 00	 cmp	 eax, 304		; 00000130H
  0007b	74 16		 je	 SHORT $LN40@ast_for_ex
  0007d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00085	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00089	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0008c	3d 31 01 00 00	 cmp	 eax, 305		; 00000131H
  00091	75 20		 jne	 SHORT $LN41@ast_for_ex
$LN40@ast_for_ex:

; 2268 :                 return ast_for_lambdef(c, CHILD(n, 0));

  00093	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0009b	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  0009f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000a7	e8 00 00 00 00	 call	 ast_for_lambdef
  000ac	e9 52 07 00 00	 jmp	 $LN45@ast_for_ex
  000b1	eb 28		 jmp	 SHORT $LN39@ast_for_ex
$LN41@ast_for_ex:

; 2269 :             else if (NCH(n) > 1)

  000b3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000bb	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  000bf	7e 1a		 jle	 SHORT $LN38@ast_for_ex

; 2270 :                 return ast_for_ifexpr(c, n);

  000c1	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  000c9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000d1	e8 00 00 00 00	 call	 ast_for_ifexpr
  000d6	e9 28 07 00 00	 jmp	 $LN45@ast_for_ex
$LN38@ast_for_ex:
$LN39@ast_for_ex:
$LN37@ast_for_ex:

; 2271 :             /* Fallthrough */
; 2272 :         case or_test:
; 2273 :         case and_test:
; 2274 :             if (NCH(n) == 1) {

  000db	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000e3	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  000e7	75 19		 jne	 SHORT $LN36@ast_for_ex

; 2275 :                 n = CHILD(n, 0);

  000e9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000f1	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000f5	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2276 :                 goto loop;

  000fd	e9 0f ff ff ff	 jmp	 $loop$23484
$LN36@ast_for_ex:

; 2277 :             }
; 2278 :             seq = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);

  00102	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0010a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0010d	ff c0		 inc	 eax
  0010f	99		 cdq
  00110	2b c2		 sub	 eax, edx
  00112	d1 f8		 sar	 eax, 1
  00114	48 98		 cdqe
  00116	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0011e	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00122	48 8b c8	 mov	 rcx, rax
  00125	e8 00 00 00 00	 call	 asdl_seq_new
  0012a	48 89 44 24 38	 mov	 QWORD PTR seq$[rsp], rax

; 2279 :             if (!seq)

  0012f	48 83 7c 24 38
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00135	75 07		 jne	 SHORT $LN35@ast_for_ex

; 2280 :                 return NULL;

  00137	33 c0		 xor	 eax, eax
  00139	e9 c5 06 00 00	 jmp	 $LN45@ast_for_ex
$LN35@ast_for_ex:

; 2281 :             for (i = 0; i < NCH(n); i += 2) {

  0013e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00146	eb 0b		 jmp	 SHORT $LN34@ast_for_ex
$LN33@ast_for_ex:
  00148	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0014c	83 c0 02	 add	 eax, 2
  0014f	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN34@ast_for_ex:
  00153	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0015b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0015e	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00162	0f 8d 92 00 00
	00		 jge	 $LN32@ast_for_ex

; 2282 :                 expr_ty e = ast_for_expr(c, CHILD(n, i));

  00168	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0016d	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00171	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00179	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0017d	48 8b d0	 mov	 rdx, rax
  00180	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00188	e8 00 00 00 00	 call	 ast_for_expr
  0018d	48 89 44 24 40	 mov	 QWORD PTR e$23501[rsp], rax

; 2283 :                 if (!e)

  00192	48 83 7c 24 40
	00		 cmp	 QWORD PTR e$23501[rsp], 0
  00198	75 07		 jne	 SHORT $LN31@ast_for_ex

; 2284 :                     return NULL;

  0019a	33 c0		 xor	 eax, eax
  0019c	e9 62 06 00 00	 jmp	 $LN45@ast_for_ex
$LN31@ast_for_ex:

; 2285 :                 asdl_seq_SET(seq, i / 2, e);

  001a1	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  001a5	99		 cdq
  001a6	2b c2		 sub	 eax, edx
  001a8	d1 f8		 sar	 eax, 1
  001aa	89 44 24 48	 mov	 DWORD PTR _asdl_i$23504[rsp], eax
  001ae	48 83 7c 24 38
	00		 cmp	 QWORD PTR seq$[rsp], 0
  001b4	74 0f		 je	 SHORT $LN47@ast_for_ex
  001b6	48 63 44 24 48	 movsxd	 rax, DWORD PTR _asdl_i$23504[rsp]
  001bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR seq$[rsp]
  001c0	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  001c3	7c 1c		 jl	 SHORT $LN48@ast_for_ex
$LN47@ast_for_ex:
  001c5	41 b8 ed 08 00
	00		 mov	 r8d, 2285		; 000008edH
  001cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@GCGEEMDH@?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001df	33 c0		 xor	 eax, eax
$LN48@ast_for_ex:
  001e1	48 63 44 24 48	 movsxd	 rax, DWORD PTR _asdl_i$23504[rsp]
  001e6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR seq$[rsp]
  001eb	48 8b 54 24 40	 mov	 rdx, QWORD PTR e$23501[rsp]
  001f0	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 2286 :             }

  001f5	e9 4e ff ff ff	 jmp	 $LN33@ast_for_ex
$LN32@ast_for_ex:

; 2287 :             if (!strcmp(STR(CHILD(n, 1)), "and"))

  001fa	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00202	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00206	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03BOPJPIAM@and?$AA@
  0020d	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00211	e8 00 00 00 00	 call	 strcmp
  00216	85 c0		 test	 eax, eax
  00218	75 3d		 jne	 SHORT $LN30@ast_for_ex

; 2288 :                 return BoolOp(And, seq, LINENO(n), n->n_col_offset,
; 2289 :                               c->c_arena);

  0021a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00222	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00226	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00233	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  00237	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0023f	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00243	48 8b 54 24 38	 mov	 rdx, QWORD PTR seq$[rsp]
  00248	b9 01 00 00 00	 mov	 ecx, 1
  0024d	e8 00 00 00 00	 call	 _Py_BoolOp
  00252	e9 ac 05 00 00	 jmp	 $LN45@ast_for_ex
$LN30@ast_for_ex:

; 2290 :             assert(!strcmp(STR(CHILD(n, 1)), "or"));

  00257	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0025f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00263	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02FODMLBIE@or?$AA@
  0026a	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0026e	e8 00 00 00 00	 call	 strcmp
  00273	85 c0		 test	 eax, eax
  00275	74 1c		 je	 SHORT $LN49@ast_for_ex
  00277	41 b8 f2 08 00
	00		 mov	 r8d, 2290		; 000008f2H
  0027d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@DLDNABC@?$AA?$CB?$AAs?$AAt?$AAr?$AAc?$AAm?$AAp?$AA?$CI?$AAS?$AAT?$AAR?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?0?$AA?5?$AA?$CC?$AAo?$AAr?$AA?$CC?$AA?$CJ?$AA?$AA@
  0028b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00291	33 c0		 xor	 eax, eax
$LN49@ast_for_ex:

; 2291 :             return BoolOp(Or, seq, LINENO(n), n->n_col_offset, c->c_arena);

  00293	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0029b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0029f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002ac	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  002b0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002b8	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  002bc	48 8b 54 24 38	 mov	 rdx, QWORD PTR seq$[rsp]
  002c1	b9 02 00 00 00	 mov	 ecx, 2
  002c6	e8 00 00 00 00	 call	 _Py_BoolOp
  002cb	e9 33 05 00 00	 jmp	 $LN45@ast_for_ex
$LN29@ast_for_ex:

; 2292 :         case not_test:
; 2293 :             if (NCH(n) == 1) {

  002d0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002d8	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  002dc	75 1b		 jne	 SHORT $LN28@ast_for_ex

; 2294 :                 n = CHILD(n, 0);

  002de	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002e6	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002ea	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2295 :                 goto loop;

  002f2	e9 1a fd ff ff	 jmp	 $LN54@ast_for_ex

; 2296 :             }
; 2297 :             else {

  002f7	eb 71		 jmp	 SHORT $LN27@ast_for_ex
$LN28@ast_for_ex:

; 2298 :                 expr_ty expression = ast_for_expr(c, CHILD(n, 1));

  002f9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00301	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00305	48 83 c0 28	 add	 rax, 40			; 00000028H
  00309	48 8b d0	 mov	 rdx, rax
  0030c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00314	e8 00 00 00 00	 call	 ast_for_expr
  00319	48 89 44 24 50	 mov	 QWORD PTR expression$23514[rsp], rax

; 2299 :                 if (!expression)

  0031e	48 83 7c 24 50
	00		 cmp	 QWORD PTR expression$23514[rsp], 0
  00324	75 07		 jne	 SHORT $LN26@ast_for_ex

; 2300 :                     return NULL;

  00326	33 c0		 xor	 eax, eax
  00328	e9 d6 04 00 00	 jmp	 $LN45@ast_for_ex
$LN26@ast_for_ex:

; 2301 : 
; 2302 :                 return UnaryOp(Not, expression, LINENO(n), n->n_col_offset,
; 2303 :                                c->c_arena);

  0032d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00335	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00339	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00346	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0034a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00352	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00356	48 8b 54 24 50	 mov	 rdx, QWORD PTR expression$23514[rsp]
  0035b	b9 02 00 00 00	 mov	 ecx, 2
  00360	e8 00 00 00 00	 call	 _Py_UnaryOp
  00365	e9 99 04 00 00	 jmp	 $LN45@ast_for_ex
$LN27@ast_for_ex:
$LN25@ast_for_ex:

; 2304 :             }
; 2305 :         case comparison:
; 2306 :             if (NCH(n) == 1) {

  0036a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00372	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00376	75 1e		 jne	 SHORT $LN24@ast_for_ex

; 2307 :                 n = CHILD(n, 0);

  00378	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00380	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00384	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2308 :                 goto loop;

  0038c	e9 80 fc ff ff	 jmp	 $LN55@ast_for_ex

; 2309 :             }
; 2310 :             else {

  00391	e9 2e 02 00 00	 jmp	 $LN23@ast_for_ex
$LN24@ast_for_ex:

; 2311 :                 expr_ty expression;
; 2312 :                 asdl_int_seq *ops;
; 2313 :                 asdl_seq *cmps;
; 2314 :                 ops = asdl_int_seq_new(NCH(n) / 2, c->c_arena);

  00396	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0039e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003a1	99		 cdq
  003a2	2b c2		 sub	 eax, edx
  003a4	d1 f8		 sar	 eax, 1
  003a6	48 98		 cdqe
  003a8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003b0	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  003b4	48 8b c8	 mov	 rcx, rax
  003b7	e8 00 00 00 00	 call	 asdl_int_seq_new
  003bc	48 89 44 24 60	 mov	 QWORD PTR ops$23521[rsp], rax

; 2315 :                 if (!ops)

  003c1	48 83 7c 24 60
	00		 cmp	 QWORD PTR ops$23521[rsp], 0
  003c7	75 07		 jne	 SHORT $LN22@ast_for_ex

; 2316 :                     return NULL;

  003c9	33 c0		 xor	 eax, eax
  003cb	e9 33 04 00 00	 jmp	 $LN45@ast_for_ex
$LN22@ast_for_ex:

; 2317 :                 cmps = asdl_seq_new(NCH(n) / 2, c->c_arena);

  003d0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003d8	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003db	99		 cdq
  003dc	2b c2		 sub	 eax, edx
  003de	d1 f8		 sar	 eax, 1
  003e0	48 98		 cdqe
  003e2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003ea	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  003ee	48 8b c8	 mov	 rcx, rax
  003f1	e8 00 00 00 00	 call	 asdl_seq_new
  003f6	48 89 44 24 58	 mov	 QWORD PTR cmps$23522[rsp], rax

; 2318 :                 if (!cmps) {

  003fb	48 83 7c 24 58
	00		 cmp	 QWORD PTR cmps$23522[rsp], 0
  00401	75 07		 jne	 SHORT $LN21@ast_for_ex

; 2319 :                     return NULL;

  00403	33 c0		 xor	 eax, eax
  00405	e9 f9 03 00 00	 jmp	 $LN45@ast_for_ex
$LN21@ast_for_ex:

; 2320 :                 }
; 2321 :                 for (i = 1; i < NCH(n); i += 2) {

  0040a	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00412	eb 0b		 jmp	 SHORT $LN20@ast_for_ex
$LN19@ast_for_ex:
  00414	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00418	83 c0 02	 add	 eax, 2
  0041b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN20@ast_for_ex:
  0041f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00427	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0042a	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0042e	0f 8d 1e 01 00
	00		 jge	 $LN18@ast_for_ex

; 2322 :                     cmpop_ty newoperator;
; 2323 : 
; 2324 :                     newoperator = ast_for_comp_op(c, CHILD(n, i));

  00434	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00439	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0043d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00445	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00449	48 8b d0	 mov	 rdx, rax
  0044c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00454	e8 00 00 00 00	 call	 ast_for_comp_op
  00459	89 44 24 70	 mov	 DWORD PTR newoperator$23530[rsp], eax

; 2325 :                     if (!newoperator) {

  0045d	83 7c 24 70 00	 cmp	 DWORD PTR newoperator$23530[rsp], 0
  00462	75 07		 jne	 SHORT $LN17@ast_for_ex

; 2326 :                         return NULL;

  00464	33 c0		 xor	 eax, eax
  00466	e9 98 03 00 00	 jmp	 $LN45@ast_for_ex
$LN17@ast_for_ex:

; 2327 :                     }
; 2328 : 
; 2329 :                     expression = ast_for_expr(c, CHILD(n, i + 1));

  0046b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0046f	ff c0		 inc	 eax
  00471	48 98		 cdqe
  00473	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00477	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0047f	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00483	48 8b d0	 mov	 rdx, rax
  00486	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0048e	e8 00 00 00 00	 call	 ast_for_expr
  00493	48 89 44 24 68	 mov	 QWORD PTR expression$23520[rsp], rax

; 2330 :                     if (!expression) {

  00498	48 83 7c 24 68
	00		 cmp	 QWORD PTR expression$23520[rsp], 0
  0049e	75 07		 jne	 SHORT $LN16@ast_for_ex

; 2331 :                         return NULL;

  004a0	33 c0		 xor	 eax, eax
  004a2	e9 5c 03 00 00	 jmp	 $LN45@ast_for_ex
$LN16@ast_for_ex:

; 2332 :                     }
; 2333 : 
; 2334 :                     asdl_seq_SET(ops, i / 2, newoperator);

  004a7	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004ab	99		 cdq
  004ac	2b c2		 sub	 eax, edx
  004ae	d1 f8		 sar	 eax, 1
  004b0	89 44 24 74	 mov	 DWORD PTR _asdl_i$23535[rsp], eax
  004b4	48 83 7c 24 60
	00		 cmp	 QWORD PTR ops$23521[rsp], 0
  004ba	74 0f		 je	 SHORT $LN50@ast_for_ex
  004bc	48 63 44 24 74	 movsxd	 rax, DWORD PTR _asdl_i$23535[rsp]
  004c1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ops$23521[rsp]
  004c6	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  004c9	7c 1c		 jl	 SHORT $LN51@ast_for_ex
$LN50@ast_for_ex:
  004cb	41 b8 1e 09 00
	00		 mov	 r8d, 2334		; 0000091eH
  004d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  004d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@HAJJNCPB@?$AA?$CI?$AAo?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAo?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  004df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004e5	33 c0		 xor	 eax, eax
$LN51@ast_for_ex:
  004e7	48 63 44 24 74	 movsxd	 rax, DWORD PTR _asdl_i$23535[rsp]
  004ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ops$23521[rsp]
  004f1	8b 54 24 70	 mov	 edx, DWORD PTR newoperator$23530[rsp]
  004f5	89 54 81 08	 mov	 DWORD PTR [rcx+rax*4+8], edx

; 2335 :                     asdl_seq_SET(cmps, i / 2, expression);

  004f9	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004fd	99		 cdq
  004fe	2b c2		 sub	 eax, edx
  00500	d1 f8		 sar	 eax, 1
  00502	89 44 24 78	 mov	 DWORD PTR _asdl_i$23538[rsp], eax
  00506	48 83 7c 24 58
	00		 cmp	 QWORD PTR cmps$23522[rsp], 0
  0050c	74 0f		 je	 SHORT $LN52@ast_for_ex
  0050e	48 63 44 24 78	 movsxd	 rax, DWORD PTR _asdl_i$23538[rsp]
  00513	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cmps$23522[rsp]
  00518	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  0051b	7c 1c		 jl	 SHORT $LN53@ast_for_ex
$LN52@ast_for_ex:
  0051d	41 b8 1f 09 00
	00		 mov	 r8d, 2335		; 0000091fH
  00523	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0052a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@HLDPKHLK@?$AA?$CI?$AAc?$AAm?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAc?$AAm?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@
  00531	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00537	33 c0		 xor	 eax, eax
$LN53@ast_for_ex:
  00539	48 63 44 24 78	 movsxd	 rax, DWORD PTR _asdl_i$23538[rsp]
  0053e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cmps$23522[rsp]
  00543	48 8b 54 24 68	 mov	 rdx, QWORD PTR expression$23520[rsp]
  00548	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 2336 :                 }

  0054d	e9 c2 fe ff ff	 jmp	 $LN19@ast_for_ex
$LN18@ast_for_ex:

; 2337 :                 expression = ast_for_expr(c, CHILD(n, 0));

  00552	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0055a	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  0055e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00566	e8 00 00 00 00	 call	 ast_for_expr
  0056b	48 89 44 24 68	 mov	 QWORD PTR expression$23520[rsp], rax

; 2338 :                 if (!expression) {

  00570	48 83 7c 24 68
	00		 cmp	 QWORD PTR expression$23520[rsp], 0
  00576	75 07		 jne	 SHORT $LN15@ast_for_ex

; 2339 :                     return NULL;

  00578	33 c0		 xor	 eax, eax
  0057a	e9 84 02 00 00	 jmp	 $LN45@ast_for_ex
$LN15@ast_for_ex:

; 2340 :                 }
; 2341 : 
; 2342 :                 return Compare(expression, ops, cmps, LINENO(n),
; 2343 :                                n->n_col_offset, c->c_arena);

  0057f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00587	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0058b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00590	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00598	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0059b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0059f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  005a7	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  005ab	4c 8b 44 24 58	 mov	 r8, QWORD PTR cmps$23522[rsp]
  005b0	48 8b 54 24 60	 mov	 rdx, QWORD PTR ops$23521[rsp]
  005b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR expression$23520[rsp]
  005ba	e8 00 00 00 00	 call	 _Py_Compare
  005bf	e9 3f 02 00 00	 jmp	 $LN45@ast_for_ex
$LN23@ast_for_ex:

; 2344 :             }
; 2345 :             break;

  005c4	e9 38 02 00 00	 jmp	 $LN43@ast_for_ex
$LN14@ast_for_ex:

; 2346 : 
; 2347 :         case star_expr:
; 2348 :             return ast_for_starred(c, n);

  005c9	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  005d1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  005d9	e8 00 00 00 00	 call	 ast_for_starred
  005de	e9 20 02 00 00	 jmp	 $LN45@ast_for_ex
$LN13@ast_for_ex:

; 2349 :         /* The next five cases all handle BinOps.  The main body of code
; 2350 :            is the same in each case, but the switch turned inside out to
; 2351 :            reuse the code for each type of operator.
; 2352 :          */
; 2353 :         case expr:
; 2354 :         case xor_expr:
; 2355 :         case and_expr:
; 2356 :         case shift_expr:
; 2357 :         case arith_expr:
; 2358 :         case term:
; 2359 :             if (NCH(n) == 1) {

  005e3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  005eb	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  005ef	75 19		 jne	 SHORT $LN12@ast_for_ex

; 2360 :                 n = CHILD(n, 0);

  005f1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  005f9	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  005fd	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2361 :                 goto loop;

  00605	e9 07 fa ff ff	 jmp	 $LN56@ast_for_ex
$LN12@ast_for_ex:

; 2362 :             }
; 2363 :             return ast_for_binop(c, n);

  0060a	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  00612	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0061a	e8 00 00 00 00	 call	 ast_for_binop
  0061f	e9 df 01 00 00	 jmp	 $LN45@ast_for_ex
$LN11@ast_for_ex:

; 2364 :         case yield_expr: {
; 2365 :             node *an = NULL;

  00624	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR an$23547[rsp], 0

; 2366 :             node *en = NULL;

  00630	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR en$23549[rsp], 0

; 2367 :             int is_from = 0;

  0063c	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR is_from$23551[rsp], 0

; 2368 :             expr_ty exp = NULL;

  00647	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR exp$23552[rsp], 0

; 2369 :             if (NCH(n) > 1)

  00653	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0065b	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  0065f	7e 18		 jle	 SHORT $LN10@ast_for_ex

; 2370 :                 an = CHILD(n, 1); /* yield_arg */

  00661	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00669	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0066d	48 83 c0 28	 add	 rax, 40			; 00000028H
  00671	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR an$23547[rsp], rax
$LN10@ast_for_ex:

; 2371 :             if (an) {

  00679	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR an$23547[rsp], 0
  00682	0f 84 8e 00 00
	00		 je	 $LN9@ast_for_ex

; 2372 :                 en = CHILD(an, NCH(an) - 1);

  00688	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR an$23547[rsp]
  00690	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00693	ff c8		 dec	 eax
  00695	48 98		 cdqe
  00697	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0069b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR an$23547[rsp]
  006a3	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  006a7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR en$23549[rsp], rax

; 2373 :                 if (NCH(an) == 2) {

  006af	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR an$23547[rsp]
  006b7	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  006bb	75 2a		 jne	 SHORT $LN8@ast_for_ex

; 2374 :                     is_from = 1;

  006bd	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR is_from$23551[rsp], 1

; 2375 :                     exp = ast_for_expr(c, en);

  006c8	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR en$23549[rsp]
  006d0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  006d8	e8 00 00 00 00	 call	 ast_for_expr
  006dd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR exp$23552[rsp], rax

; 2376 :                 }
; 2377 :                 else

  006e5	eb 1d		 jmp	 SHORT $LN7@ast_for_ex
$LN8@ast_for_ex:

; 2378 :                     exp = ast_for_testlist(c, en);

  006e7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR en$23549[rsp]
  006ef	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  006f7	e8 00 00 00 00	 call	 ast_for_testlist
  006fc	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR exp$23552[rsp], rax
$LN7@ast_for_ex:

; 2379 :                 if (!exp)

  00704	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR exp$23552[rsp], 0
  0070d	75 07		 jne	 SHORT $LN6@ast_for_ex

; 2380 :                     return NULL;

  0070f	33 c0		 xor	 eax, eax
  00711	e9 ed 00 00 00	 jmp	 $LN45@ast_for_ex
$LN6@ast_for_ex:
$LN9@ast_for_ex:

; 2381 :             }
; 2382 :             if (is_from)

  00716	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR is_from$23551[rsp], 0
  0071e	74 35		 je	 SHORT $LN5@ast_for_ex

; 2383 :                 return YieldFrom(exp, LINENO(n), n->n_col_offset, c->c_arena);

  00720	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00728	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  0072c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00734	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  00738	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00740	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00743	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR exp$23552[rsp]
  0074b	e8 00 00 00 00	 call	 _Py_YieldFrom
  00750	e9 ae 00 00 00	 jmp	 $LN45@ast_for_ex
$LN5@ast_for_ex:

; 2384 :             return Yield(exp, LINENO(n), n->n_col_offset, c->c_arena);

  00755	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0075d	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00761	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00769	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  0076d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00775	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00778	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR exp$23552[rsp]
  00780	e8 00 00 00 00	 call	 _Py_Yield
  00785	eb 7c		 jmp	 SHORT $LN45@ast_for_ex
$LN4@ast_for_ex:

; 2385 :         }
; 2386 :         case factor:
; 2387 :             if (NCH(n) == 1) {

  00787	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0078f	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00793	75 19		 jne	 SHORT $LN3@ast_for_ex

; 2388 :                 n = CHILD(n, 0);

  00795	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0079d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  007a1	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2389 :                 goto loop;

  007a9	e9 63 f8 ff ff	 jmp	 $LN57@ast_for_ex
$LN3@ast_for_ex:

; 2390 :             }
; 2391 :             return ast_for_factor(c, n);

  007ae	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  007b6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  007be	e8 00 00 00 00	 call	 ast_for_factor
  007c3	eb 3e		 jmp	 SHORT $LN45@ast_for_ex
$LN2@ast_for_ex:

; 2392 :         case power:
; 2393 :             return ast_for_power(c, n);

  007c5	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  007cd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  007d5	e8 00 00 00 00	 call	 ast_for_power
  007da	eb 27		 jmp	 SHORT $LN45@ast_for_ex
$LN1@ast_for_ex:

; 2394 :         default:
; 2395 :             PyErr_Format(PyExc_SystemError, "unhandled expr: %d", TYPE(n));

  007dc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  007e4	0f bf 00	 movsx	 eax, WORD PTR [rax]
  007e7	44 8b c0	 mov	 r8d, eax
  007ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@JJCKBAKO@unhandled?5expr?3?5?$CFd?$AA@
  007f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  007f8	e8 00 00 00 00	 call	 PyErr_Format

; 2396 :             return NULL;

  007fd	33 c0		 xor	 eax, eax
  007ff	eb 02		 jmp	 SHORT $LN45@ast_for_ex
$LN43@ast_for_ex:

; 2397 :     }
; 2398 :     /* should never get here unless if error is set */
; 2399 :     return NULL;

  00801	33 c0		 xor	 eax, eax
$LN45@ast_for_ex:

; 2400 : }

  00803	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0080a	c3		 ret	 0
  0080b	90		 npad	 1
$LN59@ast_for_ex:
  0080c	00 00 00 00	 DD	 $LN42@ast_for_ex
  00810	00 00 00 00	 DD	 $LN37@ast_for_ex
  00814	00 00 00 00	 DD	 $LN29@ast_for_ex
  00818	00 00 00 00	 DD	 $LN25@ast_for_ex
  0081c	00 00 00 00	 DD	 $LN14@ast_for_ex
  00820	00 00 00 00	 DD	 $LN13@ast_for_ex
  00824	00 00 00 00	 DD	 $LN4@ast_for_ex
  00828	00 00 00 00	 DD	 $LN2@ast_for_ex
  0082c	00 00 00 00	 DD	 $LN11@ast_for_ex
  00830	00 00 00 00	 DD	 $LN1@ast_for_ex
$LN58@ast_for_ex:
  00834	00		 DB	 0
  00835	00		 DB	 0
  00836	09		 DB	 9
  00837	09		 DB	 9
  00838	01		 DB	 1
  00839	01		 DB	 1
  0083a	02		 DB	 2
  0083b	03		 DB	 3
  0083c	09		 DB	 9
  0083d	04		 DB	 4
  0083e	05		 DB	 5
  0083f	05		 DB	 5
  00840	05		 DB	 5
  00841	05		 DB	 5
  00842	05		 DB	 5
  00843	05		 DB	 5
  00844	06		 DB	 6
  00845	07		 DB	 7
  00846	09		 DB	 9
  00847	09		 DB	 9
  00848	09		 DB	 9
  00849	09		 DB	 9
  0084a	09		 DB	 9
  0084b	09		 DB	 9
  0084c	09		 DB	 9
  0084d	09		 DB	 9
  0084e	09		 DB	 9
  0084f	09		 DB	 9
  00850	09		 DB	 9
  00851	09		 DB	 9
  00852	09		 DB	 9
  00853	09		 DB	 9
  00854	09		 DB	 9
  00855	09		 DB	 9
  00856	08		 DB	 8
ast_for_expr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@DJMGDDDJ@invalid?5comp_op?3?5has?5?$CFd?5children@ ; `string'
PUBLIC	??_C@_0BH@PIIGKMIP@invalid?5comp_op?3?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BE@KEKDOHCG@invalid?5comp_op?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_02EDKKPMHH@is?$AA@			; `string'
PUBLIC	??_C@_02LMMGJAGL@in?$AA@			; `string'
PUBLIC	??_C@_1CC@DEDMLLB@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA0?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_comp_op DD imagerel ast_for_comp_op
	DD	imagerel ast_for_comp_op+582
	DD	imagerel $unwind$ast_for_comp_op
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_comp_op DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CB@DJMGDDDJ@invalid?5comp_op?3?5has?5?$CFd?5children@
CONST	SEGMENT
??_C@_0CB@DJMGDDDJ@invalid?5comp_op?3?5has?5?$CFd?5children@ DB 'invalid '
	DB	'comp_op: has %d children', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PIIGKMIP@invalid?5comp_op?3?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BH@PIIGKMIP@invalid?5comp_op?3?5?$CFs?5?$CFs?$AA@ DB 'invalid comp'
	DB	'_op: %s %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KEKDOHCG@invalid?5comp_op?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BE@KEKDOHCG@invalid?5comp_op?3?5?$CFs?$AA@ DB 'invalid comp_op: %s'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02EDKKPMHH@is?$AA@
CONST	SEGMENT
??_C@_02EDKKPMHH@is?$AA@ DB 'is', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGJAGL@in?$AA@
CONST	SEGMENT
??_C@_02LMMGJAGL@in?$AA@ DB 'in', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DEDMLLB@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA0?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@DEDMLLB@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA0?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '1'
	DB	00H, '0', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_comp_op
_TEXT	SEGMENT
tv74 = 32
tv128 = 36
c$ = 64
n$ = 72
ast_for_comp_op PROC					; COMDAT

; 1037 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1038 :     /* comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'
; 1039 :                |'is' 'not'
; 1040 :     */
; 1041 :     REQ(n, comp_op);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 36 01 00 00	 cmp	 eax, 310		; 00000136H
  0001b	74 1c		 je	 SHORT $LN24@ast_for_co
  0001d	41 b8 11 04 00
	00		 mov	 r8d, 1041		; 00000411H
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@DEDMLLB@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA0?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN24@ast_for_co:

; 1042 :     if (NCH(n) == 1) {

  00039	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0003e	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00042	0f 85 f9 00 00
	00		 jne	 $LN21@ast_for_co

; 1043 :         n = CHILD(n, 0);

  00048	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0004d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00051	48 89 44 24 48	 mov	 QWORD PTR n$[rsp], rax

; 1044 :         switch (TYPE(n)) {

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0005b	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0005e	89 44 24 20	 mov	 DWORD PTR tv74[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR tv74[rsp]
  00066	ff c8		 dec	 eax
  00068	89 44 24 20	 mov	 DWORD PTR tv74[rsp], eax
  0006c	83 7c 24 20 1d	 cmp	 DWORD PTR tv74[rsp], 29
  00071	0f 87 a2 00 00
	00		 ja	 $LN9@ast_for_co
  00077	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv74[rsp]
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00083	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN25@ast_for_co[rcx+rax]
  0008b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN26@ast_for_co[rcx+rax*4]
  00092	48 03 c1	 add	 rax, rcx
  00095	ff e0		 jmp	 rax
$LN18@ast_for_co:

; 1045 :             case LESS:
; 1046 :                 return Lt;

  00097	b8 03 00 00 00	 mov	 eax, 3
  0009c	e9 5f 01 00 00	 jmp	 $LN22@ast_for_co
$LN17@ast_for_co:

; 1047 :             case GREATER:
; 1048 :                 return Gt;

  000a1	b8 05 00 00 00	 mov	 eax, 5
  000a6	e9 55 01 00 00	 jmp	 $LN22@ast_for_co
$LN16@ast_for_co:

; 1049 :             case EQEQUAL:                       /* == */
; 1050 :                 return Eq;

  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	e9 4b 01 00 00	 jmp	 $LN22@ast_for_co
$LN15@ast_for_co:

; 1051 :             case LESSEQUAL:
; 1052 :                 return LtE;

  000b5	b8 04 00 00 00	 mov	 eax, 4
  000ba	e9 41 01 00 00	 jmp	 $LN22@ast_for_co
$LN14@ast_for_co:

; 1053 :             case GREATEREQUAL:
; 1054 :                 return GtE;

  000bf	b8 06 00 00 00	 mov	 eax, 6
  000c4	e9 37 01 00 00	 jmp	 $LN22@ast_for_co
$LN13@ast_for_co:

; 1055 :             case NOTEQUAL:
; 1056 :                 return NotEq;

  000c9	b8 02 00 00 00	 mov	 eax, 2
  000ce	e9 2d 01 00 00	 jmp	 $LN22@ast_for_co
$LN12@ast_for_co:

; 1057 :             case NAME:
; 1058 :                 if (strcmp(STR(n), "in") == 0)

  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LMMGJAGL@in?$AA@
  000da	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000df	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000e3	e8 00 00 00 00	 call	 strcmp
  000e8	85 c0		 test	 eax, eax
  000ea	75 0a		 jne	 SHORT $LN11@ast_for_co

; 1059 :                     return In;

  000ec	b8 09 00 00 00	 mov	 eax, 9
  000f1	e9 0a 01 00 00	 jmp	 $LN22@ast_for_co
$LN11@ast_for_co:

; 1060 :                 if (strcmp(STR(n), "is") == 0)

  000f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02EDKKPMHH@is?$AA@
  000fd	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00102	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00106	e8 00 00 00 00	 call	 strcmp
  0010b	85 c0		 test	 eax, eax
  0010d	75 0a		 jne	 SHORT $LN10@ast_for_co

; 1061 :                     return Is;

  0010f	b8 07 00 00 00	 mov	 eax, 7
  00114	e9 e7 00 00 00	 jmp	 $LN22@ast_for_co
$LN10@ast_for_co:
$LN9@ast_for_co:

; 1062 :             default:
; 1063 :                 PyErr_Format(PyExc_SystemError, "invalid comp_op: %s",
; 1064 :                              STR(n));

  00119	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0011e	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@KEKDOHCG@invalid?5comp_op?3?5?$CFs?$AA@
  00129	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00130	e8 00 00 00 00	 call	 PyErr_Format

; 1065 :                 return (cmpop_ty)0;

  00135	33 c0		 xor	 eax, eax
  00137	e9 c4 00 00 00	 jmp	 $LN22@ast_for_co

; 1066 :         }
; 1067 :     }
; 1068 :     else if (NCH(n) == 2) {

  0013c	e9 a1 00 00 00	 jmp	 $LN8@ast_for_co
$LN21@ast_for_co:
  00141	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00146	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  0014a	0f 85 92 00 00
	00		 jne	 $LN7@ast_for_co

; 1069 :         /* handle "not in" and "is not" */
; 1070 :         switch (TYPE(CHILD(n, 0))) {

  00150	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00155	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00159	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0015c	89 44 24 24	 mov	 DWORD PTR tv128[rsp], eax
  00160	83 7c 24 24 01	 cmp	 DWORD PTR tv128[rsp], 1
  00165	74 02		 je	 SHORT $LN4@ast_for_co
  00167	eb 48		 jmp	 SHORT $LN1@ast_for_co
$LN4@ast_for_co:

; 1071 :             case NAME:
; 1072 :                 if (strcmp(STR(CHILD(n, 1)), "in") == 0)

  00169	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0016e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00172	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LMMGJAGL@in?$AA@
  00179	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0017d	e8 00 00 00 00	 call	 strcmp
  00182	85 c0		 test	 eax, eax
  00184	75 07		 jne	 SHORT $LN3@ast_for_co

; 1073 :                     return NotIn;

  00186	b8 0a 00 00 00	 mov	 eax, 10
  0018b	eb 73		 jmp	 SHORT $LN22@ast_for_co
$LN3@ast_for_co:

; 1074 :                 if (strcmp(STR(CHILD(n, 0)), "is") == 0)

  0018d	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00192	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00196	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02EDKKPMHH@is?$AA@
  0019d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001a1	e8 00 00 00 00	 call	 strcmp
  001a6	85 c0		 test	 eax, eax
  001a8	75 07		 jne	 SHORT $LN2@ast_for_co

; 1075 :                     return IsNot;

  001aa	b8 08 00 00 00	 mov	 eax, 8
  001af	eb 4f		 jmp	 SHORT $LN22@ast_for_co
$LN2@ast_for_co:
$LN1@ast_for_co:

; 1076 :             default:
; 1077 :                 PyErr_Format(PyExc_SystemError, "invalid comp_op: %s %s",
; 1078 :                              STR(CHILD(n, 0)), STR(CHILD(n, 1)));

  001b1	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  001b6	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001ba	48 8b 4c 24 48	 mov	 rcx, QWORD PTR n$[rsp]
  001bf	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  001c3	4c 8b 48 30	 mov	 r9, QWORD PTR [rax+48]
  001c7	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  001cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@PIIGKMIP@invalid?5comp_op?3?5?$CFs?5?$CFs?$AA@
  001d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  001d9	e8 00 00 00 00	 call	 PyErr_Format

; 1079 :                 return (cmpop_ty)0;

  001de	33 c0		 xor	 eax, eax
  001e0	eb 1e		 jmp	 SHORT $LN22@ast_for_co
$LN7@ast_for_co:
$LN8@ast_for_co:

; 1080 :         }
; 1081 :     }
; 1082 :     PyErr_Format(PyExc_SystemError, "invalid comp_op: has %d children",
; 1083 :                  NCH(n));

  001e2	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  001e7	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  001eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@DJMGDDDJ@invalid?5comp_op?3?5has?5?$CFd?5children@
  001f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  001f9	e8 00 00 00 00	 call	 PyErr_Format

; 1084 :     return (cmpop_ty)0;

  001fe	33 c0		 xor	 eax, eax
$LN22@ast_for_co:

; 1085 : }

  00200	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00204	c3		 ret	 0
  00205	0f 1f 00	 npad	 3
$LN26@ast_for_co:
  00208	00 00 00 00	 DD	 $LN12@ast_for_co
  0020c	00 00 00 00	 DD	 $LN18@ast_for_co
  00210	00 00 00 00	 DD	 $LN17@ast_for_co
  00214	00 00 00 00	 DD	 $LN16@ast_for_co
  00218	00 00 00 00	 DD	 $LN13@ast_for_co
  0021c	00 00 00 00	 DD	 $LN15@ast_for_co
  00220	00 00 00 00	 DD	 $LN14@ast_for_co
  00224	00 00 00 00	 DD	 $LN9@ast_for_co
$LN25@ast_for_co:
  00228	00		 DB	 0
  00229	07		 DB	 7
  0022a	07		 DB	 7
  0022b	07		 DB	 7
  0022c	07		 DB	 7
  0022d	07		 DB	 7
  0022e	07		 DB	 7
  0022f	07		 DB	 7
  00230	07		 DB	 7
  00231	07		 DB	 7
  00232	07		 DB	 7
  00233	07		 DB	 7
  00234	07		 DB	 7
  00235	07		 DB	 7
  00236	07		 DB	 7
  00237	07		 DB	 7
  00238	07		 DB	 7
  00239	07		 DB	 7
  0023a	07		 DB	 7
  0023b	01		 DB	 1
  0023c	02		 DB	 2
  0023d	07		 DB	 7
  0023e	07		 DB	 7
  0023f	07		 DB	 7
  00240	07		 DB	 7
  00241	07		 DB	 7
  00242	03		 DB	 3
  00243	04		 DB	 4
  00244	05		 DB	 5
  00245	06		 DB	 6
ast_for_comp_op ENDP
_TEXT	ENDS
EXTRN	_Py_Lambda:PROC
EXTRN	_Py_arguments:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_lambdef DD imagerel ast_for_lambdef
	DD	imagerel ast_for_lambdef+300
	DD	imagerel $unwind$ast_for_lambdef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_lambdef DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ast_for_lambdef
_TEXT	SEGMENT
args$ = 80
expression$ = 88
c$ = 112
n$ = 120
ast_for_lambdef PROC					; COMDAT

; 1551 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1552 :     /* lambdef: 'lambda' [varargslist] ':' test
; 1553 :        lambdef_nocond: 'lambda' [varargslist] ':' test_nocond */
; 1554 :     arguments_ty args;
; 1555 :     expr_ty expression;
; 1556 : 
; 1557 :     if (NCH(n) == 3) {

  0000e	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00013	83 78 18 03	 cmp	 DWORD PTR [rax+24], 3
  00017	0f 85 85 00 00
	00		 jne	 $LN6@ast_for_la

; 1558 :         args = arguments(NULL, NULL, NULL, NULL, NULL, NULL, NULL,
; 1559 :                          NULL, c->c_arena);

  0001d	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00022	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00026	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0002b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00034	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00046	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0004f	45 33 c9	 xor	 r9d, r9d
  00052	45 33 c0	 xor	 r8d, r8d
  00055	33 d2		 xor	 edx, edx
  00057	33 c9		 xor	 ecx, ecx
  00059	e8 00 00 00 00	 call	 _Py_arguments
  0005e	48 89 44 24 50	 mov	 QWORD PTR args$[rsp], rax

; 1560 :         if (!args)

  00063	48 83 7c 24 50
	00		 cmp	 QWORD PTR args$[rsp], 0
  00069	75 07		 jne	 SHORT $LN5@ast_for_la

; 1561 :             return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 b5 00 00 00	 jmp	 $LN7@ast_for_la
$LN5@ast_for_la:

; 1562 :         expression = ast_for_expr(c, CHILD(n, 2));

  00072	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00077	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007b	48 83 c0 50	 add	 rax, 80			; 00000050H
  0007f	48 8b d0	 mov	 rdx, rax
  00082	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00087	e8 00 00 00 00	 call	 ast_for_expr
  0008c	48 89 44 24 58	 mov	 QWORD PTR expression$[rsp], rax

; 1563 :         if (!expression)

  00091	48 83 7c 24 58
	00		 cmp	 QWORD PTR expression$[rsp], 0
  00097	75 07		 jne	 SHORT $LN4@ast_for_la

; 1564 :             return NULL;

  00099	33 c0		 xor	 eax, eax
  0009b	e9 87 00 00 00	 jmp	 $LN7@ast_for_la
$LN4@ast_for_la:

; 1565 :     }
; 1566 :     else {

  000a0	eb 56		 jmp	 SHORT $LN3@ast_for_la
$LN6@ast_for_la:

; 1567 :         args = ast_for_arguments(c, CHILD(n, 1));

  000a2	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000a7	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000ab	48 83 c0 28	 add	 rax, 40			; 00000028H
  000af	48 8b d0	 mov	 rdx, rax
  000b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000b7	e8 00 00 00 00	 call	 ast_for_arguments
  000bc	48 89 44 24 50	 mov	 QWORD PTR args$[rsp], rax

; 1568 :         if (!args)

  000c1	48 83 7c 24 50
	00		 cmp	 QWORD PTR args$[rsp], 0
  000c7	75 04		 jne	 SHORT $LN2@ast_for_la

; 1569 :             return NULL;

  000c9	33 c0		 xor	 eax, eax
  000cb	eb 5a		 jmp	 SHORT $LN7@ast_for_la
$LN2@ast_for_la:

; 1570 :         expression = ast_for_expr(c, CHILD(n, 3));

  000cd	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000d2	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000d6	48 83 c0 78	 add	 rax, 120		; 00000078H
  000da	48 8b d0	 mov	 rdx, rax
  000dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000e2	e8 00 00 00 00	 call	 ast_for_expr
  000e7	48 89 44 24 58	 mov	 QWORD PTR expression$[rsp], rax

; 1571 :         if (!expression)

  000ec	48 83 7c 24 58
	00		 cmp	 QWORD PTR expression$[rsp], 0
  000f2	75 04		 jne	 SHORT $LN1@ast_for_la

; 1572 :             return NULL;

  000f4	33 c0		 xor	 eax, eax
  000f6	eb 2f		 jmp	 SHORT $LN7@ast_for_la
$LN1@ast_for_la:
$LN3@ast_for_la:

; 1573 :     }
; 1574 : 
; 1575 :     return Lambda(args, expression, LINENO(n), n->n_col_offset, c->c_arena);

  000f8	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  000fd	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00101	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00106	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0010b	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0010f	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00114	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00118	48 8b 54 24 58	 mov	 rdx, QWORD PTR expression$[rsp]
  0011d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR args$[rsp]
  00122	e8 00 00 00 00	 call	 _Py_Lambda
$LN7@ast_for_la:

; 1576 : }

  00127	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0012b	c3		 ret	 0
ast_for_lambdef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@EMEDAENJ@unexpected?5node?5in?5varargslist?3?5@ ; `string'
PUBLIC	??_C@_1FC@PEJCECP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAf?$AAp?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN@ ; `string'
PUBLIC	??_C@_0CD@MPPDOCEK@named?5arguments?5must?5follow?5bare@ ; `string'
PUBLIC	??_C@_1EO@IBDCFMHI@?$AA?$CI?$AAp?$AAo?$AAs?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAp?$AAo?$AAs?$AAa?$AAr?$AAg?$AAs?$AA?$CJ@ ; `string'
PUBLIC	??_C@_0CO@BBDJNKDC@non?9default?5argument?5follows?5def@ ; `string'
PUBLIC	??_C@_1FO@DOPFLHLL@?$AA?$CI?$AAp?$AAo?$AAs?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAp?$AAo?$AAs?$AAd@ ; `string'
PUBLIC	??_C@_1CI@FGDJDGDO@?$AAp?$AAo?$AAs?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BI@ENJBOKKG@more?5than?5255?5arguments?$AA@ ; `string'
PUBLIC	??_C@_1GG@KGBODOLN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAy?$AAp?$AAe?$AAd?$AAa?$AAr?$AAg?$AAs?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_arguments DD imagerel ast_for_arguments
	DD	imagerel ast_for_arguments+2855
	DD	imagerel $unwind$ast_for_arguments
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_arguments DD 021101H
	DD	0230111H
xdata	ENDS
;	COMDAT ??_C@_0CI@EMEDAENJ@unexpected?5node?5in?5varargslist?3?5@
CONST	SEGMENT
??_C@_0CI@EMEDAENJ@unexpected?5node?5in?5varargslist?3?5@ DB 'unexpected '
	DB	'node in varargslist: %d @ %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@PEJCECP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAf?$AAp?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN@
CONST	SEGMENT
??_C@_1FC@PEJCECP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAf?$AAp?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'c', 00H, 'h', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't', 00H, 'f'
	DB	00H, 'p', 00H, 'd', 00H, 'e', 00H, 'f', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H, '('
	DB	00H, 'c', 00H, 'h', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'v', 00H, 'f', 00H, 'p', 00H, 'd', 00H, 'e', 00H, 'f'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MPPDOCEK@named?5arguments?5must?5follow?5bare@
CONST	SEGMENT
??_C@_0CD@MPPDOCEK@named?5arguments?5must?5follow?5bare@ DB 'named argume'
	DB	'nts must follow bare *', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@IBDCFMHI@?$AA?$CI?$AAp?$AAo?$AAs?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAp?$AAo?$AAs?$AAa?$AAr?$AAg?$AAs?$AA?$CJ@
CONST	SEGMENT
??_C@_1EO@IBDCFMHI@?$AA?$CI?$AAp?$AAo?$AAs?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAp?$AAo?$AAs?$AAa?$AAr?$AAg?$AAs?$AA?$CJ@ DB '('
	DB	00H, 'p', 00H, 'o', 00H, 's', 00H, 'a', 00H, 'r', 00H, 'g', 00H
	DB	's', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_'
	DB	00H, 'a', 00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H, 'i', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, '(', 00H, 'p', 00H, 'o', 00H, 's'
	DB	00H, 'a', 00H, 'r', 00H, 'g', 00H, 's', 00H, ')', 00H, '-', 00H
	DB	'>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@BBDJNKDC@non?9default?5argument?5follows?5def@
CONST	SEGMENT
??_C@_0CO@BBDJNKDC@non?9default?5argument?5follows?5def@ DB 'non-default '
	DB	'argument follows default argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@DOPFLHLL@?$AA?$CI?$AAp?$AAo?$AAs?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAp?$AAo?$AAs?$AAd@
CONST	SEGMENT
??_C@_1FO@DOPFLHLL@?$AA?$CI?$AAp?$AAo?$AAs?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAp?$AAo?$AAs?$AAd@ DB '('
	DB	00H, 'p', 00H, 'o', 00H, 's', 00H, 'd', 00H, 'e', 00H, 'f', 00H
	DB	'a', 00H, 'u', 00H, 'l', 00H, 't', 00H, 's', 00H, ')', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's', 00H
	DB	'd', 00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' '
	DB	00H, '(', 00H, 'p', 00H, 'o', 00H, 's', 00H, 'd', 00H, 'e', 00H
	DB	'f', 00H, 'a', 00H, 'u', 00H, 'l', 00H, 't', 00H, 's', 00H, ')'
	DB	00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@FGDJDGDO@?$AAp?$AAo?$AAs?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@FGDJDGDO@?$AAp?$AAo?$AAs?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 'a', 00H
	DB	'u', 00H, 'l', 00H, 't', 00H, 's', 00H, ' ', 00H, '!', 00H, '='
	DB	00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ENJBOKKG@more?5than?5255?5arguments?$AA@
CONST	SEGMENT
??_C@_0BI@ENJBOKKG@more?5than?5255?5arguments?$AA@ DB 'more than 255 argu'
	DB	'ments', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1GG@KGBODOLN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAy?$AAp?$AAe?$AAd?$AAa?$AAr?$AAg?$AAs?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE@
CONST	SEGMENT
??_C@_1GG@KGBODOLN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAy?$AAp?$AAe?$AAd?$AAa?$AAr?$AAg?$AAs?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't', 00H, 'y', 00H, 'p'
	DB	00H, 'e', 00H, 'd', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 's', 00H
	DB	'l', 00H, 'i', 00H, 's', 00H, 't', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H
	DB	'n', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'v'
	DB	00H, 'a', 00H, 'r', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 's', 00H
	DB	'l', 00H, 'i', 00H, 's', 00H, 't', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_arguments
_TEXT	SEGMENT
kwargannotation$ = 80
kwonlyargs$ = 88
arg$ = 96
i$ = 104
kwarg$ = 112
nkwonlyargs$ = 120
varargannotation$ = 128
kwdefaults$ = 136
k$ = 144
posdefaults$ = 152
posargs$ = 160
nposargs$ = 168
ch$ = 176
vararg$ = 184
found_default$ = 192
nposdefaults$ = 196
j$ = 200
expression$22793 = 208
_asdl_i$22799 = 216
_asdl_i$22808 = 220
res$22815 = 224
res$22828 = 228
tv176 = 232
tv185 = 240
tv194 = 248
tv203 = 256
tv218 = 264
c$ = 288
n$ = 296
ast_for_arguments PROC					; COMDAT

; 1214 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 1215 :     /* This function handles both typedargslist (function definition)
; 1216 :        and varargslist (lambda definition).
; 1217 : 
; 1218 :        parameters: '(' [typedargslist] ')'
; 1219 :        typedargslist: ((tfpdef ['=' test] ',')*
; 1220 :            ('*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef]
; 1221 :            | '**' tfpdef)
; 1222 :            | tfpdef ['=' test] (',' tfpdef ['=' test])* [','])
; 1223 :        tfpdef: NAME [':' test]
; 1224 :        varargslist: ((vfpdef ['=' test] ',')*
; 1225 :            ('*' [vfpdef] (',' vfpdef ['=' test])*  [',' '**' vfpdef]
; 1226 :            | '**' vfpdef)
; 1227 :            | vfpdef ['=' test] (',' vfpdef ['=' test])* [','])
; 1228 :        vfpdef: NAME
; 1229 :     */
; 1230 :     int i, j, k, nposargs = 0, nkwonlyargs = 0;

  00011	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR nposargs$[rsp], 0
  0001c	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR nkwonlyargs$[rsp], 0

; 1231 :     int nposdefaults = 0, found_default = 0;

  00024	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR nposdefaults$[rsp], 0
  0002f	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR found_default$[rsp], 0

; 1232 :     asdl_seq *posargs, *posdefaults, *kwonlyargs, *kwdefaults;
; 1233 :     identifier vararg = NULL, kwarg = NULL;

  0003a	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR vararg$[rsp], 0
  00046	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR kwarg$[rsp], 0

; 1234 :     arg_ty arg;
; 1235 :     expr_ty varargannotation = NULL, kwargannotation = NULL;

  0004f	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR varargannotation$[rsp], 0
  0005b	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR kwargannotation$[rsp], 0

; 1236 :     node *ch;
; 1237 : 
; 1238 :     if (TYPE(n) == parameters) {

  00064	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0006c	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0006f	3d 07 01 00 00	 cmp	 eax, 263		; 00000107H
  00074	75 6f		 jne	 SHORT $LN51@ast_for_ar

; 1239 :         if (NCH(n) == 2) /* () as argument list */

  00076	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0007e	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  00082	75 49		 jne	 SHORT $LN50@ast_for_ar

; 1240 :             return arguments(NULL, NULL, NULL, NULL, NULL, NULL, NULL,
; 1241 :                              NULL, c->c_arena);

  00084	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0008c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00090	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00095	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0009e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000a7	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000b0	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000b9	45 33 c9	 xor	 r9d, r9d
  000bc	45 33 c0	 xor	 r8d, r8d
  000bf	33 d2		 xor	 edx, edx
  000c1	33 c9		 xor	 ecx, ecx
  000c3	e8 00 00 00 00	 call	 _Py_arguments
  000c8	e9 52 0a 00 00	 jmp	 $LN52@ast_for_ar
$LN50@ast_for_ar:

; 1242 :         n = CHILD(n, 1);

  000cd	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000d5	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000d9	48 83 c0 28	 add	 rax, 40			; 00000028H
  000dd	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR n$[rsp], rax
$LN51@ast_for_ar:

; 1243 :     }
; 1244 :     assert(TYPE(n) == typedargslist || TYPE(n) == varargslist);

  000e5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000ed	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000f0	3d 08 01 00 00	 cmp	 eax, 264		; 00000108H
  000f5	74 2e		 je	 SHORT $LN54@ast_for_ar
  000f7	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000ff	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00102	3d 0a 01 00 00	 cmp	 eax, 266		; 0000010aH
  00107	74 1c		 je	 SHORT $LN54@ast_for_ar
  00109	41 b8 dc 04 00
	00		 mov	 r8d, 1244		; 000004dcH
  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GG@KGBODOLN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAy?$AAp?$AAe?$AAd?$AAa?$AAr?$AAg?$AAs?$AAl?$AAi?$AAs?$AAt?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE@
  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00123	33 c0		 xor	 eax, eax
$LN54@ast_for_ar:

; 1245 : 
; 1246 :     /* First count the number of positional args & defaults.  The
; 1247 :        variable i is the loop index for this for loop and the next.
; 1248 :        The next loop picks up where the first leaves off.
; 1249 :     */
; 1250 :     for (i = 0; i < NCH(n); i++) {

  00125	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0012d	eb 0a		 jmp	 SHORT $LN49@ast_for_ar
$LN48@ast_for_ar:
  0012f	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00133	ff c0		 inc	 eax
  00135	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN49@ast_for_ar:
  00139	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00141	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00144	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  00148	0f 8d ff 00 00
	00		 jge	 $LN47@ast_for_ar

; 1251 :         ch = CHILD(n, i);

  0014e	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00153	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00157	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0015f	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00163	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ch$[rsp], rax

; 1252 :         if (TYPE(ch) == STAR) {

  0016b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  00173	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00176	83 f8 10	 cmp	 eax, 16
  00179	75 67		 jne	 SHORT $LN46@ast_for_ar

; 1253 :             /* skip star */
; 1254 :             i++;

  0017b	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0017f	ff c0		 inc	 eax
  00181	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1255 :             if (i < NCH(n) && /* skip argument following star */
; 1256 :                 (TYPE(CHILD(n, i)) == tfpdef ||
; 1257 :                  TYPE(CHILD(n, i)) == vfpdef)) {

  00185	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0018d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00190	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  00194	7d 4a		 jge	 SHORT $LN45@ast_for_ar
  00196	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  0019b	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0019f	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  001a7	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  001ab	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  001af	3d 09 01 00 00	 cmp	 eax, 265		; 00000109H
  001b4	74 20		 je	 SHORT $LN44@ast_for_ar
  001b6	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  001bb	48 6b c0 28	 imul	 rax, 40			; 00000028H
  001bf	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  001c7	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  001cb	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  001cf	3d 0b 01 00 00	 cmp	 eax, 267		; 0000010bH
  001d4	75 0a		 jne	 SHORT $LN45@ast_for_ar
$LN44@ast_for_ar:

; 1258 :                 i++;

  001d6	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  001da	ff c0		 inc	 eax
  001dc	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN45@ast_for_ar:

; 1259 :             }
; 1260 :             break;

  001e0	eb 6b		 jmp	 SHORT $LN47@ast_for_ar
$LN46@ast_for_ar:

; 1261 :         }
; 1262 :         if (TYPE(ch) == DOUBLESTAR) break;

  001e2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  001ea	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001ed	83 f8 23	 cmp	 eax, 35			; 00000023H
  001f0	75 02		 jne	 SHORT $LN43@ast_for_ar
  001f2	eb 59		 jmp	 SHORT $LN47@ast_for_ar
$LN43@ast_for_ar:

; 1263 :         if (TYPE(ch) == vfpdef || TYPE(ch) == tfpdef) nposargs++;

  001f4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  001fc	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001ff	3d 0b 01 00 00	 cmp	 eax, 267		; 0000010bH
  00204	74 12		 je	 SHORT $LN41@ast_for_ar
  00206	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  0020e	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00211	3d 09 01 00 00	 cmp	 eax, 265		; 00000109H
  00216	75 10		 jne	 SHORT $LN42@ast_for_ar
$LN41@ast_for_ar:
  00218	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR nposargs$[rsp]
  0021f	ff c0		 inc	 eax
  00221	89 84 24 a8 00
	00 00		 mov	 DWORD PTR nposargs$[rsp], eax
$LN42@ast_for_ar:

; 1264 :         if (TYPE(ch) == EQUAL) nposdefaults++;

  00228	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  00230	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00233	83 f8 16	 cmp	 eax, 22
  00236	75 10		 jne	 SHORT $LN40@ast_for_ar
  00238	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR nposdefaults$[rsp]
  0023f	ff c0		 inc	 eax
  00241	89 84 24 c4 00
	00 00		 mov	 DWORD PTR nposdefaults$[rsp], eax
$LN40@ast_for_ar:

; 1265 :     }

  00248	e9 e2 fe ff ff	 jmp	 $LN48@ast_for_ar
$LN47@ast_for_ar:

; 1266 :     /* count the number of keyword only args &
; 1267 :        defaults for keyword only args */
; 1268 :     for ( ; i < NCH(n); ++i) {

  0024d	eb 0a		 jmp	 SHORT $LN39@ast_for_ar
$LN38@ast_for_ar:
  0024f	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00253	ff c0		 inc	 eax
  00255	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN39@ast_for_ar:
  00259	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00261	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00264	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  00268	7d 5f		 jge	 SHORT $LN37@ast_for_ar

; 1269 :         ch = CHILD(n, i);

  0026a	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  0026f	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00273	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0027b	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0027f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ch$[rsp], rax

; 1270 :         if (TYPE(ch) == DOUBLESTAR) break;

  00287	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  0028f	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00292	83 f8 23	 cmp	 eax, 35			; 00000023H
  00295	75 02		 jne	 SHORT $LN36@ast_for_ar
  00297	eb 30		 jmp	 SHORT $LN37@ast_for_ar
$LN36@ast_for_ar:

; 1271 :         if (TYPE(ch) == tfpdef || TYPE(ch) == vfpdef) nkwonlyargs++;

  00299	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  002a1	0f bf 00	 movsx	 eax, WORD PTR [rax]
  002a4	3d 09 01 00 00	 cmp	 eax, 265		; 00000109H
  002a9	74 12		 je	 SHORT $LN34@ast_for_ar
  002ab	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  002b3	0f bf 00	 movsx	 eax, WORD PTR [rax]
  002b6	3d 0b 01 00 00	 cmp	 eax, 267		; 0000010bH
  002bb	75 0a		 jne	 SHORT $LN35@ast_for_ar
$LN34@ast_for_ar:
  002bd	8b 44 24 78	 mov	 eax, DWORD PTR nkwonlyargs$[rsp]
  002c1	ff c0		 inc	 eax
  002c3	89 44 24 78	 mov	 DWORD PTR nkwonlyargs$[rsp], eax
$LN35@ast_for_ar:

; 1272 :     }

  002c7	eb 86		 jmp	 SHORT $LN38@ast_for_ar
$LN37@ast_for_ar:

; 1273 :     posargs = (nposargs ? asdl_seq_new(nposargs, c->c_arena) : NULL);

  002c9	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR nposargs$[rsp], 0
  002d1	74 26		 je	 SHORT $LN55@ast_for_ar
  002d3	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR nposargs$[rsp]
  002db	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002e3	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  002e7	48 8b c8	 mov	 rcx, rax
  002ea	e8 00 00 00 00	 call	 asdl_seq_new
  002ef	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
  002f7	eb 0c		 jmp	 SHORT $LN56@ast_for_ar
$LN55@ast_for_ar:
  002f9	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv176[rsp], 0
$LN56@ast_for_ar:
  00305	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv176[rsp]
  0030d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR posargs$[rsp], rax

; 1274 :     if (!posargs && nposargs)

  00315	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR posargs$[rsp], 0
  0031e	75 11		 jne	 SHORT $LN33@ast_for_ar
  00320	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR nposargs$[rsp], 0
  00328	74 07		 je	 SHORT $LN33@ast_for_ar

; 1275 :         return NULL;

  0032a	33 c0		 xor	 eax, eax
  0032c	e9 ee 07 00 00	 jmp	 $LN52@ast_for_ar
$LN33@ast_for_ar:

; 1276 :     kwonlyargs = (nkwonlyargs ?
; 1277 :                    asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);

  00331	83 7c 24 78 00	 cmp	 DWORD PTR nkwonlyargs$[rsp], 0
  00336	74 23		 je	 SHORT $LN57@ast_for_ar
  00338	48 63 44 24 78	 movsxd	 rax, DWORD PTR nkwonlyargs$[rsp]
  0033d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00345	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00349	48 8b c8	 mov	 rcx, rax
  0034c	e8 00 00 00 00	 call	 asdl_seq_new
  00351	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv185[rsp], rax
  00359	eb 0c		 jmp	 SHORT $LN58@ast_for_ar
$LN57@ast_for_ar:
  0035b	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv185[rsp], 0
$LN58@ast_for_ar:
  00367	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv185[rsp]
  0036f	48 89 44 24 58	 mov	 QWORD PTR kwonlyargs$[rsp], rax

; 1278 :     if (!kwonlyargs && nkwonlyargs)

  00374	48 83 7c 24 58
	00		 cmp	 QWORD PTR kwonlyargs$[rsp], 0
  0037a	75 0e		 jne	 SHORT $LN32@ast_for_ar
  0037c	83 7c 24 78 00	 cmp	 DWORD PTR nkwonlyargs$[rsp], 0
  00381	74 07		 je	 SHORT $LN32@ast_for_ar

; 1279 :         return NULL;

  00383	33 c0		 xor	 eax, eax
  00385	e9 95 07 00 00	 jmp	 $LN52@ast_for_ar
$LN32@ast_for_ar:

; 1280 :     posdefaults = (nposdefaults ?
; 1281 :                     asdl_seq_new(nposdefaults, c->c_arena) : NULL);

  0038a	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR nposdefaults$[rsp], 0
  00392	74 26		 je	 SHORT $LN59@ast_for_ar
  00394	48 63 84 24 c4
	00 00 00	 movsxd	 rax, DWORD PTR nposdefaults$[rsp]
  0039c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003a4	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  003a8	48 8b c8	 mov	 rcx, rax
  003ab	e8 00 00 00 00	 call	 asdl_seq_new
  003b0	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv194[rsp], rax
  003b8	eb 0c		 jmp	 SHORT $LN60@ast_for_ar
$LN59@ast_for_ar:
  003ba	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv194[rsp], 0
$LN60@ast_for_ar:
  003c6	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv194[rsp]
  003ce	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR posdefaults$[rsp], rax

; 1282 :     if (!posdefaults && nposdefaults)

  003d6	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR posdefaults$[rsp], 0
  003df	75 11		 jne	 SHORT $LN31@ast_for_ar
  003e1	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR nposdefaults$[rsp], 0
  003e9	74 07		 je	 SHORT $LN31@ast_for_ar

; 1283 :         return NULL;

  003eb	33 c0		 xor	 eax, eax
  003ed	e9 2d 07 00 00	 jmp	 $LN52@ast_for_ar
$LN31@ast_for_ar:

; 1284 :     /* The length of kwonlyargs and kwdefaults are same
; 1285 :        since we set NULL as default for keyword only argument w/o default
; 1286 :        - we have sequence data structure, but no dictionary */
; 1287 :     kwdefaults = (nkwonlyargs ?
; 1288 :                    asdl_seq_new(nkwonlyargs, c->c_arena) : NULL);

  003f2	83 7c 24 78 00	 cmp	 DWORD PTR nkwonlyargs$[rsp], 0
  003f7	74 23		 je	 SHORT $LN61@ast_for_ar
  003f9	48 63 44 24 78	 movsxd	 rax, DWORD PTR nkwonlyargs$[rsp]
  003fe	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00406	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0040a	48 8b c8	 mov	 rcx, rax
  0040d	e8 00 00 00 00	 call	 asdl_seq_new
  00412	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv203[rsp], rax
  0041a	eb 0c		 jmp	 SHORT $LN62@ast_for_ar
$LN61@ast_for_ar:
  0041c	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv203[rsp], 0
$LN62@ast_for_ar:
  00428	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv203[rsp]
  00430	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR kwdefaults$[rsp], rax

; 1289 :     if (!kwdefaults && nkwonlyargs)

  00438	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR kwdefaults$[rsp], 0
  00441	75 0e		 jne	 SHORT $LN30@ast_for_ar
  00443	83 7c 24 78 00	 cmp	 DWORD PTR nkwonlyargs$[rsp], 0
  00448	74 07		 je	 SHORT $LN30@ast_for_ar

; 1290 :         return NULL;

  0044a	33 c0		 xor	 eax, eax
  0044c	e9 ce 06 00 00	 jmp	 $LN52@ast_for_ar
$LN30@ast_for_ar:

; 1291 : 
; 1292 :     if (nposargs + nkwonlyargs > 255) {

  00451	8b 44 24 78	 mov	 eax, DWORD PTR nkwonlyargs$[rsp]
  00455	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR nposargs$[rsp]
  0045c	03 c8		 add	 ecx, eax
  0045e	8b c1		 mov	 eax, ecx
  00460	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00465	7e 23		 jle	 SHORT $LN29@ast_for_ar

; 1293 :         ast_error(c, n, "more than 255 arguments");

  00467	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BI@ENJBOKKG@more?5than?5255?5arguments?$AA@
  0046e	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  00476	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0047e	e8 00 00 00 00	 call	 ast_error

; 1294 :         return NULL;

  00483	33 c0		 xor	 eax, eax
  00485	e9 95 06 00 00	 jmp	 $LN52@ast_for_ar
$LN29@ast_for_ar:

; 1295 :     }
; 1296 : 
; 1297 :     /* tfpdef: NAME [':' test]
; 1298 :        vfpdef: NAME
; 1299 :     */
; 1300 :     i = 0;

  0048a	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 1301 :     j = 0;  /* index for defaults */

  00492	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0

; 1302 :     k = 0;  /* index for args */

  0049d	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR k$[rsp], 0
$LN28@ast_for_ar:

; 1303 :     while (i < NCH(n)) {

  004a8	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  004b0	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  004b3	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  004b7	0f 8d 01 06 00
	00		 jge	 $LN27@ast_for_ar

; 1304 :         ch = CHILD(n, i);

  004bd	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  004c2	48 6b c0 28	 imul	 rax, 40			; 00000028H
  004c6	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  004ce	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  004d2	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ch$[rsp], rax

; 1305 :         switch (TYPE(ch)) {

  004da	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  004e2	0f bf 00	 movsx	 eax, WORD PTR [rax]
  004e5	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv218[rsp], eax
  004ec	83 bc 24 08 01
	00 00 10	 cmp	 DWORD PTR tv218[rsp], 16
  004f4	0f 84 3c 02 00
	00		 je	 $LN18@ast_for_ar
  004fa	83 bc 24 08 01
	00 00 23	 cmp	 DWORD PTR tv218[rsp], 35 ; 00000023H
  00502	0f 84 7b 04 00
	00		 je	 $LN6@ast_for_ar
  00508	81 bc 24 08 01
	00 00 09 01 00
	00		 cmp	 DWORD PTR tv218[rsp], 265 ; 00000109H
  00513	74 12		 je	 SHORT $LN24@ast_for_ar
  00515	81 bc 24 08 01
	00 00 0b 01 00
	00		 cmp	 DWORD PTR tv218[rsp], 267 ; 0000010bH
  00520	74 05		 je	 SHORT $LN24@ast_for_ar
  00522	e9 68 05 00 00	 jmp	 $LN1@ast_for_ar
$LN24@ast_for_ar:

; 1306 :             case tfpdef:
; 1307 :             case vfpdef:
; 1308 :                 /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is
; 1309 :                    anything other than EQUAL or a comma? */
; 1310 :                 /* XXX Should NCH(n) check be made a separate check? */
; 1311 :                 if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {

  00527	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0052b	ff c0		 inc	 eax
  0052d	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00535	3b 41 18	 cmp	 eax, DWORD PTR [rcx+24]
  00538	0f 8d 1e 01 00
	00		 jge	 $LN23@ast_for_ar
  0053e	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00542	ff c0		 inc	 eax
  00544	48 98		 cdqe
  00546	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0054a	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00552	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00556	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0055a	83 f8 16	 cmp	 eax, 22
  0055d	0f 85 f9 00 00
	00		 jne	 $LN23@ast_for_ar

; 1312 :                     expr_ty expression = ast_for_expr(c, CHILD(n, i + 2));

  00563	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00567	83 c0 02	 add	 eax, 2
  0056a	48 98		 cdqe
  0056c	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00570	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00578	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0057c	48 8b d0	 mov	 rdx, rax
  0057f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00587	e8 00 00 00 00	 call	 ast_for_expr
  0058c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR expression$22793[rsp], rax

; 1313 :                     if (!expression)

  00594	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR expression$22793[rsp], 0
  0059d	75 07		 jne	 SHORT $LN22@ast_for_ar

; 1314 :                         return NULL;

  0059f	33 c0		 xor	 eax, eax
  005a1	e9 79 05 00 00	 jmp	 $LN52@ast_for_ar
$LN22@ast_for_ar:

; 1315 :                     assert(posdefaults != NULL);

  005a6	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR posdefaults$[rsp], 0
  005af	75 1c		 jne	 SHORT $LN63@ast_for_ar
  005b1	41 b8 23 05 00
	00		 mov	 r8d, 1315		; 00000523H
  005b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  005be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@FGDJDGDO@?$AAp?$AAo?$AAs?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  005c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005cb	33 c0		 xor	 eax, eax
$LN63@ast_for_ar:

; 1316 :                     asdl_seq_SET(posdefaults, j++, expression);

  005cd	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  005d4	89 84 24 d8 00
	00 00		 mov	 DWORD PTR _asdl_i$22799[rsp], eax
  005db	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  005e2	ff c0		 inc	 eax
  005e4	89 84 24 c8 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
  005eb	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR posdefaults$[rsp], 0
  005f4	74 15		 je	 SHORT $LN64@ast_for_ar
  005f6	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22799[rsp]
  005fe	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR posdefaults$[rsp]
  00606	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00609	7c 1c		 jl	 SHORT $LN65@ast_for_ar
$LN64@ast_for_ar:
  0060b	41 b8 24 05 00
	00		 mov	 r8d, 1316		; 00000524H
  00611	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00618	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@DOPFLHLL@?$AA?$CI?$AAp?$AAo?$AAs?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAp?$AAo?$AAs?$AAd@
  0061f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00625	33 c0		 xor	 eax, eax
$LN65@ast_for_ar:
  00627	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22799[rsp]
  0062f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR posdefaults$[rsp]
  00637	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR expression$22793[rsp]
  0063f	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 1317 :                     i += 2;

  00644	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00648	83 c0 02	 add	 eax, 2
  0064b	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1318 :                     found_default = 1;

  0064f	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR found_default$[rsp], 1
  0065a	eb 2d		 jmp	 SHORT $LN21@ast_for_ar
$LN23@ast_for_ar:

; 1319 :                 }
; 1320 :                 else if (found_default) {

  0065c	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR found_default$[rsp], 0
  00664	74 23		 je	 SHORT $LN20@ast_for_ar

; 1321 :                     ast_error(c, n,
; 1322 :                              "non-default argument follows default argument");

  00666	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CO@BBDJNKDC@non?9default?5argument?5follows?5def@
  0066d	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  00675	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0067d	e8 00 00 00 00	 call	 ast_error

; 1323 :                     return NULL;

  00682	33 c0		 xor	 eax, eax
  00684	e9 96 04 00 00	 jmp	 $LN52@ast_for_ar
$LN20@ast_for_ar:
$LN21@ast_for_ar:

; 1324 :                 }
; 1325 :                 arg = ast_for_arg(c, ch);

  00689	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ch$[rsp]
  00691	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00699	e8 00 00 00 00	 call	 ast_for_arg
  0069e	48 89 44 24 60	 mov	 QWORD PTR arg$[rsp], rax

; 1326 :                 if (!arg)

  006a3	48 83 7c 24 60
	00		 cmp	 QWORD PTR arg$[rsp], 0
  006a9	75 07		 jne	 SHORT $LN19@ast_for_ar

; 1327 :                     return NULL;

  006ab	33 c0		 xor	 eax, eax
  006ad	e9 6d 04 00 00	 jmp	 $LN52@ast_for_ar
$LN19@ast_for_ar:

; 1328 :                 asdl_seq_SET(posargs, k++, arg);

  006b2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  006b9	89 84 24 dc 00
	00 00		 mov	 DWORD PTR _asdl_i$22808[rsp], eax
  006c0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  006c7	ff c0		 inc	 eax
  006c9	89 84 24 90 00
	00 00		 mov	 DWORD PTR k$[rsp], eax
  006d0	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR posargs$[rsp], 0
  006d9	74 15		 je	 SHORT $LN66@ast_for_ar
  006db	48 63 84 24 dc
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22808[rsp]
  006e3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR posargs$[rsp]
  006eb	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  006ee	7c 1c		 jl	 SHORT $LN67@ast_for_ar
$LN66@ast_for_ar:
  006f0	41 b8 30 05 00
	00		 mov	 r8d, 1328		; 00000530H
  006f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  006fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@IBDCFMHI@?$AA?$CI?$AAp?$AAo?$AAs?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAp?$AAo?$AAs?$AAa?$AAr?$AAg?$AAs?$AA?$CJ@
  00704	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0070a	33 c0		 xor	 eax, eax
$LN67@ast_for_ar:
  0070c	48 63 84 24 dc
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$22808[rsp]
  00714	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR posargs$[rsp]
  0071c	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  00721	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 1329 :                 i += 2; /* the name and the comma */

  00726	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0072a	83 c0 02	 add	 eax, 2
  0072d	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1330 :                 break;

  00731	e9 83 03 00 00	 jmp	 $LN25@ast_for_ar
$LN18@ast_for_ar:

; 1331 :             case STAR:
; 1332 :                 if (i+1 >= NCH(n)) {

  00736	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0073a	ff c0		 inc	 eax
  0073c	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00744	3b 41 18	 cmp	 eax, DWORD PTR [rcx+24]
  00747	7c 33		 jl	 SHORT $LN17@ast_for_ar

; 1333 :                     ast_error(c, CHILD(n, i),
; 1334 :                         "named arguments must follow bare *");

  00749	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  0074e	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00752	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0075a	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0075e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CD@MPPDOCEK@named?5arguments?5must?5follow?5bare@
  00765	48 8b d0	 mov	 rdx, rax
  00768	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00770	e8 00 00 00 00	 call	 ast_error

; 1335 :                     return NULL;

  00775	33 c0		 xor	 eax, eax
  00777	e9 a3 03 00 00	 jmp	 $LN52@ast_for_ar
$LN17@ast_for_ar:

; 1336 :                 }
; 1337 :                 ch = CHILD(n, i+1);  /* tfpdef or COMMA */

  0077c	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00780	ff c0		 inc	 eax
  00782	48 98		 cdqe
  00784	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00788	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00790	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00794	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ch$[rsp], rax

; 1338 :                 if (TYPE(ch) == COMMA) {

  0079c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  007a4	0f bf 00	 movsx	 eax, WORD PTR [rax]
  007a7	83 f8 0c	 cmp	 eax, 12
  007aa	75 6a		 jne	 SHORT $LN16@ast_for_ar

; 1339 :                     int res = 0;

  007ac	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR res$22815[rsp], 0

; 1340 :                     i += 2; /* now follows keyword only arguments */

  007b7	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  007bb	83 c0 02	 add	 eax, 2
  007be	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1341 :                     res = handle_keywordonly_args(c, n, i,
; 1342 :                                                   kwonlyargs, kwdefaults);

  007c2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR kwdefaults$[rsp]
  007ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007cf	4c 8b 4c 24 58	 mov	 r9, QWORD PTR kwonlyargs$[rsp]
  007d4	44 8b 44 24 68	 mov	 r8d, DWORD PTR i$[rsp]
  007d9	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  007e1	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  007e9	e8 00 00 00 00	 call	 handle_keywordonly_args
  007ee	89 84 24 e0 00
	00 00		 mov	 DWORD PTR res$22815[rsp], eax

; 1343 :                     if (res == -1) return NULL;

  007f5	83 bc 24 e0 00
	00 00 ff	 cmp	 DWORD PTR res$22815[rsp], -1
  007fd	75 07		 jne	 SHORT $LN15@ast_for_ar
  007ff	33 c0		 xor	 eax, eax
  00801	e9 19 03 00 00	 jmp	 $LN52@ast_for_ar
$LN15@ast_for_ar:

; 1344 :                     i = res; /* res has new position to process */

  00806	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR res$22815[rsp]
  0080d	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1345 :                 }
; 1346 :                 else {

  00811	e9 68 01 00 00	 jmp	 $LN14@ast_for_ar
$LN16@ast_for_ar:

; 1347 :                     vararg = NEW_IDENTIFIER(CHILD(ch, 0));

  00816	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  0081e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00822	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  0082a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0082e	e8 00 00 00 00	 call	 new_identifier
  00833	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR vararg$[rsp], rax

; 1348 :                     if (!vararg)

  0083b	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR vararg$[rsp], 0
  00844	75 07		 jne	 SHORT $LN13@ast_for_ar

; 1349 :                         return NULL;

  00846	33 c0		 xor	 eax, eax
  00848	e9 d2 02 00 00	 jmp	 $LN52@ast_for_ar
$LN13@ast_for_ar:

; 1350 :                     if (forbidden_name(c, vararg, CHILD(ch, 0), 0))

  0084d	45 33 c9	 xor	 r9d, r9d
  00850	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  00858	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  0085c	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR vararg$[rsp]
  00864	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0086c	e8 00 00 00 00	 call	 forbidden_name
  00871	85 c0		 test	 eax, eax
  00873	74 07		 je	 SHORT $LN12@ast_for_ar

; 1351 :                         return NULL;

  00875	33 c0		 xor	 eax, eax
  00877	e9 a3 02 00 00	 jmp	 $LN52@ast_for_ar
$LN12@ast_for_ar:

; 1352 :                     if (NCH(ch) > 1) {

  0087c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  00884	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00888	7e 3a		 jle	 SHORT $LN11@ast_for_ar

; 1353 :                         /* there is an annotation on the vararg */
; 1354 :                         varargannotation = ast_for_expr(c, CHILD(ch, 2));

  0088a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  00892	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00896	48 83 c0 50	 add	 rax, 80			; 00000050H
  0089a	48 8b d0	 mov	 rdx, rax
  0089d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  008a5	e8 00 00 00 00	 call	 ast_for_expr
  008aa	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR varargannotation$[rsp], rax

; 1355 :                         if (!varargannotation)

  008b2	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR varargannotation$[rsp], 0
  008bb	75 07		 jne	 SHORT $LN10@ast_for_ar

; 1356 :                             return NULL;

  008bd	33 c0		 xor	 eax, eax
  008bf	e9 5b 02 00 00	 jmp	 $LN52@ast_for_ar
$LN10@ast_for_ar:
$LN11@ast_for_ar:

; 1357 :                     }
; 1358 :                     i += 3;

  008c4	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  008c8	83 c0 03	 add	 eax, 3
  008cb	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1359 :                     if (i < NCH(n) && (TYPE(CHILD(n, i)) == tfpdef
; 1360 :                                     || TYPE(CHILD(n, i)) == vfpdef)) {

  008cf	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  008d7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  008da	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  008de	0f 8d 9a 00 00
	00		 jge	 $LN9@ast_for_ar
  008e4	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  008e9	48 6b c0 28	 imul	 rax, 40			; 00000028H
  008ed	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  008f5	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  008f9	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  008fd	3d 09 01 00 00	 cmp	 eax, 265		; 00000109H
  00902	74 20		 je	 SHORT $LN8@ast_for_ar
  00904	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00909	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0090d	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00915	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00919	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0091d	3d 0b 01 00 00	 cmp	 eax, 267		; 0000010bH
  00922	75 5a		 jne	 SHORT $LN9@ast_for_ar
$LN8@ast_for_ar:

; 1361 :                         int res = 0;

  00924	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR res$22828[rsp], 0

; 1362 :                         res = handle_keywordonly_args(c, n, i,
; 1363 :                                                       kwonlyargs, kwdefaults);

  0092f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR kwdefaults$[rsp]
  00937	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0093c	4c 8b 4c 24 58	 mov	 r9, QWORD PTR kwonlyargs$[rsp]
  00941	44 8b 44 24 68	 mov	 r8d, DWORD PTR i$[rsp]
  00946	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  0094e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00956	e8 00 00 00 00	 call	 handle_keywordonly_args
  0095b	89 84 24 e4 00
	00 00		 mov	 DWORD PTR res$22828[rsp], eax

; 1364 :                         if (res == -1) return NULL;

  00962	83 bc 24 e4 00
	00 00 ff	 cmp	 DWORD PTR res$22828[rsp], -1
  0096a	75 07		 jne	 SHORT $LN7@ast_for_ar
  0096c	33 c0		 xor	 eax, eax
  0096e	e9 ac 01 00 00	 jmp	 $LN52@ast_for_ar
$LN7@ast_for_ar:

; 1365 :                         i = res; /* res has new position to process */

  00973	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR res$22828[rsp]
  0097a	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN9@ast_for_ar:
$LN14@ast_for_ar:

; 1366 :                     }
; 1367 :                 }
; 1368 :                 break;

  0097e	e9 36 01 00 00	 jmp	 $LN25@ast_for_ar
$LN6@ast_for_ar:

; 1369 :             case DOUBLESTAR:
; 1370 :                 ch = CHILD(n, i+1);  /* tfpdef */

  00983	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00987	ff c0		 inc	 eax
  00989	48 98		 cdqe
  0098b	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0098f	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00997	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0099b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ch$[rsp], rax

; 1371 :                 assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);

  009a3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  009ab	0f bf 00	 movsx	 eax, WORD PTR [rax]
  009ae	3d 09 01 00 00	 cmp	 eax, 265		; 00000109H
  009b3	74 2e		 je	 SHORT $LN68@ast_for_ar
  009b5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  009bd	0f bf 00	 movsx	 eax, WORD PTR [rax]
  009c0	3d 0b 01 00 00	 cmp	 eax, 267		; 0000010bH
  009c5	74 1c		 je	 SHORT $LN68@ast_for_ar
  009c7	41 b8 5b 05 00
	00		 mov	 r8d, 1371		; 0000055bH
  009cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  009d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FC@PEJCECP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAf?$AAp?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN@
  009db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009e1	33 c0		 xor	 eax, eax
$LN68@ast_for_ar:

; 1372 :                 kwarg = NEW_IDENTIFIER(CHILD(ch, 0));

  009e3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  009eb	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  009ef	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  009f7	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  009fb	e8 00 00 00 00	 call	 new_identifier
  00a00	48 89 44 24 70	 mov	 QWORD PTR kwarg$[rsp], rax

; 1373 :                 if (!kwarg)

  00a05	48 83 7c 24 70
	00		 cmp	 QWORD PTR kwarg$[rsp], 0
  00a0b	75 07		 jne	 SHORT $LN5@ast_for_ar

; 1374 :                     return NULL;

  00a0d	33 c0		 xor	 eax, eax
  00a0f	e9 0b 01 00 00	 jmp	 $LN52@ast_for_ar
$LN5@ast_for_ar:

; 1375 :                 if (NCH(ch) > 1) {

  00a14	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  00a1c	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00a20	7e 34		 jle	 SHORT $LN4@ast_for_ar

; 1376 :                     /* there is an annotation on the kwarg */
; 1377 :                     kwargannotation = ast_for_expr(c, CHILD(ch, 2));

  00a22	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  00a2a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00a2e	48 83 c0 50	 add	 rax, 80			; 00000050H
  00a32	48 8b d0	 mov	 rdx, rax
  00a35	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00a3d	e8 00 00 00 00	 call	 ast_for_expr
  00a42	48 89 44 24 50	 mov	 QWORD PTR kwargannotation$[rsp], rax

; 1378 :                     if (!kwargannotation)

  00a47	48 83 7c 24 50
	00		 cmp	 QWORD PTR kwargannotation$[rsp], 0
  00a4d	75 07		 jne	 SHORT $LN3@ast_for_ar

; 1379 :                         return NULL;

  00a4f	33 c0		 xor	 eax, eax
  00a51	e9 c9 00 00 00	 jmp	 $LN52@ast_for_ar
$LN3@ast_for_ar:
$LN4@ast_for_ar:

; 1380 :                 }
; 1381 :                 if (forbidden_name(c, kwarg, CHILD(ch, 0), 0))

  00a56	45 33 c9	 xor	 r9d, r9d
  00a59	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  00a61	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  00a65	48 8b 54 24 70	 mov	 rdx, QWORD PTR kwarg$[rsp]
  00a6a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00a72	e8 00 00 00 00	 call	 forbidden_name
  00a77	85 c0		 test	 eax, eax
  00a79	74 07		 je	 SHORT $LN2@ast_for_ar

; 1382 :                     return NULL;

  00a7b	33 c0		 xor	 eax, eax
  00a7d	e9 9d 00 00 00	 jmp	 $LN52@ast_for_ar
$LN2@ast_for_ar:

; 1383 :                 i += 3;

  00a82	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00a86	83 c0 03	 add	 eax, 3
  00a89	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax

; 1384 :                 break;

  00a8d	eb 2a		 jmp	 SHORT $LN25@ast_for_ar
$LN1@ast_for_ar:

; 1385 :             default:
; 1386 :                 PyErr_Format(PyExc_SystemError,
; 1387 :                              "unexpected node in varargslist: %d @ %d",
; 1388 :                              TYPE(ch), i);

  00a8f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ch$[rsp]
  00a97	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00a9a	44 8b 4c 24 68	 mov	 r9d, DWORD PTR i$[rsp]
  00a9f	44 8b c0	 mov	 r8d, eax
  00aa2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@EMEDAENJ@unexpected?5node?5in?5varargslist?3?5@
  00aa9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00ab0	e8 00 00 00 00	 call	 PyErr_Format

; 1389 :                 return NULL;

  00ab5	33 c0		 xor	 eax, eax
  00ab7	eb 66		 jmp	 SHORT $LN52@ast_for_ar
$LN25@ast_for_ar:

; 1390 :         }
; 1391 :     }

  00ab9	e9 ea f9 ff ff	 jmp	 $LN28@ast_for_ar
$LN27@ast_for_ar:

; 1392 :     return arguments(posargs, vararg, varargannotation, kwonlyargs, kwarg,
; 1393 :                     kwargannotation, posdefaults, kwdefaults, c->c_arena);

  00abe	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00ac6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00aca	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00acf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR kwdefaults$[rsp]
  00ad7	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00adc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR posdefaults$[rsp]
  00ae4	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00ae9	48 8b 44 24 50	 mov	 rax, QWORD PTR kwargannotation$[rsp]
  00aee	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00af3	48 8b 44 24 70	 mov	 rax, QWORD PTR kwarg$[rsp]
  00af8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00afd	4c 8b 4c 24 58	 mov	 r9, QWORD PTR kwonlyargs$[rsp]
  00b02	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR varargannotation$[rsp]
  00b0a	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR vararg$[rsp]
  00b12	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR posargs$[rsp]
  00b1a	e8 00 00 00 00	 call	 _Py_arguments
$LN52@ast_for_ar:

; 1394 : }

  00b1f	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00b26	c3		 ret	 0
ast_for_arguments ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CI@IEEJGGAO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CO@HAMDKJMB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyArena_AddPyObject:PROC
EXTRN	PyUnicode_InternInPlace:PROC
EXTRN	PyObject_Call:PROC
EXTRN	PyUnicode_DecodeUTF8:PROC
EXTRN	strlen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_identifier DD imagerel new_identifier
	DD	imagerel new_identifier+382
	DD	imagerel $unwind$new_identifier
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_identifier DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1CI@IEEJGGAO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@IEEJGGAO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'i', 00H, 'd', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@HAMDKJMB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@HAMDKJMB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'i', 00H
	DB	'd', 00H, ')', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT new_identifier
_TEXT	SEGMENT
id$ = 32
id2$22267 = 40
n$ = 64
c$ = 72
new_identifier PROC					; COMDAT

; 548  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 549  :     PyObject *id = PyUnicode_DecodeUTF8(n, strlen(n), NULL);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  00013	e8 00 00 00 00	 call	 strlen
  00018	45 33 c0	 xor	 r8d, r8d
  0001b	48 8b d0	 mov	 rdx, rax
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  00023	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  00028	48 89 44 24 20	 mov	 QWORD PTR id$[rsp], rax

; 550  :     if (!id)

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR id$[rsp], 0
  00033	75 07		 jne	 SHORT $LN4@new_identi

; 551  :         return NULL;

  00035	33 c0		 xor	 eax, eax
  00037	e9 3d 01 00 00	 jmp	 $LN5@new_identi
$LN4@new_identi:

; 552  :     /* PyUnicode_DecodeUTF8 should always return a ready string. */
; 553  :     assert(PyUnicode_IS_READY(id));

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR id$[rsp]
  00041	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00044	c1 e8 07	 shr	 eax, 7
  00047	83 e0 01	 and	 eax, 1
  0004a	85 c0		 test	 eax, eax
  0004c	75 1c		 jne	 SHORT $LN7@new_identi
  0004e	41 b8 29 02 00
	00		 mov	 r8d, 553		; 00000229H
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@HAMDKJMB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AA?$CJ?$AA?$AA@
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00068	33 c0		 xor	 eax, eax
$LN7@new_identi:

; 554  :     /* Check whether there are non-ASCII characters in the
; 555  :        identifier; if so, normalize to NFKC. */
; 556  :     if (!PyUnicode_IS_ASCII(id)) {

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR id$[rsp]
  0006f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00073	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00079	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0007e	85 c0		 test	 eax, eax
  00080	75 1c		 jne	 SHORT $LN8@new_identi
  00082	41 b8 2c 02 00
	00		 mov	 r8d, 556		; 0000022cH
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@IEEJGGAO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAi?$AAd?$AA?$CJ?$AA?$AA@
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009c	33 c0		 xor	 eax, eax
$LN8@new_identi:
  0009e	48 8b 44 24 20	 mov	 rax, QWORD PTR id$[rsp]
  000a3	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000a6	c1 e8 07	 shr	 eax, 7
  000a9	83 e0 01	 and	 eax, 1
  000ac	85 c0		 test	 eax, eax
  000ae	75 1c		 jne	 SHORT $LN9@new_identi
  000b0	41 b8 2c 02 00
	00		 mov	 r8d, 556		; 0000022cH
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@HAMDKJMB@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAi?$AAd?$AA?$CJ?$AA?$AA@
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ca	33 c0		 xor	 eax, eax
$LN9@new_identi:
  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR id$[rsp]
  000d1	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000d4	c1 e8 06	 shr	 eax, 6
  000d7	83 e0 01	 and	 eax, 1
  000da	85 c0		 test	 eax, eax
  000dc	75 79		 jne	 SHORT $LN3@new_identi

; 557  :         PyObject *id2;
; 558  :         if (!c->c_normalize && !init_normalization(c)) {

  000de	48 8b 44 24 48	 mov	 rax, QWORD PTR c$[rsp]
  000e3	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000e8	75 1c		 jne	 SHORT $LN2@new_identi
  000ea	48 8b 4c 24 48	 mov	 rcx, QWORD PTR c$[rsp]
  000ef	e8 00 00 00 00	 call	 init_normalization
  000f4	85 c0		 test	 eax, eax
  000f6	75 0e		 jne	 SHORT $LN2@new_identi

; 559  :             Py_DECREF(id);

  000f8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR id$[rsp]
  000fd	e8 00 00 00 00	 call	 _Py_DecRef

; 560  :             return NULL;

  00102	33 c0		 xor	 eax, eax
  00104	eb 73		 jmp	 SHORT $LN5@new_identi
$LN2@new_identi:

; 561  :         }
; 562  :         PyTuple_SET_ITEM(c->c_normalize_args, 1, id);

  00106	48 8b 44 24 48	 mov	 rax, QWORD PTR c$[rsp]
  0010b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0010f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR id$[rsp]
  00114	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 563  :         id2 = PyObject_Call(c->c_normalize, c->c_normalize_args, NULL);

  00118	45 33 c0	 xor	 r8d, r8d
  0011b	48 8b 44 24 48	 mov	 rax, QWORD PTR c$[rsp]
  00120	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00124	48 8b 44 24 48	 mov	 rax, QWORD PTR c$[rsp]
  00129	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0012d	e8 00 00 00 00	 call	 PyObject_Call
  00132	48 89 44 24 28	 mov	 QWORD PTR id2$22267[rsp], rax

; 564  :         Py_DECREF(id);

  00137	48 8b 4c 24 20	 mov	 rcx, QWORD PTR id$[rsp]
  0013c	e8 00 00 00 00	 call	 _Py_DecRef

; 565  :         if (!id2)

  00141	48 83 7c 24 28
	00		 cmp	 QWORD PTR id2$22267[rsp], 0
  00147	75 04		 jne	 SHORT $LN1@new_identi

; 566  :             return NULL;

  00149	33 c0		 xor	 eax, eax
  0014b	eb 2c		 jmp	 SHORT $LN5@new_identi
$LN1@new_identi:

; 567  :         id = id2;

  0014d	48 8b 44 24 28	 mov	 rax, QWORD PTR id2$22267[rsp]
  00152	48 89 44 24 20	 mov	 QWORD PTR id$[rsp], rax
$LN3@new_identi:

; 568  :     }
; 569  :     PyUnicode_InternInPlace(&id);

  00157	48 8d 4c 24 20	 lea	 rcx, QWORD PTR id$[rsp]
  0015c	e8 00 00 00 00	 call	 PyUnicode_InternInPlace

; 570  :     PyArena_AddPyObject(c->c_arena, id);

  00161	48 8b 54 24 20	 mov	 rdx, QWORD PTR id$[rsp]
  00166	48 8b 44 24 48	 mov	 rax, QWORD PTR c$[rsp]
  0016b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0016f	e8 00 00 00 00	 call	 PyArena_AddPyObject

; 571  :     return id;

  00174	48 8b 44 24 20	 mov	 rax, QWORD PTR id$[rsp]
$LN5@new_identi:

; 572  : }

  00179	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0017d	c3		 ret	 0
new_identifier ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@KCNADAJK@init_normalization?$AA@	; `string'
PUBLIC	??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@	; `string'
PUBLIC	??_C@_04IPKEFMHE@?$CIsN?$CJ?$AA@		; `string'
PUBLIC	??_C@_04MHPKJHMM@NFKC?$AA@			; `string'
PUBLIC	??_C@_09MMDNNKKJ@normalize?$AA@			; `string'
PUBLIC	??_C@_0M@JMEAHPBI@unicodedata?$AA@		; `string'
EXTRN	Py_BuildValue:PROC
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyObject_GetAttrString:PROC
EXTRN	PyImport_ImportModuleNoBlock:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$init_normalization DD imagerel init_normalization
	DD	imagerel init_normalization+275
	DD	imagerel $unwind$init_normalization
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$init_normalization DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BD@KCNADAJK@init_normalization?$AA@
CONST	SEGMENT
??_C@_0BD@KCNADAJK@init_normalization?$AA@ DB 'init_normalization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@
CONST	SEGMENT
??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@ DB '..\Python\ast.c', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IPKEFMHE@?$CIsN?$CJ?$AA@
CONST	SEGMENT
??_C@_04IPKEFMHE@?$CIsN?$CJ?$AA@ DB '(sN)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MHPKJHMM@NFKC?$AA@
CONST	SEGMENT
??_C@_04MHPKJHMM@NFKC?$AA@ DB 'NFKC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MMDNNKKJ@normalize?$AA@
CONST	SEGMENT
??_C@_09MMDNNKKJ@normalize?$AA@ DB 'normalize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMEAHPBI@unicodedata?$AA@
CONST	SEGMENT
??_C@_0M@JMEAHPBI@unicodedata?$AA@ DB 'unicodedata', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT init_normalization
_TEXT	SEGMENT
m$ = 48
_py_tmp$22241 = 56
c$ = 80
init_normalization PROC					; COMDAT

; 529  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  :     PyObject *m = PyImport_ImportModuleNoBlock("unicodedata");

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JMEAHPBI@unicodedata?$AA@
  00010	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  00015	48 89 44 24 30	 mov	 QWORD PTR m$[rsp], rax

; 531  :     if (!m)

  0001a	48 83 7c 24 30
	00		 cmp	 QWORD PTR m$[rsp], 0
  00020	75 07		 jne	 SHORT $LN7@init_norma

; 532  :         return 0;

  00022	33 c0		 xor	 eax, eax
  00024	e9 e5 00 00 00	 jmp	 $LN8@init_norma
$LN7@init_norma:

; 533  :     c->c_normalize = PyObject_GetAttrString(m, "normalize");

  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09MMDNNKKJ@normalize?$AA@
  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR m$[rsp]
  00035	e8 00 00 00 00	 call	 PyObject_GetAttrString
  0003a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0003f	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 534  :     Py_DECREF(m);

  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR m$[rsp]
  00048	e8 00 00 00 00	 call	 _Py_DecRef

; 535  :     if (!c->c_normalize)

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  00052	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00057	75 07		 jne	 SHORT $LN6@init_norma

; 536  :         return 0;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 ae 00 00 00	 jmp	 $LN8@init_norma
$LN6@init_norma:

; 537  :     c->c_normalize_args = Py_BuildValue("(sN)", "NFKC", Py_None);

  00060	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MHPKJHMM@NFKC?$AA@
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IPKEFMHE@?$CIsN?$CJ?$AA@
  00075	e8 00 00 00 00	 call	 Py_BuildValue
  0007a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0007f	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 538  :     if (!c->c_normalize_args) {

  00083	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  00088	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0008d	75 69		 jne	 SHORT $LN5@init_norma
$LN4@init_norma:

; 539  :         Py_CLEAR(c->c_normalize);

  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  00094	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00099	74 53		 je	 SHORT $LN1@init_norma
  0009b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000a3	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  000a8	4c 8b 48 18	 mov	 r9, QWORD PTR [rax+24]
  000ac	41 b8 1b 02 00
	00		 mov	 r8d, 539		; 0000021bH
  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@KCNADAJK@init_normalization?$AA@
  000c0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000c5	85 c0		 test	 eax, eax
  000c7	75 25		 jne	 SHORT $LN1@init_norma
  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  000ce	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000d2	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$22241[rsp], rax
  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  000dc	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0
  000e4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$22241[rsp]
  000e9	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@init_norma:
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	75 9b		 jne	 SHORT $LN4@init_norma

; 540  :         return 0;

  000f4	33 c0		 xor	 eax, eax
  000f6	eb 16		 jmp	 SHORT $LN8@init_norma
$LN5@init_norma:

; 541  :     }
; 542  :     PyTuple_SET_ITEM(c->c_normalize_args, 1, NULL);

  000f8	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  000fd	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00101	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 543  :     return 1;

  00109	b8 01 00 00 00	 mov	 eax, 1
$LN8@init_norma:

; 544  : }

  0010e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00112	c3		 ret	 0
init_normalization ENDP
_TEXT	ENDS
PUBLIC	??_C@_06EHNNKOPC@?$CINiiN?$CJ?$AA@		; `string'
PUBLIC	_Py_IncRef
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_SyntaxError:QWORD
EXTRN	PyTuple_Pack:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyUnicode_DecodeFSDefault:PROC
EXTRN	PyErr_ProgramText:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_error DD imagerel ast_error
	DD	imagerel ast_error+349
	DD	imagerel $unwind$ast_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_error DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_06EHNNKOPC@?$CINiiN?$CJ?$AA@
CONST	SEGMENT
??_C@_06EHNNKOPC@?$CINiiN?$CJ?$AA@ DB '(NiiN)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_error
_TEXT	SEGMENT
value$ = 48
filename_obj$ = 56
tmp$ = 64
loc$ = 72
errstr$ = 80
c$ = 112
n$ = 120
errmsg$ = 128
ast_error PROC						; COMDAT

; 578  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 579  :     PyObject *value, *errstr, *loc, *tmp;
; 580  :     PyObject *filename_obj;
; 581  : 
; 582  :     loc = PyErr_ProgramText(c->c_filename, LINENO(n));

  00013	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00018	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  0001b	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00020	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00024	e8 00 00 00 00	 call	 PyErr_ProgramText
  00029	48 89 44 24 48	 mov	 QWORD PTR loc$[rsp], rax

; 583  :     if (!loc) {

  0002e	48 83 7c 24 48
	00		 cmp	 QWORD PTR loc$[rsp], 0
  00034	75 18		 jne	 SHORT $LN7@ast_error

; 584  :         Py_INCREF(Py_None);

  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0003d	e8 00 00 00 00	 call	 _Py_IncRef

; 585  :         loc = Py_None;

  00042	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00049	48 89 44 24 48	 mov	 QWORD PTR loc$[rsp], rax
$LN7@ast_error:

; 586  :     }
; 587  :     if (c->c_filename) {

  0004e	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00053	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00058	74 2e		 je	 SHORT $LN6@ast_error

; 588  :         filename_obj = PyUnicode_DecodeFSDefault(c->c_filename);

  0005a	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0005f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00063	e8 00 00 00 00	 call	 PyUnicode_DecodeFSDefault
  00068	48 89 44 24 38	 mov	 QWORD PTR filename_obj$[rsp], rax

; 589  :         if (!filename_obj) {

  0006d	48 83 7c 24 38
	00		 cmp	 QWORD PTR filename_obj$[rsp], 0
  00073	75 11		 jne	 SHORT $LN5@ast_error

; 590  :             Py_DECREF(loc);

  00075	48 8b 4c 24 48	 mov	 rcx, QWORD PTR loc$[rsp]
  0007a	e8 00 00 00 00	 call	 _Py_DecRef

; 591  :             return 0;

  0007f	33 c0		 xor	 eax, eax
  00081	e9 d2 00 00 00	 jmp	 $LN8@ast_error
$LN5@ast_error:

; 592  :         }
; 593  :     } else {

  00086	eb 18		 jmp	 SHORT $LN4@ast_error
$LN6@ast_error:

; 594  :         Py_INCREF(Py_None);

  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0008f	e8 00 00 00 00	 call	 _Py_IncRef

; 595  :         filename_obj = Py_None;

  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0009b	48 89 44 24 38	 mov	 QWORD PTR filename_obj$[rsp], rax
$LN4@ast_error:

; 596  :     }
; 597  :     tmp = Py_BuildValue("(NiiN)", filename_obj, LINENO(n), n->n_col_offset, loc);

  000a0	48 8b 44 24 48	 mov	 rax, QWORD PTR loc$[rsp]
  000a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000aa	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000af	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  000b3	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000b8	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  000bc	48 8b 54 24 38	 mov	 rdx, QWORD PTR filename_obj$[rsp]
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06EHNNKOPC@?$CINiiN?$CJ?$AA@
  000c8	e8 00 00 00 00	 call	 Py_BuildValue
  000cd	48 89 44 24 40	 mov	 QWORD PTR tmp$[rsp], rax

; 598  :     if (!tmp)

  000d2	48 83 7c 24 40
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  000d8	75 04		 jne	 SHORT $LN3@ast_error

; 599  :         return 0;

  000da	33 c0		 xor	 eax, eax
  000dc	eb 7a		 jmp	 SHORT $LN8@ast_error
$LN3@ast_error:

; 600  :     errstr = PyUnicode_FromString(errmsg);

  000de	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR errmsg$[rsp]
  000e6	e8 00 00 00 00	 call	 PyUnicode_FromString
  000eb	48 89 44 24 50	 mov	 QWORD PTR errstr$[rsp], rax

; 601  :     if (!errstr) {

  000f0	48 83 7c 24 50
	00		 cmp	 QWORD PTR errstr$[rsp], 0
  000f6	75 0e		 jne	 SHORT $LN2@ast_error

; 602  :         Py_DECREF(tmp);

  000f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tmp$[rsp]
  000fd	e8 00 00 00 00	 call	 _Py_DecRef

; 603  :         return 0;

  00102	33 c0		 xor	 eax, eax
  00104	eb 52		 jmp	 SHORT $LN8@ast_error
$LN2@ast_error:

; 604  :     }
; 605  :     value = PyTuple_Pack(2, errstr, tmp);

  00106	4c 8b 44 24 40	 mov	 r8, QWORD PTR tmp$[rsp]
  0010b	48 8b 54 24 50	 mov	 rdx, QWORD PTR errstr$[rsp]
  00110	b9 02 00 00 00	 mov	 ecx, 2
  00115	e8 00 00 00 00	 call	 PyTuple_Pack
  0011a	48 89 44 24 30	 mov	 QWORD PTR value$[rsp], rax

; 606  :     Py_DECREF(errstr);

  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR errstr$[rsp]
  00124	e8 00 00 00 00	 call	 _Py_DecRef

; 607  :     Py_DECREF(tmp);

  00129	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tmp$[rsp]
  0012e	e8 00 00 00 00	 call	 _Py_DecRef

; 608  :     if (value) {

  00133	48 83 7c 24 30
	00		 cmp	 QWORD PTR value$[rsp], 0
  00139	74 1b		 je	 SHORT $LN1@ast_error

; 609  :         PyErr_SetObject(PyExc_SyntaxError, value);

  0013b	48 8b 54 24 30	 mov	 rdx, QWORD PTR value$[rsp]
  00140	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SyntaxError
  00147	e8 00 00 00 00	 call	 PyErr_SetObject

; 610  :         Py_DECREF(value);

  0014c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR value$[rsp]
  00151	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@ast_error:

; 611  :     }
; 612  :     return 0;

  00156	33 c0		 xor	 eax, eax
$LN8@ast_error:

; 613  : }

  00158	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0015c	c3		 ret	 0
ast_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@DOGDIKCJ@assignment?5to?5keyword?$AA@	; `string'
PUBLIC	??_C@_09PMJCCPKK@__debug__?$AA@			; `string'
PUBLIC	??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyUnicode_CompareWithASCIIString:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\ast.c
pdata	SEGMENT
$pdata$forbidden_name DD imagerel forbidden_name
	DD	imagerel forbidden_name+232
	DD	imagerel $unwind$forbidden_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$forbidden_name DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT ??_C@_0BG@DOGDIKCJ@assignment?5to?5keyword?$AA@
CONST	SEGMENT
??_C@_0BG@DOGDIKCJ@assignment?5to?5keyword?$AA@ DB 'assignment to keyword'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09PMJCCPKK@__debug__?$AA@
CONST	SEGMENT
??_C@_09PMJCCPKK@__debug__?$AA@ DB '__debug__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	')', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT forbidden_name
_TEXT	SEGMENT
p$22466 = 32
c$ = 64
name$ = 72
n$ = 80
full_checks$ = 88
forbidden_name PROC					; COMDAT

; 847  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 848  :     assert(PyUnicode_Check(name));

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR name$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00027	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0002c	85 c0		 test	 eax, eax
  0002e	75 1c		 jne	 SHORT $LN9@forbidden_
  00030	41 b8 50 03 00
	00		 mov	 r8d, 848		; 00000350H
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004a	33 c0		 xor	 eax, eax
$LN9@forbidden_:

; 849  :     if (PyUnicode_CompareWithASCIIString(name, "__debug__") == 0) {

  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09PMJCCPKK@__debug__?$AA@
  00053	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  00058	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  0005d	85 c0		 test	 eax, eax
  0005f	75 1d		 jne	 SHORT $LN6@forbidden_

; 850  :         ast_error(c, n, "assignment to keyword");

  00061	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@DOGDIKCJ@assignment?5to?5keyword?$AA@
  00068	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00072	e8 00 00 00 00	 call	 ast_error

; 851  :         return 1;

  00077	b8 01 00 00 00	 mov	 eax, 1
  0007c	eb 65		 jmp	 SHORT $LN7@forbidden_
$LN6@forbidden_:

; 852  :     }
; 853  :     if (full_checks) {

  0007e	83 7c 24 58 00	 cmp	 DWORD PTR full_checks$[rsp], 0
  00083	74 5c		 je	 SHORT $LN5@forbidden_

; 854  :         const char **p;
; 855  :         for (p = FORBIDDEN; *p; p++) {

  00085	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:FORBIDDEN
  0008c	48 89 44 24 20	 mov	 QWORD PTR p$22466[rsp], rax
  00091	eb 0e		 jmp	 SHORT $LN4@forbidden_
$LN3@forbidden_:
  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR p$22466[rsp]
  00098	48 83 c0 08	 add	 rax, 8
  0009c	48 89 44 24 20	 mov	 QWORD PTR p$22466[rsp], rax
$LN4@forbidden_:
  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR p$22466[rsp]
  000a6	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000aa	74 35		 je	 SHORT $LN2@forbidden_

; 856  :             if (PyUnicode_CompareWithASCIIString(name, *p) == 0) {

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR p$22466[rsp]
  000b1	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  000b9	e8 00 00 00 00	 call	 PyUnicode_CompareWithASCIIString
  000be	85 c0		 test	 eax, eax
  000c0	75 1d		 jne	 SHORT $LN1@forbidden_

; 857  :                 ast_error(c, n, "assignment to keyword");

  000c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@DOGDIKCJ@assignment?5to?5keyword?$AA@
  000c9	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$[rsp]
  000ce	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000d3	e8 00 00 00 00	 call	 ast_error

; 858  :                 return 1;

  000d8	b8 01 00 00 00	 mov	 eax, 1
  000dd	eb 04		 jmp	 SHORT $LN7@forbidden_
$LN1@forbidden_:

; 859  :             }
; 860  :         }

  000df	eb b2		 jmp	 SHORT $LN3@forbidden_
$LN2@forbidden_:
$LN5@forbidden_:

; 861  :     }
; 862  :     return 0;

  000e1	33 c0		 xor	 eax, eax
$LN7@forbidden_:

; 863  : }

  000e3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e7	c3		 ret	 0
forbidden_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EO@BGBGGBCJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAf?$AAp?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ ; `string'
EXTRN	_Py_arg:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_arg DD imagerel ast_for_arg
	DD	imagerel ast_for_arg+263
	DD	imagerel $unwind$ast_for_arg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_arg DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1EO@BGBGGBCJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAf?$AAp?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
CONST	SEGMENT
??_C@_1EO@BGBGGBCJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAf?$AAp?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't', 00H, 'f', 00H, 'p'
	DB	00H, 'd', 00H, 'e', 00H, 'f', 00H, ' ', 00H, '|', 00H, '|', 00H
	DB	' ', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n'
	DB	00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'v', 00H
	DB	'f', 00H, 'p', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_arg
_TEXT	SEGMENT
annotation$ = 32
name$ = 40
ch$ = 48
c$ = 80
n$ = 88
ast_for_arg PROC					; COMDAT

; 1118 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1119 :     identifier name;
; 1120 :     expr_ty annotation = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR annotation$[rsp], 0

; 1121 :     node *ch;
; 1122 : 
; 1123 :     assert(TYPE(n) == tfpdef || TYPE(n) == vfpdef);

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0001c	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0001f	3d 09 01 00 00	 cmp	 eax, 265		; 00000109H
  00024	74 2b		 je	 SHORT $LN7@ast_for_ar@2
  00026	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0002b	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0002e	3d 0b 01 00 00	 cmp	 eax, 267		; 0000010bH
  00033	74 1c		 je	 SHORT $LN7@ast_for_ar@2
  00035	41 b8 63 04 00
	00		 mov	 r8d, 1123		; 00000463H
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@BGBGGBCJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAf?$AAp?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5@
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004f	33 c0		 xor	 eax, eax
$LN7@ast_for_ar@2:

; 1124 :     ch = CHILD(n, 0);

  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00056	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0005a	48 89 44 24 30	 mov	 QWORD PTR ch$[rsp], rax

; 1125 :     name = NEW_IDENTIFIER(ch);

  0005f	48 8b 54 24 50	 mov	 rdx, QWORD PTR c$[rsp]
  00064	48 8b 44 24 30	 mov	 rax, QWORD PTR ch$[rsp]
  00069	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0006d	e8 00 00 00 00	 call	 new_identifier
  00072	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 1126 :     if (!name)

  00077	48 83 7c 24 28
	00		 cmp	 QWORD PTR name$[rsp], 0
  0007d	75 04		 jne	 SHORT $LN4@ast_for_ar@2

; 1127 :         return NULL;

  0007f	33 c0		 xor	 eax, eax
  00081	eb 7f		 jmp	 SHORT $LN5@ast_for_ar@2
$LN4@ast_for_ar@2:

; 1128 :     if (forbidden_name(c, name, ch, 0))

  00083	45 33 c9	 xor	 r9d, r9d
  00086	4c 8b 44 24 30	 mov	 r8, QWORD PTR ch$[rsp]
  0008b	48 8b 54 24 28	 mov	 rdx, QWORD PTR name$[rsp]
  00090	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00095	e8 00 00 00 00	 call	 forbidden_name
  0009a	85 c0		 test	 eax, eax
  0009c	74 04		 je	 SHORT $LN3@ast_for_ar@2

; 1129 :         return NULL;

  0009e	33 c0		 xor	 eax, eax
  000a0	eb 60		 jmp	 SHORT $LN5@ast_for_ar@2
$LN3@ast_for_ar@2:

; 1130 : 
; 1131 :     if (NCH(n) == 3 && TYPE(CHILD(n, 1)) == COLON) {

  000a2	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000a7	83 78 18 03	 cmp	 DWORD PTR [rax+24], 3
  000ab	75 3d		 jne	 SHORT $LN2@ast_for_ar@2
  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000b2	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000b6	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  000ba	83 f8 0b	 cmp	 eax, 11
  000bd	75 2b		 jne	 SHORT $LN2@ast_for_ar@2

; 1132 :         annotation = ast_for_expr(c, CHILD(n, 2));

  000bf	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000c4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000c8	48 83 c0 50	 add	 rax, 80			; 00000050H
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000d4	e8 00 00 00 00	 call	 ast_for_expr
  000d9	48 89 44 24 20	 mov	 QWORD PTR annotation$[rsp], rax

; 1133 :         if (!annotation)

  000de	48 83 7c 24 20
	00		 cmp	 QWORD PTR annotation$[rsp], 0
  000e4	75 04		 jne	 SHORT $LN1@ast_for_ar@2

; 1134 :             return NULL;

  000e6	33 c0		 xor	 eax, eax
  000e8	eb 18		 jmp	 SHORT $LN5@ast_for_ar@2
$LN1@ast_for_ar@2:
$LN2@ast_for_ar@2:

; 1135 :     }
; 1136 : 
; 1137 :     return arg(name, annotation, c->c_arena);

  000ea	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  000ef	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000f3	48 8b 54 24 20	 mov	 rdx, QWORD PTR annotation$[rsp]
  000f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR name$[rsp]
  000fd	e8 00 00 00 00	 call	 _Py_arg
$LN5@ast_for_ar@2:

; 1138 : }

  00102	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00106	c3		 ret	 0
ast_for_arg ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@JBKEEOMC@unexpected?5node?$AA@	; `string'
PUBLIC	??_C@_1FK@KCMNHAJA@?$AA?$CI?$AAk?$AAw?$AAo?$AAn?$AAl?$AAy?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAw?$AAo?$AAn?$AAl@ ; `string'
PUBLIC	??_C@_1FK@EBGLJEFO@?$AA?$CI?$AAk?$AAw?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAw?$AAd?$AAe?$AAf@ ; `string'
PUBLIC	??_C@_1CG@OHOKDENJ@?$AAk?$AAw?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$handle_keywordonly_args DD imagerel handle_keywordonly_args
	DD	imagerel handle_keywordonly_args+920
	DD	imagerel $unwind$handle_keywordonly_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$handle_keywordonly_args DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT ??_C@_0BA@JBKEEOMC@unexpected?5node?$AA@
CONST	SEGMENT
??_C@_0BA@JBKEEOMC@unexpected?5node?$AA@ DB 'unexpected node', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@KCMNHAJA@?$AA?$CI?$AAk?$AAw?$AAo?$AAn?$AAl?$AAy?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAw?$AAo?$AAn?$AAl@
CONST	SEGMENT
??_C@_1FK@KCMNHAJA@?$AA?$CI?$AAk?$AAw?$AAo?$AAn?$AAl?$AAy?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAw?$AAo?$AAn?$AAl@ DB '('
	DB	00H, 'k', 00H, 'w', 00H, 'o', 00H, 'n', 00H, 'l', 00H, 'y', 00H
	DB	'a', 00H, 'r', 00H, 'g', 00H, 's', 00H, ')', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's', 00H, 'd', 00H
	DB	'l', 00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' ', 00H, '('
	DB	00H, 'k', 00H, 'w', 00H, 'o', 00H, 'n', 00H, 'l', 00H, 'y', 00H
	DB	'a', 00H, 'r', 00H, 'g', 00H, 's', 00H, ')', 00H, '-', 00H, '>'
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@EBGLJEFO@?$AA?$CI?$AAk?$AAw?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAw?$AAd?$AAe?$AAf@
CONST	SEGMENT
??_C@_1FK@EBGLJEFO@?$AA?$CI?$AAk?$AAw?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAw?$AAd?$AAe?$AAf@ DB '('
	DB	00H, 'k', 00H, 'w', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 'a', 00H
	DB	'u', 00H, 'l', 00H, 't', 00H, 's', 00H, ')', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's', 00H, 'd', 00H
	DB	'l', 00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' ', 00H, '('
	DB	00H, 'k', 00H, 'w', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 'a', 00H
	DB	'u', 00H, 'l', 00H, 't', 00H, 's', 00H, ')', 00H, '-', 00H, '>'
	DB	00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@OHOKDENJ@?$AAk?$AAw?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@OHOKDENJ@?$AAk?$AAw?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'k'
	DB	00H, 'w', 00H, 'd', 00H, 'e', 00H, 'f', 00H, 'a', 00H, 'u', 00H
	DB	'l', 00H, 't', 00H, 's', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT handle_keywordonly_args
_TEXT	SEGMENT
i$ = 32
arg$ = 40
annotation$ = 48
argname$ = 56
expression$ = 64
ch$ = 72
j$ = 80
_asdl_i$22694 = 84
_asdl_i$22698 = 88
_asdl_i$22708 = 92
tv84 = 96
c$ = 128
n$ = 136
start$ = 144
kwonlyargs$ = 152
kwdefaults$ = 160
handle_keywordonly_args PROC				; COMDAT

; 1149 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1150 :     PyObject *argname;
; 1151 :     node *ch;
; 1152 :     expr_ty expression, annotation;
; 1153 :     arg_ty arg;
; 1154 :     int i = start;

  00018	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  0001f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 1155 :     int j = 0; /* index for kwdefaults and kwonlyargs */

  00023	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0

; 1156 : 
; 1157 :     if (kwonlyargs == NULL) {

  0002b	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR kwonlyargs$[rsp], 0
  00034	75 39		 jne	 SHORT $LN17@handle_key

; 1158 :         ast_error(c, CHILD(n, start), "named arguments must follow bare *");

  00036	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR start$[rsp]
  0003e	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00042	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0004a	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0004e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CD@MPPDOCEK@named?5arguments?5must?5follow?5bare@
  00055	48 8b d0	 mov	 rdx, rax
  00058	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00060	e8 00 00 00 00	 call	 ast_error

; 1159 :         return -1;

  00065	b8 ff ff ff ff	 mov	 eax, -1
  0006a	e9 24 03 00 00	 jmp	 $LN18@handle_key
$LN17@handle_key:

; 1160 :     }
; 1161 :     assert(kwdefaults != NULL);

  0006f	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR kwdefaults$[rsp], 0
  00078	75 1c		 jne	 SHORT $LN20@handle_key
  0007a	41 b8 89 04 00
	00		 mov	 r8d, 1161		; 00000489H
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@OHOKDENJ@?$AAk?$AAw?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00094	33 c0		 xor	 eax, eax
$LN20@handle_key:
$LN16@handle_key:

; 1162 :     while (i < NCH(n)) {

  00096	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0009e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000a1	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000a5	0f 8d dd 02 00
	00		 jge	 $LN15@handle_key

; 1163 :         ch = CHILD(n, i);

  000ab	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b0	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000b4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  000bc	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000c0	48 89 44 24 48	 mov	 QWORD PTR ch$[rsp], rax

; 1164 :         switch (TYPE(ch)) {

  000c5	48 8b 44 24 48	 mov	 rax, QWORD PTR ch$[rsp]
  000ca	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000cd	89 44 24 60	 mov	 DWORD PTR tv84[rsp], eax
  000d1	83 7c 24 60 23	 cmp	 DWORD PTR tv84[rsp], 35	; 00000023H
  000d6	0f 84 86 02 00
	00		 je	 $LN2@handle_key
  000dc	81 7c 24 60 09
	01 00 00	 cmp	 DWORD PTR tv84[rsp], 265 ; 00000109H
  000e4	74 0f		 je	 SHORT $LN12@handle_key
  000e6	81 7c 24 60 0b
	01 00 00	 cmp	 DWORD PTR tv84[rsp], 267 ; 0000010bH
  000ee	74 05		 je	 SHORT $LN12@handle_key
  000f0	e9 73 02 00 00	 jmp	 $LN1@handle_key
$LN12@handle_key:

; 1165 :             case vfpdef:
; 1166 :             case tfpdef:
; 1167 :                 if (i + 1 < NCH(n) && TYPE(CHILD(n, i + 1)) == EQUAL) {

  000f5	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000f9	ff c0		 inc	 eax
  000fb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00103	3b 41 18	 cmp	 eax, DWORD PTR [rcx+24]
  00106	0f 8d c5 00 00
	00		 jge	 $LN11@handle_key
  0010c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00110	ff c0		 inc	 eax
  00112	48 98		 cdqe
  00114	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00118	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00120	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00124	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00128	83 f8 16	 cmp	 eax, 22
  0012b	0f 85 a0 00 00
	00		 jne	 $LN11@handle_key

; 1168 :                     expression = ast_for_expr(c, CHILD(n, i + 2));

  00131	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00135	83 c0 02	 add	 eax, 2
  00138	48 98		 cdqe
  0013a	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0013e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00146	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0014a	48 8b d0	 mov	 rdx, rax
  0014d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00155	e8 00 00 00 00	 call	 ast_for_expr
  0015a	48 89 44 24 40	 mov	 QWORD PTR expression$[rsp], rax

; 1169 :                     if (!expression)

  0015f	48 83 7c 24 40
	00		 cmp	 QWORD PTR expression$[rsp], 0
  00165	75 05		 jne	 SHORT $LN10@handle_key

; 1170 :                         goto error;

  00167	e9 22 02 00 00	 jmp	 $error$22693
$LN10@handle_key:

; 1171 :                     asdl_seq_SET(kwdefaults, j, expression);

  0016c	8b 44 24 50	 mov	 eax, DWORD PTR j$[rsp]
  00170	89 44 24 54	 mov	 DWORD PTR _asdl_i$22694[rsp], eax
  00174	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR kwdefaults$[rsp], 0
  0017d	74 12		 je	 SHORT $LN21@handle_key
  0017f	48 63 44 24 54	 movsxd	 rax, DWORD PTR _asdl_i$22694[rsp]
  00184	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR kwdefaults$[rsp]
  0018c	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  0018f	7c 1c		 jl	 SHORT $LN22@handle_key
$LN21@handle_key:
  00191	41 b8 93 04 00
	00		 mov	 r8d, 1171		; 00000493H
  00197	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0019e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FK@EBGLJEFO@?$AA?$CI?$AAk?$AAw?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAw?$AAd?$AAe?$AAf@
  001a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001ab	33 c0		 xor	 eax, eax
$LN22@handle_key:
  001ad	48 63 44 24 54	 movsxd	 rax, DWORD PTR _asdl_i$22694[rsp]
  001b2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR kwdefaults$[rsp]
  001ba	48 8b 54 24 40	 mov	 rdx, QWORD PTR expression$[rsp]
  001bf	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 1172 :                     i += 2; /* '=' and test */

  001c4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001c8	83 c0 02	 add	 eax, 2
  001cb	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 1173 :                 }
; 1174 :                 else { /* setting NULL if no default value exists */

  001cf	eb 57		 jmp	 SHORT $LN9@handle_key
$LN11@handle_key:

; 1175 :                     asdl_seq_SET(kwdefaults, j, NULL);

  001d1	8b 44 24 50	 mov	 eax, DWORD PTR j$[rsp]
  001d5	89 44 24 58	 mov	 DWORD PTR _asdl_i$22698[rsp], eax
  001d9	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR kwdefaults$[rsp], 0
  001e2	74 12		 je	 SHORT $LN23@handle_key
  001e4	48 63 44 24 58	 movsxd	 rax, DWORD PTR _asdl_i$22698[rsp]
  001e9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR kwdefaults$[rsp]
  001f1	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  001f4	7c 1c		 jl	 SHORT $LN24@handle_key
$LN23@handle_key:
  001f6	41 b8 97 04 00
	00		 mov	 r8d, 1175		; 00000497H
  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FK@EBGLJEFO@?$AA?$CI?$AAk?$AAw?$AAd?$AAe?$AAf?$AAa?$AAu?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAw?$AAd?$AAe?$AAf@
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00210	33 c0		 xor	 eax, eax
$LN24@handle_key:
  00212	48 63 44 24 58	 movsxd	 rax, DWORD PTR _asdl_i$22698[rsp]
  00217	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR kwdefaults$[rsp]
  0021f	48 c7 44 c1 08
	00 00 00 00	 mov	 QWORD PTR [rcx+rax*8+8], 0
$LN9@handle_key:

; 1176 :                 }
; 1177 :                 if (NCH(ch) == 3) {

  00228	48 8b 44 24 48	 mov	 rax, QWORD PTR ch$[rsp]
  0022d	83 78 18 03	 cmp	 DWORD PTR [rax+24], 3
  00231	75 31		 jne	 SHORT $LN8@handle_key

; 1178 :                     /* ch is NAME ':' test */
; 1179 :                     annotation = ast_for_expr(c, CHILD(ch, 2));

  00233	48 8b 44 24 48	 mov	 rax, QWORD PTR ch$[rsp]
  00238	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0023c	48 83 c0 50	 add	 rax, 80			; 00000050H
  00240	48 8b d0	 mov	 rdx, rax
  00243	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0024b	e8 00 00 00 00	 call	 ast_for_expr
  00250	48 89 44 24 30	 mov	 QWORD PTR annotation$[rsp], rax

; 1180 :                     if (!annotation)

  00255	48 83 7c 24 30
	00		 cmp	 QWORD PTR annotation$[rsp], 0
  0025b	75 05		 jne	 SHORT $LN7@handle_key

; 1181 :                         goto error;

  0025d	e9 2c 01 00 00	 jmp	 $error$22693
$LN7@handle_key:

; 1182 :                 }
; 1183 :                 else {

  00262	eb 09		 jmp	 SHORT $LN6@handle_key
$LN8@handle_key:

; 1184 :                     annotation = NULL;

  00264	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR annotation$[rsp], 0
$LN6@handle_key:

; 1185 :                 }
; 1186 :                 ch = CHILD(ch, 0);

  0026d	48 8b 44 24 48	 mov	 rax, QWORD PTR ch$[rsp]
  00272	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00276	48 89 44 24 48	 mov	 QWORD PTR ch$[rsp], rax

; 1187 :                 argname = NEW_IDENTIFIER(ch);

  0027b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00283	48 8b 44 24 48	 mov	 rax, QWORD PTR ch$[rsp]
  00288	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0028c	e8 00 00 00 00	 call	 new_identifier
  00291	48 89 44 24 38	 mov	 QWORD PTR argname$[rsp], rax

; 1188 :                 if (!argname)

  00296	48 83 7c 24 38
	00		 cmp	 QWORD PTR argname$[rsp], 0
  0029c	75 05		 jne	 SHORT $LN5@handle_key

; 1189 :                     goto error;

  0029e	e9 eb 00 00 00	 jmp	 $error$22693
$LN5@handle_key:

; 1190 :                 if (forbidden_name(c, argname, ch, 0))

  002a3	45 33 c9	 xor	 r9d, r9d
  002a6	4c 8b 44 24 48	 mov	 r8, QWORD PTR ch$[rsp]
  002ab	48 8b 54 24 38	 mov	 rdx, QWORD PTR argname$[rsp]
  002b0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002b8	e8 00 00 00 00	 call	 forbidden_name
  002bd	85 c0		 test	 eax, eax
  002bf	74 05		 je	 SHORT $LN4@handle_key

; 1191 :                     goto error;

  002c1	e9 c8 00 00 00	 jmp	 $error$22693
$LN4@handle_key:

; 1192 :                 arg = arg(argname, annotation, c->c_arena);

  002c6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  002ce	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  002d2	48 8b 54 24 30	 mov	 rdx, QWORD PTR annotation$[rsp]
  002d7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR argname$[rsp]
  002dc	e8 00 00 00 00	 call	 _Py_arg
  002e1	48 89 44 24 28	 mov	 QWORD PTR arg$[rsp], rax

; 1193 :                 if (!arg)

  002e6	48 83 7c 24 28
	00		 cmp	 QWORD PTR arg$[rsp], 0
  002ec	75 05		 jne	 SHORT $LN3@handle_key

; 1194 :                     goto error;

  002ee	e9 9b 00 00 00	 jmp	 $error$22693
$LN3@handle_key:

; 1195 :                 asdl_seq_SET(kwonlyargs, j++, arg);

  002f3	8b 44 24 50	 mov	 eax, DWORD PTR j$[rsp]
  002f7	89 44 24 5c	 mov	 DWORD PTR _asdl_i$22708[rsp], eax
  002fb	8b 44 24 50	 mov	 eax, DWORD PTR j$[rsp]
  002ff	ff c0		 inc	 eax
  00301	89 44 24 50	 mov	 DWORD PTR j$[rsp], eax
  00305	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR kwonlyargs$[rsp], 0
  0030e	74 12		 je	 SHORT $LN25@handle_key
  00310	48 63 44 24 5c	 movsxd	 rax, DWORD PTR _asdl_i$22708[rsp]
  00315	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR kwonlyargs$[rsp]
  0031d	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00320	7c 1c		 jl	 SHORT $LN26@handle_key
$LN25@handle_key:
  00322	41 b8 ab 04 00
	00		 mov	 r8d, 1195		; 000004abH
  00328	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0032f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FK@KCMNHAJA@?$AA?$CI?$AAk?$AAw?$AAo?$AAn?$AAl?$AAy?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAw?$AAo?$AAn?$AAl@
  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0033c	33 c0		 xor	 eax, eax
$LN26@handle_key:
  0033e	48 63 44 24 5c	 movsxd	 rax, DWORD PTR _asdl_i$22708[rsp]
  00343	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR kwonlyargs$[rsp]
  0034b	48 8b 54 24 28	 mov	 rdx, QWORD PTR arg$[rsp]
  00350	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 1196 :                 i += 2; /* the name and the comma */

  00355	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00359	83 c0 02	 add	 eax, 2
  0035c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 1197 :                 break;

  00360	eb 21		 jmp	 SHORT $LN13@handle_key
$LN2@handle_key:

; 1198 :             case DOUBLESTAR:
; 1199 :                 return i;

  00362	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00366	eb 2b		 jmp	 SHORT $LN18@handle_key
$LN1@handle_key:

; 1200 :             default:
; 1201 :                 ast_error(c, ch, "unexpected node");

  00368	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@JBKEEOMC@unexpected?5node?$AA@
  0036f	48 8b 54 24 48	 mov	 rdx, QWORD PTR ch$[rsp]
  00374	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0037c	e8 00 00 00 00	 call	 ast_error

; 1202 :                 goto error;

  00381	eb 0b		 jmp	 SHORT $error$22693
$LN13@handle_key:

; 1203 :         }
; 1204 :     }

  00383	e9 0e fd ff ff	 jmp	 $LN16@handle_key
$LN15@handle_key:

; 1205 :     return i;

  00388	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0038c	eb 05		 jmp	 SHORT $LN18@handle_key
$error$22693:

; 1206 :  error:
; 1207 :     return -1;

  0038e	b8 ff ff ff ff	 mov	 eax, -1
$LN18@handle_key:

; 1208 : }

  00393	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00397	c3		 ret	 0
handle_keywordonly_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@CIIMCKFG@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA5?$AA?$AA@ ; `string'
EXTRN	_Py_IfExp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_ifexpr DD imagerel ast_for_ifexpr
	DD	imagerel ast_for_ifexpr+240
	DD	imagerel $unwind$ast_for_ifexpr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_ifexpr DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1BI@CIIMCKFG@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA5?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@CIIMCKFG@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA5?$AA?$AA@ DB 'N'
	DB	00H, 'C', 00H, 'H', 00H, '(', 00H, 'n', 00H, ')', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '5', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_ifexpr
_TEXT	SEGMENT
body$ = 48
expression$ = 56
orelse$ = 64
c$ = 96
n$ = 104
ast_for_ifexpr PROC					; COMDAT

; 1580 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1581 :     /* test: or_test 'if' or_test 'else' test */
; 1582 :     expr_ty expression, body, orelse;
; 1583 : 
; 1584 :     assert(NCH(n) == 5);

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00013	83 78 18 05	 cmp	 DWORD PTR [rax+24], 5
  00017	74 1c		 je	 SHORT $LN6@ast_for_if
  00019	41 b8 30 06 00
	00		 mov	 r8d, 1584		; 00000630H
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@CIIMCKFG@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA5?$AA?$AA@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00033	33 c0		 xor	 eax, eax
$LN6@ast_for_if:

; 1585 :     body = ast_for_expr(c, CHILD(n, 0));

  00035	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0003a	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  0003e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00043	e8 00 00 00 00	 call	 ast_for_expr
  00048	48 89 44 24 30	 mov	 QWORD PTR body$[rsp], rax

; 1586 :     if (!body)

  0004d	48 83 7c 24 30
	00		 cmp	 QWORD PTR body$[rsp], 0
  00053	75 07		 jne	 SHORT $LN3@ast_for_if

; 1587 :         return NULL;

  00055	33 c0		 xor	 eax, eax
  00057	e9 8f 00 00 00	 jmp	 $LN4@ast_for_if
$LN3@ast_for_if:

; 1588 :     expression = ast_for_expr(c, CHILD(n, 2));

  0005c	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00061	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00065	48 83 c0 50	 add	 rax, 80			; 00000050H
  00069	48 8b d0	 mov	 rdx, rax
  0006c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00071	e8 00 00 00 00	 call	 ast_for_expr
  00076	48 89 44 24 38	 mov	 QWORD PTR expression$[rsp], rax

; 1589 :     if (!expression)

  0007b	48 83 7c 24 38
	00		 cmp	 QWORD PTR expression$[rsp], 0
  00081	75 04		 jne	 SHORT $LN2@ast_for_if

; 1590 :         return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	eb 64		 jmp	 SHORT $LN4@ast_for_if
$LN2@ast_for_if:

; 1591 :     orelse = ast_for_expr(c, CHILD(n, 4));

  00087	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0008c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00090	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00096	48 8b d0	 mov	 rdx, rax
  00099	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0009e	e8 00 00 00 00	 call	 ast_for_expr
  000a3	48 89 44 24 40	 mov	 QWORD PTR orelse$[rsp], rax

; 1592 :     if (!orelse)

  000a8	48 83 7c 24 40
	00		 cmp	 QWORD PTR orelse$[rsp], 0
  000ae	75 04		 jne	 SHORT $LN1@ast_for_if

; 1593 :         return NULL;

  000b0	33 c0		 xor	 eax, eax
  000b2	eb 37		 jmp	 SHORT $LN4@ast_for_if
$LN1@ast_for_if:

; 1594 :     return IfExp(expression, body, orelse, LINENO(n), n->n_col_offset,
; 1595 :                  c->c_arena);

  000b4	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  000b9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000bd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000c2	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000c7	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ca	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000ce	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000d3	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  000d7	4c 8b 44 24 40	 mov	 r8, QWORD PTR orelse$[rsp]
  000dc	48 8b 54 24 30	 mov	 rdx, QWORD PTR body$[rsp]
  000e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR expression$[rsp]
  000e6	e8 00 00 00 00	 call	 _Py_IfExp
$LN4@ast_for_if:

; 1596 : }

  000eb	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ef	c3		 ret	 0
ast_for_ifexpr ENDP
_TEXT	ENDS
EXTRN	_Py_BinOp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_binop DD imagerel ast_for_binop
	DD	imagerel ast_for_binop+515
	DD	imagerel $unwind$ast_for_binop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_binop DD 021101H
	DD	0110111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ast_for_binop
_TEXT	SEGMENT
expr2$ = 48
i$ = 56
expr1$ = 64
nops$ = 72
result$ = 80
newoperator$ = 88
tmp_result$23348 = 96
tmp$23349 = 104
next_oper$23350 = 112
c$ = 144
n$ = 152
ast_for_binop PROC					; COMDAT

; 2034 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2035 :     /* Must account for a sequence of expressions.
; 2036 :        How should A op B op C by represented?
; 2037 :        BinOp(BinOp(A, op, B), op, C).
; 2038 :     */
; 2039 : 
; 2040 :     int i, nops;
; 2041 :     expr_ty expr1, expr2, result;
; 2042 :     operator_ty newoperator;
; 2043 : 
; 2044 :     expr1 = ast_for_expr(c, CHILD(n, 0));

  00011	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00019	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  0001d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00025	e8 00 00 00 00	 call	 ast_for_expr
  0002a	48 89 44 24 40	 mov	 QWORD PTR expr1$[rsp], rax

; 2045 :     if (!expr1)

  0002f	48 83 7c 24 40
	00		 cmp	 QWORD PTR expr1$[rsp], 0
  00035	75 07		 jne	 SHORT $LN10@ast_for_bi

; 2046 :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	e9 bd 01 00 00	 jmp	 $LN11@ast_for_bi
$LN10@ast_for_bi:

; 2047 : 
; 2048 :     expr2 = ast_for_expr(c, CHILD(n, 2));

  0003e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00046	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004a	48 83 c0 50	 add	 rax, 80			; 00000050H
  0004e	48 8b d0	 mov	 rdx, rax
  00051	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00059	e8 00 00 00 00	 call	 ast_for_expr
  0005e	48 89 44 24 30	 mov	 QWORD PTR expr2$[rsp], rax

; 2049 :     if (!expr2)

  00063	48 83 7c 24 30
	00		 cmp	 QWORD PTR expr2$[rsp], 0
  00069	75 07		 jne	 SHORT $LN9@ast_for_bi

; 2050 :         return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 89 01 00 00	 jmp	 $LN11@ast_for_bi
$LN9@ast_for_bi:

; 2051 : 
; 2052 :     newoperator = get_operator(CHILD(n, 1));

  00072	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0007a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007e	48 83 c0 28	 add	 rax, 40			; 00000028H
  00082	48 8b c8	 mov	 rcx, rax
  00085	e8 00 00 00 00	 call	 get_operator
  0008a	89 44 24 58	 mov	 DWORD PTR newoperator$[rsp], eax

; 2053 :     if (!newoperator)

  0008e	83 7c 24 58 00	 cmp	 DWORD PTR newoperator$[rsp], 0
  00093	75 07		 jne	 SHORT $LN8@ast_for_bi

; 2054 :         return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	e9 5f 01 00 00	 jmp	 $LN11@ast_for_bi
$LN8@ast_for_bi:

; 2055 : 
; 2056 :     result = BinOp(expr1, newoperator, expr2, LINENO(n), n->n_col_offset,
; 2057 :                    c->c_arena);

  0009c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000a4	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ad	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000b5	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000b8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000bc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000c4	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  000c8	4c 8b 44 24 30	 mov	 r8, QWORD PTR expr2$[rsp]
  000cd	8b 54 24 58	 mov	 edx, DWORD PTR newoperator$[rsp]
  000d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR expr1$[rsp]
  000d6	e8 00 00 00 00	 call	 _Py_BinOp
  000db	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 2058 :     if (!result)

  000e0	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  000e6	75 07		 jne	 SHORT $LN7@ast_for_bi

; 2059 :         return NULL;

  000e8	33 c0		 xor	 eax, eax
  000ea	e9 0c 01 00 00	 jmp	 $LN11@ast_for_bi
$LN7@ast_for_bi:

; 2060 : 
; 2061 :     nops = (NCH(n) - 1) / 2;

  000ef	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000f7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000fa	ff c8		 dec	 eax
  000fc	99		 cdq
  000fd	2b c2		 sub	 eax, edx
  000ff	d1 f8		 sar	 eax, 1
  00101	89 44 24 48	 mov	 DWORD PTR nops$[rsp], eax

; 2062 :     for (i = 1; i < nops; i++) {

  00105	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0010d	eb 0a		 jmp	 SHORT $LN6@ast_for_bi
$LN5@ast_for_bi:
  0010f	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00113	ff c0		 inc	 eax
  00115	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN6@ast_for_bi:
  00119	8b 44 24 48	 mov	 eax, DWORD PTR nops$[rsp]
  0011d	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00121	0f 8d cf 00 00
	00		 jge	 $LN4@ast_for_bi

; 2063 :         expr_ty tmp_result, tmp;
; 2064 :         const node* next_oper = CHILD(n, i * 2 + 1);

  00127	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0012b	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0012f	48 98		 cdqe
  00131	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00135	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0013d	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00141	48 89 44 24 70	 mov	 QWORD PTR next_oper$23350[rsp], rax

; 2065 : 
; 2066 :         newoperator = get_operator(next_oper);

  00146	48 8b 4c 24 70	 mov	 rcx, QWORD PTR next_oper$23350[rsp]
  0014b	e8 00 00 00 00	 call	 get_operator
  00150	89 44 24 58	 mov	 DWORD PTR newoperator$[rsp], eax

; 2067 :         if (!newoperator)

  00154	83 7c 24 58 00	 cmp	 DWORD PTR newoperator$[rsp], 0
  00159	75 07		 jne	 SHORT $LN3@ast_for_bi

; 2068 :             return NULL;

  0015b	33 c0		 xor	 eax, eax
  0015d	e9 99 00 00 00	 jmp	 $LN11@ast_for_bi
$LN3@ast_for_bi:

; 2069 : 
; 2070 :         tmp = ast_for_expr(c, CHILD(n, i * 2 + 2));

  00162	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00166	8d 44 00 02	 lea	 eax, DWORD PTR [rax+rax+2]
  0016a	48 98		 cdqe
  0016c	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00170	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00178	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0017c	48 8b d0	 mov	 rdx, rax
  0017f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00187	e8 00 00 00 00	 call	 ast_for_expr
  0018c	48 89 44 24 68	 mov	 QWORD PTR tmp$23349[rsp], rax

; 2071 :         if (!tmp)

  00191	48 83 7c 24 68
	00		 cmp	 QWORD PTR tmp$23349[rsp], 0
  00197	75 04		 jne	 SHORT $LN2@ast_for_bi

; 2072 :             return NULL;

  00199	33 c0		 xor	 eax, eax
  0019b	eb 5e		 jmp	 SHORT $LN11@ast_for_bi
$LN2@ast_for_bi:

; 2073 : 
; 2074 :         tmp_result = BinOp(result, newoperator, tmp,
; 2075 :                            LINENO(next_oper), next_oper->n_col_offset,
; 2076 :                            c->c_arena);

  0019d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  001a5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001a9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ae	48 8b 44 24 70	 mov	 rax, QWORD PTR next_oper$23350[rsp]
  001b3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001b6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001ba	48 8b 44 24 70	 mov	 rax, QWORD PTR next_oper$23350[rsp]
  001bf	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  001c3	4c 8b 44 24 68	 mov	 r8, QWORD PTR tmp$23349[rsp]
  001c8	8b 54 24 58	 mov	 edx, DWORD PTR newoperator$[rsp]
  001cc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  001d1	e8 00 00 00 00	 call	 _Py_BinOp
  001d6	48 89 44 24 60	 mov	 QWORD PTR tmp_result$23348[rsp], rax

; 2077 :         if (!tmp_result)

  001db	48 83 7c 24 60
	00		 cmp	 QWORD PTR tmp_result$23348[rsp], 0
  001e1	75 04		 jne	 SHORT $LN1@ast_for_bi

; 2078 :             return NULL;

  001e3	33 c0		 xor	 eax, eax
  001e5	eb 14		 jmp	 SHORT $LN11@ast_for_bi
$LN1@ast_for_bi:

; 2079 :         result = tmp_result;

  001e7	48 8b 44 24 60	 mov	 rax, QWORD PTR tmp_result$23348[rsp]
  001ec	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 2080 :     }

  001f1	e9 19 ff ff ff	 jmp	 $LN5@ast_for_bi
$LN4@ast_for_bi:

; 2081 :     return result;

  001f6	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
$LN11@ast_for_bi:

; 2082 : }

  001fb	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00202	c3		 ret	 0
ast_for_binop ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_operator DD imagerel get_operator
	DD	imagerel get_operator+234
	DD	imagerel $unwind$get_operator
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_operator DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_operator
_TEXT	SEGMENT
tv65 = 0
n$ = 32
get_operator PROC					; COMDAT

; 809  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 810  :     switch (TYPE(n)) {

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  0000e	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00011	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  00014	8b 04 24	 mov	 eax, DWORD PTR tv65[rsp]
  00017	83 e8 0e	 sub	 eax, 14
  0001a	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  0001d	83 3c 24 21	 cmp	 DWORD PTR tv65[rsp], 33	; 00000021H
  00021	77 6c		 ja	 SHORT $LN1@get_operat
  00023	48 63 04 24	 movsxd	 rax, DWORD PTR tv65[rsp]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0002e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN17@get_operat[rcx+rax]
  00036	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN18@get_operat[rcx+rax*4]
  0003d	48 03 c1	 add	 rax, rcx
  00040	ff e0		 jmp	 rax
$LN12@get_operat:

; 811  :         case VBAR:
; 812  :             return BitOr;

  00042	b8 09 00 00 00	 mov	 eax, 9
  00047	eb 48		 jmp	 SHORT $LN15@get_operat
$LN11@get_operat:

; 813  :         case CIRCUMFLEX:
; 814  :             return BitXor;

  00049	b8 0a 00 00 00	 mov	 eax, 10
  0004e	eb 41		 jmp	 SHORT $LN15@get_operat
$LN10@get_operat:

; 815  :         case AMPER:
; 816  :             return BitAnd;

  00050	b8 0b 00 00 00	 mov	 eax, 11
  00055	eb 3a		 jmp	 SHORT $LN15@get_operat
$LN9@get_operat:

; 817  :         case LEFTSHIFT:
; 818  :             return LShift;

  00057	b8 07 00 00 00	 mov	 eax, 7
  0005c	eb 33		 jmp	 SHORT $LN15@get_operat
$LN8@get_operat:

; 819  :         case RIGHTSHIFT:
; 820  :             return RShift;

  0005e	b8 08 00 00 00	 mov	 eax, 8
  00063	eb 2c		 jmp	 SHORT $LN15@get_operat
$LN7@get_operat:

; 821  :         case PLUS:
; 822  :             return Add;

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	eb 25		 jmp	 SHORT $LN15@get_operat
$LN6@get_operat:

; 823  :         case MINUS:
; 824  :             return Sub;

  0006c	b8 02 00 00 00	 mov	 eax, 2
  00071	eb 1e		 jmp	 SHORT $LN15@get_operat
$LN5@get_operat:

; 825  :         case STAR:
; 826  :             return Mult;

  00073	b8 03 00 00 00	 mov	 eax, 3
  00078	eb 17		 jmp	 SHORT $LN15@get_operat
$LN4@get_operat:

; 827  :         case SLASH:
; 828  :             return Div;

  0007a	b8 04 00 00 00	 mov	 eax, 4
  0007f	eb 10		 jmp	 SHORT $LN15@get_operat
$LN3@get_operat:

; 829  :         case DOUBLESLASH:
; 830  :             return FloorDiv;

  00081	b8 0c 00 00 00	 mov	 eax, 12
  00086	eb 09		 jmp	 SHORT $LN15@get_operat
$LN2@get_operat:

; 831  :         case PERCENT:
; 832  :             return Mod;

  00088	b8 05 00 00 00	 mov	 eax, 5
  0008d	eb 02		 jmp	 SHORT $LN15@get_operat
$LN1@get_operat:

; 833  :         default:
; 834  :             return (operator_ty)0;

  0008f	33 c0		 xor	 eax, eax
$LN15@get_operat:

; 835  :     }
; 836  : }

  00091	48 83 c4 18	 add	 rsp, 24
  00095	c3		 ret	 0
  00096	66 90		 npad	 2
$LN18@get_operat:
  00098	00 00 00 00	 DD	 $LN7@get_operat
  0009c	00 00 00 00	 DD	 $LN6@get_operat
  000a0	00 00 00 00	 DD	 $LN5@get_operat
  000a4	00 00 00 00	 DD	 $LN4@get_operat
  000a8	00 00 00 00	 DD	 $LN12@get_operat
  000ac	00 00 00 00	 DD	 $LN10@get_operat
  000b0	00 00 00 00	 DD	 $LN2@get_operat
  000b4	00 00 00 00	 DD	 $LN11@get_operat
  000b8	00 00 00 00	 DD	 $LN9@get_operat
  000bc	00 00 00 00	 DD	 $LN8@get_operat
  000c0	00 00 00 00	 DD	 $LN3@get_operat
  000c4	00 00 00 00	 DD	 $LN1@get_operat
$LN17@get_operat:
  000c8	00		 DB	 0
  000c9	01		 DB	 1
  000ca	02		 DB	 2
  000cb	03		 DB	 3
  000cc	04		 DB	 4
  000cd	05		 DB	 5
  000ce	0b		 DB	 11
  000cf	0b		 DB	 11
  000d0	0b		 DB	 11
  000d1	0b		 DB	 11
  000d2	06		 DB	 6
  000d3	0b		 DB	 11
  000d4	0b		 DB	 11
  000d5	0b		 DB	 11
  000d6	0b		 DB	 11
  000d7	0b		 DB	 11
  000d8	0b		 DB	 11
  000d9	0b		 DB	 11
  000da	07		 DB	 7
  000db	08		 DB	 8
  000dc	09		 DB	 9
  000dd	0b		 DB	 11
  000de	0b		 DB	 11
  000df	0b		 DB	 11
  000e0	0b		 DB	 11
  000e1	0b		 DB	 11
  000e2	0b		 DB	 11
  000e3	0b		 DB	 11
  000e4	0b		 DB	 11
  000e5	0b		 DB	 11
  000e6	0b		 DB	 11
  000e7	0b		 DB	 11
  000e8	0b		 DB	 11
  000e9	0a		 DB	 10
get_operator ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@MFDCCJEE@unhandled?5factor?3?5?$CFd?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_factor DD imagerel ast_for_factor
	DD	imagerel ast_for_factor+293
	DD	imagerel $unwind$ast_for_factor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_factor DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BF@MFDCCJEE@unhandled?5factor?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BF@MFDCCJEE@unhandled?5factor?3?5?$CFd?$AA@ DB 'unhandled factor: '
	DB	'%d', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_factor
_TEXT	SEGMENT
expression$ = 48
tv73 = 56
c$ = 80
n$ = 88
ast_for_factor PROC					; COMDAT

; 2162 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2163 :     expr_ty expression;
; 2164 : 
; 2165 :     expression = ast_for_expr(c, CHILD(n, 1));

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00013	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00017	48 83 c0 28	 add	 rax, 40			; 00000028H
  0001b	48 8b d0	 mov	 rdx, rax
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00023	e8 00 00 00 00	 call	 ast_for_expr
  00028	48 89 44 24 30	 mov	 QWORD PTR expression$[rsp], rax

; 2166 :     if (!expression)

  0002d	48 83 7c 24 30
	00		 cmp	 QWORD PTR expression$[rsp], 0
  00033	75 07		 jne	 SHORT $LN6@ast_for_fa

; 2167 :         return NULL;

  00035	33 c0		 xor	 eax, eax
  00037	e9 e4 00 00 00	 jmp	 $LN7@ast_for_fa
$LN6@ast_for_fa:

; 2168 : 
; 2169 :     switch (TYPE(CHILD(n, 0))) {

  0003c	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00048	89 44 24 38	 mov	 DWORD PTR tv73[rsp], eax
  0004c	83 7c 24 38 0e	 cmp	 DWORD PTR tv73[rsp], 14
  00051	74 13		 je	 SHORT $LN3@ast_for_fa
  00053	83 7c 24 38 0f	 cmp	 DWORD PTR tv73[rsp], 15
  00058	74 40		 je	 SHORT $LN2@ast_for_fa
  0005a	83 7c 24 38 1f	 cmp	 DWORD PTR tv73[rsp], 31
  0005f	74 6a		 je	 SHORT $LN1@ast_for_fa
  00061	e9 96 00 00 00	 jmp	 $LN4@ast_for_fa
$LN3@ast_for_fa:

; 2170 :         case PLUS:
; 2171 :             return UnaryOp(UAdd, expression, LINENO(n), n->n_col_offset,
; 2172 :                            c->c_arena);

  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  0006b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00074	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00079	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00082	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00086	48 8b 54 24 30	 mov	 rdx, QWORD PTR expression$[rsp]
  0008b	b9 03 00 00 00	 mov	 ecx, 3
  00090	e8 00 00 00 00	 call	 _Py_UnaryOp
  00095	e9 86 00 00 00	 jmp	 $LN7@ast_for_fa
$LN2@ast_for_fa:

; 2173 :         case MINUS:
; 2174 :             return UnaryOp(USub, expression, LINENO(n), n->n_col_offset,
; 2175 :                            c->c_arena);

  0009a	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  0009f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a8	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000ad	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  000b1	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000b6	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  000ba	48 8b 54 24 30	 mov	 rdx, QWORD PTR expression$[rsp]
  000bf	b9 04 00 00 00	 mov	 ecx, 4
  000c4	e8 00 00 00 00	 call	 _Py_UnaryOp
  000c9	eb 55		 jmp	 SHORT $LN7@ast_for_fa
$LN1@ast_for_fa:

; 2176 :         case TILDE:
; 2177 :             return UnaryOp(Invert, expression, LINENO(n),
; 2178 :                            n->n_col_offset, c->c_arena);

  000cb	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  000d0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000de	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  000e2	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000e7	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  000eb	48 8b 54 24 30	 mov	 rdx, QWORD PTR expression$[rsp]
  000f0	b9 01 00 00 00	 mov	 ecx, 1
  000f5	e8 00 00 00 00	 call	 _Py_UnaryOp
  000fa	eb 24		 jmp	 SHORT $LN7@ast_for_fa
$LN4@ast_for_fa:

; 2179 :     }
; 2180 :     PyErr_Format(PyExc_SystemError, "unhandled factor: %d",
; 2181 :                  TYPE(CHILD(n, 0)));

  000fc	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00101	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00105	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00108	44 8b c0	 mov	 r8d, eax
  0010b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@MFDCCJEE@unhandled?5factor?3?5?$CFd?$AA@
  00112	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00119	e8 00 00 00 00	 call	 PyErr_Format

; 2182 :     return NULL;

  0011e	33 c0		 xor	 eax, eax
$LN7@ast_for_fa:

; 2183 : }

  00120	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00124	c3		 ret	 0
ast_for_factor ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@CEEMJKHJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA9?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_power DD imagerel ast_for_power
	DD	imagerel ast_for_power+465
	DD	imagerel $unwind$ast_for_power
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_power DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_1CC@CEEMJKHJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA9?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@CEEMJKHJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA9?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '1'
	DB	00H, '9', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_power
_TEXT	SEGMENT
i$ = 48
tmp$ = 56
e$ = 64
ch$23456 = 72
f$23461 = 80
c$ = 112
n$ = 120
ast_for_power PROC					; COMDAT

; 2187 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2188 :     /* power: atom trailer* ('**' factor)*
; 2189 :      */
; 2190 :     int i;
; 2191 :     expr_ty e, tmp;
; 2192 :     REQ(n, power);

  0000e	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 3f 01 00 00	 cmp	 eax, 319		; 0000013fH
  0001b	74 1c		 je	 SHORT $LN13@ast_for_po
  0001d	41 b8 90 08 00
	00		 mov	 r8d, 2192		; 00000890H
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CEEMJKHJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA9?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN13@ast_for_po:

; 2193 :     e = ast_for_atom(c, CHILD(n, 0));

  00039	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0003e	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00042	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00047	e8 00 00 00 00	 call	 ast_for_atom
  0004c	48 89 44 24 40	 mov	 QWORD PTR e$[rsp], rax

; 2194 :     if (!e)

  00051	48 83 7c 24 40
	00		 cmp	 QWORD PTR e$[rsp], 0
  00057	75 07		 jne	 SHORT $LN10@ast_for_po

; 2195 :         return NULL;

  00059	33 c0		 xor	 eax, eax
  0005b	e9 6c 01 00 00	 jmp	 $LN11@ast_for_po
$LN10@ast_for_po:

; 2196 :     if (NCH(n) == 1)

  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00065	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00069	75 0a		 jne	 SHORT $LN9@ast_for_po

; 2197 :         return e;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR e$[rsp]
  00070	e9 57 01 00 00	 jmp	 $LN11@ast_for_po
$LN9@ast_for_po:

; 2198 :     for (i = 1; i < NCH(n); i++) {

  00075	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0007d	eb 0a		 jmp	 SHORT $LN8@ast_for_po
$LN7@ast_for_po:
  0007f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00083	ff c0		 inc	 eax
  00085	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN8@ast_for_po:
  00089	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0008e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00091	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00095	7d 7f		 jge	 SHORT $LN6@ast_for_po

; 2199 :         node *ch = CHILD(n, i);

  00097	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0009c	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR n$[rsp]
  000a5	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000a9	48 89 44 24 48	 mov	 QWORD PTR ch$23456[rsp], rax

; 2200 :         if (TYPE(ch) != trailer)

  000ae	48 8b 44 24 48	 mov	 rax, QWORD PTR ch$23456[rsp]
  000b3	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000b6	3d 42 01 00 00	 cmp	 eax, 322		; 00000142H
  000bb	74 02		 je	 SHORT $LN5@ast_for_po

; 2201 :             break;

  000bd	eb 57		 jmp	 SHORT $LN6@ast_for_po
$LN5@ast_for_po:

; 2202 :         tmp = ast_for_trailer(c, ch, e);

  000bf	4c 8b 44 24 40	 mov	 r8, QWORD PTR e$[rsp]
  000c4	48 8b 54 24 48	 mov	 rdx, QWORD PTR ch$23456[rsp]
  000c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000ce	e8 00 00 00 00	 call	 ast_for_trailer
  000d3	48 89 44 24 38	 mov	 QWORD PTR tmp$[rsp], rax

; 2203 :         if (!tmp)

  000d8	48 83 7c 24 38
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  000de	75 07		 jne	 SHORT $LN4@ast_for_po

; 2204 :             return NULL;

  000e0	33 c0		 xor	 eax, eax
  000e2	e9 e5 00 00 00	 jmp	 $LN11@ast_for_po
$LN4@ast_for_po:

; 2205 :         tmp->lineno = e->lineno;

  000e7	48 8b 44 24 38	 mov	 rax, QWORD PTR tmp$[rsp]
  000ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR e$[rsp]
  000f1	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  000f4	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 2206 :         tmp->col_offset = e->col_offset;

  000f7	48 8b 44 24 38	 mov	 rax, QWORD PTR tmp$[rsp]
  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR e$[rsp]
  00101	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  00104	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 2207 :         e = tmp;

  00107	48 8b 44 24 38	 mov	 rax, QWORD PTR tmp$[rsp]
  0010c	48 89 44 24 40	 mov	 QWORD PTR e$[rsp], rax

; 2208 :     }

  00111	e9 69 ff ff ff	 jmp	 $LN7@ast_for_po
$LN6@ast_for_po:

; 2209 :     if (TYPE(CHILD(n, NCH(n) - 1)) == factor) {

  00116	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0011b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0011e	ff c8		 dec	 eax
  00120	48 98		 cdqe
  00122	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00126	48 8b 4c 24 78	 mov	 rcx, QWORD PTR n$[rsp]
  0012b	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0012f	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00133	3d 3e 01 00 00	 cmp	 eax, 318		; 0000013eH
  00138	0f 85 89 00 00
	00		 jne	 $LN3@ast_for_po

; 2210 :         expr_ty f = ast_for_expr(c, CHILD(n, NCH(n) - 1));

  0013e	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00143	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00146	ff c8		 dec	 eax
  00148	48 98		 cdqe
  0014a	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0014e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR n$[rsp]
  00153	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00157	48 8b d0	 mov	 rdx, rax
  0015a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0015f	e8 00 00 00 00	 call	 ast_for_expr
  00164	48 89 44 24 50	 mov	 QWORD PTR f$23461[rsp], rax

; 2211 :         if (!f)

  00169	48 83 7c 24 50
	00		 cmp	 QWORD PTR f$23461[rsp], 0
  0016f	75 04		 jne	 SHORT $LN2@ast_for_po

; 2212 :             return NULL;

  00171	33 c0		 xor	 eax, eax
  00173	eb 57		 jmp	 SHORT $LN11@ast_for_po
$LN2@ast_for_po:

; 2213 :         tmp = BinOp(e, Pow, f, LINENO(n), n->n_col_offset, c->c_arena);

  00175	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0017a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0017e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00183	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00188	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0018b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0018f	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00194	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  00198	4c 8b 44 24 50	 mov	 r8, QWORD PTR f$23461[rsp]
  0019d	ba 06 00 00 00	 mov	 edx, 6
  001a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR e$[rsp]
  001a7	e8 00 00 00 00	 call	 _Py_BinOp
  001ac	48 89 44 24 38	 mov	 QWORD PTR tmp$[rsp], rax

; 2214 :         if (!tmp)

  001b1	48 83 7c 24 38
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  001b7	75 04		 jne	 SHORT $LN1@ast_for_po

; 2215 :             return NULL;

  001b9	33 c0		 xor	 eax, eax
  001bb	eb 0f		 jmp	 SHORT $LN11@ast_for_po
$LN1@ast_for_po:

; 2216 :         e = tmp;

  001bd	48 8b 44 24 38	 mov	 rax, QWORD PTR tmp$[rsp]
  001c2	48 89 44 24 40	 mov	 QWORD PTR e$[rsp], rax
$LN3@ast_for_po:

; 2217 :     }
; 2218 :     return e;

  001c7	48 8b 44 24 40	 mov	 rax, QWORD PTR e$[rsp]
$LN11@ast_for_po:

; 2219 : }

  001cc	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001d0	c3		 ret	 0
ast_for_power ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@OKEJGOIF@unhandled?5atom?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_1EK@IHPOJLHM@?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?9?$AA?$DO@ ; `string'
PUBLIC	??_C@_1EC@NADANMCL@?$AA?$CI?$AAk?$AAe?$AAy?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAe?$AAy?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	??_C@_1EC@CNCMENEB@?$AA?$CI?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	??_C@_1CE@ODBMHGKM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA1?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BD@PNBHIMCO@?$CI?$CFs?$CJ?5unknown?5error?$AA@ ; `string'
PUBLIC	??_C@_07PGAKHMFE@?$CI?$CFs?$CJ?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0M@LMMBHDGD@value?5error?$AA@		; `string'
PUBLIC	??_C@_0O@PKBKOBHA@unicode?5error?$AA@		; `string'
EXTRN	_Py_Set:PROC
EXTRN	_Py_Dict:PROC
EXTRN	_Py_List:PROC
EXTRN	_Py_Ellipsis:PROC
EXTRN	_Py_Num:PROC
EXTRN	_Py_Str:PROC
EXTRN	_Py_Bytes:PROC
EXTRN	PyOS_snprintf:PROC
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyObject_Str:PROC
EXTRN	PyErr_Fetch:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_UnicodeError:QWORD
EXTRN	_Py_Name:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_atom DD imagerel ast_for_atom
	DD	imagerel ast_for_atom+2707
	DD	imagerel $unwind$ast_for_atom
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_atom DD 021101H
	DD	02d0111H
xdata	ENDS
;	COMDAT ??_C@_0BC@OKEJGOIF@unhandled?5atom?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BC@OKEJGOIF@unhandled?5atom?5?$CFd?$AA@ DB 'unhandled atom %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@IHPOJLHM@?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?9?$AA?$DO@
CONST	SEGMENT
??_C@_1EK@IHPOJLHM@?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?9?$AA?$DO@ DB '('
	DB	00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, 's', 00H
	DB	')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a'
	DB	00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, '(', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u'
	DB	00H, 'e', 00H, 's', 00H, ')', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@NADANMCL@?$AA?$CI?$AAk?$AAe?$AAy?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAe?$AAy?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1EC@NADANMCL@?$AA?$CI?$AAk?$AAe?$AAy?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAe?$AAy?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@ DB '('
	DB	00H, 'k', 00H, 'e', 00H, 'y', 00H, 's', 00H, ')', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's', 00H, 'd'
	DB	00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'(', 00H, 'k', 00H, 'e', 00H, 'y', 00H, 's', 00H, ')', 00H, '-'
	DB	00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@CNCMENEB@?$AA?$CI?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1EC@CNCMENEB@?$AA?$CI?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@ DB '('
	DB	00H, 'e', 00H, 'l', 00H, 't', 00H, 's', 00H, ')', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's', 00H, 'd'
	DB	00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'(', 00H, 'e', 00H, 'l', 00H, 't', 00H, 's', 00H, ')', 00H, '-'
	DB	00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@ODBMHGKM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA1?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@ODBMHGKM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA1?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'c', 00H, 'h', 00H
	DB	')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3'
	DB	00H, '2', 00H, '1', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PNBHIMCO@?$CI?$CFs?$CJ?5unknown?5error?$AA@
CONST	SEGMENT
??_C@_0BD@PNBHIMCO@?$CI?$CFs?$CJ?5unknown?5error?$AA@ DB '(%s) unknown er'
	DB	'ror', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_07PGAKHMFE@?$CI?$CFs?$CJ?5?$CFs?$AA@
CONST	SEGMENT
??_C@_07PGAKHMFE@?$CI?$CFs?$CJ?5?$CFs?$AA@ DB '(%s) %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LMMBHDGD@value?5error?$AA@
CONST	SEGMENT
??_C@_0M@LMMBHDGD@value?5error?$AA@ DB 'value error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PKBKOBHA@unicode?5error?$AA@
CONST	SEGMENT
??_C@_0O@PKBKOBHA@unicode?5error?$AA@ DB 'unicode error', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_atom
_TEXT	SEGMENT
bytesmode$ = 48
ch$ = 56
name$23182 = 64
str$23186 = 72
errtype$23188 = 80
value$23198 = 88
tback$23199 = 96
type$23197 = 104
buf$23196 = 112
errstr$23200 = 240
s$23202 = 248
pynum$23218 = 256
elts$23234 = 264
values$23242 = 272
i$23239 = 280
size$23240 = 284
keys$23241 = 288
elts$23249 = 296
expression$23255 = 304
_asdl_i$23258 = 312
expression$23273 = 320
_asdl_i$23276 = 328
_asdl_i$23281 = 332
tv66 = 336
c$ = 368
n$ = 376
ast_for_atom PROC					; COMDAT

; 1812 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H

; 1813 :     /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']'
; 1814 :        | '{' [dictmaker|testlist_comp] '}' | NAME | NUMBER | STRING+
; 1815 :        | '...' | 'None' | 'True' | 'False'
; 1816 :     */
; 1817 :     node *ch = CHILD(n, 0);

  00011	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00019	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001d	48 89 44 24 38	 mov	 QWORD PTR ch$[rsp], rax

; 1818 :     int bytesmode = 0;

  00022	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR bytesmode$[rsp], 0

; 1819 : 
; 1820 :     switch (TYPE(ch)) {

  0002a	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  0002f	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00032	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv66[rsp], eax
  00039	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR tv66[rsp]
  00040	ff c8		 dec	 eax
  00042	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv66[rsp], eax
  00049	83 bc 24 50 01
	00 00 32	 cmp	 DWORD PTR tv66[rsp], 50	; 00000032H
  00051	0f 87 c1 09 00
	00		 ja	 $LN1@ast_for_at
  00057	48 63 84 24 50
	01 00 00	 movsxd	 rax, DWORD PTR tv66[rsp]
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00066	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN64@ast_for_at[rcx+rax]
  0006e	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN65@ast_for_at[rcx+rax*4]
  00075	48 03 c1	 add	 rax, rcx
  00078	ff e0		 jmp	 rax
$LN52@ast_for_at:

; 1821 :     case NAME: {
; 1822 :         /* All names start in Load context, but may later be
; 1823 :            changed. */
; 1824 :         PyObject *name = NEW_IDENTIFIER(ch);

  0007a	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00082	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  00087	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0008b	e8 00 00 00 00	 call	 new_identifier
  00090	48 89 44 24 40	 mov	 QWORD PTR name$23182[rsp], rax

; 1825 :         if (!name)

  00095	48 83 7c 24 40
	00		 cmp	 QWORD PTR name$23182[rsp], 0
  0009b	75 07		 jne	 SHORT $LN51@ast_for_at

; 1826 :             return NULL;

  0009d	33 c0		 xor	 eax, eax
  0009f	e9 94 09 00 00	 jmp	 $LN55@ast_for_at
$LN51@ast_for_at:

; 1827 :         return Name(name, Load, LINENO(n), n->n_col_offset, c->c_arena);

  000a4	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000ac	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b5	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000bd	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  000c1	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000c9	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  000cd	ba 01 00 00 00	 mov	 edx, 1
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR name$23182[rsp]
  000d7	e8 00 00 00 00	 call	 _Py_Name
  000dc	e9 57 09 00 00	 jmp	 $LN55@ast_for_at
$LN50@ast_for_at:

; 1828 :     }
; 1829 :     case STRING: {
; 1830 :         PyObject *str = parsestrplus(c, n, &bytesmode);

  000e1	4c 8d 44 24 30	 lea	 r8, QWORD PTR bytesmode$[rsp]
  000e6	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  000ee	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000f6	e8 00 00 00 00	 call	 parsestrplus
  000fb	48 89 44 24 48	 mov	 QWORD PTR str$23186[rsp], rax

; 1831 :         if (!str) {

  00100	48 83 7c 24 48
	00		 cmp	 QWORD PTR str$23186[rsp], 0
  00106	0f 85 34 01 00
	00		 jne	 $LN49@ast_for_at

; 1832 :             const char *errtype = NULL;

  0010c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR errtype$23188[rsp], 0

; 1833 :             if (PyErr_ExceptionMatches(PyExc_UnicodeError))

  00115	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnicodeError
  0011c	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00121	85 c0		 test	 eax, eax
  00123	74 0e		 je	 SHORT $LN48@ast_for_at

; 1834 :                 errtype = "unicode error";

  00125	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@PKBKOBHA@unicode?5error?$AA@
  0012c	48 89 44 24 50	 mov	 QWORD PTR errtype$23188[rsp], rax
  00131	eb 1c		 jmp	 SHORT $LN47@ast_for_at
$LN48@ast_for_at:

; 1835 :             else if (PyErr_ExceptionMatches(PyExc_ValueError))

  00133	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0013a	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0013f	85 c0		 test	 eax, eax
  00141	74 0c		 je	 SHORT $LN46@ast_for_at

; 1836 :                 errtype = "value error";

  00143	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@LMMBHDGD@value?5error?$AA@
  0014a	48 89 44 24 50	 mov	 QWORD PTR errtype$23188[rsp], rax
$LN46@ast_for_at:
$LN47@ast_for_at:

; 1837 :             if (errtype) {

  0014f	48 83 7c 24 50
	00		 cmp	 QWORD PTR errtype$23188[rsp], 0
  00155	0f 84 de 00 00
	00		 je	 $LN45@ast_for_at

; 1838 :                 char buf[128];
; 1839 :                 PyObject *type, *value, *tback, *errstr;
; 1840 :                 PyErr_Fetch(&type, &value, &tback);

  0015b	4c 8d 44 24 60	 lea	 r8, QWORD PTR tback$23199[rsp]
  00160	48 8d 54 24 58	 lea	 rdx, QWORD PTR value$23198[rsp]
  00165	48 8d 4c 24 68	 lea	 rcx, QWORD PTR type$23197[rsp]
  0016a	e8 00 00 00 00	 call	 PyErr_Fetch

; 1841 :                 errstr = PyObject_Str(value);

  0016f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR value$23198[rsp]
  00174	e8 00 00 00 00	 call	 PyObject_Str
  00179	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR errstr$23200[rsp], rax

; 1842 :                 if (errstr) {

  00181	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR errstr$23200[rsp], 0
  0018a	74 4c		 je	 SHORT $LN44@ast_for_at

; 1843 :                     char *s = _PyUnicode_AsString(errstr);

  0018c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR errstr$23200[rsp]
  00194	e8 00 00 00 00	 call	 PyUnicode_AsUTF8
  00199	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR s$23202[rsp], rax

; 1844 :                     PyOS_snprintf(buf, sizeof(buf), "(%s) %s", errtype, s);

  001a1	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR s$23202[rsp]
  001a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ae	4c 8b 4c 24 50	 mov	 r9, QWORD PTR errtype$23188[rsp]
  001b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07PGAKHMFE@?$CI?$CFs?$CJ?5?$CFs?$AA@
  001ba	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001bf	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buf$23196[rsp]
  001c4	e8 00 00 00 00	 call	 PyOS_snprintf

; 1845 :                     Py_DECREF(errstr);

  001c9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR errstr$23200[rsp]
  001d1	e8 00 00 00 00	 call	 _Py_DecRef

; 1846 :                 } else {

  001d6	eb 1b		 jmp	 SHORT $LN43@ast_for_at
$LN44@ast_for_at:

; 1847 :                     PyOS_snprintf(buf, sizeof(buf), "(%s) unknown error", errtype);

  001d8	4c 8b 4c 24 50	 mov	 r9, QWORD PTR errtype$23188[rsp]
  001dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BD@PNBHIMCO@?$CI?$CFs?$CJ?5unknown?5error?$AA@
  001e4	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001e9	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buf$23196[rsp]
  001ee	e8 00 00 00 00	 call	 PyOS_snprintf
$LN43@ast_for_at:

; 1848 :                 }
; 1849 :                 ast_error(c, n, buf);

  001f3	4c 8d 44 24 70	 lea	 r8, QWORD PTR buf$23196[rsp]
  001f8	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  00200	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00208	e8 00 00 00 00	 call	 ast_error

; 1850 :                 Py_DECREF(type);

  0020d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR type$23197[rsp]
  00212	e8 00 00 00 00	 call	 _Py_DecRef

; 1851 :                 Py_DECREF(value);

  00217	48 8b 4c 24 58	 mov	 rcx, QWORD PTR value$23198[rsp]
  0021c	e8 00 00 00 00	 call	 _Py_DecRef
$LN42@ast_for_at:

; 1852 :                 Py_XDECREF(tback);

  00221	48 83 7c 24 60
	00		 cmp	 QWORD PTR tback$23199[rsp], 0
  00227	74 0a		 je	 SHORT $LN39@ast_for_at
  00229	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tback$23199[rsp]
  0022e	e8 00 00 00 00	 call	 _Py_DecRef
$LN39@ast_for_at:
  00233	33 c0		 xor	 eax, eax
  00235	85 c0		 test	 eax, eax
  00237	75 e8		 jne	 SHORT $LN42@ast_for_at
$LN45@ast_for_at:

; 1853 :             }
; 1854 :             return NULL;

  00239	33 c0		 xor	 eax, eax
  0023b	e9 f8 07 00 00	 jmp	 $LN55@ast_for_at
$LN49@ast_for_at:

; 1855 :         }
; 1856 :         PyArena_AddPyObject(c->c_arena, str);

  00240	48 8b 54 24 48	 mov	 rdx, QWORD PTR str$23186[rsp]
  00245	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0024d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00251	e8 00 00 00 00	 call	 PyArena_AddPyObject

; 1857 :         if (bytesmode)

  00256	83 7c 24 30 00	 cmp	 DWORD PTR bytesmode$[rsp], 0
  0025b	74 34		 je	 SHORT $LN38@ast_for_at

; 1858 :             return Bytes(str, LINENO(n), n->n_col_offset, c->c_arena);

  0025d	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00265	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00269	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00271	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  00275	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0027d	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00280	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$23186[rsp]
  00285	e8 00 00 00 00	 call	 _Py_Bytes
  0028a	e9 a9 07 00 00	 jmp	 $LN55@ast_for_at

; 1859 :         else

  0028f	eb 32		 jmp	 SHORT $LN37@ast_for_at
$LN38@ast_for_at:

; 1860 :             return Str(str, LINENO(n), n->n_col_offset, c->c_arena);

  00291	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00299	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  0029d	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002a5	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  002a9	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002b1	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  002b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR str$23186[rsp]
  002b9	e8 00 00 00 00	 call	 _Py_Str
  002be	e9 75 07 00 00	 jmp	 $LN55@ast_for_at
$LN37@ast_for_at:
$LN36@ast_for_at:

; 1861 :     }
; 1862 :     case NUMBER: {
; 1863 :         PyObject *pynum = parsenumber(c, STR(ch));

  002c3	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  002c8	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  002cc	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002d4	e8 00 00 00 00	 call	 parsenumber
  002d9	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR pynum$23218[rsp], rax

; 1864 :         if (!pynum)

  002e1	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR pynum$23218[rsp], 0
  002ea	75 07		 jne	 SHORT $LN35@ast_for_at

; 1865 :             return NULL;

  002ec	33 c0		 xor	 eax, eax
  002ee	e9 45 07 00 00	 jmp	 $LN55@ast_for_at
$LN35@ast_for_at:

; 1866 : 
; 1867 :         PyArena_AddPyObject(c->c_arena, pynum);

  002f3	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR pynum$23218[rsp]
  002fb	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00303	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00307	e8 00 00 00 00	 call	 PyArena_AddPyObject

; 1868 :         return Num(pynum, LINENO(n), n->n_col_offset, c->c_arena);

  0030c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00314	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00318	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00320	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  00324	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0032c	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  0032f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR pynum$23218[rsp]
  00337	e8 00 00 00 00	 call	 _Py_Num
  0033c	e9 f7 06 00 00	 jmp	 $LN55@ast_for_at
$LN34@ast_for_at:

; 1869 :     }
; 1870 :     case ELLIPSIS: /* Ellipsis */
; 1871 :         return Ellipsis(LINENO(n), n->n_col_offset, c->c_arena);

  00341	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00349	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0034d	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00355	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00358	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00360	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00363	e8 00 00 00 00	 call	 _Py_Ellipsis
  00368	e9 cb 06 00 00	 jmp	 $LN55@ast_for_at
$LN33@ast_for_at:

; 1872 :     case LPAR: /* some parenthesized expressions */
; 1873 :         ch = CHILD(n, 1);

  0036d	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00375	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00379	48 83 c0 28	 add	 rax, 40			; 00000028H
  0037d	48 89 44 24 38	 mov	 QWORD PTR ch$[rsp], rax

; 1874 : 
; 1875 :         if (TYPE(ch) == RPAR)

  00382	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  00387	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0038a	83 f8 08	 cmp	 eax, 8
  0038d	75 3a		 jne	 SHORT $LN32@ast_for_at

; 1876 :             return Tuple(NULL, Load, LINENO(n), n->n_col_offset, c->c_arena);

  0038f	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00397	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0039b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a0	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003a8	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  003ac	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003b4	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  003b8	ba 01 00 00 00	 mov	 edx, 1
  003bd	33 c9		 xor	 ecx, ecx
  003bf	e8 00 00 00 00	 call	 _Py_Tuple
  003c4	e9 6f 06 00 00	 jmp	 $LN55@ast_for_at
$LN32@ast_for_at:

; 1877 : 
; 1878 :         if (TYPE(ch) == yield_expr)

  003c9	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  003ce	0f bf 00	 movsx	 eax, WORD PTR [rax]
  003d1	3d 50 01 00 00	 cmp	 eax, 336		; 00000150H
  003d6	75 17		 jne	 SHORT $LN31@ast_for_at

; 1879 :             return ast_for_expr(c, ch);

  003d8	48 8b 54 24 38	 mov	 rdx, QWORD PTR ch$[rsp]
  003dd	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003e5	e8 00 00 00 00	 call	 ast_for_expr
  003ea	e9 49 06 00 00	 jmp	 $LN55@ast_for_at
$LN31@ast_for_at:

; 1880 : 
; 1881 :         /* testlist_comp: test ( comp_for | (',' test)* [','] ) */
; 1882 :         if ((NCH(ch) > 1) && (TYPE(CHILD(ch, 1)) == comp_for))

  003ef	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  003f4	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  003f8	7e 2b		 jle	 SHORT $LN30@ast_for_at
  003fa	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  003ff	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00403	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  00407	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  0040c	75 17		 jne	 SHORT $LN30@ast_for_at

; 1883 :             return ast_for_genexp(c, ch);

  0040e	48 8b 54 24 38	 mov	 rdx, QWORD PTR ch$[rsp]
  00413	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0041b	e8 00 00 00 00	 call	 ast_for_genexp
  00420	e9 13 06 00 00	 jmp	 $LN55@ast_for_at
$LN30@ast_for_at:

; 1884 : 
; 1885 :         return ast_for_testlist(c, ch);

  00425	48 8b 54 24 38	 mov	 rdx, QWORD PTR ch$[rsp]
  0042a	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00432	e8 00 00 00 00	 call	 ast_for_testlist
  00437	e9 fc 05 00 00	 jmp	 $LN55@ast_for_at
$LN29@ast_for_at:

; 1886 :     case LSQB: /* list (or list comprehension) */
; 1887 :         ch = CHILD(n, 1);

  0043c	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00444	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00448	48 83 c0 28	 add	 rax, 40			; 00000028H
  0044c	48 89 44 24 38	 mov	 QWORD PTR ch$[rsp], rax

; 1888 : 
; 1889 :         if (TYPE(ch) == RSQB)

  00451	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  00456	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00459	83 f8 0a	 cmp	 eax, 10
  0045c	75 3a		 jne	 SHORT $LN28@ast_for_at

; 1890 :             return List(NULL, Load, LINENO(n), n->n_col_offset, c->c_arena);

  0045e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00466	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0046a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0046f	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00477	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0047b	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00483	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00487	ba 01 00 00 00	 mov	 edx, 1
  0048c	33 c9		 xor	 ecx, ecx
  0048e	e8 00 00 00 00	 call	 _Py_List
  00493	e9 a0 05 00 00	 jmp	 $LN55@ast_for_at
$LN28@ast_for_at:

; 1891 : 
; 1892 :         REQ(ch, testlist_comp);

  00498	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  0049d	0f bf 00	 movsx	 eax, WORD PTR [rax]
  004a0	3d 41 01 00 00	 cmp	 eax, 321		; 00000141H
  004a5	74 1c		 je	 SHORT $LN57@ast_for_at
  004a7	41 b8 64 07 00
	00		 mov	 r8d, 1892		; 00000764H
  004ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  004b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@ODBMHGKM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA1?$AA?$CJ?$AA?$AA@
  004bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004c1	33 c0		 xor	 eax, eax
$LN57@ast_for_at:

; 1893 :         if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {

  004c3	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  004c8	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  004cc	74 12		 je	 SHORT $LN26@ast_for_at
  004ce	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  004d3	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  004d7	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  004db	83 f8 0c	 cmp	 eax, 12
  004de	75 6e		 jne	 SHORT $LN27@ast_for_at
$LN26@ast_for_at:

; 1894 :             asdl_seq *elts = seq_for_testlist(c, ch);

  004e0	48 8b 54 24 38	 mov	 rdx, QWORD PTR ch$[rsp]
  004e5	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  004ed	e8 00 00 00 00	 call	 seq_for_testlist
  004f2	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR elts$23234[rsp], rax

; 1895 :             if (!elts)

  004fa	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR elts$23234[rsp], 0
  00503	75 07		 jne	 SHORT $LN25@ast_for_at

; 1896 :                 return NULL;

  00505	33 c0		 xor	 eax, eax
  00507	e9 2c 05 00 00	 jmp	 $LN55@ast_for_at
$LN25@ast_for_at:

; 1897 : 
; 1898 :             return List(elts, Load, LINENO(n), n->n_col_offset, c->c_arena);

  0050c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00514	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00518	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0051d	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00525	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  00529	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00531	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00535	ba 01 00 00 00	 mov	 edx, 1
  0053a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR elts$23234[rsp]
  00542	e8 00 00 00 00	 call	 _Py_List
  00547	e9 ec 04 00 00	 jmp	 $LN55@ast_for_at

; 1899 :         }
; 1900 :         else

  0054c	eb 17		 jmp	 SHORT $LN24@ast_for_at
$LN27@ast_for_at:

; 1901 :             return ast_for_listcomp(c, ch);

  0054e	48 8b 54 24 38	 mov	 rdx, QWORD PTR ch$[rsp]
  00553	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0055b	e8 00 00 00 00	 call	 ast_for_listcomp
  00560	e9 d3 04 00 00	 jmp	 $LN55@ast_for_at
$LN24@ast_for_at:
$LN23@ast_for_at:

; 1902 :     case LBRACE: {
; 1903 :         /* dictorsetmaker: test ':' test (',' test ':' test)* [','] |
; 1904 :          *                 test (gen_for | (',' test)* [','])  */
; 1905 :         int i, size;
; 1906 :         asdl_seq *keys, *values;
; 1907 : 
; 1908 :         ch = CHILD(n, 1);

  00565	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0056d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00571	48 83 c0 28	 add	 rax, 40			; 00000028H
  00575	48 89 44 24 38	 mov	 QWORD PTR ch$[rsp], rax

; 1909 :         if (TYPE(ch) == RBRACE) {

  0057a	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  0057f	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00582	83 f8 1a	 cmp	 eax, 26
  00585	75 3c		 jne	 SHORT $LN22@ast_for_at

; 1910 :             /* it's an empty dict */
; 1911 :             return Dict(NULL, NULL, LINENO(n), n->n_col_offset, c->c_arena);

  00587	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0058f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00593	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00598	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  005a0	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  005a4	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  005ac	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  005b0	33 d2		 xor	 edx, edx
  005b2	33 c9		 xor	 ecx, ecx
  005b4	e8 00 00 00 00	 call	 _Py_Dict
  005b9	e9 7a 04 00 00	 jmp	 $LN55@ast_for_at
  005be	e9 55 04 00 00	 jmp	 $LN21@ast_for_at
$LN22@ast_for_at:

; 1912 :         } else if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == COMMA) {

  005c3	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  005c8	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  005cc	74 16		 je	 SHORT $LN19@ast_for_at
  005ce	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  005d3	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  005d7	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  005db	83 f8 0c	 cmp	 eax, 12
  005de	0f 85 69 01 00
	00		 jne	 $LN20@ast_for_at
$LN19@ast_for_at:

; 1913 :             /* it's a simple set */
; 1914 :             asdl_seq *elts;
; 1915 :             size = (NCH(ch) + 1) / 2; /* +1 in case no trailing comma */

  005e4	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  005e9	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  005ec	ff c0		 inc	 eax
  005ee	99		 cdq
  005ef	2b c2		 sub	 eax, edx
  005f1	d1 f8		 sar	 eax, 1
  005f3	89 84 24 1c 01
	00 00		 mov	 DWORD PTR size$23240[rsp], eax

; 1916 :             elts = asdl_seq_new(size, c->c_arena);

  005fa	48 63 84 24 1c
	01 00 00	 movsxd	 rax, DWORD PTR size$23240[rsp]
  00602	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0060a	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0060e	48 8b c8	 mov	 rcx, rax
  00611	e8 00 00 00 00	 call	 asdl_seq_new
  00616	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR elts$23249[rsp], rax

; 1917 :             if (!elts)

  0061e	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR elts$23249[rsp], 0
  00627	75 07		 jne	 SHORT $LN18@ast_for_at

; 1918 :                 return NULL;

  00629	33 c0		 xor	 eax, eax
  0062b	e9 08 04 00 00	 jmp	 $LN55@ast_for_at
$LN18@ast_for_at:

; 1919 :             for (i = 0; i < NCH(ch); i += 2) {

  00630	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$23239[rsp], 0
  0063b	eb 11		 jmp	 SHORT $LN17@ast_for_at
$LN16@ast_for_at:
  0063d	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR i$23239[rsp]
  00644	83 c0 02	 add	 eax, 2
  00647	89 84 24 18 01
	00 00		 mov	 DWORD PTR i$23239[rsp], eax
$LN17@ast_for_at:
  0064e	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  00653	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00656	39 84 24 18 01
	00 00		 cmp	 DWORD PTR i$23239[rsp], eax
  0065d	0f 8d b0 00 00
	00		 jge	 $LN15@ast_for_at

; 1920 :                 expr_ty expression;
; 1921 :                 expression = ast_for_expr(c, CHILD(ch, i));

  00663	48 63 84 24 18
	01 00 00	 movsxd	 rax, DWORD PTR i$23239[rsp]
  0066b	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0066f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ch$[rsp]
  00674	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00678	48 8b d0	 mov	 rdx, rax
  0067b	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00683	e8 00 00 00 00	 call	 ast_for_expr
  00688	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR expression$23255[rsp], rax

; 1922 :                 if (!expression)

  00690	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR expression$23255[rsp], 0
  00699	75 07		 jne	 SHORT $LN14@ast_for_at

; 1923 :                     return NULL;

  0069b	33 c0		 xor	 eax, eax
  0069d	e9 96 03 00 00	 jmp	 $LN55@ast_for_at
$LN14@ast_for_at:

; 1924 :                 asdl_seq_SET(elts, i / 2, expression);

  006a2	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR i$23239[rsp]
  006a9	99		 cdq
  006aa	2b c2		 sub	 eax, edx
  006ac	d1 f8		 sar	 eax, 1
  006ae	89 84 24 38 01
	00 00		 mov	 DWORD PTR _asdl_i$23258[rsp], eax
  006b5	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR elts$23249[rsp], 0
  006be	74 15		 je	 SHORT $LN58@ast_for_at
  006c0	48 63 84 24 38
	01 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23258[rsp]
  006c8	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR elts$23249[rsp]
  006d0	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  006d3	7c 1c		 jl	 SHORT $LN59@ast_for_at
$LN58@ast_for_at:
  006d5	41 b8 84 07 00
	00		 mov	 r8d, 1924		; 00000784H
  006db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  006e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@CNCMENEB@?$AA?$CI?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@
  006e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006ef	33 c0		 xor	 eax, eax
$LN59@ast_for_at:
  006f1	48 63 84 24 38
	01 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23258[rsp]
  006f9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR elts$23249[rsp]
  00701	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR expression$23255[rsp]
  00709	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 1925 :             }

  0070e	e9 2a ff ff ff	 jmp	 $LN16@ast_for_at
$LN15@ast_for_at:

; 1926 :             return Set(elts, LINENO(n), n->n_col_offset, c->c_arena);

  00713	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0071b	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  0071f	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00727	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  0072b	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00733	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00736	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR elts$23249[rsp]
  0073e	e8 00 00 00 00	 call	 _Py_Set
  00743	e9 f0 02 00 00	 jmp	 $LN55@ast_for_at
  00748	e9 cb 02 00 00	 jmp	 $LN13@ast_for_at
$LN20@ast_for_at:

; 1927 :         } else if (TYPE(CHILD(ch, 1)) == comp_for) {

  0074d	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  00752	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00756	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  0075a	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  0075f	75 1c		 jne	 SHORT $LN12@ast_for_at

; 1928 :             /* it's a set comprehension */
; 1929 :             return ast_for_setcomp(c, ch);

  00761	48 8b 54 24 38	 mov	 rdx, QWORD PTR ch$[rsp]
  00766	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0076e	e8 00 00 00 00	 call	 ast_for_setcomp
  00773	e9 c0 02 00 00	 jmp	 $LN55@ast_for_at
  00778	e9 9b 02 00 00	 jmp	 $LN11@ast_for_at
$LN12@ast_for_at:

; 1930 :         } else if (NCH(ch) > 3 && TYPE(CHILD(ch, 3)) == comp_for) {

  0077d	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  00782	83 78 18 03	 cmp	 DWORD PTR [rax+24], 3
  00786	7e 30		 jle	 SHORT $LN10@ast_for_at
  00788	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  0078d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00791	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  00795	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  0079a	75 1c		 jne	 SHORT $LN10@ast_for_at

; 1931 :             return ast_for_dictcomp(c, ch);

  0079c	48 8b 54 24 38	 mov	 rdx, QWORD PTR ch$[rsp]
  007a1	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  007a9	e8 00 00 00 00	 call	 ast_for_dictcomp
  007ae	e9 85 02 00 00	 jmp	 $LN55@ast_for_at

; 1932 :         } else {

  007b3	e9 60 02 00 00	 jmp	 $LN9@ast_for_at
$LN10@ast_for_at:

; 1933 :             /* it's a dict */
; 1934 :             size = (NCH(ch) + 1) / 4; /* +1 in case no trailing comma */

  007b8	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  007bd	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  007c0	ff c0		 inc	 eax
  007c2	99		 cdq
  007c3	83 e2 03	 and	 edx, 3
  007c6	03 c2		 add	 eax, edx
  007c8	c1 f8 02	 sar	 eax, 2
  007cb	89 84 24 1c 01
	00 00		 mov	 DWORD PTR size$23240[rsp], eax

; 1935 :             keys = asdl_seq_new(size, c->c_arena);

  007d2	48 63 84 24 1c
	01 00 00	 movsxd	 rax, DWORD PTR size$23240[rsp]
  007da	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  007e2	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  007e6	48 8b c8	 mov	 rcx, rax
  007e9	e8 00 00 00 00	 call	 asdl_seq_new
  007ee	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR keys$23241[rsp], rax

; 1936 :             if (!keys)

  007f6	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR keys$23241[rsp], 0
  007ff	75 07		 jne	 SHORT $LN8@ast_for_at

; 1937 :                 return NULL;

  00801	33 c0		 xor	 eax, eax
  00803	e9 30 02 00 00	 jmp	 $LN55@ast_for_at
$LN8@ast_for_at:

; 1938 : 
; 1939 :             values = asdl_seq_new(size, c->c_arena);

  00808	48 63 84 24 1c
	01 00 00	 movsxd	 rax, DWORD PTR size$23240[rsp]
  00810	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00818	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0081c	48 8b c8	 mov	 rcx, rax
  0081f	e8 00 00 00 00	 call	 asdl_seq_new
  00824	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR values$23242[rsp], rax

; 1940 :             if (!values)

  0082c	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR values$23242[rsp], 0
  00835	75 07		 jne	 SHORT $LN7@ast_for_at

; 1941 :                 return NULL;

  00837	33 c0		 xor	 eax, eax
  00839	e9 fa 01 00 00	 jmp	 $LN55@ast_for_at
$LN7@ast_for_at:

; 1942 : 
; 1943 :             for (i = 0; i < NCH(ch); i += 4) {

  0083e	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$23239[rsp], 0
  00849	eb 11		 jmp	 SHORT $LN6@ast_for_at
$LN5@ast_for_at:
  0084b	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR i$23239[rsp]
  00852	83 c0 04	 add	 eax, 4
  00855	89 84 24 18 01
	00 00		 mov	 DWORD PTR i$23239[rsp], eax
$LN6@ast_for_at:
  0085c	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  00861	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00864	39 84 24 18 01
	00 00		 cmp	 DWORD PTR i$23239[rsp], eax
  0086b	0f 8d 67 01 00
	00		 jge	 $LN4@ast_for_at

; 1944 :                 expr_ty expression;
; 1945 : 
; 1946 :                 expression = ast_for_expr(c, CHILD(ch, i));

  00871	48 63 84 24 18
	01 00 00	 movsxd	 rax, DWORD PTR i$23239[rsp]
  00879	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0087d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ch$[rsp]
  00882	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00886	48 8b d0	 mov	 rdx, rax
  00889	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00891	e8 00 00 00 00	 call	 ast_for_expr
  00896	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR expression$23273[rsp], rax

; 1947 :                 if (!expression)

  0089e	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR expression$23273[rsp], 0
  008a7	75 07		 jne	 SHORT $LN3@ast_for_at

; 1948 :                     return NULL;

  008a9	33 c0		 xor	 eax, eax
  008ab	e9 88 01 00 00	 jmp	 $LN55@ast_for_at
$LN3@ast_for_at:

; 1949 : 
; 1950 :                 asdl_seq_SET(keys, i / 4, expression);

  008b0	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR i$23239[rsp]
  008b7	99		 cdq
  008b8	83 e2 03	 and	 edx, 3
  008bb	03 c2		 add	 eax, edx
  008bd	c1 f8 02	 sar	 eax, 2
  008c0	89 84 24 48 01
	00 00		 mov	 DWORD PTR _asdl_i$23276[rsp], eax
  008c7	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR keys$23241[rsp], 0
  008d0	74 15		 je	 SHORT $LN60@ast_for_at
  008d2	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23276[rsp]
  008da	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR keys$23241[rsp]
  008e2	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  008e5	7c 1c		 jl	 SHORT $LN61@ast_for_at
$LN60@ast_for_at:
  008e7	41 b8 9e 07 00
	00		 mov	 r8d, 1950		; 0000079eH
  008ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  008f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@NADANMCL@?$AA?$CI?$AAk?$AAe?$AAy?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAe?$AAy?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@
  008fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00901	33 c0		 xor	 eax, eax
$LN61@ast_for_at:
  00903	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23276[rsp]
  0090b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR keys$23241[rsp]
  00913	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR expression$23273[rsp]
  0091b	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 1951 : 
; 1952 :                 expression = ast_for_expr(c, CHILD(ch, i + 2));

  00920	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR i$23239[rsp]
  00927	83 c0 02	 add	 eax, 2
  0092a	48 98		 cdqe
  0092c	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00930	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ch$[rsp]
  00935	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00939	48 8b d0	 mov	 rdx, rax
  0093c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00944	e8 00 00 00 00	 call	 ast_for_expr
  00949	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR expression$23273[rsp], rax

; 1953 :                 if (!expression)

  00951	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR expression$23273[rsp], 0
  0095a	75 07		 jne	 SHORT $LN2@ast_for_at

; 1954 :                     return NULL;

  0095c	33 c0		 xor	 eax, eax
  0095e	e9 d5 00 00 00	 jmp	 $LN55@ast_for_at
$LN2@ast_for_at:

; 1955 : 
; 1956 :                 asdl_seq_SET(values, i / 4, expression);

  00963	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR i$23239[rsp]
  0096a	99		 cdq
  0096b	83 e2 03	 and	 edx, 3
  0096e	03 c2		 add	 eax, edx
  00970	c1 f8 02	 sar	 eax, 2
  00973	89 84 24 4c 01
	00 00		 mov	 DWORD PTR _asdl_i$23281[rsp], eax
  0097a	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR values$23242[rsp], 0
  00983	74 15		 je	 SHORT $LN62@ast_for_at
  00985	48 63 84 24 4c
	01 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23281[rsp]
  0098d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR values$23242[rsp]
  00995	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00998	7c 1c		 jl	 SHORT $LN63@ast_for_at
$LN62@ast_for_at:
  0099a	41 b8 a4 07 00
	00		 mov	 r8d, 1956		; 000007a4H
  009a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  009a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EK@IHPOJLHM@?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AA?$CJ?$AA?9?$AA?$DO@
  009ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  009b4	33 c0		 xor	 eax, eax
$LN63@ast_for_at:
  009b6	48 63 84 24 4c
	01 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23281[rsp]
  009be	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR values$23242[rsp]
  009c6	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR expression$23273[rsp]
  009ce	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 1957 :             }

  009d3	e9 73 fe ff ff	 jmp	 $LN5@ast_for_at
$LN4@ast_for_at:

; 1958 :             return Dict(keys, values, LINENO(n), n->n_col_offset, c->c_arena);

  009d8	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR c$[rsp]
  009e0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  009e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009e9	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  009f1	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  009f5	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR n$[rsp]
  009fd	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00a01	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR values$23242[rsp]
  00a09	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR keys$23241[rsp]
  00a11	e8 00 00 00 00	 call	 _Py_Dict
  00a16	eb 20		 jmp	 SHORT $LN55@ast_for_at
$LN9@ast_for_at:
$LN11@ast_for_at:
$LN13@ast_for_at:
$LN21@ast_for_at:
$LN1@ast_for_at:

; 1959 :         }
; 1960 :     }
; 1961 :     default:
; 1962 :         PyErr_Format(PyExc_SystemError, "unhandled atom %d", TYPE(ch));

  00a18	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  00a1d	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00a20	44 8b c0	 mov	 r8d, eax
  00a23	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@OKEJGOIF@unhandled?5atom?5?$CFd?$AA@
  00a2a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00a31	e8 00 00 00 00	 call	 PyErr_Format

; 1963 :         return NULL;

  00a36	33 c0		 xor	 eax, eax
$LN55@ast_for_at:

; 1964 :     }
; 1965 : }

  00a38	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  00a3f	c3		 ret	 0
$LN65@ast_for_at:
  00a40	00 00 00 00	 DD	 $LN52@ast_for_at
  00a44	00 00 00 00	 DD	 $LN36@ast_for_at
  00a48	00 00 00 00	 DD	 $LN50@ast_for_at
  00a4c	00 00 00 00	 DD	 $LN33@ast_for_at
  00a50	00 00 00 00	 DD	 $LN29@ast_for_at
  00a54	00 00 00 00	 DD	 $LN23@ast_for_at
  00a58	00 00 00 00	 DD	 $LN34@ast_for_at
  00a5c	00 00 00 00	 DD	 $LN1@ast_for_at
$LN64@ast_for_at:
  00a60	00		 DB	 0
  00a61	01		 DB	 1
  00a62	02		 DB	 2
  00a63	07		 DB	 7
  00a64	07		 DB	 7
  00a65	07		 DB	 7
  00a66	03		 DB	 3
  00a67	07		 DB	 7
  00a68	04		 DB	 4
  00a69	07		 DB	 7
  00a6a	07		 DB	 7
  00a6b	07		 DB	 7
  00a6c	07		 DB	 7
  00a6d	07		 DB	 7
  00a6e	07		 DB	 7
  00a6f	07		 DB	 7
  00a70	07		 DB	 7
  00a71	07		 DB	 7
  00a72	07		 DB	 7
  00a73	07		 DB	 7
  00a74	07		 DB	 7
  00a75	07		 DB	 7
  00a76	07		 DB	 7
  00a77	07		 DB	 7
  00a78	05		 DB	 5
  00a79	07		 DB	 7
  00a7a	07		 DB	 7
  00a7b	07		 DB	 7
  00a7c	07		 DB	 7
  00a7d	07		 DB	 7
  00a7e	07		 DB	 7
  00a7f	07		 DB	 7
  00a80	07		 DB	 7
  00a81	07		 DB	 7
  00a82	07		 DB	 7
  00a83	07		 DB	 7
  00a84	07		 DB	 7
  00a85	07		 DB	 7
  00a86	07		 DB	 7
  00a87	07		 DB	 7
  00a88	07		 DB	 7
  00a89	07		 DB	 7
  00a8a	07		 DB	 7
  00a8b	07		 DB	 7
  00a8c	07		 DB	 7
  00a8d	07		 DB	 7
  00a8e	07		 DB	 7
  00a8f	07		 DB	 7
  00a90	07		 DB	 7
  00a91	07		 DB	 7
  00a92	06		 DB	 6
ast_for_atom ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EC@JECKGBKO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA1?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA1?$AA1?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1BG@PNHNONPM@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA3?$AA?$AA@ ; `string'
EXTRN	_Py_DictComp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_dictcomp DD imagerel ast_for_dictcomp
	DD	imagerel ast_for_dictcomp+284
	DD	imagerel $unwind$ast_for_dictcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_dictcomp DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1EC@JECKGBKO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA1?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA1?$AA1?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@JECKGBKO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA1?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA1?$AA1?$AA?$CJ@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, '(', 00H, '&', 00H
	DB	'(', 00H, 'n', 00H, ')', 00H, '-', 00H, '>', 00H, 'n', 00H, '_'
	DB	00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '[', 00H
	DB	'1', 00H, ']', 00H, ')', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '(', 00H, '1', 00H, '1', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@PNHNONPM@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA3?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@PNHNONPM@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA3?$AA?$AA@ DB 'N'
	DB	00H, 'C', 00H, 'H', 00H, '(', 00H, 'n', 00H, ')', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '3', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_dictcomp
_TEXT	SEGMENT
value$ = 48
comps$ = 56
key$ = 64
c$ = 96
n$ = 104
ast_for_dictcomp PROC					; COMDAT

; 1767 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1768 :     expr_ty key, value;
; 1769 :     asdl_seq *comps;
; 1770 : 
; 1771 :     assert(NCH(n) > 3);

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00013	83 78 18 03	 cmp	 DWORD PTR [rax+24], 3
  00017	7f 1c		 jg	 SHORT $LN6@ast_for_di
  00019	41 b8 eb 06 00
	00		 mov	 r8d, 1771		; 000006ebH
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@PNHNONPM@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA3?$AA?$AA@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00033	33 c0		 xor	 eax, eax
$LN6@ast_for_di:

; 1772 :     REQ(CHILD(n, 1), COLON);

  00035	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0003a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0003e	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  00042	83 f8 0b	 cmp	 eax, 11
  00045	74 1c		 je	 SHORT $LN7@ast_for_di
  00047	41 b8 ec 06 00
	00		 mov	 r8d, 1772		; 000006ecH
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@JECKGBKO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA1?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA1?$AA1?$AA?$CJ@
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00061	33 c0		 xor	 eax, eax
$LN7@ast_for_di:

; 1773 : 
; 1774 :     key = ast_for_expr(c, CHILD(n, 0));

  00063	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00068	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  0006c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00071	e8 00 00 00 00	 call	 ast_for_expr
  00076	48 89 44 24 40	 mov	 QWORD PTR key$[rsp], rax

; 1775 :     if (!key)

  0007b	48 83 7c 24 40
	00		 cmp	 QWORD PTR key$[rsp], 0
  00081	75 07		 jne	 SHORT $LN3@ast_for_di

; 1776 :         return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	e9 8d 00 00 00	 jmp	 $LN4@ast_for_di
$LN3@ast_for_di:

; 1777 :     value = ast_for_expr(c, CHILD(n, 2));

  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0008f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00093	48 83 c0 50	 add	 rax, 80			; 00000050H
  00097	48 8b d0	 mov	 rdx, rax
  0009a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0009f	e8 00 00 00 00	 call	 ast_for_expr
  000a4	48 89 44 24 30	 mov	 QWORD PTR value$[rsp], rax

; 1778 :     if (!value)

  000a9	48 83 7c 24 30
	00		 cmp	 QWORD PTR value$[rsp], 0
  000af	75 04		 jne	 SHORT $LN2@ast_for_di

; 1779 :         return NULL;

  000b1	33 c0		 xor	 eax, eax
  000b3	eb 62		 jmp	 SHORT $LN4@ast_for_di
$LN2@ast_for_di:

; 1780 : 
; 1781 :     comps = ast_for_comprehension(c, CHILD(n, 3));

  000b5	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000ba	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000be	48 83 c0 78	 add	 rax, 120		; 00000078H
  000c2	48 8b d0	 mov	 rdx, rax
  000c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000ca	e8 00 00 00 00	 call	 ast_for_comprehension
  000cf	48 89 44 24 38	 mov	 QWORD PTR comps$[rsp], rax

; 1782 :     if (!comps)

  000d4	48 83 7c 24 38
	00		 cmp	 QWORD PTR comps$[rsp], 0
  000da	75 04		 jne	 SHORT $LN1@ast_for_di

; 1783 :         return NULL;

  000dc	33 c0		 xor	 eax, eax
  000de	eb 37		 jmp	 SHORT $LN4@ast_for_di
$LN1@ast_for_di:

; 1784 : 
; 1785 :     return DictComp(key, value, comps, LINENO(n), n->n_col_offset, c->c_arena);

  000e0	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  000e5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000e9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ee	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000f3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000f6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000fa	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000ff	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  00103	4c 8b 44 24 38	 mov	 r8, QWORD PTR comps$[rsp]
  00108	48 8b 54 24 30	 mov	 rdx, QWORD PTR value$[rsp]
  0010d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR key$[rsp]
  00112	e8 00 00 00 00	 call	 _Py_DictComp
$LN4@ast_for_di:

; 1786 : }

  00117	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011b	c3		 ret	 0
ast_for_dictcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EG@NNHEEAOD@?$AA?$CI?$AAc?$AAo?$AAm?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAc?$AAo?$AAm?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@ ; `string'
PUBLIC	??_C@_1DO@KHECFIPN@?$AA?$CI?$AAi?$AAf?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAf?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@NKPHIONK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA4?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@MKOGNMH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA2?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@MHPCLOGC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA3?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_comprehension:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_comprehension DD imagerel ast_for_comprehension
	DD	imagerel ast_for_comprehension+1055
	DD	imagerel $unwind$ast_for_comprehension
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_comprehension DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_1EG@NNHEEAOD@?$AA?$CI?$AAc?$AAo?$AAm?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAc?$AAo?$AAm?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@
CONST	SEGMENT
??_C@_1EG@NNHEEAOD@?$AA?$CI?$AAc?$AAo?$AAm?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAc?$AAo?$AAm?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@ DB '('
	DB	00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 's', 00H, ')', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's'
	DB	00H, 'd', 00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, '(', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 's'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@KHECFIPN@?$AA?$CI?$AAi?$AAf?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAf?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@KHECFIPN@?$AA?$CI?$AAi?$AAf?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAf?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB '('
	DB	00H, 'i', 00H, 'f', 00H, 's', 00H, ')', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's', 00H, 'd', 00H, 'l'
	DB	00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H
	DB	'i', 00H, 'f', 00H, 's', 00H, ')', 00H, '-', 00H, '>', 00H, 's'
	DB	00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@NKPHIONK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA4?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@NKPHIONK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA4?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '3'
	DB	00H, '4', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@MKOGNMH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA2?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@MKOGNMH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA2?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '3'
	DB	00H, '2', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@MHPCLOGC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA3?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@MHPCLOGC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA3?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '3'
	DB	00H, '3', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_comprehension
_TEXT	SEGMENT
comps$ = 48
i$ = 56
n_fors$ = 60
first$23066 = 64
comp$23063 = 72
expression$23065 = 80
for_ch$23067 = 88
t$23064 = 96
ifs$23083 = 104
n_ifs$23082 = 112
j$23081 = 116
_asdl_i$23095 = 120
_asdl_i$23100 = 124
c$ = 144
n$ = 152
ast_for_comprehension PROC				; COMDAT

; 1661 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1662 :     int i, n_fors;
; 1663 :     asdl_seq *comps;
; 1664 : 
; 1665 :     n_fors = count_comp_fors(c, n);

  00011	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  00019	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00021	e8 00 00 00 00	 call	 count_comp_fors
  00026	89 44 24 3c	 mov	 DWORD PTR n_fors$[rsp], eax

; 1666 :     if (n_fors == -1)

  0002a	83 7c 24 3c ff	 cmp	 DWORD PTR n_fors$[rsp], -1
  0002f	75 07		 jne	 SHORT $LN19@ast_for_co@2

; 1667 :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	e9 df 03 00 00	 jmp	 $LN20@ast_for_co@2
$LN19@ast_for_co@2:

; 1668 : 
; 1669 :     comps = asdl_seq_new(n_fors, c->c_arena);

  00038	48 63 44 24 3c	 movsxd	 rax, DWORD PTR n_fors$[rsp]
  0003d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00045	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00049	48 8b c8	 mov	 rcx, rax
  0004c	e8 00 00 00 00	 call	 asdl_seq_new
  00051	48 89 44 24 30	 mov	 QWORD PTR comps$[rsp], rax

; 1670 :     if (!comps)

  00056	48 83 7c 24 30
	00		 cmp	 QWORD PTR comps$[rsp], 0
  0005c	75 07		 jne	 SHORT $LN18@ast_for_co@2

; 1671 :         return NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	e9 b2 03 00 00	 jmp	 $LN20@ast_for_co@2
$LN18@ast_for_co@2:

; 1672 : 
; 1673 :     for (i = 0; i < n_fors; i++) {

  00065	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006d	eb 0a		 jmp	 SHORT $LN17@ast_for_co@2
$LN16@ast_for_co@2:
  0006f	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00073	ff c0		 inc	 eax
  00075	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN17@ast_for_co@2:
  00079	8b 44 24 3c	 mov	 eax, DWORD PTR n_fors$[rsp]
  0007d	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00081	0f 8d 8b 03 00
	00		 jge	 $LN15@ast_for_co@2

; 1674 :         comprehension_ty comp;
; 1675 :         asdl_seq *t;
; 1676 :         expr_ty expression, first;
; 1677 :         node *for_ch;
; 1678 : 
; 1679 :         REQ(n, comp_for);

  00087	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0008f	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00092	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  00097	74 1c		 je	 SHORT $LN22@ast_for_co@2
  00099	41 b8 8f 06 00
	00		 mov	 r8d, 1679		; 0000068fH
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MHPCLOGC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA3?$AA?$CJ?$AA?$AA@
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b3	33 c0		 xor	 eax, eax
$LN22@ast_for_co@2:

; 1680 : 
; 1681 :         for_ch = CHILD(n, 1);

  000b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000bd	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000c1	48 83 c0 28	 add	 rax, 40			; 00000028H
  000c5	48 89 44 24 58	 mov	 QWORD PTR for_ch$23067[rsp], rax

; 1682 :         t = ast_for_exprlist(c, for_ch, Store);

  000ca	41 b8 02 00 00
	00		 mov	 r8d, 2
  000d0	48 8b 54 24 58	 mov	 rdx, QWORD PTR for_ch$23067[rsp]
  000d5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000dd	e8 00 00 00 00	 call	 ast_for_exprlist
  000e2	48 89 44 24 60	 mov	 QWORD PTR t$23064[rsp], rax

; 1683 :         if (!t)

  000e7	48 83 7c 24 60
	00		 cmp	 QWORD PTR t$23064[rsp], 0
  000ed	75 07		 jne	 SHORT $LN14@ast_for_co@2

; 1684 :             return NULL;

  000ef	33 c0		 xor	 eax, eax
  000f1	e9 21 03 00 00	 jmp	 $LN20@ast_for_co@2
$LN14@ast_for_co@2:

; 1685 :         expression = ast_for_expr(c, CHILD(n, 3));

  000f6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000fe	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00102	48 83 c0 78	 add	 rax, 120		; 00000078H
  00106	48 8b d0	 mov	 rdx, rax
  00109	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00111	e8 00 00 00 00	 call	 ast_for_expr
  00116	48 89 44 24 50	 mov	 QWORD PTR expression$23065[rsp], rax

; 1686 :         if (!expression)

  0011b	48 83 7c 24 50
	00		 cmp	 QWORD PTR expression$23065[rsp], 0
  00121	75 07		 jne	 SHORT $LN13@ast_for_co@2

; 1687 :             return NULL;

  00123	33 c0		 xor	 eax, eax
  00125	e9 ed 02 00 00	 jmp	 $LN20@ast_for_co@2
$LN13@ast_for_co@2:

; 1688 : 
; 1689 :         /* Check the # of children rather than the length of t, since
; 1690 :            (x for x, in ...) has 1 element in t, but still requires a Tuple. */
; 1691 :         first = (expr_ty)asdl_seq_GET(t, 0);

  0012a	48 8b 44 24 60	 mov	 rax, QWORD PTR t$23064[rsp]
  0012f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00133	48 89 44 24 40	 mov	 QWORD PTR first$23066[rsp], rax

; 1692 :         if (NCH(for_ch) == 1)

  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR for_ch$23067[rsp]
  0013d	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00141	75 25		 jne	 SHORT $LN12@ast_for_co@2

; 1693 :             comp = comprehension(first, expression, NULL, c->c_arena);

  00143	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0014b	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  0014f	45 33 c0	 xor	 r8d, r8d
  00152	48 8b 54 24 50	 mov	 rdx, QWORD PTR expression$23065[rsp]
  00157	48 8b 4c 24 40	 mov	 rcx, QWORD PTR first$23066[rsp]
  0015c	e8 00 00 00 00	 call	 _Py_comprehension
  00161	48 89 44 24 48	 mov	 QWORD PTR comp$23063[rsp], rax

; 1694 :         else

  00166	eb 53		 jmp	 SHORT $LN11@ast_for_co@2
$LN12@ast_for_co@2:

; 1695 :             comp = comprehension(Tuple(t, Store, first->lineno, first->col_offset,
; 1696 :                                      c->c_arena),
; 1697 :                                expression, NULL, c->c_arena);

  00168	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00170	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00174	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00179	48 8b 44 24 40	 mov	 rax, QWORD PTR first$23066[rsp]
  0017e	44 8b 48 34	 mov	 r9d, DWORD PTR [rax+52]
  00182	48 8b 44 24 40	 mov	 rax, QWORD PTR first$23066[rsp]
  00187	44 8b 40 30	 mov	 r8d, DWORD PTR [rax+48]
  0018b	ba 02 00 00 00	 mov	 edx, 2
  00190	48 8b 4c 24 60	 mov	 rcx, QWORD PTR t$23064[rsp]
  00195	e8 00 00 00 00	 call	 _Py_Tuple
  0019a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001a2	4c 8b 49 08	 mov	 r9, QWORD PTR [rcx+8]
  001a6	45 33 c0	 xor	 r8d, r8d
  001a9	48 8b 54 24 50	 mov	 rdx, QWORD PTR expression$23065[rsp]
  001ae	48 8b c8	 mov	 rcx, rax
  001b1	e8 00 00 00 00	 call	 _Py_comprehension
  001b6	48 89 44 24 48	 mov	 QWORD PTR comp$23063[rsp], rax
$LN11@ast_for_co@2:

; 1698 :         if (!comp)

  001bb	48 83 7c 24 48
	00		 cmp	 QWORD PTR comp$23063[rsp], 0
  001c1	75 07		 jne	 SHORT $LN10@ast_for_co@2

; 1699 :             return NULL;

  001c3	33 c0		 xor	 eax, eax
  001c5	e9 4d 02 00 00	 jmp	 $LN20@ast_for_co@2
$LN10@ast_for_co@2:

; 1700 : 
; 1701 :         if (NCH(n) == 5) {

  001ca	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001d2	83 78 18 05	 cmp	 DWORD PTR [rax+24], 5
  001d6	0f 85 e2 01 00
	00		 jne	 $LN9@ast_for_co@2

; 1702 :             int j, n_ifs;
; 1703 :             asdl_seq *ifs;
; 1704 : 
; 1705 :             n = CHILD(n, 4);

  001dc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001e4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001e8	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  001ee	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 1706 :             n_ifs = count_comp_ifs(c, n);

  001f6	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  001fe	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00206	e8 00 00 00 00	 call	 count_comp_ifs
  0020b	89 44 24 70	 mov	 DWORD PTR n_ifs$23082[rsp], eax

; 1707 :             if (n_ifs == -1)

  0020f	83 7c 24 70 ff	 cmp	 DWORD PTR n_ifs$23082[rsp], -1
  00214	75 07		 jne	 SHORT $LN8@ast_for_co@2

; 1708 :                 return NULL;

  00216	33 c0		 xor	 eax, eax
  00218	e9 fa 01 00 00	 jmp	 $LN20@ast_for_co@2
$LN8@ast_for_co@2:

; 1709 : 
; 1710 :             ifs = asdl_seq_new(n_ifs, c->c_arena);

  0021d	48 63 44 24 70	 movsxd	 rax, DWORD PTR n_ifs$23082[rsp]
  00222	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0022a	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0022e	48 8b c8	 mov	 rcx, rax
  00231	e8 00 00 00 00	 call	 asdl_seq_new
  00236	48 89 44 24 68	 mov	 QWORD PTR ifs$23083[rsp], rax

; 1711 :             if (!ifs)

  0023b	48 83 7c 24 68
	00		 cmp	 QWORD PTR ifs$23083[rsp], 0
  00241	75 07		 jne	 SHORT $LN7@ast_for_co@2

; 1712 :                 return NULL;

  00243	33 c0		 xor	 eax, eax
  00245	e9 cd 01 00 00	 jmp	 $LN20@ast_for_co@2
$LN7@ast_for_co@2:

; 1713 : 
; 1714 :             for (j = 0; j < n_ifs; j++) {

  0024a	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR j$23081[rsp], 0
  00252	eb 0a		 jmp	 SHORT $LN6@ast_for_co@2
$LN5@ast_for_co@2:
  00254	8b 44 24 74	 mov	 eax, DWORD PTR j$23081[rsp]
  00258	ff c0		 inc	 eax
  0025a	89 44 24 74	 mov	 DWORD PTR j$23081[rsp], eax
$LN6@ast_for_co@2:
  0025e	8b 44 24 70	 mov	 eax, DWORD PTR n_ifs$23082[rsp]
  00262	39 44 24 74	 cmp	 DWORD PTR j$23081[rsp], eax
  00266	0f 8d 1e 01 00
	00		 jge	 $LN4@ast_for_co@2

; 1715 :                 REQ(n, comp_iter);

  0026c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00274	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00277	3d 4c 01 00 00	 cmp	 eax, 332		; 0000014cH
  0027c	74 1c		 je	 SHORT $LN23@ast_for_co@2
  0027e	41 b8 b3 06 00
	00		 mov	 r8d, 1715		; 000006b3H
  00284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0028b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MKOGNMH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA2?$AA?$CJ?$AA?$AA@
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00298	33 c0		 xor	 eax, eax
$LN23@ast_for_co@2:

; 1716 :                 n = CHILD(n, 0);

  0029a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002a2	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002a6	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 1717 :                 REQ(n, comp_if);

  002ae	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002b6	0f bf 00	 movsx	 eax, WORD PTR [rax]
  002b9	3d 4e 01 00 00	 cmp	 eax, 334		; 0000014eH
  002be	74 1c		 je	 SHORT $LN24@ast_for_co@2
  002c0	41 b8 b5 06 00
	00		 mov	 r8d, 1717		; 000006b5H
  002c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  002cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@NKPHIONK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA4?$AA?$CJ?$AA?$AA@
  002d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002da	33 c0		 xor	 eax, eax
$LN24@ast_for_co@2:

; 1718 : 
; 1719 :                 expression = ast_for_expr(c, CHILD(n, 1));

  002dc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002e4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002e8	48 83 c0 28	 add	 rax, 40			; 00000028H
  002ec	48 8b d0	 mov	 rdx, rax
  002ef	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002f7	e8 00 00 00 00	 call	 ast_for_expr
  002fc	48 89 44 24 50	 mov	 QWORD PTR expression$23065[rsp], rax

; 1720 :                 if (!expression)

  00301	48 83 7c 24 50
	00		 cmp	 QWORD PTR expression$23065[rsp], 0
  00307	75 07		 jne	 SHORT $LN3@ast_for_co@2

; 1721 :                     return NULL;

  00309	33 c0		 xor	 eax, eax
  0030b	e9 07 01 00 00	 jmp	 $LN20@ast_for_co@2
$LN3@ast_for_co@2:

; 1722 :                 asdl_seq_SET(ifs, j, expression);

  00310	8b 44 24 74	 mov	 eax, DWORD PTR j$23081[rsp]
  00314	89 44 24 78	 mov	 DWORD PTR _asdl_i$23095[rsp], eax
  00318	48 83 7c 24 68
	00		 cmp	 QWORD PTR ifs$23083[rsp], 0
  0031e	74 0f		 je	 SHORT $LN25@ast_for_co@2
  00320	48 63 44 24 78	 movsxd	 rax, DWORD PTR _asdl_i$23095[rsp]
  00325	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ifs$23083[rsp]
  0032a	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  0032d	7c 1c		 jl	 SHORT $LN26@ast_for_co@2
$LN25@ast_for_co@2:
  0032f	41 b8 ba 06 00
	00		 mov	 r8d, 1722		; 000006baH
  00335	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0033c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@KHECFIPN@?$AA?$CI?$AAi?$AAf?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAf?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  00343	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00349	33 c0		 xor	 eax, eax
$LN26@ast_for_co@2:
  0034b	48 63 44 24 78	 movsxd	 rax, DWORD PTR _asdl_i$23095[rsp]
  00350	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ifs$23083[rsp]
  00355	48 8b 54 24 50	 mov	 rdx, QWORD PTR expression$23065[rsp]
  0035a	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 1723 :                 if (NCH(n) == 3)

  0035f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00367	83 78 18 03	 cmp	 DWORD PTR [rax+24], 3
  0036b	75 18		 jne	 SHORT $LN2@ast_for_co@2

; 1724 :                     n = CHILD(n, 2);

  0036d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00375	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00379	48 83 c0 50	 add	 rax, 80			; 00000050H
  0037d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR n$[rsp], rax
$LN2@ast_for_co@2:

; 1725 :             }

  00385	e9 ca fe ff ff	 jmp	 $LN5@ast_for_co@2
$LN4@ast_for_co@2:

; 1726 :             /* on exit, must guarantee that n is a comp_for */
; 1727 :             if (TYPE(n) == comp_iter)

  0038a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00392	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00395	3d 4c 01 00 00	 cmp	 eax, 332		; 0000014cH
  0039a	75 14		 jne	 SHORT $LN1@ast_for_co@2

; 1728 :                 n = CHILD(n, 0);

  0039c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003a4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  003a8	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR n$[rsp], rax
$LN1@ast_for_co@2:

; 1729 :             comp->ifs = ifs;

  003b0	48 8b 44 24 48	 mov	 rax, QWORD PTR comp$23063[rsp]
  003b5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ifs$23083[rsp]
  003ba	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
$LN9@ast_for_co@2:

; 1730 :         }
; 1731 :         asdl_seq_SET(comps, i, comp);

  003be	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  003c2	89 44 24 7c	 mov	 DWORD PTR _asdl_i$23100[rsp], eax
  003c6	48 83 7c 24 30
	00		 cmp	 QWORD PTR comps$[rsp], 0
  003cc	74 0f		 je	 SHORT $LN27@ast_for_co@2
  003ce	48 63 44 24 7c	 movsxd	 rax, DWORD PTR _asdl_i$23100[rsp]
  003d3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR comps$[rsp]
  003d8	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  003db	7c 1c		 jl	 SHORT $LN28@ast_for_co@2
$LN27@ast_for_co@2:
  003dd	41 b8 c3 06 00
	00		 mov	 r8d, 1731		; 000006c3H
  003e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  003ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@NNHEEAOD@?$AA?$CI?$AAc?$AAo?$AAm?$AAp?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAc?$AAo?$AAm?$AAp?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@
  003f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003f7	33 c0		 xor	 eax, eax
$LN28@ast_for_co@2:
  003f9	48 63 44 24 7c	 movsxd	 rax, DWORD PTR _asdl_i$23100[rsp]
  003fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR comps$[rsp]
  00403	48 8b 54 24 48	 mov	 rdx, QWORD PTR comp$23063[rsp]
  00408	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 1732 :     }

  0040d	e9 5d fc ff ff	 jmp	 $LN16@ast_for_co@2
$LN15@ast_for_co@2:

; 1733 :     return comps;

  00412	48 8b 44 24 30	 mov	 rax, QWORD PTR comps$[rsp]
$LN20@ast_for_co@2:

; 1734 : }

  00417	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0041e	c3		 ret	 0
ast_for_comprehension ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@PJBBHOMK@logic?5error?5in?5count_comp_fors?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_comp_fors DD imagerel count_comp_fors
	DD	imagerel count_comp_fors+279
	DD	imagerel $unwind$count_comp_fors
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_comp_fors DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BP@PJBBHOMK@logic?5error?5in?5count_comp_fors?$AA@
CONST	SEGMENT
??_C@_0BP@PJBBHOMK@logic?5error?5in?5count_comp_fors?$AA@ DB 'logic error'
	DB	' in count_comp_fors', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT count_comp_fors
_TEXT	SEGMENT
n_fors$ = 32
c$ = 64
n$ = 72
count_comp_fors PROC					; COMDAT

; 1606 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1607 :     int n_fors = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n_fors$[rsp], 0
$count_comp_for$23018:

; 1608 : 
; 1609 :   count_comp_for:
; 1610 :     n_fors++;

  00016	8b 44 24 20	 mov	 eax, DWORD PTR n_fors$[rsp]
  0001a	ff c0		 inc	 eax
  0001c	89 44 24 20	 mov	 DWORD PTR n_fors$[rsp], eax

; 1611 :     REQ(n, comp_for);

  00020	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00025	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00028	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  0002d	74 1c		 je	 SHORT $LN10@count_comp
  0002f	41 b8 4b 06 00
	00		 mov	 r8d, 1611		; 0000064bH
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MHPCLOGC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA3?$AA?$CJ?$AA?$AA@
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00049	33 c0		 xor	 eax, eax
$LN10@count_comp:

; 1612 :     if (NCH(n) == 5)

  0004b	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00050	83 78 18 05	 cmp	 DWORD PTR [rax+24], 5
  00054	75 16		 jne	 SHORT $LN7@count_comp

; 1613 :         n = CHILD(n, 4);

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0005b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0005f	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00065	48 89 44 24 48	 mov	 QWORD PTR n$[rsp], rax

; 1614 :     else

  0006a	eb 09		 jmp	 SHORT $LN6@count_comp
$LN7@count_comp:

; 1615 :         return n_fors;

  0006c	8b 44 24 20	 mov	 eax, DWORD PTR n_fors$[rsp]
  00070	e9 9d 00 00 00	 jmp	 $LN8@count_comp
$LN6@count_comp:
$count_comp_iter$23023:

; 1616 :   count_comp_iter:
; 1617 :     REQ(n, comp_iter);

  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0007a	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0007d	3d 4c 01 00 00	 cmp	 eax, 332		; 0000014cH
  00082	74 1c		 je	 SHORT $LN11@count_comp
  00084	41 b8 51 06 00
	00		 mov	 r8d, 1617		; 00000651H
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MKOGNMH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA2?$AA?$CJ?$AA?$AA@
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009e	33 c0		 xor	 eax, eax
$LN11@count_comp:

; 1618 :     n = CHILD(n, 0);

  000a0	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000a5	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000a9	48 89 44 24 48	 mov	 QWORD PTR n$[rsp], rax

; 1619 :     if (TYPE(n) == comp_for)

  000ae	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000b3	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000b6	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  000bb	75 07		 jne	 SHORT $LN5@count_comp

; 1620 :         goto count_comp_for;

  000bd	e9 54 ff ff ff	 jmp	 $count_comp_for$23018
  000c2	eb 36		 jmp	 SHORT $LN4@count_comp
$LN5@count_comp:

; 1621 :     else if (TYPE(n) == comp_if) {

  000c4	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000c9	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000cc	3d 4e 01 00 00	 cmp	 eax, 334		; 0000014eH
  000d1	75 27		 jne	 SHORT $LN3@count_comp

; 1622 :         if (NCH(n) == 3) {

  000d3	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000d8	83 78 18 03	 cmp	 DWORD PTR [rax+24], 3
  000dc	75 16		 jne	 SHORT $LN2@count_comp

; 1623 :             n = CHILD(n, 2);

  000de	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000e3	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000e7	48 83 c0 50	 add	 rax, 80			; 00000050H
  000eb	48 89 44 24 48	 mov	 QWORD PTR n$[rsp], rax

; 1624 :             goto count_comp_iter;

  000f0	eb 83		 jmp	 SHORT $count_comp_iter$23023

; 1625 :         }
; 1626 :         else

  000f2	eb 06		 jmp	 SHORT $LN1@count_comp
$LN2@count_comp:

; 1627 :             return n_fors;

  000f4	8b 44 24 20	 mov	 eax, DWORD PTR n_fors$[rsp]
  000f8	eb 18		 jmp	 SHORT $LN8@count_comp
$LN1@count_comp:
$LN3@count_comp:
$LN4@count_comp:

; 1628 :     }
; 1629 : 
; 1630 :     /* Should never be reached */
; 1631 :     PyErr_SetString(PyExc_SystemError,
; 1632 :                     "logic error in count_comp_fors");

  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@PJBBHOMK@logic?5error?5in?5count_comp_fors?$AA@
  00101	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00108	e8 00 00 00 00	 call	 PyErr_SetString

; 1633 :     return -1;

  0010d	b8 ff ff ff ff	 mov	 eax, -1
$LN8@count_comp:

; 1634 : }

  00112	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00116	c3		 ret	 0
count_comp_fors ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_comp_ifs DD imagerel count_comp_ifs
	DD	imagerel count_comp_ifs+213
	DD	imagerel $unwind$count_comp_ifs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_comp_ifs DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT count_comp_ifs
_TEXT	SEGMENT
n_ifs$ = 32
c$ = 64
n$ = 72
count_comp_ifs PROC					; COMDAT

; 1643 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1644 :     int n_ifs = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n_ifs$[rsp], 0
$LN4@count_comp@2:

; 1645 : 
; 1646 :     while (1) {

  00016	33 c0		 xor	 eax, eax
  00018	83 f8 01	 cmp	 eax, 1
  0001b	0f 84 af 00 00
	00		 je	 $LN3@count_comp@2

; 1647 :         REQ(n, comp_iter);

  00021	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00026	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00029	3d 4c 01 00 00	 cmp	 eax, 332		; 0000014cH
  0002e	74 1c		 je	 SHORT $LN7@count_comp@2
  00030	41 b8 6f 06 00
	00		 mov	 r8d, 1647		; 0000066fH
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MKOGNMH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA2?$AA?$CJ?$AA?$AA@
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0004a	33 c0		 xor	 eax, eax
$LN7@count_comp@2:

; 1648 :         if (TYPE(CHILD(n, 0)) == comp_for)

  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00051	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00055	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00058	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  0005d	75 06		 jne	 SHORT $LN2@count_comp@2

; 1649 :             return n_ifs;

  0005f	8b 44 24 20	 mov	 eax, DWORD PTR n_ifs$[rsp]
  00063	eb 6b		 jmp	 SHORT $LN5@count_comp@2
$LN2@count_comp@2:

; 1650 :         n = CHILD(n, 0);

  00065	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0006a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0006e	48 89 44 24 48	 mov	 QWORD PTR n$[rsp], rax

; 1651 :         REQ(n, comp_if);

  00073	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00078	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0007b	3d 4e 01 00 00	 cmp	 eax, 334		; 0000014eH
  00080	74 1c		 je	 SHORT $LN8@count_comp@2
  00082	41 b8 73 06 00
	00		 mov	 r8d, 1651		; 00000673H
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@NKPHIONK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA4?$AA?$CJ?$AA?$AA@
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009c	33 c0		 xor	 eax, eax
$LN8@count_comp@2:

; 1652 :         n_ifs++;

  0009e	8b 44 24 20	 mov	 eax, DWORD PTR n_ifs$[rsp]
  000a2	ff c0		 inc	 eax
  000a4	89 44 24 20	 mov	 DWORD PTR n_ifs$[rsp], eax

; 1653 :         if (NCH(n) == 2)

  000a8	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000ad	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  000b1	75 06		 jne	 SHORT $LN1@count_comp@2

; 1654 :             return n_ifs;

  000b3	8b 44 24 20	 mov	 eax, DWORD PTR n_ifs$[rsp]
  000b7	eb 17		 jmp	 SHORT $LN5@count_comp@2
$LN1@count_comp@2:

; 1655 :         n = CHILD(n, 2);

  000b9	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000be	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000c2	48 83 c0 50	 add	 rax, 80			; 00000050H
  000c6	48 89 44 24 48	 mov	 QWORD PTR n$[rsp], rax

; 1656 :     }

  000cb	e9 46 ff ff ff	 jmp	 $LN4@count_comp@2
$LN3@count_comp@2:
$LN5@count_comp@2:

; 1657 : }

  000d0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d4	c3		 ret	 0
count_comp_ifs ENDP
_TEXT	ENDS
PUBLIC	??_C@_1GI@JPJAIMIL@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_genexp DD imagerel ast_for_genexp
	DD	imagerel ast_for_genexp+95
	DD	imagerel $unwind$ast_for_genexp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_genexp DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_1GI@JPJAIMIL@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY@
CONST	SEGMENT
??_C@_1GI@JPJAIMIL@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, 't', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, ')', 00H, ' '
	DB	00H, '|', 00H, '|', 00H, ' ', 00H, 'T', 00H, 'Y', 00H, 'P', 00H
	DB	'E', 00H, '(', 00H, 'n', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '(', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_genexp
_TEXT	SEGMENT
c$ = 48
n$ = 56
ast_for_genexp PROC					; COMDAT

; 1790 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1791 :     assert(TYPE(n) == (testlist_comp) || TYPE(n) == (argument));

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 41 01 00 00	 cmp	 eax, 321		; 00000141H
  0001b	74 2b		 je	 SHORT $LN3@ast_for_ge
  0001d	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  00022	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00025	3d 4b 01 00 00	 cmp	 eax, 331		; 0000014bH
  0002a	74 1c		 je	 SHORT $LN3@ast_for_ge
  0002c	41 b8 ff 06 00
	00		 mov	 r8d, 1791		; 000006ffH
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GI@JPJAIMIL@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAT?$AAY@
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00046	33 c0		 xor	 eax, eax
$LN3@ast_for_ge:

; 1792 :     return ast_for_itercomp(c, n, COMP_GENEXP);

  00048	45 33 c0	 xor	 r8d, r8d
  0004b	48 8b 54 24 38	 mov	 rdx, QWORD PTR n$[rsp]
  00050	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$[rsp]
  00055	e8 00 00 00 00	 call	 ast_for_itercomp

; 1793 : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
ast_for_genexp ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BG@FHHECFHH@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?$AA@ ; `string'
EXTRN	_Py_SetComp:PROC
EXTRN	_Py_ListComp:PROC
EXTRN	_Py_GeneratorExp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_itercomp DD imagerel ast_for_itercomp
	DD	imagerel ast_for_itercomp+324
	DD	imagerel $unwind$ast_for_itercomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_itercomp DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_1BG@FHHECFHH@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@FHHECFHH@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?$AA@ DB 'N'
	DB	00H, 'C', 00H, 'H', 00H, '(', 00H, 'n', 00H, ')', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '1', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_itercomp
_TEXT	SEGMENT
comps$ = 48
elt$ = 56
c$ = 80
n$ = 88
type$ = 96
ast_for_itercomp PROC					; COMDAT

; 1738 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1739 :     /* testlist_comp: test ( comp_for | (',' test)* [','] )
; 1740 :        argument: [test '='] test [comp_for]       # Really [keyword '='] test */
; 1741 :     expr_ty elt;
; 1742 :     asdl_seq *comps;
; 1743 : 
; 1744 :     assert(NCH(n) > 1);

  00013	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00018	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  0001c	7f 1c		 jg	 SHORT $LN11@ast_for_it
  0001e	41 b8 d0 06 00
	00		 mov	 r8d, 1744		; 000006d0H
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@FHHECFHH@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DO?$AA?5?$AA1?$AA?$AA@
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00038	33 c0		 xor	 eax, eax
$LN11@ast_for_it:

; 1745 : 
; 1746 :     elt = ast_for_expr(c, CHILD(n, 0));

  0003a	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0003f	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00043	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00048	e8 00 00 00 00	 call	 ast_for_expr
  0004d	48 89 44 24 38	 mov	 QWORD PTR elt$[rsp], rax

; 1747 :     if (!elt)

  00052	48 83 7c 24 38
	00		 cmp	 QWORD PTR elt$[rsp], 0
  00058	75 07		 jne	 SHORT $LN8@ast_for_it

; 1748 :         return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 de 00 00 00	 jmp	 $LN9@ast_for_it
$LN8@ast_for_it:

; 1749 : 
; 1750 :     comps = ast_for_comprehension(c, CHILD(n, 1));

  00061	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00066	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0006a	48 83 c0 28	 add	 rax, 40			; 00000028H
  0006e	48 8b d0	 mov	 rdx, rax
  00071	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00076	e8 00 00 00 00	 call	 ast_for_comprehension
  0007b	48 89 44 24 30	 mov	 QWORD PTR comps$[rsp], rax

; 1751 :     if (!comps)

  00080	48 83 7c 24 30
	00		 cmp	 QWORD PTR comps$[rsp], 0
  00086	75 07		 jne	 SHORT $LN7@ast_for_it

; 1752 :         return NULL;

  00088	33 c0		 xor	 eax, eax
  0008a	e9 b0 00 00 00	 jmp	 $LN9@ast_for_it
$LN7@ast_for_it:

; 1753 : 
; 1754 :     if (type == COMP_GENEXP)

  0008f	83 7c 24 60 00	 cmp	 DWORD PTR type$[rsp], 0
  00094	75 33		 jne	 SHORT $LN6@ast_for_it

; 1755 :         return GeneratorExp(elt, comps, LINENO(n), n->n_col_offset, c->c_arena);

  00096	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  0009b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0009f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a4	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000a9	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  000ad	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000b2	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  000b6	48 8b 54 24 30	 mov	 rdx, QWORD PTR comps$[rsp]
  000bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR elt$[rsp]
  000c0	e8 00 00 00 00	 call	 _Py_GeneratorExp
  000c5	eb 78		 jmp	 SHORT $LN9@ast_for_it
  000c7	eb 76		 jmp	 SHORT $LN5@ast_for_it
$LN6@ast_for_it:

; 1756 :     else if (type == COMP_LISTCOMP)

  000c9	83 7c 24 60 01	 cmp	 DWORD PTR type$[rsp], 1
  000ce	75 33		 jne	 SHORT $LN4@ast_for_it

; 1757 :         return ListComp(elt, comps, LINENO(n), n->n_col_offset, c->c_arena);

  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  000d5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000de	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000e3	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  000e7	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  000ec	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  000f0	48 8b 54 24 30	 mov	 rdx, QWORD PTR comps$[rsp]
  000f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR elt$[rsp]
  000fa	e8 00 00 00 00	 call	 _Py_ListComp
  000ff	eb 3e		 jmp	 SHORT $LN9@ast_for_it
  00101	eb 3c		 jmp	 SHORT $LN3@ast_for_it
$LN4@ast_for_it:

; 1758 :     else if (type == COMP_SETCOMP)

  00103	83 7c 24 60 02	 cmp	 DWORD PTR type$[rsp], 2
  00108	75 33		 jne	 SHORT $LN2@ast_for_it

; 1759 :         return SetComp(elt, comps, LINENO(n), n->n_col_offset, c->c_arena);

  0010a	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  0010f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00113	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00118	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0011d	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  00121	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00126	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  0012a	48 8b 54 24 30	 mov	 rdx, QWORD PTR comps$[rsp]
  0012f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR elt$[rsp]
  00134	e8 00 00 00 00	 call	 _Py_SetComp
  00139	eb 04		 jmp	 SHORT $LN9@ast_for_it

; 1760 :     else

  0013b	eb 02		 jmp	 SHORT $LN1@ast_for_it
$LN2@ast_for_it:

; 1761 :         /* Should never happen */
; 1762 :         return NULL;

  0013d	33 c0		 xor	 eax, eax
$LN1@ast_for_it:
$LN3@ast_for_it:
$LN5@ast_for_it:
$LN9@ast_for_it:

; 1763 : }

  0013f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00143	c3		 ret	 0
ast_for_itercomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DG@MJKIEFLO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_listcomp DD imagerel ast_for_listcomp
	DD	imagerel ast_for_listcomp+83
	DD	imagerel $unwind$ast_for_listcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_listcomp DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_1DG@MJKIEFLO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@MJKIEFLO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, 't', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, 'l', 00H, 'i', 00H, 's', 00H, 't', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, ')', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_listcomp
_TEXT	SEGMENT
c$ = 48
n$ = 56
ast_for_listcomp PROC					; COMDAT

; 1797 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1798 :     assert(TYPE(n) == (testlist_comp));

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 41 01 00 00	 cmp	 eax, 321		; 00000141H
  0001b	74 1c		 je	 SHORT $LN3@ast_for_li
  0001d	41 b8 06 07 00
	00		 mov	 r8d, 1798		; 00000706H
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MJKIEFLO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAt?$AAe?$AAs?$AAt?$AAl?$AAi?$AAs?$AAt?$AA_?$AAc?$AAo?$AAm?$AAp?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN3@ast_for_li:

; 1799 :     return ast_for_itercomp(c, n, COMP_LISTCOMP);

  00039	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003f	48 8b 54 24 38	 mov	 rdx, QWORD PTR n$[rsp]
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$[rsp]
  00049	e8 00 00 00 00	 call	 ast_for_itercomp

; 1800 : }

  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	c3		 ret	 0
ast_for_listcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DI@OOFINBJP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAd?$AAi?$AAc?$AAt?$AAo?$AAr?$AAs?$AAe?$AAt?$AAm?$AAa?$AAk?$AAe?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_setcomp DD imagerel ast_for_setcomp
	DD	imagerel ast_for_setcomp+83
	DD	imagerel $unwind$ast_for_setcomp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_setcomp DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_1DI@OOFINBJP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAd?$AAi?$AAc?$AAt?$AAo?$AAr?$AAs?$AAe?$AAt?$AAm?$AAa?$AAk?$AAe?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@OOFINBJP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAd?$AAi?$AAc?$AAt?$AAo?$AAr?$AAs?$AAe?$AAt?$AAm?$AAa?$AAk?$AAe?$AAr?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, 'd', 00H, 'i'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 's', 00H, 'e', 00H
	DB	't', 00H, 'm', 00H, 'a', 00H, 'k', 00H, 'e', 00H, 'r', 00H, ')'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_setcomp
_TEXT	SEGMENT
c$ = 48
n$ = 56
ast_for_setcomp PROC					; COMDAT

; 1804 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1805 :     assert(TYPE(n) == (dictorsetmaker));

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 48 01 00 00	 cmp	 eax, 328		; 00000148H
  0001b	74 1c		 je	 SHORT $LN3@ast_for_se
  0001d	41 b8 0d 07 00
	00		 mov	 r8d, 1805		; 0000070dH
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@OOFINBJP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAd?$AAi?$AAc?$AAt?$AAo?$AAr?$AAs?$AAe?$AAt?$AAm?$AAa?$AAk?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN3@ast_for_se:

; 1806 :     return ast_for_itercomp(c, n, COMP_SETCOMP);

  00039	41 b8 02 00 00
	00		 mov	 r8d, 2
  0003f	48 8b 54 24 38	 mov	 rdx, QWORD PTR n$[rsp]
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$[rsp]
  00049	e8 00 00 00 00	 call	 ast_for_itercomp

; 1807 : }

  0004e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00052	c3		 ret	 0
ast_for_setcomp ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FM@IFCBOHP@?$AAs?$AAl?$AAc?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAn?$AAd?$AAe?$AAx?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAl?$AAc?$AA?9?$AA?$DO@ ; `string'
PUBLIC	??_C@_1EK@BBIDLHNN@?$AA?$CI?$AAs?$AAl?$AAi?$AAc?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAl?$AAi?$AAc?$AAe?$AAs?$AA?$CJ?$AA?9?$AA?$DO@ ; `string'
PUBLIC	??_C@_1EC@KNCBFPPD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA2?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA1?$AA0?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1EA@OCDENKDD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA9?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@MAAEGNFJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA2?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_Index:PROC
EXTRN	_Py_ExtSlice:PROC
EXTRN	_Py_Subscript:PROC
EXTRN	_Py_Attribute:PROC
EXTRN	_Py_Call:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_trailer DD imagerel ast_for_trailer
	DD	imagerel ast_for_trailer+1515
	DD	imagerel $unwind$ast_for_trailer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_trailer DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT ??_C@_1FM@IFCBOHP@?$AAs?$AAl?$AAc?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAn?$AAd?$AAe?$AAx?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAl?$AAc?$AA?9?$AA?$DO@
CONST	SEGMENT
??_C@_1FM@IFCBOHP@?$AAs?$AAl?$AAc?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAn?$AAd?$AAe?$AAx?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAl?$AAc?$AA?9?$AA?$DO@ DB 's'
	DB	00H, 'l', 00H, 'c', 00H, '-', 00H, '>', 00H, 'k', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'I'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '_', 00H, 'k', 00H
	DB	'i', 00H, 'n', 00H, 'd', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 's', 00H, 'l', 00H, 'c', 00H, '-', 00H, '>', 00H, 'v', 00H
	DB	'.', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, '.'
	DB	00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@BBIDLHNN@?$AA?$CI?$AAs?$AAl?$AAi?$AAc?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAl?$AAi?$AAc?$AAe?$AAs?$AA?$CJ?$AA?9?$AA?$DO@
CONST	SEGMENT
??_C@_1EK@BBIDLHNN@?$AA?$CI?$AAs?$AAl?$AAi?$AAc?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAl?$AAi?$AAc?$AAe?$AAs?$AA?$CJ?$AA?9?$AA?$DO@ DB '('
	DB	00H, 's', 00H, 'l', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H
	DB	')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a'
	DB	00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, '(', 00H, 's', 00H, 'l', 00H, 'i', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, ')', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@KNCBFPPD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA2?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA1?$AA0?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@KNCBFPPD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA2?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA1?$AA0?$AA?$CJ@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, '(', 00H, '&', 00H
	DB	'(', 00H, 'n', 00H, ')', 00H, '-', 00H, '>', 00H, 'n', 00H, '_'
	DB	00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '[', 00H
	DB	'2', 00H, ']', 00H, ')', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '(', 00H, '1', 00H, '0', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@OCDENKDD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA9?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@OCDENKDD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA9?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, '(', 00H, '&', 00H
	DB	'(', 00H, 'n', 00H, ')', 00H, '-', 00H, '>', 00H, 'n', 00H, '_'
	DB	00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '[', 00H
	DB	'0', 00H, ']', 00H, ')', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '(', 00H, '9', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@MAAEGNFJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA2?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@MAAEGNFJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA2?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '2'
	DB	00H, '2', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_trailer
_TEXT	SEGMENT
attr_id$23376 = 64
slc$23385 = 72
slc$23390 = 80
slices$23393 = 88
simple$23392 = 96
elts$23394 = 104
e$23391 = 112
j$23389 = 120
_asdl_i$23403 = 124
_asdl_i$23417 = 128
tv235 = 136
tv241 = 144
c$ = 176
n$ = 184
left_expr$ = 192
ast_for_trailer PROC					; COMDAT

; 2086 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2087 :     /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
; 2088 :        subscriptlist: subscript (',' subscript)* [',']
; 2089 :        subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
; 2090 :      */
; 2091 :     REQ(n, trailer);

  00016	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0001e	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00021	3d 42 01 00 00	 cmp	 eax, 322		; 00000142H
  00026	74 1c		 je	 SHORT $LN25@ast_for_tr
  00028	41 b8 2b 08 00
	00		 mov	 r8d, 2091		; 0000082bH
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MAAEGNFJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA2?$AA?$CJ?$AA?$AA@
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00042	33 c0		 xor	 eax, eax
$LN25@ast_for_tr:

; 2092 :     if (TYPE(CHILD(n, 0)) == LPAR) {

  00044	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0004c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00050	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00053	83 f8 07	 cmp	 eax, 7
  00056	0f 85 94 00 00
	00		 jne	 $LN22@ast_for_tr

; 2093 :         if (NCH(n) == 2)

  0005c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00064	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  00068	75 54		 jne	 SHORT $LN21@ast_for_tr

; 2094 :             return Call(left_expr, NULL, NULL, NULL, NULL, LINENO(n),
; 2095 :                         n->n_col_offset, c->c_arena);

  0006a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00072	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00076	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0007b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00083	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00086	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0008a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00092	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00095	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00099	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000a2	45 33 c9	 xor	 r9d, r9d
  000a5	45 33 c0	 xor	 r8d, r8d
  000a8	33 d2		 xor	 edx, edx
  000aa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR left_expr$[rsp]
  000b2	e8 00 00 00 00	 call	 _Py_Call
  000b7	e9 27 05 00 00	 jmp	 $LN23@ast_for_tr

; 2096 :         else

  000bc	eb 2d		 jmp	 SHORT $LN20@ast_for_tr
$LN21@ast_for_tr:

; 2097 :             return ast_for_call(c, CHILD(n, 1), left_expr);

  000be	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000c6	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000ca	48 83 c0 28	 add	 rax, 40			; 00000028H
  000ce	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR left_expr$[rsp]
  000d6	48 8b d0	 mov	 rdx, rax
  000d9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000e1	e8 00 00 00 00	 call	 ast_for_call
  000e6	e9 f8 04 00 00	 jmp	 $LN23@ast_for_tr
$LN20@ast_for_tr:

; 2098 :     }
; 2099 :     else if (TYPE(CHILD(n, 0)) == DOT ) {

  000eb	e9 f3 04 00 00	 jmp	 $LN19@ast_for_tr
$LN22@ast_for_tr:
  000f0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000f8	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000fc	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000ff	83 f8 17	 cmp	 eax, 23
  00102	75 7f		 jne	 SHORT $LN18@ast_for_tr

; 2100 :         PyObject *attr_id = NEW_IDENTIFIER(CHILD(n, 1));

  00104	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0010c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00110	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00118	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0011c	e8 00 00 00 00	 call	 new_identifier
  00121	48 89 44 24 40	 mov	 QWORD PTR attr_id$23376[rsp], rax

; 2101 :         if (!attr_id)

  00126	48 83 7c 24 40
	00		 cmp	 QWORD PTR attr_id$23376[rsp], 0
  0012c	75 07		 jne	 SHORT $LN17@ast_for_tr

; 2102 :             return NULL;

  0012e	33 c0		 xor	 eax, eax
  00130	e9 ae 04 00 00	 jmp	 $LN23@ast_for_tr
$LN17@ast_for_tr:

; 2103 :         return Attribute(left_expr, attr_id, Load,
; 2104 :                          LINENO(n), n->n_col_offset, c->c_arena);

  00135	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0013d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00141	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00146	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0014e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00151	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00155	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0015d	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  00161	41 b8 01 00 00
	00		 mov	 r8d, 1
  00167	48 8b 54 24 40	 mov	 rdx, QWORD PTR attr_id$23376[rsp]
  0016c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR left_expr$[rsp]
  00174	e8 00 00 00 00	 call	 _Py_Attribute
  00179	e9 65 04 00 00	 jmp	 $LN23@ast_for_tr

; 2105 :     }
; 2106 :     else {

  0017e	e9 60 04 00 00	 jmp	 $LN16@ast_for_tr
$LN18@ast_for_tr:

; 2107 :         REQ(CHILD(n, 0), LSQB);

  00183	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0018b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0018f	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00192	83 f8 09	 cmp	 eax, 9
  00195	74 1c		 je	 SHORT $LN26@ast_for_tr
  00197	41 b8 3b 08 00
	00		 mov	 r8d, 2107		; 0000083bH
  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@OCDENKDD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA9?$AA?$CJ?$AA?$AA@
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b1	33 c0		 xor	 eax, eax
$LN26@ast_for_tr:

; 2108 :         REQ(CHILD(n, 2), RSQB);

  001b3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001bb	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001bf	0f bf 40 50	 movsx	 eax, WORD PTR [rax+80]
  001c3	83 f8 0a	 cmp	 eax, 10
  001c6	74 1c		 je	 SHORT $LN27@ast_for_tr
  001c8	41 b8 3c 08 00
	00		 mov	 r8d, 2108		; 0000083cH
  001ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  001d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@KNCBFPPD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA2?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA1?$AA0?$AA?$CJ@
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001e2	33 c0		 xor	 eax, eax
$LN27@ast_for_tr:

; 2109 :         n = CHILD(n, 1);

  001e4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001ec	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001f0	48 83 c0 28	 add	 rax, 40			; 00000028H
  001f4	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2110 :         if (NCH(n) == 1) {

  001fc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00204	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00208	75 7b		 jne	 SHORT $LN15@ast_for_tr

; 2111 :             slice_ty slc = ast_for_slice(c, CHILD(n, 0));

  0020a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00212	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00216	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0021e	e8 00 00 00 00	 call	 ast_for_slice
  00223	48 89 44 24 48	 mov	 QWORD PTR slc$23385[rsp], rax

; 2112 :             if (!slc)

  00228	48 83 7c 24 48
	00		 cmp	 QWORD PTR slc$23385[rsp], 0
  0022e	75 07		 jne	 SHORT $LN14@ast_for_tr

; 2113 :                 return NULL;

  00230	33 c0		 xor	 eax, eax
  00232	e9 ac 03 00 00	 jmp	 $LN23@ast_for_tr
$LN14@ast_for_tr:

; 2114 :             return Subscript(left_expr, slc, Load, LINENO(n), n->n_col_offset,
; 2115 :                              c->c_arena);

  00237	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0023f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00243	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00248	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00250	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00253	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00257	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0025f	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  00263	41 b8 01 00 00
	00		 mov	 r8d, 1
  00269	48 8b 54 24 48	 mov	 rdx, QWORD PTR slc$23385[rsp]
  0026e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR left_expr$[rsp]
  00276	e8 00 00 00 00	 call	 _Py_Subscript
  0027b	e9 63 03 00 00	 jmp	 $LN23@ast_for_tr

; 2116 :         }
; 2117 :         else {

  00280	e9 5e 03 00 00	 jmp	 $LN13@ast_for_tr
$LN15@ast_for_tr:

; 2118 :             /* The grammar is ambiguous here. The ambiguity is resolved
; 2119 :                by treating the sequence as a tuple literal if there are
; 2120 :                no slice features.
; 2121 :             */
; 2122 :             int j;
; 2123 :             slice_ty slc;
; 2124 :             expr_ty e;
; 2125 :             int simple = 1;

  00285	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR simple$23392[rsp], 1

; 2126 :             asdl_seq *slices, *elts;
; 2127 :             slices = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);

  0028d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00295	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00298	ff c0		 inc	 eax
  0029a	99		 cdq
  0029b	2b c2		 sub	 eax, edx
  0029d	d1 f8		 sar	 eax, 1
  0029f	48 98		 cdqe
  002a1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002a9	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  002ad	48 8b c8	 mov	 rcx, rax
  002b0	e8 00 00 00 00	 call	 asdl_seq_new
  002b5	48 89 44 24 58	 mov	 QWORD PTR slices$23393[rsp], rax

; 2128 :             if (!slices)

  002ba	48 83 7c 24 58
	00		 cmp	 QWORD PTR slices$23393[rsp], 0
  002c0	75 07		 jne	 SHORT $LN12@ast_for_tr

; 2129 :                 return NULL;

  002c2	33 c0		 xor	 eax, eax
  002c4	e9 1a 03 00 00	 jmp	 $LN23@ast_for_tr
$LN12@ast_for_tr:

; 2130 :             for (j = 0; j < NCH(n); j += 2) {

  002c9	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR j$23389[rsp], 0
  002d1	eb 0b		 jmp	 SHORT $LN11@ast_for_tr
$LN10@ast_for_tr:
  002d3	8b 44 24 78	 mov	 eax, DWORD PTR j$23389[rsp]
  002d7	83 c0 02	 add	 eax, 2
  002da	89 44 24 78	 mov	 DWORD PTR j$23389[rsp], eax
$LN11@ast_for_tr:
  002de	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002e6	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  002e9	39 44 24 78	 cmp	 DWORD PTR j$23389[rsp], eax
  002ed	0f 8d a4 00 00
	00		 jge	 $LN9@ast_for_tr

; 2131 :                 slc = ast_for_slice(c, CHILD(n, j));

  002f3	48 63 44 24 78	 movsxd	 rax, DWORD PTR j$23389[rsp]
  002f8	48 6b c0 28	 imul	 rax, 40			; 00000028H
  002fc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00304	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00308	48 8b d0	 mov	 rdx, rax
  0030b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00313	e8 00 00 00 00	 call	 ast_for_slice
  00318	48 89 44 24 50	 mov	 QWORD PTR slc$23390[rsp], rax

; 2132 :                 if (!slc)

  0031d	48 83 7c 24 50
	00		 cmp	 QWORD PTR slc$23390[rsp], 0
  00323	75 07		 jne	 SHORT $LN8@ast_for_tr

; 2133 :                     return NULL;

  00325	33 c0		 xor	 eax, eax
  00327	e9 b7 02 00 00	 jmp	 $LN23@ast_for_tr
$LN8@ast_for_tr:

; 2134 :                 if (slc->kind != Index_kind)

  0032c	48 8b 44 24 50	 mov	 rax, QWORD PTR slc$23390[rsp]
  00331	83 38 03	 cmp	 DWORD PTR [rax], 3
  00334	74 08		 je	 SHORT $LN7@ast_for_tr

; 2135 :                     simple = 0;

  00336	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR simple$23392[rsp], 0
$LN7@ast_for_tr:

; 2136 :                 asdl_seq_SET(slices, j / 2, slc);

  0033e	8b 44 24 78	 mov	 eax, DWORD PTR j$23389[rsp]
  00342	99		 cdq
  00343	2b c2		 sub	 eax, edx
  00345	d1 f8		 sar	 eax, 1
  00347	89 44 24 7c	 mov	 DWORD PTR _asdl_i$23403[rsp], eax
  0034b	48 83 7c 24 58
	00		 cmp	 QWORD PTR slices$23393[rsp], 0
  00351	74 0f		 je	 SHORT $LN28@ast_for_tr
  00353	48 63 44 24 7c	 movsxd	 rax, DWORD PTR _asdl_i$23403[rsp]
  00358	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slices$23393[rsp]
  0035d	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00360	7c 1c		 jl	 SHORT $LN29@ast_for_tr
$LN28@ast_for_tr:
  00362	41 b8 58 08 00
	00		 mov	 r8d, 2136		; 00000858H
  00368	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EK@BBIDLHNN@?$AA?$CI?$AAs?$AAl?$AAi?$AAc?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAl?$AAi?$AAc?$AAe?$AAs?$AA?$CJ?$AA?9?$AA?$DO@
  00376	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0037c	33 c0		 xor	 eax, eax
$LN29@ast_for_tr:
  0037e	48 63 44 24 7c	 movsxd	 rax, DWORD PTR _asdl_i$23403[rsp]
  00383	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slices$23393[rsp]
  00388	48 8b 54 24 50	 mov	 rdx, QWORD PTR slc$23390[rsp]
  0038d	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 2137 :             }

  00392	e9 3c ff ff ff	 jmp	 $LN10@ast_for_tr
$LN9@ast_for_tr:

; 2138 :             if (!simple) {

  00397	83 7c 24 60 00	 cmp	 DWORD PTR simple$23392[rsp], 0
  0039c	75 5d		 jne	 SHORT $LN6@ast_for_tr

; 2139 :                 return Subscript(left_expr, ExtSlice(slices, c->c_arena),
; 2140 :                                  Load, LINENO(n), n->n_col_offset, c->c_arena);

  0039e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  003a6	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  003aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slices$23393[rsp]
  003af	e8 00 00 00 00	 call	 _Py_ExtSlice
  003b4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003bc	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  003c0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003c5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  003cd	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  003d0	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  003d4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  003dc	44 8b 49 10	 mov	 r9d, DWORD PTR [rcx+16]
  003e0	41 b8 01 00 00
	00		 mov	 r8d, 1
  003e6	48 8b d0	 mov	 rdx, rax
  003e9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR left_expr$[rsp]
  003f1	e8 00 00 00 00	 call	 _Py_Subscript
  003f6	e9 e8 01 00 00	 jmp	 $LN23@ast_for_tr
$LN6@ast_for_tr:

; 2141 :             }
; 2142 :             /* extract Index values and put them in a Tuple */
; 2143 :             elts = asdl_seq_new(asdl_seq_LEN(slices), c->c_arena);

  003fb	48 83 7c 24 58
	00		 cmp	 QWORD PTR slices$23393[rsp], 0
  00401	75 0e		 jne	 SHORT $LN30@ast_for_tr
  00403	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv235[rsp], 0
  0040f	eb 10		 jmp	 SHORT $LN31@ast_for_tr
$LN30@ast_for_tr:
  00411	48 8b 44 24 58	 mov	 rax, QWORD PTR slices$23393[rsp]
  00416	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00419	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv235[rsp], rax
$LN31@ast_for_tr:
  00421	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00429	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0042d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv235[rsp]
  00435	e8 00 00 00 00	 call	 asdl_seq_new
  0043a	48 89 44 24 68	 mov	 QWORD PTR elts$23394[rsp], rax

; 2144 :             if (!elts)

  0043f	48 83 7c 24 68
	00		 cmp	 QWORD PTR elts$23394[rsp], 0
  00445	75 07		 jne	 SHORT $LN5@ast_for_tr

; 2145 :                 return NULL;

  00447	33 c0		 xor	 eax, eax
  00449	e9 95 01 00 00	 jmp	 $LN23@ast_for_tr
$LN5@ast_for_tr:

; 2146 :             for (j = 0; j < asdl_seq_LEN(slices); ++j) {

  0044e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR j$23389[rsp], 0
  00456	eb 0a		 jmp	 SHORT $LN4@ast_for_tr
$LN3@ast_for_tr:
  00458	8b 44 24 78	 mov	 eax, DWORD PTR j$23389[rsp]
  0045c	ff c0		 inc	 eax
  0045e	89 44 24 78	 mov	 DWORD PTR j$23389[rsp], eax
$LN4@ast_for_tr:
  00462	48 83 7c 24 58
	00		 cmp	 QWORD PTR slices$23393[rsp], 0
  00468	75 0e		 jne	 SHORT $LN32@ast_for_tr
  0046a	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv241[rsp], 0
  00476	eb 10		 jmp	 SHORT $LN33@ast_for_tr
$LN32@ast_for_tr:
  00478	48 8b 44 24 58	 mov	 rax, QWORD PTR slices$23393[rsp]
  0047d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00480	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv241[rsp], rax
$LN33@ast_for_tr:
  00488	48 63 44 24 78	 movsxd	 rax, DWORD PTR j$23389[rsp]
  0048d	48 3b 84 24 90
	00 00 00	 cmp	 rax, QWORD PTR tv241[rsp]
  00495	0f 8d a7 00 00
	00		 jge	 $LN2@ast_for_tr

; 2147 :                 slc = (slice_ty)asdl_seq_GET(slices, j);

  0049b	48 63 44 24 78	 movsxd	 rax, DWORD PTR j$23389[rsp]
  004a0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slices$23393[rsp]
  004a5	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  004aa	48 89 44 24 50	 mov	 QWORD PTR slc$23390[rsp], rax

; 2148 :                 assert(slc->kind == Index_kind  && slc->v.Index.value);

  004af	48 8b 44 24 50	 mov	 rax, QWORD PTR slc$23390[rsp]
  004b4	83 38 03	 cmp	 DWORD PTR [rax], 3
  004b7	75 0c		 jne	 SHORT $LN34@ast_for_tr
  004b9	48 8b 44 24 50	 mov	 rax, QWORD PTR slc$23390[rsp]
  004be	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  004c3	75 1c		 jne	 SHORT $LN35@ast_for_tr
$LN34@ast_for_tr:
  004c5	41 b8 64 08 00
	00		 mov	 r8d, 2148		; 00000864H
  004cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  004d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FM@IFCBOHP@?$AAs?$AAl?$AAc?$AA?9?$AA?$DO?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAI?$AAn?$AAd?$AAe?$AAx?$AA_?$AAk?$AAi?$AAn?$AAd?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAl?$AAc?$AA?9?$AA?$DO@
  004d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004df	33 c0		 xor	 eax, eax
$LN35@ast_for_tr:

; 2149 :                 asdl_seq_SET(elts, j, slc->v.Index.value);

  004e1	8b 44 24 78	 mov	 eax, DWORD PTR j$23389[rsp]
  004e5	89 84 24 80 00
	00 00		 mov	 DWORD PTR _asdl_i$23417[rsp], eax
  004ec	48 83 7c 24 68
	00		 cmp	 QWORD PTR elts$23394[rsp], 0
  004f2	74 12		 je	 SHORT $LN36@ast_for_tr
  004f4	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23417[rsp]
  004fc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR elts$23394[rsp]
  00501	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00504	7c 1c		 jl	 SHORT $LN37@ast_for_tr
$LN36@ast_for_tr:
  00506	41 b8 65 08 00
	00		 mov	 r8d, 2149		; 00000865H
  0050c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00513	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@CNCMENEB@?$AA?$CI?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAe?$AAl?$AAt?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@
  0051a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00520	33 c0		 xor	 eax, eax
$LN37@ast_for_tr:
  00522	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23417[rsp]
  0052a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR elts$23394[rsp]
  0052f	48 8b 54 24 50	 mov	 rdx, QWORD PTR slc$23390[rsp]
  00534	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00538	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 2150 :             }

  0053d	e9 16 ff ff ff	 jmp	 $LN3@ast_for_tr
$LN2@ast_for_tr:

; 2151 :             e = Tuple(elts, Load, LINENO(n), n->n_col_offset, c->c_arena);

  00542	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0054a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0054e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00553	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0055b	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0055f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00567	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  0056b	ba 01 00 00 00	 mov	 edx, 1
  00570	48 8b 4c 24 68	 mov	 rcx, QWORD PTR elts$23394[rsp]
  00575	e8 00 00 00 00	 call	 _Py_Tuple
  0057a	48 89 44 24 70	 mov	 QWORD PTR e$23391[rsp], rax

; 2152 :             if (!e)

  0057f	48 83 7c 24 70
	00		 cmp	 QWORD PTR e$23391[rsp], 0
  00585	75 04		 jne	 SHORT $LN1@ast_for_tr

; 2153 :                 return NULL;

  00587	33 c0		 xor	 eax, eax
  00589	eb 58		 jmp	 SHORT $LN23@ast_for_tr
$LN1@ast_for_tr:

; 2154 :             return Subscript(left_expr, Index(e, c->c_arena),
; 2155 :                              Load, LINENO(n), n->n_col_offset, c->c_arena);

  0058b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00593	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00597	48 8b 4c 24 70	 mov	 rcx, QWORD PTR e$23391[rsp]
  0059c	e8 00 00 00 00	 call	 _Py_Index
  005a1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  005a9	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  005ad	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005b2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  005ba	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  005bd	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  005c1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  005c9	44 8b 49 10	 mov	 r9d, DWORD PTR [rcx+16]
  005cd	41 b8 01 00 00
	00		 mov	 r8d, 1
  005d3	48 8b d0	 mov	 rdx, rax
  005d6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR left_expr$[rsp]
  005de	e8 00 00 00 00	 call	 _Py_Subscript
$LN13@ast_for_tr:
$LN16@ast_for_tr:
$LN19@ast_for_tr:
$LN23@ast_for_tr:

; 2156 :         }
; 2157 :     }
; 2158 : }

  005e3	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  005ea	c3		 ret	 0
ast_for_trailer ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@BGFNIOEE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA4?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_Slice:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_slice DD imagerel ast_for_slice
	DD	imagerel ast_for_slice+561
	DD	imagerel $unwind$ast_for_slice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_slice DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1CC@BGFNIOEE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA4?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@BGFNIOEE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA4?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '2'
	DB	00H, '4', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_slice
_TEXT	SEGMENT
step$ = 32
upper$ = 40
lower$ = 48
ch$ = 56
n2$23310 = 64
n2$23316 = 72
c$ = 96
n$ = 104
ast_for_slice PROC					; COMDAT

; 1969 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1970 :     node *ch;
; 1971 :     expr_ty lower = NULL, upper = NULL, step = NULL;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR lower$[rsp], 0
  00017	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR upper$[rsp], 0
  00020	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR step$[rsp], 0

; 1972 : 
; 1973 :     REQ(n, subscript);

  00029	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0002e	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00031	3d 44 01 00 00	 cmp	 eax, 324		; 00000144H
  00036	74 1c		 je	 SHORT $LN19@ast_for_sl
  00038	41 b8 b5 07 00
	00		 mov	 r8d, 1973		; 000007b5H
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@BGFNIOEE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA4?$AA?$CJ?$AA?$AA@
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00052	33 c0		 xor	 eax, eax
$LN19@ast_for_sl:

; 1974 : 
; 1975 :     /*
; 1976 :        subscript: test | [test] ':' [test] [sliceop]
; 1977 :        sliceop: ':' [test]
; 1978 :     */
; 1979 :     ch = CHILD(n, 0);

  00054	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00059	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0005d	48 89 44 24 38	 mov	 QWORD PTR ch$[rsp], rax

; 1980 :     if (NCH(n) == 1 && TYPE(ch) == test) {

  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00067	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  0006b	75 4a		 jne	 SHORT $LN16@ast_for_sl
  0006d	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  00072	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00075	3d 2e 01 00 00	 cmp	 eax, 302		; 0000012eH
  0007a	75 3b		 jne	 SHORT $LN16@ast_for_sl

; 1981 :         /* 'step' variable hold no significance in terms of being used over
; 1982 :            other vars */
; 1983 :         step = ast_for_expr(c, ch);

  0007c	48 8b 54 24 38	 mov	 rdx, QWORD PTR ch$[rsp]
  00081	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00086	e8 00 00 00 00	 call	 ast_for_expr
  0008b	48 89 44 24 20	 mov	 QWORD PTR step$[rsp], rax

; 1984 :         if (!step)

  00090	48 83 7c 24 20
	00		 cmp	 QWORD PTR step$[rsp], 0
  00096	75 07		 jne	 SHORT $LN15@ast_for_sl

; 1985 :             return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	e9 8d 01 00 00	 jmp	 $LN17@ast_for_sl
$LN15@ast_for_sl:

; 1986 : 
; 1987 :         return Index(step, c->c_arena);

  0009f	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  000a4	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000a8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR step$[rsp]
  000ad	e8 00 00 00 00	 call	 _Py_Index
  000b2	e9 75 01 00 00	 jmp	 $LN17@ast_for_sl
$LN16@ast_for_sl:

; 1988 :     }
; 1989 : 
; 1990 :     if (TYPE(ch) == test) {

  000b7	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  000bc	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000bf	3d 2e 01 00 00	 cmp	 eax, 302		; 0000012eH
  000c4	75 23		 jne	 SHORT $LN14@ast_for_sl

; 1991 :         lower = ast_for_expr(c, ch);

  000c6	48 8b 54 24 38	 mov	 rdx, QWORD PTR ch$[rsp]
  000cb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000d0	e8 00 00 00 00	 call	 ast_for_expr
  000d5	48 89 44 24 30	 mov	 QWORD PTR lower$[rsp], rax

; 1992 :         if (!lower)

  000da	48 83 7c 24 30
	00		 cmp	 QWORD PTR lower$[rsp], 0
  000e0	75 07		 jne	 SHORT $LN13@ast_for_sl

; 1993 :             return NULL;

  000e2	33 c0		 xor	 eax, eax
  000e4	e9 43 01 00 00	 jmp	 $LN17@ast_for_sl
$LN13@ast_for_sl:
$LN14@ast_for_sl:

; 1994 :     }
; 1995 : 
; 1996 :     /* If there's an upper bound it's in the second or third position. */
; 1997 :     if (TYPE(ch) == COLON) {

  000e9	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  000ee	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000f1	83 f8 0b	 cmp	 eax, 11
  000f4	75 51		 jne	 SHORT $LN12@ast_for_sl

; 1998 :         if (NCH(n) > 1) {

  000f6	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000fb	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  000ff	7e 44		 jle	 SHORT $LN11@ast_for_sl

; 1999 :             node *n2 = CHILD(n, 1);

  00101	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00106	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0010a	48 83 c0 28	 add	 rax, 40			; 00000028H
  0010e	48 89 44 24 40	 mov	 QWORD PTR n2$23310[rsp], rax

; 2000 : 
; 2001 :             if (TYPE(n2) == test) {

  00113	48 8b 44 24 40	 mov	 rax, QWORD PTR n2$23310[rsp]
  00118	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0011b	3d 2e 01 00 00	 cmp	 eax, 302		; 0000012eH
  00120	75 23		 jne	 SHORT $LN10@ast_for_sl

; 2002 :                 upper = ast_for_expr(c, n2);

  00122	48 8b 54 24 40	 mov	 rdx, QWORD PTR n2$23310[rsp]
  00127	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0012c	e8 00 00 00 00	 call	 ast_for_expr
  00131	48 89 44 24 28	 mov	 QWORD PTR upper$[rsp], rax

; 2003 :                 if (!upper)

  00136	48 83 7c 24 28
	00		 cmp	 QWORD PTR upper$[rsp], 0
  0013c	75 07		 jne	 SHORT $LN9@ast_for_sl

; 2004 :                     return NULL;

  0013e	33 c0		 xor	 eax, eax
  00140	e9 e7 00 00 00	 jmp	 $LN17@ast_for_sl
$LN9@ast_for_sl:
$LN10@ast_for_sl:
$LN11@ast_for_sl:

; 2005 :             }
; 2006 :         }

  00145	eb 4f		 jmp	 SHORT $LN8@ast_for_sl
$LN12@ast_for_sl:

; 2007 :     } else if (NCH(n) > 2) {

  00147	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0014c	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  00150	7e 44		 jle	 SHORT $LN7@ast_for_sl

; 2008 :         node *n2 = CHILD(n, 2);

  00152	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00157	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0015b	48 83 c0 50	 add	 rax, 80			; 00000050H
  0015f	48 89 44 24 48	 mov	 QWORD PTR n2$23316[rsp], rax

; 2009 : 
; 2010 :         if (TYPE(n2) == test) {

  00164	48 8b 44 24 48	 mov	 rax, QWORD PTR n2$23316[rsp]
  00169	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0016c	3d 2e 01 00 00	 cmp	 eax, 302		; 0000012eH
  00171	75 23		 jne	 SHORT $LN6@ast_for_sl

; 2011 :             upper = ast_for_expr(c, n2);

  00173	48 8b 54 24 48	 mov	 rdx, QWORD PTR n2$23316[rsp]
  00178	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  0017d	e8 00 00 00 00	 call	 ast_for_expr
  00182	48 89 44 24 28	 mov	 QWORD PTR upper$[rsp], rax

; 2012 :             if (!upper)

  00187	48 83 7c 24 28
	00		 cmp	 QWORD PTR upper$[rsp], 0
  0018d	75 07		 jne	 SHORT $LN5@ast_for_sl

; 2013 :                 return NULL;

  0018f	33 c0		 xor	 eax, eax
  00191	e9 96 00 00 00	 jmp	 $LN17@ast_for_sl
$LN5@ast_for_sl:
$LN6@ast_for_sl:
$LN7@ast_for_sl:
$LN8@ast_for_sl:

; 2014 :         }
; 2015 :     }
; 2016 : 
; 2017 :     ch = CHILD(n, NCH(n) - 1);

  00196	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0019b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0019e	ff c8		 dec	 eax
  001a0	48 98		 cdqe
  001a2	48 6b c0 28	 imul	 rax, 40			; 00000028H
  001a6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR n$[rsp]
  001ab	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  001af	48 89 44 24 38	 mov	 QWORD PTR ch$[rsp], rax

; 2018 :     if (TYPE(ch) == sliceop) {

  001b4	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  001b9	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001bc	3d 45 01 00 00	 cmp	 eax, 325		; 00000145H
  001c1	75 4c		 jne	 SHORT $LN4@ast_for_sl

; 2019 :         if (NCH(ch) != 1) {

  001c3	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  001c8	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  001cc	74 41		 je	 SHORT $LN3@ast_for_sl

; 2020 :             ch = CHILD(ch, 1);

  001ce	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  001d3	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001d7	48 83 c0 28	 add	 rax, 40			; 00000028H
  001db	48 89 44 24 38	 mov	 QWORD PTR ch$[rsp], rax

; 2021 :             if (TYPE(ch) == test) {

  001e0	48 8b 44 24 38	 mov	 rax, QWORD PTR ch$[rsp]
  001e5	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001e8	3d 2e 01 00 00	 cmp	 eax, 302		; 0000012eH
  001ed	75 20		 jne	 SHORT $LN2@ast_for_sl

; 2022 :                 step = ast_for_expr(c, ch);

  001ef	48 8b 54 24 38	 mov	 rdx, QWORD PTR ch$[rsp]
  001f4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  001f9	e8 00 00 00 00	 call	 ast_for_expr
  001fe	48 89 44 24 20	 mov	 QWORD PTR step$[rsp], rax

; 2023 :                 if (!step)

  00203	48 83 7c 24 20
	00		 cmp	 QWORD PTR step$[rsp], 0
  00209	75 04		 jne	 SHORT $LN1@ast_for_sl

; 2024 :                     return NULL;

  0020b	33 c0		 xor	 eax, eax
  0020d	eb 1d		 jmp	 SHORT $LN17@ast_for_sl
$LN1@ast_for_sl:
$LN2@ast_for_sl:
$LN3@ast_for_sl:
$LN4@ast_for_sl:

; 2025 :             }
; 2026 :         }
; 2027 :     }
; 2028 : 
; 2029 :     return Slice(lower, upper, step, c->c_arena);

  0020f	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00214	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00218	4c 8b 44 24 20	 mov	 r8, QWORD PTR step$[rsp]
  0021d	48 8b 54 24 28	 mov	 rdx, QWORD PTR upper$[rsp]
  00222	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lower$[rsp]
  00227	e8 00 00 00 00	 call	 _Py_Slice
$LN17@ast_for_sl:

; 2030 : }

  0022c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00230	c3		 ret	 0
ast_for_slice ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@MIBPBIBE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA1?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_Starred:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_starred DD imagerel ast_for_starred
	DD	imagerel ast_for_starred+152
	DD	imagerel $unwind$ast_for_starred
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_starred DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1CC@MIBPBIBE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA1?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@MIBPBIBE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA1?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '1'
	DB	00H, '1', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_starred
_TEXT	SEGMENT
tmp$ = 48
c$ = 80
n$ = 88
ast_for_starred PROC					; COMDAT

; 2223 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2224 :     expr_ty tmp;
; 2225 :     REQ(n, star_expr);

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 37 01 00 00	 cmp	 eax, 311		; 00000137H
  0001b	74 1c		 je	 SHORT $LN4@ast_for_st
  0001d	41 b8 b1 08 00
	00		 mov	 r8d, 2225		; 000008b1H
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MIBPBIBE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA1?$AA1?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN4@ast_for_st:

; 2226 : 
; 2227 :     tmp = ast_for_expr(c, CHILD(n, 1));

  00039	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0003e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00042	48 83 c0 28	 add	 rax, 40			; 00000028H
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0004e	e8 00 00 00 00	 call	 ast_for_expr
  00053	48 89 44 24 30	 mov	 QWORD PTR tmp$[rsp], rax

; 2228 :     if (!tmp)

  00058	48 83 7c 24 30
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0005e	75 04		 jne	 SHORT $LN1@ast_for_st

; 2229 :         return NULL;

  00060	33 c0		 xor	 eax, eax
  00062	eb 2f		 jmp	 SHORT $LN2@ast_for_st
$LN1@ast_for_st:

; 2230 : 
; 2231 :     /* The Load context is changed later. */
; 2232 :     return Starred(tmp, Load, LINENO(n), n->n_col_offset, c->c_arena);

  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  00069	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00072	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00077	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00080	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00084	ba 01 00 00 00	 mov	 edx, 1
  00089	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tmp$[rsp]
  0008e	e8 00 00 00 00	 call	 _Py_Starred
$LN2@ast_for_st:

; 2233 : }

  00093	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00097	c3		 ret	 0
ast_for_starred ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FC@OHBDJICK@?$AA?$CI?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd@ ; `string'
PUBLIC	??_C@_0BK@CEBEDAAO@keyword?5argument?5repeated?$AA@ ; `string'
PUBLIC	??_C@_0BP@GJBMLMAG@keyword?5can?8t?5be?5an?5expression?$AA@ ; `string'
PUBLIC	??_C@_0CB@FBIGLNOA@lambda?5cannot?5contain?5assignment@ ; `string'
PUBLIC	??_C@_1EC@KPDCIBGG@?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@ ; `string'
PUBLIC	??_C@_0CM@FHHDCLIK@only?5named?5arguments?5may?5follow?5@ ; `string'
PUBLIC	??_C@_0CC@JMBPEODL@non?9keyword?5arg?5after?5keyword?5ar@ ; `string'
PUBLIC	??_C@_0EA@PMHIDDOH@Generator?5expression?5must?5be?5par@ ; `string'
PUBLIC	??_C@_1CC@EBGGMMMM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA0?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_keyword:PROC
EXTRN	PyUnicode_Compare:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_call DD imagerel ast_for_call
	DD	imagerel ast_for_call+1892
	DD	imagerel $unwind$ast_for_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_call DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_1FC@OHBDJICK@?$AA?$CI?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd@
CONST	SEGMENT
??_C@_1FC@OHBDJICK@?$AA?$CI?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd@ DB '('
	DB	00H, 'k', 00H, 'e', 00H, 'y', 00H, 'w', 00H, 'o', 00H, 'r', 00H
	DB	'd', 00H, 's', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, '_', 00H, 'a', 00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H
	DB	'i', 00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H, 'k', 00H, 'e'
	DB	00H, 'y', 00H, 'w', 00H, 'o', 00H, 'r', 00H, 'd', 00H, 's', 00H
	DB	')', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CEBEDAAO@keyword?5argument?5repeated?$AA@
CONST	SEGMENT
??_C@_0BK@CEBEDAAO@keyword?5argument?5repeated?$AA@ DB 'keyword argument '
	DB	'repeated', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GJBMLMAG@keyword?5can?8t?5be?5an?5expression?$AA@
CONST	SEGMENT
??_C@_0BP@GJBMLMAG@keyword?5can?8t?5be?5an?5expression?$AA@ DB 'keyword c'
	DB	'an''t be an expression', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@FBIGLNOA@lambda?5cannot?5contain?5assignment@
CONST	SEGMENT
??_C@_0CB@FBIGLNOA@lambda?5cannot?5contain?5assignment@ DB 'lambda cannot'
	DB	' contain assignment', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@KPDCIBGG@?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@
CONST	SEGMENT
??_C@_1EC@KPDCIBGG@?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@ DB '('
	DB	00H, 'a', 00H, 'r', 00H, 'g', 00H, 's', 00H, ')', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's', 00H, 'd'
	DB	00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'(', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 's', 00H, ')', 00H, '-'
	DB	00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FHHDCLIK@only?5named?5arguments?5may?5follow?5@
CONST	SEGMENT
??_C@_0CM@FHHDCLIK@only?5named?5arguments?5may?5follow?5@ DB 'only named '
	DB	'arguments may follow *expression', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JMBPEODL@non?9keyword?5arg?5after?5keyword?5ar@
CONST	SEGMENT
??_C@_0CC@JMBPEODL@non?9keyword?5arg?5after?5keyword?5ar@ DB 'non-keyword'
	DB	' arg after keyword arg', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@PMHIDDOH@Generator?5expression?5must?5be?5par@
CONST	SEGMENT
??_C@_0EA@PMHIDDOH@Generator?5expression?5must?5be?5par@ DB 'Generator ex'
	DB	'pression must be parenthesized if not sole argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@EBGGMMMM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA0?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@EBGGMMMM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA0?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '3'
	DB	00H, '0', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_call
_TEXT	SEGMENT
args$ = 64
ngens$ = 72
nkeywords$ = 76
i$ = 80
kwarg$ = 88
keywords$ = 96
nargs$ = 104
vararg$ = 112
ch$23590 = 120
ch$23610 = 128
e$23612 = 136
_asdl_i$23622 = 144
_asdl_i$23629 = 148
tmp$23634 = 152
key$23633 = 160
kw$23632 = 168
k$23635 = 176
_asdl_i$23659 = 180
c$ = 208
n$ = 216
func$ = 224
ast_for_call PROC					; COMDAT

; 2404 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 2405 :     /*
; 2406 :       arglist: (argument ',')* (argument [',']| '*' test [',' '**' test]
; 2407 :                | '**' test)
; 2408 :       argument: [test '='] (test) [comp_for]        # Really [keyword '='] test
; 2409 :     */
; 2410 : 
; 2411 :     int i, nargs, nkeywords, ngens;
; 2412 :     asdl_seq *args;
; 2413 :     asdl_seq *keywords;
; 2414 :     expr_ty vararg = NULL, kwarg = NULL;

  00016	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR vararg$[rsp], 0
  0001f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR kwarg$[rsp], 0

; 2415 : 
; 2416 :     REQ(n, arglist);

  00028	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00030	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00033	3d 4a 01 00 00	 cmp	 eax, 330		; 0000014aH
  00038	74 1c		 je	 SHORT $LN47@ast_for_ca
  0003a	41 b8 70 09 00
	00		 mov	 r8d, 2416		; 00000970H
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@EBGGMMMM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA3?$AA0?$AA?$CJ?$AA?$AA@
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00054	33 c0		 xor	 eax, eax
$LN47@ast_for_ca:

; 2417 : 
; 2418 :     nargs = 0;

  00056	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR nargs$[rsp], 0

; 2419 :     nkeywords = 0;

  0005e	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR nkeywords$[rsp], 0

; 2420 :     ngens = 0;

  00066	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR ngens$[rsp], 0

; 2421 :     for (i = 0; i < NCH(n); i++) {

  0006e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00076	eb 0a		 jmp	 SHORT $LN44@ast_for_ca
$LN43@ast_for_ca:
  00078	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN44@ast_for_ca:
  00082	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0008a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0008d	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  00091	7d 6f		 jge	 SHORT $LN42@ast_for_ca

; 2422 :         node *ch = CHILD(n, i);

  00093	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00098	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0009c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  000a4	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000a8	48 89 44 24 78	 mov	 QWORD PTR ch$23590[rsp], rax

; 2423 :         if (TYPE(ch) == argument) {

  000ad	48 8b 44 24 78	 mov	 rax, QWORD PTR ch$23590[rsp]
  000b2	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000b5	3d 4b 01 00 00	 cmp	 eax, 331		; 0000014bH
  000ba	75 41		 jne	 SHORT $LN41@ast_for_ca

; 2424 :             if (NCH(ch) == 1)

  000bc	48 8b 44 24 78	 mov	 rax, QWORD PTR ch$23590[rsp]
  000c1	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  000c5	75 0c		 jne	 SHORT $LN40@ast_for_ca

; 2425 :                 nargs++;

  000c7	8b 44 24 68	 mov	 eax, DWORD PTR nargs$[rsp]
  000cb	ff c0		 inc	 eax
  000cd	89 44 24 68	 mov	 DWORD PTR nargs$[rsp], eax
  000d1	eb 2a		 jmp	 SHORT $LN39@ast_for_ca
$LN40@ast_for_ca:

; 2426 :             else if (TYPE(CHILD(ch, 1)) == comp_for)

  000d3	48 8b 44 24 78	 mov	 rax, QWORD PTR ch$23590[rsp]
  000d8	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000dc	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  000e0	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  000e5	75 0c		 jne	 SHORT $LN38@ast_for_ca

; 2427 :                 ngens++;

  000e7	8b 44 24 48	 mov	 eax, DWORD PTR ngens$[rsp]
  000eb	ff c0		 inc	 eax
  000ed	89 44 24 48	 mov	 DWORD PTR ngens$[rsp], eax

; 2428 :             else

  000f1	eb 0a		 jmp	 SHORT $LN37@ast_for_ca
$LN38@ast_for_ca:

; 2429 :                 nkeywords++;

  000f3	8b 44 24 4c	 mov	 eax, DWORD PTR nkeywords$[rsp]
  000f7	ff c0		 inc	 eax
  000f9	89 44 24 4c	 mov	 DWORD PTR nkeywords$[rsp], eax
$LN37@ast_for_ca:
$LN39@ast_for_ca:
$LN41@ast_for_ca:

; 2430 :         }
; 2431 :     }

  000fd	e9 76 ff ff ff	 jmp	 $LN43@ast_for_ca
$LN42@ast_for_ca:

; 2432 :     if (ngens > 1 || (ngens && (nargs || nkeywords))) {

  00102	83 7c 24 48 01	 cmp	 DWORD PTR ngens$[rsp], 1
  00107	7f 15		 jg	 SHORT $LN35@ast_for_ca
  00109	83 7c 24 48 00	 cmp	 DWORD PTR ngens$[rsp], 0
  0010e	74 31		 je	 SHORT $LN36@ast_for_ca
  00110	83 7c 24 68 00	 cmp	 DWORD PTR nargs$[rsp], 0
  00115	75 07		 jne	 SHORT $LN34@ast_for_ca
  00117	83 7c 24 4c 00	 cmp	 DWORD PTR nkeywords$[rsp], 0
  0011c	74 23		 je	 SHORT $LN36@ast_for_ca
$LN34@ast_for_ca:
$LN35@ast_for_ca:

; 2433 :         ast_error(c, n, "Generator expression must be parenthesized "
; 2434 :                   "if not sole argument");

  0011e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0EA@PMHIDDOH@Generator?5expression?5must?5be?5par@
  00125	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  0012d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00135	e8 00 00 00 00	 call	 ast_error

; 2435 :         return NULL;

  0013a	33 c0		 xor	 eax, eax
  0013c	e9 1b 06 00 00	 jmp	 $LN45@ast_for_ca
$LN36@ast_for_ca:

; 2436 :     }
; 2437 : 
; 2438 :     if (nargs + nkeywords + ngens > 255) {

  00141	8b 44 24 4c	 mov	 eax, DWORD PTR nkeywords$[rsp]
  00145	8b 4c 24 68	 mov	 ecx, DWORD PTR nargs$[rsp]
  00149	03 c8		 add	 ecx, eax
  0014b	8b c1		 mov	 eax, ecx
  0014d	03 44 24 48	 add	 eax, DWORD PTR ngens$[rsp]
  00151	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00156	7e 23		 jle	 SHORT $LN33@ast_for_ca

; 2439 :         ast_error(c, n, "more than 255 arguments");

  00158	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BI@ENJBOKKG@more?5than?5255?5arguments?$AA@
  0015f	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  00167	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0016f	e8 00 00 00 00	 call	 ast_error

; 2440 :         return NULL;

  00174	33 c0		 xor	 eax, eax
  00176	e9 e1 05 00 00	 jmp	 $LN45@ast_for_ca
$LN33@ast_for_ca:

; 2441 :     }
; 2442 : 
; 2443 :     args = asdl_seq_new(nargs + ngens, c->c_arena);

  0017b	8b 44 24 48	 mov	 eax, DWORD PTR ngens$[rsp]
  0017f	8b 4c 24 68	 mov	 ecx, DWORD PTR nargs$[rsp]
  00183	03 c8		 add	 ecx, eax
  00185	8b c1		 mov	 eax, ecx
  00187	48 98		 cdqe
  00189	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00191	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00195	48 8b c8	 mov	 rcx, rax
  00198	e8 00 00 00 00	 call	 asdl_seq_new
  0019d	48 89 44 24 40	 mov	 QWORD PTR args$[rsp], rax

; 2444 :     if (!args)

  001a2	48 83 7c 24 40
	00		 cmp	 QWORD PTR args$[rsp], 0
  001a8	75 07		 jne	 SHORT $LN32@ast_for_ca

; 2445 :         return NULL;

  001aa	33 c0		 xor	 eax, eax
  001ac	e9 ab 05 00 00	 jmp	 $LN45@ast_for_ca
$LN32@ast_for_ca:

; 2446 :     keywords = asdl_seq_new(nkeywords, c->c_arena);

  001b1	48 63 44 24 4c	 movsxd	 rax, DWORD PTR nkeywords$[rsp]
  001b6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001be	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  001c2	48 8b c8	 mov	 rcx, rax
  001c5	e8 00 00 00 00	 call	 asdl_seq_new
  001ca	48 89 44 24 60	 mov	 QWORD PTR keywords$[rsp], rax

; 2447 :     if (!keywords)

  001cf	48 83 7c 24 60
	00		 cmp	 QWORD PTR keywords$[rsp], 0
  001d5	75 07		 jne	 SHORT $LN31@ast_for_ca

; 2448 :         return NULL;

  001d7	33 c0		 xor	 eax, eax
  001d9	e9 7e 05 00 00	 jmp	 $LN45@ast_for_ca
$LN31@ast_for_ca:

; 2449 :     nargs = 0;

  001de	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR nargs$[rsp], 0

; 2450 :     nkeywords = 0;

  001e6	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR nkeywords$[rsp], 0

; 2451 :     for (i = 0; i < NCH(n); i++) {

  001ee	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001f6	eb 0a		 jmp	 SHORT $LN30@ast_for_ca
$LN29@ast_for_ca:
  001f8	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  001fc	ff c0		 inc	 eax
  001fe	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN30@ast_for_ca:
  00202	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0020a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0020d	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  00211	0f 8d f0 04 00
	00		 jge	 $LN28@ast_for_ca

; 2452 :         node *ch = CHILD(n, i);

  00217	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0021c	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00220	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00228	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0022c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ch$23610[rsp], rax

; 2453 :         if (TYPE(ch) == argument) {

  00234	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  0023c	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0023f	3d 4b 01 00 00	 cmp	 eax, 331		; 0000014bH
  00244	0f 85 0d 04 00
	00		 jne	 $LN27@ast_for_ca

; 2454 :             expr_ty e;
; 2455 :             if (NCH(ch) == 1) {

  0024a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  00252	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00256	0f 85 fa 00 00
	00		 jne	 $LN26@ast_for_ca

; 2456 :                 if (nkeywords) {

  0025c	83 7c 24 4c 00	 cmp	 DWORD PTR nkeywords$[rsp], 0
  00261	74 27		 je	 SHORT $LN25@ast_for_ca

; 2457 :                     ast_error(c, CHILD(ch, 0),
; 2458 :                               "non-keyword arg after keyword arg");

  00263	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CC@JMBPEODL@non?9keyword?5arg?5after?5keyword?5ar@
  0026a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  00272	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00276	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0027e	e8 00 00 00 00	 call	 ast_error

; 2459 :                     return NULL;

  00283	33 c0		 xor	 eax, eax
  00285	e9 d2 04 00 00	 jmp	 $LN45@ast_for_ca
$LN25@ast_for_ca:

; 2460 :                 }
; 2461 :                 if (vararg) {

  0028a	48 83 7c 24 70
	00		 cmp	 QWORD PTR vararg$[rsp], 0
  00290	74 27		 je	 SHORT $LN24@ast_for_ca

; 2462 :                     ast_error(c, CHILD(ch, 0),
; 2463 :                               "only named arguments may follow *expression");

  00292	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CM@FHHDCLIK@only?5named?5arguments?5may?5follow?5@
  00299	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  002a1	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  002a5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002ad	e8 00 00 00 00	 call	 ast_error

; 2464 :                     return NULL;

  002b2	33 c0		 xor	 eax, eax
  002b4	e9 a3 04 00 00	 jmp	 $LN45@ast_for_ca
$LN24@ast_for_ca:

; 2465 :                 }
; 2466 :                 e = ast_for_expr(c, CHILD(ch, 0));

  002b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  002c1	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  002c5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002cd	e8 00 00 00 00	 call	 ast_for_expr
  002d2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR e$23612[rsp], rax

; 2467 :                 if (!e)

  002da	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR e$23612[rsp], 0
  002e3	75 07		 jne	 SHORT $LN23@ast_for_ca

; 2468 :                     return NULL;

  002e5	33 c0		 xor	 eax, eax
  002e7	e9 70 04 00 00	 jmp	 $LN45@ast_for_ca
$LN23@ast_for_ca:

; 2469 :                 asdl_seq_SET(args, nargs++, e);

  002ec	8b 44 24 68	 mov	 eax, DWORD PTR nargs$[rsp]
  002f0	89 84 24 90 00
	00 00		 mov	 DWORD PTR _asdl_i$23622[rsp], eax
  002f7	8b 44 24 68	 mov	 eax, DWORD PTR nargs$[rsp]
  002fb	ff c0		 inc	 eax
  002fd	89 44 24 68	 mov	 DWORD PTR nargs$[rsp], eax
  00301	48 83 7c 24 40
	00		 cmp	 QWORD PTR args$[rsp], 0
  00307	74 12		 je	 SHORT $LN48@ast_for_ca
  00309	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23622[rsp]
  00311	48 8b 4c 24 40	 mov	 rcx, QWORD PTR args$[rsp]
  00316	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00319	7c 1c		 jl	 SHORT $LN49@ast_for_ca
$LN48@ast_for_ca:
  0031b	41 b8 a5 09 00
	00		 mov	 r8d, 2469		; 000009a5H
  00321	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00328	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@KPDCIBGG@?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@
  0032f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00335	33 c0		 xor	 eax, eax
$LN49@ast_for_ca:
  00337	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23622[rsp]
  0033f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR args$[rsp]
  00344	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR e$23612[rsp]
  0034c	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx
  00351	e9 fc 02 00 00	 jmp	 $LN22@ast_for_ca
$LN26@ast_for_ca:

; 2470 :             }
; 2471 :             else if (TYPE(CHILD(ch, 1)) == comp_for) {

  00356	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  0035e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00362	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  00366	3d 4d 01 00 00	 cmp	 eax, 333		; 0000014dH
  0036b	0f 85 99 00 00
	00		 jne	 $LN21@ast_for_ca

; 2472 :                 e = ast_for_genexp(c, ch);

  00371	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR ch$23610[rsp]
  00379	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00381	e8 00 00 00 00	 call	 ast_for_genexp
  00386	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR e$23612[rsp], rax

; 2473 :                 if (!e)

  0038e	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR e$23612[rsp], 0
  00397	75 07		 jne	 SHORT $LN20@ast_for_ca

; 2474 :                     return NULL;

  00399	33 c0		 xor	 eax, eax
  0039b	e9 bc 03 00 00	 jmp	 $LN45@ast_for_ca
$LN20@ast_for_ca:

; 2475 :                 asdl_seq_SET(args, nargs++, e);

  003a0	8b 44 24 68	 mov	 eax, DWORD PTR nargs$[rsp]
  003a4	89 84 24 94 00
	00 00		 mov	 DWORD PTR _asdl_i$23629[rsp], eax
  003ab	8b 44 24 68	 mov	 eax, DWORD PTR nargs$[rsp]
  003af	ff c0		 inc	 eax
  003b1	89 44 24 68	 mov	 DWORD PTR nargs$[rsp], eax
  003b5	48 83 7c 24 40
	00		 cmp	 QWORD PTR args$[rsp], 0
  003bb	74 12		 je	 SHORT $LN50@ast_for_ca
  003bd	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23629[rsp]
  003c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR args$[rsp]
  003ca	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  003cd	7c 1c		 jl	 SHORT $LN51@ast_for_ca
$LN50@ast_for_ca:
  003cf	41 b8 ab 09 00
	00		 mov	 r8d, 2475		; 000009abH
  003d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  003dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@KPDCIBGG@?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe@
  003e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003e9	33 c0		 xor	 eax, eax
$LN51@ast_for_ca:
  003eb	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23629[rsp]
  003f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR args$[rsp]
  003f8	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR e$23612[rsp]
  00400	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 2476 :             }
; 2477 :             else {

  00405	e9 48 02 00 00	 jmp	 $LN19@ast_for_ca
$LN21@ast_for_ca:

; 2478 :                 keyword_ty kw;
; 2479 :                 identifier key, tmp;
; 2480 :                 int k;
; 2481 : 
; 2482 :                 /* CHILD(ch, 0) is test, but must be an identifier? */
; 2483 :                 e = ast_for_expr(c, CHILD(ch, 0));

  0040a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  00412	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00416	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0041e	e8 00 00 00 00	 call	 ast_for_expr
  00423	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR e$23612[rsp], rax

; 2484 :                 if (!e)

  0042b	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR e$23612[rsp], 0
  00434	75 07		 jne	 SHORT $LN18@ast_for_ca

; 2485 :                     return NULL;

  00436	33 c0		 xor	 eax, eax
  00438	e9 1f 03 00 00	 jmp	 $LN45@ast_for_ca
$LN18@ast_for_ca:

; 2486 :                 /* f(lambda x: x[0] = 3) ends up getting parsed with
; 2487 :                  * LHS test = lambda x: x[0], and RHS test = 3.
; 2488 :                  * SF bug 132313 points out that complaining about a keyword
; 2489 :                  * then is very confusing.
; 2490 :                  */
; 2491 :                 if (e->kind == Lambda_kind) {

  0043d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR e$23612[rsp]
  00445	83 38 04	 cmp	 DWORD PTR [rax], 4
  00448	75 29		 jne	 SHORT $LN17@ast_for_ca

; 2492 :                     ast_error(c, CHILD(ch, 0), "lambda cannot contain assignment");

  0044a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CB@FBIGLNOA@lambda?5cannot?5contain?5assignment@
  00451	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  00459	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  0045d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00465	e8 00 00 00 00	 call	 ast_error

; 2493 :                     return NULL;

  0046a	33 c0		 xor	 eax, eax
  0046c	e9 eb 02 00 00	 jmp	 $LN45@ast_for_ca
  00471	eb 68		 jmp	 SHORT $LN16@ast_for_ca
$LN17@ast_for_ca:

; 2494 :                 } else if (e->kind != Name_kind) {

  00473	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR e$23612[rsp]
  0047b	83 38 17	 cmp	 DWORD PTR [rax], 23
  0047e	74 29		 je	 SHORT $LN15@ast_for_ca

; 2495 :                     ast_error(c, CHILD(ch, 0), "keyword can't be an expression");

  00480	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@GJBMLMAG@keyword?5can?8t?5be?5an?5expression?$AA@
  00487	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  0048f	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00493	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0049b	e8 00 00 00 00	 call	 ast_error

; 2496 :                     return NULL;

  004a0	33 c0		 xor	 eax, eax
  004a2	e9 b5 02 00 00	 jmp	 $LN45@ast_for_ca
  004a7	eb 32		 jmp	 SHORT $LN14@ast_for_ca
$LN15@ast_for_ca:

; 2497 :                 } else if (forbidden_name(c, e->v.Name.id, ch, 1)) {

  004a9	41 b9 01 00 00
	00		 mov	 r9d, 1
  004af	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR ch$23610[rsp]
  004b7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR e$23612[rsp]
  004bf	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  004c3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  004cb	e8 00 00 00 00	 call	 forbidden_name
  004d0	85 c0		 test	 eax, eax
  004d2	74 07		 je	 SHORT $LN13@ast_for_ca

; 2498 :                     return NULL;

  004d4	33 c0		 xor	 eax, eax
  004d6	e9 81 02 00 00	 jmp	 $LN45@ast_for_ca
$LN13@ast_for_ca:
$LN14@ast_for_ca:
$LN16@ast_for_ca:

; 2499 :                 }
; 2500 :                 key = e->v.Name.id;

  004db	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR e$23612[rsp]
  004e3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  004e7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR key$23633[rsp], rax

; 2501 :                 for (k = 0; k < nkeywords; k++) {

  004ef	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR k$23635[rsp], 0
  004fa	eb 10		 jmp	 SHORT $LN12@ast_for_ca
$LN11@ast_for_ca:
  004fc	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR k$23635[rsp]
  00503	ff c0		 inc	 eax
  00505	89 84 24 b0 00
	00 00		 mov	 DWORD PTR k$23635[rsp], eax
$LN12@ast_for_ca:
  0050c	8b 44 24 4c	 mov	 eax, DWORD PTR nkeywords$[rsp]
  00510	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR k$23635[rsp], eax
  00517	7d 5f		 jge	 SHORT $LN10@ast_for_ca

; 2502 :                     tmp = ((keyword_ty)asdl_seq_GET(keywords, k))->arg;

  00519	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR k$23635[rsp]
  00521	48 8b 4c 24 60	 mov	 rcx, QWORD PTR keywords$[rsp]
  00526	48 8b 44 c1 08	 mov	 rax, QWORD PTR [rcx+rax*8+8]
  0052b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0052e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tmp$23634[rsp], rax

; 2503 :                     if (!PyUnicode_Compare(tmp, key)) {

  00536	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR key$23633[rsp]
  0053e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tmp$23634[rsp]
  00546	e8 00 00 00 00	 call	 PyUnicode_Compare
  0054b	85 c0		 test	 eax, eax
  0054d	75 27		 jne	 SHORT $LN9@ast_for_ca

; 2504 :                         ast_error(c, CHILD(ch, 0), "keyword argument repeated");

  0054f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BK@CEBEDAAO@keyword?5argument?5repeated?$AA@
  00556	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  0055e	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00562	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0056a	e8 00 00 00 00	 call	 ast_error

; 2505 :                         return NULL;

  0056f	33 c0		 xor	 eax, eax
  00571	e9 e6 01 00 00	 jmp	 $LN45@ast_for_ca
$LN9@ast_for_ca:

; 2506 :                     }
; 2507 :                 }

  00576	eb 84		 jmp	 SHORT $LN11@ast_for_ca
$LN10@ast_for_ca:

; 2508 :                 e = ast_for_expr(c, CHILD(ch, 2));

  00578	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  00580	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00584	48 83 c0 50	 add	 rax, 80			; 00000050H
  00588	48 8b d0	 mov	 rdx, rax
  0058b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00593	e8 00 00 00 00	 call	 ast_for_expr
  00598	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR e$23612[rsp], rax

; 2509 :                 if (!e)

  005a0	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR e$23612[rsp], 0
  005a9	75 07		 jne	 SHORT $LN8@ast_for_ca

; 2510 :                     return NULL;

  005ab	33 c0		 xor	 eax, eax
  005ad	e9 aa 01 00 00	 jmp	 $LN45@ast_for_ca
$LN8@ast_for_ca:

; 2511 :                 kw = keyword(key, e, c->c_arena);

  005b2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  005ba	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  005be	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR e$23612[rsp]
  005c6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR key$23633[rsp]
  005ce	e8 00 00 00 00	 call	 _Py_keyword
  005d3	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR kw$23632[rsp], rax

; 2512 :                 if (!kw)

  005db	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR kw$23632[rsp], 0
  005e4	75 07		 jne	 SHORT $LN7@ast_for_ca

; 2513 :                     return NULL;

  005e6	33 c0		 xor	 eax, eax
  005e8	e9 6f 01 00 00	 jmp	 $LN45@ast_for_ca
$LN7@ast_for_ca:

; 2514 :                 asdl_seq_SET(keywords, nkeywords++, kw);

  005ed	8b 44 24 4c	 mov	 eax, DWORD PTR nkeywords$[rsp]
  005f1	89 84 24 b4 00
	00 00		 mov	 DWORD PTR _asdl_i$23659[rsp], eax
  005f8	8b 44 24 4c	 mov	 eax, DWORD PTR nkeywords$[rsp]
  005fc	ff c0		 inc	 eax
  005fe	89 44 24 4c	 mov	 DWORD PTR nkeywords$[rsp], eax
  00602	48 83 7c 24 60
	00		 cmp	 QWORD PTR keywords$[rsp], 0
  00608	74 12		 je	 SHORT $LN52@ast_for_ca
  0060a	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23659[rsp]
  00612	48 8b 4c 24 60	 mov	 rcx, QWORD PTR keywords$[rsp]
  00617	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  0061a	7c 1c		 jl	 SHORT $LN53@ast_for_ca
$LN52@ast_for_ca:
  0061c	41 b8 d2 09 00
	00		 mov	 r8d, 2514		; 000009d2H
  00622	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00629	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FC@OHBDJICK@?$AA?$CI?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAk?$AAe?$AAy?$AAw?$AAo?$AAr?$AAd@
  00630	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00636	33 c0		 xor	 eax, eax
$LN53@ast_for_ca:
  00638	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23659[rsp]
  00640	48 8b 4c 24 60	 mov	 rcx, QWORD PTR keywords$[rsp]
  00645	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR kw$23632[rsp]
  0064d	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx
$LN19@ast_for_ca:
$LN22@ast_for_ca:

; 2515 :             }

  00652	e9 ab 00 00 00	 jmp	 $LN6@ast_for_ca
$LN27@ast_for_ca:

; 2516 :         }
; 2517 :         else if (TYPE(ch) == STAR) {

  00657	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  0065f	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00662	83 f8 10	 cmp	 eax, 16
  00665	75 48		 jne	 SHORT $LN5@ast_for_ca

; 2518 :             vararg = ast_for_expr(c, CHILD(n, i+1));

  00667	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0066b	ff c0		 inc	 eax
  0066d	48 98		 cdqe
  0066f	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00673	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0067b	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0067f	48 8b d0	 mov	 rdx, rax
  00682	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0068a	e8 00 00 00 00	 call	 ast_for_expr
  0068f	48 89 44 24 70	 mov	 QWORD PTR vararg$[rsp], rax

; 2519 :             if (!vararg)

  00694	48 83 7c 24 70
	00		 cmp	 QWORD PTR vararg$[rsp], 0
  0069a	75 07		 jne	 SHORT $LN4@ast_for_ca

; 2520 :                 return NULL;

  0069c	33 c0		 xor	 eax, eax
  0069e	e9 b9 00 00 00	 jmp	 $LN45@ast_for_ca
$LN4@ast_for_ca:

; 2521 :             i++;

  006a3	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  006a7	ff c0		 inc	 eax
  006a9	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
  006ad	eb 53		 jmp	 SHORT $LN3@ast_for_ca
$LN5@ast_for_ca:

; 2522 :         }
; 2523 :         else if (TYPE(ch) == DOUBLESTAR) {

  006af	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ch$23610[rsp]
  006b7	0f bf 00	 movsx	 eax, WORD PTR [rax]
  006ba	83 f8 23	 cmp	 eax, 35			; 00000023H
  006bd	75 43		 jne	 SHORT $LN2@ast_for_ca

; 2524 :             kwarg = ast_for_expr(c, CHILD(n, i+1));

  006bf	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  006c3	ff c0		 inc	 eax
  006c5	48 98		 cdqe
  006c7	48 6b c0 28	 imul	 rax, 40			; 00000028H
  006cb	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  006d3	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  006d7	48 8b d0	 mov	 rdx, rax
  006da	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  006e2	e8 00 00 00 00	 call	 ast_for_expr
  006e7	48 89 44 24 58	 mov	 QWORD PTR kwarg$[rsp], rax

; 2525 :             if (!kwarg)

  006ec	48 83 7c 24 58
	00		 cmp	 QWORD PTR kwarg$[rsp], 0
  006f2	75 04		 jne	 SHORT $LN1@ast_for_ca

; 2526 :                 return NULL;

  006f4	33 c0		 xor	 eax, eax
  006f6	eb 64		 jmp	 SHORT $LN45@ast_for_ca
$LN1@ast_for_ca:

; 2527 :             i++;

  006f8	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  006fc	ff c0		 inc	 eax
  006fe	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN2@ast_for_ca:
$LN3@ast_for_ca:
$LN6@ast_for_ca:

; 2528 :         }
; 2529 :     }

  00702	e9 f1 fa ff ff	 jmp	 $LN29@ast_for_ca
$LN28@ast_for_ca:

; 2530 : 
; 2531 :     return Call(func, args, keywords, vararg, kwarg, func->lineno, func->col_offset, c->c_arena);

  00707	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0070f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00713	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00718	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR func$[rsp]
  00720	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00723	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00727	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR func$[rsp]
  0072f	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00732	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00736	48 8b 44 24 58	 mov	 rax, QWORD PTR kwarg$[rsp]
  0073b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00740	4c 8b 4c 24 70	 mov	 r9, QWORD PTR vararg$[rsp]
  00745	4c 8b 44 24 60	 mov	 r8, QWORD PTR keywords$[rsp]
  0074a	48 8b 54 24 40	 mov	 rdx, QWORD PTR args$[rsp]
  0074f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR func$[rsp]
  00757	e8 00 00 00 00	 call	 _Py_Call
$LN45@ast_for_ca:

; 2532 : }

  0075c	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00763	c3		 ret	 0
ast_for_call ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@FLJFCPEP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA6?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_exprlist DD imagerel ast_for_exprlist
	DD	imagerel ast_for_exprlist+361
	DD	imagerel $unwind$ast_for_exprlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_exprlist DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_1CC@FLJFCPEP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA6?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@FLJFCPEP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA6?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '2'
	DB	00H, '6', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_exprlist
_TEXT	SEGMENT
i$ = 32
seq$ = 40
e$ = 48
_asdl_i$23772 = 56
c$ = 80
n$ = 88
context$ = 96
ast_for_exprlist PROC					; COMDAT

; 2657 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2658 :     asdl_seq *seq;
; 2659 :     int i;
; 2660 :     expr_ty e;
; 2661 : 
; 2662 :     REQ(n, exprlist);

  00013	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00018	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0001b	3d 46 01 00 00	 cmp	 eax, 326		; 00000146H
  00020	74 1c		 je	 SHORT $LN9@ast_for_ex@2
  00022	41 b8 66 0a 00
	00		 mov	 r8d, 2662		; 00000a66H
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@FLJFCPEP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA6?$AA?$CJ?$AA?$AA@
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003c	33 c0		 xor	 eax, eax
$LN9@ast_for_ex@2:

; 2663 : 
; 2664 :     seq = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);

  0003e	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00043	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00046	ff c0		 inc	 eax
  00048	99		 cdq
  00049	2b c2		 sub	 eax, edx
  0004b	d1 f8		 sar	 eax, 1
  0004d	48 98		 cdqe
  0004f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00054	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00058	48 8b c8	 mov	 rcx, rax
  0005b	e8 00 00 00 00	 call	 asdl_seq_new
  00060	48 89 44 24 28	 mov	 QWORD PTR seq$[rsp], rax

; 2665 :     if (!seq)

  00065	48 83 7c 24 28
	00		 cmp	 QWORD PTR seq$[rsp], 0
  0006b	75 07		 jne	 SHORT $LN6@ast_for_ex@2

; 2666 :         return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	e9 f0 00 00 00	 jmp	 $LN7@ast_for_ex@2
$LN6@ast_for_ex@2:

; 2667 :     for (i = 0; i < NCH(n); i += 2) {

  00074	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0007c	eb 0b		 jmp	 SHORT $LN5@ast_for_ex@2
$LN4@ast_for_ex@2:
  0007e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00082	83 c0 02	 add	 eax, 2
  00085	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN5@ast_for_ex@2:
  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0008e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00091	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00095	0f 8d c4 00 00
	00		 jge	 $LN3@ast_for_ex@2

; 2668 :         e = ast_for_expr(c, CHILD(n, i));

  0009b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a0	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR n$[rsp]
  000a9	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000ad	48 8b d0	 mov	 rdx, rax
  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000b5	e8 00 00 00 00	 call	 ast_for_expr
  000ba	48 89 44 24 30	 mov	 QWORD PTR e$[rsp], rax

; 2669 :         if (!e)

  000bf	48 83 7c 24 30
	00		 cmp	 QWORD PTR e$[rsp], 0
  000c5	75 07		 jne	 SHORT $LN2@ast_for_ex@2

; 2670 :             return NULL;

  000c7	33 c0		 xor	 eax, eax
  000c9	e9 96 00 00 00	 jmp	 $LN7@ast_for_ex@2
$LN2@ast_for_ex@2:

; 2671 :         asdl_seq_SET(seq, i / 2, e);

  000ce	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000d2	99		 cdq
  000d3	2b c2		 sub	 eax, edx
  000d5	d1 f8		 sar	 eax, 1
  000d7	89 44 24 38	 mov	 DWORD PTR _asdl_i$23772[rsp], eax
  000db	48 83 7c 24 28
	00		 cmp	 QWORD PTR seq$[rsp], 0
  000e1	74 0f		 je	 SHORT $LN10@ast_for_ex@2
  000e3	48 63 44 24 38	 movsxd	 rax, DWORD PTR _asdl_i$23772[rsp]
  000e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR seq$[rsp]
  000ed	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  000f0	7c 1c		 jl	 SHORT $LN11@ast_for_ex@2
$LN10@ast_for_ex@2:
  000f2	41 b8 6f 0a 00
	00		 mov	 r8d, 2671		; 00000a6fH
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@GCGEEMDH@?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0010c	33 c0		 xor	 eax, eax
$LN11@ast_for_ex@2:
  0010e	48 63 44 24 38	 movsxd	 rax, DWORD PTR _asdl_i$23772[rsp]
  00113	48 8b 4c 24 28	 mov	 rcx, QWORD PTR seq$[rsp]
  00118	48 8b 54 24 30	 mov	 rdx, QWORD PTR e$[rsp]
  0011d	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 2672 :         if (context && !set_context(c, e, context, CHILD(n, i)))

  00122	83 7c 24 60 00	 cmp	 DWORD PTR context$[rsp], 0
  00127	74 31		 je	 SHORT $LN1@ast_for_ex@2
  00129	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0012e	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00132	48 8b 4c 24 58	 mov	 rcx, QWORD PTR n$[rsp]
  00137	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0013b	4c 8b c8	 mov	 r9, rax
  0013e	44 8b 44 24 60	 mov	 r8d, DWORD PTR context$[rsp]
  00143	48 8b 54 24 30	 mov	 rdx, QWORD PTR e$[rsp]
  00148	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0014d	e8 00 00 00 00	 call	 set_context
  00152	85 c0		 test	 eax, eax
  00154	75 04		 jne	 SHORT $LN1@ast_for_ex@2

; 2673 :             return NULL;

  00156	33 c0		 xor	 eax, eax
  00158	eb 0a		 jmp	 SHORT $LN7@ast_for_ex@2
$LN1@ast_for_ex@2:

; 2674 :     }

  0015a	e9 1f ff ff ff	 jmp	 $LN4@ast_for_ex@2
$LN3@ast_for_ex@2:

; 2675 :     return seq;

  0015f	48 8b 44 24 28	 mov	 rax, QWORD PTR seq$[rsp]
$LN7@ast_for_ex@2:

; 2676 : }

  00164	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00168	c3		 ret	 0
ast_for_exprlist ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@PHBALMFF@can?8t?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_06FOBLBEIN@delete?$AA@			; `string'
PUBLIC	??_C@_09PFNDHGIG@assign?5to?$AA@		; `string'
PUBLIC	??_C@_0DB@BFFKDNIK@unexpected?5expression?5in?5assignm@ ; `string'
PUBLIC	??_C@_0BH@JNJLIJED@conditional?5expression?$AA@	; `string'
PUBLIC	??_C@_0L@ECKICNFF@comparison?$AA@		; `string'
PUBLIC	??_C@_08KKBGFFMJ@Ellipsis?$AA@			; `string'
PUBLIC	??_C@_07IDLNMGBF@literal?$AA@			; `string'
PUBLIC	??_C@_0BD@MGEJOJHP@dict?5comprehension?$AA@	; `string'
PUBLIC	??_C@_0BC@GCKMFGBM@set?5comprehension?$AA@	; `string'
PUBLIC	??_C@_0BD@NILJGNIH@list?5comprehension?$AA@	; `string'
PUBLIC	??_C@_0BB@BIJIBHEI@yield?5expression?$AA@	; `string'
PUBLIC	??_C@_0BF@DBHAFLDO@generator?5expression?$AA@	; `string'
PUBLIC	??_C@_08LHJFAFGD@operator?$AA@			; `string'
PUBLIC	??_C@_0O@PKNENLIP@function?5call?$AA@		; `string'
PUBLIC	??_C@_06COJIGPIB@lambda?$AA@			; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
PUBLIC	??_C@_1EE@KMNLIHDK@?$AAc?$AAt?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAS?$AAt?$AAo?$AAr?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAt?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAL?$AAo?$AAa@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$set_context DD imagerel set_context
	DD	imagerel set_context+1216
	DD	imagerel $unwind$set_context
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set_context DD 021b01H
	DD	033011bH
xdata	ENDS
;	COMDAT ??_C@_0M@PHBALMFF@can?8t?5?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0M@PHBALMFF@can?8t?5?$CFs?5?$CFs?$AA@ DB 'can''t %s %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FOBLBEIN@delete?$AA@
CONST	SEGMENT
??_C@_06FOBLBEIN@delete?$AA@ DB 'delete', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09PFNDHGIG@assign?5to?$AA@
CONST	SEGMENT
??_C@_09PFNDHGIG@assign?5to?$AA@ DB 'assign to', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@BFFKDNIK@unexpected?5expression?5in?5assignm@
CONST	SEGMENT
??_C@_0DB@BFFKDNIK@unexpected?5expression?5in?5assignm@ DB 'unexpected ex'
	DB	'pression in assignment %d (line %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JNJLIJED@conditional?5expression?$AA@
CONST	SEGMENT
??_C@_0BH@JNJLIJED@conditional?5expression?$AA@ DB 'conditional expressio'
	DB	'n', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ECKICNFF@comparison?$AA@
CONST	SEGMENT
??_C@_0L@ECKICNFF@comparison?$AA@ DB 'comparison', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KKBGFFMJ@Ellipsis?$AA@
CONST	SEGMENT
??_C@_08KKBGFFMJ@Ellipsis?$AA@ DB 'Ellipsis', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IDLNMGBF@literal?$AA@
CONST	SEGMENT
??_C@_07IDLNMGBF@literal?$AA@ DB 'literal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MGEJOJHP@dict?5comprehension?$AA@
CONST	SEGMENT
??_C@_0BD@MGEJOJHP@dict?5comprehension?$AA@ DB 'dict comprehension', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GCKMFGBM@set?5comprehension?$AA@
CONST	SEGMENT
??_C@_0BC@GCKMFGBM@set?5comprehension?$AA@ DB 'set comprehension', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NILJGNIH@list?5comprehension?$AA@
CONST	SEGMENT
??_C@_0BD@NILJGNIH@list?5comprehension?$AA@ DB 'list comprehension', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BIJIBHEI@yield?5expression?$AA@
CONST	SEGMENT
??_C@_0BB@BIJIBHEI@yield?5expression?$AA@ DB 'yield expression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DBHAFLDO@generator?5expression?$AA@
CONST	SEGMENT
??_C@_0BF@DBHAFLDO@generator?5expression?$AA@ DB 'generator expression', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LHJFAFGD@operator?$AA@
CONST	SEGMENT
??_C@_08LHJFAFGD@operator?$AA@ DB 'operator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PKNENLIP@function?5call?$AA@
CONST	SEGMENT
??_C@_0O@PKNENLIP@function?5call?$AA@ DB 'function call', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06COJIGPIB@lambda?$AA@
CONST	SEGMENT
??_C@_06COJIGPIB@lambda?$AA@ DB 'lambda', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@KMNLIHDK@?$AAc?$AAt?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAS?$AAt?$AAo?$AAr?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAt?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAL?$AAo?$AAa@
CONST	SEGMENT
??_C@_1EE@KMNLIHDK@?$AAc?$AAt?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAS?$AAt?$AAo?$AAr?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAt?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAL?$AAo?$AAa@ DB 'c'
	DB	00H, 't', 00H, 'x', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'A', 00H, 'u', 00H, 'g', 00H, 'S', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, 'e', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'c', 00H
	DB	't', 00H, 'x', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'A'
	DB	00H, 'u', 00H, 'g', 00H, 'L', 00H, 'o', 00H, 'a', 00H, 'd', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT set_context
_TEXT	SEGMENT
s$ = 48
expr_name$ = 56
buf$22532 = 64
i$22537 = 368
tv70 = 372
tv136 = 376
tv151 = 384
tv163 = 392
c$ = 416
e$ = 424
ctx$ = 432
n$ = 440
set_context PROC					; COMDAT

; 874  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H

; 875  :     asdl_seq *s = NULL;

  0001b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR s$[rsp], 0

; 876  :     /* If a particular expression type can't be used for assign / delete,
; 877  :        set expr_name to its name and an error message will be generated.
; 878  :     */
; 879  :     const char* expr_name = NULL;

  00024	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR expr_name$[rsp], 0

; 880  : 
; 881  :     /* The ast defines augmented store and load contexts, but the
; 882  :        implementation here doesn't actually use them.  The code may be
; 883  :        a little more complex than necessary as a result.  It also means
; 884  :        that expressions in an augmented assignment have a Store context.
; 885  :        Consider restructuring so that augmented assignment uses
; 886  :        set_context(), too.
; 887  :     */
; 888  :     assert(ctx != AugStore && ctx != AugLoad);

  0002d	83 bc 24 b0 01
	00 00 05	 cmp	 DWORD PTR ctx$[rsp], 5
  00035	74 0a		 je	 SHORT $LN36@set_contex
  00037	83 bc 24 b0 01
	00 00 04	 cmp	 DWORD PTR ctx$[rsp], 4
  0003f	75 1c		 jne	 SHORT $LN37@set_contex
$LN36@set_contex:
  00041	41 b8 78 03 00
	00		 mov	 r8d, 888		; 00000378H
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@KMNLIHDK@?$AAc?$AAt?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAS?$AAt?$AAo?$AAr?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAc?$AAt?$AAx?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAA?$AAu?$AAg?$AAL?$AAo?$AAa@
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005b	33 c0		 xor	 eax, eax
$LN37@set_contex:

; 889  : 
; 890  :     switch (e->kind) {

  0005d	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00065	8b 00		 mov	 eax, DWORD PTR [rax]
  00067	89 84 24 74 01
	00 00		 mov	 DWORD PTR tv70[rsp], eax
  0006e	8b 84 24 74 01
	00 00		 mov	 eax, DWORD PTR tv70[rsp]
  00075	ff c8		 dec	 eax
  00077	89 84 24 74 01
	00 00		 mov	 DWORD PTR tv70[rsp], eax
  0007e	83 bc 24 74 01
	00 00 18	 cmp	 DWORD PTR tv70[rsp], 24
  00086	0f 87 7a 02 00
	00		 ja	 $LN7@set_contex
  0008c	48 63 84 24 74
	01 00 00	 movsxd	 rax, DWORD PTR tv70[rsp]
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0009b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN44@set_contex[rcx+rax*4]
  000a2	48 03 c1	 add	 rax, rcx
  000a5	ff e0		 jmp	 rax
$LN31@set_contex:

; 891  :         case Attribute_kind:
; 892  :             e->v.Attribute.ctx = ctx;

  000a7	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  000af	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR ctx$[rsp]
  000b6	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 893  :             if (ctx == Store && forbidden_name(c, e->v.Attribute.attr, n, 1))

  000b9	83 bc 24 b0 01
	00 00 02	 cmp	 DWORD PTR ctx$[rsp], 2
  000c1	75 32		 jne	 SHORT $LN30@set_contex
  000c3	41 b9 01 00 00
	00		 mov	 r9d, 1
  000c9	4c 8b 84 24 b8
	01 00 00	 mov	 r8, QWORD PTR n$[rsp]
  000d1	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  000d9	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000dd	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000e5	e8 00 00 00 00	 call	 forbidden_name
  000ea	85 c0		 test	 eax, eax
  000ec	74 07		 je	 SHORT $LN30@set_contex

; 894  :                 return 0;

  000ee	33 c0		 xor	 eax, eax
  000f0	e9 5d 03 00 00	 jmp	 $LN34@set_contex
$LN30@set_contex:

; 895  :             break;

  000f5	e9 3d 02 00 00	 jmp	 $LN32@set_contex
$LN29@set_contex:

; 896  :         case Subscript_kind:
; 897  :             e->v.Subscript.ctx = ctx;

  000fa	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00102	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR ctx$[rsp]
  00109	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 898  :             break;

  0010c	e9 26 02 00 00	 jmp	 $LN32@set_contex
$LN28@set_contex:

; 899  :         case Starred_kind:
; 900  :             e->v.Starred.ctx = ctx;

  00111	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00119	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR ctx$[rsp]
  00120	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 901  :             if (!set_context(c, e->v.Starred.value, ctx, n))

  00123	4c 8b 8c 24 b8
	01 00 00	 mov	 r9, QWORD PTR n$[rsp]
  0012b	44 8b 84 24 b0
	01 00 00	 mov	 r8d, DWORD PTR ctx$[rsp]
  00133	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0013b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0013f	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00147	e8 00 00 00 00	 call	 set_context
  0014c	85 c0		 test	 eax, eax
  0014e	75 07		 jne	 SHORT $LN27@set_contex

; 902  :                 return 0;

  00150	33 c0		 xor	 eax, eax
  00152	e9 fb 02 00 00	 jmp	 $LN34@set_contex
$LN27@set_contex:

; 903  :             break;

  00157	e9 db 01 00 00	 jmp	 $LN32@set_contex
$LN26@set_contex:

; 904  :         case Name_kind:
; 905  :             if (ctx == Store) {

  0015c	83 bc 24 b0 01
	00 00 02	 cmp	 DWORD PTR ctx$[rsp], 2
  00164	75 32		 jne	 SHORT $LN25@set_contex

; 906  :                 if (forbidden_name(c, e->v.Name.id, n, 1))

  00166	41 b9 01 00 00
	00		 mov	 r9d, 1
  0016c	4c 8b 84 24 b8
	01 00 00	 mov	 r8, QWORD PTR n$[rsp]
  00174	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0017c	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00180	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00188	e8 00 00 00 00	 call	 forbidden_name
  0018d	85 c0		 test	 eax, eax
  0018f	74 07		 je	 SHORT $LN24@set_contex

; 907  :                     return 0; /* forbidden_name() calls ast_error() */

  00191	33 c0		 xor	 eax, eax
  00193	e9 ba 02 00 00	 jmp	 $LN34@set_contex
$LN24@set_contex:
$LN25@set_contex:

; 908  :             }
; 909  :             e->v.Name.ctx = ctx;

  00198	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  001a0	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR ctx$[rsp]
  001a7	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 910  :             break;

  001aa	e9 88 01 00 00	 jmp	 $LN32@set_contex
$LN23@set_contex:

; 911  :         case List_kind:
; 912  :             e->v.List.ctx = ctx;

  001af	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  001b7	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR ctx$[rsp]
  001be	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 913  :             s = e->v.List.elts;

  001c1	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  001c9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001cd	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 914  :             break;

  001d2	e9 60 01 00 00	 jmp	 $LN32@set_contex
$LN22@set_contex:

; 915  :         case Tuple_kind:
; 916  :             if (asdl_seq_LEN(e->v.Tuple.elts))  {

  001d7	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  001df	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  001e4	75 0e		 jne	 SHORT $LN38@set_contex
  001e6	48 c7 84 24 78
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv136[rsp], 0
  001f2	eb 17		 jmp	 SHORT $LN39@set_contex
$LN38@set_contex:
  001f4	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  001fc	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00200	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00203	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv136[rsp], rax
$LN39@set_contex:
  0020b	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR tv136[rsp], 0
  00214	74 25		 je	 SHORT $LN21@set_contex

; 917  :                 e->v.Tuple.ctx = ctx;

  00216	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0021e	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR ctx$[rsp]
  00225	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 918  :                 s = e->v.Tuple.elts;

  00228	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  00230	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00234	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 919  :             }
; 920  :             else {

  00239	eb 0c		 jmp	 SHORT $LN20@set_contex
$LN21@set_contex:

; 921  :                 expr_name = "()";

  0023b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00242	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax
$LN20@set_contex:

; 922  :             }
; 923  :             break;

  00247	e9 eb 00 00 00	 jmp	 $LN32@set_contex
$LN19@set_contex:

; 924  :         case Lambda_kind:
; 925  :             expr_name = "lambda";

  0024c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06COJIGPIB@lambda?$AA@
  00253	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 926  :             break;

  00258	e9 da 00 00 00	 jmp	 $LN32@set_contex
$LN18@set_contex:

; 927  :         case Call_kind:
; 928  :             expr_name = "function call";

  0025d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@PKNENLIP@function?5call?$AA@
  00264	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 929  :             break;

  00269	e9 c9 00 00 00	 jmp	 $LN32@set_contex
$LN17@set_contex:

; 930  :         case BoolOp_kind:
; 931  :         case BinOp_kind:
; 932  :         case UnaryOp_kind:
; 933  :             expr_name = "operator";

  0026e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08LHJFAFGD@operator?$AA@
  00275	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 934  :             break;

  0027a	e9 b8 00 00 00	 jmp	 $LN32@set_contex
$LN16@set_contex:

; 935  :         case GeneratorExp_kind:
; 936  :             expr_name = "generator expression";

  0027f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@DBHAFLDO@generator?5expression?$AA@
  00286	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 937  :             break;

  0028b	e9 a7 00 00 00	 jmp	 $LN32@set_contex
$LN15@set_contex:

; 938  :         case Yield_kind:
; 939  :         case YieldFrom_kind:
; 940  :             expr_name = "yield expression";

  00290	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@BIJIBHEI@yield?5expression?$AA@
  00297	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 941  :             break;

  0029c	e9 96 00 00 00	 jmp	 $LN32@set_contex
$LN14@set_contex:

; 942  :         case ListComp_kind:
; 943  :             expr_name = "list comprehension";

  002a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@NILJGNIH@list?5comprehension?$AA@
  002a8	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 944  :             break;

  002ad	e9 85 00 00 00	 jmp	 $LN32@set_contex
$LN13@set_contex:

; 945  :         case SetComp_kind:
; 946  :             expr_name = "set comprehension";

  002b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@GCKMFGBM@set?5comprehension?$AA@
  002b9	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 947  :             break;

  002be	eb 77		 jmp	 SHORT $LN32@set_contex
$LN12@set_contex:

; 948  :         case DictComp_kind:
; 949  :             expr_name = "dict comprehension";

  002c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@MGEJOJHP@dict?5comprehension?$AA@
  002c7	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 950  :             break;

  002cc	eb 69		 jmp	 SHORT $LN32@set_contex
$LN11@set_contex:

; 951  :         case Dict_kind:
; 952  :         case Set_kind:
; 953  :         case Num_kind:
; 954  :         case Str_kind:
; 955  :         case Bytes_kind:
; 956  :             expr_name = "literal";

  002ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07IDLNMGBF@literal?$AA@
  002d5	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 957  :             break;

  002da	eb 5b		 jmp	 SHORT $LN32@set_contex
$LN10@set_contex:

; 958  :         case Ellipsis_kind:
; 959  :             expr_name = "Ellipsis";

  002dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08KKBGFFMJ@Ellipsis?$AA@
  002e3	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 960  :             break;

  002e8	eb 4d		 jmp	 SHORT $LN32@set_contex
$LN9@set_contex:

; 961  :         case Compare_kind:
; 962  :             expr_name = "comparison";

  002ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0L@ECKICNFF@comparison?$AA@
  002f1	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 963  :             break;

  002f6	eb 3f		 jmp	 SHORT $LN32@set_contex
$LN8@set_contex:

; 964  :         case IfExp_kind:
; 965  :             expr_name = "conditional expression";

  002f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@JNJLIJED@conditional?5expression?$AA@
  002ff	48 89 44 24 38	 mov	 QWORD PTR expr_name$[rsp], rax

; 966  :             break;

  00304	eb 31		 jmp	 SHORT $LN32@set_contex
$LN7@set_contex:

; 967  :         default:
; 968  :             PyErr_Format(PyExc_SystemError,
; 969  :                          "unexpected expression in assignment %d (line %d)",
; 970  :                          e->kind, e->lineno);

  00306	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0030e	44 8b 48 30	 mov	 r9d, DWORD PTR [rax+48]
  00312	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR e$[rsp]
  0031a	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0031d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@BFFKDNIK@unexpected?5expression?5in?5assignm@
  00324	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0032b	e8 00 00 00 00	 call	 PyErr_Format

; 971  :             return 0;

  00330	33 c0		 xor	 eax, eax
  00332	e9 1b 01 00 00	 jmp	 $LN34@set_contex
$LN32@set_contex:

; 972  :     }
; 973  :     /* Check for error string set by switch */
; 974  :     if (expr_name) {

  00337	48 83 7c 24 38
	00		 cmp	 QWORD PTR expr_name$[rsp], 0
  0033d	74 71		 je	 SHORT $LN6@set_contex

; 975  :         char buf[300];
; 976  :         PyOS_snprintf(buf, sizeof(buf),
; 977  :                       "can't %s %s",
; 978  :                       ctx == Store ? "assign to" : "delete",
; 979  :                       expr_name);

  0033f	83 bc 24 b0 01
	00 00 02	 cmp	 DWORD PTR ctx$[rsp], 2
  00347	75 11		 jne	 SHORT $LN40@set_contex
  00349	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_09PFNDHGIG@assign?5to?$AA@
  00350	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv151[rsp], rax
  00358	eb 0f		 jmp	 SHORT $LN41@set_contex
$LN40@set_contex:
  0035a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06FOBLBEIN@delete?$AA@
  00361	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv151[rsp], rax
$LN41@set_contex:
  00369	48 8b 44 24 38	 mov	 rax, QWORD PTR expr_name$[rsp]
  0036e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00373	4c 8b 8c 24 80
	01 00 00	 mov	 r9, QWORD PTR tv151[rsp]
  0037b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@PHBALMFF@can?8t?5?$CFs?5?$CFs?$AA@
  00382	ba 2c 01 00 00	 mov	 edx, 300		; 0000012cH
  00387	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$22532[rsp]
  0038c	e8 00 00 00 00	 call	 PyOS_snprintf

; 980  :         return ast_error(c, n, buf);

  00391	4c 8d 44 24 40	 lea	 r8, QWORD PTR buf$22532[rsp]
  00396	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  0039e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  003a6	e8 00 00 00 00	 call	 ast_error
  003ab	e9 a2 00 00 00	 jmp	 $LN34@set_contex
$LN6@set_contex:

; 981  :     }
; 982  : 
; 983  :     /* If the LHS is a list or tuple, we need to set the assignment
; 984  :        context for all the contained elements.
; 985  :     */
; 986  :     if (s) {

  003b0	48 83 7c 24 30
	00		 cmp	 QWORD PTR s$[rsp], 0
  003b6	0f 84 91 00 00
	00		 je	 $LN5@set_contex

; 987  :         int i;
; 988  : 
; 989  :         for (i = 0; i < asdl_seq_LEN(s); i++) {

  003bc	c7 84 24 70 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$22537[rsp], 0
  003c7	eb 10		 jmp	 SHORT $LN4@set_contex
$LN3@set_contex:
  003c9	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR i$22537[rsp]
  003d0	ff c0		 inc	 eax
  003d2	89 84 24 70 01
	00 00		 mov	 DWORD PTR i$22537[rsp], eax
$LN4@set_contex:
  003d9	48 83 7c 24 30
	00		 cmp	 QWORD PTR s$[rsp], 0
  003df	75 0e		 jne	 SHORT $LN42@set_contex
  003e1	48 c7 84 24 88
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv163[rsp], 0
  003ed	eb 10		 jmp	 SHORT $LN43@set_contex
$LN42@set_contex:
  003ef	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  003f4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003f7	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv163[rsp], rax
$LN43@set_contex:
  003ff	48 63 84 24 70
	01 00 00	 movsxd	 rax, DWORD PTR i$22537[rsp]
  00407	48 3b 84 24 88
	01 00 00	 cmp	 rax, QWORD PTR tv163[rsp]
  0040f	7d 3c		 jge	 SHORT $LN2@set_contex

; 990  :             if (!set_context(c, (expr_ty)asdl_seq_GET(s, i), ctx, n))

  00411	48 63 84 24 70
	01 00 00	 movsxd	 rax, DWORD PTR i$22537[rsp]
  00419	4c 8b 8c 24 b8
	01 00 00	 mov	 r9, QWORD PTR n$[rsp]
  00421	44 8b 84 24 b0
	01 00 00	 mov	 r8d, DWORD PTR ctx$[rsp]
  00429	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0042e	48 8b 54 c1 08	 mov	 rdx, QWORD PTR [rcx+rax*8+8]
  00433	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0043b	e8 00 00 00 00	 call	 set_context
  00440	85 c0		 test	 eax, eax
  00442	75 04		 jne	 SHORT $LN1@set_contex

; 991  :                 return 0;

  00444	33 c0		 xor	 eax, eax
  00446	eb 0a		 jmp	 SHORT $LN34@set_contex
$LN1@set_contex:

; 992  :         }

  00448	e9 7c ff ff ff	 jmp	 $LN3@set_contex
$LN2@set_contex:
$LN5@set_contex:

; 993  :     }
; 994  :     return 1;

  0044d	b8 01 00 00 00	 mov	 eax, 1
$LN34@set_contex:

; 995  : }

  00452	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00459	c3		 ret	 0
  0045a	66 90		 npad	 2
$LN44@set_contex:
  0045c	00 00 00 00	 DD	 $LN17@set_contex
  00460	00 00 00 00	 DD	 $LN17@set_contex
  00464	00 00 00 00	 DD	 $LN17@set_contex
  00468	00 00 00 00	 DD	 $LN19@set_contex
  0046c	00 00 00 00	 DD	 $LN8@set_contex
  00470	00 00 00 00	 DD	 $LN11@set_contex
  00474	00 00 00 00	 DD	 $LN11@set_contex
  00478	00 00 00 00	 DD	 $LN14@set_contex
  0047c	00 00 00 00	 DD	 $LN13@set_contex
  00480	00 00 00 00	 DD	 $LN12@set_contex
  00484	00 00 00 00	 DD	 $LN16@set_contex
  00488	00 00 00 00	 DD	 $LN15@set_contex
  0048c	00 00 00 00	 DD	 $LN15@set_contex
  00490	00 00 00 00	 DD	 $LN9@set_contex
  00494	00 00 00 00	 DD	 $LN18@set_contex
  00498	00 00 00 00	 DD	 $LN11@set_contex
  0049c	00 00 00 00	 DD	 $LN11@set_contex
  004a0	00 00 00 00	 DD	 $LN11@set_contex
  004a4	00 00 00 00	 DD	 $LN10@set_contex
  004a8	00 00 00 00	 DD	 $LN31@set_contex
  004ac	00 00 00 00	 DD	 $LN29@set_contex
  004b0	00 00 00 00	 DD	 $LN28@set_contex
  004b4	00 00 00 00	 DD	 $LN26@set_contex
  004b8	00 00 00 00	 DD	 $LN23@set_contex
  004bc	00 00 00 00	 DD	 $LN22@set_contex
set_context ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@LJPAMJJE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA3?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CG@HBPFDBNP@unhandled?5small_stmt?3?5TYPE?$DN?$CFd?5NC@ ; `string'
PUBLIC	??_C@_1CE@NJDHFEJP@?$AAn?$AAu?$AAm?$AA_?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@KHOOLNAB@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_stmt DD imagerel ast_for_stmt
	DD	imagerel ast_for_stmt+989
	DD	imagerel $unwind$ast_for_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_stmt DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1CC@LJPAMJJE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA3?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@LJPAMJJE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA3?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '9'
	DB	00H, '3', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HBPFDBNP@unhandled?5small_stmt?3?5TYPE?$DN?$CFd?5NC@
CONST	SEGMENT
??_C@_0CG@HBPFDBNP@unhandled?5small_stmt?3?5TYPE?$DN?$CFd?5NC@ DB 'unhand'
	DB	'led small_stmt: TYPE=%d NCH=%d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@NJDHFEJP@?$AAn?$AAu?$AAm?$AA_?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@NJDHFEJP@?$AAn?$AAu?$AAm?$AA_?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'n'
	DB	00H, 'u', 00H, 'm', 00H, '_', 00H, 's', 00H, 't', 00H, 'm', 00H
	DB	't', 00H, 's', 00H, '(', 00H, 'n', 00H, ')', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@KHOOLNAB@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@KHOOLNAB@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'N'
	DB	00H, 'C', 00H, 'H', 00H, '(', 00H, 'n', 00H, ')', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_stmt
_TEXT	SEGMENT
ch$24458 = 32
tv87 = 40
tv164 = 44
c$ = 64
n$ = 72
ast_for_stmt PROC					; COMDAT

; 3551 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3552 :     if (TYPE(n) == stmt) {

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 0c 01 00 00	 cmp	 eax, 268		; 0000010cH
  0001b	75 35		 jne	 SHORT $LN26@ast_for_st@2

; 3553 :         assert(NCH(n) == 1);

  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00022	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00026	74 1c		 je	 SHORT $LN29@ast_for_st@2
  00028	41 b8 e1 0d 00
	00		 mov	 r8d, 3553		; 00000de1H
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@KHOOLNAB@?$AAN?$AAC?$AAH?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00042	33 c0		 xor	 eax, eax
$LN29@ast_for_st@2:

; 3554 :         n = CHILD(n, 0);

  00044	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00049	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004d	48 89 44 24 48	 mov	 QWORD PTR n$[rsp], rax
$LN26@ast_for_st@2:

; 3555 :     }
; 3556 :     if (TYPE(n) == simple_stmt) {

  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00057	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0005a	3d 0d 01 00 00	 cmp	 eax, 269		; 0000010dH
  0005f	75 39		 jne	 SHORT $LN25@ast_for_st@2

; 3557 :         assert(num_stmts(n) == 1);

  00061	48 8b 4c 24 48	 mov	 rcx, QWORD PTR n$[rsp]
  00066	e8 00 00 00 00	 call	 num_stmts
  0006b	83 f8 01	 cmp	 eax, 1
  0006e	74 1c		 je	 SHORT $LN30@ast_for_st@2
  00070	41 b8 e5 0d 00
	00		 mov	 r8d, 3557		; 00000de5H
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@NJDHFEJP@?$AAn?$AAu?$AAm?$AA_?$AAs?$AAt?$AAm?$AAt?$AAs?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008a	33 c0		 xor	 eax, eax
$LN30@ast_for_st@2:

; 3558 :         n = CHILD(n, 0);

  0008c	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00091	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00095	48 89 44 24 48	 mov	 QWORD PTR n$[rsp], rax
$LN25@ast_for_st@2:

; 3559 :     }
; 3560 :     if (TYPE(n) == small_stmt) {

  0009a	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0009f	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000a2	3d 0e 01 00 00	 cmp	 eax, 270		; 0000010eH
  000a7	0f 85 2c 01 00
	00		 jne	 $LN24@ast_for_st@2

; 3561 :         n = CHILD(n, 0);

  000ad	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000b2	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000b6	48 89 44 24 48	 mov	 QWORD PTR n$[rsp], rax

; 3562 :         /* small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt
; 3563 :                   | import_stmt | global_stmt | nonlocal_stmt | assert_stmt
; 3564 :         */
; 3565 :         switch (TYPE(n)) {

  000bb	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000c0	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000c3	89 44 24 28	 mov	 DWORD PTR tv87[rsp], eax
  000c7	8b 44 24 28	 mov	 eax, DWORD PTR tv87[rsp]
  000cb	2d 0f 01 00 00	 sub	 eax, 271		; 0000010fH
  000d0	89 44 24 28	 mov	 DWORD PTR tv87[rsp], eax
  000d4	83 7c 24 28 15	 cmp	 DWORD PTR tv87[rsp], 21
  000d9	0f 87 c7 00 00
	00		 ja	 $LN13@ast_for_st@2
  000df	48 63 44 24 28	 movsxd	 rax, DWORD PTR tv87[rsp]
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000eb	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN34@ast_for_st@2[rcx+rax*4]
  000f2	48 03 c1	 add	 rax, rcx
  000f5	ff e0		 jmp	 rax
$LN21@ast_for_st@2:

; 3566 :             case expr_stmt:
; 3567 :                 return ast_for_expr_stmt(c, n);

  000f7	48 8b 54 24 48	 mov	 rdx, QWORD PTR n$[rsp]
  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00101	e8 00 00 00 00	 call	 ast_for_expr_stmt
  00106	e9 0b 02 00 00	 jmp	 $LN27@ast_for_st@2
$LN20@ast_for_st@2:

; 3568 :             case del_stmt:
; 3569 :                 return ast_for_del_stmt(c, n);

  0010b	48 8b 54 24 48	 mov	 rdx, QWORD PTR n$[rsp]
  00110	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00115	e8 00 00 00 00	 call	 ast_for_del_stmt
  0011a	e9 f7 01 00 00	 jmp	 $LN27@ast_for_st@2
$LN19@ast_for_st@2:

; 3570 :             case pass_stmt:
; 3571 :                 return Pass(LINENO(n), n->n_col_offset, c->c_arena);

  0011f	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  00124	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00128	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0012d	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  00130	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00135	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00138	e8 00 00 00 00	 call	 _Py_Pass
  0013d	e9 d4 01 00 00	 jmp	 $LN27@ast_for_st@2
$LN18@ast_for_st@2:

; 3572 :             case flow_stmt:
; 3573 :                 return ast_for_flow_stmt(c, n);

  00142	48 8b 54 24 48	 mov	 rdx, QWORD PTR n$[rsp]
  00147	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0014c	e8 00 00 00 00	 call	 ast_for_flow_stmt
  00151	e9 c0 01 00 00	 jmp	 $LN27@ast_for_st@2
$LN17@ast_for_st@2:

; 3574 :             case import_stmt:
; 3575 :                 return ast_for_import_stmt(c, n);

  00156	48 8b 54 24 48	 mov	 rdx, QWORD PTR n$[rsp]
  0015b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00160	e8 00 00 00 00	 call	 ast_for_import_stmt
  00165	e9 ac 01 00 00	 jmp	 $LN27@ast_for_st@2
$LN16@ast_for_st@2:

; 3576 :             case global_stmt:
; 3577 :                 return ast_for_global_stmt(c, n);

  0016a	48 8b 54 24 48	 mov	 rdx, QWORD PTR n$[rsp]
  0016f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00174	e8 00 00 00 00	 call	 ast_for_global_stmt
  00179	e9 98 01 00 00	 jmp	 $LN27@ast_for_st@2
$LN15@ast_for_st@2:

; 3578 :             case nonlocal_stmt:
; 3579 :                 return ast_for_nonlocal_stmt(c, n);

  0017e	48 8b 54 24 48	 mov	 rdx, QWORD PTR n$[rsp]
  00183	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00188	e8 00 00 00 00	 call	 ast_for_nonlocal_stmt
  0018d	e9 84 01 00 00	 jmp	 $LN27@ast_for_st@2
$LN14@ast_for_st@2:

; 3580 :             case assert_stmt:
; 3581 :                 return ast_for_assert_stmt(c, n);

  00192	48 8b 54 24 48	 mov	 rdx, QWORD PTR n$[rsp]
  00197	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0019c	e8 00 00 00 00	 call	 ast_for_assert_stmt
  001a1	e9 70 01 00 00	 jmp	 $LN27@ast_for_st@2
$LN13@ast_for_st@2:

; 3582 :             default:
; 3583 :                 PyErr_Format(PyExc_SystemError,
; 3584 :                              "unhandled small_stmt: TYPE=%d NCH=%d\n",
; 3585 :                              TYPE(n), NCH(n));

  001a6	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  001ab	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR n$[rsp]
  001b3	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  001b7	44 8b c0	 mov	 r8d, eax
  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@HBPFDBNP@unhandled?5small_stmt?3?5TYPE?$DN?$CFd?5NC@
  001c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  001c8	e8 00 00 00 00	 call	 PyErr_Format

; 3586 :                 return NULL;

  001cd	33 c0		 xor	 eax, eax
  001cf	e9 42 01 00 00	 jmp	 $LN27@ast_for_st@2

; 3587 :         }
; 3588 :     }
; 3589 :     else {

  001d4	e9 3d 01 00 00	 jmp	 $LN12@ast_for_st@2
$LN24@ast_for_st@2:

; 3590 :         /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt
; 3591 :                         | funcdef | classdef | decorated
; 3592 :         */
; 3593 :         node *ch = CHILD(n, 0);

  001d9	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  001de	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001e2	48 89 44 24 20	 mov	 QWORD PTR ch$24458[rsp], rax

; 3594 :         REQ(n, compound_stmt);

  001e7	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  001ec	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001ef	3d 25 01 00 00	 cmp	 eax, 293		; 00000125H
  001f4	74 1c		 je	 SHORT $LN31@ast_for_st@2
  001f6	41 b8 0a 0e 00
	00		 mov	 r8d, 3594		; 00000e0aH
  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@LJPAMJJE@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA3?$AA?$CJ?$AA?$AA@
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00210	33 c0		 xor	 eax, eax
$LN31@ast_for_st@2:

; 3595 :         switch (TYPE(ch)) {

  00212	48 8b 44 24 20	 mov	 rax, QWORD PTR ch$24458[rsp]
  00217	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0021a	89 44 24 2c	 mov	 DWORD PTR tv164[rsp], eax
  0021e	8b 44 24 2c	 mov	 eax, DWORD PTR tv164[rsp]
  00222	2d 05 01 00 00	 sub	 eax, 261		; 00000105H
  00227	89 44 24 2c	 mov	 DWORD PTR tv164[rsp], eax
  0022b	83 7c 24 2c 44	 cmp	 DWORD PTR tv164[rsp], 68 ; 00000044H
  00230	0f 87 b7 00 00
	00		 ja	 $LN1@ast_for_st@2
  00236	48 63 44 24 2c	 movsxd	 rax, DWORD PTR tv164[rsp]
  0023b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00242	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN32@ast_for_st@2[rcx+rax]
  0024a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN33@ast_for_st@2[rcx+rax*4]
  00251	48 03 c1	 add	 rax, rcx
  00254	ff e0		 jmp	 rax
$LN9@ast_for_st@2:

; 3596 :             case if_stmt:
; 3597 :                 return ast_for_if_stmt(c, ch);

  00256	48 8b 54 24 20	 mov	 rdx, QWORD PTR ch$24458[rsp]
  0025b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00260	e8 00 00 00 00	 call	 ast_for_if_stmt
  00265	e9 ac 00 00 00	 jmp	 $LN27@ast_for_st@2
$LN8@ast_for_st@2:

; 3598 :             case while_stmt:
; 3599 :                 return ast_for_while_stmt(c, ch);

  0026a	48 8b 54 24 20	 mov	 rdx, QWORD PTR ch$24458[rsp]
  0026f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00274	e8 00 00 00 00	 call	 ast_for_while_stmt
  00279	e9 98 00 00 00	 jmp	 $LN27@ast_for_st@2
$LN7@ast_for_st@2:

; 3600 :             case for_stmt:
; 3601 :                 return ast_for_for_stmt(c, ch);

  0027e	48 8b 54 24 20	 mov	 rdx, QWORD PTR ch$24458[rsp]
  00283	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00288	e8 00 00 00 00	 call	 ast_for_for_stmt
  0028d	e9 84 00 00 00	 jmp	 $LN27@ast_for_st@2
$LN6@ast_for_st@2:

; 3602 :             case try_stmt:
; 3603 :                 return ast_for_try_stmt(c, ch);

  00292	48 8b 54 24 20	 mov	 rdx, QWORD PTR ch$24458[rsp]
  00297	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0029c	e8 00 00 00 00	 call	 ast_for_try_stmt
  002a1	eb 73		 jmp	 SHORT $LN27@ast_for_st@2
$LN5@ast_for_st@2:

; 3604 :             case with_stmt:
; 3605 :                 return ast_for_with_stmt(c, ch);

  002a3	48 8b 54 24 20	 mov	 rdx, QWORD PTR ch$24458[rsp]
  002a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  002ad	e8 00 00 00 00	 call	 ast_for_with_stmt
  002b2	eb 62		 jmp	 SHORT $LN27@ast_for_st@2
$LN4@ast_for_st@2:

; 3606 :             case funcdef:
; 3607 :                 return ast_for_funcdef(c, ch, NULL);

  002b4	45 33 c0	 xor	 r8d, r8d
  002b7	48 8b 54 24 20	 mov	 rdx, QWORD PTR ch$24458[rsp]
  002bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  002c1	e8 00 00 00 00	 call	 ast_for_funcdef
  002c6	eb 4e		 jmp	 SHORT $LN27@ast_for_st@2
$LN3@ast_for_st@2:

; 3608 :             case classdef:
; 3609 :                 return ast_for_classdef(c, ch, NULL);

  002c8	45 33 c0	 xor	 r8d, r8d
  002cb	48 8b 54 24 20	 mov	 rdx, QWORD PTR ch$24458[rsp]
  002d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  002d5	e8 00 00 00 00	 call	 ast_for_classdef
  002da	eb 3a		 jmp	 SHORT $LN27@ast_for_st@2
$LN2@ast_for_st@2:

; 3610 :             case decorated:
; 3611 :                 return ast_for_decorated(c, ch);

  002dc	48 8b 54 24 20	 mov	 rdx, QWORD PTR ch$24458[rsp]
  002e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  002e6	e8 00 00 00 00	 call	 ast_for_decorated
  002eb	eb 29		 jmp	 SHORT $LN27@ast_for_st@2
$LN1@ast_for_st@2:

; 3612 :             default:
; 3613 :                 PyErr_Format(PyExc_SystemError,
; 3614 :                              "unhandled small_stmt: TYPE=%d NCH=%d\n",
; 3615 :                              TYPE(n), NCH(n));

  002ed	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  002f2	0f bf 00	 movsx	 eax, WORD PTR [rax]
  002f5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR n$[rsp]
  002fa	44 8b 49 18	 mov	 r9d, DWORD PTR [rcx+24]
  002fe	44 8b c0	 mov	 r8d, eax
  00301	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@HBPFDBNP@unhandled?5small_stmt?3?5TYPE?$DN?$CFd?5NC@
  00308	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0030f	e8 00 00 00 00	 call	 PyErr_Format

; 3616 :                 return NULL;

  00314	33 c0		 xor	 eax, eax
$LN12@ast_for_st@2:
$LN27@ast_for_st@2:

; 3617 :         }
; 3618 :     }
; 3619 : }

  00316	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0031a	c3		 ret	 0
  0031b	90		 npad	 1
$LN34@ast_for_st@2:
  0031c	00 00 00 00	 DD	 $LN21@ast_for_st@2
  00320	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00324	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00328	00 00 00 00	 DD	 $LN20@ast_for_st@2
  0032c	00 00 00 00	 DD	 $LN19@ast_for_st@2
  00330	00 00 00 00	 DD	 $LN18@ast_for_st@2
  00334	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00338	00 00 00 00	 DD	 $LN13@ast_for_st@2
  0033c	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00340	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00344	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00348	00 00 00 00	 DD	 $LN17@ast_for_st@2
  0034c	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00350	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00354	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00358	00 00 00 00	 DD	 $LN13@ast_for_st@2
  0035c	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00360	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00364	00 00 00 00	 DD	 $LN13@ast_for_st@2
  00368	00 00 00 00	 DD	 $LN16@ast_for_st@2
  0036c	00 00 00 00	 DD	 $LN15@ast_for_st@2
  00370	00 00 00 00	 DD	 $LN14@ast_for_st@2
$LN33@ast_for_st@2:
  00374	00 00 00 00	 DD	 $LN2@ast_for_st@2
  00378	00 00 00 00	 DD	 $LN4@ast_for_st@2
  0037c	00 00 00 00	 DD	 $LN9@ast_for_st@2
  00380	00 00 00 00	 DD	 $LN8@ast_for_st@2
  00384	00 00 00 00	 DD	 $LN7@ast_for_st@2
  00388	00 00 00 00	 DD	 $LN6@ast_for_st@2
  0038c	00 00 00 00	 DD	 $LN5@ast_for_st@2
  00390	00 00 00 00	 DD	 $LN3@ast_for_st@2
  00394	00 00 00 00	 DD	 $LN1@ast_for_st@2
$LN32@ast_for_st@2:
  00398	00		 DB	 0
  00399	01		 DB	 1
  0039a	08		 DB	 8
  0039b	08		 DB	 8
  0039c	08		 DB	 8
  0039d	08		 DB	 8
  0039e	08		 DB	 8
  0039f	08		 DB	 8
  003a0	08		 DB	 8
  003a1	08		 DB	 8
  003a2	08		 DB	 8
  003a3	08		 DB	 8
  003a4	08		 DB	 8
  003a5	08		 DB	 8
  003a6	08		 DB	 8
  003a7	08		 DB	 8
  003a8	08		 DB	 8
  003a9	08		 DB	 8
  003aa	08		 DB	 8
  003ab	08		 DB	 8
  003ac	08		 DB	 8
  003ad	08		 DB	 8
  003ae	08		 DB	 8
  003af	08		 DB	 8
  003b0	08		 DB	 8
  003b1	08		 DB	 8
  003b2	08		 DB	 8
  003b3	08		 DB	 8
  003b4	08		 DB	 8
  003b5	08		 DB	 8
  003b6	08		 DB	 8
  003b7	08		 DB	 8
  003b8	08		 DB	 8
  003b9	02		 DB	 2
  003ba	03		 DB	 3
  003bb	04		 DB	 4
  003bc	05		 DB	 5
  003bd	06		 DB	 6
  003be	08		 DB	 8
  003bf	08		 DB	 8
  003c0	08		 DB	 8
  003c1	08		 DB	 8
  003c2	08		 DB	 8
  003c3	08		 DB	 8
  003c4	08		 DB	 8
  003c5	08		 DB	 8
  003c6	08		 DB	 8
  003c7	08		 DB	 8
  003c8	08		 DB	 8
  003c9	08		 DB	 8
  003ca	08		 DB	 8
  003cb	08		 DB	 8
  003cc	08		 DB	 8
  003cd	08		 DB	 8
  003ce	08		 DB	 8
  003cf	08		 DB	 8
  003d0	08		 DB	 8
  003d1	08		 DB	 8
  003d2	08		 DB	 8
  003d3	08		 DB	 8
  003d4	08		 DB	 8
  003d5	08		 DB	 8
  003d6	08		 DB	 8
  003d7	08		 DB	 8
  003d8	08		 DB	 8
  003d9	08		 DB	 8
  003da	08		 DB	 8
  003db	08		 DB	 8
  003dc	07		 DB	 7
ast_for_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@KLIMAIJN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA2?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_FunctionDef:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_funcdef DD imagerel ast_for_funcdef
	DD	imagerel ast_for_funcdef+511
	DD	imagerel $unwind$ast_for_funcdef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_funcdef DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_1CC@KLIMAIJN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA2?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@KLIMAIJN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA2?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '6'
	DB	00H, '2', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_funcdef
_TEXT	SEGMENT
args$ = 64
name$ = 72
returns$ = 80
body$ = 88
name_i$ = 96
c$ = 128
n$ = 136
decorator_seq$ = 144
ast_for_funcdef PROC					; COMDAT

; 1487 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1488 :     /* funcdef: 'def' NAME parameters ['->' test] ':' suite */
; 1489 :     identifier name;
; 1490 :     arguments_ty args;
; 1491 :     asdl_seq *body;
; 1492 :     expr_ty returns = NULL;

  00013	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR returns$[rsp], 0

; 1493 :     int name_i = 1;

  0001c	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR name_i$[rsp], 1

; 1494 : 
; 1495 :     REQ(n, funcdef);

  00024	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0002c	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0002f	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00034	74 1c		 je	 SHORT $LN9@ast_for_fu
  00036	41 b8 d7 05 00
	00		 mov	 r8d, 1495		; 000005d7H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@KLIMAIJN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA2?$AA?$CJ?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN9@ast_for_fu:

; 1496 : 
; 1497 :     name = NEW_IDENTIFIER(CHILD(n, name_i));

  00052	48 63 44 24 60	 movsxd	 rax, DWORD PTR name_i$[rsp]
  00057	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0005b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00063	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00067	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  0006f	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  00074	e8 00 00 00 00	 call	 new_identifier
  00079	48 89 44 24 48	 mov	 QWORD PTR name$[rsp], rax

; 1498 :     if (!name)

  0007e	48 83 7c 24 48
	00		 cmp	 QWORD PTR name$[rsp], 0
  00084	75 07		 jne	 SHORT $LN6@ast_for_fu

; 1499 :         return NULL;

  00086	33 c0		 xor	 eax, eax
  00088	e9 6d 01 00 00	 jmp	 $LN7@ast_for_fu
$LN6@ast_for_fu:

; 1500 :     if (forbidden_name(c, name, CHILD(n, name_i), 0))

  0008d	48 63 44 24 60	 movsxd	 rax, DWORD PTR name_i$[rsp]
  00092	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00096	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0009e	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000a2	45 33 c9	 xor	 r9d, r9d
  000a5	4c 8b c0	 mov	 r8, rax
  000a8	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  000ad	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000b5	e8 00 00 00 00	 call	 forbidden_name
  000ba	85 c0		 test	 eax, eax
  000bc	74 07		 je	 SHORT $LN5@ast_for_fu

; 1501 :         return NULL;

  000be	33 c0		 xor	 eax, eax
  000c0	e9 35 01 00 00	 jmp	 $LN7@ast_for_fu
$LN5@ast_for_fu:

; 1502 :     args = ast_for_arguments(c, CHILD(n, name_i + 1));

  000c5	8b 44 24 60	 mov	 eax, DWORD PTR name_i$[rsp]
  000c9	ff c0		 inc	 eax
  000cb	48 98		 cdqe
  000cd	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000d1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  000d9	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000dd	48 8b d0	 mov	 rdx, rax
  000e0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000e8	e8 00 00 00 00	 call	 ast_for_arguments
  000ed	48 89 44 24 40	 mov	 QWORD PTR args$[rsp], rax

; 1503 :     if (!args)

  000f2	48 83 7c 24 40
	00		 cmp	 QWORD PTR args$[rsp], 0
  000f8	75 07		 jne	 SHORT $LN4@ast_for_fu

; 1504 :         return NULL;

  000fa	33 c0		 xor	 eax, eax
  000fc	e9 f9 00 00 00	 jmp	 $LN7@ast_for_fu
$LN4@ast_for_fu:

; 1505 :     if (TYPE(CHILD(n, name_i+2)) == RARROW) {

  00101	8b 44 24 60	 mov	 eax, DWORD PTR name_i$[rsp]
  00105	83 c0 02	 add	 eax, 2
  00108	48 98		 cdqe
  0010a	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0010e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00116	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0011a	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0011e	83 f8 32	 cmp	 eax, 50			; 00000032H
  00121	75 48		 jne	 SHORT $LN3@ast_for_fu

; 1506 :         returns = ast_for_expr(c, CHILD(n, name_i + 3));

  00123	8b 44 24 60	 mov	 eax, DWORD PTR name_i$[rsp]
  00127	83 c0 03	 add	 eax, 3
  0012a	48 98		 cdqe
  0012c	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00130	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00138	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0013c	48 8b d0	 mov	 rdx, rax
  0013f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00147	e8 00 00 00 00	 call	 ast_for_expr
  0014c	48 89 44 24 50	 mov	 QWORD PTR returns$[rsp], rax

; 1507 :         if (!returns)

  00151	48 83 7c 24 50
	00		 cmp	 QWORD PTR returns$[rsp], 0
  00157	75 07		 jne	 SHORT $LN2@ast_for_fu

; 1508 :             return NULL;

  00159	33 c0		 xor	 eax, eax
  0015b	e9 9a 00 00 00	 jmp	 $LN7@ast_for_fu
$LN2@ast_for_fu:

; 1509 :         name_i += 2;

  00160	8b 44 24 60	 mov	 eax, DWORD PTR name_i$[rsp]
  00164	83 c0 02	 add	 eax, 2
  00167	89 44 24 60	 mov	 DWORD PTR name_i$[rsp], eax
$LN3@ast_for_fu:

; 1510 :     }
; 1511 :     body = ast_for_suite(c, CHILD(n, name_i + 3));

  0016b	8b 44 24 60	 mov	 eax, DWORD PTR name_i$[rsp]
  0016f	83 c0 03	 add	 eax, 3
  00172	48 98		 cdqe
  00174	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00178	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00180	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00184	48 8b d0	 mov	 rdx, rax
  00187	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0018f	e8 00 00 00 00	 call	 ast_for_suite
  00194	48 89 44 24 58	 mov	 QWORD PTR body$[rsp], rax

; 1512 :     if (!body)

  00199	48 83 7c 24 58
	00		 cmp	 QWORD PTR body$[rsp], 0
  0019f	75 04		 jne	 SHORT $LN1@ast_for_fu

; 1513 :         return NULL;

  001a1	33 c0		 xor	 eax, eax
  001a3	eb 55		 jmp	 SHORT $LN7@ast_for_fu
$LN1@ast_for_fu:

; 1514 : 
; 1515 :     return FunctionDef(name, args, body, decorator_seq, returns, LINENO(n),
; 1516 :                        n->n_col_offset, c->c_arena);

  001a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  001ad	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001b1	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  001b6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001be	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001c1	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001c5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001cd	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001d0	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001d4	48 8b 44 24 50	 mov	 rax, QWORD PTR returns$[rsp]
  001d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001de	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR decorator_seq$[rsp]
  001e6	4c 8b 44 24 58	 mov	 r8, QWORD PTR body$[rsp]
  001eb	48 8b 54 24 40	 mov	 rdx, QWORD PTR args$[rsp]
  001f0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  001f5	e8 00 00 00 00	 call	 _Py_FunctionDef
$LN7@ast_for_fu:

; 1517 : }

  001fa	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001fe	c3		 ret	 0
ast_for_funcdef ENDP
_TEXT	ENDS
PUBLIC	??_C@_1HM@GFOAOMBA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAu?$AAn?$AAc?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5@ ; `string'
PUBLIC	??_C@_1CC@CNBIHKDD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA1?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_decorated DD imagerel ast_for_decorated
	DD	imagerel ast_for_decorated+346
	DD	imagerel $unwind$ast_for_decorated
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_decorated DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1HM@GFOAOMBA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAu?$AAn?$AAc?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5@
CONST	SEGMENT
??_C@_1HM@GFOAOMBA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAu?$AAn?$AAc?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'C', 00H, 'H', 00H
	DB	'I', 00H, 'L', 00H, 'D', 00H, '(', 00H, 'n', 00H, ',', 00H, ' '
	DB	00H, '1', 00H, ')', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'f', 00H, 'u', 00H, 'n', 00H, 'c', 00H, 'd', 00H, 'e'
	DB	00H, 'f', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'T', 00H
	DB	'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'C', 00H, 'H', 00H, 'I'
	DB	00H, 'L', 00H, 'D', 00H, '(', 00H, 'n', 00H, ',', 00H, ' ', 00H
	DB	'1', 00H, ')', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, 'd', 00H
	DB	'e', 00H, 'f', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@CNBIHKDD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA1?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@CNBIHKDD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA1?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '6'
	DB	00H, '1', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_decorated
_TEXT	SEGMENT
decorator_seq$ = 32
thing$ = 40
c$ = 64
n$ = 72
ast_for_decorated PROC					; COMDAT

; 1521 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1522 :     /* decorated: decorators (classdef | funcdef) */
; 1523 :     stmt_ty thing = NULL;

  0000e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR thing$[rsp], 0

; 1524 :     asdl_seq *decorator_seq = NULL;

  00017	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR decorator_seq$[rsp], 0

; 1525 : 
; 1526 :     REQ(n, decorated);

  00020	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00025	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00028	3d 05 01 00 00	 cmp	 eax, 261		; 00000105H
  0002d	74 1c		 je	 SHORT $LN8@ast_for_de
  0002f	41 b8 f6 05 00
	00		 mov	 r8d, 1526		; 000005f6H
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CNBIHKDD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA1?$AA?$CJ?$AA?$AA@
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00049	33 c0		 xor	 eax, eax
$LN8@ast_for_de:

; 1527 : 
; 1528 :     decorator_seq = ast_for_decorators(c, CHILD(n, 0));

  0004b	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00050	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00059	e8 00 00 00 00	 call	 ast_for_decorators
  0005e	48 89 44 24 20	 mov	 QWORD PTR decorator_seq$[rsp], rax

; 1529 :     if (!decorator_seq)

  00063	48 83 7c 24 20
	00		 cmp	 QWORD PTR decorator_seq$[rsp], 0
  00069	75 07		 jne	 SHORT $LN5@ast_for_de

; 1530 :       return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 e3 00 00 00	 jmp	 $LN6@ast_for_de
$LN5@ast_for_de:

; 1531 : 
; 1532 :     assert(TYPE(CHILD(n, 1)) == funcdef ||
; 1533 :            TYPE(CHILD(n, 1)) == classdef);

  00072	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00077	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007b	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  0007f	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  00084	74 30		 je	 SHORT $LN9@ast_for_de
  00086	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0008b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0008f	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  00093	3d 49 01 00 00	 cmp	 eax, 329		; 00000149H
  00098	74 1c		 je	 SHORT $LN9@ast_for_de
  0009a	41 b8 fd 05 00
	00		 mov	 r8d, 1533		; 000005fdH
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HM@GFOAOMBA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAC?$AAH?$AAI?$AAL?$AAD?$AA?$CI?$AAn?$AA?0?$AA?5?$AA1?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAf?$AAu?$AAn?$AAc?$AAd?$AAe?$AAf?$AA?5?$AA?$HM?$AA?$HM?$AA?5@
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b4	33 c0		 xor	 eax, eax
$LN9@ast_for_de:

; 1534 : 
; 1535 :     if (TYPE(CHILD(n, 1)) == funcdef) {

  000b6	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000bb	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000bf	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  000c3	3d 06 01 00 00	 cmp	 eax, 262		; 00000106H
  000c8	75 26		 jne	 SHORT $LN4@ast_for_de

; 1536 :       thing = ast_for_funcdef(c, CHILD(n, 1), decorator_seq);

  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000cf	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000d3	48 83 c0 28	 add	 rax, 40			; 00000028H
  000d7	4c 8b 44 24 20	 mov	 r8, QWORD PTR decorator_seq$[rsp]
  000dc	48 8b d0	 mov	 rdx, rax
  000df	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000e4	e8 00 00 00 00	 call	 ast_for_funcdef
  000e9	48 89 44 24 28	 mov	 QWORD PTR thing$[rsp], rax
  000ee	eb 38		 jmp	 SHORT $LN3@ast_for_de
$LN4@ast_for_de:

; 1537 :     } else if (TYPE(CHILD(n, 1)) == classdef) {

  000f0	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000f5	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000f9	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  000fd	3d 49 01 00 00	 cmp	 eax, 329		; 00000149H
  00102	75 24		 jne	 SHORT $LN2@ast_for_de

; 1538 :       thing = ast_for_classdef(c, CHILD(n, 1), decorator_seq);

  00104	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00109	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0010d	48 83 c0 28	 add	 rax, 40			; 00000028H
  00111	4c 8b 44 24 20	 mov	 r8, QWORD PTR decorator_seq$[rsp]
  00116	48 8b d0	 mov	 rdx, rax
  00119	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  0011e	e8 00 00 00 00	 call	 ast_for_classdef
  00123	48 89 44 24 28	 mov	 QWORD PTR thing$[rsp], rax
$LN2@ast_for_de:
$LN3@ast_for_de:

; 1539 :     }
; 1540 :     /* we count the decorators in when talking about the class' or
; 1541 :      * function's line number */
; 1542 :     if (thing) {

  00128	48 83 7c 24 28
	00		 cmp	 QWORD PTR thing$[rsp], 0
  0012e	74 20		 je	 SHORT $LN1@ast_for_de

; 1543 :         thing->lineno = LINENO(n);

  00130	48 8b 44 24 28	 mov	 rax, QWORD PTR thing$[rsp]
  00135	48 8b 4c 24 48	 mov	 rcx, QWORD PTR n$[rsp]
  0013a	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0013d	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 1544 :         thing->col_offset = n->n_col_offset;

  00140	48 8b 44 24 28	 mov	 rax, QWORD PTR thing$[rsp]
  00145	48 8b 4c 24 48	 mov	 rcx, QWORD PTR n$[rsp]
  0014a	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0014d	89 48 44	 mov	 DWORD PTR [rax+68], ecx
$LN1@ast_for_de:

; 1545 :     }
; 1546 :     return thing;

  00150	48 8b 44 24 28	 mov	 rax, QWORD PTR thing$[rsp]
$LN6@ast_for_de:

; 1547 : }

  00155	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00159	c3		 ret	 0
ast_for_decorated ENDP
_TEXT	ENDS
PUBLIC	??_C@_1GG@GPHCLLFH@?$AA?$CI?$AAd?$AAe?$AAc?$AAo?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAd?$AAe@ ; `string'
PUBLIC	??_C@_1CC@OGEEKJJG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA0?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_decorators DD imagerel ast_for_decorators
	DD	imagerel ast_for_decorators+283
	DD	imagerel $unwind$ast_for_decorators
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_decorators DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1GG@GPHCLLFH@?$AA?$CI?$AAd?$AAe?$AAc?$AAo?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAd?$AAe@
CONST	SEGMENT
??_C@_1GG@GPHCLLFH@?$AA?$CI?$AAd?$AAe?$AAc?$AAo?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAd?$AAe@ DB '('
	DB	00H, 'd', 00H, 'e', 00H, 'c', 00H, 'o', 00H, 'r', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 's', 00H, 'e', 00H, 'q'
	DB	00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_', 00H
	DB	'a', 00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H, 'i', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, '(', 00H, 'd', 00H, 'e', 00H, 'c', 00H
	DB	'o', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_'
	DB	00H, 's', 00H, 'e', 00H, 'q', 00H, ')', 00H, '-', 00H, '>', 00H
	DB	's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@OGEEKJJG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA0?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@OGEEKJJG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA0?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '6'
	DB	00H, '0', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_decorators
_TEXT	SEGMENT
i$ = 32
decorator_seq$ = 40
d$ = 48
_asdl_i$22918 = 56
c$ = 80
n$ = 88
ast_for_decorators PROC					; COMDAT

; 1466 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1467 :     asdl_seq* decorator_seq;
; 1468 :     expr_ty d;
; 1469 :     int i;
; 1470 : 
; 1471 :     REQ(n, decorators);

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 04 01 00 00	 cmp	 eax, 260		; 00000104H
  0001b	74 1c		 je	 SHORT $LN8@ast_for_de@2
  0001d	41 b8 bf 05 00
	00		 mov	 r8d, 1471		; 000005bfH
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@OGEEKJJG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA0?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN8@ast_for_de@2:

; 1472 :     decorator_seq = asdl_seq_new(NCH(n), c->c_arena);

  00039	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0003e	48 63 40 18	 movsxd	 rax, DWORD PTR [rax+24]
  00042	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  00047	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 asdl_seq_new
  00053	48 89 44 24 28	 mov	 QWORD PTR decorator_seq$[rsp], rax

; 1473 :     if (!decorator_seq)

  00058	48 83 7c 24 28
	00		 cmp	 QWORD PTR decorator_seq$[rsp], 0
  0005e	75 07		 jne	 SHORT $LN5@ast_for_de@2

; 1474 :         return NULL;

  00060	33 c0		 xor	 eax, eax
  00062	e9 af 00 00 00	 jmp	 $LN6@ast_for_de@2
$LN5@ast_for_de@2:

; 1475 : 
; 1476 :     for (i = 0; i < NCH(n); i++) {

  00067	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006f	eb 0a		 jmp	 SHORT $LN4@ast_for_de@2
$LN3@ast_for_de@2:
  00071	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00075	ff c0		 inc	 eax
  00077	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@ast_for_de@2:
  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00080	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00083	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00087	0f 8d 84 00 00
	00		 jge	 $LN2@ast_for_de@2

; 1477 :         d = ast_for_decorator(c, CHILD(n, i));

  0008d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00092	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00096	48 8b 4c 24 58	 mov	 rcx, QWORD PTR n$[rsp]
  0009b	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0009f	48 8b d0	 mov	 rdx, rax
  000a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  000a7	e8 00 00 00 00	 call	 ast_for_decorator
  000ac	48 89 44 24 30	 mov	 QWORD PTR d$[rsp], rax

; 1478 :         if (!d)

  000b1	48 83 7c 24 30
	00		 cmp	 QWORD PTR d$[rsp], 0
  000b7	75 04		 jne	 SHORT $LN1@ast_for_de@2

; 1479 :             return NULL;

  000b9	33 c0		 xor	 eax, eax
  000bb	eb 59		 jmp	 SHORT $LN6@ast_for_de@2
$LN1@ast_for_de@2:

; 1480 :         asdl_seq_SET(decorator_seq, i, d);

  000bd	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000c1	89 44 24 38	 mov	 DWORD PTR _asdl_i$22918[rsp], eax
  000c5	48 83 7c 24 28
	00		 cmp	 QWORD PTR decorator_seq$[rsp], 0
  000cb	74 0f		 je	 SHORT $LN9@ast_for_de@2
  000cd	48 63 44 24 38	 movsxd	 rax, DWORD PTR _asdl_i$22918[rsp]
  000d2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR decorator_seq$[rsp]
  000d7	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  000da	7c 1c		 jl	 SHORT $LN10@ast_for_de@2
$LN9@ast_for_de@2:
  000dc	41 b8 c8 05 00
	00		 mov	 r8d, 1480		; 000005c8H
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GG@GPHCLLFH@?$AA?$CI?$AAd?$AAe?$AAc?$AAo?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAd?$AAe@
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f6	33 c0		 xor	 eax, eax
$LN10@ast_for_de@2:
  000f8	48 63 44 24 38	 movsxd	 rax, DWORD PTR _asdl_i$22918[rsp]
  000fd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR decorator_seq$[rsp]
  00102	48 8b 54 24 30	 mov	 rdx, QWORD PTR d$[rsp]
  00107	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 1481 :     }

  0010c	e9 60 ff ff ff	 jmp	 $LN3@ast_for_de@2
$LN2@ast_for_de@2:

; 1482 :     return decorator_seq;

  00111	48 8b 44 24 28	 mov	 rax, QWORD PTR decorator_seq$[rsp]
$LN6@ast_for_de@2:

; 1483 : }

  00116	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011a	c3		 ret	 0
ast_for_decorators ENDP
_TEXT	ENDS
PUBLIC	??_C@_1HA@KIKBMBC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA?$CI?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAn?$AAc?$AAh@ ; `string'
PUBLIC	??_C@_1EC@NHIEELDA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA4?$AA9?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1CC@EPMEPPLN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA5?$AA9?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_decorator DD imagerel ast_for_decorator
	DD	imagerel ast_for_decorator+425
	DD	imagerel $unwind$ast_for_decorator
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_decorator DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1HA@KIKBMBC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA?$CI?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAn?$AAc?$AAh@
CONST	SEGMENT
??_C@_1HA@KIKBMBC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA?$CI?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAn?$AAc?$AAh@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, '(', 00H, '(', 00H
	DB	'&', 00H, '(', 00H, 'n', 00H, ')', 00H, '-', 00H, '>', 00H, 'n'
	DB	00H, '_', 00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H
	DB	'[', 00H, '(', 00H, '(', 00H, 'n', 00H, ')', 00H, '-', 00H, '>'
	DB	00H, 'n', 00H, '_', 00H, 'n', 00H, 'c', 00H, 'h', 00H, 'i', 00H
	DB	'l', 00H, 'd', 00H, 'r', 00H, 'e', 00H, 'n', 00H, ')', 00H, ' '
	DB	00H, '+', 00H, ' ', 00H, '-', 00H, '1', 00H, ']', 00H, ')', 00H
	DB	')', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '('
	DB	00H, '4', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@NHIEELDA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA4?$AA9?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@NHIEELDA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA4?$AA9?$AA?$CJ@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, '(', 00H, '&', 00H
	DB	'(', 00H, 'n', 00H, ')', 00H, '-', 00H, '>', 00H, 'n', 00H, '_'
	DB	00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '[', 00H
	DB	'0', 00H, ']', 00H, ')', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '(', 00H, '4', 00H, '9', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@EPMEPPLN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA5?$AA9?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@EPMEPPLN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA5?$AA9?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '5'
	DB	00H, '9', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_decorator
_TEXT	SEGMENT
name_expr$ = 64
d$ = 72
c$ = 96
n$ = 104
ast_for_decorator PROC					; COMDAT

; 1430 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1431 :     /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */
; 1432 :     expr_ty d = NULL;

  0000e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR d$[rsp], 0

; 1433 :     expr_ty name_expr;
; 1434 : 
; 1435 :     REQ(n, decorator);

  00017	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0001c	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0001f	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  00024	74 1c		 je	 SHORT $LN10@ast_for_de@3
  00026	41 b8 9b 05 00
	00		 mov	 r8d, 1435		; 0000059bH
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@EPMEPPLN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA5?$AA9?$AA?$CJ?$AA?$AA@
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00040	33 c0		 xor	 eax, eax
$LN10@ast_for_de@3:

; 1436 :     REQ(CHILD(n, 0), AT);

  00042	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00047	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004b	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0004e	83 f8 31	 cmp	 eax, 49			; 00000031H
  00051	74 1c		 je	 SHORT $LN11@ast_for_de@3
  00053	41 b8 9c 05 00
	00		 mov	 r8d, 1436		; 0000059cH
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@NHIEELDA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA4?$AA9?$AA?$CJ@
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006d	33 c0		 xor	 eax, eax
$LN11@ast_for_de@3:

; 1437 :     REQ(RCHILD(n, -1), NEWLINE);

  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00074	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00077	ff c8		 dec	 eax
  00079	48 98		 cdqe
  0007b	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0007f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR n$[rsp]
  00084	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00088	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0008c	83 f8 04	 cmp	 eax, 4
  0008f	74 1c		 je	 SHORT $LN12@ast_for_de@3
  00091	41 b8 9d 05 00
	00		 mov	 r8d, 1437		; 0000059dH
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@KIKBMBC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA?$CI?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAn?$AAc?$AAh@
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ab	33 c0		 xor	 eax, eax
$LN12@ast_for_de@3:

; 1438 : 
; 1439 :     name_expr = ast_for_dotted_name(c, CHILD(n, 1));

  000ad	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000b2	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000b6	48 83 c0 28	 add	 rax, 40			; 00000028H
  000ba	48 8b d0	 mov	 rdx, rax
  000bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000c2	e8 00 00 00 00	 call	 ast_for_dotted_name
  000c7	48 89 44 24 40	 mov	 QWORD PTR name_expr$[rsp], rax

; 1440 :     if (!name_expr)

  000cc	48 83 7c 24 40
	00		 cmp	 QWORD PTR name_expr$[rsp], 0
  000d2	75 07		 jne	 SHORT $LN7@ast_for_de@3

; 1441 :         return NULL;

  000d4	33 c0		 xor	 eax, eax
  000d6	e9 c9 00 00 00	 jmp	 $LN8@ast_for_de@3
$LN7@ast_for_de@3:

; 1442 : 
; 1443 :     if (NCH(n) == 3) { /* No arguments */

  000db	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000e0	83 78 18 03	 cmp	 DWORD PTR [rax+24], 3
  000e4	75 18		 jne	 SHORT $LN6@ast_for_de@3

; 1444 :         d = name_expr;

  000e6	48 8b 44 24 40	 mov	 rax, QWORD PTR name_expr$[rsp]
  000eb	48 89 44 24 48	 mov	 QWORD PTR d$[rsp], rax

; 1445 :         name_expr = NULL;

  000f0	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR name_expr$[rsp], 0
  000f9	e9 a1 00 00 00	 jmp	 $LN5@ast_for_de@3
$LN6@ast_for_de@3:

; 1446 :     }
; 1447 :     else if (NCH(n) == 5) { /* Call with no arguments */

  000fe	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00103	83 78 18 05	 cmp	 DWORD PTR [rax+24], 5
  00107	75 5d		 jne	 SHORT $LN4@ast_for_de@3

; 1448 :         d = Call(name_expr, NULL, NULL, NULL, NULL, LINENO(n),
; 1449 :                  n->n_col_offset, c->c_arena);

  00109	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  0010e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00112	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00117	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0011c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0011f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00123	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00128	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0012b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0012f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00138	45 33 c9	 xor	 r9d, r9d
  0013b	45 33 c0	 xor	 r8d, r8d
  0013e	33 d2		 xor	 edx, edx
  00140	48 8b 4c 24 40	 mov	 rcx, QWORD PTR name_expr$[rsp]
  00145	e8 00 00 00 00	 call	 _Py_Call
  0014a	48 89 44 24 48	 mov	 QWORD PTR d$[rsp], rax

; 1450 :         if (!d)

  0014f	48 83 7c 24 48
	00		 cmp	 QWORD PTR d$[rsp], 0
  00155	75 04		 jne	 SHORT $LN3@ast_for_de@3

; 1451 :             return NULL;

  00157	33 c0		 xor	 eax, eax
  00159	eb 49		 jmp	 SHORT $LN8@ast_for_de@3
$LN3@ast_for_de@3:

; 1452 :         name_expr = NULL;

  0015b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR name_expr$[rsp], 0

; 1453 :     }
; 1454 :     else {

  00164	eb 39		 jmp	 SHORT $LN2@ast_for_de@3
$LN4@ast_for_de@3:

; 1455 :         d = ast_for_call(c, CHILD(n, 3), name_expr);

  00166	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0016b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0016f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00173	4c 8b 44 24 40	 mov	 r8, QWORD PTR name_expr$[rsp]
  00178	48 8b d0	 mov	 rdx, rax
  0017b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00180	e8 00 00 00 00	 call	 ast_for_call
  00185	48 89 44 24 48	 mov	 QWORD PTR d$[rsp], rax

; 1456 :         if (!d)

  0018a	48 83 7c 24 48
	00		 cmp	 QWORD PTR d$[rsp], 0
  00190	75 04		 jne	 SHORT $LN1@ast_for_de@3

; 1457 :             return NULL;

  00192	33 c0		 xor	 eax, eax
  00194	eb 0e		 jmp	 SHORT $LN8@ast_for_de@3
$LN1@ast_for_de@3:

; 1458 :         name_expr = NULL;

  00196	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR name_expr$[rsp], 0
$LN2@ast_for_de@3:
$LN5@ast_for_de@3:

; 1459 :     }
; 1460 : 
; 1461 :     return d;

  0019f	48 8b 44 24 48	 mov	 rax, QWORD PTR d$[rsp]
$LN8@ast_for_de@3:

; 1462 : }

  001a4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001a8	c3		 ret	 0
ast_for_decorator ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@NEMBOKGM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA9?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_dotted_name DD imagerel ast_for_dotted_name
	DD	imagerel ast_for_dotted_name+348
	DD	imagerel $unwind$ast_for_dotted_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_dotted_name DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1CC@NEMBOKGM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA9?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@NEMBOKGM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA9?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '8'
	DB	00H, '9', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_dotted_name
_TEXT	SEGMENT
id$ = 48
i$ = 56
lineno$ = 60
col_offset$ = 64
e$ = 72
c$ = 96
n$ = 104
ast_for_dotted_name PROC				; COMDAT

; 1398 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1399 :     expr_ty e;
; 1400 :     identifier id;
; 1401 :     int lineno, col_offset;
; 1402 :     int i;
; 1403 : 
; 1404 :     REQ(n, dotted_name);

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 21 01 00 00	 cmp	 eax, 289		; 00000121H
  0001b	74 1c		 je	 SHORT $LN10@ast_for_do
  0001d	41 b8 7c 05 00
	00		 mov	 r8d, 1404		; 0000057cH
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@NEMBOKGM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA9?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN10@ast_for_do:

; 1405 : 
; 1406 :     lineno = LINENO(n);

  00039	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0003e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00041	89 44 24 3c	 mov	 DWORD PTR lineno$[rsp], eax

; 1407 :     col_offset = n->n_col_offset;

  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0004a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0004d	89 44 24 40	 mov	 DWORD PTR col_offset$[rsp], eax

; 1408 : 
; 1409 :     id = NEW_IDENTIFIER(CHILD(n, 0));

  00051	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00056	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0005a	48 8b 54 24 60	 mov	 rdx, QWORD PTR c$[rsp]
  0005f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00063	e8 00 00 00 00	 call	 new_identifier
  00068	48 89 44 24 30	 mov	 QWORD PTR id$[rsp], rax

; 1410 :     if (!id)

  0006d	48 83 7c 24 30
	00		 cmp	 QWORD PTR id$[rsp], 0
  00073	75 07		 jne	 SHORT $LN7@ast_for_do

; 1411 :         return NULL;

  00075	33 c0		 xor	 eax, eax
  00077	e9 db 00 00 00	 jmp	 $LN8@ast_for_do
$LN7@ast_for_do:

; 1412 :     e = Name(id, Load, lineno, col_offset, c->c_arena);

  0007c	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00081	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00085	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008a	44 8b 4c 24 40	 mov	 r9d, DWORD PTR col_offset$[rsp]
  0008f	44 8b 44 24 3c	 mov	 r8d, DWORD PTR lineno$[rsp]
  00094	ba 01 00 00 00	 mov	 edx, 1
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR id$[rsp]
  0009e	e8 00 00 00 00	 call	 _Py_Name
  000a3	48 89 44 24 48	 mov	 QWORD PTR e$[rsp], rax

; 1413 :     if (!e)

  000a8	48 83 7c 24 48
	00		 cmp	 QWORD PTR e$[rsp], 0
  000ae	75 07		 jne	 SHORT $LN6@ast_for_do

; 1414 :         return NULL;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 a0 00 00 00	 jmp	 $LN8@ast_for_do
$LN6@ast_for_do:

; 1415 : 
; 1416 :     for (i = 2; i < NCH(n); i+=2) {

  000b7	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR i$[rsp], 2
  000bf	eb 0b		 jmp	 SHORT $LN5@ast_for_do
$LN4@ast_for_do:
  000c1	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  000c5	83 c0 02	 add	 eax, 2
  000c8	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN5@ast_for_do:
  000cc	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000d1	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000d4	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  000d8	7d 78		 jge	 SHORT $LN3@ast_for_do

; 1417 :         id = NEW_IDENTIFIER(CHILD(n, i));

  000da	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$[rsp]
  000df	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000e3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR n$[rsp]
  000e8	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000ec	48 8b 54 24 60	 mov	 rdx, QWORD PTR c$[rsp]
  000f1	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  000f6	e8 00 00 00 00	 call	 new_identifier
  000fb	48 89 44 24 30	 mov	 QWORD PTR id$[rsp], rax

; 1418 :         if (!id)

  00100	48 83 7c 24 30
	00		 cmp	 QWORD PTR id$[rsp], 0
  00106	75 04		 jne	 SHORT $LN2@ast_for_do

; 1419 :             return NULL;

  00108	33 c0		 xor	 eax, eax
  0010a	eb 4b		 jmp	 SHORT $LN8@ast_for_do
$LN2@ast_for_do:

; 1420 :         e = Attribute(e, id, Load, lineno, col_offset, c->c_arena);

  0010c	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00111	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00115	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011a	8b 44 24 40	 mov	 eax, DWORD PTR col_offset$[rsp]
  0011e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00122	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR lineno$[rsp]
  00127	41 b8 01 00 00
	00		 mov	 r8d, 1
  0012d	48 8b 54 24 30	 mov	 rdx, QWORD PTR id$[rsp]
  00132	48 8b 4c 24 48	 mov	 rcx, QWORD PTR e$[rsp]
  00137	e8 00 00 00 00	 call	 _Py_Attribute
  0013c	48 89 44 24 48	 mov	 QWORD PTR e$[rsp], rax

; 1421 :         if (!e)

  00141	48 83 7c 24 48
	00		 cmp	 QWORD PTR e$[rsp], 0
  00147	75 04		 jne	 SHORT $LN1@ast_for_do

; 1422 :             return NULL;

  00149	33 c0		 xor	 eax, eax
  0014b	eb 0a		 jmp	 SHORT $LN8@ast_for_do
$LN1@ast_for_do:

; 1423 :     }

  0014d	e9 6f ff ff ff	 jmp	 $LN4@ast_for_do
$LN3@ast_for_do:

; 1424 : 
; 1425 :     return e;

  00152	48 8b 44 24 48	 mov	 rax, QWORD PTR e$[rsp]
$LN8@ast_for_do:

; 1426 : }

  00157	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0015b	c3		 ret	 0
ast_for_dotted_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EO@KJNHGEBL@?$AA?$CI?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AAs?$AA?$CJ@ ; `string'
PUBLIC	??_C@_0CM@CPDJBKPL@assignment?5to?5yield?5expression?5n@ ; `string'
PUBLIC	??_C@_1EC@JMDBBEOD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA1?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA2?$AA?$CJ@ ; `string'
PUBLIC	??_C@_0CM@DDDJCEPJ@illegal?5expression?5for?5augmented@ ; `string'
PUBLIC	??_C@_1CC@OBLCHKKN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA1?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_Assign:PROC
EXTRN	_Py_AugAssign:PROC
EXTRN	_Py_Expr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_expr_stmt DD imagerel ast_for_expr_stmt
	DD	imagerel ast_for_expr_stmt+1208
	DD	imagerel $unwind$ast_for_expr_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_expr_stmt DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_1EO@KJNHGEBL@?$AA?$CI?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AAs?$AA?$CJ@
CONST	SEGMENT
??_C@_1EO@KJNHGEBL@?$AA?$CI?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AAs?$AA?$CJ@ DB '('
	DB	00H, 't', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H
	DB	's', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_'
	DB	00H, 'a', 00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H, 'i', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, '(', 00H, 't', 00H, 'a', 00H, 'r'
	DB	00H, 'g', 00H, 'e', 00H, 't', 00H, 's', 00H, ')', 00H, '-', 00H
	DB	'>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CPDJBKPL@assignment?5to?5yield?5expression?5n@
CONST	SEGMENT
??_C@_0CM@CPDJBKPL@assignment?5to?5yield?5expression?5n@ DB 'assignment t'
	DB	'o yield expression not possible', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@JMDBBEOD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA1?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA2?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@JMDBBEOD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA1?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA2?$AA?$CJ@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, '(', 00H, '&', 00H
	DB	'(', 00H, 'n', 00H, ')', 00H, '-', 00H, '>', 00H, 'n', 00H, '_'
	DB	00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '[', 00H
	DB	'1', 00H, ']', 00H, ')', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '(', 00H, '2', 00H, '2', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@DDDJCEPJ@illegal?5expression?5for?5augmented@
CONST	SEGMENT
??_C@_0CM@DDDJCEPJ@illegal?5expression?5for?5augmented@ DB 'illegal expre'
	DB	'ssion for augmented assignment', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@OBLCHKKN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA1?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@OBLCHKKN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA1?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '7'
	DB	00H, '1', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_expr_stmt
_TEXT	SEGMENT
e$23698 = 48
expr2$23704 = 56
expr1$23703 = 64
ch$23706 = 72
newoperator$23705 = 80
value$23728 = 88
i$23726 = 96
expression$23729 = 104
targets$23727 = 112
ch$23738 = 120
e$23737 = 128
_asdl_i$23746 = 136
tv133 = 140
c$ = 160
n$ = 168
ast_for_expr_stmt PROC					; COMDAT

; 2560 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2561 :     REQ(n, expr_stmt);

  00011	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00019	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0001c	3d 0f 01 00 00	 cmp	 eax, 271		; 0000010fH
  00021	74 1c		 je	 SHORT $LN28@ast_for_ex@3
  00023	41 b8 01 0a 00
	00		 mov	 r8d, 2561		; 00000a01H
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@OBLCHKKN@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA1?$AA?$CJ?$AA?$AA@
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003d	33 c0		 xor	 eax, eax
$LN28@ast_for_ex@3:

; 2562 :     /* expr_stmt: testlist_star_expr (augassign (yield_expr|testlist)
; 2563 :                 | ('=' (yield_expr|testlist))*)
; 2564 :        testlist_star_expr: (test|star_expr) (',' test|star_expr)* [',']
; 2565 :        augassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^='
; 2566 :                 | '<<=' | '>>=' | '**=' | '//='
; 2567 :        test: ... here starts the operator precendence dance
; 2568 :      */
; 2569 : 
; 2570 :     if (NCH(n) == 1) {

  0003f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00047	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  0004b	75 64		 jne	 SHORT $LN25@ast_for_ex@3

; 2571 :         expr_ty e = ast_for_testlist(c, CHILD(n, 0));

  0004d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00055	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00059	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00061	e8 00 00 00 00	 call	 ast_for_testlist
  00066	48 89 44 24 30	 mov	 QWORD PTR e$23698[rsp], rax

; 2572 :         if (!e)

  0006b	48 83 7c 24 30
	00		 cmp	 QWORD PTR e$23698[rsp], 0
  00071	75 07		 jne	 SHORT $LN24@ast_for_ex@3

; 2573 :             return NULL;

  00073	33 c0		 xor	 eax, eax
  00075	e9 36 04 00 00	 jmp	 $LN26@ast_for_ex@3
$LN24@ast_for_ex@3:

; 2574 : 
; 2575 :         return Expr(e, LINENO(n), n->n_col_offset, c->c_arena);

  0007a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00082	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00086	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0008e	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  00092	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0009a	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  0009d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR e$23698[rsp]
  000a2	e8 00 00 00 00	 call	 _Py_Expr
  000a7	e9 04 04 00 00	 jmp	 $LN26@ast_for_ex@3
  000ac	e9 ff 03 00 00	 jmp	 $LN23@ast_for_ex@3
$LN25@ast_for_ex@3:

; 2576 :     }
; 2577 :     else if (TYPE(CHILD(n, 1)) == augassign) {

  000b1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000b9	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000bd	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  000c1	3d 11 01 00 00	 cmp	 eax, 273		; 00000111H
  000c6	0f 85 8d 01 00
	00		 jne	 $LN22@ast_for_ex@3

; 2578 :         expr_ty expr1, expr2;
; 2579 :         operator_ty newoperator;
; 2580 :         node *ch = CHILD(n, 0);

  000cc	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000d4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000d8	48 89 44 24 48	 mov	 QWORD PTR ch$23706[rsp], rax

; 2581 : 
; 2582 :         expr1 = ast_for_testlist(c, ch);

  000dd	48 8b 54 24 48	 mov	 rdx, QWORD PTR ch$23706[rsp]
  000e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000ea	e8 00 00 00 00	 call	 ast_for_testlist
  000ef	48 89 44 24 40	 mov	 QWORD PTR expr1$23703[rsp], rax

; 2583 :         if (!expr1)

  000f4	48 83 7c 24 40
	00		 cmp	 QWORD PTR expr1$23703[rsp], 0
  000fa	75 07		 jne	 SHORT $LN21@ast_for_ex@3

; 2584 :             return NULL;

  000fc	33 c0		 xor	 eax, eax
  000fe	e9 ad 03 00 00	 jmp	 $LN26@ast_for_ex@3
$LN21@ast_for_ex@3:

; 2585 :         if(!set_context(c, expr1, Store, ch))

  00103	4c 8b 4c 24 48	 mov	 r9, QWORD PTR ch$23706[rsp]
  00108	41 b8 02 00 00
	00		 mov	 r8d, 2
  0010e	48 8b 54 24 40	 mov	 rdx, QWORD PTR expr1$23703[rsp]
  00113	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0011b	e8 00 00 00 00	 call	 set_context
  00120	85 c0		 test	 eax, eax
  00122	75 07		 jne	 SHORT $LN20@ast_for_ex@3

; 2586 :             return NULL;

  00124	33 c0		 xor	 eax, eax
  00126	e9 85 03 00 00	 jmp	 $LN26@ast_for_ex@3
$LN20@ast_for_ex@3:

; 2587 :         /* set_context checks that most expressions are not the left side.
; 2588 :           Augmented assignments can only have a name, a subscript, or an
; 2589 :           attribute on the left, though, so we have to explicitly check for
; 2590 :           those. */
; 2591 :         switch (expr1->kind) {

  0012b	48 8b 44 24 40	 mov	 rax, QWORD PTR expr1$23703[rsp]
  00130	8b 00		 mov	 eax, DWORD PTR [rax]
  00132	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv133[rsp], eax
  00139	83 bc 24 8c 00
	00 00 14	 cmp	 DWORD PTR tv133[rsp], 20
  00141	7c 18		 jl	 SHORT $LN16@ast_for_ex@3
  00143	83 bc 24 8c 00
	00 00 15	 cmp	 DWORD PTR tv133[rsp], 21
  0014b	7e 0c		 jle	 SHORT $LN17@ast_for_ex@3
  0014d	83 bc 24 8c 00
	00 00 17	 cmp	 DWORD PTR tv133[rsp], 23
  00155	74 02		 je	 SHORT $LN17@ast_for_ex@3
  00157	eb 02		 jmp	 SHORT $LN16@ast_for_ex@3
$LN17@ast_for_ex@3:

; 2592 :             case Name_kind:
; 2593 :             case Attribute_kind:
; 2594 :             case Subscript_kind:
; 2595 :                 break;

  00159	eb 20		 jmp	 SHORT $LN18@ast_for_ex@3
$LN16@ast_for_ex@3:

; 2596 :             default:
; 2597 :                 ast_error(c, ch, "illegal expression for augmented assignment");

  0015b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CM@DDDJCEPJ@illegal?5expression?5for?5augmented@
  00162	48 8b 54 24 48	 mov	 rdx, QWORD PTR ch$23706[rsp]
  00167	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0016f	e8 00 00 00 00	 call	 ast_error

; 2598 :                 return NULL;

  00174	33 c0		 xor	 eax, eax
  00176	e9 35 03 00 00	 jmp	 $LN26@ast_for_ex@3
$LN18@ast_for_ex@3:

; 2599 :         }
; 2600 : 
; 2601 :         ch = CHILD(n, 2);

  0017b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00183	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00187	48 83 c0 50	 add	 rax, 80			; 00000050H
  0018b	48 89 44 24 48	 mov	 QWORD PTR ch$23706[rsp], rax

; 2602 :         if (TYPE(ch) == testlist)

  00190	48 8b 44 24 48	 mov	 rax, QWORD PTR ch$23706[rsp]
  00195	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00198	3d 47 01 00 00	 cmp	 eax, 327		; 00000147H
  0019d	75 19		 jne	 SHORT $LN15@ast_for_ex@3

; 2603 :             expr2 = ast_for_testlist(c, ch);

  0019f	48 8b 54 24 48	 mov	 rdx, QWORD PTR ch$23706[rsp]
  001a4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001ac	e8 00 00 00 00	 call	 ast_for_testlist
  001b1	48 89 44 24 38	 mov	 QWORD PTR expr2$23704[rsp], rax

; 2604 :         else

  001b6	eb 17		 jmp	 SHORT $LN14@ast_for_ex@3
$LN15@ast_for_ex@3:

; 2605 :             expr2 = ast_for_expr(c, ch);

  001b8	48 8b 54 24 48	 mov	 rdx, QWORD PTR ch$23706[rsp]
  001bd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001c5	e8 00 00 00 00	 call	 ast_for_expr
  001ca	48 89 44 24 38	 mov	 QWORD PTR expr2$23704[rsp], rax
$LN14@ast_for_ex@3:

; 2606 :         if (!expr2)

  001cf	48 83 7c 24 38
	00		 cmp	 QWORD PTR expr2$23704[rsp], 0
  001d5	75 07		 jne	 SHORT $LN13@ast_for_ex@3

; 2607 :             return NULL;

  001d7	33 c0		 xor	 eax, eax
  001d9	e9 d2 02 00 00	 jmp	 $LN26@ast_for_ex@3
$LN13@ast_for_ex@3:

; 2608 : 
; 2609 :         newoperator = ast_for_augassign(c, CHILD(n, 1));

  001de	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001e6	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001ea	48 83 c0 28	 add	 rax, 40			; 00000028H
  001ee	48 8b d0	 mov	 rdx, rax
  001f1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001f9	e8 00 00 00 00	 call	 ast_for_augassign
  001fe	89 44 24 50	 mov	 DWORD PTR newoperator$23705[rsp], eax

; 2610 :         if (!newoperator)

  00202	83 7c 24 50 00	 cmp	 DWORD PTR newoperator$23705[rsp], 0
  00207	75 07		 jne	 SHORT $LN12@ast_for_ex@3

; 2611 :             return NULL;

  00209	33 c0		 xor	 eax, eax
  0020b	e9 a0 02 00 00	 jmp	 $LN26@ast_for_ex@3
$LN12@ast_for_ex@3:

; 2612 : 
; 2613 :         return AugAssign(expr1, newoperator, expr2, LINENO(n), n->n_col_offset, c->c_arena);

  00210	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00218	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0021c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00221	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00229	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0022c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00230	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00238	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  0023c	4c 8b 44 24 38	 mov	 r8, QWORD PTR expr2$23704[rsp]
  00241	8b 54 24 50	 mov	 edx, DWORD PTR newoperator$23705[rsp]
  00245	48 8b 4c 24 40	 mov	 rcx, QWORD PTR expr1$23703[rsp]
  0024a	e8 00 00 00 00	 call	 _Py_AugAssign
  0024f	e9 5c 02 00 00	 jmp	 $LN26@ast_for_ex@3

; 2614 :     }
; 2615 :     else {

  00254	e9 57 02 00 00	 jmp	 $LN11@ast_for_ex@3
$LN22@ast_for_ex@3:

; 2616 :         int i;
; 2617 :         asdl_seq *targets;
; 2618 :         node *value;
; 2619 :         expr_ty expression;
; 2620 : 
; 2621 :         /* a normal assignment */
; 2622 :         REQ(CHILD(n, 1), EQUAL);

  00259	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00261	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00265	0f bf 40 28	 movsx	 eax, WORD PTR [rax+40]
  00269	83 f8 16	 cmp	 eax, 22
  0026c	74 1c		 je	 SHORT $LN29@ast_for_ex@3
  0026e	41 b8 3e 0a 00
	00		 mov	 r8d, 2622		; 00000a3eH
  00274	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0027b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@JMDBBEOD@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA1?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA2?$AA?$CJ@
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00288	33 c0		 xor	 eax, eax
$LN29@ast_for_ex@3:

; 2623 :         targets = asdl_seq_new(NCH(n) / 2, c->c_arena);

  0028a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00292	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00295	99		 cdq
  00296	2b c2		 sub	 eax, edx
  00298	d1 f8		 sar	 eax, 1
  0029a	48 98		 cdqe
  0029c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002a4	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  002a8	48 8b c8	 mov	 rcx, rax
  002ab	e8 00 00 00 00	 call	 asdl_seq_new
  002b0	48 89 44 24 70	 mov	 QWORD PTR targets$23727[rsp], rax

; 2624 :         if (!targets)

  002b5	48 83 7c 24 70
	00		 cmp	 QWORD PTR targets$23727[rsp], 0
  002bb	75 07		 jne	 SHORT $LN10@ast_for_ex@3

; 2625 :             return NULL;

  002bd	33 c0		 xor	 eax, eax
  002bf	e9 ec 01 00 00	 jmp	 $LN26@ast_for_ex@3
$LN10@ast_for_ex@3:

; 2626 :         for (i = 0; i < NCH(n) - 2; i += 2) {

  002c4	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$23726[rsp], 0
  002cc	eb 0b		 jmp	 SHORT $LN9@ast_for_ex@3
$LN8@ast_for_ex@3:
  002ce	8b 44 24 60	 mov	 eax, DWORD PTR i$23726[rsp]
  002d2	83 c0 02	 add	 eax, 2
  002d5	89 44 24 60	 mov	 DWORD PTR i$23726[rsp], eax
$LN9@ast_for_ex@3:
  002d9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002e1	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  002e4	83 e8 02	 sub	 eax, 2
  002e7	39 44 24 60	 cmp	 DWORD PTR i$23726[rsp], eax
  002eb	0f 8d 18 01 00
	00		 jge	 $LN7@ast_for_ex@3

; 2627 :             expr_ty e;
; 2628 :             node *ch = CHILD(n, i);

  002f1	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$23726[rsp]
  002f6	48 6b c0 28	 imul	 rax, 40			; 00000028H
  002fa	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00302	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00306	48 89 44 24 78	 mov	 QWORD PTR ch$23738[rsp], rax

; 2629 :             if (TYPE(ch) == yield_expr) {

  0030b	48 8b 44 24 78	 mov	 rax, QWORD PTR ch$23738[rsp]
  00310	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00313	3d 50 01 00 00	 cmp	 eax, 336		; 00000150H
  00318	75 20		 jne	 SHORT $LN6@ast_for_ex@3

; 2630 :                 ast_error(c, ch, "assignment to yield expression not possible");

  0031a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CM@CPDJBKPL@assignment?5to?5yield?5expression?5n@
  00321	48 8b 54 24 78	 mov	 rdx, QWORD PTR ch$23738[rsp]
  00326	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0032e	e8 00 00 00 00	 call	 ast_error

; 2631 :                 return NULL;

  00333	33 c0		 xor	 eax, eax
  00335	e9 76 01 00 00	 jmp	 $LN26@ast_for_ex@3
$LN6@ast_for_ex@3:

; 2632 :             }
; 2633 :             e = ast_for_testlist(c, ch);

  0033a	48 8b 54 24 78	 mov	 rdx, QWORD PTR ch$23738[rsp]
  0033f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00347	e8 00 00 00 00	 call	 ast_for_testlist
  0034c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR e$23737[rsp], rax

; 2634 :             if (!e)

  00354	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR e$23737[rsp], 0
  0035d	75 07		 jne	 SHORT $LN5@ast_for_ex@3

; 2635 :               return NULL;

  0035f	33 c0		 xor	 eax, eax
  00361	e9 4a 01 00 00	 jmp	 $LN26@ast_for_ex@3
$LN5@ast_for_ex@3:

; 2636 : 
; 2637 :             /* set context to assign */
; 2638 :             if (!set_context(c, e, Store, CHILD(n, i)))

  00366	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$23726[rsp]
  0036b	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0036f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00377	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0037b	4c 8b c8	 mov	 r9, rax
  0037e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00384	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR e$23737[rsp]
  0038c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00394	e8 00 00 00 00	 call	 set_context
  00399	85 c0		 test	 eax, eax
  0039b	75 07		 jne	 SHORT $LN4@ast_for_ex@3

; 2639 :               return NULL;

  0039d	33 c0		 xor	 eax, eax
  0039f	e9 0c 01 00 00	 jmp	 $LN26@ast_for_ex@3
$LN4@ast_for_ex@3:

; 2640 : 
; 2641 :             asdl_seq_SET(targets, i / 2, e);

  003a4	8b 44 24 60	 mov	 eax, DWORD PTR i$23726[rsp]
  003a8	99		 cdq
  003a9	2b c2		 sub	 eax, edx
  003ab	d1 f8		 sar	 eax, 1
  003ad	89 84 24 88 00
	00 00		 mov	 DWORD PTR _asdl_i$23746[rsp], eax
  003b4	48 83 7c 24 70
	00		 cmp	 QWORD PTR targets$23727[rsp], 0
  003ba	74 12		 je	 SHORT $LN30@ast_for_ex@3
  003bc	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23746[rsp]
  003c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR targets$23727[rsp]
  003c9	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  003cc	7c 1c		 jl	 SHORT $LN31@ast_for_ex@3
$LN30@ast_for_ex@3:
  003ce	41 b8 51 0a 00
	00		 mov	 r8d, 2641		; 00000a51H
  003d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  003db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@KJNHGEBL@?$AA?$CI?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AAs?$AA?$CJ@
  003e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003e8	33 c0		 xor	 eax, eax
$LN31@ast_for_ex@3:
  003ea	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23746[rsp]
  003f2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR targets$23727[rsp]
  003f7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR e$23737[rsp]
  003ff	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 2642 :         }

  00404	e9 c5 fe ff ff	 jmp	 $LN8@ast_for_ex@3
$LN7@ast_for_ex@3:

; 2643 :         value = CHILD(n, NCH(n) - 1);

  00409	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00411	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00414	ff c8		 dec	 eax
  00416	48 98		 cdqe
  00418	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0041c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00424	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00428	48 89 44 24 58	 mov	 QWORD PTR value$23728[rsp], rax

; 2644 :         if (TYPE(value) == testlist_star_expr)

  0042d	48 8b 44 24 58	 mov	 rax, QWORD PTR value$23728[rsp]
  00432	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00435	3d 10 01 00 00	 cmp	 eax, 272		; 00000110H
  0043a	75 19		 jne	 SHORT $LN3@ast_for_ex@3

; 2645 :             expression = ast_for_testlist(c, value);

  0043c	48 8b 54 24 58	 mov	 rdx, QWORD PTR value$23728[rsp]
  00441	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00449	e8 00 00 00 00	 call	 ast_for_testlist
  0044e	48 89 44 24 68	 mov	 QWORD PTR expression$23729[rsp], rax

; 2646 :         else

  00453	eb 17		 jmp	 SHORT $LN2@ast_for_ex@3
$LN3@ast_for_ex@3:

; 2647 :             expression = ast_for_expr(c, value);

  00455	48 8b 54 24 58	 mov	 rdx, QWORD PTR value$23728[rsp]
  0045a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00462	e8 00 00 00 00	 call	 ast_for_expr
  00467	48 89 44 24 68	 mov	 QWORD PTR expression$23729[rsp], rax
$LN2@ast_for_ex@3:

; 2648 :         if (!expression)

  0046c	48 83 7c 24 68
	00		 cmp	 QWORD PTR expression$23729[rsp], 0
  00472	75 04		 jne	 SHORT $LN1@ast_for_ex@3

; 2649 :             return NULL;

  00474	33 c0		 xor	 eax, eax
  00476	eb 38		 jmp	 SHORT $LN26@ast_for_ex@3
$LN1@ast_for_ex@3:

; 2650 :         return Assign(targets, expression, LINENO(n), n->n_col_offset, c->c_arena);

  00478	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00480	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00484	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00489	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00491	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  00495	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0049d	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  004a1	48 8b 54 24 68	 mov	 rdx, QWORD PTR expression$23729[rsp]
  004a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR targets$23727[rsp]
  004ab	e8 00 00 00 00	 call	 _Py_Assign
$LN11@ast_for_ex@3:
$LN23@ast_for_ex@3:
$LN26@ast_for_ex@3:

; 2651 :     }
; 2652 : }

  004b0	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  004b7	c3		 ret	 0
ast_for_expr_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@BNGEDCBG@invalid?5augassign?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_1CC@KMHKNLKG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA3?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_augassign DD imagerel ast_for_augassign
	DD	imagerel ast_for_augassign+440
	DD	imagerel $unwind$ast_for_augassign
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_augassign DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BG@BNGEDCBG@invalid?5augassign?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BG@BNGEDCBG@invalid?5augassign?3?5?$CFs?$AA@ DB 'invalid augassign'
	DB	': %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@KMHKNLKG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA3?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@KMHKNLKG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA3?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '7'
	DB	00H, '3', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_augassign
_TEXT	SEGMENT
tv74 = 32
c$ = 64
n$ = 72
ast_for_augassign PROC					; COMDAT

; 999  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1000 :     REQ(n, augassign);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 11 01 00 00	 cmp	 eax, 273		; 00000111H
  0001b	74 1c		 je	 SHORT $LN20@ast_for_au
  0001d	41 b8 e8 03 00
	00		 mov	 r8d, 1000		; 000003e8H
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@KMHKNLKG@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA3?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN20@ast_for_au:

; 1001 :     n = CHILD(n, 0);

  00039	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0003e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00042	48 89 44 24 48	 mov	 QWORD PTR n$[rsp], rax

; 1002 :     switch (STR(n)[0]) {

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0004c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00050	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00053	89 44 24 20	 mov	 DWORD PTR tv74[rsp], eax
  00057	8b 44 24 20	 mov	 eax, DWORD PTR tv74[rsp]
  0005b	83 e8 25	 sub	 eax, 37			; 00000025H
  0005e	89 44 24 20	 mov	 DWORD PTR tv74[rsp], eax
  00062	83 7c 24 20 57	 cmp	 DWORD PTR tv74[rsp], 87	; 00000057H
  00067	0f 87 a2 00 00
	00		 ja	 $LN1@ast_for_au
  0006d	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv74[rsp]
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00079	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN21@ast_for_au[rcx+rax]
  00081	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN22@ast_for_au[rcx+rax*4]
  00088	48 03 c1	 add	 rax, rcx
  0008b	ff e0		 jmp	 rax
$LN15@ast_for_au:

; 1003 :         case '+':
; 1004 :             return Add;

  0008d	b8 01 00 00 00	 mov	 eax, 1
  00092	e9 96 00 00 00	 jmp	 $LN18@ast_for_au
$LN14@ast_for_au:

; 1005 :         case '-':
; 1006 :             return Sub;

  00097	b8 02 00 00 00	 mov	 eax, 2
  0009c	e9 8c 00 00 00	 jmp	 $LN18@ast_for_au
$LN13@ast_for_au:

; 1007 :         case '/':
; 1008 :             if (STR(n)[1] == '/')

  000a1	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000a6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000aa	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000ae	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000b1	75 09		 jne	 SHORT $LN12@ast_for_au

; 1009 :                 return FloorDiv;

  000b3	b8 0c 00 00 00	 mov	 eax, 12
  000b8	eb 73		 jmp	 SHORT $LN18@ast_for_au

; 1010 :             else

  000ba	eb 07		 jmp	 SHORT $LN11@ast_for_au
$LN12@ast_for_au:

; 1011 :                 return Div;

  000bc	b8 04 00 00 00	 mov	 eax, 4
  000c1	eb 6a		 jmp	 SHORT $LN18@ast_for_au
$LN11@ast_for_au:
$LN10@ast_for_au:

; 1012 :         case '%':
; 1013 :             return Mod;

  000c3	b8 05 00 00 00	 mov	 eax, 5
  000c8	eb 63		 jmp	 SHORT $LN18@ast_for_au
$LN9@ast_for_au:

; 1014 :         case '<':
; 1015 :             return LShift;

  000ca	b8 07 00 00 00	 mov	 eax, 7
  000cf	eb 5c		 jmp	 SHORT $LN18@ast_for_au
$LN8@ast_for_au:

; 1016 :         case '>':
; 1017 :             return RShift;

  000d1	b8 08 00 00 00	 mov	 eax, 8
  000d6	eb 55		 jmp	 SHORT $LN18@ast_for_au
$LN7@ast_for_au:

; 1018 :         case '&':
; 1019 :             return BitAnd;

  000d8	b8 0b 00 00 00	 mov	 eax, 11
  000dd	eb 4e		 jmp	 SHORT $LN18@ast_for_au
$LN6@ast_for_au:

; 1020 :         case '^':
; 1021 :             return BitXor;

  000df	b8 0a 00 00 00	 mov	 eax, 10
  000e4	eb 47		 jmp	 SHORT $LN18@ast_for_au
$LN5@ast_for_au:

; 1022 :         case '|':
; 1023 :             return BitOr;

  000e6	b8 09 00 00 00	 mov	 eax, 9
  000eb	eb 40		 jmp	 SHORT $LN18@ast_for_au
$LN4@ast_for_au:

; 1024 :         case '*':
; 1025 :             if (STR(n)[1] == '*')

  000ed	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000f2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000f6	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  000fa	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  000fd	75 09		 jne	 SHORT $LN3@ast_for_au

; 1026 :                 return Pow;

  000ff	b8 06 00 00 00	 mov	 eax, 6
  00104	eb 27		 jmp	 SHORT $LN18@ast_for_au

; 1027 :             else

  00106	eb 07		 jmp	 SHORT $LN2@ast_for_au
$LN3@ast_for_au:

; 1028 :                 return Mult;

  00108	b8 03 00 00 00	 mov	 eax, 3
  0010d	eb 1e		 jmp	 SHORT $LN18@ast_for_au
$LN2@ast_for_au:
$LN1@ast_for_au:

; 1029 :         default:
; 1030 :             PyErr_Format(PyExc_SystemError, "invalid augassign: %s", STR(n));

  0010f	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00114	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@BNGEDCBG@invalid?5augassign?3?5?$CFs?$AA@
  0011f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00126	e8 00 00 00 00	 call	 PyErr_Format

; 1031 :             return (operator_ty)0;

  0012b	33 c0		 xor	 eax, eax
$LN18@ast_for_au:

; 1032 :     }
; 1033 : }

  0012d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00131	c3		 ret	 0
  00132	66 90		 npad	 2
$LN22@ast_for_au:
  00134	00 00 00 00	 DD	 $LN10@ast_for_au
  00138	00 00 00 00	 DD	 $LN7@ast_for_au
  0013c	00 00 00 00	 DD	 $LN4@ast_for_au
  00140	00 00 00 00	 DD	 $LN15@ast_for_au
  00144	00 00 00 00	 DD	 $LN14@ast_for_au
  00148	00 00 00 00	 DD	 $LN13@ast_for_au
  0014c	00 00 00 00	 DD	 $LN9@ast_for_au
  00150	00 00 00 00	 DD	 $LN8@ast_for_au
  00154	00 00 00 00	 DD	 $LN6@ast_for_au
  00158	00 00 00 00	 DD	 $LN5@ast_for_au
  0015c	00 00 00 00	 DD	 $LN1@ast_for_au
$LN21@ast_for_au:
  00160	00		 DB	 0
  00161	01		 DB	 1
  00162	0a		 DB	 10
  00163	0a		 DB	 10
  00164	0a		 DB	 10
  00165	02		 DB	 2
  00166	03		 DB	 3
  00167	0a		 DB	 10
  00168	04		 DB	 4
  00169	0a		 DB	 10
  0016a	05		 DB	 5
  0016b	0a		 DB	 10
  0016c	0a		 DB	 10
  0016d	0a		 DB	 10
  0016e	0a		 DB	 10
  0016f	0a		 DB	 10
  00170	0a		 DB	 10
  00171	0a		 DB	 10
  00172	0a		 DB	 10
  00173	0a		 DB	 10
  00174	0a		 DB	 10
  00175	0a		 DB	 10
  00176	0a		 DB	 10
  00177	06		 DB	 6
  00178	0a		 DB	 10
  00179	07		 DB	 7
  0017a	0a		 DB	 10
  0017b	0a		 DB	 10
  0017c	0a		 DB	 10
  0017d	0a		 DB	 10
  0017e	0a		 DB	 10
  0017f	0a		 DB	 10
  00180	0a		 DB	 10
  00181	0a		 DB	 10
  00182	0a		 DB	 10
  00183	0a		 DB	 10
  00184	0a		 DB	 10
  00185	0a		 DB	 10
  00186	0a		 DB	 10
  00187	0a		 DB	 10
  00188	0a		 DB	 10
  00189	0a		 DB	 10
  0018a	0a		 DB	 10
  0018b	0a		 DB	 10
  0018c	0a		 DB	 10
  0018d	0a		 DB	 10
  0018e	0a		 DB	 10
  0018f	0a		 DB	 10
  00190	0a		 DB	 10
  00191	0a		 DB	 10
  00192	0a		 DB	 10
  00193	0a		 DB	 10
  00194	0a		 DB	 10
  00195	0a		 DB	 10
  00196	0a		 DB	 10
  00197	0a		 DB	 10
  00198	0a		 DB	 10
  00199	08		 DB	 8
  0019a	0a		 DB	 10
  0019b	0a		 DB	 10
  0019c	0a		 DB	 10
  0019d	0a		 DB	 10
  0019e	0a		 DB	 10
  0019f	0a		 DB	 10
  001a0	0a		 DB	 10
  001a1	0a		 DB	 10
  001a2	0a		 DB	 10
  001a3	0a		 DB	 10
  001a4	0a		 DB	 10
  001a5	0a		 DB	 10
  001a6	0a		 DB	 10
  001a7	0a		 DB	 10
  001a8	0a		 DB	 10
  001a9	0a		 DB	 10
  001aa	0a		 DB	 10
  001ab	0a		 DB	 10
  001ac	0a		 DB	 10
  001ad	0a		 DB	 10
  001ae	0a		 DB	 10
  001af	0a		 DB	 10
  001b0	0a		 DB	 10
  001b1	0a		 DB	 10
  001b2	0a		 DB	 10
  001b3	0a		 DB	 10
  001b4	0a		 DB	 10
  001b5	0a		 DB	 10
  001b6	0a		 DB	 10
  001b7	09		 DB	 9
ast_for_augassign ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@LBHPOLBO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA4?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_Delete:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_del_stmt DD imagerel ast_for_del_stmt
	DD	imagerel ast_for_del_stmt+147
	DD	imagerel $unwind$ast_for_del_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_del_stmt DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1CC@LBHPOLBO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA4?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@LBHPOLBO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA4?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '7'
	DB	00H, '4', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_del_stmt
_TEXT	SEGMENT
expr_list$ = 32
c$ = 64
n$ = 72
ast_for_del_stmt PROC					; COMDAT

; 2680 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2681 :     asdl_seq *expr_list;
; 2682 : 
; 2683 :     /* del_stmt: 'del' exprlist */
; 2684 :     REQ(n, del_stmt);

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 12 01 00 00	 cmp	 eax, 274		; 00000112H
  0001b	74 1c		 je	 SHORT $LN4@ast_for_de@4
  0001d	41 b8 7c 0a 00
	00		 mov	 r8d, 2684		; 00000a7cH
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@LBHPOLBO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA4?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN4@ast_for_de@4:

; 2685 : 
; 2686 :     expr_list = ast_for_exprlist(c, CHILD(n, 1), Del);

  00039	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0003e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00042	48 83 c0 28	 add	 rax, 40			; 00000028H
  00046	41 b8 03 00 00
	00		 mov	 r8d, 3
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00054	e8 00 00 00 00	 call	 ast_for_exprlist
  00059	48 89 44 24 20	 mov	 QWORD PTR expr_list$[rsp], rax

; 2687 :     if (!expr_list)

  0005e	48 83 7c 24 20
	00		 cmp	 QWORD PTR expr_list$[rsp], 0
  00064	75 04		 jne	 SHORT $LN1@ast_for_de@4

; 2688 :         return NULL;

  00066	33 c0		 xor	 eax, eax
  00068	eb 24		 jmp	 SHORT $LN2@ast_for_de@4
$LN1@ast_for_de@4:

; 2689 :     return Delete(expr_list, LINENO(n), n->n_col_offset, c->c_arena);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  0006f	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00073	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00078	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  0007c	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00081	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00084	48 8b 4c 24 20	 mov	 rcx, QWORD PTR expr_list$[rsp]
  00089	e8 00 00 00 00	 call	 _Py_Delete
$LN2@ast_for_de@4:

; 2690 : }

  0008e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00092	c3		 ret	 0
ast_for_del_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@MOBIIFJ@unhandled?5flow?5statement?$AA@ ; `string'
PUBLIC	??_C@_0BJ@GBCOJIIK@unexpected?5flow_stmt?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_1CC@PMLHEKBF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA6?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_Raise:PROC
EXTRN	_Py_Return:PROC
EXTRN	_Py_Continue:PROC
EXTRN	_Py_Break:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_flow_stmt DD imagerel ast_for_flow_stmt
	DD	imagerel ast_for_flow_stmt+729
	DD	imagerel $unwind$ast_for_flow_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_flow_stmt DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0BJ@MOBIIFJ@unhandled?5flow?5statement?$AA@
CONST	SEGMENT
??_C@_0BJ@MOBIIFJ@unhandled?5flow?5statement?$AA@ DB 'unhandled flow stat'
	DB	'ement', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GBCOJIIK@unexpected?5flow_stmt?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BJ@GBCOJIIK@unexpected?5flow_stmt?3?5?$CFd?$AA@ DB 'unexpected flo'
	DB	'w_stmt: %d', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@PMLHEKBF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA6?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@PMLHEKBF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA6?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '7'
	DB	00H, '6', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_flow_stmt
_TEXT	SEGMENT
ch$ = 48
exp$23803 = 56
expression$23810 = 64
expression$23821 = 72
cause$23819 = 80
tv72 = 88
c$ = 112
n$ = 120
ast_for_flow_stmt PROC					; COMDAT

; 2694 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2695 :     /*
; 2696 :       flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt
; 2697 :                  | yield_stmt
; 2698 :       break_stmt: 'break'
; 2699 :       continue_stmt: 'continue'
; 2700 :       return_stmt: 'return' [testlist]
; 2701 :       yield_stmt: yield_expr
; 2702 :       yield_expr: 'yield' testlist | 'yield' 'from' test
; 2703 :       raise_stmt: 'raise' [test [',' test [',' test]]]
; 2704 :     */
; 2705 :     node *ch;
; 2706 : 
; 2707 :     REQ(n, flow_stmt);

  0000e	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 14 01 00 00	 cmp	 eax, 276		; 00000114H
  0001b	74 1c		 je	 SHORT $LN21@ast_for_fl
  0001d	41 b8 93 0a 00
	00		 mov	 r8d, 2707		; 00000a93H
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@PMLHEKBF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA7?$AA6?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN21@ast_for_fl:

; 2708 :     ch = CHILD(n, 0);

  00039	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0003e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00042	48 89 44 24 30	 mov	 QWORD PTR ch$[rsp], rax

; 2709 :     switch (TYPE(ch)) {

  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR ch$[rsp]
  0004c	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0004f	89 44 24 58	 mov	 DWORD PTR tv72[rsp], eax
  00053	81 7c 24 58 15
	01 00 00	 cmp	 DWORD PTR tv72[rsp], 277 ; 00000115H
  0005b	74 35		 je	 SHORT $LN16@ast_for_fl
  0005d	81 7c 24 58 16
	01 00 00	 cmp	 DWORD PTR tv72[rsp], 278 ; 00000116H
  00065	74 4e		 je	 SHORT $LN15@ast_for_fl
  00067	81 7c 24 58 17
	01 00 00	 cmp	 DWORD PTR tv72[rsp], 279 ; 00000117H
  0006f	0f 84 b3 00 00
	00		 je	 $LN12@ast_for_fl
  00075	81 7c 24 58 18
	01 00 00	 cmp	 DWORD PTR tv72[rsp], 280 ; 00000118H
  0007d	74 59		 je	 SHORT $LN14@ast_for_fl
  0007f	81 7c 24 58 19
	01 00 00	 cmp	 DWORD PTR tv72[rsp], 281 ; 00000119H
  00087	0f 84 25 01 00
	00		 je	 $LN8@ast_for_fl
  0008d	e9 0b 02 00 00	 jmp	 $LN1@ast_for_fl
$LN16@ast_for_fl:

; 2710 :         case break_stmt:
; 2711 :             return Break(LINENO(n), n->n_col_offset, c->c_arena);

  00092	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00097	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0009b	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000a0	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  000a3	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000a8	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  000ab	e8 00 00 00 00	 call	 _Py_Break
  000b0	e9 1f 02 00 00	 jmp	 $LN19@ast_for_fl
$LN15@ast_for_fl:

; 2712 :         case continue_stmt:
; 2713 :             return Continue(LINENO(n), n->n_col_offset, c->c_arena);

  000b5	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  000ba	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000be	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000c3	8b 50 14	 mov	 edx, DWORD PTR [rax+20]
  000c6	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000cb	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  000ce	e8 00 00 00 00	 call	 _Py_Continue
  000d3	e9 fc 01 00 00	 jmp	 $LN19@ast_for_fl
$LN14@ast_for_fl:

; 2714 :         case yield_stmt: { /* will reduce to yield_expr */
; 2715 :             expr_ty exp = ast_for_expr(c, CHILD(ch, 0));

  000d8	48 8b 44 24 30	 mov	 rax, QWORD PTR ch$[rsp]
  000dd	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  000e1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000e6	e8 00 00 00 00	 call	 ast_for_expr
  000eb	48 89 44 24 38	 mov	 QWORD PTR exp$23803[rsp], rax

; 2716 :             if (!exp)

  000f0	48 83 7c 24 38
	00		 cmp	 QWORD PTR exp$23803[rsp], 0
  000f6	75 07		 jne	 SHORT $LN13@ast_for_fl

; 2717 :                 return NULL;

  000f8	33 c0		 xor	 eax, eax
  000fa	e9 d5 01 00 00	 jmp	 $LN19@ast_for_fl
$LN13@ast_for_fl:

; 2718 :             return Expr(exp, LINENO(n), n->n_col_offset, c->c_arena);

  000ff	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00104	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00108	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0010d	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  00111	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00116	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00119	48 8b 4c 24 38	 mov	 rcx, QWORD PTR exp$23803[rsp]
  0011e	e8 00 00 00 00	 call	 _Py_Expr
  00123	e9 ac 01 00 00	 jmp	 $LN19@ast_for_fl
$LN12@ast_for_fl:

; 2719 :         }
; 2720 :         case return_stmt:
; 2721 :             if (NCH(ch) == 1)

  00128	48 8b 44 24 30	 mov	 rax, QWORD PTR ch$[rsp]
  0012d	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00131	75 28		 jne	 SHORT $LN11@ast_for_fl

; 2722 :                 return Return(NULL, LINENO(n), n->n_col_offset, c->c_arena);

  00133	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00138	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  0013c	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00141	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  00145	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0014a	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  0014d	33 c9		 xor	 ecx, ecx
  0014f	e8 00 00 00 00	 call	 _Py_Return
  00154	e9 7b 01 00 00	 jmp	 $LN19@ast_for_fl

; 2723 :             else {

  00159	eb 57		 jmp	 SHORT $LN10@ast_for_fl
$LN11@ast_for_fl:

; 2724 :                 expr_ty expression = ast_for_testlist(c, CHILD(ch, 1));

  0015b	48 8b 44 24 30	 mov	 rax, QWORD PTR ch$[rsp]
  00160	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00164	48 83 c0 28	 add	 rax, 40			; 00000028H
  00168	48 8b d0	 mov	 rdx, rax
  0016b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00170	e8 00 00 00 00	 call	 ast_for_testlist
  00175	48 89 44 24 40	 mov	 QWORD PTR expression$23810[rsp], rax

; 2725 :                 if (!expression)

  0017a	48 83 7c 24 40
	00		 cmp	 QWORD PTR expression$23810[rsp], 0
  00180	75 07		 jne	 SHORT $LN9@ast_for_fl

; 2726 :                     return NULL;

  00182	33 c0		 xor	 eax, eax
  00184	e9 4b 01 00 00	 jmp	 $LN19@ast_for_fl
$LN9@ast_for_fl:

; 2727 :                 return Return(expression, LINENO(n), n->n_col_offset, c->c_arena);

  00189	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0018e	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00192	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00197	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  0019b	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  001a0	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  001a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR expression$23810[rsp]
  001a8	e8 00 00 00 00	 call	 _Py_Return
  001ad	e9 22 01 00 00	 jmp	 $LN19@ast_for_fl
$LN10@ast_for_fl:
$LN8@ast_for_fl:

; 2728 :             }
; 2729 :         case raise_stmt:
; 2730 :             if (NCH(ch) == 1)

  001b2	48 8b 44 24 30	 mov	 rax, QWORD PTR ch$[rsp]
  001b7	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  001bb	75 33		 jne	 SHORT $LN7@ast_for_fl

; 2731 :                 return Raise(NULL, NULL, LINENO(n), n->n_col_offset, c->c_arena);

  001bd	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  001c2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001cb	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  001d0	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  001d4	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  001d9	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  001dd	33 d2		 xor	 edx, edx
  001df	33 c9		 xor	 ecx, ecx
  001e1	e8 00 00 00 00	 call	 _Py_Raise
  001e6	e9 e9 00 00 00	 jmp	 $LN19@ast_for_fl
  001eb	e9 ad 00 00 00	 jmp	 $LN6@ast_for_fl
$LN7@ast_for_fl:

; 2732 :             else if (NCH(ch) >= 2) {

  001f0	48 8b 44 24 30	 mov	 rax, QWORD PTR ch$[rsp]
  001f5	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  001f9	0f 8c 9e 00 00
	00		 jl	 $LN5@ast_for_fl

; 2733 :                 expr_ty cause = NULL;

  001ff	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR cause$23819[rsp], 0

; 2734 :                 expr_ty expression = ast_for_expr(c, CHILD(ch, 1));

  00208	48 8b 44 24 30	 mov	 rax, QWORD PTR ch$[rsp]
  0020d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00211	48 83 c0 28	 add	 rax, 40			; 00000028H
  00215	48 8b d0	 mov	 rdx, rax
  00218	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0021d	e8 00 00 00 00	 call	 ast_for_expr
  00222	48 89 44 24 48	 mov	 QWORD PTR expression$23821[rsp], rax

; 2735 :                 if (!expression)

  00227	48 83 7c 24 48
	00		 cmp	 QWORD PTR expression$23821[rsp], 0
  0022d	75 07		 jne	 SHORT $LN4@ast_for_fl

; 2736 :                     return NULL;

  0022f	33 c0		 xor	 eax, eax
  00231	e9 9e 00 00 00	 jmp	 $LN19@ast_for_fl
$LN4@ast_for_fl:

; 2737 :                 if (NCH(ch) == 4) {

  00236	48 8b 44 24 30	 mov	 rax, QWORD PTR ch$[rsp]
  0023b	83 78 18 04	 cmp	 DWORD PTR [rax+24], 4
  0023f	75 2b		 jne	 SHORT $LN3@ast_for_fl

; 2738 :                     cause = ast_for_expr(c, CHILD(ch, 3));

  00241	48 8b 44 24 30	 mov	 rax, QWORD PTR ch$[rsp]
  00246	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0024a	48 83 c0 78	 add	 rax, 120		; 00000078H
  0024e	48 8b d0	 mov	 rdx, rax
  00251	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00256	e8 00 00 00 00	 call	 ast_for_expr
  0025b	48 89 44 24 50	 mov	 QWORD PTR cause$23819[rsp], rax

; 2739 :                     if (!cause)

  00260	48 83 7c 24 50
	00		 cmp	 QWORD PTR cause$23819[rsp], 0
  00266	75 04		 jne	 SHORT $LN2@ast_for_fl

; 2740 :                         return NULL;

  00268	33 c0		 xor	 eax, eax
  0026a	eb 68		 jmp	 SHORT $LN19@ast_for_fl
$LN2@ast_for_fl:
$LN3@ast_for_fl:

; 2741 :                 }
; 2742 :                 return Raise(expression, cause, LINENO(n), n->n_col_offset, c->c_arena);

  0026c	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00271	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00275	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027a	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0027f	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  00283	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00288	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  0028c	48 8b 54 24 50	 mov	 rdx, QWORD PTR cause$23819[rsp]
  00291	48 8b 4c 24 48	 mov	 rcx, QWORD PTR expression$23821[rsp]
  00296	e8 00 00 00 00	 call	 _Py_Raise
  0029b	eb 37		 jmp	 SHORT $LN19@ast_for_fl
$LN5@ast_for_fl:
$LN6@ast_for_fl:
$LN1@ast_for_fl:

; 2743 :             }
; 2744 :         default:
; 2745 :             PyErr_Format(PyExc_SystemError,
; 2746 :                          "unexpected flow_stmt: %d", TYPE(ch));

  0029d	48 8b 44 24 30	 mov	 rax, QWORD PTR ch$[rsp]
  002a2	0f bf 00	 movsx	 eax, WORD PTR [rax]
  002a5	44 8b c0	 mov	 r8d, eax
  002a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GBCOJIIK@unexpected?5flow_stmt?3?5?$CFd?$AA@
  002af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  002b6	e8 00 00 00 00	 call	 PyErr_Format

; 2747 :             return NULL;

  002bb	33 c0		 xor	 eax, eax
  002bd	eb 15		 jmp	 SHORT $LN19@ast_for_fl

; 2748 :     }
; 2749 : 
; 2750 :     PyErr_SetString(PyExc_SystemError, "unhandled flow statement");

  002bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@MOBIIFJ@unhandled?5flow?5statement?$AA@
  002c6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  002cd	e8 00 00 00 00	 call	 PyErr_SetString

; 2751 :     return NULL;

  002d2	33 c0		 xor	 eax, eax
$LN19@ast_for_fl:

; 2752 : }

  002d4	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002d8	c3		 ret	 0
ast_for_flow_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@FCJHOKGM@unknown?5import?5statement?3?5starts@ ; `string'
PUBLIC	??_C@_0CE@KFALHAEB@Unexpected?5node?9type?5in?5from?9imp@ ; `string'
PUBLIC	??_C@_0DL@FACCMHDI@trailing?5comma?5not?5allowed?5witho@ ; `string'
PUBLIC	??_C@_1EO@OMNNPDFB@?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1CC@BPJNDJMJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA8?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@LOAGBKKP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA2?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_ImportFrom:PROC
EXTRN	_Py_Import:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_import_stmt DD imagerel ast_for_import_stmt
	DD	imagerel ast_for_import_stmt+1630
	DD	imagerel $unwind$ast_for_import_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_import_stmt DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0DD@FCJHOKGM@unknown?5import?5statement?3?5starts@
CONST	SEGMENT
??_C@_0DD@FCJHOKGM@unknown?5import?5statement?3?5starts@ DB 'unknown impo'
	DB	'rt statement: starts with command ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KFALHAEB@Unexpected?5node?9type?5in?5from?9imp@
CONST	SEGMENT
??_C@_0CE@KFALHAEB@Unexpected?5node?9type?5in?5from?9imp@ DB 'Unexpected '
	DB	'node-type in from-import', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@FACCMHDI@trailing?5comma?5not?5allowed?5witho@
CONST	SEGMENT
??_C@_0DL@FACCMHDI@trailing?5comma?5not?5allowed?5witho@ DB 'trailing com'
	DB	'ma not allowed without surrounding parentheses', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@OMNNPDFB@?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ@
CONST	SEGMENT
??_C@_1EO@OMNNPDFB@?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ@ DB '('
	DB	00H, 'a', 00H, 'l', 00H, 'i', 00H, 'a', 00H, 's', 00H, 'e', 00H
	DB	's', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_'
	DB	00H, 'a', 00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H, 'i', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, '(', 00H, 'a', 00H, 'l', 00H, 'i'
	DB	00H, 'a', 00H, 's', 00H, 'e', 00H, 's', 00H, ')', 00H, '-', 00H
	DB	'>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@BPJNDJMJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA8?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@BPJNDJMJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA8?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '8'
	DB	00H, '8', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@LOAGBKKP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA2?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@LOAGBKKP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA2?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '8'
	DB	00H, '2', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_import_stmt
_TEXT	SEGMENT
aliases$ = 48
i$ = 56
lineno$ = 60
col_offset$ = 64
import_alias$23942 = 72
_asdl_i$23945 = 80
ndots$23952 = 84
n_children$23950 = 88
idx$23951 = 92
modname$23955 = 96
mod$23953 = 104
import_alias$23983 = 112
_asdl_i$23986 = 120
import_alias$23992 = 128
_asdl_i$23995 = 136
tv195 = 140
c$ = 160
n$ = 168
ast_for_import_stmt PROC				; COMDAT

; 2869 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2870 :     /*
; 2871 :       import_stmt: import_name | import_from
; 2872 :       import_name: 'import' dotted_as_names
; 2873 :       import_from: 'from' (('.' | '...')* dotted_name | ('.' | '...')+)
; 2874 :                    'import' ('*' | '(' import_as_names ')' | import_as_names)
; 2875 :     */
; 2876 :     int lineno;
; 2877 :     int col_offset;
; 2878 :     int i;
; 2879 :     asdl_seq *aliases;
; 2880 : 
; 2881 :     REQ(n, import_stmt);

  00011	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00019	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0001c	3d 1a 01 00 00	 cmp	 eax, 282		; 0000011aH
  00021	74 1c		 je	 SHORT $LN36@ast_for_im
  00023	41 b8 41 0b 00
	00		 mov	 r8d, 2881		; 00000b41H
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@LOAGBKKP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA2?$AA?$CJ?$AA?$AA@
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003d	33 c0		 xor	 eax, eax
$LN36@ast_for_im:

; 2882 :     lineno = LINENO(n);

  0003f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00047	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0004a	89 44 24 3c	 mov	 DWORD PTR lineno$[rsp], eax

; 2883 :     col_offset = n->n_col_offset;

  0004e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00056	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00059	89 44 24 40	 mov	 DWORD PTR col_offset$[rsp], eax

; 2884 :     n = CHILD(n, 0);

  0005d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00065	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00069	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2885 :     if (TYPE(n) == import_name) {

  00071	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00079	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0007c	3d 1b 01 00 00	 cmp	 eax, 283		; 0000011bH
  00081	0f 85 6d 01 00
	00		 jne	 $LN33@ast_for_im

; 2886 :         n = CHILD(n, 1);

  00087	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0008f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00093	48 83 c0 28	 add	 rax, 40			; 00000028H
  00097	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2887 :         REQ(n, dotted_as_names);

  0009f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000a7	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000aa	3d 20 01 00 00	 cmp	 eax, 288		; 00000120H
  000af	74 1c		 je	 SHORT $LN37@ast_for_im
  000b1	41 b8 47 0b 00
	00		 mov	 r8d, 2887		; 00000b47H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@BPJNDJMJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA8?$AA8?$AA?$CJ?$AA?$AA@
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000cb	33 c0		 xor	 eax, eax
$LN37@ast_for_im:

; 2888 :         aliases = asdl_seq_new((NCH(n) + 1) / 2, c->c_arena);

  000cd	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000d5	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000d8	ff c0		 inc	 eax
  000da	99		 cdq
  000db	2b c2		 sub	 eax, edx
  000dd	d1 f8		 sar	 eax, 1
  000df	48 98		 cdqe
  000e1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000e9	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  000ed	48 8b c8	 mov	 rcx, rax
  000f0	e8 00 00 00 00	 call	 asdl_seq_new
  000f5	48 89 44 24 30	 mov	 QWORD PTR aliases$[rsp], rax

; 2889 :         if (!aliases)

  000fa	48 83 7c 24 30
	00		 cmp	 QWORD PTR aliases$[rsp], 0
  00100	75 07		 jne	 SHORT $LN32@ast_for_im

; 2890 :                 return NULL;

  00102	33 c0		 xor	 eax, eax
  00104	e9 4d 05 00 00	 jmp	 $LN34@ast_for_im
$LN32@ast_for_im:

; 2891 :         for (i = 0; i < NCH(n); i += 2) {

  00109	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00111	eb 0b		 jmp	 SHORT $LN31@ast_for_im
$LN30@ast_for_im:
  00113	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00117	83 c0 02	 add	 eax, 2
  0011a	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN31@ast_for_im:
  0011e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00126	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00129	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  0012d	0f 8d 98 00 00
	00		 jge	 $LN29@ast_for_im

; 2892 :             alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);

  00133	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$[rsp]
  00138	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0013c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00144	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00148	41 b8 01 00 00
	00		 mov	 r8d, 1
  0014e	48 8b d0	 mov	 rdx, rax
  00151	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00159	e8 00 00 00 00	 call	 alias_for_import_name
  0015e	48 89 44 24 48	 mov	 QWORD PTR import_alias$23942[rsp], rax

; 2893 :             if (!import_alias)

  00163	48 83 7c 24 48
	00		 cmp	 QWORD PTR import_alias$23942[rsp], 0
  00169	75 07		 jne	 SHORT $LN28@ast_for_im

; 2894 :                 return NULL;

  0016b	33 c0		 xor	 eax, eax
  0016d	e9 e4 04 00 00	 jmp	 $LN34@ast_for_im
$LN28@ast_for_im:

; 2895 :             asdl_seq_SET(aliases, i / 2, import_alias);

  00172	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00176	99		 cdq
  00177	2b c2		 sub	 eax, edx
  00179	d1 f8		 sar	 eax, 1
  0017b	89 44 24 50	 mov	 DWORD PTR _asdl_i$23945[rsp], eax
  0017f	48 83 7c 24 30
	00		 cmp	 QWORD PTR aliases$[rsp], 0
  00185	74 0f		 je	 SHORT $LN38@ast_for_im
  00187	48 63 44 24 50	 movsxd	 rax, DWORD PTR _asdl_i$23945[rsp]
  0018c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR aliases$[rsp]
  00191	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00194	7c 1c		 jl	 SHORT $LN39@ast_for_im
$LN38@ast_for_im:
  00196	41 b8 4f 0b 00
	00		 mov	 r8d, 2895		; 00000b4fH
  0019c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@OMNNPDFB@?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ@
  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b0	33 c0		 xor	 eax, eax
$LN39@ast_for_im:
  001b2	48 63 44 24 50	 movsxd	 rax, DWORD PTR _asdl_i$23945[rsp]
  001b7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR aliases$[rsp]
  001bc	48 8b 54 24 48	 mov	 rdx, QWORD PTR import_alias$23942[rsp]
  001c1	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 2896 :         }

  001c6	e9 48 ff ff ff	 jmp	 $LN30@ast_for_im
$LN29@ast_for_im:

; 2897 :         return Import(aliases, lineno, col_offset, c->c_arena);

  001cb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  001d3	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  001d7	44 8b 44 24 40	 mov	 r8d, DWORD PTR col_offset$[rsp]
  001dc	8b 54 24 3c	 mov	 edx, DWORD PTR lineno$[rsp]
  001e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR aliases$[rsp]
  001e5	e8 00 00 00 00	 call	 _Py_Import
  001ea	e9 67 04 00 00	 jmp	 $LN34@ast_for_im
  001ef	e9 3d 04 00 00	 jmp	 $LN27@ast_for_im
$LN33@ast_for_im:

; 2898 :     }
; 2899 :     else if (TYPE(n) == import_from) {

  001f4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001fc	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001ff	3d 1c 01 00 00	 cmp	 eax, 284		; 0000011cH
  00204	0f 85 27 04 00
	00		 jne	 $LN26@ast_for_im

; 2900 :         int n_children;
; 2901 :         int idx, ndots = 0;

  0020a	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR ndots$23952[rsp], 0

; 2902 :         alias_ty mod = NULL;

  00212	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR mod$23953[rsp], 0

; 2903 :         identifier modname = NULL;

  0021b	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR modname$23955[rsp], 0

; 2904 : 
; 2905 :        /* Count the number of dots (for relative imports) and check for the
; 2906 :           optional module name */
; 2907 :         for (idx = 1; idx < NCH(n); idx++) {

  00224	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR idx$23951[rsp], 1
  0022c	eb 0a		 jmp	 SHORT $LN25@ast_for_im
$LN24@ast_for_im:
  0022e	8b 44 24 5c	 mov	 eax, DWORD PTR idx$23951[rsp]
  00232	ff c0		 inc	 eax
  00234	89 44 24 5c	 mov	 DWORD PTR idx$23951[rsp], eax
$LN25@ast_for_im:
  00238	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00240	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00243	39 44 24 5c	 cmp	 DWORD PTR idx$23951[rsp], eax
  00247	0f 8d c9 00 00
	00		 jge	 $LN23@ast_for_im

; 2908 :             if (TYPE(CHILD(n, idx)) == dotted_name) {

  0024d	48 63 44 24 5c	 movsxd	 rax, DWORD PTR idx$23951[rsp]
  00252	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00256	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0025e	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00262	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00266	3d 21 01 00 00	 cmp	 eax, 289		; 00000121H
  0026b	75 4a		 jne	 SHORT $LN22@ast_for_im

; 2909 :                 mod = alias_for_import_name(c, CHILD(n, idx), 0);

  0026d	48 63 44 24 5c	 movsxd	 rax, DWORD PTR idx$23951[rsp]
  00272	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00276	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0027e	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00282	45 33 c0	 xor	 r8d, r8d
  00285	48 8b d0	 mov	 rdx, rax
  00288	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00290	e8 00 00 00 00	 call	 alias_for_import_name
  00295	48 89 44 24 68	 mov	 QWORD PTR mod$23953[rsp], rax

; 2910 :                 if (!mod)

  0029a	48 83 7c 24 68
	00		 cmp	 QWORD PTR mod$23953[rsp], 0
  002a0	75 07		 jne	 SHORT $LN21@ast_for_im

; 2911 :                     return NULL;

  002a2	33 c0		 xor	 eax, eax
  002a4	e9 ad 03 00 00	 jmp	 $LN34@ast_for_im
$LN21@ast_for_im:

; 2912 :                 idx++;

  002a9	8b 44 24 5c	 mov	 eax, DWORD PTR idx$23951[rsp]
  002ad	ff c0		 inc	 eax
  002af	89 44 24 5c	 mov	 DWORD PTR idx$23951[rsp], eax

; 2913 :                 break;

  002b3	eb 61		 jmp	 SHORT $LN23@ast_for_im
  002b5	eb 50		 jmp	 SHORT $LN20@ast_for_im
$LN22@ast_for_im:

; 2914 :             } else if (TYPE(CHILD(n, idx)) == ELLIPSIS) {

  002b7	48 63 44 24 5c	 movsxd	 rax, DWORD PTR idx$23951[rsp]
  002bc	48 6b c0 28	 imul	 rax, 40			; 00000028H
  002c0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  002c8	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  002cc	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  002d0	83 f8 33	 cmp	 eax, 51			; 00000033H
  002d3	75 12		 jne	 SHORT $LN19@ast_for_im

; 2915 :                 /* three consecutive dots are tokenized as one ELLIPSIS */
; 2916 :                 ndots += 3;

  002d5	8b 44 24 54	 mov	 eax, DWORD PTR ndots$23952[rsp]
  002d9	83 c0 03	 add	 eax, 3
  002dc	89 44 24 54	 mov	 DWORD PTR ndots$23952[rsp], eax

; 2917 :                 continue;

  002e0	e9 49 ff ff ff	 jmp	 $LN24@ast_for_im
  002e5	eb 20		 jmp	 SHORT $LN18@ast_for_im
$LN19@ast_for_im:

; 2918 :             } else if (TYPE(CHILD(n, idx)) != DOT) {

  002e7	48 63 44 24 5c	 movsxd	 rax, DWORD PTR idx$23951[rsp]
  002ec	48 6b c0 28	 imul	 rax, 40			; 00000028H
  002f0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  002f8	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  002fc	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00300	83 f8 17	 cmp	 eax, 23
  00303	74 02		 je	 SHORT $LN17@ast_for_im

; 2919 :                 break;

  00305	eb 0f		 jmp	 SHORT $LN23@ast_for_im
$LN17@ast_for_im:
$LN18@ast_for_im:
$LN20@ast_for_im:

; 2920 :             }
; 2921 :             ndots++;

  00307	8b 44 24 54	 mov	 eax, DWORD PTR ndots$23952[rsp]
  0030b	ff c0		 inc	 eax
  0030d	89 44 24 54	 mov	 DWORD PTR ndots$23952[rsp], eax

; 2922 :         }

  00311	e9 18 ff ff ff	 jmp	 $LN24@ast_for_im
$LN23@ast_for_im:

; 2923 :         idx++; /* skip over the 'import' keyword */

  00316	8b 44 24 5c	 mov	 eax, DWORD PTR idx$23951[rsp]
  0031a	ff c0		 inc	 eax
  0031c	89 44 24 5c	 mov	 DWORD PTR idx$23951[rsp], eax

; 2924 :         switch (TYPE(CHILD(n, idx))) {

  00320	48 63 44 24 5c	 movsxd	 rax, DWORD PTR idx$23951[rsp]
  00325	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00329	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00331	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00335	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00339	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv195[rsp], eax
  00340	83 bc 24 8c 00
	00 00 07	 cmp	 DWORD PTR tv195[rsp], 7
  00348	74 46		 je	 SHORT $LN13@ast_for_im
  0034a	83 bc 24 8c 00
	00 00 10	 cmp	 DWORD PTR tv195[rsp], 16
  00352	74 12		 je	 SHORT $LN14@ast_for_im
  00354	81 bc 24 8c 00
	00 00 1f 01 00
	00		 cmp	 DWORD PTR tv195[rsp], 287 ; 0000011fH
  0035f	74 63		 je	 SHORT $LN12@ast_for_im
  00361	e9 bf 00 00 00	 jmp	 $LN10@ast_for_im
$LN14@ast_for_im:

; 2925 :         case STAR:
; 2926 :             /* from ... import * */
; 2927 :             n = CHILD(n, idx);

  00366	48 63 44 24 5c	 movsxd	 rax, DWORD PTR idx$23951[rsp]
  0036b	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0036f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00377	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0037b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2928 :             n_children = 1;

  00383	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR n_children$23950[rsp], 1

; 2929 :             break;

  0038b	e9 b8 00 00 00	 jmp	 $LN15@ast_for_im
$LN13@ast_for_im:

; 2930 :         case LPAR:
; 2931 :             /* from ... import (x, y, z) */
; 2932 :             n = CHILD(n, idx + 1);

  00390	8b 44 24 5c	 mov	 eax, DWORD PTR idx$23951[rsp]
  00394	ff c0		 inc	 eax
  00396	48 98		 cdqe
  00398	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0039c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  003a4	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  003a8	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2933 :             n_children = NCH(n);

  003b0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003b8	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003bb	89 44 24 58	 mov	 DWORD PTR n_children$23950[rsp], eax

; 2934 :             break;

  003bf	e9 84 00 00 00	 jmp	 $LN15@ast_for_im
$LN12@ast_for_im:

; 2935 :         case import_as_names:
; 2936 :             /* from ... import x, y, z */
; 2937 :             n = CHILD(n, idx);

  003c4	48 63 44 24 5c	 movsxd	 rax, DWORD PTR idx$23951[rsp]
  003c9	48 6b c0 28	 imul	 rax, 40			; 00000028H
  003cd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  003d5	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  003d9	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2938 :             n_children = NCH(n);

  003e1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003e9	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003ec	89 44 24 58	 mov	 DWORD PTR n_children$23950[rsp], eax

; 2939 :             if (n_children % 2 == 0) {

  003f0	8b 44 24 58	 mov	 eax, DWORD PTR n_children$23950[rsp]
  003f4	99		 cdq
  003f5	83 e0 01	 and	 eax, 1
  003f8	33 c2		 xor	 eax, edx
  003fa	2b c2		 sub	 eax, edx
  003fc	85 c0		 test	 eax, eax
  003fe	75 23		 jne	 SHORT $LN11@ast_for_im

; 2940 :                 ast_error(c, n, "trailing comma not allowed without"
; 2941 :                              " surrounding parentheses");

  00400	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0DL@FACCMHDI@trailing?5comma?5not?5allowed?5witho@
  00407	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  0040f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00417	e8 00 00 00 00	 call	 ast_error

; 2942 :                 return NULL;

  0041c	33 c0		 xor	 eax, eax
  0041e	e9 33 02 00 00	 jmp	 $LN34@ast_for_im
$LN11@ast_for_im:

; 2943 :             }
; 2944 :             break;

  00423	eb 23		 jmp	 SHORT $LN15@ast_for_im
$LN10@ast_for_im:

; 2945 :         default:
; 2946 :             ast_error(c, n, "Unexpected node-type in from-import");

  00425	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CE@KFALHAEB@Unexpected?5node?9type?5in?5from?9imp@
  0042c	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  00434	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0043c	e8 00 00 00 00	 call	 ast_error

; 2947 :             return NULL;

  00441	33 c0		 xor	 eax, eax
  00443	e9 0e 02 00 00	 jmp	 $LN34@ast_for_im
$LN15@ast_for_im:

; 2948 :         }
; 2949 : 
; 2950 :         aliases = asdl_seq_new((n_children + 1) / 2, c->c_arena);

  00448	8b 44 24 58	 mov	 eax, DWORD PTR n_children$23950[rsp]
  0044c	ff c0		 inc	 eax
  0044e	99		 cdq
  0044f	2b c2		 sub	 eax, edx
  00451	d1 f8		 sar	 eax, 1
  00453	48 98		 cdqe
  00455	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0045d	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00461	48 8b c8	 mov	 rcx, rax
  00464	e8 00 00 00 00	 call	 asdl_seq_new
  00469	48 89 44 24 30	 mov	 QWORD PTR aliases$[rsp], rax

; 2951 :         if (!aliases)

  0046e	48 83 7c 24 30
	00		 cmp	 QWORD PTR aliases$[rsp], 0
  00474	75 07		 jne	 SHORT $LN9@ast_for_im

; 2952 :             return NULL;

  00476	33 c0		 xor	 eax, eax
  00478	e9 d9 01 00 00	 jmp	 $LN34@ast_for_im
$LN9@ast_for_im:

; 2953 : 
; 2954 :         /* handle "from ... import *" special b/c there's no children */
; 2955 :         if (TYPE(n) == STAR) {

  0047d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00485	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00488	83 f8 10	 cmp	 eax, 16
  0048b	0f 85 83 00 00
	00		 jne	 $LN8@ast_for_im

; 2956 :             alias_ty import_alias = alias_for_import_name(c, n, 1);

  00491	41 b8 01 00 00
	00		 mov	 r8d, 1
  00497	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  0049f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  004a7	e8 00 00 00 00	 call	 alias_for_import_name
  004ac	48 89 44 24 70	 mov	 QWORD PTR import_alias$23983[rsp], rax

; 2957 :             if (!import_alias)

  004b1	48 83 7c 24 70
	00		 cmp	 QWORD PTR import_alias$23983[rsp], 0
  004b7	75 07		 jne	 SHORT $LN7@ast_for_im

; 2958 :                 return NULL;

  004b9	33 c0		 xor	 eax, eax
  004bb	e9 96 01 00 00	 jmp	 $LN34@ast_for_im
$LN7@ast_for_im:

; 2959 :                 asdl_seq_SET(aliases, 0, import_alias);

  004c0	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR _asdl_i$23986[rsp], 0
  004c8	48 83 7c 24 30
	00		 cmp	 QWORD PTR aliases$[rsp], 0
  004ce	74 0f		 je	 SHORT $LN40@ast_for_im
  004d0	48 63 44 24 78	 movsxd	 rax, DWORD PTR _asdl_i$23986[rsp]
  004d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR aliases$[rsp]
  004da	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  004dd	7c 1c		 jl	 SHORT $LN41@ast_for_im
$LN40@ast_for_im:
  004df	41 b8 8f 0b 00
	00		 mov	 r8d, 2959		; 00000b8fH
  004e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  004ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@OMNNPDFB@?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ@
  004f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004f9	33 c0		 xor	 eax, eax
$LN41@ast_for_im:
  004fb	48 63 44 24 78	 movsxd	 rax, DWORD PTR _asdl_i$23986[rsp]
  00500	48 8b 4c 24 30	 mov	 rcx, QWORD PTR aliases$[rsp]
  00505	48 8b 54 24 70	 mov	 rdx, QWORD PTR import_alias$23983[rsp]
  0050a	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 2960 :         }
; 2961 :         else {

  0050f	e9 d4 00 00 00	 jmp	 $LN6@ast_for_im
$LN8@ast_for_im:

; 2962 :             for (i = 0; i < NCH(n); i += 2) {

  00514	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0051c	eb 0b		 jmp	 SHORT $LN5@ast_for_im
$LN4@ast_for_im:
  0051e	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00522	83 c0 02	 add	 eax, 2
  00525	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN5@ast_for_im:
  00529	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00531	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00534	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00538	0f 8d aa 00 00
	00		 jge	 $LN3@ast_for_im

; 2963 :                 alias_ty import_alias = alias_for_import_name(c, CHILD(n, i), 1);

  0053e	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$[rsp]
  00543	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00547	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0054f	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00553	41 b8 01 00 00
	00		 mov	 r8d, 1
  00559	48 8b d0	 mov	 rdx, rax
  0055c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00564	e8 00 00 00 00	 call	 alias_for_import_name
  00569	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR import_alias$23992[rsp], rax

; 2964 :                 if (!import_alias)

  00571	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR import_alias$23992[rsp], 0
  0057a	75 07		 jne	 SHORT $LN2@ast_for_im

; 2965 :                     return NULL;

  0057c	33 c0		 xor	 eax, eax
  0057e	e9 d3 00 00 00	 jmp	 $LN34@ast_for_im
$LN2@ast_for_im:

; 2966 :                     asdl_seq_SET(aliases, i / 2, import_alias);

  00583	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00587	99		 cdq
  00588	2b c2		 sub	 eax, edx
  0058a	d1 f8		 sar	 eax, 1
  0058c	89 84 24 88 00
	00 00		 mov	 DWORD PTR _asdl_i$23995[rsp], eax
  00593	48 83 7c 24 30
	00		 cmp	 QWORD PTR aliases$[rsp], 0
  00599	74 12		 je	 SHORT $LN42@ast_for_im
  0059b	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23995[rsp]
  005a3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR aliases$[rsp]
  005a8	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  005ab	7c 1c		 jl	 SHORT $LN43@ast_for_im
$LN42@ast_for_im:
  005ad	41 b8 96 0b 00
	00		 mov	 r8d, 2966		; 00000b96H
  005b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  005ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@OMNNPDFB@?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAa?$AAl?$AAi?$AAa?$AAs?$AAe?$AAs?$AA?$CJ@
  005c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005c7	33 c0		 xor	 eax, eax
$LN43@ast_for_im:
  005c9	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$23995[rsp]
  005d1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR aliases$[rsp]
  005d6	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR import_alias$23992[rsp]
  005de	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 2967 :             }

  005e3	e9 36 ff ff ff	 jmp	 $LN4@ast_for_im
$LN3@ast_for_im:
$LN6@ast_for_im:

; 2968 :         }
; 2969 :         if (mod != NULL)

  005e8	48 83 7c 24 68
	00		 cmp	 QWORD PTR mod$23953[rsp], 0
  005ee	74 0d		 je	 SHORT $LN1@ast_for_im

; 2970 :             modname = mod->name;

  005f0	48 8b 44 24 68	 mov	 rax, QWORD PTR mod$23953[rsp]
  005f5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005f8	48 89 44 24 60	 mov	 QWORD PTR modname$23955[rsp], rax
$LN1@ast_for_im:

; 2971 :         return ImportFrom(modname, aliases, ndots, lineno, col_offset,
; 2972 :                           c->c_arena);

  005fd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00605	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00609	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0060e	8b 44 24 40	 mov	 eax, DWORD PTR col_offset$[rsp]
  00612	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00616	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR lineno$[rsp]
  0061b	44 8b 44 24 54	 mov	 r8d, DWORD PTR ndots$23952[rsp]
  00620	48 8b 54 24 30	 mov	 rdx, QWORD PTR aliases$[rsp]
  00625	48 8b 4c 24 60	 mov	 rcx, QWORD PTR modname$23955[rsp]
  0062a	e8 00 00 00 00	 call	 _Py_ImportFrom
  0062f	eb 25		 jmp	 SHORT $LN34@ast_for_im
$LN26@ast_for_im:
$LN27@ast_for_im:

; 2973 :     }
; 2974 :     PyErr_Format(PyExc_SystemError,
; 2975 :                  "unknown import statement: starts with command '%s'",
; 2976 :                  STR(CHILD(n, 0)));

  00631	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00639	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0063d	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00641	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@FCJHOKGM@unknown?5import?5statement?3?5starts@
  00648	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0064f	e8 00 00 00 00	 call	 PyErr_Format

; 2977 :     return NULL;

  00654	33 c0		 xor	 eax, eax
$LN34@ast_for_im:

; 2978 : }

  00656	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0065d	c3		 ret	 0
ast_for_import_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@ICDONEOB@unhandled?5import?5name?5condition?$AA@ ; `string'
PUBLIC	??_C@_0BL@LEDBAIDM@unexpected?5import?5name?3?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK?$AA@			; `string'
PUBLIC	??_C@_1CG@HELEBNCJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@NEIOAFNM@?$AA?$CB?$AAa?$AA?9?$AA?$DO?$AAa?$AAs?$AAn?$AAa?$AAm?$AAe?$AA?$AA@ ; `string'
EXTRN	PyUnicode_InternFromString:PROC
EXTRN	strcpy:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	_Py_alias:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$alias_for_import_name DD imagerel alias_for_import_name
	DD	imagerel alias_for_import_name+1549
	DD	imagerel $unwind$alias_for_import_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$alias_for_import_name DD 021601H
	DD	0130116H
xdata	ENDS
;	COMDAT ??_C@_0CA@ICDONEOB@unhandled?5import?5name?5condition?$AA@
CONST	SEGMENT
??_C@_0CA@ICDONEOB@unhandled?5import?5name?5condition?$AA@ DB 'unhandled '
	DB	'import name condition', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LEDBAIDM@unexpected?5import?5name?3?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BL@LEDBAIDM@unexpected?5import?5name?3?5?$CFd?$AA@ DB 'unexpected '
	DB	'import name: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK?$AA@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK?$AA@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@HELEBNCJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@HELEBNCJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@NEIOAFNM@?$AA?$CB?$AAa?$AA?9?$AA?$DO?$AAa?$AAs?$AAn?$AAa?$AAm?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@NEIOAFNM@?$AA?$CB?$AAa?$AA?9?$AA?$DO?$AAa?$AAs?$AAn?$AAa?$AAm?$AAe?$AA?$AA@ DB '!'
	DB	00H, 'a', 00H, '-', 00H, '>', 00H, 'a', 00H, 's', 00H, 'n', 00H
	DB	'a', 00H, 'm', 00H, 'e', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT alias_for_import_name
_TEXT	SEGMENT
name$ = 32
str$ = 40
name_node$23848 = 48
str_node$23853 = 56
a$23865 = 64
asname_node$23864 = 72
name_node$23876 = 80
uni$23886 = 88
i$23883 = 96
s$23885 = 104
len$23884 = 112
sch$23902 = 120
tv65 = 128
c$ = 160
n$ = 168
store$ = 176
alias_for_import_name PROC				; COMDAT

; 2756 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
$loop$23842:

; 2757 :     /*
; 2758 :       import_as_name: NAME ['as' NAME]
; 2759 :       dotted_as_name: dotted_name ['as' NAME]
; 2760 :       dotted_name: NAME ('.' NAME)*
; 2761 :     */
; 2762 :     identifier str, name;
; 2763 : 
; 2764 :  loop:
; 2765 :     switch (TYPE(n)) {

  00016	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0001e	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00021	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv65[rsp], eax
  00028	83 bc 24 80 00
	00 00 10	 cmp	 DWORD PTR tv65[rsp], 16
  00030	0f 84 54 05 00
	00		 je	 $LN2@alias_for_
  00036	81 bc 24 80 00
	00 00 1d 01 00
	00		 cmp	 DWORD PTR tv65[rsp], 285 ; 0000011dH
  00041	74 27		 je	 SHORT $LN29@alias_for_
  00043	81 bc 24 80 00
	00 00 1e 01 00
	00		 cmp	 DWORD PTR tv65[rsp], 286 ; 0000011eH
  0004e	0f 84 1d 01 00
	00		 je	 $LN22@alias_for_
  00054	81 bc 24 80 00
	00 00 21 01 00
	00		 cmp	 DWORD PTR tv65[rsp], 289 ; 00000121H
  0005f	0f 84 0f 02 00
	00		 je	 $LN16@alias_for_
  00065	e9 61 05 00 00	 jmp	 $LN1@alias_for_
$LN29@alias_for_:

; 2766 :         case import_as_name: {
; 2767 :             node *name_node = CHILD(n, 0);

  0006a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00072	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00076	48 89 44 24 30	 mov	 QWORD PTR name_node$23848[rsp], rax

; 2768 :             str = NULL;

  0007b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR str$[rsp], 0

; 2769 :             name = NEW_IDENTIFIER(name_node);

  00084	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  0008c	48 8b 44 24 30	 mov	 rax, QWORD PTR name_node$23848[rsp]
  00091	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00095	e8 00 00 00 00	 call	 new_identifier
  0009a	48 89 44 24 20	 mov	 QWORD PTR name$[rsp], rax

; 2770 :             if (!name)

  0009f	48 83 7c 24 20
	00		 cmp	 QWORD PTR name$[rsp], 0
  000a5	75 07		 jne	 SHORT $LN28@alias_for_

; 2771 :                 return NULL;

  000a7	33 c0		 xor	 eax, eax
  000a9	e9 57 05 00 00	 jmp	 $LN32@alias_for_
$LN28@alias_for_:

; 2772 :             if (NCH(n) == 3) {

  000ae	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000b6	83 78 18 03	 cmp	 DWORD PTR [rax+24], 3
  000ba	75 70		 jne	 SHORT $LN27@alias_for_

; 2773 :                 node *str_node = CHILD(n, 2);

  000bc	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000c4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000c8	48 83 c0 50	 add	 rax, 80			; 00000050H
  000cc	48 89 44 24 38	 mov	 QWORD PTR str_node$23853[rsp], rax

; 2774 :                 str = NEW_IDENTIFIER(str_node);

  000d1	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  000d9	48 8b 44 24 38	 mov	 rax, QWORD PTR str_node$23853[rsp]
  000de	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000e2	e8 00 00 00 00	 call	 new_identifier
  000e7	48 89 44 24 28	 mov	 QWORD PTR str$[rsp], rax

; 2775 :                 if (!str)

  000ec	48 83 7c 24 28
	00		 cmp	 QWORD PTR str$[rsp], 0
  000f2	75 07		 jne	 SHORT $LN26@alias_for_

; 2776 :                     return NULL;

  000f4	33 c0		 xor	 eax, eax
  000f6	e9 0a 05 00 00	 jmp	 $LN32@alias_for_
$LN26@alias_for_:

; 2777 :                 if (store && forbidden_name(c, str, str_node, 0))

  000fb	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR store$[rsp], 0
  00103	74 25		 je	 SHORT $LN25@alias_for_
  00105	45 33 c9	 xor	 r9d, r9d
  00108	4c 8b 44 24 38	 mov	 r8, QWORD PTR str_node$23853[rsp]
  0010d	48 8b 54 24 28	 mov	 rdx, QWORD PTR str$[rsp]
  00112	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0011a	e8 00 00 00 00	 call	 forbidden_name
  0011f	85 c0		 test	 eax, eax
  00121	74 07		 je	 SHORT $LN25@alias_for_

; 2778 :                     return NULL;

  00123	33 c0		 xor	 eax, eax
  00125	e9 db 04 00 00	 jmp	 $LN32@alias_for_
$LN25@alias_for_:

; 2779 :             }
; 2780 :             else {

  0012a	eb 25		 jmp	 SHORT $LN24@alias_for_
$LN27@alias_for_:

; 2781 :                 if (forbidden_name(c, name, name_node, 0))

  0012c	45 33 c9	 xor	 r9d, r9d
  0012f	4c 8b 44 24 30	 mov	 r8, QWORD PTR name_node$23848[rsp]
  00134	48 8b 54 24 20	 mov	 rdx, QWORD PTR name$[rsp]
  00139	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00141	e8 00 00 00 00	 call	 forbidden_name
  00146	85 c0		 test	 eax, eax
  00148	74 07		 je	 SHORT $LN23@alias_for_

; 2782 :                     return NULL;

  0014a	33 c0		 xor	 eax, eax
  0014c	e9 b4 04 00 00	 jmp	 $LN32@alias_for_
$LN23@alias_for_:
$LN24@alias_for_:

; 2783 :             }
; 2784 :             return alias(name, str, c->c_arena);

  00151	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00159	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0015d	48 8b 54 24 28	 mov	 rdx, QWORD PTR str$[rsp]
  00162	48 8b 4c 24 20	 mov	 rcx, QWORD PTR name$[rsp]
  00167	e8 00 00 00 00	 call	 _Py_alias
  0016c	e9 94 04 00 00	 jmp	 $LN32@alias_for_
$LN22@alias_for_:

; 2785 :         }
; 2786 :         case dotted_as_name:
; 2787 :             if (NCH(n) == 1) {

  00171	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00179	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  0017d	75 1e		 jne	 SHORT $LN21@alias_for_

; 2788 :                 n = CHILD(n, 0);

  0017f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00187	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0018b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 2789 :                 goto loop;

  00193	e9 7e fe ff ff	 jmp	 $loop$23842

; 2790 :             }
; 2791 :             else {

  00198	e9 d2 00 00 00	 jmp	 $LN20@alias_for_
$LN21@alias_for_:

; 2792 :                 node *asname_node = CHILD(n, 2);

  0019d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001a5	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001a9	48 83 c0 50	 add	 rax, 80			; 00000050H
  001ad	48 89 44 24 48	 mov	 QWORD PTR asname_node$23864[rsp], rax

; 2793 :                 alias_ty a = alias_for_import_name(c, CHILD(n, 0), 0);

  001b2	45 33 c0	 xor	 r8d, r8d
  001b5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001bd	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  001c1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001c9	e8 00 00 00 00	 call	 alias_for_import_name
  001ce	48 89 44 24 40	 mov	 QWORD PTR a$23865[rsp], rax

; 2794 :                 if (!a)

  001d3	48 83 7c 24 40
	00		 cmp	 QWORD PTR a$23865[rsp], 0
  001d9	75 07		 jne	 SHORT $LN19@alias_for_

; 2795 :                     return NULL;

  001db	33 c0		 xor	 eax, eax
  001dd	e9 23 04 00 00	 jmp	 $LN32@alias_for_
$LN19@alias_for_:

; 2796 :                 assert(!a->asname);

  001e2	48 8b 44 24 40	 mov	 rax, QWORD PTR a$23865[rsp]
  001e7	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  001ec	74 1c		 je	 SHORT $LN34@alias_for_
  001ee	41 b8 ec 0a 00
	00		 mov	 r8d, 2796		; 00000aecH
  001f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@NEIOAFNM@?$AA?$CB?$AAa?$AA?9?$AA?$DO?$AAa?$AAs?$AAn?$AAa?$AAm?$AAe?$AA?$AA@
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00208	33 c0		 xor	 eax, eax
$LN34@alias_for_:

; 2797 :                 a->asname = NEW_IDENTIFIER(asname_node);

  0020a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00212	48 8b 44 24 48	 mov	 rax, QWORD PTR asname_node$23864[rsp]
  00217	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0021b	e8 00 00 00 00	 call	 new_identifier
  00220	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$23865[rsp]
  00225	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2798 :                 if (!a->asname)

  00229	48 8b 44 24 40	 mov	 rax, QWORD PTR a$23865[rsp]
  0022e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00233	75 07		 jne	 SHORT $LN18@alias_for_

; 2799 :                     return NULL;

  00235	33 c0		 xor	 eax, eax
  00237	e9 c9 03 00 00	 jmp	 $LN32@alias_for_
$LN18@alias_for_:

; 2800 :                 if (forbidden_name(c, a->asname, asname_node, 0))

  0023c	45 33 c9	 xor	 r9d, r9d
  0023f	4c 8b 44 24 48	 mov	 r8, QWORD PTR asname_node$23864[rsp]
  00244	48 8b 44 24 40	 mov	 rax, QWORD PTR a$23865[rsp]
  00249	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0024d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00255	e8 00 00 00 00	 call	 forbidden_name
  0025a	85 c0		 test	 eax, eax
  0025c	74 07		 je	 SHORT $LN17@alias_for_

; 2801 :                     return NULL;

  0025e	33 c0		 xor	 eax, eax
  00260	e9 a0 03 00 00	 jmp	 $LN32@alias_for_
$LN17@alias_for_:

; 2802 :                 return a;

  00265	48 8b 44 24 40	 mov	 rax, QWORD PTR a$23865[rsp]
  0026a	e9 96 03 00 00	 jmp	 $LN32@alias_for_
$LN20@alias_for_:

; 2803 :             }
; 2804 :             break;

  0026f	e9 7c 03 00 00	 jmp	 $LN30@alias_for_
$LN16@alias_for_:

; 2805 :         case dotted_name:
; 2806 :             if (NCH(n) == 1) {

  00274	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0027c	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00280	0f 85 8c 00 00
	00		 jne	 $LN15@alias_for_

; 2807 :                 node *name_node = CHILD(n, 0);

  00286	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0028e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00292	48 89 44 24 50	 mov	 QWORD PTR name_node$23876[rsp], rax

; 2808 :                 name = NEW_IDENTIFIER(name_node);

  00297	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  0029f	48 8b 44 24 50	 mov	 rax, QWORD PTR name_node$23876[rsp]
  002a4	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  002a8	e8 00 00 00 00	 call	 new_identifier
  002ad	48 89 44 24 20	 mov	 QWORD PTR name$[rsp], rax

; 2809 :                 if (!name)

  002b2	48 83 7c 24 20
	00		 cmp	 QWORD PTR name$[rsp], 0
  002b8	75 07		 jne	 SHORT $LN14@alias_for_

; 2810 :                     return NULL;

  002ba	33 c0		 xor	 eax, eax
  002bc	e9 44 03 00 00	 jmp	 $LN32@alias_for_
$LN14@alias_for_:

; 2811 :                 if (store && forbidden_name(c, name, name_node, 0))

  002c1	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR store$[rsp], 0
  002c9	74 25		 je	 SHORT $LN13@alias_for_
  002cb	45 33 c9	 xor	 r9d, r9d
  002ce	4c 8b 44 24 50	 mov	 r8, QWORD PTR name_node$23876[rsp]
  002d3	48 8b 54 24 20	 mov	 rdx, QWORD PTR name$[rsp]
  002d8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002e0	e8 00 00 00 00	 call	 forbidden_name
  002e5	85 c0		 test	 eax, eax
  002e7	74 07		 je	 SHORT $LN13@alias_for_

; 2812 :                     return NULL;

  002e9	33 c0		 xor	 eax, eax
  002eb	e9 15 03 00 00	 jmp	 $LN32@alias_for_
$LN13@alias_for_:

; 2813 :                 return alias(name, NULL, c->c_arena);

  002f0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  002f8	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  002fc	33 d2		 xor	 edx, edx
  002fe	48 8b 4c 24 20	 mov	 rcx, QWORD PTR name$[rsp]
  00303	e8 00 00 00 00	 call	 _Py_alias
  00308	e9 f8 02 00 00	 jmp	 $LN32@alias_for_

; 2814 :             }
; 2815 :             else {

  0030d	e9 76 02 00 00	 jmp	 $LN12@alias_for_
$LN15@alias_for_:

; 2816 :                 /* Create a string of the form "a.b.c" */
; 2817 :                 int i;
; 2818 :                 size_t len;
; 2819 :                 char *s;
; 2820 :                 PyObject *uni;
; 2821 : 
; 2822 :                 len = 0;

  00312	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR len$23884[rsp], 0

; 2823 :                 for (i = 0; i < NCH(n); i += 2)

  0031b	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$23883[rsp], 0
  00323	eb 0b		 jmp	 SHORT $LN11@alias_for_
$LN10@alias_for_:
  00325	8b 44 24 60	 mov	 eax, DWORD PTR i$23883[rsp]
  00329	83 c0 02	 add	 eax, 2
  0032c	89 44 24 60	 mov	 DWORD PTR i$23883[rsp], eax
$LN11@alias_for_:
  00330	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00338	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0033b	39 44 24 60	 cmp	 DWORD PTR i$23883[rsp], eax
  0033f	7d 30		 jge	 SHORT $LN9@alias_for_

; 2824 :                     /* length of string plus one for the dot */
; 2825 :                     len += strlen(STR(CHILD(n, i))) + 1;

  00341	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$23883[rsp]
  00346	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0034a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00352	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00356	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  0035b	e8 00 00 00 00	 call	 strlen
  00360	48 8b 4c 24 70	 mov	 rcx, QWORD PTR len$23884[rsp]
  00365	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  0036a	48 89 44 24 70	 mov	 QWORD PTR len$23884[rsp], rax
  0036f	eb b4		 jmp	 SHORT $LN10@alias_for_
$LN9@alias_for_:

; 2826 :                 len--; /* the last name doesn't have a dot */

  00371	48 8b 44 24 70	 mov	 rax, QWORD PTR len$23884[rsp]
  00376	48 ff c8	 dec	 rax
  00379	48 89 44 24 70	 mov	 QWORD PTR len$23884[rsp], rax

; 2827 :                 str = PyBytes_FromStringAndSize(NULL, len);

  0037e	48 8b 54 24 70	 mov	 rdx, QWORD PTR len$23884[rsp]
  00383	33 c9		 xor	 ecx, ecx
  00385	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0038a	48 89 44 24 28	 mov	 QWORD PTR str$[rsp], rax

; 2828 :                 if (!str)

  0038f	48 83 7c 24 28
	00		 cmp	 QWORD PTR str$[rsp], 0
  00395	75 07		 jne	 SHORT $LN8@alias_for_

; 2829 :                     return NULL;

  00397	33 c0		 xor	 eax, eax
  00399	e9 67 02 00 00	 jmp	 $LN32@alias_for_
$LN8@alias_for_:

; 2830 :                 s = PyBytes_AS_STRING(str);

  0039e	48 8b 44 24 28	 mov	 rax, QWORD PTR str$[rsp]
  003a3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003a7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003ad	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  003b2	85 c0		 test	 eax, eax
  003b4	75 1c		 jne	 SHORT $LN35@alias_for_
  003b6	41 b8 0e 0b 00
	00		 mov	 r8d, 2830		; 00000b0eH
  003bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  003c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@HELEBNCJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  003ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003d0	33 c0		 xor	 eax, eax
$LN35@alias_for_:
  003d2	48 8b 44 24 28	 mov	 rax, QWORD PTR str$[rsp]
  003d7	48 83 c0 78	 add	 rax, 120		; 00000078H
  003db	48 89 44 24 68	 mov	 QWORD PTR s$23885[rsp], rax

; 2831 :                 if (!s)

  003e0	48 83 7c 24 68
	00		 cmp	 QWORD PTR s$23885[rsp], 0
  003e6	75 07		 jne	 SHORT $LN7@alias_for_

; 2832 :                     return NULL;

  003e8	33 c0		 xor	 eax, eax
  003ea	e9 16 02 00 00	 jmp	 $LN32@alias_for_
$LN7@alias_for_:

; 2833 :                 for (i = 0; i < NCH(n); i += 2) {

  003ef	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$23883[rsp], 0
  003f7	eb 0b		 jmp	 SHORT $LN6@alias_for_
$LN5@alias_for_:
  003f9	8b 44 24 60	 mov	 eax, DWORD PTR i$23883[rsp]
  003fd	83 c0 02	 add	 eax, 2
  00400	89 44 24 60	 mov	 DWORD PTR i$23883[rsp], eax
$LN6@alias_for_:
  00404	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0040c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0040f	39 44 24 60	 cmp	 DWORD PTR i$23883[rsp], eax
  00413	7d 77		 jge	 SHORT $LN4@alias_for_

; 2834 :                     char *sch = STR(CHILD(n, i));

  00415	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$23883[rsp]
  0041a	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0041e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00426	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0042a	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0042f	48 89 44 24 78	 mov	 QWORD PTR sch$23902[rsp], rax

; 2835 :                     strcpy(s, STR(CHILD(n, i)));

  00434	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$23883[rsp]
  00439	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0043d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00445	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00449	48 8b 54 01 08	 mov	 rdx, QWORD PTR [rcx+rax+8]
  0044e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR s$23885[rsp]
  00453	e8 00 00 00 00	 call	 strcpy

; 2836 :                     s += strlen(sch);

  00458	48 8b 4c 24 78	 mov	 rcx, QWORD PTR sch$23902[rsp]
  0045d	e8 00 00 00 00	 call	 strlen
  00462	48 8b 4c 24 68	 mov	 rcx, QWORD PTR s$23885[rsp]
  00467	48 03 c8	 add	 rcx, rax
  0046a	48 8b c1	 mov	 rax, rcx
  0046d	48 89 44 24 68	 mov	 QWORD PTR s$23885[rsp], rax

; 2837 :                     *s++ = '.';

  00472	48 8b 44 24 68	 mov	 rax, QWORD PTR s$23885[rsp]
  00477	c6 00 2e	 mov	 BYTE PTR [rax], 46	; 0000002eH
  0047a	48 8b 44 24 68	 mov	 rax, QWORD PTR s$23885[rsp]
  0047f	48 ff c0	 inc	 rax
  00482	48 89 44 24 68	 mov	 QWORD PTR s$23885[rsp], rax

; 2838 :                 }

  00487	e9 6d ff ff ff	 jmp	 $LN5@alias_for_
$LN4@alias_for_:

; 2839 :                 --s;

  0048c	48 8b 44 24 68	 mov	 rax, QWORD PTR s$23885[rsp]
  00491	48 ff c8	 dec	 rax
  00494	48 89 44 24 68	 mov	 QWORD PTR s$23885[rsp], rax

; 2840 :                 *s = '\0';

  00499	48 8b 44 24 68	 mov	 rax, QWORD PTR s$23885[rsp]
  0049e	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2841 :                 uni = PyUnicode_DecodeUTF8(PyBytes_AS_STRING(str),
; 2842 :                                            PyBytes_GET_SIZE(str),
; 2843 :                                            NULL);

  004a1	48 8b 44 24 28	 mov	 rax, QWORD PTR str$[rsp]
  004a6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  004aa	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  004b0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  004b5	85 c0		 test	 eax, eax
  004b7	75 1c		 jne	 SHORT $LN36@alias_for_
  004b9	41 b8 1a 0b 00
	00		 mov	 r8d, 2842		; 00000b1aH
  004bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  004c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@HELEBNCJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  004cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004d3	33 c0		 xor	 eax, eax
$LN36@alias_for_:
  004d5	48 8b 44 24 28	 mov	 rax, QWORD PTR str$[rsp]
  004da	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  004de	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  004e4	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  004e9	85 c0		 test	 eax, eax
  004eb	75 1c		 jne	 SHORT $LN37@alias_for_
  004ed	41 b8 19 0b 00
	00		 mov	 r8d, 2841		; 00000b19H
  004f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  004fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@HELEBNCJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  00501	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00507	33 c0		 xor	 eax, eax
$LN37@alias_for_:
  00509	48 8b 44 24 28	 mov	 rax, QWORD PTR str$[rsp]
  0050e	48 83 c0 78	 add	 rax, 120		; 00000078H
  00512	45 33 c0	 xor	 r8d, r8d
  00515	48 8b 4c 24 28	 mov	 rcx, QWORD PTR str$[rsp]
  0051a	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  0051e	48 8b c8	 mov	 rcx, rax
  00521	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  00526	48 89 44 24 58	 mov	 QWORD PTR uni$23886[rsp], rax

; 2844 :                 Py_DECREF(str);

  0052b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR str$[rsp]
  00530	e8 00 00 00 00	 call	 _Py_DecRef

; 2845 :                 if (!uni)

  00535	48 83 7c 24 58
	00		 cmp	 QWORD PTR uni$23886[rsp], 0
  0053b	75 07		 jne	 SHORT $LN3@alias_for_

; 2846 :                     return NULL;

  0053d	33 c0		 xor	 eax, eax
  0053f	e9 c1 00 00 00	 jmp	 $LN32@alias_for_
$LN3@alias_for_:

; 2847 :                 str = uni;

  00544	48 8b 44 24 58	 mov	 rax, QWORD PTR uni$23886[rsp]
  00549	48 89 44 24 28	 mov	 QWORD PTR str$[rsp], rax

; 2848 :                 PyUnicode_InternInPlace(&str);

  0054e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR str$[rsp]
  00553	e8 00 00 00 00	 call	 PyUnicode_InternInPlace

; 2849 :                 PyArena_AddPyObject(c->c_arena, str);

  00558	48 8b 54 24 28	 mov	 rdx, QWORD PTR str$[rsp]
  0055d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00565	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00569	e8 00 00 00 00	 call	 PyArena_AddPyObject

; 2850 :                 return alias(str, NULL, c->c_arena);

  0056e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00576	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0057a	33 d2		 xor	 edx, edx
  0057c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR str$[rsp]
  00581	e8 00 00 00 00	 call	 _Py_alias
  00586	eb 7d		 jmp	 SHORT $LN32@alias_for_
$LN12@alias_for_:

; 2851 :             }
; 2852 :             break;

  00588	eb 66		 jmp	 SHORT $LN30@alias_for_
$LN2@alias_for_:

; 2853 :         case STAR:
; 2854 :             str = PyUnicode_InternFromString("*");

  0058a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01NBENCBCI@?$CK?$AA@
  00591	e8 00 00 00 00	 call	 PyUnicode_InternFromString
  00596	48 89 44 24 28	 mov	 QWORD PTR str$[rsp], rax

; 2855 :             PyArena_AddPyObject(c->c_arena, str);

  0059b	48 8b 54 24 28	 mov	 rdx, QWORD PTR str$[rsp]
  005a0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  005a8	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  005ac	e8 00 00 00 00	 call	 PyArena_AddPyObject

; 2856 :             return alias(str, NULL, c->c_arena);

  005b1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  005b9	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  005bd	33 d2		 xor	 edx, edx
  005bf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR str$[rsp]
  005c4	e8 00 00 00 00	 call	 _Py_alias
  005c9	eb 3a		 jmp	 SHORT $LN32@alias_for_
$LN1@alias_for_:

; 2857 :         default:
; 2858 :             PyErr_Format(PyExc_SystemError,
; 2859 :                          "unexpected import name: %d", TYPE(n));

  005cb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  005d3	0f bf 00	 movsx	 eax, WORD PTR [rax]
  005d6	44 8b c0	 mov	 r8d, eax
  005d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LEDBAIDM@unexpected?5import?5name?3?5?$CFd?$AA@
  005e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  005e7	e8 00 00 00 00	 call	 PyErr_Format

; 2860 :             return NULL;

  005ec	33 c0		 xor	 eax, eax
  005ee	eb 15		 jmp	 SHORT $LN32@alias_for_
$LN30@alias_for_:

; 2861 :     }
; 2862 : 
; 2863 :     PyErr_SetString(PyExc_SystemError, "unhandled import name condition");

  005f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@ICDONEOB@unhandled?5import?5name?5condition?$AA@
  005f7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  005fe	e8 00 00 00 00	 call	 PyErr_SetString

; 2864 :     return NULL;

  00603	33 c0		 xor	 eax, eax
$LN32@alias_for_:

; 2865 : }

  00605	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0060c	c3		 ret	 0
alias_for_import_name ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DG@GCJFEKEM@?$AA?$CI?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@DPGELLDK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA0?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_Global:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_global_stmt DD imagerel ast_for_global_stmt
	DD	imagerel ast_for_global_stmt+328
	DD	imagerel $unwind$ast_for_global_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_global_stmt DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1DG@GCJFEKEM@?$AA?$CI?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@GCJFEKEM@?$AA?$CI?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB '('
	DB	00H, 's', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'_', 00H, 'a', 00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H, 'i'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H, 's', 00H, ')', 00H
	DB	'-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DPGELLDK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA0?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@DPGELLDK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA0?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '9'
	DB	00H, '0', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_global_stmt
_TEXT	SEGMENT
i$ = 32
s$ = 40
name$ = 48
_asdl_i$24019 = 56
c$ = 80
n$ = 88
ast_for_global_stmt PROC				; COMDAT

; 2982 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2983 :     /* global_stmt: 'global' NAME (',' NAME)* */
; 2984 :     identifier name;
; 2985 :     asdl_seq *s;
; 2986 :     int i;
; 2987 : 
; 2988 :     REQ(n, global_stmt);

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 22 01 00 00	 cmp	 eax, 290		; 00000122H
  0001b	74 1c		 je	 SHORT $LN8@ast_for_gl
  0001d	41 b8 ac 0b 00
	00		 mov	 r8d, 2988		; 00000bacH
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@DPGELLDK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA0?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN8@ast_for_gl:

; 2989 :     s = asdl_seq_new(NCH(n) / 2, c->c_arena);

  00039	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0003e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx
  00044	d1 f8		 sar	 eax, 1
  00046	48 98		 cdqe
  00048	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0004d	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00051	48 8b c8	 mov	 rcx, rax
  00054	e8 00 00 00 00	 call	 asdl_seq_new
  00059	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 2990 :     if (!s)

  0005e	48 83 7c 24 28
	00		 cmp	 QWORD PTR s$[rsp], 0
  00064	75 07		 jne	 SHORT $LN5@ast_for_gl

; 2991 :         return NULL;

  00066	33 c0		 xor	 eax, eax
  00068	e9 d6 00 00 00	 jmp	 $LN6@ast_for_gl
$LN5@ast_for_gl:

; 2992 :     for (i = 1; i < NCH(n); i += 2) {

  0006d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00075	eb 0b		 jmp	 SHORT $LN4@ast_for_gl
$LN3@ast_for_gl:
  00077	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0007b	83 c0 02	 add	 eax, 2
  0007e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@ast_for_gl:
  00082	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00087	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0008a	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0008e	0f 8d 8b 00 00
	00		 jge	 $LN2@ast_for_gl

; 2993 :         name = NEW_IDENTIFIER(CHILD(n, i));

  00094	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00099	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0009d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR n$[rsp]
  000a2	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000a6	48 8b 54 24 50	 mov	 rdx, QWORD PTR c$[rsp]
  000ab	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  000b0	e8 00 00 00 00	 call	 new_identifier
  000b5	48 89 44 24 30	 mov	 QWORD PTR name$[rsp], rax

; 2994 :         if (!name)

  000ba	48 83 7c 24 30
	00		 cmp	 QWORD PTR name$[rsp], 0
  000c0	75 04		 jne	 SHORT $LN1@ast_for_gl

; 2995 :             return NULL;

  000c2	33 c0		 xor	 eax, eax
  000c4	eb 7d		 jmp	 SHORT $LN6@ast_for_gl
$LN1@ast_for_gl:

; 2996 :         asdl_seq_SET(s, i / 2, name);

  000c6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000ca	99		 cdq
  000cb	2b c2		 sub	 eax, edx
  000cd	d1 f8		 sar	 eax, 1
  000cf	89 44 24 38	 mov	 DWORD PTR _asdl_i$24019[rsp], eax
  000d3	48 83 7c 24 28
	00		 cmp	 QWORD PTR s$[rsp], 0
  000d9	74 0f		 je	 SHORT $LN9@ast_for_gl
  000db	48 63 44 24 38	 movsxd	 rax, DWORD PTR _asdl_i$24019[rsp]
  000e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000e5	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  000e8	7c 1c		 jl	 SHORT $LN10@ast_for_gl
$LN9@ast_for_gl:
  000ea	41 b8 b4 0b 00
	00		 mov	 r8d, 2996		; 00000bb4H
  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@GCJFEKEM@?$AA?$CI?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00104	33 c0		 xor	 eax, eax
$LN10@ast_for_gl:
  00106	48 63 44 24 38	 movsxd	 rax, DWORD PTR _asdl_i$24019[rsp]
  0010b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00110	48 8b 54 24 30	 mov	 rdx, QWORD PTR name$[rsp]
  00115	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 2997 :     }

  0011a	e9 58 ff ff ff	 jmp	 $LN3@ast_for_gl
$LN2@ast_for_gl:

; 2998 :     return Global(s, LINENO(n), n->n_col_offset, c->c_arena);

  0011f	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  00124	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00128	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0012d	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  00131	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00136	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00139	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0013e	e8 00 00 00 00	 call	 _Py_Global
$LN6@ast_for_gl:

; 2999 : }

  00143	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00147	c3		 ret	 0
ast_for_global_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@PEDIGIJP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA1?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_Nonlocal:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_nonlocal_stmt DD imagerel ast_for_nonlocal_stmt
	DD	imagerel ast_for_nonlocal_stmt+328
	DD	imagerel $unwind$ast_for_nonlocal_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_nonlocal_stmt DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1CC@PEDIGIJP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA1?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@PEDIGIJP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA1?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '9'
	DB	00H, '1', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_nonlocal_stmt
_TEXT	SEGMENT
i$ = 32
s$ = 40
name$ = 48
_asdl_i$24040 = 56
c$ = 80
n$ = 88
ast_for_nonlocal_stmt PROC				; COMDAT

; 3003 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3004 :     /* nonlocal_stmt: 'nonlocal' NAME (',' NAME)* */
; 3005 :     identifier name;
; 3006 :     asdl_seq *s;
; 3007 :     int i;
; 3008 : 
; 3009 :     REQ(n, nonlocal_stmt);

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 23 01 00 00	 cmp	 eax, 291		; 00000123H
  0001b	74 1c		 je	 SHORT $LN8@ast_for_no
  0001d	41 b8 c1 0b 00
	00		 mov	 r8d, 3009		; 00000bc1H
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@PEDIGIJP@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA1?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN8@ast_for_no:

; 3010 :     s = asdl_seq_new(NCH(n) / 2, c->c_arena);

  00039	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0003e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00041	99		 cdq
  00042	2b c2		 sub	 eax, edx
  00044	d1 f8		 sar	 eax, 1
  00046	48 98		 cdqe
  00048	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$[rsp]
  0004d	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00051	48 8b c8	 mov	 rcx, rax
  00054	e8 00 00 00 00	 call	 asdl_seq_new
  00059	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 3011 :     if (!s)

  0005e	48 83 7c 24 28
	00		 cmp	 QWORD PTR s$[rsp], 0
  00064	75 07		 jne	 SHORT $LN5@ast_for_no

; 3012 :         return NULL;

  00066	33 c0		 xor	 eax, eax
  00068	e9 d6 00 00 00	 jmp	 $LN6@ast_for_no
$LN5@ast_for_no:

; 3013 :     for (i = 1; i < NCH(n); i += 2) {

  0006d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00075	eb 0b		 jmp	 SHORT $LN4@ast_for_no
$LN3@ast_for_no:
  00077	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0007b	83 c0 02	 add	 eax, 2
  0007e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@ast_for_no:
  00082	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00087	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0008a	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0008e	0f 8d 8b 00 00
	00		 jge	 $LN2@ast_for_no

; 3014 :         name = NEW_IDENTIFIER(CHILD(n, i));

  00094	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00099	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0009d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR n$[rsp]
  000a2	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000a6	48 8b 54 24 50	 mov	 rdx, QWORD PTR c$[rsp]
  000ab	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  000b0	e8 00 00 00 00	 call	 new_identifier
  000b5	48 89 44 24 30	 mov	 QWORD PTR name$[rsp], rax

; 3015 :         if (!name)

  000ba	48 83 7c 24 30
	00		 cmp	 QWORD PTR name$[rsp], 0
  000c0	75 04		 jne	 SHORT $LN1@ast_for_no

; 3016 :             return NULL;

  000c2	33 c0		 xor	 eax, eax
  000c4	eb 7d		 jmp	 SHORT $LN6@ast_for_no
$LN1@ast_for_no:

; 3017 :         asdl_seq_SET(s, i / 2, name);

  000c6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000ca	99		 cdq
  000cb	2b c2		 sub	 eax, edx
  000cd	d1 f8		 sar	 eax, 1
  000cf	89 44 24 38	 mov	 DWORD PTR _asdl_i$24040[rsp], eax
  000d3	48 83 7c 24 28
	00		 cmp	 QWORD PTR s$[rsp], 0
  000d9	74 0f		 je	 SHORT $LN9@ast_for_no
  000db	48 63 44 24 38	 movsxd	 rax, DWORD PTR _asdl_i$24040[rsp]
  000e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000e5	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  000e8	7c 1c		 jl	 SHORT $LN10@ast_for_no
$LN9@ast_for_no:
  000ea	41 b8 c9 0b 00
	00		 mov	 r8d, 3017		; 00000bc9H
  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@GCJFEKEM@?$AA?$CI?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00104	33 c0		 xor	 eax, eax
$LN10@ast_for_no:
  00106	48 63 44 24 38	 movsxd	 rax, DWORD PTR _asdl_i$24040[rsp]
  0010b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00110	48 8b 54 24 30	 mov	 rdx, QWORD PTR name$[rsp]
  00115	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 3018 :     }

  0011a	e9 58 ff ff ff	 jmp	 $LN3@ast_for_no
$LN2@ast_for_no:

; 3019 :     return Nonlocal(s, LINENO(n), n->n_col_offset, c->c_arena);

  0011f	48 8b 44 24 50	 mov	 rax, QWORD PTR c$[rsp]
  00124	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
  00128	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0012d	44 8b 40 14	 mov	 r8d, DWORD PTR [rax+20]
  00131	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00136	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00139	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0013e	e8 00 00 00 00	 call	 _Py_Nonlocal
$LN6@ast_for_no:

; 3020 : }

  00143	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00147	c3		 ret	 0
ast_for_nonlocal_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@MLKGHAGN@improper?5number?5of?5parts?5to?5?8ass@ ; `string'
PUBLIC	??_C@_1CC@HCKMBKDB@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA2?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_Assert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_assert_stmt DD imagerel ast_for_assert_stmt
	DD	imagerel ast_for_assert_stmt+353
	DD	imagerel $unwind$ast_for_assert_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_assert_stmt DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0DD@MLKGHAGN@improper?5number?5of?5parts?5to?5?8ass@
CONST	SEGMENT
??_C@_0DD@MLKGHAGN@improper?5number?5of?5parts?5to?5?8ass@ DB 'improper n'
	DB	'umber of parts to ''assert'' statement: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@HCKMBKDB@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA2?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@HCKMBKDB@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA2?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '9'
	DB	00H, '2', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_assert_stmt
_TEXT	SEGMENT
expression$24051 = 48
expr2$24058 = 56
expr1$24057 = 64
c$ = 96
n$ = 104
ast_for_assert_stmt PROC				; COMDAT

; 3024 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3025 :     /* assert_stmt: 'assert' test [',' test] */
; 3026 :     REQ(n, assert_stmt);

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 24 01 00 00	 cmp	 eax, 292		; 00000124H
  0001b	74 1c		 je	 SHORT $LN9@ast_for_as
  0001d	41 b8 d2 0b 00
	00		 mov	 r8d, 3026		; 00000bd2H
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@HCKMBKDB@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA2?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN9@ast_for_as:

; 3027 :     if (NCH(n) == 2) {

  00039	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0003e	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  00042	75 64		 jne	 SHORT $LN6@ast_for_as

; 3028 :         expr_ty expression = ast_for_expr(c, CHILD(n, 1));

  00044	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00049	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004d	48 83 c0 28	 add	 rax, 40			; 00000028H
  00051	48 8b d0	 mov	 rdx, rax
  00054	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00059	e8 00 00 00 00	 call	 ast_for_expr
  0005e	48 89 44 24 30	 mov	 QWORD PTR expression$24051[rsp], rax

; 3029 :         if (!expression)

  00063	48 83 7c 24 30
	00		 cmp	 QWORD PTR expression$24051[rsp], 0
  00069	75 07		 jne	 SHORT $LN5@ast_for_as

; 3030 :             return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 ea 00 00 00	 jmp	 $LN7@ast_for_as
$LN5@ast_for_as:

; 3031 :         return Assert(expression, NULL, LINENO(n), n->n_col_offset, c->c_arena);

  00072	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00077	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00080	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00085	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  00089	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0008e	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00092	33 d2		 xor	 edx, edx
  00094	48 8b 4c 24 30	 mov	 rcx, QWORD PTR expression$24051[rsp]
  00099	e8 00 00 00 00	 call	 _Py_Assert
  0009e	e9 b9 00 00 00	 jmp	 $LN7@ast_for_as
  000a3	e9 96 00 00 00	 jmp	 $LN4@ast_for_as
$LN6@ast_for_as:

; 3032 :     }
; 3033 :     else if (NCH(n) == 4) {

  000a8	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000ad	83 78 18 04	 cmp	 DWORD PTR [rax+24], 4
  000b1	0f 85 87 00 00
	00		 jne	 $LN3@ast_for_as

; 3034 :         expr_ty expr1, expr2;
; 3035 : 
; 3036 :         expr1 = ast_for_expr(c, CHILD(n, 1));

  000b7	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000bc	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000c0	48 83 c0 28	 add	 rax, 40			; 00000028H
  000c4	48 8b d0	 mov	 rdx, rax
  000c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000cc	e8 00 00 00 00	 call	 ast_for_expr
  000d1	48 89 44 24 40	 mov	 QWORD PTR expr1$24057[rsp], rax

; 3037 :         if (!expr1)

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR expr1$24057[rsp], 0
  000dc	75 04		 jne	 SHORT $LN2@ast_for_as

; 3038 :             return NULL;

  000de	33 c0		 xor	 eax, eax
  000e0	eb 7a		 jmp	 SHORT $LN7@ast_for_as
$LN2@ast_for_as:

; 3039 :         expr2 = ast_for_expr(c, CHILD(n, 3));

  000e2	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  000e7	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000eb	48 83 c0 78	 add	 rax, 120		; 00000078H
  000ef	48 8b d0	 mov	 rdx, rax
  000f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000f7	e8 00 00 00 00	 call	 ast_for_expr
  000fc	48 89 44 24 38	 mov	 QWORD PTR expr2$24058[rsp], rax

; 3040 :         if (!expr2)

  00101	48 83 7c 24 38
	00		 cmp	 QWORD PTR expr2$24058[rsp], 0
  00107	75 04		 jne	 SHORT $LN1@ast_for_as

; 3041 :             return NULL;

  00109	33 c0		 xor	 eax, eax
  0010b	eb 4f		 jmp	 SHORT $LN7@ast_for_as
$LN1@ast_for_as:

; 3042 : 
; 3043 :         return Assert(expr1, expr2, LINENO(n), n->n_col_offset, c->c_arena);

  0010d	48 8b 44 24 60	 mov	 rax, QWORD PTR c$[rsp]
  00112	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00116	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011b	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00120	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  00124	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00129	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  0012d	48 8b 54 24 38	 mov	 rdx, QWORD PTR expr2$24058[rsp]
  00132	48 8b 4c 24 40	 mov	 rcx, QWORD PTR expr1$24057[rsp]
  00137	e8 00 00 00 00	 call	 _Py_Assert
  0013c	eb 1e		 jmp	 SHORT $LN7@ast_for_as
$LN3@ast_for_as:
$LN4@ast_for_as:

; 3044 :     }
; 3045 :     PyErr_Format(PyExc_SystemError,
; 3046 :                  "improper number of parts to 'assert' statement: %d",
; 3047 :                  NCH(n));

  0013e	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00143	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@MLKGHAGN@improper?5number?5of?5parts?5to?5?8ass@
  0014e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00155	e8 00 00 00 00	 call	 PyErr_Format

; 3048 :     return NULL;

  0015a	33 c0		 xor	 eax, eax
$LN7@ast_for_as:

; 3049 : }

  0015c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00160	c3		 ret	 0
ast_for_assert_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@MGFDFFEL@?$AAp?$AAo?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAe?$AAq?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@GCIPBBIC@?$AA?$CI?$AAj?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAC?$AAH?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@ELFBIIK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA1?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_suite DD imagerel ast_for_suite
	DD	imagerel ast_for_suite+1037
	DD	imagerel $unwind$ast_for_suite
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_suite DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_1CC@MGFDFFEL@?$AAp?$AAo?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAe?$AAq?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@MGFDFFEL@?$AAp?$AAo?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAe?$AAq?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	's', 00H, 'e', 00H, 'q', 00H, '-', 00H, '>', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@GCIPBBIC@?$AA?$CI?$AAj?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAC?$AAH?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@GCIPBBIC@?$AA?$CI?$AAj?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAC?$AAH?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?$AA@ DB '('
	DB	00H, 'j', 00H, ' ', 00H, '+', 00H, ' ', 00H, '1', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'C', 00H, 'H'
	DB	00H, '(', 00H, 'c', 00H, 'h', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@ELFBIIK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA1?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@ELFBIIK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA1?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '0'
	DB	00H, '1', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_suite
_TEXT	SEGMENT
i$ = 32
num$ = 36
s$ = 40
end$ = 48
total$ = 52
seq$ = 56
ch$ = 64
pos$ = 72
_asdl_i$24089 = 76
_asdl_i$24099 = 80
j$24102 = 84
_asdl_i$24112 = 88
c$ = 112
n$ = 120
ast_for_suite PROC					; COMDAT

; 3053 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3054 :     /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */
; 3055 :     asdl_seq *seq;
; 3056 :     stmt_ty s;
; 3057 :     int i, total, num, end, pos = 0;

  0000e	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR pos$[rsp], 0

; 3058 :     node *ch;
; 3059 : 
; 3060 :     REQ(n, suite);

  00016	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0001b	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0001e	3d 2d 01 00 00	 cmp	 eax, 301		; 0000012dH
  00023	74 1c		 je	 SHORT $LN22@ast_for_su
  00025	41 b8 f4 0b 00
	00		 mov	 r8d, 3060		; 00000bf4H
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@ELFBIIK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA1?$AA?$CJ?$AA?$AA@
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003f	33 c0		 xor	 eax, eax
$LN22@ast_for_su:

; 3061 : 
; 3062 :     total = num_stmts(n);

  00041	48 8b 4c 24 78	 mov	 rcx, QWORD PTR n$[rsp]
  00046	e8 00 00 00 00	 call	 num_stmts
  0004b	89 44 24 34	 mov	 DWORD PTR total$[rsp], eax

; 3063 :     seq = asdl_seq_new(total, c->c_arena);

  0004f	48 63 44 24 34	 movsxd	 rax, DWORD PTR total$[rsp]
  00054	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00059	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0005d	48 8b c8	 mov	 rcx, rax
  00060	e8 00 00 00 00	 call	 asdl_seq_new
  00065	48 89 44 24 38	 mov	 QWORD PTR seq$[rsp], rax

; 3064 :     if (!seq)

  0006a	48 83 7c 24 38
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00070	75 07		 jne	 SHORT $LN19@ast_for_su

; 3065 :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	e9 8f 03 00 00	 jmp	 $LN20@ast_for_su
$LN19@ast_for_su:

; 3066 :     if (TYPE(CHILD(n, 0)) == simple_stmt) {

  00079	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0007e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00082	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00085	3d 0d 01 00 00	 cmp	 eax, 269		; 0000010dH
  0008a	0f 85 04 01 00
	00		 jne	 $LN18@ast_for_su

; 3067 :         n = CHILD(n, 0);

  00090	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00095	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00099	48 89 44 24 78	 mov	 QWORD PTR n$[rsp], rax

; 3068 :         /* simple_stmt always ends with a NEWLINE,
; 3069 :            and may have a trailing SEMI
; 3070 :         */
; 3071 :         end = NCH(n) - 1;

  0009e	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000a3	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000a6	ff c8		 dec	 eax
  000a8	89 44 24 30	 mov	 DWORD PTR end$[rsp], eax

; 3072 :         if (TYPE(CHILD(n, end - 1)) == SEMI)

  000ac	8b 44 24 30	 mov	 eax, DWORD PTR end$[rsp]
  000b0	ff c8		 dec	 eax
  000b2	48 98		 cdqe
  000b4	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000b8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR n$[rsp]
  000bd	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000c1	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000c5	83 f8 0d	 cmp	 eax, 13
  000c8	75 0a		 jne	 SHORT $LN17@ast_for_su

; 3073 :             end--;

  000ca	8b 44 24 30	 mov	 eax, DWORD PTR end$[rsp]
  000ce	ff c8		 dec	 eax
  000d0	89 44 24 30	 mov	 DWORD PTR end$[rsp], eax
$LN17@ast_for_su:

; 3074 :         /* loop by 2 to skip semi-colons */
; 3075 :         for (i = 0; i < end; i += 2) {

  000d4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000dc	eb 0b		 jmp	 SHORT $LN16@ast_for_su
$LN15@ast_for_su:
  000de	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000e2	83 c0 02	 add	 eax, 2
  000e5	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN16@ast_for_su:
  000e9	8b 44 24 30	 mov	 eax, DWORD PTR end$[rsp]
  000ed	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000f1	0f 8d 98 00 00
	00		 jge	 $LN14@ast_for_su

; 3076 :             ch = CHILD(n, i);

  000f7	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000fc	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00100	48 8b 4c 24 78	 mov	 rcx, QWORD PTR n$[rsp]
  00105	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00109	48 89 44 24 40	 mov	 QWORD PTR ch$[rsp], rax

; 3077 :             s = ast_for_stmt(c, ch);

  0010e	48 8b 54 24 40	 mov	 rdx, QWORD PTR ch$[rsp]
  00113	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00118	e8 00 00 00 00	 call	 ast_for_stmt
  0011d	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 3078 :             if (!s)

  00122	48 83 7c 24 28
	00		 cmp	 QWORD PTR s$[rsp], 0
  00128	75 07		 jne	 SHORT $LN13@ast_for_su

; 3079 :                 return NULL;

  0012a	33 c0		 xor	 eax, eax
  0012c	e9 d7 02 00 00	 jmp	 $LN20@ast_for_su
$LN13@ast_for_su:

; 3080 :             asdl_seq_SET(seq, pos++, s);

  00131	8b 44 24 48	 mov	 eax, DWORD PTR pos$[rsp]
  00135	89 44 24 4c	 mov	 DWORD PTR _asdl_i$24089[rsp], eax
  00139	8b 44 24 48	 mov	 eax, DWORD PTR pos$[rsp]
  0013d	ff c0		 inc	 eax
  0013f	89 44 24 48	 mov	 DWORD PTR pos$[rsp], eax
  00143	48 83 7c 24 38
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00149	74 0f		 je	 SHORT $LN23@ast_for_su
  0014b	48 63 44 24 4c	 movsxd	 rax, DWORD PTR _asdl_i$24089[rsp]
  00150	48 8b 4c 24 38	 mov	 rcx, QWORD PTR seq$[rsp]
  00155	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00158	7c 1c		 jl	 SHORT $LN24@ast_for_su
$LN23@ast_for_su:
  0015a	41 b8 08 0c 00
	00		 mov	 r8d, 3080		; 00000c08H
  00160	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@GCGEEMDH@?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00174	33 c0		 xor	 eax, eax
$LN24@ast_for_su:
  00176	48 63 44 24 4c	 movsxd	 rax, DWORD PTR _asdl_i$24089[rsp]
  0017b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR seq$[rsp]
  00180	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00185	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 3081 :         }

  0018a	e9 4f ff ff ff	 jmp	 $LN15@ast_for_su
$LN14@ast_for_su:

; 3082 :     }
; 3083 :     else {

  0018f	e9 44 02 00 00	 jmp	 $LN12@ast_for_su
$LN18@ast_for_su:

; 3084 :         for (i = 2; i < (NCH(n) - 1); i++) {

  00194	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR i$[rsp], 2
  0019c	eb 0a		 jmp	 SHORT $LN11@ast_for_su
$LN10@ast_for_su:
  0019e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001a2	ff c0		 inc	 eax
  001a4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN11@ast_for_su:
  001a8	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  001ad	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001b0	ff c8		 dec	 eax
  001b2	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001b6	0f 8d 1c 02 00
	00		 jge	 $LN9@ast_for_su

; 3085 :             ch = CHILD(n, i);

  001bc	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001c1	48 6b c0 28	 imul	 rax, 40			; 00000028H
  001c5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR n$[rsp]
  001ca	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  001ce	48 89 44 24 40	 mov	 QWORD PTR ch$[rsp], rax

; 3086 :             REQ(ch, stmt);

  001d3	48 8b 44 24 40	 mov	 rax, QWORD PTR ch$[rsp]
  001d8	0f bf 00	 movsx	 eax, WORD PTR [rax]
  001db	3d 0c 01 00 00	 cmp	 eax, 268		; 0000010cH
  001e0	74 1c		 je	 SHORT $LN25@ast_for_su
  001e2	41 b8 0e 0c 00
	00		 mov	 r8d, 3086		; 00000c0eH
  001e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@KPJLECKA@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA8?$AA?$CJ?$AA?$AA@
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001fc	33 c0		 xor	 eax, eax
$LN25@ast_for_su:

; 3087 :             num = num_stmts(ch);

  001fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ch$[rsp]
  00203	e8 00 00 00 00	 call	 num_stmts
  00208	89 44 24 24	 mov	 DWORD PTR num$[rsp], eax

; 3088 :             if (num == 1) {

  0020c	83 7c 24 24 01	 cmp	 DWORD PTR num$[rsp], 1
  00211	0f 85 81 00 00
	00		 jne	 $LN8@ast_for_su

; 3089 :                 /* small_stmt or compound_stmt with only one child */
; 3090 :                 s = ast_for_stmt(c, ch);

  00217	48 8b 54 24 40	 mov	 rdx, QWORD PTR ch$[rsp]
  0021c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00221	e8 00 00 00 00	 call	 ast_for_stmt
  00226	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 3091 :                 if (!s)

  0022b	48 83 7c 24 28
	00		 cmp	 QWORD PTR s$[rsp], 0
  00231	75 07		 jne	 SHORT $LN7@ast_for_su

; 3092 :                     return NULL;

  00233	33 c0		 xor	 eax, eax
  00235	e9 ce 01 00 00	 jmp	 $LN20@ast_for_su
$LN7@ast_for_su:

; 3093 :                 asdl_seq_SET(seq, pos++, s);

  0023a	8b 44 24 48	 mov	 eax, DWORD PTR pos$[rsp]
  0023e	89 44 24 50	 mov	 DWORD PTR _asdl_i$24099[rsp], eax
  00242	8b 44 24 48	 mov	 eax, DWORD PTR pos$[rsp]
  00246	ff c0		 inc	 eax
  00248	89 44 24 48	 mov	 DWORD PTR pos$[rsp], eax
  0024c	48 83 7c 24 38
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00252	74 0f		 je	 SHORT $LN26@ast_for_su
  00254	48 63 44 24 50	 movsxd	 rax, DWORD PTR _asdl_i$24099[rsp]
  00259	48 8b 4c 24 38	 mov	 rcx, QWORD PTR seq$[rsp]
  0025e	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00261	7c 1c		 jl	 SHORT $LN27@ast_for_su
$LN26@ast_for_su:
  00263	41 b8 15 0c 00
	00		 mov	 r8d, 3093		; 00000c15H
  00269	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00270	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@GCGEEMDH@?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  00277	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0027d	33 c0		 xor	 eax, eax
$LN27@ast_for_su:
  0027f	48 63 44 24 50	 movsxd	 rax, DWORD PTR _asdl_i$24099[rsp]
  00284	48 8b 4c 24 38	 mov	 rcx, QWORD PTR seq$[rsp]
  00289	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  0028e	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 3094 :             }
; 3095 :             else {

  00293	e9 3b 01 00 00	 jmp	 $LN6@ast_for_su
$LN8@ast_for_su:

; 3096 :                 int j;
; 3097 :                 ch = CHILD(ch, 0);

  00298	48 8b 44 24 40	 mov	 rax, QWORD PTR ch$[rsp]
  0029d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002a1	48 89 44 24 40	 mov	 QWORD PTR ch$[rsp], rax

; 3098 :                 REQ(ch, simple_stmt);

  002a6	48 8b 44 24 40	 mov	 rax, QWORD PTR ch$[rsp]
  002ab	0f bf 00	 movsx	 eax, WORD PTR [rax]
  002ae	3d 0d 01 00 00	 cmp	 eax, 269		; 0000010dH
  002b3	74 1c		 je	 SHORT $LN28@ast_for_su
  002b5	41 b8 1a 0c 00
	00		 mov	 r8d, 3098		; 00000c1aH
  002bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  002c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@GEMHJBAF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA6?$AA9?$AA?$CJ?$AA?$AA@
  002c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002cf	33 c0		 xor	 eax, eax
$LN28@ast_for_su:

; 3099 :                 for (j = 0; j < NCH(ch); j += 2) {

  002d1	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR j$24102[rsp], 0
  002d9	eb 0b		 jmp	 SHORT $LN5@ast_for_su
$LN4@ast_for_su:
  002db	8b 44 24 54	 mov	 eax, DWORD PTR j$24102[rsp]
  002df	83 c0 02	 add	 eax, 2
  002e2	89 44 24 54	 mov	 DWORD PTR j$24102[rsp], eax
$LN5@ast_for_su:
  002e6	48 8b 44 24 40	 mov	 rax, QWORD PTR ch$[rsp]
  002eb	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  002ee	39 44 24 54	 cmp	 DWORD PTR j$24102[rsp], eax
  002f2	0f 8d db 00 00
	00		 jge	 $LN3@ast_for_su

; 3100 :                     /* statement terminates with a semi-colon ';' */
; 3101 :                     if (NCH(CHILD(ch, j)) == 0) {

  002f8	48 63 44 24 54	 movsxd	 rax, DWORD PTR j$24102[rsp]
  002fd	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00301	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ch$[rsp]
  00306	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0030a	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  0030f	75 31		 jne	 SHORT $LN2@ast_for_su

; 3102 :                         assert((j + 1) == NCH(ch));

  00311	8b 44 24 54	 mov	 eax, DWORD PTR j$24102[rsp]
  00315	ff c0		 inc	 eax
  00317	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ch$[rsp]
  0031c	3b 41 18	 cmp	 eax, DWORD PTR [rcx+24]
  0031f	74 1c		 je	 SHORT $LN29@ast_for_su
  00321	41 b8 1e 0c 00
	00		 mov	 r8d, 3102		; 00000c1eH
  00327	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0032e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@GCIPBBIC@?$AA?$CI?$AAj?$AA?5?$AA?$CL?$AA?5?$AA1?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAC?$AAH?$AA?$CI?$AAc?$AAh?$AA?$CJ?$AA?$AA@
  00335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0033b	33 c0		 xor	 eax, eax
$LN29@ast_for_su:

; 3103 :                         break;

  0033d	e9 91 00 00 00	 jmp	 $LN3@ast_for_su
$LN2@ast_for_su:

; 3104 :                     }
; 3105 :                     s = ast_for_stmt(c, CHILD(ch, j));

  00342	48 63 44 24 54	 movsxd	 rax, DWORD PTR j$24102[rsp]
  00347	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0034b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ch$[rsp]
  00350	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00354	48 8b d0	 mov	 rdx, rax
  00357	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0035c	e8 00 00 00 00	 call	 ast_for_stmt
  00361	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 3106 :                     if (!s)

  00366	48 83 7c 24 28
	00		 cmp	 QWORD PTR s$[rsp], 0
  0036c	75 07		 jne	 SHORT $LN1@ast_for_su

; 3107 :                         return NULL;

  0036e	33 c0		 xor	 eax, eax
  00370	e9 93 00 00 00	 jmp	 $LN20@ast_for_su
$LN1@ast_for_su:

; 3108 :                     asdl_seq_SET(seq, pos++, s);

  00375	8b 44 24 48	 mov	 eax, DWORD PTR pos$[rsp]
  00379	89 44 24 58	 mov	 DWORD PTR _asdl_i$24112[rsp], eax
  0037d	8b 44 24 48	 mov	 eax, DWORD PTR pos$[rsp]
  00381	ff c0		 inc	 eax
  00383	89 44 24 48	 mov	 DWORD PTR pos$[rsp], eax
  00387	48 83 7c 24 38
	00		 cmp	 QWORD PTR seq$[rsp], 0
  0038d	74 0f		 je	 SHORT $LN30@ast_for_su
  0038f	48 63 44 24 58	 movsxd	 rax, DWORD PTR _asdl_i$24112[rsp]
  00394	48 8b 4c 24 38	 mov	 rcx, QWORD PTR seq$[rsp]
  00399	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  0039c	7c 1c		 jl	 SHORT $LN31@ast_for_su
$LN30@ast_for_su:
  0039e	41 b8 24 0c 00
	00		 mov	 r8d, 3108		; 00000c24H
  003a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  003ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@GCGEEMDH@?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAs?$AAe?$AAq?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  003b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003b8	33 c0		 xor	 eax, eax
$LN31@ast_for_su:
  003ba	48 63 44 24 58	 movsxd	 rax, DWORD PTR _asdl_i$24112[rsp]
  003bf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR seq$[rsp]
  003c4	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  003c9	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 3109 :                 }

  003ce	e9 08 ff ff ff	 jmp	 $LN4@ast_for_su
$LN3@ast_for_su:
$LN6@ast_for_su:

; 3110 :             }
; 3111 :         }

  003d3	e9 c6 fd ff ff	 jmp	 $LN10@ast_for_su
$LN9@ast_for_su:
$LN12@ast_for_su:

; 3112 :     }
; 3113 :     assert(pos == seq->size);

  003d8	48 63 44 24 48	 movsxd	 rax, DWORD PTR pos$[rsp]
  003dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR seq$[rsp]
  003e2	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  003e5	74 1c		 je	 SHORT $LN32@ast_for_su
  003e7	41 b8 29 0c 00
	00		 mov	 r8d, 3113		; 00000c29H
  003ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  003f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MGFDFFEL@?$AAp?$AAo?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAs?$AAe?$AAq?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?$AA@
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00401	33 c0		 xor	 eax, eax
$LN32@ast_for_su:

; 3114 :     return seq;

  00403	48 8b 44 24 38	 mov	 rax, QWORD PTR seq$[rsp]
$LN20@ast_for_su:

; 3115 : }

  00408	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0040c	c3		 ret	 0
ast_for_suite ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@DBODNALO@unexpected?5token?5in?5?8if?8?5stateme@ ; `string'
PUBLIC	??_C@_1EK@OPBDPBKB@?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?9?$AA?$DO@ ; `string'
PUBLIC	??_C@_1EK@PNODFBDF@?$AA?$CI?$AAo?$AAr?$AAe?$AAl?$AAs?$AAe?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAo?$AAr?$AAe?$AAl?$AAs?$AAe?$AA?$CJ?$AA?9?$AA?$DO@ ; `string'
PUBLIC	??_C@_1CC@KEPFPJCM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA4?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_If:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_if_stmt DD imagerel ast_for_if_stmt
	DD	imagerel ast_for_if_stmt+1827
	DD	imagerel $unwind$ast_for_if_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_if_stmt DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_0CH@DBODNALO@unexpected?5token?5in?5?8if?8?5stateme@
CONST	SEGMENT
??_C@_0CH@DBODNALO@unexpected?5token?5in?5?8if?8?5stateme@ DB 'unexpected'
	DB	' token in ''if'' statement: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@OPBDPBKB@?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?9?$AA?$DO@
CONST	SEGMENT
??_C@_1EK@OPBDPBKB@?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?9?$AA?$DO@ DB '('
	DB	00H, 'n', 00H, 'e', 00H, 'w', 00H, 'o', 00H, 'b', 00H, 'j', 00H
	DB	')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a'
	DB	00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, '(', 00H, 'n', 00H, 'e', 00H, 'w', 00H, 'o'
	DB	00H, 'b', 00H, 'j', 00H, ')', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@PNODFBDF@?$AA?$CI?$AAo?$AAr?$AAe?$AAl?$AAs?$AAe?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAo?$AAr?$AAe?$AAl?$AAs?$AAe?$AA?$CJ?$AA?9?$AA?$DO@
CONST	SEGMENT
??_C@_1EK@PNODFBDF@?$AA?$CI?$AAo?$AAr?$AAe?$AAl?$AAs?$AAe?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAo?$AAr?$AAe?$AAl?$AAs?$AAe?$AA?$CJ?$AA?9?$AA?$DO@ DB '('
	DB	00H, 'o', 00H, 'r', 00H, 'e', 00H, 'l', 00H, 's', 00H, 'e', 00H
	DB	')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a'
	DB	00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, '(', 00H, 'o', 00H, 'r', 00H, 'e', 00H, 'l'
	DB	00H, 's', 00H, 'e', 00H, ')', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@KEPFPJCM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA4?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@KEPFPJCM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA4?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '9'
	DB	00H, '4', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_if_stmt
_TEXT	SEGMENT
s$ = 48
expression$24126 = 56
suite_seq$24127 = 64
expression$24134 = 72
seq1$24135 = 80
seq2$24136 = 88
i$24145 = 96
n_elif$24146 = 100
expression$24148 = 104
suite_seq$24149 = 112
has_else$24147 = 120
orelse$24150 = 128
suite_seq2$24154 = 136
_asdl_i$24163 = 144
off$24169 = 148
newobj$24170 = 152
_asdl_i$24177 = 160
c$ = 192
n$ = 200
ast_for_if_stmt PROC					; COMDAT

; 3119 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 3120 :     /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*
; 3121 :        ['else' ':' suite]
; 3122 :     */
; 3123 :     char *s;
; 3124 : 
; 3125 :     REQ(n, if_stmt);

  00011	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00019	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0001c	3d 26 01 00 00	 cmp	 eax, 294		; 00000126H
  00021	74 1c		 je	 SHORT $LN26@ast_for_if@2
  00023	41 b8 35 0c 00
	00		 mov	 r8d, 3125		; 00000c35H
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@KEPFPJCM@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA4?$AA?$CJ?$AA?$AA@
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003d	33 c0		 xor	 eax, eax
$LN26@ast_for_if@2:

; 3126 : 
; 3127 :     if (NCH(n) == 4) {

  0003f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00047	83 78 18 04	 cmp	 DWORD PTR [rax+24], 4
  0004b	0f 85 ab 00 00
	00		 jne	 $LN23@ast_for_if@2

; 3128 :         expr_ty expression;
; 3129 :         asdl_seq *suite_seq;
; 3130 : 
; 3131 :         expression = ast_for_expr(c, CHILD(n, 1));

  00051	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00059	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0005d	48 83 c0 28	 add	 rax, 40			; 00000028H
  00061	48 8b d0	 mov	 rdx, rax
  00064	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0006c	e8 00 00 00 00	 call	 ast_for_expr
  00071	48 89 44 24 38	 mov	 QWORD PTR expression$24126[rsp], rax

; 3132 :         if (!expression)

  00076	48 83 7c 24 38
	00		 cmp	 QWORD PTR expression$24126[rsp], 0
  0007c	75 07		 jne	 SHORT $LN22@ast_for_if@2

; 3133 :             return NULL;

  0007e	33 c0		 xor	 eax, eax
  00080	e9 96 06 00 00	 jmp	 $LN24@ast_for_if@2
$LN22@ast_for_if@2:

; 3134 :         suite_seq = ast_for_suite(c, CHILD(n, 3));

  00085	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0008d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00091	48 83 c0 78	 add	 rax, 120		; 00000078H
  00095	48 8b d0	 mov	 rdx, rax
  00098	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000a0	e8 00 00 00 00	 call	 ast_for_suite
  000a5	48 89 44 24 40	 mov	 QWORD PTR suite_seq$24127[rsp], rax

; 3135 :         if (!suite_seq)

  000aa	48 83 7c 24 40
	00		 cmp	 QWORD PTR suite_seq$24127[rsp], 0
  000b0	75 07		 jne	 SHORT $LN21@ast_for_if@2

; 3136 :             return NULL;

  000b2	33 c0		 xor	 eax, eax
  000b4	e9 62 06 00 00	 jmp	 $LN24@ast_for_if@2
$LN21@ast_for_if@2:

; 3137 : 
; 3138 :         return If(expression, suite_seq, NULL, LINENO(n), n->n_col_offset,
; 3139 :                   c->c_arena);

  000b9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000c1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ca	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000d2	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000d5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000d9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000e1	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  000e5	45 33 c0	 xor	 r8d, r8d
  000e8	48 8b 54 24 40	 mov	 rdx, QWORD PTR suite_seq$24127[rsp]
  000ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR expression$24126[rsp]
  000f2	e8 00 00 00 00	 call	 _Py_If
  000f7	e9 1f 06 00 00	 jmp	 $LN24@ast_for_if@2
$LN23@ast_for_if@2:

; 3140 :     }
; 3141 : 
; 3142 :     s = STR(CHILD(n, 4));

  000fc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00104	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00108	48 8b 80 a8 00
	00 00		 mov	 rax, QWORD PTR [rax+168]
  0010f	48 89 44 24 30	 mov	 QWORD PTR s$[rsp], rax

; 3143 :     /* s[2], the third character in the string, will be
; 3144 :        's' for el_s_e, or
; 3145 :        'i' for el_i_f
; 3146 :     */
; 3147 :     if (s[2] == 's') {

  00114	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00119	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  0011d	83 f8 73	 cmp	 eax, 115		; 00000073H
  00120	0f 85 e8 00 00
	00		 jne	 $LN20@ast_for_if@2

; 3148 :         expr_ty expression;
; 3149 :         asdl_seq *seq1, *seq2;
; 3150 : 
; 3151 :         expression = ast_for_expr(c, CHILD(n, 1));

  00126	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0012e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00132	48 83 c0 28	 add	 rax, 40			; 00000028H
  00136	48 8b d0	 mov	 rdx, rax
  00139	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00141	e8 00 00 00 00	 call	 ast_for_expr
  00146	48 89 44 24 48	 mov	 QWORD PTR expression$24134[rsp], rax

; 3152 :         if (!expression)

  0014b	48 83 7c 24 48
	00		 cmp	 QWORD PTR expression$24134[rsp], 0
  00151	75 07		 jne	 SHORT $LN19@ast_for_if@2

; 3153 :             return NULL;

  00153	33 c0		 xor	 eax, eax
  00155	e9 c1 05 00 00	 jmp	 $LN24@ast_for_if@2
$LN19@ast_for_if@2:

; 3154 :         seq1 = ast_for_suite(c, CHILD(n, 3));

  0015a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00162	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00166	48 83 c0 78	 add	 rax, 120		; 00000078H
  0016a	48 8b d0	 mov	 rdx, rax
  0016d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00175	e8 00 00 00 00	 call	 ast_for_suite
  0017a	48 89 44 24 50	 mov	 QWORD PTR seq1$24135[rsp], rax

; 3155 :         if (!seq1)

  0017f	48 83 7c 24 50
	00		 cmp	 QWORD PTR seq1$24135[rsp], 0
  00185	75 07		 jne	 SHORT $LN18@ast_for_if@2

; 3156 :             return NULL;

  00187	33 c0		 xor	 eax, eax
  00189	e9 8d 05 00 00	 jmp	 $LN24@ast_for_if@2
$LN18@ast_for_if@2:

; 3157 :         seq2 = ast_for_suite(c, CHILD(n, 6));

  0018e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00196	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0019a	48 05 f0 00 00
	00		 add	 rax, 240		; 000000f0H
  001a0	48 8b d0	 mov	 rdx, rax
  001a3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001ab	e8 00 00 00 00	 call	 ast_for_suite
  001b0	48 89 44 24 58	 mov	 QWORD PTR seq2$24136[rsp], rax

; 3158 :         if (!seq2)

  001b5	48 83 7c 24 58
	00		 cmp	 QWORD PTR seq2$24136[rsp], 0
  001bb	75 07		 jne	 SHORT $LN17@ast_for_if@2

; 3159 :             return NULL;

  001bd	33 c0		 xor	 eax, eax
  001bf	e9 57 05 00 00	 jmp	 $LN24@ast_for_if@2
$LN17@ast_for_if@2:

; 3160 : 
; 3161 :         return If(expression, seq1, seq2, LINENO(n), n->n_col_offset,
; 3162 :                   c->c_arena);

  001c4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  001cc	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001d0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001dd	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001e0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001e4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001ec	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  001f0	4c 8b 44 24 58	 mov	 r8, QWORD PTR seq2$24136[rsp]
  001f5	48 8b 54 24 50	 mov	 rdx, QWORD PTR seq1$24135[rsp]
  001fa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR expression$24134[rsp]
  001ff	e8 00 00 00 00	 call	 _Py_If
  00204	e9 12 05 00 00	 jmp	 $LN24@ast_for_if@2
  00209	e9 f3 04 00 00	 jmp	 $LN16@ast_for_if@2
$LN20@ast_for_if@2:

; 3163 :     }
; 3164 :     else if (s[2] == 'i') {

  0020e	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00213	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  00217	83 f8 69	 cmp	 eax, 105		; 00000069H
  0021a	0f 85 e1 04 00
	00		 jne	 $LN15@ast_for_if@2

; 3165 :         int i, n_elif, has_else = 0;

  00220	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR has_else$24147[rsp], 0

; 3166 :         expr_ty expression;
; 3167 :         asdl_seq *suite_seq;
; 3168 :         asdl_seq *orelse = NULL;

  00228	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR orelse$24150[rsp], 0

; 3169 :         n_elif = NCH(n) - 4;

  00234	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0023c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0023f	83 e8 04	 sub	 eax, 4
  00242	89 44 24 64	 mov	 DWORD PTR n_elif$24146[rsp], eax

; 3170 :         /* must reference the child n_elif+1 since 'else' token is third,
; 3171 :            not fourth, child from the end. */
; 3172 :         if (TYPE(CHILD(n, (n_elif + 1))) == NAME
; 3173 :             && STR(CHILD(n, (n_elif + 1)))[2] == 's') {

  00246	8b 44 24 64	 mov	 eax, DWORD PTR n_elif$24146[rsp]
  0024a	ff c0		 inc	 eax
  0024c	48 98		 cdqe
  0024e	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00252	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0025a	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0025e	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00262	83 f8 01	 cmp	 eax, 1
  00265	75 39		 jne	 SHORT $LN14@ast_for_if@2
  00267	8b 44 24 64	 mov	 eax, DWORD PTR n_elif$24146[rsp]
  0026b	ff c0		 inc	 eax
  0026d	48 98		 cdqe
  0026f	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00273	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0027b	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0027f	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00284	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  00288	83 f8 73	 cmp	 eax, 115		; 00000073H
  0028b	75 13		 jne	 SHORT $LN14@ast_for_if@2

; 3174 :             has_else = 1;

  0028d	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR has_else$24147[rsp], 1

; 3175 :             n_elif -= 3;

  00295	8b 44 24 64	 mov	 eax, DWORD PTR n_elif$24146[rsp]
  00299	83 e8 03	 sub	 eax, 3
  0029c	89 44 24 64	 mov	 DWORD PTR n_elif$24146[rsp], eax
$LN14@ast_for_if@2:

; 3176 :         }
; 3177 :         n_elif /= 4;

  002a0	8b 44 24 64	 mov	 eax, DWORD PTR n_elif$24146[rsp]
  002a4	99		 cdq
  002a5	83 e2 03	 and	 edx, 3
  002a8	03 c2		 add	 eax, edx
  002aa	c1 f8 02	 sar	 eax, 2
  002ad	89 44 24 64	 mov	 DWORD PTR n_elif$24146[rsp], eax

; 3178 : 
; 3179 :         if (has_else) {

  002b1	83 7c 24 78 00	 cmp	 DWORD PTR has_else$24147[rsp], 0
  002b6	0f 84 dd 01 00
	00		 je	 $LN13@ast_for_if@2

; 3180 :             asdl_seq *suite_seq2;
; 3181 : 
; 3182 :             orelse = asdl_seq_new(1, c->c_arena);

  002bc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  002c4	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  002c8	b9 01 00 00 00	 mov	 ecx, 1
  002cd	e8 00 00 00 00	 call	 asdl_seq_new
  002d2	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR orelse$24150[rsp], rax

; 3183 :             if (!orelse)

  002da	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR orelse$24150[rsp], 0
  002e3	75 07		 jne	 SHORT $LN12@ast_for_if@2

; 3184 :                 return NULL;

  002e5	33 c0		 xor	 eax, eax
  002e7	e9 2f 04 00 00	 jmp	 $LN24@ast_for_if@2
$LN12@ast_for_if@2:

; 3185 :             expression = ast_for_expr(c, CHILD(n, NCH(n) - 6));

  002ec	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002f4	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  002f7	83 e8 06	 sub	 eax, 6
  002fa	48 98		 cdqe
  002fc	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00300	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00308	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0030c	48 8b d0	 mov	 rdx, rax
  0030f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00317	e8 00 00 00 00	 call	 ast_for_expr
  0031c	48 89 44 24 68	 mov	 QWORD PTR expression$24148[rsp], rax

; 3186 :             if (!expression)

  00321	48 83 7c 24 68
	00		 cmp	 QWORD PTR expression$24148[rsp], 0
  00327	75 07		 jne	 SHORT $LN11@ast_for_if@2

; 3187 :                 return NULL;

  00329	33 c0		 xor	 eax, eax
  0032b	e9 eb 03 00 00	 jmp	 $LN24@ast_for_if@2
$LN11@ast_for_if@2:

; 3188 :             suite_seq = ast_for_suite(c, CHILD(n, NCH(n) - 4));

  00330	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00338	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0033b	83 e8 04	 sub	 eax, 4
  0033e	48 98		 cdqe
  00340	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00344	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0034c	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00350	48 8b d0	 mov	 rdx, rax
  00353	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0035b	e8 00 00 00 00	 call	 ast_for_suite
  00360	48 89 44 24 70	 mov	 QWORD PTR suite_seq$24149[rsp], rax

; 3189 :             if (!suite_seq)

  00365	48 83 7c 24 70
	00		 cmp	 QWORD PTR suite_seq$24149[rsp], 0
  0036b	75 07		 jne	 SHORT $LN10@ast_for_if@2

; 3190 :                 return NULL;

  0036d	33 c0		 xor	 eax, eax
  0036f	e9 a7 03 00 00	 jmp	 $LN24@ast_for_if@2
$LN10@ast_for_if@2:

; 3191 :             suite_seq2 = ast_for_suite(c, CHILD(n, NCH(n) - 1));

  00374	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0037c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0037f	ff c8		 dec	 eax
  00381	48 98		 cdqe
  00383	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00387	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0038f	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00393	48 8b d0	 mov	 rdx, rax
  00396	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0039e	e8 00 00 00 00	 call	 ast_for_suite
  003a3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR suite_seq2$24154[rsp], rax

; 3192 :             if (!suite_seq2)

  003ab	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR suite_seq2$24154[rsp], 0
  003b4	75 07		 jne	 SHORT $LN9@ast_for_if@2

; 3193 :                 return NULL;

  003b6	33 c0		 xor	 eax, eax
  003b8	e9 5e 03 00 00	 jmp	 $LN24@ast_for_if@2
$LN9@ast_for_if@2:

; 3194 : 
; 3195 :             asdl_seq_SET(orelse, 0,
; 3196 :                          If(expression, suite_seq, suite_seq2,
; 3197 :                             LINENO(CHILD(n, NCH(n) - 6)),
; 3198 :                             CHILD(n, NCH(n) - 6)->n_col_offset,
; 3199 :                             c->c_arena));

  003bd	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _asdl_i$24163[rsp], 0
  003c8	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR orelse$24150[rsp], 0
  003d1	74 15		 je	 SHORT $LN27@ast_for_if@2
  003d3	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$24163[rsp]
  003db	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR orelse$24150[rsp]
  003e3	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  003e6	7c 1c		 jl	 SHORT $LN28@ast_for_if@2
$LN27@ast_for_if@2:
  003e8	41 b8 7f 0c 00
	00		 mov	 r8d, 3199		; 00000c7fH
  003ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  003f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EK@PNODFBDF@?$AA?$CI?$AAo?$AAr?$AAe?$AAl?$AAs?$AAe?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAo?$AAr?$AAe?$AAl?$AAs?$AAe?$AA?$CJ?$AA?9?$AA?$DO@
  003fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00402	33 c0		 xor	 eax, eax
$LN28@ast_for_if@2:
  00404	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0040c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0040f	83 e8 06	 sub	 eax, 6
  00412	48 98		 cdqe
  00414	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00418	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00420	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00424	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  0042c	8b 52 18	 mov	 edx, DWORD PTR [rdx+24]
  0042f	83 ea 06	 sub	 edx, 6
  00432	48 63 d2	 movsxd	 rdx, edx
  00435	48 6b d2 28	 imul	 rdx, 40			; 00000028H
  00439	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR n$[rsp]
  00441	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  00445	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR c$[rsp]
  0044d	4d 8b 49 08	 mov	 r9, QWORD PTR [r9+8]
  00451	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  00456	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  0045a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0045e	45 8b 4c 10 10	 mov	 r9d, DWORD PTR [r8+rdx+16]
  00463	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR suite_seq2$24154[rsp]
  0046b	48 8b 54 24 70	 mov	 rdx, QWORD PTR suite_seq$24149[rsp]
  00470	48 8b 4c 24 68	 mov	 rcx, QWORD PTR expression$24148[rsp]
  00475	e8 00 00 00 00	 call	 _Py_If
  0047a	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR _asdl_i$24163[rsp]
  00482	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR orelse$24150[rsp]
  0048a	48 89 44 ca 08	 mov	 QWORD PTR [rdx+rcx*8+8], rax

; 3200 :             /* the just-created orelse handled the last elif */
; 3201 :             n_elif--;

  0048f	8b 44 24 64	 mov	 eax, DWORD PTR n_elif$24146[rsp]
  00493	ff c8		 dec	 eax
  00495	89 44 24 64	 mov	 DWORD PTR n_elif$24146[rsp], eax
$LN13@ast_for_if@2:

; 3202 :         }
; 3203 : 
; 3204 :         for (i = 0; i < n_elif; i++) {

  00499	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$24145[rsp], 0
  004a1	eb 0a		 jmp	 SHORT $LN8@ast_for_if@2
$LN7@ast_for_if@2:
  004a3	8b 44 24 60	 mov	 eax, DWORD PTR i$24145[rsp]
  004a7	ff c0		 inc	 eax
  004a9	89 44 24 60	 mov	 DWORD PTR i$24145[rsp], eax
$LN8@ast_for_if@2:
  004ad	8b 44 24 64	 mov	 eax, DWORD PTR n_elif$24146[rsp]
  004b1	39 44 24 60	 cmp	 DWORD PTR i$24145[rsp], eax
  004b5	0f 8d 9c 01 00
	00		 jge	 $LN6@ast_for_if@2

; 3205 :             int off = 5 + (n_elif - i - 1) * 4;

  004bb	8b 44 24 60	 mov	 eax, DWORD PTR i$24145[rsp]
  004bf	8b 4c 24 64	 mov	 ecx, DWORD PTR n_elif$24146[rsp]
  004c3	2b c8		 sub	 ecx, eax
  004c5	8b c1		 mov	 eax, ecx
  004c7	8d 04 85 01 00
	00 00		 lea	 eax, DWORD PTR [rax*4+1]
  004ce	89 84 24 94 00
	00 00		 mov	 DWORD PTR off$24169[rsp], eax

; 3206 :             asdl_seq *newobj = asdl_seq_new(1, c->c_arena);

  004d5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  004dd	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  004e1	b9 01 00 00 00	 mov	 ecx, 1
  004e6	e8 00 00 00 00	 call	 asdl_seq_new
  004eb	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR newobj$24170[rsp], rax

; 3207 :             if (!newobj)

  004f3	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR newobj$24170[rsp], 0
  004fc	75 07		 jne	 SHORT $LN5@ast_for_if@2

; 3208 :                 return NULL;

  004fe	33 c0		 xor	 eax, eax
  00500	e9 16 02 00 00	 jmp	 $LN24@ast_for_if@2
$LN5@ast_for_if@2:

; 3209 :             expression = ast_for_expr(c, CHILD(n, off));

  00505	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR off$24169[rsp]
  0050d	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00511	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00519	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0051d	48 8b d0	 mov	 rdx, rax
  00520	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00528	e8 00 00 00 00	 call	 ast_for_expr
  0052d	48 89 44 24 68	 mov	 QWORD PTR expression$24148[rsp], rax

; 3210 :             if (!expression)

  00532	48 83 7c 24 68
	00		 cmp	 QWORD PTR expression$24148[rsp], 0
  00538	75 07		 jne	 SHORT $LN4@ast_for_if@2

; 3211 :                 return NULL;

  0053a	33 c0		 xor	 eax, eax
  0053c	e9 da 01 00 00	 jmp	 $LN24@ast_for_if@2
$LN4@ast_for_if@2:

; 3212 :             suite_seq = ast_for_suite(c, CHILD(n, off + 2));

  00541	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR off$24169[rsp]
  00548	83 c0 02	 add	 eax, 2
  0054b	48 98		 cdqe
  0054d	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00551	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00559	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0055d	48 8b d0	 mov	 rdx, rax
  00560	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00568	e8 00 00 00 00	 call	 ast_for_suite
  0056d	48 89 44 24 70	 mov	 QWORD PTR suite_seq$24149[rsp], rax

; 3213 :             if (!suite_seq)

  00572	48 83 7c 24 70
	00		 cmp	 QWORD PTR suite_seq$24149[rsp], 0
  00578	75 07		 jne	 SHORT $LN3@ast_for_if@2

; 3214 :                 return NULL;

  0057a	33 c0		 xor	 eax, eax
  0057c	e9 9a 01 00 00	 jmp	 $LN24@ast_for_if@2
$LN3@ast_for_if@2:

; 3215 : 
; 3216 :             asdl_seq_SET(newobj, 0,
; 3217 :                          If(expression, suite_seq, orelse,
; 3218 :                             LINENO(CHILD(n, off)),
; 3219 :                             CHILD(n, off)->n_col_offset, c->c_arena));

  00581	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR _asdl_i$24177[rsp], 0
  0058c	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR newobj$24170[rsp], 0
  00595	74 15		 je	 SHORT $LN29@ast_for_if@2
  00597	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR _asdl_i$24177[rsp]
  0059f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR newobj$24170[rsp]
  005a7	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  005aa	7c 1c		 jl	 SHORT $LN30@ast_for_if@2
$LN29@ast_for_if@2:
  005ac	41 b8 93 0c 00
	00		 mov	 r8d, 3219		; 00000c93H
  005b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  005b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EK@OPBDPBKB@?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAn?$AAe?$AAw?$AAo?$AAb?$AAj?$AA?$CJ?$AA?9?$AA?$DO@
  005c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005c6	33 c0		 xor	 eax, eax
$LN30@ast_for_if@2:
  005c8	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR off$24169[rsp]
  005d0	48 6b c0 28	 imul	 rax, 40			; 00000028H
  005d4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  005dc	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  005e0	48 63 94 24 94
	00 00 00	 movsxd	 rdx, DWORD PTR off$24169[rsp]
  005e8	48 6b d2 28	 imul	 rdx, 40			; 00000028H
  005ec	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR n$[rsp]
  005f4	4d 8b 40 20	 mov	 r8, QWORD PTR [r8+32]
  005f8	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR c$[rsp]
  00600	4d 8b 49 08	 mov	 r9, QWORD PTR [r9+8]
  00604	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  00609	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  0060d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00611	45 8b 4c 10 10	 mov	 r9d, DWORD PTR [r8+rdx+16]
  00616	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR orelse$24150[rsp]
  0061e	48 8b 54 24 70	 mov	 rdx, QWORD PTR suite_seq$24149[rsp]
  00623	48 8b 4c 24 68	 mov	 rcx, QWORD PTR expression$24148[rsp]
  00628	e8 00 00 00 00	 call	 _Py_If
  0062d	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR _asdl_i$24177[rsp]
  00635	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR newobj$24170[rsp]
  0063d	48 89 44 ca 08	 mov	 QWORD PTR [rdx+rcx*8+8], rax

; 3220 :             orelse = newobj;

  00642	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR newobj$24170[rsp]
  0064a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR orelse$24150[rsp], rax

; 3221 :         }

  00652	e9 4c fe ff ff	 jmp	 $LN7@ast_for_if@2
$LN6@ast_for_if@2:

; 3222 :         expression = ast_for_expr(c, CHILD(n, 1));

  00657	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0065f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00663	48 83 c0 28	 add	 rax, 40			; 00000028H
  00667	48 8b d0	 mov	 rdx, rax
  0066a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00672	e8 00 00 00 00	 call	 ast_for_expr
  00677	48 89 44 24 68	 mov	 QWORD PTR expression$24148[rsp], rax

; 3223 :         if (!expression)

  0067c	48 83 7c 24 68
	00		 cmp	 QWORD PTR expression$24148[rsp], 0
  00682	75 07		 jne	 SHORT $LN2@ast_for_if@2

; 3224 :             return NULL;

  00684	33 c0		 xor	 eax, eax
  00686	e9 90 00 00 00	 jmp	 $LN24@ast_for_if@2
$LN2@ast_for_if@2:

; 3225 :         suite_seq = ast_for_suite(c, CHILD(n, 3));

  0068b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00693	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00697	48 83 c0 78	 add	 rax, 120		; 00000078H
  0069b	48 8b d0	 mov	 rdx, rax
  0069e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  006a6	e8 00 00 00 00	 call	 ast_for_suite
  006ab	48 89 44 24 70	 mov	 QWORD PTR suite_seq$24149[rsp], rax

; 3226 :         if (!suite_seq)

  006b0	48 83 7c 24 70
	00		 cmp	 QWORD PTR suite_seq$24149[rsp], 0
  006b6	75 04		 jne	 SHORT $LN1@ast_for_if@2

; 3227 :             return NULL;

  006b8	33 c0		 xor	 eax, eax
  006ba	eb 5f		 jmp	 SHORT $LN24@ast_for_if@2
$LN1@ast_for_if@2:

; 3228 :         return If(expression, suite_seq, orelse,
; 3229 :                   LINENO(n), n->n_col_offset, c->c_arena);

  006bc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  006c4	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  006c8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006cd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  006d5	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  006d8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  006dc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  006e4	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  006e8	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR orelse$24150[rsp]
  006f0	48 8b 54 24 70	 mov	 rdx, QWORD PTR suite_seq$24149[rsp]
  006f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR expression$24148[rsp]
  006fa	e8 00 00 00 00	 call	 _Py_If
  006ff	eb 1a		 jmp	 SHORT $LN24@ast_for_if@2
$LN15@ast_for_if@2:
$LN16@ast_for_if@2:

; 3230 :     }
; 3231 : 
; 3232 :     PyErr_Format(PyExc_SystemError,
; 3233 :                  "unexpected token in 'if' statement: %s", s);

  00701	4c 8b 44 24 30	 mov	 r8, QWORD PTR s$[rsp]
  00706	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@DBODNALO@unexpected?5token?5in?5?8if?8?5stateme@
  0070d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00714	e8 00 00 00 00	 call	 PyErr_Format

; 3234 :     return NULL;

  00719	33 c0		 xor	 eax, eax
$LN24@ast_for_if@2:

; 3235 : }

  0071b	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00722	c3		 ret	 0
ast_for_if_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@BBLJCPPH@wrong?5number?5of?5tokens?5for?5?8whil@ ; `string'
PUBLIC	??_C@_1CC@GPKJCKIJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA5?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_While:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_while_stmt DD imagerel ast_for_while_stmt
	DD	imagerel ast_for_while_stmt+471
	DD	imagerel $unwind$ast_for_while_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_while_stmt DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0DB@BBLJCPPH@wrong?5number?5of?5tokens?5for?5?8whil@
CONST	SEGMENT
??_C@_0DB@BBLJCPPH@wrong?5number?5of?5tokens?5for?5?8whil@ DB 'wrong numb'
	DB	'er of tokens for ''while'' statement: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@GPKJCKIJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA5?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@GPKJCKIJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA5?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '9'
	DB	00H, '5', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_while_stmt
_TEXT	SEGMENT
expression$24195 = 48
suite_seq$24196 = 56
expression$24204 = 64
seq1$24205 = 72
seq2$24206 = 80
c$ = 112
n$ = 120
ast_for_while_stmt PROC					; COMDAT

; 3239 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3240 :     /* while_stmt: 'while' test ':' suite ['else' ':' suite] */
; 3241 :     REQ(n, while_stmt);

  0000e	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 27 01 00 00	 cmp	 eax, 295		; 00000127H
  0001b	74 1c		 je	 SHORT $LN11@ast_for_wh
  0001d	41 b8 a9 0c 00
	00		 mov	 r8d, 3241		; 00000ca9H
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@GPKJCKIJ@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA5?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN11@ast_for_wh:

; 3242 : 
; 3243 :     if (NCH(n) == 4) {

  00039	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0003e	83 78 18 04	 cmp	 DWORD PTR [rax+24], 4
  00042	0f 85 9b 00 00
	00		 jne	 $LN8@ast_for_wh

; 3244 :         expr_ty expression;
; 3245 :         asdl_seq *suite_seq;
; 3246 : 
; 3247 :         expression = ast_for_expr(c, CHILD(n, 1));

  00048	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0004d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00051	48 83 c0 28	 add	 rax, 40			; 00000028H
  00055	48 8b d0	 mov	 rdx, rax
  00058	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0005d	e8 00 00 00 00	 call	 ast_for_expr
  00062	48 89 44 24 30	 mov	 QWORD PTR expression$24195[rsp], rax

; 3248 :         if (!expression)

  00067	48 83 7c 24 30
	00		 cmp	 QWORD PTR expression$24195[rsp], 0
  0006d	75 07		 jne	 SHORT $LN7@ast_for_wh

; 3249 :             return NULL;

  0006f	33 c0		 xor	 eax, eax
  00071	e9 5c 01 00 00	 jmp	 $LN9@ast_for_wh
$LN7@ast_for_wh:

; 3250 :         suite_seq = ast_for_suite(c, CHILD(n, 3));

  00076	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0007b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0008b	e8 00 00 00 00	 call	 ast_for_suite
  00090	48 89 44 24 38	 mov	 QWORD PTR suite_seq$24196[rsp], rax

; 3251 :         if (!suite_seq)

  00095	48 83 7c 24 38
	00		 cmp	 QWORD PTR suite_seq$24196[rsp], 0
  0009b	75 07		 jne	 SHORT $LN6@ast_for_wh

; 3252 :             return NULL;

  0009d	33 c0		 xor	 eax, eax
  0009f	e9 2e 01 00 00	 jmp	 $LN9@ast_for_wh
$LN6@ast_for_wh:

; 3253 :         return While(expression, suite_seq, NULL, LINENO(n), n->n_col_offset, c->c_arena);

  000a4	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  000a9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ad	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b2	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000b7	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ba	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000be	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000c3	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  000c7	45 33 c0	 xor	 r8d, r8d
  000ca	48 8b 54 24 38	 mov	 rdx, QWORD PTR suite_seq$24196[rsp]
  000cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR expression$24195[rsp]
  000d4	e8 00 00 00 00	 call	 _Py_While
  000d9	e9 f4 00 00 00	 jmp	 $LN9@ast_for_wh
  000de	e9 d1 00 00 00	 jmp	 $LN5@ast_for_wh
$LN8@ast_for_wh:

; 3254 :     }
; 3255 :     else if (NCH(n) == 7) {

  000e3	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000e8	83 78 18 07	 cmp	 DWORD PTR [rax+24], 7
  000ec	0f 85 c2 00 00
	00		 jne	 $LN4@ast_for_wh

; 3256 :         expr_ty expression;
; 3257 :         asdl_seq *seq1, *seq2;
; 3258 : 
; 3259 :         expression = ast_for_expr(c, CHILD(n, 1));

  000f2	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000f7	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000fb	48 83 c0 28	 add	 rax, 40			; 00000028H
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00107	e8 00 00 00 00	 call	 ast_for_expr
  0010c	48 89 44 24 40	 mov	 QWORD PTR expression$24204[rsp], rax

; 3260 :         if (!expression)

  00111	48 83 7c 24 40
	00		 cmp	 QWORD PTR expression$24204[rsp], 0
  00117	75 07		 jne	 SHORT $LN3@ast_for_wh

; 3261 :             return NULL;

  00119	33 c0		 xor	 eax, eax
  0011b	e9 b2 00 00 00	 jmp	 $LN9@ast_for_wh
$LN3@ast_for_wh:

; 3262 :         seq1 = ast_for_suite(c, CHILD(n, 3));

  00120	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00125	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00129	48 83 c0 78	 add	 rax, 120		; 00000078H
  0012d	48 8b d0	 mov	 rdx, rax
  00130	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00135	e8 00 00 00 00	 call	 ast_for_suite
  0013a	48 89 44 24 48	 mov	 QWORD PTR seq1$24205[rsp], rax

; 3263 :         if (!seq1)

  0013f	48 83 7c 24 48
	00		 cmp	 QWORD PTR seq1$24205[rsp], 0
  00145	75 07		 jne	 SHORT $LN2@ast_for_wh

; 3264 :             return NULL;

  00147	33 c0		 xor	 eax, eax
  00149	e9 84 00 00 00	 jmp	 $LN9@ast_for_wh
$LN2@ast_for_wh:

; 3265 :         seq2 = ast_for_suite(c, CHILD(n, 6));

  0014e	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00153	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00157	48 05 f0 00 00
	00		 add	 rax, 240		; 000000f0H
  0015d	48 8b d0	 mov	 rdx, rax
  00160	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00165	e8 00 00 00 00	 call	 ast_for_suite
  0016a	48 89 44 24 50	 mov	 QWORD PTR seq2$24206[rsp], rax

; 3266 :         if (!seq2)

  0016f	48 83 7c 24 50
	00		 cmp	 QWORD PTR seq2$24206[rsp], 0
  00175	75 04		 jne	 SHORT $LN1@ast_for_wh

; 3267 :             return NULL;

  00177	33 c0		 xor	 eax, eax
  00179	eb 57		 jmp	 SHORT $LN9@ast_for_wh
$LN1@ast_for_wh:

; 3268 : 
; 3269 :         return While(expression, seq1, seq2, LINENO(n), n->n_col_offset, c->c_arena);

  0017b	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00180	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00184	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00189	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0018e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00191	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00195	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0019a	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  0019e	4c 8b 44 24 50	 mov	 r8, QWORD PTR seq2$24206[rsp]
  001a3	48 8b 54 24 48	 mov	 rdx, QWORD PTR seq1$24205[rsp]
  001a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR expression$24204[rsp]
  001ad	e8 00 00 00 00	 call	 _Py_While
  001b2	eb 1e		 jmp	 SHORT $LN9@ast_for_wh
$LN4@ast_for_wh:
$LN5@ast_for_wh:

; 3270 :     }
; 3271 : 
; 3272 :     PyErr_Format(PyExc_SystemError,
; 3273 :                  "wrong number of tokens for 'while' statement: %d",
; 3274 :                  NCH(n));

  001b4	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  001b9	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@BBLJCPPH@wrong?5number?5of?5tokens?5for?5?8whil@
  001c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  001cb	e8 00 00 00 00	 call	 PyErr_Format

; 3275 :     return NULL;

  001d0	33 c0		 xor	 eax, eax
$LN9@ast_for_wh:

; 3276 : }

  001d2	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001d6	c3		 ret	 0
ast_for_while_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@OJDNFICH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA6?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_For:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_for_stmt DD imagerel ast_for_for_stmt
	DD	imagerel ast_for_for_stmt+477
	DD	imagerel $unwind$ast_for_for_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_for_stmt DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_1CC@OJDNFICH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA6?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@OJDNFICH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA6?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '9'
	DB	00H, '6', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_for_stmt
_TEXT	SEGMENT
first$ = 64
_target$ = 72
expression$ = 80
suite_seq$ = 88
seq$ = 96
target$ = 104
node_target$ = 112
c$ = 144
n$ = 152
ast_for_for_stmt PROC					; COMDAT

; 3280 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 3281 :     asdl_seq *_target, *seq = NULL, *suite_seq;

  00011	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR seq$[rsp], 0

; 3282 :     expr_ty expression;
; 3283 :     expr_ty target, first;
; 3284 :     const node *node_target;
; 3285 :     /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */
; 3286 :     REQ(n, for_stmt);

  0001a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00022	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00025	3d 28 01 00 00	 cmp	 eax, 296		; 00000128H
  0002a	74 1c		 je	 SHORT $LN10@ast_for_fo
  0002c	41 b8 d6 0c 00
	00		 mov	 r8d, 3286		; 00000cd6H
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@OJDNFICH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA6?$AA?$CJ?$AA?$AA@
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00046	33 c0		 xor	 eax, eax
$LN10@ast_for_fo:

; 3287 : 
; 3288 :     if (NCH(n) == 9) {

  00048	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00050	83 78 18 09	 cmp	 DWORD PTR [rax+24], 9
  00054	75 36		 jne	 SHORT $LN7@ast_for_fo

; 3289 :         seq = ast_for_suite(c, CHILD(n, 8));

  00056	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0005e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00062	48 05 40 01 00
	00		 add	 rax, 320		; 00000140H
  00068	48 8b d0	 mov	 rdx, rax
  0006b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00073	e8 00 00 00 00	 call	 ast_for_suite
  00078	48 89 44 24 60	 mov	 QWORD PTR seq$[rsp], rax

; 3290 :         if (!seq)

  0007d	48 83 7c 24 60
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00083	75 07		 jne	 SHORT $LN6@ast_for_fo

; 3291 :             return NULL;

  00085	33 c0		 xor	 eax, eax
  00087	e9 49 01 00 00	 jmp	 $LN8@ast_for_fo
$LN6@ast_for_fo:
$LN7@ast_for_fo:

; 3292 :     }
; 3293 : 
; 3294 :     node_target = CHILD(n, 1);

  0008c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00094	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00098	48 83 c0 28	 add	 rax, 40			; 00000028H
  0009c	48 89 44 24 70	 mov	 QWORD PTR node_target$[rsp], rax

; 3295 :     _target = ast_for_exprlist(c, node_target, Store);

  000a1	41 b8 02 00 00
	00		 mov	 r8d, 2
  000a7	48 8b 54 24 70	 mov	 rdx, QWORD PTR node_target$[rsp]
  000ac	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000b4	e8 00 00 00 00	 call	 ast_for_exprlist
  000b9	48 89 44 24 48	 mov	 QWORD PTR _target$[rsp], rax

; 3296 :     if (!_target)

  000be	48 83 7c 24 48
	00		 cmp	 QWORD PTR _target$[rsp], 0
  000c4	75 07		 jne	 SHORT $LN5@ast_for_fo

; 3297 :         return NULL;

  000c6	33 c0		 xor	 eax, eax
  000c8	e9 08 01 00 00	 jmp	 $LN8@ast_for_fo
$LN5@ast_for_fo:

; 3298 :     /* Check the # of children rather than the length of _target, since
; 3299 :        for x, in ... has 1 element in _target, but still requires a Tuple. */
; 3300 :     first = (expr_ty)asdl_seq_GET(_target, 0);

  000cd	48 8b 44 24 48	 mov	 rax, QWORD PTR _target$[rsp]
  000d2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000d6	48 89 44 24 40	 mov	 QWORD PTR first$[rsp], rax

; 3301 :     if (NCH(node_target) == 1)

  000db	48 8b 44 24 70	 mov	 rax, QWORD PTR node_target$[rsp]
  000e0	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  000e4	75 0c		 jne	 SHORT $LN4@ast_for_fo

; 3302 :         target = first;

  000e6	48 8b 44 24 40	 mov	 rax, QWORD PTR first$[rsp]
  000eb	48 89 44 24 68	 mov	 QWORD PTR target$[rsp], rax

; 3303 :     else

  000f0	eb 37		 jmp	 SHORT $LN3@ast_for_fo
$LN4@ast_for_fo:

; 3304 :         target = Tuple(_target, Store, first->lineno, first->col_offset, c->c_arena);

  000f2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000fa	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR first$[rsp]
  00108	44 8b 48 34	 mov	 r9d, DWORD PTR [rax+52]
  0010c	48 8b 44 24 40	 mov	 rax, QWORD PTR first$[rsp]
  00111	44 8b 40 30	 mov	 r8d, DWORD PTR [rax+48]
  00115	ba 02 00 00 00	 mov	 edx, 2
  0011a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _target$[rsp]
  0011f	e8 00 00 00 00	 call	 _Py_Tuple
  00124	48 89 44 24 68	 mov	 QWORD PTR target$[rsp], rax
$LN3@ast_for_fo:

; 3305 : 
; 3306 :     expression = ast_for_testlist(c, CHILD(n, 3));

  00129	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00131	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00135	48 83 c0 78	 add	 rax, 120		; 00000078H
  00139	48 8b d0	 mov	 rdx, rax
  0013c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00144	e8 00 00 00 00	 call	 ast_for_testlist
  00149	48 89 44 24 50	 mov	 QWORD PTR expression$[rsp], rax

; 3307 :     if (!expression)

  0014e	48 83 7c 24 50
	00		 cmp	 QWORD PTR expression$[rsp], 0
  00154	75 04		 jne	 SHORT $LN2@ast_for_fo

; 3308 :         return NULL;

  00156	33 c0		 xor	 eax, eax
  00158	eb 7b		 jmp	 SHORT $LN8@ast_for_fo
$LN2@ast_for_fo:

; 3309 :     suite_seq = ast_for_suite(c, CHILD(n, 5));

  0015a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00162	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00166	48 05 c8 00 00
	00		 add	 rax, 200		; 000000c8H
  0016c	48 8b d0	 mov	 rdx, rax
  0016f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00177	e8 00 00 00 00	 call	 ast_for_suite
  0017c	48 89 44 24 58	 mov	 QWORD PTR suite_seq$[rsp], rax

; 3310 :     if (!suite_seq)

  00181	48 83 7c 24 58
	00		 cmp	 QWORD PTR suite_seq$[rsp], 0
  00187	75 04		 jne	 SHORT $LN1@ast_for_fo

; 3311 :         return NULL;

  00189	33 c0		 xor	 eax, eax
  0018b	eb 48		 jmp	 SHORT $LN8@ast_for_fo
$LN1@ast_for_fo:

; 3312 : 
; 3313 :     return For(target, expression, suite_seq, seq, LINENO(n), n->n_col_offset,
; 3314 :                c->c_arena);

  0018d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00195	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00199	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0019e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001a6	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001a9	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001ad	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001b5	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001b8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001bc	4c 8b 4c 24 60	 mov	 r9, QWORD PTR seq$[rsp]
  001c1	4c 8b 44 24 58	 mov	 r8, QWORD PTR suite_seq$[rsp]
  001c6	48 8b 54 24 50	 mov	 rdx, QWORD PTR expression$[rsp]
  001cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR target$[rsp]
  001d0	e8 00 00 00 00	 call	 _Py_For
$LN8@ast_for_fo:

; 3315 : }

  001d5	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001dc	c3		 ret	 0
ast_for_for_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FE@HHLCDOGG@?$AAf?$AAi?$AAn?$AAa?$AAl?$AAl?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAs?$AAd?$AAl?$AA_?$AAs?$AAe?$AAq?$AA_?$AAL?$AAE?$AAN?$AA?$CI@ ; `string'
PUBLIC	??_C@_1FC@EPGKLLPF@?$AA?$CI?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0BK@MKJMBJFL@malformed?5?8try?8?5statement?$AA@ ; `string'
PUBLIC	??_C@_07MKBLAIAL@finally?$AA@			; `string'
PUBLIC	??_C@_1CC@CCGBILIC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA7?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_Try:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_try_stmt DD imagerel ast_for_try_stmt
	DD	imagerel ast_for_try_stmt+1026
	DD	imagerel $unwind$ast_for_try_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_try_stmt DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_1FE@HHLCDOGG@?$AAf?$AAi?$AAn?$AAa?$AAl?$AAl?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAs?$AAd?$AAl?$AA_?$AAs?$AAe?$AAq?$AA_?$AAL?$AAE?$AAN?$AA?$CI@
CONST	SEGMENT
??_C@_1FE@HHLCDOGG@?$AAf?$AAi?$AAn?$AAa?$AAl?$AAl?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAs?$AAd?$AAl?$AA_?$AAs?$AAe?$AAq?$AA_?$AAL?$AAE?$AAN?$AA?$CI@ DB 'f'
	DB	00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'y', 00H
	DB	' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L'
	DB	00H, 'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'a', 00H
	DB	's', 00H, 'd', 00H, 'l', 00H, '_', 00H, 's', 00H, 'e', 00H, 'q'
	DB	00H, '_', 00H, 'L', 00H, 'E', 00H, 'N', 00H, '(', 00H, 'h', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'e', 00H, 'r', 00H, 's'
	DB	00H, ')', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FC@EPGKLLPF@?$AA?$CI?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr@
CONST	SEGMENT
??_C@_1FC@EPGKLLPF@?$AA?$CI?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr@ DB '('
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, ')', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, '_', 00H, 'a', 00H, 's', 00H, 'd', 00H, 'l', 00H, '_', 00H
	DB	'i', 00H, ' ', 00H, '<', 00H, ' ', 00H, '(', 00H, 'h', 00H, 'a'
	DB	00H, 'n', 00H, 'd', 00H, 'l', 00H, 'e', 00H, 'r', 00H, 's', 00H
	DB	')', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MKJMBJFL@malformed?5?8try?8?5statement?$AA@
CONST	SEGMENT
??_C@_0BK@MKJMBJFL@malformed?5?8try?8?5statement?$AA@ DB 'malformed ''try'
	DB	''' statement', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07MKBLAIAL@finally?$AA@
CONST	SEGMENT
??_C@_07MKBLAIAL@finally?$AA@ DB 'finally', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@CCGBILIC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA7?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@CCGBILIC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA7?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '9'
	DB	00H, '7', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_try_stmt
_TEXT	SEGMENT
body$ = 64
handlers$ = 72
n_except$ = 80
finally$ = 88
orelse$ = 96
nch$ = 104
i$24324 = 108
e$24331 = 112
_asdl_i$24334 = 120
tv215 = 128
c$ = 160
n$ = 168
ast_for_try_stmt PROC					; COMDAT

; 3373 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 3374 :     const int nch = NCH(n);

  00011	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00019	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0001c	89 44 24 68	 mov	 DWORD PTR nch$[rsp], eax

; 3375 :     int n_except = (nch - 3)/3;

  00020	8b 44 24 68	 mov	 eax, DWORD PTR nch$[rsp]
  00024	83 e8 03	 sub	 eax, 3
  00027	99		 cdq
  00028	b9 03 00 00 00	 mov	 ecx, 3
  0002d	f7 f9		 idiv	 ecx
  0002f	89 44 24 50	 mov	 DWORD PTR n_except$[rsp], eax

; 3376 :     asdl_seq *body, *handlers = NULL, *orelse = NULL, *finally = NULL;

  00033	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR handlers$[rsp], 0
  0003c	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR orelse$[rsp], 0
  00045	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR finally$[rsp], 0

; 3377 : 
; 3378 :     REQ(n, try_stmt);

  0004e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00056	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00059	3d 29 01 00 00	 cmp	 eax, 297		; 00000129H
  0005e	74 1c		 je	 SHORT $LN19@ast_for_tr@2
  00060	41 b8 32 0d 00
	00		 mov	 r8d, 3378		; 00000d32H
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@CCGBILIC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA7?$AA?$CJ?$AA?$AA@
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007a	33 c0		 xor	 eax, eax
$LN19@ast_for_tr@2:

; 3379 : 
; 3380 :     body = ast_for_suite(c, CHILD(n, 2));

  0007c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00084	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00088	48 83 c0 50	 add	 rax, 80			; 00000050H
  0008c	48 8b d0	 mov	 rdx, rax
  0008f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00097	e8 00 00 00 00	 call	 ast_for_suite
  0009c	48 89 44 24 40	 mov	 QWORD PTR body$[rsp], rax

; 3381 :     if (body == NULL)

  000a1	48 83 7c 24 40
	00		 cmp	 QWORD PTR body$[rsp], 0
  000a7	75 07		 jne	 SHORT $LN16@ast_for_tr@2

; 3382 :         return NULL;

  000a9	33 c0		 xor	 eax, eax
  000ab	e9 4a 03 00 00	 jmp	 $LN17@ast_for_tr@2
$LN16@ast_for_tr@2:

; 3383 : 
; 3384 :     if (TYPE(CHILD(n, nch - 3)) == NAME) {

  000b0	8b 44 24 68	 mov	 eax, DWORD PTR nch$[rsp]
  000b4	83 e8 03	 sub	 eax, 3
  000b7	48 98		 cdqe
  000b9	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000bd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  000c5	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000c9	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000cd	83 f8 01	 cmp	 eax, 1
  000d0	0f 85 32 01 00
	00		 jne	 $LN15@ast_for_tr@2

; 3385 :         if (strcmp(STR(CHILD(n, nch - 3)), "finally") == 0) {

  000d6	8b 44 24 68	 mov	 eax, DWORD PTR nch$[rsp]
  000da	83 e8 03	 sub	 eax, 3
  000dd	48 98		 cdqe
  000df	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000e3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  000eb	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  000ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07MKBLAIAL@finally?$AA@
  000f6	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  000fb	e8 00 00 00 00	 call	 strcmp
  00100	85 c0		 test	 eax, eax
  00102	0f 85 b8 00 00
	00		 jne	 $LN14@ast_for_tr@2

; 3386 :             if (nch >= 9 && TYPE(CHILD(n, nch - 6)) == NAME) {

  00108	83 7c 24 68 09	 cmp	 DWORD PTR nch$[rsp], 9
  0010d	7c 69		 jl	 SHORT $LN13@ast_for_tr@2
  0010f	8b 44 24 68	 mov	 eax, DWORD PTR nch$[rsp]
  00113	83 e8 06	 sub	 eax, 6
  00116	48 98		 cdqe
  00118	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0011c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00124	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00128	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0012c	83 f8 01	 cmp	 eax, 1
  0012f	75 47		 jne	 SHORT $LN13@ast_for_tr@2

; 3387 :                 /* we can assume it's an "else",
; 3388 :                    because nch >= 9 for try-else-finally and
; 3389 :                    it would otherwise have a type of except_clause */
; 3390 :                 orelse = ast_for_suite(c, CHILD(n, nch - 4));

  00131	8b 44 24 68	 mov	 eax, DWORD PTR nch$[rsp]
  00135	83 e8 04	 sub	 eax, 4
  00138	48 98		 cdqe
  0013a	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0013e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00146	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0014a	48 8b d0	 mov	 rdx, rax
  0014d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00155	e8 00 00 00 00	 call	 ast_for_suite
  0015a	48 89 44 24 60	 mov	 QWORD PTR orelse$[rsp], rax

; 3391 :                 if (orelse == NULL)

  0015f	48 83 7c 24 60
	00		 cmp	 QWORD PTR orelse$[rsp], 0
  00165	75 07		 jne	 SHORT $LN12@ast_for_tr@2

; 3392 :                     return NULL;

  00167	33 c0		 xor	 eax, eax
  00169	e9 8c 02 00 00	 jmp	 $LN17@ast_for_tr@2
$LN12@ast_for_tr@2:

; 3393 :                 n_except--;

  0016e	8b 44 24 50	 mov	 eax, DWORD PTR n_except$[rsp]
  00172	ff c8		 dec	 eax
  00174	89 44 24 50	 mov	 DWORD PTR n_except$[rsp], eax
$LN13@ast_for_tr@2:

; 3394 :             }
; 3395 : 
; 3396 :             finally = ast_for_suite(c, CHILD(n, nch - 1));

  00178	8b 44 24 68	 mov	 eax, DWORD PTR nch$[rsp]
  0017c	ff c8		 dec	 eax
  0017e	48 98		 cdqe
  00180	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00184	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0018c	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00190	48 8b d0	 mov	 rdx, rax
  00193	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0019b	e8 00 00 00 00	 call	 ast_for_suite
  001a0	48 89 44 24 58	 mov	 QWORD PTR finally$[rsp], rax

; 3397 :             if (finally == NULL)

  001a5	48 83 7c 24 58
	00		 cmp	 QWORD PTR finally$[rsp], 0
  001ab	75 07		 jne	 SHORT $LN11@ast_for_tr@2

; 3398 :                 return NULL;

  001ad	33 c0		 xor	 eax, eax
  001af	e9 46 02 00 00	 jmp	 $LN17@ast_for_tr@2
$LN11@ast_for_tr@2:

; 3399 :             n_except--;

  001b4	8b 44 24 50	 mov	 eax, DWORD PTR n_except$[rsp]
  001b8	ff c8		 dec	 eax
  001ba	89 44 24 50	 mov	 DWORD PTR n_except$[rsp], eax

; 3400 :         }
; 3401 :         else {

  001be	eb 46		 jmp	 SHORT $LN10@ast_for_tr@2
$LN14@ast_for_tr@2:

; 3402 :             /* we can assume it's an "else",
; 3403 :                otherwise it would have a type of except_clause */
; 3404 :             orelse = ast_for_suite(c, CHILD(n, nch - 1));

  001c0	8b 44 24 68	 mov	 eax, DWORD PTR nch$[rsp]
  001c4	ff c8		 dec	 eax
  001c6	48 98		 cdqe
  001c8	48 6b c0 28	 imul	 rax, 40			; 00000028H
  001cc	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  001d4	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  001d8	48 8b d0	 mov	 rdx, rax
  001db	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001e3	e8 00 00 00 00	 call	 ast_for_suite
  001e8	48 89 44 24 60	 mov	 QWORD PTR orelse$[rsp], rax

; 3405 :             if (orelse == NULL)

  001ed	48 83 7c 24 60
	00		 cmp	 QWORD PTR orelse$[rsp], 0
  001f3	75 07		 jne	 SHORT $LN9@ast_for_tr@2

; 3406 :                 return NULL;

  001f5	33 c0		 xor	 eax, eax
  001f7	e9 fe 01 00 00	 jmp	 $LN17@ast_for_tr@2
$LN9@ast_for_tr@2:

; 3407 :             n_except--;

  001fc	8b 44 24 50	 mov	 eax, DWORD PTR n_except$[rsp]
  00200	ff c8		 dec	 eax
  00202	89 44 24 50	 mov	 DWORD PTR n_except$[rsp], eax
$LN10@ast_for_tr@2:

; 3408 :         }

  00206	eb 47		 jmp	 SHORT $LN8@ast_for_tr@2
$LN15@ast_for_tr@2:

; 3409 :     }
; 3410 :     else if (TYPE(CHILD(n, nch - 3)) != except_clause) {

  00208	8b 44 24 68	 mov	 eax, DWORD PTR nch$[rsp]
  0020c	83 e8 03	 sub	 eax, 3
  0020f	48 98		 cdqe
  00211	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00215	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0021d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00221	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00225	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  0022a	74 23		 je	 SHORT $LN7@ast_for_tr@2

; 3411 :         ast_error(c, n, "malformed 'try' statement");

  0022c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BK@MKJMBJFL@malformed?5?8try?8?5statement?$AA@
  00233	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  0023b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00243	e8 00 00 00 00	 call	 ast_error

; 3412 :         return NULL;

  00248	33 c0		 xor	 eax, eax
  0024a	e9 ab 01 00 00	 jmp	 $LN17@ast_for_tr@2
$LN7@ast_for_tr@2:
$LN8@ast_for_tr@2:

; 3413 :     }
; 3414 : 
; 3415 :     if (n_except > 0) {

  0024f	83 7c 24 50 00	 cmp	 DWORD PTR n_except$[rsp], 0
  00254	0f 8e 03 01 00
	00		 jle	 $LN6@ast_for_tr@2

; 3416 :         int i;
; 3417 :         /* process except statements to create a try ... except */
; 3418 :         handlers = asdl_seq_new(n_except, c->c_arena);

  0025a	48 63 44 24 50	 movsxd	 rax, DWORD PTR n_except$[rsp]
  0025f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00267	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0026b	48 8b c8	 mov	 rcx, rax
  0026e	e8 00 00 00 00	 call	 asdl_seq_new
  00273	48 89 44 24 48	 mov	 QWORD PTR handlers$[rsp], rax

; 3419 :         if (handlers == NULL)

  00278	48 83 7c 24 48
	00		 cmp	 QWORD PTR handlers$[rsp], 0
  0027e	75 07		 jne	 SHORT $LN5@ast_for_tr@2

; 3420 :             return NULL;

  00280	33 c0		 xor	 eax, eax
  00282	e9 73 01 00 00	 jmp	 $LN17@ast_for_tr@2
$LN5@ast_for_tr@2:

; 3421 : 
; 3422 :         for (i = 0; i < n_except; i++) {

  00287	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR i$24324[rsp], 0
  0028f	eb 0a		 jmp	 SHORT $LN4@ast_for_tr@2
$LN3@ast_for_tr@2:
  00291	8b 44 24 6c	 mov	 eax, DWORD PTR i$24324[rsp]
  00295	ff c0		 inc	 eax
  00297	89 44 24 6c	 mov	 DWORD PTR i$24324[rsp], eax
$LN4@ast_for_tr@2:
  0029b	8b 44 24 50	 mov	 eax, DWORD PTR n_except$[rsp]
  0029f	39 44 24 6c	 cmp	 DWORD PTR i$24324[rsp], eax
  002a3	0f 8d b4 00 00
	00		 jge	 $LN2@ast_for_tr@2

; 3423 :             excepthandler_ty e = ast_for_except_clause(c, CHILD(n, 3 + i * 3),
; 3424 :                                                        CHILD(n, 5 + i * 3));

  002a9	8b 44 24 6c	 mov	 eax, DWORD PTR i$24324[rsp]
  002ad	6b c0 03	 imul	 eax, 3
  002b0	83 c0 05	 add	 eax, 5
  002b3	48 98		 cdqe
  002b5	48 6b c0 28	 imul	 rax, 40			; 00000028H
  002b9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  002c1	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  002c5	8b 4c 24 6c	 mov	 ecx, DWORD PTR i$24324[rsp]
  002c9	6b c9 03	 imul	 ecx, 3
  002cc	83 c1 03	 add	 ecx, 3
  002cf	48 63 c9	 movsxd	 rcx, ecx
  002d2	48 6b c9 28	 imul	 rcx, 40			; 00000028H
  002d6	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  002de	48 03 4a 20	 add	 rcx, QWORD PTR [rdx+32]
  002e2	4c 8b c0	 mov	 r8, rax
  002e5	48 8b d1	 mov	 rdx, rcx
  002e8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002f0	e8 00 00 00 00	 call	 ast_for_except_clause
  002f5	48 89 44 24 70	 mov	 QWORD PTR e$24331[rsp], rax

; 3425 :             if (!e)

  002fa	48 83 7c 24 70
	00		 cmp	 QWORD PTR e$24331[rsp], 0
  00300	75 07		 jne	 SHORT $LN1@ast_for_tr@2

; 3426 :                 return NULL;

  00302	33 c0		 xor	 eax, eax
  00304	e9 f1 00 00 00	 jmp	 $LN17@ast_for_tr@2
$LN1@ast_for_tr@2:

; 3427 :             asdl_seq_SET(handlers, i, e);

  00309	8b 44 24 6c	 mov	 eax, DWORD PTR i$24324[rsp]
  0030d	89 44 24 78	 mov	 DWORD PTR _asdl_i$24334[rsp], eax
  00311	48 83 7c 24 48
	00		 cmp	 QWORD PTR handlers$[rsp], 0
  00317	74 0f		 je	 SHORT $LN20@ast_for_tr@2
  00319	48 63 44 24 78	 movsxd	 rax, DWORD PTR _asdl_i$24334[rsp]
  0031e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR handlers$[rsp]
  00323	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  00326	7c 1c		 jl	 SHORT $LN21@ast_for_tr@2
$LN20@ast_for_tr@2:
  00328	41 b8 63 0d 00
	00		 mov	 r8d, 3427		; 00000d63H
  0032e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00335	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FC@EPGKLLPF@?$AA?$CI?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr@
  0033c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00342	33 c0		 xor	 eax, eax
$LN21@ast_for_tr@2:
  00344	48 63 44 24 78	 movsxd	 rax, DWORD PTR _asdl_i$24334[rsp]
  00349	48 8b 4c 24 48	 mov	 rcx, QWORD PTR handlers$[rsp]
  0034e	48 8b 54 24 70	 mov	 rdx, QWORD PTR e$24331[rsp]
  00353	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 3428 :         }

  00358	e9 34 ff ff ff	 jmp	 $LN3@ast_for_tr@2
$LN2@ast_for_tr@2:
$LN6@ast_for_tr@2:

; 3429 :     }
; 3430 : 
; 3431 :     assert(finally != NULL || asdl_seq_LEN(handlers));

  0035d	48 83 7c 24 58
	00		 cmp	 QWORD PTR finally$[rsp], 0
  00363	75 4d		 jne	 SHORT $LN24@ast_for_tr@2
  00365	48 83 7c 24 48
	00		 cmp	 QWORD PTR handlers$[rsp], 0
  0036b	75 0e		 jne	 SHORT $LN22@ast_for_tr@2
  0036d	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv215[rsp], 0
  00379	eb 10		 jmp	 SHORT $LN23@ast_for_tr@2
$LN22@ast_for_tr@2:
  0037b	48 8b 44 24 48	 mov	 rax, QWORD PTR handlers$[rsp]
  00380	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00383	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
$LN23@ast_for_tr@2:
  0038b	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tv215[rsp], 0
  00394	75 1c		 jne	 SHORT $LN24@ast_for_tr@2
  00396	41 b8 67 0d 00
	00		 mov	 r8d, 3431		; 00000d67H
  0039c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  003a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@HHLCDOGG@?$AAf?$AAi?$AAn?$AAa?$AAl?$AAl?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAs?$AAd?$AAl?$AA_?$AAs?$AAe?$AAq?$AA_?$AAL?$AAE?$AAN?$AA?$CI@
  003aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003b0	33 c0		 xor	 eax, eax
$LN24@ast_for_tr@2:

; 3432 :     return Try(body, handlers, orelse, finally, LINENO(n), n->n_col_offset, c->c_arena);

  003b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  003ba	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003be	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  003c3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003cb	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  003ce	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003d2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003da	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  003dd	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003e1	4c 8b 4c 24 58	 mov	 r9, QWORD PTR finally$[rsp]
  003e6	4c 8b 44 24 60	 mov	 r8, QWORD PTR orelse$[rsp]
  003eb	48 8b 54 24 48	 mov	 rdx, QWORD PTR handlers$[rsp]
  003f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR body$[rsp]
  003f5	e8 00 00 00 00	 call	 _Py_Try
$LN17@ast_for_tr@2:

; 3433 : }

  003fa	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00401	c3		 ret	 0
ast_for_try_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@ODIINJEH@wrong?5number?5of?5children?5for?5?8ex@ ; `string'
PUBLIC	??_C@_1CI@INGPDMEF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAb?$AAo?$AAd?$AAy?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA1?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@LKBJIHMO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAe?$AAx?$AAc?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA0?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_ExceptHandler:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_except_clause DD imagerel ast_for_except_clause
	DD	imagerel ast_for_except_clause+653
	DD	imagerel $unwind$ast_for_except_clause
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_except_clause DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0DB@ODIINJEH@wrong?5number?5of?5children?5for?5?8ex@
CONST	SEGMENT
??_C@_0DB@ODIINJEH@wrong?5number?5of?5children?5for?5?8ex@ DB 'wrong numb'
	DB	'er of children for ''except'' clause: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@INGPDMEF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAb?$AAo?$AAd?$AAy?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA1?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@INGPDMEF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAb?$AAo?$AAd?$AAy?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA1?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'b', 00H, 'o', 00H
	DB	'd', 00H, 'y', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '(', 00H, '3', 00H, '0', 00H, '1', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@LKBJIHMO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAe?$AAx?$AAc?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA0?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@LKBJIHMO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAe?$AAx?$AAc?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA0?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'e', 00H, 'x', 00H
	DB	'c', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '('
	DB	00H, '3', 00H, '0', 00H, '0', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_except_clause
_TEXT	SEGMENT
suite_seq$24256 = 48
expression$24263 = 56
suite_seq$24264 = 64
expression$24273 = 72
suite_seq$24272 = 80
e$24274 = 88
c$ = 112
exc$ = 120
body$ = 128
ast_for_except_clause PROC				; COMDAT

; 3319 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3320 :     /* except_clause: 'except' [test ['as' test]] */
; 3321 :     REQ(exc, except_clause);

  00013	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  00018	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0001b	3d 2c 01 00 00	 cmp	 eax, 300		; 0000012cH
  00020	74 1c		 je	 SHORT $LN15@ast_for_ex@4
  00022	41 b8 f9 0c 00
	00		 mov	 r8d, 3321		; 00000cf9H
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@LKBJIHMO@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAe?$AAx?$AAc?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA0?$AA?$CJ?$AA?$AA@
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003c	33 c0		 xor	 eax, eax
$LN15@ast_for_ex@4:

; 3322 :     REQ(body, suite);

  0003e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR body$[rsp]
  00046	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00049	3d 2d 01 00 00	 cmp	 eax, 301		; 0000012dH
  0004e	74 1c		 je	 SHORT $LN16@ast_for_ex@4
  00050	41 b8 fa 0c 00
	00		 mov	 r8d, 3322		; 00000cfaH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@INGPDMEF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAb?$AAo?$AAd?$AAy?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA0?$AA1?$AA?$CJ?$AA?$AA@
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006a	33 c0		 xor	 eax, eax
$LN16@ast_for_ex@4:

; 3323 : 
; 3324 :     if (NCH(exc) == 1) {

  0006c	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  00071	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  00075	75 61		 jne	 SHORT $LN12@ast_for_ex@4

; 3325 :         asdl_seq *suite_seq = ast_for_suite(c, body);

  00077	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR body$[rsp]
  0007f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00084	e8 00 00 00 00	 call	 ast_for_suite
  00089	48 89 44 24 30	 mov	 QWORD PTR suite_seq$24256[rsp], rax

; 3326 :         if (!suite_seq)

  0008e	48 83 7c 24 30
	00		 cmp	 QWORD PTR suite_seq$24256[rsp], 0
  00094	75 07		 jne	 SHORT $LN11@ast_for_ex@4

; 3327 :             return NULL;

  00096	33 c0		 xor	 eax, eax
  00098	e9 eb 01 00 00	 jmp	 $LN13@ast_for_ex@4
$LN11@ast_for_ex@4:

; 3328 : 
; 3329 :         return ExceptHandler(NULL, NULL, suite_seq, LINENO(exc),
; 3330 :                              exc->n_col_offset, c->c_arena);

  0009d	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  000a2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ab	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  000b0	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000b3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b7	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  000bc	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  000c0	4c 8b 44 24 30	 mov	 r8, QWORD PTR suite_seq$24256[rsp]
  000c5	33 d2		 xor	 edx, edx
  000c7	33 c9		 xor	 ecx, ecx
  000c9	e8 00 00 00 00	 call	 _Py_ExceptHandler
  000ce	e9 b5 01 00 00	 jmp	 $LN13@ast_for_ex@4
  000d3	e9 92 01 00 00	 jmp	 $LN10@ast_for_ex@4
$LN12@ast_for_ex@4:

; 3331 :     }
; 3332 :     else if (NCH(exc) == 2) {

  000d8	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  000dd	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  000e1	0f 85 92 00 00
	00		 jne	 $LN9@ast_for_ex@4

; 3333 :         expr_ty expression;
; 3334 :         asdl_seq *suite_seq;
; 3335 : 
; 3336 :         expression = ast_for_expr(c, CHILD(exc, 1));

  000e7	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  000ec	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000f0	48 83 c0 28	 add	 rax, 40			; 00000028H
  000f4	48 8b d0	 mov	 rdx, rax
  000f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000fc	e8 00 00 00 00	 call	 ast_for_expr
  00101	48 89 44 24 38	 mov	 QWORD PTR expression$24263[rsp], rax

; 3337 :         if (!expression)

  00106	48 83 7c 24 38
	00		 cmp	 QWORD PTR expression$24263[rsp], 0
  0010c	75 07		 jne	 SHORT $LN8@ast_for_ex@4

; 3338 :             return NULL;

  0010e	33 c0		 xor	 eax, eax
  00110	e9 73 01 00 00	 jmp	 $LN13@ast_for_ex@4
$LN8@ast_for_ex@4:

; 3339 :         suite_seq = ast_for_suite(c, body);

  00115	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR body$[rsp]
  0011d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00122	e8 00 00 00 00	 call	 ast_for_suite
  00127	48 89 44 24 40	 mov	 QWORD PTR suite_seq$24264[rsp], rax

; 3340 :         if (!suite_seq)

  0012c	48 83 7c 24 40
	00		 cmp	 QWORD PTR suite_seq$24264[rsp], 0
  00132	75 07		 jne	 SHORT $LN7@ast_for_ex@4

; 3341 :             return NULL;

  00134	33 c0		 xor	 eax, eax
  00136	e9 4d 01 00 00	 jmp	 $LN13@ast_for_ex@4
$LN7@ast_for_ex@4:

; 3342 : 
; 3343 :         return ExceptHandler(expression, NULL, suite_seq, LINENO(exc),
; 3344 :                              exc->n_col_offset, c->c_arena);

  0013b	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00140	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00144	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00149	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  0014e	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00151	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00155	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  0015a	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  0015e	4c 8b 44 24 40	 mov	 r8, QWORD PTR suite_seq$24264[rsp]
  00163	33 d2		 xor	 edx, edx
  00165	48 8b 4c 24 38	 mov	 rcx, QWORD PTR expression$24263[rsp]
  0016a	e8 00 00 00 00	 call	 _Py_ExceptHandler
  0016f	e9 14 01 00 00	 jmp	 $LN13@ast_for_ex@4
  00174	e9 f1 00 00 00	 jmp	 $LN6@ast_for_ex@4
$LN9@ast_for_ex@4:

; 3345 :     }
; 3346 :     else if (NCH(exc) == 4) {

  00179	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  0017e	83 78 18 04	 cmp	 DWORD PTR [rax+24], 4
  00182	0f 85 e2 00 00
	00		 jne	 $LN5@ast_for_ex@4

; 3347 :         asdl_seq *suite_seq;
; 3348 :         expr_ty expression;
; 3349 :         identifier e = NEW_IDENTIFIER(CHILD(exc, 3));

  00188	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  0018d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00191	48 8b 54 24 70	 mov	 rdx, QWORD PTR c$[rsp]
  00196	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0019d	e8 00 00 00 00	 call	 new_identifier
  001a2	48 89 44 24 58	 mov	 QWORD PTR e$24274[rsp], rax

; 3350 :         if (!e)

  001a7	48 83 7c 24 58
	00		 cmp	 QWORD PTR e$24274[rsp], 0
  001ad	75 07		 jne	 SHORT $LN4@ast_for_ex@4

; 3351 :             return NULL;

  001af	33 c0		 xor	 eax, eax
  001b1	e9 d2 00 00 00	 jmp	 $LN13@ast_for_ex@4
$LN4@ast_for_ex@4:

; 3352 :         if (forbidden_name(c, e, CHILD(exc, 3), 0))

  001b6	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  001bb	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001bf	48 83 c0 78	 add	 rax, 120		; 00000078H
  001c3	45 33 c9	 xor	 r9d, r9d
  001c6	4c 8b c0	 mov	 r8, rax
  001c9	48 8b 54 24 58	 mov	 rdx, QWORD PTR e$24274[rsp]
  001ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  001d3	e8 00 00 00 00	 call	 forbidden_name
  001d8	85 c0		 test	 eax, eax
  001da	74 07		 je	 SHORT $LN3@ast_for_ex@4

; 3353 :             return NULL;

  001dc	33 c0		 xor	 eax, eax
  001de	e9 a5 00 00 00	 jmp	 $LN13@ast_for_ex@4
$LN3@ast_for_ex@4:

; 3354 :         expression = ast_for_expr(c, CHILD(exc, 1));

  001e3	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  001e8	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001ec	48 83 c0 28	 add	 rax, 40			; 00000028H
  001f0	48 8b d0	 mov	 rdx, rax
  001f3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  001f8	e8 00 00 00 00	 call	 ast_for_expr
  001fd	48 89 44 24 48	 mov	 QWORD PTR expression$24273[rsp], rax

; 3355 :         if (!expression)

  00202	48 83 7c 24 48
	00		 cmp	 QWORD PTR expression$24273[rsp], 0
  00208	75 04		 jne	 SHORT $LN2@ast_for_ex@4

; 3356 :             return NULL;

  0020a	33 c0		 xor	 eax, eax
  0020c	eb 7a		 jmp	 SHORT $LN13@ast_for_ex@4
$LN2@ast_for_ex@4:

; 3357 :         suite_seq = ast_for_suite(c, body);

  0020e	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR body$[rsp]
  00216	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  0021b	e8 00 00 00 00	 call	 ast_for_suite
  00220	48 89 44 24 50	 mov	 QWORD PTR suite_seq$24272[rsp], rax

; 3358 :         if (!suite_seq)

  00225	48 83 7c 24 50
	00		 cmp	 QWORD PTR suite_seq$24272[rsp], 0
  0022b	75 04		 jne	 SHORT $LN1@ast_for_ex@4

; 3359 :             return NULL;

  0022d	33 c0		 xor	 eax, eax
  0022f	eb 57		 jmp	 SHORT $LN13@ast_for_ex@4
$LN1@ast_for_ex@4:

; 3360 : 
; 3361 :         return ExceptHandler(expression, e, suite_seq, LINENO(exc),
; 3362 :                              exc->n_col_offset, c->c_arena);

  00231	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  00236	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0023a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0023f	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  00244	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00247	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0024b	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  00250	44 8b 48 10	 mov	 r9d, DWORD PTR [rax+16]
  00254	4c 8b 44 24 50	 mov	 r8, QWORD PTR suite_seq$24272[rsp]
  00259	48 8b 54 24 58	 mov	 rdx, QWORD PTR e$24274[rsp]
  0025e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR expression$24273[rsp]
  00263	e8 00 00 00 00	 call	 _Py_ExceptHandler
  00268	eb 1e		 jmp	 SHORT $LN13@ast_for_ex@4
$LN5@ast_for_ex@4:
$LN6@ast_for_ex@4:
$LN10@ast_for_ex@4:

; 3363 :     }
; 3364 : 
; 3365 :     PyErr_Format(PyExc_SystemError,
; 3366 :                  "wrong number of children for 'except' clause: %d",
; 3367 :                  NCH(exc));

  0026a	48 8b 44 24 78	 mov	 rax, QWORD PTR exc$[rsp]
  0026f	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  00273	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@ODIINJEH@wrong?5number?5of?5children?5for?5?8ex@
  0027a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00281	e8 00 00 00 00	 call	 PyErr_Format

; 3368 :     return NULL;

  00286	33 c0		 xor	 eax, eax
$LN13@ast_for_ex@4:

; 3369 : }

  00288	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0028c	c3		 ret	 0
ast_for_except_clause ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EG@MEBHMPHM@?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@ ; `string'
PUBLIC	??_C@_1CC@NDDHDJFH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA8?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_With:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_with_stmt DD imagerel ast_for_with_stmt
	DD	imagerel ast_for_with_stmt+410
	DD	imagerel $unwind$ast_for_with_stmt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_with_stmt DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_1EG@MEBHMPHM@?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@
CONST	SEGMENT
??_C@_1EG@MEBHMPHM@?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@ DB '('
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'm', 00H, 's', 00H, ')', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '_', 00H, 'a', 00H, 's'
	DB	00H, 'd', 00H, 'l', 00H, '_', 00H, 'i', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, '(', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'm', 00H, 's'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 's', 00H, 'i', 00H, 'z', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@NDDHDJFH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA8?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@NDDHDJFH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA8?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '9'
	DB	00H, '8', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_with_stmt
_TEXT	SEGMENT
n_items$ = 48
i$ = 52
body$ = 56
items$ = 64
item$24376 = 72
_asdl_i$24379 = 80
c$ = 112
n$ = 120
ast_for_with_stmt PROC					; COMDAT

; 3462 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3463 :     int i, n_items;
; 3464 :     asdl_seq *items, *body;
; 3465 : 
; 3466 :     REQ(n, with_stmt);

  0000e	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00013	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00016	3d 2a 01 00 00	 cmp	 eax, 298		; 0000012aH
  0001b	74 1c		 je	 SHORT $LN9@ast_for_wi
  0001d	41 b8 8a 0d 00
	00		 mov	 r8d, 3466		; 00000d8aH
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@NDDHDJFH@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA8?$AA?$CJ?$AA?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00037	33 c0		 xor	 eax, eax
$LN9@ast_for_wi:

; 3467 : 
; 3468 :     n_items = (NCH(n) - 2) / 2;

  00039	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0003e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00041	83 e8 02	 sub	 eax, 2
  00044	99		 cdq
  00045	2b c2		 sub	 eax, edx
  00047	d1 f8		 sar	 eax, 1
  00049	89 44 24 30	 mov	 DWORD PTR n_items$[rsp], eax

; 3469 :     items = asdl_seq_new(n_items, c->c_arena);

  0004d	48 63 44 24 30	 movsxd	 rax, DWORD PTR n_items$[rsp]
  00052	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00057	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	e8 00 00 00 00	 call	 asdl_seq_new
  00063	48 89 44 24 40	 mov	 QWORD PTR items$[rsp], rax

; 3470 :     if (!items)

  00068	48 83 7c 24 40
	00		 cmp	 QWORD PTR items$[rsp], 0
  0006e	75 07		 jne	 SHORT $LN6@ast_for_wi

; 3471 :         return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	e9 1e 01 00 00	 jmp	 $LN7@ast_for_wi
$LN6@ast_for_wi:

; 3472 :     for (i = 1; i < NCH(n) - 2; i += 2) {

  00077	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0007f	eb 0b		 jmp	 SHORT $LN5@ast_for_wi
$LN4@ast_for_wi:
  00081	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00085	83 c0 02	 add	 eax, 2
  00088	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN5@ast_for_wi:
  0008c	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00091	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00094	83 e8 02	 sub	 eax, 2
  00097	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  0009b	0f 8d 8e 00 00
	00		 jge	 $LN3@ast_for_wi

; 3473 :         withitem_ty item = ast_for_with_item(c, CHILD(n, i));

  000a1	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  000a6	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000aa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR n$[rsp]
  000af	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000b3	48 8b d0	 mov	 rdx, rax
  000b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  000bb	e8 00 00 00 00	 call	 ast_for_with_item
  000c0	48 89 44 24 48	 mov	 QWORD PTR item$24376[rsp], rax

; 3474 :         if (!item)

  000c5	48 83 7c 24 48
	00		 cmp	 QWORD PTR item$24376[rsp], 0
  000cb	75 07		 jne	 SHORT $LN2@ast_for_wi

; 3475 :             return NULL;

  000cd	33 c0		 xor	 eax, eax
  000cf	e9 c1 00 00 00	 jmp	 $LN7@ast_for_wi
$LN2@ast_for_wi:

; 3476 :         asdl_seq_SET(items, (i - 1) / 2, item);

  000d4	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  000d8	ff c8		 dec	 eax
  000da	99		 cdq
  000db	2b c2		 sub	 eax, edx
  000dd	d1 f8		 sar	 eax, 1
  000df	89 44 24 50	 mov	 DWORD PTR _asdl_i$24379[rsp], eax
  000e3	48 83 7c 24 40
	00		 cmp	 QWORD PTR items$[rsp], 0
  000e9	74 0f		 je	 SHORT $LN10@ast_for_wi
  000eb	48 63 44 24 50	 movsxd	 rax, DWORD PTR _asdl_i$24379[rsp]
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR items$[rsp]
  000f5	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  000f8	7c 1c		 jl	 SHORT $LN11@ast_for_wi
$LN10@ast_for_wi:
  000fa	41 b8 94 0d 00
	00		 mov	 r8d, 3476		; 00000d94H
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@MEBHMPHM@?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA_?$AAa?$AAs?$AAd?$AAl?$AA_?$AAi?$AA?5?$AA?$DM?$AA?5?$AA?$CI?$AAi?$AAt?$AAe?$AAm?$AAs?$AA?$CJ?$AA?9?$AA?$DO?$AAs?$AAi@
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00114	33 c0		 xor	 eax, eax
$LN11@ast_for_wi:
  00116	48 63 44 24 50	 movsxd	 rax, DWORD PTR _asdl_i$24379[rsp]
  0011b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR items$[rsp]
  00120	48 8b 54 24 48	 mov	 rdx, QWORD PTR item$24376[rsp]
  00125	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx

; 3477 :     }

  0012a	e9 52 ff ff ff	 jmp	 $LN4@ast_for_wi
$LN3@ast_for_wi:

; 3478 : 
; 3479 :     body = ast_for_suite(c, CHILD(n, NCH(n) - 1));

  0012f	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00134	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00137	ff c8		 dec	 eax
  00139	48 98		 cdqe
  0013b	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0013f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR n$[rsp]
  00144	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00148	48 8b d0	 mov	 rdx, rax
  0014b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR c$[rsp]
  00150	e8 00 00 00 00	 call	 ast_for_suite
  00155	48 89 44 24 38	 mov	 QWORD PTR body$[rsp], rax

; 3480 :     if (!body)

  0015a	48 83 7c 24 38
	00		 cmp	 QWORD PTR body$[rsp], 0
  00160	75 04		 jne	 SHORT $LN1@ast_for_wi

; 3481 :         return NULL;

  00162	33 c0		 xor	 eax, eax
  00164	eb 2f		 jmp	 SHORT $LN7@ast_for_wi
$LN1@ast_for_wi:

; 3482 : 
; 3483 :     return With(items, body, LINENO(n), n->n_col_offset, c->c_arena);

  00166	48 8b 44 24 70	 mov	 rax, QWORD PTR c$[rsp]
  0016b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0016f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00174	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00179	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  0017d	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00182	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00186	48 8b 54 24 38	 mov	 rdx, QWORD PTR body$[rsp]
  0018b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR items$[rsp]
  00190	e8 00 00 00 00	 call	 _Py_With
$LN7@ast_for_wi:

; 3484 : }

  00195	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00199	c3		 ret	 0
ast_for_with_stmt ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@BIGLOKPC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA9?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_withitem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_with_item DD imagerel ast_for_with_item
	DD	imagerel ast_for_with_item+219
	DD	imagerel $unwind$ast_for_with_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_with_item DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1CC@BIGLOKPC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA9?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@BIGLOKPC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA9?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '2', 00H, '9'
	DB	00H, '9', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_with_item
_TEXT	SEGMENT
optional_vars$ = 32
context_expr$ = 40
c$ = 64
n$ = 72
ast_for_with_item PROC					; COMDAT

; 3438 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3439 :     expr_ty context_expr, optional_vars = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR optional_vars$[rsp], 0

; 3440 : 
; 3441 :     REQ(n, with_item);

  00017	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0001c	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0001f	3d 2b 01 00 00	 cmp	 eax, 299		; 0000012bH
  00024	74 1c		 je	 SHORT $LN7@ast_for_wi@2
  00026	41 b8 71 0d 00
	00		 mov	 r8d, 3441		; 00000d71H
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@BIGLOKPC@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA2?$AA9?$AA9?$AA?$CJ?$AA?$AA@
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00040	33 c0		 xor	 eax, eax
$LN7@ast_for_wi@2:

; 3442 :     context_expr = ast_for_expr(c, CHILD(n, 0));

  00042	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00047	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00050	e8 00 00 00 00	 call	 ast_for_expr
  00055	48 89 44 24 28	 mov	 QWORD PTR context_expr$[rsp], rax

; 3443 :     if (!context_expr)

  0005a	48 83 7c 24 28
	00		 cmp	 QWORD PTR context_expr$[rsp], 0
  00060	75 04		 jne	 SHORT $LN4@ast_for_wi@2

; 3444 :         return NULL;

  00062	33 c0		 xor	 eax, eax
  00064	eb 70		 jmp	 SHORT $LN5@ast_for_wi@2
$LN4@ast_for_wi@2:

; 3445 :     if (NCH(n) == 3) {

  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  0006b	83 78 18 03	 cmp	 DWORD PTR [rax+24], 3
  0006f	75 4d		 jne	 SHORT $LN3@ast_for_wi@2

; 3446 :         optional_vars = ast_for_expr(c, CHILD(n, 2));

  00071	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00076	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0007a	48 83 c0 50	 add	 rax, 80			; 00000050H
  0007e	48 8b d0	 mov	 rdx, rax
  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  00086	e8 00 00 00 00	 call	 ast_for_expr
  0008b	48 89 44 24 20	 mov	 QWORD PTR optional_vars$[rsp], rax

; 3447 : 
; 3448 :         if (!optional_vars) {

  00090	48 83 7c 24 20
	00		 cmp	 QWORD PTR optional_vars$[rsp], 0
  00096	75 04		 jne	 SHORT $LN2@ast_for_wi@2

; 3449 :             return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	eb 3a		 jmp	 SHORT $LN5@ast_for_wi@2
$LN2@ast_for_wi@2:

; 3450 :         }
; 3451 :         if (!set_context(c, optional_vars, Store, n)) {

  0009c	4c 8b 4c 24 48	 mov	 r9, QWORD PTR n$[rsp]
  000a1	41 b8 02 00 00
	00		 mov	 r8d, 2
  000a7	48 8b 54 24 20	 mov	 rdx, QWORD PTR optional_vars$[rsp]
  000ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$[rsp]
  000b1	e8 00 00 00 00	 call	 set_context
  000b6	85 c0		 test	 eax, eax
  000b8	75 04		 jne	 SHORT $LN1@ast_for_wi@2

; 3452 :             return NULL;

  000ba	33 c0		 xor	 eax, eax
  000bc	eb 18		 jmp	 SHORT $LN5@ast_for_wi@2
$LN1@ast_for_wi@2:
$LN3@ast_for_wi@2:

; 3453 :         }
; 3454 :     }
; 3455 : 
; 3456 :     return withitem(context_expr, optional_vars, c->c_arena);

  000be	48 8b 44 24 40	 mov	 rax, QWORD PTR c$[rsp]
  000c3	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  000c7	48 8b 54 24 20	 mov	 rdx, QWORD PTR optional_vars$[rsp]
  000cc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR context_expr$[rsp]
  000d1	e8 00 00 00 00	 call	 _Py_withitem
$LN5@ast_for_wi@2:

; 3457 : }

  000d6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000da	c3		 ret	 0
ast_for_with_item ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CC@KKMDJNJK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA9?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	_Py_ClassDef:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ast_for_classdef DD imagerel ast_for_classdef
	DD	imagerel ast_for_classdef+1068
	DD	imagerel $unwind$ast_for_classdef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ast_for_classdef DD 021601H
	DD	0110116H
xdata	ENDS
;	COMDAT ??_C@_1CC@KKMDJNJK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA9?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@KKMDJNJK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA9?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, 'n', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '(', 00H, '3', 00H, '2'
	DB	00H, '9', 00H, ')', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ast_for_classdef
_TEXT	SEGMENT
s$ = 80
classname$ = 88
call$ = 96
dummy_name$24418 = 104
dummy$24419 = 112
c$ = 144
n$ = 152
decorator_seq$ = 160
ast_for_classdef PROC					; COMDAT

; 3488 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 3489 :     /* classdef: 'class' NAME ['(' arglist ')'] ':' suite */
; 3490 :     PyObject *classname;
; 3491 :     asdl_seq *s;
; 3492 :     expr_ty call;
; 3493 : 
; 3494 :     REQ(n, classdef);

  00016	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0001e	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00021	3d 49 01 00 00	 cmp	 eax, 329		; 00000149H
  00026	74 1c		 je	 SHORT $LN16@ast_for_cl
  00028	41 b8 a6 0d 00
	00		 mov	 r8d, 3494		; 00000da6H
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@KKMDJNJK@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA2?$AA9?$AA?$CJ?$AA?$AA@
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00042	33 c0		 xor	 eax, eax
$LN16@ast_for_cl:

; 3495 : 
; 3496 :     if (NCH(n) == 4) { /* class NAME ':' suite */

  00044	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0004c	83 78 18 04	 cmp	 DWORD PTR [rax+24], 4
  00050	0f 85 fe 00 00
	00		 jne	 $LN13@ast_for_cl

; 3497 :         s = ast_for_suite(c, CHILD(n, 3));

  00056	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0005e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00062	48 83 c0 78	 add	 rax, 120		; 00000078H
  00066	48 8b d0	 mov	 rdx, rax
  00069	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00071	e8 00 00 00 00	 call	 ast_for_suite
  00076	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 3498 :         if (!s)

  0007b	48 83 7c 24 50
	00		 cmp	 QWORD PTR s$[rsp], 0
  00081	75 07		 jne	 SHORT $LN12@ast_for_cl

; 3499 :             return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	e9 9a 03 00 00	 jmp	 $LN14@ast_for_cl
$LN12@ast_for_cl:

; 3500 :         classname = NEW_IDENTIFIER(CHILD(n, 1));

  0008a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00092	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00096	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  0009e	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  000a2	e8 00 00 00 00	 call	 new_identifier
  000a7	48 89 44 24 58	 mov	 QWORD PTR classname$[rsp], rax

; 3501 :         if (!classname)

  000ac	48 83 7c 24 58
	00		 cmp	 QWORD PTR classname$[rsp], 0
  000b2	75 07		 jne	 SHORT $LN11@ast_for_cl

; 3502 :             return NULL;

  000b4	33 c0		 xor	 eax, eax
  000b6	e9 69 03 00 00	 jmp	 $LN14@ast_for_cl
$LN11@ast_for_cl:

; 3503 :         if (forbidden_name(c, classname, CHILD(n, 3), 0))

  000bb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  000c3	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000c7	48 83 c0 78	 add	 rax, 120		; 00000078H
  000cb	45 33 c9	 xor	 r9d, r9d
  000ce	4c 8b c0	 mov	 r8, rax
  000d1	48 8b 54 24 58	 mov	 rdx, QWORD PTR classname$[rsp]
  000d6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  000de	e8 00 00 00 00	 call	 forbidden_name
  000e3	85 c0		 test	 eax, eax
  000e5	74 07		 je	 SHORT $LN10@ast_for_cl

; 3504 :             return NULL;

  000e7	33 c0		 xor	 eax, eax
  000e9	e9 36 03 00 00	 jmp	 $LN14@ast_for_cl
$LN10@ast_for_cl:

; 3505 :         return ClassDef(classname, NULL, NULL, NULL, NULL, s, decorator_seq,
; 3506 :                         LINENO(n), n->n_col_offset, c->c_arena);

  000ee	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  000f6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000fa	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  000ff	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00107	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0010a	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0010e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00116	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00119	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0011d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR decorator_seq$[rsp]
  00125	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0012a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0012f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00134	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0013d	45 33 c9	 xor	 r9d, r9d
  00140	45 33 c0	 xor	 r8d, r8d
  00143	33 d2		 xor	 edx, edx
  00145	48 8b 4c 24 58	 mov	 rcx, QWORD PTR classname$[rsp]
  0014a	e8 00 00 00 00	 call	 _Py_ClassDef
  0014f	e9 d0 02 00 00	 jmp	 $LN14@ast_for_cl
$LN13@ast_for_cl:

; 3507 :     }
; 3508 : 
; 3509 :     if (TYPE(CHILD(n, 3)) == RPAR) { /* class NAME '(' ')' ':' suite */

  00154	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0015c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00160	0f bf 40 78	 movsx	 eax, WORD PTR [rax+120]
  00164	83 f8 08	 cmp	 eax, 8
  00167	0f 85 00 01 00
	00		 jne	 $LN9@ast_for_cl

; 3510 :         s = ast_for_suite(c, CHILD(n,5));

  0016d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00175	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00179	48 05 c8 00 00
	00		 add	 rax, 200		; 000000c8H
  0017f	48 8b d0	 mov	 rdx, rax
  00182	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0018a	e8 00 00 00 00	 call	 ast_for_suite
  0018f	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 3511 :         if (!s)

  00194	48 83 7c 24 50
	00		 cmp	 QWORD PTR s$[rsp], 0
  0019a	75 07		 jne	 SHORT $LN8@ast_for_cl

; 3512 :             return NULL;

  0019c	33 c0		 xor	 eax, eax
  0019e	e9 81 02 00 00	 jmp	 $LN14@ast_for_cl
$LN8@ast_for_cl:

; 3513 :         classname = NEW_IDENTIFIER(CHILD(n, 1));

  001a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001ab	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001af	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  001b7	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  001bb	e8 00 00 00 00	 call	 new_identifier
  001c0	48 89 44 24 58	 mov	 QWORD PTR classname$[rsp], rax

; 3514 :         if (!classname)

  001c5	48 83 7c 24 58
	00		 cmp	 QWORD PTR classname$[rsp], 0
  001cb	75 07		 jne	 SHORT $LN7@ast_for_cl

; 3515 :             return NULL;

  001cd	33 c0		 xor	 eax, eax
  001cf	e9 50 02 00 00	 jmp	 $LN14@ast_for_cl
$LN7@ast_for_cl:

; 3516 :         if (forbidden_name(c, classname, CHILD(n, 3), 0))

  001d4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  001dc	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001e0	48 83 c0 78	 add	 rax, 120		; 00000078H
  001e4	45 33 c9	 xor	 r9d, r9d
  001e7	4c 8b c0	 mov	 r8, rax
  001ea	48 8b 54 24 58	 mov	 rdx, QWORD PTR classname$[rsp]
  001ef	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  001f7	e8 00 00 00 00	 call	 forbidden_name
  001fc	85 c0		 test	 eax, eax
  001fe	74 07		 je	 SHORT $LN6@ast_for_cl

; 3517 :             return NULL;

  00200	33 c0		 xor	 eax, eax
  00202	e9 1d 02 00 00	 jmp	 $LN14@ast_for_cl
$LN6@ast_for_cl:

; 3518 :         return ClassDef(classname, NULL, NULL, NULL, NULL, s, decorator_seq,
; 3519 :                         LINENO(n), n->n_col_offset, c->c_arena);

  00207	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0020f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00213	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00218	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00220	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00223	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00227	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0022f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00232	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00236	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR decorator_seq$[rsp]
  0023e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00243	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00248	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0024d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00256	45 33 c9	 xor	 r9d, r9d
  00259	45 33 c0	 xor	 r8d, r8d
  0025c	33 d2		 xor	 edx, edx
  0025e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR classname$[rsp]
  00263	e8 00 00 00 00	 call	 _Py_ClassDef
  00268	e9 b7 01 00 00	 jmp	 $LN14@ast_for_cl
$LN9@ast_for_cl:

; 3520 :     }
; 3521 : 
; 3522 :     /* class NAME '(' arglist ')' ':' suite */
; 3523 :     /* build up a fake Call node so we can extract its pieces */
; 3524 :     {
; 3525 :         PyObject *dummy_name;
; 3526 :         expr_ty dummy;
; 3527 :         dummy_name = NEW_IDENTIFIER(CHILD(n, 1));

  0026d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00275	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00279	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00281	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00285	e8 00 00 00 00	 call	 new_identifier
  0028a	48 89 44 24 68	 mov	 QWORD PTR dummy_name$24418[rsp], rax

; 3528 :         if (!dummy_name)

  0028f	48 83 7c 24 68
	00		 cmp	 QWORD PTR dummy_name$24418[rsp], 0
  00295	75 07		 jne	 SHORT $LN5@ast_for_cl

; 3529 :             return NULL;

  00297	33 c0		 xor	 eax, eax
  00299	e9 86 01 00 00	 jmp	 $LN14@ast_for_cl
$LN5@ast_for_cl:

; 3530 :         dummy = Name(dummy_name, Load, LINENO(n), n->n_col_offset, c->c_arena);

  0029e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  002a6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002af	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002b7	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  002bb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002c3	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  002c7	ba 01 00 00 00	 mov	 edx, 1
  002cc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dummy_name$24418[rsp]
  002d1	e8 00 00 00 00	 call	 _Py_Name
  002d6	48 89 44 24 70	 mov	 QWORD PTR dummy$24419[rsp], rax

; 3531 :         call = ast_for_call(c, CHILD(n, 3), dummy);

  002db	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  002e3	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002e7	48 83 c0 78	 add	 rax, 120		; 00000078H
  002eb	4c 8b 44 24 70	 mov	 r8, QWORD PTR dummy$24419[rsp]
  002f0	48 8b d0	 mov	 rdx, rax
  002f3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002fb	e8 00 00 00 00	 call	 ast_for_call
  00300	48 89 44 24 60	 mov	 QWORD PTR call$[rsp], rax

; 3532 :         if (!call)

  00305	48 83 7c 24 60
	00		 cmp	 QWORD PTR call$[rsp], 0
  0030b	75 07		 jne	 SHORT $LN4@ast_for_cl

; 3533 :             return NULL;

  0030d	33 c0		 xor	 eax, eax
  0030f	e9 10 01 00 00	 jmp	 $LN14@ast_for_cl
$LN4@ast_for_cl:

; 3534 :     }
; 3535 :     s = ast_for_suite(c, CHILD(n, 6));

  00314	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0031c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00320	48 05 f0 00 00
	00		 add	 rax, 240		; 000000f0H
  00326	48 8b d0	 mov	 rdx, rax
  00329	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00331	e8 00 00 00 00	 call	 ast_for_suite
  00336	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 3536 :     if (!s)

  0033b	48 83 7c 24 50
	00		 cmp	 QWORD PTR s$[rsp], 0
  00341	75 07		 jne	 SHORT $LN3@ast_for_cl

; 3537 :         return NULL;

  00343	33 c0		 xor	 eax, eax
  00345	e9 da 00 00 00	 jmp	 $LN14@ast_for_cl
$LN3@ast_for_cl:

; 3538 :     classname = NEW_IDENTIFIER(CHILD(n, 1));

  0034a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00352	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00356	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  0035e	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00362	e8 00 00 00 00	 call	 new_identifier
  00367	48 89 44 24 58	 mov	 QWORD PTR classname$[rsp], rax

; 3539 :     if (!classname)

  0036c	48 83 7c 24 58
	00		 cmp	 QWORD PTR classname$[rsp], 0
  00372	75 07		 jne	 SHORT $LN2@ast_for_cl

; 3540 :         return NULL;

  00374	33 c0		 xor	 eax, eax
  00376	e9 a9 00 00 00	 jmp	 $LN14@ast_for_cl
$LN2@ast_for_cl:

; 3541 :     if (forbidden_name(c, classname, CHILD(n, 1), 0))

  0037b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  00383	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00387	48 83 c0 28	 add	 rax, 40			; 00000028H
  0038b	45 33 c9	 xor	 r9d, r9d
  0038e	4c 8b c0	 mov	 r8, rax
  00391	48 8b 54 24 58	 mov	 rdx, QWORD PTR classname$[rsp]
  00396	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0039e	e8 00 00 00 00	 call	 forbidden_name
  003a3	85 c0		 test	 eax, eax
  003a5	74 04		 je	 SHORT $LN1@ast_for_cl

; 3542 :         return NULL;

  003a7	33 c0		 xor	 eax, eax
  003a9	eb 79		 jmp	 SHORT $LN14@ast_for_cl
$LN1@ast_for_cl:

; 3543 : 
; 3544 :     return ClassDef(classname, call->v.Call.args, call->v.Call.keywords,
; 3545 :                     call->v.Call.starargs, call->v.Call.kwargs, s,
; 3546 :                     decorator_seq, LINENO(n), n->n_col_offset, c->c_arena);

  003ab	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  003b3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003b7	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  003bc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003c4	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  003c7	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  003cb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  003d3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  003d6	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  003da	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR decorator_seq$[rsp]
  003e2	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  003e7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  003ec	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003f1	48 8b 44 24 60	 mov	 rax, QWORD PTR call$[rsp]
  003f6	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  003fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ff	48 8b 44 24 60	 mov	 rax, QWORD PTR call$[rsp]
  00404	4c 8b 48 20	 mov	 r9, QWORD PTR [rax+32]
  00408	48 8b 44 24 60	 mov	 rax, QWORD PTR call$[rsp]
  0040d	4c 8b 40 18	 mov	 r8, QWORD PTR [rax+24]
  00411	48 8b 44 24 60	 mov	 rax, QWORD PTR call$[rsp]
  00416	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0041a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR classname$[rsp]
  0041f	e8 00 00 00 00	 call	 _Py_ClassDef
$LN14@ast_for_cl:

; 3547 : }

  00424	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0042b	c3		 ret	 0
ast_for_classdef ENDP
_TEXT	ENDS
PUBLIC	$T26049
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_1BE@EEKACIGI@?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyComplex_FromCComplex:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyOS_string_to_double:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyOS_strtol:PROC
EXTRN	PyLong_FromString:PROC
EXTRN	PyOS_strtoul:PROC
EXTRN	__imp__errno:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$parsenumber DD imagerel parsenumber
	DD	imagerel parsenumber+506
	DD	imagerel $unwind$parsenumber
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parsenumber DD 031001H
	DD	0700ce210H
	DD	0600bH
xdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_1BE@EEKACIGI@?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@EEKACIGI@?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H
	DB	'L', 00H, 'L', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT parsenumber
_TEXT	SEGMENT
x$ = 32
imflag$ = 36
compl$ = 40
end$ = 56
dx$ = 64
$T26049 = 80
tv78 = 96
c$ = 144
s$ = 152
parsenumber PROC					; COMDAT

; 3623 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 3624 :     const char *end;
; 3625 :     long x;
; 3626 :     double dx;
; 3627 :     Py_complex compl;
; 3628 :     int imflag;
; 3629 : 
; 3630 :     assert(s != NULL);

  00010	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR s$[rsp], 0
  00019	75 1c		 jne	 SHORT $LN12@parsenumbe
  0001b	41 b8 2e 0e 00
	00		 mov	 r8d, 3630		; 00000e2eH
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@EEKACIGI@?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00035	33 c0		 xor	 eax, eax
$LN12@parsenumbe:

; 3631 :     errno = 0;

  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3632 :     end = s + strlen(s) - 1;

  00043	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0004b	e8 00 00 00 00	 call	 strlen
  00050	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00058	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0005d	48 89 44 24 38	 mov	 QWORD PTR end$[rsp], rax

; 3633 :     imflag = *end == 'j' || *end == 'J';

  00062	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  00067	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0006a	83 f8 6a	 cmp	 eax, 106		; 0000006aH
  0006d	74 17		 je	 SHORT $LN13@parsenumbe
  0006f	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  00074	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00077	83 f8 4a	 cmp	 eax, 74			; 0000004aH
  0007a	74 0a		 je	 SHORT $LN13@parsenumbe
  0007c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  00084	eb 08		 jmp	 SHORT $LN14@parsenumbe
$LN13@parsenumbe:
  00086	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
$LN14@parsenumbe:
  0008e	8b 44 24 60	 mov	 eax, DWORD PTR tv78[rsp]
  00092	89 44 24 24	 mov	 DWORD PTR imflag$[rsp], eax

; 3634 :     if (s[0] == '0') {

  00096	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0009e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a1	83 f8 30	 cmp	 eax, 48			; 00000030H
  000a4	75 44		 jne	 SHORT $LN9@parsenumbe

; 3635 :         x = (long) PyOS_strtoul((char *)s, (char **)&end, 0);

  000a6	45 33 c0	 xor	 r8d, r8d
  000a9	48 8d 54 24 38	 lea	 rdx, QWORD PTR end$[rsp]
  000ae	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000b6	e8 00 00 00 00	 call	 PyOS_strtoul
  000bb	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 3636 :         if (x < 0 && errno == 0) {

  000bf	83 7c 24 20 00	 cmp	 DWORD PTR x$[rsp], 0
  000c4	7d 22		 jge	 SHORT $LN8@parsenumbe
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000cc	83 38 00	 cmp	 DWORD PTR [rax], 0
  000cf	75 17		 jne	 SHORT $LN8@parsenumbe

; 3637 :             return PyLong_FromString((char *)s,
; 3638 :                                      (char **)0,
; 3639 :                                      0);

  000d1	45 33 c0	 xor	 r8d, r8d
  000d4	33 d2		 xor	 edx, edx
  000d6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000de	e8 00 00 00 00	 call	 PyLong_FromString
  000e3	e9 0b 01 00 00	 jmp	 $LN10@parsenumbe
$LN8@parsenumbe:

; 3640 :         }
; 3641 :     }
; 3642 :     else

  000e8	eb 19		 jmp	 SHORT $LN7@parsenumbe
$LN9@parsenumbe:

; 3643 :         x = PyOS_strtol((char *)s, (char **)&end, 0);

  000ea	45 33 c0	 xor	 r8d, r8d
  000ed	48 8d 54 24 38	 lea	 rdx, QWORD PTR end$[rsp]
  000f2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000fa	e8 00 00 00 00	 call	 PyOS_strtol
  000ff	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax
$LN7@parsenumbe:

; 3644 :     if (*end == '\0') {

  00103	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  00108	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0010b	85 c0		 test	 eax, eax
  0010d	75 30		 jne	 SHORT $LN6@parsenumbe

; 3645 :         if (errno != 0)

  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00115	83 38 00	 cmp	 DWORD PTR [rax], 0
  00118	74 17		 je	 SHORT $LN5@parsenumbe

; 3646 :             return PyLong_FromString((char *)s, (char **)0, 0);

  0011a	45 33 c0	 xor	 r8d, r8d
  0011d	33 d2		 xor	 edx, edx
  0011f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00127	e8 00 00 00 00	 call	 PyLong_FromString
  0012c	e9 c2 00 00 00	 jmp	 $LN10@parsenumbe
$LN5@parsenumbe:

; 3647 :         return PyLong_FromLong(x);

  00131	8b 4c 24 20	 mov	 ecx, DWORD PTR x$[rsp]
  00135	e8 00 00 00 00	 call	 PyLong_FromLong
  0013a	e9 b4 00 00 00	 jmp	 $LN10@parsenumbe
$LN6@parsenumbe:

; 3648 :     }
; 3649 :     /* XXX Huge floats may silently fail */
; 3650 :     if (imflag) {

  0013f	83 7c 24 24 00	 cmp	 DWORD PTR imflag$[rsp], 0
  00144	74 6a		 je	 SHORT $LN4@parsenumbe

; 3651 :         compl.real = 0.;

  00146	66 0f 57 c0	 xorpd	 xmm0, xmm0
  0014a	f2 0f 11 44 24
	28		 movsdx	 QWORD PTR compl$[rsp], xmm0

; 3652 :         compl.imag = PyOS_string_to_double(s, (char **)&end, NULL);

  00150	45 33 c0	 xor	 r8d, r8d
  00153	48 8d 54 24 38	 lea	 rdx, QWORD PTR end$[rsp]
  00158	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00160	e8 00 00 00 00	 call	 PyOS_string_to_double
  00165	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR compl$[rsp+8], xmm0

; 3653 :         if (compl.imag == -1.0 && PyErr_Occurred())

  0016b	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR compl$[rsp+8]
  00171	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00179	7a 10		 jp	 SHORT $LN3@parsenumbe
  0017b	75 0e		 jne	 SHORT $LN3@parsenumbe
  0017d	e8 00 00 00 00	 call	 PyErr_Occurred
  00182	48 85 c0	 test	 rax, rax
  00185	74 04		 je	 SHORT $LN3@parsenumbe

; 3654 :             return NULL;

  00187	33 c0		 xor	 eax, eax
  00189	eb 68		 jmp	 SHORT $LN10@parsenumbe
$LN3@parsenumbe:

; 3655 :         return PyComplex_FromCComplex(compl);

  0018b	48 8d 44 24 50	 lea	 rax, QWORD PTR $T26049[rsp]
  00190	48 8d 4c 24 28	 lea	 rcx, QWORD PTR compl$[rsp]
  00195	48 8b f8	 mov	 rdi, rax
  00198	48 8b f1	 mov	 rsi, rcx
  0019b	b9 10 00 00 00	 mov	 ecx, 16
  001a0	f3 a4		 rep movsb
  001a2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T26049[rsp]
  001a7	e8 00 00 00 00	 call	 PyComplex_FromCComplex
  001ac	eb 45		 jmp	 SHORT $LN10@parsenumbe

; 3656 :     }
; 3657 :     else

  001ae	eb 43		 jmp	 SHORT $LN2@parsenumbe
$LN4@parsenumbe:

; 3658 :     {
; 3659 :         dx = PyOS_string_to_double(s, NULL, NULL);

  001b0	45 33 c0	 xor	 r8d, r8d
  001b3	33 d2		 xor	 edx, edx
  001b5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001bd	e8 00 00 00 00	 call	 PyOS_string_to_double
  001c2	f2 0f 11 44 24
	40		 movsdx	 QWORD PTR dx$[rsp], xmm0

; 3660 :         if (dx == -1.0 && PyErr_Occurred())

  001c8	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR dx$[rsp]
  001ce	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  001d6	7a 10		 jp	 SHORT $LN1@parsenumbe
  001d8	75 0e		 jne	 SHORT $LN1@parsenumbe
  001da	e8 00 00 00 00	 call	 PyErr_Occurred
  001df	48 85 c0	 test	 rax, rax
  001e2	74 04		 je	 SHORT $LN1@parsenumbe

; 3661 :             return NULL;

  001e4	33 c0		 xor	 eax, eax
  001e6	eb 0b		 jmp	 SHORT $LN10@parsenumbe
$LN1@parsenumbe:

; 3662 :         return PyFloat_FromDouble(dx);

  001e8	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR dx$[rsp]
  001ee	e8 00 00 00 00	 call	 PyFloat_FromDouble
$LN2@parsenumbe:
$LN10@parsenumbe:

; 3663 :     }
; 3664 : }

  001f3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001f7	5f		 pop	 rdi
  001f8	5e		 pop	 rsi
  001f9	c3		 ret	 0
parsenumber ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@HOOKFABC@cannot?5mix?5bytes?5and?5nonbytes?5li@ ; `string'
PUBLIC	??_C@_1EA@EDKPPJFF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyUnicode_Concat:PROC
EXTRN	PyBytes_ConcatAndDel:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$parsestrplus DD imagerel parsestrplus
	DD	imagerel parsestrplus+433
	DD	imagerel $unwind$parsestrplus
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parsestrplus DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0CH@HOOKFABC@cannot?5mix?5bytes?5and?5nonbytes?5li@
CONST	SEGMENT
??_C@_0CH@HOOKFABC@cannot?5mix?5bytes?5and?5nonbytes?5li@ DB 'cannot mix '
	DB	'bytes and nonbytes literals', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@EDKPPJFF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@EDKPPJFF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA?$CJ?$AA?$AA@ DB 'T'
	DB	00H, 'Y', 00H, 'P', 00H, 'E', 00H, '(', 00H, '(', 00H, '&', 00H
	DB	'(', 00H, 'n', 00H, ')', 00H, '-', 00H, '>', 00H, 'n', 00H, '_'
	DB	00H, 'c', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'd', 00H, '[', 00H
	DB	'0', 00H, ']', 00H, ')', 00H, ')', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '(', 00H, '3', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT parsestrplus
_TEXT	SEGMENT
v$ = 32
i$ = 40
s$24710 = 48
subbm$24711 = 56
temp$24724 = 64
c$ = 96
n$ = 104
bytesmode$ = 112
parsestrplus PROC					; COMDAT

; 3837 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3838 :     PyObject *v;
; 3839 :     int i;
; 3840 :     REQ(CHILD(n, 0), STRING);

  00013	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00018	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001c	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0001f	83 f8 03	 cmp	 eax, 3
  00022	74 1c		 je	 SHORT $LN17@parsestrpl
  00024	41 b8 00 0f 00
	00		 mov	 r8d, 3840		; 00000f00H
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@EDKPPJFF@?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AA?$CI?$AA?$CG?$AA?$CI?$AAn?$AA?$CJ?$AA?9?$AA?$DO?$AAn?$AA_?$AAc?$AAh?$AAi?$AAl?$AAd?$AA?$FL?$AA0?$AA?$FN?$AA?$CJ?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AA3?$AA?$CJ?$AA?$AA@
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003e	33 c0		 xor	 eax, eax
$LN17@parsestrpl:

; 3841 :     v = parsestr(c, CHILD(n, 0), bytesmode);

  00040	4c 8b 44 24 70	 mov	 r8, QWORD PTR bytesmode$[rsp]
  00045	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  0004a	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  0004e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  00053	e8 00 00 00 00	 call	 parsestr
  00058	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 3842 :     if (v != NULL) {

  0005d	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00063	0f 84 22 01 00
	00		 je	 $LN14@parsestrpl

; 3843 :         /* String literal concatenation */
; 3844 :         for (i = 1; i < NCH(n); i++) {

  00069	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00071	eb 0a		 jmp	 SHORT $LN13@parsestrpl
$LN12@parsestrpl:
  00073	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00077	ff c0		 inc	 eax
  00079	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN13@parsestrpl:
  0007d	48 8b 44 24 68	 mov	 rax, QWORD PTR n$[rsp]
  00082	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00085	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00089	0f 8d fc 00 00
	00		 jge	 $LN11@parsestrpl

; 3845 :             PyObject *s;
; 3846 :             int subbm = 0;

  0008f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR subbm$24711[rsp], 0

; 3847 :             s = parsestr(c, CHILD(n, i), &subbm);

  00097	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0009c	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000a0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR n$[rsp]
  000a5	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000a9	4c 8d 44 24 38	 lea	 r8, QWORD PTR subbm$24711[rsp]
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000b6	e8 00 00 00 00	 call	 parsestr
  000bb	48 89 44 24 30	 mov	 QWORD PTR s$24710[rsp], rax

; 3848 :             if (s == NULL)

  000c0	48 83 7c 24 30
	00		 cmp	 QWORD PTR s$24710[rsp], 0
  000c6	75 05		 jne	 SHORT $LN10@parsestrpl

; 3849 :                 goto onError;

  000c8	e9 c5 00 00 00	 jmp	 $onError$24714
$LN10@parsestrpl:

; 3850 :             if (*bytesmode != subbm) {

  000cd	48 8b 44 24 70	 mov	 rax, QWORD PTR bytesmode$[rsp]
  000d2	8b 4c 24 38	 mov	 ecx, DWORD PTR subbm$24711[rsp]
  000d6	39 08		 cmp	 DWORD PTR [rax], ecx
  000d8	74 25		 je	 SHORT $LN9@parsestrpl

; 3851 :                 ast_error(c, n, "cannot mix bytes and nonbytes literals");

  000da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@HOOKFABC@cannot?5mix?5bytes?5and?5nonbytes?5li@
  000e1	48 8b 54 24 68	 mov	 rdx, QWORD PTR n$[rsp]
  000e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR c$[rsp]
  000eb	e8 00 00 00 00	 call	 ast_error

; 3852 :                 Py_DECREF(s);

  000f0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$24710[rsp]
  000f5	e8 00 00 00 00	 call	 _Py_DecRef

; 3853 :                 goto onError;

  000fa	e9 93 00 00 00	 jmp	 $onError$24714
$LN9@parsestrpl:

; 3854 :             }
; 3855 :             if (PyBytes_Check(v) && PyBytes_Check(s)) {

  000ff	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00104	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00108	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0010e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00113	85 c0		 test	 eax, eax
  00115	74 33		 je	 SHORT $LN8@parsestrpl
  00117	48 8b 44 24 30	 mov	 rax, QWORD PTR s$24710[rsp]
  0011c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00120	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00126	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0012b	85 c0		 test	 eax, eax
  0012d	74 1b		 je	 SHORT $LN8@parsestrpl

; 3856 :                 PyBytes_ConcatAndDel(&v, s);

  0012f	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$24710[rsp]
  00134	48 8d 4c 24 20	 lea	 rcx, QWORD PTR v$[rsp]
  00139	e8 00 00 00 00	 call	 PyBytes_ConcatAndDel

; 3857 :                 if (v == NULL)

  0013e	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00144	75 02		 jne	 SHORT $LN7@parsestrpl

; 3858 :                     goto onError;

  00146	eb 4a		 jmp	 SHORT $onError$24714
$LN7@parsestrpl:

; 3859 :             }
; 3860 :             else {

  00148	eb 3c		 jmp	 SHORT $LN6@parsestrpl
$LN8@parsestrpl:

; 3861 :                 PyObject *temp = PyUnicode_Concat(v, s);

  0014a	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$24710[rsp]
  0014f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00154	e8 00 00 00 00	 call	 PyUnicode_Concat
  00159	48 89 44 24 40	 mov	 QWORD PTR temp$24724[rsp], rax

; 3862 :                 Py_DECREF(s);

  0015e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$24710[rsp]
  00163	e8 00 00 00 00	 call	 _Py_DecRef

; 3863 :                 Py_DECREF(v);

  00168	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0016d	e8 00 00 00 00	 call	 _Py_DecRef

; 3864 :                 v = temp;

  00172	48 8b 44 24 40	 mov	 rax, QWORD PTR temp$24724[rsp]
  00177	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 3865 :                 if (v == NULL)

  0017c	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00182	75 02		 jne	 SHORT $LN5@parsestrpl

; 3866 :                     goto onError;

  00184	eb 0c		 jmp	 SHORT $onError$24714
$LN5@parsestrpl:
$LN6@parsestrpl:

; 3867 :             }
; 3868 :         }

  00186	e9 e8 fe ff ff	 jmp	 $LN12@parsestrpl
$LN11@parsestrpl:
$LN14@parsestrpl:

; 3869 :     }
; 3870 :     return v;

  0018b	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00190	eb 1a		 jmp	 SHORT $LN15@parsestrpl
$onError$24714:
$LN4@parsestrpl:

; 3871 : 
; 3872 :   onError:
; 3873 :     Py_XDECREF(v);

  00192	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00198	74 0a		 je	 SHORT $LN1@parsestrpl
  0019a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0019f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@parsestrpl:
  001a4	33 c0		 xor	 eax, eax
  001a6	85 c0		 test	 eax, eax
  001a8	75 e8		 jne	 SHORT $LN4@parsestrpl

; 3874 :     return NULL;

  001aa	33 c0		 xor	 eax, eax
$LN15@parsestrpl:

; 3875 : }

  001ac	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b0	c3		 ret	 0
parsestrplus ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@IOCBPCNE@bytes?5can?5only?5contain?5ASCII?5lit@ ; `string'
PUBLIC	??_C@_0BM@LLDDPBAC@string?5to?5parse?5is?5too?5long?$AA@ ; `string'
EXTRN	PyBytes_DecodeEscape:PROC
EXTRN	PyUnicode_DecodeLatin1:PROC
EXTRN	PyUnicode_FromStringAndSize:PROC
EXTRN	PyUnicode_AsEncodedString:PROC
EXTRN	__imp_strchr:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	_PyErr_BadInternalCall:PROC
EXTRN	_Py_ctype_table:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$parsestr DD imagerel parsestr
	DD	imagerel parsestr+1198
	DD	imagerel $unwind$parsestr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parsestr DD 021601H
	DD	0110116H
xdata	ENDS
;	COMDAT ??_C@_0DB@IOCBPCNE@bytes?5can?5only?5contain?5ASCII?5lit@
CONST	SEGMENT
??_C@_0DB@IOCBPCNE@bytes?5can?5only?5contain?5ASCII?5lit@ DB 'bytes can o'
	DB	'nly contain ASCII literal characters.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@LLDDPBAC@string?5to?5parse?5is?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BM@LLDDPBAC@string?5to?5parse?5is?5too?5long?$AA@ DB 'string to pa'
	DB	'rse is too long', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT parsestr
_TEXT	SEGMENT
need_encoding$ = 48
rawmode$ = 52
s$ = 56
quote$ = 64
len$ = 72
ch$24665 = 80
v$24678 = 88
u$24679 = 96
tv182 = 104
tv217 = 112
c$ = 144
n$ = 152
bytesmode$ = 160
parsestr PROC						; COMDAT

; 3748 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 3749 :     size_t len;
; 3750 :     const char *s = STR(n);

  00016	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR n$[rsp]
  0001e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00022	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 3751 :     int quote = Py_CHARMASK(*s);

  00027	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0002c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00034	0f b6 c0	 movzx	 eax, al
  00037	89 44 24 40	 mov	 DWORD PTR quote$[rsp], eax

; 3752 :     int rawmode = 0;

  0003b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR rawmode$[rsp], 0

; 3753 :     int need_encoding;
; 3754 :     if (Py_ISALPHA(quote)) {

  00043	8b 44 24 40	 mov	 eax, DWORD PTR quote$[rsp]
  00047	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004c	0f b6 c0	 movzx	 eax, al
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00056	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00059	83 e0 03	 and	 eax, 3
  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 b0 00 00
	00		 je	 $LN35@parsestr
$LN34@parsestr:

; 3755 :         while (!*bytesmode || !rawmode) {

  00064	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR bytesmode$[rsp]
  0006c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0006f	74 0b		 je	 SHORT $LN32@parsestr
  00071	83 7c 24 34 00	 cmp	 DWORD PTR rawmode$[rsp], 0
  00076	0f 85 98 00 00
	00		 jne	 $LN33@parsestr
$LN32@parsestr:

; 3756 :             if (quote == 'b' || quote == 'B') {

  0007c	83 7c 24 40 62	 cmp	 DWORD PTR quote$[rsp], 98 ; 00000062H
  00081	74 07		 je	 SHORT $LN30@parsestr
  00083	83 7c 24 40 42	 cmp	 DWORD PTR quote$[rsp], 66 ; 00000042H
  00088	75 29		 jne	 SHORT $LN31@parsestr
$LN30@parsestr:

; 3757 :                 quote = *++s;

  0008a	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0008f	48 ff c0	 inc	 rax
  00092	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax
  00097	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0009c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009f	89 44 24 40	 mov	 DWORD PTR quote$[rsp], eax

; 3758 :                 *bytesmode = 1;

  000a3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR bytesmode$[rsp]
  000ab	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
  000b1	eb 5c		 jmp	 SHORT $LN29@parsestr
$LN31@parsestr:

; 3759 :             }
; 3760 :             else if (quote == 'u' || quote == 'U') {

  000b3	83 7c 24 40 75	 cmp	 DWORD PTR quote$[rsp], 117 ; 00000075H
  000b8	74 07		 je	 SHORT $LN27@parsestr
  000ba	83 7c 24 40 55	 cmp	 DWORD PTR quote$[rsp], 85 ; 00000055H
  000bf	75 1b		 jne	 SHORT $LN28@parsestr
$LN27@parsestr:

; 3761 :                 quote = *++s;

  000c1	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000c6	48 ff c0	 inc	 rax
  000c9	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax
  000ce	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000d3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000d6	89 44 24 40	 mov	 DWORD PTR quote$[rsp], eax
  000da	eb 33		 jmp	 SHORT $LN26@parsestr
$LN28@parsestr:

; 3762 :             }
; 3763 :             else if (quote == 'r' || quote == 'R') {

  000dc	83 7c 24 40 72	 cmp	 DWORD PTR quote$[rsp], 114 ; 00000072H
  000e1	74 07		 je	 SHORT $LN24@parsestr
  000e3	83 7c 24 40 52	 cmp	 DWORD PTR quote$[rsp], 82 ; 00000052H
  000e8	75 23		 jne	 SHORT $LN25@parsestr
$LN24@parsestr:

; 3764 :                 quote = *++s;

  000ea	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000ef	48 ff c0	 inc	 rax
  000f2	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax
  000f7	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000fc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ff	89 44 24 40	 mov	 DWORD PTR quote$[rsp], eax

; 3765 :                 rawmode = 1;

  00103	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR rawmode$[rsp], 1

; 3766 :             }
; 3767 :             else {

  0010b	eb 02		 jmp	 SHORT $LN23@parsestr
$LN25@parsestr:

; 3768 :                 break;

  0010d	eb 05		 jmp	 SHORT $LN33@parsestr
$LN23@parsestr:
$LN26@parsestr:
$LN29@parsestr:

; 3769 :             }
; 3770 :         }

  0010f	e9 50 ff ff ff	 jmp	 $LN34@parsestr
$LN33@parsestr:
$LN35@parsestr:

; 3771 :     }
; 3772 :     if (quote != '\'' && quote != '\"') {

  00114	83 7c 24 40 27	 cmp	 DWORD PTR quote$[rsp], 39 ; 00000027H
  00119	74 1f		 je	 SHORT $LN22@parsestr
  0011b	83 7c 24 40 22	 cmp	 DWORD PTR quote$[rsp], 34 ; 00000022H
  00120	74 18		 je	 SHORT $LN22@parsestr

; 3773 :         PyErr_BadInternalCall();

  00122	ba bd 0e 00 00	 mov	 edx, 3773		; 00000ebdH
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@
  0012e	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3774 :         return NULL;

  00133	33 c0		 xor	 eax, eax
  00135	e9 6c 03 00 00	 jmp	 $LN36@parsestr
$LN22@parsestr:

; 3775 :     }
; 3776 :     s++;

  0013a	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0013f	48 ff c0	 inc	 rax
  00142	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 3777 :     len = strlen(s);

  00147	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0014c	e8 00 00 00 00	 call	 strlen
  00151	48 89 44 24 48	 mov	 QWORD PTR len$[rsp], rax

; 3778 :     if (len > INT_MAX) {

  00156	48 81 7c 24 48
	ff ff ff 7f	 cmp	 QWORD PTR len$[rsp], 2147483647 ; 7fffffffH
  0015f	76 1a		 jbe	 SHORT $LN21@parsestr

; 3779 :         PyErr_SetString(PyExc_OverflowError,
; 3780 :                         "string to parse is too long");

  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@LLDDPBAC@string?5to?5parse?5is?5too?5long?$AA@
  00168	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0016f	e8 00 00 00 00	 call	 PyErr_SetString

; 3781 :         return NULL;

  00174	33 c0		 xor	 eax, eax
  00176	e9 2b 03 00 00	 jmp	 $LN36@parsestr
$LN21@parsestr:

; 3782 :     }
; 3783 :     if (s[--len] != quote) {

  0017b	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00180	48 ff c8	 dec	 rax
  00183	48 89 44 24 48	 mov	 QWORD PTR len$[rsp], rax
  00188	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  0018d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00192	48 03 c8	 add	 rcx, rax
  00195	48 8b c1	 mov	 rax, rcx
  00198	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0019b	3b 44 24 40	 cmp	 eax, DWORD PTR quote$[rsp]
  0019f	74 18		 je	 SHORT $LN20@parsestr

; 3784 :         PyErr_BadInternalCall();

  001a1	ba c8 0e 00 00	 mov	 edx, 3784		; 00000ec8H
  001a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@
  001ad	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3785 :         return NULL;

  001b2	33 c0		 xor	 eax, eax
  001b4	e9 ed 02 00 00	 jmp	 $LN36@parsestr
$LN20@parsestr:

; 3786 :     }
; 3787 :     if (len >= 4 && s[0] == quote && s[1] == quote) {

  001b9	48 83 7c 24 48
	04		 cmp	 QWORD PTR len$[rsp], 4
  001bf	0f 82 a5 00 00
	00		 jb	 $LN19@parsestr
  001c5	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  001ca	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001cd	3b 44 24 40	 cmp	 eax, DWORD PTR quote$[rsp]
  001d1	0f 85 93 00 00
	00		 jne	 $LN19@parsestr
  001d7	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  001dc	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  001e0	3b 44 24 40	 cmp	 eax, DWORD PTR quote$[rsp]
  001e4	0f 85 80 00 00
	00		 jne	 $LN19@parsestr

; 3788 :         s += 2;

  001ea	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  001ef	48 83 c0 02	 add	 rax, 2
  001f3	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 3789 :         len -= 2;

  001f8	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  001fd	48 83 e8 02	 sub	 rax, 2
  00201	48 89 44 24 48	 mov	 QWORD PTR len$[rsp], rax

; 3790 :         if (s[--len] != quote || s[--len] != quote) {

  00206	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  0020b	48 ff c8	 dec	 rax
  0020e	48 89 44 24 48	 mov	 QWORD PTR len$[rsp], rax
  00213	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00218	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0021d	48 03 c8	 add	 rcx, rax
  00220	48 8b c1	 mov	 rax, rcx
  00223	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00226	3b 44 24 40	 cmp	 eax, DWORD PTR quote$[rsp]
  0022a	75 26		 jne	 SHORT $LN17@parsestr
  0022c	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00231	48 ff c8	 dec	 rax
  00234	48 89 44 24 48	 mov	 QWORD PTR len$[rsp], rax
  00239	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  0023e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00243	48 03 c8	 add	 rcx, rax
  00246	48 8b c1	 mov	 rax, rcx
  00249	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0024c	3b 44 24 40	 cmp	 eax, DWORD PTR quote$[rsp]
  00250	74 18		 je	 SHORT $LN18@parsestr
$LN17@parsestr:

; 3791 :             PyErr_BadInternalCall();

  00252	ba cf 0e 00 00	 mov	 edx, 3791		; 00000ecfH
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@DHFJPBFM@?4?4?2Python?2ast?4c?$AA@
  0025e	e8 00 00 00 00	 call	 _PyErr_BadInternalCall

; 3792 :             return NULL;

  00263	33 c0		 xor	 eax, eax
  00265	e9 3c 02 00 00	 jmp	 $LN36@parsestr
$LN18@parsestr:
$LN19@parsestr:

; 3793 :         }
; 3794 :     }
; 3795 :     if (!*bytesmode && !rawmode) {

  0026a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR bytesmode$[rsp]
  00272	83 38 00	 cmp	 DWORD PTR [rax], 0
  00275	75 38		 jne	 SHORT $LN16@parsestr
  00277	83 7c 24 34 00	 cmp	 DWORD PTR rawmode$[rsp], 0
  0027c	75 31		 jne	 SHORT $LN16@parsestr

; 3796 :         return decode_unicode(c, s, len, rawmode, c->c_encoding);

  0027e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00286	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00289	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028e	44 8b 4c 24 34	 mov	 r9d, DWORD PTR rawmode$[rsp]
  00293	4c 8b 44 24 48	 mov	 r8, QWORD PTR len$[rsp]
  00298	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$[rsp]
  0029d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  002a5	e8 00 00 00 00	 call	 decode_unicode
  002aa	e9 f7 01 00 00	 jmp	 $LN36@parsestr
$LN16@parsestr:

; 3797 :     }
; 3798 :     if (*bytesmode) {

  002af	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR bytesmode$[rsp]
  002b7	83 38 00	 cmp	 DWORD PTR [rax], 0
  002ba	74 61		 je	 SHORT $LN15@parsestr

; 3799 :         /* Disallow non-ascii characters (but not escapes) */
; 3800 :         const char *ch;
; 3801 :         for (ch = s; *ch; ch++) {

  002bc	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  002c1	48 89 44 24 50	 mov	 QWORD PTR ch$24665[rsp], rax
  002c6	eb 0d		 jmp	 SHORT $LN14@parsestr
$LN13@parsestr:
  002c8	48 8b 44 24 50	 mov	 rax, QWORD PTR ch$24665[rsp]
  002cd	48 ff c0	 inc	 rax
  002d0	48 89 44 24 50	 mov	 QWORD PTR ch$24665[rsp], rax
$LN14@parsestr:
  002d5	48 8b 44 24 50	 mov	 rax, QWORD PTR ch$24665[rsp]
  002da	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002dd	85 c0		 test	 eax, eax
  002df	74 3c		 je	 SHORT $LN12@parsestr

; 3802 :             if (Py_CHARMASK(*ch) >= 0x80) {

  002e1	48 8b 44 24 50	 mov	 rax, QWORD PTR ch$24665[rsp]
  002e6	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002e9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002ee	0f b6 c0	 movzx	 eax, al
  002f1	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002f6	7c 23		 jl	 SHORT $LN11@parsestr

; 3803 :                 ast_error(c, n, "bytes can only contain ASCII "
; 3804 :                           "literal characters.");

  002f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0DB@IOCBPCNE@bytes?5can?5only?5contain?5ASCII?5lit@
  002ff	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR n$[rsp]
  00307	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  0030f	e8 00 00 00 00	 call	 ast_error

; 3805 :                 return NULL;

  00314	33 c0		 xor	 eax, eax
  00316	e9 8b 01 00 00	 jmp	 $LN36@parsestr
$LN11@parsestr:

; 3806 :             }
; 3807 :         }

  0031b	eb ab		 jmp	 SHORT $LN13@parsestr
$LN12@parsestr:
$LN15@parsestr:

; 3808 :     }
; 3809 :     need_encoding = (!*bytesmode && c->c_encoding != NULL &&
; 3810 :                      strcmp(c->c_encoding, "utf-8") != 0);

  0031d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR bytesmode$[rsp]
  00325	83 38 00	 cmp	 DWORD PTR [rax], 0
  00328	75 33		 jne	 SHORT $LN38@parsestr
  0032a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00332	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00336	74 25		 je	 SHORT $LN38@parsestr
  00338	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  0033f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00347	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0034a	e8 00 00 00 00	 call	 strcmp
  0034f	85 c0		 test	 eax, eax
  00351	74 0a		 je	 SHORT $LN38@parsestr
  00353	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv182[rsp], 1
  0035b	eb 08		 jmp	 SHORT $LN39@parsestr
$LN38@parsestr:
  0035d	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv182[rsp], 0
$LN39@parsestr:
  00365	8b 44 24 68	 mov	 eax, DWORD PTR tv182[rsp]
  00369	89 44 24 30	 mov	 DWORD PTR need_encoding$[rsp], eax

; 3811 :     if (rawmode || strchr(s, '\\') == NULL) {

  0036d	83 7c 24 34 00	 cmp	 DWORD PTR rawmode$[rsp], 0
  00372	75 19		 jne	 SHORT $LN9@parsestr
  00374	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00379	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0037e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00384	48 85 c0	 test	 rax, rax
  00387	0f 85 d5 00 00
	00		 jne	 $LN10@parsestr
$LN9@parsestr:

; 3812 :         if (need_encoding) {

  0038d	83 7c 24 30 00	 cmp	 DWORD PTR need_encoding$[rsp], 0
  00392	74 69		 je	 SHORT $LN8@parsestr

; 3813 :             PyObject *v, *u = PyUnicode_DecodeUTF8(s, len, NULL);

  00394	45 33 c0	 xor	 r8d, r8d
  00397	48 8b 54 24 48	 mov	 rdx, QWORD PTR len$[rsp]
  0039c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  003a1	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8
  003a6	48 89 44 24 60	 mov	 QWORD PTR u$24679[rsp], rax

; 3814 :             if (u == NULL || !*bytesmode)

  003ab	48 83 7c 24 60
	00		 cmp	 QWORD PTR u$24679[rsp], 0
  003b1	74 0d		 je	 SHORT $LN6@parsestr
  003b3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR bytesmode$[rsp]
  003bb	83 38 00	 cmp	 DWORD PTR [rax], 0
  003be	75 0a		 jne	 SHORT $LN7@parsestr
$LN6@parsestr:

; 3815 :                 return u;

  003c0	48 8b 44 24 60	 mov	 rax, QWORD PTR u$24679[rsp]
  003c5	e9 dc 00 00 00	 jmp	 $LN36@parsestr
$LN7@parsestr:

; 3816 :             v = PyUnicode_AsEncodedString(u, c->c_encoding, NULL);

  003ca	45 33 c0	 xor	 r8d, r8d
  003cd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  003d5	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  003d8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR u$24679[rsp]
  003dd	e8 00 00 00 00	 call	 PyUnicode_AsEncodedString
  003e2	48 89 44 24 58	 mov	 QWORD PTR v$24678[rsp], rax

; 3817 :             Py_DECREF(u);

  003e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR u$24679[rsp]
  003ec	e8 00 00 00 00	 call	 _Py_DecRef

; 3818 :             return v;

  003f1	48 8b 44 24 58	 mov	 rax, QWORD PTR v$24678[rsp]
  003f6	e9 ab 00 00 00	 jmp	 $LN36@parsestr
  003fb	eb 65		 jmp	 SHORT $LN5@parsestr
$LN8@parsestr:

; 3819 :         } else if (*bytesmode) {

  003fd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR bytesmode$[rsp]
  00405	83 38 00	 cmp	 DWORD PTR [rax], 0
  00408	74 16		 je	 SHORT $LN4@parsestr

; 3820 :             return PyBytes_FromStringAndSize(s, len);

  0040a	48 8b 54 24 48	 mov	 rdx, QWORD PTR len$[rsp]
  0040f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00414	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00419	e9 88 00 00 00	 jmp	 $LN36@parsestr
  0041e	eb 42		 jmp	 SHORT $LN3@parsestr
$LN4@parsestr:

; 3821 :         } else if (strcmp(c->c_encoding, "utf-8") == 0) {

  00420	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CAMHEFLG@utf?98?$AA@
  00427	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  0042f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00432	e8 00 00 00 00	 call	 strcmp
  00437	85 c0		 test	 eax, eax
  00439	75 13		 jne	 SHORT $LN2@parsestr

; 3822 :             return PyUnicode_FromStringAndSize(s, len);

  0043b	48 8b 54 24 48	 mov	 rdx, QWORD PTR len$[rsp]
  00440	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00445	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  0044a	eb 5a		 jmp	 SHORT $LN36@parsestr

; 3823 :         } else {

  0044c	eb 14		 jmp	 SHORT $LN1@parsestr
$LN2@parsestr:

; 3824 :             return PyUnicode_DecodeLatin1(s, len, NULL);

  0044e	45 33 c0	 xor	 r8d, r8d
  00451	48 8b 54 24 48	 mov	 rdx, QWORD PTR len$[rsp]
  00456	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0045b	e8 00 00 00 00	 call	 PyUnicode_DecodeLatin1
  00460	eb 44		 jmp	 SHORT $LN36@parsestr
$LN1@parsestr:
$LN3@parsestr:
$LN5@parsestr:
$LN10@parsestr:

; 3825 :         }
; 3826 :     }
; 3827 :     return PyBytes_DecodeEscape(s, len, NULL, 1,
; 3828 :                                  need_encoding ? c->c_encoding : NULL);

  00462	83 7c 24 30 00	 cmp	 DWORD PTR need_encoding$[rsp], 0
  00467	74 12		 je	 SHORT $LN40@parsestr
  00469	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR c$[rsp]
  00471	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00474	48 89 44 24 70	 mov	 QWORD PTR tv217[rsp], rax
  00479	eb 09		 jmp	 SHORT $LN41@parsestr
$LN40@parsestr:
  0047b	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR tv217[rsp], 0
$LN41@parsestr:
  00484	48 8b 44 24 70	 mov	 rax, QWORD PTR tv217[rsp]
  00489	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0048e	41 b9 01 00 00
	00		 mov	 r9d, 1
  00494	45 33 c0	 xor	 r8d, r8d
  00497	48 8b 54 24 48	 mov	 rdx, QWORD PTR len$[rsp]
  0049c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  004a1	e8 00 00 00 00	 call	 PyBytes_DecodeEscape
$LN36@parsestr:

; 3829 : }

  004a6	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  004ad	c3		 ret	 0
parsestr ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@PABPNAMF@?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_06OODBCFAF@?2U?$CF08x?$AA@		; `string'
PUBLIC	??_C@_1EE@OMBLPAIH@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@ ; `string'
PUBLIC	??_C@_1CM@PFAECKAM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@FBGDDCHE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_05CIKIJNBG@u005c?$AA@			; `string'
EXTRN	PyUnicode_DecodeUnicodeEscape:PROC
EXTRN	PyUnicode_DecodeRawUnicodeEscape:PROC
EXTRN	PyBytes_AsString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$decode_unicode DD imagerel decode_unicode
	DD	imagerel decode_unicode+1390
	DD	imagerel $unwind$decode_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_unicode DD 021b01H
	DD	013011bH
xdata	ENDS
;	COMDAT ??_C@_1CM@PABPNAMF@?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@PABPNAMF@?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@ DB 'p'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, 'b', 00H, 'u', 00H, 'f', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'y', 00H, '_'
	DB	00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '(', 00H, 'u', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06OODBCFAF@?2U?$CF08x?$AA@
CONST	SEGMENT
??_C@_06OODBCFAF@?2U?$CF08x?$AA@ DB '\U%08x', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@OMBLPAIH@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
CONST	SEGMENT
??_C@_1EE@OMBLPAIH@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'w', 00H, ')', 00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@PFAECKAM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@PFAECKAM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'w', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@FBGDDCHE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@FBGDDCHE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'w', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CIKIJNBG@u005c?$AA@
CONST	SEGMENT
??_C@_05CIKIJNBG@u005c?$AA@ DB 'u005c', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT decode_unicode
_TEXT	SEGMENT
p$ = 32
v$ = 40
u$ = 48
end$ = 56
buf$ = 64
kind$24565 = 72
w$24564 = 80
i$24568 = 88
len$24567 = 96
data$24566 = 104
chr$24604 = 112
tv178 = 120
tv187 = 128
tv217 = 136
tv216 = 140
c$ = 160
s$ = 168
len$ = 176
rawmode$ = 184
encoding$ = 192
decode_unicode PROC					; COMDAT

; 3679 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 3680 :     PyObject *v, *u;
; 3681 :     char *buf;
; 3682 :     char *p;
; 3683 :     const char *end;
; 3684 : 
; 3685 :     if (encoding == NULL) {

  0001b	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR encoding$[rsp], 0
  00024	75 0e		 jne	 SHORT $LN20@decode_uni

; 3686 :         u = NULL;

  00026	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR u$[rsp], 0

; 3687 :     } else {

  0002f	e9 cf 04 00 00	 jmp	 $LN19@decode_uni
$LN20@decode_uni:

; 3688 :         /* check for integer overflow */
; 3689 :         if (len > PY_SIZE_MAX / 6)

  00034	48 b8 aa aa aa
	aa aa aa aa 2a	 mov	 rax, 3074457345618258602 ; 2aaaaaaaaaaaaaaaH
  0003e	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR len$[rsp], rax
  00046	76 07		 jbe	 SHORT $LN18@decode_uni

; 3690 :             return NULL;

  00048	33 c0		 xor	 eax, eax
  0004a	e9 17 05 00 00	 jmp	 $LN21@decode_uni
$LN18@decode_uni:

; 3691 :         /* "" (2 bytes) may become "\U000000E4" (10 bytes), or 1:5
; 3692 :            "\" (3 bytes) may become "\u005c\U000000E4" (16 bytes), or ~1:6 */
; 3693 :         u = PyBytes_FromStringAndSize((char *)NULL, len * 6);

  0004f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  00057	48 6b c0 06	 imul	 rax, 6
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	33 c9		 xor	 ecx, ecx
  00060	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00065	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax

; 3694 :         if (u == NULL)

  0006a	48 83 7c 24 30
	00		 cmp	 QWORD PTR u$[rsp], 0
  00070	75 07		 jne	 SHORT $LN17@decode_uni

; 3695 :             return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	e9 ed 04 00 00	 jmp	 $LN21@decode_uni
$LN17@decode_uni:

; 3696 :         p = buf = PyBytes_AsString(u);

  00079	48 8b 4c 24 30	 mov	 rcx, QWORD PTR u$[rsp]
  0007e	e8 00 00 00 00	 call	 PyBytes_AsString
  00083	48 89 44 24 40	 mov	 QWORD PTR buf$[rsp], rax
  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$[rsp]
  0008d	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 3697 :         end = s + len;

  00092	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0009a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000a2	48 03 c8	 add	 rcx, rax
  000a5	48 8b c1	 mov	 rax, rcx
  000a8	48 89 44 24 38	 mov	 QWORD PTR end$[rsp], rax
$LN16@decode_uni:

; 3698 :         while (s < end) {

  000ad	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  000b2	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR s$[rsp], rax
  000ba	0f 83 1e 04 00
	00		 jae	 $LN15@decode_uni

; 3699 :             if (*s == '\\') {

  000c0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000c8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000cb	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  000ce	75 65		 jne	 SHORT $LN14@decode_uni

; 3700 :                 *p++ = *s++;

  000d0	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000d5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000dd	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000e0	88 08		 mov	 BYTE PTR [rax], cl
  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000e7	48 ff c0	 inc	 rax
  000ea	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  000ef	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000f7	48 ff c0	 inc	 rax
  000fa	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 3701 :                 if (*s & 0x80) {

  00102	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0010a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0010d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00112	85 c0		 test	 eax, eax
  00114	74 1f		 je	 SHORT $LN13@decode_uni

; 3702 :                     strcpy(p, "u005c");

  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CIKIJNBG@u005c?$AA@
  0011d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00122	e8 00 00 00 00	 call	 strcpy

; 3703 :                     p += 5;

  00127	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0012c	48 83 c0 05	 add	 rax, 5
  00130	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN13@decode_uni:
$LN14@decode_uni:

; 3704 :                 }
; 3705 :             }
; 3706 :             if (*s & 0x80) { /* XXX inefficient */

  00135	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0013d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00140	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00145	85 c0		 test	 eax, eax
  00147	0f 84 5a 03 00
	00		 je	 $LN12@decode_uni

; 3707 :                 PyObject *w;
; 3708 :                 int kind;
; 3709 :                 void *data;
; 3710 :                 Py_ssize_t len, i;
; 3711 :                 w = decode_utf8(c, &s, end);

  0014d	4c 8b 44 24 38	 mov	 r8, QWORD PTR end$[rsp]
  00152	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR s$[rsp]
  0015a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR c$[rsp]
  00162	e8 00 00 00 00	 call	 decode_utf8
  00167	48 89 44 24 50	 mov	 QWORD PTR w$24564[rsp], rax

; 3712 :                 if (w == NULL) {

  0016c	48 83 7c 24 50
	00		 cmp	 QWORD PTR w$24564[rsp], 0
  00172	75 11		 jne	 SHORT $LN11@decode_uni

; 3713 :                     Py_DECREF(u);

  00174	48 8b 4c 24 30	 mov	 rcx, QWORD PTR u$[rsp]
  00179	e8 00 00 00 00	 call	 _Py_DecRef

; 3714 :                     return NULL;

  0017e	33 c0		 xor	 eax, eax
  00180	e9 e1 03 00 00	 jmp	 $LN21@decode_uni
$LN11@decode_uni:

; 3715 :                 }
; 3716 :                 kind = PyUnicode_KIND(w);

  00185	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  0018a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0018e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00194	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00199	85 c0		 test	 eax, eax
  0019b	75 1c		 jne	 SHORT $LN23@decode_uni
  0019d	41 b8 84 0e 00
	00		 mov	 r8d, 3716		; 00000e84H
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@FBGDDCHE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
  001b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b7	33 c0		 xor	 eax, eax
$LN23@decode_uni:
  001b9	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  001be	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001c1	c1 e8 07	 shr	 eax, 7
  001c4	83 e0 01	 and	 eax, 1
  001c7	85 c0		 test	 eax, eax
  001c9	75 1c		 jne	 SHORT $LN24@decode_uni
  001cb	41 b8 84 0e 00
	00		 mov	 r8d, 3716		; 00000e84H
  001d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@PFAECKAM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001e5	33 c0		 xor	 eax, eax
$LN24@decode_uni:
  001e7	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  001ec	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001ef	c1 e8 02	 shr	 eax, 2
  001f2	83 e0 07	 and	 eax, 7
  001f5	89 44 24 48	 mov	 DWORD PTR kind$24565[rsp], eax

; 3717 :                 data = PyUnicode_DATA(w);

  001f9	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  001fe	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00202	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00208	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0020d	85 c0		 test	 eax, eax
  0020f	75 1c		 jne	 SHORT $LN25@decode_uni
  00211	41 b8 85 0e 00
	00		 mov	 r8d, 3717		; 00000e85H
  00217	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@FBGDDCHE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0022b	33 c0		 xor	 eax, eax
$LN25@decode_uni:
  0022d	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  00232	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00235	c1 e8 05	 shr	 eax, 5
  00238	83 e0 01	 and	 eax, 1
  0023b	85 c0		 test	 eax, eax
  0023d	0f 84 a5 00 00
	00		 je	 $LN31@decode_uni
  00243	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  00248	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0024c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00252	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00257	85 c0		 test	 eax, eax
  00259	75 1c		 jne	 SHORT $LN26@decode_uni
  0025b	41 b8 85 0e 00
	00		 mov	 r8d, 3717		; 00000e85H
  00261	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@FBGDDCHE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
  0026f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00275	33 c0		 xor	 eax, eax
$LN26@decode_uni:
  00277	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  0027c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0027f	c1 e8 07	 shr	 eax, 7
  00282	83 e0 01	 and	 eax, 1
  00285	85 c0		 test	 eax, eax
  00287	75 1c		 jne	 SHORT $LN27@decode_uni
  00289	41 b8 85 0e 00
	00		 mov	 r8d, 3717		; 00000e85H
  0028f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@PFAECKAM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002a3	33 c0		 xor	 eax, eax
$LN27@decode_uni:
  002a5	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  002aa	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002ad	c1 e8 06	 shr	 eax, 6
  002b0	83 e0 01	 and	 eax, 1
  002b3	85 c0		 test	 eax, eax
  002b5	74 12		 je	 SHORT $LN28@decode_uni
  002b7	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  002bc	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  002c2	48 89 44 24 78	 mov	 QWORD PTR tv178[rsp], rax
  002c7	eb 10		 jmp	 SHORT $LN29@decode_uni
$LN28@decode_uni:
  002c9	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  002ce	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  002d4	48 89 44 24 78	 mov	 QWORD PTR tv178[rsp], rax
$LN29@decode_uni:
  002d9	48 8b 44 24 78	 mov	 rax, QWORD PTR tv178[rsp]
  002de	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv187[rsp], rax
  002e6	eb 3f		 jmp	 SHORT $LN32@decode_uni
$LN31@decode_uni:
  002e8	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  002ed	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  002f5	75 1c		 jne	 SHORT $LN30@decode_uni
  002f7	41 b8 85 0e 00
	00		 mov	 r8d, 3717		; 00000e85H
  002fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00304	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@OMBLPAIH@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAw?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4?$AAa?$AAn@
  0030b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00311	33 c0		 xor	 eax, eax
$LN30@decode_uni:
  00313	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  00318	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0031f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv187[rsp], rax
$LN32@decode_uni:
  00327	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv187[rsp]
  0032f	48 89 44 24 68	 mov	 QWORD PTR data$24566[rsp], rax

; 3718 :                 len = PyUnicode_GET_LENGTH(w);

  00334	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  00339	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0033d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00343	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00348	85 c0		 test	 eax, eax
  0034a	75 1c		 jne	 SHORT $LN33@decode_uni
  0034c	41 b8 86 0e 00
	00		 mov	 r8d, 3718		; 00000e86H
  00352	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00359	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@FBGDDCHE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
  00360	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00366	33 c0		 xor	 eax, eax
$LN33@decode_uni:
  00368	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  0036d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00370	c1 e8 07	 shr	 eax, 7
  00373	83 e0 01	 and	 eax, 1
  00376	85 c0		 test	 eax, eax
  00378	75 1c		 jne	 SHORT $LN34@decode_uni
  0037a	41 b8 86 0e 00
	00		 mov	 r8d, 3718		; 00000e86H
  00380	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  00387	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@PFAECKAM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAw?$AA?$CJ?$AA?$AA@
  0038e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00394	33 c0		 xor	 eax, eax
$LN34@decode_uni:
  00396	48 8b 44 24 50	 mov	 rax, QWORD PTR w$24564[rsp]
  0039b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0039f	48 89 44 24 60	 mov	 QWORD PTR len$24567[rsp], rax

; 3719 :                 for (i = 0; i < len; i++) {

  003a4	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR i$24568[rsp], 0
  003ad	eb 0d		 jmp	 SHORT $LN10@decode_uni
$LN9@decode_uni:
  003af	48 8b 44 24 58	 mov	 rax, QWORD PTR i$24568[rsp]
  003b4	48 ff c0	 inc	 rax
  003b7	48 89 44 24 58	 mov	 QWORD PTR i$24568[rsp], rax
$LN10@decode_uni:
  003bc	48 8b 44 24 60	 mov	 rax, QWORD PTR len$24567[rsp]
  003c1	48 39 44 24 58	 cmp	 QWORD PTR i$24568[rsp], rax
  003c6	0f 8d 98 00 00
	00		 jge	 $LN8@decode_uni

; 3720 :                     Py_UCS4 chr = PyUnicode_READ(kind, data, i);

  003cc	83 7c 24 48 01	 cmp	 DWORD PTR kind$24565[rsp], 1
  003d1	75 1c		 jne	 SHORT $LN37@decode_uni
  003d3	48 8b 44 24 58	 mov	 rax, QWORD PTR i$24568[rsp]
  003d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR data$24566[rsp]
  003dd	48 03 c8	 add	 rcx, rax
  003e0	48 8b c1	 mov	 rax, rcx
  003e3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003e6	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv217[rsp], eax
  003ed	eb 40		 jmp	 SHORT $LN38@decode_uni
$LN37@decode_uni:
  003ef	83 7c 24 48 02	 cmp	 DWORD PTR kind$24565[rsp], 2
  003f4	75 17		 jne	 SHORT $LN35@decode_uni
  003f6	48 8b 44 24 68	 mov	 rax, QWORD PTR data$24566[rsp]
  003fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR i$24568[rsp]
  00400	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00404	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv216[rsp], eax
  0040b	eb 14		 jmp	 SHORT $LN36@decode_uni
$LN35@decode_uni:
  0040d	48 8b 44 24 68	 mov	 rax, QWORD PTR data$24566[rsp]
  00412	48 8b 4c 24 58	 mov	 rcx, QWORD PTR i$24568[rsp]
  00417	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0041a	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv216[rsp], eax
$LN36@decode_uni:
  00421	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv216[rsp]
  00428	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv217[rsp], eax
$LN38@decode_uni:
  0042f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv217[rsp]
  00436	89 44 24 70	 mov	 DWORD PTR chr$24604[rsp], eax

; 3721 :                     sprintf(p, "\\U%08x", chr);

  0043a	44 8b 44 24 70	 mov	 r8d, DWORD PTR chr$24604[rsp]
  0043f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06OODBCFAF@?2U?$CF08x?$AA@
  00446	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0044b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 3722 :                     p += 10;

  00451	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00456	48 83 c0 0a	 add	 rax, 10
  0045a	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 3723 :                 }

  0045f	e9 4b ff ff ff	 jmp	 $LN9@decode_uni
$LN8@decode_uni:

; 3724 :                 /* Should be impossible to overflow */
; 3725 :                 assert(p - buf <= Py_SIZE(u));

  00464	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$[rsp]
  00469	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0046e	48 2b c8	 sub	 rcx, rax
  00471	48 8b c1	 mov	 rax, rcx
  00474	48 8b 4c 24 30	 mov	 rcx, QWORD PTR u$[rsp]
  00479	48 3b 41 60	 cmp	 rax, QWORD PTR [rcx+96]
  0047d	7e 1c		 jle	 SHORT $LN39@decode_uni
  0047f	41 b8 8d 0e 00
	00		 mov	 r8d, 3725		; 00000e8dH
  00485	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CA@FDBOFCJB@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAa?$AAs?$AAt?$AA?4?$AAc?$AA?$AA@
  0048c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@PABPNAMF@?$AAp?$AA?5?$AA?9?$AA?5?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAP?$AAy?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?$CI?$AAu?$AA?$CJ?$AA?$AA@
  00493	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00499	33 c0		 xor	 eax, eax
$LN39@decode_uni:

; 3726 :                 Py_DECREF(w);

  0049b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR w$24564[rsp]
  004a0	e8 00 00 00 00	 call	 _Py_DecRef

; 3727 :             } else {

  004a5	eb 32		 jmp	 SHORT $LN7@decode_uni
$LN12@decode_uni:

; 3728 :                 *p++ = *s++;

  004a7	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004ac	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004b4	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  004b7	88 08		 mov	 BYTE PTR [rax], cl
  004b9	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  004be	48 ff c0	 inc	 rax
  004c1	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  004c6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004ce	48 ff c0	 inc	 rax
  004d1	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
$LN7@decode_uni:

; 3729 :             }
; 3730 :         }

  004d9	e9 cf fb ff ff	 jmp	 $LN16@decode_uni
$LN15@decode_uni:

; 3731 :         len = p - buf;

  004de	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$[rsp]
  004e3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  004e8	48 2b c8	 sub	 rcx, rax
  004eb	48 8b c1	 mov	 rax, rcx
  004ee	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 3732 :         s = buf;

  004f6	48 8b 44 24 40	 mov	 rax, QWORD PTR buf$[rsp]
  004fb	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
$LN19@decode_uni:

; 3733 :     }
; 3734 :     if (rawmode)

  00503	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR rawmode$[rsp], 0
  0050b	74 1f		 je	 SHORT $LN6@decode_uni

; 3735 :         v = PyUnicode_DecodeRawUnicodeEscape(s, len, NULL);

  0050d	45 33 c0	 xor	 r8d, r8d
  00510	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR len$[rsp]
  00518	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00520	e8 00 00 00 00	 call	 PyUnicode_DecodeRawUnicodeEscape
  00525	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax

; 3736 :     else

  0052a	eb 1d		 jmp	 SHORT $LN5@decode_uni
$LN6@decode_uni:

; 3737 :         v = PyUnicode_DecodeUnicodeEscape(s, len, NULL);

  0052c	45 33 c0	 xor	 r8d, r8d
  0052f	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR len$[rsp]
  00537	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0053f	e8 00 00 00 00	 call	 PyUnicode_DecodeUnicodeEscape
  00544	48 89 44 24 28	 mov	 QWORD PTR v$[rsp], rax
$LN5@decode_uni:
$LN4@decode_uni:

; 3738 :     Py_XDECREF(u);

  00549	48 83 7c 24 30
	00		 cmp	 QWORD PTR u$[rsp], 0
  0054f	74 0a		 je	 SHORT $LN1@decode_uni
  00551	48 8b 4c 24 30	 mov	 rcx, QWORD PTR u$[rsp]
  00556	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@decode_uni:
  0055b	33 c0		 xor	 eax, eax
  0055d	85 c0		 test	 eax, eax
  0055f	75 e8		 jne	 SHORT $LN4@decode_uni

; 3739 :     return v;

  00561	48 8b 44 24 28	 mov	 rax, QWORD PTR v$[rsp]
$LN21@decode_uni:

; 3740 : }

  00566	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0056d	c3		 ret	 0
decode_unicode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$decode_utf8 DD imagerel decode_utf8
	DD	imagerel decode_utf8+136
	DD	imagerel $unwind$decode_utf8
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$decode_utf8 DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT decode_utf8
_TEXT	SEGMENT
s$ = 32
t$ = 40
c$ = 64
sPtr$ = 72
end$ = 80
decode_utf8 PROC					; COMDAT

; 3668 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3669 :     char *s, *t;
; 3670 :     t = s = (char *)*sPtr;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR sPtr$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00025	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax
$LN2@decode_utf:

; 3671 :     /* while (s < end && *s != '\\') s++; */ /* inefficient for u".." */
; 3672 :     while (s < end && (*s & 0x80)) s++;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR end$[rsp]
  0002f	48 39 44 24 20	 cmp	 QWORD PTR s$[rsp], rax
  00034	73 20		 jae	 SHORT $LN1@decode_utf
  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0003b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0003e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00043	85 c0		 test	 eax, eax
  00045	74 0f		 je	 SHORT $LN1@decode_utf
  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0004c	48 ff c0	 inc	 rax
  0004f	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
  00054	eb d4		 jmp	 SHORT $LN2@decode_utf
$LN1@decode_utf:

; 3673 :     *sPtr = s;

  00056	48 8b 44 24 48	 mov	 rax, QWORD PTR sPtr$[rsp]
  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00060	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3674 :     return PyUnicode_DecodeUTF8(t, s - t, NULL);

  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0006d	48 2b c8	 sub	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	45 33 c0	 xor	 r8d, r8d
  00076	48 8b d0	 mov	 rdx, rax
  00079	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  0007e	e8 00 00 00 00	 call	 PyUnicode_DecodeUTF8

; 3675 : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
decode_utf8 ENDP
_TEXT	ENDS
END
