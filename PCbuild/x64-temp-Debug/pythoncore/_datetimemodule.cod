; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CK@LPNFBAGO@Fast?5implementation?5of?5the?5datet@ ; `string'
PUBLIC	??_C@_09BLEDGJAH@_datetime?$AA@			; `string'
PUBLIC	??_C@_0BC@JEMBMAD@datetime?4datetime?$AA@	; `string'
PUBLIC	??_C@_0DA@OEACLEJI@tz?5?9?$DO?5convert?5to?5local?5time?5in?5n@ ; `string'
PUBLIC	??_C@_0L@ECALMFAG@astimezone?$AA@		; `string'
PUBLIC	??_C@_0CL@IFILGCIP@Return?5datetime?5with?5new?5specifi@ ; `string'
PUBLIC	??_C@_0JA@IBIENBBE@?$FLsep?$FN?5?9?$DO?5string?5in?5ISO?58601?5form@ ; `string'
PUBLIC	??_C@_0DJ@MGNAKBHL@Return?5UTC?5time?5tuple?0?5compatibl@ ; `string'
PUBLIC	??_C@_0N@LHNBNFDP@utctimetuple?$AA@		; `string'
PUBLIC	??_C@_0CB@CCPKKINL@Return?5POSIX?5timestamp?5as?5float?4@ ; `string'
PUBLIC	??_C@_0CO@LKCKICLJ@Return?5time?5object?5with?5same?5tim@ ; `string'
PUBLIC	??_C@_06LODNGPBG@timetz?$AA@			; `string'
PUBLIC	??_C@_0DI@BHDEBDDH@Return?5time?5object?5with?5same?5tim@ ; `string'
PUBLIC	??_C@_0DC@LNOALPPA@Return?5date?5object?5with?5same?5yea@ ; `string'
PUBLIC	??_C@_0DG@POLGFJIG@date?0?5time?5?9?$DO?5datetime?5with?5same@ ; `string'
PUBLIC	??_C@_07PCDCECCK@combine?$AA@			; `string'
PUBLIC	??_C@_0EM@OMBKPNCM@string?0?5format?5?9?$DO?5new?5datetime?5p@ ; `string'
PUBLIC	??_C@_08JKOOHOPP@strptime?$AA@			; `string'
PUBLIC	??_C@_0EF@KHGJAJAA@timestamp?5?9?$DO?5UTC?5datetime?5from?5a@ ; `string'
PUBLIC	??_C@_0BB@GBGDJFBJ@utcfromtimestamp?$AA@	; `string'
PUBLIC	??_C@_0DJ@MJHLLJLE@timestamp?$FL?0?5tz?$FN?5?9?$DO?5tz?8s?5local?5ti@ ; `string'
PUBLIC	??_C@_0DF@OGGJLCPO@Return?5a?5new?5datetime?5representi@ ; `string'
PUBLIC	??_C@_06GKOOHOFL@utcnow?$AA@			; `string'
PUBLIC	??_C@_0DD@JPPGJGOI@?$FLtz?$FN?5?9?$DO?5new?5datetime?5with?5tz?8s?5l@ ; `string'
PUBLIC	??_C@_03CGLHMDPP@now?$AA@			; `string'
PUBLIC	??_C@_03MGBCFPKM@sep?$AA@			; `string'
PUBLIC	??_C@_04JNIHBGGH@date?$AA@			; `string'
PUBLIC	??_C@_0BD@LIAHNOMG@_strptime_datetime?$AA@	; `string'
PUBLIC	??_C@_09OMDJNLDP@timestamp?$AA@			; `string'
PUBLIC	??_C@_02IGJGHHBN@tz?$AA@			; `string'
PUBLIC	??_C@_0O@NMMCJMEE@datetime?4time?$AA@		; `string'
PUBLIC	??_C@_0CH@HGAMGBKA@Return?5time?5with?5new?5specified?5f@ ; `string'
PUBLIC	??_C@_0BO@PCCLEJIH@Return?5self?4tzinfo?4dst?$CIself?$CJ?4?$AA@ ; `string'
PUBLIC	??_C@_0CB@BKFJMHAP@Return?5self?4tzinfo?4tzname?$CIself?$CJ?4@ ; `string'
PUBLIC	??_C@_0CE@LHGMAHOI@Return?5self?4tzinfo?4utcoffset?$CIsel@ ; `string'
PUBLIC	??_C@_0DN@HPEMOKB@Return?5string?5in?5ISO?58601?5format@ ; `string'
PUBLIC	??_C@_06DBOJKPOI@tzinfo?$AA@			; `string'
PUBLIC	??_C@_0M@IPLGOMOC@microsecond?$AA@		; `string'
PUBLIC	??_C@_06BJCFNGJP@second?$AA@			; `string'
PUBLIC	??_C@_06JGJIJFNK@minute?$AA@			; `string'
PUBLIC	??_C@_04LMOJGCPE@hour?$AA@			; `string'
PUBLIC	??_C@_0BC@BMDCMDDO@datetime?4timezone?$AA@	; `string'
PUBLIC	??_C@_0P@BIOPACEL@pickle?5support?$AA@		; `string'
PUBLIC	??_C@_0N@BDGMCEOD@Return?5None?4?$AA@		; `string'
PUBLIC	??_C@_0BF@NDKIKJK@Return?5fixed?5offset?4?$AA@	; `string'
PUBLIC	??_C@_0GP@EEKHNJLP@If?5name?5is?5specified?5when?5timezo@ ; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_06KLHHMIGM@offset?$AA@			; `string'
PUBLIC	??_C@_0BA@GEFABIKC@datetime?4tzinfo?$AA@	; `string'
PUBLIC	??_C@_0BA@IKFFDJGA@?9?$DO?5?$CIcls?0?5state?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CL@PFDHOCLO@datetime?5in?5UTC?5?9?$DO?5datetime?5in?5l@ ; `string'
PUBLIC	??_C@_07COGHOOJN@fromutc?$AA@			; `string'
PUBLIC	??_C@_0CP@CILGLPLI@datetime?5?9?$DO?5DST?5offset?5in?5minute@ ; `string'
PUBLIC	??_C@_03HHBLCKEM@dst?$AA@			; `string'
PUBLIC	??_C@_0FG@KHADFGHJ@datetime?5?9?$DO?5timedelta?5showing?5of@ ; `string'
PUBLIC	??_C@_09DGNKAEDJ@utcoffset?$AA@			; `string'
PUBLIC	??_C@_0CG@ECFLPKO@datetime?5?9?$DO?5string?5name?5of?5time?5@ ; `string'
PUBLIC	??_C@_0N@NAMJJHIO@__getstate__?$AA@		; `string'
PUBLIC	??_C@_0BA@NHLJJDN@__getinitargs__?$AA@		; `string'
PUBLIC	??_C@_0O@GKGBLLNG@datetime?4date?$AA@		; `string'
PUBLIC	??_C@_0CH@GIJAIIMK@Return?5date?5with?5new?5specified?5f@ ; `string'
PUBLIC	??_C@_0FA@FKOJHDKA@Return?5the?5day?5of?5the?5week?5repre@ ; `string'
PUBLIC	??_C@_07FALBAABE@weekday?$AA@			; `string'
PUBLIC	??_C@_0ED@NMEOEPCF@Return?5proleptic?5Gregorian?5ordin@ ; `string'
PUBLIC	??_C@_09EONCNCPH@toordinal?$AA@			; `string'
PUBLIC	??_C@_0FA@KMKAPEAA@Return?5the?5day?5of?5the?5week?5repre@ ; `string'
PUBLIC	??_C@_0L@OLCJLGMC@isoweekday?$AA@		; `string'
PUBLIC	??_C@_0CO@IHBEGEBB@Return?5string?5in?5ISO?58601?5format@ ; `string'
PUBLIC	??_C@_0EA@IKJAEJCA@Return?5a?53?9tuple?5containing?5ISO?5@ ; `string'
PUBLIC	??_C@_0M@NNCHLCCB@isocalendar?$AA@		; `string'
PUBLIC	??_C@_0DF@CKKAPDOD@Return?5time?5tuple?0?5compatible?5wi@ ; `string'
PUBLIC	??_C@_0BM@NAMMOMBA@Formats?5self?5with?5strftime?4?$AA@ ; `string'
PUBLIC	??_C@_0L@MEMCGMKL@__format__?$AA@		; `string'
PUBLIC	??_C@_0CD@LOCOCHNH@format?5?9?$DO?5strftime?$CI?$CJ?5style?5strin@ ; `string'
PUBLIC	??_C@_0BN@GEPPPCNC@Return?5ctime?$CI?$CJ?5style?5string?4?$AA@ ; `string'
PUBLIC	??_C@_05NCKEBKLP@ctime?$AA@			; `string'
PUBLIC	??_C@_0EO@GEOOIIOE@Current?5date?5or?5datetime?3?5?5same?5@ ; `string'
PUBLIC	??_C@_05MGEAPCOL@today?$AA@			; `string'
PUBLIC	??_C@_0DM@HOLBBDCF@int?5?9?$DO?5date?5corresponding?5to?5a?5p@ ; `string'
PUBLIC	??_C@_0M@EGBEAMKN@fromordinal?$AA@		; `string'
PUBLIC	??_C@_0ED@ODEPENLP@timestamp?5?9?$DO?5local?5date?5from?5a?5P@ ; `string'
PUBLIC	??_C@_06DLEPGFEF@format?$AA@			; `string'
PUBLIC	??_C@_09BCIOHOOO@timetuple?$AA@			; `string'
PUBLIC	??_C@_09KILOLAPA@isoformat?$AA@			; `string'
PUBLIC	??_C@_0O@LBDJOPJI@fromtimestamp?$AA@		; `string'
PUBLIC	??_C@_03NNBHCDBP@day?$AA@			; `string'
PUBLIC	??_C@_05MEBAADFH@month?$AA@			; `string'
PUBLIC	??_C@_04JFPLDHAO@year?$AA@			; `string'
PUBLIC	??_C@_0BD@HJBKAPAI@datetime?4timedelta?$AA@	; `string'
PUBLIC	??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_0BP@FCABBAIC@Total?5seconds?5in?5the?5duration?4?$AA@ ; `string'
PUBLIC	??_C@_0O@NKEEINIH@total_seconds?$AA@		; `string'
PUBLIC	??_C@_0DG@IHOJEBBG@Number?5of?5microseconds?5?$CI?$DO?$DN?50?5and@ ; `string'
PUBLIC	??_C@_0CO@EIOKLPFO@Number?5of?5seconds?5?$CI?$DO?$DN?50?5and?5less@ ; `string'
PUBLIC	??_C@_0BA@CFKEOBG@Number?5of?5days?4?$AA@	; `string'
PUBLIC	??_C@_05EFKAJCNN@weeks?$AA@			; `string'
PUBLIC	??_C@_05LOHOPFFC@hours?$AA@			; `string'
PUBLIC	??_C@_07GCICIJGK@minutes?$AA@			; `string'
PUBLIC	??_C@_0N@JDBMCDJK@milliseconds?$AA@		; `string'
PUBLIC	??_C@_0N@EKJJBPIN@microseconds?$AA@		; `string'
PUBLIC	??_C@_07GELLIBDG@seconds?$AA@			; `string'
PUBLIC	??_C@_04IJMHDAOD@days?$AA@			; `string'
PUBLIC	??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@	; `string'
PUBLIC	??_C@_0M@HIOPEIIP@struct_time?$AA@		; `string'
PUBLIC	??_C@_04CLCEDBPF@time?$AA@			; `string'
PUBLIC	??_C@_08EPGBJPHJ@strftime?$AA@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_03MKABNOCG@Dec?$AA@			; `string'
PUBLIC	??_C@_03JPJOFNIA@Nov?$AA@			; `string'
PUBLIC	??_C@_03BMAOKBAD@Oct?$AA@			; `string'
PUBLIC	??_C@_03GGCAPAJC@Sep?$AA@			; `string'
PUBLIC	??_C@_03IFJFEIGA@Aug?$AA@			; `string'
PUBLIC	??_C@_03LBGABGKK@Jul?$AA@			; `string'
PUBLIC	??_C@_03IDFGHECI@Jun?$AA@			; `string'
PUBLIC	??_C@_03CNMDKL@May?$AA@				; `string'
PUBLIC	??_C@_03LEOLGMJP@Apr?$AA@			; `string'
PUBLIC	??_C@_03ODNJBKGA@Mar?$AA@			; `string'
PUBLIC	??_C@_03HJBDCHOM@Feb?$AA@			; `string'
PUBLIC	??_C@_03JIHJHPIE@Jan?$AA@			; `string'
PUBLIC	??_C@_03KOEHGMDN@Sun?$AA@			; `string'
PUBLIC	??_C@_03FEFJNEK@Sat?$AA@			; `string'
PUBLIC	??_C@_03IDIOELNC@Fri?$AA@			; `string'
PUBLIC	??_C@_03IOFIKPDN@Thu?$AA@			; `string'
PUBLIC	??_C@_03MHOMLAJA@Wed?$AA@			; `string'
PUBLIC	??_C@_03NAGEINEP@Tue?$AA@			; `string'
PUBLIC	??_C@_03PDAGKDH@Mon?$AA@			; `string'
PUBLIC	??_C@_06CNBAGEMF@tzname?$AA@			; `string'
EXTRN	PyType_GenericNew:PROC
EXTRN	PyObject_GenericGetAttr:PROC
_BSS	SEGMENT
us_per_us DQ	01H DUP (?)
us_per_ms DQ	01H DUP (?)
us_per_second DQ 01H DUP (?)
us_per_minute DQ 01H DUP (?)
us_per_hour DQ	01H DUP (?)
us_per_day DQ	01H DUP (?)
us_per_week DQ	01H DUP (?)
seconds_per_day DQ 01H DUP (?)
?module@?1??datetime_strptime@@9@9 DQ 01H DUP (?)	; `datetime_strptime'::`2'::module
module_methods DB 020H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CK@LPNFBAGO@Fast?5implementation?5of?5the?5datet@
CONST	SEGMENT
??_C@_0CK@LPNFBAGO@Fast?5implementation?5of?5the?5datet@ DB 'Fast impleme'
	DB	'ntation of the datetime type.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BLEDGJAH@_datetime?$AA@
CONST	SEGMENT
??_C@_09BLEDGJAH@_datetime?$AA@ DB '_datetime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JEMBMAD@datetime?4datetime?$AA@
CONST	SEGMENT
??_C@_0BC@JEMBMAD@datetime?4datetime?$AA@ DB 'datetime.datetime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@OEACLEJI@tz?5?9?$DO?5convert?5to?5local?5time?5in?5n@
CONST	SEGMENT
??_C@_0DA@OEACLEJI@tz?5?9?$DO?5convert?5to?5local?5time?5in?5n@ DB 'tz ->'
	DB	' convert to local time in new timezone tz', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ECALMFAG@astimezone?$AA@
CONST	SEGMENT
??_C@_0L@ECALMFAG@astimezone?$AA@ DB 'astimezone', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IFILGCIP@Return?5datetime?5with?5new?5specifi@
CONST	SEGMENT
??_C@_0CL@IFILGCIP@Return?5datetime?5with?5new?5specifi@ DB 'Return datet'
	DB	'ime with new specified fields.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0JA@IBIENBBE@?$FLsep?$FN?5?9?$DO?5string?5in?5ISO?58601?5form@
CONST	SEGMENT
??_C@_0JA@IBIENBBE@?$FLsep?$FN?5?9?$DO?5string?5in?5ISO?58601?5form@ DB '['
	DB	'sep] -> string in ISO 8601 format, YYYY-MM-DDTHH:MM:SS[.mmmmm'
	DB	'm][+HH:MM].', 0aH, 0aH, 'sep is used to separate the year fro'
	DB	'm the time, and defaults to ''T''.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MGNAKBHL@Return?5UTC?5time?5tuple?0?5compatibl@
CONST	SEGMENT
??_C@_0DJ@MGNAKBHL@Return?5UTC?5time?5tuple?0?5compatibl@ DB 'Return UTC '
	DB	'time tuple, compatible with time.localtime().', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LHNBNFDP@utctimetuple?$AA@
CONST	SEGMENT
??_C@_0N@LHNBNFDP@utctimetuple?$AA@ DB 'utctimetuple', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@CCPKKINL@Return?5POSIX?5timestamp?5as?5float?4@
CONST	SEGMENT
??_C@_0CB@CCPKKINL@Return?5POSIX?5timestamp?5as?5float?4@ DB 'Return POSI'
	DB	'X timestamp as float.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LKCKICLJ@Return?5time?5object?5with?5same?5tim@
CONST	SEGMENT
??_C@_0CO@LKCKICLJ@Return?5time?5object?5with?5same?5tim@ DB 'Return time'
	DB	' object with same time and tzinfo.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LODNGPBG@timetz?$AA@
CONST	SEGMENT
??_C@_06LODNGPBG@timetz?$AA@ DB 'timetz', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@BHDEBDDH@Return?5time?5object?5with?5same?5tim@
CONST	SEGMENT
??_C@_0DI@BHDEBDDH@Return?5time?5object?5with?5same?5tim@ DB 'Return time'
	DB	' object with same time but with tzinfo=None.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LNOALPPA@Return?5date?5object?5with?5same?5yea@
CONST	SEGMENT
??_C@_0DC@LNOALPPA@Return?5date?5object?5with?5same?5yea@ DB 'Return date'
	DB	' object with same year, month and day.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@POLGFJIG@date?0?5time?5?9?$DO?5datetime?5with?5same@
CONST	SEGMENT
??_C@_0DG@POLGFJIG@date?0?5time?5?9?$DO?5datetime?5with?5same@ DB 'date, '
	DB	'time -> datetime with same date and time fields', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07PCDCECCK@combine?$AA@
CONST	SEGMENT
??_C@_07PCDCECCK@combine?$AA@ DB 'combine', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@OMBKPNCM@string?0?5format?5?9?$DO?5new?5datetime?5p@
CONST	SEGMENT
??_C@_0EM@OMBKPNCM@string?0?5format?5?9?$DO?5new?5datetime?5p@ DB 'string'
	DB	', format -> new datetime parsed from a string (like time.strp'
	DB	'time()).', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08JKOOHOPP@strptime?$AA@
CONST	SEGMENT
??_C@_08JKOOHOPP@strptime?$AA@ DB 'strptime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@KHGJAJAA@timestamp?5?9?$DO?5UTC?5datetime?5from?5a@
CONST	SEGMENT
??_C@_0EF@KHGJAJAA@timestamp?5?9?$DO?5UTC?5datetime?5from?5a@ DB 'timesta'
	DB	'mp -> UTC datetime from a POSIX timestamp (like time.time()).'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GBGDJFBJ@utcfromtimestamp?$AA@
CONST	SEGMENT
??_C@_0BB@GBGDJFBJ@utcfromtimestamp?$AA@ DB 'utcfromtimestamp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@MJHLLJLE@timestamp?$FL?0?5tz?$FN?5?9?$DO?5tz?8s?5local?5ti@
CONST	SEGMENT
??_C@_0DJ@MJHLLJLE@timestamp?$FL?0?5tz?$FN?5?9?$DO?5tz?8s?5local?5ti@ DB 't'
	DB	'imestamp[, tz] -> tz''s local time from POSIX timestamp.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@OGGJLCPO@Return?5a?5new?5datetime?5representi@
CONST	SEGMENT
??_C@_0DF@OGGJLCPO@Return?5a?5new?5datetime?5representi@ DB 'Return a new'
	DB	' datetime representing UTC day and time.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GKOOHOFL@utcnow?$AA@
CONST	SEGMENT
??_C@_06GKOOHOFL@utcnow?$AA@ DB 'utcnow', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JPPGJGOI@?$FLtz?$FN?5?9?$DO?5new?5datetime?5with?5tz?8s?5l@
CONST	SEGMENT
??_C@_0DD@JPPGJGOI@?$FLtz?$FN?5?9?$DO?5new?5datetime?5with?5tz?8s?5l@ DB '['
	DB	'tz] -> new datetime with tz''s local day and time.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03CGLHMDPP@now?$AA@
CONST	SEGMENT
??_C@_03CGLHMDPP@now?$AA@ DB 'now', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MGBCFPKM@sep?$AA@
CONST	SEGMENT
??_C@_03MGBCFPKM@sep?$AA@ DB 'sep', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04JNIHBGGH@date?$AA@
CONST	SEGMENT
??_C@_04JNIHBGGH@date?$AA@ DB 'date', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LIAHNOMG@_strptime_datetime?$AA@
CONST	SEGMENT
??_C@_0BD@LIAHNOMG@_strptime_datetime?$AA@ DB '_strptime_datetime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OMDJNLDP@timestamp?$AA@
CONST	SEGMENT
??_C@_09OMDJNLDP@timestamp?$AA@ DB 'timestamp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02IGJGHHBN@tz?$AA@
CONST	SEGMENT
??_C@_02IGJGHHBN@tz?$AA@ DB 'tz', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NMMCJMEE@datetime?4time?$AA@
CONST	SEGMENT
??_C@_0O@NMMCJMEE@datetime?4time?$AA@ DB 'datetime.time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HGAMGBKA@Return?5time?5with?5new?5specified?5f@
CONST	SEGMENT
??_C@_0CH@HGAMGBKA@Return?5time?5with?5new?5specified?5f@ DB 'Return time'
	DB	' with new specified fields.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PCCLEJIH@Return?5self?4tzinfo?4dst?$CIself?$CJ?4?$AA@
CONST	SEGMENT
??_C@_0BO@PCCLEJIH@Return?5self?4tzinfo?4dst?$CIself?$CJ?4?$AA@ DB 'Retur'
	DB	'n self.tzinfo.dst(self).', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BKFJMHAP@Return?5self?4tzinfo?4tzname?$CIself?$CJ?4@
CONST	SEGMENT
??_C@_0CB@BKFJMHAP@Return?5self?4tzinfo?4tzname?$CIself?$CJ?4@ DB 'Return'
	DB	' self.tzinfo.tzname(self).', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LHGMAHOI@Return?5self?4tzinfo?4utcoffset?$CIsel@
CONST	SEGMENT
??_C@_0CE@LHGMAHOI@Return?5self?4tzinfo?4utcoffset?$CIsel@ DB 'Return sel'
	DB	'f.tzinfo.utcoffset(self).', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HPEMOKB@Return?5string?5in?5ISO?58601?5format@
CONST	SEGMENT
??_C@_0DN@HPEMOKB@Return?5string?5in?5ISO?58601?5format@ DB 'Return strin'
	DB	'g in ISO 8601 format, HH:MM:SS[.mmmmmm][+HH:MM].', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DBOJKPOI@tzinfo?$AA@
CONST	SEGMENT
??_C@_06DBOJKPOI@tzinfo?$AA@ DB 'tzinfo', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IPLGOMOC@microsecond?$AA@
CONST	SEGMENT
??_C@_0M@IPLGOMOC@microsecond?$AA@ DB 'microsecond', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BJCFNGJP@second?$AA@
CONST	SEGMENT
??_C@_06BJCFNGJP@second?$AA@ DB 'second', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGJIJFNK@minute?$AA@
CONST	SEGMENT
??_C@_06JGJIJFNK@minute?$AA@ DB 'minute', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LMOJGCPE@hour?$AA@
CONST	SEGMENT
??_C@_04LMOJGCPE@hour?$AA@ DB 'hour', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BMDCMDDO@datetime?4timezone?$AA@
CONST	SEGMENT
??_C@_0BC@BMDCMDDO@datetime?4timezone?$AA@ DB 'datetime.timezone', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BIOPACEL@pickle?5support?$AA@
CONST	SEGMENT
??_C@_0P@BIOPACEL@pickle?5support?$AA@ DB 'pickle support', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BDGMCEOD@Return?5None?4?$AA@
CONST	SEGMENT
??_C@_0N@BDGMCEOD@Return?5None?4?$AA@ DB 'Return None.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NDKIKJK@Return?5fixed?5offset?4?$AA@
CONST	SEGMENT
??_C@_0BF@NDKIKJK@Return?5fixed?5offset?4?$AA@ DB 'Return fixed offset.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@EEKHNJLP@If?5name?5is?5specified?5when?5timezo@
CONST	SEGMENT
??_C@_0GP@EEKHNJLP@If?5name?5is?5specified?5when?5timezo@ DB 'If name is '
	DB	'specified when timezone is created, returns the name.  Otherw'
	DB	'ise returns offset as ''UTC(+|-)HH:MM''.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLHHMIGM@offset?$AA@
CONST	SEGMENT
??_C@_06KLHHMIGM@offset?$AA@ DB 'offset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GEFABIKC@datetime?4tzinfo?$AA@
CONST	SEGMENT
??_C@_0BA@GEFABIKC@datetime?4tzinfo?$AA@ DB 'datetime.tzinfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@IKFFDJGA@?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@IKFFDJGA@?9?$DO?5?$CIcls?0?5state?$CJ?$AA@ DB '-> (cls, state)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PFDHOCLO@datetime?5in?5UTC?5?9?$DO?5datetime?5in?5l@
CONST	SEGMENT
??_C@_0CL@PFDHOCLO@datetime?5in?5UTC?5?9?$DO?5datetime?5in?5l@ DB 'dateti'
	DB	'me in UTC -> datetime in local time.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07COGHOOJN@fromutc?$AA@
CONST	SEGMENT
??_C@_07COGHOOJN@fromutc?$AA@ DB 'fromutc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@CILGLPLI@datetime?5?9?$DO?5DST?5offset?5in?5minute@
CONST	SEGMENT
??_C@_0CP@CILGLPLI@datetime?5?9?$DO?5DST?5offset?5in?5minute@ DB 'datetim'
	DB	'e -> DST offset in minutes east of UTC.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HHBLCKEM@dst?$AA@
CONST	SEGMENT
??_C@_03HHBLCKEM@dst?$AA@ DB 'dst', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@KHADFGHJ@datetime?5?9?$DO?5timedelta?5showing?5of@
CONST	SEGMENT
??_C@_0FG@KHADFGHJ@datetime?5?9?$DO?5timedelta?5showing?5of@ DB 'datetime'
	DB	' -> timedelta showing offset from UTC, negative values indica'
	DB	'ting West of UTC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DGNKAEDJ@utcoffset?$AA@
CONST	SEGMENT
??_C@_09DGNKAEDJ@utcoffset?$AA@ DB 'utcoffset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ECFLPKO@datetime?5?9?$DO?5string?5name?5of?5time?5@
CONST	SEGMENT
??_C@_0CG@ECFLPKO@datetime?5?9?$DO?5string?5name?5of?5time?5@ DB 'datetim'
	DB	'e -> string name of time zone.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAMJJHIO@__getstate__?$AA@
CONST	SEGMENT
??_C@_0N@NAMJJHIO@__getstate__?$AA@ DB '__getstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NHLJJDN@__getinitargs__?$AA@
CONST	SEGMENT
??_C@_0BA@NHLJJDN@__getinitargs__?$AA@ DB '__getinitargs__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKGBLLNG@datetime?4date?$AA@
CONST	SEGMENT
??_C@_0O@GKGBLLNG@datetime?4date?$AA@ DB 'datetime.date', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GIJAIIMK@Return?5date?5with?5new?5specified?5f@
CONST	SEGMENT
??_C@_0CH@GIJAIIMK@Return?5date?5with?5new?5specified?5f@ DB 'Return date'
	DB	' with new specified fields.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@FKOJHDKA@Return?5the?5day?5of?5the?5week?5repre@
CONST	SEGMENT
??_C@_0FA@FKOJHDKA@Return?5the?5day?5of?5the?5week?5repre@ DB 'Return the'
	DB	' day of the week represented by the date.', 0aH, 'Monday == 0'
	DB	' ... Sunday == 6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FALBAABE@weekday?$AA@
CONST	SEGMENT
??_C@_07FALBAABE@weekday?$AA@ DB 'weekday', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@NMEOEPCF@Return?5proleptic?5Gregorian?5ordin@
CONST	SEGMENT
??_C@_0ED@NMEOEPCF@Return?5proleptic?5Gregorian?5ordin@ DB 'Return prolep'
	DB	'tic Gregorian ordinal.  January 1 of year 1 is day 1.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EONCNCPH@toordinal?$AA@
CONST	SEGMENT
??_C@_09EONCNCPH@toordinal?$AA@ DB 'toordinal', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@KMKAPEAA@Return?5the?5day?5of?5the?5week?5repre@
CONST	SEGMENT
??_C@_0FA@KMKAPEAA@Return?5the?5day?5of?5the?5week?5repre@ DB 'Return the'
	DB	' day of the week represented by the date.', 0aH, 'Monday == 1'
	DB	' ... Sunday == 7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OLCJLGMC@isoweekday?$AA@
CONST	SEGMENT
??_C@_0L@OLCJLGMC@isoweekday?$AA@ DB 'isoweekday', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@IHBEGEBB@Return?5string?5in?5ISO?58601?5format@
CONST	SEGMENT
??_C@_0CO@IHBEGEBB@Return?5string?5in?5ISO?58601?5format@ DB 'Return stri'
	DB	'ng in ISO 8601 format, YYYY-MM-DD.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@IKJAEJCA@Return?5a?53?9tuple?5containing?5ISO?5@
CONST	SEGMENT
??_C@_0EA@IKJAEJCA@Return?5a?53?9tuple?5containing?5ISO?5@ DB 'Return a 3'
	DB	'-tuple containing ISO year, week number, and weekday.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NNCHLCCB@isocalendar?$AA@
CONST	SEGMENT
??_C@_0M@NNCHLCCB@isocalendar?$AA@ DB 'isocalendar', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CKKAPDOD@Return?5time?5tuple?0?5compatible?5wi@
CONST	SEGMENT
??_C@_0DF@CKKAPDOD@Return?5time?5tuple?0?5compatible?5wi@ DB 'Return time'
	DB	' tuple, compatible with time.localtime().', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NAMMOMBA@Formats?5self?5with?5strftime?4?$AA@
CONST	SEGMENT
??_C@_0BM@NAMMOMBA@Formats?5self?5with?5strftime?4?$AA@ DB 'Formats self '
	DB	'with strftime.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEMCGMKL@__format__?$AA@
CONST	SEGMENT
??_C@_0L@MEMCGMKL@__format__?$AA@ DB '__format__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@LOCOCHNH@format?5?9?$DO?5strftime?$CI?$CJ?5style?5strin@
CONST	SEGMENT
??_C@_0CD@LOCOCHNH@format?5?9?$DO?5strftime?$CI?$CJ?5style?5strin@ DB 'fo'
	DB	'rmat -> strftime() style string.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GEPPPCNC@Return?5ctime?$CI?$CJ?5style?5string?4?$AA@
CONST	SEGMENT
??_C@_0BN@GEPPPCNC@Return?5ctime?$CI?$CJ?5style?5string?4?$AA@ DB 'Return'
	DB	' ctime() style string.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NCKEBKLP@ctime?$AA@
CONST	SEGMENT
??_C@_05NCKEBKLP@ctime?$AA@ DB 'ctime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@GEOOIIOE@Current?5date?5or?5datetime?3?5?5same?5@
CONST	SEGMENT
??_C@_0EO@GEOOIIOE@Current?5date?5or?5datetime?3?5?5same?5@ DB 'Current d'
	DB	'ate or datetime:  same as self.__class__.fromtimestamp(time.t'
	DB	'ime()).', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGEAPCOL@today?$AA@
CONST	SEGMENT
??_C@_05MGEAPCOL@today?$AA@ DB 'today', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@HOLBBDCF@int?5?9?$DO?5date?5corresponding?5to?5a?5p@
CONST	SEGMENT
??_C@_0DM@HOLBBDCF@int?5?9?$DO?5date?5corresponding?5to?5a?5p@ DB 'int ->'
	DB	' date corresponding to a proleptic Gregorian ordinal.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EGBEAMKN@fromordinal?$AA@
CONST	SEGMENT
??_C@_0M@EGBEAMKN@fromordinal?$AA@ DB 'fromordinal', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@ODEPENLP@timestamp?5?9?$DO?5local?5date?5from?5a?5P@
CONST	SEGMENT
??_C@_0ED@ODEPENLP@timestamp?5?9?$DO?5local?5date?5from?5a?5P@ DB 'timest'
	DB	'amp -> local date from a POSIX timestamp (like time.time()).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLEPGFEF@format?$AA@
CONST	SEGMENT
??_C@_06DLEPGFEF@format?$AA@ DB 'format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BCIOHOOO@timetuple?$AA@
CONST	SEGMENT
??_C@_09BCIOHOOO@timetuple?$AA@ DB 'timetuple', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09KILOLAPA@isoformat?$AA@
CONST	SEGMENT
??_C@_09KILOLAPA@isoformat?$AA@ DB 'isoformat', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LBDJOPJI@fromtimestamp?$AA@
CONST	SEGMENT
??_C@_0O@LBDJOPJI@fromtimestamp?$AA@ DB 'fromtimestamp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NNBHCDBP@day?$AA@
CONST	SEGMENT
??_C@_03NNBHCDBP@day?$AA@ DB 'day', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEBAADFH@month?$AA@
CONST	SEGMENT
??_C@_05MEBAADFH@month?$AA@ DB 'month', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JFPLDHAO@year?$AA@
CONST	SEGMENT
??_C@_04JFPLDHAO@year?$AA@ DB 'year', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HJBKAPAI@datetime?4timedelta?$AA@
CONST	SEGMENT
??_C@_0BD@HJBKAPAI@datetime?4timedelta?$AA@ DB 'datetime.timedelta', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@ DB '_'
	DB	'_reduce__() -> (cls, state)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FCABBAIC@Total?5seconds?5in?5the?5duration?4?$AA@
CONST	SEGMENT
??_C@_0BP@FCABBAIC@Total?5seconds?5in?5the?5duration?4?$AA@ DB 'Total sec'
	DB	'onds in the duration.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NKEEINIH@total_seconds?$AA@
CONST	SEGMENT
??_C@_0O@NKEEINIH@total_seconds?$AA@ DB 'total_seconds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@IHOJEBBG@Number?5of?5microseconds?5?$CI?$DO?$DN?50?5and@
CONST	SEGMENT
??_C@_0DG@IHOJEBBG@Number?5of?5microseconds?5?$CI?$DO?$DN?50?5and@ DB 'Nu'
	DB	'mber of microseconds (>= 0 and less than 1 second).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@EIOKLPFO@Number?5of?5seconds?5?$CI?$DO?$DN?50?5and?5less@
CONST	SEGMENT
??_C@_0CO@EIOKLPFO@Number?5of?5seconds?5?$CI?$DO?$DN?50?5and?5less@ DB 'N'
	DB	'umber of seconds (>= 0 and less than 1 day).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CFKEOBG@Number?5of?5days?4?$AA@
CONST	SEGMENT
??_C@_0BA@CFKEOBG@Number?5of?5days?4?$AA@ DB 'Number of days.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05EFKAJCNN@weeks?$AA@
CONST	SEGMENT
??_C@_05EFKAJCNN@weeks?$AA@ DB 'weeks', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LOHOPFFC@hours?$AA@
CONST	SEGMENT
??_C@_05LOHOPFFC@hours?$AA@ DB 'hours', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GCICIJGK@minutes?$AA@
CONST	SEGMENT
??_C@_07GCICIJGK@minutes?$AA@ DB 'minutes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JDBMCDJK@milliseconds?$AA@
CONST	SEGMENT
??_C@_0N@JDBMCDJK@milliseconds?$AA@ DB 'milliseconds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EKJJBPIN@microseconds?$AA@
CONST	SEGMENT
??_C@_0N@EKJJBPIN@microseconds?$AA@ DB 'microseconds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GELLIBDG@seconds?$AA@
CONST	SEGMENT
??_C@_07GELLIBDG@seconds?$AA@ DB 'seconds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IJMHDAOD@days?$AA@
CONST	SEGMENT
??_C@_04IJMHDAOD@days?$AA@ DB 'days', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@
CONST	SEGMENT
??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@ DB 'as_integer_ratio', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HIOPEIIP@struct_time?$AA@
CONST	SEGMENT
??_C@_0M@HIOPEIIP@struct_time?$AA@ DB 'struct_time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLCEDBPF@time?$AA@
CONST	SEGMENT
??_C@_04CLCEDBPF@time?$AA@ DB 'time', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPGBJPHJ@strftime?$AA@
CONST	SEGMENT
??_C@_08EPGBJPHJ@strftime?$AA@ DB 'strftime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MKABNOCG@Dec?$AA@
CONST	SEGMENT
??_C@_03MKABNOCG@Dec?$AA@ DB 'Dec', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JPJOFNIA@Nov?$AA@
CONST	SEGMENT
??_C@_03JPJOFNIA@Nov?$AA@ DB 'Nov', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03BMAOKBAD@Oct?$AA@
CONST	SEGMENT
??_C@_03BMAOKBAD@Oct?$AA@ DB 'Oct', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GGCAPAJC@Sep?$AA@
CONST	SEGMENT
??_C@_03GGCAPAJC@Sep?$AA@ DB 'Sep', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IFJFEIGA@Aug?$AA@
CONST	SEGMENT
??_C@_03IFJFEIGA@Aug?$AA@ DB 'Aug', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LBGABGKK@Jul?$AA@
CONST	SEGMENT
??_C@_03LBGABGKK@Jul?$AA@ DB 'Jul', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IDFGHECI@Jun?$AA@
CONST	SEGMENT
??_C@_03IDFGHECI@Jun?$AA@ DB 'Jun', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CNMDKL@May?$AA@
CONST	SEGMENT
??_C@_03CNMDKL@May?$AA@ DB 'May', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LEOLGMJP@Apr?$AA@
CONST	SEGMENT
??_C@_03LEOLGMJP@Apr?$AA@ DB 'Apr', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ODNJBKGA@Mar?$AA@
CONST	SEGMENT
??_C@_03ODNJBKGA@Mar?$AA@ DB 'Mar', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HJBDCHOM@Feb?$AA@
CONST	SEGMENT
??_C@_03HJBDCHOM@Feb?$AA@ DB 'Feb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03JIHJHPIE@Jan?$AA@
CONST	SEGMENT
??_C@_03JIHJHPIE@Jan?$AA@ DB 'Jan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KOEHGMDN@Sun?$AA@
CONST	SEGMENT
??_C@_03KOEHGMDN@Sun?$AA@ DB 'Sun', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FEFJNEK@Sat?$AA@
CONST	SEGMENT
??_C@_03FEFJNEK@Sat?$AA@ DB 'Sat', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IDIOELNC@Fri?$AA@
CONST	SEGMENT
??_C@_03IDIOELNC@Fri?$AA@ DB 'Fri', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IOFIKPDN@Thu?$AA@
CONST	SEGMENT
??_C@_03IOFIKPDN@Thu?$AA@ DB 'Thu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MHOMLAJA@Wed?$AA@
CONST	SEGMENT
??_C@_03MHOMLAJA@Wed?$AA@ DB 'Wed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NAGEINEP@Tue?$AA@
CONST	SEGMENT
??_C@_03NAGEINEP@Tue?$AA@ DB 'Tue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PDAGKDH@Mon?$AA@
CONST	SEGMENT
??_C@_03PDAGKDH@Mon?$AA@ DB 'Mon', 00H			; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_fromutc@?1??datetime_astimezone@@9@9 DQ 0000000000000000H ; `datetime_astimezone'::`2'::PyId_fromutc
	DQ	FLAT:??_C@_07COGHOOJN@fromutc?$AA@
	DQ	0000000000000000H
?PyId_isoformat@?1??datetime_str@@9@9 DQ 0000000000000000H ; `datetime_str'::`2'::PyId_isoformat
	DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	0000000000000000H
?PyId__strptime_datetime@?1??datetime_strptime@@9@9 DQ 0000000000000000H ; `datetime_strptime'::`2'::PyId__strptime_datetime
	DQ	FLAT:??_C@_0BD@LIAHNOMG@_strptime_datetime?$AA@
	DQ	0000000000000000H
?PyId_fromutc@?2??datetime_fromtimestamp@@9@9 DQ 0000000000000000H ; `datetime_fromtimestamp'::`3'::PyId_fromutc
	DQ	FLAT:??_C@_07COGHOOJN@fromutc?$AA@
	DQ	0000000000000000H
?PyId_fromutc@?2??datetime_now@@9@9 DQ 0000000000000000H ; `datetime_now'::`3'::PyId_fromutc
	DQ	FLAT:??_C@_07COGHOOJN@fromutc?$AA@
	DQ	0000000000000000H
?PyId_isoformat@?1??time_str@@9@9 DQ 0000000000000000H	; `time_str'::`2'::PyId_isoformat
	DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	0000000000000000H
?PyId___getstate__@?1??tzinfo_reduce@@9@9 DQ 0000000000000000H ; `tzinfo_reduce'::`2'::PyId___getstate__
	DQ	FLAT:??_C@_0N@NAMJJHIO@__getstate__?$AA@
	DQ	0000000000000000H
?PyId___getinitargs__@?1??tzinfo_reduce@@9@9 DQ 0000000000000000H ; `tzinfo_reduce'::`2'::PyId___getinitargs__
	DQ	FLAT:??_C@_0BA@NHLJJDN@__getinitargs__?$AA@
	DQ	0000000000000000H
?PyId_strftime@?1??date_format@@9@9 DQ 0000000000000000H ; `date_format'::`2'::PyId_strftime
	DQ	FLAT:??_C@_08EPGBJPHJ@strftime?$AA@
	DQ	0000000000000000H
?PyId_timetuple@?1??date_strftime@@9@9 DQ 0000000000000000H ; `date_strftime'::`2'::PyId_timetuple
	DQ	FLAT:??_C@_09BCIOHOOO@timetuple?$AA@
	DQ	0000000000000000H
?PyId_isoformat@?1??date_str@@9@9 DQ 0000000000000000H	; `date_str'::`2'::PyId_isoformat
	DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	0000000000000000H
?PyId_fromtimestamp@?1??date_today@@9@9 DQ 0000000000000000H ; `date_today'::`2'::PyId_fromtimestamp
	DQ	FLAT:??_C@_0O@LBDJOPJI@fromtimestamp?$AA@
	DQ	0000000000000000H
?PyId_as_integer_ratio@?1??truedivide_timedelta_float@@9@9 DQ 0000000000000000H ; `truedivide_timedelta_float'::`2'::PyId_as_integer_ratio
	DQ	FLAT:??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@
	DQ	0000000000000000H
?PyId_as_integer_ratio@?1??multiply_float_timedelta@@9@9 DQ 0000000000000000H ; `multiply_float_timedelta'::`2'::PyId_as_integer_ratio
	DQ	FLAT:??_C@_0BB@IDBMACFH@as_integer_ratio?$AA@
	DQ	0000000000000000H
?PyId_struct_time@?2??build_struct_time@@9@9 DQ 0000000000000000H ; `build_struct_time'::`3'::PyId_struct_time
	DQ	FLAT:??_C@_0M@HIOPEIIP@struct_time?$AA@
	DQ	0000000000000000H
?PyId_time@?2??time_time@@9@9 DQ 0000000000000000H	; `time_time'::`3'::PyId_time
	DQ	FLAT:??_C@_04CLCEDBPF@time?$AA@
	DQ	0000000000000000H
?PyId_strftime@?BC@??wrap_strftime@@9@9 DQ 0000000000000000H ; `wrap_strftime'::`18'::PyId_strftime
	DQ	FLAT:??_C@_08EPGBJPHJ@strftime?$AA@
	DQ	0000000000000000H
?PyId_replace@?1??make_Zreplacement@@9@9 DQ 0000000000000000H ; `make_Zreplacement'::`2'::PyId_replace
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	0000000000000000H
?PyId_tzname@?1??call_tzname@@9@9 DQ 0000000000000000H	; `call_tzname'::`2'::PyId_tzname
	DQ	FLAT:??_C@_06CNBAGEMF@tzname?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_06CNBAGEMF@tzname?$AA@
CONST	SEGMENT
??_C@_06CNBAGEMF@tzname?$AA@ DB 'tzname', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
_days_in_month DD 00H
	DD	01fH
	DD	01cH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01fH
	DD	01eH
	DD	01fH
	DD	01eH
	DD	01fH
	ORG $+4
_days_before_month DD 00H
	DD	00H
	DD	01fH
	DD	03bH
	DD	05aH
	DD	078H
	DD	097H
	DD	0b5H
	DD	0d4H
	DD	0f3H
	DD	0111H
	DD	0130H
	DD	014eH
	ORG $+4
?DayNames@?1??format_ctime@@9@9 DQ FLAT:??_C@_03PDAGKDH@Mon?$AA@ ; `format_ctime'::`2'::DayNames
	DQ	FLAT:??_C@_03NAGEINEP@Tue?$AA@
	DQ	FLAT:??_C@_03MHOMLAJA@Wed?$AA@
	DQ	FLAT:??_C@_03IOFIKPDN@Thu?$AA@
	DQ	FLAT:??_C@_03IDIOELNC@Fri?$AA@
	DQ	FLAT:??_C@_03FEFJNEK@Sat?$AA@
	DQ	FLAT:??_C@_03KOEHGMDN@Sun?$AA@
	ORG $+8
?MonthNames@?1??format_ctime@@9@9 DQ FLAT:??_C@_03JIHJHPIE@Jan?$AA@ ; `format_ctime'::`2'::MonthNames
	DQ	FLAT:??_C@_03HJBDCHOM@Feb?$AA@
	DQ	FLAT:??_C@_03ODNJBKGA@Mar?$AA@
	DQ	FLAT:??_C@_03LEOLGMJP@Apr?$AA@
	DQ	FLAT:??_C@_03CNMDKL@May?$AA@
	DQ	FLAT:??_C@_03IDFGHECI@Jun?$AA@
	DQ	FLAT:??_C@_03LBGABGKK@Jul?$AA@
	DQ	FLAT:??_C@_03IFJFEIGA@Aug?$AA@
	DQ	FLAT:??_C@_03GGCAPAJC@Sep?$AA@
	DQ	FLAT:??_C@_03BMAOKBAD@Oct?$AA@
	DQ	FLAT:??_C@_03JPJOFNIA@Nov?$AA@
	DQ	FLAT:??_C@_03MKABNOCG@Dec?$AA@
?keywords@?1??delta_new@@9@9 DQ FLAT:??_C@_04IJMHDAOD@days?$AA@ ; `delta_new'::`2'::keywords
	DQ	FLAT:??_C@_07GELLIBDG@seconds?$AA@
	DQ	FLAT:??_C@_0N@EKJJBPIN@microseconds?$AA@
	DQ	FLAT:??_C@_0N@JDBMCDJK@milliseconds?$AA@
	DQ	FLAT:??_C@_07GCICIJGK@minutes?$AA@
	DQ	FLAT:??_C@_05LOHOPFFC@hours?$AA@
	DQ	FLAT:??_C@_05EFKAJCNN@weeks?$AA@
	DQ	0000000000000000H
delta_members DQ FLAT:??_C@_04IJMHDAOD@days?$AA@
	DD	01H
	ORG $+4
	DQ	0000000000000068H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BA@CFKEOBG@Number?5of?5days?4?$AA@
	DQ	FLAT:??_C@_07GELLIBDG@seconds?$AA@
	DD	01H
	ORG $+4
	DQ	000000000000006cH
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CO@EIOKLPFO@Number?5of?5seconds?5?$CI?$DO?$DN?50?5and?5less@
	DQ	FLAT:??_C@_0N@EKJJBPIN@microseconds?$AA@
	DD	01H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0DG@IHOJEBBG@Number?5of?5microseconds?5?$CI?$DO?$DN?50?5and@
	DQ	0000000000000000H
	ORG $+32
delta_methods DQ FLAT:??_C@_0O@NKEEINIH@total_seconds?$AA@
	DQ	FLAT:delta_total_seconds
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BP@FCABBAIC@Total?5seconds?5in?5the?5duration?4?$AA@
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:delta_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
delta_doc DB	'Difference between two datetime values.', 00H
	ORG $+8
delta_as_number DQ FLAT:delta_add
	DQ	FLAT:delta_subtract
	DQ	FLAT:delta_multiply
	DQ	FLAT:delta_remainder
	DQ	FLAT:delta_divmod
	DQ	0000000000000000H
	DQ	FLAT:delta_negative
	DQ	FLAT:delta_positive
	DQ	FLAT:delta_abs
	DQ	FLAT:delta_bool
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_divide
	DQ	FLAT:delta_truedivide
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
PyDateTime_DeltaType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BD@HJBKAPAI@datetime?4timedelta?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_repr
	DQ	FLAT:delta_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_hash
	DQ	0000000000000000H
	DQ	FLAT:delta_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:delta_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_methods
	DQ	FLAT:delta_members
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:delta_new
	DQ	0000000000000000H
	ORG $+64
date_getset DQ	FLAT:??_C@_04JFPLDHAO@year?$AA@
	DQ	FLAT:date_year
	ORG $+24
	DQ	FLAT:??_C@_05MEBAADFH@month?$AA@
	DQ	FLAT:date_month
	ORG $+24
	DQ	FLAT:??_C@_03NNBHCDBP@day?$AA@
	DQ	FLAT:date_day
	ORG $+24
	DQ	0000000000000000H
	ORG $+32
date_kws DQ	FLAT:??_C@_04JFPLDHAO@year?$AA@
	DQ	FLAT:??_C@_05MEBAADFH@month?$AA@
	DQ	FLAT:??_C@_03NNBHCDBP@day?$AA@
	DQ	0000000000000000H
?keywords@?1??date_strftime@@9@9 DQ FLAT:??_C@_06DLEPGFEF@format?$AA@ ; `date_strftime'::`2'::keywords
	DQ	0000000000000000H
date_methods DQ	FLAT:??_C@_0O@LBDJOPJI@fromtimestamp?$AA@
	DQ	FLAT:date_fromtimestamp
	DD	011H
	ORG $+4
	DQ	FLAT:??_C@_0ED@ODEPENLP@timestamp?5?9?$DO?5local?5date?5from?5a?5P@
	DQ	FLAT:??_C@_0M@EGBEAMKN@fromordinal?$AA@
	DQ	FLAT:date_fromordinal
	DD	011H
	ORG $+4
	DQ	FLAT:??_C@_0DM@HOLBBDCF@int?5?9?$DO?5date?5corresponding?5to?5a?5p@
	DQ	FLAT:??_C@_05MGEAPCOL@today?$AA@
	DQ	FLAT:date_today
	DD	014H
	ORG $+4
	DQ	FLAT:??_C@_0EO@GEOOIIOE@Current?5date?5or?5datetime?3?5?5same?5@
	DQ	FLAT:??_C@_05NCKEBKLP@ctime?$AA@
	DQ	FLAT:date_ctime
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@GEPPPCNC@Return?5ctime?$CI?$CJ?5style?5string?4?$AA@
	DQ	FLAT:??_C@_08EPGBJPHJ@strftime?$AA@
	DQ	FLAT:date_strftime
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0CD@LOCOCHNH@format?5?9?$DO?5strftime?$CI?$CJ?5style?5strin@
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	FLAT:date_format
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BM@NAMMOMBA@Formats?5self?5with?5strftime?4?$AA@
	DQ	FLAT:??_C@_09BCIOHOOO@timetuple?$AA@
	DQ	FLAT:date_timetuple
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DF@CKKAPDOD@Return?5time?5tuple?0?5compatible?5wi@
	DQ	FLAT:??_C@_0M@NNCHLCCB@isocalendar?$AA@
	DQ	FLAT:date_isocalendar
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0EA@IKJAEJCA@Return?5a?53?9tuple?5containing?5ISO?5@
	DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	FLAT:date_isoformat
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CO@IHBEGEBB@Return?5string?5in?5ISO?58601?5format@
	DQ	FLAT:??_C@_0L@OLCJLGMC@isoweekday?$AA@
	DQ	FLAT:date_isoweekday
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0FA@KMKAPEAA@Return?5the?5day?5of?5the?5week?5repre@
	DQ	FLAT:??_C@_09EONCNCPH@toordinal?$AA@
	DQ	FLAT:date_toordinal
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0ED@NMEOEPCF@Return?5proleptic?5Gregorian?5ordin@
	DQ	FLAT:??_C@_07FALBAABE@weekday?$AA@
	DQ	FLAT:date_weekday
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0FA@FKOJHDKA@Return?5the?5day?5of?5the?5week?5repre@
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:date_replace
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0CH@GIJAIIMK@Return?5date?5with?5new?5specified?5f@
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:date_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
date_doc DB	'date(year, month, day) --> date object', 00H
	ORG $+9
date_as_number DQ FLAT:date_add
	DQ	FLAT:date_subtract
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+192
PyDateTime_DateType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@GKGBLLNG@datetime?4date?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:date_repr
	DQ	FLAT:date_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:date_hash
	DQ	0000000000000000H
	DQ	FLAT:date_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:date_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:date_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:date_methods
	DQ	0000000000000000H
	DQ	FLAT:date_getset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:date_new
	DQ	0000000000000000H
	ORG $+64
tzinfo_methods DQ FLAT:??_C@_06CNBAGEMF@tzname?$AA@
	DQ	FLAT:tzinfo_tzname
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0CG@ECFLPKO@datetime?5?9?$DO?5string?5name?5of?5time?5@
	DQ	FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
	DQ	FLAT:tzinfo_utcoffset
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0FG@KHADFGHJ@datetime?5?9?$DO?5timedelta?5showing?5of@
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:tzinfo_dst
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0CP@CILGLPLI@datetime?5?9?$DO?5DST?5offset?5in?5minute@
	DQ	FLAT:??_C@_07COGHOOJN@fromutc?$AA@
	DQ	FLAT:tzinfo_fromutc
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0CL@PFDHOCLO@datetime?5in?5UTC?5?9?$DO?5datetime?5in?5l@
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:tzinfo_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BA@IKFFDJGA@?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
tzinfo_doc DB	'Abstract base class for time zone info objects.', 00H
PyDateTime_TZInfoType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BA@GEFABIKC@datetime?4tzinfo?$AA@
	DQ	0000000000000060H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:tzinfo_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:tzinfo_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyType_GenericNew
	DQ	0000000000000000H
	ORG $+64
timezone_kws DQ	FLAT:??_C@_06KLHHMIGM@offset?$AA@
	DQ	FLAT:??_C@_04MEMAJGDJ@name?$AA@
	DQ	0000000000000000H
	ORG $+8
timezone_methods DQ FLAT:??_C@_06CNBAGEMF@tzname?$AA@
	DQ	FLAT:timezone_tzname
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0GP@EEKHNJLP@If?5name?5is?5specified?5when?5timezo@
	DQ	FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
	DQ	FLAT:timezone_utcoffset
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0BF@NDKIKJK@Return?5fixed?5offset?4?$AA@
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:timezone_dst
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0N@BDGMCEOD@Return?5None?4?$AA@
	DQ	FLAT:??_C@_07COGHOOJN@fromutc?$AA@
	DQ	FLAT:timezone_fromutc
	DD	08H
	ORG $+4
	DQ	FLAT:??_C@_0CL@PFDHOCLO@datetime?5in?5UTC?5?9?$DO?5datetime?5in?5l@
	DQ	FLAT:??_C@_0BA@NHLJJDN@__getinitargs__?$AA@
	DQ	FLAT:timezone_getinitargs
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0P@BIOPACEL@pickle?5support?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
timezone_doc DB	'Fixed offset from UTC implementation of tzinfo.', 00H
PyDateTime_TimeZoneType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@BMDCMDDO@datetime?4timezone?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:timezone_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:timezone_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:timezone_hash
	DQ	0000000000000000H
	DQ	FLAT:timezone_str
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	FLAT:timezone_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:timezone_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:timezone_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyDateTime_TZInfoType
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:timezone_new
	ORG $+72
time_getset DQ	FLAT:??_C@_04LMOJGCPE@hour?$AA@
	DQ	FLAT:time_hour
	ORG $+24
	DQ	FLAT:??_C@_06JGJIJFNK@minute?$AA@
	DQ	FLAT:time_minute
	ORG $+24
	DQ	FLAT:??_C@_06BJCFNGJP@second?$AA@
	DQ	FLAT:py_time_second
	ORG $+24
	DQ	FLAT:??_C@_0M@IPLGOMOC@microsecond?$AA@
	DQ	FLAT:time_microsecond
	ORG $+24
	DQ	FLAT:??_C@_06DBOJKPOI@tzinfo?$AA@
	DQ	FLAT:time_tzinfo
	ORG $+24
	DQ	0000000000000000H
	ORG $+32
time_kws DQ	FLAT:??_C@_04LMOJGCPE@hour?$AA@
	DQ	FLAT:??_C@_06JGJIJFNK@minute?$AA@
	DQ	FLAT:??_C@_06BJCFNGJP@second?$AA@
	DQ	FLAT:??_C@_0M@IPLGOMOC@microsecond?$AA@
	DQ	FLAT:??_C@_06DBOJKPOI@tzinfo?$AA@
	DQ	0000000000000000H
?keywords@?1??time_strftime@@9@9 DQ FLAT:??_C@_06DLEPGFEF@format?$AA@ ; `time_strftime'::`2'::keywords
	DQ	0000000000000000H
time_methods DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	FLAT:time_isoformat
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DN@HPEMOKB@Return?5string?5in?5ISO?58601?5format@
	DQ	FLAT:??_C@_08EPGBJPHJ@strftime?$AA@
	DQ	FLAT:time_strftime
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0CD@LOCOCHNH@format?5?9?$DO?5strftime?$CI?$CJ?5style?5strin@
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	FLAT:date_format
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0BM@NAMMOMBA@Formats?5self?5with?5strftime?4?$AA@
	DQ	FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
	DQ	FLAT:time_utcoffset
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CE@LHGMAHOI@Return?5self?4tzinfo?4utcoffset?$CIsel@
	DQ	FLAT:??_C@_06CNBAGEMF@tzname?$AA@
	DQ	FLAT:time_tzname
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@BKFJMHAP@Return?5self?4tzinfo?4tzname?$CIself?$CJ?4@
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:time_dst
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BO@PCCLEJIH@Return?5self?4tzinfo?4dst?$CIself?$CJ?4?$AA@
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:time_replace
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0CH@HGAMGBKA@Return?5time?5with?5new?5specified?5f@
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:time_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
time_doc DB	'time([hour[, minute[, second[, microsecond[, tzinfo]]]]]'
	DB	') --> a time object', 0aH, 0aH, 'All arguments are optional. '
	DB	'tzinfo may be None, or an instance of', 0aH, 'a tzinfo subcla'
	DB	'ss. The remaining arguments may be ints.', 0aH, 00H
	ORG $+8
time_as_number DQ 0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_bool
	ORG $+192
PyDateTime_TimeType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0O@NMMCJMEE@datetime?4time?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:time_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_repr
	DQ	FLAT:time_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_hash
	DQ	0000000000000000H
	DQ	FLAT:time_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:time_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_methods
	DQ	0000000000000000H
	DQ	FLAT:time_getset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:time_alloc
	DQ	FLAT:time_new
	DQ	0000000000000000H
	ORG $+64
datetime_getset DQ FLAT:??_C@_04LMOJGCPE@hour?$AA@
	DQ	FLAT:datetime_hour
	ORG $+24
	DQ	FLAT:??_C@_06JGJIJFNK@minute?$AA@
	DQ	FLAT:datetime_minute
	ORG $+24
	DQ	FLAT:??_C@_06BJCFNGJP@second?$AA@
	DQ	FLAT:datetime_second
	ORG $+24
	DQ	FLAT:??_C@_0M@IPLGOMOC@microsecond?$AA@
	DQ	FLAT:datetime_microsecond
	ORG $+24
	DQ	FLAT:??_C@_06DBOJKPOI@tzinfo?$AA@
	DQ	FLAT:datetime_tzinfo
	ORG $+24
	DQ	0000000000000000H
	ORG $+32
datetime_kws DQ	FLAT:??_C@_04JFPLDHAO@year?$AA@
	DQ	FLAT:??_C@_05MEBAADFH@month?$AA@
	DQ	FLAT:??_C@_03NNBHCDBP@day?$AA@
	DQ	FLAT:??_C@_04LMOJGCPE@hour?$AA@
	DQ	FLAT:??_C@_06JGJIJFNK@minute?$AA@
	DQ	FLAT:??_C@_06BJCFNGJP@second?$AA@
	DQ	FLAT:??_C@_0M@IPLGOMOC@microsecond?$AA@
	DQ	FLAT:??_C@_06DBOJKPOI@tzinfo?$AA@
	DQ	0000000000000000H
?keywords@?1??datetime_now@@9@9 DQ FLAT:??_C@_02IGJGHHBN@tz?$AA@ ; `datetime_now'::`2'::keywords
	DQ	0000000000000000H
?keywords@?1??datetime_fromtimestamp@@9@9 DQ FLAT:??_C@_09OMDJNLDP@timestamp?$AA@ ; `datetime_fromtimestamp'::`2'::keywords
	DQ	FLAT:??_C@_02IGJGHHBN@tz?$AA@
	DQ	0000000000000000H
?keywords@?1??datetime_combine@@9@9 DQ FLAT:??_C@_04JNIHBGGH@date?$AA@ ; `datetime_combine'::`2'::keywords
	DQ	FLAT:??_C@_04CLCEDBPF@time?$AA@
	DQ	0000000000000000H
?keywords@?1??datetime_isoformat@@9@9 DQ FLAT:??_C@_03MGBCFPKM@sep?$AA@ ; `datetime_isoformat'::`2'::keywords
	DQ	0000000000000000H
?keywords@?1??datetime_astimezone@@9@9 DQ FLAT:??_C@_02IGJGHHBN@tz?$AA@ ; `datetime_astimezone'::`2'::keywords
	DQ	0000000000000000H
	ORG $+8
datetime_methods DQ FLAT:??_C@_03CGLHMDPP@now?$AA@
	DQ	FLAT:datetime_now
	DD	013H
	ORG $+4
	DQ	FLAT:??_C@_0DD@JPPGJGOI@?$FLtz?$FN?5?9?$DO?5new?5datetime?5with?5tz?8s?5l@
	DQ	FLAT:??_C@_06GKOOHOFL@utcnow?$AA@
	DQ	FLAT:datetime_utcnow
	DD	014H
	ORG $+4
	DQ	FLAT:??_C@_0DF@OGGJLCPO@Return?5a?5new?5datetime?5representi@
	DQ	FLAT:??_C@_0O@LBDJOPJI@fromtimestamp?$AA@
	DQ	FLAT:datetime_fromtimestamp
	DD	013H
	ORG $+4
	DQ	FLAT:??_C@_0DJ@MJHLLJLE@timestamp?$FL?0?5tz?$FN?5?9?$DO?5tz?8s?5local?5ti@
	DQ	FLAT:??_C@_0BB@GBGDJFBJ@utcfromtimestamp?$AA@
	DQ	FLAT:datetime_utcfromtimestamp
	DD	011H
	ORG $+4
	DQ	FLAT:??_C@_0EF@KHGJAJAA@timestamp?5?9?$DO?5UTC?5datetime?5from?5a@
	DQ	FLAT:??_C@_08JKOOHOPP@strptime?$AA@
	DQ	FLAT:datetime_strptime
	DD	011H
	ORG $+4
	DQ	FLAT:??_C@_0EM@OMBKPNCM@string?0?5format?5?9?$DO?5new?5datetime?5p@
	DQ	FLAT:??_C@_07PCDCECCK@combine?$AA@
	DQ	FLAT:datetime_combine
	DD	013H
	ORG $+4
	DQ	FLAT:??_C@_0DG@POLGFJIG@date?0?5time?5?9?$DO?5datetime?5with?5same@
	DQ	FLAT:??_C@_04JNIHBGGH@date?$AA@
	DQ	FLAT:datetime_getdate
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DC@LNOALPPA@Return?5date?5object?5with?5same?5yea@
	DQ	FLAT:??_C@_04CLCEDBPF@time?$AA@
	DQ	FLAT:datetime_gettime
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DI@BHDEBDDH@Return?5time?5object?5with?5same?5tim@
	DQ	FLAT:??_C@_06LODNGPBG@timetz?$AA@
	DQ	FLAT:datetime_gettimetz
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CO@LKCKICLJ@Return?5time?5object?5with?5same?5tim@
	DQ	FLAT:??_C@_05NCKEBKLP@ctime?$AA@
	DQ	FLAT:datetime_ctime
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@GEPPPCNC@Return?5ctime?$CI?$CJ?5style?5string?4?$AA@
	DQ	FLAT:??_C@_09BCIOHOOO@timetuple?$AA@
	DQ	FLAT:datetime_timetuple
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DF@CKKAPDOD@Return?5time?5tuple?0?5compatible?5wi@
	DQ	FLAT:??_C@_09OMDJNLDP@timestamp?$AA@
	DQ	FLAT:datetime_timestamp
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@CCPKKINL@Return?5POSIX?5timestamp?5as?5float?4@
	DQ	FLAT:??_C@_0N@LHNBNFDP@utctimetuple?$AA@
	DQ	FLAT:datetime_utctimetuple
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DJ@MGNAKBHL@Return?5UTC?5time?5tuple?0?5compatibl@
	DQ	FLAT:??_C@_09KILOLAPA@isoformat?$AA@
	DQ	FLAT:datetime_isoformat
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0JA@IBIENBBE@?$FLsep?$FN?5?9?$DO?5string?5in?5ISO?58601?5form@
	DQ	FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
	DQ	FLAT:datetime_utcoffset
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CE@LHGMAHOI@Return?5self?4tzinfo?4utcoffset?$CIsel@
	DQ	FLAT:??_C@_06CNBAGEMF@tzname?$AA@
	DQ	FLAT:datetime_tzname
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@BKFJMHAP@Return?5self?4tzinfo?4tzname?$CIself?$CJ?4@
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:datetime_dst
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BO@PCCLEJIH@Return?5self?4tzinfo?4dst?$CIself?$CJ?4?$AA@
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:datetime_replace
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0CL@IFILGCIP@Return?5datetime?5with?5new?5specifi@
	DQ	FLAT:??_C@_0L@ECALMFAG@astimezone?$AA@
	DQ	FLAT:datetime_astimezone
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0DA@OEACLEJI@tz?5?9?$DO?5convert?5to?5local?5time?5in?5n@
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:datetime_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0BN@JMEDOFNE@__reduce__?$CI?$CJ?5?9?$DO?5?$CIcls?0?5state?$CJ?$AA@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
datetime_doc DB	'datetime(year, month, day[, hour[, minute[, second[, mic'
	DB	'rosecond[,tzinfo]]]]])', 0aH, 0aH, 'The year, month and day a'
	DB	'rguments are required. tzinfo may be None, or an', 0aH, 'inst'
	DB	'ance of a tzinfo subclass. The remaining arguments may be int'
	DB	's.', 0aH, 00H
	ORG $+1
datetime_as_number DQ FLAT:datetime_add
	DQ	FLAT:datetime_subtract
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+192
PyDateTime_DateTimeType DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@JEMBMAD@datetime?4datetime?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:datetime_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:datetime_repr
	DQ	FLAT:datetime_as_number
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:datetime_hash
	DQ	0000000000000000H
	DQ	FLAT:datetime_str
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040400H
	ORG $+4
	DQ	FLAT:datetime_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:datetime_richcompare
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:datetime_methods
	DQ	0000000000000000H
	DQ	FLAT:datetime_getset
	DQ	FLAT:PyDateTime_DateType
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:datetime_alloc
	DQ	FLAT:datetime_new
	DQ	0000000000000000H
	ORG $+64
CAPI	DQ	FLAT:PyDateTime_DateType
	DQ	FLAT:PyDateTime_DateTimeType
	DQ	FLAT:PyDateTime_TimeType
	DQ	FLAT:PyDateTime_DeltaType
	DQ	FLAT:PyDateTime_TZInfoType
	DQ	FLAT:new_date_ex
	DQ	FLAT:new_datetime_ex
	DQ	FLAT:new_time_ex
	DQ	FLAT:new_delta_ex
	DQ	FLAT:datetime_fromtimestamp
	DQ	FLAT:date_fromtimestamp
	ORG $+8
datetimemodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_09BLEDGJAH@_datetime?$AA@
	DQ	FLAT:??_C@_0CK@LPNFBAGO@Fast?5implementation?5of?5the?5datet@
	DQ	ffffffffffffffffH
	DQ	FLAT:module_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyObject_DebugMalloc:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_datetimemodule.c
pdata	SEGMENT
$pdata$time_alloc DD imagerel time_alloc
	DD	imagerel time_alloc+97
	DD	imagerel $unwind$time_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_alloc DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_alloc
_TEXT	SEGMENT
self$ = 32
tv66 = 40
type$ = 64
aware$ = 72
time_alloc PROC						; COMDAT

; 609  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 610  :     PyObject *self;
; 611  : 
; 612  :     self = (PyObject *)
; 613  :         PyObject_MALLOC(aware ?
; 614  :                         sizeof(PyDateTime_Time) :
; 615  :                 sizeof(_PyDateTime_BaseTime));

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR aware$[rsp], 0
  00014	74 0b		 je	 SHORT $LN4@time_alloc
  00016	48 c7 44 24 28
	80 00 00 00	 mov	 QWORD PTR tv66[rsp], 128 ; 00000080H
  0001f	eb 09		 jmp	 SHORT $LN5@time_alloc
$LN4@time_alloc:
  00021	48 c7 44 24 28
	70 00 00 00	 mov	 QWORD PTR tv66[rsp], 112 ; 00000070H
$LN5@time_alloc:
  0002a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv66[rsp]
  0002f	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00034	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 616  :     if (self == NULL)

  00039	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  0003f	75 07		 jne	 SHORT $LN1@time_alloc

; 617  :         return (PyObject *)PyErr_NoMemory();

  00041	e8 00 00 00 00	 call	 PyErr_NoMemory
  00046	eb 14		 jmp	 SHORT $LN2@time_alloc
$LN1@time_alloc:

; 618  :     PyObject_INIT(self, type);

  00048	48 8b 54 24 40	 mov	 rdx, QWORD PTR type$[rsp]
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00052	e8 00 00 00 00	 call	 PyObject_INIT

; 619  :     return self;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
$LN2@time_alloc:

; 620  : }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	c3		 ret	 0
time_alloc ENDP
_TEXT	ENDS
EXTRN	_Py_NewReference:PROC
EXTRN	_PxObject_Init:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$PyObject_INIT DD imagerel PyObject_INIT
	DD	imagerel PyObject_INIT+84
	DD	imagerel $unwind$PyObject_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_INIT DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_INIT
_TEXT	SEGMENT
op$ = 48
tp$ = 56
PyObject_INIT PROC					; COMDAT

; 236  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 237  :     Px_RETURN(_PxObject_Init(op, tp))

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 11		 je	 SHORT $LN1@PyObject_I
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR tp$[rsp]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00021	e8 00 00 00 00	 call	 _PxObject_Init
  00026	eb 27		 jmp	 SHORT $LN2@PyObject_I
$LN1@PyObject_I:

; 238  :     Py_TYPE(op) = tp;

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tp$[rsp]
  00032	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 239  :     _PyObject_InitHead(op);

  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  0003b	e8 00 00 00 00	 call	 _PyObject_InitHead

; 240  :     _Py_NewReference(op);

  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op$[rsp]
  00045	e8 00 00 00 00	 call	 _Py_NewReference

; 241  :     return op;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
$LN2@PyObject_I:

; 242  : }

  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
PyObject_INIT ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_InitHead DD imagerel _PyObject_InitHead
	DD	imagerel _PyObject_InitHead+182
	DD	imagerel $unwind$_PyObject_InitHead
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_InitHead DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, '_', 00H, 'T', 00H, 'Y', 00H, 'P', 00H, 'E', 00H
	DB	'(', 00H, 'o', 00H, 'p', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@
CONST	SEGMENT
??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'i', 00H, 'n', 00H
	DB	'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H
	DB	'.', 00H, 'h', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyObject_InitHead
_TEXT	SEGMENT
op$ = 48
_PyObject_InitHead PROC					; COMDAT

; 215  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 216  :     assert(Py_TYPE(op));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0000e	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  00013	75 1c		 jne	 SHORT $LN3@PyObject_I@2
  00015	41 b8 d8 00 00
	00		 mov	 r8d, 216		; 000000d8H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EI@MBCBHLGB@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAi?$AAn?$AAc?$AAl?$AAu?$AAd?$AAe?$AA?2?$AAo?$AAb?$AAj?$AAi?$AAm?$AAp@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@GPFDFIDP@?$AAP?$AAy?$AA_?$AAT?$AAY?$AAP?$AAE?$AA?$CI?$AAo?$AAp?$AA?$CJ?$AA?$AA@
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002f	33 c0		 xor	 eax, eax
$LN3@PyObject_I@2:

; 217  :     op->is_px = _Py_NOT_PARALLEL;

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00036	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00040	48 89 08	 mov	 QWORD PTR [rax], rcx

; 218  :     op->px    = _Py_NOT_PARALLEL;

  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00048	48 b9 78 56 ef
	be 34 12 ad de	 mov	 rcx, -2401243008567650696 ; dead1234beef5678H
  00052	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 219  :     op->slist_entry.Next = NULL;

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0005b	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 220  :     op->px_flags  = Py_PXFLAGS_ISPY;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00068	48 c7 40 20 01
	00 00 00	 mov	 QWORD PTR [rax+32], 1

; 221  :     op->srw_lock  = NULL;

  00070	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00075	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 222  :     op->event     = NULL;

  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 223  :     op->orig_type = NULL;

  0008a	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0008f	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 224  : #ifdef Py_TRACE_REFS
; 225  :     op->_ob_next = NULL;

  00097	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  0009c	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 226  :     op->_ob_prev = NULL;

  000a4	48 8b 44 24 30	 mov	 rax, QWORD PTR op$[rsp]
  000a9	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 227  : #else
; 228  :     op->_ob_next = _Py_NOT_PARALLEL;
; 229  :     op->_ob_prev = _Py_NOT_PARALLEL;
; 230  : #endif
; 231  : }

  000b1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b5	c3		 ret	 0
_PyObject_InitHead ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\_datetimemodule.c
pdata	SEGMENT
$pdata$datetime_alloc DD imagerel datetime_alloc
	DD	imagerel datetime_alloc+97
	DD	imagerel $unwind$datetime_alloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_alloc DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_alloc
_TEXT	SEGMENT
self$ = 32
tv66 = 40
type$ = 64
aware$ = 72
datetime_alloc PROC					; COMDAT

; 624  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 625  :     PyObject *self;
; 626  : 
; 627  :     self = (PyObject *)
; 628  :         PyObject_MALLOC(aware ?
; 629  :                         sizeof(PyDateTime_DateTime) :
; 630  :                 sizeof(_PyDateTime_BaseDateTime));

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR aware$[rsp], 0
  00014	74 0b		 je	 SHORT $LN4@datetime_a
  00016	48 c7 44 24 28
	80 00 00 00	 mov	 QWORD PTR tv66[rsp], 128 ; 00000080H
  0001f	eb 09		 jmp	 SHORT $LN5@datetime_a
$LN4@datetime_a:
  00021	48 c7 44 24 28
	80 00 00 00	 mov	 QWORD PTR tv66[rsp], 128 ; 00000080H
$LN5@datetime_a:
  0002a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv66[rsp]
  0002f	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00034	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 631  :     if (self == NULL)

  00039	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  0003f	75 07		 jne	 SHORT $LN1@datetime_a

; 632  :         return (PyObject *)PyErr_NoMemory();

  00041	e8 00 00 00 00	 call	 PyErr_NoMemory
  00046	eb 14		 jmp	 SHORT $LN2@datetime_a
$LN1@datetime_a:

; 633  :     PyObject_INIT(self, type);

  00048	48 8b 54 24 40	 mov	 rdx, QWORD PTR type$[rsp]
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00052	e8 00 00 00 00	 call	 PyObject_INIT

; 634  :     return self;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
$LN2@datetime_a:

; 635  : }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	c3		 ret	 0
datetime_alloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_date_ex DD imagerel new_date_ex
	DD	imagerel new_date_ex+87
	DD	imagerel $unwind$new_date_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_date_ex DD 011601H
	DD	06216H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT new_date_ex
_TEXT	SEGMENT
self$ = 32
year$ = 64
month$ = 72
day$ = 80
type$ = 88
new_date_ex PROC					; COMDAT

; 659  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 660  :     PyDateTime_Date *self;
; 661  : 
; 662  :     self = (PyDateTime_Date *) (type->tp_alloc(type, 0));

  00016	33 d2		 xor	 edx, edx
  00018	48 8b 4c 24 58	 mov	 rcx, QWORD PTR type$[rsp]
  0001d	48 8b 44 24 58	 mov	 rax, QWORD PTR type$[rsp]
  00022	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00028	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 663  :     if (self != NULL)

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  00033	74 18		 je	 SHORT $LN1@new_date_e

; 664  :         set_date_fields(self, year, month, day);

  00035	44 8b 4c 24 50	 mov	 r9d, DWORD PTR day$[rsp]
  0003a	44 8b 44 24 48	 mov	 r8d, DWORD PTR month$[rsp]
  0003f	8b 54 24 40	 mov	 edx, DWORD PTR year$[rsp]
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00048	e8 00 00 00 00	 call	 set_date_fields
$LN1@new_date_e:

; 665  :     return (PyObject *) self;

  0004d	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]

; 666  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
new_date_ex ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT set_date_fields
_TEXT	SEGMENT
self$ = 8
y$ = 16
m$ = 24
d$ = 32
set_date_fields PROC					; COMDAT

; 645  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 646  :     self->hashcode = -1;

  00013	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1

; 647  :     SET_YEAR(self, y);

  00020	8b 44 24 10	 mov	 eax, DWORD PTR y$[rsp]
  00024	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00029	c1 f8 08	 sar	 eax, 8
  0002c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR self$[rsp]
  00031	88 41 69	 mov	 BYTE PTR [rcx+105], al
  00034	8b 44 24 10	 mov	 eax, DWORD PTR y$[rsp]
  00038	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR self$[rsp]
  00042	88 41 6a	 mov	 BYTE PTR [rcx+106], al

; 648  :     SET_MONTH(self, m);

  00045	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  0004a	0f b6 4c 24 18	 movzx	 ecx, BYTE PTR m$[rsp]
  0004f	88 48 6b	 mov	 BYTE PTR [rax+107], cl

; 649  :     SET_DAY(self, d);

  00052	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  00057	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR d$[rsp]
  0005c	88 48 6c	 mov	 BYTE PTR [rax+108], cl

; 650  : }

  0005f	c3		 ret	 0
set_date_fields ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_datetime_ex DD imagerel new_datetime_ex
	DD	imagerel new_datetime_ex+305
	DD	imagerel $unwind$new_datetime_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_datetime_ex DD 011601H
	DD	08216H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT new_datetime_ex
_TEXT	SEGMENT
aware$ = 32
self$ = 40
tv65 = 48
year$ = 80
month$ = 88
day$ = 96
hour$ = 104
minute$ = 112
second$ = 120
usecond$ = 128
tzinfo$ = 136
type$ = 144
new_datetime_ex PROC					; COMDAT

; 675  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 676  :     PyDateTime_DateTime *self;
; 677  :     char aware = tzinfo != Py_None;

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001d	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR tzinfo$[rsp], rax
  00025	74 0a		 je	 SHORT $LN5@new_dateti
  00027	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0002f	eb 08		 jmp	 SHORT $LN6@new_dateti
$LN5@new_dateti:
  00031	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN6@new_dateti:
  00039	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv65[rsp]
  0003e	88 44 24 20	 mov	 BYTE PTR aware$[rsp], al

; 678  : 
; 679  :     self = (PyDateTime_DateTime *) (type->tp_alloc(type, aware));

  00042	48 0f be 44 24
	20		 movsx	 rax, BYTE PTR aware$[rsp]
  00048	48 8b d0	 mov	 rdx, rax
  0004b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  00053	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  0005b	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00061	48 89 44 24 28	 mov	 QWORD PTR self$[rsp], rax

; 680  :     if (self != NULL) {

  00066	48 83 7c 24 28
	00		 cmp	 QWORD PTR self$[rsp], 0
  0006c	0f 84 b5 00 00
	00		 je	 $LN2@new_dateti

; 681  :         self->hastzinfo = aware;

  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  00077	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR aware$[rsp]
  0007c	88 48 68	 mov	 BYTE PTR [rax+104], cl

; 682  :         set_date_fields((PyDateTime_Date *)self, year, month, day);

  0007f	44 8b 4c 24 60	 mov	 r9d, DWORD PTR day$[rsp]
  00084	44 8b 44 24 58	 mov	 r8d, DWORD PTR month$[rsp]
  00089	8b 54 24 50	 mov	 edx, DWORD PTR year$[rsp]
  0008d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  00092	e8 00 00 00 00	 call	 set_date_fields

; 683  :         DATE_SET_HOUR(self, hour);

  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  0009c	0f b6 4c 24 68	 movzx	 ecx, BYTE PTR hour$[rsp]
  000a1	88 48 6d	 mov	 BYTE PTR [rax+109], cl

; 684  :         DATE_SET_MINUTE(self, minute);

  000a4	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  000a9	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR minute$[rsp]
  000ae	88 48 6e	 mov	 BYTE PTR [rax+110], cl

; 685  :         DATE_SET_SECOND(self, second);

  000b1	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  000b6	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR second$[rsp]
  000bb	88 48 6f	 mov	 BYTE PTR [rax+111], cl

; 686  :         DATE_SET_MICROSECOND(self, usecond);

  000be	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR usecond$[rsp]
  000c5	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  000ca	c1 f8 10	 sar	 eax, 16
  000cd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  000d2	88 41 70	 mov	 BYTE PTR [rcx+112], al
  000d5	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR usecond$[rsp]
  000dc	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  000e1	c1 f8 08	 sar	 eax, 8
  000e4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  000e9	88 41 71	 mov	 BYTE PTR [rcx+113], al
  000ec	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR usecond$[rsp]
  000f3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  000fd	88 41 72	 mov	 BYTE PTR [rcx+114], al

; 687  :         if (aware) {

  00100	0f be 44 24 20	 movsx	 eax, BYTE PTR aware$[rsp]
  00105	85 c0		 test	 eax, eax
  00107	74 1e		 je	 SHORT $LN1@new_dateti

; 688  :             Py_INCREF(tzinfo);

  00109	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00111	e8 00 00 00 00	 call	 _Py_IncRef

; 689  :             self->tzinfo = tzinfo;

  00116	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  0011b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00123	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx
$LN1@new_dateti:
$LN2@new_dateti:

; 690  :         }
; 691  :     }
; 692  :     return (PyObject *)self;

  00127	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]

; 693  : }

  0012c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00130	c3		 ret	 0
new_datetime_ex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\_datetimemodule.c
pdata	SEGMENT
$pdata$new_time_ex DD imagerel new_time_ex
	DD	imagerel new_time_ex+270
	DD	imagerel $unwind$new_time_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_time_ex DD 011601H
	DD	08216H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT new_time_ex
_TEXT	SEGMENT
aware$ = 32
self$ = 40
tv65 = 48
hour$ = 80
minute$ = 88
second$ = 96
usecond$ = 104
tzinfo$ = 112
type$ = 120
new_time_ex PROC					; COMDAT

; 703  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 704  :     PyDateTime_Time *self;
; 705  :     char aware = tzinfo != Py_None;

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001d	48 39 44 24 70	 cmp	 QWORD PTR tzinfo$[rsp], rax
  00022	74 0a		 je	 SHORT $LN5@new_time_e
  00024	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0002c	eb 08		 jmp	 SHORT $LN6@new_time_e
$LN5@new_time_e:
  0002e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN6@new_time_e:
  00036	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv65[rsp]
  0003b	88 44 24 20	 mov	 BYTE PTR aware$[rsp], al

; 706  : 
; 707  :     self = (PyDateTime_Time *) (type->tp_alloc(type, aware));

  0003f	48 0f be 44 24
	20		 movsx	 rax, BYTE PTR aware$[rsp]
  00045	48 8b d0	 mov	 rdx, rax
  00048	48 8b 4c 24 78	 mov	 rcx, QWORD PTR type$[rsp]
  0004d	48 8b 44 24 78	 mov	 rax, QWORD PTR type$[rsp]
  00052	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00058	48 89 44 24 28	 mov	 QWORD PTR self$[rsp], rax

; 708  :     if (self != NULL) {

  0005d	48 83 7c 24 28
	00		 cmp	 QWORD PTR self$[rsp], 0
  00063	0f 84 9b 00 00
	00		 je	 $LN2@new_time_e

; 709  :         self->hastzinfo = aware;

  00069	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  0006e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR aware$[rsp]
  00073	88 48 68	 mov	 BYTE PTR [rax+104], cl

; 710  :         self->hashcode = -1;

  00076	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  0007b	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1

; 711  :         TIME_SET_HOUR(self, hour);

  00083	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  00088	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR hour$[rsp]
  0008d	88 48 69	 mov	 BYTE PTR [rax+105], cl

; 712  :         TIME_SET_MINUTE(self, minute);

  00090	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  00095	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR minute$[rsp]
  0009a	88 48 6a	 mov	 BYTE PTR [rax+106], cl

; 713  :         TIME_SET_SECOND(self, second);

  0009d	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  000a2	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR second$[rsp]
  000a7	88 48 6b	 mov	 BYTE PTR [rax+107], cl

; 714  :         TIME_SET_MICROSECOND(self, usecond);

  000aa	8b 44 24 68	 mov	 eax, DWORD PTR usecond$[rsp]
  000ae	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  000b3	c1 f8 10	 sar	 eax, 16
  000b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  000bb	88 41 6c	 mov	 BYTE PTR [rcx+108], al
  000be	8b 44 24 68	 mov	 eax, DWORD PTR usecond$[rsp]
  000c2	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  000c7	c1 f8 08	 sar	 eax, 8
  000ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  000cf	88 41 6d	 mov	 BYTE PTR [rcx+109], al
  000d2	8b 44 24 68	 mov	 eax, DWORD PTR usecond$[rsp]
  000d6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000db	48 8b 4c 24 28	 mov	 rcx, QWORD PTR self$[rsp]
  000e0	88 41 6e	 mov	 BYTE PTR [rcx+110], al

; 715  :         if (aware) {

  000e3	0f be 44 24 20	 movsx	 eax, BYTE PTR aware$[rsp]
  000e8	85 c0		 test	 eax, eax
  000ea	74 18		 je	 SHORT $LN1@new_time_e

; 716  :             Py_INCREF(tzinfo);

  000ec	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  000f1	e8 00 00 00 00	 call	 _Py_IncRef

; 717  :             self->tzinfo = tzinfo;

  000f6	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  000fb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00100	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
$LN1@new_time_e:
$LN2@new_time_e:

; 718  :         }
; 719  :     }
; 720  :     return (PyObject *)self;

  00104	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]

; 721  : }

  00109	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010d	c3		 ret	 0
new_time_ex ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FI@KACGPDLI@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd@ ; `string'
PUBLIC	??_C@_1EE@MBFAEOCO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0@ ; `string'
PUBLIC	??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_delta_ex DD imagerel new_delta_ex
	DD	imagerel new_delta_ex+246
	DD	imagerel $unwind$new_delta_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_delta_ex DD 011601H
	DD	06216H
xdata	ENDS
;	COMDAT ??_C@_1FI@KACGPDLI@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd@
CONST	SEGMENT
??_C@_1FI@KACGPDLI@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'm', 00H, 'i', 00H
	DB	'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'e', 00H, 'c', 00H, 'o'
	DB	00H, 'n', 00H, 'd', 00H, 's', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's'
	DB	00H, 'e', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'd', 00H, 's', 00H
	DB	' ', 00H, '<', 00H, ' ', 00H, '1', 00H, '0', 00H, '0', 00H, '0'
	DB	00H, '0', 00H, '0', 00H, '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@MBFAEOCO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0@
CONST	SEGMENT
??_C@_1EE@MBFAEOCO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 's', 00H, 'e', 00H
	DB	'c', 00H, 'o', 00H, 'n', 00H, 'd', 00H, 's', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'c', 00H, 'o', 00H
	DB	'n', 00H, 'd', 00H, 's', 00H, ' ', 00H, '<', 00H, ' ', 00H, '2'
	DB	00H, '4', 00H, '*', 00H, '3', 00H, '6', 00H, '0', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, '_', 00H, 'd', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'e', 00H
	DB	'm', 00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, '.'
	DB	00H, 'c', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT new_delta_ex
_TEXT	SEGMENT
self$ = 32
days$ = 64
seconds$ = 72
microseconds$ = 80
normalize$ = 88
type$ = 96
new_delta_ex PROC					; COMDAT

; 735  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 736  :     PyDateTime_Delta *self;
; 737  : 
; 738  :     if (normalize)

  00016	83 7c 24 58 00	 cmp	 DWORD PTR normalize$[rsp], 0
  0001b	74 14		 je	 SHORT $LN3@new_delta_

; 739  :         normalize_d_s_us(&days, &seconds, &microseconds);

  0001d	4c 8d 44 24 50	 lea	 r8, QWORD PTR microseconds$[rsp]
  00022	48 8d 54 24 48	 lea	 rdx, QWORD PTR seconds$[rsp]
  00027	48 8d 4c 24 40	 lea	 rcx, QWORD PTR days$[rsp]
  0002c	e8 00 00 00 00	 call	 normalize_d_s_us
$LN3@new_delta_:

; 740  :     assert(0 <= seconds && seconds < 24*3600);

  00031	83 7c 24 48 00	 cmp	 DWORD PTR seconds$[rsp], 0
  00036	7c 0a		 jl	 SHORT $LN6@new_delta_
  00038	81 7c 24 48 80
	51 01 00	 cmp	 DWORD PTR seconds$[rsp], 86400 ; 00015180H
  00040	7c 1c		 jl	 SHORT $LN7@new_delta_
$LN6@new_delta_:
  00042	41 b8 e4 02 00
	00		 mov	 r8d, 740		; 000002e4H
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@MBFAEOCO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0@
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005c	33 c0		 xor	 eax, eax
$LN7@new_delta_:

; 741  :     assert(0 <= microseconds && microseconds < 1000000);

  0005e	83 7c 24 50 00	 cmp	 DWORD PTR microseconds$[rsp], 0
  00063	7c 0a		 jl	 SHORT $LN8@new_delta_
  00065	81 7c 24 50 40
	42 0f 00	 cmp	 DWORD PTR microseconds$[rsp], 1000000 ; 000f4240H
  0006d	7c 1c		 jl	 SHORT $LN9@new_delta_
$LN8@new_delta_:
  0006f	41 b8 e5 02 00
	00		 mov	 r8d, 741		; 000002e5H
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FI@KACGPDLI@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd@
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00089	33 c0		 xor	 eax, eax
$LN9@new_delta_:

; 742  : 
; 743  :     if (check_delta_day_range(days) < 0)

  0008b	8b 4c 24 40	 mov	 ecx, DWORD PTR days$[rsp]
  0008f	e8 00 00 00 00	 call	 check_delta_day_range
  00094	85 c0		 test	 eax, eax
  00096	7d 04		 jge	 SHORT $LN2@new_delta_

; 744  :         return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	eb 55		 jmp	 SHORT $LN4@new_delta_
$LN2@new_delta_:

; 745  : 
; 746  :     self = (PyDateTime_Delta *) (type->tp_alloc(type, 0));

  0009c	33 d2		 xor	 edx, edx
  0009e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR type$[rsp]
  000a3	48 8b 44 24 60	 mov	 rax, QWORD PTR type$[rsp]
  000a8	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  000ae	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 747  :     if (self != NULL) {

  000b3	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  000b9	74 31		 je	 SHORT $LN1@new_delta_

; 748  :         self->hashcode = -1;

  000bb	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000c0	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1

; 749  :         SET_TD_DAYS(self, days);

  000c8	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000cd	8b 4c 24 40	 mov	 ecx, DWORD PTR days$[rsp]
  000d1	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 750  :         SET_TD_SECONDS(self, seconds);

  000d4	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000d9	8b 4c 24 48	 mov	 ecx, DWORD PTR seconds$[rsp]
  000dd	89 48 6c	 mov	 DWORD PTR [rax+108], ecx

; 751  :         SET_TD_MICROSECONDS(self, microseconds);

  000e0	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000e5	8b 4c 24 50	 mov	 ecx, DWORD PTR microseconds$[rsp]
  000e9	89 48 70	 mov	 DWORD PTR [rax+112], ecx
$LN1@new_delta_:

; 752  :     }
; 753  :     return (PyObject *) self;

  000ec	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
$LN4@new_delta_:

; 754  : }

  000f1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f5	c3		 ret	 0
new_delta_ex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@GIAJIAD@days?$DN?$CFd?$DL?5must?5have?5magnitude?5?$DM?$DN?5@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_delta_day_range DD imagerel check_delta_day_range
	DD	imagerel check_delta_day_range+72
	DD	imagerel $unwind$check_delta_day_range
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_delta_day_range DD 010801H
	DD	04208H
xdata	ENDS
;	COMDAT ??_C@_0CD@GIAJIAD@days?$DN?$CFd?$DL?5must?5have?5magnitude?5?$DM?$DN?5@
CONST	SEGMENT
??_C@_0CD@GIAJIAD@days?$DN?$CFd?$DL?5must?5have?5magnitude?5?$DM?$DN?5@ DB 'd'
	DB	'ays=%d; must have magnitude <= %d', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT check_delta_day_range
_TEXT	SEGMENT
days$ = 48
check_delta_day_range PROC				; COMDAT

; 378  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 379  :     if (-MAX_DELTA_DAYS <= days && days <= MAX_DELTA_DAYS)

  00008	81 7c 24 30 01
	36 65 c4	 cmp	 DWORD PTR days$[rsp], -999999999 ; ffffffffc4653601H
  00010	7c 0e		 jl	 SHORT $LN1@check_delt
  00012	81 7c 24 30 ff
	c9 9a 3b	 cmp	 DWORD PTR days$[rsp], 999999999 ; 3b9ac9ffH
  0001a	7f 04		 jg	 SHORT $LN1@check_delt

; 380  :         return 0;

  0001c	33 c0		 xor	 eax, eax
  0001e	eb 23		 jmp	 SHORT $LN2@check_delt
$LN1@check_delt:

; 381  :     PyErr_Format(PyExc_OverflowError,
; 382  :                  "days=%d; must have magnitude <= %d",
; 383  :                  days, MAX_DELTA_DAYS);

  00020	41 b9 ff c9 9a
	3b		 mov	 r9d, 999999999		; 3b9ac9ffH
  00026	44 8b 44 24 30	 mov	 r8d, DWORD PTR days$[rsp]
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@GIAJIAD@days?$DN?$CFd?$DL?5must?5have?5magnitude?5?$DM?$DN?5@
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00039	e8 00 00 00 00	 call	 PyErr_Format

; 384  :     return -1;

  0003e	b8 ff ff ff ff	 mov	 eax, -1
$LN2@check_delt:

; 385  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
check_delta_day_range ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@DFJLENKG@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAu?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAu?$AAs?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@GMKBNAPO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAs?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize_d_s_us DD imagerel normalize_d_s_us
	DD	imagerel normalize_d_s_us+214
	DD	imagerel $unwind$normalize_d_s_us
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize_d_s_us DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_1DE@DFJLENKG@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAu?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAu?$AAs?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@DFJLENKG@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAu?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAu?$AAs?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '*', 00H, 'u', 00H
	DB	's', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '*', 00H, 'u'
	DB	00H, 's', 00H, ' ', 00H, '<', 00H, ' ', 00H, '1', 00H, '0', 00H
	DB	'0', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@GMKBNAPO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAs?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@GMKBNAPO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAs?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0?$AA0?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '*', 00H, 's', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '*', 00H, 's', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, '2', 00H, '4', 00H, '*', 00H, '3', 00H
	DB	'6', 00H, '0', 00H, '0', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT normalize_d_s_us
_TEXT	SEGMENT
d$ = 48
s$ = 56
us$ = 64
normalize_d_s_us PROC					; COMDAT

; 473  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 474  :     if (*us < 0 || *us >= 1000000) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR us$[rsp]
  00018	83 38 00	 cmp	 DWORD PTR [rax], 0
  0001b	7c 0d		 jl	 SHORT $LN3@normalize_
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR us$[rsp]
  00022	81 38 40 42 0f
	00		 cmp	 DWORD PTR [rax], 1000000 ; 000f4240H
  00028	7c 15		 jl	 SHORT $LN4@normalize_
$LN3@normalize_:

; 475  :         normalize_pair(s, us, 1000000);

  0002a	41 b8 40 42 0f
	00		 mov	 r8d, 1000000		; 000f4240H
  00030	48 8b 54 24 40	 mov	 rdx, QWORD PTR us$[rsp]
  00035	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0003a	e8 00 00 00 00	 call	 normalize_pair
$LN4@normalize_:

; 476  :         /* |s| can't be bigger than about
; 477  :          * |original s| + |original us|/1000000 now.
; 478  :          */
; 479  : 
; 480  :     }
; 481  :     if (*s < 0 || *s >= 24*3600) {

  0003f	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00044	83 38 00	 cmp	 DWORD PTR [rax], 0
  00047	7c 0d		 jl	 SHORT $LN1@normalize_
  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0004e	81 38 80 51 01
	00		 cmp	 DWORD PTR [rax], 86400	; 00015180H
  00054	7c 15		 jl	 SHORT $LN2@normalize_
$LN1@normalize_:

; 482  :         normalize_pair(d, s, 24*3600);

  00056	41 b8 80 51 01
	00		 mov	 r8d, 86400		; 00015180H
  0005c	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$[rsp]
  00061	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00066	e8 00 00 00 00	 call	 normalize_pair
$LN2@normalize_:

; 483  :         /* |d| can't be bigger than about
; 484  :          * |original d| +
; 485  :          * (|original s| + |original us|/1000000) / (24*3600) now.
; 486  :          */
; 487  :     }
; 488  :     assert(0 <= *s && *s < 24*3600);

  0006b	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00070	83 38 00	 cmp	 DWORD PTR [rax], 0
  00073	7c 0d		 jl	 SHORT $LN7@normalize_
  00075	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0007a	81 38 80 51 01
	00		 cmp	 DWORD PTR [rax], 86400	; 00015180H
  00080	7c 1c		 jl	 SHORT $LN8@normalize_
$LN7@normalize_:
  00082	41 b8 e8 01 00
	00		 mov	 r8d, 488		; 000001e8H
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@GMKBNAPO@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAs?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0?$AA0?$AA?$AA@
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009c	33 c0		 xor	 eax, eax
$LN8@normalize_:

; 489  :     assert(0 <= *us && *us < 1000000);

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR us$[rsp]
  000a3	83 38 00	 cmp	 DWORD PTR [rax], 0
  000a6	7c 0d		 jl	 SHORT $LN9@normalize_
  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR us$[rsp]
  000ad	81 38 40 42 0f
	00		 cmp	 DWORD PTR [rax], 1000000 ; 000f4240H
  000b3	7c 1c		 jl	 SHORT $LN10@normalize_
$LN9@normalize_:
  000b5	41 b8 e9 01 00
	00		 mov	 r8d, 489		; 000001e9H
  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@DFJLENKG@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAu?$AAs?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAu?$AAs?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000cf	33 c0		 xor	 eax, eax
$LN10@normalize_:

; 490  : }

  000d1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d5	c3		 ret	 0
normalize_d_s_us ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DC@BOICJFGB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAl?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAl?$AAo?$AA?5?$AA?$DM?$AA?5?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FK@FBOFMDGA@?$AA?$CB?$AA?5?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAA?$AAD?$AAD?$AA_?$AAO?$AAV?$AAE?$AAR?$AAF?$AAL?$AAO?$AAW?$AAE?$AAD?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAh?$AAi?$AA?0?$AA?5@ ; `string'
PUBLIC	??_C@_1BC@FMHPNKHK@?$AAl?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAh?$AAi?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@BBCKBPNA@?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize_pair DD imagerel normalize_pair
	DD	imagerel normalize_pair+285
	DD	imagerel $unwind$normalize_pair
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize_pair DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1DC@BOICJFGB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAl?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAl?$AAo?$AA?5?$AA?$DM?$AA?5?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@BOICJFGB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAl?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAl?$AAo?$AA?5?$AA?$DM?$AA?5?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '*', 00H, 'l', 00H
	DB	'o', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '*', 00H, 'l'
	DB	00H, 'o', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'f', 00H, 'a', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FK@FBOFMDGA@?$AA?$CB?$AA?5?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAA?$AAD?$AAD?$AA_?$AAO?$AAV?$AAE?$AAR?$AAF?$AAL?$AAO?$AAW?$AAE?$AAD?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAh?$AAi?$AA?0?$AA?5@
CONST	SEGMENT
??_C@_1FK@FBOFMDGA@?$AA?$CB?$AA?5?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAA?$AAD?$AAD?$AA_?$AAO?$AAV?$AAE?$AAR?$AAF?$AAL?$AAO?$AAW?$AAE?$AAD?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAh?$AAi?$AA?0?$AA?5@ DB '!'
	DB	00H, ' ', 00H, 'S', 00H, 'I', 00H, 'G', 00H, 'N', 00H, 'E', 00H
	DB	'D', 00H, '_', 00H, 'A', 00H, 'D', 00H, 'D', 00H, '_', 00H, 'O'
	DB	00H, 'V', 00H, 'E', 00H, 'R', 00H, 'F', 00H, 'L', 00H, 'O', 00H
	DB	'W', 00H, 'E', 00H, 'D', 00H, '(', 00H, 'n', 00H, 'e', 00H, 'w'
	DB	00H, '_', 00H, 'h', 00H, 'i', 00H, ',', 00H, ' ', 00H, '*', 00H
	DB	'h', 00H, 'i', 00H, ',', 00H, ' ', 00H, 'n', 00H, 'u', 00H, 'm'
	DB	00H, '_', 00H, 'h', 00H, 'i', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@FMHPNKHK@?$AAl?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAh?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@FMHPNKHK@?$AAl?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAh?$AAi?$AA?$AA@ DB 'l'
	DB	00H, 'o', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'h', 00H
	DB	'i', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@BBCKBPNA@?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@BBCKBPNA@?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'f'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT normalize_pair
_TEXT	SEGMENT
new_hi$20681 = 32
num_hi$20680 = 36
hi$ = 64
lo$ = 72
factor$ = 80
normalize_pair PROC					; COMDAT

; 453  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 454  :     assert(factor > 0);

  00013	83 7c 24 50 00	 cmp	 DWORD PTR factor$[rsp], 0
  00018	7f 1c		 jg	 SHORT $LN5@normalize_@2
  0001a	41 b8 c6 01 00
	00		 mov	 r8d, 454		; 000001c6H
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@BBCKBPNA@?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00034	33 c0		 xor	 eax, eax
$LN5@normalize_@2:

; 455  :     assert(lo != hi);

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR hi$[rsp]
  0003b	48 39 44 24 48	 cmp	 QWORD PTR lo$[rsp], rax
  00040	75 1c		 jne	 SHORT $LN6@normalize_@2
  00042	41 b8 c7 01 00
	00		 mov	 r8d, 455		; 000001c7H
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@FMHPNKHK@?$AAl?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAh?$AAi?$AA?$AA@
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005c	33 c0		 xor	 eax, eax
$LN6@normalize_@2:

; 456  :     if (*lo < 0 || *lo >= factor) {

  0005e	48 8b 44 24 48	 mov	 rax, QWORD PTR lo$[rsp]
  00063	83 38 00	 cmp	 DWORD PTR [rax], 0
  00066	7c 0d		 jl	 SHORT $LN1@normalize_@2
  00068	48 8b 44 24 48	 mov	 rax, QWORD PTR lo$[rsp]
  0006d	8b 4c 24 50	 mov	 ecx, DWORD PTR factor$[rsp]
  00071	39 08		 cmp	 DWORD PTR [rax], ecx
  00073	7c 70		 jl	 SHORT $LN2@normalize_@2
$LN1@normalize_@2:

; 457  :         const int num_hi = divmod(*lo, factor, lo);

  00075	4c 8b 44 24 48	 mov	 r8, QWORD PTR lo$[rsp]
  0007a	8b 54 24 50	 mov	 edx, DWORD PTR factor$[rsp]
  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR lo$[rsp]
  00083	8b 08		 mov	 ecx, DWORD PTR [rax]
  00085	e8 00 00 00 00	 call	 divmod
  0008a	89 44 24 24	 mov	 DWORD PTR num_hi$20680[rsp], eax

; 458  :         const int new_hi = *hi + num_hi;

  0008e	48 8b 44 24 40	 mov	 rax, QWORD PTR hi$[rsp]
  00093	8b 00		 mov	 eax, DWORD PTR [rax]
  00095	03 44 24 24	 add	 eax, DWORD PTR num_hi$20680[rsp]
  00099	89 44 24 20	 mov	 DWORD PTR new_hi$20681[rsp], eax

; 459  :         assert(! SIGNED_ADD_OVERFLOWED(new_hi, *hi, num_hi));

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR hi$[rsp]
  000a2	8b 00		 mov	 eax, DWORD PTR [rax]
  000a4	8b 4c 24 20	 mov	 ecx, DWORD PTR new_hi$20681[rsp]
  000a8	33 c8		 xor	 ecx, eax
  000aa	8b c1		 mov	 eax, ecx
  000ac	8b 4c 24 24	 mov	 ecx, DWORD PTR num_hi$20680[rsp]
  000b0	8b 54 24 20	 mov	 edx, DWORD PTR new_hi$20681[rsp]
  000b4	33 d1		 xor	 edx, ecx
  000b6	8b ca		 mov	 ecx, edx
  000b8	23 c1		 and	 eax, ecx
  000ba	85 c0		 test	 eax, eax
  000bc	7d 1c		 jge	 SHORT $LN7@normalize_@2
  000be	41 b8 cb 01 00
	00		 mov	 r8d, 459		; 000001cbH
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FK@FBOFMDGA@?$AA?$CB?$AA?5?$AAS?$AAI?$AAG?$AAN?$AAE?$AAD?$AA_?$AAA?$AAD?$AAD?$AA_?$AAO?$AAV?$AAE?$AAR?$AAF?$AAL?$AAO?$AAW?$AAE?$AAD?$AA?$CI?$AAn?$AAe?$AAw?$AA_?$AAh?$AAi?$AA?0?$AA?5@
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d8	33 c0		 xor	 eax, eax
$LN7@normalize_@2:

; 460  :         *hi = new_hi;

  000da	48 8b 44 24 40	 mov	 rax, QWORD PTR hi$[rsp]
  000df	8b 4c 24 20	 mov	 ecx, DWORD PTR new_hi$20681[rsp]
  000e3	89 08		 mov	 DWORD PTR [rax], ecx
$LN2@normalize_@2:

; 461  :     }
; 462  :     assert(0 <= *lo && *lo < factor);

  000e5	48 8b 44 24 48	 mov	 rax, QWORD PTR lo$[rsp]
  000ea	83 38 00	 cmp	 DWORD PTR [rax], 0
  000ed	7c 0d		 jl	 SHORT $LN8@normalize_@2
  000ef	48 8b 44 24 48	 mov	 rax, QWORD PTR lo$[rsp]
  000f4	8b 4c 24 50	 mov	 ecx, DWORD PTR factor$[rsp]
  000f8	39 08		 cmp	 DWORD PTR [rax], ecx
  000fa	7c 1c		 jl	 SHORT $LN9@normalize_@2
$LN8@normalize_@2:
  000fc	41 b8 ce 01 00
	00		 mov	 r8d, 462		; 000001ceH
  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@BOICJFGB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAl?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAl?$AAo?$AA?5?$AA?$DM?$AA?5?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?$AA@
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00116	33 c0		 xor	 eax, eax
$LN9@normalize_@2:

; 463  : }

  00118	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0011c	c3		 ret	 0
normalize_pair ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@HJNDIGKD@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAr?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAr?$AA?5?$AA?$DM?$AA?5?$AAy?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@BFFEDNPN@?$AAy?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$divmod DD imagerel divmod
	DD	imagerel divmod+187
	DD	imagerel $unwind$divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$divmod DD 011101H
	DD	06211H
xdata	ENDS
;	COMDAT ??_C@_1CE@HJNDIGKD@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAr?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAr?$AA?5?$AA?$DM?$AA?5?$AAy?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@HJNDIGKD@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAr?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAr?$AA?5?$AA?$DM?$AA?5?$AAy?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '*', 00H, 'r', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '*', 00H, 'r', 00H, ' '
	DB	00H, '<', 00H, ' ', 00H, 'y', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@BFFEDNPN@?$AAy?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1M@BFFEDNPN@?$AAy?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'y', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT divmod
_TEXT	SEGMENT
quo$ = 32
x$ = 64
y$ = 72
r$ = 80
divmod	PROC						; COMDAT

; 129  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 130  :     int quo;
; 131  : 
; 132  :     assert(y > 0);

  00011	83 7c 24 48 00	 cmp	 DWORD PTR y$[rsp], 0
  00016	7f 1c		 jg	 SHORT $LN4@divmod
  00018	41 b8 84 00 00
	00		 mov	 r8d, 132		; 00000084H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1M@BFFEDNPN@?$AAy?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00032	33 c0		 xor	 eax, eax
$LN4@divmod:

; 133  :     quo = x / y;

  00034	8b 44 24 40	 mov	 eax, DWORD PTR x$[rsp]
  00038	99		 cdq
  00039	f7 7c 24 48	 idiv	 DWORD PTR y$[rsp]
  0003d	89 44 24 20	 mov	 DWORD PTR quo$[rsp], eax

; 134  :     *r = x - quo * y;

  00041	8b 44 24 20	 mov	 eax, DWORD PTR quo$[rsp]
  00045	0f af 44 24 48	 imul	 eax, DWORD PTR y$[rsp]
  0004a	8b 4c 24 40	 mov	 ecx, DWORD PTR x$[rsp]
  0004e	2b c8		 sub	 ecx, eax
  00050	8b c1		 mov	 eax, ecx
  00052	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$[rsp]
  00057	89 01		 mov	 DWORD PTR [rcx], eax

; 135  :     if (*r < 0) {

  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  0005e	83 38 00	 cmp	 DWORD PTR [rax], 0
  00061	7d 1c		 jge	 SHORT $LN1@divmod

; 136  :         --quo;

  00063	8b 44 24 20	 mov	 eax, DWORD PTR quo$[rsp]
  00067	ff c8		 dec	 eax
  00069	89 44 24 20	 mov	 DWORD PTR quo$[rsp], eax

; 137  :         *r += y;

  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  00072	8b 00		 mov	 eax, DWORD PTR [rax]
  00074	03 44 24 48	 add	 eax, DWORD PTR y$[rsp]
  00078	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$[rsp]
  0007d	89 01		 mov	 DWORD PTR [rcx], eax
$LN1@divmod:

; 138  :     }
; 139  :     assert(0 <= *r && *r < y);

  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  00084	83 38 00	 cmp	 DWORD PTR [rax], 0
  00087	7c 0d		 jl	 SHORT $LN5@divmod
  00089	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  0008e	8b 4c 24 48	 mov	 ecx, DWORD PTR y$[rsp]
  00092	39 08		 cmp	 DWORD PTR [rax], ecx
  00094	7c 1c		 jl	 SHORT $LN6@divmod
$LN5@divmod:
  00096	41 b8 8b 00 00
	00		 mov	 r8d, 139		; 0000008bH
  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@HJNDIGKD@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAr?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAr?$AA?5?$AA?$DM?$AA?5?$AAy?$AA?$AA@
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b0	33 c0		 xor	 eax, eax
$LN6@divmod:

; 140  :     return quo;

  000b2	8b 44 24 20	 mov	 eax, DWORD PTR quo$[rsp]

; 141  : }

  000b6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ba	c3		 ret	 0
divmod	ENDP
_TEXT	ENDS
EXTRN	PyType_IsSubtype:PROC
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_add DD imagerel delta_add
	DD	imagerel delta_add+251
	DD	imagerel $unwind$delta_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_add DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_add
_TEXT	SEGMENT
result$ = 48
days$21896 = 56
seconds$21899 = 60
microseconds$21902 = 64
left$ = 96
right$ = 104
delta_add PROC						; COMDAT

; 1727 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1728 :     PyObject *result = Py_NotImplemented;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00015	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1729 : 
; 1730 :     if (PyDelta_Check(left) && PyDelta_Check(right)) {

  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00021	48 8b 4c 24 60	 mov	 rcx, QWORD PTR left$[rsp]
  00026	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002a	74 1d		 je	 SHORT $LN3@delta_add
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR left$[rsp]
  00038	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00041	85 c0		 test	 eax, eax
  00043	0f 84 90 00 00
	00		 je	 $LN4@delta_add
$LN3@delta_add:
  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00050	48 8b 4c 24 68	 mov	 rcx, QWORD PTR right$[rsp]
  00055	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00059	74 19		 je	 SHORT $LN2@delta_add
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR right$[rsp]
  00067	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0006b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00070	85 c0		 test	 eax, eax
  00072	74 65		 je	 SHORT $LN4@delta_add
$LN2@delta_add:

; 1731 :         /* delta + delta */
; 1732 :         /* The C-level additions can't overflow because of the
; 1733 :          * invariant bounds.
; 1734 :          */
; 1735 :         int days = GET_TD_DAYS(left) + GET_TD_DAYS(right);

  00074	48 8b 44 24 60	 mov	 rax, QWORD PTR left$[rsp]
  00079	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0007c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR right$[rsp]
  00081	03 41 68	 add	 eax, DWORD PTR [rcx+104]
  00084	89 44 24 38	 mov	 DWORD PTR days$21896[rsp], eax

; 1736 :         int seconds = GET_TD_SECONDS(left) + GET_TD_SECONDS(right);

  00088	48 8b 44 24 60	 mov	 rax, QWORD PTR left$[rsp]
  0008d	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00090	48 8b 4c 24 68	 mov	 rcx, QWORD PTR right$[rsp]
  00095	03 41 6c	 add	 eax, DWORD PTR [rcx+108]
  00098	89 44 24 3c	 mov	 DWORD PTR seconds$21899[rsp], eax

; 1737 :         int microseconds = GET_TD_MICROSECONDS(left) +
; 1738 :                            GET_TD_MICROSECONDS(right);

  0009c	48 8b 44 24 60	 mov	 rax, QWORD PTR left$[rsp]
  000a1	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR right$[rsp]
  000a9	03 41 70	 add	 eax, DWORD PTR [rcx+112]
  000ac	89 44 24 40	 mov	 DWORD PTR microseconds$21902[rsp], eax

; 1739 :         result = new_delta(days, seconds, microseconds, 1);

  000b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  000b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bc	41 b9 01 00 00
	00		 mov	 r9d, 1
  000c2	44 8b 44 24 40	 mov	 r8d, DWORD PTR microseconds$21902[rsp]
  000c7	8b 54 24 3c	 mov	 edx, DWORD PTR seconds$21899[rsp]
  000cb	8b 4c 24 38	 mov	 ecx, DWORD PTR days$21896[rsp]
  000cf	e8 00 00 00 00	 call	 new_delta_ex
  000d4	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
$LN4@delta_add:

; 1740 :     }
; 1741 : 
; 1742 :     if (result == Py_NotImplemented)

  000d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000e0	48 39 44 24 30	 cmp	 QWORD PTR result$[rsp], rax
  000e5	75 0a		 jne	 SHORT $LN1@delta_add

; 1743 :         Py_INCREF(result);

  000e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  000ec	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@delta_add:

; 1744 :     return result;

  000f1	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 1745 : }

  000f6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000fa	c3		 ret	 0
delta_add ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_negative DD imagerel delta_negative
	DD	imagerel delta_negative+82
	DD	imagerel $unwind$delta_negative
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_negative DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_negative
_TEXT	SEGMENT
tv74 = 48
self$ = 80
delta_negative PROC					; COMDAT

; 1749 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1750 :     return new_delta(-GET_TD_DAYS(self),
; 1751 :                      -GET_TD_SECONDS(self),
; 1752 :                      -GET_TD_MICROSECONDS(self),
; 1753 :                      1);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00011	f7 d8		 neg	 eax
  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00018	8b 49 6c	 mov	 ecx, DWORD PTR [rcx+108]
  0001b	f7 d9		 neg	 ecx
  0001d	48 8b 54 24 50	 mov	 rdx, QWORD PTR self$[rsp]
  00022	8b 52 68	 mov	 edx, DWORD PTR [rdx+104]
  00025	f7 da		 neg	 edx
  00027	89 54 24 30	 mov	 DWORD PTR tv74[rsp], edx
  0002b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyDateTime_DeltaType
  00032	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00037	41 b9 01 00 00
	00		 mov	 r9d, 1
  0003d	44 8b c0	 mov	 r8d, eax
  00040	8b d1		 mov	 edx, ecx
  00042	8b 44 24 30	 mov	 eax, DWORD PTR tv74[rsp]
  00046	8b c8		 mov	 ecx, eax
  00048	e8 00 00 00 00	 call	 new_delta_ex

; 1754 : }

  0004d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00051	c3		 ret	 0
delta_negative ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_positive DD imagerel delta_positive
	DD	imagerel delta_positive+59
	DD	imagerel $unwind$delta_positive
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_positive DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_positive
_TEXT	SEGMENT
self$ = 64
delta_positive PROC					; COMDAT

; 1758 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1759 :     /* Could optimize this (by returning self) if this isn't a
; 1760 :      * subclass -- but who uses unary + ?  Approximately nobody.
; 1761 :      */
; 1762 :     return new_delta(GET_TD_DAYS(self),
; 1763 :                      GET_TD_SECONDS(self),
; 1764 :                      GET_TD_MICROSECONDS(self),
; 1765 :                      0);

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00010	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00015	45 33 c9	 xor	 r9d, r9d
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0001d	44 8b 40 70	 mov	 r8d, DWORD PTR [rax+112]
  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00026	8b 50 6c	 mov	 edx, DWORD PTR [rax+108]
  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002e	8b 48 68	 mov	 ecx, DWORD PTR [rax+104]
  00031	e8 00 00 00 00	 call	 new_delta_ex

; 1766 : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
delta_positive ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@DPFHFDHE@?$AAG?$AAE?$AAT?$AA_?$AAT?$AAD?$AA_?$AAS?$AAE?$AAC?$AAO?$AAN?$AAD?$AAS?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DO@LIIKIPFL@?$AAG?$AAE?$AAT?$AA_?$AAT?$AAD?$AA_?$AAM?$AAI?$AAC?$AAR?$AAO?$AAS?$AAE?$AAC?$AAO?$AAN?$AAD?$AAS?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_abs DD imagerel delta_abs
	DD	imagerel delta_abs+140
	DD	imagerel $unwind$delta_abs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_abs DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1DE@DPFHFDHE@?$AAG?$AAE?$AAT?$AA_?$AAT?$AAD?$AA_?$AAS?$AAE?$AAC?$AAO?$AAN?$AAD?$AAS?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@DPFHFDHE@?$AAG?$AAE?$AAT?$AA_?$AAT?$AAD?$AA_?$AAS?$AAE?$AAC?$AAO?$AAN?$AAD?$AAS?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'G'
	DB	00H, 'E', 00H, 'T', 00H, '_', 00H, 'T', 00H, 'D', 00H, '_', 00H
	DB	'S', 00H, 'E', 00H, 'C', 00H, 'O', 00H, 'N', 00H, 'D', 00H, 'S'
	DB	00H, '(', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'f', 00H, ')', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@LIIKIPFL@?$AAG?$AAE?$AAT?$AA_?$AAT?$AAD?$AA_?$AAM?$AAI?$AAC?$AAR?$AAO?$AAS?$AAE?$AAC?$AAO?$AAN?$AAD?$AAS?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@LIIKIPFL@?$AAG?$AAE?$AAT?$AA_?$AAT?$AAD?$AA_?$AAM?$AAI?$AAC?$AAR?$AAO?$AAS?$AAE?$AAC?$AAO?$AAN?$AAD?$AAS?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'G'
	DB	00H, 'E', 00H, 'T', 00H, '_', 00H, 'T', 00H, 'D', 00H, '_', 00H
	DB	'M', 00H, 'I', 00H, 'C', 00H, 'R', 00H, 'O', 00H, 'S', 00H, 'E'
	DB	00H, 'C', 00H, 'O', 00H, 'N', 00H, 'D', 00H, 'S', 00H, '(', 00H
	DB	's', 00H, 'e', 00H, 'l', 00H, 'f', 00H, ')', 00H, ' ', 00H, '>'
	DB	00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT delta_abs
_TEXT	SEGMENT
result$ = 32
self$ = 64
delta_abs PROC						; COMDAT

; 1770 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1771 :     PyObject *result;
; 1772 : 
; 1773 :     assert(GET_TD_MICROSECONDS(self) >= 0);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  00012	7d 1c		 jge	 SHORT $LN5@delta_abs
  00014	41 b8 ed 06 00
	00		 mov	 r8d, 1773		; 000006edH
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@LIIKIPFL@?$AAG?$AAE?$AAT?$AA_?$AAT?$AAD?$AA_?$AAM?$AAI?$AAC?$AAR?$AAO?$AAS?$AAE?$AAC?$AAO?$AAN?$AAD?$AAS?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002e	33 c0		 xor	 eax, eax
$LN5@delta_abs:

; 1774 :     assert(GET_TD_SECONDS(self) >= 0);

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00035	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00039	7d 1c		 jge	 SHORT $LN6@delta_abs
  0003b	41 b8 ee 06 00
	00		 mov	 r8d, 1774		; 000006eeH
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@DPFHFDHE@?$AAG?$AAE?$AAT?$AA_?$AAT?$AAD?$AA_?$AAS?$AAE?$AAC?$AAO?$AAN?$AAD?$AAS?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00055	33 c0		 xor	 eax, eax
$LN6@delta_abs:

; 1775 : 
; 1776 :     if (GET_TD_DAYS(self) < 0)

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0005c	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00060	7d 11		 jge	 SHORT $LN2@delta_abs

; 1777 :         result = delta_negative(self);

  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00067	e8 00 00 00 00	 call	 delta_negative
  0006c	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1778 :     else

  00071	eb 0f		 jmp	 SHORT $LN1@delta_abs
$LN2@delta_abs:

; 1779 :         result = delta_positive(self);

  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00078	e8 00 00 00 00	 call	 delta_positive
  0007d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN1@delta_abs:

; 1780 : 
; 1781 :     return result;

  00082	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 1782 : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
delta_abs ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_subtract DD imagerel delta_subtract
	DD	imagerel delta_subtract+257
	DD	imagerel $unwind$delta_subtract
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_subtract DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_subtract
_TEXT	SEGMENT
result$ = 48
days$21948 = 56
seconds$21951 = 60
microseconds$21954 = 64
left$ = 96
right$ = 104
delta_subtract PROC					; COMDAT

; 1786 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1787 :     PyObject *result = Py_NotImplemented;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00015	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1788 : 
; 1789 :     if (PyDelta_Check(left) && PyDelta_Check(right)) {

  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00021	48 8b 4c 24 60	 mov	 rcx, QWORD PTR left$[rsp]
  00026	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002a	74 1d		 je	 SHORT $LN3@delta_subt
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00033	48 8b 44 24 60	 mov	 rax, QWORD PTR left$[rsp]
  00038	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00041	85 c0		 test	 eax, eax
  00043	0f 84 96 00 00
	00		 je	 $LN4@delta_subt
$LN3@delta_subt:
  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00050	48 8b 4c 24 68	 mov	 rcx, QWORD PTR right$[rsp]
  00055	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00059	74 19		 je	 SHORT $LN2@delta_subt
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR right$[rsp]
  00067	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0006b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00070	85 c0		 test	 eax, eax
  00072	74 6b		 je	 SHORT $LN4@delta_subt
$LN2@delta_subt:

; 1790 :         /* delta - delta */
; 1791 :         /* The C-level additions can't overflow because of the
; 1792 :          * invariant bounds.
; 1793 :          */
; 1794 :         int days = GET_TD_DAYS(left) - GET_TD_DAYS(right);

  00074	48 8b 44 24 60	 mov	 rax, QWORD PTR left$[rsp]
  00079	48 8b 4c 24 68	 mov	 rcx, QWORD PTR right$[rsp]
  0007e	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  00081	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00084	2b c1		 sub	 eax, ecx
  00086	89 44 24 38	 mov	 DWORD PTR days$21948[rsp], eax

; 1795 :         int seconds = GET_TD_SECONDS(left) - GET_TD_SECONDS(right);

  0008a	48 8b 44 24 60	 mov	 rax, QWORD PTR left$[rsp]
  0008f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR right$[rsp]
  00094	8b 49 6c	 mov	 ecx, DWORD PTR [rcx+108]
  00097	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0009a	2b c1		 sub	 eax, ecx
  0009c	89 44 24 3c	 mov	 DWORD PTR seconds$21951[rsp], eax

; 1796 :         int microseconds = GET_TD_MICROSECONDS(left) -
; 1797 :                            GET_TD_MICROSECONDS(right);

  000a0	48 8b 44 24 60	 mov	 rax, QWORD PTR left$[rsp]
  000a5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR right$[rsp]
  000aa	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  000ad	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000b0	2b c1		 sub	 eax, ecx
  000b2	89 44 24 40	 mov	 DWORD PTR microseconds$21954[rsp], eax

; 1798 :         result = new_delta(days, seconds, microseconds, 1);

  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  000bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c2	41 b9 01 00 00
	00		 mov	 r9d, 1
  000c8	44 8b 44 24 40	 mov	 r8d, DWORD PTR microseconds$21954[rsp]
  000cd	8b 54 24 3c	 mov	 edx, DWORD PTR seconds$21951[rsp]
  000d1	8b 4c 24 38	 mov	 ecx, DWORD PTR days$21948[rsp]
  000d5	e8 00 00 00 00	 call	 new_delta_ex
  000da	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
$LN4@delta_subt:

; 1799 :     }
; 1800 : 
; 1801 :     if (result == Py_NotImplemented)

  000df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000e6	48 39 44 24 30	 cmp	 QWORD PTR result$[rsp], rax
  000eb	75 0a		 jne	 SHORT $LN1@delta_subt

; 1802 :         Py_INCREF(result);

  000ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  000f2	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@delta_subt:

; 1803 :     return result;

  000f7	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 1804 : }

  000fc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00100	c3		 ret	 0
delta_subtract ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_richcompare DD imagerel delta_richcompare
	DD	imagerel delta_richcompare+122
	DD	imagerel $unwind$delta_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_richcompare DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_richcompare
_TEXT	SEGMENT
diff$21986 = 32
self$ = 64
other$ = 72
op$ = 80
delta_richcompare PROC					; COMDAT

; 1821 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1822 :     if (PyDelta_Check(other)) {

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR other$[rsp]
  0001f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00023	74 19		 je	 SHORT $LN2@delta_rich
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0002c	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  00031	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00035	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003a	85 c0		 test	 eax, eax
  0003c	74 24		 je	 SHORT $LN3@delta_rich
$LN2@delta_rich:

; 1823 :         int diff = delta_cmp(self, other);

  0003e	48 8b 54 24 48	 mov	 rdx, QWORD PTR other$[rsp]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00048	e8 00 00 00 00	 call	 delta_cmp
  0004d	89 44 24 20	 mov	 DWORD PTR diff$21986[rsp], eax

; 1824 :         return diff_to_bool(diff, op);

  00051	8b 54 24 50	 mov	 edx, DWORD PTR op$[rsp]
  00055	8b 4c 24 20	 mov	 ecx, DWORD PTR diff$21986[rsp]
  00059	e8 00 00 00 00	 call	 diff_to_bool
  0005e	eb 15		 jmp	 SHORT $LN4@delta_rich

; 1825 :     }
; 1826 :     else {

  00060	eb 13		 jmp	 SHORT $LN1@delta_rich
$LN3@delta_rich:

; 1827 :         Py_RETURN_NOTIMPLEMENTED;

  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00069	e8 00 00 00 00	 call	 _Py_IncRef
  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN1@delta_rich:
$LN4@delta_rich:

; 1828 :     }
; 1829 : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
delta_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BO@MMMNONMK@?$AA?$CB?$AA?5?$AA?$CC?$AAo?$AAp?$AA?5?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_0L@JBGBGKIG@op?5unknown?$AA@		; `string'
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$diff_to_bool DD imagerel diff_to_bool
	DD	imagerel diff_to_bool+412
	DD	imagerel $unwind$diff_to_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$diff_to_bool DD 010c01H
	DD	0c20cH
xdata	ENDS
;	COMDAT ??_C@_1BO@MMMNONMK@?$AA?$CB?$AA?5?$AA?$CC?$AAo?$AAp?$AA?5?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MMMNONMK@?$AA?$CB?$AA?5?$AA?$CC?$AAo?$AAp?$AA?5?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$CC?$AA?$AA@ DB '!'
	DB	00H, ' ', 00H, '"', 00H, 'o', 00H, 'p', 00H, ' ', 00H, 'u', 00H
	DB	'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H, 'w', 00H, 'n', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JBGBGKIG@op?5unknown?$AA@
CONST	SEGMENT
??_C@_0L@JBGBGKIG@op?5unknown?$AA@ DB 'op unknown', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT diff_to_bool
_TEXT	SEGMENT
istrue$ = 32
result$ = 40
tv64 = 48
tv66 = 52
tv68 = 56
tv70 = 60
tv72 = 64
tv74 = 68
tv76 = 72
tv84 = 80
diff$ = 112
op$ = 120
diff_to_bool PROC					; COMDAT

; 1365 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1366 :     PyObject *result;
; 1367 :     int istrue;
; 1368 : 
; 1369 :     switch (op) {

  0000c	8b 44 24 78	 mov	 eax, DWORD PTR op$[rsp]
  00010	89 44 24 30	 mov	 DWORD PTR tv64[rsp], eax
  00014	83 7c 24 30 05	 cmp	 DWORD PTR tv64[rsp], 5
  00019	0f 87 f3 00 00
	00		 ja	 $LN1@diff_to_bo
  0001f	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv64[rsp]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0002b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN27@diff_to_bo[rcx+rax*4]
  00032	48 03 c1	 add	 rax, rcx
  00035	ff e0		 jmp	 rax
$LN7@diff_to_bo:

; 1370 :         case Py_EQ: istrue = diff == 0; break;

  00037	83 7c 24 70 00	 cmp	 DWORD PTR diff$[rsp], 0
  0003c	75 0a		 jne	 SHORT $LN12@diff_to_bo
  0003e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00046	eb 08		 jmp	 SHORT $LN13@diff_to_bo
$LN12@diff_to_bo:
  00048	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN13@diff_to_bo:
  00050	8b 44 24 34	 mov	 eax, DWORD PTR tv66[rsp]
  00054	89 44 24 20	 mov	 DWORD PTR istrue$[rsp], eax
  00058	e9 e5 00 00 00	 jmp	 $LN8@diff_to_bo
$LN6@diff_to_bo:

; 1371 :         case Py_NE: istrue = diff != 0; break;

  0005d	83 7c 24 70 00	 cmp	 DWORD PTR diff$[rsp], 0
  00062	74 0a		 je	 SHORT $LN14@diff_to_bo
  00064	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  0006c	eb 08		 jmp	 SHORT $LN15@diff_to_bo
$LN14@diff_to_bo:
  0006e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN15@diff_to_bo:
  00076	8b 44 24 38	 mov	 eax, DWORD PTR tv68[rsp]
  0007a	89 44 24 20	 mov	 DWORD PTR istrue$[rsp], eax
  0007e	e9 bf 00 00 00	 jmp	 $LN8@diff_to_bo
$LN5@diff_to_bo:

; 1372 :         case Py_LE: istrue = diff <= 0; break;

  00083	83 7c 24 70 00	 cmp	 DWORD PTR diff$[rsp], 0
  00088	7f 0a		 jg	 SHORT $LN16@diff_to_bo
  0008a	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00092	eb 08		 jmp	 SHORT $LN17@diff_to_bo
$LN16@diff_to_bo:
  00094	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN17@diff_to_bo:
  0009c	8b 44 24 3c	 mov	 eax, DWORD PTR tv70[rsp]
  000a0	89 44 24 20	 mov	 DWORD PTR istrue$[rsp], eax
  000a4	e9 99 00 00 00	 jmp	 $LN8@diff_to_bo
$LN4@diff_to_bo:

; 1373 :         case Py_GE: istrue = diff >= 0; break;

  000a9	83 7c 24 70 00	 cmp	 DWORD PTR diff$[rsp], 0
  000ae	7c 0a		 jl	 SHORT $LN18@diff_to_bo
  000b0	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  000b8	eb 08		 jmp	 SHORT $LN19@diff_to_bo
$LN18@diff_to_bo:
  000ba	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN19@diff_to_bo:
  000c2	8b 44 24 40	 mov	 eax, DWORD PTR tv72[rsp]
  000c6	89 44 24 20	 mov	 DWORD PTR istrue$[rsp], eax
  000ca	eb 76		 jmp	 SHORT $LN8@diff_to_bo
$LN3@diff_to_bo:

; 1374 :         case Py_LT: istrue = diff < 0; break;

  000cc	83 7c 24 70 00	 cmp	 DWORD PTR diff$[rsp], 0
  000d1	7d 0a		 jge	 SHORT $LN20@diff_to_bo
  000d3	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  000db	eb 08		 jmp	 SHORT $LN21@diff_to_bo
$LN20@diff_to_bo:
  000dd	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN21@diff_to_bo:
  000e5	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]
  000e9	89 44 24 20	 mov	 DWORD PTR istrue$[rsp], eax
  000ed	eb 53		 jmp	 SHORT $LN8@diff_to_bo
$LN2@diff_to_bo:

; 1375 :         case Py_GT: istrue = diff > 0; break;

  000ef	83 7c 24 70 00	 cmp	 DWORD PTR diff$[rsp], 0
  000f4	7e 0a		 jle	 SHORT $LN22@diff_to_bo
  000f6	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  000fe	eb 08		 jmp	 SHORT $LN23@diff_to_bo
$LN22@diff_to_bo:
  00100	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN23@diff_to_bo:
  00108	8b 44 24 48	 mov	 eax, DWORD PTR tv76[rsp]
  0010c	89 44 24 20	 mov	 DWORD PTR istrue$[rsp], eax
  00110	eb 30		 jmp	 SHORT $LN8@diff_to_bo
$LN1@diff_to_bo:

; 1376 :         default:
; 1377 :             assert(! "op unknown");

  00112	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0L@JBGBGKIG@op?5unknown?$AA@
  00119	48 85 c0	 test	 rax, rax
  0011c	74 1c		 je	 SHORT $LN24@diff_to_bo
  0011e	41 b8 61 05 00
	00		 mov	 r8d, 1377		; 00000561H
  00124	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0012b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@MMMNONMK@?$AA?$CB?$AA?5?$AA?$CC?$AAo?$AAp?$AA?5?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?$CC?$AA?$AA@
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00138	33 c0		 xor	 eax, eax
$LN24@diff_to_bo:

; 1378 :             istrue = 0; /* To shut up compiler */

  0013a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR istrue$[rsp], 0
$LN8@diff_to_bo:

; 1379 :     }
; 1380 :     result = istrue ? Py_True : Py_False;

  00142	83 7c 24 20 00	 cmp	 DWORD PTR istrue$[rsp], 0
  00147	74 0e		 je	 SHORT $LN25@diff_to_bo
  00149	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00150	48 89 44 24 50	 mov	 QWORD PTR tv84[rsp], rax
  00155	eb 0c		 jmp	 SHORT $LN26@diff_to_bo
$LN25@diff_to_bo:
  00157	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0015e	48 89 44 24 50	 mov	 QWORD PTR tv84[rsp], rax
$LN26@diff_to_bo:
  00163	48 8b 44 24 50	 mov	 rax, QWORD PTR tv84[rsp]
  00168	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1381 :     Py_INCREF(result);

  0016d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00172	e8 00 00 00 00	 call	 _Py_IncRef

; 1382 :     return result;

  00177	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]

; 1383 : }

  0017c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00180	c3		 ret	 0
  00181	0f 1f 00	 npad	 3
$LN27@diff_to_bo:
  00184	00 00 00 00	 DD	 $LN3@diff_to_bo
  00188	00 00 00 00	 DD	 $LN5@diff_to_bo
  0018c	00 00 00 00	 DD	 $LN7@diff_to_bo
  00190	00 00 00 00	 DD	 $LN6@diff_to_bo
  00194	00 00 00 00	 DD	 $LN2@diff_to_bo
  00198	00 00 00 00	 DD	 $LN4@diff_to_bo
diff_to_bool ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_cmp DD imagerel delta_cmp
	DD	imagerel delta_cmp+97
	DD	imagerel $unwind$delta_cmp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_cmp DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_cmp
_TEXT	SEGMENT
diff$ = 0
self$ = 32
other$ = 40
delta_cmp PROC						; COMDAT

; 1808 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1809 :     int diff = GET_TD_DAYS(self) - GET_TD_DAYS(other);

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 4c 24 28	 mov	 rcx, QWORD PTR other$[rsp]
  00018	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  0001b	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0001e	2b c1		 sub	 eax, ecx
  00020	89 04 24	 mov	 DWORD PTR diff$[rsp], eax

; 1810 :     if (diff == 0) {

  00023	83 3c 24 00	 cmp	 DWORD PTR diff$[rsp], 0
  00027	75 30		 jne	 SHORT $LN2@delta_cmp

; 1811 :         diff = GET_TD_SECONDS(self) - GET_TD_SECONDS(other);

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0002e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR other$[rsp]
  00033	8b 49 6c	 mov	 ecx, DWORD PTR [rcx+108]
  00036	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00039	2b c1		 sub	 eax, ecx
  0003b	89 04 24	 mov	 DWORD PTR diff$[rsp], eax

; 1812 :         if (diff == 0)

  0003e	83 3c 24 00	 cmp	 DWORD PTR diff$[rsp], 0
  00042	75 15		 jne	 SHORT $LN1@delta_cmp

; 1813 :             diff = GET_TD_MICROSECONDS(self) -
; 1814 :                 GET_TD_MICROSECONDS(other);

  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00049	48 8b 4c 24 28	 mov	 rcx, QWORD PTR other$[rsp]
  0004e	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00051	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00054	2b c1		 sub	 eax, ecx
  00056	89 04 24	 mov	 DWORD PTR diff$[rsp], eax
$LN1@delta_cmp:
$LN2@delta_cmp:

; 1815 :     }
; 1816 :     return diff;

  00059	8b 04 24	 mov	 eax, DWORD PTR diff$[rsp]

; 1817 : }

  0005c	48 83 c4 18	 add	 rsp, 24
  00060	c3		 ret	 0
delta_cmp ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
EXTRN	PyObject_Hash:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_hash DD imagerel delta_hash
	DD	imagerel delta_hash+87
	DD	imagerel $unwind$delta_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_hash DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_hash
_TEXT	SEGMENT
temp$21997 = 32
self$ = 64
delta_hash PROC						; COMDAT

; 1835 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1836 :     if (self->hashcode == -1) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 ff	 cmp	 QWORD PTR [rax+96], -1
  00013	75 34		 jne	 SHORT $LN2@delta_hash

; 1837 :         PyObject *temp = delta_getstate(self);

  00015	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001a	e8 00 00 00 00	 call	 delta_getstate
  0001f	48 89 44 24 20	 mov	 QWORD PTR temp$21997[rsp], rax

; 1838 :         if (temp != NULL) {

  00024	48 83 7c 24 20
	00		 cmp	 QWORD PTR temp$21997[rsp], 0
  0002a	74 1d		 je	 SHORT $LN1@delta_hash

; 1839 :             self->hashcode = PyObject_Hash(temp);

  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR temp$21997[rsp]
  00031	e8 00 00 00 00	 call	 PyObject_Hash
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0003b	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 1840 :             Py_DECREF(temp);

  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR temp$21997[rsp]
  00044	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@delta_hash:
$LN2@delta_hash:

; 1841 :         }
; 1842 :     }
; 1843 :     return self->hashcode;

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]

; 1844 : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
delta_hash ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyFloat_Type:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\modules\_datetimemodule.c
pdata	SEGMENT
$pdata$delta_multiply DD imagerel delta_multiply
	DD	imagerel delta_multiply+323
	DD	imagerel $unwind$delta_multiply
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_multiply DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_multiply
_TEXT	SEGMENT
result$ = 32
left$ = 64
right$ = 72
delta_multiply PROC					; COMDAT

; 1848 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1849 :     PyObject *result = Py_NotImplemented;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00015	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1850 : 
; 1851 :     if (PyDelta_Check(left)) {

  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR left$[rsp]
  00026	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002a	74 19		 je	 SHORT $LN11@delta_mult
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR left$[rsp]
  00038	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00041	85 c0		 test	 eax, eax
  00043	74 6f		 je	 SHORT $LN12@delta_mult
$LN11@delta_mult:

; 1852 :         /* delta * ??? */
; 1853 :         if (PyLong_Check(right))

  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR right$[rsp]
  0004a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00054	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00059	85 c0		 test	 eax, eax
  0005b	74 16		 je	 SHORT $LN10@delta_mult

; 1854 :             result = multiply_int_timedelta(right,
; 1855 :                             (PyDateTime_Delta *) left);

  0005d	48 8b 54 24 40	 mov	 rdx, QWORD PTR left$[rsp]
  00062	48 8b 4c 24 48	 mov	 rcx, QWORD PTR right$[rsp]
  00067	e8 00 00 00 00	 call	 multiply_int_timedelta
  0006c	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
  00071	eb 3f		 jmp	 SHORT $LN9@delta_mult
$LN10@delta_mult:

; 1856 :         else if (PyFloat_Check(right))

  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  0007a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR right$[rsp]
  0007f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00083	74 19		 je	 SHORT $LN7@delta_mult
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0008c	48 8b 44 24 48	 mov	 rax, QWORD PTR right$[rsp]
  00091	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00095	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009a	85 c0		 test	 eax, eax
  0009c	74 14		 je	 SHORT $LN8@delta_mult
$LN7@delta_mult:

; 1857 :             result = multiply_float_timedelta(right,
; 1858 :                             (PyDateTime_Delta *) left);

  0009e	48 8b 54 24 40	 mov	 rdx, QWORD PTR left$[rsp]
  000a3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR right$[rsp]
  000a8	e8 00 00 00 00	 call	 multiply_float_timedelta
  000ad	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN8@delta_mult:
$LN9@delta_mult:

; 1859 :     }
; 1860 :     else if (PyLong_Check(left))

  000b2	eb 6d		 jmp	 SHORT $LN6@delta_mult
$LN12@delta_mult:
  000b4	48 8b 44 24 40	 mov	 rax, QWORD PTR left$[rsp]
  000b9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000bd	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000c3	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000c8	85 c0		 test	 eax, eax
  000ca	74 16		 je	 SHORT $LN5@delta_mult

; 1861 :         result = multiply_int_timedelta(left,
; 1862 :                         (PyDateTime_Delta *) right);

  000cc	48 8b 54 24 48	 mov	 rdx, QWORD PTR right$[rsp]
  000d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR left$[rsp]
  000d6	e8 00 00 00 00	 call	 multiply_int_timedelta
  000db	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
  000e0	eb 3f		 jmp	 SHORT $LN4@delta_mult
$LN5@delta_mult:

; 1863 :     else if (PyFloat_Check(left))

  000e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR left$[rsp]
  000ee	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000f2	74 19		 je	 SHORT $LN2@delta_mult
  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  000fb	48 8b 44 24 40	 mov	 rax, QWORD PTR left$[rsp]
  00100	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00104	e8 00 00 00 00	 call	 PyType_IsSubtype
  00109	85 c0		 test	 eax, eax
  0010b	74 14		 je	 SHORT $LN3@delta_mult
$LN2@delta_mult:

; 1864 :         result = multiply_float_timedelta(left,
; 1865 :                         (PyDateTime_Delta *) right);

  0010d	48 8b 54 24 48	 mov	 rdx, QWORD PTR right$[rsp]
  00112	48 8b 4c 24 40	 mov	 rcx, QWORD PTR left$[rsp]
  00117	e8 00 00 00 00	 call	 multiply_float_timedelta
  0011c	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN3@delta_mult:
$LN4@delta_mult:
$LN6@delta_mult:

; 1866 : 
; 1867 :     if (result == Py_NotImplemented)

  00121	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00128	48 39 44 24 20	 cmp	 QWORD PTR result$[rsp], rax
  0012d	75 0a		 jne	 SHORT $LN1@delta_mult

; 1868 :         Py_INCREF(result);

  0012f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00134	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@delta_mult:

; 1869 :     return result;

  00139	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 1870 : }

  0013e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00142	c3		 ret	 0
delta_multiply ENDP
_TEXT	ENDS
EXTRN	PyNumber_Multiply:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$multiply_int_timedelta DD imagerel multiply_int_timedelta
	DD	imagerel multiply_int_timedelta+125
	DD	imagerel $unwind$multiply_int_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$multiply_int_timedelta DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT multiply_int_timedelta
_TEXT	SEGMENT
pyus_out$ = 32
pyus_in$ = 40
result$ = 48
intobj$ = 80
delta$ = 88
multiply_int_timedelta PROC				; COMDAT

; 1557 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1558 :     PyObject *pyus_in;
; 1559 :     PyObject *pyus_out;
; 1560 :     PyObject *result;
; 1561 : 
; 1562 :     pyus_in = delta_to_microseconds(delta);

  0000e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR delta$[rsp]
  00013	e8 00 00 00 00	 call	 delta_to_microseconds
  00018	48 89 44 24 28	 mov	 QWORD PTR pyus_in$[rsp], rax

; 1563 :     if (pyus_in == NULL)

  0001d	48 83 7c 24 28
	00		 cmp	 QWORD PTR pyus_in$[rsp], 0
  00023	75 04		 jne	 SHORT $LN2@multiply_i

; 1564 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 4f		 jmp	 SHORT $LN3@multiply_i
$LN2@multiply_i:

; 1565 : 
; 1566 :     pyus_out = PyNumber_Multiply(pyus_in, intobj);

  00029	48 8b 54 24 50	 mov	 rdx, QWORD PTR intobj$[rsp]
  0002e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  00033	e8 00 00 00 00	 call	 PyNumber_Multiply
  00038	48 89 44 24 20	 mov	 QWORD PTR pyus_out$[rsp], rax

; 1567 :     Py_DECREF(pyus_in);

  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  00042	e8 00 00 00 00	 call	 _Py_DecRef

; 1568 :     if (pyus_out == NULL)

  00047	48 83 7c 24 20
	00		 cmp	 QWORD PTR pyus_out$[rsp], 0
  0004d	75 04		 jne	 SHORT $LN1@multiply_i

; 1569 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	eb 25		 jmp	 SHORT $LN3@multiply_i
$LN1@multiply_i:

; 1570 : 
; 1571 :     result = microseconds_to_delta(pyus_out);

  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_out$[rsp]
  0005f	e8 00 00 00 00	 call	 microseconds_to_delta_ex
  00064	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1572 :     Py_DECREF(pyus_out);

  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_out$[rsp]
  0006e	e8 00 00 00 00	 call	 _Py_DecRef

; 1573 :     return result;

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN3@multiply_i:

; 1574 : }

  00078	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007c	c3		 ret	 0
multiply_int_timedelta ENDP
_TEXT	ENDS
EXTRN	PyNumber_Add:PROC
EXTRN	PyLong_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_to_microseconds DD imagerel delta_to_microseconds
	DD	imagerel delta_to_microseconds+404
	DD	imagerel $unwind$delta_to_microseconds
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_to_microseconds DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_to_microseconds
_TEXT	SEGMENT
x2$ = 32
x1$ = 40
result$ = 48
x3$ = 56
self$ = 80
delta_to_microseconds PROC				; COMDAT

; 1425 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1426 :     PyObject *x1 = NULL;

  00009	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR x1$[rsp], 0

; 1427 :     PyObject *x2 = NULL;

  00012	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR x2$[rsp], 0

; 1428 :     PyObject *x3 = NULL;

  0001b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR x3$[rsp], 0

; 1429 :     PyObject *result = NULL;

  00024	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 1430 : 
; 1431 :     x1 = PyLong_FromLong(GET_TD_DAYS(self));

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00032	8b 48 68	 mov	 ecx, DWORD PTR [rax+104]
  00035	e8 00 00 00 00	 call	 PyLong_FromLong
  0003a	48 89 44 24 28	 mov	 QWORD PTR x1$[rsp], rax

; 1432 :     if (x1 == NULL)

  0003f	48 83 7c 24 28
	00		 cmp	 QWORD PTR x1$[rsp], 0
  00045	75 05		 jne	 SHORT $LN18@delta_to_m

; 1433 :         goto Done;

  00047	e9 f6 00 00 00	 jmp	 $Done$21609
$LN18@delta_to_m:

; 1434 :     x2 = PyNumber_Multiply(x1, seconds_per_day);        /* days in seconds */

  0004c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR seconds_per_day
  00053	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x1$[rsp]
  00058	e8 00 00 00 00	 call	 PyNumber_Multiply
  0005d	48 89 44 24 20	 mov	 QWORD PTR x2$[rsp], rax

; 1435 :     if (x2 == NULL)

  00062	48 83 7c 24 20
	00		 cmp	 QWORD PTR x2$[rsp], 0
  00068	75 05		 jne	 SHORT $LN17@delta_to_m

; 1436 :         goto Done;

  0006a	e9 d3 00 00 00	 jmp	 $Done$21609
$LN17@delta_to_m:

; 1437 :     Py_DECREF(x1);

  0006f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x1$[rsp]
  00074	e8 00 00 00 00	 call	 _Py_DecRef

; 1438 :     x1 = NULL;

  00079	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR x1$[rsp], 0

; 1439 : 
; 1440 :     /* x2 has days in seconds */
; 1441 :     x1 = PyLong_FromLong(GET_TD_SECONDS(self));         /* seconds */

  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00087	8b 48 6c	 mov	 ecx, DWORD PTR [rax+108]
  0008a	e8 00 00 00 00	 call	 PyLong_FromLong
  0008f	48 89 44 24 28	 mov	 QWORD PTR x1$[rsp], rax

; 1442 :     if (x1 == NULL)

  00094	48 83 7c 24 28
	00		 cmp	 QWORD PTR x1$[rsp], 0
  0009a	75 05		 jne	 SHORT $LN16@delta_to_m

; 1443 :         goto Done;

  0009c	e9 a1 00 00 00	 jmp	 $Done$21609
$LN16@delta_to_m:

; 1444 :     x3 = PyNumber_Add(x1, x2);          /* days and seconds in seconds */

  000a1	48 8b 54 24 20	 mov	 rdx, QWORD PTR x2$[rsp]
  000a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x1$[rsp]
  000ab	e8 00 00 00 00	 call	 PyNumber_Add
  000b0	48 89 44 24 38	 mov	 QWORD PTR x3$[rsp], rax

; 1445 :     if (x3 == NULL)

  000b5	48 83 7c 24 38
	00		 cmp	 QWORD PTR x3$[rsp], 0
  000bb	75 05		 jne	 SHORT $LN15@delta_to_m

; 1446 :         goto Done;

  000bd	e9 80 00 00 00	 jmp	 $Done$21609
$LN15@delta_to_m:

; 1447 :     Py_DECREF(x1);

  000c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x1$[rsp]
  000c7	e8 00 00 00 00	 call	 _Py_DecRef

; 1448 :     Py_DECREF(x2);

  000cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x2$[rsp]
  000d1	e8 00 00 00 00	 call	 _Py_DecRef

; 1449 :     /* x1 = */ x2 = NULL;

  000d6	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR x2$[rsp], 0

; 1450 : 
; 1451 :     /* x3 has days+seconds in seconds */
; 1452 :     x1 = PyNumber_Multiply(x3, us_per_second);          /* us */

  000df	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR us_per_second
  000e6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR x3$[rsp]
  000eb	e8 00 00 00 00	 call	 PyNumber_Multiply
  000f0	48 89 44 24 28	 mov	 QWORD PTR x1$[rsp], rax

; 1453 :     if (x1 == NULL)

  000f5	48 83 7c 24 28
	00		 cmp	 QWORD PTR x1$[rsp], 0
  000fb	75 02		 jne	 SHORT $LN14@delta_to_m

; 1454 :         goto Done;

  000fd	eb 43		 jmp	 SHORT $Done$21609
$LN14@delta_to_m:

; 1455 :     Py_DECREF(x3);

  000ff	48 8b 4c 24 38	 mov	 rcx, QWORD PTR x3$[rsp]
  00104	e8 00 00 00 00	 call	 _Py_DecRef

; 1456 :     x3 = NULL;

  00109	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR x3$[rsp], 0

; 1457 : 
; 1458 :     /* x1 has days+seconds in us */
; 1459 :     x2 = PyLong_FromLong(GET_TD_MICROSECONDS(self));

  00112	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00117	8b 48 70	 mov	 ecx, DWORD PTR [rax+112]
  0011a	e8 00 00 00 00	 call	 PyLong_FromLong
  0011f	48 89 44 24 20	 mov	 QWORD PTR x2$[rsp], rax

; 1460 :     if (x2 == NULL)

  00124	48 83 7c 24 20
	00		 cmp	 QWORD PTR x2$[rsp], 0
  0012a	75 02		 jne	 SHORT $LN13@delta_to_m

; 1461 :         goto Done;

  0012c	eb 14		 jmp	 SHORT $Done$21609
$LN13@delta_to_m:

; 1462 :     result = PyNumber_Add(x1, x2);

  0012e	48 8b 54 24 20	 mov	 rdx, QWORD PTR x2$[rsp]
  00133	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x1$[rsp]
  00138	e8 00 00 00 00	 call	 PyNumber_Add
  0013d	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
$Done$21609:
$LN12@delta_to_m:

; 1463 : 
; 1464 : Done:
; 1465 :     Py_XDECREF(x1);

  00142	48 83 7c 24 28
	00		 cmp	 QWORD PTR x1$[rsp], 0
  00148	74 0a		 je	 SHORT $LN9@delta_to_m
  0014a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR x1$[rsp]
  0014f	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@delta_to_m:
  00154	33 c0		 xor	 eax, eax
  00156	85 c0		 test	 eax, eax
  00158	75 e8		 jne	 SHORT $LN12@delta_to_m
$LN8@delta_to_m:

; 1466 :     Py_XDECREF(x2);

  0015a	48 83 7c 24 20
	00		 cmp	 QWORD PTR x2$[rsp], 0
  00160	74 0a		 je	 SHORT $LN5@delta_to_m
  00162	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x2$[rsp]
  00167	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@delta_to_m:
  0016c	33 c0		 xor	 eax, eax
  0016e	85 c0		 test	 eax, eax
  00170	75 e8		 jne	 SHORT $LN8@delta_to_m
$LN4@delta_to_m:

; 1467 :     Py_XDECREF(x3);

  00172	48 83 7c 24 38
	00		 cmp	 QWORD PTR x3$[rsp], 0
  00178	74 0a		 je	 SHORT $LN1@delta_to_m
  0017a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR x3$[rsp]
  0017f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@delta_to_m:
  00184	33 c0		 xor	 eax, eax
  00186	85 c0		 test	 eax, eax
  00188	75 e8		 jne	 SHORT $LN4@delta_to_m

; 1468 :     return result;

  0018a	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 1469 : }

  0018f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00193	c3		 ret	 0
delta_to_microseconds ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CM@DACIBDGD@normalized?5days?5too?5large?5to?5fit@ ; `string'
PUBLIC	??_C@_1DI@ILDPNEAB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@DNBCFJEA@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@HACMFIPB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyLong_AsLong:PROC
EXTRN	PyTuple_GetItem:PROC
EXTRN	PyNumber_Divmod:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$microseconds_to_delta_ex DD imagerel microseconds_to_delta_ex
	DD	imagerel microseconds_to_delta_ex+736
	DD	imagerel $unwind$microseconds_to_delta_ex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$microseconds_to_delta_ex DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0CM@DACIBDGD@normalized?5days?5too?5large?5to?5fit@
CONST	SEGMENT
??_C@_0CM@DACIBDGD@normalized?5days?5too?5large?5to?5fit@ DB 'normalized '
	DB	'days too large to fit in a C int', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@ILDPNEAB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@ILDPNEAB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0?$AA0?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 't', 00H, 'e', 00H
	DB	'm', 00H, 'p', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 't'
	DB	00H, 'e', 00H, 'm', 00H, 'p', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'2', 00H, '4', 00H, '*', 00H, '3', 00H, '6', 00H, '0', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@DNBCFJEA@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@DNBCFJEA@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'E', 00H, 'r', 00H, 'r', 00H, '_', 00H, 'O', 00H
	DB	'c', 00H, 'c', 00H, 'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'd'
	DB	00H, '(', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@HACMFIPB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@HACMFIPB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@ DB '0'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 't', 00H, 'e', 00H
	DB	'm', 00H, 'p', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 't'
	DB	00H, 'e', 00H, 'm', 00H, 'p', 00H, ' ', 00H, '<', 00H, ' ', 00H
	DB	'1', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '0'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT microseconds_to_delta_ex
_TEXT	SEGMENT
num$ = 48
s$ = 56
temp$ = 60
tuple$ = 64
result$ = 72
d$ = 80
us$ = 84
pyus$ = 112
type$ = 120
microseconds_to_delta_ex PROC				; COMDAT

; 1475 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1476 :     int us;
; 1477 :     int s;
; 1478 :     int d;
; 1479 :     long temp;
; 1480 : 
; 1481 :     PyObject *tuple = NULL;

  0000e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tuple$[rsp], 0

; 1482 :     PyObject *num = NULL;

  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR num$[rsp], 0

; 1483 :     PyObject *result = NULL;

  00020	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 1484 : 
; 1485 :     tuple = PyNumber_Divmod(pyus, us_per_second);

  00029	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR us_per_second
  00030	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pyus$[rsp]
  00035	e8 00 00 00 00	 call	 PyNumber_Divmod
  0003a	48 89 44 24 40	 mov	 QWORD PTR tuple$[rsp], rax

; 1486 :     if (tuple == NULL)

  0003f	48 83 7c 24 40
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  00045	75 05		 jne	 SHORT $LN20@microsecon

; 1487 :         goto Done;

  00047	e9 5a 02 00 00	 jmp	 $Done$21662
$LN20@microsecon:

; 1488 : 
; 1489 :     num = PyTuple_GetItem(tuple, 1);            /* us */

  0004c	ba 01 00 00 00	 mov	 edx, 1
  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tuple$[rsp]
  00056	e8 00 00 00 00	 call	 PyTuple_GetItem
  0005b	48 89 44 24 30	 mov	 QWORD PTR num$[rsp], rax

; 1490 :     if (num == NULL)

  00060	48 83 7c 24 30
	00		 cmp	 QWORD PTR num$[rsp], 0
  00066	75 05		 jne	 SHORT $LN19@microsecon

; 1491 :         goto Done;

  00068	e9 39 02 00 00	 jmp	 $Done$21662
$LN19@microsecon:

; 1492 :     temp = PyLong_AsLong(num);

  0006d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR num$[rsp]
  00072	e8 00 00 00 00	 call	 PyLong_AsLong
  00077	89 44 24 3c	 mov	 DWORD PTR temp$[rsp], eax

; 1493 :     num = NULL;

  0007b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR num$[rsp], 0

; 1494 :     if (temp == -1 && PyErr_Occurred())

  00084	83 7c 24 3c ff	 cmp	 DWORD PTR temp$[rsp], -1
  00089	75 0f		 jne	 SHORT $LN18@microsecon
  0008b	e8 00 00 00 00	 call	 PyErr_Occurred
  00090	48 85 c0	 test	 rax, rax
  00093	74 05		 je	 SHORT $LN18@microsecon

; 1495 :         goto Done;

  00095	e9 0c 02 00 00	 jmp	 $Done$21662
$LN18@microsecon:

; 1496 :     assert(0 <= temp && temp < 1000000);

  0009a	83 7c 24 3c 00	 cmp	 DWORD PTR temp$[rsp], 0
  0009f	7c 0a		 jl	 SHORT $LN23@microsecon
  000a1	81 7c 24 3c 40
	42 0f 00	 cmp	 DWORD PTR temp$[rsp], 1000000 ; 000f4240H
  000a9	7c 1c		 jl	 SHORT $LN24@microsecon
$LN23@microsecon:
  000ab	41 b8 d8 05 00
	00		 mov	 r8d, 1496		; 000005d8H
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@HACMFIPB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$DM?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA?$AA@
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000c5	33 c0		 xor	 eax, eax
$LN24@microsecon:

; 1497 :     us = (int)temp;

  000c7	8b 44 24 3c	 mov	 eax, DWORD PTR temp$[rsp]
  000cb	89 44 24 54	 mov	 DWORD PTR us$[rsp], eax

; 1498 :     if (us < 0) {

  000cf	83 7c 24 54 00	 cmp	 DWORD PTR us$[rsp], 0
  000d4	7d 2b		 jge	 SHORT $LN17@microsecon

; 1499 :         /* The divisor was positive, so this must be an error. */
; 1500 :         assert(PyErr_Occurred());

  000d6	e8 00 00 00 00	 call	 PyErr_Occurred
  000db	48 85 c0	 test	 rax, rax
  000de	75 1c		 jne	 SHORT $LN25@microsecon
  000e0	41 b8 dc 05 00
	00		 mov	 r8d, 1500		; 000005dcH
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@DNBCFJEA@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000fa	33 c0		 xor	 eax, eax
$LN25@microsecon:

; 1501 :         goto Done;

  000fc	e9 a5 01 00 00	 jmp	 $Done$21662
$LN17@microsecon:

; 1502 :     }
; 1503 : 
; 1504 :     num = PyTuple_GetItem(tuple, 0);            /* leftover seconds */

  00101	33 d2		 xor	 edx, edx
  00103	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tuple$[rsp]
  00108	e8 00 00 00 00	 call	 PyTuple_GetItem
  0010d	48 89 44 24 30	 mov	 QWORD PTR num$[rsp], rax

; 1505 :     if (num == NULL)

  00112	48 83 7c 24 30
	00		 cmp	 QWORD PTR num$[rsp], 0
  00118	75 05		 jne	 SHORT $LN16@microsecon

; 1506 :         goto Done;

  0011a	e9 87 01 00 00	 jmp	 $Done$21662
$LN16@microsecon:

; 1507 :     Py_INCREF(num);

  0011f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR num$[rsp]
  00124	e8 00 00 00 00	 call	 _Py_IncRef

; 1508 :     Py_DECREF(tuple);

  00129	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tuple$[rsp]
  0012e	e8 00 00 00 00	 call	 _Py_DecRef

; 1509 : 
; 1510 :     tuple = PyNumber_Divmod(num, seconds_per_day);

  00133	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR seconds_per_day
  0013a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR num$[rsp]
  0013f	e8 00 00 00 00	 call	 PyNumber_Divmod
  00144	48 89 44 24 40	 mov	 QWORD PTR tuple$[rsp], rax

; 1511 :     if (tuple == NULL)

  00149	48 83 7c 24 40
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  0014f	75 05		 jne	 SHORT $LN15@microsecon

; 1512 :         goto Done;

  00151	e9 50 01 00 00	 jmp	 $Done$21662
$LN15@microsecon:

; 1513 :     Py_DECREF(num);

  00156	48 8b 4c 24 30	 mov	 rcx, QWORD PTR num$[rsp]
  0015b	e8 00 00 00 00	 call	 _Py_DecRef

; 1514 : 
; 1515 :     num = PyTuple_GetItem(tuple, 1);            /* seconds */

  00160	ba 01 00 00 00	 mov	 edx, 1
  00165	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tuple$[rsp]
  0016a	e8 00 00 00 00	 call	 PyTuple_GetItem
  0016f	48 89 44 24 30	 mov	 QWORD PTR num$[rsp], rax

; 1516 :     if (num == NULL)

  00174	48 83 7c 24 30
	00		 cmp	 QWORD PTR num$[rsp], 0
  0017a	75 05		 jne	 SHORT $LN14@microsecon

; 1517 :         goto Done;

  0017c	e9 25 01 00 00	 jmp	 $Done$21662
$LN14@microsecon:

; 1518 :     temp = PyLong_AsLong(num);

  00181	48 8b 4c 24 30	 mov	 rcx, QWORD PTR num$[rsp]
  00186	e8 00 00 00 00	 call	 PyLong_AsLong
  0018b	89 44 24 3c	 mov	 DWORD PTR temp$[rsp], eax

; 1519 :     num = NULL;

  0018f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR num$[rsp], 0

; 1520 :     if (temp == -1 && PyErr_Occurred())

  00198	83 7c 24 3c ff	 cmp	 DWORD PTR temp$[rsp], -1
  0019d	75 0f		 jne	 SHORT $LN13@microsecon
  0019f	e8 00 00 00 00	 call	 PyErr_Occurred
  001a4	48 85 c0	 test	 rax, rax
  001a7	74 05		 je	 SHORT $LN13@microsecon

; 1521 :         goto Done;

  001a9	e9 f8 00 00 00	 jmp	 $Done$21662
$LN13@microsecon:

; 1522 :     assert(0 <= temp && temp < 24*3600);

  001ae	83 7c 24 3c 00	 cmp	 DWORD PTR temp$[rsp], 0
  001b3	7c 0a		 jl	 SHORT $LN26@microsecon
  001b5	81 7c 24 3c 80
	51 01 00	 cmp	 DWORD PTR temp$[rsp], 86400 ; 00015180H
  001bd	7c 1c		 jl	 SHORT $LN27@microsecon
$LN26@microsecon:
  001bf	41 b8 f2 05 00
	00		 mov	 r8d, 1522		; 000005f2H
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@ILDPNEAB@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAe?$AAm?$AAp?$AA?5?$AA?$DM?$AA?5?$AA2?$AA4?$AA?$CK?$AA3?$AA6?$AA0?$AA0?$AA?$AA@
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d9	33 c0		 xor	 eax, eax
$LN27@microsecon:

; 1523 :     s = (int)temp;

  001db	8b 44 24 3c	 mov	 eax, DWORD PTR temp$[rsp]
  001df	89 44 24 38	 mov	 DWORD PTR s$[rsp], eax

; 1524 : 
; 1525 :     if (s < 0) {

  001e3	83 7c 24 38 00	 cmp	 DWORD PTR s$[rsp], 0
  001e8	7d 2b		 jge	 SHORT $LN12@microsecon

; 1526 :         /* The divisor was positive, so this must be an error. */
; 1527 :         assert(PyErr_Occurred());

  001ea	e8 00 00 00 00	 call	 PyErr_Occurred
  001ef	48 85 c0	 test	 rax, rax
  001f2	75 1c		 jne	 SHORT $LN28@microsecon
  001f4	41 b8 f7 05 00
	00		 mov	 r8d, 1527		; 000005f7H
  001fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@DNBCFJEA@?$AAP?$AAy?$AAE?$AAr?$AAr?$AA_?$AAO?$AAc?$AAc?$AAu?$AAr?$AAr?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0020e	33 c0		 xor	 eax, eax
$LN28@microsecon:

; 1528 :         goto Done;

  00210	e9 91 00 00 00	 jmp	 $Done$21662
$LN12@microsecon:

; 1529 :     }
; 1530 : 
; 1531 :     num = PyTuple_GetItem(tuple, 0);            /* leftover days */

  00215	33 d2		 xor	 edx, edx
  00217	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tuple$[rsp]
  0021c	e8 00 00 00 00	 call	 PyTuple_GetItem
  00221	48 89 44 24 30	 mov	 QWORD PTR num$[rsp], rax

; 1532 :     if (num == NULL)

  00226	48 83 7c 24 30
	00		 cmp	 QWORD PTR num$[rsp], 0
  0022c	75 02		 jne	 SHORT $LN11@microsecon

; 1533 :         goto Done;

  0022e	eb 76		 jmp	 SHORT $Done$21662
$LN11@microsecon:

; 1534 :     Py_INCREF(num);

  00230	48 8b 4c 24 30	 mov	 rcx, QWORD PTR num$[rsp]
  00235	e8 00 00 00 00	 call	 _Py_IncRef

; 1535 :     temp = PyLong_AsLong(num);

  0023a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR num$[rsp]
  0023f	e8 00 00 00 00	 call	 PyLong_AsLong
  00244	89 44 24 3c	 mov	 DWORD PTR temp$[rsp], eax

; 1536 :     if (temp == -1 && PyErr_Occurred())

  00248	83 7c 24 3c ff	 cmp	 DWORD PTR temp$[rsp], -1
  0024d	75 0c		 jne	 SHORT $LN10@microsecon
  0024f	e8 00 00 00 00	 call	 PyErr_Occurred
  00254	48 85 c0	 test	 rax, rax
  00257	74 02		 je	 SHORT $LN10@microsecon

; 1537 :         goto Done;

  00259	eb 4b		 jmp	 SHORT $Done$21662
$LN10@microsecon:

; 1538 :     d = (int)temp;

  0025b	8b 44 24 3c	 mov	 eax, DWORD PTR temp$[rsp]
  0025f	89 44 24 50	 mov	 DWORD PTR d$[rsp], eax

; 1539 :     if ((long)d != temp) {

  00263	8b 44 24 3c	 mov	 eax, DWORD PTR temp$[rsp]
  00267	39 44 24 50	 cmp	 DWORD PTR d$[rsp], eax
  0026b	74 15		 je	 SHORT $LN9@microsecon

; 1540 :         PyErr_SetString(PyExc_OverflowError, "normalized days too "
; 1541 :                         "large to fit in a C int");

  0026d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@DACIBDGD@normalized?5days?5too?5large?5to?5fit@
  00274	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0027b	e8 00 00 00 00	 call	 PyErr_SetString

; 1542 :         goto Done;

  00280	eb 24		 jmp	 SHORT $Done$21662
$LN9@microsecon:

; 1543 :     }
; 1544 :     result = new_delta_ex(d, s, us, 0, type);

  00282	48 8b 44 24 78	 mov	 rax, QWORD PTR type$[rsp]
  00287	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028c	45 33 c9	 xor	 r9d, r9d
  0028f	44 8b 44 24 54	 mov	 r8d, DWORD PTR us$[rsp]
  00294	8b 54 24 38	 mov	 edx, DWORD PTR s$[rsp]
  00298	8b 4c 24 50	 mov	 ecx, DWORD PTR d$[rsp]
  0029c	e8 00 00 00 00	 call	 new_delta_ex
  002a1	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax
$Done$21662:
$LN8@microsecon:

; 1545 : 
; 1546 : Done:
; 1547 :     Py_XDECREF(tuple);

  002a6	48 83 7c 24 40
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  002ac	74 0a		 je	 SHORT $LN5@microsecon
  002ae	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tuple$[rsp]
  002b3	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@microsecon:
  002b8	33 c0		 xor	 eax, eax
  002ba	85 c0		 test	 eax, eax
  002bc	75 e8		 jne	 SHORT $LN8@microsecon
$LN4@microsecon:

; 1548 :     Py_XDECREF(num);

  002be	48 83 7c 24 30
	00		 cmp	 QWORD PTR num$[rsp], 0
  002c4	74 0a		 je	 SHORT $LN1@microsecon
  002c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR num$[rsp]
  002cb	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@microsecon:
  002d0	33 c0		 xor	 eax, eax
  002d2	85 c0		 test	 eax, eax
  002d4	75 e8		 jne	 SHORT $LN4@microsecon

; 1549 :     return result;

  002d6	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]

; 1550 : }

  002db	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002df	c3		 ret	 0
microseconds_to_delta_ex ENDP
_TEXT	ENDS
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$multiply_float_timedelta DD imagerel multiply_float_timedelta
	DD	imagerel multiply_float_timedelta+318
	DD	imagerel $unwind$multiply_float_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$multiply_float_timedelta DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT multiply_float_timedelta
_TEXT	SEGMENT
ratio$ = 32
pyus_out$ = 40
pyus_in$ = 48
temp$ = 56
result$ = 64
floatobj$ = 96
delta$ = 104
multiply_float_timedelta PROC				; COMDAT

; 1578 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1579 :     PyObject *result = NULL;

  0000e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 1580 :     PyObject *pyus_in = NULL, *temp, *pyus_out;

  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR pyus_in$[rsp], 0

; 1581 :     PyObject *ratio = NULL;

  00020	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR ratio$[rsp], 0

; 1582 :     _Py_IDENTIFIER(as_integer_ratio);
; 1583 : 
; 1584 :     pyus_in = delta_to_microseconds(delta);

  00029	48 8b 4c 24 68	 mov	 rcx, QWORD PTR delta$[rsp]
  0002e	e8 00 00 00 00	 call	 delta_to_microseconds
  00033	48 89 44 24 30	 mov	 QWORD PTR pyus_in$[rsp], rax

; 1585 :     if (pyus_in == NULL)

  00038	48 83 7c 24 30
	00		 cmp	 QWORD PTR pyus_in$[rsp], 0
  0003e	75 07		 jne	 SHORT $LN12@multiply_f

; 1586 :         return NULL;

  00040	33 c0		 xor	 eax, eax
  00042	e9 f2 00 00 00	 jmp	 $LN13@multiply_f
$LN12@multiply_f:

; 1587 :     ratio = _PyObject_CallMethodId(floatobj, &PyId_as_integer_ratio, NULL);

  00047	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_as_integer_ratio@?1??multiply_float_timedelta@@9@9
  0004c	8b c0		 mov	 eax, eax
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00054	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0005d	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00061	45 33 c0	 xor	 r8d, r8d
  00064	48 8b d0	 mov	 rdx, rax
  00067	48 8b 4c 24 60	 mov	 rcx, QWORD PTR floatobj$[rsp]
  0006c	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00071	48 89 44 24 20	 mov	 QWORD PTR ratio$[rsp], rax

; 1588 :     if (ratio == NULL)

  00076	48 83 7c 24 20
	00		 cmp	 QWORD PTR ratio$[rsp], 0
  0007c	75 05		 jne	 SHORT $LN11@multiply_f

; 1589 :         goto error;

  0007e	e9 81 00 00 00	 jmp	 $error$21748
$LN11@multiply_f:

; 1590 :     temp = PyNumber_Multiply(pyus_in, PyTuple_GET_ITEM(ratio, 0));

  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR ratio$[rsp]
  00088	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  0008c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  00091	e8 00 00 00 00	 call	 PyNumber_Multiply
  00096	48 89 44 24 38	 mov	 QWORD PTR temp$[rsp], rax

; 1591 :     Py_DECREF(pyus_in);

  0009b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  000a0	e8 00 00 00 00	 call	 _Py_DecRef

; 1592 :     pyus_in = NULL;

  000a5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR pyus_in$[rsp], 0

; 1593 :     if (temp == NULL)

  000ae	48 83 7c 24 38
	00		 cmp	 QWORD PTR temp$[rsp], 0
  000b4	75 02		 jne	 SHORT $LN10@multiply_f

; 1594 :         goto error;

  000b6	eb 4c		 jmp	 SHORT $error$21748
$LN10@multiply_f:

; 1595 :     pyus_out = divide_nearest(temp, PyTuple_GET_ITEM(ratio, 1));

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR ratio$[rsp]
  000bd	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  000c1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR temp$[rsp]
  000c6	e8 00 00 00 00	 call	 divide_nearest
  000cb	48 89 44 24 28	 mov	 QWORD PTR pyus_out$[rsp], rax

; 1596 :     Py_DECREF(temp);

  000d0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR temp$[rsp]
  000d5	e8 00 00 00 00	 call	 _Py_DecRef

; 1597 :     if (pyus_out == NULL)

  000da	48 83 7c 24 28
	00		 cmp	 QWORD PTR pyus_out$[rsp], 0
  000e0	75 02		 jne	 SHORT $LN9@multiply_f

; 1598 :         goto error;

  000e2	eb 20		 jmp	 SHORT $error$21748
$LN9@multiply_f:

; 1599 :     result = microseconds_to_delta(pyus_out);

  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  000eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_out$[rsp]
  000f0	e8 00 00 00 00	 call	 microseconds_to_delta_ex
  000f5	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 1600 :     Py_DECREF(pyus_out);

  000fa	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_out$[rsp]
  000ff	e8 00 00 00 00	 call	 _Py_DecRef
$error$21748:
$LN8@multiply_f:

; 1601 :  error:
; 1602 :     Py_XDECREF(pyus_in);

  00104	48 83 7c 24 30
	00		 cmp	 QWORD PTR pyus_in$[rsp], 0
  0010a	74 0a		 je	 SHORT $LN5@multiply_f
  0010c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  00111	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@multiply_f:
  00116	33 c0		 xor	 eax, eax
  00118	85 c0		 test	 eax, eax
  0011a	75 e8		 jne	 SHORT $LN8@multiply_f
$LN4@multiply_f:

; 1603 :     Py_XDECREF(ratio);

  0011c	48 83 7c 24 20
	00		 cmp	 QWORD PTR ratio$[rsp], 0
  00122	74 0a		 je	 SHORT $LN1@multiply_f
  00124	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ratio$[rsp]
  00129	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@multiply_f:
  0012e	33 c0		 xor	 eax, eax
  00130	85 c0		 test	 eax, eax
  00132	75 e8		 jne	 SHORT $LN4@multiply_f

; 1604 : 
; 1605 :     return result;

  00134	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN13@multiply_f:

; 1606 : }

  00139	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013d	c3		 ret	 0
multiply_float_timedelta ENDP
_TEXT	ENDS
EXTRN	_PyLong_DivmodNear:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$divide_nearest DD imagerel divide_nearest
	DD	imagerel divide_nearest+90
	DD	imagerel $unwind$divide_nearest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$divide_nearest DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT divide_nearest
_TEXT	SEGMENT
temp$ = 32
result$ = 40
m$ = 64
n$ = 72
divide_nearest PROC					; COMDAT

; 161  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 162  :     PyObject *result;
; 163  :     PyObject *temp;
; 164  : 
; 165  :     temp = _PyLong_DivmodNear(m, n);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR n$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR m$[rsp]
  00018	e8 00 00 00 00	 call	 _PyLong_DivmodNear
  0001d	48 89 44 24 20	 mov	 QWORD PTR temp$[rsp], rax

; 166  :     if (temp == NULL)

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR temp$[rsp], 0
  00028	75 04		 jne	 SHORT $LN1@divide_nea

; 167  :         return NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 27		 jmp	 SHORT $LN2@divide_nea
$LN1@divide_nea:

; 168  :     result = PyTuple_GET_ITEM(temp, 0);

  0002e	48 8b 44 24 20	 mov	 rax, QWORD PTR temp$[rsp]
  00033	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00037	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 169  :     Py_INCREF(result);

  0003c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00041	e8 00 00 00 00	 call	 _Py_IncRef

; 170  :     Py_DECREF(temp);

  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR temp$[rsp]
  0004b	e8 00 00 00 00	 call	 _Py_DecRef

; 171  : 
; 172  :     return result;

  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN2@divide_nea:

; 173  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
divide_nearest ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_divide DD imagerel delta_divide
	DD	imagerel delta_divide+212
	DD	imagerel $unwind$delta_divide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_divide DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_divide
_TEXT	SEGMENT
result$ = 32
left$ = 64
right$ = 72
delta_divide PROC					; COMDAT

; 1874 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1875 :     PyObject *result = Py_NotImplemented;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00015	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1876 : 
; 1877 :     if (PyDelta_Check(left)) {

  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR left$[rsp]
  00026	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002a	74 19		 je	 SHORT $LN6@delta_divi
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR left$[rsp]
  00038	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00041	85 c0		 test	 eax, eax
  00043	74 6d		 je	 SHORT $LN7@delta_divi
$LN6@delta_divi:

; 1878 :         /* delta * ??? */
; 1879 :         if (PyLong_Check(right))

  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR right$[rsp]
  0004a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00054	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00059	85 c0		 test	 eax, eax
  0005b	74 16		 je	 SHORT $LN5@delta_divi

; 1880 :             result = divide_timedelta_int(
; 1881 :                             (PyDateTime_Delta *)left,
; 1882 :                             right);

  0005d	48 8b 54 24 48	 mov	 rdx, QWORD PTR right$[rsp]
  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR left$[rsp]
  00067	e8 00 00 00 00	 call	 divide_timedelta_int
  0006c	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
  00071	eb 3f		 jmp	 SHORT $LN4@delta_divi
$LN5@delta_divi:

; 1883 :         else if (PyDelta_Check(right))

  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  0007a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR right$[rsp]
  0007f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00083	74 19		 je	 SHORT $LN2@delta_divi
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0008c	48 8b 44 24 48	 mov	 rax, QWORD PTR right$[rsp]
  00091	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00095	e8 00 00 00 00	 call	 PyType_IsSubtype
  0009a	85 c0		 test	 eax, eax
  0009c	74 14		 je	 SHORT $LN3@delta_divi
$LN2@delta_divi:

; 1884 :             result = divide_timedelta_timedelta(
; 1885 :                             (PyDateTime_Delta *)left,
; 1886 :                             (PyDateTime_Delta *)right);

  0009e	48 8b 54 24 48	 mov	 rdx, QWORD PTR right$[rsp]
  000a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR left$[rsp]
  000a8	e8 00 00 00 00	 call	 divide_timedelta_timedelta
  000ad	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN3@delta_divi:
$LN4@delta_divi:
$LN7@delta_divi:

; 1887 :     }
; 1888 : 
; 1889 :     if (result == Py_NotImplemented)

  000b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000b9	48 39 44 24 20	 cmp	 QWORD PTR result$[rsp], rax
  000be	75 0a		 jne	 SHORT $LN1@delta_divi

; 1890 :         Py_INCREF(result);

  000c0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  000c5	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@delta_divi:

; 1891 :     return result;

  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 1892 : }

  000cf	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d3	c3		 ret	 0
delta_divide ENDP
_TEXT	ENDS
EXTRN	PyNumber_FloorDivide:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$divide_timedelta_int DD imagerel divide_timedelta_int
	DD	imagerel divide_timedelta_int+125
	DD	imagerel $unwind$divide_timedelta_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$divide_timedelta_int DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT divide_timedelta_int
_TEXT	SEGMENT
pyus_out$ = 32
pyus_in$ = 40
result$ = 48
delta$ = 80
intobj$ = 88
divide_timedelta_int PROC				; COMDAT

; 1610 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1611 :     PyObject *pyus_in;
; 1612 :     PyObject *pyus_out;
; 1613 :     PyObject *result;
; 1614 : 
; 1615 :     pyus_in = delta_to_microseconds(delta);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delta$[rsp]
  00013	e8 00 00 00 00	 call	 delta_to_microseconds
  00018	48 89 44 24 28	 mov	 QWORD PTR pyus_in$[rsp], rax

; 1616 :     if (pyus_in == NULL)

  0001d	48 83 7c 24 28
	00		 cmp	 QWORD PTR pyus_in$[rsp], 0
  00023	75 04		 jne	 SHORT $LN2@divide_tim

; 1617 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 4f		 jmp	 SHORT $LN3@divide_tim
$LN2@divide_tim:

; 1618 : 
; 1619 :     pyus_out = PyNumber_FloorDivide(pyus_in, intobj);

  00029	48 8b 54 24 58	 mov	 rdx, QWORD PTR intobj$[rsp]
  0002e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  00033	e8 00 00 00 00	 call	 PyNumber_FloorDivide
  00038	48 89 44 24 20	 mov	 QWORD PTR pyus_out$[rsp], rax

; 1620 :     Py_DECREF(pyus_in);

  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  00042	e8 00 00 00 00	 call	 _Py_DecRef

; 1621 :     if (pyus_out == NULL)

  00047	48 83 7c 24 20
	00		 cmp	 QWORD PTR pyus_out$[rsp], 0
  0004d	75 04		 jne	 SHORT $LN1@divide_tim

; 1622 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	eb 25		 jmp	 SHORT $LN3@divide_tim
$LN1@divide_tim:

; 1623 : 
; 1624 :     result = microseconds_to_delta(pyus_out);

  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_out$[rsp]
  0005f	e8 00 00 00 00	 call	 microseconds_to_delta_ex
  00064	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1625 :     Py_DECREF(pyus_out);

  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_out$[rsp]
  0006e	e8 00 00 00 00	 call	 _Py_DecRef

; 1626 :     return result;

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN3@divide_tim:

; 1627 : }

  00078	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007c	c3		 ret	 0
divide_timedelta_int ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$divide_timedelta_timedelta DD imagerel divide_timedelta_timedelta
	DD	imagerel divide_timedelta_timedelta+128
	DD	imagerel $unwind$divide_timedelta_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$divide_timedelta_timedelta DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT divide_timedelta_timedelta
_TEXT	SEGMENT
pyus_left$ = 32
pyus_right$ = 40
result$ = 48
left$ = 80
right$ = 88
divide_timedelta_timedelta PROC				; COMDAT

; 1631 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1632 :     PyObject *pyus_left;
; 1633 :     PyObject *pyus_right;
; 1634 :     PyObject *result;
; 1635 : 
; 1636 :     pyus_left = delta_to_microseconds(left);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR left$[rsp]
  00013	e8 00 00 00 00	 call	 delta_to_microseconds
  00018	48 89 44 24 20	 mov	 QWORD PTR pyus_left$[rsp], rax

; 1637 :     if (pyus_left == NULL)

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR pyus_left$[rsp], 0
  00023	75 04		 jne	 SHORT $LN2@divide_tim@2

; 1638 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 52		 jmp	 SHORT $LN3@divide_tim@2
$LN2@divide_tim@2:

; 1639 : 
; 1640 :     pyus_right = delta_to_microseconds(right);

  00029	48 8b 4c 24 58	 mov	 rcx, QWORD PTR right$[rsp]
  0002e	e8 00 00 00 00	 call	 delta_to_microseconds
  00033	48 89 44 24 28	 mov	 QWORD PTR pyus_right$[rsp], rax

; 1641 :     if (pyus_right == NULL)     {

  00038	48 83 7c 24 28
	00		 cmp	 QWORD PTR pyus_right$[rsp], 0
  0003e	75 0e		 jne	 SHORT $LN1@divide_tim@2

; 1642 :         Py_DECREF(pyus_left);

  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  00045	e8 00 00 00 00	 call	 _Py_DecRef

; 1643 :         return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	eb 2d		 jmp	 SHORT $LN3@divide_tim@2
$LN1@divide_tim@2:

; 1644 :     }
; 1645 : 
; 1646 :     result = PyNumber_FloorDivide(pyus_left, pyus_right);

  0004e	48 8b 54 24 28	 mov	 rdx, QWORD PTR pyus_right$[rsp]
  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  00058	e8 00 00 00 00	 call	 PyNumber_FloorDivide
  0005d	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1647 :     Py_DECREF(pyus_left);

  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  00067	e8 00 00 00 00	 call	 _Py_DecRef

; 1648 :     Py_DECREF(pyus_right);

  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_right$[rsp]
  00071	e8 00 00 00 00	 call	 _Py_DecRef

; 1649 :     return result;

  00076	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN3@divide_tim@2:

; 1650 : }

  0007b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007f	c3		 ret	 0
divide_timedelta_timedelta ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_truedivide DD imagerel delta_truedivide
	DD	imagerel delta_truedivide+281
	DD	imagerel $unwind$delta_truedivide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_truedivide DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_truedivide
_TEXT	SEGMENT
result$ = 32
left$ = 64
right$ = 72
delta_truedivide PROC					; COMDAT

; 1896 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1897 :     PyObject *result = Py_NotImplemented;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00015	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1898 : 
; 1899 :     if (PyDelta_Check(left)) {

  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR left$[rsp]
  00026	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002a	74 1d		 je	 SHORT $LN9@delta_true
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR left$[rsp]
  00038	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00041	85 c0		 test	 eax, eax
  00043	0f 84 ae 00 00
	00		 je	 $LN10@delta_true
$LN9@delta_true:

; 1900 :         if (PyDelta_Check(right))

  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00050	48 8b 4c 24 48	 mov	 rcx, QWORD PTR right$[rsp]
  00055	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00059	74 19		 je	 SHORT $LN7@delta_true
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00062	48 8b 44 24 48	 mov	 rax, QWORD PTR right$[rsp]
  00067	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0006b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00070	85 c0		 test	 eax, eax
  00072	74 16		 je	 SHORT $LN8@delta_true
$LN7@delta_true:

; 1901 :             result = truedivide_timedelta_timedelta(
; 1902 :                             (PyDateTime_Delta *)left,
; 1903 :                             (PyDateTime_Delta *)right);

  00074	48 8b 54 24 48	 mov	 rdx, QWORD PTR right$[rsp]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR left$[rsp]
  0007e	e8 00 00 00 00	 call	 truedivide_timedelta_timedelta
  00083	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
  00088	eb 6d		 jmp	 SHORT $LN6@delta_true
$LN8@delta_true:

; 1904 :         else if (PyFloat_Check(right))

  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00091	48 8b 4c 24 48	 mov	 rcx, QWORD PTR right$[rsp]
  00096	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0009a	74 19		 je	 SHORT $LN4@delta_true
  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  000a3	48 8b 44 24 48	 mov	 rax, QWORD PTR right$[rsp]
  000a8	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000ac	e8 00 00 00 00	 call	 PyType_IsSubtype
  000b1	85 c0		 test	 eax, eax
  000b3	74 16		 je	 SHORT $LN5@delta_true
$LN4@delta_true:

; 1905 :             result = truedivide_timedelta_float(
; 1906 :                             (PyDateTime_Delta *)left, right);

  000b5	48 8b 54 24 48	 mov	 rdx, QWORD PTR right$[rsp]
  000ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR left$[rsp]
  000bf	e8 00 00 00 00	 call	 truedivide_timedelta_float
  000c4	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
  000c9	eb 2c		 jmp	 SHORT $LN3@delta_true
$LN5@delta_true:

; 1907 :         else if (PyLong_Check(right))

  000cb	48 8b 44 24 48	 mov	 rax, QWORD PTR right$[rsp]
  000d0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d4	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000da	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000df	85 c0		 test	 eax, eax
  000e1	74 14		 je	 SHORT $LN2@delta_true

; 1908 :             result = truedivide_timedelta_int(
; 1909 :                             (PyDateTime_Delta *)left, right);

  000e3	48 8b 54 24 48	 mov	 rdx, QWORD PTR right$[rsp]
  000e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR left$[rsp]
  000ed	e8 00 00 00 00	 call	 truedivide_timedelta_int
  000f2	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN2@delta_true:
$LN3@delta_true:
$LN6@delta_true:
$LN10@delta_true:

; 1910 :     }
; 1911 : 
; 1912 :     if (result == Py_NotImplemented)

  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000fe	48 39 44 24 20	 cmp	 QWORD PTR result$[rsp], rax
  00103	75 0a		 jne	 SHORT $LN1@delta_true

; 1913 :         Py_INCREF(result);

  00105	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  0010a	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@delta_true:

; 1914 :     return result;

  0010f	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 1915 : }

  00114	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00118	c3		 ret	 0
delta_truedivide ENDP
_TEXT	ENDS
EXTRN	PyNumber_TrueDivide:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$truedivide_timedelta_timedelta DD imagerel truedivide_timedelta_timedelta
	DD	imagerel truedivide_timedelta_timedelta+128
	DD	imagerel $unwind$truedivide_timedelta_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$truedivide_timedelta_timedelta DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT truedivide_timedelta_timedelta
_TEXT	SEGMENT
pyus_left$ = 32
pyus_right$ = 40
result$ = 48
left$ = 80
right$ = 88
truedivide_timedelta_timedelta PROC			; COMDAT

; 1654 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1655 :     PyObject *pyus_left;
; 1656 :     PyObject *pyus_right;
; 1657 :     PyObject *result;
; 1658 : 
; 1659 :     pyus_left = delta_to_microseconds(left);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR left$[rsp]
  00013	e8 00 00 00 00	 call	 delta_to_microseconds
  00018	48 89 44 24 20	 mov	 QWORD PTR pyus_left$[rsp], rax

; 1660 :     if (pyus_left == NULL)

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR pyus_left$[rsp], 0
  00023	75 04		 jne	 SHORT $LN2@truedivide

; 1661 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 52		 jmp	 SHORT $LN3@truedivide
$LN2@truedivide:

; 1662 : 
; 1663 :     pyus_right = delta_to_microseconds(right);

  00029	48 8b 4c 24 58	 mov	 rcx, QWORD PTR right$[rsp]
  0002e	e8 00 00 00 00	 call	 delta_to_microseconds
  00033	48 89 44 24 28	 mov	 QWORD PTR pyus_right$[rsp], rax

; 1664 :     if (pyus_right == NULL)     {

  00038	48 83 7c 24 28
	00		 cmp	 QWORD PTR pyus_right$[rsp], 0
  0003e	75 0e		 jne	 SHORT $LN1@truedivide

; 1665 :         Py_DECREF(pyus_left);

  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  00045	e8 00 00 00 00	 call	 _Py_DecRef

; 1666 :         return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	eb 2d		 jmp	 SHORT $LN3@truedivide
$LN1@truedivide:

; 1667 :     }
; 1668 : 
; 1669 :     result = PyNumber_TrueDivide(pyus_left, pyus_right);

  0004e	48 8b 54 24 28	 mov	 rdx, QWORD PTR pyus_right$[rsp]
  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  00058	e8 00 00 00 00	 call	 PyNumber_TrueDivide
  0005d	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1670 :     Py_DECREF(pyus_left);

  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  00067	e8 00 00 00 00	 call	 _Py_DecRef

; 1671 :     Py_DECREF(pyus_right);

  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_right$[rsp]
  00071	e8 00 00 00 00	 call	 _Py_DecRef

; 1672 :     return result;

  00076	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN3@truedivide:

; 1673 : }

  0007b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007f	c3		 ret	 0
truedivide_timedelta_timedelta ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$truedivide_timedelta_float DD imagerel truedivide_timedelta_float
	DD	imagerel truedivide_timedelta_float+318
	DD	imagerel $unwind$truedivide_timedelta_float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$truedivide_timedelta_float DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT truedivide_timedelta_float
_TEXT	SEGMENT
ratio$ = 32
pyus_out$ = 40
pyus_in$ = 48
temp$ = 56
result$ = 64
delta$ = 96
f$ = 104
truedivide_timedelta_float PROC				; COMDAT

; 1677 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1678 :     PyObject *result = NULL;

  0000e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 1679 :     PyObject *pyus_in = NULL, *temp, *pyus_out;

  00017	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR pyus_in$[rsp], 0

; 1680 :     PyObject *ratio = NULL;

  00020	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR ratio$[rsp], 0

; 1681 :     _Py_IDENTIFIER(as_integer_ratio);
; 1682 : 
; 1683 :     pyus_in = delta_to_microseconds(delta);

  00029	48 8b 4c 24 60	 mov	 rcx, QWORD PTR delta$[rsp]
  0002e	e8 00 00 00 00	 call	 delta_to_microseconds
  00033	48 89 44 24 30	 mov	 QWORD PTR pyus_in$[rsp], rax

; 1684 :     if (pyus_in == NULL)

  00038	48 83 7c 24 30
	00		 cmp	 QWORD PTR pyus_in$[rsp], 0
  0003e	75 07		 jne	 SHORT $LN12@truedivide@2

; 1685 :         return NULL;

  00040	33 c0		 xor	 eax, eax
  00042	e9 f2 00 00 00	 jmp	 $LN13@truedivide@2
$LN12@truedivide@2:

; 1686 :     ratio = _PyObject_CallMethodId(f, &PyId_as_integer_ratio, NULL);

  00047	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_as_integer_ratio@?1??truedivide_timedelta_float@@9@9
  0004c	8b c0		 mov	 eax, eax
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00054	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0005d	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00061	45 33 c0	 xor	 r8d, r8d
  00064	48 8b d0	 mov	 rdx, rax
  00067	48 8b 4c 24 68	 mov	 rcx, QWORD PTR f$[rsp]
  0006c	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00071	48 89 44 24 20	 mov	 QWORD PTR ratio$[rsp], rax

; 1687 :     if (ratio == NULL)

  00076	48 83 7c 24 20
	00		 cmp	 QWORD PTR ratio$[rsp], 0
  0007c	75 05		 jne	 SHORT $LN11@truedivide@2

; 1688 :         goto error;

  0007e	e9 81 00 00 00	 jmp	 $error$21844
$LN11@truedivide@2:

; 1689 :     temp = PyNumber_Multiply(pyus_in, PyTuple_GET_ITEM(ratio, 1));

  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR ratio$[rsp]
  00088	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  0008c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  00091	e8 00 00 00 00	 call	 PyNumber_Multiply
  00096	48 89 44 24 38	 mov	 QWORD PTR temp$[rsp], rax

; 1690 :     Py_DECREF(pyus_in);

  0009b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  000a0	e8 00 00 00 00	 call	 _Py_DecRef

; 1691 :     pyus_in = NULL;

  000a5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR pyus_in$[rsp], 0

; 1692 :     if (temp == NULL)

  000ae	48 83 7c 24 38
	00		 cmp	 QWORD PTR temp$[rsp], 0
  000b4	75 02		 jne	 SHORT $LN10@truedivide@2

; 1693 :         goto error;

  000b6	eb 4c		 jmp	 SHORT $error$21844
$LN10@truedivide@2:

; 1694 :     pyus_out = divide_nearest(temp, PyTuple_GET_ITEM(ratio, 0));

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR ratio$[rsp]
  000bd	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  000c1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR temp$[rsp]
  000c6	e8 00 00 00 00	 call	 divide_nearest
  000cb	48 89 44 24 28	 mov	 QWORD PTR pyus_out$[rsp], rax

; 1695 :     Py_DECREF(temp);

  000d0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR temp$[rsp]
  000d5	e8 00 00 00 00	 call	 _Py_DecRef

; 1696 :     if (pyus_out == NULL)

  000da	48 83 7c 24 28
	00		 cmp	 QWORD PTR pyus_out$[rsp], 0
  000e0	75 02		 jne	 SHORT $LN9@truedivide@2

; 1697 :         goto error;

  000e2	eb 20		 jmp	 SHORT $error$21844
$LN9@truedivide@2:

; 1698 :     result = microseconds_to_delta(pyus_out);

  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  000eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_out$[rsp]
  000f0	e8 00 00 00 00	 call	 microseconds_to_delta_ex
  000f5	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 1699 :     Py_DECREF(pyus_out);

  000fa	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_out$[rsp]
  000ff	e8 00 00 00 00	 call	 _Py_DecRef
$error$21844:
$LN8@truedivide@2:

; 1700 :  error:
; 1701 :     Py_XDECREF(pyus_in);

  00104	48 83 7c 24 30
	00		 cmp	 QWORD PTR pyus_in$[rsp], 0
  0010a	74 0a		 je	 SHORT $LN5@truedivide@2
  0010c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  00111	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@truedivide@2:
  00116	33 c0		 xor	 eax, eax
  00118	85 c0		 test	 eax, eax
  0011a	75 e8		 jne	 SHORT $LN8@truedivide@2
$LN4@truedivide@2:

; 1702 :     Py_XDECREF(ratio);

  0011c	48 83 7c 24 20
	00		 cmp	 QWORD PTR ratio$[rsp], 0
  00122	74 0a		 je	 SHORT $LN1@truedivide@2
  00124	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ratio$[rsp]
  00129	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@truedivide@2:
  0012e	33 c0		 xor	 eax, eax
  00130	85 c0		 test	 eax, eax
  00132	75 e8		 jne	 SHORT $LN4@truedivide@2

; 1703 : 
; 1704 :     return result;

  00134	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN13@truedivide@2:

; 1705 : }

  00139	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013d	c3		 ret	 0
truedivide_timedelta_float ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$truedivide_timedelta_int DD imagerel truedivide_timedelta_int
	DD	imagerel truedivide_timedelta_int+125
	DD	imagerel $unwind$truedivide_timedelta_int
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$truedivide_timedelta_int DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT truedivide_timedelta_int
_TEXT	SEGMENT
pyus_out$ = 32
pyus_in$ = 40
result$ = 48
delta$ = 80
i$ = 88
truedivide_timedelta_int PROC				; COMDAT

; 1709 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1710 :     PyObject *result;
; 1711 :     PyObject *pyus_in, *pyus_out;
; 1712 :     pyus_in = delta_to_microseconds(delta);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR delta$[rsp]
  00013	e8 00 00 00 00	 call	 delta_to_microseconds
  00018	48 89 44 24 28	 mov	 QWORD PTR pyus_in$[rsp], rax

; 1713 :     if (pyus_in == NULL)

  0001d	48 83 7c 24 28
	00		 cmp	 QWORD PTR pyus_in$[rsp], 0
  00023	75 04		 jne	 SHORT $LN2@truedivide@3

; 1714 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 4f		 jmp	 SHORT $LN3@truedivide@3
$LN2@truedivide@3:

; 1715 :     pyus_out = divide_nearest(pyus_in, i);

  00029	48 8b 54 24 58	 mov	 rdx, QWORD PTR i$[rsp]
  0002e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  00033	e8 00 00 00 00	 call	 divide_nearest
  00038	48 89 44 24 20	 mov	 QWORD PTR pyus_out$[rsp], rax

; 1716 :     Py_DECREF(pyus_in);

  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_in$[rsp]
  00042	e8 00 00 00 00	 call	 _Py_DecRef

; 1717 :     if (pyus_out == NULL)

  00047	48 83 7c 24 20
	00		 cmp	 QWORD PTR pyus_out$[rsp], 0
  0004d	75 04		 jne	 SHORT $LN1@truedivide@3

; 1718 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	eb 25		 jmp	 SHORT $LN3@truedivide@3
$LN1@truedivide@3:

; 1719 :     result = microseconds_to_delta(pyus_out);

  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_out$[rsp]
  0005f	e8 00 00 00 00	 call	 microseconds_to_delta_ex
  00064	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1720 :     Py_DECREF(pyus_out);

  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_out$[rsp]
  0006e	e8 00 00 00 00	 call	 _Py_DecRef

; 1721 : 
; 1722 :     return result;

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN3@truedivide@3:

; 1723 : }

  00078	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007c	c3		 ret	 0
truedivide_timedelta_int ENDP
_TEXT	ENDS
EXTRN	PyNumber_Remainder:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_remainder DD imagerel delta_remainder
	DD	imagerel delta_remainder+297
	DD	imagerel $unwind$delta_remainder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_remainder DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_remainder
_TEXT	SEGMENT
pyus_left$ = 32
remainder$ = 40
pyus_right$ = 48
pyus_remainder$ = 56
left$ = 80
right$ = 88
delta_remainder PROC					; COMDAT

; 1919 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1920 :     PyObject *pyus_left;
; 1921 :     PyObject *pyus_right;
; 1922 :     PyObject *pyus_remainder;
; 1923 :     PyObject *remainder;
; 1924 : 
; 1925 :     if (!PyDelta_Check(left) || !PyDelta_Check(right))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR left$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 19		 je	 SHORT $LN5@delta_rema
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR left$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	74 2b		 je	 SHORT $LN6@delta_rema
$LN5@delta_rema:
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00040	48 8b 4c 24 58	 mov	 rcx, QWORD PTR right$[rsp]
  00045	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00049	74 31		 je	 SHORT $LN7@delta_rema
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00052	48 8b 44 24 58	 mov	 rax, QWORD PTR right$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 18		 jne	 SHORT $LN7@delta_rema
$LN6@delta_rema:

; 1926 :         Py_RETURN_NOTIMPLEMENTED;

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0006b	e8 00 00 00 00	 call	 _Py_IncRef
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00077	e9 a8 00 00 00	 jmp	 $LN8@delta_rema
$LN7@delta_rema:

; 1927 : 
; 1928 :     pyus_left = delta_to_microseconds((PyDateTime_Delta *)left);

  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR left$[rsp]
  00081	e8 00 00 00 00	 call	 delta_to_microseconds
  00086	48 89 44 24 20	 mov	 QWORD PTR pyus_left$[rsp], rax

; 1929 :     if (pyus_left == NULL)

  0008b	48 83 7c 24 20
	00		 cmp	 QWORD PTR pyus_left$[rsp], 0
  00091	75 07		 jne	 SHORT $LN4@delta_rema

; 1930 :         return NULL;

  00093	33 c0		 xor	 eax, eax
  00095	e9 8a 00 00 00	 jmp	 $LN8@delta_rema
$LN4@delta_rema:

; 1931 : 
; 1932 :     pyus_right = delta_to_microseconds((PyDateTime_Delta *)right);

  0009a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR right$[rsp]
  0009f	e8 00 00 00 00	 call	 delta_to_microseconds
  000a4	48 89 44 24 30	 mov	 QWORD PTR pyus_right$[rsp], rax

; 1933 :     if (pyus_right == NULL) {

  000a9	48 83 7c 24 30
	00		 cmp	 QWORD PTR pyus_right$[rsp], 0
  000af	75 0e		 jne	 SHORT $LN3@delta_rema

; 1934 :         Py_DECREF(pyus_left);

  000b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  000b6	e8 00 00 00 00	 call	 _Py_DecRef

; 1935 :         return NULL;

  000bb	33 c0		 xor	 eax, eax
  000bd	eb 65		 jmp	 SHORT $LN8@delta_rema
$LN3@delta_rema:

; 1936 :     }
; 1937 : 
; 1938 :     pyus_remainder = PyNumber_Remainder(pyus_left, pyus_right);

  000bf	48 8b 54 24 30	 mov	 rdx, QWORD PTR pyus_right$[rsp]
  000c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  000c9	e8 00 00 00 00	 call	 PyNumber_Remainder
  000ce	48 89 44 24 38	 mov	 QWORD PTR pyus_remainder$[rsp], rax

; 1939 :     Py_DECREF(pyus_left);

  000d3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  000d8	e8 00 00 00 00	 call	 _Py_DecRef

; 1940 :     Py_DECREF(pyus_right);

  000dd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pyus_right$[rsp]
  000e2	e8 00 00 00 00	 call	 _Py_DecRef

; 1941 :     if (pyus_remainder == NULL)

  000e7	48 83 7c 24 38
	00		 cmp	 QWORD PTR pyus_remainder$[rsp], 0
  000ed	75 04		 jne	 SHORT $LN2@delta_rema

; 1942 :         return NULL;

  000ef	33 c0		 xor	 eax, eax
  000f1	eb 31		 jmp	 SHORT $LN8@delta_rema
$LN2@delta_rema:

; 1943 : 
; 1944 :     remainder = microseconds_to_delta(pyus_remainder);

  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  000fa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pyus_remainder$[rsp]
  000ff	e8 00 00 00 00	 call	 microseconds_to_delta_ex
  00104	48 89 44 24 28	 mov	 QWORD PTR remainder$[rsp], rax

; 1945 :     Py_DECREF(pyus_remainder);

  00109	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pyus_remainder$[rsp]
  0010e	e8 00 00 00 00	 call	 _Py_DecRef

; 1946 :     if (remainder == NULL)

  00113	48 83 7c 24 28
	00		 cmp	 QWORD PTR remainder$[rsp], 0
  00119	75 04		 jne	 SHORT $LN1@delta_rema

; 1947 :         return NULL;

  0011b	33 c0		 xor	 eax, eax
  0011d	eb 05		 jmp	 SHORT $LN8@delta_rema
$LN1@delta_rema:

; 1948 : 
; 1949 :     return remainder;

  0011f	48 8b 44 24 28	 mov	 rax, QWORD PTR remainder$[rsp]
$LN8@delta_rema:

; 1950 : }

  00124	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00128	c3		 ret	 0
delta_remainder ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DE@GADFDJJF@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAi?$AAv?$AAm?$AAo?$AAd?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?$AA@ ; `string'
EXTRN	PyTuple_Pack:PROC
EXTRN	PyTuple_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_divmod DD imagerel delta_divmod
	DD	imagerel delta_divmod+400
	DD	imagerel $unwind$delta_divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_divmod DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1DE@GADFDJJF@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAi?$AAv?$AAm?$AAo?$AAd?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@GADFDJJF@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAi?$AAv?$AAm?$AAo?$AAd?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'T', 00H, 'u', 00H, 'p', 00H, 'l', 00H, 'e', 00H
	DB	'_', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '(', 00H, 'd'
	DB	00H, 'i', 00H, 'v', 00H, 'm', 00H, 'o', 00H, 'd', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '2', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT delta_divmod
_TEXT	SEGMENT
divmod$ = 32
pyus_left$ = 40
pyus_right$ = 48
result$ = 56
delta$ = 64
left$ = 96
right$ = 104
delta_divmod PROC					; COMDAT

; 1954 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1955 :     PyObject *pyus_left;
; 1956 :     PyObject *pyus_right;
; 1957 :     PyObject *divmod;
; 1958 :     PyObject *delta;
; 1959 :     PyObject *result;
; 1960 : 
; 1961 :     if (!PyDelta_Check(left) || !PyDelta_Check(right))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00015	48 8b 4c 24 60	 mov	 rcx, QWORD PTR left$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 19		 je	 SHORT $LN5@delta_divm
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00027	48 8b 44 24 60	 mov	 rax, QWORD PTR left$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	74 2b		 je	 SHORT $LN6@delta_divm
$LN5@delta_divm:
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00040	48 8b 4c 24 68	 mov	 rcx, QWORD PTR right$[rsp]
  00045	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00049	74 31		 je	 SHORT $LN7@delta_divm
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00052	48 8b 44 24 68	 mov	 rax, QWORD PTR right$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	75 18		 jne	 SHORT $LN7@delta_divm
$LN6@delta_divm:

; 1962 :         Py_RETURN_NOTIMPLEMENTED;

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0006b	e8 00 00 00 00	 call	 _Py_IncRef
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00077	e9 0f 01 00 00	 jmp	 $LN8@delta_divm
$LN7@delta_divm:

; 1963 : 
; 1964 :     pyus_left = delta_to_microseconds((PyDateTime_Delta *)left);

  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR left$[rsp]
  00081	e8 00 00 00 00	 call	 delta_to_microseconds
  00086	48 89 44 24 28	 mov	 QWORD PTR pyus_left$[rsp], rax

; 1965 :     if (pyus_left == NULL)

  0008b	48 83 7c 24 28
	00		 cmp	 QWORD PTR pyus_left$[rsp], 0
  00091	75 07		 jne	 SHORT $LN4@delta_divm

; 1966 :         return NULL;

  00093	33 c0		 xor	 eax, eax
  00095	e9 f1 00 00 00	 jmp	 $LN8@delta_divm
$LN4@delta_divm:

; 1967 : 
; 1968 :     pyus_right = delta_to_microseconds((PyDateTime_Delta *)right);

  0009a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR right$[rsp]
  0009f	e8 00 00 00 00	 call	 delta_to_microseconds
  000a4	48 89 44 24 30	 mov	 QWORD PTR pyus_right$[rsp], rax

; 1969 :     if (pyus_right == NULL) {

  000a9	48 83 7c 24 30
	00		 cmp	 QWORD PTR pyus_right$[rsp], 0
  000af	75 11		 jne	 SHORT $LN3@delta_divm

; 1970 :         Py_DECREF(pyus_left);

  000b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  000b6	e8 00 00 00 00	 call	 _Py_DecRef

; 1971 :         return NULL;

  000bb	33 c0		 xor	 eax, eax
  000bd	e9 c9 00 00 00	 jmp	 $LN8@delta_divm
$LN3@delta_divm:

; 1972 :     }
; 1973 : 
; 1974 :     divmod = PyNumber_Divmod(pyus_left, pyus_right);

  000c2	48 8b 54 24 30	 mov	 rdx, QWORD PTR pyus_right$[rsp]
  000c7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  000cc	e8 00 00 00 00	 call	 PyNumber_Divmod
  000d1	48 89 44 24 20	 mov	 QWORD PTR divmod$[rsp], rax

; 1975 :     Py_DECREF(pyus_left);

  000d6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pyus_left$[rsp]
  000db	e8 00 00 00 00	 call	 _Py_DecRef

; 1976 :     Py_DECREF(pyus_right);

  000e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pyus_right$[rsp]
  000e5	e8 00 00 00 00	 call	 _Py_DecRef

; 1977 :     if (divmod == NULL)

  000ea	48 83 7c 24 20
	00		 cmp	 QWORD PTR divmod$[rsp], 0
  000f0	75 07		 jne	 SHORT $LN2@delta_divm

; 1978 :         return NULL;

  000f2	33 c0		 xor	 eax, eax
  000f4	e9 92 00 00 00	 jmp	 $LN8@delta_divm
$LN2@delta_divm:

; 1979 : 
; 1980 :     assert(PyTuple_Size(divmod) == 2);

  000f9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR divmod$[rsp]
  000fe	e8 00 00 00 00	 call	 PyTuple_Size
  00103	48 83 f8 02	 cmp	 rax, 2
  00107	74 1c		 je	 SHORT $LN10@delta_divm
  00109	41 b8 bc 07 00
	00		 mov	 r8d, 1980		; 000007bcH
  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DE@GADFDJJF@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAd?$AAi?$AAv?$AAm?$AAo?$AAd?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA2?$AA?$AA@
  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00123	33 c0		 xor	 eax, eax
$LN10@delta_divm:

; 1981 :     delta = microseconds_to_delta(PyTuple_GET_ITEM(divmod, 1));

  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0012c	48 8b 44 24 20	 mov	 rax, QWORD PTR divmod$[rsp]
  00131	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00135	e8 00 00 00 00	 call	 microseconds_to_delta_ex
  0013a	48 89 44 24 40	 mov	 QWORD PTR delta$[rsp], rax

; 1982 :     if (delta == NULL) {

  0013f	48 83 7c 24 40
	00		 cmp	 QWORD PTR delta$[rsp], 0
  00145	75 0e		 jne	 SHORT $LN1@delta_divm

; 1983 :         Py_DECREF(divmod);

  00147	48 8b 4c 24 20	 mov	 rcx, QWORD PTR divmod$[rsp]
  0014c	e8 00 00 00 00	 call	 _Py_DecRef

; 1984 :         return NULL;

  00151	33 c0		 xor	 eax, eax
  00153	eb 36		 jmp	 SHORT $LN8@delta_divm
$LN1@delta_divm:

; 1985 :     }
; 1986 :     result = PyTuple_Pack(2, PyTuple_GET_ITEM(divmod, 0), delta);

  00155	4c 8b 44 24 40	 mov	 r8, QWORD PTR delta$[rsp]
  0015a	48 8b 44 24 20	 mov	 rax, QWORD PTR divmod$[rsp]
  0015f	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00163	b9 02 00 00 00	 mov	 ecx, 2
  00168	e8 00 00 00 00	 call	 PyTuple_Pack
  0016d	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 1987 :     Py_DECREF(delta);

  00172	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delta$[rsp]
  00177	e8 00 00 00 00	 call	 _Py_DecRef

; 1988 :     Py_DECREF(divmod);

  0017c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR divmod$[rsp]
  00181	e8 00 00 00 00	 call	 _Py_DecRef

; 1989 :     return result;

  00186	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN8@delta_divm:

; 1990 : }

  0018b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018f	c3		 ret	 0
delta_divmod ENDP
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	??_C@_0BB@DBPOALAA@?$HMOOOOOOO?3__new__?$AA@	; `string'
EXTRN	PyArg_ParseTupleAndKeywords:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_new DD imagerel delta_new
	DD	imagerel delta_new+1116
	DD	imagerel $unwind$delta_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_new DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT ??_C@_0BB@DBPOALAA@?$HMOOOOOOO?3__new__?$AA@
CONST	SEGMENT
??_C@_0BB@DBPOALAA@?$HMOOOOOOO?3__new__?$AA@ DB '|OOOOOOO:__new__', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT delta_new
_TEXT	SEGMENT
day$ = 96
leftover_us$ = 104
y$ = 112
x$ = 120
ms$ = 128
second$ = 136
minute$ = 144
hour$ = 152
self$ = 160
week$ = 168
us$ = 176
temp$22296 = 184
type$ = 208
args$ = 216
kw$ = 224
delta_new PROC						; COMDAT

; 2084 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 2085 :     PyObject *self = NULL;

  00016	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR self$[rsp], 0

; 2086 : 
; 2087 :     /* Argument objects. */
; 2088 :     PyObject *day = NULL;

  00022	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR day$[rsp], 0

; 2089 :     PyObject *second = NULL;

  0002b	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR second$[rsp], 0

; 2090 :     PyObject *us = NULL;

  00037	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR us$[rsp], 0

; 2091 :     PyObject *ms = NULL;

  00043	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ms$[rsp], 0

; 2092 :     PyObject *minute = NULL;

  0004f	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR minute$[rsp], 0

; 2093 :     PyObject *hour = NULL;

  0005b	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR hour$[rsp], 0

; 2094 :     PyObject *week = NULL;

  00067	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR week$[rsp], 0

; 2095 : 
; 2096 :     PyObject *x = NULL;         /* running sum of microseconds */

  00073	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 2097 :     PyObject *y = NULL;         /* temp sum of microseconds */

  0007c	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR y$[rsp], 0

; 2098 :     double leftover_us = 0.0;

  00085	66 0f 57 c0	 xorpd	 xmm0, xmm0
  00089	f2 0f 11 44 24
	68		 movsdx	 QWORD PTR leftover_us$[rsp], xmm0

; 2099 : 
; 2100 :     static char *keywords[] = {
; 2101 :         "days", "seconds", "microseconds", "milliseconds",
; 2102 :         "minutes", "hours", "weeks", NULL
; 2103 :     };
; 2104 : 
; 2105 :     if (PyArg_ParseTupleAndKeywords(args, kw, "|OOOOOOO:__new__",
; 2106 :                                     keywords,
; 2107 :                                     &day, &second, &us,
; 2108 :                                     &ms, &minute, &hour, &week) == 0)

  0008f	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR week$[rsp]
  00097	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0009c	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR hour$[rsp]
  000a4	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  000a9	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR minute$[rsp]
  000b1	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000b6	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR ms$[rsp]
  000be	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000c3	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR us$[rsp]
  000cb	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000d0	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR second$[rsp]
  000d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000dd	48 8d 44 24 60	 lea	 rax, QWORD PTR day$[rsp]
  000e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??delta_new@@9@9
  000ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@DBPOALAA@?$HMOOOOOOO?3__new__?$AA@
  000f5	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  000fd	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00105	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0010a	85 c0		 test	 eax, eax
  0010c	75 05		 jne	 SHORT $LN19@delta_new

; 2109 :         goto Done;

  0010e	e9 39 03 00 00	 jmp	 $Done$22263
$LN19@delta_new:

; 2110 : 
; 2111 :     x = PyLong_FromLong(0);

  00113	33 c9		 xor	 ecx, ecx
  00115	e8 00 00 00 00	 call	 PyLong_FromLong
  0011a	48 89 44 24 78	 mov	 QWORD PTR x$[rsp], rax

; 2112 :     if (x == NULL)

  0011f	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  00125	75 05		 jne	 SHORT $LN18@delta_new

; 2113 :         goto Done;

  00127	e9 20 03 00 00	 jmp	 $Done$22263
$LN18@delta_new:

; 2114 : 
; 2115 : #define CLEANUP         \
; 2116 :     Py_DECREF(x);       \
; 2117 :     x = y;              \
; 2118 :     if (x == NULL)      \
; 2119 :         goto Done
; 2120 : 
; 2121 :     if (us) {

  0012c	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR us$[rsp], 0
  00135	74 50		 je	 SHORT $LN17@delta_new

; 2122 :         y = accum("microseconds", x, us, us_per_us, &leftover_us);

  00137	48 8d 44 24 68	 lea	 rax, QWORD PTR leftover_us$[rsp]
  0013c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00141	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_us
  00148	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR us$[rsp]
  00150	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@EKJJBPIN@microseconds?$AA@
  0015c	e8 00 00 00 00	 call	 accum
  00161	48 89 44 24 70	 mov	 QWORD PTR y$[rsp], rax

; 2123 :         CLEANUP;

  00166	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  0016b	e8 00 00 00 00	 call	 _Py_DecRef
  00170	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  00175	48 89 44 24 78	 mov	 QWORD PTR x$[rsp], rax
  0017a	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  00180	75 05		 jne	 SHORT $LN16@delta_new
  00182	e9 c5 02 00 00	 jmp	 $Done$22263
$LN16@delta_new:
$LN17@delta_new:

; 2124 :     }
; 2125 :     if (ms) {

  00187	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR ms$[rsp], 0
  00190	74 50		 je	 SHORT $LN15@delta_new

; 2126 :         y = accum("milliseconds", x, ms, us_per_ms, &leftover_us);

  00192	48 8d 44 24 68	 lea	 rax, QWORD PTR leftover_us$[rsp]
  00197	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019c	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_ms
  001a3	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR ms$[rsp]
  001ab	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@JDBMCDJK@milliseconds?$AA@
  001b7	e8 00 00 00 00	 call	 accum
  001bc	48 89 44 24 70	 mov	 QWORD PTR y$[rsp], rax

; 2127 :         CLEANUP;

  001c1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  001c6	e8 00 00 00 00	 call	 _Py_DecRef
  001cb	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  001d0	48 89 44 24 78	 mov	 QWORD PTR x$[rsp], rax
  001d5	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  001db	75 05		 jne	 SHORT $LN14@delta_new
  001dd	e9 6a 02 00 00	 jmp	 $Done$22263
$LN14@delta_new:
$LN15@delta_new:

; 2128 :     }
; 2129 :     if (second) {

  001e2	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR second$[rsp], 0
  001eb	74 50		 je	 SHORT $LN13@delta_new

; 2130 :         y = accum("seconds", x, second, us_per_second, &leftover_us);

  001ed	48 8d 44 24 68	 lea	 rax, QWORD PTR leftover_us$[rsp]
  001f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f7	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_second
  001fe	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR second$[rsp]
  00206	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07GELLIBDG@seconds?$AA@
  00212	e8 00 00 00 00	 call	 accum
  00217	48 89 44 24 70	 mov	 QWORD PTR y$[rsp], rax

; 2131 :         CLEANUP;

  0021c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  00221	e8 00 00 00 00	 call	 _Py_DecRef
  00226	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  0022b	48 89 44 24 78	 mov	 QWORD PTR x$[rsp], rax
  00230	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  00236	75 05		 jne	 SHORT $LN12@delta_new
  00238	e9 0f 02 00 00	 jmp	 $Done$22263
$LN12@delta_new:
$LN13@delta_new:

; 2132 :     }
; 2133 :     if (minute) {

  0023d	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR minute$[rsp], 0
  00246	74 50		 je	 SHORT $LN11@delta_new

; 2134 :         y = accum("minutes", x, minute, us_per_minute, &leftover_us);

  00248	48 8d 44 24 68	 lea	 rax, QWORD PTR leftover_us$[rsp]
  0024d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00252	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_minute
  00259	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR minute$[rsp]
  00261	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  00266	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07GCICIJGK@minutes?$AA@
  0026d	e8 00 00 00 00	 call	 accum
  00272	48 89 44 24 70	 mov	 QWORD PTR y$[rsp], rax

; 2135 :         CLEANUP;

  00277	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  0027c	e8 00 00 00 00	 call	 _Py_DecRef
  00281	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  00286	48 89 44 24 78	 mov	 QWORD PTR x$[rsp], rax
  0028b	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  00291	75 05		 jne	 SHORT $LN10@delta_new
  00293	e9 b4 01 00 00	 jmp	 $Done$22263
$LN10@delta_new:
$LN11@delta_new:

; 2136 :     }
; 2137 :     if (hour) {

  00298	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR hour$[rsp], 0
  002a1	74 50		 je	 SHORT $LN9@delta_new

; 2138 :         y = accum("hours", x, hour, us_per_hour, &leftover_us);

  002a3	48 8d 44 24 68	 lea	 rax, QWORD PTR leftover_us$[rsp]
  002a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ad	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_hour
  002b4	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR hour$[rsp]
  002bc	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  002c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LOHOPFFC@hours?$AA@
  002c8	e8 00 00 00 00	 call	 accum
  002cd	48 89 44 24 70	 mov	 QWORD PTR y$[rsp], rax

; 2139 :         CLEANUP;

  002d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  002d7	e8 00 00 00 00	 call	 _Py_DecRef
  002dc	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  002e1	48 89 44 24 78	 mov	 QWORD PTR x$[rsp], rax
  002e6	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  002ec	75 05		 jne	 SHORT $LN8@delta_new
  002ee	e9 59 01 00 00	 jmp	 $Done$22263
$LN8@delta_new:
$LN9@delta_new:

; 2140 :     }
; 2141 :     if (day) {

  002f3	48 83 7c 24 60
	00		 cmp	 QWORD PTR day$[rsp], 0
  002f9	74 4d		 je	 SHORT $LN7@delta_new

; 2142 :         y = accum("days", x, day, us_per_day, &leftover_us);

  002fb	48 8d 44 24 68	 lea	 rax, QWORD PTR leftover_us$[rsp]
  00300	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00305	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_day
  0030c	4c 8b 44 24 60	 mov	 r8, QWORD PTR day$[rsp]
  00311	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  00316	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IJMHDAOD@days?$AA@
  0031d	e8 00 00 00 00	 call	 accum
  00322	48 89 44 24 70	 mov	 QWORD PTR y$[rsp], rax

; 2143 :         CLEANUP;

  00327	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  0032c	e8 00 00 00 00	 call	 _Py_DecRef
  00331	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  00336	48 89 44 24 78	 mov	 QWORD PTR x$[rsp], rax
  0033b	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  00341	75 05		 jne	 SHORT $LN6@delta_new
  00343	e9 04 01 00 00	 jmp	 $Done$22263
$LN6@delta_new:
$LN7@delta_new:

; 2144 :     }
; 2145 :     if (week) {

  00348	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR week$[rsp], 0
  00351	74 50		 je	 SHORT $LN5@delta_new

; 2146 :         y = accum("weeks", x, week, us_per_week, &leftover_us);

  00353	48 8d 44 24 68	 lea	 rax, QWORD PTR leftover_us$[rsp]
  00358	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0035d	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR us_per_week
  00364	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR week$[rsp]
  0036c	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  00371	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05EFKAJCNN@weeks?$AA@
  00378	e8 00 00 00 00	 call	 accum
  0037d	48 89 44 24 70	 mov	 QWORD PTR y$[rsp], rax

; 2147 :         CLEANUP;

  00382	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  00387	e8 00 00 00 00	 call	 _Py_DecRef
  0038c	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  00391	48 89 44 24 78	 mov	 QWORD PTR x$[rsp], rax
  00396	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  0039c	75 05		 jne	 SHORT $LN4@delta_new
  0039e	e9 a9 00 00 00	 jmp	 $Done$22263
$LN4@delta_new:
$LN5@delta_new:

; 2148 :     }
; 2149 :     if (leftover_us) {

  003a3	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR leftover_us$[rsp]
  003a9	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  003b1	7a 02		 jp	 SHORT $LN22@delta_new
  003b3	74 73		 je	 SHORT $LN3@delta_new
$LN22@delta_new:

; 2150 :         /* Round to nearest whole # of us, and add into x. */
; 2151 :         PyObject *temp = PyLong_FromLong(round_to_long(leftover_us));

  003b5	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR leftover_us$[rsp]
  003bb	e8 00 00 00 00	 call	 round_to_long
  003c0	8b c8		 mov	 ecx, eax
  003c2	e8 00 00 00 00	 call	 PyLong_FromLong
  003c7	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR temp$22296[rsp], rax

; 2152 :         if (temp == NULL) {

  003cf	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR temp$22296[rsp], 0
  003d8	75 0c		 jne	 SHORT $LN2@delta_new

; 2153 :             Py_DECREF(x);

  003da	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  003df	e8 00 00 00 00	 call	 _Py_DecRef

; 2154 :             goto Done;

  003e4	eb 66		 jmp	 SHORT $Done$22263
$LN2@delta_new:

; 2155 :         }
; 2156 :         y = PyNumber_Add(x, temp);

  003e6	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR temp$22296[rsp]
  003ee	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  003f3	e8 00 00 00 00	 call	 PyNumber_Add
  003f8	48 89 44 24 70	 mov	 QWORD PTR y$[rsp], rax

; 2157 :         Py_DECREF(temp);

  003fd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR temp$22296[rsp]
  00405	e8 00 00 00 00	 call	 _Py_DecRef

; 2158 :         CLEANUP;

  0040a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  0040f	e8 00 00 00 00	 call	 _Py_DecRef
  00414	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  00419	48 89 44 24 78	 mov	 QWORD PTR x$[rsp], rax
  0041e	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  00424	75 02		 jne	 SHORT $LN1@delta_new
  00426	eb 24		 jmp	 SHORT $Done$22263
$LN1@delta_new:
$LN3@delta_new:

; 2159 :     }
; 2160 : 
; 2161 :     self = microseconds_to_delta_ex(x, type);

  00428	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR type$[rsp]
  00430	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  00435	e8 00 00 00 00	 call	 microseconds_to_delta_ex
  0043a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR self$[rsp], rax

; 2162 :     Py_DECREF(x);

  00442	48 8b 4c 24 78	 mov	 rcx, QWORD PTR x$[rsp]
  00447	e8 00 00 00 00	 call	 _Py_DecRef
$Done$22263:

; 2163 : Done:
; 2164 :     return self;

  0044c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]

; 2165 : 
; 2166 : #undef CLEANUP
; 2167 : }

  00454	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0045b	c3		 ret	 0
delta_new ENDP
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
EXTRN	__imp_ceil:PROC
EXTRN	__imp_floor:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$round_to_long DD imagerel round_to_long
	DD	imagerel round_to_long+91
	DD	imagerel $unwind$round_to_long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$round_to_long DD 010a01H
	DD	0420aH
xdata	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT round_to_long
_TEXT	SEGMENT
x$ = 48
round_to_long PROC					; COMDAT

; 148  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 149  :     if (x >= 0.0)

  0000a	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00010	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@0000000000000000
  00018	72 1c		 jb	 SHORT $LN2@round_to_l

; 150  :         x = floor(x + 0.5);

  0001a	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  00020	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_floor
  0002e	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR x$[rsp], xmm0

; 151  :     else

  00034	eb 1a		 jmp	 SHORT $LN1@round_to_l
$LN2@round_to_l:

; 152  :         x = ceil(x - 0.5);

  00036	f2 0f 10 44 24
	30		 movsdx	 xmm0, QWORD PTR x$[rsp]
  0003c	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ceil
  0004a	f2 0f 11 44 24
	30		 movsdx	 QWORD PTR x$[rsp], xmm0
$LN1@round_to_l:

; 153  :     return (long)x;

  00050	f2 0f 2c 44 24
	30		 cvttsd2si eax, QWORD PTR x$[rsp]

; 154  : }

  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005a	c3		 ret	 0
round_to_long ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@BBEBJCPJ@unsupported?5type?5for?5timedelta?5?$CF@ ; `string'
PUBLIC	??_C@_1CK@KMBDOCAH@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	__real@bff0000000000000
PUBLIC	??_C@_1BI@LBPPPCD@?$AAn?$AAu?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyLong_AsDouble:PROC
EXTRN	PyLong_FromDouble:PROC
EXTRN	__imp_modf:PROC
EXTRN	PyFloat_AsDouble:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$accum DD	imagerel accum
	DD	imagerel accum+730
	DD	imagerel $unwind$accum
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$accum DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT ??_C@_0DA@BBEBJCPJ@unsupported?5type?5for?5timedelta?5?$CF@
CONST	SEGMENT
??_C@_0DA@BBEBJCPJ@unsupported?5type?5for?5timedelta?5?$CF@ DB 'unsupport'
	DB	'ed type for timedelta %s component: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@KMBDOCAH@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@KMBDOCAH@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'f'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT ??_C@_1BI@LBPPPCD@?$AAn?$AAu?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@LBPPPCD@?$AAn?$AAu?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'n'
	DB	00H, 'u', 00H, 'm', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT accum
_TEXT	SEGMENT
sum$ = 32
prod$ = 40
y$22195 = 48
x$22194 = 56
intpart$22193 = 64
dnum$22191 = 72
fracpart$22192 = 80
tag$ = 112
sofar$ = 120
num$ = 128
factor$ = 136
leftover$ = 144
accum	PROC						; COMDAT

; 2004 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2005 :     PyObject *prod;
; 2006 :     PyObject *sum;
; 2007 : 
; 2008 :     assert(num != NULL);

  00018	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR num$[rsp], 0
  00021	75 1c		 jne	 SHORT $LN13@accum
  00023	41 b8 d8 07 00
	00		 mov	 r8d, 2008		; 000007d8H
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@LBPPPCD@?$AAn?$AAu?$AAm?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003d	33 c0		 xor	 eax, eax
$LN13@accum:

; 2009 : 
; 2010 :     if (PyLong_Check(num)) {

  0003f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR num$[rsp]
  00047	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00051	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00056	85 c0		 test	 eax, eax
  00058	74 51		 je	 SHORT $LN10@accum

; 2011 :         prod = PyNumber_Multiply(num, factor);

  0005a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR factor$[rsp]
  00062	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR num$[rsp]
  0006a	e8 00 00 00 00	 call	 PyNumber_Multiply
  0006f	48 89 44 24 28	 mov	 QWORD PTR prod$[rsp], rax

; 2012 :         if (prod == NULL)

  00074	48 83 7c 24 28
	00		 cmp	 QWORD PTR prod$[rsp], 0
  0007a	75 07		 jne	 SHORT $LN9@accum

; 2013 :             return NULL;

  0007c	33 c0		 xor	 eax, eax
  0007e	e9 52 02 00 00	 jmp	 $LN11@accum
$LN9@accum:

; 2014 :         sum = PyNumber_Add(sofar, prod);

  00083	48 8b 54 24 28	 mov	 rdx, QWORD PTR prod$[rsp]
  00088	48 8b 4c 24 78	 mov	 rcx, QWORD PTR sofar$[rsp]
  0008d	e8 00 00 00 00	 call	 PyNumber_Add
  00092	48 89 44 24 20	 mov	 QWORD PTR sum$[rsp], rax

; 2015 :         Py_DECREF(prod);

  00097	48 8b 4c 24 28	 mov	 rcx, QWORD PTR prod$[rsp]
  0009c	e8 00 00 00 00	 call	 _Py_DecRef

; 2016 :         return sum;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR sum$[rsp]
  000a6	e9 2a 02 00 00	 jmp	 $LN11@accum
$LN10@accum:

; 2017 :     }
; 2018 : 
; 2019 :     if (PyFloat_Check(num)) {

  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  000b2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR num$[rsp]
  000ba	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000be	74 20		 je	 SHORT $LN7@accum
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  000c7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR num$[rsp]
  000cf	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000d3	e8 00 00 00 00	 call	 PyType_IsSubtype
  000d8	85 c0		 test	 eax, eax
  000da	0f 84 cb 01 00
	00		 je	 $LN8@accum
$LN7@accum:

; 2020 :         double dnum;
; 2021 :         double fracpart;
; 2022 :         double intpart;
; 2023 :         PyObject *x;
; 2024 :         PyObject *y;
; 2025 : 
; 2026 :         /* The Plan:  decompose num into an integer part and a
; 2027 :          * fractional part, num = intpart + fracpart.
; 2028 :          * Then num * factor ==
; 2029 :          *      intpart * factor + fracpart * factor
; 2030 :          * and the LHS can be computed exactly in long arithmetic.
; 2031 :          * The RHS is again broken into an int part and frac part.
; 2032 :          * and the frac part is added into *leftover.
; 2033 :          */
; 2034 :         dnum = PyFloat_AsDouble(num);

  000e0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR num$[rsp]
  000e8	e8 00 00 00 00	 call	 PyFloat_AsDouble
  000ed	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR dnum$22191[rsp], xmm0

; 2035 :         if (dnum == -1.0 && PyErr_Occurred())

  000f3	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR dnum$22191[rsp]
  000f9	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  00101	7a 13		 jp	 SHORT $LN6@accum
  00103	75 11		 jne	 SHORT $LN6@accum
  00105	e8 00 00 00 00	 call	 PyErr_Occurred
  0010a	48 85 c0	 test	 rax, rax
  0010d	74 07		 je	 SHORT $LN6@accum

; 2036 :             return NULL;

  0010f	33 c0		 xor	 eax, eax
  00111	e9 bf 01 00 00	 jmp	 $LN11@accum
$LN6@accum:

; 2037 :         fracpart = modf(dnum, &intpart);

  00116	48 8d 54 24 40	 lea	 rdx, QWORD PTR intpart$22193[rsp]
  0011b	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR dnum$22191[rsp]
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf
  00127	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR fracpart$22192[rsp], xmm0

; 2038 :         x = PyLong_FromDouble(intpart);

  0012d	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR intpart$22193[rsp]
  00133	e8 00 00 00 00	 call	 PyLong_FromDouble
  00138	48 89 44 24 38	 mov	 QWORD PTR x$22194[rsp], rax

; 2039 :         if (x == NULL)

  0013d	48 83 7c 24 38
	00		 cmp	 QWORD PTR x$22194[rsp], 0
  00143	75 07		 jne	 SHORT $LN5@accum

; 2040 :             return NULL;

  00145	33 c0		 xor	 eax, eax
  00147	e9 89 01 00 00	 jmp	 $LN11@accum
$LN5@accum:

; 2041 : 
; 2042 :         prod = PyNumber_Multiply(x, factor);

  0014c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR factor$[rsp]
  00154	48 8b 4c 24 38	 mov	 rcx, QWORD PTR x$22194[rsp]
  00159	e8 00 00 00 00	 call	 PyNumber_Multiply
  0015e	48 89 44 24 28	 mov	 QWORD PTR prod$[rsp], rax

; 2043 :         Py_DECREF(x);

  00163	48 8b 4c 24 38	 mov	 rcx, QWORD PTR x$22194[rsp]
  00168	e8 00 00 00 00	 call	 _Py_DecRef

; 2044 :         if (prod == NULL)

  0016d	48 83 7c 24 28
	00		 cmp	 QWORD PTR prod$[rsp], 0
  00173	75 07		 jne	 SHORT $LN4@accum

; 2045 :             return NULL;

  00175	33 c0		 xor	 eax, eax
  00177	e9 59 01 00 00	 jmp	 $LN11@accum
$LN4@accum:

; 2046 : 
; 2047 :         sum = PyNumber_Add(sofar, prod);

  0017c	48 8b 54 24 28	 mov	 rdx, QWORD PTR prod$[rsp]
  00181	48 8b 4c 24 78	 mov	 rcx, QWORD PTR sofar$[rsp]
  00186	e8 00 00 00 00	 call	 PyNumber_Add
  0018b	48 89 44 24 20	 mov	 QWORD PTR sum$[rsp], rax

; 2048 :         Py_DECREF(prod);

  00190	48 8b 4c 24 28	 mov	 rcx, QWORD PTR prod$[rsp]
  00195	e8 00 00 00 00	 call	 _Py_DecRef

; 2049 :         if (sum == NULL)

  0019a	48 83 7c 24 20
	00		 cmp	 QWORD PTR sum$[rsp], 0
  001a0	75 07		 jne	 SHORT $LN3@accum

; 2050 :             return NULL;

  001a2	33 c0		 xor	 eax, eax
  001a4	e9 2c 01 00 00	 jmp	 $LN11@accum
$LN3@accum:

; 2051 : 
; 2052 :         if (fracpart == 0.0)

  001a9	f2 0f 10 44 24
	50		 movsdx	 xmm0, QWORD PTR fracpart$22192[rsp]
  001af	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  001b7	7a 0c		 jp	 SHORT $LN2@accum
  001b9	75 0a		 jne	 SHORT $LN2@accum

; 2053 :             return sum;

  001bb	48 8b 44 24 20	 mov	 rax, QWORD PTR sum$[rsp]
  001c0	e9 10 01 00 00	 jmp	 $LN11@accum
$LN2@accum:

; 2054 :         /* So far we've lost no information.  Dealing with the
; 2055 :          * fractional part requires float arithmetic, and may
; 2056 :          * lose a little info.
; 2057 :          */
; 2058 :         assert(PyLong_Check(factor));

  001c5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR factor$[rsp]
  001cd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001d1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001d7	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  001dc	85 c0		 test	 eax, eax
  001de	75 1c		 jne	 SHORT $LN14@accum
  001e0	41 b8 0a 08 00
	00		 mov	 r8d, 2058		; 0000080aH
  001e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@KMBDOCAH@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?$CJ?$AA?$AA@
  001f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001fa	33 c0		 xor	 eax, eax
$LN14@accum:

; 2059 :         dnum = PyLong_AsDouble(factor);

  001fc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR factor$[rsp]
  00204	e8 00 00 00 00	 call	 PyLong_AsDouble
  00209	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR dnum$22191[rsp], xmm0

; 2060 : 
; 2061 :         dnum *= fracpart;

  0020f	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR dnum$22191[rsp]
  00215	f2 0f 59 44 24
	50		 mulsd	 xmm0, QWORD PTR fracpart$22192[rsp]
  0021b	f2 0f 11 44 24
	48		 movsdx	 QWORD PTR dnum$22191[rsp], xmm0

; 2062 :         fracpart = modf(dnum, &intpart);

  00221	48 8d 54 24 40	 lea	 rdx, QWORD PTR intpart$22193[rsp]
  00226	f2 0f 10 44 24
	48		 movsdx	 xmm0, QWORD PTR dnum$22191[rsp]
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf
  00232	f2 0f 11 44 24
	50		 movsdx	 QWORD PTR fracpart$22192[rsp], xmm0

; 2063 :         x = PyLong_FromDouble(intpart);

  00238	f2 0f 10 44 24
	40		 movsdx	 xmm0, QWORD PTR intpart$22193[rsp]
  0023e	e8 00 00 00 00	 call	 PyLong_FromDouble
  00243	48 89 44 24 38	 mov	 QWORD PTR x$22194[rsp], rax

; 2064 :         if (x == NULL) {

  00248	48 83 7c 24 38
	00		 cmp	 QWORD PTR x$22194[rsp], 0
  0024e	75 0e		 jne	 SHORT $LN1@accum

; 2065 :             Py_DECREF(sum);

  00250	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sum$[rsp]
  00255	e8 00 00 00 00	 call	 _Py_DecRef

; 2066 :             return NULL;

  0025a	33 c0		 xor	 eax, eax
  0025c	eb 77		 jmp	 SHORT $LN11@accum
$LN1@accum:

; 2067 :         }
; 2068 : 
; 2069 :         y = PyNumber_Add(sum, x);

  0025e	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$22194[rsp]
  00263	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sum$[rsp]
  00268	e8 00 00 00 00	 call	 PyNumber_Add
  0026d	48 89 44 24 30	 mov	 QWORD PTR y$22195[rsp], rax

; 2070 :         Py_DECREF(sum);

  00272	48 8b 4c 24 20	 mov	 rcx, QWORD PTR sum$[rsp]
  00277	e8 00 00 00 00	 call	 _Py_DecRef

; 2071 :         Py_DECREF(x);

  0027c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR x$22194[rsp]
  00281	e8 00 00 00 00	 call	 _Py_DecRef

; 2072 :         *leftover += fracpart;

  00286	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR leftover$[rsp]
  0028e	f2 0f 10 00	 movsdx	 xmm0, QWORD PTR [rax]
  00292	f2 0f 58 44 24
	50		 addsd	 xmm0, QWORD PTR fracpart$22192[rsp]
  00298	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR leftover$[rsp]
  002a0	f2 0f 11 00	 movsdx	 QWORD PTR [rax], xmm0

; 2073 :         return y;

  002a4	48 8b 44 24 30	 mov	 rax, QWORD PTR y$22195[rsp]
  002a9	eb 2a		 jmp	 SHORT $LN11@accum
$LN8@accum:

; 2074 :     }
; 2075 : 
; 2076 :     PyErr_Format(PyExc_TypeError,
; 2077 :                  "unsupported type for timedelta %s component: %s",
; 2078 :                  tag, Py_TYPE(num)->tp_name);

  002ab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR num$[rsp]
  002b3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002b7	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  002bb	4c 8b 44 24 70	 mov	 r8, QWORD PTR tag$[rsp]
  002c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@BBEBJCPJ@unsupported?5type?5for?5timedelta?5?$CF@
  002c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002ce	e8 00 00 00 00	 call	 PyErr_Format

; 2079 :     return NULL;

  002d3	33 c0		 xor	 eax, eax
$LN11@accum:

; 2080 : }

  002d5	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002d9	c3		 ret	 0
accum	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_bool DD imagerel delta_bool
	DD	imagerel delta_bool+66
	DD	imagerel $unwind$delta_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_bool DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_bool
_TEXT	SEGMENT
tv70 = 0
self$ = 32
delta_bool PROC						; COMDAT

; 2171 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 2172 :     return (GET_TD_DAYS(self) != 0
; 2173 :         || GET_TD_SECONDS(self) != 0
; 2174 :         || GET_TD_MICROSECONDS(self) != 0);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  00012	75 1f		 jne	 SHORT $LN3@delta_bool
  00014	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00019	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  0001d	75 14		 jne	 SHORT $LN3@delta_bool
  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  00024	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  00028	75 09		 jne	 SHORT $LN3@delta_bool
  0002a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv70[rsp], 0
  00031	eb 07		 jmp	 SHORT $LN4@delta_bool
$LN3@delta_bool:
  00033	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv70[rsp], 1
$LN4@delta_bool:
  0003a	8b 04 24	 mov	 eax, DWORD PTR tv70[rsp]

; 2175 : }

  0003d	48 83 c4 18	 add	 rsp, 24
  00041	c3		 ret	 0
delta_bool ENDP
_TEXT	ENDS
PUBLIC	??_C@_06BPGFIOAL@?$CFs?$CI?$CFd?$CJ?$AA@	; `string'
PUBLIC	??_C@_0L@KEFADODA@?$CFs?$CI?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_repr DD imagerel delta_repr
	DD	imagerel delta_repr+172
	DD	imagerel $unwind$delta_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_repr DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_06BPGFIOAL@?$CFs?$CI?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_06BPGFIOAL@?$CFs?$CI?$CFd?$CJ?$AA@ DB '%s(%d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEFADODA@?$CFs?$CI?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0L@KEFADODA@?$CFs?$CI?$CFd?0?5?$CFd?$CJ?$AA@ DB '%s(%d, %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ DB '%s(%d, %d'
	DB	', %d)', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT delta_repr
_TEXT	SEGMENT
self$ = 64
delta_repr PROC						; COMDAT

; 2179 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2180 :     if (GET_TD_MICROSECONDS(self) != 0)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  00012	74 39		 je	 SHORT $LN2@delta_repr

; 2181 :         return PyUnicode_FromFormat("%s(%d, %d, %d)",
; 2182 :                                     Py_TYPE(self)->tp_name,
; 2183 :                                     GET_TD_DAYS(self),
; 2184 :                                     GET_TD_SECONDS(self),
; 2185 :                                     GET_TD_MICROSECONDS(self));

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00019	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00022	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00025	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0002e	44 8b 49 6c	 mov	 r9d, DWORD PTR [rcx+108]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00037	44 8b 41 68	 mov	 r8d, DWORD PTR [rcx+104]
  0003b	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  00046	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0004b	eb 5a		 jmp	 SHORT $LN3@delta_repr
$LN2@delta_repr:

; 2186 :     if (GET_TD_SECONDS(self) != 0)

  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00052	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00056	74 2d		 je	 SHORT $LN1@delta_repr

; 2187 :         return PyUnicode_FromFormat("%s(%d, %d)",
; 2188 :                                     Py_TYPE(self)->tp_name,
; 2189 :                                     GET_TD_DAYS(self),
; 2190 :                                     GET_TD_SECONDS(self));

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0005d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00061	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00066	44 8b 49 6c	 mov	 r9d, DWORD PTR [rcx+108]
  0006a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0006f	44 8b 41 68	 mov	 r8d, DWORD PTR [rcx+104]
  00073	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@KEFADODA@?$CFs?$CI?$CFd?0?5?$CFd?$CJ?$AA@
  0007e	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00083	eb 22		 jmp	 SHORT $LN3@delta_repr
$LN1@delta_repr:

; 2191 : 
; 2192 :     return PyUnicode_FromFormat("%s(%d)",
; 2193 :                                 Py_TYPE(self)->tp_name,
; 2194 :                                 GET_TD_DAYS(self));

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0008a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00093	44 8b 41 68	 mov	 r8d, DWORD PTR [rcx+104]
  00097	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06BPGFIOAL@?$CFs?$CI?$CFd?$CJ?$AA@
  000a2	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN3@delta_repr:

; 2195 : }

  000a7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ab	c3		 ret	 0
delta_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d?$AA@	; `string'
PUBLIC	??_C@_0BC@GILBIBOD@?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ ; `string'
PUBLIC	??_C@_0BH@FHDHELPI@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?$AA@ ; `string'
PUBLIC	??_C@_0BM@FFEPHDE@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_str DD imagerel delta_str
	DD	imagerel delta_str+377
	DD	imagerel $unwind$delta_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_str DD 010901H
	DD	0e209H
xdata	ENDS
;	COMDAT ??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d?$AA@ DB '%d:%02d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GILBIBOD@?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
CONST	SEGMENT
??_C@_0BC@GILBIBOD@?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ DB '%d:%02d:%02d'
	DB	'.%06d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FHDHELPI@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0BH@FHDHELPI@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?$AA@ DB '%d'
	DB	' day%s, %d:%02d:%02d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFEPHDE@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
CONST	SEGMENT
??_C@_0BM@FFEPHDE@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ DB '%'
	DB	'd day%s, %d:%02d:%02d.%06d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT delta_str
_TEXT	SEGMENT
days$ = 64
minutes$ = 68
seconds$ = 72
hours$ = 76
us$ = 80
tv84 = 88
tv94 = 96
self$ = 128
delta_str PROC						; COMDAT

; 2199 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2200 :     int us = GET_TD_MICROSECONDS(self);

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00011	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00014	89 44 24 50	 mov	 DWORD PTR us$[rsp], eax

; 2201 :     int seconds = GET_TD_SECONDS(self);

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00020	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00023	89 44 24 48	 mov	 DWORD PTR seconds$[rsp], eax

; 2202 :     int minutes = divmod(seconds, 60, &seconds);

  00027	4c 8d 44 24 48	 lea	 r8, QWORD PTR seconds$[rsp]
  0002c	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00031	8b 4c 24 48	 mov	 ecx, DWORD PTR seconds$[rsp]
  00035	e8 00 00 00 00	 call	 divmod
  0003a	89 44 24 44	 mov	 DWORD PTR minutes$[rsp], eax

; 2203 :     int hours = divmod(minutes, 60, &minutes);

  0003e	4c 8d 44 24 44	 lea	 r8, QWORD PTR minutes$[rsp]
  00043	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00048	8b 4c 24 44	 mov	 ecx, DWORD PTR minutes$[rsp]
  0004c	e8 00 00 00 00	 call	 divmod
  00051	89 44 24 4c	 mov	 DWORD PTR hours$[rsp], eax

; 2204 :     int days = GET_TD_DAYS(self);

  00055	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0005d	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00060	89 44 24 40	 mov	 DWORD PTR days$[rsp], eax

; 2205 : 
; 2206 :     if (days) {

  00064	83 7c 24 40 00	 cmp	 DWORD PTR days$[rsp], 0
  00069	0f 84 be 00 00
	00		 je	 $LN6@delta_str

; 2207 :         if (us)

  0006f	83 7c 24 50 00	 cmp	 DWORD PTR us$[rsp], 0
  00074	74 61		 je	 SHORT $LN5@delta_str

; 2208 :             return PyUnicode_FromFormat("%d day%s, %d:%02d:%02d.%06d",
; 2209 :                                         days, (days == 1 || days == -1) ? "" : "s",
; 2210 :                                         hours, minutes, seconds, us);

  00076	83 7c 24 40 01	 cmp	 DWORD PTR days$[rsp], 1
  0007b	74 15		 je	 SHORT $LN9@delta_str
  0007d	83 7c 24 40 ff	 cmp	 DWORD PTR days$[rsp], -1
  00082	74 0e		 je	 SHORT $LN9@delta_str
  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  0008b	48 89 44 24 58	 mov	 QWORD PTR tv84[rsp], rax
  00090	eb 0c		 jmp	 SHORT $LN10@delta_str
$LN9@delta_str:
  00092	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00099	48 89 44 24 58	 mov	 QWORD PTR tv84[rsp], rax
$LN10@delta_str:
  0009e	8b 44 24 50	 mov	 eax, DWORD PTR us$[rsp]
  000a2	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000a6	8b 44 24 48	 mov	 eax, DWORD PTR seconds$[rsp]
  000aa	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000ae	8b 44 24 44	 mov	 eax, DWORD PTR minutes$[rsp]
  000b2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b6	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR hours$[rsp]
  000bb	4c 8b 44 24 58	 mov	 r8, QWORD PTR tv84[rsp]
  000c0	8b 54 24 40	 mov	 edx, DWORD PTR days$[rsp]
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@FFEPHDE@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
  000cb	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000d0	e9 9f 00 00 00	 jmp	 $LN7@delta_str

; 2211 :         else

  000d5	eb 54		 jmp	 SHORT $LN4@delta_str
$LN5@delta_str:

; 2212 :             return PyUnicode_FromFormat("%d day%s, %d:%02d:%02d",
; 2213 :                                         days, (days == 1 || days == -1) ? "" : "s",
; 2214 :                                         hours, minutes, seconds);

  000d7	83 7c 24 40 01	 cmp	 DWORD PTR days$[rsp], 1
  000dc	74 15		 je	 SHORT $LN11@delta_str
  000de	83 7c 24 40 ff	 cmp	 DWORD PTR days$[rsp], -1
  000e3	74 0e		 je	 SHORT $LN11@delta_str
  000e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  000ec	48 89 44 24 60	 mov	 QWORD PTR tv94[rsp], rax
  000f1	eb 0c		 jmp	 SHORT $LN12@delta_str
$LN11@delta_str:
  000f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000fa	48 89 44 24 60	 mov	 QWORD PTR tv94[rsp], rax
$LN12@delta_str:
  000ff	8b 44 24 48	 mov	 eax, DWORD PTR seconds$[rsp]
  00103	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00107	8b 44 24 44	 mov	 eax, DWORD PTR minutes$[rsp]
  0010b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0010f	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR hours$[rsp]
  00114	4c 8b 44 24 60	 mov	 r8, QWORD PTR tv94[rsp]
  00119	8b 54 24 40	 mov	 edx, DWORD PTR days$[rsp]
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@FHDHELPI@?$CFd?5day?$CFs?0?5?$CFd?3?$CF02d?3?$CF02d?$AA@
  00124	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00129	eb 49		 jmp	 SHORT $LN7@delta_str
$LN4@delta_str:

; 2215 :     } else {

  0012b	eb 47		 jmp	 SHORT $LN3@delta_str
$LN6@delta_str:

; 2216 :         if (us)

  0012d	83 7c 24 50 00	 cmp	 DWORD PTR us$[rsp], 0
  00132	74 26		 je	 SHORT $LN2@delta_str

; 2217 :             return PyUnicode_FromFormat("%d:%02d:%02d.%06d",
; 2218 :                                         hours, minutes, seconds, us);

  00134	8b 44 24 50	 mov	 eax, DWORD PTR us$[rsp]
  00138	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0013c	44 8b 4c 24 48	 mov	 r9d, DWORD PTR seconds$[rsp]
  00141	44 8b 44 24 44	 mov	 r8d, DWORD PTR minutes$[rsp]
  00146	8b 54 24 4c	 mov	 edx, DWORD PTR hours$[rsp]
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@GILBIBOD@?$CFd?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
  00151	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00156	eb 1c		 jmp	 SHORT $LN7@delta_str

; 2219 :         else

  00158	eb 1a		 jmp	 SHORT $LN1@delta_str
$LN2@delta_str:

; 2220 :             return PyUnicode_FromFormat("%d:%02d:%02d",
; 2221 :                                         hours, minutes, seconds);

  0015a	44 8b 4c 24 48	 mov	 r9d, DWORD PTR seconds$[rsp]
  0015f	44 8b 44 24 44	 mov	 r8d, DWORD PTR minutes$[rsp]
  00164	8b 54 24 4c	 mov	 edx, DWORD PTR hours$[rsp]
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@PKIKNCIH@?$CFd?3?$CF02d?3?$CF02d?$AA@
  0016f	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN1@delta_str:
$LN3@delta_str:
$LN7@delta_str:

; 2222 :     }
; 2223 : 
; 2224 : }

  00174	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00178	c3		 ret	 0
delta_str ENDP
_TEXT	ENDS
PUBLIC	??_C@_03GLKMLICL@iii?$AA@			; `string'
EXTRN	Py_BuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_getstate DD imagerel delta_getstate
	DD	imagerel delta_getstate+52
	DD	imagerel $unwind$delta_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_getstate DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_03GLKMLICL@iii?$AA@
CONST	SEGMENT
??_C@_03GLKMLICL@iii?$AA@ DB 'iii', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT delta_getstate
_TEXT	SEGMENT
self$ = 48
delta_getstate PROC					; COMDAT

; 2231 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2232 :     return Py_BuildValue("iii", GET_TD_DAYS(self),
; 2233 :                                 GET_TD_SECONDS(self),
; 2234 :                                 GET_TD_MICROSECONDS(self));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00017	44 8b 40 6c	 mov	 r8d, DWORD PTR [rax+108]
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	8b 50 68	 mov	 edx, DWORD PTR [rax+104]
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  0002a	e8 00 00 00 00	 call	 Py_BuildValue

; 2235 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
delta_getstate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_total_seconds DD imagerel delta_total_seconds
	DD	imagerel delta_total_seconds+123
	DD	imagerel $unwind$delta_total_seconds
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_total_seconds DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT delta_total_seconds
_TEXT	SEGMENT
total_microseconds$ = 32
one_million$ = 40
total_seconds$ = 48
self$ = 80
delta_total_seconds PROC				; COMDAT

; 2239 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2240 :     PyObject *total_seconds;
; 2241 :     PyObject *total_microseconds;
; 2242 :     PyObject *one_million;
; 2243 : 
; 2244 :     total_microseconds = delta_to_microseconds((PyDateTime_Delta *)self);

  00009	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 delta_to_microseconds
  00013	48 89 44 24 20	 mov	 QWORD PTR total_microseconds$[rsp], rax

; 2245 :     if (total_microseconds == NULL)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR total_microseconds$[rsp], 0
  0001e	75 04		 jne	 SHORT $LN2@delta_tota

; 2246 :         return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	eb 52		 jmp	 SHORT $LN3@delta_tota
$LN2@delta_tota:

; 2247 : 
; 2248 :     one_million = PyLong_FromLong(1000000L);

  00024	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00029	e8 00 00 00 00	 call	 PyLong_FromLong
  0002e	48 89 44 24 28	 mov	 QWORD PTR one_million$[rsp], rax

; 2249 :     if (one_million == NULL) {

  00033	48 83 7c 24 28
	00		 cmp	 QWORD PTR one_million$[rsp], 0
  00039	75 0e		 jne	 SHORT $LN1@delta_tota

; 2250 :         Py_DECREF(total_microseconds);

  0003b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR total_microseconds$[rsp]
  00040	e8 00 00 00 00	 call	 _Py_DecRef

; 2251 :         return NULL;

  00045	33 c0		 xor	 eax, eax
  00047	eb 2d		 jmp	 SHORT $LN3@delta_tota
$LN1@delta_tota:

; 2252 :     }
; 2253 : 
; 2254 :     total_seconds = PyNumber_TrueDivide(total_microseconds, one_million);

  00049	48 8b 54 24 28	 mov	 rdx, QWORD PTR one_million$[rsp]
  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR total_microseconds$[rsp]
  00053	e8 00 00 00 00	 call	 PyNumber_TrueDivide
  00058	48 89 44 24 30	 mov	 QWORD PTR total_seconds$[rsp], rax

; 2255 : 
; 2256 :     Py_DECREF(total_microseconds);

  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR total_microseconds$[rsp]
  00062	e8 00 00 00 00	 call	 _Py_DecRef

; 2257 :     Py_DECREF(one_million);

  00067	48 8b 4c 24 28	 mov	 rcx, QWORD PTR one_million$[rsp]
  0006c	e8 00 00 00 00	 call	 _Py_DecRef

; 2258 :     return total_seconds;

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR total_seconds$[rsp]
$LN3@delta_tota:

; 2259 : }

  00076	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007a	c3		 ret	 0
delta_total_seconds ENDP
_TEXT	ENDS
PUBLIC	??_C@_02BFICIOJL@ON?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$delta_reduce DD imagerel delta_reduce
	DD	imagerel delta_reduce+48
	DD	imagerel $unwind$delta_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$delta_reduce DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_02BFICIOJL@ON?$AA@
CONST	SEGMENT
??_C@_02BFICIOJL@ON?$AA@ DB 'ON', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT delta_reduce
_TEXT	SEGMENT
self$ = 48
delta_reduce PROC					; COMDAT

; 2263 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2264 :     return Py_BuildValue("ON", Py_TYPE(self), delta_getstate(self));

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0000e	e8 00 00 00 00	 call	 delta_getstate
  00013	4c 8b c0	 mov	 r8, rax
  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001b	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02BFICIOJL@ON?$AA@
  00026	e8 00 00 00 00	 call	 Py_BuildValue

; 2265 : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
delta_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_year DD imagerel date_year
	DD	imagerel date_year+49
	DD	imagerel $unwind$date_year
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_year DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_year
_TEXT	SEGMENT
self$ = 48
unused$ = 56
date_year PROC						; COMDAT

; 2381 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2382 :     return PyLong_FromLong(GET_YEAR(self));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00017	c1 e0 08	 shl	 eax, 8
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0001f	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00023	0b c1		 or	 eax, ecx
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 PyLong_FromLong

; 2383 : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
date_year ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_month DD imagerel date_month
	DD	imagerel date_month+35
	DD	imagerel $unwind$date_month
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_month DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_month
_TEXT	SEGMENT
self$ = 48
unused$ = 56
date_month PROC						; COMDAT

; 2387 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2388 :     return PyLong_FromLong(GET_MONTH(self));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  00017	8b c8		 mov	 ecx, eax
  00019	e8 00 00 00 00	 call	 PyLong_FromLong

; 2389 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
date_month ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_day DD imagerel date_day
	DD	imagerel date_day+35
	DD	imagerel $unwind$date_day
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_day DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_day
_TEXT	SEGMENT
self$ = 48
unused$ = 56
date_day PROC						; COMDAT

; 2393 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2394 :     return PyLong_FromLong(GET_DAY(self));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00017	8b c8		 mov	 ecx, eax
  00019	e8 00 00 00 00	 call	 PyLong_FromLong

; 2395 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
date_day ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_new DD imagerel date_new
	DD	imagerel date_new+522
	DD	imagerel $unwind$date_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_new DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ')', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT date_new
_TEXT	SEGMENT
day$ = 64
month$ = 68
self$ = 72
year$ = 80
state$ = 88
me$22490 = 96
pdata$22494 = 104
type$ = 128
args$ = 136
kw$ = 144
date_new PROC						; COMDAT

; 2410 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2411 :     PyObject *self = NULL;

  00013	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR self$[rsp], 0

; 2412 :     PyObject *state;
; 2413 :     int year;
; 2414 :     int month;
; 2415 :     int day;
; 2416 : 
; 2417 :     /* Check for invocation from pickle with __getstate__ state */
; 2418 :     if (PyTuple_GET_SIZE(args) == 1 &&
; 2419 :         PyBytes_Check(state = PyTuple_GET_ITEM(args, 0)) &&
; 2420 :         PyBytes_GET_SIZE(state) == _PyDateTime_DATE_DATASIZE &&
; 2421 :         MONTH_IS_SANE(PyBytes_AS_STRING(state)[2]))

  0001c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00024	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  00029	0f 85 53 01 00
	00		 jne	 $LN4@date_new
  0002f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00037	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0003b	48 89 44 24 58	 mov	 QWORD PTR state$[rsp], rax
  00040	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  00045	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00049	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00054	85 c0		 test	 eax, eax
  00056	0f 84 26 01 00
	00		 je	 $LN4@date_new
  0005c	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  00061	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00065	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0006b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00070	85 c0		 test	 eax, eax
  00072	75 1c		 jne	 SHORT $LN7@date_new
  00074	41 b8 74 09 00
	00		 mov	 r8d, 2420		; 00000974H
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008e	33 c0		 xor	 eax, eax
$LN7@date_new:
  00090	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  00095	48 83 78 60 04	 cmp	 QWORD PTR [rax+96], 4
  0009a	0f 85 e2 00 00
	00		 jne	 $LN4@date_new
  000a0	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  000a5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000af	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000b4	85 c0		 test	 eax, eax
  000b6	75 1c		 jne	 SHORT $LN8@date_new
  000b8	41 b8 75 09 00
	00		 mov	 r8d, 2421		; 00000975H
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d2	33 c0		 xor	 eax, eax
$LN8@date_new:
  000d4	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  000d9	0f be 40 7a	 movsx	 eax, BYTE PTR [rax+122]
  000dd	ff c8		 dec	 eax
  000df	83 f8 0c	 cmp	 eax, 12
  000e2	0f 83 9a 00 00
	00		 jae	 $LN4@date_new

; 2422 :     {
; 2423 :         PyDateTime_Date *me;
; 2424 : 
; 2425 :         me = (PyDateTime_Date *) (type->tp_alloc(type, 0));

  000e8	33 d2		 xor	 edx, edx
  000ea	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  000f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  000fa	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00100	48 89 44 24 60	 mov	 QWORD PTR me$22490[rsp], rax

; 2426 :         if (me != NULL) {

  00105	48 83 7c 24 60
	00		 cmp	 QWORD PTR me$22490[rsp], 0
  0010b	74 6b		 je	 SHORT $LN3@date_new

; 2427 :             char *pdata = PyBytes_AS_STRING(state);

  0010d	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  00112	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00116	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0011c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00121	85 c0		 test	 eax, eax
  00123	75 1c		 jne	 SHORT $LN9@date_new
  00125	41 b8 7b 09 00
	00		 mov	 r8d, 2427		; 0000097bH
  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0013f	33 c0		 xor	 eax, eax
$LN9@date_new:
  00141	48 8b 44 24 58	 mov	 rax, QWORD PTR state$[rsp]
  00146	48 83 c0 78	 add	 rax, 120		; 00000078H
  0014a	48 89 44 24 68	 mov	 QWORD PTR pdata$22494[rsp], rax

; 2428 :             memcpy(me->data, pdata, _PyDateTime_DATE_DATASIZE);

  0014f	48 8b 44 24 60	 mov	 rax, QWORD PTR me$22490[rsp]
  00154	48 83 c0 69	 add	 rax, 105		; 00000069H
  00158	41 b8 04 00 00
	00		 mov	 r8d, 4
  0015e	48 8b 54 24 68	 mov	 rdx, QWORD PTR pdata$22494[rsp]
  00163	48 8b c8	 mov	 rcx, rax
  00166	e8 00 00 00 00	 call	 memcpy

; 2429 :             me->hashcode = -1;

  0016b	48 8b 44 24 60	 mov	 rax, QWORD PTR me$22490[rsp]
  00170	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1
$LN3@date_new:

; 2430 :         }
; 2431 :         return (PyObject *)me;

  00178	48 8b 44 24 60	 mov	 rax, QWORD PTR me$22490[rsp]
  0017d	e9 83 00 00 00	 jmp	 $LN5@date_new
$LN4@date_new:

; 2432 :     }
; 2433 : 
; 2434 :     if (PyArg_ParseTupleAndKeywords(args, kw, "iii", date_kws,
; 2435 :                                     &year, &month, &day)) {

  00182	48 8d 44 24 40	 lea	 rax, QWORD PTR day$[rsp]
  00187	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0018c	48 8d 44 24 44	 lea	 rax, QWORD PTR month$[rsp]
  00191	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00196	48 8d 44 24 50	 lea	 rax, QWORD PTR year$[rsp]
  0019b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:date_kws
  001a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  001ae	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  001b6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  001be	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  001c3	85 c0		 test	 eax, eax
  001c5	74 39		 je	 SHORT $LN2@date_new

; 2436 :         if (check_date_args(year, month, day) < 0)

  001c7	44 8b 44 24 40	 mov	 r8d, DWORD PTR day$[rsp]
  001cc	8b 54 24 44	 mov	 edx, DWORD PTR month$[rsp]
  001d0	8b 4c 24 50	 mov	 ecx, DWORD PTR year$[rsp]
  001d4	e8 00 00 00 00	 call	 check_date_args
  001d9	85 c0		 test	 eax, eax
  001db	7d 04		 jge	 SHORT $LN1@date_new

; 2437 :             return NULL;

  001dd	33 c0		 xor	 eax, eax
  001df	eb 24		 jmp	 SHORT $LN5@date_new
$LN1@date_new:

; 2438 :         self = new_date_ex(year, month, day, type);

  001e1	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR type$[rsp]
  001e9	44 8b 44 24 40	 mov	 r8d, DWORD PTR day$[rsp]
  001ee	8b 54 24 44	 mov	 edx, DWORD PTR month$[rsp]
  001f2	8b 4c 24 50	 mov	 ecx, DWORD PTR year$[rsp]
  001f6	e8 00 00 00 00	 call	 new_date_ex
  001fb	48 89 44 24 48	 mov	 QWORD PTR self$[rsp], rax
$LN2@date_new:

; 2439 :     }
; 2440 :     return self;

  00200	48 8b 44 24 48	 mov	 rax, QWORD PTR self$[rsp]
$LN5@date_new:

; 2441 : }

  00205	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00209	c3		 ret	 0
date_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@OOGOFMAP@day?5is?5out?5of?5range?5for?5month?$AA@ ; `string'
PUBLIC	??_C@_0BH@HLLPOIEL@month?5must?5be?5in?51?4?412?$AA@ ; `string'
PUBLIC	??_C@_0BF@OKOCEDOB@year?5is?5out?5of?5range?$AA@ ; `string'
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_date_args DD imagerel check_date_args
	DD	imagerel check_date_args+159
	DD	imagerel $unwind$check_date_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_date_args DD 011101H
	DD	04211H
xdata	ENDS
;	COMDAT ??_C@_0BO@OOGOFMAP@day?5is?5out?5of?5range?5for?5month?$AA@
CONST	SEGMENT
??_C@_0BO@OOGOFMAP@day?5is?5out?5of?5range?5for?5month?$AA@ DB 'day is ou'
	DB	't of range for month', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HLLPOIEL@month?5must?5be?5in?51?4?412?$AA@
CONST	SEGMENT
??_C@_0BH@HLLPOIEL@month?5must?5be?5in?51?4?412?$AA@ DB 'month must be in'
	DB	' 1..12', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OKOCEDOB@year?5is?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BF@OKOCEDOB@year?5is?5out?5of?5range?$AA@ DB 'year is out of range'
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT check_date_args
_TEXT	SEGMENT
year$ = 48
month$ = 56
day$ = 64
check_date_args PROC					; COMDAT

; 392  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 393  : 
; 394  :     if (year < MINYEAR || year > MAXYEAR) {

  00011	83 7c 24 30 01	 cmp	 DWORD PTR year$[rsp], 1
  00016	7c 0a		 jl	 SHORT $LN5@check_date
  00018	81 7c 24 30 0f
	27 00 00	 cmp	 DWORD PTR year$[rsp], 9999 ; 0000270fH
  00020	7e 1a		 jle	 SHORT $LN6@check_date
$LN5@check_date:

; 395  :         PyErr_SetString(PyExc_ValueError,
; 396  :                         "year is out of range");

  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@OKOCEDOB@year?5is?5out?5of?5range?$AA@
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00030	e8 00 00 00 00	 call	 PyErr_SetString

; 397  :         return -1;

  00035	b8 ff ff ff ff	 mov	 eax, -1
  0003a	eb 5e		 jmp	 SHORT $LN7@check_date
$LN6@check_date:

; 398  :     }
; 399  :     if (month < 1 || month > 12) {

  0003c	83 7c 24 38 01	 cmp	 DWORD PTR month$[rsp], 1
  00041	7c 07		 jl	 SHORT $LN3@check_date
  00043	83 7c 24 38 0c	 cmp	 DWORD PTR month$[rsp], 12
  00048	7e 1a		 jle	 SHORT $LN4@check_date
$LN3@check_date:

; 400  :         PyErr_SetString(PyExc_ValueError,
; 401  :                         "month must be in 1..12");

  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@HLLPOIEL@month?5must?5be?5in?51?4?412?$AA@
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00058	e8 00 00 00 00	 call	 PyErr_SetString

; 402  :         return -1;

  0005d	b8 ff ff ff ff	 mov	 eax, -1
  00062	eb 36		 jmp	 SHORT $LN7@check_date
$LN4@check_date:

; 403  :     }
; 404  :     if (day < 1 || day > days_in_month(year, month)) {

  00064	83 7c 24 40 01	 cmp	 DWORD PTR day$[rsp], 1
  00069	7c 13		 jl	 SHORT $LN1@check_date
  0006b	8b 54 24 38	 mov	 edx, DWORD PTR month$[rsp]
  0006f	8b 4c 24 30	 mov	 ecx, DWORD PTR year$[rsp]
  00073	e8 00 00 00 00	 call	 days_in_month
  00078	39 44 24 40	 cmp	 DWORD PTR day$[rsp], eax
  0007c	7e 1a		 jle	 SHORT $LN2@check_date
$LN1@check_date:

; 405  :         PyErr_SetString(PyExc_ValueError,
; 406  :                         "day is out of range for month");

  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@OOGOFMAP@day?5is?5out?5of?5range?5for?5month?$AA@
  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0008c	e8 00 00 00 00	 call	 PyErr_SetString

; 407  :         return -1;

  00091	b8 ff ff ff ff	 mov	 eax, -1
  00096	eb 02		 jmp	 SHORT $LN7@check_date
$LN2@check_date:

; 408  :     }
; 409  :     return 0;

  00098	33 c0		 xor	 eax, eax
$LN7@check_date:

; 410  : }

  0009a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009e	c3		 ret	 0
check_date_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@LDAHDJMP@?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA2?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@MBJLKPJC@?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$days_in_month DD imagerel days_in_month
	DD	imagerel days_in_month+131
	DD	imagerel $unwind$days_in_month
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$days_in_month DD 010c01H
	DD	0420cH
xdata	ENDS
;	COMDAT ??_C@_1BI@LDAHDJMP@?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@LDAHDJMP@?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA2?$AA?$AA@ DB 'm'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, 'h', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '1', 00H, '2', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@MBJLKPJC@?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@MBJLKPJC@?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'm'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, 'h', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '1', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT days_in_month
_TEXT	SEGMENT
year$ = 48
month$ = 56
days_in_month PROC					; COMDAT

; 209  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 210  :     assert(month >= 1);

  0000c	83 7c 24 38 01	 cmp	 DWORD PTR month$[rsp], 1
  00011	7d 1c		 jge	 SHORT $LN5@days_in_mo
  00013	41 b8 d2 00 00
	00		 mov	 r8d, 210		; 000000d2H
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@MBJLKPJC@?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002d	33 c0		 xor	 eax, eax
$LN5@days_in_mo:

; 211  :     assert(month <= 12);

  0002f	83 7c 24 38 0c	 cmp	 DWORD PTR month$[rsp], 12
  00034	7e 1c		 jle	 SHORT $LN6@days_in_mo
  00036	41 b8 d3 00 00
	00		 mov	 r8d, 211		; 000000d3H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@LDAHDJMP@?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA2?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN6@days_in_mo:

; 212  :     if (month == 2 && is_leap(year))

  00052	83 7c 24 38 02	 cmp	 DWORD PTR month$[rsp], 2
  00057	75 16		 jne	 SHORT $LN2@days_in_mo
  00059	8b 4c 24 30	 mov	 ecx, DWORD PTR year$[rsp]
  0005d	e8 00 00 00 00	 call	 is_leap
  00062	85 c0		 test	 eax, eax
  00064	74 09		 je	 SHORT $LN2@days_in_mo

; 213  :         return 29;

  00066	b8 1d 00 00 00	 mov	 eax, 29
  0006b	eb 11		 jmp	 SHORT $LN3@days_in_mo

; 214  :     else

  0006d	eb 0f		 jmp	 SHORT $LN1@days_in_mo
$LN2@days_in_mo:

; 215  :         return _days_in_month[month];

  0006f	48 63 44 24 38	 movsxd	 rax, DWORD PTR month$[rsp]
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_days_in_month
  0007b	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
$LN1@days_in_mo:
$LN3@days_in_mo:

; 216  : }

  0007e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00082	c3		 ret	 0
days_in_month ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_leap DD imagerel is_leap
	DD	imagerel is_leap+96
	DD	imagerel $unwind$is_leap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_leap DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT is_leap
_TEXT	SEGMENT
ayear$ = 0
tv70 = 4
year$ = 32
is_leap	PROC						; COMDAT

; 196  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 197  :     /* Cast year to unsigned.  The result is the same either way, but
; 198  :      * C can generate faster code for unsigned mod than for signed
; 199  :      * mod (especially for % 4 -- a good compiler should just grab
; 200  :      * the last 2 bits when the LHS is unsigned).
; 201  :      */
; 202  :     const unsigned int ayear = (unsigned int)year;

  00008	8b 44 24 20	 mov	 eax, DWORD PTR year$[rsp]
  0000c	89 04 24	 mov	 DWORD PTR ayear$[rsp], eax

; 203  :     return ayear % 4 == 0 && (ayear % 100 != 0 || ayear % 400 == 0);

  0000f	33 d2		 xor	 edx, edx
  00011	8b 04 24	 mov	 eax, DWORD PTR ayear$[rsp]
  00014	b9 04 00 00 00	 mov	 ecx, 4
  00019	f7 f1		 div	 ecx
  0001b	8b c2		 mov	 eax, edx
  0001d	85 c0		 test	 eax, eax
  0001f	75 2e		 jne	 SHORT $LN4@is_leap
  00021	33 d2		 xor	 edx, edx
  00023	8b 04 24	 mov	 eax, DWORD PTR ayear$[rsp]
  00026	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0002b	f7 f1		 div	 ecx
  0002d	8b c2		 mov	 eax, edx
  0002f	85 c0		 test	 eax, eax
  00031	75 12		 jne	 SHORT $LN3@is_leap
  00033	33 d2		 xor	 edx, edx
  00035	8b 04 24	 mov	 eax, DWORD PTR ayear$[rsp]
  00038	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  0003d	f7 f1		 div	 ecx
  0003f	8b c2		 mov	 eax, edx
  00041	85 c0		 test	 eax, eax
  00043	75 0a		 jne	 SHORT $LN4@is_leap
$LN3@is_leap:
  00045	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0004d	eb 08		 jmp	 SHORT $LN5@is_leap
$LN4@is_leap:
  0004f	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN5@is_leap:
  00057	8b 44 24 04	 mov	 eax, DWORD PTR tv70[rsp]

; 204  : }

  0005b	48 83 c4 18	 add	 rsp, 24
  0005f	c3		 ret	 0
is_leap	ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_today DD imagerel date_today
	DD	imagerel date_today+112
	DD	imagerel $unwind$date_today
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_today DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT date_today
_TEXT	SEGMENT
time$ = 32
result$ = 40
cls$ = 64
dummy$ = 72
date_today PROC						; COMDAT

; 2477 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2478 :     PyObject *time;
; 2479 :     PyObject *result;
; 2480 :     _Py_IDENTIFIER(fromtimestamp);
; 2481 : 
; 2482 :     time = time_time();

  0000e	e8 00 00 00 00	 call	 time_time
  00013	48 89 44 24 20	 mov	 QWORD PTR time$[rsp], rax

; 2483 :     if (time == NULL)

  00018	48 83 7c 24 20
	00		 cmp	 QWORD PTR time$[rsp], 0
  0001e	75 04		 jne	 SHORT $LN1@date_today

; 2484 :         return NULL;

  00020	33 c0		 xor	 eax, eax
  00022	eb 47		 jmp	 SHORT $LN2@date_today
$LN1@date_today:

; 2485 : 
; 2486 :     /* Note well:  today() is a class method, so this may not call
; 2487 :      * date.fromtimestamp.  For example, it may call
; 2488 :      * datetime.fromtimestamp.  That's why we need all the accuracy
; 2489 :      * time.time() delivers; if someone were gonzo about optimization,
; 2490 :      * date.today() could get away with plain C time().
; 2491 :      */
; 2492 :     result = _PyObject_CallMethodId(cls, &PyId_fromtimestamp, "O", time);

  00024	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_fromtimestamp@?1??date_today@@9@9
  00029	8b c0		 mov	 eax, eax
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00031	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0003a	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0003e	4c 8b 4c 24 20	 mov	 r9, QWORD PTR time$[rsp]
  00043	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  0004a	48 8b d0	 mov	 rdx, rax
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cls$[rsp]
  00052	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00057	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 2493 :     Py_DECREF(time);

  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR time$[rsp]
  00061	e8 00 00 00 00	 call	 _Py_DecRef

; 2494 :     return result;

  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN2@date_today:

; 2495 : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
date_today ENDP
_TEXT	ENDS
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
EXTRN	PyImport_ImportModuleNoBlock:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_time DD imagerel time_time
	DD	imagerel time_time+109
	DD	imagerel $unwind$time_time
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_time DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT time_time
_TEXT	SEGMENT
time$ = 32
result$ = 40
time_time PROC						; COMDAT

; 1317 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1318 :     PyObject *result = NULL;

  00004	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 1319 :     PyObject *time = PyImport_ImportModuleNoBlock("time");

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04CLCEDBPF@time?$AA@
  00014	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  00019	48 89 44 24 20	 mov	 QWORD PTR time$[rsp], rax

; 1320 : 
; 1321 :     if (time != NULL) {

  0001e	48 83 7c 24 20
	00		 cmp	 QWORD PTR time$[rsp], 0
  00024	74 3d		 je	 SHORT $LN1@time_time

; 1322 :         _Py_IDENTIFIER(time);
; 1323 : 
; 1324 :         result = _PyObject_CallMethodId(time, &PyId_time, "()");

  00026	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_time@?2??time_time@@9@9
  0002b	8b c0		 mov	 eax, eax
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00033	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0003c	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00040	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00047	48 8b d0	 mov	 rdx, rax
  0004a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR time$[rsp]
  0004f	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00054	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1325 :         Py_DECREF(time);

  00059	48 8b 4c 24 20	 mov	 rcx, QWORD PTR time$[rsp]
  0005e	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@time_time:

; 1326 :     }
; 1327 :     return result;

  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]

; 1328 : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	c3		 ret	 0
time_time ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@IHAFJAAN@O?3fromtimestamp?$AA@	; `string'
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_fromtimestamp DD imagerel date_fromtimestamp
	DD	imagerel date_fromtimestamp+79
	DD	imagerel $unwind$date_fromtimestamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_fromtimestamp DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BA@IHAFJAAN@O?3fromtimestamp?$AA@
CONST	SEGMENT
??_C@_0BA@IHAFJAAN@O?3fromtimestamp?$AA@ DB 'O:fromtimestamp', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT date_fromtimestamp
_TEXT	SEGMENT
result$ = 32
timestamp$ = 40
cls$ = 64
args$ = 72
date_fromtimestamp PROC					; COMDAT

; 2500 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2501 :     PyObject *timestamp;
; 2502 :     PyObject *result = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 2503 : 
; 2504 :     if (PyArg_ParseTuple(args, "O:fromtimestamp", &timestamp))

  00017	4c 8d 44 24 28	 lea	 r8, QWORD PTR timestamp$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@IHAFJAAN@O?3fromtimestamp?$AA@
  00023	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002d	85 c0		 test	 eax, eax
  0002f	74 14		 je	 SHORT $LN1@date_fromt

; 2505 :         result = date_local_from_object(cls, timestamp);

  00031	48 8b 54 24 28	 mov	 rdx, QWORD PTR timestamp$[rsp]
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cls$[rsp]
  0003b	e8 00 00 00 00	 call	 date_local_from_object
  00040	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN1@date_fromt:

; 2506 :     return result;

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 2507 : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
date_fromtimestamp ENDP
_TEXT	ENDS
EXTRN	PyObject_CallFunction:PROC
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OSError:QWORD
EXTRN	__imp__errno:PROC
EXTRN	_PyTime_ObjectToTime_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_local_from_object DD imagerel date_local_from_object
	DD	imagerel date_local_from_object+164
	DD	imagerel $unwind$date_local_from_object
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_local_from_object DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_local_from_object
_TEXT	SEGMENT
tm$ = 48
t$ = 56
cls$ = 80
obj$ = 88
date_local_from_object PROC				; COMDAT

; 2446 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2447 :     struct tm *tm;
; 2448 :     time_t t;
; 2449 : 
; 2450 :     if (_PyTime_ObjectToTime_t(obj, &t) == -1)

  0000e	48 8d 54 24 38	 lea	 rdx, QWORD PTR t$[rsp]
  00013	48 8b 4c 24 58	 mov	 rcx, QWORD PTR obj$[rsp]
  00018	e8 00 00 00 00	 call	 _PyTime_ObjectToTime_t
  0001d	83 f8 ff	 cmp	 eax, -1
  00020	75 04		 jne	 SHORT $LN3@date_local

; 2451 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	eb 79		 jmp	 SHORT $LN4@date_local
$LN3@date_local:

; 2452 : 
; 2453 :     tm = localtime(&t);

  00026	48 8d 4c 24 38	 lea	 rcx, QWORD PTR t$[rsp]
  0002b	e8 00 00 00 00	 call	 localtime
  00030	48 89 44 24 30	 mov	 QWORD PTR tm$[rsp], rax

; 2454 :     if (tm == NULL) {

  00035	48 83 7c 24 30
	00		 cmp	 QWORD PTR tm$[rsp], 0
  0003b	75 27		 jne	 SHORT $LN2@date_local

; 2455 :         /* unconvertible time */
; 2456 : #ifdef EINVAL
; 2457 :         if (errno == 0)

  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00043	83 38 00	 cmp	 DWORD PTR [rax], 0
  00046	75 0c		 jne	 SHORT $LN1@date_local

; 2458 :             errno = EINVAL;

  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004e	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
$LN1@date_local:

; 2459 : #endif
; 2460 :         PyErr_SetFromErrno(PyExc_OSError);

  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  0005b	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 2461 :         return NULL;

  00060	33 c0		 xor	 eax, eax
  00062	eb 3b		 jmp	 SHORT $LN4@date_local
$LN2@date_local:

; 2462 :     }
; 2463 : 
; 2464 :     return PyObject_CallFunction(cls, "iii",
; 2465 :                                  tm->tm_year + 1900,
; 2466 :                                  tm->tm_mon + 1,
; 2467 :                                  tm->tm_mday);

  00064	48 8b 44 24 30	 mov	 rax, QWORD PTR tm$[rsp]
  00069	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0006c	ff c0		 inc	 eax
  0006e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tm$[rsp]
  00073	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00076	81 c1 6c 07 00
	00		 add	 ecx, 1900		; 0000076cH
  0007c	48 8b 54 24 30	 mov	 rdx, QWORD PTR tm$[rsp]
  00081	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  00084	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  00088	44 8b c8	 mov	 r9d, eax
  0008b	44 8b c1	 mov	 r8d, ecx
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  00095	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cls$[rsp]
  0009a	e8 00 00 00 00	 call	 PyObject_CallFunction
$LN4@date_local:

; 2468 : }

  0009f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a3	c3		 ret	 0
date_local_from_object ENDP
_TEXT	ENDS
EXTRN	__imp__localtime64:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+25
	DD	imagerel $unwind$localtime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$localtime DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT localtime
_TEXT	SEGMENT
_Time$ = 48
localtime PROC						; COMDAT

; 113  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64

; 117  : #pragma warning( pop )
; 118  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
localtime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@CHKJOJPJ@ordinal?5must?5be?5?$DO?$DN?51?$AA@ ; `string'
PUBLIC	??_C@_0O@PDNHEIGF@i?3fromordinal?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\modules\_datetimemodule.c
pdata	SEGMENT
$pdata$date_fromordinal DD imagerel date_fromordinal
	DD	imagerel date_fromordinal+151
	DD	imagerel $unwind$date_fromordinal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_fromordinal DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0BF@CHKJOJPJ@ordinal?5must?5be?5?$DO?$DN?51?$AA@
CONST	SEGMENT
??_C@_0BF@CHKJOJPJ@ordinal?5must?5be?5?$DO?$DN?51?$AA@ DB 'ordinal must b'
	DB	'e >= 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PDNHEIGF@i?3fromordinal?$AA@
CONST	SEGMENT
??_C@_0O@PDNHEIGF@i?3fromordinal?$AA@ DB 'i:fromordinal', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT date_fromordinal
_TEXT	SEGMENT
ordinal$ = 48
result$ = 56
day$22555 = 64
month$22554 = 68
year$22553 = 72
cls$ = 96
args$ = 104
date_fromordinal PROC					; COMDAT

; 2514 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2515 :     PyObject *result = NULL;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 2516 :     int ordinal;
; 2517 : 
; 2518 :     if (PyArg_ParseTuple(args, "i:fromordinal", &ordinal)) {

  00017	4c 8d 44 24 30	 lea	 r8, QWORD PTR ordinal$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@PDNHEIGF@i?3fromordinal?$AA@
  00023	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002d	85 c0		 test	 eax, eax
  0002f	74 5c		 je	 SHORT $LN3@date_fromo

; 2519 :         int year;
; 2520 :         int month;
; 2521 :         int day;
; 2522 : 
; 2523 :         if (ordinal < 1)

  00031	83 7c 24 30 01	 cmp	 DWORD PTR ordinal$[rsp], 1
  00036	7d 15		 jge	 SHORT $LN2@date_fromo

; 2524 :             PyErr_SetString(PyExc_ValueError, "ordinal must be "
; 2525 :                                               ">= 1");

  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@CHKJOJPJ@ordinal?5must?5be?5?$DO?$DN?51?$AA@
  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00046	e8 00 00 00 00	 call	 PyErr_SetString

; 2526 :         else {

  0004b	eb 40		 jmp	 SHORT $LN1@date_fromo
$LN2@date_fromo:

; 2527 :             ord_to_ymd(ordinal, &year, &month, &day);

  0004d	4c 8d 4c 24 40	 lea	 r9, QWORD PTR day$22555[rsp]
  00052	4c 8d 44 24 44	 lea	 r8, QWORD PTR month$22554[rsp]
  00057	48 8d 54 24 48	 lea	 rdx, QWORD PTR year$22553[rsp]
  0005c	8b 4c 24 30	 mov	 ecx, DWORD PTR ordinal$[rsp]
  00060	e8 00 00 00 00	 call	 ord_to_ymd

; 2528 :             result = PyObject_CallFunction(cls, "iii",
; 2529 :                                            year, month, day);

  00065	8b 44 24 40	 mov	 eax, DWORD PTR day$22555[rsp]
  00069	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006d	44 8b 4c 24 44	 mov	 r9d, DWORD PTR month$22554[rsp]
  00072	44 8b 44 24 48	 mov	 r8d, DWORD PTR year$22553[rsp]
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  0007e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cls$[rsp]
  00083	e8 00 00 00 00	 call	 PyObject_CallFunction
  00088	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax
$LN1@date_fromo:
$LN3@date_fromo:

; 2530 :         }
; 2531 :     }
; 2532 :     return result;

  0008d	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]

; 2533 : }

  00092	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00096	c3		 ret	 0
date_fromordinal ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EC@ELBJNAGA@?$AAn?$AA?5?$AA?$DM?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAi?$AAn?$AA_?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?$CI?$AA?$CK?$AAy?$AAe?$AAa?$AAr?$AA?0?$AA?5?$AA?$CK?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1O@CNPBLIGI@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@FGNBEJCO@?$AAl?$AAe?$AAa?$AAp?$AAy?$AAe?$AAa?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAs?$AA_?$AAl?$AAe?$AAa?$AAp?$AA?$CI?$AA?$CK?$AAy?$AAe?$AAa?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@FHBDFNK@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@NBHLCFDD@?$AAo?$AAr?$AAd?$AAi?$AAn?$AAa?$AAl?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$ord_to_ymd DD imagerel ord_to_ymd
	DD	imagerel ord_to_ymd+701
	DD	imagerel $unwind$ord_to_ymd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ord_to_ymd DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT ??_C@_1EC@ELBJNAGA@?$AAn?$AA?5?$AA?$DM?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAi?$AAn?$AA_?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?$CI?$AA?$CK?$AAy?$AAe?$AAa?$AAr?$AA?0?$AA?5?$AA?$CK?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@ELBJNAGA@?$AAn?$AA?5?$AA?$DM?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAi?$AAn?$AA_?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?$CI?$AA?$CK?$AAy?$AAe?$AAa?$AAr?$AA?0?$AA?5?$AA?$CK?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?$CJ@ DB 'n'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 'd', 00H, 'a', 00H, 'y', 00H
	DB	's', 00H, '_', 00H, 'i', 00H, 'n', 00H, '_', 00H, 'm', 00H, 'o'
	DB	00H, 'n', 00H, 't', 00H, 'h', 00H, '(', 00H, '*', 00H, 'y', 00H
	DB	'e', 00H, 'a', 00H, 'r', 00H, ',', 00H, ' ', 00H, '*', 00H, 'm'
	DB	00H, 'o', 00H, 'n', 00H, 't', 00H, 'h', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@CNPBLIGI@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1O@CNPBLIGI@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?$AA@ DB '0', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'n', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@FGNBEJCO@?$AAl?$AAe?$AAa?$AAp?$AAy?$AAe?$AAa?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAs?$AA_?$AAl?$AAe?$AAa?$AAp?$AA?$CI?$AA?$CK?$AAy?$AAe?$AAa?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@FGNBEJCO@?$AAl?$AAe?$AAa?$AAp?$AAy?$AAe?$AAa?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAs?$AA_?$AAl?$AAe?$AAa?$AAp?$AA?$CI?$AA?$CK?$AAy?$AAe?$AAa?$AAr?$AA?$CJ?$AA?$AA@ DB 'l'
	DB	00H, 'e', 00H, 'a', 00H, 'p', 00H, 'y', 00H, 'e', 00H, 'a', 00H
	DB	'r', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'i', 00H, 's'
	DB	00H, '_', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'p', 00H, '(', 00H
	DB	'*', 00H, 'y', 00H, 'e', 00H, 'a', 00H, 'r', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@FHBDFNK@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1O@FHBDFNK@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'n', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NBHLCFDD@?$AAo?$AAr?$AAd?$AAi?$AAn?$AAa?$AAl?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NBHLCFDD@?$AAo?$AAr?$AAd?$AAi?$AAn?$AAa?$AAl?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'o'
	DB	00H, 'r', 00H, 'd', 00H, 'i', 00H, 'n', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ord_to_ymd
_TEXT	SEGMENT
n$ = 32
n100$ = 36
n1$ = 40
n4$ = 44
leapyear$ = 48
preceding$ = 52
n400$ = 56
tv128 = 60
tv143 = 64
ordinal$ = 96
year$ = 104
month$ = 112
day$ = 120
ord_to_ymd PROC						; COMDAT

; 257  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 258  :     int n, n1, n4, n100, n400, leapyear, preceding;
; 259  : 
; 260  :     /* ordinal is a 1-based index, starting at 1-Jan-1.  The pattern of
; 261  :      * leap years repeats exactly every 400 years.  The basic strategy is
; 262  :      * to find the closest 400-year boundary at or before ordinal, then
; 263  :      * work with the offset from that boundary to ordinal.  Life is much
; 264  :      * clearer if we subtract 1 from ordinal first -- then the values
; 265  :      * of ordinal at 400-year boundaries are exactly those divisible
; 266  :      * by DI400Y:
; 267  :      *
; 268  :      *    D  M   Y            n              n-1
; 269  :      *    -- --- ----        ----------     ----------------
; 270  :      *    31 Dec -400        -DI400Y       -DI400Y -1
; 271  :      *     1 Jan -399         -DI400Y +1   -DI400Y      400-year boundary
; 272  :      *    ...
; 273  :      *    30 Dec  000        -1             -2
; 274  :      *    31 Dec  000         0             -1
; 275  :      *     1 Jan  001         1              0          400-year boundary
; 276  :      *     2 Jan  001         2              1
; 277  :      *     3 Jan  001         3              2
; 278  :      *    ...
; 279  :      *    31 Dec  400         DI400Y        DI400Y -1
; 280  :      *     1 Jan  401         DI400Y +1     DI400Y      400-year boundary
; 281  :      */
; 282  :     assert(ordinal >= 1);

  00017	83 7c 24 60 01	 cmp	 DWORD PTR ordinal$[rsp], 1
  0001c	7d 1c		 jge	 SHORT $LN6@ord_to_ymd
  0001e	41 b8 1a 01 00
	00		 mov	 r8d, 282		; 0000011aH
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@NBHLCFDD@?$AAo?$AAr?$AAd?$AAi?$AAn?$AAa?$AAl?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00038	33 c0		 xor	 eax, eax
$LN6@ord_to_ymd:

; 283  :     --ordinal;

  0003a	8b 44 24 60	 mov	 eax, DWORD PTR ordinal$[rsp]
  0003e	ff c8		 dec	 eax
  00040	89 44 24 60	 mov	 DWORD PTR ordinal$[rsp], eax

; 284  :     n400 = ordinal / DI400Y;

  00044	8b 44 24 60	 mov	 eax, DWORD PTR ordinal$[rsp]
  00048	99		 cdq
  00049	b9 b1 3a 02 00	 mov	 ecx, 146097		; 00023ab1H
  0004e	f7 f9		 idiv	 ecx
  00050	89 44 24 38	 mov	 DWORD PTR n400$[rsp], eax

; 285  :     n = ordinal % DI400Y;

  00054	8b 44 24 60	 mov	 eax, DWORD PTR ordinal$[rsp]
  00058	99		 cdq
  00059	b9 b1 3a 02 00	 mov	 ecx, 146097		; 00023ab1H
  0005e	f7 f9		 idiv	 ecx
  00060	8b c2		 mov	 eax, edx
  00062	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 286  :     *year = n400 * 400 + 1;

  00066	8b 44 24 38	 mov	 eax, DWORD PTR n400$[rsp]
  0006a	69 c0 90 01 00
	00		 imul	 eax, 400		; 00000190H
  00070	ff c0		 inc	 eax
  00072	48 8b 4c 24 68	 mov	 rcx, QWORD PTR year$[rsp]
  00077	89 01		 mov	 DWORD PTR [rcx], eax

; 287  : 
; 288  :     /* Now n is the (non-negative) offset, in days, from January 1 of
; 289  :      * year, to the desired date.  Now compute how many 100-year cycles
; 290  :      * precede n.
; 291  :      * Note that it's possible for n100 to equal 4!  In that case 4 full
; 292  :      * 100-year cycles precede the desired day, which implies the
; 293  :      * desired day is December 31 at the end of a 400-year cycle.
; 294  :      */
; 295  :     n100 = n / DI100Y;

  00079	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0007d	99		 cdq
  0007e	b9 ac 8e 00 00	 mov	 ecx, 36524		; 00008eacH
  00083	f7 f9		 idiv	 ecx
  00085	89 44 24 24	 mov	 DWORD PTR n100$[rsp], eax

; 296  :     n = n % DI100Y;

  00089	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0008d	99		 cdq
  0008e	b9 ac 8e 00 00	 mov	 ecx, 36524		; 00008eacH
  00093	f7 f9		 idiv	 ecx
  00095	8b c2		 mov	 eax, edx
  00097	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 297  : 
; 298  :     /* Now compute how many 4-year cycles precede it. */
; 299  :     n4 = n / DI4Y;

  0009b	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0009f	99		 cdq
  000a0	b9 b5 05 00 00	 mov	 ecx, 1461		; 000005b5H
  000a5	f7 f9		 idiv	 ecx
  000a7	89 44 24 2c	 mov	 DWORD PTR n4$[rsp], eax

; 300  :     n = n % DI4Y;

  000ab	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000af	99		 cdq
  000b0	b9 b5 05 00 00	 mov	 ecx, 1461		; 000005b5H
  000b5	f7 f9		 idiv	 ecx
  000b7	8b c2		 mov	 eax, edx
  000b9	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 301  : 
; 302  :     /* And now how many single years.  Again n1 can be 4, and again
; 303  :      * meaning that the desired day is December 31 at the end of the
; 304  :      * 4-year cycle.
; 305  :      */
; 306  :     n1 = n / 365;

  000bd	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000c1	99		 cdq
  000c2	b9 6d 01 00 00	 mov	 ecx, 365		; 0000016dH
  000c7	f7 f9		 idiv	 ecx
  000c9	89 44 24 28	 mov	 DWORD PTR n1$[rsp], eax

; 307  :     n = n % 365;

  000cd	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  000d1	99		 cdq
  000d2	b9 6d 01 00 00	 mov	 ecx, 365		; 0000016dH
  000d7	f7 f9		 idiv	 ecx
  000d9	8b c2		 mov	 eax, edx
  000db	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 308  : 
; 309  :     *year += n100 * 100 + n4 * 4 + n1;

  000df	8b 44 24 24	 mov	 eax, DWORD PTR n100$[rsp]
  000e3	6b c0 64	 imul	 eax, 100		; 00000064H
  000e6	8b 4c 24 28	 mov	 ecx, DWORD PTR n1$[rsp]
  000ea	03 c8		 add	 ecx, eax
  000ec	8b c1		 mov	 eax, ecx
  000ee	8b 4c 24 2c	 mov	 ecx, DWORD PTR n4$[rsp]
  000f2	8d 04 88	 lea	 eax, DWORD PTR [rax+rcx*4]
  000f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR year$[rsp]
  000fa	03 01		 add	 eax, DWORD PTR [rcx]
  000fc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR year$[rsp]
  00101	89 01		 mov	 DWORD PTR [rcx], eax

; 310  :     if (n1 == 4 || n100 == 4) {

  00103	83 7c 24 28 04	 cmp	 DWORD PTR n1$[rsp], 4
  00108	74 07		 je	 SHORT $LN2@ord_to_ymd
  0010a	83 7c 24 24 04	 cmp	 DWORD PTR n100$[rsp], 4
  0010f	75 4e		 jne	 SHORT $LN3@ord_to_ymd
$LN2@ord_to_ymd:

; 311  :         assert(n == 0);

  00111	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  00116	74 1c		 je	 SHORT $LN7@ord_to_ymd
  00118	41 b8 37 01 00
	00		 mov	 r8d, 311		; 00000137H
  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@FHBDFNK@?$AAn?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00132	33 c0		 xor	 eax, eax
$LN7@ord_to_ymd:

; 312  :         *year -= 1;

  00134	48 8b 44 24 68	 mov	 rax, QWORD PTR year$[rsp]
  00139	8b 00		 mov	 eax, DWORD PTR [rax]
  0013b	ff c8		 dec	 eax
  0013d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR year$[rsp]
  00142	89 01		 mov	 DWORD PTR [rcx], eax

; 313  :         *month = 12;

  00144	48 8b 44 24 70	 mov	 rax, QWORD PTR month$[rsp]
  00149	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 314  :         *day = 31;

  0014f	48 8b 44 24 78	 mov	 rax, QWORD PTR day$[rsp]
  00154	c7 00 1f 00 00
	00		 mov	 DWORD PTR [rax], 31

; 315  :         return;

  0015a	e9 59 01 00 00	 jmp	 $LN4@ord_to_ymd
$LN3@ord_to_ymd:

; 316  :     }
; 317  : 
; 318  :     /* Now the year is correct, and n is the offset from January 1.  We
; 319  :      * find the month via an estimate that's either exact or one too
; 320  :      * large.
; 321  :      */
; 322  :     leapyear = n1 == 3 && (n4 != 24 || n100 == 3);

  0015f	83 7c 24 28 03	 cmp	 DWORD PTR n1$[rsp], 3
  00164	75 18		 jne	 SHORT $LN9@ord_to_ymd
  00166	83 7c 24 2c 18	 cmp	 DWORD PTR n4$[rsp], 24
  0016b	75 07		 jne	 SHORT $LN8@ord_to_ymd
  0016d	83 7c 24 24 03	 cmp	 DWORD PTR n100$[rsp], 3
  00172	75 0a		 jne	 SHORT $LN9@ord_to_ymd
$LN8@ord_to_ymd:
  00174	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  0017c	eb 08		 jmp	 SHORT $LN10@ord_to_ymd
$LN9@ord_to_ymd:
  0017e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN10@ord_to_ymd:
  00186	8b 44 24 3c	 mov	 eax, DWORD PTR tv128[rsp]
  0018a	89 44 24 30	 mov	 DWORD PTR leapyear$[rsp], eax

; 323  :     assert(leapyear == is_leap(*year));

  0018e	48 8b 44 24 68	 mov	 rax, QWORD PTR year$[rsp]
  00193	8b 08		 mov	 ecx, DWORD PTR [rax]
  00195	e8 00 00 00 00	 call	 is_leap
  0019a	39 44 24 30	 cmp	 DWORD PTR leapyear$[rsp], eax
  0019e	74 1c		 je	 SHORT $LN11@ord_to_ymd
  001a0	41 b8 43 01 00
	00		 mov	 r8d, 323		; 00000143H
  001a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@FGNBEJCO@?$AAl?$AAe?$AAa?$AAp?$AAy?$AAe?$AAa?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAi?$AAs?$AA_?$AAl?$AAe?$AAa?$AAp?$AA?$CI?$AA?$CK?$AAy?$AAe?$AAa?$AAr?$AA?$CJ?$AA?$AA@
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001ba	33 c0		 xor	 eax, eax
$LN11@ord_to_ymd:

; 324  :     *month = (n + 50) >> 5;

  001bc	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  001c0	83 c0 32	 add	 eax, 50			; 00000032H
  001c3	c1 f8 05	 sar	 eax, 5
  001c6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR month$[rsp]
  001cb	89 01		 mov	 DWORD PTR [rcx], eax

; 325  :     preceding = (_days_before_month[*month] + (*month > 2 && leapyear));

  001cd	48 8b 44 24 70	 mov	 rax, QWORD PTR month$[rsp]
  001d2	83 38 02	 cmp	 DWORD PTR [rax], 2
  001d5	7e 11		 jle	 SHORT $LN12@ord_to_ymd
  001d7	83 7c 24 30 00	 cmp	 DWORD PTR leapyear$[rsp], 0
  001dc	74 0a		 je	 SHORT $LN12@ord_to_ymd
  001de	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
  001e6	eb 08		 jmp	 SHORT $LN13@ord_to_ymd
$LN12@ord_to_ymd:
  001e8	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN13@ord_to_ymd:
  001f0	48 8b 44 24 70	 mov	 rax, QWORD PTR month$[rsp]
  001f5	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_days_before_month
  001ff	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00202	03 44 24 40	 add	 eax, DWORD PTR tv143[rsp]
  00206	89 44 24 34	 mov	 DWORD PTR preceding$[rsp], eax

; 326  :     if (preceding > n) {

  0020a	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0020e	39 44 24 34	 cmp	 DWORD PTR preceding$[rsp], eax
  00212	7e 2f		 jle	 SHORT $LN1@ord_to_ymd

; 327  :         /* estimate is too large */
; 328  :         *month -= 1;

  00214	48 8b 44 24 70	 mov	 rax, QWORD PTR month$[rsp]
  00219	8b 00		 mov	 eax, DWORD PTR [rax]
  0021b	ff c8		 dec	 eax
  0021d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR month$[rsp]
  00222	89 01		 mov	 DWORD PTR [rcx], eax

; 329  :         preceding -= days_in_month(*year, *month);

  00224	48 8b 44 24 70	 mov	 rax, QWORD PTR month$[rsp]
  00229	8b 10		 mov	 edx, DWORD PTR [rax]
  0022b	48 8b 44 24 68	 mov	 rax, QWORD PTR year$[rsp]
  00230	8b 08		 mov	 ecx, DWORD PTR [rax]
  00232	e8 00 00 00 00	 call	 days_in_month
  00237	8b 4c 24 34	 mov	 ecx, DWORD PTR preceding$[rsp]
  0023b	2b c8		 sub	 ecx, eax
  0023d	8b c1		 mov	 eax, ecx
  0023f	89 44 24 34	 mov	 DWORD PTR preceding$[rsp], eax
$LN1@ord_to_ymd:

; 330  :     }
; 331  :     n -= preceding;

  00243	8b 44 24 34	 mov	 eax, DWORD PTR preceding$[rsp]
  00247	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  0024b	2b c8		 sub	 ecx, eax
  0024d	8b c1		 mov	 eax, ecx
  0024f	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 332  :     assert(0 <= n);

  00253	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  00258	7d 1c		 jge	 SHORT $LN14@ord_to_ymd
  0025a	41 b8 4c 01 00
	00		 mov	 r8d, 332		; 0000014cH
  00260	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@CNPBLIGI@?$AA0?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAn?$AA?$AA@
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00274	33 c0		 xor	 eax, eax
$LN14@ord_to_ymd:

; 333  :     assert(n < days_in_month(*year, *month));

  00276	48 8b 44 24 70	 mov	 rax, QWORD PTR month$[rsp]
  0027b	8b 10		 mov	 edx, DWORD PTR [rax]
  0027d	48 8b 44 24 68	 mov	 rax, QWORD PTR year$[rsp]
  00282	8b 08		 mov	 ecx, DWORD PTR [rax]
  00284	e8 00 00 00 00	 call	 days_in_month
  00289	39 44 24 20	 cmp	 DWORD PTR n$[rsp], eax
  0028d	7c 1c		 jl	 SHORT $LN15@ord_to_ymd
  0028f	41 b8 4d 01 00
	00		 mov	 r8d, 333		; 0000014dH
  00295	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@ELBJNAGA@?$AAn?$AA?5?$AA?$DM?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAi?$AAn?$AA_?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?$CI?$AA?$CK?$AAy?$AAe?$AAa?$AAr?$AA?0?$AA?5?$AA?$CK?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?$CJ@
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002a9	33 c0		 xor	 eax, eax
$LN15@ord_to_ymd:

; 334  : 
; 335  :     *day = n + 1;

  002ab	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  002af	ff c0		 inc	 eax
  002b1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR day$[rsp]
  002b6	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@ord_to_ymd:

; 336  : }

  002b8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002bc	c3		 ret	 0
ord_to_ymd ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_add DD imagerel date_add
	DD	imagerel date_add+319
	DD	imagerel $unwind$date_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_add DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_add
_TEXT	SEGMENT
left$ = 48
right$ = 56
date_add PROC						; COMDAT

; 2559 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2560 :     if (PyDateTime_Check(left) || PyDateTime_Check(right))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR left$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 44		 je	 SHORT $LN9@date_add
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR left$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 2b		 jne	 SHORT $LN9@date_add
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR right$[rsp]
  00045	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00049	74 19		 je	 SHORT $LN8@date_add
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00052	48 8b 44 24 38	 mov	 rax, QWORD PTR right$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	74 18		 je	 SHORT $LN10@date_add
$LN8@date_add:
$LN9@date_add:

; 2561 :         Py_RETURN_NOTIMPLEMENTED;

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0006b	e8 00 00 00 00	 call	 _Py_IncRef
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00077	e9 be 00 00 00	 jmp	 $LN11@date_add
$LN10@date_add:

; 2562 : 
; 2563 :     if (PyDate_Check(left)) {

  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateType
  00083	48 8b 4c 24 30	 mov	 rcx, QWORD PTR left$[rsp]
  00088	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0008c	74 19		 je	 SHORT $LN6@date_add
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateType
  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR left$[rsp]
  0009a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0009e	e8 00 00 00 00	 call	 PyType_IsSubtype
  000a3	85 c0		 test	 eax, eax
  000a5	74 41		 je	 SHORT $LN7@date_add
$LN6@date_add:

; 2564 :         /* date + ??? */
; 2565 :         if (PyDelta_Check(right))

  000a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  000ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR right$[rsp]
  000b3	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000b7	74 19		 je	 SHORT $LN4@date_add
  000b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  000c0	48 8b 44 24 38	 mov	 rax, QWORD PTR right$[rsp]
  000c5	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000c9	e8 00 00 00 00	 call	 PyType_IsSubtype
  000ce	85 c0		 test	 eax, eax
  000d0	74 14		 je	 SHORT $LN5@date_add
$LN4@date_add:

; 2566 :             /* date + delta */
; 2567 :             return add_date_timedelta((PyDateTime_Date *) left,
; 2568 :                                       (PyDateTime_Delta *) right,
; 2569 :                                       0);

  000d2	45 33 c0	 xor	 r8d, r8d
  000d5	48 8b 54 24 38	 mov	 rdx, QWORD PTR right$[rsp]
  000da	48 8b 4c 24 30	 mov	 rcx, QWORD PTR left$[rsp]
  000df	e8 00 00 00 00	 call	 add_date_timedelta
  000e4	eb 54		 jmp	 SHORT $LN11@date_add
$LN5@date_add:

; 2570 :     }
; 2571 :     else {

  000e6	eb 3f		 jmp	 SHORT $LN3@date_add
$LN7@date_add:

; 2572 :         /* ??? + date
; 2573 :          * 'right' must be one of us, or we wouldn't have been called
; 2574 :          */
; 2575 :         if (PyDelta_Check(left))

  000e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  000ef	48 8b 4c 24 30	 mov	 rcx, QWORD PTR left$[rsp]
  000f4	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000f8	74 19		 je	 SHORT $LN1@date_add
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00101	48 8b 44 24 30	 mov	 rax, QWORD PTR left$[rsp]
  00106	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0010a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0010f	85 c0		 test	 eax, eax
  00111	74 14		 je	 SHORT $LN2@date_add
$LN1@date_add:

; 2576 :             /* delta + date */
; 2577 :             return add_date_timedelta((PyDateTime_Date *) right,
; 2578 :                                       (PyDateTime_Delta *) left,
; 2579 :                                       0);

  00113	45 33 c0	 xor	 r8d, r8d
  00116	48 8b 54 24 30	 mov	 rdx, QWORD PTR left$[rsp]
  0011b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR right$[rsp]
  00120	e8 00 00 00 00	 call	 add_date_timedelta
  00125	eb 13		 jmp	 SHORT $LN11@date_add
$LN2@date_add:
$LN3@date_add:

; 2580 :     }
; 2581 :     Py_RETURN_NOTIMPLEMENTED;

  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0012e	e8 00 00 00 00	 call	 _Py_IncRef
  00133	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN11@date_add:

; 2582 : }

  0013a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0013e	c3		 ret	 0
date_add ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_date_timedelta DD imagerel add_date_timedelta
	DD	imagerel add_date_timedelta+188
	DD	imagerel $unwind$add_date_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_date_timedelta DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT add_date_timedelta
_TEXT	SEGMENT
day$ = 32
month$ = 36
result$ = 40
year$ = 48
deltadays$ = 52
tv81 = 56
date$ = 80
delta$ = 88
negate$ = 96
add_date_timedelta PROC					; COMDAT

; 2544 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2545 :     PyObject *result = NULL;

  00013	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 2546 :     int year = GET_YEAR(date);

  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR date$[rsp]
  00021	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00025	c1 e0 08	 shl	 eax, 8
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR date$[rsp]
  0002d	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00031	0b c1		 or	 eax, ecx
  00033	89 44 24 30	 mov	 DWORD PTR year$[rsp], eax

; 2547 :     int month = GET_MONTH(date);

  00037	48 8b 44 24 50	 mov	 rax, QWORD PTR date$[rsp]
  0003c	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  00040	89 44 24 24	 mov	 DWORD PTR month$[rsp], eax

; 2548 :     int deltadays = GET_TD_DAYS(delta);

  00044	48 8b 44 24 58	 mov	 rax, QWORD PTR delta$[rsp]
  00049	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0004c	89 44 24 34	 mov	 DWORD PTR deltadays$[rsp], eax

; 2549 :     /* C-level overflow is impossible because |deltadays| < 1e9. */
; 2550 :     int day = GET_DAY(date) + (negate ? -deltadays : deltadays);

  00050	83 7c 24 60 00	 cmp	 DWORD PTR negate$[rsp], 0
  00055	74 0c		 je	 SHORT $LN4@add_date_t
  00057	8b 44 24 34	 mov	 eax, DWORD PTR deltadays$[rsp]
  0005b	f7 d8		 neg	 eax
  0005d	89 44 24 38	 mov	 DWORD PTR tv81[rsp], eax
  00061	eb 08		 jmp	 SHORT $LN5@add_date_t
$LN4@add_date_t:
  00063	8b 44 24 34	 mov	 eax, DWORD PTR deltadays$[rsp]
  00067	89 44 24 38	 mov	 DWORD PTR tv81[rsp], eax
$LN5@add_date_t:
  0006b	48 8b 44 24 50	 mov	 rax, QWORD PTR date$[rsp]
  00070	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00074	03 44 24 38	 add	 eax, DWORD PTR tv81[rsp]
  00078	89 44 24 20	 mov	 DWORD PTR day$[rsp], eax

; 2551 : 
; 2552 :     if (normalize_date(&year, &month, &day) >= 0)

  0007c	4c 8d 44 24 20	 lea	 r8, QWORD PTR day$[rsp]
  00081	48 8d 54 24 24	 lea	 rdx, QWORD PTR month$[rsp]
  00086	48 8d 4c 24 30	 lea	 rcx, QWORD PTR year$[rsp]
  0008b	e8 00 00 00 00	 call	 normalize_date
  00090	85 c0		 test	 eax, eax
  00092	7c 1e		 jl	 SHORT $LN1@add_date_t

; 2553 :         result = new_date(year, month, day);

  00094	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_DateType
  0009b	44 8b 44 24 20	 mov	 r8d, DWORD PTR day$[rsp]
  000a0	8b 54 24 24	 mov	 edx, DWORD PTR month$[rsp]
  000a4	8b 4c 24 30	 mov	 ecx, DWORD PTR year$[rsp]
  000a8	e8 00 00 00 00	 call	 new_date_ex
  000ad	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax
$LN1@add_date_t:

; 2554 :     return result;

  000b2	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]

; 2555 : }

  000b7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bb	c3		 ret	 0
add_date_timedelta ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize_date DD imagerel normalize_date
	DD	imagerel normalize_date+44
	DD	imagerel $unwind$normalize_date
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize_date DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT normalize_date
_TEXT	SEGMENT
year$ = 48
month$ = 56
day$ = 64
normalize_date PROC					; COMDAT

; 567  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 568  :     return normalize_y_m_d(year, month, day);

  00013	4c 8b 44 24 40	 mov	 r8, QWORD PTR day$[rsp]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR month$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR year$[rsp]
  00022	e8 00 00 00 00	 call	 normalize_y_m_d

; 569  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
normalize_date ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@ICPHLELO@date?5value?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_1O@DCNOMMAE@?$AA?$CK?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@KPHHPGJF@?$AA?$CK?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@OBOHIJIC@?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA2?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize_y_m_d DD imagerel normalize_y_m_d
	DD	imagerel normalize_y_m_d+529
	DD	imagerel $unwind$normalize_y_m_d
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize_y_m_d DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BI@ICPHLELO@date?5value?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BI@ICPHLELO@date?5value?5out?5of?5range?$AA@ DB 'date value out of'
	DB	' range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@DCNOMMAE@?$AA?$CK?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1O@DCNOMMAE@?$AA?$CK?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB '*', 00H
	DB	'd', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@KPHHPGJF@?$AA?$CK?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1O@KPHHPGJF@?$AA?$CK?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB '*', 00H
	DB	'm', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@OBOHIJIC@?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@OBOHIJIC@?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA2?$AA?$AA@ DB '1'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '*', 00H, 'm', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '*', 00H, 'm', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, '1', 00H, '2', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT normalize_y_m_d
_TEXT	SEGMENT
dim$ = 32
ordinal$20722 = 36
y$ = 64
m$ = 72
d$ = 80
normalize_y_m_d PROC					; COMDAT

; 500  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 501  :     int dim;            /* # of days in month */
; 502  : 
; 503  :     /* In actual use, m is always the month component extracted from a
; 504  :      * date/datetime object.  Therefore it is always in [1, 12] range.
; 505  :      */
; 506  : 
; 507  :     assert(1 <= *m && *m <= 12);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  00018	83 38 01	 cmp	 DWORD PTR [rax], 1
  0001b	7c 0a		 jl	 SHORT $LN16@normalize_@3
  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  00022	83 38 0c	 cmp	 DWORD PTR [rax], 12
  00025	7e 1c		 jle	 SHORT $LN17@normalize_@3
$LN16@normalize_@3:
  00027	41 b8 fb 01 00
	00		 mov	 r8d, 507		; 000001fbH
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@OBOHIJIC@?$AA1?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CK?$AAm?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CK?$AAm?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA2?$AA?$AA@
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00041	33 c0		 xor	 eax, eax
$LN17@normalize_@3:

; 508  : 
; 509  :     /* Now only day can be out of bounds (year may also be out of bounds
; 510  :      * for a datetime object, but we don't care about that here).
; 511  :      * If day is out of bounds, what to do is arguable, but at least the
; 512  :      * method here is principled and explainable.
; 513  :      */
; 514  :     dim = days_in_month(*y, *m);

  00043	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  00048	8b 10		 mov	 edx, DWORD PTR [rax]
  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR y$[rsp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00051	e8 00 00 00 00	 call	 days_in_month
  00056	89 44 24 20	 mov	 DWORD PTR dim$[rsp], eax

; 515  :     if (*d < 1 || *d > dim) {

  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR d$[rsp]
  0005f	83 38 01	 cmp	 DWORD PTR [rax], 1
  00062	7c 11		 jl	 SHORT $LN12@normalize_@3
  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR d$[rsp]
  00069	8b 4c 24 20	 mov	 ecx, DWORD PTR dim$[rsp]
  0006d	39 08		 cmp	 DWORD PTR [rax], ecx
  0006f	0f 8e 18 01 00
	00		 jle	 $LN13@normalize_@3
$LN12@normalize_@3:

; 516  :         /* Move day-1 days from the first of the month.  First try to
; 517  :          * get off cheap if we're only one day out of range
; 518  :          * (adjustments for timezone alone can't be worse than that).
; 519  :          */
; 520  :         if (*d == 0) {

  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR d$[rsp]
  0007a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0007d	75 61		 jne	 SHORT $LN11@normalize_@3

; 521  :             --*m;

  0007f	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  00084	8b 00		 mov	 eax, DWORD PTR [rax]
  00086	ff c8		 dec	 eax
  00088	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  0008d	89 01		 mov	 DWORD PTR [rcx], eax

; 522  :             if (*m > 0)

  0008f	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  00094	83 38 00	 cmp	 DWORD PTR [rax], 0
  00097	7e 1c		 jle	 SHORT $LN10@normalize_@3

; 523  :                 *d = days_in_month(*y, *m);

  00099	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  0009e	8b 10		 mov	 edx, DWORD PTR [rax]
  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR y$[rsp]
  000a5	8b 08		 mov	 ecx, DWORD PTR [rax]
  000a7	e8 00 00 00 00	 call	 days_in_month
  000ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d$[rsp]
  000b1	89 01		 mov	 DWORD PTR [rcx], eax

; 524  :             else {

  000b3	eb 26		 jmp	 SHORT $LN9@normalize_@3
$LN10@normalize_@3:

; 525  :                 --*y;

  000b5	48 8b 44 24 40	 mov	 rax, QWORD PTR y$[rsp]
  000ba	8b 00		 mov	 eax, DWORD PTR [rax]
  000bc	ff c8		 dec	 eax
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR y$[rsp]
  000c3	89 01		 mov	 DWORD PTR [rcx], eax

; 526  :                 *m = 12;

  000c5	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  000ca	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 527  :                 *d = 31;

  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR d$[rsp]
  000d5	c7 00 1f 00 00
	00		 mov	 DWORD PTR [rax], 31
$LN9@normalize_@3:

; 528  :             }

  000db	e9 ad 00 00 00	 jmp	 $LN8@normalize_@3
$LN11@normalize_@3:

; 529  :         }
; 530  :         else if (*d == dim + 1) {

  000e0	8b 44 24 20	 mov	 eax, DWORD PTR dim$[rsp]
  000e4	ff c0		 inc	 eax
  000e6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d$[rsp]
  000eb	39 01		 cmp	 DWORD PTR [rcx], eax
  000ed	75 42		 jne	 SHORT $LN7@normalize_@3

; 531  :             /* move forward a day */
; 532  :             ++*m;

  000ef	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  000f4	8b 00		 mov	 eax, DWORD PTR [rax]
  000f6	ff c0		 inc	 eax
  000f8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  000fd	89 01		 mov	 DWORD PTR [rcx], eax

; 533  :             *d = 1;

  000ff	48 8b 44 24 50	 mov	 rax, QWORD PTR d$[rsp]
  00104	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 534  :             if (*m > 12) {

  0010a	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  0010f	83 38 0c	 cmp	 DWORD PTR [rax], 12
  00112	7e 1b		 jle	 SHORT $LN6@normalize_@3

; 535  :                 *m = 1;

  00114	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  00119	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 536  :                 ++*y;

  0011f	48 8b 44 24 40	 mov	 rax, QWORD PTR y$[rsp]
  00124	8b 00		 mov	 eax, DWORD PTR [rax]
  00126	ff c0		 inc	 eax
  00128	48 8b 4c 24 40	 mov	 rcx, QWORD PTR y$[rsp]
  0012d	89 01		 mov	 DWORD PTR [rcx], eax
$LN6@normalize_@3:

; 537  :             }
; 538  :         }
; 539  :         else {

  0012f	eb 5c		 jmp	 SHORT $LN5@normalize_@3
$LN7@normalize_@3:

; 540  :             int ordinal = ymd_to_ord(*y, *m, 1) +
; 541  :                                       *d - 1;

  00131	41 b8 01 00 00
	00		 mov	 r8d, 1
  00137	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  0013c	8b 10		 mov	 edx, DWORD PTR [rax]
  0013e	48 8b 44 24 40	 mov	 rax, QWORD PTR y$[rsp]
  00143	8b 08		 mov	 ecx, DWORD PTR [rax]
  00145	e8 00 00 00 00	 call	 ymd_to_ord
  0014a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d$[rsp]
  0014f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00151	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00155	89 44 24 24	 mov	 DWORD PTR ordinal$20722[rsp], eax

; 542  :             if (ordinal < 1 || ordinal > MAXORDINAL) {

  00159	83 7c 24 24 01	 cmp	 DWORD PTR ordinal$20722[rsp], 1
  0015e	7c 0a		 jl	 SHORT $LN3@normalize_@3
  00160	81 7c 24 24 db
	b9 37 00	 cmp	 DWORD PTR ordinal$20722[rsp], 3652059 ; 0037b9dbH
  00168	7e 07		 jle	 SHORT $LN4@normalize_@3
$LN3@normalize_@3:

; 543  :                 goto error;

  0016a	e9 85 00 00 00	 jmp	 $error$20725

; 544  :             } else {

  0016f	eb 1c		 jmp	 SHORT $LN2@normalize_@3
$LN4@normalize_@3:

; 545  :                 ord_to_ymd(ordinal, y, m, d);

  00171	4c 8b 4c 24 50	 mov	 r9, QWORD PTR d$[rsp]
  00176	4c 8b 44 24 48	 mov	 r8, QWORD PTR m$[rsp]
  0017b	48 8b 54 24 40	 mov	 rdx, QWORD PTR y$[rsp]
  00180	8b 4c 24 24	 mov	 ecx, DWORD PTR ordinal$20722[rsp]
  00184	e8 00 00 00 00	 call	 ord_to_ymd

; 546  :                 return 0;

  00189	33 c0		 xor	 eax, eax
  0018b	eb 7f		 jmp	 SHORT $LN14@normalize_@3
$LN2@normalize_@3:
$LN5@normalize_@3:
$LN8@normalize_@3:
$LN13@normalize_@3:

; 547  :             }
; 548  :         }
; 549  :     }
; 550  :     assert(*m > 0);

  0018d	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
  00192	83 38 00	 cmp	 DWORD PTR [rax], 0
  00195	7f 1c		 jg	 SHORT $LN18@normalize_@3
  00197	41 b8 26 02 00
	00		 mov	 r8d, 550		; 00000226H
  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@KPHHPGJF@?$AA?$CK?$AAm?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b1	33 c0		 xor	 eax, eax
$LN18@normalize_@3:

; 551  :     assert(*d > 0);

  001b3	48 8b 44 24 50	 mov	 rax, QWORD PTR d$[rsp]
  001b8	83 38 00	 cmp	 DWORD PTR [rax], 0
  001bb	7f 1c		 jg	 SHORT $LN19@normalize_@3
  001bd	41 b8 27 02 00
	00		 mov	 r8d, 551		; 00000227H
  001c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@DCNOMMAE@?$AA?$CK?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d7	33 c0		 xor	 eax, eax
$LN19@normalize_@3:

; 552  :     if (MINYEAR <= *y && *y <= MAXYEAR)

  001d9	48 8b 44 24 40	 mov	 rax, QWORD PTR y$[rsp]
  001de	83 38 01	 cmp	 DWORD PTR [rax], 1
  001e1	7c 11		 jl	 SHORT $LN1@normalize_@3
  001e3	48 8b 44 24 40	 mov	 rax, QWORD PTR y$[rsp]
  001e8	81 38 0f 27 00
	00		 cmp	 DWORD PTR [rax], 9999	; 0000270fH
  001ee	7f 04		 jg	 SHORT $LN1@normalize_@3

; 553  :         return 0;

  001f0	33 c0		 xor	 eax, eax
  001f2	eb 18		 jmp	 SHORT $LN14@normalize_@3
$LN1@normalize_@3:
$error$20725:

; 554  :  error:
; 555  :     PyErr_SetString(PyExc_OverflowError,
; 556  :             "date value out of range");

  001f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@ICPHLELO@date?5value?5out?5of?5range?$AA@
  001fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00202	e8 00 00 00 00	 call	 PyErr_SetString

; 557  :     return -1;

  00207	b8 ff ff ff ff	 mov	 eax, -1
$LN14@normalize_@3:

; 558  : 
; 559  : }

  0020c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00210	c3		 ret	 0
normalize_y_m_d ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ymd_to_ord DD imagerel ymd_to_ord
	DD	imagerel ymd_to_ord+60
	DD	imagerel $unwind$ymd_to_ord
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ymd_to_ord DD 011101H
	DD	06211H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ymd_to_ord
_TEXT	SEGMENT
tv64 = 32
year$ = 64
month$ = 72
day$ = 80
ymd_to_ord PROC						; COMDAT

; 341  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 342  :     return days_before_year(year) + days_before_month(year, month) + day;

  00011	8b 4c 24 40	 mov	 ecx, DWORD PTR year$[rsp]
  00015	e8 00 00 00 00	 call	 days_before_year
  0001a	89 44 24 20	 mov	 DWORD PTR tv64[rsp], eax
  0001e	8b 54 24 48	 mov	 edx, DWORD PTR month$[rsp]
  00022	8b 4c 24 40	 mov	 ecx, DWORD PTR year$[rsp]
  00026	e8 00 00 00 00	 call	 days_before_month
  0002b	8b 4c 24 50	 mov	 ecx, DWORD PTR day$[rsp]
  0002f	8b 54 24 20	 mov	 edx, DWORD PTR tv64[rsp]
  00033	03 ca		 add	 ecx, edx
  00035	03 c1		 add	 eax, ecx

; 343  : }

  00037	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003b	c3		 ret	 0
ymd_to_ord ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$days_before_month DD imagerel days_before_month
	DD	imagerel days_before_month+140
	DD	imagerel $unwind$days_before_month
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$days_before_month DD 010c01H
	DD	0620cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT days_before_month
_TEXT	SEGMENT
days$ = 32
year$ = 64
month$ = 72
days_before_month PROC					; COMDAT

; 221  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 222  :     int days;
; 223  : 
; 224  :     assert(month >= 1);

  0000c	83 7c 24 48 01	 cmp	 DWORD PTR month$[rsp], 1
  00011	7d 1c		 jge	 SHORT $LN4@days_befor
  00013	41 b8 e0 00 00
	00		 mov	 r8d, 224		; 000000e0H
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@MBJLKPJC@?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002d	33 c0		 xor	 eax, eax
$LN4@days_befor:

; 225  :     assert(month <= 12);

  0002f	83 7c 24 48 0c	 cmp	 DWORD PTR month$[rsp], 12
  00034	7e 1c		 jle	 SHORT $LN5@days_befor
  00036	41 b8 e1 00 00
	00		 mov	 r8d, 225		; 000000e1H
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@LDAHDJMP@?$AAm?$AAo?$AAn?$AAt?$AAh?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA1?$AA2?$AA?$AA@
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00050	33 c0		 xor	 eax, eax
$LN5@days_befor:

; 226  :     days = _days_before_month[month];

  00052	48 63 44 24 48	 movsxd	 rax, DWORD PTR month$[rsp]
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_days_before_month
  0005e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00061	89 44 24 20	 mov	 DWORD PTR days$[rsp], eax

; 227  :     if (month > 2 && is_leap(year))

  00065	83 7c 24 48 02	 cmp	 DWORD PTR month$[rsp], 2
  0006a	7e 17		 jle	 SHORT $LN1@days_befor
  0006c	8b 4c 24 40	 mov	 ecx, DWORD PTR year$[rsp]
  00070	e8 00 00 00 00	 call	 is_leap
  00075	85 c0		 test	 eax, eax
  00077	74 0a		 je	 SHORT $LN1@days_befor

; 228  :         ++days;

  00079	8b 44 24 20	 mov	 eax, DWORD PTR days$[rsp]
  0007d	ff c0		 inc	 eax
  0007f	89 44 24 20	 mov	 DWORD PTR days$[rsp], eax
$LN1@days_befor:

; 229  :     return days;

  00083	8b 44 24 20	 mov	 eax, DWORD PTR days$[rsp]

; 230  : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
days_before_month ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BE@GHLFKFNK@?$AAy?$AAe?$AAa?$AAr?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$days_before_year DD imagerel days_before_year
	DD	imagerel days_before_year+141
	DD	imagerel $unwind$days_before_year
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$days_before_year DD 010801H
	DD	06208H
xdata	ENDS
;	COMDAT ??_C@_1BE@GHLFKFNK@?$AAy?$AAe?$AAa?$AAr?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@GHLFKFNK@?$AAy?$AAe?$AAa?$AAr?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'y'
	DB	00H, 'e', 00H, 'a', 00H, 'r', 00H, ' ', 00H, '>', 00H, '=', 00H
	DB	' ', 00H, '1', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT days_before_year
_TEXT	SEGMENT
y$ = 32
tv70 = 36
tv72 = 40
tv74 = 44
year$ = 64
days_before_year PROC					; COMDAT

; 237  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 238  :     int y = year - 1;

  00008	8b 44 24 40	 mov	 eax, DWORD PTR year$[rsp]
  0000c	ff c8		 dec	 eax
  0000e	89 44 24 20	 mov	 DWORD PTR y$[rsp], eax

; 239  :     /* This is incorrect if year <= 0; we really want the floor
; 240  :      * here.  But so long as MINYEAR is 1, the smallest year this
; 241  :      * can see is 1.
; 242  :      */
; 243  :     assert (year >= 1);

  00012	83 7c 24 40 01	 cmp	 DWORD PTR year$[rsp], 1
  00017	7d 1c		 jge	 SHORT $LN3@days_befor@2
  00019	41 b8 f3 00 00
	00		 mov	 r8d, 243		; 000000f3H
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@GHLFKFNK@?$AAy?$AAe?$AAa?$AAr?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00033	33 c0		 xor	 eax, eax
$LN3@days_befor@2:

; 244  :     return y*365 + y/4 - y/100 + y/400;

  00035	8b 44 24 20	 mov	 eax, DWORD PTR y$[rsp]
  00039	69 c0 6d 01 00
	00		 imul	 eax, 365		; 0000016dH
  0003f	89 44 24 24	 mov	 DWORD PTR tv70[rsp], eax
  00043	8b 44 24 20	 mov	 eax, DWORD PTR y$[rsp]
  00047	99		 cdq
  00048	83 e2 03	 and	 edx, 3
  0004b	03 c2		 add	 eax, edx
  0004d	c1 f8 02	 sar	 eax, 2
  00050	8b 4c 24 24	 mov	 ecx, DWORD PTR tv70[rsp]
  00054	03 c8		 add	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	89 44 24 28	 mov	 DWORD PTR tv72[rsp], eax
  0005c	8b 44 24 20	 mov	 eax, DWORD PTR y$[rsp]
  00060	99		 cdq
  00061	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00066	f7 f9		 idiv	 ecx
  00068	8b 4c 24 28	 mov	 ecx, DWORD PTR tv72[rsp]
  0006c	2b c8		 sub	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	89 44 24 2c	 mov	 DWORD PTR tv74[rsp], eax
  00074	8b 44 24 20	 mov	 eax, DWORD PTR y$[rsp]
  00078	99		 cdq
  00079	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  0007e	f7 f9		 idiv	 ecx
  00080	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv74[rsp]
  00084	03 c8		 add	 ecx, eax
  00086	8b c1		 mov	 eax, ecx

; 245  : }

  00088	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008c	c3		 ret	 0
days_before_year ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_subtract DD imagerel date_subtract
	DD	imagerel date_subtract+483
	DD	imagerel $unwind$date_subtract
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_subtract DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_subtract
_TEXT	SEGMENT
left_ord$22633 = 48
right_ord$22638 = 52
tv141 = 56
tv159 = 60
left$ = 80
right$ = 88
date_subtract PROC					; COMDAT

; 2586 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2587 :     if (PyDateTime_Check(left) || PyDateTime_Check(right))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR left$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 44		 je	 SHORT $LN8@date_subtr
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR left$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 2b		 jne	 SHORT $LN8@date_subtr
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00040	48 8b 4c 24 58	 mov	 rcx, QWORD PTR right$[rsp]
  00045	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00049	74 19		 je	 SHORT $LN7@date_subtr
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00052	48 8b 44 24 58	 mov	 rax, QWORD PTR right$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	74 18		 je	 SHORT $LN9@date_subtr
$LN7@date_subtr:
$LN8@date_subtr:

; 2588 :         Py_RETURN_NOTIMPLEMENTED;

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0006b	e8 00 00 00 00	 call	 _Py_IncRef
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00077	e9 62 01 00 00	 jmp	 $LN10@date_subtr
$LN9@date_subtr:

; 2589 : 
; 2590 :     if (PyDate_Check(left)) {

  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateType
  00083	48 8b 4c 24 50	 mov	 rcx, QWORD PTR left$[rsp]
  00088	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0008c	74 1d		 je	 SHORT $LN5@date_subtr
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateType
  00095	48 8b 44 24 50	 mov	 rax, QWORD PTR left$[rsp]
  0009a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0009e	e8 00 00 00 00	 call	 PyType_IsSubtype
  000a3	85 c0		 test	 eax, eax
  000a5	0f 84 20 01 00
	00		 je	 $LN6@date_subtr
$LN5@date_subtr:

; 2591 :         if (PyDate_Check(right)) {

  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateType
  000b2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR right$[rsp]
  000b7	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000bb	74 1d		 je	 SHORT $LN3@date_subtr
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateType
  000c4	48 8b 44 24 58	 mov	 rax, QWORD PTR right$[rsp]
  000c9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000cd	e8 00 00 00 00	 call	 PyType_IsSubtype
  000d2	85 c0		 test	 eax, eax
  000d4	0f 84 af 00 00
	00		 je	 $LN4@date_subtr
$LN3@date_subtr:

; 2592 :             /* date - date */
; 2593 :             int left_ord = ymd_to_ord(GET_YEAR(left),
; 2594 :                                       GET_MONTH(left),
; 2595 :                                       GET_DAY(left));

  000da	48 8b 44 24 50	 mov	 rax, QWORD PTR left$[rsp]
  000df	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR left$[rsp]
  000e8	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  000ec	48 8b 54 24 50	 mov	 rdx, QWORD PTR left$[rsp]
  000f1	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  000f5	c1 e2 08	 shl	 edx, 8
  000f8	4c 8b 44 24 50	 mov	 r8, QWORD PTR left$[rsp]
  000fd	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  00102	41 0b d0	 or	 edx, r8d
  00105	89 54 24 38	 mov	 DWORD PTR tv141[rsp], edx
  00109	44 8b c0	 mov	 r8d, eax
  0010c	8b d1		 mov	 edx, ecx
  0010e	8b 44 24 38	 mov	 eax, DWORD PTR tv141[rsp]
  00112	8b c8		 mov	 ecx, eax
  00114	e8 00 00 00 00	 call	 ymd_to_ord
  00119	89 44 24 30	 mov	 DWORD PTR left_ord$22633[rsp], eax

; 2596 :             int right_ord = ymd_to_ord(GET_YEAR(right),
; 2597 :                                        GET_MONTH(right),
; 2598 :                                        GET_DAY(right));

  0011d	48 8b 44 24 58	 mov	 rax, QWORD PTR right$[rsp]
  00122	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00126	48 8b 4c 24 58	 mov	 rcx, QWORD PTR right$[rsp]
  0012b	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  0012f	48 8b 54 24 58	 mov	 rdx, QWORD PTR right$[rsp]
  00134	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  00138	c1 e2 08	 shl	 edx, 8
  0013b	4c 8b 44 24 58	 mov	 r8, QWORD PTR right$[rsp]
  00140	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  00145	41 0b d0	 or	 edx, r8d
  00148	89 54 24 3c	 mov	 DWORD PTR tv159[rsp], edx
  0014c	44 8b c0	 mov	 r8d, eax
  0014f	8b d1		 mov	 edx, ecx
  00151	8b 44 24 3c	 mov	 eax, DWORD PTR tv159[rsp]
  00155	8b c8		 mov	 ecx, eax
  00157	e8 00 00 00 00	 call	 ymd_to_ord
  0015c	89 44 24 34	 mov	 DWORD PTR right_ord$22638[rsp], eax

; 2599 :             return new_delta(left_ord - right_ord, 0, 0, 0);

  00160	8b 44 24 34	 mov	 eax, DWORD PTR right_ord$22638[rsp]
  00164	8b 4c 24 30	 mov	 ecx, DWORD PTR left_ord$22633[rsp]
  00168	2b c8		 sub	 ecx, eax
  0016a	8b c1		 mov	 eax, ecx
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DeltaType
  00173	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00178	45 33 c9	 xor	 r9d, r9d
  0017b	45 33 c0	 xor	 r8d, r8d
  0017e	33 d2		 xor	 edx, edx
  00180	8b c8		 mov	 ecx, eax
  00182	e8 00 00 00 00	 call	 new_delta_ex
  00187	eb 55		 jmp	 SHORT $LN10@date_subtr
$LN4@date_subtr:

; 2600 :         }
; 2601 :         if (PyDelta_Check(right)) {

  00189	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00190	48 8b 4c 24 58	 mov	 rcx, QWORD PTR right$[rsp]
  00195	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00199	74 19		 je	 SHORT $LN1@date_subtr
  0019b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  001a2	48 8b 44 24 58	 mov	 rax, QWORD PTR right$[rsp]
  001a7	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001ab	e8 00 00 00 00	 call	 PyType_IsSubtype
  001b0	85 c0		 test	 eax, eax
  001b2	74 17		 je	 SHORT $LN2@date_subtr
$LN1@date_subtr:

; 2602 :             /* date - delta */
; 2603 :             return add_date_timedelta((PyDateTime_Date *) left,
; 2604 :                                       (PyDateTime_Delta *) right,
; 2605 :                                       1);

  001b4	41 b8 01 00 00
	00		 mov	 r8d, 1
  001ba	48 8b 54 24 58	 mov	 rdx, QWORD PTR right$[rsp]
  001bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR left$[rsp]
  001c4	e8 00 00 00 00	 call	 add_date_timedelta
  001c9	eb 13		 jmp	 SHORT $LN10@date_subtr
$LN2@date_subtr:
$LN6@date_subtr:

; 2606 :         }
; 2607 :     }
; 2608 :     Py_RETURN_NOTIMPLEMENTED;

  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  001d2	e8 00 00 00 00	 call	 _Py_IncRef
  001d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN10@date_subtr:

; 2609 : }

  001de	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001e2	c3		 ret	 0
date_subtract ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_repr DD imagerel date_repr
	DD	imagerel date_repr+102
	DD	imagerel $unwind$date_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_repr DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_repr
_TEXT	SEGMENT
tv86 = 48
self$ = 80
date_repr PROC						; COMDAT

; 2616 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2617 :     return PyUnicode_FromFormat("%s(%d, %d, %d)",
; 2618 :                                 Py_TYPE(self)->tp_name,
; 2619 :                                 GET_YEAR(self), GET_MONTH(self), GET_DAY(self));

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00017	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  0001b	48 8b 54 24 50	 mov	 rdx, QWORD PTR self$[rsp]
  00020	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  00024	c1 e2 08	 shl	 edx, 8
  00027	4c 8b 44 24 50	 mov	 r8, QWORD PTR self$[rsp]
  0002c	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  00031	41 0b d0	 or	 edx, r8d
  00034	4c 8b 44 24 50	 mov	 r8, QWORD PTR self$[rsp]
  00039	4d 8b 40 58	 mov	 r8, QWORD PTR [r8+88]
  0003d	4c 89 44 24 30	 mov	 QWORD PTR tv86[rsp], r8
  00042	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00046	44 8b c9	 mov	 r9d, ecx
  00049	44 8b c2	 mov	 r8d, edx
  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR tv86[rsp]
  00051	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  0005c	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 2620 : }

  00061	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00065	c3		 ret	 0
date_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@MCDGMPHH@?$CF04d?9?$CF02d?9?$CF02d?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_isoformat DD imagerel date_isoformat
	DD	imagerel date_isoformat+75
	DD	imagerel $unwind$date_isoformat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_isoformat DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0P@MCDGMPHH@?$CF04d?9?$CF02d?9?$CF02d?$AA@
CONST	SEGMENT
??_C@_0P@MCDGMPHH@?$CF04d?9?$CF02d?9?$CF02d?$AA@ DB '%04d-%02d-%02d', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT date_isoformat
_TEXT	SEGMENT
self$ = 48
date_isoformat PROC					; COMDAT

; 2624 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2625 :     return PyUnicode_FromFormat("%04d-%02d-%02d",
; 2626 :                                 GET_YEAR(self), GET_MONTH(self), GET_DAY(self));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00017	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  0001b	48 8b 54 24 30	 mov	 rdx, QWORD PTR self$[rsp]
  00020	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  00024	c1 e2 08	 shl	 edx, 8
  00027	4c 8b 44 24 30	 mov	 r8, QWORD PTR self$[rsp]
  0002c	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  00031	41 0b d0	 or	 edx, r8d
  00034	44 8b c8	 mov	 r9d, eax
  00037	44 8b c1	 mov	 r8d, ecx
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@MCDGMPHH@?$CF04d?9?$CF02d?9?$CF02d?$AA@
  00041	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 2627 : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
date_isoformat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_str DD imagerel date_str
	DD	imagerel date_str+60
	DD	imagerel $unwind$date_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_str DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_str
_TEXT	SEGMENT
self$ = 48
date_str PROC						; COMDAT

; 2632 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2633 :     _Py_IDENTIFIER(isoformat);
; 2634 : 
; 2635 :     return _PyObject_CallMethodId((PyObject *)self, &PyId_isoformat, "()");

  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_isoformat@?1??date_str@@9@9
  0000e	8b c0		 mov	 eax, eax
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00016	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0001f	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00023	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0002a	48 8b d0	 mov	 rdx, rax
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00032	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 2636 : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
date_str ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_ctime DD imagerel date_ctime
	DD	imagerel date_ctime+32
	DD	imagerel $unwind$date_ctime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_ctime DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_ctime
_TEXT	SEGMENT
self$ = 48
date_ctime PROC						; COMDAT

; 2641 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2642 :     return format_ctime(self, 0, 0, 0);

  00009	45 33 c9	 xor	 r9d, r9d
  0000c	45 33 c0	 xor	 r8d, r8d
  0000f	33 d2		 xor	 edx, edx
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00016	e8 00 00 00 00	 call	 format_ctime

; 2643 : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
date_ctime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@FEEHMIJ@?$CFs?5?$CFs?5?$CF2d?5?$CF02d?3?$CF02d?3?$CF02d?5?$CF04d?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_ctime DD imagerel format_ctime
	DD	imagerel format_ctime+221
	DD	imagerel $unwind$format_ctime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_ctime DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT ??_C@_0BO@FEEHMIJ@?$CFs?5?$CFs?5?$CF2d?5?$CF02d?3?$CF02d?3?$CF02d?5?$CF04d?$AA@
CONST	SEGMENT
??_C@_0BO@FEEHMIJ@?$CFs?5?$CFs?5?$CF2d?5?$CF02d?3?$CF02d?3?$CF02d?5?$CF04d?$AA@ DB '%'
	DB	's %s %2d %02d:%02d:%02d %04d', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT format_ctime
_TEXT	SEGMENT
wday$ = 64
tv80 = 68
tv139 = 72
date$ = 96
hours$ = 104
minutes$ = 112
seconds$ = 120
format_ctime PROC					; COMDAT

; 1007 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1008 :     static const char *DayNames[] = {
; 1009 :         "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"
; 1010 :     };
; 1011 :     static const char *MonthNames[] = {
; 1012 :         "Jan", "Feb", "Mar", "Apr", "May", "Jun",
; 1013 :         "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
; 1014 :     };
; 1015 : 
; 1016 :     int wday = weekday(GET_YEAR(date), GET_MONTH(date), GET_DAY(date));

  00017	48 8b 44 24 60	 mov	 rax, QWORD PTR date$[rsp]
  0001c	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00020	48 8b 4c 24 60	 mov	 rcx, QWORD PTR date$[rsp]
  00025	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  00029	48 8b 54 24 60	 mov	 rdx, QWORD PTR date$[rsp]
  0002e	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  00032	c1 e2 08	 shl	 edx, 8
  00035	4c 8b 44 24 60	 mov	 r8, QWORD PTR date$[rsp]
  0003a	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  0003f	41 0b d0	 or	 edx, r8d
  00042	89 54 24 44	 mov	 DWORD PTR tv80[rsp], edx
  00046	44 8b c0	 mov	 r8d, eax
  00049	8b d1		 mov	 edx, ecx
  0004b	8b 44 24 44	 mov	 eax, DWORD PTR tv80[rsp]
  0004f	8b c8		 mov	 ecx, eax
  00051	e8 00 00 00 00	 call	 weekday
  00056	89 44 24 40	 mov	 DWORD PTR wday$[rsp], eax

; 1017 : 
; 1018 :     return PyUnicode_FromFormat("%s %s %2d %02d:%02d:%02d %04d",
; 1019 :                                 DayNames[wday], MonthNames[GET_MONTH(date)-1],
; 1020 :                                 GET_DAY(date), hours, minutes, seconds,
; 1021 :                                 GET_YEAR(date));

  0005a	48 8b 44 24 60	 mov	 rax, QWORD PTR date$[rsp]
  0005f	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00063	c1 e0 08	 shl	 eax, 8
  00066	48 8b 4c 24 60	 mov	 rcx, QWORD PTR date$[rsp]
  0006b	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  0006f	0b c1		 or	 eax, ecx
  00071	48 8b 4c 24 60	 mov	 rcx, QWORD PTR date$[rsp]
  00076	0f b6 49 6c	 movzx	 ecx, BYTE PTR [rcx+108]
  0007a	48 8b 54 24 60	 mov	 rdx, QWORD PTR date$[rsp]
  0007f	0f b6 52 6b	 movzx	 edx, BYTE PTR [rdx+107]
  00083	ff ca		 dec	 edx
  00085	48 63 d2	 movsxd	 rdx, edx
  00088	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?MonthNames@?1??format_ctime@@9@9
  0008f	4c 63 4c 24 40	 movsxd	 r9, DWORD PTR wday$[rsp]
  00094	4c 89 4c 24 48	 mov	 QWORD PTR tv139[rsp], r9
  00099	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:?DayNames@?1??format_ctime@@9@9
  000a0	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  000a4	8b 44 24 78	 mov	 eax, DWORD PTR seconds$[rsp]
  000a8	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000ac	8b 44 24 70	 mov	 eax, DWORD PTR minutes$[rsp]
  000b0	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000b4	8b 44 24 68	 mov	 eax, DWORD PTR hours$[rsp]
  000b8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000bc	44 8b c9	 mov	 r9d, ecx
  000bf	4d 8b 04 d0	 mov	 r8, QWORD PTR [r8+rdx*8]
  000c3	48 8b 44 24 48	 mov	 rax, QWORD PTR tv139[rsp]
  000c8	49 8b 14 c2	 mov	 rdx, QWORD PTR [r10+rax*8]
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@FEEHMIJ@?$CFs?5?$CFs?5?$CF2d?5?$CF02d?3?$CF02d?3?$CF02d?5?$CF04d?$AA@
  000d3	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 1022 : }

  000d8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000dc	c3		 ret	 0
format_ctime ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$weekday DD imagerel weekday
	DD	imagerel weekday+53
	DD	imagerel $unwind$weekday
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$weekday DD 011101H
	DD	04211H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT weekday
_TEXT	SEGMENT
year$ = 48
month$ = 56
day$ = 64
weekday	PROC						; COMDAT

; 348  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 349  :     return (ymd_to_ord(year, month, day) + 6) % 7;

  00011	44 8b 44 24 40	 mov	 r8d, DWORD PTR day$[rsp]
  00016	8b 54 24 38	 mov	 edx, DWORD PTR month$[rsp]
  0001a	8b 4c 24 30	 mov	 ecx, DWORD PTR year$[rsp]
  0001e	e8 00 00 00 00	 call	 ymd_to_ord
  00023	83 c0 06	 add	 eax, 6
  00026	99		 cdq
  00027	b9 07 00 00 00	 mov	 ecx, 7
  0002c	f7 f9		 idiv	 ecx
  0002e	8b c2		 mov	 eax, edx

; 350  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
weekday	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LENHFJKM@U?3strftime?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_strftime DD imagerel date_strftime
	DD	imagerel date_strftime+179
	DD	imagerel $unwind$date_strftime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_strftime DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0L@LENHFJKM@U?3strftime?$AA@
CONST	SEGMENT
??_C@_0L@LENHFJKM@U?3strftime?$AA@ DB 'U:strftime', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT date_strftime
_TEXT	SEGMENT
format$ = 48
tuple$ = 56
result$ = 64
self$ = 96
args$ = 104
kw$ = 112
date_strftime PROC					; COMDAT

; 2647 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2648 :     /* This method can be inherited, and needs to call the
; 2649 :      * timetuple() method appropriate to self's class.
; 2650 :      */
; 2651 :     PyObject *result;
; 2652 :     PyObject *tuple;
; 2653 :     PyObject *format;
; 2654 :     _Py_IDENTIFIER(timetuple);
; 2655 :     static char *keywords[] = {"format", NULL};
; 2656 : 
; 2657 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "U:strftime", keywords,
; 2658 :                                       &format))

  00013	48 8d 44 24 30	 lea	 rax, QWORD PTR format$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??date_strftime@@9@9
  00024	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@LENHFJKM@U?3strftime?$AA@
  0002b	48 8b 54 24 70	 mov	 rdx, QWORD PTR kw$[rsp]
  00030	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00035	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0003a	85 c0		 test	 eax, eax
  0003c	75 04		 jne	 SHORT $LN2@date_strft

; 2659 :         return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 6c		 jmp	 SHORT $LN3@date_strft
$LN2@date_strft:

; 2660 : 
; 2661 :     tuple = _PyObject_CallMethodId((PyObject *)self, &PyId_timetuple, "()");

  00042	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_timetuple@?1??date_strftime@@9@9
  00047	8b c0		 mov	 eax, eax
  00049	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0004f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00058	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0005c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00063	48 8b d0	 mov	 rdx, rax
  00066	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0006b	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00070	48 89 44 24 38	 mov	 QWORD PTR tuple$[rsp], rax

; 2662 :     if (tuple == NULL)

  00075	48 83 7c 24 38
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  0007b	75 04		 jne	 SHORT $LN1@date_strft

; 2663 :         return NULL;

  0007d	33 c0		 xor	 eax, eax
  0007f	eb 2d		 jmp	 SHORT $LN3@date_strft
$LN1@date_strft:

; 2664 :     result = wrap_strftime((PyObject *)self, format, tuple,
; 2665 :                            (PyObject *)self);

  00081	4c 8b 4c 24 60	 mov	 r9, QWORD PTR self$[rsp]
  00086	4c 8b 44 24 38	 mov	 r8, QWORD PTR tuple$[rsp]
  0008b	48 8b 54 24 30	 mov	 rdx, QWORD PTR format$[rsp]
  00090	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00095	e8 00 00 00 00	 call	 wrap_strftime
  0009a	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 2666 :     Py_DECREF(tuple);

  0009f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tuple$[rsp]
  000a4	e8 00 00 00 00	 call	 _Py_DecRef

; 2667 :     return result;

  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN3@date_strft:

; 2668 : }

  000ae	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000b2	c3		 ret	 0
date_strftime ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MJJLPNK@OO?$AA@				; `string'
PUBLIC	??_C@_1CM@JMJOIOGF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAf?$AAm?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@INIGFBCG@?$AAu?$AAs?$AAe?$AAd?$AAn?$AAe?$AAw?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAo?$AAt?$AAa?$AAl?$AAn?$AAe?$AAw?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@IIEOOHJB@?$AAn?$AAt?$AAo?$AAa?$AAp?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@EILIIHHL@?$AAp?$AAt?$AAo?$AAa?$AAp?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@BAJLHDKH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@OBEPDOFM@?$AAf?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DM@ENGGNKCD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAZ?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@DEPLKICC@?$AAZ?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DI@LMLOOL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAz?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@BCJHHKPO@?$AAz?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@CDHMOIAH@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AAa?$AAr?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CA@KEHIIGHP@strftime?5format?5ends?5with?5raw?5?$CF?$AA@ ; `string'
PUBLIC	??_C@_1DA@GIDHAEEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DM@PMCNGDBM@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAt?$AAu?$AAp?$AAl?$AAe?$AA?$AA@ ; `string'
EXTRN	PyUnicode_FromString:PROC
EXTRN	_PyBytes_Resize:PROC
EXTRN	strlen:PROC
EXTRN	PyBytes_AsString:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	PyUnicode_AsUTF8AndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$wrap_strftime DD imagerel wrap_strftime
	DD	imagerel wrap_strftime+2095
	DD	imagerel $unwind$wrap_strftime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wrap_strftime DD 021b01H
	DD	025011bH
xdata	ENDS
;	COMDAT ??_C@_02MJJLPNK@OO?$AA@
CONST	SEGMENT
??_C@_02MJJLPNK@OO?$AA@ DB 'OO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@JMJOIOGF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAf?$AAm?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@JMJOIOGF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAf?$AAm?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'n', 00H, 'e', 00H, 'w', 00H, 'f', 00H, 'm', 00H, 't', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@INIGFBCG@?$AAu?$AAs?$AAe?$AAd?$AAn?$AAe?$AAw?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAo?$AAt?$AAa?$AAl?$AAn?$AAe?$AAw?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@INIGFBCG@?$AAu?$AAs?$AAe?$AAd?$AAn?$AAe?$AAw?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAo?$AAt?$AAa?$AAl?$AAn?$AAe?$AAw?$AA?$AA@ DB 'u'
	DB	00H, 's', 00H, 'e', 00H, 'd', 00H, 'n', 00H, 'e', 00H, 'w', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 't', 00H, 'o', 00H, 't'
	DB	00H, 'a', 00H, 'l', 00H, 'n', 00H, 'e', 00H, 'w', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@IIEOOHJB@?$AAn?$AAt?$AAo?$AAa?$AAp?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@IIEOOHJB@?$AAn?$AAt?$AAo?$AAa?$AAp?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'n'
	DB	00H, 't', 00H, 'o', 00H, 'a', 00H, 'p', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'd', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@EILIIHHL@?$AAp?$AAt?$AAo?$AAa?$AAp?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@EILIIHHL@?$AAp?$AAt?$AAo?$AAa?$AAp?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'p'
	DB	00H, 't', 00H, 'o', 00H, 'a', 00H, 'p', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'd', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N'
	DB	00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@BAJLHDKH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@BAJLHDKH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'f', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@OBEPDOFM@?$AAf?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@OBEPDOFM@?$AAf?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'f'
	DB	00H, 'r', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, '!'
	DB	00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@ENGGNKCD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAZ?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@ENGGNKCD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAZ?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'Z', 00H, 'r', 00H, 'e', 00H, 'p', 00H
	DB	'l', 00H, 'a', 00H, 'c', 00H, 'e', 00H, 'm', 00H, 'e', 00H, 'n'
	DB	00H, 't', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@DEPLKICC@?$AAZ?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@DEPLKICC@?$AAZ?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'Z'
	DB	00H, 'r', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, '!'
	DB	00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@LMLOOL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAz?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@LMLOOL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAz?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'z', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a', 00H
	DB	'c', 00H, 'e', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@BCJHHKPO@?$AAz?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@BCJHHKPO@?$AAz?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'z'
	DB	00H, 'r', 00H, 'e', 00H, 'p', 00H, 'l', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, ' ', 00H, '!'
	DB	00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@CDHMOIAH@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AAa?$AAr?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@CDHMOIAH@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AAa?$AAr?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'z', 00H, 'i', 00H, 'n', 00H, 'f', 00H, 'o', 00H, 'a', 00H
	DB	'r', 00H, 'g', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N'
	DB	00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KEHIIGHP@strftime?5format?5ends?5with?5raw?5?$CF?$AA@
CONST	SEGMENT
??_C@_0CA@KEHIIGHP@strftime?5format?5ends?5with?5raw?5?$CF?$AA@ DB 'strft'
	DB	'ime format ends with raw %', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@GIDHAEEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@GIDHAEEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm', 00H
	DB	'a', 00H, 't', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@PMCNGDBM@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAt?$AAu?$AAp?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@PMCNGDBM@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAt?$AAu?$AAp?$AAl?$AAe?$AA?$AA@ DB 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'm'
	DB	00H, 'a', 00H, 't', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	't', 00H, 'i', 00H, 'm', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'p'
	DB	00H, 'l', 00H, 'e', 00H, 00H, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT wrap_strftime
_TEXT	SEGMENT
zreplacement$ = 48
freplacement$ = 56
ntoappend$ = 64
usednew$ = 72
ptoappend$ = 80
pin$ = 88
totalnew$ = 96
newfmt$ = 104
result$ = 112
ch$ = 120
flen$ = 128
Zreplacement$ = 136
pnew$ = 144
tzinfo$21396 = 152
buf$21395 = 160
time$21468 = 272
format$21467 = 280
object$ = 304
format$ = 312
timetuple$ = 320
tzinfoarg$ = 328
wrap_strftime PROC					; COMDAT

; 1146 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H

; 1147 :     PyObject *result = NULL;            /* guilty until proved innocent */

  0001b	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 1148 : 
; 1149 :     PyObject *zreplacement = NULL;      /* py string, replacement for %z */

  00024	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR zreplacement$[rsp], 0

; 1150 :     PyObject *Zreplacement = NULL;      /* py string, replacement for %Z */

  0002d	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR Zreplacement$[rsp], 0

; 1151 :     PyObject *freplacement = NULL;      /* py string, replacement for %f */

  00039	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR freplacement$[rsp], 0

; 1152 : 
; 1153 :     const char *pin;            /* pointer to next char in input format */
; 1154 :     Py_ssize_t flen;            /* length of input format */
; 1155 :     char ch;                    /* next char in input format */
; 1156 : 
; 1157 :     PyObject *newfmt = NULL;            /* py string, the output format */

  00042	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR newfmt$[rsp], 0

; 1158 :     char *pnew;         /* pointer to available byte in output format */
; 1159 :     size_t totalnew;            /* number bytes total in output format buffer,
; 1160 :                                exclusive of trailing \0 */
; 1161 :     size_t usednew;     /* number bytes used so far in output format buffer */
; 1162 : 
; 1163 :     const char *ptoappend;      /* ptr to string to append to output buffer */
; 1164 :     Py_ssize_t ntoappend;       /* # of bytes to append to output buffer */
; 1165 : 
; 1166 :     assert(object && format && timetuple);

  0004b	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR object$[rsp], 0
  00054	74 16		 je	 SHORT $LN52@wrap_strft
  00056	48 83 bc 24 38
	01 00 00 00	 cmp	 QWORD PTR format$[rsp], 0
  0005f	74 0b		 je	 SHORT $LN52@wrap_strft
  00061	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR timetuple$[rsp], 0
  0006a	75 1c		 jne	 SHORT $LN53@wrap_strft
$LN52@wrap_strft:
  0006c	41 b8 8e 04 00
	00		 mov	 r8d, 1166		; 0000048eH
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@PMCNGDBM@?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAi?$AAm?$AAe?$AAt?$AAu?$AAp?$AAl?$AAe?$AA?$AA@
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00086	33 c0		 xor	 eax, eax
$LN53@wrap_strft:

; 1167 :     assert(PyUnicode_Check(format));

  00088	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR format$[rsp]
  00090	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00094	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0009f	85 c0		 test	 eax, eax
  000a1	75 1c		 jne	 SHORT $LN54@wrap_strft
  000a3	41 b8 8f 04 00
	00		 mov	 r8d, 1167		; 0000048fH
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@GIDHAEEI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAo?$AAr?$AAm?$AAa?$AAt?$AA?$CJ?$AA?$AA@
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000bd	33 c0		 xor	 eax, eax
$LN54@wrap_strft:

; 1168 :     /* Convert the input format to a C string and size */
; 1169 :     pin = _PyUnicode_AsStringAndSize(format, &flen);

  000bf	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR flen$[rsp]
  000c7	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR format$[rsp]
  000cf	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  000d4	48 89 44 24 58	 mov	 QWORD PTR pin$[rsp], rax

; 1170 :     if (!pin)

  000d9	48 83 7c 24 58
	00		 cmp	 QWORD PTR pin$[rsp], 0
  000df	75 07		 jne	 SHORT $LN49@wrap_strft

; 1171 :         return NULL;

  000e1	33 c0		 xor	 eax, eax
  000e3	e9 3f 07 00 00	 jmp	 $LN50@wrap_strft
$LN49@wrap_strft:

; 1172 : 
; 1173 :     /* Scan the input format, looking for %z/%Z/%f escapes, building
; 1174 :      * a new format.  Since computing the replacements for those codes
; 1175 :      * is expensive, don't unless they're actually used.
; 1176 :      */
; 1177 :     if (flen > INT_MAX - 1) {

  000e8	48 81 bc 24 80
	00 00 00 fe ff
	ff 7f		 cmp	 QWORD PTR flen$[rsp], 2147483646 ; 7ffffffeH
  000f4	7e 0a		 jle	 SHORT $LN48@wrap_strft

; 1178 :         PyErr_NoMemory();

  000f6	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1179 :         goto Done;

  000fb	e9 bc 06 00 00	 jmp	 $Done$21380
$LN48@wrap_strft:

; 1180 :     }
; 1181 : 
; 1182 :     totalnew = flen + 1;        /* realistic if no %z/%Z */

  00100	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR flen$[rsp]
  00108	48 ff c0	 inc	 rax
  0010b	48 89 44 24 60	 mov	 QWORD PTR totalnew$[rsp], rax

; 1183 :     newfmt = PyBytes_FromStringAndSize(NULL, totalnew);

  00110	48 8b 54 24 60	 mov	 rdx, QWORD PTR totalnew$[rsp]
  00115	33 c9		 xor	 ecx, ecx
  00117	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0011c	48 89 44 24 68	 mov	 QWORD PTR newfmt$[rsp], rax

; 1184 :     if (newfmt == NULL) goto Done;

  00121	48 83 7c 24 68
	00		 cmp	 QWORD PTR newfmt$[rsp], 0
  00127	75 05		 jne	 SHORT $LN47@wrap_strft
  00129	e9 8e 06 00 00	 jmp	 $Done$21380
$LN47@wrap_strft:

; 1185 :     pnew = PyBytes_AsString(newfmt);

  0012e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR newfmt$[rsp]
  00133	e8 00 00 00 00	 call	 PyBytes_AsString
  00138	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pnew$[rsp], rax

; 1186 :     usednew = 0;

  00140	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR usednew$[rsp], 0
$LN69@wrap_strft:
$LN46@wrap_strft:

; 1187 : 
; 1188 :     while ((ch = *pin++) != '\0') {

  00149	48 8b 44 24 58	 mov	 rax, QWORD PTR pin$[rsp]
  0014e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00151	88 44 24 78	 mov	 BYTE PTR ch$[rsp], al
  00155	0f be 44 24 78	 movsx	 eax, BYTE PTR ch$[rsp]
  0015a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pin$[rsp]
  0015f	48 ff c1	 inc	 rcx
  00162	48 89 4c 24 58	 mov	 QWORD PTR pin$[rsp], rcx
  00167	85 c0		 test	 eax, eax
  00169	0f 84 4b 05 00
	00		 je	 $LN45@wrap_strft

; 1189 :         if (ch != '%') {

  0016f	0f be 44 24 78	 movsx	 eax, BYTE PTR ch$[rsp]
  00174	83 f8 25	 cmp	 eax, 37			; 00000025H
  00177	74 1b		 je	 SHORT $LN44@wrap_strft

; 1190 :             ptoappend = pin - 1;

  00179	48 8b 44 24 58	 mov	 rax, QWORD PTR pin$[rsp]
  0017e	48 ff c8	 dec	 rax
  00181	48 89 44 24 50	 mov	 QWORD PTR ptoappend$[rsp], rax

; 1191 :             ntoappend = 1;

  00186	48 c7 44 24 40
	01 00 00 00	 mov	 QWORD PTR ntoappend$[rsp], 1
  0018f	e9 ed 03 00 00	 jmp	 $LN43@wrap_strft
$LN44@wrap_strft:

; 1192 :         }
; 1193 :         else if ((ch = *pin++) == '\0') {

  00194	48 8b 44 24 58	 mov	 rax, QWORD PTR pin$[rsp]
  00199	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019c	88 44 24 78	 mov	 BYTE PTR ch$[rsp], al
  001a0	0f be 44 24 78	 movsx	 eax, BYTE PTR ch$[rsp]
  001a5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pin$[rsp]
  001aa	48 ff c1	 inc	 rcx
  001ad	48 89 4c 24 58	 mov	 QWORD PTR pin$[rsp], rcx
  001b2	85 c0		 test	 eax, eax
  001b4	75 1d		 jne	 SHORT $LN42@wrap_strft

; 1194 :             /* There's a lone trailing %; doesn't make sense. */
; 1195 :             PyErr_SetString(PyExc_ValueError, "strftime format "
; 1196 :                             "ends with raw %");

  001b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KEHIIGHP@strftime?5format?5ends?5with?5raw?5?$CF?$AA@
  001bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001c4	e8 00 00 00 00	 call	 PyErr_SetString

; 1197 :             goto Done;

  001c9	e9 ee 05 00 00	 jmp	 $Done$21380
  001ce	e9 ae 03 00 00	 jmp	 $LN41@wrap_strft
$LN42@wrap_strft:

; 1198 :         }
; 1199 :         /* A % has been seen and ch is the character after it. */
; 1200 :         else if (ch == 'z') {

  001d3	0f be 44 24 78	 movsx	 eax, BYTE PTR ch$[rsp]
  001d8	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  001db	0f 85 a9 01 00
	00		 jne	 $LN40@wrap_strft

; 1201 :             if (zreplacement == NULL) {

  001e1	48 83 7c 24 30
	00		 cmp	 QWORD PTR zreplacement$[rsp], 0
  001e7	0f 85 f0 00 00
	00		 jne	 $LN39@wrap_strft

; 1202 :                 /* format utcoffset */
; 1203 :                 char buf[100];
; 1204 :                 PyObject *tzinfo = get_tzinfo_member(object);

  001ed	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR object$[rsp]
  001f5	e8 00 00 00 00	 call	 get_tzinfo_member
  001fa	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tzinfo$21396[rsp], rax

; 1205 :                 zreplacement = PyBytes_FromStringAndSize("", 0);

  00202	33 d2		 xor	 edx, edx
  00204	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0020b	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00210	48 89 44 24 30	 mov	 QWORD PTR zreplacement$[rsp], rax

; 1206 :                 if (zreplacement == NULL) goto Done;

  00215	48 83 7c 24 30
	00		 cmp	 QWORD PTR zreplacement$[rsp], 0
  0021b	75 05		 jne	 SHORT $LN38@wrap_strft
  0021d	e9 9a 05 00 00	 jmp	 $Done$21380
$LN38@wrap_strft:

; 1207 :                 if (tzinfo != Py_None && tzinfo != NULL) {

  00222	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00229	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR tzinfo$21396[rsp], rax
  00231	0f 84 a6 00 00
	00		 je	 $LN37@wrap_strft
  00237	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR tzinfo$21396[rsp], 0
  00240	0f 84 97 00 00
	00		 je	 $LN37@wrap_strft

; 1208 :                     assert(tzinfoarg != NULL);

  00246	48 83 bc 24 48
	01 00 00 00	 cmp	 QWORD PTR tzinfoarg$[rsp], 0
  0024f	75 1c		 jne	 SHORT $LN55@wrap_strft
  00251	41 b8 b8 04 00
	00		 mov	 r8d, 1208		; 000004b8H
  00257	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0025e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@CDHMOIAH@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AAa?$AAr?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00265	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0026b	33 c0		 xor	 eax, eax
$LN55@wrap_strft:

; 1209 :                     if (format_utcoffset(buf,
; 1210 :                                          sizeof(buf),
; 1211 :                                          "",
; 1212 :                                          tzinfo,
; 1213 :                                          tzinfoarg) < 0)

  0026d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR tzinfoarg$[rsp]
  00275	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027a	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR tzinfo$21396[rsp]
  00282	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00289	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0028e	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$21395[rsp]
  00296	e8 00 00 00 00	 call	 format_utcoffset
  0029b	85 c0		 test	 eax, eax
  0029d	7d 05		 jge	 SHORT $LN36@wrap_strft

; 1214 :                         goto Done;

  0029f	e9 18 05 00 00	 jmp	 $Done$21380
$LN36@wrap_strft:

; 1215 :                     Py_DECREF(zreplacement);

  002a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR zreplacement$[rsp]
  002a9	e8 00 00 00 00	 call	 _Py_DecRef

; 1216 :                     zreplacement =
; 1217 :                       PyBytes_FromStringAndSize(buf,
; 1218 :                                                strlen(buf));

  002ae	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$21395[rsp]
  002b6	e8 00 00 00 00	 call	 strlen
  002bb	48 8b d0	 mov	 rdx, rax
  002be	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$21395[rsp]
  002c6	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  002cb	48 89 44 24 30	 mov	 QWORD PTR zreplacement$[rsp], rax

; 1219 :                     if (zreplacement == NULL)

  002d0	48 83 7c 24 30
	00		 cmp	 QWORD PTR zreplacement$[rsp], 0
  002d6	75 05		 jne	 SHORT $LN35@wrap_strft

; 1220 :                         goto Done;

  002d8	e9 df 04 00 00	 jmp	 $Done$21380
$LN35@wrap_strft:
$LN37@wrap_strft:
$LN39@wrap_strft:

; 1221 :                 }
; 1222 :             }
; 1223 :             assert(zreplacement != NULL);

  002dd	48 83 7c 24 30
	00		 cmp	 QWORD PTR zreplacement$[rsp], 0
  002e3	75 1c		 jne	 SHORT $LN56@wrap_strft
  002e5	41 b8 c7 04 00
	00		 mov	 r8d, 1223		; 000004c7H
  002eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@BCJHHKPO@?$AAz?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  002f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ff	33 c0		 xor	 eax, eax
$LN56@wrap_strft:

; 1224 :             ptoappend = PyBytes_AS_STRING(zreplacement);

  00301	48 8b 44 24 30	 mov	 rax, QWORD PTR zreplacement$[rsp]
  00306	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0030a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00310	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00315	85 c0		 test	 eax, eax
  00317	75 1c		 jne	 SHORT $LN57@wrap_strft
  00319	41 b8 c8 04 00
	00		 mov	 r8d, 1224		; 000004c8H
  0031f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@LMLOOL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAz?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00333	33 c0		 xor	 eax, eax
$LN57@wrap_strft:
  00335	48 8b 44 24 30	 mov	 rax, QWORD PTR zreplacement$[rsp]
  0033a	48 83 c0 78	 add	 rax, 120		; 00000078H
  0033e	48 89 44 24 50	 mov	 QWORD PTR ptoappend$[rsp], rax

; 1225 :             ntoappend = PyBytes_GET_SIZE(zreplacement);

  00343	48 8b 44 24 30	 mov	 rax, QWORD PTR zreplacement$[rsp]
  00348	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0034c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00352	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00357	85 c0		 test	 eax, eax
  00359	75 1c		 jne	 SHORT $LN58@wrap_strft
  0035b	41 b8 c9 04 00
	00		 mov	 r8d, 1225		; 000004c9H
  00361	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00368	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@LMLOOL@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAz?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  0036f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00375	33 c0		 xor	 eax, eax
$LN58@wrap_strft:
  00377	48 8b 44 24 30	 mov	 rax, QWORD PTR zreplacement$[rsp]
  0037c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00380	48 89 44 24 40	 mov	 QWORD PTR ntoappend$[rsp], rax
  00385	e9 f7 01 00 00	 jmp	 $LN34@wrap_strft
$LN40@wrap_strft:

; 1226 :         }
; 1227 :         else if (ch == 'Z') {

  0038a	0f be 44 24 78	 movsx	 eax, BYTE PTR ch$[rsp]
  0038f	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  00392	0f 85 bf 00 00
	00		 jne	 $LN33@wrap_strft

; 1228 :             /* format tzname */
; 1229 :             if (Zreplacement == NULL) {

  00398	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR Zreplacement$[rsp], 0
  003a1	75 2d		 jne	 SHORT $LN32@wrap_strft

; 1230 :                 Zreplacement = make_Zreplacement(object,
; 1231 :                                                  tzinfoarg);

  003a3	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR tzinfoarg$[rsp]
  003ab	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR object$[rsp]
  003b3	e8 00 00 00 00	 call	 make_Zreplacement
  003b8	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR Zreplacement$[rsp], rax

; 1232 :                 if (Zreplacement == NULL)

  003c0	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR Zreplacement$[rsp], 0
  003c9	75 05		 jne	 SHORT $LN31@wrap_strft

; 1233 :                     goto Done;

  003cb	e9 ec 03 00 00	 jmp	 $Done$21380
$LN31@wrap_strft:
$LN32@wrap_strft:

; 1234 :             }
; 1235 :             assert(Zreplacement != NULL);

  003d0	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR Zreplacement$[rsp], 0
  003d9	75 1c		 jne	 SHORT $LN59@wrap_strft
  003db	41 b8 d3 04 00
	00		 mov	 r8d, 1235		; 000004d3H
  003e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  003e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@DEPLKICC@?$AAZ?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  003ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003f5	33 c0		 xor	 eax, eax
$LN59@wrap_strft:

; 1236 :             assert(PyUnicode_Check(Zreplacement));

  003f7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR Zreplacement$[rsp]
  003ff	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00403	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00409	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0040e	85 c0		 test	 eax, eax
  00410	75 1c		 jne	 SHORT $LN60@wrap_strft
  00412	41 b8 d4 04 00
	00		 mov	 r8d, 1236		; 000004d4H
  00418	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0041f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@ENGGNKCD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAZ?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  00426	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0042c	33 c0		 xor	 eax, eax
$LN60@wrap_strft:

; 1237 :             ptoappend = _PyUnicode_AsStringAndSize(Zreplacement,
; 1238 :                                                   &ntoappend);

  0042e	48 8d 54 24 40	 lea	 rdx, QWORD PTR ntoappend$[rsp]
  00433	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Zreplacement$[rsp]
  0043b	e8 00 00 00 00	 call	 PyUnicode_AsUTF8AndSize
  00440	48 89 44 24 50	 mov	 QWORD PTR ptoappend$[rsp], rax

; 1239 :             if (ptoappend == NULL)

  00445	48 83 7c 24 50
	00		 cmp	 QWORD PTR ptoappend$[rsp], 0
  0044b	75 05		 jne	 SHORT $LN30@wrap_strft

; 1240 :                 goto Done;

  0044d	e9 6a 03 00 00	 jmp	 $Done$21380
$LN30@wrap_strft:

; 1241 :         }
; 1242 :         else if (ch == 'f') {

  00452	e9 2a 01 00 00	 jmp	 $LN29@wrap_strft
$LN33@wrap_strft:
  00457	0f be 44 24 78	 movsx	 eax, BYTE PTR ch$[rsp]
  0045c	83 f8 66	 cmp	 eax, 102		; 00000066H
  0045f	0f 85 05 01 00
	00		 jne	 $LN28@wrap_strft

; 1243 :             /* format microseconds */
; 1244 :             if (freplacement == NULL) {

  00465	48 83 7c 24 38
	00		 cmp	 QWORD PTR freplacement$[rsp], 0
  0046b	75 1f		 jne	 SHORT $LN27@wrap_strft

; 1245 :                 freplacement = make_freplacement(object);

  0046d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR object$[rsp]
  00475	e8 00 00 00 00	 call	 make_freplacement
  0047a	48 89 44 24 38	 mov	 QWORD PTR freplacement$[rsp], rax

; 1246 :                 if (freplacement == NULL)

  0047f	48 83 7c 24 38
	00		 cmp	 QWORD PTR freplacement$[rsp], 0
  00485	75 05		 jne	 SHORT $LN26@wrap_strft

; 1247 :                     goto Done;

  00487	e9 30 03 00 00	 jmp	 $Done$21380
$LN26@wrap_strft:
$LN27@wrap_strft:

; 1248 :             }
; 1249 :             assert(freplacement != NULL);

  0048c	48 83 7c 24 38
	00		 cmp	 QWORD PTR freplacement$[rsp], 0
  00492	75 1c		 jne	 SHORT $LN61@wrap_strft
  00494	41 b8 e1 04 00
	00		 mov	 r8d, 1249		; 000004e1H
  0049a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  004a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@OBEPDOFM@?$AAf?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  004a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004ae	33 c0		 xor	 eax, eax
$LN61@wrap_strft:

; 1250 :             assert(PyBytes_Check(freplacement));

  004b0	48 8b 44 24 38	 mov	 rax, QWORD PTR freplacement$[rsp]
  004b5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  004b9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  004bf	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  004c4	85 c0		 test	 eax, eax
  004c6	75 1c		 jne	 SHORT $LN62@wrap_strft
  004c8	41 b8 e2 04 00
	00		 mov	 r8d, 1250		; 000004e2H
  004ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  004d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@BAJLHDKH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  004dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004e2	33 c0		 xor	 eax, eax
$LN62@wrap_strft:

; 1251 :             ptoappend = PyBytes_AS_STRING(freplacement);

  004e4	48 8b 44 24 38	 mov	 rax, QWORD PTR freplacement$[rsp]
  004e9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  004ed	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  004f3	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  004f8	85 c0		 test	 eax, eax
  004fa	75 1c		 jne	 SHORT $LN63@wrap_strft
  004fc	41 b8 e3 04 00
	00		 mov	 r8d, 1251		; 000004e3H
  00502	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00509	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@BAJLHDKH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  00510	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00516	33 c0		 xor	 eax, eax
$LN63@wrap_strft:
  00518	48 8b 44 24 38	 mov	 rax, QWORD PTR freplacement$[rsp]
  0051d	48 83 c0 78	 add	 rax, 120		; 00000078H
  00521	48 89 44 24 50	 mov	 QWORD PTR ptoappend$[rsp], rax

; 1252 :             ntoappend = PyBytes_GET_SIZE(freplacement);

  00526	48 8b 44 24 38	 mov	 rax, QWORD PTR freplacement$[rsp]
  0052b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0052f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00535	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0053a	85 c0		 test	 eax, eax
  0053c	75 1c		 jne	 SHORT $LN64@wrap_strft
  0053e	41 b8 e4 04 00
	00		 mov	 r8d, 1252		; 000004e4H
  00544	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0054b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@BAJLHDKH@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAf?$AAr?$AAe?$AAp?$AAl?$AAa?$AAc?$AAe?$AAm?$AAe?$AAn?$AAt?$AA?$CJ?$AA?$AA@
  00552	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00558	33 c0		 xor	 eax, eax
$LN64@wrap_strft:
  0055a	48 8b 44 24 38	 mov	 rax, QWORD PTR freplacement$[rsp]
  0055f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00563	48 89 44 24 40	 mov	 QWORD PTR ntoappend$[rsp], rax

; 1253 :         }
; 1254 :         else {

  00568	eb 17		 jmp	 SHORT $LN25@wrap_strft
$LN28@wrap_strft:

; 1255 :             /* percent followed by neither z nor Z */
; 1256 :             ptoappend = pin - 2;

  0056a	48 8b 44 24 58	 mov	 rax, QWORD PTR pin$[rsp]
  0056f	48 83 e8 02	 sub	 rax, 2
  00573	48 89 44 24 50	 mov	 QWORD PTR ptoappend$[rsp], rax

; 1257 :             ntoappend = 2;

  00578	48 c7 44 24 40
	02 00 00 00	 mov	 QWORD PTR ntoappend$[rsp], 2
$LN25@wrap_strft:
$LN29@wrap_strft:
$LN34@wrap_strft:
$LN41@wrap_strft:
$LN43@wrap_strft:

; 1258 :         }
; 1259 : 
; 1260 :         /* Append the ntoappend chars starting at ptoappend to
; 1261 :          * the new format.
; 1262 :          */
; 1263 :         if (ntoappend == 0)

  00581	48 83 7c 24 40
	00		 cmp	 QWORD PTR ntoappend$[rsp], 0
  00587	75 05		 jne	 SHORT $LN24@wrap_strft

; 1264 :             continue;

  00589	e9 bb fb ff ff	 jmp	 $LN46@wrap_strft
$LN24@wrap_strft:

; 1265 :         assert(ptoappend != NULL);

  0058e	48 83 7c 24 50
	00		 cmp	 QWORD PTR ptoappend$[rsp], 0
  00594	75 1c		 jne	 SHORT $LN65@wrap_strft
  00596	41 b8 f1 04 00
	00		 mov	 r8d, 1265		; 000004f1H
  0059c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  005a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@EILIIHHL@?$AAp?$AAt?$AAo?$AAa?$AAp?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  005aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005b0	33 c0		 xor	 eax, eax
$LN65@wrap_strft:

; 1266 :         assert(ntoappend > 0);

  005b2	48 83 7c 24 40
	00		 cmp	 QWORD PTR ntoappend$[rsp], 0
  005b8	7f 1c		 jg	 SHORT $LN66@wrap_strft
  005ba	41 b8 f2 04 00
	00		 mov	 r8d, 1266		; 000004f2H
  005c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  005c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@IIEOOHJB@?$AAn?$AAt?$AAo?$AAa?$AAp?$AAp?$AAe?$AAn?$AAd?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  005ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005d4	33 c0		 xor	 eax, eax
$LN66@wrap_strft:
$LN23@wrap_strft:

; 1267 :         while (usednew + ntoappend > totalnew) {

  005d6	48 8b 44 24 40	 mov	 rax, QWORD PTR ntoappend$[rsp]
  005db	48 8b 4c 24 48	 mov	 rcx, QWORD PTR usednew$[rsp]
  005e0	48 03 c8	 add	 rcx, rax
  005e3	48 8b c1	 mov	 rax, rcx
  005e6	48 3b 44 24 60	 cmp	 rax, QWORD PTR totalnew$[rsp]
  005eb	76 59		 jbe	 SHORT $LN22@wrap_strft

; 1268 :             if (totalnew > (PY_SSIZE_T_MAX >> 1)) { /* overflow */

  005ed	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  005f7	48 39 44 24 60	 cmp	 QWORD PTR totalnew$[rsp], rax
  005fc	76 0a		 jbe	 SHORT $LN21@wrap_strft

; 1269 :                 PyErr_NoMemory();

  005fe	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1270 :                 goto Done;

  00603	e9 b4 01 00 00	 jmp	 $Done$21380
$LN21@wrap_strft:

; 1271 :             }
; 1272 :             totalnew <<= 1;

  00608	48 8b 44 24 60	 mov	 rax, QWORD PTR totalnew$[rsp]
  0060d	48 d1 e0	 shl	 rax, 1
  00610	48 89 44 24 60	 mov	 QWORD PTR totalnew$[rsp], rax

; 1273 :             if (_PyBytes_Resize(&newfmt, totalnew) < 0)

  00615	48 8b 54 24 60	 mov	 rdx, QWORD PTR totalnew$[rsp]
  0061a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR newfmt$[rsp]
  0061f	e8 00 00 00 00	 call	 _PyBytes_Resize
  00624	85 c0		 test	 eax, eax
  00626	7d 05		 jge	 SHORT $LN20@wrap_strft

; 1274 :                 goto Done;

  00628	e9 8f 01 00 00	 jmp	 $Done$21380
$LN20@wrap_strft:

; 1275 :             pnew = PyBytes_AsString(newfmt) + usednew;

  0062d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR newfmt$[rsp]
  00632	e8 00 00 00 00	 call	 PyBytes_AsString
  00637	48 03 44 24 48	 add	 rax, QWORD PTR usednew$[rsp]
  0063c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pnew$[rsp], rax

; 1276 :         }

  00644	eb 90		 jmp	 SHORT $LN23@wrap_strft
$LN22@wrap_strft:

; 1277 :         memcpy(pnew, ptoappend, ntoappend);

  00646	4c 8b 44 24 40	 mov	 r8, QWORD PTR ntoappend$[rsp]
  0064b	48 8b 54 24 50	 mov	 rdx, QWORD PTR ptoappend$[rsp]
  00650	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pnew$[rsp]
  00658	e8 00 00 00 00	 call	 memcpy

; 1278 :         pnew += ntoappend;

  0065d	48 8b 44 24 40	 mov	 rax, QWORD PTR ntoappend$[rsp]
  00662	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pnew$[rsp]
  0066a	48 03 c8	 add	 rcx, rax
  0066d	48 8b c1	 mov	 rax, rcx
  00670	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pnew$[rsp], rax

; 1279 :         usednew += ntoappend;

  00678	48 8b 44 24 40	 mov	 rax, QWORD PTR ntoappend$[rsp]
  0067d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR usednew$[rsp]
  00682	48 03 c8	 add	 rcx, rax
  00685	48 8b c1	 mov	 rax, rcx
  00688	48 89 44 24 48	 mov	 QWORD PTR usednew$[rsp], rax

; 1280 :         assert(usednew <= totalnew);

  0068d	48 8b 44 24 60	 mov	 rax, QWORD PTR totalnew$[rsp]
  00692	48 39 44 24 48	 cmp	 QWORD PTR usednew$[rsp], rax
  00697	76 1c		 jbe	 SHORT $LN67@wrap_strft
  00699	41 b8 00 05 00
	00		 mov	 r8d, 1280		; 00000500H
  0069f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  006a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@INIGFBCG@?$AAu?$AAs?$AAe?$AAd?$AAn?$AAe?$AAw?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAt?$AAo?$AAt?$AAa?$AAl?$AAn?$AAe?$AAw?$AA?$AA@
  006ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006b3	33 c0		 xor	 eax, eax
$LN67@wrap_strft:

; 1281 :     }  /* end while() */

  006b5	e9 8f fa ff ff	 jmp	 $LN69@wrap_strft
$LN45@wrap_strft:

; 1282 : 
; 1283 :     if (_PyBytes_Resize(&newfmt, usednew) < 0)

  006ba	48 8b 54 24 48	 mov	 rdx, QWORD PTR usednew$[rsp]
  006bf	48 8d 4c 24 68	 lea	 rcx, QWORD PTR newfmt$[rsp]
  006c4	e8 00 00 00 00	 call	 _PyBytes_Resize
  006c9	85 c0		 test	 eax, eax
  006cb	7d 05		 jge	 SHORT $LN19@wrap_strft

; 1284 :         goto Done;

  006cd	e9 ea 00 00 00	 jmp	 $Done$21380
$LN19@wrap_strft:

; 1285 :     {
; 1286 :         PyObject *format;
; 1287 :         PyObject *time = PyImport_ImportModuleNoBlock("time");

  006d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04CLCEDBPF@time?$AA@
  006d9	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  006de	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR time$21468[rsp], rax

; 1288 : 
; 1289 :         if (time == NULL)

  006e6	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR time$21468[rsp], 0
  006ef	75 05		 jne	 SHORT $LN18@wrap_strft

; 1290 :             goto Done;

  006f1	e9 c6 00 00 00	 jmp	 $Done$21380
$LN18@wrap_strft:

; 1291 :         format = PyUnicode_FromString(PyBytes_AS_STRING(newfmt));

  006f6	48 8b 44 24 68	 mov	 rax, QWORD PTR newfmt$[rsp]
  006fb	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  006ff	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00705	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0070a	85 c0		 test	 eax, eax
  0070c	75 1c		 jne	 SHORT $LN68@wrap_strft
  0070e	41 b8 0b 05 00
	00		 mov	 r8d, 1291		; 0000050bH
  00714	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0071b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@JMJOIOGF@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAf?$AAm?$AAt?$AA?$CJ?$AA?$AA@
  00722	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00728	33 c0		 xor	 eax, eax
$LN68@wrap_strft:
  0072a	48 8b 44 24 68	 mov	 rax, QWORD PTR newfmt$[rsp]
  0072f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00733	48 8b c8	 mov	 rcx, rax
  00736	e8 00 00 00 00	 call	 PyUnicode_FromString
  0073b	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR format$21467[rsp], rax

; 1292 :         if (format != NULL) {

  00743	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR format$21467[rsp], 0
  0074c	74 61		 je	 SHORT $LN17@wrap_strft

; 1293 :             _Py_IDENTIFIER(strftime);
; 1294 : 
; 1295 :             result = _PyObject_CallMethodId(time, &PyId_strftime, "OO",
; 1296 :                                             format, timetuple, NULL);

  0074e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_strftime@?BC@??wrap_strftime@@9@9
  00753	8b c0		 mov	 eax, eax
  00755	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0075b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00764	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00768	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00771	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR timetuple$[rsp]
  00779	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0077e	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR format$21467[rsp]
  00786	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02MJJLPNK@OO?$AA@
  0078d	48 8b d0	 mov	 rdx, rax
  00790	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR time$21468[rsp]
  00798	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  0079d	48 89 44 24 70	 mov	 QWORD PTR result$[rsp], rax

; 1297 :             Py_DECREF(format);

  007a2	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR format$21467[rsp]
  007aa	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@wrap_strft:

; 1298 :         }
; 1299 :         Py_DECREF(time);

  007af	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR time$21468[rsp]
  007b7	e8 00 00 00 00	 call	 _Py_DecRef
$Done$21380:
$LN16@wrap_strft:

; 1300 :     }
; 1301 :  Done:
; 1302 :     Py_XDECREF(freplacement);

  007bc	48 83 7c 24 38
	00		 cmp	 QWORD PTR freplacement$[rsp], 0
  007c2	74 0a		 je	 SHORT $LN13@wrap_strft
  007c4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR freplacement$[rsp]
  007c9	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@wrap_strft:
  007ce	33 c0		 xor	 eax, eax
  007d0	85 c0		 test	 eax, eax
  007d2	75 e8		 jne	 SHORT $LN16@wrap_strft
$LN12@wrap_strft:

; 1303 :     Py_XDECREF(zreplacement);

  007d4	48 83 7c 24 30
	00		 cmp	 QWORD PTR zreplacement$[rsp], 0
  007da	74 0a		 je	 SHORT $LN9@wrap_strft
  007dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR zreplacement$[rsp]
  007e1	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@wrap_strft:
  007e6	33 c0		 xor	 eax, eax
  007e8	85 c0		 test	 eax, eax
  007ea	75 e8		 jne	 SHORT $LN12@wrap_strft
$LN8@wrap_strft:

; 1304 :     Py_XDECREF(Zreplacement);

  007ec	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR Zreplacement$[rsp], 0
  007f5	74 0d		 je	 SHORT $LN5@wrap_strft
  007f7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR Zreplacement$[rsp]
  007ff	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@wrap_strft:
  00804	33 c0		 xor	 eax, eax
  00806	85 c0		 test	 eax, eax
  00808	75 e2		 jne	 SHORT $LN8@wrap_strft
$LN4@wrap_strft:

; 1305 :     Py_XDECREF(newfmt);

  0080a	48 83 7c 24 68
	00		 cmp	 QWORD PTR newfmt$[rsp], 0
  00810	74 0a		 je	 SHORT $LN1@wrap_strft
  00812	48 8b 4c 24 68	 mov	 rcx, QWORD PTR newfmt$[rsp]
  00817	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@wrap_strft:
  0081c	33 c0		 xor	 eax, eax
  0081e	85 c0		 test	 eax, eax
  00820	75 e8		 jne	 SHORT $LN4@wrap_strft

; 1306 :     return result;

  00822	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
$LN50@wrap_strft:

; 1307 : }

  00827	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0082e	c3		 ret	 0
wrap_strftime ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_tzinfo_member DD imagerel get_tzinfo_member
	DD	imagerel get_tzinfo_member+170
	DD	imagerel $unwind$get_tzinfo_member
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_tzinfo_member DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_tzinfo_member
_TEXT	SEGMENT
tzinfo$ = 32
self$ = 64
get_tzinfo_member PROC					; COMDAT

; 853  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 854  :     PyObject *tzinfo = NULL;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tzinfo$[rsp], 0

; 855  : 
; 856  :     if (PyDateTime_Check(self) && HASTZINFO(self))

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00022	74 19		 je	 SHORT $LN4@get_tzinfo
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00030	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00034	e8 00 00 00 00	 call	 PyType_IsSubtype
  00039	85 c0		 test	 eax, eax
  0003b	74 1d		 je	 SHORT $LN5@get_tzinfo
$LN4@get_tzinfo:
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00042	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00046	85 c0		 test	 eax, eax
  00048	74 10		 je	 SHORT $LN5@get_tzinfo

; 857  :         tzinfo = ((PyDateTime_DateTime *)self)->tzinfo;

  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004f	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00053	48 89 44 24 20	 mov	 QWORD PTR tzinfo$[rsp], rax
  00058	eb 46		 jmp	 SHORT $LN3@get_tzinfo
$LN5@get_tzinfo:

; 858  :     else if (PyTime_Check(self) && HASTZINFO(self))

  0005a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TimeType
  00061	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00066	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0006a	74 19		 je	 SHORT $LN1@get_tzinfo
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_TimeType
  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00078	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0007c	e8 00 00 00 00	 call	 PyType_IsSubtype
  00081	85 c0		 test	 eax, eax
  00083	74 1b		 je	 SHORT $LN2@get_tzinfo
$LN1@get_tzinfo:
  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0008a	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  0008e	85 c0		 test	 eax, eax
  00090	74 0e		 je	 SHORT $LN2@get_tzinfo

; 859  :         tzinfo = ((PyDateTime_Time *)self)->tzinfo;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00097	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0009b	48 89 44 24 20	 mov	 QWORD PTR tzinfo$[rsp], rax
$LN2@get_tzinfo:
$LN3@get_tzinfo:

; 860  : 
; 861  :     return tzinfo;

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR tzinfo$[rsp]

; 862  : }

  000a5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a9	c3		 ret	 0
get_tzinfo_member ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FAPLGAH@?$CFc?$CF02d?$CFs?$CF02d?$AA@	; `string'
PUBLIC	??_C@_1BK@LCOJKHBM@?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@JGBDBCBN@?$AAb?$AAu?$AAf?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
EXTRN	PyOS_snprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_utcoffset DD imagerel format_utcoffset
	DD	imagerel format_utcoffset+400
	DD	imagerel $unwind$format_utcoffset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_utcoffset DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT ??_C@_0N@FAPLGAH@?$CFc?$CF02d?$CFs?$CF02d?$AA@
CONST	SEGMENT
??_C@_0N@FAPLGAH@?$CFc?$CF02d?$CFs?$CF02d?$AA@ DB '%c%02d%s%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@LCOJKHBM@?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@LCOJKHBM@?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'c', 00H, 'o', 00H, 'n', 00H, 'd', 00H, 's', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@JGBDBCBN@?$AAb?$AAu?$AAf?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@JGBDBCBN@?$AAb?$AAu?$AAf?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'b'
	DB	00H, 'u', 00H, 'f', 00H, 'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT format_utcoffset
_TEXT	SEGMENT
minutes$ = 64
offset$ = 72
sign$ = 80
seconds$ = 84
hours$ = 88
temp$21269 = 96
buf$ = 128
buflen$ = 136
sep$ = 144
tzinfo$ = 152
tzinfoarg$ = 160
format_utcoffset PROC					; COMDAT

; 1039 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1040 :     PyObject *offset;
; 1041 :     int hours, minutes, seconds;
; 1042 :     char sign;
; 1043 : 
; 1044 :     assert(buflen >= 1);

  00018	48 83 bc 24 88
	00 00 00 01	 cmp	 QWORD PTR buflen$[rsp], 1
  00021	73 1c		 jae	 SHORT $LN8@format_utc
  00023	41 b8 14 04 00
	00		 mov	 r8d, 1044		; 00000414H
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@JGBDBCBN@?$AAb?$AAu?$AAf?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003d	33 c0		 xor	 eax, eax
$LN8@format_utc:

; 1045 : 
; 1046 :     offset = call_utcoffset(tzinfo, tzinfoarg);

  0003f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR tzinfoarg$[rsp]
  00047	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  0004f	e8 00 00 00 00	 call	 call_utcoffset
  00054	48 89 44 24 48	 mov	 QWORD PTR offset$[rsp], rax

; 1047 :     if (offset == NULL)

  00059	48 83 7c 24 48
	00		 cmp	 QWORD PTR offset$[rsp], 0
  0005f	75 0a		 jne	 SHORT $LN5@format_utc

; 1048 :         return -1;

  00061	b8 ff ff ff ff	 mov	 eax, -1
  00066	e9 20 01 00 00	 jmp	 $LN6@format_utc
$LN5@format_utc:

; 1049 :     if (offset == Py_None) {

  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00072	48 39 44 24 48	 cmp	 QWORD PTR offset$[rsp], rax
  00077	75 1c		 jne	 SHORT $LN4@format_utc

; 1050 :         Py_DECREF(offset);

  00079	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offset$[rsp]
  0007e	e8 00 00 00 00	 call	 _Py_DecRef

; 1051 :         *buf = '\0';

  00083	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0008b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1052 :         return 0;

  0008e	33 c0		 xor	 eax, eax
  00090	e9 f6 00 00 00	 jmp	 $LN6@format_utc
$LN4@format_utc:

; 1053 :     }
; 1054 :     /* Offset is normalized, so it is negative if days < 0 */
; 1055 :     if (GET_TD_DAYS(offset) < 0) {

  00095	48 8b 44 24 48	 mov	 rax, QWORD PTR offset$[rsp]
  0009a	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  0009e	7d 3c		 jge	 SHORT $LN3@format_utc

; 1056 :         PyObject *temp = offset;

  000a0	48 8b 44 24 48	 mov	 rax, QWORD PTR offset$[rsp]
  000a5	48 89 44 24 60	 mov	 QWORD PTR temp$21269[rsp], rax

; 1057 :         sign = '-';

  000aa	c6 44 24 50 2d	 mov	 BYTE PTR sign$[rsp], 45	; 0000002dH

; 1058 :         offset = delta_negative((PyDateTime_Delta *)offset);

  000af	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offset$[rsp]
  000b4	e8 00 00 00 00	 call	 delta_negative
  000b9	48 89 44 24 48	 mov	 QWORD PTR offset$[rsp], rax

; 1059 :         Py_DECREF(temp);

  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR temp$21269[rsp]
  000c3	e8 00 00 00 00	 call	 _Py_DecRef

; 1060 :         if (offset == NULL)

  000c8	48 83 7c 24 48
	00		 cmp	 QWORD PTR offset$[rsp], 0
  000ce	75 0a		 jne	 SHORT $LN2@format_utc

; 1061 :             return -1;

  000d0	b8 ff ff ff ff	 mov	 eax, -1
  000d5	e9 b1 00 00 00	 jmp	 $LN6@format_utc
$LN2@format_utc:

; 1062 :     }
; 1063 :     else {

  000da	eb 05		 jmp	 SHORT $LN1@format_utc
$LN3@format_utc:

; 1064 :         sign = '+';

  000dc	c6 44 24 50 2b	 mov	 BYTE PTR sign$[rsp], 43	; 0000002bH
$LN1@format_utc:

; 1065 :     }
; 1066 :     /* Offset is not negative here. */
; 1067 :     seconds = GET_TD_SECONDS(offset);

  000e1	48 8b 44 24 48	 mov	 rax, QWORD PTR offset$[rsp]
  000e6	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000e9	89 44 24 54	 mov	 DWORD PTR seconds$[rsp], eax

; 1068 :     Py_DECREF(offset);

  000ed	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offset$[rsp]
  000f2	e8 00 00 00 00	 call	 _Py_DecRef

; 1069 :     minutes = divmod(seconds, 60, &seconds);

  000f7	4c 8d 44 24 54	 lea	 r8, QWORD PTR seconds$[rsp]
  000fc	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00101	8b 4c 24 54	 mov	 ecx, DWORD PTR seconds$[rsp]
  00105	e8 00 00 00 00	 call	 divmod
  0010a	89 44 24 40	 mov	 DWORD PTR minutes$[rsp], eax

; 1070 :     hours = divmod(minutes, 60, &minutes);

  0010e	4c 8d 44 24 40	 lea	 r8, QWORD PTR minutes$[rsp]
  00113	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00118	8b 4c 24 40	 mov	 ecx, DWORD PTR minutes$[rsp]
  0011c	e8 00 00 00 00	 call	 divmod
  00121	89 44 24 58	 mov	 DWORD PTR hours$[rsp], eax

; 1071 :     assert(seconds == 0);

  00125	83 7c 24 54 00	 cmp	 DWORD PTR seconds$[rsp], 0
  0012a	74 1c		 je	 SHORT $LN9@format_utc
  0012c	41 b8 2f 04 00
	00		 mov	 r8d, 1071		; 0000042fH
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@LCOJKHBM@?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00146	33 c0		 xor	 eax, eax
$LN9@format_utc:

; 1072 :     /* XXX ignore sub-minute data, curently not allowed. */
; 1073 :     PyOS_snprintf(buf, buflen, "%c%02d%s%02d", sign, hours, sep, minutes);

  00148	0f be 44 24 50	 movsx	 eax, BYTE PTR sign$[rsp]
  0014d	8b 4c 24 40	 mov	 ecx, DWORD PTR minutes$[rsp]
  00151	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00155	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sep$[rsp]
  0015d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00162	8b 4c 24 58	 mov	 ecx, DWORD PTR hours$[rsp]
  00166	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0016a	44 8b c8	 mov	 r9d, eax
  0016d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@FAPLGAH@?$CFc?$CF02d?$CFs?$CF02d?$AA@
  00174	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buflen$[rsp]
  0017c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00184	e8 00 00 00 00	 call	 PyOS_snprintf

; 1074 : 
; 1075 :     return 0;

  00189	33 c0		 xor	 eax, eax
$LN6@format_utc:

; 1076 : }

  0018b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0018f	c3		 ret	 0
format_utcoffset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_utcoffset DD imagerel call_utcoffset
	DD	imagerel call_utcoffset+41
	DD	imagerel $unwind$call_utcoffset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_utcoffset DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT call_utcoffset
_TEXT	SEGMENT
tzinfo$ = 48
tzinfoarg$ = 56
call_utcoffset PROC					; COMDAT

; 923  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 924  :     return call_tzinfo_method(tzinfo, "utcoffset", tzinfoarg);

  0000e	4c 8b 44 24 38	 mov	 r8, QWORD PTR tzinfoarg$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  0001f	e8 00 00 00 00	 call	 call_tzinfo_method

; 925  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
call_utcoffset ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DI@CJHONLAB@tzinfo?4?$CFs?$CI?$CJ?5must?5return?5None?5or?5@ ; `string'
PUBLIC	??_C@_0FK@GNEMBLOI@offset?5must?5be?5a?5timedelta?5stric@ ; `string'
PUBLIC	??_C@_0EC@KJOMKDID@offset?5must?5be?5a?5timedelta?5repre@ ; `string'
PUBLIC	??_C@_1FI@LGKFAGBK@?$AAP?$AAy?$AAT?$AAZ?$AAI?$AAn?$AAf?$AAo?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo@ ; `string'
PUBLIC	??_C@_1BO@DNINNPAP@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	PyObject_CallMethod:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_tzinfo_method DD imagerel call_tzinfo_method
	DD	imagerel call_tzinfo_method+534
	DD	imagerel $unwind$call_tzinfo_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_tzinfo_method DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0DI@CJHONLAB@tzinfo?4?$CFs?$CI?$CJ?5must?5return?5None?5or?5@
CONST	SEGMENT
??_C@_0DI@CJHONLAB@tzinfo?4?$CFs?$CI?$CJ?5must?5return?5None?5or?5@ DB 't'
	DB	'zinfo.%s() must return None or timedelta, not ''%.200s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@GNEMBLOI@offset?5must?5be?5a?5timedelta?5stric@
CONST	SEGMENT
??_C@_0FK@GNEMBLOI@offset?5must?5be?5a?5timedelta?5stric@ DB 'offset must'
	DB	' be a timedelta strictly between -timedelta(hours=24) and tim'
	DB	'edelta(hours=24).', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@KJOMKDID@offset?5must?5be?5a?5timedelta?5repre@
CONST	SEGMENT
??_C@_0EC@KJOMKDID@offset?5must?5be?5a?5timedelta?5repre@ DB 'offset must'
	DB	' be a timedelta representing a whole number of minutes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@LGKFAGBK@?$AAP?$AAy?$AAT?$AAZ?$AAI?$AAn?$AAf?$AAo?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo@
CONST	SEGMENT
??_C@_1FI@LGKFAGBK@?$AAP?$AAy?$AAT?$AAZ?$AAI?$AAn?$AAf?$AAo?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo@ DB 'P'
	DB	00H, 'y', 00H, 'T', 00H, 'Z', 00H, 'I', 00H, 'n', 00H, 'f', 00H
	DB	'o', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k'
	DB	00H, '(', 00H, 't', 00H, 'z', 00H, 'i', 00H, 'n', 00H, 'f', 00H
	DB	'o', 00H, ')', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 't'
	DB	00H, 'z', 00H, 'i', 00H, 'n', 00H, 'f', 00H, 'o', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'y', 00H, '_', 00H, 'N'
	DB	00H, 'o', 00H, 'n', 00H, 'e', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@DNINNPAP@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@DNINNPAP@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'z', 00H, 'i', 00H, 'n', 00H, 'f', 00H, 'o', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT call_tzinfo_method
_TEXT	SEGMENT
offset$ = 32
tzinfo$ = 64
name$ = 72
tzinfoarg$ = 80
call_tzinfo_method PROC					; COMDAT

; 873  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 874  :     PyObject *offset;
; 875  : 
; 876  :     assert(tzinfo != NULL);

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR tzinfo$[rsp], 0
  00019	75 1c		 jne	 SHORT $LN14@call_tzinf
  0001b	41 b8 6c 03 00
	00		 mov	 r8d, 876		; 0000036cH
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@DNINNPAP@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00035	33 c0		 xor	 eax, eax
$LN14@call_tzinf:

; 877  :     assert(PyTZInfo_Check(tzinfo) || tzinfo == Py_None);

  00037	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TZInfoType
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00043	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00047	74 43		 je	 SHORT $LN15@call_tzinf
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_TZInfoType
  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR tzinfo$[rsp]
  00055	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00059	e8 00 00 00 00	 call	 PyType_IsSubtype
  0005e	85 c0		 test	 eax, eax
  00060	75 2a		 jne	 SHORT $LN15@call_tzinf
  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00069	48 39 44 24 40	 cmp	 QWORD PTR tzinfo$[rsp], rax
  0006e	74 1c		 je	 SHORT $LN15@call_tzinf
  00070	41 b8 6d 03 00
	00		 mov	 r8d, 877		; 0000036dH
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FI@LGKFAGBK@?$AAP?$AAy?$AAT?$AAZ?$AAI?$AAn?$AAf?$AAo?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$CJ?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo@
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008a	33 c0		 xor	 eax, eax
$LN15@call_tzinf:

; 878  :     assert(tzinfoarg != NULL);

  0008c	48 83 7c 24 50
	00		 cmp	 QWORD PTR tzinfoarg$[rsp], 0
  00092	75 1c		 jne	 SHORT $LN16@call_tzinf
  00094	41 b8 6e 03 00
	00		 mov	 r8d, 878		; 0000036eH
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@CDHMOIAH@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AAa?$AAr?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ae	33 c0		 xor	 eax, eax
$LN16@call_tzinf:

; 879  : 
; 880  :     if (tzinfo == Py_None)

  000b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000b7	48 39 44 24 40	 cmp	 QWORD PTR tzinfo$[rsp], rax
  000bc	75 18		 jne	 SHORT $LN11@call_tzinf

; 881  :         Py_RETURN_NONE;

  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000c5	e8 00 00 00 00	 call	 _Py_IncRef
  000ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000d1	e9 3b 01 00 00	 jmp	 $LN12@call_tzinf
$LN11@call_tzinf:

; 882  :     offset = PyObject_CallMethod(tzinfo, name, "O", tzinfoarg);

  000d6	4c 8b 4c 24 50	 mov	 r9, QWORD PTR tzinfoarg$[rsp]
  000db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000e2	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  000e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  000ec	e8 00 00 00 00	 call	 PyObject_CallMethod
  000f1	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 883  :     if (offset == Py_None || offset == NULL)

  000f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000fd	48 39 44 24 20	 cmp	 QWORD PTR offset$[rsp], rax
  00102	74 08		 je	 SHORT $LN9@call_tzinf
  00104	48 83 7c 24 20
	00		 cmp	 QWORD PTR offset$[rsp], 0
  0010a	75 0a		 jne	 SHORT $LN10@call_tzinf
$LN9@call_tzinf:

; 884  :         return offset;

  0010c	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  00111	e9 fb 00 00 00	 jmp	 $LN12@call_tzinf
$LN10@call_tzinf:

; 885  :     if (PyDelta_Check(offset)) {

  00116	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  0011d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  00122	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00126	74 1d		 je	 SHORT $LN7@call_tzinf
  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0012f	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  00134	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00138	e8 00 00 00 00	 call	 PyType_IsSubtype
  0013d	85 c0		 test	 eax, eax
  0013f	0f 84 94 00 00
	00		 je	 $LN8@call_tzinf
$LN7@call_tzinf:

; 886  :         if (GET_TD_MICROSECONDS(offset) != 0 || GET_TD_SECONDS(offset) % 60 != 0) {

  00145	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  0014a	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  0014e	75 16		 jne	 SHORT $LN5@call_tzinf
  00150	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  00155	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00158	99		 cdq
  00159	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  0015e	f7 f9		 idiv	 ecx
  00160	8b c2		 mov	 eax, edx
  00162	85 c0		 test	 eax, eax
  00164	74 24		 je	 SHORT $LN6@call_tzinf
$LN5@call_tzinf:

; 887  :             Py_DECREF(offset);

  00166	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  0016b	e8 00 00 00 00	 call	 _Py_DecRef

; 888  :             PyErr_Format(PyExc_ValueError, "offset must be a timedelta"
; 889  :                          " representing a whole number of minutes");

  00170	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@KJOMKDID@offset?5must?5be?5a?5timedelta?5repre@
  00177	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0017e	e8 00 00 00 00	 call	 PyErr_Format

; 890  :             return NULL;

  00183	33 c0		 xor	 eax, eax
  00185	e9 87 00 00 00	 jmp	 $LN12@call_tzinf
$LN6@call_tzinf:

; 891  :         }
; 892  :         if ((GET_TD_DAYS(offset) == -1 && GET_TD_SECONDS(offset) == 0) ||
; 893  :             GET_TD_DAYS(offset) < -1 || GET_TD_DAYS(offset) >= 1) {

  0018a	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  0018f	83 78 68 ff	 cmp	 DWORD PTR [rax+104], -1
  00193	75 0b		 jne	 SHORT $LN2@call_tzinf
  00195	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  0019a	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  0019e	74 16		 je	 SHORT $LN3@call_tzinf
$LN2@call_tzinf:
  001a0	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  001a5	83 78 68 ff	 cmp	 DWORD PTR [rax+104], -1
  001a9	7c 0b		 jl	 SHORT $LN3@call_tzinf
  001ab	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  001b0	83 78 68 01	 cmp	 DWORD PTR [rax+104], 1
  001b4	7c 21		 jl	 SHORT $LN4@call_tzinf
$LN3@call_tzinf:

; 894  :             Py_DECREF(offset);

  001b6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  001bb	e8 00 00 00 00	 call	 _Py_DecRef

; 895  :             PyErr_Format(PyExc_ValueError, "offset must be a timedelta"
; 896  :                          " strictly between -timedelta(hours=24) and"
; 897  :                          " timedelta(hours=24).");

  001c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FK@GNEMBLOI@offset?5must?5be?5a?5timedelta?5stric@
  001c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001ce	e8 00 00 00 00	 call	 PyErr_Format

; 898  :             return NULL;

  001d3	33 c0		 xor	 eax, eax
  001d5	eb 3a		 jmp	 SHORT $LN12@call_tzinf
$LN4@call_tzinf:

; 899  :         }
; 900  :     }
; 901  :     else {

  001d7	eb 33		 jmp	 SHORT $LN1@call_tzinf
$LN8@call_tzinf:

; 902  :         Py_DECREF(offset);

  001d9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  001de	e8 00 00 00 00	 call	 _Py_DecRef

; 903  :         PyErr_Format(PyExc_TypeError,
; 904  :                      "tzinfo.%s() must return None or "
; 905  :                      "timedelta, not '%.200s'",
; 906  :                      name, Py_TYPE(offset)->tp_name);

  001e3	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  001e8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001ec	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  001f0	4c 8b 44 24 48	 mov	 r8, QWORD PTR name$[rsp]
  001f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@CJHONLAB@tzinfo?4?$CFs?$CI?$CJ?5must?5return?5None?5or?5@
  001fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00203	e8 00 00 00 00	 call	 PyErr_Format

; 907  :         return NULL;

  00208	33 c0		 xor	 eax, eax
  0020a	eb 05		 jmp	 SHORT $LN12@call_tzinf
$LN1@call_tzinf:

; 908  :     }
; 909  : 
; 910  :     return offset;

  0020c	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
$LN12@call_tzinf:

; 911  : }

  00211	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00215	c3		 ret	 0
call_tzinfo_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@BFKOKFNK@tzname?4replace?$CI?$CJ?5did?5not?5return?5@ ; `string'
PUBLIC	??_C@_02FCBLNKNB@ss?$AA@			; `string'
PUBLIC	??_C@_01FGNFDNOH@?$CF?$AA@			; `string'
PUBLIC	??_C@_02NGMLHCAB@?$CF?$CF?$AA@			; `string'
PUBLIC	??_C@_1CM@GBFBNFJK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAe?$AAm?$AAp?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyUnicode_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$make_Zreplacement DD imagerel make_Zreplacement
	DD	imagerel make_Zreplacement+416
	DD	imagerel $unwind$make_Zreplacement
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_Zreplacement DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0CJ@BFKOKFNK@tzname?4replace?$CI?$CJ?5did?5not?5return?5@
CONST	SEGMENT
??_C@_0CJ@BFKOKFNK@tzname?4replace?$CI?$CJ?5did?5not?5return?5@ DB 'tznam'
	DB	'e.replace() did not return a string', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02FCBLNKNB@ss?$AA@
CONST	SEGMENT
??_C@_02FCBLNKNB@ss?$AA@ DB 'ss', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FGNFDNOH@?$CF?$AA@
CONST	SEGMENT
??_C@_01FGNFDNOH@?$CF?$AA@ DB '%', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NGMLHCAB@?$CF?$CF?$AA@
CONST	SEGMENT
??_C@_02NGMLHCAB@?$CF?$CF?$AA@ DB '%%', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@GBFBNFJK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAe?$AAm?$AAp?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@GBFBNFJK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAe?$AAm?$AAp?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 't', 00H, 'e', 00H, 'm', 00H, 'p', 00H
	DB	')', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT make_Zreplacement
_TEXT	SEGMENT
temp$ = 48
tzinfo$ = 56
Zreplacement$ = 64
object$ = 96
tzinfoarg$ = 104
make_Zreplacement PROC					; COMDAT

; 1080 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1081 :     PyObject *temp;
; 1082 :     PyObject *tzinfo = get_tzinfo_member(object);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR object$[rsp]
  00013	e8 00 00 00 00	 call	 get_tzinfo_member
  00018	48 89 44 24 38	 mov	 QWORD PTR tzinfo$[rsp], rax

; 1083 :     PyObject *Zreplacement = PyUnicode_FromStringAndSize(NULL, 0);

  0001d	33 d2		 xor	 edx, edx
  0001f	33 c9		 xor	 ecx, ecx
  00021	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize
  00026	48 89 44 24 40	 mov	 QWORD PTR Zreplacement$[rsp], rax

; 1084 :     _Py_IDENTIFIER(replace);
; 1085 : 
; 1086 :     if (Zreplacement == NULL)

  0002b	48 83 7c 24 40
	00		 cmp	 QWORD PTR Zreplacement$[rsp], 0
  00031	75 07		 jne	 SHORT $LN7@make_Zrepl

; 1087 :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	e9 61 01 00 00	 jmp	 $LN8@make_Zrepl
$LN7@make_Zrepl:

; 1088 :     if (tzinfo == Py_None || tzinfo == NULL)

  0003a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00041	48 39 44 24 38	 cmp	 QWORD PTR tzinfo$[rsp], rax
  00046	74 08		 je	 SHORT $LN5@make_Zrepl
  00048	48 83 7c 24 38
	00		 cmp	 QWORD PTR tzinfo$[rsp], 0
  0004e	75 0a		 jne	 SHORT $LN6@make_Zrepl
$LN5@make_Zrepl:

; 1089 :         return Zreplacement;

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR Zreplacement$[rsp]
  00055	e9 41 01 00 00	 jmp	 $LN8@make_Zrepl
$LN6@make_Zrepl:

; 1090 : 
; 1091 :     assert(tzinfoarg != NULL);

  0005a	48 83 7c 24 68
	00		 cmp	 QWORD PTR tzinfoarg$[rsp], 0
  00060	75 1c		 jne	 SHORT $LN10@make_Zrepl
  00062	41 b8 43 04 00
	00		 mov	 r8d, 1091		; 00000443H
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@CDHMOIAH@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AAa?$AAr?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007c	33 c0		 xor	 eax, eax
$LN10@make_Zrepl:

; 1092 :     temp = call_tzname(tzinfo, tzinfoarg);

  0007e	48 8b 54 24 68	 mov	 rdx, QWORD PTR tzinfoarg$[rsp]
  00083	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00088	e8 00 00 00 00	 call	 call_tzname
  0008d	48 89 44 24 30	 mov	 QWORD PTR temp$[rsp], rax

; 1093 :     if (temp == NULL)

  00092	48 83 7c 24 30
	00		 cmp	 QWORD PTR temp$[rsp], 0
  00098	75 05		 jne	 SHORT $LN4@make_Zrepl

; 1094 :         goto Error;

  0009a	e9 f0 00 00 00	 jmp	 $Error$21303
$LN4@make_Zrepl:

; 1095 :     if (temp == Py_None) {

  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000a6	48 39 44 24 30	 cmp	 QWORD PTR temp$[rsp], rax
  000ab	75 14		 jne	 SHORT $LN3@make_Zrepl

; 1096 :         Py_DECREF(temp);

  000ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR temp$[rsp]
  000b2	e8 00 00 00 00	 call	 _Py_DecRef

; 1097 :         return Zreplacement;

  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR Zreplacement$[rsp]
  000bc	e9 da 00 00 00	 jmp	 $LN8@make_Zrepl
$LN3@make_Zrepl:

; 1098 :     }
; 1099 : 
; 1100 :     assert(PyUnicode_Check(temp));

  000c1	48 8b 44 24 30	 mov	 rax, QWORD PTR temp$[rsp]
  000c6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ca	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d0	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000d5	85 c0		 test	 eax, eax
  000d7	75 1c		 jne	 SHORT $LN11@make_Zrepl
  000d9	41 b8 4c 04 00
	00		 mov	 r8d, 1100		; 0000044cH
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@GBFBNFJK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAt?$AAe?$AAm?$AAp?$AA?$CJ?$AA?$AA@
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f3	33 c0		 xor	 eax, eax
$LN11@make_Zrepl:

; 1101 :     /* Since the tzname is getting stuffed into the
; 1102 :      * format, we have to double any % signs so that
; 1103 :      * strftime doesn't treat them as format codes.
; 1104 :      */
; 1105 :     Py_DECREF(Zreplacement);

  000f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Zreplacement$[rsp]
  000fa	e8 00 00 00 00	 call	 _Py_DecRef

; 1106 :     Zreplacement = _PyObject_CallMethodId(temp, &PyId_replace, "ss", "%", "%%");

  000ff	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_replace@?1??make_Zreplacement@@9@9
  00104	8b c0		 mov	 eax, eax
  00106	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0010c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00115	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02NGMLHCAB@?$CF?$CF?$AA@
  00120	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00125	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01FGNFDNOH@?$CF?$AA@
  0012c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02FCBLNKNB@ss?$AA@
  00133	48 8b d0	 mov	 rdx, rax
  00136	48 8b 4c 24 30	 mov	 rcx, QWORD PTR temp$[rsp]
  0013b	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00140	48 89 44 24 40	 mov	 QWORD PTR Zreplacement$[rsp], rax

; 1107 :     Py_DECREF(temp);

  00145	48 8b 4c 24 30	 mov	 rcx, QWORD PTR temp$[rsp]
  0014a	e8 00 00 00 00	 call	 _Py_DecRef

; 1108 :     if (Zreplacement == NULL)

  0014f	48 83 7c 24 40
	00		 cmp	 QWORD PTR Zreplacement$[rsp], 0
  00155	75 04		 jne	 SHORT $LN2@make_Zrepl

; 1109 :         return NULL;

  00157	33 c0		 xor	 eax, eax
  00159	eb 40		 jmp	 SHORT $LN8@make_Zrepl
$LN2@make_Zrepl:

; 1110 :     if (!PyUnicode_Check(Zreplacement)) {

  0015b	48 8b 44 24 40	 mov	 rax, QWORD PTR Zreplacement$[rsp]
  00160	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00164	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0016a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0016f	85 c0		 test	 eax, eax
  00171	75 15		 jne	 SHORT $LN1@make_Zrepl

; 1111 :         PyErr_SetString(PyExc_TypeError,
; 1112 :                         "tzname.replace() did not return a string");

  00173	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@BFKOKFNK@tzname?4replace?$CI?$CJ?5did?5not?5return?5@
  0017a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00181	e8 00 00 00 00	 call	 PyErr_SetString

; 1113 :         goto Error;

  00186	eb 07		 jmp	 SHORT $Error$21303
$LN1@make_Zrepl:

; 1114 :     }
; 1115 :     return Zreplacement;

  00188	48 8b 44 24 40	 mov	 rax, QWORD PTR Zreplacement$[rsp]
  0018d	eb 0c		 jmp	 SHORT $LN8@make_Zrepl
$Error$21303:

; 1116 : 
; 1117 :   Error:
; 1118 :     Py_DECREF(Zreplacement);

  0018f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR Zreplacement$[rsp]
  00194	e8 00 00 00 00	 call	 _Py_DecRef

; 1119 :     return NULL;

  00199	33 c0		 xor	 eax, eax
$LN8@make_Zrepl:

; 1120 : }

  0019b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0019f	c3		 ret	 0
make_Zreplacement ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@IEFGKKMD@tzinfo?4tzname?$CI?$CJ?5must?5return?5None@ ; `string'
PUBLIC	??_C@_1EG@JMCGCFEM@?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA_?$AAs?$AAu?$AAb?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?$CI?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_tzname DD imagerel call_tzname
	DD	imagerel call_tzname+336
	DD	imagerel $unwind$call_tzname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_tzname DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0DH@IEFGKKMD@tzinfo?4tzname?$CI?$CJ?5must?5return?5None@
CONST	SEGMENT
??_C@_0DH@IEFGKKMD@tzinfo?4tzname?$CI?$CJ?5must?5return?5None@ DB 'tzinfo'
	DB	'.tzname() must return None or a string, not ''%s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@JMCGCFEM@?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA_?$AAs?$AAu?$AAb?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?$CI?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
CONST	SEGMENT
??_C@_1EG@JMCGCFEM@?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA_?$AAs?$AAu?$AAb?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?$CI?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@ DB 'c'
	DB	00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '_', 00H, 't', 00H
	DB	'z', 00H, 'i', 00H, 'n', 00H, 'f', 00H, 'o', 00H, '_', 00H, 's'
	DB	00H, 'u', 00H, 'b', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, '(', 00H, 't', 00H, 'z', 00H, 'i', 00H, 'n', 00H, 'f'
	DB	00H, 'o', 00H, ')', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT call_tzname
_TEXT	SEGMENT
result$ = 32
tzinfo$ = 64
tzinfoarg$ = 72
call_tzname PROC					; COMDAT

; 949  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 950  :     PyObject *result;
; 951  :     _Py_IDENTIFIER(tzname);
; 952  : 
; 953  :     assert(tzinfo != NULL);

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR tzinfo$[rsp], 0
  00014	75 1c		 jne	 SHORT $LN7@call_tznam
  00016	41 b8 b9 03 00
	00		 mov	 r8d, 953		; 000003b9H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@DNINNPAP@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00030	33 c0		 xor	 eax, eax
$LN7@call_tznam:

; 954  :     assert(check_tzinfo_subclass(tzinfo) >= 0);

  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00037	e8 00 00 00 00	 call	 check_tzinfo_subclass
  0003c	85 c0		 test	 eax, eax
  0003e	7d 1c		 jge	 SHORT $LN8@call_tznam
  00040	41 b8 ba 03 00
	00		 mov	 r8d, 954		; 000003baH
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@JMCGCFEM@?$AAc?$AAh?$AAe?$AAc?$AAk?$AA_?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA_?$AAs?$AAu?$AAb?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?$CI?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN@
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005a	33 c0		 xor	 eax, eax
$LN8@call_tznam:

; 955  :     assert(tzinfoarg != NULL);

  0005c	48 83 7c 24 48
	00		 cmp	 QWORD PTR tzinfoarg$[rsp], 0
  00062	75 1c		 jne	 SHORT $LN9@call_tznam
  00064	41 b8 bb 03 00
	00		 mov	 r8d, 955		; 000003bbH
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@CDHMOIAH@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AAa?$AAr?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN9@call_tznam:

; 956  : 
; 957  :     if (tzinfo == Py_None)

  00080	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00087	48 39 44 24 40	 cmp	 QWORD PTR tzinfo$[rsp], rax
  0008c	75 18		 jne	 SHORT $LN4@call_tznam

; 958  :         Py_RETURN_NONE;

  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00095	e8 00 00 00 00	 call	 _Py_IncRef
  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000a1	e9 a5 00 00 00	 jmp	 $LN5@call_tznam
$LN4@call_tznam:

; 959  : 
; 960  :     result = _PyObject_CallMethodId(tzinfo, &PyId_tzname, "O", tzinfoarg);

  000a6	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_tzname@?1??call_tzname@@9@9
  000ab	8b c0		 mov	 eax, eax
  000ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000b3	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000bc	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000c0	4c 8b 4c 24 48	 mov	 r9, QWORD PTR tzinfoarg$[rsp]
  000c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  000d4	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  000d9	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 961  : 
; 962  :     if (result == NULL || result == Py_None)

  000de	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  000e4	74 0e		 je	 SHORT $LN2@call_tznam
  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ed	48 39 44 24 20	 cmp	 QWORD PTR result$[rsp], rax
  000f2	75 07		 jne	 SHORT $LN3@call_tznam
$LN2@call_tznam:

; 963  :         return result;

  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  000f9	eb 50		 jmp	 SHORT $LN5@call_tznam
$LN3@call_tznam:

; 964  : 
; 965  :     if (!PyUnicode_Check(result)) {

  000fb	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00100	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00104	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0010a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0010f	85 c0		 test	 eax, eax
  00111	75 33		 jne	 SHORT $LN1@call_tznam

; 966  :         PyErr_Format(PyExc_TypeError, "tzinfo.tzname() must "
; 967  :                      "return None or a string, not '%s'",
; 968  :                      Py_TYPE(result)->tp_name);

  00113	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00118	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0011c	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@IEFGKKMD@tzinfo?4tzname?$CI?$CJ?5must?5return?5None@
  00127	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0012e	e8 00 00 00 00	 call	 PyErr_Format

; 969  :         Py_DECREF(result);

  00133	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00138	e8 00 00 00 00	 call	 _Py_DecRef

; 970  :         result = NULL;

  0013d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0
$LN1@call_tznam:

; 971  :     }
; 972  : 
; 973  :     return result;

  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN5@call_tznam:

; 974  : }

  0014b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0014f	c3		 ret	 0
call_tzname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EE@GAPMMBNH@tzinfo?5argument?5must?5be?5None?5or?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_tzinfo_subclass DD imagerel check_tzinfo_subclass
	DD	imagerel check_tzinfo_subclass+112
	DD	imagerel $unwind$check_tzinfo_subclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_tzinfo_subclass DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0EE@GAPMMBNH@tzinfo?5argument?5must?5be?5None?5or?5@
CONST	SEGMENT
??_C@_0EE@GAPMMBNH@tzinfo?5argument?5must?5be?5None?5or?5@ DB 'tzinfo arg'
	DB	'ument must be None or of a tzinfo subclass, not type ''%s''', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT check_tzinfo_subclass
_TEXT	SEGMENT
p$ = 48
check_tzinfo_subclass PROC				; COMDAT

; 837  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 838  :     if (p == Py_None || PyTZInfo_Check(p))

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00010	48 39 44 24 30	 cmp	 QWORD PTR p$[rsp], rax
  00015	74 2b		 je	 SHORT $LN2@check_tzin
  00017	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TZInfoType
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00023	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00027	74 19		 je	 SHORT $LN1@check_tzin
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_TZInfoType
  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00035	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00039	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003e	85 c0		 test	 eax, eax
  00040	74 04		 je	 SHORT $LN3@check_tzin
$LN1@check_tzin:
$LN2@check_tzin:

; 839  :         return 0;

  00042	33 c0		 xor	 eax, eax
  00044	eb 25		 jmp	 SHORT $LN4@check_tzin
$LN3@check_tzin:

; 840  :     PyErr_Format(PyExc_TypeError,
; 841  :                  "tzinfo argument must be None or of a tzinfo subclass, "
; 842  :                  "not type '%s'",
; 843  :                  Py_TYPE(p)->tp_name);

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  0004b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004f	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EE@GAPMMBNH@tzinfo?5argument?5must?5be?5None?5or?5@
  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00061	e8 00 00 00 00	 call	 PyErr_Format

; 844  :     return -1;

  00066	b8 ff ff ff ff	 mov	 eax, -1
$LN4@check_tzin:

; 845  : }

  0006b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006f	c3		 ret	 0
check_tzinfo_subclass ENDP
_TEXT	ENDS
PUBLIC	??_C@_04OBKAGHLG@?$CF06d?$AA@			; `string'
EXTRN	__imp_sprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$make_freplacement DD imagerel make_freplacement
	DD	imagerel make_freplacement+264
	DD	imagerel $unwind$make_freplacement
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$make_freplacement DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_04OBKAGHLG@?$CF06d?$AA@
CONST	SEGMENT
??_C@_04OBKAGHLG@?$CF06d?$AA@ DB '%06d', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT make_freplacement
_TEXT	SEGMENT
freplacement$ = 32
object$ = 112
make_freplacement PROC					; COMDAT

; 1124 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1125 :     char freplacement[64];
; 1126 :     if (PyTime_Check(object))

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TimeType
  00010	48 8b 4c 24 70	 mov	 rcx, QWORD PTR object$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 19		 je	 SHORT $LN5@make_frepl
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_TimeType
  00022	48 8b 44 24 70	 mov	 rax, QWORD PTR object$[rsp]
  00027	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0002b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00030	85 c0		 test	 eax, eax
  00032	74 3c		 je	 SHORT $LN6@make_frepl
$LN5@make_frepl:

; 1127 :         sprintf(freplacement, "%06d", TIME_GET_MICROSECOND(object));

  00034	48 8b 44 24 70	 mov	 rax, QWORD PTR object$[rsp]
  00039	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  0003d	c1 e0 10	 shl	 eax, 16
  00040	48 8b 4c 24 70	 mov	 rcx, QWORD PTR object$[rsp]
  00045	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  00049	c1 e1 08	 shl	 ecx, 8
  0004c	0b c1		 or	 eax, ecx
  0004e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR object$[rsp]
  00053	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  00057	0b c1		 or	 eax, ecx
  00059	44 8b c0	 mov	 r8d, eax
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04OBKAGHLG@?$CF06d?$AA@
  00063	48 8d 4c 24 20	 lea	 rcx, QWORD PTR freplacement$[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
  0006e	eb 7c		 jmp	 SHORT $LN4@make_frepl
$LN6@make_frepl:

; 1128 :     else if (PyDateTime_Check(object))

  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00077	48 8b 4c 24 70	 mov	 rcx, QWORD PTR object$[rsp]
  0007c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00080	74 19		 je	 SHORT $LN2@make_frepl
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00089	48 8b 44 24 70	 mov	 rax, QWORD PTR object$[rsp]
  0008e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00092	e8 00 00 00 00	 call	 PyType_IsSubtype
  00097	85 c0		 test	 eax, eax
  00099	74 3c		 je	 SHORT $LN3@make_frepl
$LN2@make_frepl:

; 1129 :         sprintf(freplacement, "%06d", DATE_GET_MICROSECOND(object));

  0009b	48 8b 44 24 70	 mov	 rax, QWORD PTR object$[rsp]
  000a0	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  000a4	c1 e0 10	 shl	 eax, 16
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR object$[rsp]
  000ac	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  000b0	c1 e1 08	 shl	 ecx, 8
  000b3	0b c1		 or	 eax, ecx
  000b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR object$[rsp]
  000ba	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  000be	0b c1		 or	 eax, ecx
  000c0	44 8b c0	 mov	 r8d, eax
  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04OBKAGHLG@?$CF06d?$AA@
  000ca	48 8d 4c 24 20	 lea	 rcx, QWORD PTR freplacement$[rsp]
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 1130 :     else

  000d5	eb 15		 jmp	 SHORT $LN1@make_frepl
$LN3@make_frepl:

; 1131 :         sprintf(freplacement, "%06d", 0);

  000d7	45 33 c0	 xor	 r8d, r8d
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04OBKAGHLG@?$CF06d?$AA@
  000e1	48 8d 4c 24 20	 lea	 rcx, QWORD PTR freplacement$[rsp]
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf
$LN1@make_frepl:
$LN4@make_frepl:

; 1132 : 
; 1133 :     return PyBytes_FromStringAndSize(freplacement, strlen(freplacement));

  000ec	48 8d 4c 24 20	 lea	 rcx, QWORD PTR freplacement$[rsp]
  000f1	e8 00 00 00 00	 call	 strlen
  000f6	48 8b d0	 mov	 rdx, rax
  000f9	48 8d 4c 24 20	 lea	 rcx, QWORD PTR freplacement$[rsp]
  000fe	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 1134 : }

  00103	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00107	c3		 ret	 0
make_freplacement ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@EKIKMBMC@U?3__format__?$AA@		; `string'
EXTRN	PyObject_Str:PROC
EXTRN	PyUnicode_GetLength:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_format DD imagerel date_format
	DD	imagerel date_format+127
	DD	imagerel $unwind$date_format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_format DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0N@EKIKMBMC@U?3__format__?$AA@
CONST	SEGMENT
??_C@_0N@EKIKMBMC@U?3__format__?$AA@ DB 'U:__format__', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT date_format
_TEXT	SEGMENT
format$ = 32
self$ = 64
args$ = 72
date_format PROC					; COMDAT

; 2672 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2673 :     PyObject *format;
; 2674 :     _Py_IDENTIFIER(strftime);
; 2675 : 
; 2676 :     if (!PyArg_ParseTuple(args, "U:__format__", &format))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR format$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@EKIKMBMC@U?3__format__?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@date_forma

; 2677 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 4e		 jmp	 SHORT $LN3@date_forma
$LN2@date_forma:

; 2678 : 
; 2679 :     /* if the format is zero length, return str(self) */
; 2680 :     if (PyUnicode_GetLength(format) == 0)

  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR format$[rsp]
  00031	e8 00 00 00 00	 call	 PyUnicode_GetLength
  00036	48 85 c0	 test	 rax, rax
  00039	75 0c		 jne	 SHORT $LN1@date_forma

; 2681 :         return PyObject_Str((PyObject *)self);

  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00040	e8 00 00 00 00	 call	 PyObject_Str
  00045	eb 33		 jmp	 SHORT $LN3@date_forma
$LN1@date_forma:

; 2682 : 
; 2683 :     return _PyObject_CallMethodId((PyObject *)self, &PyId_strftime, "O", format);

  00047	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_strftime@?1??date_format@@9@9
  0004c	8b c0		 mov	 eax, eax
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00054	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0005d	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00061	4c 8b 4c 24 20	 mov	 r9, QWORD PTR format$[rsp]
  00066	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00075	e8 00 00 00 00	 call	 _PyObject_CallMethodId
$LN3@date_forma:

; 2684 : }

  0007a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007e	c3		 ret	 0
date_format ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_isoweekday DD imagerel date_isoweekday
	DD	imagerel date_isoweekday+94
	DD	imagerel $unwind$date_isoweekday
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_isoweekday DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_isoweekday
_TEXT	SEGMENT
dow$ = 32
tv80 = 36
self$ = 64
date_isoweekday PROC					; COMDAT

; 2690 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2691 :     int dow = weekday(GET_YEAR(self), GET_MONTH(self), GET_DAY(self));

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00017	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  0001b	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  00020	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  00024	c1 e2 08	 shl	 edx, 8
  00027	4c 8b 44 24 40	 mov	 r8, QWORD PTR self$[rsp]
  0002c	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  00031	41 0b d0	 or	 edx, r8d
  00034	89 54 24 24	 mov	 DWORD PTR tv80[rsp], edx
  00038	44 8b c0	 mov	 r8d, eax
  0003b	8b d1		 mov	 edx, ecx
  0003d	8b 44 24 24	 mov	 eax, DWORD PTR tv80[rsp]
  00041	8b c8		 mov	 ecx, eax
  00043	e8 00 00 00 00	 call	 weekday
  00048	89 44 24 20	 mov	 DWORD PTR dow$[rsp], eax

; 2692 : 
; 2693 :     return PyLong_FromLong(dow + 1);

  0004c	8b 44 24 20	 mov	 eax, DWORD PTR dow$[rsp]
  00050	ff c0		 inc	 eax
  00052	8b c8		 mov	 ecx, eax
  00054	e8 00 00 00 00	 call	 PyLong_FromLong

; 2694 : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
date_isoweekday ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_isocalendar DD imagerel date_isocalendar
	DD	imagerel date_isocalendar+266
	DD	imagerel $unwind$date_isocalendar
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_isocalendar DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_isocalendar
_TEXT	SEGMENT
day$ = 32
today$ = 36
week$ = 40
year$ = 44
week1_monday$ = 48
self$ = 80
date_isocalendar PROC					; COMDAT

; 2698 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2699 :     int  year         = GET_YEAR(self);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00012	c1 e0 08	 shl	 eax, 8
  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0001a	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  0001e	0b c1		 or	 eax, ecx
  00020	89 44 24 2c	 mov	 DWORD PTR year$[rsp], eax

; 2700 :     int  week1_monday = iso_week1_monday(year);

  00024	8b 4c 24 2c	 mov	 ecx, DWORD PTR year$[rsp]
  00028	e8 00 00 00 00	 call	 iso_week1_monday
  0002d	89 44 24 30	 mov	 DWORD PTR week1_monday$[rsp], eax

; 2701 :     int today         = ymd_to_ord(year, GET_MONTH(self), GET_DAY(self));

  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00036	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  0003a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0003f	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  00043	44 8b c0	 mov	 r8d, eax
  00046	8b d1		 mov	 edx, ecx
  00048	8b 4c 24 2c	 mov	 ecx, DWORD PTR year$[rsp]
  0004c	e8 00 00 00 00	 call	 ymd_to_ord
  00051	89 44 24 24	 mov	 DWORD PTR today$[rsp], eax

; 2702 :     int  week;
; 2703 :     int  day;
; 2704 : 
; 2705 :     week = divmod(today - week1_monday, 7, &day);

  00055	8b 44 24 30	 mov	 eax, DWORD PTR week1_monday$[rsp]
  00059	8b 4c 24 24	 mov	 ecx, DWORD PTR today$[rsp]
  0005d	2b c8		 sub	 ecx, eax
  0005f	8b c1		 mov	 eax, ecx
  00061	4c 8d 44 24 20	 lea	 r8, QWORD PTR day$[rsp]
  00066	ba 07 00 00 00	 mov	 edx, 7
  0006b	8b c8		 mov	 ecx, eax
  0006d	e8 00 00 00 00	 call	 divmod
  00072	89 44 24 28	 mov	 DWORD PTR week$[rsp], eax

; 2706 :     if (week < 0) {

  00076	83 7c 24 28 00	 cmp	 DWORD PTR week$[rsp], 0
  0007b	7d 3a		 jge	 SHORT $LN3@date_isoca

; 2707 :         --year;

  0007d	8b 44 24 2c	 mov	 eax, DWORD PTR year$[rsp]
  00081	ff c8		 dec	 eax
  00083	89 44 24 2c	 mov	 DWORD PTR year$[rsp], eax

; 2708 :         week1_monday = iso_week1_monday(year);

  00087	8b 4c 24 2c	 mov	 ecx, DWORD PTR year$[rsp]
  0008b	e8 00 00 00 00	 call	 iso_week1_monday
  00090	89 44 24 30	 mov	 DWORD PTR week1_monday$[rsp], eax

; 2709 :         week = divmod(today - week1_monday, 7, &day);

  00094	8b 44 24 30	 mov	 eax, DWORD PTR week1_monday$[rsp]
  00098	8b 4c 24 24	 mov	 ecx, DWORD PTR today$[rsp]
  0009c	2b c8		 sub	 ecx, eax
  0009e	8b c1		 mov	 eax, ecx
  000a0	4c 8d 44 24 20	 lea	 r8, QWORD PTR day$[rsp]
  000a5	ba 07 00 00 00	 mov	 edx, 7
  000aa	8b c8		 mov	 ecx, eax
  000ac	e8 00 00 00 00	 call	 divmod
  000b1	89 44 24 28	 mov	 DWORD PTR week$[rsp], eax
  000b5	eb 2c		 jmp	 SHORT $LN2@date_isoca
$LN3@date_isoca:

; 2710 :     }
; 2711 :     else if (week >= 52 && today >= iso_week1_monday(year + 1)) {

  000b7	83 7c 24 28 34	 cmp	 DWORD PTR week$[rsp], 52 ; 00000034H
  000bc	7c 25		 jl	 SHORT $LN1@date_isoca
  000be	8b 44 24 2c	 mov	 eax, DWORD PTR year$[rsp]
  000c2	ff c0		 inc	 eax
  000c4	8b c8		 mov	 ecx, eax
  000c6	e8 00 00 00 00	 call	 iso_week1_monday
  000cb	39 44 24 24	 cmp	 DWORD PTR today$[rsp], eax
  000cf	7c 12		 jl	 SHORT $LN1@date_isoca

; 2712 :         ++year;

  000d1	8b 44 24 2c	 mov	 eax, DWORD PTR year$[rsp]
  000d5	ff c0		 inc	 eax
  000d7	89 44 24 2c	 mov	 DWORD PTR year$[rsp], eax

; 2713 :         week = 0;

  000db	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR week$[rsp], 0
$LN1@date_isoca:
$LN2@date_isoca:

; 2714 :     }
; 2715 :     return Py_BuildValue("iii", year, week + 1, day + 1);

  000e3	8b 44 24 20	 mov	 eax, DWORD PTR day$[rsp]
  000e7	ff c0		 inc	 eax
  000e9	8b 4c 24 28	 mov	 ecx, DWORD PTR week$[rsp]
  000ed	ff c1		 inc	 ecx
  000ef	44 8b c8	 mov	 r9d, eax
  000f2	44 8b c1	 mov	 r8d, ecx
  000f5	8b 54 24 2c	 mov	 edx, DWORD PTR year$[rsp]
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  00100	e8 00 00 00 00	 call	 Py_BuildValue

; 2716 : }

  00105	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00109	c3		 ret	 0
date_isocalendar ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iso_week1_monday DD imagerel iso_week1_monday
	DD	imagerel iso_week1_monday+96
	DD	imagerel $unwind$iso_week1_monday
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iso_week1_monday DD 010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT iso_week1_monday
_TEXT	SEGMENT
first_day$ = 32
first_weekday$ = 36
week1_monday$ = 40
year$ = 64
iso_week1_monday PROC					; COMDAT

; 357  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 358  :     int first_day = ymd_to_ord(year, 1, 1);     /* ord of 1/1 */

  00008	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000e	ba 01 00 00 00	 mov	 edx, 1
  00013	8b 4c 24 40	 mov	 ecx, DWORD PTR year$[rsp]
  00017	e8 00 00 00 00	 call	 ymd_to_ord
  0001c	89 44 24 20	 mov	 DWORD PTR first_day$[rsp], eax

; 359  :     /* 0 if 1/1 is a Monday, 1 if a Tue, etc. */
; 360  :     int first_weekday = (first_day + 6) % 7;

  00020	8b 44 24 20	 mov	 eax, DWORD PTR first_day$[rsp]
  00024	83 c0 06	 add	 eax, 6
  00027	99		 cdq
  00028	b9 07 00 00 00	 mov	 ecx, 7
  0002d	f7 f9		 idiv	 ecx
  0002f	8b c2		 mov	 eax, edx
  00031	89 44 24 24	 mov	 DWORD PTR first_weekday$[rsp], eax

; 361  :     /* ordinal of closest Monday at or before 1/1 */
; 362  :     int week1_monday  = first_day - first_weekday;

  00035	8b 44 24 24	 mov	 eax, DWORD PTR first_weekday$[rsp]
  00039	8b 4c 24 20	 mov	 ecx, DWORD PTR first_day$[rsp]
  0003d	2b c8		 sub	 ecx, eax
  0003f	8b c1		 mov	 eax, ecx
  00041	89 44 24 28	 mov	 DWORD PTR week1_monday$[rsp], eax

; 363  : 
; 364  :     if (first_weekday > 3)      /* if 1/1 was Fri, Sat, Sun */

  00045	83 7c 24 24 03	 cmp	 DWORD PTR first_weekday$[rsp], 3
  0004a	7e 0b		 jle	 SHORT $LN1@iso_week1_

; 365  :         week1_monday += 7;

  0004c	8b 44 24 28	 mov	 eax, DWORD PTR week1_monday$[rsp]
  00050	83 c0 07	 add	 eax, 7
  00053	89 44 24 28	 mov	 DWORD PTR week1_monday$[rsp], eax
$LN1@iso_week1_:

; 366  :     return week1_monday;

  00057	8b 44 24 28	 mov	 eax, DWORD PTR week1_monday$[rsp]

; 367  : }

  0005b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005f	c3		 ret	 0
iso_week1_monday ENDP
_TEXT	ENDS
EXTRN	memcmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_richcompare DD imagerel date_richcompare
	DD	imagerel date_richcompare+139
	DD	imagerel $unwind$date_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_richcompare DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_richcompare
_TEXT	SEGMENT
diff$22760 = 32
self$ = 64
other$ = 72
op$ = 80
date_richcompare PROC					; COMDAT

; 2722 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2723 :     if (PyDate_Check(other)) {

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateType
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR other$[rsp]
  0001f	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00023	74 19		 je	 SHORT $LN2@date_richc
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateType
  0002c	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  00031	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00035	e8 00 00 00 00	 call	 PyType_IsSubtype
  0003a	85 c0		 test	 eax, eax
  0003c	74 35		 je	 SHORT $LN3@date_richc
$LN2@date_richc:

; 2724 :         int diff = memcmp(((PyDateTime_Date *)self)->data,
; 2725 :                           ((PyDateTime_Date *)other)->data,
; 2726 :                           _PyDateTime_DATE_DATASIZE);

  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR other$[rsp]
  00043	48 83 c0 69	 add	 rax, 105		; 00000069H
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0004c	48 83 c1 69	 add	 rcx, 105		; 00000069H
  00050	41 b8 04 00 00
	00		 mov	 r8d, 4
  00056	48 8b d0	 mov	 rdx, rax
  00059	e8 00 00 00 00	 call	 memcmp
  0005e	89 44 24 20	 mov	 DWORD PTR diff$22760[rsp], eax

; 2727 :         return diff_to_bool(diff, op);

  00062	8b 54 24 50	 mov	 edx, DWORD PTR op$[rsp]
  00066	8b 4c 24 20	 mov	 ecx, DWORD PTR diff$22760[rsp]
  0006a	e8 00 00 00 00	 call	 diff_to_bool
  0006f	eb 15		 jmp	 SHORT $LN4@date_richc

; 2728 :     }
; 2729 :     else

  00071	eb 13		 jmp	 SHORT $LN1@date_richc
$LN3@date_richc:

; 2730 :         Py_RETURN_NOTIMPLEMENTED;

  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0007a	e8 00 00 00 00	 call	 _Py_IncRef
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN1@date_richc:
$LN4@date_richc:

; 2731 : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
date_richcompare ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_timetuple DD imagerel date_timetuple
	DD	imagerel date_timetuple+104
	DD	imagerel $unwind$date_timetuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_timetuple DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_timetuple
_TEXT	SEGMENT
tv84 = 64
self$ = 96
date_timetuple PROC					; COMDAT

; 2735 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2736 :     return build_struct_time(GET_YEAR(self),
; 2737 :                              GET_MONTH(self),
; 2738 :                              GET_DAY(self),
; 2739 :                              0, 0, 0, -1);

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00012	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00017	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  0001b	48 8b 54 24 60	 mov	 rdx, QWORD PTR self$[rsp]
  00020	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  00024	c1 e2 08	 shl	 edx, 8
  00027	4c 8b 44 24 60	 mov	 r8, QWORD PTR self$[rsp]
  0002c	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  00031	41 0b d0	 or	 edx, r8d
  00034	89 54 24 40	 mov	 DWORD PTR tv84[rsp], edx
  00038	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR [rsp+48], -1
  00040	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00048	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00050	45 33 c9	 xor	 r9d, r9d
  00053	44 8b c0	 mov	 r8d, eax
  00056	8b d1		 mov	 edx, ecx
  00058	8b 44 24 40	 mov	 eax, DWORD PTR tv84[rsp]
  0005c	8b c8		 mov	 ecx, eax
  0005e	e8 00 00 00 00	 call	 build_struct_time

; 2740 : }

  00063	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00067	c3		 ret	 0
date_timetuple ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@CFPDDNCK@?$CI?$CIiiiiiiiii?$CJ?$CJ?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_struct_time DD imagerel build_struct_time
	DD	imagerel build_struct_time+280
	DD	imagerel $unwind$build_struct_time
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_struct_time DD 021901H
	DD	0110119H
xdata	ENDS
;	COMDAT ??_C@_0O@CFPDDNCK@?$CI?$CIiiiiiiiii?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@CFPDDNCK@?$CI?$CIiiiiiiiii?$CJ?$CJ?$AA@ DB '((iiiiiiiii))', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT build_struct_time
_TEXT	SEGMENT
time$ = 96
result$ = 104
tv72 = 112
y$ = 144
m$ = 152
d$ = 160
hh$ = 168
mm$ = 176
ss$ = 184
dstflag$ = 192
build_struct_time PROC					; COMDAT

; 1335 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1336 :     PyObject *time;
; 1337 :     PyObject *result = NULL;

  00019	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 1338 : 
; 1339 :     time = PyImport_ImportModuleNoBlock("time");

  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04CLCEDBPF@time?$AA@
  00029	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  0002e	48 89 44 24 60	 mov	 QWORD PTR time$[rsp], rax

; 1340 :     if (time != NULL) {

  00033	48 83 7c 24 60
	00		 cmp	 QWORD PTR time$[rsp], 0
  00039	0f 84 cc 00 00
	00		 je	 $LN1@build_stru

; 1341 :         _Py_IDENTIFIER(struct_time);
; 1342 : 
; 1343 :         result = _PyObject_CallMethodId(time, &PyId_struct_time,
; 1344 :                                         "((iiiiiiiii))",
; 1345 :                                         y, m, d,
; 1346 :                                         hh, mm, ss,
; 1347 :                                         weekday(y, m, d),
; 1348 :                                         days_before_month(y, m) + d,
; 1349 :                                         dstflag);

  0003f	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR m$[rsp]
  00046	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR y$[rsp]
  0004d	e8 00 00 00 00	 call	 days_before_month
  00052	03 84 24 a0 00
	00 00		 add	 eax, DWORD PTR d$[rsp]
  00059	89 44 24 70	 mov	 DWORD PTR tv72[rsp], eax
  0005d	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR d$[rsp]
  00065	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR m$[rsp]
  0006c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR y$[rsp]
  00073	e8 00 00 00 00	 call	 weekday
  00078	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PyId_struct_time@?2??build_struct_time@@9@9
  0007d	8b c9		 mov	 ecx, ecx
  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  00085	65 4c 8b 04 25
	58 00 00 00	 mov	 r8, QWORD PTR gs:88
  0008e	49 03 0c d0	 add	 rcx, QWORD PTR [r8+rdx*8]
  00092	8b 94 24 c0 00
	00 00		 mov	 edx, DWORD PTR dstflag$[rsp]
  00099	89 54 24 58	 mov	 DWORD PTR [rsp+88], edx
  0009d	8b 54 24 70	 mov	 edx, DWORD PTR tv72[rsp]
  000a1	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  000a5	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  000a9	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR ss$[rsp]
  000b0	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  000b4	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR mm$[rsp]
  000bb	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  000bf	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR hh$[rsp]
  000c6	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000ca	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR d$[rsp]
  000d1	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000d5	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR m$[rsp]
  000dc	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e0	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR y$[rsp]
  000e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@CFPDDNCK@?$CI?$CIiiiiiiiii?$CJ?$CJ?$AA@
  000ef	48 8b d1	 mov	 rdx, rcx
  000f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR time$[rsp]
  000f7	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  000fc	48 89 44 24 68	 mov	 QWORD PTR result$[rsp], rax

; 1350 :         Py_DECREF(time);

  00101	48 8b 4c 24 60	 mov	 rcx, QWORD PTR time$[rsp]
  00106	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@build_stru:

; 1351 :     }
; 1352 :     return result;

  0010b	48 8b 44 24 68	 mov	 rax, QWORD PTR result$[rsp]

; 1353 : }

  00110	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00117	c3		 ret	 0
build_struct_time ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@GJNAPPAP@?$HMiii?3replace?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_replace DD imagerel date_replace
	DD	imagerel date_replace+232
	DD	imagerel $unwind$date_replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_replace DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0N@GJNAPPAP@?$HMiii?3replace?$AA@
CONST	SEGMENT
??_C@_0N@GJNAPPAP@?$HMiii?3replace?$AA@ DB '|iii:replace', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT date_replace
_TEXT	SEGMENT
day$ = 64
month$ = 68
tuple$ = 72
clone$ = 80
year$ = 88
self$ = 112
args$ = 120
kw$ = 128
date_replace PROC					; COMDAT

; 2744 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2745 :     PyObject *clone;
; 2746 :     PyObject *tuple;
; 2747 :     int year = GET_YEAR(self);

  00013	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00018	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  0001c	c1 e0 08	 shl	 eax, 8
  0001f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00024	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00028	0b c1		 or	 eax, ecx
  0002a	89 44 24 58	 mov	 DWORD PTR year$[rsp], eax

; 2748 :     int month = GET_MONTH(self);

  0002e	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00033	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  00037	89 44 24 44	 mov	 DWORD PTR month$[rsp], eax

; 2749 :     int day = GET_DAY(self);

  0003b	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00040	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00044	89 44 24 40	 mov	 DWORD PTR day$[rsp], eax

; 2750 : 
; 2751 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "|iii:replace", date_kws,
; 2752 :                                       &year, &month, &day))

  00048	48 8d 44 24 40	 lea	 rax, QWORD PTR day$[rsp]
  0004d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00052	48 8d 44 24 44	 lea	 rax, QWORD PTR month$[rsp]
  00057	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005c	48 8d 44 24 58	 lea	 rax, QWORD PTR year$[rsp]
  00061	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00066	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:date_kws
  0006d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@GJNAPPAP@?$HMiii?3replace?$AA@
  00074	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  0007c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00081	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00086	85 c0		 test	 eax, eax
  00088	75 04		 jne	 SHORT $LN2@date_repla

; 2753 :         return NULL;

  0008a	33 c0		 xor	 eax, eax
  0008c	eb 55		 jmp	 SHORT $LN3@date_repla
$LN2@date_repla:

; 2754 :     tuple = Py_BuildValue("iii", year, month, day);

  0008e	44 8b 4c 24 40	 mov	 r9d, DWORD PTR day$[rsp]
  00093	44 8b 44 24 44	 mov	 r8d, DWORD PTR month$[rsp]
  00098	8b 54 24 58	 mov	 edx, DWORD PTR year$[rsp]
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  000a3	e8 00 00 00 00	 call	 Py_BuildValue
  000a8	48 89 44 24 48	 mov	 QWORD PTR tuple$[rsp], rax

; 2755 :     if (tuple == NULL)

  000ad	48 83 7c 24 48
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  000b3	75 04		 jne	 SHORT $LN1@date_repla

; 2756 :         return NULL;

  000b5	33 c0		 xor	 eax, eax
  000b7	eb 2a		 jmp	 SHORT $LN3@date_repla
$LN1@date_repla:

; 2757 :     clone = date_new(Py_TYPE(self), tuple, NULL);

  000b9	45 33 c0	 xor	 r8d, r8d
  000bc	48 8b 54 24 48	 mov	 rdx, QWORD PTR tuple$[rsp]
  000c1	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000c6	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000ca	e8 00 00 00 00	 call	 date_new
  000cf	48 89 44 24 50	 mov	 QWORD PTR clone$[rsp], rax

; 2758 :     Py_DECREF(tuple);

  000d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tuple$[rsp]
  000d9	e8 00 00 00 00	 call	 _Py_DecRef

; 2759 :     return clone;

  000de	48 8b 44 24 50	 mov	 rax, QWORD PTR clone$[rsp]
$LN3@date_repla:

; 2760 : }

  000e3	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000e7	c3		 ret	 0
date_replace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_hash DD imagerel date_hash
	DD	imagerel date_hash+66
	DD	imagerel $unwind$date_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_hash DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_hash
_TEXT	SEGMENT
self$ = 48
date_hash PROC						; COMDAT

; 2773 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2774 :     if (self->hashcode == -1)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 ff	 cmp	 QWORD PTR [rax+96], -1
  00013	75 1f		 jne	 SHORT $LN1@date_hash

; 2775 :         self->hashcode = generic_hash(
; 2776 :             (unsigned char *)self->data, _PyDateTime_DATE_DATASIZE);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001a	48 83 c0 69	 add	 rax, 105		; 00000069H
  0001e	ba 04 00 00 00	 mov	 edx, 4
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 generic_hash
  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00030	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN1@date_hash:

; 2777 : 
; 2778 :     return self->hashcode;

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00039	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]

; 2779 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
date_hash ENDP
_TEXT	ENDS
EXTRN	_Py_HashBytes:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$generic_hash DD imagerel generic_hash
	DD	imagerel generic_hash+36
	DD	imagerel $unwind$generic_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$generic_hash DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT generic_hash
_TEXT	SEGMENT
data$ = 48
len$ = 56
generic_hash PROC					; COMDAT

; 2764 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2765 :     return _Py_HashBytes(data, len);

  0000d	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  00012	48 8b d0	 mov	 rdx, rax
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0001a	e8 00 00 00 00	 call	 _Py_HashBytes

; 2766 : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
generic_hash ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_toordinal DD imagerel date_toordinal
	DD	imagerel date_toordinal+84
	DD	imagerel $unwind$date_toordinal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_toordinal DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_toordinal
_TEXT	SEGMENT
tv81 = 32
self$ = 64
date_toordinal PROC					; COMDAT

; 2783 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2784 :     return PyLong_FromLong(ymd_to_ord(GET_YEAR(self), GET_MONTH(self),
; 2785 :                                      GET_DAY(self)));

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00017	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  0001b	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  00020	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  00024	c1 e2 08	 shl	 edx, 8
  00027	4c 8b 44 24 40	 mov	 r8, QWORD PTR self$[rsp]
  0002c	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  00031	41 0b d0	 or	 edx, r8d
  00034	89 54 24 20	 mov	 DWORD PTR tv81[rsp], edx
  00038	44 8b c0	 mov	 r8d, eax
  0003b	8b d1		 mov	 edx, ecx
  0003d	8b 44 24 20	 mov	 eax, DWORD PTR tv81[rsp]
  00041	8b c8		 mov	 ecx, eax
  00043	e8 00 00 00 00	 call	 ymd_to_ord
  00048	8b c8		 mov	 ecx, eax
  0004a	e8 00 00 00 00	 call	 PyLong_FromLong

; 2786 : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
date_toordinal ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_weekday DD imagerel date_weekday
	DD	imagerel date_weekday+90
	DD	imagerel $unwind$date_weekday
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_weekday DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT date_weekday
_TEXT	SEGMENT
dow$ = 32
tv80 = 36
self$ = 64
date_weekday PROC					; COMDAT

; 2790 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2791 :     int dow = weekday(GET_YEAR(self), GET_MONTH(self), GET_DAY(self));

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00017	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  0001b	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  00020	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  00024	c1 e2 08	 shl	 edx, 8
  00027	4c 8b 44 24 40	 mov	 r8, QWORD PTR self$[rsp]
  0002c	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  00031	41 0b d0	 or	 edx, r8d
  00034	89 54 24 24	 mov	 DWORD PTR tv80[rsp], edx
  00038	44 8b c0	 mov	 r8d, eax
  0003b	8b d1		 mov	 edx, ecx
  0003d	8b 44 24 24	 mov	 eax, DWORD PTR tv80[rsp]
  00041	8b c8		 mov	 ecx, eax
  00043	e8 00 00 00 00	 call	 weekday
  00048	89 44 24 20	 mov	 DWORD PTR dow$[rsp], eax

; 2792 : 
; 2793 :     return PyLong_FromLong(dow);

  0004c	8b 4c 24 20	 mov	 ecx, DWORD PTR dow$[rsp]
  00050	e8 00 00 00 00	 call	 PyLong_FromLong

; 2794 : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
date_weekday ENDP
_TEXT	ENDS
PUBLIC	??_C@_04DFFJBLGN@?$CION?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_reduce DD imagerel date_reduce
	DD	imagerel date_reduce+53
	DD	imagerel $unwind$date_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_reduce DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_04DFFJBLGN@?$CION?$CJ?$AA@
CONST	SEGMENT
??_C@_04DFFJBLGN@?$CION?$CJ?$AA@ DB '(ON)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT date_reduce
_TEXT	SEGMENT
self$ = 48
arg$ = 56
date_reduce PROC					; COMDAT

; 2810 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2811 :     return Py_BuildValue("(ON)", Py_TYPE(self), date_getstate(self));

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 date_getstate
  00018	4c 8b c0	 mov	 r8, rax
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DFFJBLGN@?$CION?$CJ?$AA@
  0002b	e8 00 00 00 00	 call	 Py_BuildValue

; 2812 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
date_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$date_getstate DD imagerel date_getstate
	DD	imagerel date_getstate+58
	DD	imagerel $unwind$date_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$date_getstate DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@
CONST	SEGMENT
??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@ DB '(N)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT date_getstate
_TEXT	SEGMENT
field$ = 32
self$ = 64
date_getstate PROC					; COMDAT

; 2801 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2802 :     PyObject* field;
; 2803 :     field = PyBytes_FromStringAndSize((char*)self->data,
; 2804 :                                        _PyDateTime_DATE_DATASIZE);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 c0 69	 add	 rax, 105		; 00000069H
  00012	ba 04 00 00 00	 mov	 edx, 4
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0001f	48 89 44 24 20	 mov	 QWORD PTR field$[rsp], rax

; 2805 :     return Py_BuildValue("(N)", field);

  00024	48 8b 54 24 20	 mov	 rdx, QWORD PTR field$[rsp]
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IFHPJIBD@?$CIN?$CJ?$AA@
  00030	e8 00 00 00 00	 call	 Py_BuildValue

; 2806 : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
date_getstate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$tzinfo_tzname DD imagerel tzinfo_tzname
	DD	imagerel tzinfo_tzname+31
	DD	imagerel $unwind$tzinfo_tzname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tzinfo_tzname DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT tzinfo_tzname
_TEXT	SEGMENT
self$ = 48
dt$ = 56
tzinfo_tzname PROC					; COMDAT

; 2962 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2963 :     return tzinfo_nogo("tzname");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06CNBAGEMF@tzname?$AA@
  00015	e8 00 00 00 00	 call	 tzinfo_nogo

; 2964 : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
tzinfo_tzname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@BIJFOKGF@a?5tzinfo?5subclass?5must?5implement@ ; `string'
EXTRN	PyExc_NotImplementedError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$tzinfo_nogo DD imagerel tzinfo_nogo
	DD	imagerel tzinfo_nogo+40
	DD	imagerel $unwind$tzinfo_nogo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tzinfo_nogo DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0CG@BIJFOKGF@a?5tzinfo?5subclass?5must?5implement@
CONST	SEGMENT
??_C@_0CG@BIJFOKGF@a?5tzinfo?5subclass?5must?5implement@ DB 'a tzinfo sub'
	DB	'class must implement %s()', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tzinfo_nogo
_TEXT	SEGMENT
methodname$ = 48
tzinfo_nogo PROC					; COMDAT

; 2951 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2952 :     PyErr_Format(PyExc_NotImplementedError,
; 2953 :                  "a tzinfo subclass must implement %s()",
; 2954 :                  methodname);

  00009	4c 8b 44 24 30	 mov	 r8, QWORD PTR methodname$[rsp]
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@BIJFOKGF@a?5tzinfo?5subclass?5must?5implement@
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  0001c	e8 00 00 00 00	 call	 PyErr_Format

; 2955 :     return NULL;

  00021	33 c0		 xor	 eax, eax

; 2956 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
tzinfo_nogo ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$tzinfo_utcoffset DD imagerel tzinfo_utcoffset
	DD	imagerel tzinfo_utcoffset+31
	DD	imagerel $unwind$tzinfo_utcoffset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tzinfo_utcoffset DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT tzinfo_utcoffset
_TEXT	SEGMENT
self$ = 48
dt$ = 56
tzinfo_utcoffset PROC					; COMDAT

; 2968 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2969 :     return tzinfo_nogo("utcoffset");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
  00015	e8 00 00 00 00	 call	 tzinfo_nogo

; 2970 : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
tzinfo_utcoffset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$tzinfo_dst DD imagerel tzinfo_dst
	DD	imagerel tzinfo_dst+31
	DD	imagerel $unwind$tzinfo_dst
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tzinfo_dst DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT tzinfo_dst
_TEXT	SEGMENT
self$ = 48
dt$ = 56
tzinfo_dst PROC						; COMDAT

; 2974 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2975 :     return tzinfo_nogo("dst");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03HHBLCKEM@dst?$AA@
  00015	e8 00 00 00 00	 call	 tzinfo_nogo

; 2976 : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
tzinfo_dst ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DL@LEKGAOEA@fromutc?3?5tz?4dst?$CI?$CJ?5gaveinconsiste@ ; `string'
PUBLIC	??_C@_0CI@HGDFKND@fromutc?3?5non?9None?5dst?$CI?$CJ?5result?5r@ ; `string'
PUBLIC	??_C@_0CO@FIKJNFDM@fromutc?3?5non?9None?5utcoffset?$CI?$CJ?5re@ ; `string'
PUBLIC	??_C@_0BP@GGFFFAGL@fromutc?3?5dt?4tzinfo?5is?5not?5self?$AA@ ; `string'
PUBLIC	??_C@_0CF@OKCHMBGC@fromutc?3?5argument?5must?5be?5a?5date@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$tzinfo_fromutc DD imagerel tzinfo_fromutc
	DD	imagerel tzinfo_fromutc+737
	DD	imagerel $unwind$tzinfo_fromutc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tzinfo_fromutc DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0DL@LEKGAOEA@fromutc?3?5tz?4dst?$CI?$CJ?5gaveinconsiste@
CONST	SEGMENT
??_C@_0DL@LEKGAOEA@fromutc?3?5tz?4dst?$CI?$CJ?5gaveinconsiste@ DB 'fromut'
	DB	'c: tz.dst() gaveinconsistent results; cannot convert', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HGDFKND@fromutc?3?5non?9None?5dst?$CI?$CJ?5result?5r@
CONST	SEGMENT
??_C@_0CI@HGDFKND@fromutc?3?5non?9None?5dst?$CI?$CJ?5result?5r@ DB 'fromu'
	DB	'tc: non-None dst() result required', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@FIKJNFDM@fromutc?3?5non?9None?5utcoffset?$CI?$CJ?5re@
CONST	SEGMENT
??_C@_0CO@FIKJNFDM@fromutc?3?5non?9None?5utcoffset?$CI?$CJ?5re@ DB 'fromu'
	DB	'tc: non-None utcoffset() result required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@GGFFFAGL@fromutc?3?5dt?4tzinfo?5is?5not?5self?$AA@
CONST	SEGMENT
??_C@_0BP@GGFFFAGL@fromutc?3?5dt?4tzinfo?5is?5not?5self?$AA@ DB 'fromutc:'
	DB	' dt.tzinfo is not self', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OKCHMBGC@fromutc?3?5argument?5must?5be?5a?5date@
CONST	SEGMENT
??_C@_0CF@OKCHMBGC@fromutc?3?5argument?5must?5be?5a?5date@ DB 'fromutc: a'
	DB	'rgument must be a datetime', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tzinfo_fromutc
_TEXT	SEGMENT
dst$ = 32
off$ = 40
delta$ = 48
result$ = 56
temp$22993 = 64
tv77 = 72
tv143 = 80
self$ = 112
dt$ = 120
tzinfo_fromutc PROC					; COMDAT

; 2987 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2988 :     PyObject *result = NULL;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 2989 :     PyObject *off = NULL, *dst = NULL;

  00017	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR off$[rsp], 0
  00020	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR dst$[rsp], 0

; 2990 :     PyDateTime_Delta *delta = NULL;

  00029	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR delta$[rsp], 0

; 2991 : 
; 2992 :     if (!PyDateTime_Check(dt)) {

  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00039	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dt$[rsp]
  0003e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00042	74 33		 je	 SHORT $LN28@tzinfo_fro
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  0004b	48 8b 44 24 78	 mov	 rax, QWORD PTR dt$[rsp]
  00050	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00054	e8 00 00 00 00	 call	 PyType_IsSubtype
  00059	85 c0		 test	 eax, eax
  0005b	75 1a		 jne	 SHORT $LN28@tzinfo_fro

; 2993 :         PyErr_SetString(PyExc_TypeError,
; 2994 :                         "fromutc: argument must be a datetime");

  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@OKCHMBGC@fromutc?3?5argument?5must?5be?5a?5date@
  00064	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0006b	e8 00 00 00 00	 call	 PyErr_SetString

; 2995 :         return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	e9 65 02 00 00	 jmp	 $LN29@tzinfo_fro
$LN28@tzinfo_fro:

; 2996 :     }
; 2997 :     if (GET_DT_TZINFO(dt) != (PyObject *)self) {

  00077	48 8b 44 24 78	 mov	 rax, QWORD PTR dt$[rsp]
  0007c	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00080	85 c0		 test	 eax, eax
  00082	74 10		 je	 SHORT $LN31@tzinfo_fro
  00084	48 8b 44 24 78	 mov	 rax, QWORD PTR dt$[rsp]
  00089	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0008d	48 89 44 24 48	 mov	 QWORD PTR tv77[rsp], rax
  00092	eb 0c		 jmp	 SHORT $LN32@tzinfo_fro
$LN31@tzinfo_fro:
  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0009b	48 89 44 24 48	 mov	 QWORD PTR tv77[rsp], rax
$LN32@tzinfo_fro:
  000a0	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000a5	48 39 44 24 48	 cmp	 QWORD PTR tv77[rsp], rax
  000aa	74 1a		 je	 SHORT $LN27@tzinfo_fro

; 2998 :         PyErr_SetString(PyExc_ValueError, "fromutc: dt.tzinfo "
; 2999 :                         "is not self");

  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@GGFFFAGL@fromutc?3?5dt?4tzinfo?5is?5not?5self?$AA@
  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ba	e8 00 00 00 00	 call	 PyErr_SetString

; 3000 :         return NULL;

  000bf	33 c0		 xor	 eax, eax
  000c1	e9 16 02 00 00	 jmp	 $LN29@tzinfo_fro
$LN27@tzinfo_fro:

; 3001 :     }
; 3002 : 
; 3003 :     off = datetime_utcoffset(dt, NULL);

  000c6	33 d2		 xor	 edx, edx
  000c8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dt$[rsp]
  000cd	e8 00 00 00 00	 call	 datetime_utcoffset
  000d2	48 89 44 24 28	 mov	 QWORD PTR off$[rsp], rax

; 3004 :     if (off == NULL)

  000d7	48 83 7c 24 28
	00		 cmp	 QWORD PTR off$[rsp], 0
  000dd	75 07		 jne	 SHORT $LN26@tzinfo_fro

; 3005 :         return NULL;

  000df	33 c0		 xor	 eax, eax
  000e1	e9 f6 01 00 00	 jmp	 $LN29@tzinfo_fro
$LN26@tzinfo_fro:

; 3006 :     if (off == Py_None) {

  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ed	48 39 44 24 28	 cmp	 QWORD PTR off$[rsp], rax
  000f2	75 18		 jne	 SHORT $LN25@tzinfo_fro

; 3007 :         PyErr_SetString(PyExc_ValueError, "fromutc: non-None "
; 3008 :                         "utcoffset() result required");

  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@FIKJNFDM@fromutc?3?5non?9None?5utcoffset?$CI?$CJ?5re@
  000fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00102	e8 00 00 00 00	 call	 PyErr_SetString

; 3009 :         goto Fail;

  00107	e9 6e 01 00 00	 jmp	 $Fail$22973
$LN25@tzinfo_fro:

; 3010 :     }
; 3011 : 
; 3012 :     dst = datetime_dst(dt, NULL);

  0010c	33 d2		 xor	 edx, edx
  0010e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dt$[rsp]
  00113	e8 00 00 00 00	 call	 datetime_dst
  00118	48 89 44 24 20	 mov	 QWORD PTR dst$[rsp], rax

; 3013 :     if (dst == NULL)

  0011d	48 83 7c 24 20
	00		 cmp	 QWORD PTR dst$[rsp], 0
  00123	75 05		 jne	 SHORT $LN24@tzinfo_fro

; 3014 :         goto Fail;

  00125	e9 50 01 00 00	 jmp	 $Fail$22973
$LN24@tzinfo_fro:

; 3015 :     if (dst == Py_None) {

  0012a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00131	48 39 44 24 20	 cmp	 QWORD PTR dst$[rsp], rax
  00136	75 18		 jne	 SHORT $LN23@tzinfo_fro

; 3016 :         PyErr_SetString(PyExc_ValueError, "fromutc: non-None "
; 3017 :                         "dst() result required");

  00138	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@HGDFKND@fromutc?3?5non?9None?5dst?$CI?$CJ?5result?5r@
  0013f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00146	e8 00 00 00 00	 call	 PyErr_SetString

; 3018 :         goto Fail;

  0014b	e9 2a 01 00 00	 jmp	 $Fail$22973
$LN23@tzinfo_fro:

; 3019 :     }
; 3020 : 
; 3021 :     delta = (PyDateTime_Delta *)delta_subtract(off, dst);

  00150	48 8b 54 24 20	 mov	 rdx, QWORD PTR dst$[rsp]
  00155	48 8b 4c 24 28	 mov	 rcx, QWORD PTR off$[rsp]
  0015a	e8 00 00 00 00	 call	 delta_subtract
  0015f	48 89 44 24 30	 mov	 QWORD PTR delta$[rsp], rax

; 3022 :     if (delta == NULL)

  00164	48 83 7c 24 30
	00		 cmp	 QWORD PTR delta$[rsp], 0
  0016a	75 05		 jne	 SHORT $LN22@tzinfo_fro

; 3023 :         goto Fail;

  0016c	e9 09 01 00 00	 jmp	 $Fail$22973
$LN22@tzinfo_fro:

; 3024 :     result = add_datetime_timedelta((PyDateTime_DateTime *)dt, delta, 1);

  00171	41 b8 01 00 00
	00		 mov	 r8d, 1
  00177	48 8b 54 24 30	 mov	 rdx, QWORD PTR delta$[rsp]
  0017c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dt$[rsp]
  00181	e8 00 00 00 00	 call	 add_datetime_timedelta
  00186	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 3025 :     if (result == NULL)

  0018b	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  00191	75 05		 jne	 SHORT $LN21@tzinfo_fro

; 3026 :         goto Fail;

  00193	e9 e2 00 00 00	 jmp	 $Fail$22973
$LN21@tzinfo_fro:

; 3027 : 
; 3028 :     Py_DECREF(dst);

  00198	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dst$[rsp]
  0019d	e8 00 00 00 00	 call	 _Py_DecRef

; 3029 :     dst = call_dst(GET_DT_TZINFO(dt), result);

  001a2	48 8b 44 24 78	 mov	 rax, QWORD PTR dt$[rsp]
  001a7	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  001ab	85 c0		 test	 eax, eax
  001ad	74 10		 je	 SHORT $LN33@tzinfo_fro
  001af	48 8b 44 24 78	 mov	 rax, QWORD PTR dt$[rsp]
  001b4	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  001b8	48 89 44 24 50	 mov	 QWORD PTR tv143[rsp], rax
  001bd	eb 0c		 jmp	 SHORT $LN34@tzinfo_fro
$LN33@tzinfo_fro:
  001bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001c6	48 89 44 24 50	 mov	 QWORD PTR tv143[rsp], rax
$LN34@tzinfo_fro:
  001cb	48 8b 54 24 38	 mov	 rdx, QWORD PTR result$[rsp]
  001d0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv143[rsp]
  001d5	e8 00 00 00 00	 call	 call_dst
  001da	48 89 44 24 20	 mov	 QWORD PTR dst$[rsp], rax

; 3030 :     if (dst == NULL)

  001df	48 83 7c 24 20
	00		 cmp	 QWORD PTR dst$[rsp], 0
  001e5	75 05		 jne	 SHORT $LN20@tzinfo_fro

; 3031 :         goto Fail;

  001e7	e9 8e 00 00 00	 jmp	 $Fail$22973
$LN20@tzinfo_fro:

; 3032 :     if (dst == Py_None)

  001ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001f3	48 39 44 24 20	 cmp	 QWORD PTR dst$[rsp], rax
  001f8	75 02		 jne	 SHORT $LN19@tzinfo_fro

; 3033 :         goto Inconsistent;

  001fa	eb 6b		 jmp	 SHORT $Inconsistent$22991
$LN19@tzinfo_fro:

; 3034 :     if (delta_bool(delta) != 0) {

  001fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delta$[rsp]
  00201	e8 00 00 00 00	 call	 delta_bool
  00206	85 c0		 test	 eax, eax
  00208	74 38		 je	 SHORT $LN18@tzinfo_fro

; 3035 :         PyObject *temp = result;

  0020a	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  0020f	48 89 44 24 40	 mov	 QWORD PTR temp$22993[rsp], rax

; 3036 :         result = add_datetime_timedelta((PyDateTime_DateTime *)result,
; 3037 :                                         (PyDateTime_Delta *)dst, 1);

  00214	41 b8 01 00 00
	00		 mov	 r8d, 1
  0021a	48 8b 54 24 20	 mov	 rdx, QWORD PTR dst$[rsp]
  0021f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  00224	e8 00 00 00 00	 call	 add_datetime_timedelta
  00229	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 3038 :         Py_DECREF(temp);

  0022e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR temp$22993[rsp]
  00233	e8 00 00 00 00	 call	 _Py_DecRef

; 3039 :         if (result == NULL)

  00238	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  0023e	75 02		 jne	 SHORT $LN17@tzinfo_fro

; 3040 :             goto Fail;

  00240	eb 38		 jmp	 SHORT $Fail$22973
$LN17@tzinfo_fro:
$LN18@tzinfo_fro:

; 3041 :     }
; 3042 :     Py_DECREF(delta);

  00242	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delta$[rsp]
  00247	e8 00 00 00 00	 call	 _Py_DecRef

; 3043 :     Py_DECREF(dst);

  0024c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dst$[rsp]
  00251	e8 00 00 00 00	 call	 _Py_DecRef

; 3044 :     Py_DECREF(off);

  00256	48 8b 4c 24 28	 mov	 rcx, QWORD PTR off$[rsp]
  0025b	e8 00 00 00 00	 call	 _Py_DecRef

; 3045 :     return result;

  00260	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  00265	eb 75		 jmp	 SHORT $LN29@tzinfo_fro
$Inconsistent$22991:

; 3046 : 
; 3047 : Inconsistent:
; 3048 :     PyErr_SetString(PyExc_ValueError, "fromutc: tz.dst() gave"
; 3049 :                     "inconsistent results; cannot convert");

  00267	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@LEKGAOEA@fromutc?3?5tz?4dst?$CI?$CJ?5gaveinconsiste@
  0026e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00275	e8 00 00 00 00	 call	 PyErr_SetString
$Fail$22973:
$LN16@tzinfo_fro:

; 3050 : 
; 3051 :     /* fall thru to failure */
; 3052 : Fail:
; 3053 :     Py_XDECREF(off);

  0027a	48 83 7c 24 28
	00		 cmp	 QWORD PTR off$[rsp], 0
  00280	74 0a		 je	 SHORT $LN13@tzinfo_fro
  00282	48 8b 4c 24 28	 mov	 rcx, QWORD PTR off$[rsp]
  00287	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@tzinfo_fro:
  0028c	33 c0		 xor	 eax, eax
  0028e	85 c0		 test	 eax, eax
  00290	75 e8		 jne	 SHORT $LN16@tzinfo_fro
$LN12@tzinfo_fro:

; 3054 :     Py_XDECREF(dst);

  00292	48 83 7c 24 20
	00		 cmp	 QWORD PTR dst$[rsp], 0
  00298	74 0a		 je	 SHORT $LN9@tzinfo_fro
  0029a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dst$[rsp]
  0029f	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@tzinfo_fro:
  002a4	33 c0		 xor	 eax, eax
  002a6	85 c0		 test	 eax, eax
  002a8	75 e8		 jne	 SHORT $LN12@tzinfo_fro
$LN8@tzinfo_fro:

; 3055 :     Py_XDECREF(delta);

  002aa	48 83 7c 24 30
	00		 cmp	 QWORD PTR delta$[rsp], 0
  002b0	74 0a		 je	 SHORT $LN5@tzinfo_fro
  002b2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR delta$[rsp]
  002b7	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@tzinfo_fro:
  002bc	33 c0		 xor	 eax, eax
  002be	85 c0		 test	 eax, eax
  002c0	75 e8		 jne	 SHORT $LN8@tzinfo_fro
$LN4@tzinfo_fro:

; 3056 :     Py_XDECREF(result);

  002c2	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  002c8	74 0a		 je	 SHORT $LN1@tzinfo_fro
  002ca	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  002cf	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@tzinfo_fro:
  002d4	33 c0		 xor	 eax, eax
  002d6	85 c0		 test	 eax, eax
  002d8	75 e8		 jne	 SHORT $LN4@tzinfo_fro

; 3057 :     return NULL;

  002da	33 c0		 xor	 eax, eax
$LN29@tzinfo_fro:

; 3058 : }

  002dc	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002e0	c3		 ret	 0
tzinfo_fromutc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_dst DD imagerel call_dst
	DD	imagerel call_dst+41
	DD	imagerel $unwind$call_dst
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_dst DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT call_dst
_TEXT	SEGMENT
tzinfo$ = 48
tzinfoarg$ = 56
call_dst PROC						; COMDAT

; 937  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 938  :     return call_tzinfo_method(tzinfo, "dst", tzinfoarg);

  0000e	4c 8b 44 24 38	 mov	 r8, QWORD PTR tzinfoarg$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03HHBLCKEM@dst?$AA@
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  0001f	e8 00 00 00 00	 call	 call_tzinfo_method

; 939  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
call_dst ENDP
_TEXT	ENDS
PUBLIC	??_C@_05DKOIAGLA@?$CIONN?$CJ?$AA@		; `string'
EXTRN	PyDict_Size:PROC
EXTRN	_PyObject_GetDictPtr:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyObject_CallObject:PROC
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	PyTuple_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tzinfo_reduce DD imagerel tzinfo_reduce
	DD	imagerel tzinfo_reduce+481
	DD	imagerel $unwind$tzinfo_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tzinfo_reduce DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_05DKOIAGLA@?$CIONN?$CJ?$AA@
CONST	SEGMENT
??_C@_05DKOIAGLA@?$CIONN?$CJ?$AA@ DB '(ONN)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tzinfo_reduce
_TEXT	SEGMENT
args$ = 32
getstate$ = 40
getinitargs$ = 48
tmp$ = 56
state$ = 64
dictptr$23060 = 72
self$ = 96
tzinfo_reduce PROC					; COMDAT

; 3067 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3068 :     PyObject *args, *state, *tmp;
; 3069 :     PyObject *getinitargs, *getstate;
; 3070 :     _Py_IDENTIFIER(__getinitargs__);
; 3071 :     _Py_IDENTIFIER(__getstate__);
; 3072 : 
; 3073 :     tmp = PyTuple_New(0);

  00009	33 c9		 xor	 ecx, ecx
  0000b	e8 00 00 00 00	 call	 PyTuple_New
  00010	48 89 44 24 38	 mov	 QWORD PTR tmp$[rsp], rax

; 3074 :     if (tmp == NULL)

  00015	48 83 7c 24 38
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0001b	75 07		 jne	 SHORT $LN10@tzinfo_red

; 3075 :         return NULL;

  0001d	33 c0		 xor	 eax, eax
  0001f	e9 b8 01 00 00	 jmp	 $LN11@tzinfo_red
$LN10@tzinfo_red:

; 3076 : 
; 3077 :     getinitargs = _PyObject_GetAttrId(self, &PyId___getinitargs__);

  00024	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___getinitargs__@?1??tzinfo_reduce@@9@9
  00029	8b c0		 mov	 eax, eax
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00031	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0003a	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0003e	48 8b d0	 mov	 rdx, rax
  00041	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00046	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0004b	48 89 44 24 30	 mov	 QWORD PTR getinitargs$[rsp], rax

; 3078 :     if (getinitargs != NULL) {

  00050	48 83 7c 24 30
	00		 cmp	 QWORD PTR getinitargs$[rsp], 0
  00056	74 39		 je	 SHORT $LN9@tzinfo_red

; 3079 :         args = PyObject_CallObject(getinitargs, tmp);

  00058	48 8b 54 24 38	 mov	 rdx, QWORD PTR tmp$[rsp]
  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR getinitargs$[rsp]
  00062	e8 00 00 00 00	 call	 PyObject_CallObject
  00067	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 3080 :         Py_DECREF(getinitargs);

  0006c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR getinitargs$[rsp]
  00071	e8 00 00 00 00	 call	 _Py_DecRef

; 3081 :         if (args == NULL) {

  00076	48 83 7c 24 20
	00		 cmp	 QWORD PTR args$[rsp], 0
  0007c	75 11		 jne	 SHORT $LN8@tzinfo_red

; 3082 :             Py_DECREF(tmp);

  0007e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tmp$[rsp]
  00083	e8 00 00 00 00	 call	 _Py_DecRef

; 3083 :             return NULL;

  00088	33 c0		 xor	 eax, eax
  0008a	e9 4d 01 00 00	 jmp	 $LN11@tzinfo_red
$LN8@tzinfo_red:

; 3084 :         }
; 3085 :     }
; 3086 :     else {

  0008f	eb 19		 jmp	 SHORT $LN7@tzinfo_red
$LN9@tzinfo_red:

; 3087 :         PyErr_Clear();

  00091	e8 00 00 00 00	 call	 PyErr_Clear

; 3088 :         args = tmp;

  00096	48 8b 44 24 38	 mov	 rax, QWORD PTR tmp$[rsp]
  0009b	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 3089 :         Py_INCREF(args);

  000a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  000a5	e8 00 00 00 00	 call	 _Py_IncRef
$LN7@tzinfo_red:

; 3090 :     }
; 3091 : 
; 3092 :     getstate = _PyObject_GetAttrId(self, &PyId___getstate__);

  000aa	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___getstate__@?1??tzinfo_reduce@@9@9
  000af	8b c0		 mov	 eax, eax
  000b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000b7	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000c0	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000c4	48 8b d0	 mov	 rdx, rax
  000c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000cc	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  000d1	48 89 44 24 28	 mov	 QWORD PTR getstate$[rsp], rax

; 3093 :     if (getstate != NULL) {

  000d6	48 83 7c 24 28
	00		 cmp	 QWORD PTR getstate$[rsp], 0
  000dc	74 43		 je	 SHORT $LN6@tzinfo_red

; 3094 :         state = PyObject_CallObject(getstate, tmp);

  000de	48 8b 54 24 38	 mov	 rdx, QWORD PTR tmp$[rsp]
  000e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR getstate$[rsp]
  000e8	e8 00 00 00 00	 call	 PyObject_CallObject
  000ed	48 89 44 24 40	 mov	 QWORD PTR state$[rsp], rax

; 3095 :         Py_DECREF(getstate);

  000f2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR getstate$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_DecRef

; 3096 :         if (state == NULL) {

  000fc	48 83 7c 24 40
	00		 cmp	 QWORD PTR state$[rsp], 0
  00102	75 1b		 jne	 SHORT $LN5@tzinfo_red

; 3097 :             Py_DECREF(args);

  00104	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  00109	e8 00 00 00 00	 call	 _Py_DecRef

; 3098 :             Py_DECREF(tmp);

  0010e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tmp$[rsp]
  00113	e8 00 00 00 00	 call	 _Py_DecRef

; 3099 :             return NULL;

  00118	33 c0		 xor	 eax, eax
  0011a	e9 bd 00 00 00	 jmp	 $LN11@tzinfo_red
$LN5@tzinfo_red:

; 3100 :         }
; 3101 :     }
; 3102 :     else {

  0011f	eb 5c		 jmp	 SHORT $LN4@tzinfo_red
$LN6@tzinfo_red:

; 3103 :         PyObject **dictptr;
; 3104 :         PyErr_Clear();

  00121	e8 00 00 00 00	 call	 PyErr_Clear

; 3105 :         state = Py_None;

  00126	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0012d	48 89 44 24 40	 mov	 QWORD PTR state$[rsp], rax

; 3106 :         dictptr = _PyObject_GetDictPtr(self);

  00132	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00137	e8 00 00 00 00	 call	 _PyObject_GetDictPtr
  0013c	48 89 44 24 48	 mov	 QWORD PTR dictptr$23060[rsp], rax

; 3107 :         if (dictptr && *dictptr && PyDict_Size(*dictptr))

  00141	48 83 7c 24 48
	00		 cmp	 QWORD PTR dictptr$23060[rsp], 0
  00147	74 2a		 je	 SHORT $LN3@tzinfo_red
  00149	48 8b 44 24 48	 mov	 rax, QWORD PTR dictptr$23060[rsp]
  0014e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00152	74 1f		 je	 SHORT $LN3@tzinfo_red
  00154	48 8b 44 24 48	 mov	 rax, QWORD PTR dictptr$23060[rsp]
  00159	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0015c	e8 00 00 00 00	 call	 PyDict_Size
  00161	48 85 c0	 test	 rax, rax
  00164	74 0d		 je	 SHORT $LN3@tzinfo_red

; 3108 :             state = *dictptr;

  00166	48 8b 44 24 48	 mov	 rax, QWORD PTR dictptr$23060[rsp]
  0016b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0016e	48 89 44 24 40	 mov	 QWORD PTR state$[rsp], rax
$LN3@tzinfo_red:

; 3109 :         Py_INCREF(state);

  00173	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00178	e8 00 00 00 00	 call	 _Py_IncRef
$LN4@tzinfo_red:

; 3110 :     }
; 3111 : 
; 3112 :     Py_DECREF(tmp);

  0017d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tmp$[rsp]
  00182	e8 00 00 00 00	 call	 _Py_DecRef

; 3113 : 
; 3114 :     if (state == Py_None) {

  00187	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0018e	48 39 44 24 40	 cmp	 QWORD PTR state$[rsp], rax
  00193	75 28		 jne	 SHORT $LN2@tzinfo_red

; 3115 :         Py_DECREF(state);

  00195	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  0019a	e8 00 00 00 00	 call	 _Py_DecRef

; 3116 :         return Py_BuildValue("(ON)", Py_TYPE(self), args);

  0019f	4c 8b 44 24 20	 mov	 r8, QWORD PTR args$[rsp]
  001a4	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001a9	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  001ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DFFJBLGN@?$CION?$CJ?$AA@
  001b4	e8 00 00 00 00	 call	 Py_BuildValue
  001b9	eb 21		 jmp	 SHORT $LN11@tzinfo_red

; 3117 :     }
; 3118 :     else

  001bb	eb 1f		 jmp	 SHORT $LN1@tzinfo_red
$LN2@tzinfo_red:

; 3119 :         return Py_BuildValue("(ONN)", Py_TYPE(self), args, state);

  001bd	4c 8b 4c 24 40	 mov	 r9, QWORD PTR state$[rsp]
  001c2	4c 8b 44 24 20	 mov	 r8, QWORD PTR args$[rsp]
  001c7	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001cc	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  001d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05DKOIAGLA@?$CIONN?$CJ?$AA@
  001d7	e8 00 00 00 00	 call	 Py_BuildValue
$LN1@tzinfo_red:
$LN11@tzinfo_red:

; 3120 : }

  001dc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e0	c3		 ret	 0
tzinfo_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@OGBJIODI@O?$CB?$HMO?$CB?3timezone?$AA@	; `string'
EXTRN	PyUnicode_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_new DD imagerel timezone_new
	DD	imagerel timezone_new+129
	DD	imagerel $unwind$timezone_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_new DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0P@OGBJIODI@O?$CB?$HMO?$CB?3timezone?$AA@
CONST	SEGMENT
??_C@_0P@OGBJIODI@O?$CB?$HMO?$CB?3timezone?$AA@ DB 'O!|O!:timezone', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT timezone_new
_TEXT	SEGMENT
name$ = 64
offset$ = 72
type$ = 96
args$ = 104
kw$ = 112
timezone_new PROC					; COMDAT

; 3192 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3193 :     PyObject *offset;
; 3194 :     PyObject *name = NULL;

  00013	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR name$[rsp], 0

; 3195 :     if (PyArg_ParseTupleAndKeywords(args, kw, "O!|O!:timezone", timezone_kws,
; 3196 :                                     &PyDateTime_DeltaType, &offset,
; 3197 :                                     &PyUnicode_Type, &name))

  0001c	48 8d 44 24 40	 lea	 rax, QWORD PTR name$[rsp]
  00021	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyUnicode_Type
  0002d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00032	48 8d 44 24 48	 lea	 rax, QWORD PTR offset$[rsp]
  00037	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00043	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00048	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:timezone_kws
  0004f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@OGBJIODI@O?$CB?$HMO?$CB?3timezone?$AA@
  00056	48 8b 54 24 70	 mov	 rdx, QWORD PTR kw$[rsp]
  0005b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00060	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00065	85 c0		 test	 eax, eax
  00067	74 11		 je	 SHORT $LN1@timezone_n

; 3198 :         return new_timezone(offset, name);

  00069	48 8b 54 24 40	 mov	 rdx, QWORD PTR name$[rsp]
  0006e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offset$[rsp]
  00073	e8 00 00 00 00	 call	 new_timezone
  00078	eb 02		 jmp	 SHORT $LN2@timezone_n
$LN1@timezone_n:

; 3199 : 
; 3200 :     return NULL;

  0007a	33 c0		 xor	 eax, eax
$LN2@timezone_n:

; 3201 : }

  0007c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00080	c3		 ret	 0
timezone_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0GC@LAOOJPDN@offset?5must?5be?5a?5timedelta?5stric@ ; `string'
PUBLIC	??_C@_0EL@EMKHHDPF@offset?5must?5be?5a?5timedelta?5repre@ ; `string'
PUBLIC	??_C@_1EM@MJHOHJKH@?$AAn?$AAa?$AAm?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI@ ; `string'
PUBLIC	??_C@_1CM@HCBLKHBO@?$AAP?$AAy?$AAD?$AAe?$AAl?$AAt?$AAa?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@CPCGGCE@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
_BSS	SEGMENT
PyDateTime_TimeZone_UTC DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_timezone DD imagerel new_timezone
	DD	imagerel new_timezone+380
	DD	imagerel $unwind$new_timezone
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_timezone DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0GC@LAOOJPDN@offset?5must?5be?5a?5timedelta?5stric@
CONST	SEGMENT
??_C@_0GC@LAOOJPDN@offset?5must?5be?5a?5timedelta?5stric@ DB 'offset must'
	DB	' be a timedelta strictly between -timedelta(hours=24) and tim'
	DB	'edelta(hours=24), not %R.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@EMKHHDPF@offset?5must?5be?5a?5timedelta?5repre@
CONST	SEGMENT
??_C@_0EL@EMKHHDPF@offset?5must?5be?5a?5timedelta?5repre@ DB 'offset must'
	DB	' be a timedelta representing a whole number of minutes, not %'
	DB	'R.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@MJHOHJKH@?$AAn?$AAa?$AAm?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI@
CONST	SEGMENT
??_C@_1EM@MJHOHJKH@?$AAn?$AAa?$AAm?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI@ DB 'n'
	DB	00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H
	DB	'i', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'C'
	DB	00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'n', 00H
	DB	'a', 00H, 'm', 00H, 'e', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@HCBLKHBO@?$AAP?$AAy?$AAD?$AAe?$AAl?$AAt?$AAa?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@HCBLKHBO@?$AAP?$AAy?$AAD?$AAe?$AAl?$AAt?$AAa?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'D', 00H, 'e', 00H, 'l', 00H, 't', 00H, 'a', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'o', 00H, 'f', 00H, 'f', 00H, 's', 00H, 'e', 00H, 't', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@CPCGGCE@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@CPCGGCE@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'o'
	DB	00H, 'f', 00H, 'f', 00H, 's', 00H, 'e', 00H, 't', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT new_timezone
_TEXT	SEGMENT
offset$ = 48
name$ = 56
new_timezone PROC					; COMDAT

; 801  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 802  :     assert(offset != NULL);

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR offset$[rsp], 0
  00014	75 1c		 jne	 SHORT $LN9@new_timezo
  00016	41 b8 22 03 00
	00		 mov	 r8d, 802		; 00000322H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@CPCGGCE@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00030	33 c0		 xor	 eax, eax
$LN9@new_timezo:

; 803  :     assert(PyDelta_Check(offset));

  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR offset$[rsp]
  0003e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00042	74 35		 je	 SHORT $LN10@new_timezo
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR offset$[rsp]
  00050	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00054	e8 00 00 00 00	 call	 PyType_IsSubtype
  00059	85 c0		 test	 eax, eax
  0005b	75 1c		 jne	 SHORT $LN10@new_timezo
  0005d	41 b8 23 03 00
	00		 mov	 r8d, 803		; 00000323H
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@HCBLKHBO@?$AAP?$AAy?$AAD?$AAe?$AAl?$AAt?$AAa?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?$AA@
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00077	33 c0		 xor	 eax, eax
$LN10@new_timezo:

; 804  :     assert(name == NULL || PyUnicode_Check(name));

  00079	48 83 7c 24 38
	00		 cmp	 QWORD PTR name$[rsp], 0
  0007f	74 34		 je	 SHORT $LN11@new_timezo
  00081	48 8b 44 24 38	 mov	 rax, QWORD PTR name$[rsp]
  00086	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00090	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00095	85 c0		 test	 eax, eax
  00097	75 1c		 jne	 SHORT $LN11@new_timezo
  00099	41 b8 24 03 00
	00		 mov	 r8d, 804		; 00000324H
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@MJHOHJKH@?$AAn?$AAa?$AAm?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI@
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b3	33 c0		 xor	 eax, eax
$LN11@new_timezo:

; 805  : 
; 806  :     if (name == NULL && delta_bool((PyDateTime_Delta *)offset) == 0) {

  000b5	48 83 7c 24 38
	00		 cmp	 QWORD PTR name$[rsp], 0
  000bb	75 26		 jne	 SHORT $LN6@new_timezo
  000bd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR offset$[rsp]
  000c2	e8 00 00 00 00	 call	 delta_bool
  000c7	85 c0		 test	 eax, eax
  000c9	75 18		 jne	 SHORT $LN6@new_timezo

; 807  :         Py_INCREF(PyDateTime_TimeZone_UTC);

  000cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyDateTime_TimeZone_UTC
  000d2	e8 00 00 00 00	 call	 _Py_IncRef

; 808  :         return PyDateTime_TimeZone_UTC;

  000d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyDateTime_TimeZone_UTC
  000de	e9 94 00 00 00	 jmp	 $LN7@new_timezo
$LN6@new_timezo:

; 809  :     }
; 810  :     if (GET_TD_MICROSECONDS(offset) != 0 || GET_TD_SECONDS(offset) % 60 != 0) {

  000e3	48 8b 44 24 30	 mov	 rax, QWORD PTR offset$[rsp]
  000e8	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  000ec	75 16		 jne	 SHORT $LN4@new_timezo
  000ee	48 8b 44 24 30	 mov	 rax, QWORD PTR offset$[rsp]
  000f3	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  000f6	99		 cdq
  000f7	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  000fc	f7 f9		 idiv	 ecx
  000fe	8b c2		 mov	 eax, edx
  00100	85 c0		 test	 eax, eax
  00102	74 1c		 je	 SHORT $LN5@new_timezo
$LN4@new_timezo:

; 811  :         PyErr_Format(PyExc_ValueError, "offset must be a timedelta"
; 812  :                      " representing a whole number of minutes,"
; 813  :                      " not %R.", offset);

  00104	4c 8b 44 24 30	 mov	 r8, QWORD PTR offset$[rsp]
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EL@EMKHHDPF@offset?5must?5be?5a?5timedelta?5repre@
  00110	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00117	e8 00 00 00 00	 call	 PyErr_Format

; 814  :         return NULL;

  0011c	33 c0		 xor	 eax, eax
  0011e	eb 57		 jmp	 SHORT $LN7@new_timezo
$LN5@new_timezo:

; 815  :     }
; 816  :     if ((GET_TD_DAYS(offset) == -1 && GET_TD_SECONDS(offset) == 0) ||
; 817  :         GET_TD_DAYS(offset) < -1 || GET_TD_DAYS(offset) >= 1) {

  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR offset$[rsp]
  00125	83 78 68 ff	 cmp	 DWORD PTR [rax+104], -1
  00129	75 0b		 jne	 SHORT $LN1@new_timezo
  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR offset$[rsp]
  00130	83 78 6c 00	 cmp	 DWORD PTR [rax+108], 0
  00134	74 16		 je	 SHORT $LN2@new_timezo
$LN1@new_timezo:
  00136	48 8b 44 24 30	 mov	 rax, QWORD PTR offset$[rsp]
  0013b	83 78 68 ff	 cmp	 DWORD PTR [rax+104], -1
  0013f	7c 0b		 jl	 SHORT $LN2@new_timezo
  00141	48 8b 44 24 30	 mov	 rax, QWORD PTR offset$[rsp]
  00146	83 78 68 01	 cmp	 DWORD PTR [rax+104], 1
  0014a	7c 1c		 jl	 SHORT $LN3@new_timezo
$LN2@new_timezo:

; 818  :         PyErr_Format(PyExc_ValueError, "offset must be a timedelta"
; 819  :                      " strictly between -timedelta(hours=24) and"
; 820  :                      " timedelta(hours=24),"
; 821  :                      " not %R.", offset);

  0014c	4c 8b 44 24 30	 mov	 r8, QWORD PTR offset$[rsp]
  00151	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GC@LAOOJPDN@offset?5must?5be?5a?5timedelta?5stric@
  00158	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0015f	e8 00 00 00 00	 call	 PyErr_Format

; 822  :         return NULL;

  00164	33 c0		 xor	 eax, eax
  00166	eb 0f		 jmp	 SHORT $LN7@new_timezo
$LN3@new_timezo:

; 823  :     }
; 824  : 
; 825  :     return create_timezone(offset, name);

  00168	48 8b 54 24 38	 mov	 rdx, QWORD PTR name$[rsp]
  0016d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR offset$[rsp]
  00172	e8 00 00 00 00	 call	 create_timezone
$LN7@new_timezo:

; 826  : }

  00177	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0017b	c3		 ret	 0
new_timezone ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$create_timezone DD imagerel create_timezone
	DD	imagerel create_timezone+300
	DD	imagerel $unwind$create_timezone
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$create_timezone DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT create_timezone
_TEXT	SEGMENT
type$ = 32
self$ = 40
offset$ = 64
name$ = 72
create_timezone PROC					; COMDAT

; 778  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 779  :     PyDateTime_TimeZone *self;
; 780  :     PyTypeObject *type = &PyDateTime_TimeZoneType;

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TimeZoneType
  00015	48 89 44 24 20	 mov	 QWORD PTR type$[rsp], rax

; 781  : 
; 782  :     assert(offset != NULL);

  0001a	48 83 7c 24 40
	00		 cmp	 QWORD PTR offset$[rsp], 0
  00020	75 1c		 jne	 SHORT $LN8@create_tim
  00022	41 b8 0e 03 00
	00		 mov	 r8d, 782		; 0000030eH
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@CPCGGCE@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003c	33 c0		 xor	 eax, eax
$LN8@create_tim:

; 783  :     assert(PyDelta_Check(offset));

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset$[rsp]
  0004a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0004e	74 35		 je	 SHORT $LN9@create_tim
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR offset$[rsp]
  0005c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00060	e8 00 00 00 00	 call	 PyType_IsSubtype
  00065	85 c0		 test	 eax, eax
  00067	75 1c		 jne	 SHORT $LN9@create_tim
  00069	41 b8 0f 03 00
	00		 mov	 r8d, 783		; 0000030fH
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@HCBLKHBO@?$AAP?$AAy?$AAD?$AAe?$AAl?$AAt?$AAa?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?$CJ?$AA?$AA@
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00083	33 c0		 xor	 eax, eax
$LN9@create_tim:

; 784  :     assert(name == NULL || PyUnicode_Check(name));

  00085	48 83 7c 24 48
	00		 cmp	 QWORD PTR name$[rsp], 0
  0008b	74 34		 je	 SHORT $LN10@create_tim
  0008d	48 8b 44 24 48	 mov	 rax, QWORD PTR name$[rsp]
  00092	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00096	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000a1	85 c0		 test	 eax, eax
  000a3	75 1c		 jne	 SHORT $LN10@create_tim
  000a5	41 b8 10 03 00
	00		 mov	 r8d, 784		; 00000310H
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@MJHOHJKH@?$AAn?$AAa?$AAm?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI@
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000bf	33 c0		 xor	 eax, eax
$LN10@create_tim:

; 785  : 
; 786  :     self = (PyDateTime_TimeZone *)(type->tp_alloc(type, 0));

  000c1	33 d2		 xor	 edx, edx
  000c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR type$[rsp]
  000c8	48 8b 44 24 20	 mov	 rax, QWORD PTR type$[rsp]
  000cd	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  000d3	48 89 44 24 28	 mov	 QWORD PTR self$[rsp], rax

; 787  :     if (self == NULL) {

  000d8	48 83 7c 24 28
	00		 cmp	 QWORD PTR self$[rsp], 0
  000de	75 04		 jne	 SHORT $LN5@create_tim

; 788  :         return NULL;

  000e0	33 c0		 xor	 eax, eax
  000e2	eb 43		 jmp	 SHORT $LN6@create_tim
$LN5@create_tim:

; 789  :     }
; 790  :     Py_INCREF(offset);

  000e4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset$[rsp]
  000e9	e8 00 00 00 00	 call	 _Py_IncRef

; 791  :     self->offset = offset;

  000ee	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  000f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset$[rsp]
  000f8	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
$LN4@create_tim:

; 792  :     Py_XINCREF(name);

  000fc	48 83 7c 24 48
	00		 cmp	 QWORD PTR name$[rsp], 0
  00102	74 0a		 je	 SHORT $LN1@create_tim
  00104	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  00109	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@create_tim:
  0010e	33 c0		 xor	 eax, eax
  00110	85 c0		 test	 eax, eax
  00112	75 e8		 jne	 SHORT $LN4@create_tim

; 793  :     self->name = name;

  00114	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
  00119	48 8b 4c 24 48	 mov	 rcx, QWORD PTR name$[rsp]
  0011e	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 794  :     return (PyObject *)self;

  00122	48 8b 44 24 28	 mov	 rax, QWORD PTR self$[rsp]
$LN6@create_tim:

; 795  : }

  00127	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012b	c3		 ret	 0
create_timezone ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@FPNMNAAI@timezone_dealloc?$AA@	; `string'
PUBLIC	??_C@_0BN@MMPIHDBP@?4?4?2Modules?2_datetimemodule?4c?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_dealloc DD imagerel timezone_dealloc
	DD	imagerel timezone_dealloc+236
	DD	imagerel $unwind$timezone_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_dealloc DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0BB@FPNMNAAI@timezone_dealloc?$AA@
CONST	SEGMENT
??_C@_0BB@FPNMNAAI@timezone_dealloc?$AA@ DB 'timezone_dealloc', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MMPIHDBP@?4?4?2Modules?2_datetimemodule?4c?$AA@
CONST	SEGMENT
??_C@_0BN@MMPIHDBP@?4?4?2Modules?2_datetimemodule?4c?$AA@ DB '..\Modules\'
	DB	'_datetimemodule.c', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT timezone_dealloc
_TEXT	SEGMENT
_py_tmp$23128 = 48
_py_tmp$23136 = 56
self$ = 80
timezone_dealloc PROC					; COMDAT

; 3205 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN8@timezone_d:

; 3206 :     Py_CLEAR(self->offset);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 53		 je	 SHORT $LN5@timezone_d
  00015	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00022	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  00026	41 b8 86 0c 00
	00		 mov	 r8d, 3206		; 00000c86H
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@MMPIHDBP@?4?4?2Modules?2_datetimemodule?4c?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FPNMNAAI@timezone_dealloc?$AA@
  0003a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003f	85 c0		 test	 eax, eax
  00041	75 25		 jne	 SHORT $LN5@timezone_d
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00048	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004c	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$23128[rsp], rax
  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00056	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$23128[rsp]
  00063	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@timezone_d:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 9b		 jne	 SHORT $LN8@timezone_d
$LN4@timezone_d:

; 3207 :     Py_CLEAR(self->name);

  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00073	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00078	74 53		 je	 SHORT $LN1@timezone_d
  0007a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00087	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0008b	41 b8 87 0c 00
	00		 mov	 r8d, 3207		; 00000c87H
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@MMPIHDBP@?4?4?2Modules?2_datetimemodule?4c?$AA@
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@FPNMNAAI@timezone_dealloc?$AA@
  0009f	e8 00 00 00 00	 call	 _PyParallel_Guard
  000a4	85 c0		 test	 eax, eax
  000a6	75 25		 jne	 SHORT $LN1@timezone_d
  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000ad	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b1	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$23136[rsp], rax
  000b6	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000bb	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
  000c3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$23136[rsp]
  000c8	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@timezone_d:
  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 9b		 jne	 SHORT $LN4@timezone_d

; 3208 :     Py_TYPE(self)->tp_free((PyObject *)self);

  000d3	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000d8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000dc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000e1	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 3209 : }

  000e7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000eb	c3		 ret	 0
timezone_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_richcompare DD imagerel timezone_richcompare
	DD	imagerel timezone_richcompare+156
	DD	imagerel $unwind$timezone_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_richcompare DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT timezone_richcompare
_TEXT	SEGMENT
self$ = 48
other$ = 56
op$ = 64
timezone_richcompare PROC				; COMDAT

; 3214 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3215 :     if (op != Py_EQ && op != Py_NE)

  00013	83 7c 24 40 02	 cmp	 DWORD PTR op$[rsp], 2
  00018	74 1c		 je	 SHORT $LN4@timezone_r
  0001a	83 7c 24 40 03	 cmp	 DWORD PTR op$[rsp], 3
  0001f	74 15		 je	 SHORT $LN4@timezone_r

; 3216 :         Py_RETURN_NOTIMPLEMENTED;

  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00028	e8 00 00 00 00	 call	 _Py_IncRef
  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00034	eb 61		 jmp	 SHORT $LN5@timezone_r
$LN4@timezone_r:

; 3217 :     if (Py_TYPE(other) != &PyDateTime_TimeZoneType) {

  00036	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TimeZoneType
  0003d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR other$[rsp]
  00042	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00046	74 33		 je	 SHORT $LN3@timezone_r

; 3218 : 	if (op == Py_EQ)

  00048	83 7c 24 40 02	 cmp	 DWORD PTR op$[rsp], 2
  0004d	75 17		 jne	 SHORT $LN2@timezone_r

; 3219 : 	    Py_RETURN_FALSE;

  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00056	e8 00 00 00 00	 call	 _Py_IncRef
  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00062	eb 33		 jmp	 SHORT $LN5@timezone_r

; 3220 : 	else

  00064	eb 15		 jmp	 SHORT $LN1@timezone_r
$LN2@timezone_r:

; 3221 : 	    Py_RETURN_TRUE;

  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  0006d	e8 00 00 00 00	 call	 _Py_IncRef
  00072	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00079	eb 1c		 jmp	 SHORT $LN5@timezone_r
$LN1@timezone_r:
$LN3@timezone_r:

; 3222 :     }
; 3223 :     return delta_richcompare(self->offset, other->offset, op);

  0007b	44 8b 44 24 40	 mov	 r8d, DWORD PTR op$[rsp]
  00080	48 8b 44 24 38	 mov	 rax, QWORD PTR other$[rsp]
  00085	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00089	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0008e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00092	e8 00 00 00 00	 call	 delta_richcompare
$LN5@timezone_r:

; 3224 : }

  00097	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009b	c3		 ret	 0
timezone_richcompare ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_hash DD imagerel timezone_hash
	DD	imagerel timezone_hash+28
	DD	imagerel $unwind$timezone_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_hash DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT timezone_hash
_TEXT	SEGMENT
self$ = 48
timezone_hash PROC					; COMDAT

; 3228 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3229 :     return delta_hash((PyDateTime_Delta *)self->offset);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00012	e8 00 00 00 00	 call	 delta_hash

; 3230 : }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
timezone_hash ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@EPAFDHHK@?$CFs?$CI?$CFR?0?5?$CFR?$CJ?$AA@ ; `string'
PUBLIC	??_C@_06DPIDBHCJ@?$CFs?$CI?$CFR?$CJ?$AA@	; `string'
PUBLIC	??_C@_06ENJIHAPG@?$CFs?4utc?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_repr DD imagerel timezone_repr
	DD	imagerel timezone_repr+140
	DD	imagerel $unwind$timezone_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_repr DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@EPAFDHHK@?$CFs?$CI?$CFR?0?5?$CFR?$CJ?$AA@
CONST	SEGMENT
??_C@_0L@EPAFDHHK@?$CFs?$CI?$CFR?0?5?$CFR?$CJ?$AA@ DB '%s(%R, %R)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06DPIDBHCJ@?$CFs?$CI?$CFR?$CJ?$AA@
CONST	SEGMENT
??_C@_06DPIDBHCJ@?$CFs?$CI?$CFR?$CJ?$AA@ DB '%s(%R)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06ENJIHAPG@?$CFs?4utc?$AA@
CONST	SEGMENT
??_C@_06ENJIHAPG@?$CFs?4utc?$AA@ DB '%s.utc', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT timezone_repr
_TEXT	SEGMENT
type_name$ = 32
self$ = 64
timezone_repr PROC					; COMDAT

; 3248 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3249 :     /* Note that although timezone is not subclassable, it is convenient
; 3250 :        to use Py_TYPE(self)->tp_name here. */
; 3251 :     const char *type_name = Py_TYPE(self)->tp_name;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00016	48 89 44 24 20	 mov	 QWORD PTR type_name$[rsp], rax

; 3252 : 
; 3253 :     if (((PyObject *)self) == PyDateTime_TimeZone_UTC)

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyDateTime_TimeZone_UTC
  00022	48 39 44 24 40	 cmp	 QWORD PTR self$[rsp], rax
  00027	75 13		 jne	 SHORT $LN2@timezone_r@2

; 3254 :         return PyUnicode_FromFormat("%s.utc", type_name);

  00029	48 8b 54 24 20	 mov	 rdx, QWORD PTR type_name$[rsp]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06ENJIHAPG@?$CFs?4utc?$AA@
  00035	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0003a	eb 4b		 jmp	 SHORT $LN3@timezone_r@2
$LN2@timezone_r@2:

; 3255 : 
; 3256 :     if (self->name == NULL)

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00041	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00046	75 1c		 jne	 SHORT $LN1@timezone_r@2

; 3257 :         return PyUnicode_FromFormat("%s(%R)", type_name, self->offset);

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004d	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00051	48 8b 54 24 20	 mov	 rdx, QWORD PTR type_name$[rsp]
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06DPIDBHCJ@?$CFs?$CI?$CFR?$CJ?$AA@
  0005d	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00062	eb 23		 jmp	 SHORT $LN3@timezone_r@2
$LN1@timezone_r@2:

; 3258 : 
; 3259 :     return PyUnicode_FromFormat("%s(%R, %R)", type_name, self->offset,
; 3260 :                                 self->name);

  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00069	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00072	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00076	48 8b 54 24 20	 mov	 rdx, QWORD PTR type_name$[rsp]
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@EPAFDHHK@?$CFs?$CI?$CFR?0?5?$CFR?$CJ?$AA@
  00082	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN3@timezone_r@2:

; 3261 : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
timezone_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@KHLHJEGA@UTC?$CFc?$CF02d?3?$CF02d?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_str DD imagerel timezone_str
	DD	imagerel timezone_str+271
	DD	imagerel $unwind$timezone_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_str DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0P@KHLHJEGA@UTC?$CFc?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0P@KHLHJEGA@UTC?$CFc?$CF02d?3?$CF02d?$AA@ DB 'UTC%c%02d:%02d', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT timezone_str
_TEXT	SEGMENT
offset$ = 32
minutes$ = 40
sign$ = 44
seconds$ = 48
hours$ = 52
self$ = 80
timezone_str PROC					; COMDAT

; 3266 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3267 :     int hours, minutes, seconds;
; 3268 :     PyObject *offset;
; 3269 :     char sign;
; 3270 : 
; 3271 :     if (self->name != NULL) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	74 1c		 je	 SHORT $LN4@timezone_s

; 3272 :         Py_INCREF(self->name);

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001a	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  0001e	e8 00 00 00 00	 call	 _Py_IncRef

; 3273 :         return self->name;

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00028	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0002c	e9 d9 00 00 00	 jmp	 $LN5@timezone_s
$LN4@timezone_s:

; 3274 :     }
; 3275 :     /* Offset is normalized, so it is negative if days < 0 */
; 3276 :     if (GET_TD_DAYS(self->offset) < 0) {

  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00036	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0003a	83 78 68 00	 cmp	 DWORD PTR [rax+104], 0
  0003e	7d 29		 jge	 SHORT $LN3@timezone_s

; 3277 :         sign = '-';

  00040	c6 44 24 2c 2d	 mov	 BYTE PTR sign$[rsp], 45	; 0000002dH

; 3278 :         offset = delta_negative((PyDateTime_Delta *)self->offset);

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0004a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0004e	e8 00 00 00 00	 call	 delta_negative
  00053	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 3279 :         if (offset == NULL)

  00058	48 83 7c 24 20
	00		 cmp	 QWORD PTR offset$[rsp], 0
  0005e	75 07		 jne	 SHORT $LN2@timezone_s

; 3280 :             return NULL;

  00060	33 c0		 xor	 eax, eax
  00062	e9 a3 00 00 00	 jmp	 $LN5@timezone_s
$LN2@timezone_s:

; 3281 :     }
; 3282 :     else {

  00067	eb 1d		 jmp	 SHORT $LN1@timezone_s
$LN3@timezone_s:

; 3283 :         sign = '+';

  00069	c6 44 24 2c 2b	 mov	 BYTE PTR sign$[rsp], 43	; 0000002bH

; 3284 :         offset = self->offset;

  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00073	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00077	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 3285 :         Py_INCREF(offset);

  0007c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  00081	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@timezone_s:

; 3286 :     }
; 3287 :     /* Offset is not negative here. */
; 3288 :     seconds = GET_TD_SECONDS(offset);

  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  0008b	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0008e	89 44 24 30	 mov	 DWORD PTR seconds$[rsp], eax

; 3289 :     Py_DECREF(offset);

  00092	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  00097	e8 00 00 00 00	 call	 _Py_DecRef

; 3290 :     minutes = divmod(seconds, 60, &seconds);

  0009c	4c 8d 44 24 30	 lea	 r8, QWORD PTR seconds$[rsp]
  000a1	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  000a6	8b 4c 24 30	 mov	 ecx, DWORD PTR seconds$[rsp]
  000aa	e8 00 00 00 00	 call	 divmod
  000af	89 44 24 28	 mov	 DWORD PTR minutes$[rsp], eax

; 3291 :     hours = divmod(minutes, 60, &minutes);

  000b3	4c 8d 44 24 28	 lea	 r8, QWORD PTR minutes$[rsp]
  000b8	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  000bd	8b 4c 24 28	 mov	 ecx, DWORD PTR minutes$[rsp]
  000c1	e8 00 00 00 00	 call	 divmod
  000c6	89 44 24 34	 mov	 DWORD PTR hours$[rsp], eax

; 3292 :     /* XXX ignore sub-minute data, curently not allowed. */
; 3293 :     assert(seconds == 0);

  000ca	83 7c 24 30 00	 cmp	 DWORD PTR seconds$[rsp], 0
  000cf	74 1c		 je	 SHORT $LN7@timezone_s
  000d1	41 b8 dd 0c 00
	00		 mov	 r8d, 3293		; 00000cddH
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@LCOJKHBM@?$AAs?$AAe?$AAc?$AAo?$AAn?$AAd?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000eb	33 c0		 xor	 eax, eax
$LN7@timezone_s:

; 3294 :     return PyUnicode_FromFormat("UTC%c%02d:%02d", sign, hours, minutes);

  000ed	0f be 44 24 2c	 movsx	 eax, BYTE PTR sign$[rsp]
  000f2	44 8b 4c 24 28	 mov	 r9d, DWORD PTR minutes$[rsp]
  000f7	44 8b 44 24 34	 mov	 r8d, DWORD PTR hours$[rsp]
  000fc	8b d0		 mov	 edx, eax
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@KHLHJEGA@UTC?$CFc?$CF02d?3?$CF02d?$AA@
  00105	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN5@timezone_s:

; 3295 : }

  0010a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010e	c3		 ret	 0
timezone_str ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_tzname DD imagerel timezone_tzname
	DD	imagerel timezone_tzname+55
	DD	imagerel $unwind$timezone_tzname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_tzname DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT timezone_tzname
_TEXT	SEGMENT
self$ = 48
dt$ = 56
timezone_tzname PROC					; COMDAT

; 3299 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3300 :     if (_timezone_check_argument(dt, "tzname") == -1)

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CNBAGEMF@tzname?$AA@
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dt$[rsp]
  0001a	e8 00 00 00 00	 call	 _timezone_check_argument
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	75 04		 jne	 SHORT $LN1@timezone_t

; 3301 :         return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	eb 0a		 jmp	 SHORT $LN2@timezone_t
$LN1@timezone_t:

; 3302 : 
; 3303 :     return timezone_str(self);

  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0002d	e8 00 00 00 00	 call	 timezone_str
$LN2@timezone_t:

; 3304 : }

  00032	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00036	c3		 ret	 0
timezone_tzname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EA@HNIDGIFA@?$CFs?$CIdt?$CJ?5argument?5must?5be?5a?5dateti@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_timezone_check_argument DD imagerel _timezone_check_argument
	DD	imagerel _timezone_check_argument+122
	DD	imagerel $unwind$_timezone_check_argument
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_timezone_check_argument DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0EA@HNIDGIFA@?$CFs?$CIdt?$CJ?5argument?5must?5be?5a?5dateti@
CONST	SEGMENT
??_C@_0EA@HNIDGIFA@?$CFs?$CIdt?$CJ?5argument?5must?5be?5a?5dateti@ DB '%s'
	DB	'(dt) argument must be a datetime instance or None, not %.200s'
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _timezone_check_argument
_TEXT	SEGMENT
dt$ = 48
meth$ = 56
_timezone_check_argument PROC				; COMDAT

; 3238 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3239 :     if (dt == Py_None || PyDateTime_Check(dt))

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00015	48 39 44 24 30	 cmp	 QWORD PTR dt$[rsp], rax
  0001a	74 2b		 je	 SHORT $LN2@timezone_c
  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dt$[rsp]
  00028	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002c	74 19		 je	 SHORT $LN1@timezone_c
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR dt$[rsp]
  0003a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00043	85 c0		 test	 eax, eax
  00045	74 04		 je	 SHORT $LN3@timezone_c
$LN1@timezone_c:
$LN2@timezone_c:

; 3240 :         return 0;

  00047	33 c0		 xor	 eax, eax
  00049	eb 2a		 jmp	 SHORT $LN4@timezone_c
$LN3@timezone_c:

; 3241 :     PyErr_Format(PyExc_TypeError, "%s(dt) argument must be a datetime instance"
; 3242 :                  " or None, not %.200s", meth, Py_TYPE(dt)->tp_name);

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR dt$[rsp]
  00050	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00054	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00058	4c 8b 44 24 38	 mov	 r8, QWORD PTR meth$[rsp]
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EA@HNIDGIFA@?$CFs?$CIdt?$CJ?5argument?5must?5be?5a?5dateti@
  00064	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0006b	e8 00 00 00 00	 call	 PyErr_Format

; 3243 :     return -1;

  00070	b8 ff ff ff ff	 mov	 eax, -1
$LN4@timezone_c:

; 3244 : }

  00075	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00079	c3		 ret	 0
_timezone_check_argument ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_utcoffset DD imagerel timezone_utcoffset
	DD	imagerel timezone_utcoffset+68
	DD	imagerel $unwind$timezone_utcoffset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_utcoffset DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT timezone_utcoffset
_TEXT	SEGMENT
self$ = 48
dt$ = 56
timezone_utcoffset PROC					; COMDAT

; 3308 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3309 :     if (_timezone_check_argument(dt, "utcoffset") == -1)

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09DGNKAEDJ@utcoffset?$AA@
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dt$[rsp]
  0001a	e8 00 00 00 00	 call	 _timezone_check_argument
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	75 04		 jne	 SHORT $LN1@timezone_u

; 3310 :         return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	eb 17		 jmp	 SHORT $LN2@timezone_u
$LN1@timezone_u:

; 3311 : 
; 3312 :     Py_INCREF(self->offset);

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0002d	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00031	e8 00 00 00 00	 call	 _Py_IncRef

; 3313 :     return self->offset;

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
$LN2@timezone_u:

; 3314 : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
timezone_utcoffset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_dst DD imagerel timezone_dst
	DD	imagerel timezone_dst+64
	DD	imagerel $unwind$timezone_dst
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_dst DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT timezone_dst
_TEXT	SEGMENT
self$ = 48
dt$ = 56
timezone_dst PROC					; COMDAT

; 3318 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3319 :     if (_timezone_check_argument(dt, "dst") == -1)

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03HHBLCKEM@dst?$AA@
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dt$[rsp]
  0001a	e8 00 00 00 00	 call	 _timezone_check_argument
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	75 04		 jne	 SHORT $LN1@timezone_d@2

; 3320 :         return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	eb 13		 jmp	 SHORT $LN2@timezone_d@2
$LN1@timezone_d@2:

; 3321 : 
; 3322 :     Py_RETURN_NONE;

  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0002f	e8 00 00 00 00	 call	 _Py_IncRef
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@timezone_d@2:

; 3323 : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
timezone_dst ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_fromutc DD imagerel timezone_fromutc
	DD	imagerel timezone_fromutc+162
	DD	imagerel $unwind$timezone_fromutc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_fromutc DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT timezone_fromutc
_TEXT	SEGMENT
self$ = 48
dt$ = 56
timezone_fromutc PROC					; COMDAT

; 3327 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3328 :     if (!PyDateTime_Check(dt)) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dt$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 30		 je	 SHORT $LN3@timezone_f
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00027	48 8b 44 24 38	 mov	 rax, QWORD PTR dt$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	75 17		 jne	 SHORT $LN3@timezone_f

; 3329 :         PyErr_SetString(PyExc_TypeError,
; 3330 :                         "fromutc: argument must be a datetime");

  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@OKCHMBGC@fromutc?3?5argument?5must?5be?5a?5date@
  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00047	e8 00 00 00 00	 call	 PyErr_SetString

; 3331 :         return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 4d		 jmp	 SHORT $LN4@timezone_f
$LN3@timezone_f:

; 3332 :     }
; 3333 :     if (!HASTZINFO(dt) || dt->tzinfo != (PyObject *)self) {

  00050	48 8b 44 24 38	 mov	 rax, QWORD PTR dt$[rsp]
  00055	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00059	85 c0		 test	 eax, eax
  0005b	74 10		 je	 SHORT $LN1@timezone_f
  0005d	48 8b 44 24 38	 mov	 rax, QWORD PTR dt$[rsp]
  00062	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00067	48 39 48 78	 cmp	 QWORD PTR [rax+120], rcx
  0006b	74 17		 je	 SHORT $LN2@timezone_f
$LN1@timezone_f:

; 3334 :         PyErr_SetString(PyExc_ValueError, "fromutc: dt.tzinfo "
; 3335 :                         "is not self");

  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@GGFFFAGL@fromutc?3?5dt?4tzinfo?5is?5not?5self?$AA@
  00074	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0007b	e8 00 00 00 00	 call	 PyErr_SetString

; 3336 :         return NULL;

  00080	33 c0		 xor	 eax, eax
  00082	eb 19		 jmp	 SHORT $LN4@timezone_f
$LN2@timezone_f:

; 3337 :     }
; 3338 : 
; 3339 :     return add_datetime_timedelta(dt, (PyDateTime_Delta *)self->offset, 1);

  00084	41 b8 01 00 00
	00		 mov	 r8d, 1
  0008a	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0008f	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00093	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dt$[rsp]
  00098	e8 00 00 00 00	 call	 add_datetime_timedelta
$LN4@timezone_f:

; 3340 : }

  0009d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a1	c3		 ret	 0
timezone_fromutc ENDP
_TEXT	ENDS
PUBLIC	??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@		; `string'
PUBLIC	??_C@_03IELNPCCE@?$CIO?$CJ?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$timezone_getinitargs DD imagerel timezone_getinitargs
	DD	imagerel timezone_getinitargs+79
	DD	imagerel $unwind$timezone_getinitargs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timezone_getinitargs DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@
CONST	SEGMENT
??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@ DB '(OO)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_03IELNPCCE@?$CIO?$CJ?$AA@ DB '(O)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT timezone_getinitargs
_TEXT	SEGMENT
self$ = 48
timezone_getinitargs PROC				; COMDAT

; 3344 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3345 :     if (self->name == NULL)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	75 17		 jne	 SHORT $LN1@timezone_g

; 3346 :         return Py_BuildValue("(O)", self->offset);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001a	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IELNPCCE@?$CIO?$CJ?$AA@
  00025	e8 00 00 00 00	 call	 Py_BuildValue
  0002a	eb 1e		 jmp	 SHORT $LN2@timezone_g
$LN1@timezone_g:

; 3347 :     return Py_BuildValue("(OO)", self->offset, self->name);

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00031	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003a	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DEJLHBFK@?$CIOO?$CJ?$AA@
  00045	e8 00 00 00 00	 call	 Py_BuildValue
$LN2@timezone_g:

; 3348 : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
timezone_getinitargs ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_hour DD imagerel time_hour
	DD	imagerel time_hour+35
	DD	imagerel $unwind$time_hour
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_hour DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_hour
_TEXT	SEGMENT
self$ = 48
unused$ = 56
time_hour PROC						; COMDAT

; 3423 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3424 :     return PyLong_FromLong(TIME_GET_HOUR(self));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00017	8b c8		 mov	 ecx, eax
  00019	e8 00 00 00 00	 call	 PyLong_FromLong

; 3425 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
time_hour ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_minute DD imagerel time_minute
	DD	imagerel time_minute+35
	DD	imagerel $unwind$time_minute
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_minute DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_minute
_TEXT	SEGMENT
self$ = 48
unused$ = 56
time_minute PROC					; COMDAT

; 3429 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3430 :     return PyLong_FromLong(TIME_GET_MINUTE(self));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f b6 40 6a	 movzx	 eax, BYTE PTR [rax+106]
  00017	8b c8		 mov	 ecx, eax
  00019	e8 00 00 00 00	 call	 PyLong_FromLong

; 3431 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
time_minute ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$py_time_second DD imagerel py_time_second
	DD	imagerel py_time_second+35
	DD	imagerel $unwind$py_time_second
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$py_time_second DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT py_time_second
_TEXT	SEGMENT
self$ = 48
unused$ = 56
py_time_second PROC					; COMDAT

; 3436 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3437 :     return PyLong_FromLong(TIME_GET_SECOND(self));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  00017	8b c8		 mov	 ecx, eax
  00019	e8 00 00 00 00	 call	 PyLong_FromLong

; 3438 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
py_time_second ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_microsecond DD imagerel time_microsecond
	DD	imagerel time_microsecond+63
	DD	imagerel $unwind$time_microsecond
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_microsecond DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_microsecond
_TEXT	SEGMENT
self$ = 48
unused$ = 56
time_microsecond PROC					; COMDAT

; 3442 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3443 :     return PyLong_FromLong(TIME_GET_MICROSECOND(self));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00017	c1 e0 10	 shl	 eax, 16
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0001f	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  00023	c1 e1 08	 shl	 ecx, 8
  00026	0b c1		 or	 eax, ecx
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0002d	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  00031	0b c1		 or	 eax, ecx
  00033	8b c8		 mov	 ecx, eax
  00035	e8 00 00 00 00	 call	 PyLong_FromLong

; 3444 : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
time_microsecond ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_tzinfo DD imagerel time_tzinfo
	DD	imagerel time_tzinfo+85
	DD	imagerel $unwind$time_tzinfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_tzinfo DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_tzinfo
_TEXT	SEGMENT
result$ = 32
tv68 = 40
self$ = 64
unused$ = 72
time_tzinfo PROC					; COMDAT

; 3448 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3449 :     PyObject *result = HASTZINFO(self) ? self->tzinfo : Py_None;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00017	85 c0		 test	 eax, eax
  00019	74 10		 je	 SHORT $LN3@time_tzinf
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	48 89 44 24 28	 mov	 QWORD PTR tv68[rsp], rax
  00029	eb 0c		 jmp	 SHORT $LN4@time_tzinf
$LN3@time_tzinf:
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00032	48 89 44 24 28	 mov	 QWORD PTR tv68[rsp], rax
$LN4@time_tzinf:
  00037	48 8b 44 24 28	 mov	 rax, QWORD PTR tv68[rsp]
  0003c	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 3450 :     Py_INCREF(result);

  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00046	e8 00 00 00 00	 call	 _Py_IncRef

; 3451 :     return result;

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 3452 : }

  00050	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00054	c3		 ret	 0
time_tzinfo ENDP
_TEXT	ENDS
PUBLIC	??_C@_06IEELMKJM@?$HMiiiiO?$AA@			; `string'
PUBLIC	??_C@_0BF@ECAEDOJO@bad?5tzinfo?5state?5arg?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_new DD imagerel time_new
	DD	imagerel time_new+852
	DD	imagerel $unwind$time_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_new DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT ??_C@_06IEELMKJM@?$HMiiiiO?$AA@
CONST	SEGMENT
??_C@_06IEELMKJM@?$HMiiiiO?$AA@ DB '|iiiiO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ECAEDOJO@bad?5tzinfo?5state?5arg?$AA@
CONST	SEGMENT
??_C@_0BF@ECAEDOJO@bad?5tzinfo?5state?5arg?$AA@ DB 'bad tzinfo state arg', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT time_new
_TEXT	SEGMENT
usecond$ = 80
second$ = 84
minute$ = 88
hour$ = 92
self$ = 96
tzinfo$ = 104
state$ = 112
aware$23382 = 120
me$23381 = 128
pdata$23393 = 136
tv138 = 144
type$ = 176
args$ = 184
kw$ = 192
time_new PROC						; COMDAT

; 3472 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 3473 :     PyObject *self = NULL;

  00016	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR self$[rsp], 0

; 3474 :     PyObject *state;
; 3475 :     int hour = 0;

  0001f	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hour$[rsp], 0

; 3476 :     int minute = 0;

  00027	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR minute$[rsp], 0

; 3477 :     int second = 0;

  0002f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR second$[rsp], 0

; 3478 :     int usecond = 0;

  00037	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR usecond$[rsp], 0

; 3479 :     PyObject *tzinfo = Py_None;

  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00046	48 89 44 24 68	 mov	 QWORD PTR tzinfo$[rsp], rax

; 3480 : 
; 3481 :     /* Check for invocation from pickle with __getstate__ state */
; 3482 :     if (PyTuple_GET_SIZE(args) >= 1 &&
; 3483 :         PyTuple_GET_SIZE(args) <= 2 &&
; 3484 :         PyBytes_Check(state = PyTuple_GET_ITEM(args, 0)) &&
; 3485 :         PyBytes_GET_SIZE(state) == _PyDateTime_TIME_DATASIZE &&
; 3486 :         ((unsigned char) (PyBytes_AS_STRING(state)[0])) < 24)

  0004b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00053	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  00058	0f 8c 2c 02 00
	00		 jl	 $LN8@time_new
  0005e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00066	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  0006b	0f 8f 19 02 00
	00		 jg	 $LN8@time_new
  00071	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00079	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0007d	48 89 44 24 70	 mov	 QWORD PTR state$[rsp], rax
  00082	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00087	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00091	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00096	85 c0		 test	 eax, eax
  00098	0f 84 ec 01 00
	00		 je	 $LN8@time_new
  0009e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000a3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000ad	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000b2	85 c0		 test	 eax, eax
  000b4	75 1c		 jne	 SHORT $LN11@time_new
  000b6	41 b8 9d 0d 00
	00		 mov	 r8d, 3485		; 00000d9dH
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d0	33 c0		 xor	 eax, eax
$LN11@time_new:
  000d2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000d7	48 83 78 60 06	 cmp	 QWORD PTR [rax+96], 6
  000dc	0f 85 a8 01 00
	00		 jne	 $LN8@time_new
  000e2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000e7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000eb	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 1c		 jne	 SHORT $LN12@time_new
  000fa	41 b8 9e 0d 00
	00		 mov	 r8d, 3486		; 00000d9eH
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00114	33 c0		 xor	 eax, eax
$LN12@time_new:
  00116	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0011b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0011f	83 f8 18	 cmp	 eax, 24
  00122	0f 8d 62 01 00
	00		 jge	 $LN8@time_new

; 3487 :     {
; 3488 :         PyDateTime_Time *me;
; 3489 :         char aware;
; 3490 : 
; 3491 :         if (PyTuple_GET_SIZE(args) == 2) {

  00128	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00130	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  00135	75 39		 jne	 SHORT $LN7@time_new

; 3492 :             tzinfo = PyTuple_GET_ITEM(args, 1);

  00137	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  0013f	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00143	48 89 44 24 68	 mov	 QWORD PTR tzinfo$[rsp], rax

; 3493 :             if (check_tzinfo_subclass(tzinfo) < 0) {

  00148	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  0014d	e8 00 00 00 00	 call	 check_tzinfo_subclass
  00152	85 c0		 test	 eax, eax
  00154	7d 1a		 jge	 SHORT $LN6@time_new

; 3494 :                 PyErr_SetString(PyExc_TypeError, "bad "
; 3495 :                     "tzinfo state arg");

  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@ECAEDOJO@bad?5tzinfo?5state?5arg?$AA@
  0015d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00164	e8 00 00 00 00	 call	 PyErr_SetString

; 3496 :                 return NULL;

  00169	33 c0		 xor	 eax, eax
  0016b	e9 dc 01 00 00	 jmp	 $LN9@time_new
$LN6@time_new:
$LN7@time_new:

; 3497 :             }
; 3498 :         }
; 3499 :         aware = (char)(tzinfo != Py_None);

  00170	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00177	48 39 44 24 68	 cmp	 QWORD PTR tzinfo$[rsp], rax
  0017c	74 0a		 je	 SHORT $LN13@time_new
  0017e	c6 84 24 90 00
	00 00 01	 mov	 BYTE PTR tv138[rsp], 1
  00186	eb 08		 jmp	 SHORT $LN14@time_new
$LN13@time_new:
  00188	c6 84 24 90 00
	00 00 00	 mov	 BYTE PTR tv138[rsp], 0
$LN14@time_new:
  00190	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR tv138[rsp]
  00198	88 44 24 78	 mov	 BYTE PTR aware$23382[rsp], al

; 3500 :         me = (PyDateTime_Time *) (type->tp_alloc(type, aware));

  0019c	48 0f be 44 24
	78		 movsx	 rax, BYTE PTR aware$23382[rsp]
  001a2	48 8b d0	 mov	 rdx, rax
  001a5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  001ad	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  001b5	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  001bb	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR me$23381[rsp], rax

; 3501 :         if (me != NULL) {

  001c3	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR me$23381[rsp], 0
  001cc	0f 84 ab 00 00
	00		 je	 $LN5@time_new

; 3502 :             char *pdata = PyBytes_AS_STRING(state);

  001d2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  001d7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001db	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001e1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001e6	85 c0		 test	 eax, eax
  001e8	75 1c		 jne	 SHORT $LN15@time_new
  001ea	41 b8 ae 0d 00
	00		 mov	 r8d, 3502		; 00000daeH
  001f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00204	33 c0		 xor	 eax, eax
$LN15@time_new:
  00206	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0020b	48 83 c0 78	 add	 rax, 120		; 00000078H
  0020f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pdata$23393[rsp], rax

; 3503 : 
; 3504 :             memcpy(me->data, pdata, _PyDateTime_TIME_DATASIZE);

  00217	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR me$23381[rsp]
  0021f	48 83 c0 69	 add	 rax, 105		; 00000069H
  00223	41 b8 06 00 00
	00		 mov	 r8d, 6
  00229	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pdata$23393[rsp]
  00231	48 8b c8	 mov	 rcx, rax
  00234	e8 00 00 00 00	 call	 memcpy

; 3505 :             me->hashcode = -1;

  00239	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR me$23381[rsp]
  00241	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1

; 3506 :             me->hastzinfo = aware;

  00249	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR me$23381[rsp]
  00251	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR aware$23382[rsp]
  00256	88 48 68	 mov	 BYTE PTR [rax+104], cl

; 3507 :             if (aware) {

  00259	0f be 44 24 78	 movsx	 eax, BYTE PTR aware$23382[rsp]
  0025e	85 c0		 test	 eax, eax
  00260	74 1b		 je	 SHORT $LN4@time_new

; 3508 :                 Py_INCREF(tzinfo);

  00262	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00267	e8 00 00 00 00	 call	 _Py_IncRef

; 3509 :                 me->tzinfo = tzinfo;

  0026c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR me$23381[rsp]
  00274	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00279	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
$LN4@time_new:
$LN5@time_new:

; 3510 :             }
; 3511 :         }
; 3512 :         return (PyObject *)me;

  0027d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR me$23381[rsp]
  00285	e9 c2 00 00 00	 jmp	 $LN9@time_new
$LN8@time_new:

; 3513 :     }
; 3514 : 
; 3515 :     if (PyArg_ParseTupleAndKeywords(args, kw, "|iiiiO", time_kws,
; 3516 :                                     &hour, &minute, &second, &usecond,
; 3517 :                                     &tzinfo)) {

  0028a	48 8d 44 24 68	 lea	 rax, QWORD PTR tzinfo$[rsp]
  0028f	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00294	48 8d 44 24 50	 lea	 rax, QWORD PTR usecond$[rsp]
  00299	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0029e	48 8d 44 24 54	 lea	 rax, QWORD PTR second$[rsp]
  002a3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  002a8	48 8d 44 24 58	 lea	 rax, QWORD PTR minute$[rsp]
  002ad	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002b2	48 8d 44 24 5c	 lea	 rax, QWORD PTR hour$[rsp]
  002b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002bc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:time_kws
  002c3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06IEELMKJM@?$HMiiiiO?$AA@
  002ca	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  002d2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  002da	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  002df	85 c0		 test	 eax, eax
  002e1	74 64		 je	 SHORT $LN3@time_new

; 3518 :         if (check_time_args(hour, minute, second, usecond) < 0)

  002e3	44 8b 4c 24 50	 mov	 r9d, DWORD PTR usecond$[rsp]
  002e8	44 8b 44 24 54	 mov	 r8d, DWORD PTR second$[rsp]
  002ed	8b 54 24 58	 mov	 edx, DWORD PTR minute$[rsp]
  002f1	8b 4c 24 5c	 mov	 ecx, DWORD PTR hour$[rsp]
  002f5	e8 00 00 00 00	 call	 check_time_args
  002fa	85 c0		 test	 eax, eax
  002fc	7d 04		 jge	 SHORT $LN2@time_new

; 3519 :             return NULL;

  002fe	33 c0		 xor	 eax, eax
  00300	eb 4a		 jmp	 SHORT $LN9@time_new
$LN2@time_new:

; 3520 :         if (check_tzinfo_subclass(tzinfo) < 0)

  00302	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00307	e8 00 00 00 00	 call	 check_tzinfo_subclass
  0030c	85 c0		 test	 eax, eax
  0030e	7d 04		 jge	 SHORT $LN1@time_new

; 3521 :             return NULL;

  00310	33 c0		 xor	 eax, eax
  00312	eb 38		 jmp	 SHORT $LN9@time_new
$LN1@time_new:

; 3522 :         self = new_time_ex(hour, minute, second, usecond, tzinfo,
; 3523 :                            type);

  00314	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  0031c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00321	48 8b 44 24 68	 mov	 rax, QWORD PTR tzinfo$[rsp]
  00326	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0032b	44 8b 4c 24 50	 mov	 r9d, DWORD PTR usecond$[rsp]
  00330	44 8b 44 24 54	 mov	 r8d, DWORD PTR second$[rsp]
  00335	8b 54 24 58	 mov	 edx, DWORD PTR minute$[rsp]
  00339	8b 4c 24 5c	 mov	 ecx, DWORD PTR hour$[rsp]
  0033d	e8 00 00 00 00	 call	 new_time_ex
  00342	48 89 44 24 60	 mov	 QWORD PTR self$[rsp], rax
$LN3@time_new:

; 3524 :     }
; 3525 :     return self;

  00347	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
$LN9@time_new:

; 3526 : }

  0034c	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00353	c3		 ret	 0
time_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@MAGNOEPP@microsecond?5must?5be?5in?50?4?4999999@ ; `string'
PUBLIC	??_C@_0BI@FHJLBIID@second?5must?5be?5in?50?4?459?$AA@ ; `string'
PUBLIC	??_C@_0BI@FCAMKLIB@minute?5must?5be?5in?50?4?459?$AA@ ; `string'
PUBLIC	??_C@_0BG@BMLNJKHN@hour?5must?5be?5in?50?4?423?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_time_args DD imagerel check_time_args
	DD	imagerel check_time_args+192
	DD	imagerel $unwind$check_time_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_time_args DD 011601H
	DD	04216H
xdata	ENDS
;	COMDAT ??_C@_0CB@MAGNOEPP@microsecond?5must?5be?5in?50?4?4999999@
CONST	SEGMENT
??_C@_0CB@MAGNOEPP@microsecond?5must?5be?5in?50?4?4999999@ DB 'microsecon'
	DB	'd must be in 0..999999', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FHJLBIID@second?5must?5be?5in?50?4?459?$AA@
CONST	SEGMENT
??_C@_0BI@FHJLBIID@second?5must?5be?5in?50?4?459?$AA@ DB 'second must be '
	DB	'in 0..59', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FCAMKLIB@minute?5must?5be?5in?50?4?459?$AA@
CONST	SEGMENT
??_C@_0BI@FCAMKLIB@minute?5must?5be?5in?50?4?459?$AA@ DB 'minute must be '
	DB	'in 0..59', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BMLNJKHN@hour?5must?5be?5in?50?4?423?$AA@
CONST	SEGMENT
??_C@_0BG@BMLNJKHN@hour?5must?5be?5in?50?4?423?$AA@ DB 'hour must be in 0'
	DB	'..23', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT check_time_args
_TEXT	SEGMENT
h$ = 48
m$ = 56
s$ = 64
us$ = 72
check_time_args PROC					; COMDAT

; 417  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 418  :     if (h < 0 || h > 23) {

  00016	83 7c 24 30 00	 cmp	 DWORD PTR h$[rsp], 0
  0001b	7c 07		 jl	 SHORT $LN7@check_time
  0001d	83 7c 24 30 17	 cmp	 DWORD PTR h$[rsp], 23
  00022	7e 1a		 jle	 SHORT $LN8@check_time
$LN7@check_time:

; 419  :         PyErr_SetString(PyExc_ValueError,
; 420  :                         "hour must be in 0..23");

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@BMLNJKHN@hour?5must?5be?5in?50?4?423?$AA@
  0002b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00032	e8 00 00 00 00	 call	 PyErr_SetString

; 421  :         return -1;

  00037	b8 ff ff ff ff	 mov	 eax, -1
  0003c	eb 7d		 jmp	 SHORT $LN9@check_time
$LN8@check_time:

; 422  :     }
; 423  :     if (m < 0 || m > 59) {

  0003e	83 7c 24 38 00	 cmp	 DWORD PTR m$[rsp], 0
  00043	7c 07		 jl	 SHORT $LN5@check_time
  00045	83 7c 24 38 3b	 cmp	 DWORD PTR m$[rsp], 59	; 0000003bH
  0004a	7e 1a		 jle	 SHORT $LN6@check_time
$LN5@check_time:

; 424  :         PyErr_SetString(PyExc_ValueError,
; 425  :                         "minute must be in 0..59");

  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@FCAMKLIB@minute?5must?5be?5in?50?4?459?$AA@
  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0005a	e8 00 00 00 00	 call	 PyErr_SetString

; 426  :         return -1;

  0005f	b8 ff ff ff ff	 mov	 eax, -1
  00064	eb 55		 jmp	 SHORT $LN9@check_time
$LN6@check_time:

; 427  :     }
; 428  :     if (s < 0 || s > 59) {

  00066	83 7c 24 40 00	 cmp	 DWORD PTR s$[rsp], 0
  0006b	7c 07		 jl	 SHORT $LN3@check_time
  0006d	83 7c 24 40 3b	 cmp	 DWORD PTR s$[rsp], 59	; 0000003bH
  00072	7e 1a		 jle	 SHORT $LN4@check_time
$LN3@check_time:

; 429  :         PyErr_SetString(PyExc_ValueError,
; 430  :                         "second must be in 0..59");

  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@FHJLBIID@second?5must?5be?5in?50?4?459?$AA@
  0007b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00082	e8 00 00 00 00	 call	 PyErr_SetString

; 431  :         return -1;

  00087	b8 ff ff ff ff	 mov	 eax, -1
  0008c	eb 2d		 jmp	 SHORT $LN9@check_time
$LN4@check_time:

; 432  :     }
; 433  :     if (us < 0 || us > 999999) {

  0008e	83 7c 24 48 00	 cmp	 DWORD PTR us$[rsp], 0
  00093	7c 0a		 jl	 SHORT $LN1@check_time
  00095	81 7c 24 48 3f
	42 0f 00	 cmp	 DWORD PTR us$[rsp], 999999 ; 000f423fH
  0009d	7e 1a		 jle	 SHORT $LN2@check_time
$LN1@check_time:

; 434  :         PyErr_SetString(PyExc_ValueError,
; 435  :                         "microsecond must be in 0..999999");

  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@MAGNOEPP@microsecond?5must?5be?5in?50?4?4999999@
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ad	e8 00 00 00 00	 call	 PyErr_SetString

; 436  :         return -1;

  000b2	b8 ff ff ff ff	 mov	 eax, -1
  000b7	eb 02		 jmp	 SHORT $LN9@check_time
$LN2@check_time:

; 437  :     }
; 438  :     return 0;

  000b9	33 c0		 xor	 eax, eax
$LN9@check_time:

; 439  : }

  000bb	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000bf	c3		 ret	 0
check_time_args ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_dealloc DD imagerel time_dealloc
	DD	imagerel time_dealloc+79
	DD	imagerel $unwind$time_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_dealloc
_TEXT	SEGMENT
self$ = 48
time_dealloc PROC					; COMDAT

; 3534 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3535 :     if (HASTZINFO(self)) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00012	85 c0		 test	 eax, eax
  00014	74 20		 je	 SHORT $LN5@time_deall
$LN4@time_deall:

; 3536 :         Py_XDECREF(self->tzinfo);

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001b	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00020	74 0e		 je	 SHORT $LN1@time_deall
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0002b	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@time_deall:
  00030	33 c0		 xor	 eax, eax
  00032	85 c0		 test	 eax, eax
  00034	75 e0		 jne	 SHORT $LN4@time_deall
$LN5@time_deall:

; 3537 :     }
; 3538 :     Py_TYPE(self)->tp_free((PyObject *)self);

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00044	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 3539 : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
time_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_utcoffset DD imagerel time_utcoffset
	DD	imagerel time_utcoffset+77
	DD	imagerel $unwind$time_utcoffset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_utcoffset DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_utcoffset
_TEXT	SEGMENT
tv70 = 32
self$ = 64
unused$ = 72
time_utcoffset PROC					; COMDAT

; 3547 : time_utcoffset(PyObject *self, PyObject *unused) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3548 :     return call_utcoffset(GET_TIME_TZINFO(self), Py_None);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00017	85 c0		 test	 eax, eax
  00019	74 10		 je	 SHORT $LN3@time_utcof
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
  00029	eb 0c		 jmp	 SHORT $LN4@time_utcof
$LN3@time_utcof:
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00032	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
$LN4@time_utcof:
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv70[rsp]
  00043	e8 00 00 00 00	 call	 call_utcoffset

; 3549 : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
time_utcoffset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_dst DD imagerel time_dst
	DD	imagerel time_dst+77
	DD	imagerel $unwind$time_dst
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_dst DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_dst
_TEXT	SEGMENT
tv70 = 32
self$ = 64
unused$ = 72
time_dst PROC						; COMDAT

; 3552 : time_dst(PyObject *self, PyObject *unused) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3553 :     return call_dst(GET_TIME_TZINFO(self), Py_None);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00017	85 c0		 test	 eax, eax
  00019	74 10		 je	 SHORT $LN3@time_dst
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
  00029	eb 0c		 jmp	 SHORT $LN4@time_dst
$LN3@time_dst:
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00032	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
$LN4@time_dst:
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv70[rsp]
  00043	e8 00 00 00 00	 call	 call_dst

; 3554 : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
time_dst ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_tzname DD imagerel time_tzname
	DD	imagerel time_tzname+77
	DD	imagerel $unwind$time_tzname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_tzname DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_tzname
_TEXT	SEGMENT
tv70 = 32
self$ = 64
unused$ = 72
time_tzname PROC					; COMDAT

; 3557 : time_tzname(PyDateTime_Time *self, PyObject *unused) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3558 :     return call_tzname(GET_TIME_TZINFO(self), Py_None);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00017	85 c0		 test	 eax, eax
  00019	74 10		 je	 SHORT $LN3@time_tznam
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00024	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
  00029	eb 0c		 jmp	 SHORT $LN4@time_tznam
$LN3@time_tznam:
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00032	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
$LN4@time_tznam:
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv70[rsp]
  00043	e8 00 00 00 00	 call	 call_tzname

; 3559 : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
time_tzname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@HDNELIKC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_repr DD imagerel time_repr
	DD	imagerel time_repr+309
	DD	imagerel $unwind$time_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_repr DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_0BD@HDNELIKC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@HDNELIKC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ DB '%'
	DB	's(%d, %d, %d, %d)', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT time_repr
_TEXT	SEGMENT
h$ = 48
type_name$ = 56
s$ = 64
result$ = 72
us$ = 80
m$ = 84
self$ = 112
time_repr PROC						; COMDAT

; 3567 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3568 :     const char *type_name = Py_TYPE(self)->tp_name;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00016	48 89 44 24 38	 mov	 QWORD PTR type_name$[rsp], rax

; 3569 :     int h = TIME_GET_HOUR(self);

  0001b	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00020	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00024	89 44 24 30	 mov	 DWORD PTR h$[rsp], eax

; 3570 :     int m = TIME_GET_MINUTE(self);

  00028	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0002d	0f b6 40 6a	 movzx	 eax, BYTE PTR [rax+106]
  00031	89 44 24 54	 mov	 DWORD PTR m$[rsp], eax

; 3571 :     int s = TIME_GET_SECOND(self);

  00035	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0003a	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  0003e	89 44 24 40	 mov	 DWORD PTR s$[rsp], eax

; 3572 :     int us = TIME_GET_MICROSECOND(self);

  00042	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00047	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  0004b	c1 e0 10	 shl	 eax, 16
  0004e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00053	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  00057	c1 e1 08	 shl	 ecx, 8
  0005a	0b c1		 or	 eax, ecx
  0005c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00061	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  00065	0b c1		 or	 eax, ecx
  00067	89 44 24 50	 mov	 DWORD PTR us$[rsp], eax

; 3573 :     PyObject *result = NULL;

  0006b	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 3574 : 
; 3575 :     if (us)

  00074	83 7c 24 50 00	 cmp	 DWORD PTR us$[rsp], 0
  00079	74 32		 je	 SHORT $LN5@time_repr

; 3576 :         result = PyUnicode_FromFormat("%s(%d, %d, %d, %d)",
; 3577 :                                       type_name, h, m, s, us);

  0007b	8b 44 24 50	 mov	 eax, DWORD PTR us$[rsp]
  0007f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00083	8b 44 24 40	 mov	 eax, DWORD PTR s$[rsp]
  00087	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0008b	44 8b 4c 24 54	 mov	 r9d, DWORD PTR m$[rsp]
  00090	44 8b 44 24 30	 mov	 r8d, DWORD PTR h$[rsp]
  00095	48 8b 54 24 38	 mov	 rdx, QWORD PTR type_name$[rsp]
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@HDNELIKC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  000a1	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000a6	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax
  000ab	eb 51		 jmp	 SHORT $LN4@time_repr
$LN5@time_repr:

; 3578 :     else if (s)

  000ad	83 7c 24 40 00	 cmp	 DWORD PTR s$[rsp], 0
  000b2	74 2a		 je	 SHORT $LN3@time_repr

; 3579 :         result = PyUnicode_FromFormat("%s(%d, %d, %d)",
; 3580 :                                       type_name, h, m, s);

  000b4	8b 44 24 40	 mov	 eax, DWORD PTR s$[rsp]
  000b8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000bc	44 8b 4c 24 54	 mov	 r9d, DWORD PTR m$[rsp]
  000c1	44 8b 44 24 30	 mov	 r8d, DWORD PTR h$[rsp]
  000c6	48 8b 54 24 38	 mov	 rdx, QWORD PTR type_name$[rsp]
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@LIKGBHDC@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  000d2	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000d7	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 3581 :     else

  000dc	eb 20		 jmp	 SHORT $LN2@time_repr
$LN3@time_repr:

; 3582 :         result = PyUnicode_FromFormat("%s(%d, %d)", type_name, h, m);

  000de	44 8b 4c 24 54	 mov	 r9d, DWORD PTR m$[rsp]
  000e3	44 8b 44 24 30	 mov	 r8d, DWORD PTR h$[rsp]
  000e8	48 8b 54 24 38	 mov	 rdx, QWORD PTR type_name$[rsp]
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@KEFADODA@?$CFs?$CI?$CFd?0?5?$CFd?$CJ?$AA@
  000f4	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000f9	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax
$LN2@time_repr:
$LN4@time_repr:

; 3583 :     if (result != NULL && HASTZINFO(self))

  000fe	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  00104	74 25		 je	 SHORT $LN1@time_repr
  00106	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0010b	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  0010f	85 c0		 test	 eax, eax
  00111	74 18		 je	 SHORT $LN1@time_repr

; 3584 :         result = append_keyword_tzinfo(result, self->tzinfo);

  00113	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00118	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  0011c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00121	e8 00 00 00 00	 call	 append_keyword_tzinfo
  00126	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax
$LN1@time_repr:

; 3585 :     return result;

  0012b	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]

; 3586 : }

  00130	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00134	c3		 ret	 0
time_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@GPOFMDAD@?$CFU?0?5tzinfo?$DN?$CFR?$CJ?$AA@ ; `string'
PUBLIC	??_C@_1HO@GNMKBMAP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAR?$AAE?$AAA?$AAD?$AA_?$AAC?$AAH?$AAA?$AAR?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?0?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc@ ; `string'
PUBLIC	??_C@_1EO@GCIGMOBP@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ ; `string'
PUBLIC	??_C@_1DG@MEDLBADO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@FPHHGLOE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@OLHLJMGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@EGIBEFNC@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@CEBKPFIL@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyUnicode_Substring:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$append_keyword_tzinfo DD imagerel append_keyword_tzinfo
	DD	imagerel append_keyword_tzinfo+2136
	DD	imagerel $unwind$append_keyword_tzinfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$append_keyword_tzinfo DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0P@GPOFMDAD@?$CFU?0?5tzinfo?$DN?$CFR?$CJ?$AA@
CONST	SEGMENT
??_C@_0P@GPOFMDAD@?$CFU?0?5tzinfo?$DN?$CFR?$CJ?$AA@ DB '%U, tzinfo=%R)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HO@GNMKBMAP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAR?$AAE?$AAA?$AAD?$AA_?$AAC?$AAH?$AAA?$AAR?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?0?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc@
CONST	SEGMENT
??_C@_1HO@GNMKBMAP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAR?$AAE?$AAA?$AAD?$AA_?$AAC?$AAH?$AAA?$AAR?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?0?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'A', 00H, 'D'
	DB	00H, '_', 00H, 'C', 00H, 'H', 00H, 'A', 00H, 'R', 00H, '(', 00H
	DB	'r', 00H, 'e', 00H, 'p', 00H, 'r', 00H, ',', 00H, ' ', 00H, 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'G', 00H, 'E', 00H, 'T', 00H, '_'
	DB	00H, 'L', 00H, 'E', 00H, 'N', 00H, 'G', 00H, 'T', 00H, 'H', 00H
	DB	'(', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'r', 00H, ')', 00H, '-'
	DB	00H, '1', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'''', 00H, ')', 00H, '''', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@GCIGMOBP@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
CONST	SEGMENT
??_C@_1EO@GCIGMOBP@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'(', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'r', 00H, ')', 00H, ')'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@MEDLBADO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@MEDLBADO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, '(', 00H
	DB	'r', 00H, 'e', 00H, 'p', 00H, 'r', 00H, ')', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@FPHHGLOE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@FPHHGLOE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, '(', 00H, 'r', 00H, 'e', 00H, 'p', 00H
	DB	'r', 00H, ')', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@OLHLJMGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@OLHLJMGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'r', 00H
	DB	'e', 00H, 'p', 00H, 'r', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@EGIBEFNC@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1O@EGIBEFNC@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$AA@ DB 't', 00H, 'z'
	DB	00H, 'i', 00H, 'n', 00H, 'f', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@CEBKPFIL@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@CEBKPFIL@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'r', 00H, 'e', 00H, 'p', 00H, 'r', 00H
	DB	')', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT append_keyword_tzinfo
_TEXT	SEGMENT
temp$ = 32
tv179 = 40
tv188 = 48
tv357 = 56
tv262 = 64
tv271 = 72
tv356 = 80
tv326 = 88
tv335 = 96
repr$ = 128
tzinfo$ = 136
append_keyword_tzinfo PROC				; COMDAT

; 983  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 984  :     PyObject *temp;
; 985  : 
; 986  :     assert(PyUnicode_Check(repr));

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00016	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00020	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00025	85 c0		 test	 eax, eax
  00027	75 1c		 jne	 SHORT $LN5@append_key
  00029	41 b8 da 03 00
	00		 mov	 r8d, 986		; 000003daH
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CEBKPFIL@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00043	33 c0		 xor	 eax, eax
$LN5@append_key:

; 987  :     assert(tzinfo);

  00045	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR tzinfo$[rsp], 0
  0004e	75 1c		 jne	 SHORT $LN6@append_key
  00050	41 b8 db 03 00
	00		 mov	 r8d, 987		; 000003dbH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1O@EGIBEFNC@?$AAt?$AAz?$AAi?$AAn?$AAf?$AAo?$AA?$AA@
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0006a	33 c0		 xor	 eax, eax
$LN6@append_key:

; 988  :     if (tzinfo == Py_None)

  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00073	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR tzinfo$[rsp], rax
  0007b	75 0d		 jne	 SHORT $LN2@append_key

; 989  :         return repr;

  0007d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00085	e9 c9 07 00 00	 jmp	 $LN3@append_key
$LN2@append_key:

; 990  :     /* Get rid of the trailing ')'. */
; 991  :     assert(PyUnicode_READ_CHAR(repr, PyUnicode_GET_LENGTH(repr)-1) == ')');

  0008a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00092	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00096	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000a1	85 c0		 test	 eax, eax
  000a3	75 1c		 jne	 SHORT $LN7@append_key
  000a5	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CEBKPFIL@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000bf	33 c0		 xor	 eax, eax
$LN7@append_key:
  000c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  000c9	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000cc	c1 e8 07	 shr	 eax, 7
  000cf	83 e0 01	 and	 eax, 1
  000d2	85 c0		 test	 eax, eax
  000d4	75 1c		 jne	 SHORT $LN8@append_key
  000d6	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@OLHLJMGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f0	33 c0		 xor	 eax, eax
$LN8@append_key:
  000f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  000fa	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000fe	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00104	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00109	85 c0		 test	 eax, eax
  0010b	75 1c		 jne	 SHORT $LN9@append_key
  0010d	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  00113	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FPHHGLOE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00127	33 c0		 xor	 eax, eax
$LN9@append_key:
  00129	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00131	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00134	c1 e8 07	 shr	 eax, 7
  00137	83 e0 01	 and	 eax, 1
  0013a	85 c0		 test	 eax, eax
  0013c	75 1c		 jne	 SHORT $LN10@append_key
  0013e	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MEDLBADO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00158	33 c0		 xor	 eax, eax
$LN10@append_key:
  0015a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00162	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00165	c1 e8 02	 shr	 eax, 2
  00168	83 e0 07	 and	 eax, 7
  0016b	83 f8 01	 cmp	 eax, 1
  0016e	0f 85 ca 01 00
	00		 jne	 $LN45@append_key
  00174	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  0017c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00180	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00186	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0018b	85 c0		 test	 eax, eax
  0018d	75 1c		 jne	 SHORT $LN11@append_key
  0018f	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  00195	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0019c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FPHHGLOE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001a9	33 c0		 xor	 eax, eax
$LN11@append_key:
  001ab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  001b3	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001b6	c1 e8 05	 shr	 eax, 5
  001b9	83 e0 01	 and	 eax, 1
  001bc	85 c0		 test	 eax, eax
  001be	0f 84 b1 00 00
	00		 je	 $LN17@append_key
  001c4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  001cc	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001d0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001d6	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  001db	85 c0		 test	 eax, eax
  001dd	75 1c		 jne	 SHORT $LN12@append_key
  001df	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  001e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FPHHGLOE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001f9	33 c0		 xor	 eax, eax
$LN12@append_key:
  001fb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00203	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00206	c1 e8 07	 shr	 eax, 7
  00209	83 e0 01	 and	 eax, 1
  0020c	85 c0		 test	 eax, eax
  0020e	75 1c		 jne	 SHORT $LN13@append_key
  00210	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  00216	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0021d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MEDLBADO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00224	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0022a	33 c0		 xor	 eax, eax
$LN13@append_key:
  0022c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00234	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00237	c1 e8 06	 shr	 eax, 6
  0023a	83 e0 01	 and	 eax, 1
  0023d	85 c0		 test	 eax, eax
  0023f	74 15		 je	 SHORT $LN14@append_key
  00241	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00249	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0024f	48 89 44 24 28	 mov	 QWORD PTR tv179[rsp], rax
  00254	eb 13		 jmp	 SHORT $LN15@append_key
$LN14@append_key:
  00256	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  0025e	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  00264	48 89 44 24 28	 mov	 QWORD PTR tv179[rsp], rax
$LN15@append_key:
  00269	48 8b 44 24 28	 mov	 rax, QWORD PTR tv179[rsp]
  0026e	48 89 44 24 30	 mov	 QWORD PTR tv188[rsp], rax
  00273	eb 42		 jmp	 SHORT $LN18@append_key
$LN17@append_key:
  00275	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  0027d	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00285	75 1c		 jne	 SHORT $LN16@append_key
  00287	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  0028d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00294	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@GCIGMOBP@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002a1	33 c0		 xor	 eax, eax
$LN16@append_key:
  002a3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  002ab	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  002b2	48 89 44 24 30	 mov	 QWORD PTR tv188[rsp], rax
$LN18@append_key:
  002b7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  002bf	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002c3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002c9	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  002ce	85 c0		 test	 eax, eax
  002d0	75 1c		 jne	 SHORT $LN19@append_key
  002d2	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  002d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CEBKPFIL@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  002e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ec	33 c0		 xor	 eax, eax
$LN19@append_key:
  002ee	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  002f6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002f9	c1 e8 07	 shr	 eax, 7
  002fc	83 e0 01	 and	 eax, 1
  002ff	85 c0		 test	 eax, eax
  00301	75 1c		 jne	 SHORT $LN20@append_key
  00303	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  00309	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00310	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@OLHLJMGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  00317	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0031d	33 c0		 xor	 eax, eax
$LN20@append_key:
  0031f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00327	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0032b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv188[rsp]
  00330	0f b6 44 01 ff	 movzx	 eax, BYTE PTR [rcx+rax-1]
  00335	89 44 24 38	 mov	 DWORD PTR tv357[rsp], eax
  00339	e9 18 04 00 00	 jmp	 $LN46@append_key
$LN45@append_key:
  0033e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00346	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0034a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00350	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00355	85 c0		 test	 eax, eax
  00357	75 1c		 jne	 SHORT $LN21@append_key
  00359	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  0035f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00366	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FPHHGLOE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0036d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00373	33 c0		 xor	 eax, eax
$LN21@append_key:
  00375	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  0037d	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00380	c1 e8 07	 shr	 eax, 7
  00383	83 e0 01	 and	 eax, 1
  00386	85 c0		 test	 eax, eax
  00388	75 1c		 jne	 SHORT $LN22@append_key
  0038a	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  00390	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00397	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MEDLBADO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0039e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003a4	33 c0		 xor	 eax, eax
$LN22@append_key:
  003a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  003ae	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  003b1	c1 e8 02	 shr	 eax, 2
  003b4	83 e0 07	 and	 eax, 7
  003b7	83 f8 02	 cmp	 eax, 2
  003ba	0f 85 ca 01 00
	00		 jne	 $LN43@append_key
  003c0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  003c8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003cc	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003d2	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  003d7	85 c0		 test	 eax, eax
  003d9	75 1c		 jne	 SHORT $LN23@append_key
  003db	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  003e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  003e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FPHHGLOE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  003ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003f5	33 c0		 xor	 eax, eax
$LN23@append_key:
  003f7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  003ff	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00402	c1 e8 05	 shr	 eax, 5
  00405	83 e0 01	 and	 eax, 1
  00408	85 c0		 test	 eax, eax
  0040a	0f 84 b1 00 00
	00		 je	 $LN29@append_key
  00410	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00418	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0041c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00422	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00427	85 c0		 test	 eax, eax
  00429	75 1c		 jne	 SHORT $LN24@append_key
  0042b	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  00431	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00438	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FPHHGLOE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0043f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00445	33 c0		 xor	 eax, eax
$LN24@append_key:
  00447	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  0044f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00452	c1 e8 07	 shr	 eax, 7
  00455	83 e0 01	 and	 eax, 1
  00458	85 c0		 test	 eax, eax
  0045a	75 1c		 jne	 SHORT $LN25@append_key
  0045c	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  00462	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00469	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MEDLBADO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00470	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00476	33 c0		 xor	 eax, eax
$LN25@append_key:
  00478	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00480	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00483	c1 e8 06	 shr	 eax, 6
  00486	83 e0 01	 and	 eax, 1
  00489	85 c0		 test	 eax, eax
  0048b	74 15		 je	 SHORT $LN26@append_key
  0048d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00495	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0049b	48 89 44 24 40	 mov	 QWORD PTR tv262[rsp], rax
  004a0	eb 13		 jmp	 SHORT $LN27@append_key
$LN26@append_key:
  004a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  004aa	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  004b0	48 89 44 24 40	 mov	 QWORD PTR tv262[rsp], rax
$LN27@append_key:
  004b5	48 8b 44 24 40	 mov	 rax, QWORD PTR tv262[rsp]
  004ba	48 89 44 24 48	 mov	 QWORD PTR tv271[rsp], rax
  004bf	eb 42		 jmp	 SHORT $LN30@append_key
$LN29@append_key:
  004c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  004c9	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  004d1	75 1c		 jne	 SHORT $LN28@append_key
  004d3	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  004d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  004e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@GCIGMOBP@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  004e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004ed	33 c0		 xor	 eax, eax
$LN28@append_key:
  004ef	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  004f7	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  004fe	48 89 44 24 48	 mov	 QWORD PTR tv271[rsp], rax
$LN30@append_key:
  00503	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  0050b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0050f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00515	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0051a	85 c0		 test	 eax, eax
  0051c	75 1c		 jne	 SHORT $LN31@append_key
  0051e	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  00524	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0052b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CEBKPFIL@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  00532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00538	33 c0		 xor	 eax, eax
$LN31@append_key:
  0053a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00542	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00545	c1 e8 07	 shr	 eax, 7
  00548	83 e0 01	 and	 eax, 1
  0054b	85 c0		 test	 eax, eax
  0054d	75 1c		 jne	 SHORT $LN32@append_key
  0054f	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  00555	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0055c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@OLHLJMGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  00563	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00569	33 c0		 xor	 eax, eax
$LN32@append_key:
  0056b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00573	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00577	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv271[rsp]
  0057c	0f b7 44 41 fe	 movzx	 eax, WORD PTR [rcx+rax*2-2]
  00581	89 44 24 50	 mov	 DWORD PTR tv356[rsp], eax
  00585	e9 c4 01 00 00	 jmp	 $LN44@append_key
$LN43@append_key:
  0058a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00592	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00596	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0059c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  005a1	85 c0		 test	 eax, eax
  005a3	75 1c		 jne	 SHORT $LN33@append_key
  005a5	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  005ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  005b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FPHHGLOE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  005b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005bf	33 c0		 xor	 eax, eax
$LN33@append_key:
  005c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  005c9	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  005cc	c1 e8 05	 shr	 eax, 5
  005cf	83 e0 01	 and	 eax, 1
  005d2	85 c0		 test	 eax, eax
  005d4	0f 84 b1 00 00
	00		 je	 $LN39@append_key
  005da	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  005e2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005e6	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005ec	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  005f1	85 c0		 test	 eax, eax
  005f3	75 1c		 jne	 SHORT $LN34@append_key
  005f5	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  005fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00602	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FPHHGLOE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00609	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0060f	33 c0		 xor	 eax, eax
$LN34@append_key:
  00611	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00619	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0061c	c1 e8 07	 shr	 eax, 7
  0061f	83 e0 01	 and	 eax, 1
  00622	85 c0		 test	 eax, eax
  00624	75 1c		 jne	 SHORT $LN35@append_key
  00626	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  0062c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00633	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MEDLBADO@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0063a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00640	33 c0		 xor	 eax, eax
$LN35@append_key:
  00642	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  0064a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0064d	c1 e8 06	 shr	 eax, 6
  00650	83 e0 01	 and	 eax, 1
  00653	85 c0		 test	 eax, eax
  00655	74 15		 je	 SHORT $LN36@append_key
  00657	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  0065f	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00665	48 89 44 24 58	 mov	 QWORD PTR tv326[rsp], rax
  0066a	eb 13		 jmp	 SHORT $LN37@append_key
$LN36@append_key:
  0066c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00674	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0067a	48 89 44 24 58	 mov	 QWORD PTR tv326[rsp], rax
$LN37@append_key:
  0067f	48 8b 44 24 58	 mov	 rax, QWORD PTR tv326[rsp]
  00684	48 89 44 24 60	 mov	 QWORD PTR tv335[rsp], rax
  00689	eb 42		 jmp	 SHORT $LN40@append_key
$LN39@append_key:
  0068b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00693	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  0069b	75 1c		 jne	 SHORT $LN38@append_key
  0069d	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  006a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  006aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@GCIGMOBP@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  006b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  006b7	33 c0		 xor	 eax, eax
$LN38@append_key:
  006b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  006c1	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  006c8	48 89 44 24 60	 mov	 QWORD PTR tv335[rsp], rax
$LN40@append_key:
  006cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  006d5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  006d9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  006df	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  006e4	85 c0		 test	 eax, eax
  006e6	75 1c		 jne	 SHORT $LN41@append_key
  006e8	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  006ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  006f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CEBKPFIL@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  006fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00702	33 c0		 xor	 eax, eax
$LN41@append_key:
  00704	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  0070c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0070f	c1 e8 07	 shr	 eax, 7
  00712	83 e0 01	 and	 eax, 1
  00715	85 c0		 test	 eax, eax
  00717	75 1c		 jne	 SHORT $LN42@append_key
  00719	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  0071f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00726	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@OLHLJMGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  0072d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00733	33 c0		 xor	 eax, eax
$LN42@append_key:
  00735	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  0073d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00741	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv335[rsp]
  00746	8b 44 81 fc	 mov	 eax, DWORD PTR [rcx+rax*4-4]
  0074a	89 44 24 50	 mov	 DWORD PTR tv356[rsp], eax
$LN44@append_key:
  0074e	8b 44 24 50	 mov	 eax, DWORD PTR tv356[rsp]
  00752	89 44 24 38	 mov	 DWORD PTR tv357[rsp], eax
$LN46@append_key:
  00756	83 7c 24 38 29	 cmp	 DWORD PTR tv357[rsp], 41 ; 00000029H
  0075b	74 1c		 je	 SHORT $LN47@append_key
  0075d	41 b8 df 03 00
	00		 mov	 r8d, 991		; 000003dfH
  00763	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0076a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HO@GNMKBMAP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAR?$AAE?$AAA?$AAD?$AA_?$AAC?$AAH?$AAA?$AAR?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?0?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc@
  00771	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00777	33 c0		 xor	 eax, eax
$LN47@append_key:

; 992  :     temp = PyUnicode_Substring(repr, 0, PyUnicode_GET_LENGTH(repr) - 1);

  00779	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  00781	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00785	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0078b	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00790	85 c0		 test	 eax, eax
  00792	75 1c		 jne	 SHORT $LN48@append_key
  00794	41 b8 e0 03 00
	00		 mov	 r8d, 992		; 000003e0H
  0079a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  007a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@CEBKPFIL@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  007a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  007ae	33 c0		 xor	 eax, eax
$LN48@append_key:
  007b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  007b8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  007bb	c1 e8 07	 shr	 eax, 7
  007be	83 e0 01	 and	 eax, 1
  007c1	85 c0		 test	 eax, eax
  007c3	75 1c		 jne	 SHORT $LN49@append_key
  007c5	41 b8 e0 03 00
	00		 mov	 r8d, 992		; 000003e0H
  007cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  007d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@OLHLJMGC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAp?$AAr?$AA?$CJ?$AA?$AA@
  007d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  007df	33 c0		 xor	 eax, eax
$LN49@append_key:
  007e1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
  007e9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  007ed	48 ff c8	 dec	 rax
  007f0	4c 8b c0	 mov	 r8, rax
  007f3	33 d2		 xor	 edx, edx
  007f5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR repr$[rsp]
  007fd	e8 00 00 00 00	 call	 PyUnicode_Substring
  00802	48 89 44 24 20	 mov	 QWORD PTR temp$[rsp], rax

; 993  :     Py_DECREF(repr);

  00807	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR repr$[rsp]
  0080f	e8 00 00 00 00	 call	 _Py_DecRef

; 994  :     if (temp == NULL)

  00814	48 83 7c 24 20
	00		 cmp	 QWORD PTR temp$[rsp], 0
  0081a	75 04		 jne	 SHORT $LN1@append_key

; 995  :         return NULL;

  0081c	33 c0		 xor	 eax, eax
  0081e	eb 33		 jmp	 SHORT $LN3@append_key
$LN1@append_key:

; 996  :     repr = PyUnicode_FromFormat("%U, tzinfo=%R)", temp, tzinfo);

  00820	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR tzinfo$[rsp]
  00828	48 8b 54 24 20	 mov	 rdx, QWORD PTR temp$[rsp]
  0082d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@GPOFMDAD@?$CFU?0?5tzinfo?$DN?$CFR?$CJ?$AA@
  00834	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00839	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR repr$[rsp], rax

; 997  :     Py_DECREF(temp);

  00841	48 8b 4c 24 20	 mov	 rcx, QWORD PTR temp$[rsp]
  00846	e8 00 00 00 00	 call	 _Py_DecRef

; 998  :     return repr;

  0084b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR repr$[rsp]
$LN3@append_key:

; 999  : }

  00853	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00857	c3		 ret	 0
append_keyword_tzinfo ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_str DD imagerel time_str
	DD	imagerel time_str+60
	DD	imagerel $unwind$time_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_str DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_str
_TEXT	SEGMENT
self$ = 48
time_str PROC						; COMDAT

; 3590 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3591 :     _Py_IDENTIFIER(isoformat);
; 3592 : 
; 3593 :     return _PyObject_CallMethodId((PyObject *)self, &PyId_isoformat, "()");

  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_isoformat@?1??time_str@@9@9
  0000e	8b c0		 mov	 eax, eax
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00016	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0001f	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00023	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  0002a	48 8b d0	 mov	 rdx, rax
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00032	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 3594 : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
time_str ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@ ; `string'
PUBLIC	??_C@_0BE@MLECEOFF@?$CF02d?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ ; `string'
EXTRN	PyUnicode_AppendAndDel:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_isoformat DD imagerel time_isoformat
	DD	imagerel time_isoformat+386
	DD	imagerel $unwind$time_isoformat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_isoformat DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@ DB '%02d:%02d:%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MLECEOFF@?$CF02d?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
CONST	SEGMENT
??_C@_0BE@MLECEOFF@?$CF02d?3?$CF02d?3?$CF02d?4?$CF06d?$AA@ DB '%02d:%02d:'
	DB	'%02d.%06d', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT time_isoformat
_TEXT	SEGMENT
buf$ = 48
us$ = 160
result$ = 168
self$ = 192
unused$ = 200
time_isoformat PROC					; COMDAT

; 3598 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 3599 :     char buf[100];
; 3600 :     PyObject *result;
; 3601 :     int us = TIME_GET_MICROSECOND(self);

  00011	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00019	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  0001d	c1 e0 10	 shl	 eax, 16
  00020	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00028	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  0002c	c1 e1 08	 shl	 ecx, 8
  0002f	0b c1		 or	 eax, ecx
  00031	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00039	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  0003d	0b c1		 or	 eax, ecx
  0003f	89 84 24 a0 00
	00 00		 mov	 DWORD PTR us$[rsp], eax

; 3602 : 
; 3603 :     if (us)

  00046	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR us$[rsp], 0
  0004e	74 4d		 je	 SHORT $LN5@time_isofo

; 3604 :         result = PyUnicode_FromFormat("%02d:%02d:%02d.%06d",
; 3605 :                                       TIME_GET_HOUR(self),
; 3606 :                                       TIME_GET_MINUTE(self),
; 3607 :                                       TIME_GET_SECOND(self),
; 3608 :                                       us);

  00050	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00058	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  0005c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00064	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00068	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  00070	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  00074	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR us$[rsp]
  0007c	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  00081	44 8b c8	 mov	 r9d, eax
  00084	44 8b c1	 mov	 r8d, ecx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@MLECEOFF@?$CF02d?3?$CF02d?3?$CF02d?4?$CF06d?$AA@
  0008e	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00093	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR result$[rsp], rax

; 3609 :     else

  0009b	eb 3e		 jmp	 SHORT $LN4@time_isofo
$LN5@time_isofo:

; 3610 :         result = PyUnicode_FromFormat("%02d:%02d:%02d",
; 3611 :                                       TIME_GET_HOUR(self),
; 3612 :                                       TIME_GET_MINUTE(self),
; 3613 :                                       TIME_GET_SECOND(self));

  0009d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000a5	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  000a9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000b1	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  000b5	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  000bd	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  000c1	44 8b c8	 mov	 r9d, eax
  000c4	44 8b c1	 mov	 r8d, ecx
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@PLMNPDMB@?$CF02d?3?$CF02d?3?$CF02d?$AA@
  000ce	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000d3	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR result$[rsp], rax
$LN4@time_isofo:

; 3614 : 
; 3615 :     if (result == NULL || !HASTZINFO(self) || self->tzinfo == Py_None)

  000db	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR result$[rsp], 0
  000e4	74 25		 je	 SHORT $LN2@time_isofo
  000e6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000ee	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  000f2	85 c0		 test	 eax, eax
  000f4	74 15		 je	 SHORT $LN2@time_isofo
  000f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000fd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00105	48 39 41 70	 cmp	 QWORD PTR [rcx+112], rax
  00109	75 0a		 jne	 SHORT $LN3@time_isofo
$LN2@time_isofo:

; 3616 :         return result;

  0010b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00113	eb 65		 jmp	 SHORT $LN6@time_isofo
$LN3@time_isofo:

; 3617 : 
; 3618 :     /* We need to append the UTC offset. */
; 3619 :     if (format_utcoffset(buf, sizeof(buf), ":", self->tzinfo,
; 3620 :                          Py_None) < 0) {

  00115	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0011c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00121	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00129	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  0012d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  00134	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  00139	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  0013e	e8 00 00 00 00	 call	 format_utcoffset
  00143	85 c0		 test	 eax, eax
  00145	7d 11		 jge	 SHORT $LN1@time_isofo

; 3621 :         Py_DECREF(result);

  00147	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  0014f	e8 00 00 00 00	 call	 _Py_DecRef

; 3622 :         return NULL;

  00154	33 c0		 xor	 eax, eax
  00156	eb 22		 jmp	 SHORT $LN6@time_isofo
$LN1@time_isofo:

; 3623 :     }
; 3624 :     PyUnicode_AppendAndDel(&result, PyUnicode_FromString(buf));

  00158	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  0015d	e8 00 00 00 00	 call	 PyUnicode_FromString
  00162	48 8b d0	 mov	 rdx, rax
  00165	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR result$[rsp]
  0016d	e8 00 00 00 00	 call	 PyUnicode_AppendAndDel

; 3625 :     return result;

  00172	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN6@time_isofo:

; 3626 : }

  0017a	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00181	c3		 ret	 0
time_isoformat ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DC@LIFPLMHE@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AAu?$AAp?$AAl?$AAe?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA9?$AA?$AA@ ; `string'
PUBLIC	??_C@_09BOADOOAM@iiiiiiiii?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_strftime DD imagerel time_strftime
	DD	imagerel time_strftime+293
	DD	imagerel $unwind$time_strftime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_strftime DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_1DC@LIFPLMHE@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AAu?$AAp?$AAl?$AAe?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA9?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@LIFPLMHE@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AAu?$AAp?$AAl?$AAe?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA9?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'T', 00H, 'u', 00H, 'p', 00H, 'l', 00H, 'e', 00H
	DB	'_', 00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '(', 00H, 't'
	DB	00H, 'u', 00H, 'p', 00H, 'l', 00H, 'e', 00H, ')', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '9', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09BOADOOAM@iiiiiiiii?$AA@
CONST	SEGMENT
??_C@_09BOADOOAM@iiiiiiiii?$AA@ DB 'iiiiiiiii', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT time_strftime
_TEXT	SEGMENT
format$ = 80
tuple$ = 88
result$ = 96
self$ = 128
args$ = 136
kw$ = 144
time_strftime PROC					; COMDAT

; 3630 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 3631 :     PyObject *result;
; 3632 :     PyObject *tuple;
; 3633 :     PyObject *format;
; 3634 :     static char *keywords[] = {"format", NULL};
; 3635 : 
; 3636 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "U:strftime", keywords,
; 3637 :                                       &format))

  00013	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??time_strftime@@9@9
  00024	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@LENHFJKM@U?3strftime?$AA@
  0002b	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0003b	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00040	85 c0		 test	 eax, eax
  00042	75 07		 jne	 SHORT $LN2@time_strft

; 3638 :         return NULL;

  00044	33 c0		 xor	 eax, eax
  00046	e9 d5 00 00 00	 jmp	 $LN3@time_strft
$LN2@time_strft:

; 3639 : 
; 3640 :     /* Python's strftime does insane things with the year part of the
; 3641 :      * timetuple.  The year is forced to (the otherwise nonsensical)
; 3642 :      * 1900 to work around that.
; 3643 :      */
; 3644 :     tuple = Py_BuildValue("iiiiiiiii",
; 3645 :                           1900, 1, 1, /* year, month, day */
; 3646 :                   TIME_GET_HOUR(self),
; 3647 :                   TIME_GET_MINUTE(self),
; 3648 :                   TIME_GET_SECOND(self),
; 3649 :                   0, 1, -1); /* weekday, daynum, dst */

  0004b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00053	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  00057	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0005f	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00063	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  0006b	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  0006f	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR [rsp+72], -1
  00077	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR [rsp+64], 1
  0007f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00088	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0008c	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00090	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  00094	41 b9 01 00 00
	00		 mov	 r9d, 1
  0009a	41 b8 01 00 00
	00		 mov	 r8d, 1
  000a0	ba 6c 07 00 00	 mov	 edx, 1900		; 0000076cH
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09BOADOOAM@iiiiiiiii?$AA@
  000ac	e8 00 00 00 00	 call	 Py_BuildValue
  000b1	48 89 44 24 58	 mov	 QWORD PTR tuple$[rsp], rax

; 3650 :     if (tuple == NULL)

  000b6	48 83 7c 24 58
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  000bc	75 04		 jne	 SHORT $LN1@time_strft

; 3651 :         return NULL;

  000be	33 c0		 xor	 eax, eax
  000c0	eb 5e		 jmp	 SHORT $LN3@time_strft
$LN1@time_strft:

; 3652 :     assert(PyTuple_Size(tuple) == 9);

  000c2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tuple$[rsp]
  000c7	e8 00 00 00 00	 call	 PyTuple_Size
  000cc	48 83 f8 09	 cmp	 rax, 9
  000d0	74 1c		 je	 SHORT $LN5@time_strft
  000d2	41 b8 44 0e 00
	00		 mov	 r8d, 3652		; 00000e44H
  000d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@LIFPLMHE@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAS?$AAi?$AAz?$AAe?$AA?$CI?$AAt?$AAu?$AAp?$AAl?$AAe?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA9?$AA?$AA@
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ec	33 c0		 xor	 eax, eax
$LN5@time_strft:

; 3653 :     result = wrap_strftime((PyObject *)self, format, tuple,
; 3654 :                            Py_None);

  000ee	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  000f5	4c 8b 44 24 58	 mov	 r8, QWORD PTR tuple$[rsp]
  000fa	48 8b 54 24 50	 mov	 rdx, QWORD PTR format$[rsp]
  000ff	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00107	e8 00 00 00 00	 call	 wrap_strftime
  0010c	48 89 44 24 60	 mov	 QWORD PTR result$[rsp], rax

; 3655 :     Py_DECREF(tuple);

  00111	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tuple$[rsp]
  00116	e8 00 00 00 00	 call	 _Py_DecRef

; 3656 :     return result;

  0011b	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
$LN3@time_strft:

; 3657 : }

  00120	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00124	c3		 ret	 0
time_strftime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DC@KAMMMLPO@can?8t?5compare?5offset?9naive?5and?5o@ ; `string'
PUBLIC	??_C@_1CG@DINEGPHF@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA1?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA2?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_richcompare DD imagerel time_richcompare
	DD	imagerel time_richcompare+956
	DD	imagerel $unwind$time_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_richcompare DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0DC@KAMMMLPO@can?8t?5compare?5offset?9naive?5and?5o@
CONST	SEGMENT
??_C@_0DC@KAMMMLPO@can?8t?5compare?5offset?9naive?5and?5o@ DB 'can''t com'
	DB	'pare offset-naive and offset-aware times', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@DINEGPHF@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA1?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@DINEGPHF@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA1?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA2?$AA?$AA@ DB 'o'
	DB	00H, 'f', 00H, 'f', 00H, 's', 00H, 'e', 00H, 't', 00H, '1', 00H
	DB	' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'o', 00H, 'f', 00H, 'f'
	DB	00H, 's', 00H, 'e', 00H, 't', 00H, '2', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT time_richcompare
_TEXT	SEGMENT
offset1$ = 32
offset2$ = 40
result$ = 48
diff$ = 56
offsecs2$23578 = 60
offsecs1$23577 = 64
tv76 = 72
tv81 = 80
self$ = 112
other$ = 120
op$ = 128
time_richcompare PROC					; COMDAT

; 3665 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3666 :     PyObject *result = NULL;

  00013	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 3667 :     PyObject *offset1, *offset2;
; 3668 :     int diff;
; 3669 : 
; 3670 :     if (! PyTime_Check(other))

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TimeType
  00023	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  00028	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002c	74 31		 je	 SHORT $LN20@time_richc
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_TimeType
  00035	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  0003a	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0003e	e8 00 00 00 00	 call	 PyType_IsSubtype
  00043	85 c0		 test	 eax, eax
  00045	75 18		 jne	 SHORT $LN20@time_richc

; 3671 :         Py_RETURN_NOTIMPLEMENTED;

  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  0004e	e8 00 00 00 00	 call	 _Py_IncRef
  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0005a	e9 58 03 00 00	 jmp	 $LN21@time_richc
$LN20@time_richc:

; 3672 : 
; 3673 :     if (GET_TIME_TZINFO(self) == GET_TIME_TZINFO(other)) {

  0005f	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00064	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00068	85 c0		 test	 eax, eax
  0006a	74 10		 je	 SHORT $LN23@time_richc
  0006c	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00071	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00075	48 89 44 24 48	 mov	 QWORD PTR tv76[rsp], rax
  0007a	eb 0c		 jmp	 SHORT $LN24@time_richc
$LN23@time_richc:
  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00083	48 89 44 24 48	 mov	 QWORD PTR tv76[rsp], rax
$LN24@time_richc:
  00088	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  0008d	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00091	85 c0		 test	 eax, eax
  00093	74 10		 je	 SHORT $LN25@time_richc
  00095	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  0009a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0009e	48 89 44 24 50	 mov	 QWORD PTR tv81[rsp], rax
  000a3	eb 0c		 jmp	 SHORT $LN26@time_richc
$LN25@time_richc:
  000a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ac	48 89 44 24 50	 mov	 QWORD PTR tv81[rsp], rax
$LN26@time_richc:
  000b1	48 8b 44 24 50	 mov	 rax, QWORD PTR tv81[rsp]
  000b6	48 39 44 24 48	 cmp	 QWORD PTR tv76[rsp], rax
  000bb	75 39		 jne	 SHORT $LN19@time_richc

; 3674 :         diff = memcmp(((PyDateTime_Time *)self)->data,
; 3675 :                       ((PyDateTime_Time *)other)->data,
; 3676 :                       _PyDateTime_TIME_DATASIZE);

  000bd	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  000c2	48 83 c0 69	 add	 rax, 105		; 00000069H
  000c6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000cb	48 83 c1 69	 add	 rcx, 105		; 00000069H
  000cf	41 b8 06 00 00
	00		 mov	 r8d, 6
  000d5	48 8b d0	 mov	 rdx, rax
  000d8	e8 00 00 00 00	 call	 memcmp
  000dd	89 44 24 38	 mov	 DWORD PTR diff$[rsp], eax

; 3677 :         return diff_to_bool(diff, op);

  000e1	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR op$[rsp]
  000e8	8b 4c 24 38	 mov	 ecx, DWORD PTR diff$[rsp]
  000ec	e8 00 00 00 00	 call	 diff_to_bool
  000f1	e9 c1 02 00 00	 jmp	 $LN21@time_richc
$LN19@time_richc:

; 3678 :     }
; 3679 :     offset1 = time_utcoffset(self, NULL);

  000f6	33 d2		 xor	 edx, edx
  000f8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000fd	e8 00 00 00 00	 call	 time_utcoffset
  00102	48 89 44 24 20	 mov	 QWORD PTR offset1$[rsp], rax

; 3680 :     if (offset1 == NULL)

  00107	48 83 7c 24 20
	00		 cmp	 QWORD PTR offset1$[rsp], 0
  0010d	75 07		 jne	 SHORT $LN18@time_richc

; 3681 :         return NULL;

  0010f	33 c0		 xor	 eax, eax
  00111	e9 a1 02 00 00	 jmp	 $LN21@time_richc
$LN18@time_richc:

; 3682 :     offset2 = time_utcoffset(other, NULL);

  00116	33 d2		 xor	 edx, edx
  00118	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  0011d	e8 00 00 00 00	 call	 time_utcoffset
  00122	48 89 44 24 28	 mov	 QWORD PTR offset2$[rsp], rax

; 3683 :     if (offset2 == NULL)

  00127	48 83 7c 24 28
	00		 cmp	 QWORD PTR offset2$[rsp], 0
  0012d	75 05		 jne	 SHORT $LN17@time_richc

; 3684 :         goto done;

  0012f	e9 5c 02 00 00	 jmp	 $done$23564
$LN17@time_richc:

; 3685 :     /* If they're both naive, or both aware and have the same offsets,
; 3686 :      * we get off cheap.  Note that if they're both naive, offset1 ==
; 3687 :      * offset2 == Py_None at this point.
; 3688 :      */
; 3689 :     if ((offset1 == offset2) ||
; 3690 :         (PyDelta_Check(offset1) && PyDelta_Check(offset2) &&
; 3691 :          delta_cmp(offset1, offset2) == 0)) {

  00134	48 8b 44 24 28	 mov	 rax, QWORD PTR offset2$[rsp]
  00139	48 39 44 24 20	 cmp	 QWORD PTR offset1$[rsp], rax
  0013e	74 69		 je	 SHORT $LN15@time_richc
  00140	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00147	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset1$[rsp]
  0014c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00150	74 19		 je	 SHORT $LN14@time_richc
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00159	48 8b 44 24 20	 mov	 rax, QWORD PTR offset1$[rsp]
  0015e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00162	e8 00 00 00 00	 call	 PyType_IsSubtype
  00167	85 c0		 test	 eax, eax
  00169	74 7c		 je	 SHORT $LN16@time_richc
$LN14@time_richc:
  0016b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00172	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset2$[rsp]
  00177	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0017b	74 19		 je	 SHORT $LN13@time_richc
  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00184	48 8b 44 24 28	 mov	 rax, QWORD PTR offset2$[rsp]
  00189	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0018d	e8 00 00 00 00	 call	 PyType_IsSubtype
  00192	85 c0		 test	 eax, eax
  00194	74 51		 je	 SHORT $LN16@time_richc
$LN13@time_richc:
  00196	48 8b 54 24 28	 mov	 rdx, QWORD PTR offset2$[rsp]
  0019b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset1$[rsp]
  001a0	e8 00 00 00 00	 call	 delta_cmp
  001a5	85 c0		 test	 eax, eax
  001a7	75 3e		 jne	 SHORT $LN16@time_richc
$LN15@time_richc:

; 3692 :         diff = memcmp(((PyDateTime_Time *)self)->data,
; 3693 :                       ((PyDateTime_Time *)other)->data,
; 3694 :                       _PyDateTime_TIME_DATASIZE);

  001a9	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  001ae	48 83 c0 69	 add	 rax, 105		; 00000069H
  001b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001b7	48 83 c1 69	 add	 rcx, 105		; 00000069H
  001bb	41 b8 06 00 00
	00		 mov	 r8d, 6
  001c1	48 8b d0	 mov	 rdx, rax
  001c4	e8 00 00 00 00	 call	 memcmp
  001c9	89 44 24 38	 mov	 DWORD PTR diff$[rsp], eax

; 3695 :         result = diff_to_bool(diff, op);

  001cd	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR op$[rsp]
  001d4	8b 4c 24 38	 mov	 ecx, DWORD PTR diff$[rsp]
  001d8	e8 00 00 00 00	 call	 diff_to_bool
  001dd	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
  001e2	e9 a9 01 00 00	 jmp	 $LN12@time_richc
$LN16@time_richc:

; 3696 :     }
; 3697 :     /* The hard case: both aware with different UTC offsets */
; 3698 :     else if (offset1 != Py_None && offset2 != Py_None) {

  001e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001ee	48 39 44 24 20	 cmp	 QWORD PTR offset1$[rsp], rax
  001f3	0f 84 40 01 00
	00		 je	 $LN11@time_richc
  001f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00200	48 39 44 24 28	 cmp	 QWORD PTR offset2$[rsp], rax
  00205	0f 84 2e 01 00
	00		 je	 $LN11@time_richc

; 3699 :         int offsecs1, offsecs2;
; 3700 :         assert(offset1 != offset2); /* else last "if" handled it */

  0020b	48 8b 44 24 28	 mov	 rax, QWORD PTR offset2$[rsp]
  00210	48 39 44 24 20	 cmp	 QWORD PTR offset1$[rsp], rax
  00215	75 1c		 jne	 SHORT $LN27@time_richc
  00217	41 b8 74 0e 00
	00		 mov	 r8d, 3700		; 00000e74H
  0021d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@DINEGPHF@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA1?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA2?$AA?$AA@
  0022b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00231	33 c0		 xor	 eax, eax
$LN27@time_richc:

; 3701 :         offsecs1 = TIME_GET_HOUR(self) * 3600 +
; 3702 :                    TIME_GET_MINUTE(self) * 60 +
; 3703 :                    TIME_GET_SECOND(self) -
; 3704 :                    GET_TD_DAYS(offset1) * 86400 -
; 3705 :                    GET_TD_SECONDS(offset1);

  00233	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00238	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  0023c	69 c0 10 0e 00
	00		 imul	 eax, 3600		; 00000e10H
  00242	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00247	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  0024b	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  0024e	03 c1		 add	 eax, ecx
  00250	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00255	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  00259	03 c1		 add	 eax, ecx
  0025b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset1$[rsp]
  00260	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  00263	69 c9 80 51 01
	00		 imul	 ecx, 86400		; 00015180H
  00269	2b c1		 sub	 eax, ecx
  0026b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset1$[rsp]
  00270	2b 41 6c	 sub	 eax, DWORD PTR [rcx+108]
  00273	89 44 24 40	 mov	 DWORD PTR offsecs1$23577[rsp], eax

; 3706 :         offsecs2 = TIME_GET_HOUR(other) * 3600 +
; 3707 :                    TIME_GET_MINUTE(other) * 60 +
; 3708 :                    TIME_GET_SECOND(other) -
; 3709 :                    GET_TD_DAYS(offset2) * 86400 -
; 3710 :                    GET_TD_SECONDS(offset2);

  00277	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  0027c	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00280	69 c0 10 0e 00
	00		 imul	 eax, 3600		; 00000e10H
  00286	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  0028b	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  0028f	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  00292	03 c1		 add	 eax, ecx
  00294	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  00299	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  0029d	03 c1		 add	 eax, ecx
  0029f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset2$[rsp]
  002a4	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  002a7	69 c9 80 51 01
	00		 imul	 ecx, 86400		; 00015180H
  002ad	2b c1		 sub	 eax, ecx
  002af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset2$[rsp]
  002b4	2b 41 6c	 sub	 eax, DWORD PTR [rcx+108]
  002b7	89 44 24 3c	 mov	 DWORD PTR offsecs2$23578[rsp], eax

; 3711 :         diff = offsecs1 - offsecs2;

  002bb	8b 44 24 3c	 mov	 eax, DWORD PTR offsecs2$23578[rsp]
  002bf	8b 4c 24 40	 mov	 ecx, DWORD PTR offsecs1$23577[rsp]
  002c3	2b c8		 sub	 ecx, eax
  002c5	8b c1		 mov	 eax, ecx
  002c7	89 44 24 38	 mov	 DWORD PTR diff$[rsp], eax

; 3712 :         if (diff == 0)

  002cb	83 7c 24 38 00	 cmp	 DWORD PTR diff$[rsp], 0
  002d0	75 50		 jne	 SHORT $LN10@time_richc

; 3713 :             diff = TIME_GET_MICROSECOND(self) -
; 3714 :                    TIME_GET_MICROSECOND(other);

  002d2	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  002d7	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  002db	c1 e0 10	 shl	 eax, 16
  002de	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  002e3	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  002e7	c1 e1 08	 shl	 ecx, 8
  002ea	0b c1		 or	 eax, ecx
  002ec	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  002f1	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  002f5	0b c1		 or	 eax, ecx
  002f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  002fc	0f b6 49 6c	 movzx	 ecx, BYTE PTR [rcx+108]
  00300	c1 e1 10	 shl	 ecx, 16
  00303	48 8b 54 24 78	 mov	 rdx, QWORD PTR other$[rsp]
  00308	0f b6 52 6d	 movzx	 edx, BYTE PTR [rdx+109]
  0030c	c1 e2 08	 shl	 edx, 8
  0030f	0b ca		 or	 ecx, edx
  00311	48 8b 54 24 78	 mov	 rdx, QWORD PTR other$[rsp]
  00316	0f b6 52 6e	 movzx	 edx, BYTE PTR [rdx+110]
  0031a	0b ca		 or	 ecx, edx
  0031c	2b c1		 sub	 eax, ecx
  0031e	89 44 24 38	 mov	 DWORD PTR diff$[rsp], eax
$LN10@time_richc:

; 3715 :         result = diff_to_bool(diff, op);

  00322	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR op$[rsp]
  00329	8b 4c 24 38	 mov	 ecx, DWORD PTR diff$[rsp]
  0032d	e8 00 00 00 00	 call	 diff_to_bool
  00332	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
  00337	eb 57		 jmp	 SHORT $LN9@time_richc
$LN11@time_richc:

; 3716 :     }
; 3717 :     else if (op == Py_EQ) {

  00339	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  00341	75 18		 jne	 SHORT $LN8@time_richc

; 3718 :         result = Py_False;

  00343	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0034a	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 3719 :         Py_INCREF(result);

  0034f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00354	e8 00 00 00 00	 call	 _Py_IncRef
  00359	eb 35		 jmp	 SHORT $LN7@time_richc
$LN8@time_richc:

; 3720 :     }
; 3721 :     else if (op == Py_NE) {

  0035b	83 bc 24 80 00
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  00363	75 18		 jne	 SHORT $LN6@time_richc

; 3722 :         result = Py_True;

  00365	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0036c	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 3723 :         Py_INCREF(result);

  00371	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00376	e8 00 00 00 00	 call	 _Py_IncRef

; 3724 :     }
; 3725 :     else {

  0037b	eb 13		 jmp	 SHORT $LN5@time_richc
$LN6@time_richc:

; 3726 :         PyErr_SetString(PyExc_TypeError,
; 3727 :                         "can't compare offset-naive and "
; 3728 :                         "offset-aware times");

  0037d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@KAMMMLPO@can?8t?5compare?5offset?9naive?5and?5o@
  00384	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0038b	e8 00 00 00 00	 call	 PyErr_SetString
$LN5@time_richc:
$LN7@time_richc:
$LN9@time_richc:
$LN12@time_richc:
$done$23564:

; 3729 :     }
; 3730 :  done:
; 3731 :     Py_DECREF(offset1);

  00390	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset1$[rsp]
  00395	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@time_richc:

; 3732 :     Py_XDECREF(offset2);

  0039a	48 83 7c 24 28
	00		 cmp	 QWORD PTR offset2$[rsp], 0
  003a0	74 0a		 je	 SHORT $LN1@time_richc
  003a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset2$[rsp]
  003a7	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@time_richc:
  003ac	33 c0		 xor	 eax, eax
  003ae	85 c0		 test	 eax, eax
  003b0	75 e8		 jne	 SHORT $LN4@time_richc

; 3733 :     return result;

  003b2	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN21@time_richc:

; 3734 : }

  003b7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003bb	c3		 ret	 0
time_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CA@HEPCOKGC@?$AAH?$AAA?$AAS?$AAT?$AAZ?$AAI?$AAN?$AAF?$AAO?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_hash DD imagerel time_hash
	DD	imagerel time_hash+414
	DD	imagerel $unwind$time_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_hash DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_1CA@HEPCOKGC@?$AAH?$AAA?$AAS?$AAT?$AAZ?$AAI?$AAN?$AAF?$AAO?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@HEPCOKGC@?$AAH?$AAA?$AAS?$AAT?$AAZ?$AAI?$AAN?$AAF?$AAO?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ DB 'H'
	DB	00H, 'A', 00H, 'S', 00H, 'T', 00H, 'Z', 00H, 'I', 00H, 'N', 00H
	DB	'F', 00H, 'O', 00H, '(', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'f'
	DB	00H, ')', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT time_hash
_TEXT	SEGMENT
offset$23619 = 48
temp1$23627 = 56
seconds$23629 = 64
temp2$23628 = 72
microseconds$23630 = 80
self$ = 112
time_hash PROC						; COMDAT

; 3738 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3739 :     if (self->hashcode == -1) {

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 ff	 cmp	 QWORD PTR [rax+96], -1
  00013	0f 85 77 01 00
	00		 jne	 $LN6@time_hash

; 3740 :         PyObject *offset;
; 3741 : 
; 3742 :         offset = time_utcoffset((PyObject *)self, NULL);

  00019	33 d2		 xor	 edx, edx
  0001b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00020	e8 00 00 00 00	 call	 time_utcoffset
  00025	48 89 44 24 30	 mov	 QWORD PTR offset$23619[rsp], rax

; 3743 : 
; 3744 :         if (offset == NULL)

  0002a	48 83 7c 24 30
	00		 cmp	 QWORD PTR offset$23619[rsp], 0
  00030	75 0c		 jne	 SHORT $LN5@time_hash

; 3745 :             return -1;

  00032	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00039	e9 5b 01 00 00	 jmp	 $LN7@time_hash
$LN5@time_hash:

; 3746 : 
; 3747 :         /* Reduce this to a hash of another object. */
; 3748 :         if (offset == Py_None)

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00045	48 39 44 24 30	 cmp	 QWORD PTR offset$23619[rsp], rax
  0004a	75 24		 jne	 SHORT $LN4@time_hash

; 3749 :             self->hashcode = generic_hash(
; 3750 :                 (unsigned char *)self->data, _PyDateTime_TIME_DATASIZE);

  0004c	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00051	48 83 c0 69	 add	 rax, 105		; 00000069H
  00055	ba 06 00 00 00	 mov	 edx, 6
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	e8 00 00 00 00	 call	 generic_hash
  00062	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00067	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 3751 :         else {

  0006b	e9 16 01 00 00	 jmp	 $LN3@time_hash
$LN4@time_hash:

; 3752 :             PyObject *temp1, *temp2;
; 3753 :             int seconds, microseconds;
; 3754 :             assert(HASTZINFO(self));

  00070	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00075	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00079	85 c0		 test	 eax, eax
  0007b	75 1c		 jne	 SHORT $LN9@time_hash
  0007d	41 b8 aa 0e 00
	00		 mov	 r8d, 3754		; 00000eaaH
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@HEPCOKGC@?$AAH?$AAA?$AAS?$AAT?$AAZ?$AAI?$AAN?$AAF?$AAO?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00097	33 c0		 xor	 eax, eax
$LN9@time_hash:

; 3755 :             seconds = TIME_GET_HOUR(self) * 3600 +
; 3756 :                       TIME_GET_MINUTE(self) * 60 +
; 3757 :                       TIME_GET_SECOND(self);

  00099	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0009e	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  000a2	69 c0 10 0e 00
	00		 imul	 eax, 3600		; 00000e10H
  000a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000ad	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  000b1	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  000b4	03 c1		 add	 eax, ecx
  000b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000bb	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  000bf	03 c1		 add	 eax, ecx
  000c1	89 44 24 40	 mov	 DWORD PTR seconds$23629[rsp], eax

; 3758 :             microseconds = TIME_GET_MICROSECOND(self);

  000c5	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000ca	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  000ce	c1 e0 10	 shl	 eax, 16
  000d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000d6	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  000da	c1 e1 08	 shl	 ecx, 8
  000dd	0b c1		 or	 eax, ecx
  000df	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000e4	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  000e8	0b c1		 or	 eax, ecx
  000ea	89 44 24 50	 mov	 DWORD PTR microseconds$23630[rsp], eax

; 3759 :             temp1 = new_delta(0, seconds, microseconds, 1);

  000ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  000f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fa	41 b9 01 00 00
	00		 mov	 r9d, 1
  00100	44 8b 44 24 50	 mov	 r8d, DWORD PTR microseconds$23630[rsp]
  00105	8b 54 24 40	 mov	 edx, DWORD PTR seconds$23629[rsp]
  00109	33 c9		 xor	 ecx, ecx
  0010b	e8 00 00 00 00	 call	 new_delta_ex
  00110	48 89 44 24 38	 mov	 QWORD PTR temp1$23627[rsp], rax

; 3760 :             if (temp1 == NULL) {

  00115	48 83 7c 24 38
	00		 cmp	 QWORD PTR temp1$23627[rsp], 0
  0011b	75 13		 jne	 SHORT $LN2@time_hash

; 3761 :                 Py_DECREF(offset);

  0011d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR offset$23619[rsp]
  00122	e8 00 00 00 00	 call	 _Py_DecRef

; 3762 :                 return -1;

  00127	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0012e	eb 69		 jmp	 SHORT $LN7@time_hash
$LN2@time_hash:

; 3763 :             }
; 3764 :             temp2 = delta_subtract(temp1, offset);

  00130	48 8b 54 24 30	 mov	 rdx, QWORD PTR offset$23619[rsp]
  00135	48 8b 4c 24 38	 mov	 rcx, QWORD PTR temp1$23627[rsp]
  0013a	e8 00 00 00 00	 call	 delta_subtract
  0013f	48 89 44 24 48	 mov	 QWORD PTR temp2$23628[rsp], rax

; 3765 :             Py_DECREF(temp1);

  00144	48 8b 4c 24 38	 mov	 rcx, QWORD PTR temp1$23627[rsp]
  00149	e8 00 00 00 00	 call	 _Py_DecRef

; 3766 :             if (temp2 == NULL) {

  0014e	48 83 7c 24 48
	00		 cmp	 QWORD PTR temp2$23628[rsp], 0
  00154	75 13		 jne	 SHORT $LN1@time_hash

; 3767 :                 Py_DECREF(offset);

  00156	48 8b 4c 24 30	 mov	 rcx, QWORD PTR offset$23619[rsp]
  0015b	e8 00 00 00 00	 call	 _Py_DecRef

; 3768 :                 return -1;

  00160	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00167	eb 30		 jmp	 SHORT $LN7@time_hash
$LN1@time_hash:

; 3769 :             }
; 3770 :             self->hashcode = PyObject_Hash(temp2);

  00169	48 8b 4c 24 48	 mov	 rcx, QWORD PTR temp2$23628[rsp]
  0016e	e8 00 00 00 00	 call	 PyObject_Hash
  00173	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00178	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 3771 :             Py_DECREF(temp2);

  0017c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR temp2$23628[rsp]
  00181	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@time_hash:

; 3772 :         }
; 3773 :         Py_DECREF(offset);

  00186	48 8b 4c 24 30	 mov	 rcx, QWORD PTR offset$23619[rsp]
  0018b	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@time_hash:

; 3774 :     }
; 3775 :     return self->hashcode;

  00190	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00195	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
$LN7@time_hash:

; 3776 : }

  00199	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0019d	c3		 ret	 0
time_hash ENDP
_TEXT	ENDS
PUBLIC	??_C@_05IDCNAOBO@iiiiO?$AA@			; `string'
PUBLIC	??_C@_0P@DLDONPBF@?$HMiiiiO?3replace?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_replace DD imagerel time_replace
	DD	imagerel time_replace+393
	DD	imagerel $unwind$time_replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_replace DD 021601H
	DD	0130116H
xdata	ENDS
;	COMDAT ??_C@_05IDCNAOBO@iiiiO?$AA@
CONST	SEGMENT
??_C@_05IDCNAOBO@iiiiO?$AA@ DB 'iiiiO', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DLDONPBF@?$HMiiiiO?3replace?$AA@
CONST	SEGMENT
??_C@_0P@DLDONPBF@?$HMiiiiO?3replace?$AA@ DB '|iiiiO:replace', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT time_replace
_TEXT	SEGMENT
mm$ = 80
tzinfo$ = 88
tuple$ = 96
hh$ = 104
us$ = 108
clone$ = 112
ss$ = 120
tv90 = 128
self$ = 160
args$ = 168
kw$ = 176
time_replace PROC					; COMDAT

; 3780 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 3781 :     PyObject *clone;
; 3782 :     PyObject *tuple;
; 3783 :     int hh = TIME_GET_HOUR(self);

  00016	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001e	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00022	89 44 24 68	 mov	 DWORD PTR hh$[rsp], eax

; 3784 :     int mm = TIME_GET_MINUTE(self);

  00026	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0002e	0f b6 40 6a	 movzx	 eax, BYTE PTR [rax+106]
  00032	89 44 24 50	 mov	 DWORD PTR mm$[rsp], eax

; 3785 :     int ss = TIME_GET_SECOND(self);

  00036	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0003e	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  00042	89 44 24 78	 mov	 DWORD PTR ss$[rsp], eax

; 3786 :     int us = TIME_GET_MICROSECOND(self);

  00046	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0004e	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00052	c1 e0 10	 shl	 eax, 16
  00055	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0005d	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  00061	c1 e1 08	 shl	 ecx, 8
  00064	0b c1		 or	 eax, ecx
  00066	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0006e	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  00072	0b c1		 or	 eax, ecx
  00074	89 44 24 6c	 mov	 DWORD PTR us$[rsp], eax

; 3787 :     PyObject *tzinfo = HASTZINFO(self) ? self->tzinfo : Py_None;

  00078	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00080	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00084	85 c0		 test	 eax, eax
  00086	74 16		 je	 SHORT $LN5@time_repla
  00088	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00090	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00094	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  0009c	eb 0f		 jmp	 SHORT $LN6@time_repla
$LN5@time_repla:
  0009e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000a5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
$LN6@time_repla:
  000ad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv90[rsp]
  000b5	48 89 44 24 58	 mov	 QWORD PTR tzinfo$[rsp], rax

; 3788 : 
; 3789 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "|iiiiO:replace",
; 3790 :                                       time_kws,
; 3791 :                                       &hh, &mm, &ss, &us, &tzinfo))

  000ba	48 8d 44 24 58	 lea	 rax, QWORD PTR tzinfo$[rsp]
  000bf	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000c4	48 8d 44 24 6c	 lea	 rax, QWORD PTR us$[rsp]
  000c9	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000ce	48 8d 44 24 78	 lea	 rax, QWORD PTR ss$[rsp]
  000d3	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000d8	48 8d 44 24 50	 lea	 rax, QWORD PTR mm$[rsp]
  000dd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000e2	48 8d 44 24 68	 lea	 rax, QWORD PTR hh$[rsp]
  000e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ec	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:time_kws
  000f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@DLDONPBF@?$HMiiiiO?3replace?$AA@
  000fa	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  00102	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0010a	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0010f	85 c0		 test	 eax, eax
  00111	75 04		 jne	 SHORT $LN2@time_repla

; 3792 :         return NULL;

  00113	33 c0		 xor	 eax, eax
  00115	eb 6a		 jmp	 SHORT $LN3@time_repla
$LN2@time_repla:

; 3793 :     tuple = Py_BuildValue("iiiiO", hh, mm, ss, us, tzinfo);

  00117	48 8b 44 24 58	 mov	 rax, QWORD PTR tzinfo$[rsp]
  0011c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00121	8b 44 24 6c	 mov	 eax, DWORD PTR us$[rsp]
  00125	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00129	44 8b 4c 24 78	 mov	 r9d, DWORD PTR ss$[rsp]
  0012e	44 8b 44 24 50	 mov	 r8d, DWORD PTR mm$[rsp]
  00133	8b 54 24 68	 mov	 edx, DWORD PTR hh$[rsp]
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IDCNAOBO@iiiiO?$AA@
  0013e	e8 00 00 00 00	 call	 Py_BuildValue
  00143	48 89 44 24 60	 mov	 QWORD PTR tuple$[rsp], rax

; 3794 :     if (tuple == NULL)

  00148	48 83 7c 24 60
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  0014e	75 04		 jne	 SHORT $LN1@time_repla

; 3795 :         return NULL;

  00150	33 c0		 xor	 eax, eax
  00152	eb 2d		 jmp	 SHORT $LN3@time_repla
$LN1@time_repla:

; 3796 :     clone = time_new(Py_TYPE(self), tuple, NULL);

  00154	45 33 c0	 xor	 r8d, r8d
  00157	48 8b 54 24 60	 mov	 rdx, QWORD PTR tuple$[rsp]
  0015c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00164	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00168	e8 00 00 00 00	 call	 time_new
  0016d	48 89 44 24 70	 mov	 QWORD PTR clone$[rsp], rax

; 3797 :     Py_DECREF(tuple);

  00172	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tuple$[rsp]
  00177	e8 00 00 00 00	 call	 _Py_DecRef

; 3798 :     return clone;

  0017c	48 8b 44 24 70	 mov	 rax, QWORD PTR clone$[rsp]
$LN3@time_repla:

; 3799 : }

  00181	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00188	c3		 ret	 0
time_replace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_bool DD imagerel time_bool
	DD	imagerel time_bool+283
	DD	imagerel $unwind$time_bool
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_bool DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_bool
_TEXT	SEGMENT
offset$ = 32
offsecs$ = 40
tzinfo$ = 48
tv86 = 56
tv140 = 64
self$ = 96
time_bool PROC						; COMDAT

; 3803 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3804 :     PyObject *offset, *tzinfo;
; 3805 :     int offsecs = 0;

  00009	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR offsecs$[rsp], 0

; 3806 : 
; 3807 :     if (TIME_GET_SECOND(self) || TIME_GET_MICROSECOND(self)) {

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00016	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  0001a	85 c0		 test	 eax, eax
  0001c	75 29		 jne	 SHORT $LN3@time_bool
  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00023	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00027	c1 e0 10	 shl	 eax, 16
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0002f	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  00033	c1 e1 08	 shl	 ecx, 8
  00036	0b c1		 or	 eax, ecx
  00038	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0003d	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  00041	0b c1		 or	 eax, ecx
  00043	85 c0		 test	 eax, eax
  00045	74 0a		 je	 SHORT $LN4@time_bool
$LN3@time_bool:

; 3808 :         /* Since utcoffset is in whole minutes, nothing can
; 3809 :          * alter the conclusion that this is nonzero.
; 3810 :          */
; 3811 :         return 1;

  00047	b8 01 00 00 00	 mov	 eax, 1
  0004c	e9 c5 00 00 00	 jmp	 $LN5@time_bool
$LN4@time_bool:

; 3812 :     }
; 3813 :     tzinfo = GET_TIME_TZINFO(self);

  00051	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00056	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  0005a	85 c0		 test	 eax, eax
  0005c	74 10		 je	 SHORT $LN7@time_bool
  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00063	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00067	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
  0006c	eb 0c		 jmp	 SHORT $LN8@time_bool
$LN7@time_bool:
  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00075	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
$LN8@time_bool:
  0007a	48 8b 44 24 38	 mov	 rax, QWORD PTR tv86[rsp]
  0007f	48 89 44 24 30	 mov	 QWORD PTR tzinfo$[rsp], rax

; 3814 :     if (tzinfo != Py_None) {

  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0008b	48 39 44 24 30	 cmp	 QWORD PTR tzinfo$[rsp], rax
  00090	74 49		 je	 SHORT $LN2@time_bool

; 3815 :         offset = call_utcoffset(tzinfo, Py_None);

  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  0009e	e8 00 00 00 00	 call	 call_utcoffset
  000a3	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 3816 :         if (offset == NULL)

  000a8	48 83 7c 24 20
	00		 cmp	 QWORD PTR offset$[rsp], 0
  000ae	75 07		 jne	 SHORT $LN1@time_bool

; 3817 :             return -1;

  000b0	b8 ff ff ff ff	 mov	 eax, -1
  000b5	eb 5f		 jmp	 SHORT $LN5@time_bool
$LN1@time_bool:

; 3818 :         offsecs = GET_TD_DAYS(offset)*86400 + GET_TD_SECONDS(offset);

  000b7	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  000bc	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  000bf	69 c0 80 51 01
	00		 imul	 eax, 86400		; 00015180H
  000c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  000ca	03 41 6c	 add	 eax, DWORD PTR [rcx+108]
  000cd	89 44 24 28	 mov	 DWORD PTR offsecs$[rsp], eax

; 3819 :         Py_DECREF(offset);

  000d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset$[rsp]
  000d6	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@time_bool:

; 3820 :     }
; 3821 :     return (TIME_GET_MINUTE(self)*60 - offsecs + TIME_GET_HOUR(self)*3600) != 0;

  000db	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000e0	0f b6 40 6a	 movzx	 eax, BYTE PTR [rax+106]
  000e4	6b c0 3c	 imul	 eax, 60			; 0000003cH
  000e7	2b 44 24 28	 sub	 eax, DWORD PTR offsecs$[rsp]
  000eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000f0	0f b6 49 69	 movzx	 ecx, BYTE PTR [rcx+105]
  000f4	69 c9 10 0e 00
	00		 imul	 ecx, 3600		; 00000e10H
  000fa	03 c1		 add	 eax, ecx
  000fc	85 c0		 test	 eax, eax
  000fe	74 0a		 je	 SHORT $LN9@time_bool
  00100	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv140[rsp], 1
  00108	eb 08		 jmp	 SHORT $LN10@time_bool
$LN9@time_bool:
  0010a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
$LN10@time_bool:
  00112	8b 44 24 40	 mov	 eax, DWORD PTR tv140[rsp]
$LN5@time_bool:

; 3822 : }

  00116	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011a	c3		 ret	 0
time_bool ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_reduce DD imagerel time_reduce
	DD	imagerel time_reduce+53
	DD	imagerel $unwind$time_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_reduce DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_reduce
_TEXT	SEGMENT
self$ = 48
arg$ = 56
time_reduce PROC					; COMDAT

; 3851 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3852 :     return Py_BuildValue("(ON)", Py_TYPE(self), time_getstate(self));

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 time_getstate
  00018	4c 8b c0	 mov	 r8, rax
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DFFJBLGN@?$CION?$CJ?$AA@
  0002b	e8 00 00 00 00	 call	 Py_BuildValue

; 3853 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
time_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_getstate DD imagerel time_getstate
	DD	imagerel time_getstate+155
	DD	imagerel $unwind$time_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_getstate DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_getstate
_TEXT	SEGMENT
basestate$ = 32
result$ = 40
self$ = 64
time_getstate PROC					; COMDAT

; 3833 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3834 :     PyObject *basestate;
; 3835 :     PyObject *result = NULL;

  00009	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 3836 : 
; 3837 :     basestate =  PyBytes_FromStringAndSize((char *)self->data,
; 3838 :                                             _PyDateTime_TIME_DATASIZE);

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00017	48 83 c0 69	 add	 rax, 105		; 00000069H
  0001b	ba 06 00 00 00	 mov	 edx, 6
  00020	48 8b c8	 mov	 rcx, rax
  00023	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00028	48 89 44 24 20	 mov	 QWORD PTR basestate$[rsp], rax

; 3839 :     if (basestate != NULL) {

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR basestate$[rsp], 0
  00033	74 5c		 je	 SHORT $LN4@time_getst

; 3840 :         if (! HASTZINFO(self) || self->tzinfo == Py_None)

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003a	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  0003e	85 c0		 test	 eax, eax
  00040	74 12		 je	 SHORT $LN2@time_getst
  00042	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0004e	48 39 41 70	 cmp	 QWORD PTR [rcx+112], rax
  00052	75 16		 jne	 SHORT $LN3@time_getst
$LN2@time_getst:

; 3841 :             result = PyTuple_Pack(1, basestate);

  00054	48 8b 54 24 20	 mov	 rdx, QWORD PTR basestate$[rsp]
  00059	b9 01 00 00 00	 mov	 ecx, 1
  0005e	e8 00 00 00 00	 call	 PyTuple_Pack
  00063	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 3842 :         else

  00068	eb 1d		 jmp	 SHORT $LN1@time_getst
$LN3@time_getst:

; 3843 :             result = PyTuple_Pack(2, basestate, self->tzinfo);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006f	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00073	48 8b 54 24 20	 mov	 rdx, QWORD PTR basestate$[rsp]
  00078	b9 02 00 00 00	 mov	 ecx, 2
  0007d	e8 00 00 00 00	 call	 PyTuple_Pack
  00082	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax
$LN1@time_getst:

; 3844 :         Py_DECREF(basestate);

  00087	48 8b 4c 24 20	 mov	 rcx, QWORD PTR basestate$[rsp]
  0008c	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@time_getst:

; 3845 :     }
; 3846 :     return result;

  00091	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]

; 3847 : }

  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	c3		 ret	 0
time_getstate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_hour DD imagerel datetime_hour
	DD	imagerel datetime_hour+35
	DD	imagerel $unwind$datetime_hour
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_hour DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_hour
_TEXT	SEGMENT
self$ = 48
unused$ = 56
datetime_hour PROC					; COMDAT

; 3956 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3957 :     return PyLong_FromLong(DATE_GET_HOUR(self));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  00017	8b c8		 mov	 ecx, eax
  00019	e8 00 00 00 00	 call	 PyLong_FromLong

; 3958 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
datetime_hour ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_minute DD imagerel datetime_minute
	DD	imagerel datetime_minute+35
	DD	imagerel $unwind$datetime_minute
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_minute DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_minute
_TEXT	SEGMENT
self$ = 48
unused$ = 56
datetime_minute PROC					; COMDAT

; 3962 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3963 :     return PyLong_FromLong(DATE_GET_MINUTE(self));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f b6 40 6e	 movzx	 eax, BYTE PTR [rax+110]
  00017	8b c8		 mov	 ecx, eax
  00019	e8 00 00 00 00	 call	 PyLong_FromLong

; 3964 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
datetime_minute ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_second DD imagerel datetime_second
	DD	imagerel datetime_second+35
	DD	imagerel $unwind$datetime_second
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_second DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_second
_TEXT	SEGMENT
self$ = 48
unused$ = 56
datetime_second PROC					; COMDAT

; 3968 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3969 :     return PyLong_FromLong(DATE_GET_SECOND(self));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f b6 40 6f	 movzx	 eax, BYTE PTR [rax+111]
  00017	8b c8		 mov	 ecx, eax
  00019	e8 00 00 00 00	 call	 PyLong_FromLong

; 3970 : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
datetime_second ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_microsecond DD imagerel datetime_microsecond
	DD	imagerel datetime_microsecond+63
	DD	imagerel $unwind$datetime_microsecond
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_microsecond DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_microsecond
_TEXT	SEGMENT
self$ = 48
unused$ = 56
datetime_microsecond PROC				; COMDAT

; 3974 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3975 :     return PyLong_FromLong(DATE_GET_MICROSECOND(self));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  00017	c1 e0 10	 shl	 eax, 16
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0001f	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  00023	c1 e1 08	 shl	 ecx, 8
  00026	0b c1		 or	 eax, ecx
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0002d	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  00031	0b c1		 or	 eax, ecx
  00033	8b c8		 mov	 ecx, eax
  00035	e8 00 00 00 00	 call	 PyLong_FromLong

; 3976 : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
datetime_microsecond ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_tzinfo DD imagerel datetime_tzinfo
	DD	imagerel datetime_tzinfo+85
	DD	imagerel $unwind$datetime_tzinfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_tzinfo DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_tzinfo
_TEXT	SEGMENT
result$ = 32
tv68 = 40
self$ = 64
unused$ = 72
datetime_tzinfo PROC					; COMDAT

; 3980 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3981 :     PyObject *result = HASTZINFO(self) ? self->tzinfo : Py_None;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00017	85 c0		 test	 eax, eax
  00019	74 10		 je	 SHORT $LN3@datetime_t
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00024	48 89 44 24 28	 mov	 QWORD PTR tv68[rsp], rax
  00029	eb 0c		 jmp	 SHORT $LN4@datetime_t
$LN3@datetime_t:
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00032	48 89 44 24 28	 mov	 QWORD PTR tv68[rsp], rax
$LN4@datetime_t:
  00037	48 8b 44 24 28	 mov	 rax, QWORD PTR tv68[rsp]
  0003c	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 3982 :     Py_INCREF(result);

  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00046	e8 00 00 00 00	 call	 _Py_IncRef

; 3983 :     return result;

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 3984 : }

  00050	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00054	c3		 ret	 0
datetime_tzinfo ENDP
_TEXT	ENDS
PUBLIC	??_C@_09OIDLNOEB@iii?$HMiiiiO?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_new DD imagerel datetime_new
	DD	imagerel datetime_new+1013
	DD	imagerel $unwind$datetime_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_new DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_09OIDLNOEB@iii?$HMiiiiO?$AA@
CONST	SEGMENT
??_C@_09OIDLNOEB@iii?$HMiiiiO?$AA@ DB 'iii|iiiiO', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_new
_TEXT	SEGMENT
day$ = 96
usecond$ = 100
second$ = 104
minute$ = 108
hour$ = 112
month$ = 116
self$ = 120
tzinfo$ = 128
year$ = 136
state$ = 144
aware$23844 = 152
me$23843 = 160
pdata$23854 = 168
tv139 = 176
type$ = 208
args$ = 216
kw$ = 224
datetime_new PROC					; COMDAT

; 4006 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 4007 :     PyObject *self = NULL;

  00016	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR self$[rsp], 0

; 4008 :     PyObject *state;
; 4009 :     int year;
; 4010 :     int month;
; 4011 :     int day;
; 4012 :     int hour = 0;

  0001f	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR hour$[rsp], 0

; 4013 :     int minute = 0;

  00027	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR minute$[rsp], 0

; 4014 :     int second = 0;

  0002f	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR second$[rsp], 0

; 4015 :     int usecond = 0;

  00037	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR usecond$[rsp], 0

; 4016 :     PyObject *tzinfo = Py_None;

  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00046	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tzinfo$[rsp], rax

; 4017 : 
; 4018 :     /* Check for invocation from pickle with __getstate__ state */
; 4019 :     if (PyTuple_GET_SIZE(args) >= 1 &&
; 4020 :         PyTuple_GET_SIZE(args) <= 2 &&
; 4021 :         PyBytes_Check(state = PyTuple_GET_ITEM(args, 0)) &&
; 4022 :         PyBytes_GET_SIZE(state) == _PyDateTime_DATETIME_DATASIZE &&
; 4023 :         MONTH_IS_SANE(PyBytes_AS_STRING(state)[2]))

  0004e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00056	48 83 78 60 01	 cmp	 QWORD PTR [rax+96], 1
  0005b	0f 8c 61 02 00
	00		 jl	 $LN9@datetime_n
  00061	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00069	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  0006e	0f 8f 4e 02 00
	00		 jg	 $LN9@datetime_n
  00074	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  0007c	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00080	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR state$[rsp], rax
  00088	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00090	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00094	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0009f	85 c0		 test	 eax, eax
  000a1	0f 84 1b 02 00
	00		 je	 $LN9@datetime_n
  000a7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000af	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000b3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000b9	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000be	85 c0		 test	 eax, eax
  000c0	75 1c		 jne	 SHORT $LN12@datetime_n
  000c2	41 b8 b6 0f 00
	00		 mov	 r8d, 4022		; 00000fb6H
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000dc	33 c0		 xor	 eax, eax
$LN12@datetime_n:
  000de	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000e6	48 83 78 60 0a	 cmp	 QWORD PTR [rax+96], 10
  000eb	0f 85 d1 01 00
	00		 jne	 $LN9@datetime_n
  000f1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000f9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000fd	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00103	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00108	85 c0		 test	 eax, eax
  0010a	75 1c		 jne	 SHORT $LN13@datetime_n
  0010c	41 b8 b7 0f 00
	00		 mov	 r8d, 4023		; 00000fb7H
  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00126	33 c0		 xor	 eax, eax
$LN13@datetime_n:
  00128	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00130	0f be 40 7a	 movsx	 eax, BYTE PTR [rax+122]
  00134	ff c8		 dec	 eax
  00136	83 f8 0c	 cmp	 eax, 12
  00139	0f 83 83 01 00
	00		 jae	 $LN9@datetime_n

; 4024 :     {
; 4025 :         PyDateTime_DateTime *me;
; 4026 :         char aware;
; 4027 : 
; 4028 :         if (PyTuple_GET_SIZE(args) == 2) {

  0013f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00147	48 83 78 60 02	 cmp	 QWORD PTR [rax+96], 2
  0014c	75 3f		 jne	 SHORT $LN8@datetime_n

; 4029 :             tzinfo = PyTuple_GET_ITEM(args, 1);

  0014e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  00156	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0015a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tzinfo$[rsp], rax

; 4030 :             if (check_tzinfo_subclass(tzinfo) < 0) {

  00162	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  0016a	e8 00 00 00 00	 call	 check_tzinfo_subclass
  0016f	85 c0		 test	 eax, eax
  00171	7d 1a		 jge	 SHORT $LN7@datetime_n

; 4031 :                 PyErr_SetString(PyExc_TypeError, "bad "
; 4032 :                     "tzinfo state arg");

  00173	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@ECAEDOJO@bad?5tzinfo?5state?5arg?$AA@
  0017a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00181	e8 00 00 00 00	 call	 PyErr_SetString

; 4033 :                 return NULL;

  00186	33 c0		 xor	 eax, eax
  00188	e9 60 02 00 00	 jmp	 $LN10@datetime_n
$LN7@datetime_n:
$LN8@datetime_n:

; 4034 :             }
; 4035 :         }
; 4036 :         aware = (char)(tzinfo != Py_None);

  0018d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00194	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR tzinfo$[rsp], rax
  0019c	74 0a		 je	 SHORT $LN14@datetime_n
  0019e	c6 84 24 b0 00
	00 00 01	 mov	 BYTE PTR tv139[rsp], 1
  001a6	eb 08		 jmp	 SHORT $LN15@datetime_n
$LN14@datetime_n:
  001a8	c6 84 24 b0 00
	00 00 00	 mov	 BYTE PTR tv139[rsp], 0
$LN15@datetime_n:
  001b0	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR tv139[rsp]
  001b8	88 84 24 98 00
	00 00		 mov	 BYTE PTR aware$23844[rsp], al

; 4037 :         me = (PyDateTime_DateTime *) (type->tp_alloc(type , aware));

  001bf	48 0f be 84 24
	98 00 00 00	 movsx	 rax, BYTE PTR aware$23844[rsp]
  001c8	48 8b d0	 mov	 rdx, rax
  001cb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  001d3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  001db	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  001e1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR me$23843[rsp], rax

; 4038 :         if (me != NULL) {

  001e9	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR me$23843[rsp], 0
  001f2	0f 84 bd 00 00
	00		 je	 $LN6@datetime_n

; 4039 :             char *pdata = PyBytes_AS_STRING(state);

  001f8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00200	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00204	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0020a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0020f	85 c0		 test	 eax, eax
  00211	75 1c		 jne	 SHORT $LN16@datetime_n
  00213	41 b8 c7 0f 00
	00		 mov	 r8d, 4039		; 00000fc7H
  00219	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00220	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JJLMKMKP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?$CJ?$AA?$AA@
  00227	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0022d	33 c0		 xor	 eax, eax
$LN16@datetime_n:
  0022f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00237	48 83 c0 78	 add	 rax, 120		; 00000078H
  0023b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pdata$23854[rsp], rax

; 4040 : 
; 4041 :             memcpy(me->data, pdata, _PyDateTime_DATETIME_DATASIZE);

  00243	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR me$23843[rsp]
  0024b	48 83 c0 69	 add	 rax, 105		; 00000069H
  0024f	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00255	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pdata$23854[rsp]
  0025d	48 8b c8	 mov	 rcx, rax
  00260	e8 00 00 00 00	 call	 memcpy

; 4042 :             me->hashcode = -1;

  00265	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR me$23843[rsp]
  0026d	48 c7 40 60 ff
	ff ff ff	 mov	 QWORD PTR [rax+96], -1

; 4043 :             me->hastzinfo = aware;

  00275	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR me$23843[rsp]
  0027d	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR aware$23844[rsp]
  00285	88 48 68	 mov	 BYTE PTR [rax+104], cl

; 4044 :             if (aware) {

  00288	0f be 84 24 98
	00 00 00	 movsx	 eax, BYTE PTR aware$23844[rsp]
  00290	85 c0		 test	 eax, eax
  00292	74 21		 je	 SHORT $LN5@datetime_n

; 4045 :                 Py_INCREF(tzinfo);

  00294	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  0029c	e8 00 00 00 00	 call	 _Py_IncRef

; 4046 :                 me->tzinfo = tzinfo;

  002a1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR me$23843[rsp]
  002a9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  002b1	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx
$LN5@datetime_n:
$LN6@datetime_n:

; 4047 :             }
; 4048 :         }
; 4049 :         return (PyObject *)me;

  002b5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR me$23843[rsp]
  002bd	e9 2b 01 00 00	 jmp	 $LN10@datetime_n
$LN9@datetime_n:

; 4050 :     }
; 4051 : 
; 4052 :     if (PyArg_ParseTupleAndKeywords(args, kw, "iii|iiiiO", datetime_kws,
; 4053 :                                     &year, &month, &day, &hour, &minute,
; 4054 :                                     &second, &usecond, &tzinfo)) {

  002c2	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR tzinfo$[rsp]
  002ca	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  002cf	48 8d 44 24 64	 lea	 rax, QWORD PTR usecond$[rsp]
  002d4	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  002d9	48 8d 44 24 68	 lea	 rax, QWORD PTR second$[rsp]
  002de	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  002e3	48 8d 44 24 6c	 lea	 rax, QWORD PTR minute$[rsp]
  002e8	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  002ed	48 8d 44 24 70	 lea	 rax, QWORD PTR hour$[rsp]
  002f2	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002f7	48 8d 44 24 60	 lea	 rax, QWORD PTR day$[rsp]
  002fc	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00301	48 8d 44 24 74	 lea	 rax, QWORD PTR month$[rsp]
  00306	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0030b	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR year$[rsp]
  00313	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00318	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:datetime_kws
  0031f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09OIDLNOEB@iii?$HMiiiiO?$AA@
  00326	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  0032e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00336	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0033b	85 c0		 test	 eax, eax
  0033d	0f 84 a5 00 00
	00		 je	 $LN4@datetime_n

; 4055 :         if (check_date_args(year, month, day) < 0)

  00343	44 8b 44 24 60	 mov	 r8d, DWORD PTR day$[rsp]
  00348	8b 54 24 74	 mov	 edx, DWORD PTR month$[rsp]
  0034c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR year$[rsp]
  00353	e8 00 00 00 00	 call	 check_date_args
  00358	85 c0		 test	 eax, eax
  0035a	7d 07		 jge	 SHORT $LN3@datetime_n

; 4056 :             return NULL;

  0035c	33 c0		 xor	 eax, eax
  0035e	e9 8a 00 00 00	 jmp	 $LN10@datetime_n
$LN3@datetime_n:

; 4057 :         if (check_time_args(hour, minute, second, usecond) < 0)

  00363	44 8b 4c 24 64	 mov	 r9d, DWORD PTR usecond$[rsp]
  00368	44 8b 44 24 68	 mov	 r8d, DWORD PTR second$[rsp]
  0036d	8b 54 24 6c	 mov	 edx, DWORD PTR minute$[rsp]
  00371	8b 4c 24 70	 mov	 ecx, DWORD PTR hour$[rsp]
  00375	e8 00 00 00 00	 call	 check_time_args
  0037a	85 c0		 test	 eax, eax
  0037c	7d 04		 jge	 SHORT $LN2@datetime_n

; 4058 :             return NULL;

  0037e	33 c0		 xor	 eax, eax
  00380	eb 6b		 jmp	 SHORT $LN10@datetime_n
$LN2@datetime_n:

; 4059 :         if (check_tzinfo_subclass(tzinfo) < 0)

  00382	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  0038a	e8 00 00 00 00	 call	 check_tzinfo_subclass
  0038f	85 c0		 test	 eax, eax
  00391	7d 04		 jge	 SHORT $LN1@datetime_n

; 4060 :             return NULL;

  00393	33 c0		 xor	 eax, eax
  00395	eb 56		 jmp	 SHORT $LN10@datetime_n
$LN1@datetime_n:

; 4061 :         self = new_datetime_ex(year, month, day,
; 4062 :                                 hour, minute, second, usecond,
; 4063 :                                 tzinfo, type);

  00397	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  0039f	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  003a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tzinfo$[rsp]
  003ac	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  003b1	8b 44 24 64	 mov	 eax, DWORD PTR usecond$[rsp]
  003b5	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  003b9	8b 44 24 68	 mov	 eax, DWORD PTR second$[rsp]
  003bd	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003c1	8b 44 24 6c	 mov	 eax, DWORD PTR minute$[rsp]
  003c5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003c9	44 8b 4c 24 70	 mov	 r9d, DWORD PTR hour$[rsp]
  003ce	44 8b 44 24 60	 mov	 r8d, DWORD PTR day$[rsp]
  003d3	8b 54 24 74	 mov	 edx, DWORD PTR month$[rsp]
  003d7	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR year$[rsp]
  003de	e8 00 00 00 00	 call	 new_datetime_ex
  003e3	48 89 44 24 78	 mov	 QWORD PTR self$[rsp], rax
$LN4@datetime_n:

; 4064 :     }
; 4065 :     return self;

  003e8	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
$LN10@datetime_n:

; 4066 : }

  003ed	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  003f4	c3		 ret	 0
datetime_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_06KEMIGBFM@?$HMO?3now?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_now DD imagerel datetime_now
	DD	imagerel datetime_now+275
	DD	imagerel $unwind$datetime_now
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_now DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_06KEMIGBFM@?$HMO?3now?$AA@
CONST	SEGMENT
??_C@_06KEMIGBFM@?$HMO?3now?$AA@ DB '|O:now', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_now
_TEXT	SEGMENT
self$ = 48
tzinfo$ = 56
temp$23936 = 64
tv77 = 72
cls$ = 96
args$ = 104
kw$ = 112
datetime_now PROC					; COMDAT

; 4146 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4147 :     PyObject *self;
; 4148 :     PyObject *tzinfo = Py_None;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001a	48 89 44 24 38	 mov	 QWORD PTR tzinfo$[rsp], rax

; 4149 :     static char *keywords[] = {"tz", NULL};
; 4150 : 
; 4151 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "|O:now", keywords,
; 4152 :                                       &tzinfo))

  0001f	48 8d 44 24 38	 lea	 rax, QWORD PTR tzinfo$[rsp]
  00024	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00029	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??datetime_now@@9@9
  00030	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06KEMIGBFM@?$HMO?3now?$AA@
  00037	48 8b 54 24 70	 mov	 rdx, QWORD PTR kw$[rsp]
  0003c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00041	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00046	85 c0		 test	 eax, eax
  00048	75 07		 jne	 SHORT $LN3@datetime_n@2

; 4153 :         return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 bd 00 00 00	 jmp	 $LN4@datetime_n@2
$LN3@datetime_n@2:

; 4154 :     if (check_tzinfo_subclass(tzinfo) < 0)

  00051	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00056	e8 00 00 00 00	 call	 check_tzinfo_subclass
  0005b	85 c0		 test	 eax, eax
  0005d	7d 07		 jge	 SHORT $LN2@datetime_n@2

; 4155 :         return NULL;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 a8 00 00 00	 jmp	 $LN4@datetime_n@2
$LN2@datetime_n@2:

; 4156 : 
; 4157 :     self = datetime_best_possible(cls,
; 4158 :                                   tzinfo == Py_None ? localtime : gmtime,
; 4159 :                                   tzinfo);

  00066	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0006d	48 39 44 24 38	 cmp	 QWORD PTR tzinfo$[rsp], rax
  00072	75 0e		 jne	 SHORT $LN6@datetime_n@2
  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:localtime
  0007b	48 89 44 24 48	 mov	 QWORD PTR tv77[rsp], rax
  00080	eb 0c		 jmp	 SHORT $LN7@datetime_n@2
$LN6@datetime_n@2:
  00082	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:gmtime
  00089	48 89 44 24 48	 mov	 QWORD PTR tv77[rsp], rax
$LN7@datetime_n@2:
  0008e	4c 8b 44 24 38	 mov	 r8, QWORD PTR tzinfo$[rsp]
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv77[rsp]
  00098	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cls$[rsp]
  0009d	e8 00 00 00 00	 call	 datetime_best_possible
  000a2	48 89 44 24 30	 mov	 QWORD PTR self$[rsp], rax

; 4160 :     if (self != NULL && tzinfo != Py_None) {

  000a7	48 83 7c 24 30
	00		 cmp	 QWORD PTR self$[rsp], 0
  000ad	74 5a		 je	 SHORT $LN1@datetime_n@2
  000af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000b6	48 39 44 24 38	 cmp	 QWORD PTR tzinfo$[rsp], rax
  000bb	74 4c		 je	 SHORT $LN1@datetime_n@2

; 4161 :         /* Convert UTC to tzinfo's zone. */
; 4162 :         PyObject *temp = self;

  000bd	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000c2	48 89 44 24 40	 mov	 QWORD PTR temp$23936[rsp], rax

; 4163 :         _Py_IDENTIFIER(fromutc);
; 4164 : 
; 4165 :         self = _PyObject_CallMethodId(tzinfo, &PyId_fromutc, "O", self);

  000c7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_fromutc@?2??datetime_now@@9@9
  000cc	8b c0		 mov	 eax, eax
  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000d4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000dd	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000e1	4c 8b 4c 24 30	 mov	 r9, QWORD PTR self$[rsp]
  000e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000ed	48 8b d0	 mov	 rdx, rax
  000f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  000f5	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  000fa	48 89 44 24 30	 mov	 QWORD PTR self$[rsp], rax

; 4166 :         Py_DECREF(temp);

  000ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR temp$23936[rsp]
  00104	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@datetime_n@2:

; 4167 :     }
; 4168 :     return self;

  00109	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
$LN4@datetime_n@2:

; 4169 : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
datetime_now ENDP
_TEXT	ENDS
EXTRN	__imp__gmtime64:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$gmtime DD imagerel gmtime
	DD	imagerel gmtime+25
	DD	imagerel $unwind$gmtime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gmtime DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gmtime
_TEXT	SEGMENT
_Time$ = 48
gmtime	PROC						; COMDAT

; 100  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 101  : #pragma warning( push )
; 102  : #pragma warning( disable : 4996 )
; 103  :     return _gmtime64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__gmtime64

; 104  : #pragma warning( pop )
; 105  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
gmtime	ENDP
_TEXT	ENDS
EXTRN	_PyTime_gettimeofday:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_datetimemodule.c
pdata	SEGMENT
$pdata$datetime_best_possible DD imagerel datetime_best_possible
	DD	imagerel datetime_best_possible+69
	DD	imagerel $unwind$datetime_best_possible
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_best_possible DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_best_possible
_TEXT	SEGMENT
t$ = 48
cls$ = 80
f$ = 88
tzinfo$ = 96
datetime_best_possible PROC				; COMDAT

; 4134 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4135 :     _PyTime_timeval t;
; 4136 :     _PyTime_gettimeofday(&t);

  00013	48 8d 4c 24 30	 lea	 rcx, QWORD PTR t$[rsp]
  00018	e8 00 00 00 00	 call	 _PyTime_gettimeofday

; 4137 :     return datetime_from_timet_and_us(cls, f, t.tv_sec, (int)t.tv_usec,
; 4138 :                                       tzinfo);

  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR tzinfo$[rsp]
  00022	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00027	44 8b 4c 24 38	 mov	 r9d, DWORD PTR t$[rsp+8]
  0002c	4c 8b 44 24 30	 mov	 r8, QWORD PTR t$[rsp]
  00031	48 8b 54 24 58	 mov	 rdx, QWORD PTR f$[rsp]
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cls$[rsp]
  0003b	e8 00 00 00 00	 call	 datetime_from_timet_and_us

; 4139 : }

  00040	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00044	c3		 ret	 0
datetime_best_possible ENDP
_TEXT	ENDS
PUBLIC	??_C@_08PFKMDOEK@iiiiiiiO?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_from_timet_and_us DD imagerel datetime_from_timet_and_us
	DD	imagerel datetime_from_timet_and_us+233
	DD	imagerel $unwind$datetime_from_timet_and_us
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_from_timet_and_us DD 011801H
	DD	0c218H
xdata	ENDS
;	COMDAT ??_C@_08PFKMDOEK@iiiiiiiO?$AA@
CONST	SEGMENT
??_C@_08PFKMDOEK@iiiiiiiO?$AA@ DB 'iiiiiiiO', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_from_timet_and_us
_TEXT	SEGMENT
tm$ = 80
cls$ = 112
f$ = 120
timet$ = 128
us$ = 136
tzinfo$ = 144
datetime_from_timet_and_us PROC				; COMDAT

; 4078 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4079 :     struct tm *tm;
; 4080 : 
; 4081 :     tm = f(&timet);

  00018	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR timet$[rsp]
  00020	ff 54 24 78	 call	 QWORD PTR f$[rsp]
  00024	48 89 44 24 50	 mov	 QWORD PTR tm$[rsp], rax

; 4082 :     if (tm == NULL) {

  00029	48 83 7c 24 50
	00		 cmp	 QWORD PTR tm$[rsp], 0
  0002f	75 28		 jne	 SHORT $LN3@datetime_f

; 4083 : #ifdef EINVAL
; 4084 :         if (errno == 0)

  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00037	83 38 00	 cmp	 DWORD PTR [rax], 0
  0003a	75 0c		 jne	 SHORT $LN2@datetime_f

; 4085 :             errno = EINVAL;

  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00042	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
$LN2@datetime_f:

; 4086 : #endif
; 4087 :         return PyErr_SetFromErrno(PyExc_OSError);

  00048	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  0004f	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  00054	e9 8b 00 00 00	 jmp	 $LN4@datetime_f
$LN3@datetime_f:

; 4088 :     }
; 4089 : 
; 4090 :     /* The platform localtime/gmtime may insert leap seconds,
; 4091 :      * indicated by tm->tm_sec > 59.  We don't care about them,
; 4092 :      * except to the extent that passing them on to the datetime
; 4093 :      * constructor would raise ValueError for a reason that
; 4094 :      * made no sense to the user.
; 4095 :      */
; 4096 :     if (tm->tm_sec > 59)

  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR tm$[rsp]
  0005e	83 38 3b	 cmp	 DWORD PTR [rax], 59	; 0000003bH
  00061	7e 0b		 jle	 SHORT $LN1@datetime_f

; 4097 :         tm->tm_sec = 59;

  00063	48 8b 44 24 50	 mov	 rax, QWORD PTR tm$[rsp]
  00068	c7 00 3b 00 00
	00		 mov	 DWORD PTR [rax], 59	; 0000003bH
$LN1@datetime_f:

; 4098 :     return PyObject_CallFunction(cls, "iiiiiiiO",
; 4099 :                                  tm->tm_year + 1900,
; 4100 :                                  tm->tm_mon + 1,
; 4101 :                                  tm->tm_mday,
; 4102 :                                  tm->tm_hour,
; 4103 :                                  tm->tm_min,
; 4104 :                                  tm->tm_sec,
; 4105 :                                  us,
; 4106 :                                  tzinfo);

  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR tm$[rsp]
  00073	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00076	ff c0		 inc	 eax
  00078	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tm$[rsp]
  0007d	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00080	81 c1 6c 07 00
	00		 add	 ecx, 1900		; 0000076cH
  00086	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tzinfo$[rsp]
  0008e	48 89 54 24 48	 mov	 QWORD PTR [rsp+72], rdx
  00093	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR us$[rsp]
  0009a	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR tm$[rsp]
  000a3	8b 12		 mov	 edx, DWORD PTR [rdx]
  000a5	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  000a9	48 8b 54 24 50	 mov	 rdx, QWORD PTR tm$[rsp]
  000ae	8b 52 04	 mov	 edx, DWORD PTR [rdx+4]
  000b1	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  000b5	48 8b 54 24 50	 mov	 rdx, QWORD PTR tm$[rsp]
  000ba	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  000bd	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  000c1	48 8b 54 24 50	 mov	 rdx, QWORD PTR tm$[rsp]
  000c6	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  000c9	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  000cd	44 8b c8	 mov	 r9d, eax
  000d0	44 8b c1	 mov	 r8d, ecx
  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08PFKMDOEK@iiiiiiiO?$AA@
  000da	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cls$[rsp]
  000df	e8 00 00 00 00	 call	 PyObject_CallFunction
$LN4@datetime_f:

; 4107 : }

  000e4	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000e8	c3		 ret	 0
datetime_from_timet_and_us ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_utcnow DD imagerel datetime_utcnow
	DD	imagerel datetime_utcnow+43
	DD	imagerel $unwind$datetime_utcnow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_utcnow DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_utcnow
_TEXT	SEGMENT
cls$ = 48
dummy$ = 56
datetime_utcnow PROC					; COMDAT

; 4176 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4177 :     return datetime_best_possible(cls, gmtime, Py_None);

  0000e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gmtime
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cls$[rsp]
  00021	e8 00 00 00 00	 call	 datetime_best_possible

; 4178 : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
datetime_utcnow ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@LBPLGGDP@O?$HMO?3fromtimestamp?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_fromtimestamp DD imagerel datetime_fromtimestamp
	DD	imagerel datetime_fromtimestamp+293
	DD	imagerel $unwind$datetime_fromtimestamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_fromtimestamp DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0BC@LBPLGGDP@O?$HMO?3fromtimestamp?$AA@
CONST	SEGMENT
??_C@_0BC@LBPLGGDP@O?$HMO?3fromtimestamp?$AA@ DB 'O|O:fromtimestamp', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_fromtimestamp
_TEXT	SEGMENT
self$ = 48
tzinfo$ = 56
timestamp$ = 64
temp$23968 = 72
tv79 = 80
cls$ = 112
args$ = 120
kw$ = 128
datetime_fromtimestamp PROC				; COMDAT

; 4183 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4184 :     PyObject *self;
; 4185 :     PyObject *timestamp;
; 4186 :     PyObject *tzinfo = Py_None;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001a	48 89 44 24 38	 mov	 QWORD PTR tzinfo$[rsp], rax

; 4187 :     static char *keywords[] = {"timestamp", "tz", NULL};
; 4188 : 
; 4189 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "O|O:fromtimestamp",
; 4190 :                                       keywords, &timestamp, &tzinfo))

  0001f	48 8d 44 24 38	 lea	 rax, QWORD PTR tzinfo$[rsp]
  00024	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00029	48 8d 44 24 40	 lea	 rax, QWORD PTR timestamp$[rsp]
  0002e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00033	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??datetime_fromtimestamp@@9@9
  0003a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BC@LBPLGGDP@O?$HMO?3fromtimestamp?$AA@
  00041	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  00049	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  0004e	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00053	85 c0		 test	 eax, eax
  00055	75 07		 jne	 SHORT $LN3@datetime_f@2

; 4191 :         return NULL;

  00057	33 c0		 xor	 eax, eax
  00059	e9 c2 00 00 00	 jmp	 $LN4@datetime_f@2
$LN3@datetime_f@2:

; 4192 :     if (check_tzinfo_subclass(tzinfo) < 0)

  0005e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00063	e8 00 00 00 00	 call	 check_tzinfo_subclass
  00068	85 c0		 test	 eax, eax
  0006a	7d 07		 jge	 SHORT $LN2@datetime_f@2

; 4193 :         return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	e9 ad 00 00 00	 jmp	 $LN4@datetime_f@2
$LN2@datetime_f@2:

; 4194 : 
; 4195 :     self = datetime_from_timestamp(cls,
; 4196 :                                    tzinfo == Py_None ? localtime : gmtime,
; 4197 :                                    timestamp,
; 4198 :                                    tzinfo);

  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0007a	48 39 44 24 38	 cmp	 QWORD PTR tzinfo$[rsp], rax
  0007f	75 0e		 jne	 SHORT $LN6@datetime_f@2
  00081	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:localtime
  00088	48 89 44 24 50	 mov	 QWORD PTR tv79[rsp], rax
  0008d	eb 0c		 jmp	 SHORT $LN7@datetime_f@2
$LN6@datetime_f@2:
  0008f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:gmtime
  00096	48 89 44 24 50	 mov	 QWORD PTR tv79[rsp], rax
$LN7@datetime_f@2:
  0009b	4c 8b 4c 24 38	 mov	 r9, QWORD PTR tzinfo$[rsp]
  000a0	4c 8b 44 24 40	 mov	 r8, QWORD PTR timestamp$[rsp]
  000a5	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv79[rsp]
  000aa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cls$[rsp]
  000af	e8 00 00 00 00	 call	 datetime_from_timestamp
  000b4	48 89 44 24 30	 mov	 QWORD PTR self$[rsp], rax

; 4199 :     if (self != NULL && tzinfo != Py_None) {

  000b9	48 83 7c 24 30
	00		 cmp	 QWORD PTR self$[rsp], 0
  000bf	74 5a		 je	 SHORT $LN1@datetime_f@2
  000c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000c8	48 39 44 24 38	 cmp	 QWORD PTR tzinfo$[rsp], rax
  000cd	74 4c		 je	 SHORT $LN1@datetime_f@2

; 4200 :         /* Convert UTC to tzinfo's zone. */
; 4201 :         PyObject *temp = self;

  000cf	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000d4	48 89 44 24 48	 mov	 QWORD PTR temp$23968[rsp], rax

; 4202 :         _Py_IDENTIFIER(fromutc);
; 4203 : 
; 4204 :         self = _PyObject_CallMethodId(tzinfo, &PyId_fromutc, "O", self);

  000d9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_fromutc@?2??datetime_fromtimestamp@@9@9
  000de	8b c0		 mov	 eax, eax
  000e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000e6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000ef	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000f3	4c 8b 4c 24 30	 mov	 r9, QWORD PTR self$[rsp]
  000f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00107	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  0010c	48 89 44 24 30	 mov	 QWORD PTR self$[rsp], rax

; 4205 :         Py_DECREF(temp);

  00111	48 8b 4c 24 48	 mov	 rcx, QWORD PTR temp$23968[rsp]
  00116	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@datetime_f@2:

; 4206 :     }
; 4207 :     return self;

  0011b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
$LN4@datetime_f@2:

; 4208 : }

  00120	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00124	c3		 ret	 0
datetime_fromtimestamp ENDP
_TEXT	ENDS
EXTRN	_PyTime_ObjectToTimeval:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_from_timestamp DD imagerel datetime_from_timestamp
	DD	imagerel datetime_from_timestamp+93
	DD	imagerel $unwind$datetime_from_timestamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_from_timestamp DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_from_timestamp
_TEXT	SEGMENT
timet$ = 48
us$ = 56
cls$ = 80
f$ = 88
timestamp$ = 96
tzinfo$ = 104
datetime_from_timestamp PROC				; COMDAT

; 4119 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4120 :     time_t timet;
; 4121 :     long us;
; 4122 : 
; 4123 :     if (_PyTime_ObjectToTimeval(timestamp, &timet, &us) == -1)

  00018	4c 8d 44 24 38	 lea	 r8, QWORD PTR us$[rsp]
  0001d	48 8d 54 24 30	 lea	 rdx, QWORD PTR timet$[rsp]
  00022	48 8b 4c 24 60	 mov	 rcx, QWORD PTR timestamp$[rsp]
  00027	e8 00 00 00 00	 call	 _PyTime_ObjectToTimeval
  0002c	83 f8 ff	 cmp	 eax, -1
  0002f	75 04		 jne	 SHORT $LN1@datetime_f@3

; 4124 :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	eb 23		 jmp	 SHORT $LN2@datetime_f@3
$LN1@datetime_f@3:

; 4125 :     return datetime_from_timet_and_us(cls, f, timet, (int)us, tzinfo);

  00035	48 8b 44 24 68	 mov	 rax, QWORD PTR tzinfo$[rsp]
  0003a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003f	44 8b 4c 24 38	 mov	 r9d, DWORD PTR us$[rsp]
  00044	4c 8b 44 24 30	 mov	 r8, QWORD PTR timet$[rsp]
  00049	48 8b 54 24 58	 mov	 rdx, QWORD PTR f$[rsp]
  0004e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cls$[rsp]
  00053	e8 00 00 00 00	 call	 datetime_from_timet_and_us
$LN2@datetime_f@3:

; 4126 : }

  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
datetime_from_timestamp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@BNHDPGIK@O?3utcfromtimestamp?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_utcfromtimestamp DD imagerel datetime_utcfromtimestamp
	DD	imagerel datetime_utcfromtimestamp+93
	DD	imagerel $unwind$datetime_utcfromtimestamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_utcfromtimestamp DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BD@BNHDPGIK@O?3utcfromtimestamp?$AA@
CONST	SEGMENT
??_C@_0BD@BNHDPGIK@O?3utcfromtimestamp?$AA@ DB 'O:utcfromtimestamp', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_utcfromtimestamp
_TEXT	SEGMENT
result$ = 32
timestamp$ = 40
cls$ = 64
args$ = 72
datetime_utcfromtimestamp PROC				; COMDAT

; 4213 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4214 :     PyObject *timestamp;
; 4215 :     PyObject *result = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 4216 : 
; 4217 :     if (PyArg_ParseTuple(args, "O:utcfromtimestamp", &timestamp))

  00017	4c 8d 44 24 28	 lea	 r8, QWORD PTR timestamp$[rsp]
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@BNHDPGIK@O?3utcfromtimestamp?$AA@
  00023	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002d	85 c0		 test	 eax, eax
  0002f	74 22		 je	 SHORT $LN1@datetime_u

; 4218 :         result = datetime_from_timestamp(cls, gmtime, timestamp,
; 4219 :                                          Py_None);

  00031	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00038	4c 8b 44 24 28	 mov	 r8, QWORD PTR timestamp$[rsp]
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gmtime
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cls$[rsp]
  00049	e8 00 00 00 00	 call	 datetime_from_timestamp
  0004e	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN1@datetime_u:

; 4220 :     return result;

  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 4221 : }

  00058	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005c	c3		 ret	 0
datetime_utcfromtimestamp ENDP
_TEXT	ENDS
PUBLIC	??_C@_03BBOLPBLP@OOO?$AA@			; `string'
PUBLIC	??_C@_09NHHCNPOC@_strptime?$AA@			; `string'
PUBLIC	??_C@_0M@NFNCOCLF@UU?3strptime?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_strptime DD imagerel datetime_strptime
	DD	imagerel datetime_strptime+170
	DD	imagerel $unwind$datetime_strptime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_strptime DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_03BBOLPBLP@OOO?$AA@
CONST	SEGMENT
??_C@_03BBOLPBLP@OOO?$AA@ DB 'OOO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09NHHCNPOC@_strptime?$AA@
CONST	SEGMENT
??_C@_09NHHCNPOC@_strptime?$AA@ DB '_strptime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NFNCOCLF@UU?3strptime?$AA@
CONST	SEGMENT
??_C@_0M@NFNCOCLF@UU?3strptime?$AA@ DB 'UU:strptime', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_strptime
_TEXT	SEGMENT
format$ = 48
string$ = 56
cls$ = 80
args$ = 88
datetime_strptime PROC					; COMDAT

; 4226 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4227 :     static PyObject *module = NULL;
; 4228 :     PyObject *string, *format;
; 4229 :     _Py_IDENTIFIER(_strptime_datetime);
; 4230 : 
; 4231 :     if (!PyArg_ParseTuple(args, "UU:strptime", &string, &format))

  0000e	4c 8d 4c 24 30	 lea	 r9, QWORD PTR format$[rsp]
  00013	4c 8d 44 24 38	 lea	 r8, QWORD PTR string$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@NFNCOCLF@UU?3strptime?$AA@
  0001f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN3@datetime_s

; 4232 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 74		 jmp	 SHORT $LN4@datetime_s
$LN3@datetime_s:

; 4233 : 
; 4234 :     if (module == NULL) {

  00031	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?module@?1??datetime_strptime@@9@9, 0
  00039	75 21		 jne	 SHORT $LN2@datetime_s

; 4235 :         module = PyImport_ImportModuleNoBlock("_strptime");

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09NHHCNPOC@_strptime?$AA@
  00042	e8 00 00 00 00	 call	 PyImport_ImportModuleNoBlock
  00047	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?module@?1??datetime_strptime@@9@9, rax

; 4236 :         if (module == NULL)

  0004e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?module@?1??datetime_strptime@@9@9, 0
  00056	75 04		 jne	 SHORT $LN1@datetime_s

; 4237 :             return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	eb 49		 jmp	 SHORT $LN4@datetime_s
$LN1@datetime_s:
$LN2@datetime_s:

; 4238 :     }
; 4239 :     return _PyObject_CallMethodId(module, &PyId__strptime_datetime, "OOO",
; 4240 :                                  cls, string, format);

  0005c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId__strptime_datetime@?1??datetime_strptime@@9@9
  00061	8b c0		 mov	 eax, eax
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00069	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00072	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR format$[rsp]
  0007b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00080	48 8b 4c 24 38	 mov	 rcx, QWORD PTR string$[rsp]
  00085	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0008a	4c 8b 4c 24 50	 mov	 r9, QWORD PTR cls$[rsp]
  0008f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03BBOLPBLP@OOO?$AA@
  00096	48 8b d0	 mov	 rdx, rax
  00099	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?module@?1??datetime_strptime@@9@9
  000a0	e8 00 00 00 00	 call	 _PyObject_CallMethodId
$LN4@datetime_s:

; 4241 : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
datetime_strptime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NPDNMHED@O?$CBO?$CB?3combine?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_combine DD imagerel datetime_combine
	DD	imagerel datetime_combine+343
	DD	imagerel $unwind$datetime_combine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_combine DD 021401H
	DD	03010d214H
xdata	ENDS
;	COMDAT ??_C@_0N@NPDNMHED@O?$CBO?$CB?3combine?$AA@
CONST	SEGMENT
??_C@_0N@NPDNMHED@O?$CBO?$CB?3combine?$AA@ DB 'O!O!:combine', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_combine
_TEXT	SEGMENT
time$ = 80
date$ = 88
result$ = 96
tzinfo$24025 = 104
cls$ = 128
args$ = 136
kw$ = 144
datetime_combine PROC					; COMDAT

; 4246 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 4247 :     static char *keywords[] = {"date", "time", NULL};
; 4248 :     PyObject *date;
; 4249 :     PyObject *time;
; 4250 :     PyObject *result = NULL;

  00014	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 4251 : 
; 4252 :     if (PyArg_ParseTupleAndKeywords(args, kw, "O!O!:combine", keywords,
; 4253 :                                     &PyDateTime_DateType, &date,
; 4254 :                                     &PyDateTime_TimeType, &time)) {

  0001d	48 8d 44 24 50	 lea	 rax, QWORD PTR time$[rsp]
  00022	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00027	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TimeType
  0002e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00033	48 8d 44 24 58	 lea	 rax, QWORD PTR date$[rsp]
  00038	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateType
  00044	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00049	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??datetime_combine@@9@9
  00050	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@NPDNMHED@O?$CBO?$CB?3combine?$AA@
  00057	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  0005f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00067	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 d8 00 00
	00		 je	 $LN2@datetime_c

; 4255 :         PyObject *tzinfo = Py_None;

  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0007b	48 89 44 24 68	 mov	 QWORD PTR tzinfo$24025[rsp], rax

; 4256 : 
; 4257 :         if (HASTZINFO(time))

  00080	48 8b 44 24 50	 mov	 rax, QWORD PTR time$[rsp]
  00085	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00089	85 c0		 test	 eax, eax
  0008b	74 0e		 je	 SHORT $LN1@datetime_c

; 4258 :             tzinfo = ((PyDateTime_Time *)time)->tzinfo;

  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR time$[rsp]
  00092	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00096	48 89 44 24 68	 mov	 QWORD PTR tzinfo$24025[rsp], rax
$LN1@datetime_c:

; 4259 :         result = PyObject_CallFunction(cls, "iiiiiiiO",
; 4260 :                                         GET_YEAR(date),
; 4261 :                                         GET_MONTH(date),
; 4262 :                                         GET_DAY(date),
; 4263 :                                         TIME_GET_HOUR(time),
; 4264 :                                         TIME_GET_MINUTE(time),
; 4265 :                                         TIME_GET_SECOND(time),
; 4266 :                                         TIME_GET_MICROSECOND(time),
; 4267 :                                         tzinfo);

  0009b	48 8b 44 24 50	 mov	 rax, QWORD PTR time$[rsp]
  000a0	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  000a4	c1 e0 10	 shl	 eax, 16
  000a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR time$[rsp]
  000ac	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  000b0	c1 e1 08	 shl	 ecx, 8
  000b3	0b c1		 or	 eax, ecx
  000b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR time$[rsp]
  000ba	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  000be	0b c1		 or	 eax, ecx
  000c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR time$[rsp]
  000c5	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  000c9	48 8b 54 24 50	 mov	 rdx, QWORD PTR time$[rsp]
  000ce	0f b6 52 6a	 movzx	 edx, BYTE PTR [rdx+106]
  000d2	4c 8b 44 24 50	 mov	 r8, QWORD PTR time$[rsp]
  000d7	45 0f b6 40 69	 movzx	 r8d, BYTE PTR [r8+105]
  000dc	4c 8b 4c 24 58	 mov	 r9, QWORD PTR date$[rsp]
  000e1	45 0f b6 49 6c	 movzx	 r9d, BYTE PTR [r9+108]
  000e6	4c 8b 54 24 58	 mov	 r10, QWORD PTR date$[rsp]
  000eb	45 0f b6 52 6b	 movzx	 r10d, BYTE PTR [r10+107]
  000f0	4c 8b 5c 24 58	 mov	 r11, QWORD PTR date$[rsp]
  000f5	45 0f b6 5b 69	 movzx	 r11d, BYTE PTR [r11+105]
  000fa	41 c1 e3 08	 shl	 r11d, 8
  000fe	48 8b 5c 24 58	 mov	 rbx, QWORD PTR date$[rsp]
  00103	0f b6 5b 6a	 movzx	 ebx, BYTE PTR [rbx+106]
  00107	44 0b db	 or	 r11d, ebx
  0010a	41 8b db	 mov	 ebx, r11d
  0010d	4c 8b 5c 24 68	 mov	 r11, QWORD PTR tzinfo$24025[rsp]
  00112	4c 89 5c 24 48	 mov	 QWORD PTR [rsp+72], r11
  00117	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0011b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0011f	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00123	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00128	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  0012d	45 8b ca	 mov	 r9d, r10d
  00130	44 8b c3	 mov	 r8d, ebx
  00133	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08PFKMDOEK@iiiiiiiO?$AA@
  0013a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cls$[rsp]
  00142	e8 00 00 00 00	 call	 PyObject_CallFunction
  00147	48 89 44 24 60	 mov	 QWORD PTR result$[rsp], rax
$LN2@datetime_c:

; 4268 :     }
; 4269 :     return result;

  0014c	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]

; 4270 : }

  00151	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00155	5b		 pop	 rbx
  00156	c3		 ret	 0
datetime_combine ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_dealloc DD imagerel datetime_dealloc
	DD	imagerel datetime_dealloc+79
	DD	imagerel $unwind$datetime_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_dealloc
_TEXT	SEGMENT
self$ = 48
datetime_dealloc PROC					; COMDAT

; 4278 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4279 :     if (HASTZINFO(self)) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00012	85 c0		 test	 eax, eax
  00014	74 20		 je	 SHORT $LN5@datetime_d
$LN4@datetime_d:

; 4280 :         Py_XDECREF(self->tzinfo);

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0001b	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00020	74 0e		 je	 SHORT $LN1@datetime_d
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00027	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  0002b	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@datetime_d:
  00030	33 c0		 xor	 eax, eax
  00032	85 c0		 test	 eax, eax
  00034	75 e0		 jne	 SHORT $LN4@datetime_d
$LN5@datetime_d:

; 4281 :     }
; 4282 :     Py_TYPE(self)->tp_free((PyObject *)self);

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00044	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 4283 : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
datetime_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_utcoffset DD imagerel datetime_utcoffset
	DD	imagerel datetime_utcoffset+75
	DD	imagerel $unwind$datetime_utcoffset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_utcoffset DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_utcoffset
_TEXT	SEGMENT
tv70 = 32
self$ = 64
unused$ = 72
datetime_utcoffset PROC					; COMDAT

; 4291 : datetime_utcoffset(PyObject *self, PyObject *unused) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4292 :     return call_utcoffset(GET_DT_TZINFO(self), self);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00017	85 c0		 test	 eax, eax
  00019	74 10		 je	 SHORT $LN3@datetime_u@2
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00024	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
  00029	eb 0c		 jmp	 SHORT $LN4@datetime_u@2
$LN3@datetime_u@2:
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00032	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
$LN4@datetime_u@2:
  00037	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  0003c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv70[rsp]
  00041	e8 00 00 00 00	 call	 call_utcoffset

; 4293 : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
datetime_utcoffset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_dst DD imagerel datetime_dst
	DD	imagerel datetime_dst+75
	DD	imagerel $unwind$datetime_dst
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_dst DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_dst
_TEXT	SEGMENT
tv70 = 32
self$ = 64
unused$ = 72
datetime_dst PROC					; COMDAT

; 4296 : datetime_dst(PyObject *self, PyObject *unused) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4297 :     return call_dst(GET_DT_TZINFO(self), self);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00017	85 c0		 test	 eax, eax
  00019	74 10		 je	 SHORT $LN3@datetime_d@2
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00024	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
  00029	eb 0c		 jmp	 SHORT $LN4@datetime_d@2
$LN3@datetime_d@2:
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00032	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
$LN4@datetime_d@2:
  00037	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  0003c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv70[rsp]
  00041	e8 00 00 00 00	 call	 call_dst

; 4298 : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
datetime_dst ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_tzname DD imagerel datetime_tzname
	DD	imagerel datetime_tzname+75
	DD	imagerel $unwind$datetime_tzname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_tzname DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_tzname
_TEXT	SEGMENT
tv70 = 32
self$ = 64
unused$ = 72
datetime_tzname PROC					; COMDAT

; 4301 : datetime_tzname(PyObject *self, PyObject *unused) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4302 :     return call_tzname(GET_DT_TZINFO(self), self);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00017	85 c0		 test	 eax, eax
  00019	74 10		 je	 SHORT $LN3@datetime_t@2
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00024	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
  00029	eb 0c		 jmp	 SHORT $LN4@datetime_t@2
$LN3@datetime_t@2:
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00032	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
$LN4@datetime_t@2:
  00037	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  0003c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv70[rsp]
  00041	e8 00 00 00 00	 call	 call_tzname

; 4303 : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
datetime_tzname ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DI@NDEJBMCE@?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_datetime_timedelta DD imagerel add_datetime_timedelta
	DD	imagerel add_datetime_timedelta+485
	DD	imagerel $unwind$add_datetime_timedelta
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_datetime_timedelta DD 021601H
	DD	0110116H
xdata	ENDS
;	COMDAT ??_C@_1DI@NDEJBMCE@?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@NDEJBMCE@?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@ DB 'f'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '1', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, 'f', 00H, 'a', 00H, 'c', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '-', 00H, '1'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT add_datetime_timedelta
_TEXT	SEGMENT
day$ = 80
microsecond$ = 84
second$ = 88
minute$ = 92
hour$ = 96
month$ = 100
year$ = 104
tv162 = 112
date$ = 144
delta$ = 152
factor$ = 160
add_datetime_timedelta PROC				; COMDAT

; 4315 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 4316 :     /* Note that the C-level additions can't overflow, because of
; 4317 :      * invariant bounds on the member values.
; 4318 :      */
; 4319 :     int year = GET_YEAR(date);

  00016	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR date$[rsp]
  0001e	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00022	c1 e0 08	 shl	 eax, 8
  00025	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR date$[rsp]
  0002d	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00031	0b c1		 or	 eax, ecx
  00033	89 44 24 68	 mov	 DWORD PTR year$[rsp], eax

; 4320 :     int month = GET_MONTH(date);

  00037	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR date$[rsp]
  0003f	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  00043	89 44 24 64	 mov	 DWORD PTR month$[rsp], eax

; 4321 :     int day = GET_DAY(date) + GET_TD_DAYS(delta) * factor;

  00047	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR date$[rsp]
  0004f	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00053	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR delta$[rsp]
  0005b	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  0005e	0f af 8c 24 a0
	00 00 00	 imul	 ecx, DWORD PTR factor$[rsp]
  00066	03 c1		 add	 eax, ecx
  00068	89 44 24 50	 mov	 DWORD PTR day$[rsp], eax

; 4322 :     int hour = DATE_GET_HOUR(date);

  0006c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR date$[rsp]
  00074	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  00078	89 44 24 60	 mov	 DWORD PTR hour$[rsp], eax

; 4323 :     int minute = DATE_GET_MINUTE(date);

  0007c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR date$[rsp]
  00084	0f b6 40 6e	 movzx	 eax, BYTE PTR [rax+110]
  00088	89 44 24 5c	 mov	 DWORD PTR minute$[rsp], eax

; 4324 :     int second = DATE_GET_SECOND(date) + GET_TD_SECONDS(delta) * factor;

  0008c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR date$[rsp]
  00094	0f b6 40 6f	 movzx	 eax, BYTE PTR [rax+111]
  00098	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR delta$[rsp]
  000a0	8b 49 6c	 mov	 ecx, DWORD PTR [rcx+108]
  000a3	0f af 8c 24 a0
	00 00 00	 imul	 ecx, DWORD PTR factor$[rsp]
  000ab	03 c1		 add	 eax, ecx
  000ad	89 44 24 58	 mov	 DWORD PTR second$[rsp], eax

; 4325 :     int microsecond = DATE_GET_MICROSECOND(date) +
; 4326 :                       GET_TD_MICROSECONDS(delta) * factor;

  000b1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR date$[rsp]
  000b9	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  000bd	c1 e0 10	 shl	 eax, 16
  000c0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR date$[rsp]
  000c8	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  000cc	c1 e1 08	 shl	 ecx, 8
  000cf	0b c1		 or	 eax, ecx
  000d1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR date$[rsp]
  000d9	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  000dd	0b c1		 or	 eax, ecx
  000df	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR delta$[rsp]
  000e7	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  000ea	0f af 8c 24 a0
	00 00 00	 imul	 ecx, DWORD PTR factor$[rsp]
  000f2	03 c1		 add	 eax, ecx
  000f4	89 44 24 54	 mov	 DWORD PTR microsecond$[rsp], eax

; 4327 : 
; 4328 :     assert(factor == 1 || factor == -1);

  000f8	83 bc 24 a0 00
	00 00 01	 cmp	 DWORD PTR factor$[rsp], 1
  00100	74 26		 je	 SHORT $LN5@add_dateti
  00102	83 bc 24 a0 00
	00 00 ff	 cmp	 DWORD PTR factor$[rsp], -1
  0010a	74 1c		 je	 SHORT $LN5@add_dateti
  0010c	41 b8 e8 10 00
	00		 mov	 r8d, 4328		; 000010e8H
  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@NDEJBMCE@?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAf?$AAa?$AAc?$AAt?$AAo?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?9?$AA1?$AA?$AA@
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00126	33 c0		 xor	 eax, eax
$LN5@add_dateti:

; 4329 :     if (normalize_datetime(&year, &month, &day,
; 4330 :                            &hour, &minute, &second, &microsecond) < 0)

  00128	48 8d 44 24 54	 lea	 rax, QWORD PTR microsecond$[rsp]
  0012d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00132	48 8d 44 24 58	 lea	 rax, QWORD PTR second$[rsp]
  00137	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0013c	48 8d 44 24 5c	 lea	 rax, QWORD PTR minute$[rsp]
  00141	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00146	4c 8d 4c 24 60	 lea	 r9, QWORD PTR hour$[rsp]
  0014b	4c 8d 44 24 50	 lea	 r8, QWORD PTR day$[rsp]
  00150	48 8d 54 24 64	 lea	 rdx, QWORD PTR month$[rsp]
  00155	48 8d 4c 24 68	 lea	 rcx, QWORD PTR year$[rsp]
  0015a	e8 00 00 00 00	 call	 normalize_datetime
  0015f	85 c0		 test	 eax, eax
  00161	7d 06		 jge	 SHORT $LN2@add_dateti

; 4331 :         return NULL;

  00163	33 c0		 xor	 eax, eax
  00165	eb 76		 jmp	 SHORT $LN3@add_dateti

; 4332 :     else

  00167	eb 74		 jmp	 SHORT $LN1@add_dateti
$LN2@add_dateti:

; 4333 :         return new_datetime(year, month, day,
; 4334 :                             hour, minute, second, microsecond,
; 4335 :                             HASTZINFO(date) ? date->tzinfo : Py_None);

  00169	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR date$[rsp]
  00171	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00175	85 c0		 test	 eax, eax
  00177	74 13		 je	 SHORT $LN6@add_dateti
  00179	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR date$[rsp]
  00181	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00185	48 89 44 24 70	 mov	 QWORD PTR tv162[rsp], rax
  0018a	eb 0c		 jmp	 SHORT $LN7@add_dateti
$LN6@add_dateti:
  0018c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00193	48 89 44 24 70	 mov	 QWORD PTR tv162[rsp], rax
$LN7@add_dateti:
  00198	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  0019f	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  001a4	48 8b 44 24 70	 mov	 rax, QWORD PTR tv162[rsp]
  001a9	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  001ae	8b 44 24 54	 mov	 eax, DWORD PTR microsecond$[rsp]
  001b2	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001b6	8b 44 24 58	 mov	 eax, DWORD PTR second$[rsp]
  001ba	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001be	8b 44 24 5c	 mov	 eax, DWORD PTR minute$[rsp]
  001c2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001c6	44 8b 4c 24 60	 mov	 r9d, DWORD PTR hour$[rsp]
  001cb	44 8b 44 24 50	 mov	 r8d, DWORD PTR day$[rsp]
  001d0	8b 54 24 64	 mov	 edx, DWORD PTR month$[rsp]
  001d4	8b 4c 24 68	 mov	 ecx, DWORD PTR year$[rsp]
  001d8	e8 00 00 00 00	 call	 new_datetime_ex
$LN1@add_dateti:
$LN3@add_dateti:

; 4336 : }

  001dd	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001e4	c3		 ret	 0
add_datetime_timedelta ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$normalize_datetime DD imagerel normalize_datetime
	DD	imagerel normalize_datetime+133
	DD	imagerel $unwind$normalize_datetime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$normalize_datetime DD 011801H
	DD	04218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT normalize_datetime
_TEXT	SEGMENT
year$ = 48
month$ = 56
day$ = 64
hour$ = 72
minute$ = 80
second$ = 88
microsecond$ = 96
normalize_datetime PROC					; COMDAT

; 578  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 579  :     normalize_pair(second, microsecond, 1000000);

  00018	41 b8 40 42 0f
	00		 mov	 r8d, 1000000		; 000f4240H
  0001e	48 8b 54 24 60	 mov	 rdx, QWORD PTR microsecond$[rsp]
  00023	48 8b 4c 24 58	 mov	 rcx, QWORD PTR second$[rsp]
  00028	e8 00 00 00 00	 call	 normalize_pair

; 580  :     normalize_pair(minute, second, 60);

  0002d	41 b8 3c 00 00
	00		 mov	 r8d, 60			; 0000003cH
  00033	48 8b 54 24 58	 mov	 rdx, QWORD PTR second$[rsp]
  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR minute$[rsp]
  0003d	e8 00 00 00 00	 call	 normalize_pair

; 581  :     normalize_pair(hour, minute, 60);

  00042	41 b8 3c 00 00
	00		 mov	 r8d, 60			; 0000003cH
  00048	48 8b 54 24 50	 mov	 rdx, QWORD PTR minute$[rsp]
  0004d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hour$[rsp]
  00052	e8 00 00 00 00	 call	 normalize_pair

; 582  :     normalize_pair(day, hour, 24);

  00057	41 b8 18 00 00
	00		 mov	 r8d, 24
  0005d	48 8b 54 24 48	 mov	 rdx, QWORD PTR hour$[rsp]
  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR day$[rsp]
  00067	e8 00 00 00 00	 call	 normalize_pair

; 583  :     return normalize_date(year, month, day);

  0006c	4c 8b 44 24 40	 mov	 r8, QWORD PTR day$[rsp]
  00071	48 8b 54 24 38	 mov	 rdx, QWORD PTR month$[rsp]
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR year$[rsp]
  0007b	e8 00 00 00 00	 call	 normalize_date

; 584  : }

  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	c3		 ret	 0
normalize_datetime ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_add DD imagerel datetime_add
	DD	imagerel datetime_add+215
	DD	imagerel $unwind$datetime_add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_add DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_add
_TEXT	SEGMENT
left$ = 48
right$ = 56
datetime_add PROC					; COMDAT

; 4340 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4341 :     if (PyDateTime_Check(left)) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR left$[rsp]
  0001a	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0001e	74 19		 je	 SHORT $LN6@datetime_a@2
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR left$[rsp]
  0002c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00030	e8 00 00 00 00	 call	 PyType_IsSubtype
  00035	85 c0		 test	 eax, eax
  00037	74 44		 je	 SHORT $LN7@datetime_a@2
$LN6@datetime_a@2:

; 4342 :         /* datetime + ??? */
; 4343 :         if (PyDelta_Check(right))

  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR right$[rsp]
  00045	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00049	74 19		 je	 SHORT $LN4@datetime_a@2
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00052	48 8b 44 24 38	 mov	 rax, QWORD PTR right$[rsp]
  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	e8 00 00 00 00	 call	 PyType_IsSubtype
  00060	85 c0		 test	 eax, eax
  00062	74 17		 je	 SHORT $LN5@datetime_a@2
$LN4@datetime_a@2:

; 4344 :             /* datetime + delta */
; 4345 :             return add_datetime_timedelta(
; 4346 :                             (PyDateTime_DateTime *)left,
; 4347 :                             (PyDateTime_Delta *)right,
; 4348 :                             1);

  00064	41 b8 01 00 00
	00		 mov	 r8d, 1
  0006a	48 8b 54 24 38	 mov	 rdx, QWORD PTR right$[rsp]
  0006f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR left$[rsp]
  00074	e8 00 00 00 00	 call	 add_datetime_timedelta
  00079	eb 57		 jmp	 SHORT $LN8@datetime_a@2
$LN5@datetime_a@2:

; 4349 :     }
; 4350 :     else if (PyDelta_Check(left)) {

  0007b	eb 42		 jmp	 SHORT $LN3@datetime_a@2
$LN7@datetime_a@2:
  0007d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00084	48 8b 4c 24 30	 mov	 rcx, QWORD PTR left$[rsp]
  00089	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0008d	74 19		 je	 SHORT $LN1@datetime_a@2
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR left$[rsp]
  0009b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0009f	e8 00 00 00 00	 call	 PyType_IsSubtype
  000a4	85 c0		 test	 eax, eax
  000a6	74 17		 je	 SHORT $LN2@datetime_a@2
$LN1@datetime_a@2:

; 4351 :         /* delta + datetime */
; 4352 :         return add_datetime_timedelta((PyDateTime_DateTime *) right,
; 4353 :                                       (PyDateTime_Delta *) left,
; 4354 :                                       1);

  000a8	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ae	48 8b 54 24 30	 mov	 rdx, QWORD PTR left$[rsp]
  000b3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR right$[rsp]
  000b8	e8 00 00 00 00	 call	 add_datetime_timedelta
  000bd	eb 13		 jmp	 SHORT $LN8@datetime_a@2
$LN2@datetime_a@2:
$LN3@datetime_a@2:

; 4355 :     }
; 4356 :     Py_RETURN_NOTIMPLEMENTED;

  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  000c6	e8 00 00 00 00	 call	 _Py_IncRef
  000cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN8@datetime_a@2:

; 4357 : }

  000d2	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d6	c3		 ret	 0
datetime_add ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@MNPNJBBF@can?8t?5subtract?5offset?9naive?5and?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_subtract DD imagerel datetime_subtract
	DD	imagerel datetime_subtract+1198
	DD	imagerel $unwind$datetime_subtract
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_subtract DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0DH@MNPNJBBF@can?8t?5subtract?5offset?9naive?5and?5@
CONST	SEGMENT
??_C@_0DH@MNPNJBBF@can?8t?5subtract?5offset?9naive?5and?5@ DB 'can''t sub'
	DB	'tract offset-naive and offset-aware datetimes', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_subtract
_TEXT	SEGMENT
result$ = 48
delta_s$24151 = 56
delta_d$24150 = 60
offset1$24146 = 64
offdiff$24148 = 72
delta_us$24152 = 80
offset2$24147 = 88
temp$24205 = 96
tv82 = 104
tv87 = 112
tv135 = 120
tv134 = 124
tv170 = 128
tv154 = 132
tv188 = 136
left$ = 160
right$ = 168
datetime_subtract PROC					; COMDAT

; 4361 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 4362 :     PyObject *result = Py_NotImplemented;

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00018	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 4363 : 
; 4364 :     if (PyDateTime_Check(left)) {

  0001d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00024	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR left$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 20		 je	 SHORT $LN15@datetime_s@2
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00039	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR left$[rsp]
  00041	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00045	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004a	85 c0		 test	 eax, eax
  0004c	0f 84 37 04 00
	00		 je	 $LN16@datetime_s@2
$LN15@datetime_s@2:

; 4365 :         /* datetime - ??? */
; 4366 :         if (PyDateTime_Check(right)) {

  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00059	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR right$[rsp]
  00061	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00065	74 20		 je	 SHORT $LN13@datetime_s@2
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  0006e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR right$[rsp]
  00076	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0007a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0007f	85 c0		 test	 eax, eax
  00081	0f 84 b1 03 00
	00		 je	 $LN14@datetime_s@2
$LN13@datetime_s@2:

; 4367 :             /* datetime - datetime */
; 4368 :             PyObject *offset1, *offset2, *offdiff = NULL;

  00087	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR offdiff$24148[rsp], 0

; 4369 :             int delta_d, delta_s, delta_us;
; 4370 : 
; 4371 :             if (GET_DT_TZINFO(left) == GET_DT_TZINFO(right)) {

  00090	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR left$[rsp]
  00098	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  0009c	85 c0		 test	 eax, eax
  0009e	74 13		 je	 SHORT $LN19@datetime_s@2
  000a0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR left$[rsp]
  000a8	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000ac	48 89 44 24 68	 mov	 QWORD PTR tv82[rsp], rax
  000b1	eb 0c		 jmp	 SHORT $LN20@datetime_s@2
$LN19@datetime_s@2:
  000b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ba	48 89 44 24 68	 mov	 QWORD PTR tv82[rsp], rax
$LN20@datetime_s@2:
  000bf	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR right$[rsp]
  000c7	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  000cb	85 c0		 test	 eax, eax
  000cd	74 13		 je	 SHORT $LN21@datetime_s@2
  000cf	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR right$[rsp]
  000d7	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000db	48 89 44 24 70	 mov	 QWORD PTR tv87[rsp], rax
  000e0	eb 0c		 jmp	 SHORT $LN22@datetime_s@2
$LN21@datetime_s@2:
  000e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000e9	48 89 44 24 70	 mov	 QWORD PTR tv87[rsp], rax
$LN22@datetime_s@2:
  000ee	48 8b 44 24 70	 mov	 rax, QWORD PTR tv87[rsp]
  000f3	48 39 44 24 68	 cmp	 QWORD PTR tv82[rsp], rax
  000f8	75 2f		 jne	 SHORT $LN12@datetime_s@2

; 4372 :                 offset2 = offset1 = Py_None;

  000fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00101	48 89 44 24 40	 mov	 QWORD PTR offset1$24146[rsp], rax
  00106	48 8b 44 24 40	 mov	 rax, QWORD PTR offset1$24146[rsp]
  0010b	48 89 44 24 58	 mov	 QWORD PTR offset2$24147[rsp], rax

; 4373 :                 Py_INCREF(offset1);

  00110	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset1$24146[rsp]
  00115	e8 00 00 00 00	 call	 _Py_IncRef

; 4374 :                 Py_INCREF(offset2);

  0011a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR offset2$24147[rsp]
  0011f	e8 00 00 00 00	 call	 _Py_IncRef

; 4375 :             }
; 4376 :             else {

  00124	e9 c8 00 00 00	 jmp	 $LN11@datetime_s@2
$LN12@datetime_s@2:

; 4377 :                 offset1 = datetime_utcoffset(left, NULL);

  00129	33 d2		 xor	 edx, edx
  0012b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR left$[rsp]
  00133	e8 00 00 00 00	 call	 datetime_utcoffset
  00138	48 89 44 24 40	 mov	 QWORD PTR offset1$24146[rsp], rax

; 4378 :                 if (offset1 == NULL)

  0013d	48 83 7c 24 40
	00		 cmp	 QWORD PTR offset1$24146[rsp], 0
  00143	75 07		 jne	 SHORT $LN10@datetime_s@2

; 4379 :                     return NULL;

  00145	33 c0		 xor	 eax, eax
  00147	e9 5a 03 00 00	 jmp	 $LN17@datetime_s@2
$LN10@datetime_s@2:

; 4380 :                 offset2 = datetime_utcoffset(right, NULL);

  0014c	33 d2		 xor	 edx, edx
  0014e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR right$[rsp]
  00156	e8 00 00 00 00	 call	 datetime_utcoffset
  0015b	48 89 44 24 58	 mov	 QWORD PTR offset2$24147[rsp], rax

; 4381 :                 if (offset2 == NULL) {

  00160	48 83 7c 24 58
	00		 cmp	 QWORD PTR offset2$24147[rsp], 0
  00166	75 11		 jne	 SHORT $LN9@datetime_s@2

; 4382 :                     Py_DECREF(offset1);

  00168	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset1$24146[rsp]
  0016d	e8 00 00 00 00	 call	 _Py_DecRef

; 4383 :                     return NULL;

  00172	33 c0		 xor	 eax, eax
  00174	e9 2d 03 00 00	 jmp	 $LN17@datetime_s@2
$LN9@datetime_s@2:

; 4384 :                 }
; 4385 :                 if ((offset1 != Py_None) != (offset2 != Py_None)) {

  00179	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00180	48 39 44 24 40	 cmp	 QWORD PTR offset1$24146[rsp], rax
  00185	74 0a		 je	 SHORT $LN25@datetime_s@2
  00187	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  0018f	eb 08		 jmp	 SHORT $LN26@datetime_s@2
$LN25@datetime_s@2:
  00191	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN26@datetime_s@2:
  00199	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001a0	48 39 44 24 58	 cmp	 QWORD PTR offset2$24147[rsp], rax
  001a5	74 0a		 je	 SHORT $LN23@datetime_s@2
  001a7	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  001af	eb 08		 jmp	 SHORT $LN24@datetime_s@2
$LN23@datetime_s@2:
  001b1	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN24@datetime_s@2:
  001b9	8b 44 24 7c	 mov	 eax, DWORD PTR tv134[rsp]
  001bd	39 44 24 78	 cmp	 DWORD PTR tv135[rsp], eax
  001c1	74 2e		 je	 SHORT $LN8@datetime_s@2

; 4386 :                     PyErr_SetString(PyExc_TypeError,
; 4387 :                                     "can't subtract offset-naive and "
; 4388 :                                     "offset-aware datetimes");

  001c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@MNPNJBBF@can?8t?5subtract?5offset?9naive?5and?5@
  001ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001d1	e8 00 00 00 00	 call	 PyErr_SetString

; 4389 :                     Py_DECREF(offset1);

  001d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset1$24146[rsp]
  001db	e8 00 00 00 00	 call	 _Py_DecRef

; 4390 :                     Py_DECREF(offset2);

  001e0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR offset2$24147[rsp]
  001e5	e8 00 00 00 00	 call	 _Py_DecRef

; 4391 :                     return NULL;

  001ea	33 c0		 xor	 eax, eax
  001ec	e9 b5 02 00 00	 jmp	 $LN17@datetime_s@2
$LN8@datetime_s@2:
$LN11@datetime_s@2:

; 4392 :                 }
; 4393 :             }
; 4394 :             if ((offset1 != offset2) &&
; 4395 :                 delta_cmp(offset1, offset2) != 0) {

  001f1	48 8b 44 24 58	 mov	 rax, QWORD PTR offset2$24147[rsp]
  001f6	48 39 44 24 40	 cmp	 QWORD PTR offset1$24146[rsp], rax
  001fb	74 4a		 je	 SHORT $LN7@datetime_s@2
  001fd	48 8b 54 24 58	 mov	 rdx, QWORD PTR offset2$24147[rsp]
  00202	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset1$24146[rsp]
  00207	e8 00 00 00 00	 call	 delta_cmp
  0020c	85 c0		 test	 eax, eax
  0020e	74 37		 je	 SHORT $LN7@datetime_s@2

; 4396 :                 offdiff = delta_subtract(offset1, offset2);

  00210	48 8b 54 24 58	 mov	 rdx, QWORD PTR offset2$24147[rsp]
  00215	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset1$24146[rsp]
  0021a	e8 00 00 00 00	 call	 delta_subtract
  0021f	48 89 44 24 48	 mov	 QWORD PTR offdiff$24148[rsp], rax

; 4397 :                 if (offdiff == NULL) {

  00224	48 83 7c 24 48
	00		 cmp	 QWORD PTR offdiff$24148[rsp], 0
  0022a	75 1b		 jne	 SHORT $LN6@datetime_s@2

; 4398 :                     Py_DECREF(offset1);

  0022c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset1$24146[rsp]
  00231	e8 00 00 00 00	 call	 _Py_DecRef

; 4399 :                     Py_DECREF(offset2);

  00236	48 8b 4c 24 58	 mov	 rcx, QWORD PTR offset2$24147[rsp]
  0023b	e8 00 00 00 00	 call	 _Py_DecRef

; 4400 :                     return NULL;

  00240	33 c0		 xor	 eax, eax
  00242	e9 5f 02 00 00	 jmp	 $LN17@datetime_s@2
$LN6@datetime_s@2:
$LN7@datetime_s@2:

; 4401 :                 }
; 4402 :             }
; 4403 :             Py_DECREF(offset1);

  00247	48 8b 4c 24 40	 mov	 rcx, QWORD PTR offset1$24146[rsp]
  0024c	e8 00 00 00 00	 call	 _Py_DecRef

; 4404 :             Py_DECREF(offset2);

  00251	48 8b 4c 24 58	 mov	 rcx, QWORD PTR offset2$24147[rsp]
  00256	e8 00 00 00 00	 call	 _Py_DecRef

; 4405 :             delta_d = ymd_to_ord(GET_YEAR(left),
; 4406 :                                  GET_MONTH(left),
; 4407 :                                  GET_DAY(left)) -
; 4408 :                       ymd_to_ord(GET_YEAR(right),
; 4409 :                                  GET_MONTH(right),
; 4410 :                                  GET_DAY(right));

  0025b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR left$[rsp]
  00263	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00267	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR left$[rsp]
  0026f	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  00273	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR left$[rsp]
  0027b	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  0027f	c1 e2 08	 shl	 edx, 8
  00282	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR left$[rsp]
  0028a	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  0028f	41 0b d0	 or	 edx, r8d
  00292	89 94 24 80 00
	00 00		 mov	 DWORD PTR tv170[rsp], edx
  00299	44 8b c0	 mov	 r8d, eax
  0029c	8b d1		 mov	 edx, ecx
  0029e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv170[rsp]
  002a5	8b c8		 mov	 ecx, eax
  002a7	e8 00 00 00 00	 call	 ymd_to_ord
  002ac	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv154[rsp], eax
  002b3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR right$[rsp]
  002bb	0f b6 49 6c	 movzx	 ecx, BYTE PTR [rcx+108]
  002bf	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR right$[rsp]
  002c7	0f b6 52 6b	 movzx	 edx, BYTE PTR [rdx+107]
  002cb	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR right$[rsp]
  002d3	45 0f b6 40 69	 movzx	 r8d, BYTE PTR [r8+105]
  002d8	41 c1 e0 08	 shl	 r8d, 8
  002dc	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR right$[rsp]
  002e4	45 0f b6 49 6a	 movzx	 r9d, BYTE PTR [r9+106]
  002e9	45 0b c1	 or	 r8d, r9d
  002ec	44 89 84 24 88
	00 00 00	 mov	 DWORD PTR tv188[rsp], r8d
  002f4	44 8b c1	 mov	 r8d, ecx
  002f7	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv188[rsp]
  002fe	e8 00 00 00 00	 call	 ymd_to_ord
  00303	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv154[rsp]
  0030a	2b c8		 sub	 ecx, eax
  0030c	8b c1		 mov	 eax, ecx
  0030e	89 44 24 3c	 mov	 DWORD PTR delta_d$24150[rsp], eax

; 4411 :             /* These can't overflow, since the values are
; 4412 :              * normalized.  At most this gives the number of
; 4413 :              * seconds in one day.
; 4414 :              */
; 4415 :             delta_s = (DATE_GET_HOUR(left) -
; 4416 :                        DATE_GET_HOUR(right)) * 3600 +
; 4417 :                       (DATE_GET_MINUTE(left) -
; 4418 :                        DATE_GET_MINUTE(right)) * 60 +
; 4419 :                       (DATE_GET_SECOND(left) -
; 4420 :                        DATE_GET_SECOND(right));

  00312	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR left$[rsp]
  0031a	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  0031e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR right$[rsp]
  00326	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  0032a	2b c1		 sub	 eax, ecx
  0032c	69 c0 10 0e 00
	00		 imul	 eax, 3600		; 00000e10H
  00332	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR left$[rsp]
  0033a	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  0033e	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR right$[rsp]
  00346	0f b6 52 6e	 movzx	 edx, BYTE PTR [rdx+110]
  0034a	2b ca		 sub	 ecx, edx
  0034c	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  0034f	03 c1		 add	 eax, ecx
  00351	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR left$[rsp]
  00359	0f b6 49 6f	 movzx	 ecx, BYTE PTR [rcx+111]
  0035d	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR right$[rsp]
  00365	0f b6 52 6f	 movzx	 edx, BYTE PTR [rdx+111]
  00369	2b ca		 sub	 ecx, edx
  0036b	03 c1		 add	 eax, ecx
  0036d	89 44 24 38	 mov	 DWORD PTR delta_s$24151[rsp], eax

; 4421 :             delta_us = DATE_GET_MICROSECOND(left) -
; 4422 :                        DATE_GET_MICROSECOND(right);

  00371	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR left$[rsp]
  00379	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  0037d	c1 e0 10	 shl	 eax, 16
  00380	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR left$[rsp]
  00388	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  0038c	c1 e1 08	 shl	 ecx, 8
  0038f	0b c1		 or	 eax, ecx
  00391	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR left$[rsp]
  00399	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  0039d	0b c1		 or	 eax, ecx
  0039f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR right$[rsp]
  003a7	0f b6 49 70	 movzx	 ecx, BYTE PTR [rcx+112]
  003ab	c1 e1 10	 shl	 ecx, 16
  003ae	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR right$[rsp]
  003b6	0f b6 52 71	 movzx	 edx, BYTE PTR [rdx+113]
  003ba	c1 e2 08	 shl	 edx, 8
  003bd	0b ca		 or	 ecx, edx
  003bf	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR right$[rsp]
  003c7	0f b6 52 72	 movzx	 edx, BYTE PTR [rdx+114]
  003cb	0b ca		 or	 ecx, edx
  003cd	2b c1		 sub	 eax, ecx
  003cf	89 44 24 50	 mov	 DWORD PTR delta_us$24152[rsp], eax

; 4423 :             result = new_delta(delta_d, delta_s, delta_us, 1);

  003d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  003da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003df	41 b9 01 00 00
	00		 mov	 r9d, 1
  003e5	44 8b 44 24 50	 mov	 r8d, DWORD PTR delta_us$24152[rsp]
  003ea	8b 54 24 38	 mov	 edx, DWORD PTR delta_s$24151[rsp]
  003ee	8b 4c 24 3c	 mov	 ecx, DWORD PTR delta_d$24150[rsp]
  003f2	e8 00 00 00 00	 call	 new_delta_ex
  003f7	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 4424 :             if (offdiff != NULL) {

  003fc	48 83 7c 24 48
	00		 cmp	 QWORD PTR offdiff$24148[rsp], 0
  00402	74 32		 je	 SHORT $LN5@datetime_s@2

; 4425 :                 PyObject *temp = result;

  00404	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  00409	48 89 44 24 60	 mov	 QWORD PTR temp$24205[rsp], rax

; 4426 :                 result = delta_subtract(result, offdiff);

  0040e	48 8b 54 24 48	 mov	 rdx, QWORD PTR offdiff$24148[rsp]
  00413	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00418	e8 00 00 00 00	 call	 delta_subtract
  0041d	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 4427 :                 Py_DECREF(temp);

  00422	48 8b 4c 24 60	 mov	 rcx, QWORD PTR temp$24205[rsp]
  00427	e8 00 00 00 00	 call	 _Py_DecRef

; 4428 :                 Py_DECREF(offdiff);

  0042c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR offdiff$24148[rsp]
  00431	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@datetime_s@2:

; 4429 :             }

  00436	eb 51		 jmp	 SHORT $LN4@datetime_s@2
$LN14@datetime_s@2:

; 4430 :         }
; 4431 :         else if (PyDelta_Check(right)) {

  00438	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  0043f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR right$[rsp]
  00447	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0044b	74 1c		 je	 SHORT $LN2@datetime_s@2
  0044d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  00454	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR right$[rsp]
  0045c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00460	e8 00 00 00 00	 call	 PyType_IsSubtype
  00465	85 c0		 test	 eax, eax
  00467	74 20		 je	 SHORT $LN3@datetime_s@2
$LN2@datetime_s@2:

; 4432 :             /* datetime - delta */
; 4433 :             result = add_datetime_timedelta(
; 4434 :                             (PyDateTime_DateTime *)left,
; 4435 :                             (PyDateTime_Delta *)right,
; 4436 :                             -1);

  00469	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  0046f	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR right$[rsp]
  00477	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR left$[rsp]
  0047f	e8 00 00 00 00	 call	 add_datetime_timedelta
  00484	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
$LN3@datetime_s@2:
$LN4@datetime_s@2:
$LN16@datetime_s@2:

; 4437 :         }
; 4438 :     }
; 4439 : 
; 4440 :     if (result == Py_NotImplemented)

  00489	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00490	48 39 44 24 30	 cmp	 QWORD PTR result$[rsp], rax
  00495	75 0a		 jne	 SHORT $LN1@datetime_s@2

; 4441 :         Py_INCREF(result);

  00497	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  0049c	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@datetime_s@2:

; 4442 :     return result;

  004a1	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN17@datetime_s@2:

; 4443 : }

  004a6	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  004ad	c3		 ret	 0
datetime_subtract ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@NAPEDBH@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BL@ELEDCBGB@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BP@INDHCFMD@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_repr DD imagerel datetime_repr
	DD	imagerel datetime_repr+630
	DD	imagerel $unwind$datetime_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_repr DD 020a01H
	DD	03006d20aH
xdata	ENDS
;	COMDAT ??_C@_0BH@NAPEDBH@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BH@NAPEDBH@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ DB '%'
	DB	's(%d, %d, %d, %d, %d)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@ELEDCBGB@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BL@ELEDCBGB@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ DB '%'
	DB	's(%d, %d, %d, %d, %d, %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@INDHCFMD@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BP@INDHCFMD@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@ DB '%'
	DB	's(%d, %d, %d, %d, %d, %d, %d)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_repr
_TEXT	SEGMENT
baserepr$ = 80
type_name$ = 88
tv190 = 96
self$ = 128
datetime_repr PROC					; COMDAT

; 4449 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 4450 :     const char *type_name = Py_TYPE(self)->tp_name;

  0000a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00012	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00016	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0001a	48 89 44 24 58	 mov	 QWORD PTR type_name$[rsp], rax

; 4451 :     PyObject *baserepr;
; 4452 : 
; 4453 :     if (DATE_GET_MICROSECOND(self)) {

  0001f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00027	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  0002b	c1 e0 10	 shl	 eax, 16
  0002e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00036	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  0003a	c1 e1 08	 shl	 ecx, 8
  0003d	0b c1		 or	 eax, ecx
  0003f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00047	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  0004b	0b c1		 or	 eax, ecx
  0004d	85 c0		 test	 eax, eax
  0004f	0f 84 c7 00 00
	00		 je	 $LN6@datetime_r

; 4454 :         baserepr = PyUnicode_FromFormat(
; 4455 :                       "%s(%d, %d, %d, %d, %d, %d, %d)",
; 4456 :                       type_name,
; 4457 :                       GET_YEAR(self), GET_MONTH(self), GET_DAY(self),
; 4458 :                       DATE_GET_HOUR(self), DATE_GET_MINUTE(self),
; 4459 :                       DATE_GET_SECOND(self),
; 4460 :                       DATE_GET_MICROSECOND(self));

  00055	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0005d	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  00061	c1 e0 10	 shl	 eax, 16
  00064	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0006c	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  00070	c1 e1 08	 shl	 ecx, 8
  00073	0b c1		 or	 eax, ecx
  00075	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0007d	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  00081	0b c1		 or	 eax, ecx
  00083	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0008b	0f b6 49 6f	 movzx	 ecx, BYTE PTR [rcx+111]
  0008f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  00097	0f b6 52 6e	 movzx	 edx, BYTE PTR [rdx+110]
  0009b	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR self$[rsp]
  000a3	45 0f b6 40 6d	 movzx	 r8d, BYTE PTR [r8+109]
  000a8	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR self$[rsp]
  000b0	45 0f b6 49 6c	 movzx	 r9d, BYTE PTR [r9+108]
  000b5	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR self$[rsp]
  000bd	45 0f b6 52 6b	 movzx	 r10d, BYTE PTR [r10+107]
  000c2	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR self$[rsp]
  000ca	45 0f b6 5b 69	 movzx	 r11d, BYTE PTR [r11+105]
  000cf	41 c1 e3 08	 shl	 r11d, 8
  000d3	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR self$[rsp]
  000db	0f b6 5b 6a	 movzx	 ebx, BYTE PTR [rbx+106]
  000df	44 0b db	 or	 r11d, ebx
  000e2	41 8b db	 mov	 ebx, r11d
  000e5	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  000e9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ed	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  000f1	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  000f6	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  000fb	45 8b ca	 mov	 r9d, r10d
  000fe	44 8b c3	 mov	 r8d, ebx
  00101	48 8b 54 24 58	 mov	 rdx, QWORD PTR type_name$[rsp]
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@INDHCFMD@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  0010d	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00112	48 89 44 24 50	 mov	 QWORD PTR baserepr$[rsp], rax
  00117	e9 1f 01 00 00	 jmp	 $LN5@datetime_r
$LN6@datetime_r:

; 4461 :     }
; 4462 :     else if (DATE_GET_SECOND(self)) {

  0011c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00124	0f b6 40 6f	 movzx	 eax, BYTE PTR [rax+111]
  00128	85 c0		 test	 eax, eax
  0012a	0f 84 95 00 00
	00		 je	 $LN4@datetime_r

; 4463 :         baserepr = PyUnicode_FromFormat(
; 4464 :                       "%s(%d, %d, %d, %d, %d, %d)",
; 4465 :                       type_name,
; 4466 :                       GET_YEAR(self), GET_MONTH(self), GET_DAY(self),
; 4467 :                       DATE_GET_HOUR(self), DATE_GET_MINUTE(self),
; 4468 :                       DATE_GET_SECOND(self));

  00130	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00138	0f b6 40 6f	 movzx	 eax, BYTE PTR [rax+111]
  0013c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00144	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  00148	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  00150	0f b6 52 6d	 movzx	 edx, BYTE PTR [rdx+109]
  00154	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR self$[rsp]
  0015c	0f b6 5b 6c	 movzx	 ebx, BYTE PTR [rbx+108]
  00160	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR self$[rsp]
  00168	45 0f b6 40 6b	 movzx	 r8d, BYTE PTR [r8+107]
  0016d	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR self$[rsp]
  00175	45 0f b6 49 69	 movzx	 r9d, BYTE PTR [r9+105]
  0017a	41 c1 e1 08	 shl	 r9d, 8
  0017e	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR self$[rsp]
  00186	45 0f b6 52 6a	 movzx	 r10d, BYTE PTR [r10+106]
  0018b	45 0b ca	 or	 r9d, r10d
  0018e	44 89 4c 24 60	 mov	 DWORD PTR tv190[rsp], r9d
  00193	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00197	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0019b	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  0019f	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  001a3	45 8b c8	 mov	 r9d, r8d
  001a6	8b 44 24 60	 mov	 eax, DWORD PTR tv190[rsp]
  001aa	44 8b c0	 mov	 r8d, eax
  001ad	48 8b 54 24 58	 mov	 rdx, QWORD PTR type_name$[rsp]
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@ELEDCBGB@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  001b9	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  001be	48 89 44 24 50	 mov	 QWORD PTR baserepr$[rsp], rax

; 4469 :     }
; 4470 :     else {

  001c3	eb 76		 jmp	 SHORT $LN3@datetime_r
$LN4@datetime_r:

; 4471 :         baserepr = PyUnicode_FromFormat(
; 4472 :                       "%s(%d, %d, %d, %d, %d)",
; 4473 :                       type_name,
; 4474 :                       GET_YEAR(self), GET_MONTH(self), GET_DAY(self),
; 4475 :                       DATE_GET_HOUR(self), DATE_GET_MINUTE(self));

  001c5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001cd	0f b6 40 6e	 movzx	 eax, BYTE PTR [rax+110]
  001d1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  001d9	0f b6 49 6d	 movzx	 ecx, BYTE PTR [rcx+109]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  001e5	0f b6 52 6c	 movzx	 edx, BYTE PTR [rdx+108]
  001e9	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR self$[rsp]
  001f1	0f b6 5b 6b	 movzx	 ebx, BYTE PTR [rbx+107]
  001f5	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR self$[rsp]
  001fd	45 0f b6 40 69	 movzx	 r8d, BYTE PTR [r8+105]
  00202	41 c1 e0 08	 shl	 r8d, 8
  00206	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR self$[rsp]
  0020e	45 0f b6 49 6a	 movzx	 r9d, BYTE PTR [r9+106]
  00213	45 0b c1	 or	 r8d, r9d
  00216	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0021a	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0021e	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  00222	44 8b cb	 mov	 r9d, ebx
  00225	48 8b 54 24 58	 mov	 rdx, QWORD PTR type_name$[rsp]
  0022a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@NAPEDBH@?$CFs?$CI?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?0?5?$CFd?$CJ?$AA@
  00231	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00236	48 89 44 24 50	 mov	 QWORD PTR baserepr$[rsp], rax
$LN3@datetime_r:
$LN5@datetime_r:

; 4476 :     }
; 4477 :     if (baserepr == NULL || ! HASTZINFO(self))

  0023b	48 83 7c 24 50
	00		 cmp	 QWORD PTR baserepr$[rsp], 0
  00241	74 10		 je	 SHORT $LN1@datetime_r
  00243	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0024b	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  0024f	85 c0		 test	 eax, eax
  00251	75 07		 jne	 SHORT $LN2@datetime_r
$LN1@datetime_r:

; 4478 :         return baserepr;

  00253	48 8b 44 24 50	 mov	 rax, QWORD PTR baserepr$[rsp]
  00258	eb 16		 jmp	 SHORT $LN7@datetime_r
$LN2@datetime_r:

; 4479 :     return append_keyword_tzinfo(baserepr, self->tzinfo);

  0025a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00262	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  00266	48 8b 4c 24 50	 mov	 rcx, QWORD PTR baserepr$[rsp]
  0026b	e8 00 00 00 00	 call	 append_keyword_tzinfo
$LN7@datetime_r:

; 4480 : }

  00270	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00274	5b		 pop	 rbx
  00275	c3		 ret	 0
datetime_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_03KJMMOONA@?$CIs?$CJ?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_str DD imagerel datetime_str
	DD	imagerel datetime_str+67
	DD	imagerel $unwind$datetime_str
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_str DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
CONST	SEGMENT
??_C@_03KJMMOONA@?$CIs?$CJ?$AA@ DB '(s)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_str
_TEXT	SEGMENT
self$ = 48
datetime_str PROC					; COMDAT

; 4484 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4485 :     _Py_IDENTIFIER(isoformat);
; 4486 : 
; 4487 :     return _PyObject_CallMethodId((PyObject *)self, &PyId_isoformat, "(s)", " ");

  00009	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_isoformat@?1??datetime_str@@9@9
  0000e	8b c0		 mov	 eax, eax
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00016	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0001f	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00023	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_03KJMMOONA@?$CIs?$CJ?$AA@
  00031	48 8b d0	 mov	 rdx, rax
  00034	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00039	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 4488 : }

  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00042	c3		 ret	 0
datetime_str ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@MFKBOFBI@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?$AA@ ; `string'
PUBLIC	??_C@_0CE@DKNNHCAH@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?4?$CF@ ; `string'
PUBLIC	??_C@_0N@OJDGCNOD@?$HMC?3isoformat?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_isoformat DD imagerel datetime_isoformat
	DD	imagerel datetime_isoformat+606
	DD	imagerel $unwind$datetime_isoformat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_isoformat DD 021601H
	DD	01d0116H
xdata	ENDS
;	COMDAT ??_C@_0BP@MFKBOFBI@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?$AA@
CONST	SEGMENT
??_C@_0BP@MFKBOFBI@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?$AA@ DB '%'
	DB	'04d-%02d-%02d%c%02d:%02d:%02d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@DKNNHCAH@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?4?$CF@
CONST	SEGMENT
??_C@_0CE@DKNNHCAH@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?4?$CF@ DB '%'
	DB	'04d-%02d-%02d%c%02d:%02d:%02d.%06d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OJDGCNOD@?$HMC?3isoformat?$AA@
CONST	SEGMENT
??_C@_0N@OJDGCNOD@?$HMC?3isoformat?$AA@ DB '|C:isoformat', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_isoformat
_TEXT	SEGMENT
sep$ = 80
us$ = 84
result$ = 88
buffer$ = 96
tv138 = 208
tv170 = 212
self$ = 240
args$ = 248
kw$ = 256
datetime_isoformat PROC					; COMDAT

; 4492 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 4493 :     int sep = 'T';

  00016	c7 44 24 50 54
	00 00 00	 mov	 DWORD PTR sep$[rsp], 84	; 00000054H

; 4494 :     static char *keywords[] = {"sep", NULL};
; 4495 :     char buffer[100];
; 4496 :     PyObject *result;
; 4497 :     int us = DATE_GET_MICROSECOND(self);

  0001e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00026	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  0002a	c1 e0 10	 shl	 eax, 16
  0002d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00035	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  00039	c1 e1 08	 shl	 ecx, 8
  0003c	0b c1		 or	 eax, ecx
  0003e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00046	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  0004a	0b c1		 or	 eax, ecx
  0004c	89 44 24 54	 mov	 DWORD PTR us$[rsp], eax

; 4498 : 
; 4499 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "|C:isoformat", keywords, &sep))

  00050	48 8d 44 24 50	 lea	 rax, QWORD PTR sep$[rsp]
  00055	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??datetime_isoformat@@9@9
  00061	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@OJDGCNOD@?$HMC?3isoformat?$AA@
  00068	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  00070	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00078	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0007d	85 c0		 test	 eax, eax
  0007f	75 07		 jne	 SHORT $LN6@datetime_i

; 4500 :         return NULL;

  00081	33 c0		 xor	 eax, eax
  00083	e9 ce 01 00 00	 jmp	 $LN7@datetime_i
$LN6@datetime_i:

; 4501 :     if (us)

  00088	83 7c 24 54 00	 cmp	 DWORD PTR us$[rsp], 0
  0008d	0f 84 ab 00 00
	00		 je	 $LN5@datetime_i

; 4502 :         result = PyUnicode_FromFormat("%04d-%02d-%02d%c%02d:%02d:%02d.%06d",
; 4503 :                                       GET_YEAR(self), GET_MONTH(self),
; 4504 :                                       GET_DAY(self), (int)sep,
; 4505 :                                       DATE_GET_HOUR(self), DATE_GET_MINUTE(self),
; 4506 :                                       DATE_GET_SECOND(self), us);

  00093	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0009b	0f b6 40 6f	 movzx	 eax, BYTE PTR [rax+111]
  0009f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000a7	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  000ab	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  000b3	0f b6 52 6d	 movzx	 edx, BYTE PTR [rdx+109]
  000b7	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR self$[rsp]
  000bf	45 0f b6 40 6c	 movzx	 r8d, BYTE PTR [r8+108]
  000c4	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR self$[rsp]
  000cc	45 0f b6 49 6b	 movzx	 r9d, BYTE PTR [r9+107]
  000d1	44 89 8c 24 d0
	00 00 00	 mov	 DWORD PTR tv138[rsp], r9d
  000d9	4c 8b 94 24 f0
	00 00 00	 mov	 r10, QWORD PTR self$[rsp]
  000e1	45 0f b6 52 69	 movzx	 r10d, BYTE PTR [r10+105]
  000e6	41 c1 e2 08	 shl	 r10d, 8
  000ea	4c 8b 9c 24 f0
	00 00 00	 mov	 r11, QWORD PTR self$[rsp]
  000f2	45 0f b6 5b 6a	 movzx	 r11d, BYTE PTR [r11+106]
  000f7	45 0b d3	 or	 r10d, r11d
  000fa	44 8b 5c 24 54	 mov	 r11d, DWORD PTR us$[rsp]
  000ff	44 89 5c 24 40	 mov	 DWORD PTR [rsp+64], r11d
  00104	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00108	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0010c	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00110	8b 44 24 50	 mov	 eax, DWORD PTR sep$[rsp]
  00114	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00118	45 8b c8	 mov	 r9d, r8d
  0011b	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv138[rsp]
  00122	44 8b c0	 mov	 r8d, eax
  00125	41 8b d2	 mov	 edx, r10d
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@DKNNHCAH@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?4?$CF@
  0012f	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00134	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 4507 :     else

  00139	e9 9c 00 00 00	 jmp	 $LN4@datetime_i
$LN5@datetime_i:

; 4508 :         result = PyUnicode_FromFormat("%04d-%02d-%02d%c%02d:%02d:%02d",
; 4509 :                                       GET_YEAR(self), GET_MONTH(self),
; 4510 :                                       GET_DAY(self), (int)sep,
; 4511 :                                       DATE_GET_HOUR(self), DATE_GET_MINUTE(self),
; 4512 :                                       DATE_GET_SECOND(self));

  0013e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00146	0f b6 40 6f	 movzx	 eax, BYTE PTR [rax+111]
  0014a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00152	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  00156	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  0015e	0f b6 52 6d	 movzx	 edx, BYTE PTR [rdx+109]
  00162	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR self$[rsp]
  0016a	45 0f b6 40 6c	 movzx	 r8d, BYTE PTR [r8+108]
  0016f	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR self$[rsp]
  00177	45 0f b6 49 6b	 movzx	 r9d, BYTE PTR [r9+107]
  0017c	44 89 8c 24 d4
	00 00 00	 mov	 DWORD PTR tv170[rsp], r9d
  00184	4c 8b 94 24 f0
	00 00 00	 mov	 r10, QWORD PTR self$[rsp]
  0018c	45 0f b6 52 69	 movzx	 r10d, BYTE PTR [r10+105]
  00191	41 c1 e2 08	 shl	 r10d, 8
  00195	4c 8b 9c 24 f0
	00 00 00	 mov	 r11, QWORD PTR self$[rsp]
  0019d	45 0f b6 5b 6a	 movzx	 r11d, BYTE PTR [r11+106]
  001a2	45 0b d3	 or	 r10d, r11d
  001a5	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  001a9	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  001ad	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  001b1	8b 44 24 50	 mov	 eax, DWORD PTR sep$[rsp]
  001b5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001b9	45 8b c8	 mov	 r9d, r8d
  001bc	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv170[rsp]
  001c3	44 8b c0	 mov	 r8d, eax
  001c6	41 8b d2	 mov	 edx, r10d
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@MFKBOFBI@?$CF04d?9?$CF02d?9?$CF02d?$CFc?$CF02d?3?$CF02d?3?$CF02d?$AA@
  001d0	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  001d5	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax
$LN4@datetime_i:

; 4513 : 
; 4514 :     if (!result || !HASTZINFO(self))

  001da	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  001e0	74 10		 je	 SHORT $LN2@datetime_i
  001e2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001ea	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  001ee	85 c0		 test	 eax, eax
  001f0	75 07		 jne	 SHORT $LN3@datetime_i
$LN2@datetime_i:

; 4515 :         return result;

  001f2	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001f7	eb 5d		 jmp	 SHORT $LN7@datetime_i
$LN3@datetime_i:

; 4516 : 
; 4517 :     /* We need to append the UTC offset. */
; 4518 :     if (format_utcoffset(buffer, sizeof(buffer), ":", self->tzinfo,
; 4519 :                          (PyObject *)self) < 0) {

  001f9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00201	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00206	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0020e	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  00212	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  00219	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0021e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buffer$[rsp]
  00223	e8 00 00 00 00	 call	 format_utcoffset
  00228	85 c0		 test	 eax, eax
  0022a	7d 0e		 jge	 SHORT $LN1@datetime_i

; 4520 :         Py_DECREF(result);

  0022c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  00231	e8 00 00 00 00	 call	 _Py_DecRef

; 4521 :         return NULL;

  00236	33 c0		 xor	 eax, eax
  00238	eb 1c		 jmp	 SHORT $LN7@datetime_i
$LN1@datetime_i:

; 4522 :     }
; 4523 :     PyUnicode_AppendAndDel(&result, PyUnicode_FromString(buffer));

  0023a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buffer$[rsp]
  0023f	e8 00 00 00 00	 call	 PyUnicode_FromString
  00244	48 8b d0	 mov	 rdx, rax
  00247	48 8d 4c 24 58	 lea	 rcx, QWORD PTR result$[rsp]
  0024c	e8 00 00 00 00	 call	 PyUnicode_AppendAndDel

; 4524 :     return result;

  00251	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
$LN7@datetime_i:

; 4525 : }

  00256	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0025d	c3		 ret	 0
datetime_isoformat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_ctime DD imagerel datetime_ctime
	DD	imagerel datetime_ctime+57
	DD	imagerel $unwind$datetime_ctime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_ctime DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_ctime
_TEXT	SEGMENT
self$ = 48
datetime_ctime PROC					; COMDAT

; 4529 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4530 :     return format_ctime((PyDateTime_Date *)self,
; 4531 :                         DATE_GET_HOUR(self),
; 4532 :                         DATE_GET_MINUTE(self),
; 4533 :                         DATE_GET_SECOND(self));

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f b6 40 6f	 movzx	 eax, BYTE PTR [rax+111]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00017	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  0001b	48 8b 54 24 30	 mov	 rdx, QWORD PTR self$[rsp]
  00020	0f b6 52 6d	 movzx	 edx, BYTE PTR [rdx+109]
  00024	44 8b c8	 mov	 r9d, eax
  00027	44 8b c1	 mov	 r8d, ecx
  0002a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0002f	e8 00 00 00 00	 call	 format_ctime

; 4534 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
datetime_ctime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@LPDNADML@can?8t?5compare?5offset?9naive?5and?5o@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_richcompare DD imagerel datetime_richcompare
	DD	imagerel datetime_richcompare+940
	DD	imagerel $unwind$datetime_richcompare
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_richcompare DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0DG@LPDNADML@can?8t?5compare?5offset?9naive?5and?5o@
CONST	SEGMENT
??_C@_0DG@LPDNADML@can?8t?5compare?5offset?9naive?5and?5o@ DB 'can''t com'
	DB	'pare offset-naive and offset-aware datetimes', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_richcompare
_TEXT	SEGMENT
offset1$ = 32
offset2$ = 40
result$ = 48
diff$ = 56
delta$24384 = 64
tv90 = 72
tv95 = 80
self$ = 112
other$ = 120
op$ = 128
datetime_richcompare PROC				; COMDAT

; 4540 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4541 :     PyObject *result = NULL;

  00013	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 4542 :     PyObject *offset1, *offset2;
; 4543 :     int diff;
; 4544 : 
; 4545 :     if (! PyDateTime_Check(other)) {

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00023	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  00028	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002c	0f 84 b8 00 00
	00		 je	 $LN25@datetime_r@2
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateTimeType
  00039	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  0003e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00042	e8 00 00 00 00	 call	 PyType_IsSubtype
  00047	85 c0		 test	 eax, eax
  00049	0f 85 9b 00 00
	00		 jne	 $LN25@datetime_r@2

; 4546 :         if (PyDate_Check(other)) {

  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateType
  00056	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  0005b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0005f	74 19		 je	 SHORT $LN23@datetime_r@2
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DateType
  00068	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  0006d	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00071	e8 00 00 00 00	 call	 PyType_IsSubtype
  00076	85 c0		 test	 eax, eax
  00078	74 58		 je	 SHORT $LN24@datetime_r@2
$LN23@datetime_r@2:

; 4547 :             /* Prevent invocation of date_richcompare.  We want to
; 4548 :                return NotImplemented here to give the other object
; 4549 :                a chance.  But since DateTime is a subclass of
; 4550 :                Date, if the other object is a Date, it would
; 4551 :                compute an ordering based on the date part alone,
; 4552 :                and we don't want that.  So force unequal or
; 4553 :                uncomparable here in that case. */
; 4554 :             if (op == Py_EQ)

  0007a	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  00082	75 18		 jne	 SHORT $LN22@datetime_r@2

; 4555 :                 Py_RETURN_FALSE;

  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  0008b	e8 00 00 00 00	 call	 _Py_IncRef
  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00097	e9 0b 03 00 00	 jmp	 $LN26@datetime_r@2
$LN22@datetime_r@2:

; 4556 :             if (op == Py_NE)

  0009c	83 bc 24 80 00
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  000a4	75 18		 jne	 SHORT $LN21@datetime_r@2

; 4557 :                 Py_RETURN_TRUE;

  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000ad	e8 00 00 00 00	 call	 _Py_IncRef
  000b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000b9	e9 e9 02 00 00	 jmp	 $LN26@datetime_r@2
$LN21@datetime_r@2:

; 4558 :             return cmperror(self, other);

  000be	48 8b 54 24 78	 mov	 rdx, QWORD PTR other$[rsp]
  000c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000c8	e8 00 00 00 00	 call	 cmperror
  000cd	e9 d5 02 00 00	 jmp	 $LN26@datetime_r@2
$LN24@datetime_r@2:

; 4559 :         }
; 4560 :         Py_RETURN_NOTIMPLEMENTED;

  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  000d9	e8 00 00 00 00	 call	 _Py_IncRef
  000de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000e5	e9 bd 02 00 00	 jmp	 $LN26@datetime_r@2
$LN25@datetime_r@2:

; 4561 :     }
; 4562 : 
; 4563 :     if (GET_DT_TZINFO(self) == GET_DT_TZINFO(other)) {

  000ea	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000ef	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  000f3	85 c0		 test	 eax, eax
  000f5	74 10		 je	 SHORT $LN28@datetime_r@2
  000f7	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000fc	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00100	48 89 44 24 48	 mov	 QWORD PTR tv90[rsp], rax
  00105	eb 0c		 jmp	 SHORT $LN29@datetime_r@2
$LN28@datetime_r@2:
  00107	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0010e	48 89 44 24 48	 mov	 QWORD PTR tv90[rsp], rax
$LN29@datetime_r@2:
  00113	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  00118	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  0011c	85 c0		 test	 eax, eax
  0011e	74 10		 je	 SHORT $LN30@datetime_r@2
  00120	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  00125	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00129	48 89 44 24 50	 mov	 QWORD PTR tv95[rsp], rax
  0012e	eb 0c		 jmp	 SHORT $LN31@datetime_r@2
$LN30@datetime_r@2:
  00130	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00137	48 89 44 24 50	 mov	 QWORD PTR tv95[rsp], rax
$LN31@datetime_r@2:
  0013c	48 8b 44 24 50	 mov	 rax, QWORD PTR tv95[rsp]
  00141	48 39 44 24 48	 cmp	 QWORD PTR tv90[rsp], rax
  00146	75 39		 jne	 SHORT $LN20@datetime_r@2

; 4564 :         diff = memcmp(((PyDateTime_DateTime *)self)->data,
; 4565 :                       ((PyDateTime_DateTime *)other)->data,
; 4566 :                       _PyDateTime_DATETIME_DATASIZE);

  00148	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  0014d	48 83 c0 69	 add	 rax, 105		; 00000069H
  00151	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00156	48 83 c1 69	 add	 rcx, 105		; 00000069H
  0015a	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00160	48 8b d0	 mov	 rdx, rax
  00163	e8 00 00 00 00	 call	 memcmp
  00168	89 44 24 38	 mov	 DWORD PTR diff$[rsp], eax

; 4567 :         return diff_to_bool(diff, op);

  0016c	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR op$[rsp]
  00173	8b 4c 24 38	 mov	 ecx, DWORD PTR diff$[rsp]
  00177	e8 00 00 00 00	 call	 diff_to_bool
  0017c	e9 26 02 00 00	 jmp	 $LN26@datetime_r@2
$LN20@datetime_r@2:

; 4568 :     }
; 4569 :     offset1 = datetime_utcoffset(self, NULL);

  00181	33 d2		 xor	 edx, edx
  00183	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00188	e8 00 00 00 00	 call	 datetime_utcoffset
  0018d	48 89 44 24 20	 mov	 QWORD PTR offset1$[rsp], rax

; 4570 :     if (offset1 == NULL)

  00192	48 83 7c 24 20
	00		 cmp	 QWORD PTR offset1$[rsp], 0
  00198	75 07		 jne	 SHORT $LN19@datetime_r@2

; 4571 :         return NULL;

  0019a	33 c0		 xor	 eax, eax
  0019c	e9 06 02 00 00	 jmp	 $LN26@datetime_r@2
$LN19@datetime_r@2:

; 4572 :     offset2 = datetime_utcoffset(other, NULL);

  001a1	33 d2		 xor	 edx, edx
  001a3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR other$[rsp]
  001a8	e8 00 00 00 00	 call	 datetime_utcoffset
  001ad	48 89 44 24 28	 mov	 QWORD PTR offset2$[rsp], rax

; 4573 :     if (offset2 == NULL)

  001b2	48 83 7c 24 28
	00		 cmp	 QWORD PTR offset2$[rsp], 0
  001b8	75 05		 jne	 SHORT $LN18@datetime_r@2

; 4574 :         goto done;

  001ba	e9 c1 01 00 00	 jmp	 $done$24371
$LN18@datetime_r@2:

; 4575 :     /* If they're both naive, or both aware and have the same offsets,
; 4576 :      * we get off cheap.  Note that if they're both naive, offset1 ==
; 4577 :      * offset2 == Py_None at this point.
; 4578 :      */
; 4579 :     if ((offset1 == offset2) ||
; 4580 :         (PyDelta_Check(offset1) && PyDelta_Check(offset2) &&
; 4581 :          delta_cmp(offset1, offset2) == 0)) {

  001bf	48 8b 44 24 28	 mov	 rax, QWORD PTR offset2$[rsp]
  001c4	48 39 44 24 20	 cmp	 QWORD PTR offset1$[rsp], rax
  001c9	74 69		 je	 SHORT $LN16@datetime_r@2
  001cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  001d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset1$[rsp]
  001d7	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001db	74 19		 je	 SHORT $LN15@datetime_r@2
  001dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  001e4	48 8b 44 24 20	 mov	 rax, QWORD PTR offset1$[rsp]
  001e9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001ed	e8 00 00 00 00	 call	 PyType_IsSubtype
  001f2	85 c0		 test	 eax, eax
  001f4	74 7c		 je	 SHORT $LN17@datetime_r@2
$LN15@datetime_r@2:
  001f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  001fd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset2$[rsp]
  00202	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00206	74 19		 je	 SHORT $LN14@datetime_r@2
  00208	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyDateTime_DeltaType
  0020f	48 8b 44 24 28	 mov	 rax, QWORD PTR offset2$[rsp]
  00214	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00218	e8 00 00 00 00	 call	 PyType_IsSubtype
  0021d	85 c0		 test	 eax, eax
  0021f	74 51		 je	 SHORT $LN17@datetime_r@2
$LN14@datetime_r@2:
  00221	48 8b 54 24 28	 mov	 rdx, QWORD PTR offset2$[rsp]
  00226	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset1$[rsp]
  0022b	e8 00 00 00 00	 call	 delta_cmp
  00230	85 c0		 test	 eax, eax
  00232	75 3e		 jne	 SHORT $LN17@datetime_r@2
$LN16@datetime_r@2:

; 4582 :         diff = memcmp(((PyDateTime_DateTime *)self)->data,
; 4583 :                       ((PyDateTime_DateTime *)other)->data,
; 4584 :                       _PyDateTime_DATETIME_DATASIZE);

  00234	48 8b 44 24 78	 mov	 rax, QWORD PTR other$[rsp]
  00239	48 83 c0 69	 add	 rax, 105		; 00000069H
  0023d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00242	48 83 c1 69	 add	 rcx, 105		; 00000069H
  00246	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0024c	48 8b d0	 mov	 rdx, rax
  0024f	e8 00 00 00 00	 call	 memcmp
  00254	89 44 24 38	 mov	 DWORD PTR diff$[rsp], eax

; 4585 :         result = diff_to_bool(diff, op);

  00258	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR op$[rsp]
  0025f	8b 4c 24 38	 mov	 ecx, DWORD PTR diff$[rsp]
  00263	e8 00 00 00 00	 call	 diff_to_bool
  00268	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
  0026d	e9 0e 01 00 00	 jmp	 $LN13@datetime_r@2
$LN17@datetime_r@2:

; 4586 :     }
; 4587 :     else if (offset1 != Py_None && offset2 != Py_None) {

  00272	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00279	48 39 44 24 20	 cmp	 QWORD PTR offset1$[rsp], rax
  0027e	0f 84 a5 00 00
	00		 je	 $LN12@datetime_r@2
  00284	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0028b	48 39 44 24 28	 cmp	 QWORD PTR offset2$[rsp], rax
  00290	0f 84 93 00 00
	00		 je	 $LN12@datetime_r@2

; 4588 :         PyDateTime_Delta *delta;
; 4589 : 
; 4590 :         assert(offset1 != offset2); /* else last "if" handled it */

  00296	48 8b 44 24 28	 mov	 rax, QWORD PTR offset2$[rsp]
  0029b	48 39 44 24 20	 cmp	 QWORD PTR offset1$[rsp], rax
  002a0	75 1c		 jne	 SHORT $LN32@datetime_r@2
  002a2	41 b8 ee 11 00
	00		 mov	 r8d, 4590		; 000011eeH
  002a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@DINEGPHF@?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA1?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA2?$AA?$AA@
  002b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002bc	33 c0		 xor	 eax, eax
$LN32@datetime_r@2:

; 4591 :         delta = (PyDateTime_Delta *)datetime_subtract((PyObject *)self,
; 4592 :                                                        other);

  002be	48 8b 54 24 78	 mov	 rdx, QWORD PTR other$[rsp]
  002c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  002c8	e8 00 00 00 00	 call	 datetime_subtract
  002cd	48 89 44 24 40	 mov	 QWORD PTR delta$24384[rsp], rax

; 4593 :         if (delta == NULL)

  002d2	48 83 7c 24 40
	00		 cmp	 QWORD PTR delta$24384[rsp], 0
  002d8	75 05		 jne	 SHORT $LN11@datetime_r@2

; 4594 :             goto done;

  002da	e9 a1 00 00 00	 jmp	 $done$24371
$LN11@datetime_r@2:

; 4595 :         diff = GET_TD_DAYS(delta);

  002df	48 8b 44 24 40	 mov	 rax, QWORD PTR delta$24384[rsp]
  002e4	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  002e7	89 44 24 38	 mov	 DWORD PTR diff$[rsp], eax

; 4596 :         if (diff == 0)

  002eb	83 7c 24 38 00	 cmp	 DWORD PTR diff$[rsp], 0
  002f0	75 16		 jne	 SHORT $LN10@datetime_r@2

; 4597 :             diff = GET_TD_SECONDS(delta) |
; 4598 :                    GET_TD_MICROSECONDS(delta);

  002f2	48 8b 44 24 40	 mov	 rax, QWORD PTR delta$24384[rsp]
  002f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delta$24384[rsp]
  002fc	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  002ff	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  00302	0b c1		 or	 eax, ecx
  00304	89 44 24 38	 mov	 DWORD PTR diff$[rsp], eax
$LN10@datetime_r@2:

; 4599 :         Py_DECREF(delta);

  00308	48 8b 4c 24 40	 mov	 rcx, QWORD PTR delta$24384[rsp]
  0030d	e8 00 00 00 00	 call	 _Py_DecRef

; 4600 :         result = diff_to_bool(diff, op);

  00312	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR op$[rsp]
  00319	8b 4c 24 38	 mov	 ecx, DWORD PTR diff$[rsp]
  0031d	e8 00 00 00 00	 call	 diff_to_bool
  00322	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
  00327	eb 57		 jmp	 SHORT $LN9@datetime_r@2
$LN12@datetime_r@2:

; 4601 :     }
; 4602 :     else if (op == Py_EQ) {

  00329	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR op$[rsp], 2
  00331	75 18		 jne	 SHORT $LN8@datetime_r@2

; 4603 :         result = Py_False;

  00333	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0033a	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 4604 :         Py_INCREF(result);

  0033f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00344	e8 00 00 00 00	 call	 _Py_IncRef
  00349	eb 35		 jmp	 SHORT $LN7@datetime_r@2
$LN8@datetime_r@2:

; 4605 :     }
; 4606 :     else if (op == Py_NE) {

  0034b	83 bc 24 80 00
	00 00 03	 cmp	 DWORD PTR op$[rsp], 3
  00353	75 18		 jne	 SHORT $LN6@datetime_r@2

; 4607 :         result = Py_True;

  00355	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  0035c	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 4608 :         Py_INCREF(result);

  00361	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00366	e8 00 00 00 00	 call	 _Py_IncRef

; 4609 :     }
; 4610 :     else {

  0036b	eb 13		 jmp	 SHORT $LN5@datetime_r@2
$LN6@datetime_r@2:

; 4611 :         PyErr_SetString(PyExc_TypeError,
; 4612 :                         "can't compare offset-naive and "
; 4613 :                         "offset-aware datetimes");

  0036d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@LPDNADML@can?8t?5compare?5offset?9naive?5and?5o@
  00374	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0037b	e8 00 00 00 00	 call	 PyErr_SetString
$LN5@datetime_r@2:
$LN7@datetime_r@2:
$LN9@datetime_r@2:
$LN13@datetime_r@2:
$done$24371:

; 4614 :     }
; 4615 :  done:
; 4616 :     Py_DECREF(offset1);

  00380	48 8b 4c 24 20	 mov	 rcx, QWORD PTR offset1$[rsp]
  00385	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@datetime_r@2:

; 4617 :     Py_XDECREF(offset2);

  0038a	48 83 7c 24 28
	00		 cmp	 QWORD PTR offset2$[rsp], 0
  00390	74 0a		 je	 SHORT $LN1@datetime_r@2
  00392	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset2$[rsp]
  00397	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@datetime_r@2:
  0039c	33 c0		 xor	 eax, eax
  0039e	85 c0		 test	 eax, eax
  003a0	75 e8		 jne	 SHORT $LN4@datetime_r@2

; 4618 :     return result;

  003a2	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN26@datetime_r@2:

; 4619 : }

  003a7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003ab	c3		 ret	 0
datetime_richcompare ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@KMOACFMA@can?8t?5compare?5?$CFs?5to?5?$CFs?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmperror DD imagerel cmperror
	DD	imagerel cmperror+66
	DD	imagerel $unwind$cmperror
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmperror DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0BH@KMOACFMA@can?8t?5compare?5?$CFs?5to?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BH@KMOACFMA@can?8t?5compare?5?$CFs?5to?5?$CFs?$AA@ DB 'can''t comp'
	DB	'are %s to %s', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cmperror
_TEXT	SEGMENT
a$ = 48
b$ = 56
cmperror PROC						; COMDAT

; 1388 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1389 :     PyErr_Format(PyExc_TypeError,
; 1390 :                  "can't compare %s to %s",
; 1391 :                  Py_TYPE(a)->tp_name, Py_TYPE(b)->tp_name);

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  0001c	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00020	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00024	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@KMOACFMA@can?8t?5compare?5?$CFs?5to?5?$CFs?$AA@
  0002f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00036	e8 00 00 00 00	 call	 PyErr_Format

; 1392 :     return NULL;

  0003b	33 c0		 xor	 eax, eax

; 1393 : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
cmperror ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_hash DD imagerel datetime_hash
	DD	imagerel datetime_hash+477
	DD	imagerel $unwind$datetime_hash
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_hash DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_hash
_TEXT	SEGMENT
offset$24416 = 48
days$24426 = 56
temp1$24424 = 64
seconds$24427 = 72
temp2$24425 = 80
tv131 = 88
self$ = 112
datetime_hash PROC					; COMDAT

; 4623 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4624 :     if (self->hashcode == -1) {

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 60 ff	 cmp	 QWORD PTR [rax+96], -1
  00013	0f 85 b6 01 00
	00		 jne	 $LN6@datetime_h

; 4625 :         PyObject *offset;
; 4626 : 
; 4627 :         offset = datetime_utcoffset((PyObject *)self, NULL);

  00019	33 d2		 xor	 edx, edx
  0001b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00020	e8 00 00 00 00	 call	 datetime_utcoffset
  00025	48 89 44 24 30	 mov	 QWORD PTR offset$24416[rsp], rax

; 4628 : 
; 4629 :         if (offset == NULL)

  0002a	48 83 7c 24 30
	00		 cmp	 QWORD PTR offset$24416[rsp], 0
  00030	75 0c		 jne	 SHORT $LN5@datetime_h

; 4630 :             return -1;

  00032	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00039	e9 9a 01 00 00	 jmp	 $LN7@datetime_h
$LN5@datetime_h:

; 4631 : 
; 4632 :         /* Reduce this to a hash of another object. */
; 4633 :         if (offset == Py_None)

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00045	48 39 44 24 30	 cmp	 QWORD PTR offset$24416[rsp], rax
  0004a	75 24		 jne	 SHORT $LN4@datetime_h

; 4634 :             self->hashcode = generic_hash(
; 4635 :                 (unsigned char *)self->data, _PyDateTime_DATETIME_DATASIZE);

  0004c	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00051	48 83 c0 69	 add	 rax, 105		; 00000069H
  00055	ba 0a 00 00 00	 mov	 edx, 10
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	e8 00 00 00 00	 call	 generic_hash
  00062	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00067	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 4636 :         else {

  0006b	e9 55 01 00 00	 jmp	 $LN3@datetime_h
$LN4@datetime_h:

; 4637 :             PyObject *temp1, *temp2;
; 4638 :             int days, seconds;
; 4639 : 
; 4640 :             assert(HASTZINFO(self));

  00070	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00075	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00079	85 c0		 test	 eax, eax
  0007b	75 1c		 jne	 SHORT $LN9@datetime_h
  0007d	41 b8 20 12 00
	00		 mov	 r8d, 4640		; 00001220H
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@HEPCOKGC@?$AAH?$AAA?$AAS?$AAT?$AAZ?$AAI?$AAN?$AAF?$AAO?$AA?$CI?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00097	33 c0		 xor	 eax, eax
$LN9@datetime_h:

; 4641 :             days = ymd_to_ord(GET_YEAR(self),
; 4642 :                               GET_MONTH(self),
; 4643 :                               GET_DAY(self));

  00099	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0009e	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  000a2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000a7	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  000ab	48 8b 54 24 70	 mov	 rdx, QWORD PTR self$[rsp]
  000b0	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  000b4	c1 e2 08	 shl	 edx, 8
  000b7	4c 8b 44 24 70	 mov	 r8, QWORD PTR self$[rsp]
  000bc	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  000c1	41 0b d0	 or	 edx, r8d
  000c4	89 54 24 58	 mov	 DWORD PTR tv131[rsp], edx
  000c8	44 8b c0	 mov	 r8d, eax
  000cb	8b d1		 mov	 edx, ecx
  000cd	8b 44 24 58	 mov	 eax, DWORD PTR tv131[rsp]
  000d1	8b c8		 mov	 ecx, eax
  000d3	e8 00 00 00 00	 call	 ymd_to_ord
  000d8	89 44 24 38	 mov	 DWORD PTR days$24426[rsp], eax

; 4644 :             seconds = DATE_GET_HOUR(self) * 3600 +
; 4645 :                       DATE_GET_MINUTE(self) * 60 +
; 4646 :                       DATE_GET_SECOND(self);

  000dc	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000e1	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  000e5	69 c0 10 0e 00
	00		 imul	 eax, 3600		; 00000e10H
  000eb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000f0	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  000f4	6b c9 3c	 imul	 ecx, 60			; 0000003cH
  000f7	03 c1		 add	 eax, ecx
  000f9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  000fe	0f b6 49 6f	 movzx	 ecx, BYTE PTR [rcx+111]
  00102	03 c1		 add	 eax, ecx
  00104	89 44 24 48	 mov	 DWORD PTR seconds$24427[rsp], eax

; 4647 :             temp1 = new_delta(days, seconds,
; 4648 :                               DATE_GET_MICROSECOND(self),
; 4649 :                               1);

  00108	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0010d	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  00111	c1 e0 10	 shl	 eax, 16
  00114	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00119	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  0011d	c1 e1 08	 shl	 ecx, 8
  00120	0b c1		 or	 eax, ecx
  00122	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00127	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  0012b	0b c1		 or	 eax, ecx
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DeltaType
  00134	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00139	41 b9 01 00 00
	00		 mov	 r9d, 1
  0013f	44 8b c0	 mov	 r8d, eax
  00142	8b 54 24 48	 mov	 edx, DWORD PTR seconds$24427[rsp]
  00146	8b 4c 24 38	 mov	 ecx, DWORD PTR days$24426[rsp]
  0014a	e8 00 00 00 00	 call	 new_delta_ex
  0014f	48 89 44 24 40	 mov	 QWORD PTR temp1$24424[rsp], rax

; 4650 :             if (temp1 == NULL) {

  00154	48 83 7c 24 40
	00		 cmp	 QWORD PTR temp1$24424[rsp], 0
  0015a	75 13		 jne	 SHORT $LN2@datetime_h

; 4651 :                 Py_DECREF(offset);

  0015c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR offset$24416[rsp]
  00161	e8 00 00 00 00	 call	 _Py_DecRef

; 4652 :                 return -1;

  00166	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0016d	eb 69		 jmp	 SHORT $LN7@datetime_h
$LN2@datetime_h:

; 4653 :             }
; 4654 :             temp2 = delta_subtract(temp1, offset);

  0016f	48 8b 54 24 30	 mov	 rdx, QWORD PTR offset$24416[rsp]
  00174	48 8b 4c 24 40	 mov	 rcx, QWORD PTR temp1$24424[rsp]
  00179	e8 00 00 00 00	 call	 delta_subtract
  0017e	48 89 44 24 50	 mov	 QWORD PTR temp2$24425[rsp], rax

; 4655 :             Py_DECREF(temp1);

  00183	48 8b 4c 24 40	 mov	 rcx, QWORD PTR temp1$24424[rsp]
  00188	e8 00 00 00 00	 call	 _Py_DecRef

; 4656 :             if (temp2 == NULL) {

  0018d	48 83 7c 24 50
	00		 cmp	 QWORD PTR temp2$24425[rsp], 0
  00193	75 13		 jne	 SHORT $LN1@datetime_h

; 4657 :                 Py_DECREF(offset);

  00195	48 8b 4c 24 30	 mov	 rcx, QWORD PTR offset$24416[rsp]
  0019a	e8 00 00 00 00	 call	 _Py_DecRef

; 4658 :                 return -1;

  0019f	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  001a6	eb 30		 jmp	 SHORT $LN7@datetime_h
$LN1@datetime_h:

; 4659 :             }
; 4660 :             self->hashcode = PyObject_Hash(temp2);

  001a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR temp2$24425[rsp]
  001ad	e8 00 00 00 00	 call	 PyObject_Hash
  001b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  001b7	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 4661 :             Py_DECREF(temp2);

  001bb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR temp2$24425[rsp]
  001c0	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@datetime_h:

; 4662 :         }
; 4663 :         Py_DECREF(offset);

  001c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR offset$24416[rsp]
  001ca	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@datetime_h:

; 4664 :     }
; 4665 :     return self->hashcode;

  001cf	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  001d4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
$LN7@datetime_h:

; 4666 : }

  001d8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001dc	c3		 ret	 0
datetime_hash ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@NPOLIPLD@?$HMiiiiiiiO?3replace?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_replace DD imagerel datetime_replace
	DD	imagerel datetime_replace+548
	DD	imagerel $unwind$datetime_replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_replace DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT ??_C@_0BC@NPOLIPLD@?$HMiiiiiiiO?3replace?$AA@
CONST	SEGMENT
??_C@_0BC@NPOLIPLD@?$HMiiiiiiiO?3replace?$AA@ DB '|iiiiiiiO:replace', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_replace
_TEXT	SEGMENT
y$ = 96
mm$ = 100
tzinfo$ = 104
tuple$ = 112
hh$ = 120
us$ = 124
d$ = 128
clone$ = 136
ss$ = 144
m$ = 148
tv136 = 152
self$ = 176
args$ = 184
kw$ = 192
datetime_replace PROC					; COMDAT

; 4670 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 4671 :     PyObject *clone;
; 4672 :     PyObject *tuple;
; 4673 :     int y = GET_YEAR(self);

  00016	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001e	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00022	c1 e0 08	 shl	 eax, 8
  00025	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  0002d	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00031	0b c1		 or	 eax, ecx
  00033	89 44 24 60	 mov	 DWORD PTR y$[rsp], eax

; 4674 :     int m = GET_MONTH(self);

  00037	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0003f	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  00043	89 84 24 94 00
	00 00		 mov	 DWORD PTR m$[rsp], eax

; 4675 :     int d = GET_DAY(self);

  0004a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00052	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00056	89 84 24 80 00
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 4676 :     int hh = DATE_GET_HOUR(self);

  0005d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00065	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  00069	89 44 24 78	 mov	 DWORD PTR hh$[rsp], eax

; 4677 :     int mm = DATE_GET_MINUTE(self);

  0006d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00075	0f b6 40 6e	 movzx	 eax, BYTE PTR [rax+110]
  00079	89 44 24 64	 mov	 DWORD PTR mm$[rsp], eax

; 4678 :     int ss = DATE_GET_SECOND(self);

  0007d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00085	0f b6 40 6f	 movzx	 eax, BYTE PTR [rax+111]
  00089	89 84 24 90 00
	00 00		 mov	 DWORD PTR ss$[rsp], eax

; 4679 :     int us = DATE_GET_MICROSECOND(self);

  00090	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00098	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  0009c	c1 e0 10	 shl	 eax, 16
  0009f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000a7	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  000ab	c1 e1 08	 shl	 ecx, 8
  000ae	0b c1		 or	 eax, ecx
  000b0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000b8	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  000bc	0b c1		 or	 eax, ecx
  000be	89 44 24 7c	 mov	 DWORD PTR us$[rsp], eax

; 4680 :     PyObject *tzinfo = HASTZINFO(self) ? self->tzinfo : Py_None;

  000c2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000ca	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  000ce	85 c0		 test	 eax, eax
  000d0	74 16		 je	 SHORT $LN5@datetime_r@3
  000d2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000da	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000de	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv136[rsp], rax
  000e6	eb 0f		 jmp	 SHORT $LN6@datetime_r@3
$LN5@datetime_r@3:
  000e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ef	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv136[rsp], rax
$LN6@datetime_r@3:
  000f7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv136[rsp]
  000ff	48 89 44 24 68	 mov	 QWORD PTR tzinfo$[rsp], rax

; 4681 : 
; 4682 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "|iiiiiiiO:replace",
; 4683 :                                       datetime_kws,
; 4684 :                                       &y, &m, &d, &hh, &mm, &ss, &us,
; 4685 :                                       &tzinfo))

  00104	48 8d 44 24 68	 lea	 rax, QWORD PTR tzinfo$[rsp]
  00109	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0010e	48 8d 44 24 7c	 lea	 rax, QWORD PTR us$[rsp]
  00113	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00118	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR ss$[rsp]
  00120	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00125	48 8d 44 24 64	 lea	 rax, QWORD PTR mm$[rsp]
  0012a	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0012f	48 8d 44 24 78	 lea	 rax, QWORD PTR hh$[rsp]
  00134	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00139	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR d$[rsp]
  00141	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00146	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR m$[rsp]
  0014e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00153	48 8d 44 24 60	 lea	 rax, QWORD PTR y$[rsp]
  00158	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:datetime_kws
  00164	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BC@NPOLIPLD@?$HMiiiiiiiO?3replace?$AA@
  0016b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR kw$[rsp]
  00173	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0017b	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00180	85 c0		 test	 eax, eax
  00182	75 07		 jne	 SHORT $LN2@datetime_r@3

; 4686 :         return NULL;

  00184	33 c0		 xor	 eax, eax
  00186	e9 91 00 00 00	 jmp	 $LN3@datetime_r@3
$LN2@datetime_r@3:

; 4687 :     tuple = Py_BuildValue("iiiiiiiO", y, m, d, hh, mm, ss, us, tzinfo);

  0018b	48 8b 44 24 68	 mov	 rax, QWORD PTR tzinfo$[rsp]
  00190	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00195	8b 44 24 7c	 mov	 eax, DWORD PTR us$[rsp]
  00199	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0019d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR ss$[rsp]
  001a4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001a8	8b 44 24 64	 mov	 eax, DWORD PTR mm$[rsp]
  001ac	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001b0	8b 44 24 78	 mov	 eax, DWORD PTR hh$[rsp]
  001b4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001b8	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR d$[rsp]
  001c0	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR m$[rsp]
  001c8	8b 54 24 60	 mov	 edx, DWORD PTR y$[rsp]
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08PFKMDOEK@iiiiiiiO?$AA@
  001d3	e8 00 00 00 00	 call	 Py_BuildValue
  001d8	48 89 44 24 70	 mov	 QWORD PTR tuple$[rsp], rax

; 4688 :     if (tuple == NULL)

  001dd	48 83 7c 24 70
	00		 cmp	 QWORD PTR tuple$[rsp], 0
  001e3	75 04		 jne	 SHORT $LN1@datetime_r@3

; 4689 :         return NULL;

  001e5	33 c0		 xor	 eax, eax
  001e7	eb 33		 jmp	 SHORT $LN3@datetime_r@3
$LN1@datetime_r@3:

; 4690 :     clone = datetime_new(Py_TYPE(self), tuple, NULL);

  001e9	45 33 c0	 xor	 r8d, r8d
  001ec	48 8b 54 24 70	 mov	 rdx, QWORD PTR tuple$[rsp]
  001f1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001f9	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001fd	e8 00 00 00 00	 call	 datetime_new
  00202	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR clone$[rsp], rax

; 4691 :     Py_DECREF(tuple);

  0020a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tuple$[rsp]
  0020f	e8 00 00 00 00	 call	 _Py_DecRef

; 4692 :     return clone;

  00214	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR clone$[rsp]
$LN3@datetime_r@3:

; 4693 : }

  0021c	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00223	c3		 ret	 0
datetime_replace ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@HOLPDAGJ@astimezone?$CI?$CJ?5cannot?5be?5applied?5t@ ; `string'
PUBLIC	??_C@_0O@FMEOLFLO@?$HMO?3astimezone?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_astimezone DD imagerel datetime_astimezone
	DD	imagerel datetime_astimezone+492
	DD	imagerel $unwind$datetime_astimezone
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_astimezone DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0DD@HOLPDAGJ@astimezone?$CI?$CJ?5cannot?5be?5applied?5t@
CONST	SEGMENT
??_C@_0DD@HOLPDAGJ@astimezone?$CI?$CJ?5cannot?5be?5applied?5t@ DB 'astime'
	DB	'zone() cannot be applied to a naive datetime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FMEOLFLO@?$HMO?3astimezone?$AA@
CONST	SEGMENT
??_C@_0O@FMEOLFLO@?$HMO?3astimezone?$AA@ DB '|O:astimezone', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_astimezone
_TEXT	SEGMENT
temp$ = 48
offset$ = 56
tzinfo$ = 64
result$ = 72
self$ = 96
args$ = 104
kw$ = 112
datetime_astimezone PROC				; COMDAT

; 4760 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4761 :     PyDateTime_DateTime *result;
; 4762 :     PyObject *offset;
; 4763 :     PyObject *temp;
; 4764 :     PyObject *tzinfo = Py_None;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001a	48 89 44 24 40	 mov	 QWORD PTR tzinfo$[rsp], rax

; 4765 :     _Py_IDENTIFIER(fromutc);
; 4766 :     static char *keywords[] = {"tz", NULL};
; 4767 : 
; 4768 :     if (! PyArg_ParseTupleAndKeywords(args, kw, "|O:astimezone", keywords,
; 4769 : 				      &tzinfo))

  0001f	48 8d 44 24 40	 lea	 rax, QWORD PTR tzinfo$[rsp]
  00024	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00029	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??datetime_astimezone@@9@9
  00030	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@FMEOLFLO@?$HMO?3astimezone?$AA@
  00037	48 8b 54 24 70	 mov	 rdx, QWORD PTR kw$[rsp]
  0003c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00041	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00046	85 c0		 test	 eax, eax
  00048	75 07		 jne	 SHORT $LN11@datetime_a@3

; 4770 :         return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	e9 96 01 00 00	 jmp	 $LN12@datetime_a@3
$LN11@datetime_a@3:

; 4771 : 
; 4772 :     if (check_tzinfo_subclass(tzinfo) == -1)

  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00056	e8 00 00 00 00	 call	 check_tzinfo_subclass
  0005b	83 f8 ff	 cmp	 eax, -1
  0005e	75 07		 jne	 SHORT $LN10@datetime_a@3

; 4773 :         return NULL;

  00060	33 c0		 xor	 eax, eax
  00062	e9 80 01 00 00	 jmp	 $LN12@datetime_a@3
$LN10@datetime_a@3:

; 4774 : 
; 4775 :     if (!HASTZINFO(self) || self->tzinfo == Py_None)

  00067	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0006c	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00070	85 c0		 test	 eax, eax
  00072	74 12		 je	 SHORT $LN8@datetime_a@3
  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0007b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00080	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  00084	75 02		 jne	 SHORT $LN9@datetime_a@3
$LN8@datetime_a@3:

; 4776 :         goto NeedAware;

  00086	eb 5c		 jmp	 SHORT $NeedAware$24560
$LN9@datetime_a@3:

; 4777 : 
; 4778 :     /* Conversion to self's own time zone is a NOP. */
; 4779 :     if (self->tzinfo == tzinfo) {

  00088	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0008d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00092	48 39 48 78	 cmp	 QWORD PTR [rax+120], rcx
  00096	75 14		 jne	 SHORT $LN7@datetime_a@3

; 4780 :         Py_INCREF(self);

  00098	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0009d	e8 00 00 00 00	 call	 _Py_IncRef

; 4781 :         return self;

  000a2	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000a7	e9 3b 01 00 00	 jmp	 $LN12@datetime_a@3
$LN7@datetime_a@3:

; 4782 :     }
; 4783 : 
; 4784 :     /* Convert self to UTC. */
; 4785 :     offset = datetime_utcoffset((PyObject *)self, NULL);

  000ac	33 d2		 xor	 edx, edx
  000ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000b3	e8 00 00 00 00	 call	 datetime_utcoffset
  000b8	48 89 44 24 38	 mov	 QWORD PTR offset$[rsp], rax

; 4786 :     if (offset == NULL)

  000bd	48 83 7c 24 38
	00		 cmp	 QWORD PTR offset$[rsp], 0
  000c3	75 07		 jne	 SHORT $LN6@datetime_a@3

; 4787 :         return NULL;

  000c5	33 c0		 xor	 eax, eax
  000c7	e9 1b 01 00 00	 jmp	 $LN12@datetime_a@3
$LN6@datetime_a@3:

; 4788 :     if (offset == Py_None) {

  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000d3	48 39 44 24 38	 cmp	 QWORD PTR offset$[rsp], rax
  000d8	75 24		 jne	 SHORT $LN5@datetime_a@3

; 4789 :         Py_DECREF(offset);

  000da	48 8b 4c 24 38	 mov	 rcx, QWORD PTR offset$[rsp]
  000df	e8 00 00 00 00	 call	 _Py_DecRef
$NeedAware$24560:

; 4790 :       NeedAware:
; 4791 :         PyErr_SetString(PyExc_ValueError, "astimezone() cannot be applied to "
; 4792 :                         "a naive datetime");

  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@HOLPDAGJ@astimezone?$CI?$CJ?5cannot?5be?5applied?5t@
  000eb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000f2	e8 00 00 00 00	 call	 PyErr_SetString

; 4793 :         return NULL;

  000f7	33 c0		 xor	 eax, eax
  000f9	e9 e9 00 00 00	 jmp	 $LN12@datetime_a@3
$LN5@datetime_a@3:

; 4794 :     }
; 4795 : 
; 4796 :     /* result = self - offset */
; 4797 :     result = (PyDateTime_DateTime *)add_datetime_timedelta(self,
; 4798 :                                        (PyDateTime_Delta *)offset, -1);

  000fe	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00104	48 8b 54 24 38	 mov	 rdx, QWORD PTR offset$[rsp]
  00109	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0010e	e8 00 00 00 00	 call	 add_datetime_timedelta
  00113	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 4799 :     Py_DECREF(offset);

  00118	48 8b 4c 24 38	 mov	 rcx, QWORD PTR offset$[rsp]
  0011d	e8 00 00 00 00	 call	 _Py_DecRef

; 4800 :     if (result == NULL)

  00122	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  00128	75 07		 jne	 SHORT $LN4@datetime_a@3

; 4801 :         return NULL;

  0012a	33 c0		 xor	 eax, eax
  0012c	e9 b6 00 00 00	 jmp	 $LN12@datetime_a@3
$LN4@datetime_a@3:

; 4802 : 
; 4803 :     /* Attach new tzinfo and let fromutc() do the rest. */
; 4804 :     temp = result->tzinfo;

  00131	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00136	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0013a	48 89 44 24 30	 mov	 QWORD PTR temp$[rsp], rax

; 4805 :     if (tzinfo == Py_None) {

  0013f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00146	48 39 44 24 40	 cmp	 QWORD PTR tzinfo$[rsp], rax
  0014b	75 27		 jne	 SHORT $LN3@datetime_a@3

; 4806 :         tzinfo = local_timezone(result);

  0014d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00152	e8 00 00 00 00	 call	 local_timezone
  00157	48 89 44 24 40	 mov	 QWORD PTR tzinfo$[rsp], rax

; 4807 :         if (tzinfo == NULL) {

  0015c	48 83 7c 24 40
	00		 cmp	 QWORD PTR tzinfo$[rsp], 0
  00162	75 0e		 jne	 SHORT $LN2@datetime_a@3

; 4808 :             Py_DECREF(result);

  00164	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00169	e8 00 00 00 00	 call	 _Py_DecRef

; 4809 :             return NULL;

  0016e	33 c0		 xor	 eax, eax
  00170	eb 75		 jmp	 SHORT $LN12@datetime_a@3
$LN2@datetime_a@3:

; 4810 :         }
; 4811 :     }
; 4812 :     else

  00172	eb 0a		 jmp	 SHORT $LN1@datetime_a@3
$LN3@datetime_a@3:

; 4813 :       Py_INCREF(tzinfo);

  00174	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00179	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@datetime_a@3:

; 4814 :     result->tzinfo = tzinfo;

  0017e	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00183	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  00188	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 4815 :     Py_DECREF(temp);

  0018c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR temp$[rsp]
  00191	e8 00 00 00 00	 call	 _Py_DecRef

; 4816 : 
; 4817 :     temp = (PyObject *)result;

  00196	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  0019b	48 89 44 24 30	 mov	 QWORD PTR temp$[rsp], rax

; 4818 :     result = (PyDateTime_DateTime *)
; 4819 :         _PyObject_CallMethodId(tzinfo, &PyId_fromutc, "O", temp);

  001a0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_fromutc@?1??datetime_astimezone@@9@9
  001a5	8b c0		 mov	 eax, eax
  001a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001ad	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  001b6	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  001ba	4c 8b 4c 24 30	 mov	 r9, QWORD PTR temp$[rsp]
  001bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  001c6	48 8b d0	 mov	 rdx, rax
  001c9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  001ce	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  001d3	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 4820 :     Py_DECREF(temp);

  001d8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR temp$[rsp]
  001dd	e8 00 00 00 00	 call	 _Py_DecRef

; 4821 : 
; 4822 :     return result;

  001e2	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
$LN12@datetime_a@3:

; 4823 : }

  001e7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001eb	c3		 ret	 0
datetime_astimezone ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@GMJLDMKP@surrogateescape?$AA@		; `string'
EXTRN	PyUnicode_DecodeLocale:PROC
EXTRN	__imp_tzname:BYTE
EXTRN	__imp_daylight:DWORD
_BSS	SEGMENT
PyDateTime_Epoch DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$local_timezone DD imagerel local_timezone
	DD	imagerel local_timezone+668
	DD	imagerel $unwind$local_timezone
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$local_timezone DD 020c01H
	DD	015010cH
xdata	ENDS
;	COMDAT ??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
CONST	SEGMENT
??_C@_0BA@GMJLDMKP@surrogateescape?$AA@ DB 'surrogateescape', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT local_timezone
_TEXT	SEGMENT
one_second$ = 80
timep$ = 88
seconds$ = 96
nameo$ = 104
delta$ = 112
timestamp$ = 120
result$ = 128
zone$ = 136
local_time$24518 = 144
tv151 = 152
utc_time$ = 176
local_timezone PROC					; COMDAT

; 4697 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 4698 :     PyObject *result = NULL;

  0000c	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR result$[rsp], 0

; 4699 :     struct tm *timep;
; 4700 :     time_t timestamp;
; 4701 :     PyObject *delta;
; 4702 :     PyObject *one_second;
; 4703 :     PyObject *seconds;
; 4704 :     PyObject *nameo = NULL;

  00018	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR nameo$[rsp], 0

; 4705 :     const char *zone = NULL;

  00021	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR zone$[rsp], 0

; 4706 : 
; 4707 :     delta = datetime_subtract((PyObject *)utc_time, PyDateTime_Epoch);

  0002d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyDateTime_Epoch
  00034	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR utc_time$[rsp]
  0003c	e8 00 00 00 00	 call	 datetime_subtract
  00041	48 89 44 24 70	 mov	 QWORD PTR delta$[rsp], rax

; 4708 :     if (delta == NULL)

  00046	48 83 7c 24 70
	00		 cmp	 QWORD PTR delta$[rsp], 0
  0004c	75 07		 jne	 SHORT $LN9@local_time

; 4709 :         return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	e9 3f 02 00 00	 jmp	 $LN10@local_time
$LN9@local_time:

; 4710 :     one_second = new_delta(0, 1, 0, 0);

  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  0005c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00061	45 33 c9	 xor	 r9d, r9d
  00064	45 33 c0	 xor	 r8d, r8d
  00067	ba 01 00 00 00	 mov	 edx, 1
  0006c	33 c9		 xor	 ecx, ecx
  0006e	e8 00 00 00 00	 call	 new_delta_ex
  00073	48 89 44 24 50	 mov	 QWORD PTR one_second$[rsp], rax

; 4711 :     if (one_second == NULL)

  00078	48 83 7c 24 50
	00		 cmp	 QWORD PTR one_second$[rsp], 0
  0007e	75 05		 jne	 SHORT $LN8@local_time

; 4712 :         goto error;

  00080	e9 fd 01 00 00	 jmp	 $error$24508
$LN8@local_time:

; 4713 :     seconds = divide_timedelta_timedelta((PyDateTime_Delta *)delta,
; 4714 :                                          (PyDateTime_Delta *)one_second);

  00085	48 8b 54 24 50	 mov	 rdx, QWORD PTR one_second$[rsp]
  0008a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delta$[rsp]
  0008f	e8 00 00 00 00	 call	 divide_timedelta_timedelta
  00094	48 89 44 24 60	 mov	 QWORD PTR seconds$[rsp], rax

; 4715 :     Py_DECREF(one_second);

  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR one_second$[rsp]
  0009e	e8 00 00 00 00	 call	 _Py_DecRef

; 4716 :     if (seconds == NULL)

  000a3	48 83 7c 24 60
	00		 cmp	 QWORD PTR seconds$[rsp], 0
  000a9	75 05		 jne	 SHORT $LN7@local_time

; 4717 :         goto error;

  000ab	e9 d2 01 00 00	 jmp	 $error$24508
$LN7@local_time:

; 4718 :     Py_DECREF(delta);

  000b0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delta$[rsp]
  000b5	e8 00 00 00 00	 call	 _Py_DecRef

; 4719 :     timestamp = PyLong_AsLong(seconds);

  000ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR seconds$[rsp]
  000bf	e8 00 00 00 00	 call	 PyLong_AsLong
  000c4	48 98		 cdqe
  000c6	48 89 44 24 78	 mov	 QWORD PTR timestamp$[rsp], rax

; 4720 :     Py_DECREF(seconds);

  000cb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR seconds$[rsp]
  000d0	e8 00 00 00 00	 call	 _Py_DecRef

; 4721 :     if (timestamp == -1 && PyErr_Occurred())

  000d5	48 83 7c 24 78
	ff		 cmp	 QWORD PTR timestamp$[rsp], -1
  000db	75 11		 jne	 SHORT $LN6@local_time
  000dd	e8 00 00 00 00	 call	 PyErr_Occurred
  000e2	48 85 c0	 test	 rax, rax
  000e5	74 07		 je	 SHORT $LN6@local_time

; 4722 :         return NULL;

  000e7	33 c0		 xor	 eax, eax
  000e9	e9 a6 01 00 00	 jmp	 $LN10@local_time
$LN6@local_time:

; 4723 :     timep = localtime(&timestamp);

  000ee	48 8d 4c 24 78	 lea	 rcx, QWORD PTR timestamp$[rsp]
  000f3	e8 00 00 00 00	 call	 localtime
  000f8	48 89 44 24 58	 mov	 QWORD PTR timep$[rsp], rax

; 4724 : #ifdef HAVE_STRUCT_TM_TM_ZONE
; 4725 :     zone = timep->tm_zone;
; 4726 :     delta = new_delta(0, timep->tm_gmtoff, 0, 1);
; 4727 : #else /* HAVE_STRUCT_TM_TM_ZONE */
; 4728 :     {
; 4729 :         PyObject *local_time;
; 4730 :         local_time = new_datetime(timep->tm_year + 1900, timep->tm_mon + 1,
; 4731 :                                   timep->tm_mday, timep->tm_hour, timep->tm_min,
; 4732 :                                   timep->tm_sec, DATE_GET_MICROSECOND(utc_time),
; 4733 :                                   utc_time->tzinfo);

  000fd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR utc_time$[rsp]
  00105	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  00109	c1 e0 10	 shl	 eax, 16
  0010c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR utc_time$[rsp]
  00114	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  00118	c1 e1 08	 shl	 ecx, 8
  0011b	0b c1		 or	 eax, ecx
  0011d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR utc_time$[rsp]
  00125	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  00129	0b c1		 or	 eax, ecx
  0012b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR timep$[rsp]
  00130	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00133	ff c1		 inc	 ecx
  00135	48 8b 54 24 58	 mov	 rdx, QWORD PTR timep$[rsp]
  0013a	8b 52 14	 mov	 edx, DWORD PTR [rdx+20]
  0013d	81 c2 6c 07 00
	00		 add	 edx, 1900		; 0000076cH
  00143	89 94 24 98 00
	00 00		 mov	 DWORD PTR tv151[rsp], edx
  0014a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyDateTime_DateTimeType
  00151	4c 89 44 24 40	 mov	 QWORD PTR [rsp+64], r8
  00156	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR utc_time$[rsp]
  0015e	4d 8b 40 78	 mov	 r8, QWORD PTR [r8+120]
  00162	4c 89 44 24 38	 mov	 QWORD PTR [rsp+56], r8
  00167	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0016b	48 8b 44 24 58	 mov	 rax, QWORD PTR timep$[rsp]
  00170	8b 00		 mov	 eax, DWORD PTR [rax]
  00172	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00176	48 8b 44 24 58	 mov	 rax, QWORD PTR timep$[rsp]
  0017b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0017e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00182	48 8b 44 24 58	 mov	 rax, QWORD PTR timep$[rsp]
  00187	44 8b 48 08	 mov	 r9d, DWORD PTR [rax+8]
  0018b	48 8b 44 24 58	 mov	 rax, QWORD PTR timep$[rsp]
  00190	44 8b 40 0c	 mov	 r8d, DWORD PTR [rax+12]
  00194	8b d1		 mov	 edx, ecx
  00196	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv151[rsp]
  0019d	8b c8		 mov	 ecx, eax
  0019f	e8 00 00 00 00	 call	 new_datetime_ex
  001a4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR local_time$24518[rsp], rax

; 4734 :         if (local_time == NULL)

  001ac	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR local_time$24518[rsp], 0
  001b5	75 05		 jne	 SHORT $LN5@local_time

; 4735 :             goto error;

  001b7	e9 c6 00 00 00	 jmp	 $error$24508
$LN5@local_time:

; 4736 :         delta = datetime_subtract(local_time, (PyObject*)utc_time);

  001bc	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR utc_time$[rsp]
  001c4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR local_time$24518[rsp]
  001cc	e8 00 00 00 00	 call	 datetime_subtract
  001d1	48 89 44 24 70	 mov	 QWORD PTR delta$[rsp], rax

; 4737 :         /* XXX: before relying on tzname, we should compare delta
; 4738 :            to the offset implied by timezone/altzone */
; 4739 :         if (daylight && timep->tm_isdst >= 0)

  001d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_daylight
  001dd	83 38 00	 cmp	 DWORD PTR [rax], 0
  001e0	74 32		 je	 SHORT $LN4@local_time
  001e2	48 8b 44 24 58	 mov	 rax, QWORD PTR timep$[rsp]
  001e7	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  001eb	7c 27		 jl	 SHORT $LN4@local_time

; 4740 :             zone = tzname[timep->tm_isdst % 2];

  001ed	48 8b 44 24 58	 mov	 rax, QWORD PTR timep$[rsp]
  001f2	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  001f5	99		 cdq
  001f6	83 e0 01	 and	 eax, 1
  001f9	33 c2		 xor	 eax, edx
  001fb	2b c2		 sub	 eax, edx
  001fd	48 98		 cdqe
  001ff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_tzname
  00206	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0020a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR zone$[rsp], rax

; 4741 :         else

  00212	eb 12		 jmp	 SHORT $LN3@local_time
$LN4@local_time:

; 4742 :             zone = tzname[0];

  00214	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_tzname
  0021b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0021e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR zone$[rsp], rax
$LN3@local_time:

; 4743 :         Py_DECREF(local_time);

  00226	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR local_time$24518[rsp]
  0022e	e8 00 00 00 00	 call	 _Py_DecRef

; 4744 :     }
; 4745 : #endif /* HAVE_STRUCT_TM_TM_ZONE */
; 4746 :     if (zone != NULL) {

  00233	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR zone$[rsp], 0
  0023c	74 23		 je	 SHORT $LN2@local_time

; 4747 :         nameo = PyUnicode_DecodeLocale(zone, "surrogateescape");

  0023e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
  00245	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR zone$[rsp]
  0024d	e8 00 00 00 00	 call	 PyUnicode_DecodeLocale
  00252	48 89 44 24 68	 mov	 QWORD PTR nameo$[rsp], rax

; 4748 :         if (nameo == NULL)

  00257	48 83 7c 24 68
	00		 cmp	 QWORD PTR nameo$[rsp], 0
  0025d	75 02		 jne	 SHORT $LN1@local_time

; 4749 :             goto error;

  0025f	eb 21		 jmp	 SHORT $error$24508
$LN1@local_time:
$LN2@local_time:

; 4750 :     }
; 4751 :     result = new_timezone(delta, nameo);

  00261	48 8b 54 24 68	 mov	 rdx, QWORD PTR nameo$[rsp]
  00266	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delta$[rsp]
  0026b	e8 00 00 00 00	 call	 new_timezone
  00270	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR result$[rsp], rax

; 4752 :     Py_DECREF(nameo);

  00278	48 8b 4c 24 68	 mov	 rcx, QWORD PTR nameo$[rsp]
  0027d	e8 00 00 00 00	 call	 _Py_DecRef
$error$24508:

; 4753 :   error:
; 4754 :     Py_DECREF(delta);

  00282	48 8b 4c 24 70	 mov	 rcx, QWORD PTR delta$[rsp]
  00287	e8 00 00 00 00	 call	 _Py_DecRef

; 4755 :     return result;

  0028c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN10@local_time:

; 4756 : }

  00294	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0029b	c3		 ret	 0
local_timezone ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_timetuple DD imagerel datetime_timetuple
	DD	imagerel datetime_timetuple+244
	DD	imagerel $unwind$datetime_timetuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_timetuple DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_timetuple
_TEXT	SEGMENT
dstflag$ = 64
dst$24596 = 72
tv130 = 80
self$ = 112
datetime_timetuple PROC					; COMDAT

; 4827 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4828 :     int dstflag = -1;

  00009	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR dstflag$[rsp], -1

; 4829 : 
; 4830 :     if (HASTZINFO(self) && self->tzinfo != Py_None) {

  00011	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00016	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  0001a	85 c0		 test	 eax, eax
  0001c	74 5f		 je	 SHORT $LN3@datetime_t@3
  0001e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00025	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0002a	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  0002e	74 4d		 je	 SHORT $LN3@datetime_t@3

; 4831 :         PyObject * dst;
; 4832 : 
; 4833 :         dst = call_dst(self->tzinfo, (PyObject *)self);

  00030	48 8b 54 24 70	 mov	 rdx, QWORD PTR self$[rsp]
  00035	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0003a	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  0003e	e8 00 00 00 00	 call	 call_dst
  00043	48 89 44 24 48	 mov	 QWORD PTR dst$24596[rsp], rax

; 4834 :         if (dst == NULL)

  00048	48 83 7c 24 48
	00		 cmp	 QWORD PTR dst$24596[rsp], 0
  0004e	75 07		 jne	 SHORT $LN2@datetime_t@3

; 4835 :             return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	e9 98 00 00 00	 jmp	 $LN4@datetime_t@3
$LN2@datetime_t@3:

; 4836 : 
; 4837 :         if (dst != Py_None)

  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0005e	48 39 44 24 48	 cmp	 QWORD PTR dst$24596[rsp], rax
  00063	74 0e		 je	 SHORT $LN1@datetime_t@3

; 4838 :             dstflag = delta_bool((PyDateTime_Delta *)dst);

  00065	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dst$24596[rsp]
  0006a	e8 00 00 00 00	 call	 delta_bool
  0006f	89 44 24 40	 mov	 DWORD PTR dstflag$[rsp], eax
$LN1@datetime_t@3:

; 4839 :         Py_DECREF(dst);

  00073	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dst$24596[rsp]
  00078	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@datetime_t@3:

; 4840 :     }
; 4841 :     return build_struct_time(GET_YEAR(self),
; 4842 :                              GET_MONTH(self),
; 4843 :                              GET_DAY(self),
; 4844 :                              DATE_GET_HOUR(self),
; 4845 :                              DATE_GET_MINUTE(self),
; 4846 :                              DATE_GET_SECOND(self),
; 4847 :                              dstflag);

  0007d	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00082	0f b6 40 6f	 movzx	 eax, BYTE PTR [rax+111]
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0008b	0f b6 49 6e	 movzx	 ecx, BYTE PTR [rcx+110]
  0008f	48 8b 54 24 70	 mov	 rdx, QWORD PTR self$[rsp]
  00094	0f b6 52 6d	 movzx	 edx, BYTE PTR [rdx+109]
  00098	4c 8b 44 24 70	 mov	 r8, QWORD PTR self$[rsp]
  0009d	45 0f b6 40 6c	 movzx	 r8d, BYTE PTR [r8+108]
  000a2	4c 8b 4c 24 70	 mov	 r9, QWORD PTR self$[rsp]
  000a7	45 0f b6 49 6b	 movzx	 r9d, BYTE PTR [r9+107]
  000ac	44 89 4c 24 50	 mov	 DWORD PTR tv130[rsp], r9d
  000b1	4c 8b 54 24 70	 mov	 r10, QWORD PTR self$[rsp]
  000b6	45 0f b6 52 69	 movzx	 r10d, BYTE PTR [r10+105]
  000bb	41 c1 e2 08	 shl	 r10d, 8
  000bf	4c 8b 5c 24 70	 mov	 r11, QWORD PTR self$[rsp]
  000c4	45 0f b6 5b 6a	 movzx	 r11d, BYTE PTR [r11+106]
  000c9	45 0b d3	 or	 r10d, r11d
  000cc	44 8b 5c 24 40	 mov	 r11d, DWORD PTR dstflag$[rsp]
  000d1	44 89 5c 24 30	 mov	 DWORD PTR [rsp+48], r11d
  000d6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000da	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000de	44 8b ca	 mov	 r9d, edx
  000e1	8b 44 24 50	 mov	 eax, DWORD PTR tv130[rsp]
  000e5	8b d0		 mov	 edx, eax
  000e7	41 8b ca	 mov	 ecx, r10d
  000ea	e8 00 00 00 00	 call	 build_struct_time
$LN4@datetime_t@3:

; 4848 : }

  000ef	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000f3	c3		 ret	 0
datetime_timetuple ENDP
_TEXT	ENDS
PUBLIC	__real@412e848000000000
PUBLIC	??_C@_0BH@BMMGHMPN@timestamp?5out?5of?5range?$AA@ ; `string'
EXTRN	PyFloat_FromDouble:PROC
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_timestamp DD imagerel datetime_timestamp
	DD	imagerel datetime_timestamp+381
	DD	imagerel $unwind$datetime_timestamp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_timestamp DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
CONST	ENDS
;	COMDAT ??_C@_0BH@BMMGHMPN@timestamp?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BH@BMMGHMPN@timestamp?5out?5of?5range?$AA@ DB 'timestamp out of ra'
	DB	'nge', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT datetime_timestamp
_TEXT	SEGMENT
result$ = 32
delta$24618 = 40
time$24625 = 48
timestamp$24626 = 88
self$ = 112
datetime_timestamp PROC					; COMDAT

; 4852 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4853 :     PyObject *result;
; 4854 : 
; 4855 :     if (HASTZINFO(self) && self->tzinfo != Py_None) {

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00012	85 c0		 test	 eax, eax
  00014	74 55		 je	 SHORT $LN4@datetime_t@4
  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00022	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  00026	74 43		 je	 SHORT $LN4@datetime_t@4

; 4856 :         PyObject *delta;
; 4857 :         delta = datetime_subtract((PyObject *)self, PyDateTime_Epoch);

  00028	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyDateTime_Epoch
  0002f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00034	e8 00 00 00 00	 call	 datetime_subtract
  00039	48 89 44 24 28	 mov	 QWORD PTR delta$24618[rsp], rax

; 4858 :         if (delta == NULL)

  0003e	48 83 7c 24 28
	00		 cmp	 QWORD PTR delta$24618[rsp], 0
  00044	75 07		 jne	 SHORT $LN3@datetime_t@4

; 4859 :             return NULL;

  00046	33 c0		 xor	 eax, eax
  00048	e9 2b 01 00 00	 jmp	 $LN5@datetime_t@4
$LN3@datetime_t@4:

; 4860 :         result = delta_total_seconds(delta);

  0004d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR delta$24618[rsp]
  00052	e8 00 00 00 00	 call	 delta_total_seconds
  00057	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 4861 :         Py_DECREF(delta);

  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR delta$24618[rsp]
  00061	e8 00 00 00 00	 call	 _Py_DecRef

; 4862 :     }
; 4863 :     else {

  00066	e9 08 01 00 00	 jmp	 $LN2@datetime_t@4
$LN4@datetime_t@4:

; 4864 :         struct tm time;
; 4865 :         time_t timestamp;
; 4866 :         memset((void *) &time, '\0', sizeof(struct tm));

  0006b	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  00071	33 d2		 xor	 edx, edx
  00073	48 8d 4c 24 30	 lea	 rcx, QWORD PTR time$24625[rsp]
  00078	e8 00 00 00 00	 call	 memset

; 4867 :         time.tm_year = GET_YEAR(self) - 1900;

  0007d	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00082	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00086	c1 e0 08	 shl	 eax, 8
  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0008e	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00092	0b c1		 or	 eax, ecx
  00094	2d 6c 07 00 00	 sub	 eax, 1900		; 0000076cH
  00099	89 44 24 44	 mov	 DWORD PTR time$24625[rsp+20], eax

; 4868 :         time.tm_mon = GET_MONTH(self) - 1;

  0009d	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000a2	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  000a6	ff c8		 dec	 eax
  000a8	89 44 24 40	 mov	 DWORD PTR time$24625[rsp+16], eax

; 4869 :         time.tm_mday = GET_DAY(self);

  000ac	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000b1	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  000b5	89 44 24 3c	 mov	 DWORD PTR time$24625[rsp+12], eax

; 4870 :         time.tm_hour = DATE_GET_HOUR(self);

  000b9	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000be	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  000c2	89 44 24 38	 mov	 DWORD PTR time$24625[rsp+8], eax

; 4871 :         time.tm_min = DATE_GET_MINUTE(self);

  000c6	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000cb	0f b6 40 6e	 movzx	 eax, BYTE PTR [rax+110]
  000cf	89 44 24 34	 mov	 DWORD PTR time$24625[rsp+4], eax

; 4872 :         time.tm_sec = DATE_GET_SECOND(self);

  000d3	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  000d8	0f b6 40 6f	 movzx	 eax, BYTE PTR [rax+111]
  000dc	89 44 24 30	 mov	 DWORD PTR time$24625[rsp], eax

; 4873 :         time.tm_wday = -1;

  000e0	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR time$24625[rsp+24], -1

; 4874 :         time.tm_isdst = -1;

  000e8	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR time$24625[rsp+32], -1

; 4875 :         timestamp = mktime(&time);

  000f0	48 8d 4c 24 30	 lea	 rcx, QWORD PTR time$24625[rsp]
  000f5	e8 00 00 00 00	 call	 mktime
  000fa	48 89 44 24 58	 mov	 QWORD PTR timestamp$24626[rsp], rax

; 4876 :         /* Return value of -1 does not necessarily mean an error, but tm_wday
; 4877 :          * cannot remain set to -1 if mktime succeeded. */
; 4878 :         if (timestamp == (time_t)(-1) && time.tm_wday == -1) {

  000ff	48 83 7c 24 58
	ff		 cmp	 QWORD PTR timestamp$24626[rsp], -1
  00105	75 1e		 jne	 SHORT $LN1@datetime_t@4
  00107	83 7c 24 48 ff	 cmp	 DWORD PTR time$24625[rsp+24], -1
  0010c	75 17		 jne	 SHORT $LN1@datetime_t@4

; 4879 :             PyErr_SetString(PyExc_OverflowError,
; 4880 :                             "timestamp out of range");

  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@BMMGHMPN@timestamp?5out?5of?5range?$AA@
  00115	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0011c	e8 00 00 00 00	 call	 PyErr_SetString

; 4881 :             return NULL;

  00121	33 c0		 xor	 eax, eax
  00123	eb 53		 jmp	 SHORT $LN5@datetime_t@4
$LN1@datetime_t@4:

; 4882 :         }
; 4883 :         result = PyFloat_FromDouble(timestamp + DATE_GET_MICROSECOND(self) / 1e6);

  00125	66 0f ef c0	 pxor	 xmm0, xmm0
  00129	f2 48 0f 2a 44
	24 58		 cvtsi2sd xmm0, QWORD PTR timestamp$24626[rsp]
  00130	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00135	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  00139	c1 e0 10	 shl	 eax, 16
  0013c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  00141	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  00145	c1 e1 08	 shl	 ecx, 8
  00148	0b c1		 or	 eax, ecx
  0014a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR self$[rsp]
  0014f	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  00153	0b c1		 or	 eax, ecx
  00155	66 0f 6e c8	 movd	 xmm1, eax
  00159	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0015d	f2 0f 5e 0d 00
	00 00 00	 divsd	 xmm1, QWORD PTR __real@412e848000000000
  00165	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00169	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0016e	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN2@datetime_t@4:

; 4884 :     }
; 4885 :     return result;

  00173	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN5@datetime_t@4:

; 4886 : }

  00178	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0017c	c3		 ret	 0
datetime_timestamp ENDP
_TEXT	ENDS
EXTRN	__imp__mktime64:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
pdata	SEGMENT
$pdata$mktime DD imagerel mktime
	DD	imagerel mktime+25
	DD	imagerel $unwind$mktime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mktime DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mktime
_TEXT	SEGMENT
_Tm$ = 48
mktime	PROC						; COMDAT

; 124  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 125  :     return _mktime64(_Tm);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Tm$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__mktime64

; 126  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
mktime	ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\_datetimemodule.c
pdata	SEGMENT
$pdata$datetime_getdate DD imagerel datetime_getdate
	DD	imagerel datetime_getdate+84
	DD	imagerel $unwind$datetime_getdate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_getdate DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_getdate
_TEXT	SEGMENT
tv81 = 32
self$ = 64
datetime_getdate PROC					; COMDAT

; 4890 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4891 :     return new_date(GET_YEAR(self),
; 4892 :                     GET_MONTH(self),
; 4893 :                     GET_DAY(self));

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00017	0f b6 49 6b	 movzx	 ecx, BYTE PTR [rcx+107]
  0001b	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  00020	0f b6 52 69	 movzx	 edx, BYTE PTR [rdx+105]
  00024	c1 e2 08	 shl	 edx, 8
  00027	4c 8b 44 24 40	 mov	 r8, QWORD PTR self$[rsp]
  0002c	45 0f b6 40 6a	 movzx	 r8d, BYTE PTR [r8+106]
  00031	41 0b d0	 or	 edx, r8d
  00034	89 54 24 20	 mov	 DWORD PTR tv81[rsp], edx
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_DateType
  0003f	44 8b c0	 mov	 r8d, eax
  00042	8b d1		 mov	 edx, ecx
  00044	8b 44 24 20	 mov	 eax, DWORD PTR tv81[rsp]
  00048	8b c8		 mov	 ecx, eax
  0004a	e8 00 00 00 00	 call	 new_date_ex

; 4894 : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
datetime_getdate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_gettime DD imagerel datetime_gettime
	DD	imagerel datetime_gettime+125
	DD	imagerel $unwind$datetime_gettime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_gettime DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_gettime
_TEXT	SEGMENT
tv91 = 48
self$ = 80
datetime_gettime PROC					; COMDAT

; 4898 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4899 :     return new_time(DATE_GET_HOUR(self),
; 4900 :                     DATE_GET_MINUTE(self),
; 4901 :                     DATE_GET_SECOND(self),
; 4902 :                     DATE_GET_MICROSECOND(self),
; 4903 :                     Py_None);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  00012	c1 e0 10	 shl	 eax, 16
  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0001a	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  0001e	c1 e1 08	 shl	 ecx, 8
  00021	0b c1		 or	 eax, ecx
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00028	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  0002c	0b c1		 or	 eax, ecx
  0002e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00033	0f b6 49 6f	 movzx	 ecx, BYTE PTR [rcx+111]
  00037	48 8b 54 24 50	 mov	 rdx, QWORD PTR self$[rsp]
  0003c	0f b6 52 6e	 movzx	 edx, BYTE PTR [rdx+110]
  00040	4c 8b 44 24 50	 mov	 r8, QWORD PTR self$[rsp]
  00045	45 0f b6 40 6d	 movzx	 r8d, BYTE PTR [r8+109]
  0004a	44 89 44 24 30	 mov	 DWORD PTR tv91[rsp], r8d
  0004f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_TimeType
  00056	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  0005b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  00062	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00067	44 8b c8	 mov	 r9d, eax
  0006a	44 8b c1	 mov	 r8d, ecx
  0006d	8b 44 24 30	 mov	 eax, DWORD PTR tv91[rsp]
  00071	8b c8		 mov	 ecx, eax
  00073	e8 00 00 00 00	 call	 new_time_ex

; 4904 : }

  00078	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007c	c3		 ret	 0
datetime_gettime ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_gettimetz DD imagerel datetime_gettimetz
	DD	imagerel datetime_gettimetz+164
	DD	imagerel $unwind$datetime_gettimetz
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_gettimetz DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_gettimetz
_TEXT	SEGMENT
tv70 = 48
tv128 = 56
self$ = 80
datetime_gettimetz PROC					; COMDAT

; 4908 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4909 :     return new_time(DATE_GET_HOUR(self),
; 4910 :                     DATE_GET_MINUTE(self),
; 4911 :                     DATE_GET_SECOND(self),
; 4912 :                     DATE_GET_MICROSECOND(self),
; 4913 :                     GET_DT_TZINFO(self));

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00012	85 c0		 test	 eax, eax
  00014	74 10		 je	 SHORT $LN3@datetime_g
  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001b	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0001f	48 89 44 24 30	 mov	 QWORD PTR tv70[rsp], rax
  00024	eb 0c		 jmp	 SHORT $LN4@datetime_g
$LN3@datetime_g:
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0002d	48 89 44 24 30	 mov	 QWORD PTR tv70[rsp], rax
$LN4@datetime_g:
  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00037	0f b6 40 70	 movzx	 eax, BYTE PTR [rax+112]
  0003b	c1 e0 10	 shl	 eax, 16
  0003e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00043	0f b6 49 71	 movzx	 ecx, BYTE PTR [rcx+113]
  00047	c1 e1 08	 shl	 ecx, 8
  0004a	0b c1		 or	 eax, ecx
  0004c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00051	0f b6 49 72	 movzx	 ecx, BYTE PTR [rcx+114]
  00055	0b c1		 or	 eax, ecx
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	0f b6 49 6f	 movzx	 ecx, BYTE PTR [rcx+111]
  00060	48 8b 54 24 50	 mov	 rdx, QWORD PTR self$[rsp]
  00065	0f b6 52 6e	 movzx	 edx, BYTE PTR [rdx+110]
  00069	4c 8b 44 24 50	 mov	 r8, QWORD PTR self$[rsp]
  0006e	45 0f b6 40 6d	 movzx	 r8d, BYTE PTR [r8+109]
  00073	44 89 44 24 38	 mov	 DWORD PTR tv128[rsp], r8d
  00078	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_TimeType
  0007f	4c 89 4c 24 28	 mov	 QWORD PTR [rsp+40], r9
  00084	4c 8b 4c 24 30	 mov	 r9, QWORD PTR tv70[rsp]
  00089	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0008e	44 8b c8	 mov	 r9d, eax
  00091	44 8b c1	 mov	 r8d, ecx
  00094	8b 44 24 38	 mov	 eax, DWORD PTR tv128[rsp]
  00098	8b c8		 mov	 ecx, eax
  0009a	e8 00 00 00 00	 call	 new_time_ex

; 4914 : }

  0009f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a3	c3		 ret	 0
datetime_gettimetz ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_utctimetuple DD imagerel datetime_utctimetuple
	DD	imagerel datetime_utctimetuple+409
	DD	imagerel $unwind$datetime_utctimetuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_utctimetuple DD 020c01H
	DD	011010cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_utctimetuple
_TEXT	SEGMENT
y$ = 64
mm$ = 68
tzinfo$ = 72
hh$ = 80
utcself$ = 88
d$ = 96
ss$ = 100
m$ = 104
offset$24690 = 112
tv68 = 120
self$ = 144
datetime_utctimetuple PROC				; COMDAT

; 4918 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 4919 :     int y, m, d, hh, mm, ss;
; 4920 :     PyObject *tzinfo;
; 4921 :     PyDateTime_DateTime *utcself;
; 4922 : 
; 4923 :     tzinfo = GET_DT_TZINFO(self);

  0000c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00014	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  00018	85 c0		 test	 eax, eax
  0001a	74 13		 je	 SHORT $LN9@datetime_u@3
  0001c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00024	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00028	48 89 44 24 78	 mov	 QWORD PTR tv68[rsp], rax
  0002d	eb 0c		 jmp	 SHORT $LN10@datetime_u@3
$LN9@datetime_u@3:
  0002f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00036	48 89 44 24 78	 mov	 QWORD PTR tv68[rsp], rax
$LN10@datetime_u@3:
  0003b	48 8b 44 24 78	 mov	 rax, QWORD PTR tv68[rsp]
  00040	48 89 44 24 48	 mov	 QWORD PTR tzinfo$[rsp], rax

; 4924 :     if (tzinfo == Py_None) {

  00045	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0004c	48 39 44 24 48	 cmp	 QWORD PTR tzinfo$[rsp], rax
  00051	75 1c		 jne	 SHORT $LN6@datetime_u@3

; 4925 :         utcself = self;

  00053	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0005b	48 89 44 24 58	 mov	 QWORD PTR utcself$[rsp], rax

; 4926 :         Py_INCREF(utcself);

  00060	48 8b 4c 24 58	 mov	 rcx, QWORD PTR utcself$[rsp]
  00065	e8 00 00 00 00	 call	 _Py_IncRef

; 4927 :     }
; 4928 :     else {

  0006a	e9 8d 00 00 00	 jmp	 $LN5@datetime_u@3
$LN6@datetime_u@3:

; 4929 :         PyObject *offset;
; 4930 :         offset = call_utcoffset(tzinfo, (PyObject *)self);

  0006f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR self$[rsp]
  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tzinfo$[rsp]
  0007c	e8 00 00 00 00	 call	 call_utcoffset
  00081	48 89 44 24 70	 mov	 QWORD PTR offset$24690[rsp], rax

; 4931 :         if (offset == NULL)

  00086	48 83 7c 24 70
	00		 cmp	 QWORD PTR offset$24690[rsp], 0
  0008c	75 07		 jne	 SHORT $LN4@datetime_u@3

; 4932 :             return NULL;

  0008e	33 c0		 xor	 eax, eax
  00090	e9 fc 00 00 00	 jmp	 $LN7@datetime_u@3
$LN4@datetime_u@3:

; 4933 :         if (offset == Py_None) {

  00095	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0009c	48 39 44 24 70	 cmp	 QWORD PTR offset$24690[rsp], rax
  000a1	75 23		 jne	 SHORT $LN3@datetime_u@3

; 4934 :             Py_DECREF(offset);

  000a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR offset$24690[rsp]
  000a8	e8 00 00 00 00	 call	 _Py_DecRef

; 4935 :             utcself = self;

  000ad	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000b5	48 89 44 24 58	 mov	 QWORD PTR utcself$[rsp], rax

; 4936 :             Py_INCREF(utcself);

  000ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR utcself$[rsp]
  000bf	e8 00 00 00 00	 call	 _Py_IncRef

; 4937 :         }
; 4938 :         else {

  000c4	eb 36		 jmp	 SHORT $LN2@datetime_u@3
$LN3@datetime_u@3:

; 4939 :             utcself = (PyDateTime_DateTime *)add_datetime_timedelta(self,
; 4940 :                                                 (PyDateTime_Delta *)offset, -1);

  000c6	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  000cc	48 8b 54 24 70	 mov	 rdx, QWORD PTR offset$24690[rsp]
  000d1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000d9	e8 00 00 00 00	 call	 add_datetime_timedelta
  000de	48 89 44 24 58	 mov	 QWORD PTR utcself$[rsp], rax

; 4941 :             Py_DECREF(offset);

  000e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR offset$24690[rsp]
  000e8	e8 00 00 00 00	 call	 _Py_DecRef

; 4942 :             if (utcself == NULL)

  000ed	48 83 7c 24 58
	00		 cmp	 QWORD PTR utcself$[rsp], 0
  000f3	75 07		 jne	 SHORT $LN1@datetime_u@3

; 4943 :                 return NULL;

  000f5	33 c0		 xor	 eax, eax
  000f7	e9 95 00 00 00	 jmp	 $LN7@datetime_u@3
$LN1@datetime_u@3:
$LN2@datetime_u@3:
$LN5@datetime_u@3:

; 4944 :         }
; 4945 :     }
; 4946 :     y = GET_YEAR(utcself);

  000fc	48 8b 44 24 58	 mov	 rax, QWORD PTR utcself$[rsp]
  00101	0f b6 40 69	 movzx	 eax, BYTE PTR [rax+105]
  00105	c1 e0 08	 shl	 eax, 8
  00108	48 8b 4c 24 58	 mov	 rcx, QWORD PTR utcself$[rsp]
  0010d	0f b6 49 6a	 movzx	 ecx, BYTE PTR [rcx+106]
  00111	0b c1		 or	 eax, ecx
  00113	89 44 24 40	 mov	 DWORD PTR y$[rsp], eax

; 4947 :     m = GET_MONTH(utcself);

  00117	48 8b 44 24 58	 mov	 rax, QWORD PTR utcself$[rsp]
  0011c	0f b6 40 6b	 movzx	 eax, BYTE PTR [rax+107]
  00120	89 44 24 68	 mov	 DWORD PTR m$[rsp], eax

; 4948 :     d = GET_DAY(utcself);

  00124	48 8b 44 24 58	 mov	 rax, QWORD PTR utcself$[rsp]
  00129	0f b6 40 6c	 movzx	 eax, BYTE PTR [rax+108]
  0012d	89 44 24 60	 mov	 DWORD PTR d$[rsp], eax

; 4949 :     hh = DATE_GET_HOUR(utcself);

  00131	48 8b 44 24 58	 mov	 rax, QWORD PTR utcself$[rsp]
  00136	0f b6 40 6d	 movzx	 eax, BYTE PTR [rax+109]
  0013a	89 44 24 50	 mov	 DWORD PTR hh$[rsp], eax

; 4950 :     mm = DATE_GET_MINUTE(utcself);

  0013e	48 8b 44 24 58	 mov	 rax, QWORD PTR utcself$[rsp]
  00143	0f b6 40 6e	 movzx	 eax, BYTE PTR [rax+110]
  00147	89 44 24 44	 mov	 DWORD PTR mm$[rsp], eax

; 4951 :     ss = DATE_GET_SECOND(utcself);

  0014b	48 8b 44 24 58	 mov	 rax, QWORD PTR utcself$[rsp]
  00150	0f b6 40 6f	 movzx	 eax, BYTE PTR [rax+111]
  00154	89 44 24 64	 mov	 DWORD PTR ss$[rsp], eax

; 4952 : 
; 4953 :     Py_DECREF(utcself);

  00158	48 8b 4c 24 58	 mov	 rcx, QWORD PTR utcself$[rsp]
  0015d	e8 00 00 00 00	 call	 _Py_DecRef

; 4954 :     return build_struct_time(y, m, d, hh, mm, ss, 0);

  00162	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0016a	8b 44 24 64	 mov	 eax, DWORD PTR ss$[rsp]
  0016e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00172	8b 44 24 44	 mov	 eax, DWORD PTR mm$[rsp]
  00176	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0017a	44 8b 4c 24 50	 mov	 r9d, DWORD PTR hh$[rsp]
  0017f	44 8b 44 24 60	 mov	 r8d, DWORD PTR d$[rsp]
  00184	8b 54 24 68	 mov	 edx, DWORD PTR m$[rsp]
  00188	8b 4c 24 40	 mov	 ecx, DWORD PTR y$[rsp]
  0018c	e8 00 00 00 00	 call	 build_struct_time
$LN7@datetime_u@3:

; 4955 : }

  00191	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00198	c3		 ret	 0
datetime_utctimetuple ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_reduce DD imagerel datetime_reduce
	DD	imagerel datetime_reduce+53
	DD	imagerel $unwind$datetime_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_reduce DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_reduce
_TEXT	SEGMENT
self$ = 48
arg$ = 56
datetime_reduce PROC					; COMDAT

; 4984 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4985 :     return Py_BuildValue("(ON)", Py_TYPE(self), datetime_getstate(self));

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 datetime_getstate
  00018	4c 8b c0	 mov	 r8, rax
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04DFFJBLGN@?$CION?$CJ?$AA@
  0002b	e8 00 00 00 00	 call	 Py_BuildValue

; 4986 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
datetime_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$datetime_getstate DD imagerel datetime_getstate
	DD	imagerel datetime_getstate+155
	DD	imagerel $unwind$datetime_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$datetime_getstate DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT datetime_getstate
_TEXT	SEGMENT
basestate$ = 32
result$ = 40
self$ = 64
datetime_getstate PROC					; COMDAT

; 4966 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4967 :     PyObject *basestate;
; 4968 :     PyObject *result = NULL;

  00009	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 4969 : 
; 4970 :     basestate = PyBytes_FromStringAndSize((char *)self->data,
; 4971 :                                            _PyDateTime_DATETIME_DATASIZE);

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00017	48 83 c0 69	 add	 rax, 105		; 00000069H
  0001b	ba 0a 00 00 00	 mov	 edx, 10
  00020	48 8b c8	 mov	 rcx, rax
  00023	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00028	48 89 44 24 20	 mov	 QWORD PTR basestate$[rsp], rax

; 4972 :     if (basestate != NULL) {

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR basestate$[rsp], 0
  00033	74 5c		 je	 SHORT $LN4@datetime_g@2

; 4973 :         if (! HASTZINFO(self) || self->tzinfo == Py_None)

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003a	0f be 40 68	 movsx	 eax, BYTE PTR [rax+104]
  0003e	85 c0		 test	 eax, eax
  00040	74 12		 je	 SHORT $LN2@datetime_g@2
  00042	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0004e	48 39 41 78	 cmp	 QWORD PTR [rcx+120], rax
  00052	75 16		 jne	 SHORT $LN3@datetime_g@2
$LN2@datetime_g@2:

; 4974 :             result = PyTuple_Pack(1, basestate);

  00054	48 8b 54 24 20	 mov	 rdx, QWORD PTR basestate$[rsp]
  00059	b9 01 00 00 00	 mov	 ecx, 1
  0005e	e8 00 00 00 00	 call	 PyTuple_Pack
  00063	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 4975 :         else

  00068	eb 1d		 jmp	 SHORT $LN1@datetime_g@2
$LN3@datetime_g@2:

; 4976 :             result = PyTuple_Pack(2, basestate, self->tzinfo);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006f	4c 8b 40 78	 mov	 r8, QWORD PTR [rax+120]
  00073	48 8b 54 24 20	 mov	 rdx, QWORD PTR basestate$[rsp]
  00078	b9 02 00 00 00	 mov	 ecx, 2
  0007d	e8 00 00 00 00	 call	 PyTuple_Pack
  00082	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax
$LN1@datetime_g@2:

; 4977 :         Py_DECREF(basestate);

  00087	48 8b 4c 24 20	 mov	 rcx, QWORD PTR basestate$[rsp]
  0008c	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@datetime_g@2:

; 4978 :     }
; 4979 :     return result;

  00091	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]

; 4980 : }

  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	c3		 ret	 0
datetime_getstate ENDP
_TEXT	ENDS
PUBLIC	__real@42619a1c74000000
PUBLIC	__real@42341dd760000000
PUBLIC	__real@41ead27480000000
PUBLIC	??_C@_1EE@OIFLALBL@?$AAD?$AAI?$AA1?$AA0?$AA0?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA1?$AA0?$AA0?$AA?$CL?$AA1@ ; `string'
PUBLIC	??_C@_1EE@LCIKPEHE@?$AAD?$AAI?$AA4?$AA0?$AA0?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA4?$AA0?$AA0?$AA?$CL?$AA1@ ; `string'
PUBLIC	??_C@_1DM@FBDDOMDA@?$AAD?$AAI?$AA4?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA4?$AA?$CL?$AA1?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0O@HPLJLMAK@datetime_CAPI?$AA@		; `string'
PUBLIC	??_C@_0BH@HJAJCAAF@datetime?4datetime_CAPI?$AA@	; `string'
PUBLIC	??_C@_08EDKBBHCH@timezone?$AA@			; `string'
PUBLIC	??_C@_09BNCODEBM@timedelta?$AA@			; `string'
PUBLIC	??_C@_08FGNPMIBK@datetime?$AA@			; `string'
PUBLIC	??_C@_07EKPINOGJ@MAXYEAR?$AA@			; `string'
PUBLIC	??_C@_07KMJIHBII@MINYEAR?$AA@			; `string'
PUBLIC	??_C@_03JPHCIIKF@utc?$AA@			; `string'
PUBLIC	??_C@_03LJAEFNNE@max?$AA@			; `string'
PUBLIC	??_C@_03KLIPLJLL@min?$AA@			; `string'
PUBLIC	??_C@_0L@CAGNKJED@resolution?$AA@		; `string'
PUBLIC	PyInit__datetime
EXTRN	PyCapsule_New:PROC
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_AddIntConstant:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyType_Ready:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__datetime DD imagerel $LN52
	DD	imagerel $LN52+2579
	DD	imagerel $unwind$PyInit__datetime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__datetime DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT __real@42619a1c74000000
CONST	SEGMENT
__real@42619a1c74000000 DQ 042619a1c74000000r	; 6.048e+011
CONST	ENDS
;	COMDAT __real@42341dd760000000
CONST	SEGMENT
__real@42341dd760000000 DQ 042341dd760000000r	; 8.64e+010
CONST	ENDS
;	COMDAT __real@41ead27480000000
CONST	SEGMENT
__real@41ead27480000000 DQ 041ead27480000000r	; 3.6e+009
CONST	ENDS
;	COMDAT ??_C@_1EE@OIFLALBL@?$AAD?$AAI?$AA1?$AA0?$AA0?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA1?$AA0?$AA0?$AA?$CL?$AA1@
CONST	SEGMENT
??_C@_1EE@OIFLALBL@?$AAD?$AAI?$AA1?$AA0?$AA0?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA1?$AA0?$AA0?$AA?$CL?$AA1@ DB 'D'
	DB	00H, 'I', 00H, '1', 00H, '0', 00H, '0', 00H, 'Y', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'd', 00H, 'a', 00H, 'y', 00H, 's'
	DB	00H, '_', 00H, 'b', 00H, 'e', 00H, 'f', 00H, 'o', 00H, 'r', 00H
	DB	'e', 00H, '_', 00H, 'y', 00H, 'e', 00H, 'a', 00H, 'r', 00H, '('
	DB	00H, '1', 00H, '0', 00H, '0', 00H, '+', 00H, '1', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@LCIKPEHE@?$AAD?$AAI?$AA4?$AA0?$AA0?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA4?$AA0?$AA0?$AA?$CL?$AA1@
CONST	SEGMENT
??_C@_1EE@LCIKPEHE@?$AAD?$AAI?$AA4?$AA0?$AA0?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA4?$AA0?$AA0?$AA?$CL?$AA1@ DB 'D'
	DB	00H, 'I', 00H, '4', 00H, '0', 00H, '0', 00H, 'Y', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'd', 00H, 'a', 00H, 'y', 00H, 's'
	DB	00H, '_', 00H, 'b', 00H, 'e', 00H, 'f', 00H, 'o', 00H, 'r', 00H
	DB	'e', 00H, '_', 00H, 'y', 00H, 'e', 00H, 'a', 00H, 'r', 00H, '('
	DB	00H, '4', 00H, '0', 00H, '0', 00H, '+', 00H, '1', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@FBDDOMDA@?$AAD?$AAI?$AA4?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA4?$AA?$CL?$AA1?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@FBDDOMDA@?$AAD?$AAI?$AA4?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA4?$AA?$CL?$AA1?$AA?$CJ?$AA?$AA@ DB 'D'
	DB	00H, 'I', 00H, '4', 00H, 'Y', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'd', 00H, 'a', 00H, 'y', 00H, 's', 00H, '_', 00H, 'b'
	DB	00H, 'e', 00H, 'f', 00H, 'o', 00H, 'r', 00H, 'e', 00H, '_', 00H
	DB	'y', 00H, 'e', 00H, 'a', 00H, 'r', 00H, '(', 00H, '4', 00H, '+'
	DB	00H, '1', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HPLJLMAK@datetime_CAPI?$AA@
CONST	SEGMENT
??_C@_0O@HPLJLMAK@datetime_CAPI?$AA@ DB 'datetime_CAPI', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@HJAJCAAF@datetime?4datetime_CAPI?$AA@
CONST	SEGMENT
??_C@_0BH@HJAJCAAF@datetime?4datetime_CAPI?$AA@ DB 'datetime.datetime_CAP'
	DB	'I', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_08EDKBBHCH@timezone?$AA@
CONST	SEGMENT
??_C@_08EDKBBHCH@timezone?$AA@ DB 'timezone', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BNCODEBM@timedelta?$AA@
CONST	SEGMENT
??_C@_09BNCODEBM@timedelta?$AA@ DB 'timedelta', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FGNPMIBK@datetime?$AA@
CONST	SEGMENT
??_C@_08FGNPMIBK@datetime?$AA@ DB 'datetime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EKPINOGJ@MAXYEAR?$AA@
CONST	SEGMENT
??_C@_07EKPINOGJ@MAXYEAR?$AA@ DB 'MAXYEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KMJIHBII@MINYEAR?$AA@
CONST	SEGMENT
??_C@_07KMJIHBII@MINYEAR?$AA@ DB 'MINYEAR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JPHCIIKF@utc?$AA@
CONST	SEGMENT
??_C@_03JPHCIIKF@utc?$AA@ DB 'utc', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LJAEFNNE@max?$AA@
CONST	SEGMENT
??_C@_03LJAEFNNE@max?$AA@ DB 'max', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KLIPLJLL@min?$AA@
CONST	SEGMENT
??_C@_03KLIPLJLL@min?$AA@ DB 'min', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CAGNKJED@resolution?$AA@
CONST	SEGMENT
??_C@_0L@CAGNKJED@resolution?$AA@ DB 'resolution', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit__datetime
_TEXT	SEGMENT
x$ = 80
delta$ = 88
d$ = 96
m$ = 104
PyInit__datetime PROC					; COMDAT

; 5170 : {

$LN52:
  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 5171 :     PyObject *m;        /* a module object */
; 5172 :     PyObject *d;        /* its dict */
; 5173 :     PyObject *x;
; 5174 :     PyObject *delta;
; 5175 : 
; 5176 :     m = PyModule_Create(&datetimemodule);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:datetimemodule
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00015	48 89 44 24 68	 mov	 QWORD PTR m$[rsp], rax

; 5177 :     if (m == NULL)

  0001a	48 83 7c 24 68
	00		 cmp	 QWORD PTR m$[rsp], 0
  00020	75 07		 jne	 SHORT $LN46@PyInit__da

; 5178 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 e5 09 00 00	 jmp	 $LN47@PyInit__da
$LN46@PyInit__da:

; 5179 : 
; 5180 :     if (PyType_Ready(&PyDateTime_DateType) < 0)

  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DateType
  00030	e8 00 00 00 00	 call	 PyType_Ready
  00035	85 c0		 test	 eax, eax
  00037	7d 07		 jge	 SHORT $LN45@PyInit__da

; 5181 :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 ce 09 00 00	 jmp	 $LN47@PyInit__da
$LN45@PyInit__da:

; 5182 :     if (PyType_Ready(&PyDateTime_DateTimeType) < 0)

  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DateTimeType
  00047	e8 00 00 00 00	 call	 PyType_Ready
  0004c	85 c0		 test	 eax, eax
  0004e	7d 07		 jge	 SHORT $LN44@PyInit__da

; 5183 :         return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	e9 b7 09 00 00	 jmp	 $LN47@PyInit__da
$LN44@PyInit__da:

; 5184 :     if (PyType_Ready(&PyDateTime_DeltaType) < 0)

  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DeltaType
  0005e	e8 00 00 00 00	 call	 PyType_Ready
  00063	85 c0		 test	 eax, eax
  00065	7d 07		 jge	 SHORT $LN43@PyInit__da

; 5185 :         return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	e9 a0 09 00 00	 jmp	 $LN47@PyInit__da
$LN43@PyInit__da:

; 5186 :     if (PyType_Ready(&PyDateTime_TimeType) < 0)

  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_TimeType
  00075	e8 00 00 00 00	 call	 PyType_Ready
  0007a	85 c0		 test	 eax, eax
  0007c	7d 07		 jge	 SHORT $LN42@PyInit__da

; 5187 :         return NULL;

  0007e	33 c0		 xor	 eax, eax
  00080	e9 89 09 00 00	 jmp	 $LN47@PyInit__da
$LN42@PyInit__da:

; 5188 :     if (PyType_Ready(&PyDateTime_TZInfoType) < 0)

  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_TZInfoType
  0008c	e8 00 00 00 00	 call	 PyType_Ready
  00091	85 c0		 test	 eax, eax
  00093	7d 07		 jge	 SHORT $LN41@PyInit__da

; 5189 :         return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	e9 72 09 00 00	 jmp	 $LN47@PyInit__da
$LN41@PyInit__da:

; 5190 :     if (PyType_Ready(&PyDateTime_TimeZoneType) < 0)

  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_TimeZoneType
  000a3	e8 00 00 00 00	 call	 PyType_Ready
  000a8	85 c0		 test	 eax, eax
  000aa	7d 07		 jge	 SHORT $LN40@PyInit__da

; 5191 :         return NULL;

  000ac	33 c0		 xor	 eax, eax
  000ae	e9 5b 09 00 00	 jmp	 $LN47@PyInit__da
$LN40@PyInit__da:

; 5192 : 
; 5193 :     /* timedelta values */
; 5194 :     d = PyDateTime_DeltaType.tp_dict;

  000b3	48 8b 05 60 01
	00 00		 mov	 rax, QWORD PTR PyDateTime_DeltaType+352
  000ba	48 89 44 24 60	 mov	 QWORD PTR d$[rsp], rax

; 5195 : 
; 5196 :     x = new_delta(0, 0, 1, 0);

  000bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  000c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cb	45 33 c9	 xor	 r9d, r9d
  000ce	41 b8 01 00 00
	00		 mov	 r8d, 1
  000d4	33 d2		 xor	 edx, edx
  000d6	33 c9		 xor	 ecx, ecx
  000d8	e8 00 00 00 00	 call	 new_delta_ex
  000dd	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5197 :     if (x == NULL || PyDict_SetItemString(d, "resolution", x) < 0)

  000e2	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  000e8	74 1a		 je	 SHORT $LN38@PyInit__da
  000ea	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  000ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@CAGNKJED@resolution?$AA@
  000f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  000fb	e8 00 00 00 00	 call	 PyDict_SetItemString
  00100	85 c0		 test	 eax, eax
  00102	7d 07		 jge	 SHORT $LN39@PyInit__da
$LN38@PyInit__da:

; 5198 :         return NULL;

  00104	33 c0		 xor	 eax, eax
  00106	e9 03 09 00 00	 jmp	 $LN47@PyInit__da
$LN39@PyInit__da:

; 5199 :     Py_DECREF(x);

  0010b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  00110	e8 00 00 00 00	 call	 _Py_DecRef

; 5200 : 
; 5201 :     x = new_delta(-MAX_DELTA_DAYS, 0, 0, 0);

  00115	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  0011c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00121	45 33 c9	 xor	 r9d, r9d
  00124	45 33 c0	 xor	 r8d, r8d
  00127	33 d2		 xor	 edx, edx
  00129	b9 01 36 65 c4	 mov	 ecx, -999999999		; ffffffffc4653601H
  0012e	e8 00 00 00 00	 call	 new_delta_ex
  00133	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5202 :     if (x == NULL || PyDict_SetItemString(d, "min", x) < 0)

  00138	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  0013e	74 1a		 je	 SHORT $LN36@PyInit__da
  00140	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KLIPLJLL@min?$AA@
  0014c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  00151	e8 00 00 00 00	 call	 PyDict_SetItemString
  00156	85 c0		 test	 eax, eax
  00158	7d 07		 jge	 SHORT $LN37@PyInit__da
$LN36@PyInit__da:

; 5203 :         return NULL;

  0015a	33 c0		 xor	 eax, eax
  0015c	e9 ad 08 00 00	 jmp	 $LN47@PyInit__da
$LN37@PyInit__da:

; 5204 :     Py_DECREF(x);

  00161	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  00166	e8 00 00 00 00	 call	 _Py_DecRef

; 5205 : 
; 5206 :     x = new_delta(MAX_DELTA_DAYS, 24*3600-1, 1000000-1, 0);

  0016b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00172	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00177	45 33 c9	 xor	 r9d, r9d
  0017a	41 b8 3f 42 0f
	00		 mov	 r8d, 999999		; 000f423fH
  00180	ba 7f 51 01 00	 mov	 edx, 86399		; 0001517fH
  00185	b9 ff c9 9a 3b	 mov	 ecx, 999999999		; 3b9ac9ffH
  0018a	e8 00 00 00 00	 call	 new_delta_ex
  0018f	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5207 :     if (x == NULL || PyDict_SetItemString(d, "max", x) < 0)

  00194	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  0019a	74 1a		 je	 SHORT $LN34@PyInit__da
  0019c	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  001a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LJAEFNNE@max?$AA@
  001a8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  001ad	e8 00 00 00 00	 call	 PyDict_SetItemString
  001b2	85 c0		 test	 eax, eax
  001b4	7d 07		 jge	 SHORT $LN35@PyInit__da
$LN34@PyInit__da:

; 5208 :         return NULL;

  001b6	33 c0		 xor	 eax, eax
  001b8	e9 51 08 00 00	 jmp	 $LN47@PyInit__da
$LN35@PyInit__da:

; 5209 :     Py_DECREF(x);

  001bd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  001c2	e8 00 00 00 00	 call	 _Py_DecRef

; 5210 : 
; 5211 :     /* date values */
; 5212 :     d = PyDateTime_DateType.tp_dict;

  001c7	48 8b 05 60 01
	00 00		 mov	 rax, QWORD PTR PyDateTime_DateType+352
  001ce	48 89 44 24 60	 mov	 QWORD PTR d$[rsp], rax

; 5213 : 
; 5214 :     x = new_date(1, 1, 1);

  001d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_DateType
  001da	41 b8 01 00 00
	00		 mov	 r8d, 1
  001e0	ba 01 00 00 00	 mov	 edx, 1
  001e5	b9 01 00 00 00	 mov	 ecx, 1
  001ea	e8 00 00 00 00	 call	 new_date_ex
  001ef	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5215 :     if (x == NULL || PyDict_SetItemString(d, "min", x) < 0)

  001f4	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  001fa	74 1a		 je	 SHORT $LN32@PyInit__da
  001fc	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  00201	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KLIPLJLL@min?$AA@
  00208	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  0020d	e8 00 00 00 00	 call	 PyDict_SetItemString
  00212	85 c0		 test	 eax, eax
  00214	7d 07		 jge	 SHORT $LN33@PyInit__da
$LN32@PyInit__da:

; 5216 :         return NULL;

  00216	33 c0		 xor	 eax, eax
  00218	e9 f1 07 00 00	 jmp	 $LN47@PyInit__da
$LN33@PyInit__da:

; 5217 :     Py_DECREF(x);

  0021d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  00222	e8 00 00 00 00	 call	 _Py_DecRef

; 5218 : 
; 5219 :     x = new_date(MAXYEAR, 12, 31);

  00227	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyDateTime_DateType
  0022e	41 b8 1f 00 00
	00		 mov	 r8d, 31
  00234	ba 0c 00 00 00	 mov	 edx, 12
  00239	b9 0f 27 00 00	 mov	 ecx, 9999		; 0000270fH
  0023e	e8 00 00 00 00	 call	 new_date_ex
  00243	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5220 :     if (x == NULL || PyDict_SetItemString(d, "max", x) < 0)

  00248	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  0024e	74 1a		 je	 SHORT $LN30@PyInit__da
  00250	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  00255	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LJAEFNNE@max?$AA@
  0025c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  00261	e8 00 00 00 00	 call	 PyDict_SetItemString
  00266	85 c0		 test	 eax, eax
  00268	7d 07		 jge	 SHORT $LN31@PyInit__da
$LN30@PyInit__da:

; 5221 :         return NULL;

  0026a	33 c0		 xor	 eax, eax
  0026c	e9 9d 07 00 00	 jmp	 $LN47@PyInit__da
$LN31@PyInit__da:

; 5222 :     Py_DECREF(x);

  00271	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  00276	e8 00 00 00 00	 call	 _Py_DecRef

; 5223 : 
; 5224 :     x = new_delta(1, 0, 0, 0);

  0027b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00282	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00287	45 33 c9	 xor	 r9d, r9d
  0028a	45 33 c0	 xor	 r8d, r8d
  0028d	33 d2		 xor	 edx, edx
  0028f	b9 01 00 00 00	 mov	 ecx, 1
  00294	e8 00 00 00 00	 call	 new_delta_ex
  00299	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5225 :     if (x == NULL || PyDict_SetItemString(d, "resolution", x) < 0)

  0029e	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  002a4	74 1a		 je	 SHORT $LN28@PyInit__da
  002a6	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  002ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@CAGNKJED@resolution?$AA@
  002b2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  002b7	e8 00 00 00 00	 call	 PyDict_SetItemString
  002bc	85 c0		 test	 eax, eax
  002be	7d 07		 jge	 SHORT $LN29@PyInit__da
$LN28@PyInit__da:

; 5226 :         return NULL;

  002c0	33 c0		 xor	 eax, eax
  002c2	e9 47 07 00 00	 jmp	 $LN47@PyInit__da
$LN29@PyInit__da:

; 5227 :     Py_DECREF(x);

  002c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  002cc	e8 00 00 00 00	 call	 _Py_DecRef

; 5228 : 
; 5229 :     /* time values */
; 5230 :     d = PyDateTime_TimeType.tp_dict;

  002d1	48 8b 05 60 01
	00 00		 mov	 rax, QWORD PTR PyDateTime_TimeType+352
  002d8	48 89 44 24 60	 mov	 QWORD PTR d$[rsp], rax

; 5231 : 
; 5232 :     x = new_time(0, 0, 0, 0, Py_None);

  002dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TimeType
  002e4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  002f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f5	45 33 c9	 xor	 r9d, r9d
  002f8	45 33 c0	 xor	 r8d, r8d
  002fb	33 d2		 xor	 edx, edx
  002fd	33 c9		 xor	 ecx, ecx
  002ff	e8 00 00 00 00	 call	 new_time_ex
  00304	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5233 :     if (x == NULL || PyDict_SetItemString(d, "min", x) < 0)

  00309	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  0030f	74 1a		 je	 SHORT $LN26@PyInit__da
  00311	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  00316	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KLIPLJLL@min?$AA@
  0031d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  00322	e8 00 00 00 00	 call	 PyDict_SetItemString
  00327	85 c0		 test	 eax, eax
  00329	7d 07		 jge	 SHORT $LN27@PyInit__da
$LN26@PyInit__da:

; 5234 :         return NULL;

  0032b	33 c0		 xor	 eax, eax
  0032d	e9 dc 06 00 00	 jmp	 $LN47@PyInit__da
$LN27@PyInit__da:

; 5235 :     Py_DECREF(x);

  00332	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  00337	e8 00 00 00 00	 call	 _Py_DecRef

; 5236 : 
; 5237 :     x = new_time(23, 59, 59, 999999, Py_None);

  0033c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_TimeType
  00343	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00348	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0034f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00354	41 b9 3f 42 0f
	00		 mov	 r9d, 999999		; 000f423fH
  0035a	41 b8 3b 00 00
	00		 mov	 r8d, 59			; 0000003bH
  00360	ba 3b 00 00 00	 mov	 edx, 59			; 0000003bH
  00365	b9 17 00 00 00	 mov	 ecx, 23
  0036a	e8 00 00 00 00	 call	 new_time_ex
  0036f	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5238 :     if (x == NULL || PyDict_SetItemString(d, "max", x) < 0)

  00374	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  0037a	74 1a		 je	 SHORT $LN24@PyInit__da
  0037c	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  00381	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LJAEFNNE@max?$AA@
  00388	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  0038d	e8 00 00 00 00	 call	 PyDict_SetItemString
  00392	85 c0		 test	 eax, eax
  00394	7d 07		 jge	 SHORT $LN25@PyInit__da
$LN24@PyInit__da:

; 5239 :         return NULL;

  00396	33 c0		 xor	 eax, eax
  00398	e9 71 06 00 00	 jmp	 $LN47@PyInit__da
$LN25@PyInit__da:

; 5240 :     Py_DECREF(x);

  0039d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  003a2	e8 00 00 00 00	 call	 _Py_DecRef

; 5241 : 
; 5242 :     x = new_delta(0, 0, 1, 0);

  003a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  003ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b3	45 33 c9	 xor	 r9d, r9d
  003b6	41 b8 01 00 00
	00		 mov	 r8d, 1
  003bc	33 d2		 xor	 edx, edx
  003be	33 c9		 xor	 ecx, ecx
  003c0	e8 00 00 00 00	 call	 new_delta_ex
  003c5	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5243 :     if (x == NULL || PyDict_SetItemString(d, "resolution", x) < 0)

  003ca	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  003d0	74 1a		 je	 SHORT $LN22@PyInit__da
  003d2	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  003d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@CAGNKJED@resolution?$AA@
  003de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  003e3	e8 00 00 00 00	 call	 PyDict_SetItemString
  003e8	85 c0		 test	 eax, eax
  003ea	7d 07		 jge	 SHORT $LN23@PyInit__da
$LN22@PyInit__da:

; 5244 :         return NULL;

  003ec	33 c0		 xor	 eax, eax
  003ee	e9 1b 06 00 00	 jmp	 $LN47@PyInit__da
$LN23@PyInit__da:

; 5245 :     Py_DECREF(x);

  003f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  003f8	e8 00 00 00 00	 call	 _Py_DecRef

; 5246 : 
; 5247 :     /* datetime values */
; 5248 :     d = PyDateTime_DateTimeType.tp_dict;

  003fd	48 8b 05 60 01
	00 00		 mov	 rax, QWORD PTR PyDateTime_DateTimeType+352
  00404	48 89 44 24 60	 mov	 QWORD PTR d$[rsp], rax

; 5249 : 
; 5250 :     x = new_datetime(1, 1, 1, 0, 0, 0, 0, Py_None);

  00409	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00410	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00415	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0041c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00421	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00429	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00431	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00439	45 33 c9	 xor	 r9d, r9d
  0043c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00442	ba 01 00 00 00	 mov	 edx, 1
  00447	b9 01 00 00 00	 mov	 ecx, 1
  0044c	e8 00 00 00 00	 call	 new_datetime_ex
  00451	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5251 :     if (x == NULL || PyDict_SetItemString(d, "min", x) < 0)

  00456	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  0045c	74 1a		 je	 SHORT $LN20@PyInit__da
  0045e	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  00463	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KLIPLJLL@min?$AA@
  0046a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  0046f	e8 00 00 00 00	 call	 PyDict_SetItemString
  00474	85 c0		 test	 eax, eax
  00476	7d 07		 jge	 SHORT $LN21@PyInit__da
$LN20@PyInit__da:

; 5252 :         return NULL;

  00478	33 c0		 xor	 eax, eax
  0047a	e9 8f 05 00 00	 jmp	 $LN47@PyInit__da
$LN21@PyInit__da:

; 5253 :     Py_DECREF(x);

  0047f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  00484	e8 00 00 00 00	 call	 _Py_DecRef

; 5254 : 
; 5255 :     x = new_datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999, Py_None);

  00489	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  00490	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00495	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0049c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  004a1	c7 44 24 30 3f
	42 0f 00	 mov	 DWORD PTR [rsp+48], 999999 ; 000f423fH
  004a9	c7 44 24 28 3b
	00 00 00	 mov	 DWORD PTR [rsp+40], 59	; 0000003bH
  004b1	c7 44 24 20 3b
	00 00 00	 mov	 DWORD PTR [rsp+32], 59	; 0000003bH
  004b9	41 b9 17 00 00
	00		 mov	 r9d, 23
  004bf	41 b8 1f 00 00
	00		 mov	 r8d, 31
  004c5	ba 0c 00 00 00	 mov	 edx, 12
  004ca	b9 0f 27 00 00	 mov	 ecx, 9999		; 0000270fH
  004cf	e8 00 00 00 00	 call	 new_datetime_ex
  004d4	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5256 :     if (x == NULL || PyDict_SetItemString(d, "max", x) < 0)

  004d9	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  004df	74 1a		 je	 SHORT $LN18@PyInit__da
  004e1	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  004e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LJAEFNNE@max?$AA@
  004ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  004f2	e8 00 00 00 00	 call	 PyDict_SetItemString
  004f7	85 c0		 test	 eax, eax
  004f9	7d 07		 jge	 SHORT $LN19@PyInit__da
$LN18@PyInit__da:

; 5257 :         return NULL;

  004fb	33 c0		 xor	 eax, eax
  004fd	e9 0c 05 00 00	 jmp	 $LN47@PyInit__da
$LN19@PyInit__da:

; 5258 :     Py_DECREF(x);

  00502	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  00507	e8 00 00 00 00	 call	 _Py_DecRef

; 5259 : 
; 5260 :     x = new_delta(0, 0, 1, 0);

  0050c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00513	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00518	45 33 c9	 xor	 r9d, r9d
  0051b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00521	33 d2		 xor	 edx, edx
  00523	33 c9		 xor	 ecx, ecx
  00525	e8 00 00 00 00	 call	 new_delta_ex
  0052a	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5261 :     if (x == NULL || PyDict_SetItemString(d, "resolution", x) < 0)

  0052f	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  00535	74 1a		 je	 SHORT $LN16@PyInit__da
  00537	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  0053c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@CAGNKJED@resolution?$AA@
  00543	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  00548	e8 00 00 00 00	 call	 PyDict_SetItemString
  0054d	85 c0		 test	 eax, eax
  0054f	7d 07		 jge	 SHORT $LN17@PyInit__da
$LN16@PyInit__da:

; 5262 :         return NULL;

  00551	33 c0		 xor	 eax, eax
  00553	e9 b6 04 00 00	 jmp	 $LN47@PyInit__da
$LN17@PyInit__da:

; 5263 :     Py_DECREF(x);

  00558	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  0055d	e8 00 00 00 00	 call	 _Py_DecRef

; 5264 : 
; 5265 :     /* timezone values */
; 5266 :     d = PyDateTime_TimeZoneType.tp_dict;

  00562	48 8b 05 60 01
	00 00		 mov	 rax, QWORD PTR PyDateTime_TimeZoneType+352
  00569	48 89 44 24 60	 mov	 QWORD PTR d$[rsp], rax

; 5267 : 
; 5268 :     delta = new_delta(0, 0, 0, 0);

  0056e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  00575	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0057a	45 33 c9	 xor	 r9d, r9d
  0057d	45 33 c0	 xor	 r8d, r8d
  00580	33 d2		 xor	 edx, edx
  00582	33 c9		 xor	 ecx, ecx
  00584	e8 00 00 00 00	 call	 new_delta_ex
  00589	48 89 44 24 58	 mov	 QWORD PTR delta$[rsp], rax

; 5269 :     if (delta == NULL)

  0058e	48 83 7c 24 58
	00		 cmp	 QWORD PTR delta$[rsp], 0
  00594	75 07		 jne	 SHORT $LN15@PyInit__da

; 5270 :         return NULL;

  00596	33 c0		 xor	 eax, eax
  00598	e9 71 04 00 00	 jmp	 $LN47@PyInit__da
$LN15@PyInit__da:

; 5271 :     x = create_timezone(delta, NULL);

  0059d	33 d2		 xor	 edx, edx
  0059f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR delta$[rsp]
  005a4	e8 00 00 00 00	 call	 create_timezone
  005a9	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5272 :     Py_DECREF(delta);

  005ae	48 8b 4c 24 58	 mov	 rcx, QWORD PTR delta$[rsp]
  005b3	e8 00 00 00 00	 call	 _Py_DecRef

; 5273 :     if (x == NULL || PyDict_SetItemString(d, "utc", x) < 0)

  005b8	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  005be	74 1a		 je	 SHORT $LN13@PyInit__da
  005c0	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  005c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JPHCIIKF@utc?$AA@
  005cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  005d1	e8 00 00 00 00	 call	 PyDict_SetItemString
  005d6	85 c0		 test	 eax, eax
  005d8	7d 07		 jge	 SHORT $LN14@PyInit__da
$LN13@PyInit__da:

; 5274 :         return NULL;

  005da	33 c0		 xor	 eax, eax
  005dc	e9 2d 04 00 00	 jmp	 $LN47@PyInit__da
$LN14@PyInit__da:

; 5275 :     PyDateTime_TimeZone_UTC = x;

  005e1	48 8b 44 24 50	 mov	 rax, QWORD PTR x$[rsp]
  005e6	48 89 05 00 00
	00 00		 mov	 QWORD PTR PyDateTime_TimeZone_UTC, rax

; 5276 : 
; 5277 :     delta = new_delta(-1, 60, 0, 1); /* -23:59 */

  005ed	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  005f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f9	41 b9 01 00 00
	00		 mov	 r9d, 1
  005ff	45 33 c0	 xor	 r8d, r8d
  00602	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00607	b9 ff ff ff ff	 mov	 ecx, -1
  0060c	e8 00 00 00 00	 call	 new_delta_ex
  00611	48 89 44 24 58	 mov	 QWORD PTR delta$[rsp], rax

; 5278 :     if (delta == NULL)

  00616	48 83 7c 24 58
	00		 cmp	 QWORD PTR delta$[rsp], 0
  0061c	75 07		 jne	 SHORT $LN12@PyInit__da

; 5279 :         return NULL;

  0061e	33 c0		 xor	 eax, eax
  00620	e9 e9 03 00 00	 jmp	 $LN47@PyInit__da
$LN12@PyInit__da:

; 5280 :     x = create_timezone(delta, NULL);

  00625	33 d2		 xor	 edx, edx
  00627	48 8b 4c 24 58	 mov	 rcx, QWORD PTR delta$[rsp]
  0062c	e8 00 00 00 00	 call	 create_timezone
  00631	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5281 :     Py_DECREF(delta);

  00636	48 8b 4c 24 58	 mov	 rcx, QWORD PTR delta$[rsp]
  0063b	e8 00 00 00 00	 call	 _Py_DecRef

; 5282 :     if (x == NULL || PyDict_SetItemString(d, "min", x) < 0)

  00640	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  00646	74 1a		 je	 SHORT $LN10@PyInit__da
  00648	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  0064d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03KLIPLJLL@min?$AA@
  00654	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  00659	e8 00 00 00 00	 call	 PyDict_SetItemString
  0065e	85 c0		 test	 eax, eax
  00660	7d 07		 jge	 SHORT $LN11@PyInit__da
$LN10@PyInit__da:

; 5283 :         return NULL;

  00662	33 c0		 xor	 eax, eax
  00664	e9 a5 03 00 00	 jmp	 $LN47@PyInit__da
$LN11@PyInit__da:

; 5284 :     Py_DECREF(x);

  00669	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  0066e	e8 00 00 00 00	 call	 _Py_DecRef

; 5285 : 
; 5286 :     delta = new_delta(0, (23 * 60 + 59) * 60, 0, 0); /* +23:59 */

  00673	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DeltaType
  0067a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0067f	45 33 c9	 xor	 r9d, r9d
  00682	45 33 c0	 xor	 r8d, r8d
  00685	ba 44 51 01 00	 mov	 edx, 86340		; 00015144H
  0068a	33 c9		 xor	 ecx, ecx
  0068c	e8 00 00 00 00	 call	 new_delta_ex
  00691	48 89 44 24 58	 mov	 QWORD PTR delta$[rsp], rax

; 5287 :     if (delta == NULL)

  00696	48 83 7c 24 58
	00		 cmp	 QWORD PTR delta$[rsp], 0
  0069c	75 07		 jne	 SHORT $LN9@PyInit__da

; 5288 :         return NULL;

  0069e	33 c0		 xor	 eax, eax
  006a0	e9 69 03 00 00	 jmp	 $LN47@PyInit__da
$LN9@PyInit__da:

; 5289 :     x = create_timezone(delta, NULL);

  006a5	33 d2		 xor	 edx, edx
  006a7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR delta$[rsp]
  006ac	e8 00 00 00 00	 call	 create_timezone
  006b1	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5290 :     Py_DECREF(delta);

  006b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR delta$[rsp]
  006bb	e8 00 00 00 00	 call	 _Py_DecRef

; 5291 :     if (x == NULL || PyDict_SetItemString(d, "max", x) < 0)

  006c0	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  006c6	74 1a		 je	 SHORT $LN7@PyInit__da
  006c8	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  006cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LJAEFNNE@max?$AA@
  006d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR d$[rsp]
  006d9	e8 00 00 00 00	 call	 PyDict_SetItemString
  006de	85 c0		 test	 eax, eax
  006e0	7d 07		 jge	 SHORT $LN8@PyInit__da
$LN7@PyInit__da:

; 5292 :         return NULL;

  006e2	33 c0		 xor	 eax, eax
  006e4	e9 25 03 00 00	 jmp	 $LN47@PyInit__da
$LN8@PyInit__da:

; 5293 :     Py_DECREF(x);

  006e9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR x$[rsp]
  006ee	e8 00 00 00 00	 call	 _Py_DecRef

; 5294 : 
; 5295 :     /* Epoch */
; 5296 :     PyDateTime_Epoch = new_datetime(1970, 1, 1, 0, 0, 0, 0,
; 5297 :                                     PyDateTime_TimeZone_UTC);

  006f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDateTime_DateTimeType
  006fa	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  006ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR PyDateTime_TimeZone_UTC
  00706	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0070b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00713	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0071b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00723	45 33 c9	 xor	 r9d, r9d
  00726	41 b8 01 00 00
	00		 mov	 r8d, 1
  0072c	ba 01 00 00 00	 mov	 edx, 1
  00731	b9 b2 07 00 00	 mov	 ecx, 1970		; 000007b2H
  00736	e8 00 00 00 00	 call	 new_datetime_ex
  0073b	48 89 05 00 00
	00 00		 mov	 QWORD PTR PyDateTime_Epoch, rax

; 5298 :     if (PyDateTime_Epoch == NULL)

  00742	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR PyDateTime_Epoch, 0
  0074a	75 07		 jne	 SHORT $LN6@PyInit__da

; 5299 :       return NULL;

  0074c	33 c0		 xor	 eax, eax
  0074e	e9 bb 02 00 00	 jmp	 $LN47@PyInit__da
$LN6@PyInit__da:

; 5300 : 
; 5301 :     /* module initialization */
; 5302 :     PyModule_AddIntConstant(m, "MINYEAR", MINYEAR);

  00753	41 b8 01 00 00
	00		 mov	 r8d, 1
  00759	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KMJIHBII@MINYEAR?$AA@
  00760	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m$[rsp]
  00765	e8 00 00 00 00	 call	 PyModule_AddIntConstant

; 5303 :     PyModule_AddIntConstant(m, "MAXYEAR", MAXYEAR);

  0076a	41 b8 0f 27 00
	00		 mov	 r8d, 9999		; 0000270fH
  00770	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EKPINOGJ@MAXYEAR?$AA@
  00777	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m$[rsp]
  0077c	e8 00 00 00 00	 call	 PyModule_AddIntConstant

; 5304 : 
; 5305 :     Py_INCREF(&PyDateTime_DateType);

  00781	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DateType
  00788	e8 00 00 00 00	 call	 _Py_IncRef

; 5306 :     PyModule_AddObject(m, "date", (PyObject *) &PyDateTime_DateType);

  0078d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyDateTime_DateType
  00794	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04JNIHBGGH@date?$AA@
  0079b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m$[rsp]
  007a0	e8 00 00 00 00	 call	 PyModule_AddObject

; 5307 : 
; 5308 :     Py_INCREF(&PyDateTime_DateTimeType);

  007a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DateTimeType
  007ac	e8 00 00 00 00	 call	 _Py_IncRef

; 5309 :     PyModule_AddObject(m, "datetime",
; 5310 :                        (PyObject *)&PyDateTime_DateTimeType);

  007b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyDateTime_DateTimeType
  007b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08FGNPMIBK@datetime?$AA@
  007bf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m$[rsp]
  007c4	e8 00 00 00 00	 call	 PyModule_AddObject

; 5311 : 
; 5312 :     Py_INCREF(&PyDateTime_TimeType);

  007c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_TimeType
  007d0	e8 00 00 00 00	 call	 _Py_IncRef

; 5313 :     PyModule_AddObject(m, "time", (PyObject *) &PyDateTime_TimeType);

  007d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyDateTime_TimeType
  007dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04CLCEDBPF@time?$AA@
  007e3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m$[rsp]
  007e8	e8 00 00 00 00	 call	 PyModule_AddObject

; 5314 : 
; 5315 :     Py_INCREF(&PyDateTime_DeltaType);

  007ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_DeltaType
  007f4	e8 00 00 00 00	 call	 _Py_IncRef

; 5316 :     PyModule_AddObject(m, "timedelta", (PyObject *) &PyDateTime_DeltaType);

  007f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyDateTime_DeltaType
  00800	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09BNCODEBM@timedelta?$AA@
  00807	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m$[rsp]
  0080c	e8 00 00 00 00	 call	 PyModule_AddObject

; 5317 : 
; 5318 :     Py_INCREF(&PyDateTime_TZInfoType);

  00811	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_TZInfoType
  00818	e8 00 00 00 00	 call	 _Py_IncRef

; 5319 :     PyModule_AddObject(m, "tzinfo", (PyObject *) &PyDateTime_TZInfoType);

  0081d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyDateTime_TZInfoType
  00824	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06DBOJKPOI@tzinfo?$AA@
  0082b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m$[rsp]
  00830	e8 00 00 00 00	 call	 PyModule_AddObject

; 5320 : 
; 5321 :     Py_INCREF(&PyDateTime_TimeZoneType);

  00835	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyDateTime_TimeZoneType
  0083c	e8 00 00 00 00	 call	 _Py_IncRef

; 5322 :     PyModule_AddObject(m, "timezone", (PyObject *) &PyDateTime_TimeZoneType);

  00841	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyDateTime_TimeZoneType
  00848	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08EDKBBHCH@timezone?$AA@
  0084f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m$[rsp]
  00854	e8 00 00 00 00	 call	 PyModule_AddObject

; 5323 : 
; 5324 :     x = PyCapsule_New(&CAPI, PyDateTime_CAPSULE_NAME, NULL);

  00859	45 33 c0	 xor	 r8d, r8d
  0085c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@HJAJCAAF@datetime?4datetime_CAPI?$AA@
  00863	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CAPI
  0086a	e8 00 00 00 00	 call	 PyCapsule_New
  0086f	48 89 44 24 50	 mov	 QWORD PTR x$[rsp], rax

; 5325 :     if (x == NULL)

  00874	48 83 7c 24 50
	00		 cmp	 QWORD PTR x$[rsp], 0
  0087a	75 07		 jne	 SHORT $LN5@PyInit__da

; 5326 :         return NULL;

  0087c	33 c0		 xor	 eax, eax
  0087e	e9 8b 01 00 00	 jmp	 $LN47@PyInit__da
$LN5@PyInit__da:

; 5327 :     PyModule_AddObject(m, "datetime_CAPI", x);

  00883	4c 8b 44 24 50	 mov	 r8, QWORD PTR x$[rsp]
  00888	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@HPLJLMAK@datetime_CAPI?$AA@
  0088f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR m$[rsp]
  00894	e8 00 00 00 00	 call	 PyModule_AddObject

; 5328 : 
; 5329 :     /* A 4-year cycle has an extra leap day over what we'd get from
; 5330 :      * pasting together 4 single years.
; 5331 :      */
; 5332 :     assert(DI4Y == 4 * 365 + 1);
; 5333 :     assert(DI4Y == days_before_year(4+1));

  00899	b9 05 00 00 00	 mov	 ecx, 5
  0089e	e8 00 00 00 00	 call	 days_before_year
  008a3	3d b5 05 00 00	 cmp	 eax, 1461		; 000005b5H
  008a8	74 1c		 je	 SHORT $LN49@PyInit__da
  008aa	41 b8 d5 14 00
	00		 mov	 r8d, 5333		; 000014d5H
  008b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  008b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@FBDDOMDA@?$AAD?$AAI?$AA4?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA4?$AA?$CL?$AA1?$AA?$CJ?$AA?$AA@
  008be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  008c4	33 c0		 xor	 eax, eax
$LN49@PyInit__da:

; 5334 : 
; 5335 :     /* Similarly, a 400-year cycle has an extra leap day over what we'd
; 5336 :      * get from pasting together 4 100-year cycles.
; 5337 :      */
; 5338 :     assert(DI400Y == 4 * DI100Y + 1);
; 5339 :     assert(DI400Y == days_before_year(400+1));

  008c6	b9 91 01 00 00	 mov	 ecx, 401		; 00000191H
  008cb	e8 00 00 00 00	 call	 days_before_year
  008d0	3d b1 3a 02 00	 cmp	 eax, 146097		; 00023ab1H
  008d5	74 1c		 je	 SHORT $LN50@PyInit__da
  008d7	41 b8 db 14 00
	00		 mov	 r8d, 5339		; 000014dbH
  008dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  008e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@LCIKPEHE@?$AAD?$AAI?$AA4?$AA0?$AA0?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA4?$AA0?$AA0?$AA?$CL?$AA1@
  008eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  008f1	33 c0		 xor	 eax, eax
$LN50@PyInit__da:

; 5340 : 
; 5341 :     /* OTOH, a 100-year cycle has one fewer leap day than we'd get from
; 5342 :      * pasting together 25 4-year cycles.
; 5343 :      */
; 5344 :     assert(DI100Y == 25 * DI4Y - 1);
; 5345 :     assert(DI100Y == days_before_year(100+1));

  008f3	b9 65 00 00 00	 mov	 ecx, 101		; 00000065H
  008f8	e8 00 00 00 00	 call	 days_before_year
  008fd	3d ac 8e 00 00	 cmp	 eax, 36524		; 00008eacH
  00902	74 1c		 je	 SHORT $LN51@PyInit__da
  00904	41 b8 e1 14 00
	00		 mov	 r8d, 5345		; 000014e1H
  0090a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@MIHLFJMJ@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAd?$AAa?$AAt?$AAe?$AAt?$AAi?$AAm?$AAe?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00911	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@OIFLALBL@?$AAD?$AAI?$AA1?$AA0?$AA0?$AAY?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAd?$AAa?$AAy?$AAs?$AA_?$AAb?$AAe?$AAf?$AAo?$AAr?$AAe?$AA_?$AAy?$AAe?$AAa?$AAr?$AA?$CI?$AA1?$AA0?$AA0?$AA?$CL?$AA1@
  00918	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0091e	33 c0		 xor	 eax, eax
$LN51@PyInit__da:

; 5346 : 
; 5347 :     us_per_us = PyLong_FromLong(1);

  00920	b9 01 00 00 00	 mov	 ecx, 1
  00925	e8 00 00 00 00	 call	 PyLong_FromLong
  0092a	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_us, rax

; 5348 :     us_per_ms = PyLong_FromLong(1000);

  00931	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00936	e8 00 00 00 00	 call	 PyLong_FromLong
  0093b	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_ms, rax

; 5349 :     us_per_second = PyLong_FromLong(1000000);

  00942	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00947	e8 00 00 00 00	 call	 PyLong_FromLong
  0094c	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_second, rax

; 5350 :     us_per_minute = PyLong_FromLong(60000000);

  00953	b9 00 87 93 03	 mov	 ecx, 60000000		; 03938700H
  00958	e8 00 00 00 00	 call	 PyLong_FromLong
  0095d	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_minute, rax

; 5351 :     seconds_per_day = PyLong_FromLong(24 * 3600);

  00964	b9 80 51 01 00	 mov	 ecx, 86400		; 00015180H
  00969	e8 00 00 00 00	 call	 PyLong_FromLong
  0096e	48 89 05 00 00
	00 00		 mov	 QWORD PTR seconds_per_day, rax

; 5352 :     if (us_per_us == NULL || us_per_ms == NULL || us_per_second == NULL ||
; 5353 :         us_per_minute == NULL || seconds_per_day == NULL)

  00975	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR us_per_us, 0
  0097d	74 28		 je	 SHORT $LN3@PyInit__da
  0097f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR us_per_ms, 0
  00987	74 1e		 je	 SHORT $LN3@PyInit__da
  00989	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR us_per_second, 0
  00991	74 14		 je	 SHORT $LN3@PyInit__da
  00993	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR us_per_minute, 0
  0099b	74 0a		 je	 SHORT $LN3@PyInit__da
  0099d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR seconds_per_day, 0
  009a5	75 04		 jne	 SHORT $LN4@PyInit__da
$LN3@PyInit__da:

; 5354 :         return NULL;

  009a7	33 c0		 xor	 eax, eax
  009a9	eb 63		 jmp	 SHORT $LN47@PyInit__da
$LN4@PyInit__da:

; 5355 : 
; 5356 :     /* The rest are too big for 32-bit ints, but even
; 5357 :      * us_per_week fits in 40 bits, so doubles should be exact.
; 5358 :      */
; 5359 :     us_per_hour = PyLong_FromDouble(3600000000.0);

  009ab	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@41ead27480000000
  009b3	e8 00 00 00 00	 call	 PyLong_FromDouble
  009b8	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_hour, rax

; 5360 :     us_per_day = PyLong_FromDouble(86400000000.0);

  009bf	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@42341dd760000000
  009c7	e8 00 00 00 00	 call	 PyLong_FromDouble
  009cc	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_day, rax

; 5361 :     us_per_week = PyLong_FromDouble(604800000000.0);

  009d3	f2 0f 10 05 00
	00 00 00	 movsdx	 xmm0, QWORD PTR __real@42619a1c74000000
  009db	e8 00 00 00 00	 call	 PyLong_FromDouble
  009e0	48 89 05 00 00
	00 00		 mov	 QWORD PTR us_per_week, rax

; 5362 :     if (us_per_hour == NULL || us_per_day == NULL || us_per_week == NULL)

  009e7	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR us_per_hour, 0
  009ef	74 14		 je	 SHORT $LN1@PyInit__da
  009f1	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR us_per_day, 0
  009f9	74 0a		 je	 SHORT $LN1@PyInit__da
  009fb	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR us_per_week, 0
  00a03	75 04		 jne	 SHORT $LN2@PyInit__da
$LN1@PyInit__da:

; 5363 :         return NULL;

  00a05	33 c0		 xor	 eax, eax
  00a07	eb 05		 jmp	 SHORT $LN47@PyInit__da
$LN2@PyInit__da:

; 5364 :     return m;

  00a09	48 8b 44 24 68	 mov	 rax, QWORD PTR m$[rsp]
$LN47@PyInit__da:

; 5365 : }

  00a0e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00a12	c3		 ret	 0
PyInit__datetime ENDP
_TEXT	ENDS
END
