; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@GNFKBAHD@_io?4FileIO?$AA@		; `string'
PUBLIC	??_C@_0BM@PHALLEFK@String?5giving?5the?5file?5mode?$AA@ ; `string'
PUBLIC	??_C@_0CL@CMPIPNMN@True?5if?5the?5file?5descriptor?5will@ ; `string'
PUBLIC	??_C@_0BL@DEDMGLDL@True?5if?5the?5file?5is?5closed?$AA@ ; `string'
PUBLIC	??_C@_06IKJOPBFO@closed?$AA@			; `string'
PUBLIC	??_C@_0N@NAMJJHIO@__getstate__?$AA@		; `string'
PUBLIC	??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@		; `string'
PUBLIC	??_C@_06BMABDNNN@isatty?$AA@			; `string'
PUBLIC	??_C@_06FFBIALPD@fileno?$AA@			; `string'
PUBLIC	??_C@_08IBOGFJJC@writable?$AA@			; `string'
PUBLIC	??_C@_08INDGGIBD@readable?$AA@			; `string'
PUBLIC	??_C@_08JPFEOKJG@seekable?$AA@			; `string'
PUBLIC	??_C@_08MABILMFG@truncate?$AA@			; `string'
PUBLIC	??_C@_04LBPCFPDD@tell?$AA@			; `string'
PUBLIC	??_C@_04EDECCOGL@seek?$AA@			; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_08BPEKIGCI@readinto?$AA@			; `string'
PUBLIC	??_C@_07JCDFOMC@readall?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_06MNHBHLPO@opener?$AA@			; `string'
PUBLIC	??_C@_07IOEMJIMP@closefd?$AA@			; `string'
PUBLIC	??_C@_04GMGOKAFF@mode?$AA@			; `string'
PUBLIC	??_C@_04DAMGJPCA@file?$AA@			; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
PUBLIC	PyFileIO_Type
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericGetAttr:PROC
;	COMDAT ??_C@_0L@GNFKBAHD@_io?4FileIO?$AA@
CONST	SEGMENT
??_C@_0L@GNFKBAHD@_io?4FileIO?$AA@ DB '_io.FileIO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PHALLEFK@String?5giving?5the?5file?5mode?$AA@
CONST	SEGMENT
??_C@_0BM@PHALLEFK@String?5giving?5the?5file?5mode?$AA@ DB 'String giving'
	DB	' the file mode', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CMPIPNMN@True?5if?5the?5file?5descriptor?5will@
CONST	SEGMENT
??_C@_0CL@CMPIPNMN@True?5if?5the?5file?5descriptor?5will@ DB 'True if the'
	DB	' file descriptor will be closed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DEDMGLDL@True?5if?5the?5file?5is?5closed?$AA@
CONST	SEGMENT
??_C@_0BL@DEDMGLDL@True?5if?5the?5file?5is?5closed?$AA@ DB 'True if the f'
	DB	'ile is closed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJOPBFO@closed?$AA@
CONST	SEGMENT
??_C@_06IKJOPBFO@closed?$AA@ DB 'closed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NAMJJHIO@__getstate__?$AA@
CONST	SEGMENT
??_C@_0N@NAMJJHIO@__getstate__?$AA@ DB '__getstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@
CONST	SEGMENT
??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@ DB '_dealloc_warn', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMABDNNN@isatty?$AA@
CONST	SEGMENT
??_C@_06BMABDNNN@isatty?$AA@ DB 'isatty', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFBIALPD@fileno?$AA@
CONST	SEGMENT
??_C@_06FFBIALPD@fileno?$AA@ DB 'fileno', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IBOGFJJC@writable?$AA@
CONST	SEGMENT
??_C@_08IBOGFJJC@writable?$AA@ DB 'writable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08INDGGIBD@readable?$AA@
CONST	SEGMENT
??_C@_08INDGGIBD@readable?$AA@ DB 'readable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JPFEOKJG@seekable?$AA@
CONST	SEGMENT
??_C@_08JPFEOKJG@seekable?$AA@ DB 'seekable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08MABILMFG@truncate?$AA@
CONST	SEGMENT
??_C@_08MABILMFG@truncate?$AA@ DB 'truncate', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBPCFPDD@tell?$AA@
CONST	SEGMENT
??_C@_04LBPCFPDD@tell?$AA@ DB 'tell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDECCOGL@seek?$AA@
CONST	SEGMENT
??_C@_04EDECCOGL@seek?$AA@ DB 'seek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BPEKIGCI@readinto?$AA@
CONST	SEGMENT
??_C@_08BPEKIGCI@readinto?$AA@ DB 'readinto', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JCDFOMC@readall?$AA@
CONST	SEGMENT
??_C@_07JCDFOMC@readall?$AA@ DB 'readall', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?kwlist@?1??fileio_init@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `fileio_init'::`2'::kwlist
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:??_C@_07IOEMJIMP@closefd?$AA@
	DQ	FLAT:??_C@_06MNHBHLPO@opener?$AA@
	DQ	0000000000000000H
tell_doc DB	'tell() -> int.  Current file position', 00H
	ORG $+2
fileio_doc DB	'file(name: str[, mode: str][, opener: None]) -> file IO '
	DB	'object', 0aH, 0aH, 'Open a file.  The mode can be ''r'', ''w'''
	DB	', ''x'' or ''a'' for reading (default),', 0aH, 'writing, excl'
	DB	'usive creation or appending.  The file will be created if it', 0aH
	DB	'doesn''t exist when opened for writing or appending; it will '
	DB	'be truncated', 0aH, 'when opened for writing.  A `FileExistsE'
	DB	'rror` will be raised if it already', 0aH, 'exists when opened'
	DB	' for creating. Opening a file for creating implies', 0aH, 'wr'
	DB	'iting so this mode behaves in a similar way to ''w''.Add a '''
	DB	'+'' to the mode', 0aH, 'to allow simultaneous reading and wri'
	DB	'ting. A custom opener can be used by', 0aH, 'passing a callab'
	DB	'le as *opener*. The underlying file descriptor for the file', 0aH
	DB	'object is then obtained by calling opener with (*name*, *flag'
	DB	's*).', 0aH, '*opener* must return an open file descriptor (pa'
	DB	'ssing os.open as *opener*', 0aH, 'results in functionality si'
	DB	'milar to passing None).', 00H
	ORG $+3
read_doc DB	'read(size: int) -> bytes.  read at most size bytes, retu'
	DB	'rned as bytes.', 0aH, 0aH, 'Only makes one system call, so le'
	DB	'ss data may be returned than requested', 0aH, 'In non-blockin'
	DB	'g mode, returns None if no data is available.', 0aH, 'On end-'
	DB	'of-file, returns ''''.', 00H
	ORG $+8
readall_doc DB	'readall() -> bytes.  read all data from the file, return'
	DB	'ed as bytes.', 0aH, 0aH, 'In non-blocking mode, returns as mu'
	DB	'ch as is immediately available,', 0aH, 'or None if no data is'
	DB	' available.  On end-of-file, returns ''''.', 00H
	ORG $+9
write_doc DB	'write(b: bytes) -> int.  Write bytes b to file, return n'
	DB	'umber written.', 0aH, 0aH, 'Only makes one system call, so no'
	DB	't all of the data may be written.', 0aH, 'The number of bytes'
	DB	' actually written is returned.', 00H
	ORG $+3
fileno_doc DB	'fileno() -> int. "file descriptor".', 0aH, 0aH, 'This is'
	DB	' needed for lower-level file interfaces, such the fcntl modul'
	DB	'e.', 00H
	ORG $+4
seek_doc DB	'seek(offset: int[, whence: int]) -> None.  Move to new f'
	DB	'ile position.', 0aH, 0aH, 'Argument offset is a byte count.  '
	DB	'Optional argument whence defaults to', 0aH, '0 (offset from s'
	DB	'tart of file, offset should be >= 0); other values are 1', 0aH
	DB	'(move relative to current position, positive or negative), an'
	DB	'd 2 (move', 0aH, 'relative to end of file, usually negative, '
	DB	'although many platforms allow', 0aH, 'seeking beyond the end '
	DB	'of a file).', 0aH, 'Note that not all file objects are seekab'
	DB	'le.', 00H
	ORG $+9
truncate_doc DB	'truncate([size: int]) -> None.  Truncate the file to at '
	DB	'most size bytes.', 0aH, 0aH, 'Size defaults to the current fi'
	DB	'le position, as returned by tell().The current file position '
	DB	'is changed to the value of size.', 00H
	ORG $+1
readinto_doc DB	'readinto() -> Same as RawIOBase.readinto().', 00H
	ORG $+12
close_doc DB	'close() -> None.  Close the file.', 0aH, 0aH, 'A closed '
	DB	'file cannot be used for further I/O operations.  close() may '
	DB	'be', 0aH, 'called more than once without error.  Changes the '
	DB	'fileno to -1.', 00H
	ORG $+4
isatty_doc DB	'isatty() -> bool.  True if the file is connected to a tt'
	DB	'y device.', 00H
	ORG $+6
seekable_doc DB	'seekable() -> bool.  True if file supports random-access'
	DB	'.', 00H
	ORG $+6
readable_doc DB	'readable() -> bool.  True if file was opened in a read m'
	DB	'ode.', 00H
	ORG $+3
writable_doc DB	'writable() -> bool.  True if file was opened in a write '
	DB	'mode.', 00H
	ORG $+10
fileio_methods DQ FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	FLAT:fileio_read
	DD	01H
	ORG $+4
	DQ	FLAT:read_doc
	DQ	FLAT:??_C@_07JCDFOMC@readall?$AA@
	DQ	FLAT:fileio_readall
	DD	04H
	ORG $+4
	DQ	FLAT:readall_doc
	DQ	FLAT:??_C@_08BPEKIGCI@readinto?$AA@
	DQ	FLAT:fileio_readinto
	DD	01H
	ORG $+4
	DQ	FLAT:readinto_doc
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	FLAT:fileio_write
	DD	01H
	ORG $+4
	DQ	FLAT:write_doc
	DQ	FLAT:??_C@_04EDECCOGL@seek?$AA@
	DQ	FLAT:fileio_seek
	DD	01H
	ORG $+4
	DQ	FLAT:seek_doc
	DQ	FLAT:??_C@_04LBPCFPDD@tell?$AA@
	DQ	FLAT:fileio_tell
	DD	01H
	ORG $+4
	DQ	FLAT:tell_doc
	DQ	FLAT:??_C@_08MABILMFG@truncate?$AA@
	DQ	FLAT:fileio_truncate
	DD	01H
	ORG $+4
	DQ	FLAT:truncate_doc
	DQ	FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	FLAT:fileio_close
	DD	04H
	ORG $+4
	DQ	FLAT:close_doc
	DQ	FLAT:??_C@_08JPFEOKJG@seekable?$AA@
	DQ	FLAT:fileio_seekable
	DD	04H
	ORG $+4
	DQ	FLAT:seekable_doc
	DQ	FLAT:??_C@_08INDGGIBD@readable?$AA@
	DQ	FLAT:fileio_readable
	DD	04H
	ORG $+4
	DQ	FLAT:readable_doc
	DQ	FLAT:??_C@_08IBOGFJJC@writable?$AA@
	DQ	FLAT:fileio_writable
	DD	04H
	ORG $+4
	DQ	FLAT:writable_doc
	DQ	FLAT:??_C@_06FFBIALPD@fileno?$AA@
	DQ	FLAT:fileio_fileno
	DD	04H
	ORG $+4
	DQ	FLAT:fileno_doc
	DQ	FLAT:??_C@_06BMABDNNN@isatty?$AA@
	DQ	FLAT:fileio_isatty
	DD	04H
	ORG $+4
	DQ	FLAT:isatty_doc
	DQ	FLAT:??_C@_0O@OLJIIFNG@_dealloc_warn?$AA@
	DQ	FLAT:fileio_dealloc_warn
	DD	08H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0N@NAMJJHIO@__getstate__?$AA@
	DQ	FLAT:fileio_getstate
	DD	04H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
fileio_getsetlist DQ FLAT:??_C@_06IKJOPBFO@closed?$AA@
	DQ	FLAT:get_closed
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BL@DEDMGLDL@True?5if?5the?5file?5is?5closed?$AA@
	ORG $+8
	DQ	FLAT:??_C@_07IOEMJIMP@closefd?$AA@
	DQ	FLAT:get_closefd
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CL@CMPIPNMN@True?5if?5the?5file?5descriptor?5will@
	ORG $+8
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:get_mode
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BM@PHALLEFK@String?5giving?5the?5file?5mode?$AA@
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
PyFileIO_Type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0L@GNFKBAHD@_io?4FileIO?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:fileio_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:fileio_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:fileio_doc
	DQ	FLAT:fileio_traverse
	DQ	FLAT:fileio_clear
	DQ	0000000000000000H
	DQ	0000000000000068H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:fileio_methods
	DQ	0000000000000000H
	DQ	FLAT:fileio_getsetlist
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000070H
	DQ	FLAT:fileio_init
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:fileio_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
_DATA	ENDS
;	COMDAT ??_C@_06MNHBHLPO@opener?$AA@
CONST	SEGMENT
??_C@_06MNHBHLPO@opener?$AA@ DB 'opener', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07IOEMJIMP@closefd?$AA@
CONST	SEGMENT
??_C@_07IOEMJIMP@closefd?$AA@ DB 'closefd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GMGOKAFF@mode?$AA@
CONST	SEGMENT
??_C@_04GMGOKAFF@mode?$AA@ DB 'mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DAMGJPCA@file?$AA@
CONST	SEGMENT
??_C@_04DAMGJPCA@file?$AA@ DB 'file', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_name@?1??fileio_repr@@9@9 DQ 0000000000000000H	; `fileio_repr'::`2'::PyId_name
	DQ	FLAT:??_C@_04MEMAJGDJ@name?$AA@
	DQ	0000000000000000H
?PyId_close@?1??fileio_close@@9@9 DQ 0000000000000000H	; `fileio_close'::`2'::PyId_close
	DQ	FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
PUBLIC	_PyFileIO_closed
;	COMDAT pdata
; File c:\src\pyparallel\modules\_io\fileio.c
pdata	SEGMENT
$pdata$_PyFileIO_closed DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$_PyFileIO_closed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFileIO_closed DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyFileIO_closed
_TEXT	SEGMENT
tv66 = 0
self$ = 32
_PyFileIO_closed PROC					; COMDAT

; 66   : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 67   :     return ((fileio *)self)->fd < 0;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00012	7d 09		 jge	 SHORT $LN3@PyFileIO_c
  00014	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv66[rsp], 1
  0001b	eb 07		 jmp	 SHORT $LN4@PyFileIO_c
$LN3@PyFileIO_c:
  0001d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv66[rsp], 0
$LN4@PyFileIO_c:
  00024	8b 04 24	 mov	 eax, DWORD PTR tv66[rsp]

; 68   : }

  00027	48 83 c4 18	 add	 rsp, 24
  0002b	c3		 ret	 0
_PyFileIO_closed ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0BB@HLPMKFEG@unclosed?5file?5?$CFR?$AA@	; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyErr_Restore:PROC
EXTRN	PyErr_WriteUnraisable:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_Warning:QWORD
EXTRN	PyErr_WarnFormat:PROC
EXTRN	PyExc_ResourceWarning:QWORD
EXTRN	PyErr_Fetch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_dealloc_warn DD imagerel fileio_dealloc_warn
	DD	imagerel fileio_dealloc_warn+166
	DD	imagerel $unwind$fileio_dealloc_warn
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_dealloc_warn DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BB@HLPMKFEG@unclosed?5file?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BB@HLPMKFEG@unclosed?5file?5?$CFR?$AA@ DB 'unclosed file %R', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_dealloc_warn
_TEXT	SEGMENT
val$63809 = 32
tb$63810 = 40
exc$63808 = 48
self$ = 80
source$ = 88
fileio_dealloc_warn PROC				; COMDAT

; 75   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 76   :     if (self->fd >= 0 && self->closefd) {

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00017	7c 75		 jl	 SHORT $LN3@fileio_dea
  00019	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001e	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00021	c1 e8 06	 shr	 eax, 6
  00024	83 e0 01	 and	 eax, 1
  00027	85 c0		 test	 eax, eax
  00029	74 63		 je	 SHORT $LN3@fileio_dea

; 77   :         PyObject *exc, *val, *tb;
; 78   :         PyErr_Fetch(&exc, &val, &tb);

  0002b	4c 8d 44 24 28	 lea	 r8, QWORD PTR tb$63810[rsp]
  00030	48 8d 54 24 20	 lea	 rdx, QWORD PTR val$63809[rsp]
  00035	48 8d 4c 24 30	 lea	 rcx, QWORD PTR exc$63808[rsp]
  0003a	e8 00 00 00 00	 call	 PyErr_Fetch

; 79   :         if (PyErr_WarnFormat(PyExc_ResourceWarning, 1,
; 80   :                              "unclosed file %R", source)) {

  0003f	4c 8b 4c 24 58	 mov	 r9, QWORD PTR source$[rsp]
  00044	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@HLPMKFEG@unclosed?5file?5?$CFR?$AA@
  0004b	ba 01 00 00 00	 mov	 edx, 1
  00050	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ResourceWarning
  00057	e8 00 00 00 00	 call	 PyErr_WarnFormat
  0005c	85 c0		 test	 eax, eax
  0005e	74 1a		 je	 SHORT $LN2@fileio_dea

; 81   :             /* Spurious errors can appear at shutdown */
; 82   :             if (PyErr_ExceptionMatches(PyExc_Warning))

  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_Warning
  00067	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0006c	85 c0		 test	 eax, eax
  0006e	74 0a		 je	 SHORT $LN1@fileio_dea

; 83   :                 PyErr_WriteUnraisable((PyObject *) self);

  00070	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00075	e8 00 00 00 00	 call	 PyErr_WriteUnraisable
$LN1@fileio_dea:
$LN2@fileio_dea:

; 84   :         }
; 85   :         PyErr_Restore(exc, val, tb);

  0007a	4c 8b 44 24 28	 mov	 r8, QWORD PTR tb$63810[rsp]
  0007f	48 8b 54 24 20	 mov	 rdx, QWORD PTR val$63809[rsp]
  00084	48 8b 4c 24 30	 mov	 rcx, QWORD PTR exc$63808[rsp]
  00089	e8 00 00 00 00	 call	 PyErr_Restore
$LN3@fileio_dea:

; 86   :     }
; 87   :     Py_RETURN_NONE;

  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00095	e8 00 00 00 00	 call	 _Py_IncRef
  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 88   : }

  000a1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a5	c3		 ret	 0
fileio_dealloc_warn ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
PUBLIC	_Py_DecRef
EXTRN	_PyObject_CallMethodId_SizeT:PROC
EXTRN	PyRawIOBase_Type:BYTE
EXTRN	__imp__errno:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\_io\fileio.c
pdata	SEGMENT
$pdata$fileio_close DD imagerel fileio_close
	DD	imagerel fileio_close+225
	DD	imagerel $unwind$fileio_close
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_close DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_close
_TEXT	SEGMENT
r$63852 = 32
tv80 = 40
self$ = 64
fileio_close PROC					; COMDAT

; 126  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 127  :     _Py_IDENTIFIER(close);
; 128  :     if (!self->closefd) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00011	c1 e8 06	 shr	 eax, 6
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	75 24		 jne	 SHORT $LN5@fileio_clo

; 129  :         self->fd = -1;

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00020	c7 40 60 ff ff
	ff ff		 mov	 DWORD PTR [rax+96], -1

; 130  :         Py_RETURN_NONE;

  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0002e	e8 00 00 00 00	 call	 _Py_IncRef
  00033	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0003a	e9 9d 00 00 00	 jmp	 $LN6@fileio_clo
$LN5@fileio_clo:

; 131  :     }
; 132  :     if (self->deallocating) {

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00044	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00047	c1 e8 07	 shr	 eax, 7
  0004a	83 e0 01	 and	 eax, 1
  0004d	85 c0		 test	 eax, eax
  0004f	74 2d		 je	 SHORT $LN4@fileio_clo

; 133  :         PyObject *r = fileio_dealloc_warn(self, (PyObject *) self);

  00051	48 8b 54 24 40	 mov	 rdx, QWORD PTR self$[rsp]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005b	e8 00 00 00 00	 call	 fileio_dealloc_warn
  00060	48 89 44 24 20	 mov	 QWORD PTR r$63852[rsp], rax

; 134  :         if (r)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR r$63852[rsp], 0
  0006b	74 0c		 je	 SHORT $LN3@fileio_clo

; 135  :             Py_DECREF(r);

  0006d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR r$63852[rsp]
  00072	e8 00 00 00 00	 call	 _Py_DecRef

; 136  :         else

  00077	eb 05		 jmp	 SHORT $LN2@fileio_clo
$LN3@fileio_clo:

; 137  :             PyErr_Clear();

  00079	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@fileio_clo:
$LN4@fileio_clo:

; 138  :     }
; 139  :     errno = internal_close(self);

  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00083	e8 00 00 00 00	 call	 internal_close
  00088	89 44 24 28	 mov	 DWORD PTR tv80[rsp], eax
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00092	8b 4c 24 28	 mov	 ecx, DWORD PTR tv80[rsp]
  00096	89 08		 mov	 DWORD PTR [rax], ecx

; 140  :     if (errno < 0)

  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0009e	83 38 00	 cmp	 DWORD PTR [rax], 0
  000a1	7d 04		 jge	 SHORT $LN1@fileio_clo

; 141  :         return NULL;

  000a3	33 c0		 xor	 eax, eax
  000a5	eb 35		 jmp	 SHORT $LN6@fileio_clo
$LN1@fileio_clo:

; 142  : 
; 143  :     return _PyObject_CallMethodId((PyObject*)&PyRawIOBase_Type,
; 144  :                                   &PyId_close, "O", self);

  000a7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_close@?1??fileio_close@@9@9
  000ac	8b c0		 mov	 eax, eax
  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000b4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000bd	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000c1	4c 8b 4c 24 40	 mov	 r9, QWORD PTR self$[rsp]
  000c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  000cd	48 8b d0	 mov	 rdx, rax
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyRawIOBase_Type
  000d7	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT
$LN6@fileio_clo:

; 145  : }

  000dc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e0	c3		 ret	 0
fileio_close ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_IOError:QWORD
EXTRN	PyEval_RestoreThread:PROC
EXTRN	__imp_close:PROC
EXTRN	PyEval_SaveThread:PROC
EXTRN	_PyVerify_fd:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_io\fileio.c
pdata	SEGMENT
$pdata$internal_close DD imagerel internal_close
	DD	imagerel internal_close+193
	DD	imagerel $unwind$internal_close
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$internal_close DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT internal_close
_TEXT	SEGMENT
save_errno$ = 32
err$ = 36
fd$63836 = 40
_save$63838 = 48
self$ = 80
internal_close PROC					; COMDAT

; 98   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 99   :     int err = 0;

  00009	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR err$[rsp], 0

; 100  :     int save_errno = 0;

  00011	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR save_errno$[rsp], 0

; 101  :     if (self->fd >= 0) {

  00019	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001e	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00022	7c 70		 jl	 SHORT $LN5@internal_c

; 102  :         int fd = self->fd;

  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00029	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0002c	89 44 24 28	 mov	 DWORD PTR fd$63836[rsp], eax

; 103  :         self->fd = -1;

  00030	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00035	c7 40 60 ff ff
	ff ff		 mov	 DWORD PTR [rax+96], -1

; 104  :         /* fd is accessible and someone else may have closed it */
; 105  :         if (_PyVerify_fd(fd)) {

  0003c	8b 4c 24 28	 mov	 ecx, DWORD PTR fd$63836[rsp]
  00040	e8 00 00 00 00	 call	 _PyVerify_fd
  00045	85 c0		 test	 eax, eax
  00047	74 37		 je	 SHORT $LN4@internal_c

; 106  :             Py_BEGIN_ALLOW_THREADS

  00049	e8 00 00 00 00	 call	 PyEval_SaveThread
  0004e	48 89 44 24 30	 mov	 QWORD PTR _save$63838[rsp], rax

; 107  :             err = close(fd);

  00053	8b 4c 24 28	 mov	 ecx, DWORD PTR fd$63836[rsp]
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  0005d	89 44 24 24	 mov	 DWORD PTR err$[rsp], eax

; 108  :             if (err < 0)

  00061	83 7c 24 24 00	 cmp	 DWORD PTR err$[rsp], 0
  00066	7d 0c		 jge	 SHORT $LN3@internal_c

; 109  :                 save_errno = errno;

  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0006e	8b 00		 mov	 eax, DWORD PTR [rax]
  00070	89 44 24 20	 mov	 DWORD PTR save_errno$[rsp], eax
$LN3@internal_c:

; 110  :             Py_END_ALLOW_THREADS

  00074	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _save$63838[rsp]
  00079	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 111  :         } else {

  0007e	eb 14		 jmp	 SHORT $LN2@internal_c
$LN4@internal_c:

; 112  :             save_errno = errno;

  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00086	8b 00		 mov	 eax, DWORD PTR [rax]
  00088	89 44 24 20	 mov	 DWORD PTR save_errno$[rsp], eax

; 113  :             err = -1;

  0008c	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR err$[rsp], -1
$LN2@internal_c:
$LN5@internal_c:

; 114  :         }
; 115  :     }
; 116  :     if (err < 0) {

  00094	83 7c 24 24 00	 cmp	 DWORD PTR err$[rsp], 0
  00099	7d 1f		 jge	 SHORT $LN1@internal_c

; 117  :         errno = save_errno;

  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a1	8b 4c 24 20	 mov	 ecx, DWORD PTR save_errno$[rsp]
  000a5	89 08		 mov	 DWORD PTR [rax], ecx

; 118  :         PyErr_SetFromErrno(PyExc_IOError);

  000a7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  000ae	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 119  :         return -1;

  000b3	b8 ff ff ff ff	 mov	 eax, -1
  000b8	eb 02		 jmp	 SHORT $LN6@internal_c
$LN1@internal_c:

; 120  :     }
; 121  :     return 0;

  000ba	33 c0		 xor	 eax, eax
$LN6@internal_c:

; 122  : }

  000bc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c0	c3		 ret	 0
internal_close ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@ ; `string'
PUBLIC	??_C@_1DA@JIFCJEHP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_new DD imagerel fileio_new
	DD	imagerel fileio_new+254
	DD	imagerel $unwind$fileio_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_new DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@
CONST	SEGMENT
??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@ DB 't'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H
	DB	'-', 00H, '>', 00H, 't', 00H, 'p', 00H, '_', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@JIFCJEHP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@JIFCJEHP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, '_', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, 'f', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'i', 00H
	DB	'o', 00H, '.', 00H, 'c', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_new
_TEXT	SEGMENT
self$ = 32
type$ = 64
args$ = 72
kwds$ = 80
fileio_new PROC						; COMDAT

; 149  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 150  :     fileio *self;
; 151  : 
; 152  :     assert(type != NULL && type->tp_alloc != NULL);

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR type$[rsp], 0
  00019	74 0f		 je	 SHORT $LN4@fileio_new
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  00020	48 83 b8 88 01
	00 00 00	 cmp	 QWORD PTR [rax+392], 0
  00028	75 1c		 jne	 SHORT $LN5@fileio_new
$LN4@fileio_new:
  0002a	41 b8 98 00 00
	00		 mov	 r8d, 152		; 00000098H
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@JIFCJEHP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@JJDKKDOG@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAt?$AAy?$AAp?$AAe?$AA?9?$AA?$DO?$AAt?$AAp?$AA_?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?5?$AA?$CB@
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00044	33 c0		 xor	 eax, eax
$LN5@fileio_new:

; 153  : 
; 154  :     self = (fileio *) type->tp_alloc(type, 0);

  00046	33 d2		 xor	 edx, edx
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  00052	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00058	48 89 44 24 20	 mov	 QWORD PTR self$[rsp], rax

; 155  :     if (self != NULL) {

  0005d	48 83 7c 24 20
	00		 cmp	 QWORD PTR self$[rsp], 0
  00063	0f 84 8b 00 00
	00		 je	 $LN1@fileio_new

; 156  :         self->fd = -1;

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0006e	c7 40 60 ff ff
	ff ff		 mov	 DWORD PTR [rax+96], -1

; 157  :         self->created = 0;

  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0007a	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0007d	83 e0 fe	 and	 eax, -2			; fffffffeH
  00080	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00085	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 158  :         self->readable = 0;

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  0008d	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00090	83 e0 fd	 and	 eax, -3			; fffffffdH
  00093	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  00098	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 159  :         self->writable = 0;

  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000a0	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000a3	83 e0 fb	 and	 eax, -5			; fffffffbH
  000a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  000ab	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 160  :         self->appending = 0;

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000b3	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000b6	83 e0 f7	 and	 eax, -9			; fffffff7H
  000b9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  000be	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 161  :         self->seekable = -1;

  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000c6	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000c9	83 c8 30	 or	 eax, 48			; 00000030H
  000cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  000d1	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 162  :         self->closefd = 1;

  000d4	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000d9	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000dc	83 c8 40	 or	 eax, 64			; 00000040H
  000df	48 8b 4c 24 20	 mov	 rcx, QWORD PTR self$[rsp]
  000e4	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 163  :         self->weakreflist = NULL;

  000e7	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]
  000ec	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
$LN1@fileio_new:

; 164  :     }
; 165  : 
; 166  :     return (PyObject *) self;

  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR self$[rsp]

; 167  : }

  000f9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fd	c3		 ret	 0
fileio_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@LJPPJMDP@fileio_init?$AA@		; `string'
PUBLIC	??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@ ; `string'
PUBLIC	??_C@_0BN@NEODOJEE@expected?5integer?5from?5opener?$AA@ ; `string'
PUBLIC	??_C@_02MPEHDMPO@Oi?$AA@			; `string'
PUBLIC	??_C@_0CI@GJMLAAMK@Cannot?5use?5closefd?$DNFalse?5with?5fi@ ; `string'
PUBLIC	??_C@_0BF@JGEPLGFH@invalid?5mode?3?5?$CF?4200s?$AA@ ; `string'
PUBLIC	??_C@_0EM@IILANKJ@Must?5have?5exactly?5one?5of?5create?1@ ; `string'
PUBLIC	??_C@_1DC@DJCNEMFI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@ ; `string'
PUBLIC	??_C@_0BI@NNGPANE@Negative?5filedescriptor?$AA@	; `string'
PUBLIC	??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@ ; `string'
PUBLIC	??_C@_0N@CGOGJEEK@O?$HMsiO?3fileio?$AA@		; `string'
PUBLIC	??_C@_1CM@JMEEGGGF@?$AAP?$AAy?$AAF?$AAi?$AAl?$AAe?$AAI?$AAO?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
EXTRN	PyObject_SetAttrString:PROC
EXTRN	__imp__setmode:PROC
EXTRN	PyErr_SetFromErrnoWithFilename:PROC
EXTRN	PyErr_SetFromErrnoWithFilenameObject:PROC
EXTRN	_PyObject_CallFunction_SizeT:PROC
EXTRN	__imp_open:PROC
EXTRN	__imp__wopen:PROC
EXTRN	PyErr_Format:PROC
EXTRN	__ImageBase:BYTE
EXTRN	PyUnicode_FSConverter:PROC
EXTRN	PyUnicode_AsUnicode:PROC
EXTRN	_PyUnicode_HasNULChars:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	_PyLong_AsInt:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyFloat_Type:BYTE
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_init DD imagerel fileio_init
	DD	imagerel fileio_init+2330
	DD	imagerel $unwind$fileio_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_init DD 021601H
	DD	01d0116H
xdata	ENDS
;	COMDAT ??_C@_0M@LJPPJMDP@fileio_init?$AA@
CONST	SEGMENT
??_C@_0M@LJPPJMDP@fileio_init?$AA@ DB 'fileio_init', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
CONST	SEGMENT
??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@ DB '..\Modules\_io\'
	DB	'fileio.c', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@NEODOJEE@expected?5integer?5from?5opener?$AA@
CONST	SEGMENT
??_C@_0BN@NEODOJEE@expected?5integer?5from?5opener?$AA@ DB 'expected inte'
	DB	'ger from opener', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MPEHDMPO@Oi?$AA@
CONST	SEGMENT
??_C@_02MPEHDMPO@Oi?$AA@ DB 'Oi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GJMLAAMK@Cannot?5use?5closefd?$DNFalse?5with?5fi@
CONST	SEGMENT
??_C@_0CI@GJMLAAMK@Cannot?5use?5closefd?$DNFalse?5with?5fi@ DB 'Cannot us'
	DB	'e closefd=False with file name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JGEPLGFH@invalid?5mode?3?5?$CF?4200s?$AA@
CONST	SEGMENT
??_C@_0BF@JGEPLGFH@invalid?5mode?3?5?$CF?4200s?$AA@ DB 'invalid mode: %.2'
	DB	'00s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@IILANKJ@Must?5have?5exactly?5one?5of?5create?1@
CONST	SEGMENT
??_C@_0EM@IILANKJ@Must?5have?5exactly?5one?5of?5create?1@ DB 'Must have e'
	DB	'xactly one of create/read/write/append mode and at most one p'
	DB	'lus', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@DJCNEMFI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@DJCNEMFI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'o', 00H, 'b', 00H, 'j', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@
CONST	SEGMENT
??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@ DB 'embedded NUL charact'
	DB	'er', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NNGPANE@Negative?5filedescriptor?$AA@
CONST	SEGMENT
??_C@_0BI@NNGPANE@Negative?5filedescriptor?$AA@ DB 'Negative filedescript'
	DB	'or', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@
CONST	SEGMENT
??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@ DB 'integer arg'
	DB	'ument expected, got float', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CGOGJEEK@O?$HMsiO?3fileio?$AA@
CONST	SEGMENT
??_C@_0N@CGOGJEEK@O?$HMsiO?3fileio?$AA@ DB 'O|siO:fileio', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@JMEEGGGF@?$AAP?$AAy?$AAF?$AAi?$AAl?$AAe?$AAI?$AAO?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@JMEEGGGF@?$AAP?$AAy?$AAF?$AAi?$AAl?$AAe?$AAI?$AAO?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'F', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'I', 00H
	DB	'O', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k'
	DB	00H, '(', 00H, 'o', 00H, 's', 00H, 'e', 00H, 'l', 00H, 'f', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_init
_TEXT	SEGMENT
flags$ = 64
mode$ = 72
s$ = 80
stringobj$ = 88
closefd$ = 96
nameobj$ = 104
widename$ = 112
self$ = 120
name$ = 128
ret$ = 136
plus$ = 140
fd_is_own$ = 144
rwa$ = 148
fd$ = 152
opener$ = 160
rv$63959 = 168
_save$64006 = 176
fdobj$64011 = 184
pos$64030 = 192
_py_tmp$64044 = 200
tv174 = 208
tv175 = 212
oself$ = 240
args$ = 248
kwds$ = 256
fileio_init PROC					; COMDAT

; 210  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 211  :     fileio *self = (fileio *) oself;

  00016	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR oself$[rsp]
  0001e	48 89 44 24 78	 mov	 QWORD PTR self$[rsp], rax

; 212  :     static char *kwlist[] = {"file", "mode", "closefd", "opener", NULL};
; 213  :     const char *name = NULL;

  00023	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR name$[rsp], 0

; 214  :     PyObject *nameobj, *stringobj = NULL, *opener = Py_None;

  0002f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR stringobj$[rsp], 0
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0003f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR opener$[rsp], rax

; 215  :     char *mode = "r";

  00047	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01KDCPPGHE@r?$AA@
  0004e	48 89 44 24 48	 mov	 QWORD PTR mode$[rsp], rax

; 216  :     char *s;
; 217  : #ifdef MS_WINDOWS
; 218  :     Py_UNICODE *widename = NULL;

  00053	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR widename$[rsp], 0

; 219  : #endif
; 220  :     int ret = 0;

  0005c	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ret$[rsp], 0

; 221  :     int rwa = 0, plus = 0;

  00067	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rwa$[rsp], 0
  00072	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR plus$[rsp], 0

; 222  :     int flags = 0;

  0007d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR flags$[rsp], 0

; 223  :     int fd = -1;

  00085	c7 84 24 98 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR fd$[rsp], -1

; 224  :     int closefd = 1;

  00090	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR closefd$[rsp], 1

; 225  :     int fd_is_own = 0;

  00098	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR fd_is_own$[rsp], 0

; 226  : 
; 227  :     assert(PyFileIO_Check(oself));

  000a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFileIO_Type
  000aa	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR oself$[rsp]
  000b2	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000b6	74 38		 je	 SHORT $LN64@fileio_ini
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFileIO_Type
  000bf	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR oself$[rsp]
  000c7	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000cb	e8 00 00 00 00	 call	 PyType_IsSubtype
  000d0	85 c0		 test	 eax, eax
  000d2	75 1c		 jne	 SHORT $LN64@fileio_ini
  000d4	41 b8 e3 00 00
	00		 mov	 r8d, 227		; 000000e3H
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@JIFCJEHP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@JMEEGGGF@?$AAP?$AAy?$AAF?$AAi?$AAl?$AAe?$AAI?$AAO?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AAs?$AAe?$AAl?$AAf?$AA?$CJ?$AA?$AA@
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ee	33 c0		 xor	 eax, eax
$LN64@fileio_ini:

; 228  :     if (self->fd >= 0) {

  000f0	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  000f5	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  000f9	7c 38		 jl	 SHORT $LN61@fileio_ini

; 229  :         if (self->closefd) {

  000fb	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  00100	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00103	c1 e8 06	 shr	 eax, 6
  00106	83 e0 01	 and	 eax, 1
  00109	85 c0		 test	 eax, eax
  0010b	74 1a		 je	 SHORT $LN60@fileio_ini

; 230  :             /* Have to close the existing file first. */
; 231  :             if (internal_close(self) < 0)

  0010d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  00112	e8 00 00 00 00	 call	 internal_close
  00117	85 c0		 test	 eax, eax
  00119	7d 0a		 jge	 SHORT $LN59@fileio_ini

; 232  :                 return -1;

  0011b	b8 ff ff ff ff	 mov	 eax, -1
  00120	e9 83 07 00 00	 jmp	 $LN62@fileio_ini
$LN59@fileio_ini:

; 233  :         }
; 234  :         else

  00125	eb 0c		 jmp	 SHORT $LN58@fileio_ini
$LN60@fileio_ini:

; 235  :             self->fd = -1;

  00127	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  0012c	c7 40 60 ff ff
	ff ff		 mov	 DWORD PTR [rax+96], -1
$LN58@fileio_ini:
$LN61@fileio_ini:

; 236  :     }
; 237  : 
; 238  :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|siO:fileio",
; 239  :                                      kwlist, &nameobj, &mode, &closefd,
; 240  :                                      &opener))

  00133	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR opener$[rsp]
  0013b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00140	48 8d 44 24 60	 lea	 rax, QWORD PTR closefd$[rsp]
  00145	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0014a	48 8d 44 24 48	 lea	 rax, QWORD PTR mode$[rsp]
  0014f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00154	48 8d 44 24 68	 lea	 rax, QWORD PTR nameobj$[rsp]
  00159	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??fileio_init@@9@9
  00165	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@CGOGJEEK@O?$HMsiO?3fileio?$AA@
  0016c	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00174	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0017c	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00181	85 c0		 test	 eax, eax
  00183	75 0a		 jne	 SHORT $LN57@fileio_ini

; 241  :         return -1;

  00185	b8 ff ff ff ff	 mov	 eax, -1
  0018a	e9 19 07 00 00	 jmp	 $LN62@fileio_ini
$LN57@fileio_ini:

; 242  : 
; 243  :     if (PyFloat_Check(nameobj)) {

  0018f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00196	48 8b 4c 24 68	 mov	 rcx, QWORD PTR nameobj$[rsp]
  0019b	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0019f	74 19		 je	 SHORT $LN55@fileio_ini
  001a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  001a8	48 8b 44 24 68	 mov	 rax, QWORD PTR nameobj$[rsp]
  001ad	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  001b1	e8 00 00 00 00	 call	 PyType_IsSubtype
  001b6	85 c0		 test	 eax, eax
  001b8	74 1d		 je	 SHORT $LN56@fileio_ini
$LN55@fileio_ini:

; 244  :         PyErr_SetString(PyExc_TypeError,
; 245  :                         "integer argument expected, got float");

  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@BFHGIJMM@integer?5argument?5expected?0?5got?5f@
  001c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001c8	e8 00 00 00 00	 call	 PyErr_SetString

; 246  :         return -1;

  001cd	b8 ff ff ff ff	 mov	 eax, -1
  001d2	e9 d1 06 00 00	 jmp	 $LN62@fileio_ini
$LN56@fileio_ini:

; 247  :     }
; 248  : 
; 249  :     fd = _PyLong_AsInt(nameobj);

  001d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR nameobj$[rsp]
  001dc	e8 00 00 00 00	 call	 _PyLong_AsInt
  001e1	89 84 24 98 00
	00 00		 mov	 DWORD PTR fd$[rsp], eax

; 250  :     if (fd < 0) {

  001e8	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR fd$[rsp], 0
  001f0	7d 2c		 jge	 SHORT $LN54@fileio_ini

; 251  :         if (!PyErr_Occurred()) {

  001f2	e8 00 00 00 00	 call	 PyErr_Occurred
  001f7	48 85 c0	 test	 rax, rax
  001fa	75 1d		 jne	 SHORT $LN53@fileio_ini

; 252  :             PyErr_SetString(PyExc_ValueError,
; 253  :                             "Negative filedescriptor");

  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@NNGPANE@Negative?5filedescriptor?$AA@
  00203	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0020a	e8 00 00 00 00	 call	 PyErr_SetString

; 254  :             return -1;

  0020f	b8 ff ff ff ff	 mov	 eax, -1
  00214	e9 8f 06 00 00	 jmp	 $LN62@fileio_ini
$LN53@fileio_ini:

; 255  :         }
; 256  :         PyErr_Clear();

  00219	e8 00 00 00 00	 call	 PyErr_Clear
$LN54@fileio_ini:

; 257  :     }
; 258  : 
; 259  : #ifdef MS_WINDOWS
; 260  :     if (PyUnicode_Check(nameobj)) {

  0021e	48 8b 44 24 68	 mov	 rax, QWORD PTR nameobj$[rsp]
  00223	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00227	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0022d	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00232	85 c0		 test	 eax, eax
  00234	74 65		 je	 SHORT $LN52@fileio_ini

; 261  :         int rv = _PyUnicode_HasNULChars(nameobj);

  00236	48 8b 4c 24 68	 mov	 rcx, QWORD PTR nameobj$[rsp]
  0023b	e8 00 00 00 00	 call	 _PyUnicode_HasNULChars
  00240	89 84 24 a8 00
	00 00		 mov	 DWORD PTR rv$63959[rsp], eax

; 262  :         if (rv) {

  00247	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR rv$63959[rsp], 0
  0024f	74 27		 je	 SHORT $LN51@fileio_ini

; 263  :             if (rv != -1)

  00251	83 bc 24 a8 00
	00 00 ff	 cmp	 DWORD PTR rv$63959[rsp], -1
  00259	74 13		 je	 SHORT $LN50@fileio_ini

; 264  :                 PyErr_SetString(PyExc_TypeError, "embedded NUL character");

  0025b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JDIDDKBJ@embedded?5NUL?5character?$AA@
  00262	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00269	e8 00 00 00 00	 call	 PyErr_SetString
$LN50@fileio_ini:

; 265  :             return -1;

  0026e	b8 ff ff ff ff	 mov	 eax, -1
  00273	e9 30 06 00 00	 jmp	 $LN62@fileio_ini
$LN51@fileio_ini:

; 266  :         }
; 267  :         widename = PyUnicode_AsUnicode(nameobj);

  00278	48 8b 4c 24 68	 mov	 rcx, QWORD PTR nameobj$[rsp]
  0027d	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00282	48 89 44 24 70	 mov	 QWORD PTR widename$[rsp], rax

; 268  :         if (widename == NULL)

  00287	48 83 7c 24 70
	00		 cmp	 QWORD PTR widename$[rsp], 0
  0028d	75 0a		 jne	 SHORT $LN49@fileio_ini

; 269  :             return -1;

  0028f	b8 ff ff ff ff	 mov	 eax, -1
  00294	e9 0f 06 00 00	 jmp	 $LN62@fileio_ini
$LN49@fileio_ini:

; 270  :     } else

  00299	eb 6c		 jmp	 SHORT $LN48@fileio_ini
$LN52@fileio_ini:

; 271  : #endif
; 272  :     if (fd < 0)

  0029b	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR fd$[rsp], 0
  002a3	7d 62		 jge	 SHORT $LN47@fileio_ini

; 273  :     {
; 274  :         if (!PyUnicode_FSConverter(nameobj, &stringobj)) {

  002a5	48 8d 54 24 58	 lea	 rdx, QWORD PTR stringobj$[rsp]
  002aa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR nameobj$[rsp]
  002af	e8 00 00 00 00	 call	 PyUnicode_FSConverter
  002b4	85 c0		 test	 eax, eax
  002b6	75 0a		 jne	 SHORT $LN46@fileio_ini

; 275  :             return -1;

  002b8	b8 ff ff ff ff	 mov	 eax, -1
  002bd	e9 e6 05 00 00	 jmp	 $LN62@fileio_ini
$LN46@fileio_ini:

; 276  :         }
; 277  :         name = PyBytes_AS_STRING(stringobj);

  002c2	48 8b 44 24 58	 mov	 rax, QWORD PTR stringobj$[rsp]
  002c7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002cb	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002d1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002d6	85 c0		 test	 eax, eax
  002d8	75 1c		 jne	 SHORT $LN65@fileio_ini
  002da	41 b8 15 01 00
	00		 mov	 r8d, 277		; 00000115H
  002e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@JIFCJEHP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  002e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@DJCNEMFI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AAo?$AAb?$AAj?$AA?$CJ?$AA?$AA@
  002ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002f4	33 c0		 xor	 eax, eax
$LN65@fileio_ini:
  002f6	48 8b 44 24 58	 mov	 rax, QWORD PTR stringobj$[rsp]
  002fb	48 83 c0 78	 add	 rax, 120		; 00000078H
  002ff	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR name$[rsp], rax
$LN47@fileio_ini:
$LN48@fileio_ini:

; 278  :     }
; 279  : 
; 280  :     s = mode;

  00307	48 8b 44 24 48	 mov	 rax, QWORD PTR mode$[rsp]
  0030c	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax
$LN45@fileio_ini:

; 281  :     while (*s) {

  00311	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00316	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00319	85 c0		 test	 eax, eax
  0031b	0f 84 f4 01 00
	00		 je	 $LN44@fileio_ini

; 282  :         switch (*s++) {

  00321	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00326	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00329	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv174[rsp], eax
  00330	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00335	48 ff c0	 inc	 rax
  00338	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax
  0033d	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv174[rsp]
  00344	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv175[rsp], eax
  0034b	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv175[rsp]
  00352	83 e8 2b	 sub	 eax, 43			; 0000002bH
  00355	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv175[rsp], eax
  0035c	83 bc 24 d4 00
	00 00 4d	 cmp	 DWORD PTR tv175[rsp], 77 ; 0000004dH
  00364	0f 87 89 01 00
	00		 ja	 $LN30@fileio_ini
  0036a	48 63 84 24 d4
	00 00 00	 movsxd	 rax, DWORD PTR tv175[rsp]
  00372	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00379	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN66@fileio_ini[rcx+rax]
  00381	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN67@fileio_ini[rcx+rax*4]
  00388	48 03 c1	 add	 rax, rcx
  0038b	ff e0		 jmp	 rax
$LN41@fileio_ini:

; 283  :         case 'x':
; 284  :             if (rwa) {

  0038d	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rwa$[rsp], 0
  00395	74 18		 je	 SHORT $LN40@fileio_ini
$bad_mode$63981:

; 285  :             bad_mode:
; 286  :                 PyErr_SetString(PyExc_ValueError,
; 287  :                                 "Must have exactly one of create/read/write/append "
; 288  :                                 "mode and at most one plus");

  00397	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EM@IILANKJ@Must?5have?5exactly?5one?5of?5create?1@
  0039e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  003a5	e8 00 00 00 00	 call	 PyErr_SetString

; 289  :                 goto error;

  003aa	e9 61 04 00 00	 jmp	 $error$63983
$LN40@fileio_ini:

; 290  :             }
; 291  :             rwa = 1;

  003af	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR rwa$[rsp], 1

; 292  :             self->created = 1;

  003ba	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  003bf	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  003c2	83 c8 01	 or	 eax, 1
  003c5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  003ca	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 293  :             self->writable = 1;

  003cd	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  003d2	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  003d5	83 c8 04	 or	 eax, 4
  003d8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  003dd	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 294  :             flags |= O_EXCL | O_CREAT;

  003e0	8b 44 24 40	 mov	 eax, DWORD PTR flags$[rsp]
  003e4	0d 00 05 00 00	 or	 eax, 1280		; 00000500H
  003e9	89 44 24 40	 mov	 DWORD PTR flags$[rsp], eax

; 295  :             break;

  003ed	e9 1e 01 00 00	 jmp	 $LN42@fileio_ini
$LN39@fileio_ini:

; 296  :         case 'r':
; 297  :             if (rwa)

  003f2	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rwa$[rsp], 0
  003fa	74 02		 je	 SHORT $LN38@fileio_ini

; 298  :                 goto bad_mode;

  003fc	eb 99		 jmp	 SHORT $bad_mode$63981
$LN38@fileio_ini:

; 299  :             rwa = 1;

  003fe	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR rwa$[rsp], 1

; 300  :             self->readable = 1;

  00409	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  0040e	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00411	83 c8 02	 or	 eax, 2
  00414	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  00419	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 301  :             break;

  0041c	e9 ef 00 00 00	 jmp	 $LN42@fileio_ini
$LN37@fileio_ini:

; 302  :         case 'w':
; 303  :             if (rwa)

  00421	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rwa$[rsp], 0
  00429	74 05		 je	 SHORT $LN36@fileio_ini

; 304  :                 goto bad_mode;

  0042b	e9 67 ff ff ff	 jmp	 $bad_mode$63981
$LN36@fileio_ini:

; 305  :             rwa = 1;

  00430	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR rwa$[rsp], 1

; 306  :             self->writable = 1;

  0043b	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  00440	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00443	83 c8 04	 or	 eax, 4
  00446	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  0044b	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 307  :             flags |= O_CREAT | O_TRUNC;

  0044e	8b 44 24 40	 mov	 eax, DWORD PTR flags$[rsp]
  00452	0d 00 03 00 00	 or	 eax, 768		; 00000300H
  00457	89 44 24 40	 mov	 DWORD PTR flags$[rsp], eax

; 308  :             break;

  0045b	e9 b0 00 00 00	 jmp	 $LN42@fileio_ini
$LN35@fileio_ini:

; 309  :         case 'a':
; 310  :             if (rwa)

  00460	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rwa$[rsp], 0
  00468	74 05		 je	 SHORT $LN34@fileio_ini

; 311  :                 goto bad_mode;

  0046a	e9 28 ff ff ff	 jmp	 $bad_mode$63981
$LN34@fileio_ini:

; 312  :             rwa = 1;

  0046f	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR rwa$[rsp], 1

; 313  :             self->writable = 1;

  0047a	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  0047f	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00482	83 c8 04	 or	 eax, 4
  00485	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  0048a	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 314  :             self->appending = 1;

  0048d	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  00492	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00495	83 c8 08	 or	 eax, 8
  00498	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  0049d	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 315  :             flags |= O_APPEND | O_CREAT;

  004a0	8b 44 24 40	 mov	 eax, DWORD PTR flags$[rsp]
  004a4	0d 08 01 00 00	 or	 eax, 264		; 00000108H
  004a9	89 44 24 40	 mov	 DWORD PTR flags$[rsp], eax

; 316  :             break;

  004ad	eb 61		 jmp	 SHORT $LN42@fileio_ini
$LN33@fileio_ini:

; 317  :         case 'b':
; 318  :             break;

  004af	eb 5f		 jmp	 SHORT $LN42@fileio_ini
$LN32@fileio_ini:

; 319  :         case '+':
; 320  :             if (plus)

  004b1	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR plus$[rsp], 0
  004b9	74 05		 je	 SHORT $LN31@fileio_ini

; 321  :                 goto bad_mode;

  004bb	e9 d7 fe ff ff	 jmp	 $bad_mode$63981
$LN31@fileio_ini:

; 322  :             self->readable = self->writable = 1;

  004c0	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  004c5	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  004c8	83 c8 04	 or	 eax, 4
  004cb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  004d0	89 41 64	 mov	 DWORD PTR [rcx+100], eax
  004d3	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  004d8	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  004db	83 c8 02	 or	 eax, 2
  004de	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  004e3	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 323  :             plus = 1;

  004e6	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR plus$[rsp], 1

; 324  :             break;

  004f1	eb 1d		 jmp	 SHORT $LN42@fileio_ini
$LN30@fileio_ini:

; 325  :         default:
; 326  :             PyErr_Format(PyExc_ValueError,
; 327  :                          "invalid mode: %.200s", mode);

  004f3	4c 8b 44 24 48	 mov	 r8, QWORD PTR mode$[rsp]
  004f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@JGEPLGFH@invalid?5mode?3?5?$CF?4200s?$AA@
  004ff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00506	e8 00 00 00 00	 call	 PyErr_Format

; 328  :             goto error;

  0050b	e9 00 03 00 00	 jmp	 $error$63983
$LN42@fileio_ini:

; 329  :         }
; 330  :     }

  00510	e9 fc fd ff ff	 jmp	 $LN45@fileio_ini
$LN44@fileio_ini:

; 331  : 
; 332  :     if (!rwa)

  00515	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rwa$[rsp], 0
  0051d	75 05		 jne	 SHORT $LN29@fileio_ini

; 333  :         goto bad_mode;

  0051f	e9 73 fe ff ff	 jmp	 $bad_mode$63981
$LN29@fileio_ini:

; 334  : 
; 335  :     if (self->readable && self->writable)

  00524	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  00529	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0052c	d1 e8		 shr	 eax, 1
  0052e	83 e0 01	 and	 eax, 1
  00531	85 c0		 test	 eax, eax
  00533	74 1f		 je	 SHORT $LN28@fileio_ini
  00535	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  0053a	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0053d	c1 e8 02	 shr	 eax, 2
  00540	83 e0 01	 and	 eax, 1
  00543	85 c0		 test	 eax, eax
  00545	74 0d		 je	 SHORT $LN28@fileio_ini

; 336  :         flags |= O_RDWR;

  00547	8b 44 24 40	 mov	 eax, DWORD PTR flags$[rsp]
  0054b	83 c8 02	 or	 eax, 2
  0054e	89 44 24 40	 mov	 DWORD PTR flags$[rsp], eax
  00552	eb 26		 jmp	 SHORT $LN27@fileio_ini
$LN28@fileio_ini:

; 337  :     else if (self->readable)

  00554	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  00559	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0055c	d1 e8		 shr	 eax, 1
  0055e	83 e0 01	 and	 eax, 1
  00561	85 c0		 test	 eax, eax
  00563	74 0a		 je	 SHORT $LN26@fileio_ini

; 338  :         flags |= O_RDONLY;

  00565	8b 44 24 40	 mov	 eax, DWORD PTR flags$[rsp]
  00569	89 44 24 40	 mov	 DWORD PTR flags$[rsp], eax

; 339  :     else

  0056d	eb 0b		 jmp	 SHORT $LN25@fileio_ini
$LN26@fileio_ini:

; 340  :         flags |= O_WRONLY;

  0056f	8b 44 24 40	 mov	 eax, DWORD PTR flags$[rsp]
  00573	83 c8 01	 or	 eax, 1
  00576	89 44 24 40	 mov	 DWORD PTR flags$[rsp], eax
$LN25@fileio_ini:
$LN27@fileio_ini:

; 341  : 
; 342  : #ifdef O_BINARY
; 343  :     flags |= O_BINARY;

  0057a	8b 44 24 40	 mov	 eax, DWORD PTR flags$[rsp]
  0057e	0f ba e8 0f	 bts	 eax, 15
  00582	89 44 24 40	 mov	 DWORD PTR flags$[rsp], eax

; 344  : #endif
; 345  : 
; 346  :     if (fd >= 0) {

  00586	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR fd$[rsp], 0
  0058e	7c 4a		 jl	 SHORT $LN24@fileio_ini

; 347  :         if (check_fd(fd))

  00590	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00597	e8 00 00 00 00	 call	 check_fd
  0059c	85 c0		 test	 eax, eax
  0059e	74 05		 je	 SHORT $LN23@fileio_ini

; 348  :             goto error;

  005a0	e9 6b 02 00 00	 jmp	 $error$63983
$LN23@fileio_ini:

; 349  :         self->fd = fd;

  005a5	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  005aa	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  005b1	89 48 60	 mov	 DWORD PTR [rax+96], ecx

; 350  :         self->closefd = closefd;

  005b4	8b 44 24 60	 mov	 eax, DWORD PTR closefd$[rsp]
  005b8	83 e0 01	 and	 eax, 1
  005bb	c1 e0 06	 shl	 eax, 6
  005be	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  005c3	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  005c6	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  005c9	0b c8		 or	 ecx, eax
  005cb	8b c1		 mov	 eax, ecx
  005cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  005d2	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 351  :     }
; 352  :     else {

  005d5	e9 a7 01 00 00	 jmp	 $LN22@fileio_ini
$LN24@fileio_ini:

; 353  :         self->closefd = 1;

  005da	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  005df	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  005e2	83 c8 40	 or	 eax, 64			; 00000040H
  005e5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  005ea	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 354  :         if (!closefd) {

  005ed	83 7c 24 60 00	 cmp	 DWORD PTR closefd$[rsp], 0
  005f2	75 18		 jne	 SHORT $LN21@fileio_ini

; 355  :             PyErr_SetString(PyExc_ValueError,
; 356  :                 "Cannot use closefd=False with file name");

  005f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@GJMLAAMK@Cannot?5use?5closefd?$DNFalse?5with?5fi@
  005fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00602	e8 00 00 00 00	 call	 PyErr_SetString

; 357  :             goto error;

  00607	e9 04 02 00 00	 jmp	 $error$63983
$LN21@fileio_ini:

; 358  :         }
; 359  : 
; 360  :         errno = 0;

  0060c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00612	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 361  :         if (opener == Py_None) {

  00618	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0061f	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR opener$[rsp], rax
  00627	75 66		 jne	 SHORT $LN20@fileio_ini

; 362  :             Py_BEGIN_ALLOW_THREADS

  00629	e8 00 00 00 00	 call	 PyEval_SaveThread
  0062e	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR _save$64006[rsp], rax

; 363  : #ifdef MS_WINDOWS
; 364  :             if (widename != NULL)

  00636	48 83 7c 24 70
	00		 cmp	 QWORD PTR widename$[rsp], 0
  0063c	74 1f		 je	 SHORT $LN19@fileio_ini

; 365  :                 self->fd = _wopen(widename, flags, 0666);

  0063e	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  00644	8b 54 24 40	 mov	 edx, DWORD PTR flags$[rsp]
  00648	48 8b 4c 24 70	 mov	 rcx, QWORD PTR widename$[rsp]
  0064d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wopen
  00653	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  00658	89 41 60	 mov	 DWORD PTR [rcx+96], eax

; 366  :             else

  0065b	eb 20		 jmp	 SHORT $LN18@fileio_ini
$LN19@fileio_ini:

; 367  : #endif
; 368  :                 self->fd = open(name, flags, 0666);

  0065d	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  00663	8b 54 24 40	 mov	 edx, DWORD PTR flags$[rsp]
  00667	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR name$[rsp]
  0066f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open
  00675	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  0067a	89 41 60	 mov	 DWORD PTR [rcx+96], eax
$LN18@fileio_ini:

; 369  :             Py_END_ALLOW_THREADS

  0067d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR _save$64006[rsp]
  00685	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 370  :         } else {

  0068a	e9 a8 00 00 00	 jmp	 $LN17@fileio_ini
$LN20@fileio_ini:

; 371  :             PyObject *fdobj = PyObject_CallFunction(
; 372  :                                   opener, "Oi", nameobj, flags);

  0068f	44 8b 4c 24 40	 mov	 r9d, DWORD PTR flags$[rsp]
  00694	4c 8b 44 24 68	 mov	 r8, QWORD PTR nameobj$[rsp]
  00699	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MPEHDMPO@Oi?$AA@
  006a0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR opener$[rsp]
  006a8	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT
  006ad	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR fdobj$64011[rsp], rax

; 373  :             if (fdobj == NULL)

  006b5	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR fdobj$64011[rsp], 0
  006be	75 05		 jne	 SHORT $LN16@fileio_ini

; 374  :                 goto error;

  006c0	e9 4b 01 00 00	 jmp	 $error$63983
$LN16@fileio_ini:

; 375  :             if (!PyLong_Check(fdobj)) {

  006c5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR fdobj$64011[rsp]
  006cd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  006d1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  006d7	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  006dc	85 c0		 test	 eax, eax
  006de	75 25		 jne	 SHORT $LN15@fileio_ini

; 376  :                 Py_DECREF(fdobj);

  006e0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR fdobj$64011[rsp]
  006e8	e8 00 00 00 00	 call	 _Py_DecRef

; 377  :                 PyErr_SetString(PyExc_TypeError,
; 378  :                         "expected integer from opener");

  006ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@NEODOJEE@expected?5integer?5from?5opener?$AA@
  006f4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  006fb	e8 00 00 00 00	 call	 PyErr_SetString

; 379  :                 goto error;

  00700	e9 0b 01 00 00	 jmp	 $error$63983
$LN15@fileio_ini:

; 380  :             }
; 381  : 
; 382  :             self->fd = _PyLong_AsInt(fdobj);

  00705	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR fdobj$64011[rsp]
  0070d	e8 00 00 00 00	 call	 _PyLong_AsInt
  00712	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  00717	89 41 60	 mov	 DWORD PTR [rcx+96], eax

; 383  :             Py_DECREF(fdobj);

  0071a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR fdobj$64011[rsp]
  00722	e8 00 00 00 00	 call	 _Py_DecRef

; 384  :             if (self->fd == -1) {

  00727	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  0072c	83 78 60 ff	 cmp	 DWORD PTR [rax+96], -1
  00730	75 05		 jne	 SHORT $LN14@fileio_ini

; 385  :                 goto error;

  00732	e9 d9 00 00 00	 jmp	 $error$63983
$LN14@fileio_ini:
$LN17@fileio_ini:

; 386  :             }
; 387  :         }
; 388  : 
; 389  :         fd_is_own = 1;

  00737	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR fd_is_own$[rsp], 1

; 390  :         if (self->fd < 0) {

  00742	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  00747	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  0074b	7d 34		 jge	 SHORT $LN13@fileio_ini

; 391  : #ifdef MS_WINDOWS
; 392  :             if (widename != NULL)

  0074d	48 83 7c 24 70
	00		 cmp	 QWORD PTR widename$[rsp], 0
  00753	74 13		 je	 SHORT $LN12@fileio_ini

; 393  :                 PyErr_SetFromErrnoWithFilenameObject(PyExc_IOError, nameobj);

  00755	48 8b 54 24 68	 mov	 rdx, QWORD PTR nameobj$[rsp]
  0075a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00761	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilenameObject

; 394  :             else

  00766	eb 14		 jmp	 SHORT $LN11@fileio_ini
$LN12@fileio_ini:

; 395  : #endif
; 396  :                 PyErr_SetFromErrnoWithFilename(PyExc_IOError, name);

  00768	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR name$[rsp]
  00770	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00777	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilename
$LN11@fileio_ini:

; 397  :             goto error;

  0077c	e9 8f 00 00 00	 jmp	 $error$63983
$LN13@fileio_ini:
$LN22@fileio_ini:

; 398  :         }
; 399  :     }
; 400  :     if (dircheck(self, nameobj) < 0)

  00781	48 8b 54 24 68	 mov	 rdx, QWORD PTR nameobj$[rsp]
  00786	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  0078b	e8 00 00 00 00	 call	 dircheck
  00790	85 c0		 test	 eax, eax
  00792	7d 02		 jge	 SHORT $LN10@fileio_ini

; 401  :         goto error;

  00794	eb 7a		 jmp	 SHORT $error$63983
$LN10@fileio_ini:

; 402  : 
; 403  : #if defined(MS_WINDOWS) || defined(__CYGWIN__)
; 404  :     /* don't translate newlines (\r\n <=> \n) */
; 405  :     _setmode(self->fd, O_BINARY);

  00796	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  0079b	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  007a0	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  007a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode

; 406  : #endif
; 407  : 
; 408  :     if (PyObject_SetAttrString((PyObject *)self, "name", nameobj) < 0)

  007a9	4c 8b 44 24 68	 mov	 r8, QWORD PTR nameobj$[rsp]
  007ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MEMAJGDJ@name?$AA@
  007b5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  007ba	e8 00 00 00 00	 call	 PyObject_SetAttrString
  007bf	85 c0		 test	 eax, eax
  007c1	7d 02		 jge	 SHORT $LN9@fileio_ini

; 409  :         goto error;

  007c3	eb 4b		 jmp	 SHORT $error$63983
$LN9@fileio_ini:

; 410  : 
; 411  :     if (self->appending) {

  007c5	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  007ca	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  007cd	c1 e8 03	 shr	 eax, 3
  007d0	83 e0 01	 and	 eax, 1
  007d3	85 c0		 test	 eax, eax
  007d5	74 37		 je	 SHORT $LN8@fileio_ini

; 412  :         /* For consistent behaviour, we explicitly seek to the
; 413  :            end of file (otherwise, it might be done only on the
; 414  :            first write()). */
; 415  :         PyObject *pos = portable_lseek(self->fd, NULL, 2);

  007d7	41 b8 02 00 00
	00		 mov	 r8d, 2
  007dd	33 d2		 xor	 edx, edx
  007df	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  007e4	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  007e7	e8 00 00 00 00	 call	 portable_lseek
  007ec	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pos$64030[rsp], rax

; 416  :         if (pos == NULL)

  007f4	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR pos$64030[rsp], 0
  007fd	75 02		 jne	 SHORT $LN7@fileio_ini

; 417  :             goto error;

  007ff	eb 0f		 jmp	 SHORT $error$63983
$LN7@fileio_ini:

; 418  :         Py_DECREF(pos);

  00801	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pos$64030[rsp]
  00809	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@fileio_ini:

; 419  :     }
; 420  : 
; 421  :     goto done;

  0080e	eb 36		 jmp	 SHORT $done$64035
$error$63983:

; 422  : 
; 423  :  error:
; 424  :     ret = -1;

  00810	c7 84 24 88 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ret$[rsp], -1

; 425  :     if (!fd_is_own)

  0081b	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR fd_is_own$[rsp], 0
  00823	75 0c		 jne	 SHORT $LN6@fileio_ini

; 426  :         self->fd = -1;

  00825	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  0082a	c7 40 60 ff ff
	ff ff		 mov	 DWORD PTR [rax+96], -1
$LN6@fileio_ini:

; 427  :     if (self->fd >= 0)

  00831	48 8b 44 24 78	 mov	 rax, QWORD PTR self$[rsp]
  00836	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  0083a	7c 0a		 jl	 SHORT $LN5@fileio_ini

; 428  :         internal_close(self);

  0083c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR self$[rsp]
  00841	e8 00 00 00 00	 call	 internal_close
$LN5@fileio_ini:
$done$64035:
$LN4@fileio_ini:

; 429  : 
; 430  :  done:
; 431  :     Py_CLEAR(stringobj);

  00846	48 83 7c 24 58
	00		 cmp	 QWORD PTR stringobj$[rsp], 0
  0084c	74 4d		 je	 SHORT $LN1@fileio_ini
  0084e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00856	4c 8b 4c 24 58	 mov	 r9, QWORD PTR stringobj$[rsp]
  0085b	41 b8 af 01 00
	00		 mov	 r8d, 431		; 000001afH
  00861	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  00868	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@LJPPJMDP@fileio_init?$AA@
  0086f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00874	85 c0		 test	 eax, eax
  00876	75 23		 jne	 SHORT $LN1@fileio_ini
  00878	48 8b 44 24 58	 mov	 rax, QWORD PTR stringobj$[rsp]
  0087d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR _py_tmp$64044[rsp], rax
  00885	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR stringobj$[rsp], 0
  0088e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$64044[rsp]
  00896	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@fileio_ini:
  0089b	33 c0		 xor	 eax, eax
  0089d	85 c0		 test	 eax, eax
  0089f	75 a5		 jne	 SHORT $LN4@fileio_ini

; 432  :     return ret;

  008a1	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR ret$[rsp]
$LN62@fileio_ini:

; 433  : }

  008a8	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  008af	c3		 ret	 0
$LN67@fileio_ini:
  008b0	00 00 00 00	 DD	 $LN32@fileio_ini
  008b4	00 00 00 00	 DD	 $LN35@fileio_ini
  008b8	00 00 00 00	 DD	 $LN33@fileio_ini
  008bc	00 00 00 00	 DD	 $LN39@fileio_ini
  008c0	00 00 00 00	 DD	 $LN37@fileio_ini
  008c4	00 00 00 00	 DD	 $LN41@fileio_ini
  008c8	00 00 00 00	 DD	 $LN30@fileio_ini
$LN66@fileio_ini:
  008cc	00		 DB	 0
  008cd	06		 DB	 6
  008ce	06		 DB	 6
  008cf	06		 DB	 6
  008d0	06		 DB	 6
  008d1	06		 DB	 6
  008d2	06		 DB	 6
  008d3	06		 DB	 6
  008d4	06		 DB	 6
  008d5	06		 DB	 6
  008d6	06		 DB	 6
  008d7	06		 DB	 6
  008d8	06		 DB	 6
  008d9	06		 DB	 6
  008da	06		 DB	 6
  008db	06		 DB	 6
  008dc	06		 DB	 6
  008dd	06		 DB	 6
  008de	06		 DB	 6
  008df	06		 DB	 6
  008e0	06		 DB	 6
  008e1	06		 DB	 6
  008e2	06		 DB	 6
  008e3	06		 DB	 6
  008e4	06		 DB	 6
  008e5	06		 DB	 6
  008e6	06		 DB	 6
  008e7	06		 DB	 6
  008e8	06		 DB	 6
  008e9	06		 DB	 6
  008ea	06		 DB	 6
  008eb	06		 DB	 6
  008ec	06		 DB	 6
  008ed	06		 DB	 6
  008ee	06		 DB	 6
  008ef	06		 DB	 6
  008f0	06		 DB	 6
  008f1	06		 DB	 6
  008f2	06		 DB	 6
  008f3	06		 DB	 6
  008f4	06		 DB	 6
  008f5	06		 DB	 6
  008f6	06		 DB	 6
  008f7	06		 DB	 6
  008f8	06		 DB	 6
  008f9	06		 DB	 6
  008fa	06		 DB	 6
  008fb	06		 DB	 6
  008fc	06		 DB	 6
  008fd	06		 DB	 6
  008fe	06		 DB	 6
  008ff	06		 DB	 6
  00900	06		 DB	 6
  00901	06		 DB	 6
  00902	01		 DB	 1
  00903	02		 DB	 2
  00904	06		 DB	 6
  00905	06		 DB	 6
  00906	06		 DB	 6
  00907	06		 DB	 6
  00908	06		 DB	 6
  00909	06		 DB	 6
  0090a	06		 DB	 6
  0090b	06		 DB	 6
  0090c	06		 DB	 6
  0090d	06		 DB	 6
  0090e	06		 DB	 6
  0090f	06		 DB	 6
  00910	06		 DB	 6
  00911	06		 DB	 6
  00912	06		 DB	 6
  00913	03		 DB	 3
  00914	06		 DB	 6
  00915	06		 DB	 6
  00916	06		 DB	 6
  00917	06		 DB	 6
  00918	04		 DB	 4
  00919	05		 DB	 5
fileio_init ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dircheck DD imagerel dircheck
	DD	imagerel dircheck+111
	DD	imagerel $unwind$dircheck
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dircheck DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT dircheck
_TEXT	SEGMENT
buf$ = 32
self$ = 96
nameobj$ = 104
dircheck PROC						; COMDAT

; 175  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 176  : #if defined(HAVE_FSTAT) && defined(S_ISDIR) && defined(EISDIR)
; 177  :     struct stat buf;
; 178  :     if (self->fd < 0)

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00013	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00017	7d 04		 jge	 SHORT $LN2@dircheck

; 179  :         return 0;

  00019	33 c0		 xor	 eax, eax
  0001b	eb 4d		 jmp	 SHORT $LN3@dircheck
$LN2@dircheck:

; 180  :     if (fstat(self->fd, &buf) == 0 && S_ISDIR(buf.st_mode)) {

  0001d	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  00022	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00027	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  0002a	e8 00 00 00 00	 call	 fstat
  0002f	85 c0		 test	 eax, eax
  00031	75 35		 jne	 SHORT $LN1@dircheck
  00033	0f b7 44 24 26	 movzx	 eax, WORD PTR buf$[rsp+6]
  00038	25 00 f0 00 00	 and	 eax, 61440		; 0000f000H
  0003d	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00042	75 24		 jne	 SHORT $LN1@dircheck

; 181  :         errno = EISDIR;

  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004a	c7 00 15 00 00
	00		 mov	 DWORD PTR [rax], 21

; 182  :         PyErr_SetFromErrnoWithFilenameObject(PyExc_IOError, nameobj);

  00050	48 8b 54 24 68	 mov	 rdx, QWORD PTR nameobj$[rsp]
  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0005c	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilenameObject

; 183  :         return -1;

  00061	b8 ff ff ff ff	 mov	 eax, -1
  00066	eb 02		 jmp	 SHORT $LN3@dircheck
$LN1@dircheck:

; 184  :     }
; 185  : #endif
; 186  :     return 0;

  00068	33 c0		 xor	 eax, eax
$LN3@dircheck:

; 187  : }

  0006a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006e	c3		 ret	 0
dircheck ENDP
_TEXT	ENDS
EXTRN	__imp__fstat64i32:PROC
;	COMDAT pdata
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\sys\stat.inl
pdata	SEGMENT
$pdata$fstat DD	imagerel fstat
	DD	imagerel fstat+33
	DD	imagerel $unwind$fstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fstat DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fstat
_TEXT	SEGMENT
_Desc$ = 48
_Stat$ = 56
fstat	PROC						; COMDAT

; 52   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 53   :     _STATIC_ASSERT( sizeof(struct stat) == sizeof(struct _stat64i32) );
; 54   :     return _fstat64i32(_Desc,(struct _stat64i32 *)_Stat);

  0000d	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Stat$[rsp]
  00012	8b 4c 24 30	 mov	 ecx, DWORD PTR _Desc$[rsp]
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64i32

; 55   : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
fstat	ENDP
_TEXT	ENDS
PUBLIC	??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@		; `string'
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_OSError:QWORD
EXTRN	__imp_strerror:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_io\fileio.c
pdata	SEGMENT
$pdata$check_fd DD imagerel check_fd
	DD	imagerel check_fd+156
	DD	imagerel $unwind$check_fd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_fd DD 010801H
	DD	0c208H
xdata	ENDS
;	COMDAT ??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
CONST	SEGMENT
??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@ DB '(is)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT check_fd
_TEXT	SEGMENT
buf$ = 32
msg$63897 = 80
exc$63896 = 88
fd$ = 112
check_fd PROC						; COMDAT

; 191  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 192  : #if defined(HAVE_FSTAT)
; 193  :     struct stat buf;
; 194  :     if (!_PyVerify_fd(fd) || (fstat(fd, &buf) < 0 && errno == EBADF)) {

  00008	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  0000c	e8 00 00 00 00	 call	 _PyVerify_fd
  00011	85 c0		 test	 eax, eax
  00013	74 1d		 je	 SHORT $LN5@check_fd
  00015	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  0001a	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  0001e	e8 00 00 00 00	 call	 fstat
  00023	85 c0		 test	 eax, eax
  00025	7d 6e		 jge	 SHORT $LN6@check_fd
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0002d	83 38 09	 cmp	 DWORD PTR [rax], 9
  00030	75 63		 jne	 SHORT $LN6@check_fd
$LN5@check_fd:

; 195  :         PyObject *exc;
; 196  :         char *msg = strerror(EBADF);

  00032	b9 09 00 00 00	 mov	 ecx, 9
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  0003d	48 89 44 24 50	 mov	 QWORD PTR msg$63897[rsp], rax

; 197  :         exc = PyObject_CallFunction(PyExc_OSError, "(is)",
; 198  :                                     EBADF, msg);

  00042	4c 8b 4c 24 50	 mov	 r9, QWORD PTR msg$63897[rsp]
  00047	41 b8 09 00 00
	00		 mov	 r8d, 9
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04JMLDJNEM@?$CIis?$CJ?$AA@
  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  0005b	e8 00 00 00 00	 call	 _PyObject_CallFunction_SizeT
  00060	48 89 44 24 58	 mov	 QWORD PTR exc$63896[rsp], rax

; 199  :         PyErr_SetObject(PyExc_OSError, exc);

  00065	48 8b 54 24 58	 mov	 rdx, QWORD PTR exc$63896[rsp]
  0006a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  00071	e8 00 00 00 00	 call	 PyErr_SetObject
$LN4@check_fd:

; 200  :         Py_XDECREF(exc);

  00076	48 83 7c 24 58
	00		 cmp	 QWORD PTR exc$63896[rsp], 0
  0007c	74 0a		 je	 SHORT $LN1@check_fd
  0007e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR exc$63896[rsp]
  00083	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@check_fd:
  00088	33 c0		 xor	 eax, eax
  0008a	85 c0		 test	 eax, eax
  0008c	75 e8		 jne	 SHORT $LN4@check_fd

; 201  :         return -1;

  0008e	b8 ff ff ff ff	 mov	 eax, -1
  00093	eb 02		 jmp	 SHORT $LN7@check_fd
$LN6@check_fd:

; 202  :     }
; 203  : #endif
; 204  :     return 0;

  00095	33 c0		 xor	 eax, eax
$LN7@check_fd:

; 205  : }

  00097	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0009b	c3		 ret	 0
check_fd ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@KLLNOING@fileio_traverse?$AA@		; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_traverse DD imagerel fileio_traverse
	DD	imagerel fileio_traverse+116
	DD	imagerel $unwind$fileio_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BA@KLLNOING@fileio_traverse?$AA@
CONST	SEGMENT
??_C@_0BA@KLLNOING@fileio_traverse?$AA@ DB 'fileio_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_traverse
_TEXT	SEGMENT
vret$64062 = 32
self$ = 64
visit$ = 72
arg$ = 80
fileio_traverse PROC					; COMDAT

; 437  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@fileio_tra:

; 438  :     Py_VISIT(self->dict);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@fileio_tra
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KLLNOING@fileio_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@fileio_tra:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003d	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00042	74 23		 je	 SHORT $LN2@fileio_tra
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0004e	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$64062[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$64062[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@fileio_tra
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$64062[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@fileio_tra
$LN1@fileio_tra:
$LN2@fileio_tra:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@fileio_tra

; 439  :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@fileio_tra:

; 440  : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
fileio_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@CALGGHPA@fileio_clear?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_clear DD imagerel fileio_clear
	DD	imagerel fileio_clear+117
	DD	imagerel $unwind$fileio_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_clear DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0N@CALGGHPA@fileio_clear?$AA@
CONST	SEGMENT
??_C@_0N@CALGGHPA@fileio_clear?$AA@ DB 'fileio_clear', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_clear
_TEXT	SEGMENT
_py_tmp$64074 = 48
self$ = 80
fileio_clear PROC					; COMDAT

; 444  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@fileio_cle:

; 445  :     Py_CLEAR(self->dict);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00013	74 53		 je	 SHORT $LN1@fileio_cle
  00015	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00022	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00026	41 b8 bd 01 00
	00		 mov	 r8d, 445		; 000001bdH
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@CALGGHPA@fileio_clear?$AA@
  0003a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003f	85 c0		 test	 eax, eax
  00041	75 25		 jne	 SHORT $LN1@fileio_cle
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00048	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0004c	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$64074[rsp], rax
  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00056	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$64074[rsp]
  00063	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@fileio_cle:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 9b		 jne	 SHORT $LN4@fileio_cle

; 446  :     return 0;

  0006e	33 c0		 xor	 eax, eax

; 447  : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
fileio_clear ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ ; `string'
PUBLIC	??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@		; `string'
EXTRN	PyObject_ClearWeakRefs:PROC
EXTRN	_PyIOBase_finalize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_dealloc DD imagerel fileio_dealloc
	DD	imagerel fileio_dealloc+435
	DD	imagerel $unwind$fileio_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_dealloc DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
CONST	SEGMENT
??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@ DB 'g'
	DB	00H, '-', 00H, '>', 00H, 'g', 00H, 'c', 00H, '.', 00H, 'g', 00H
	DB	'c', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 's', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H, 'y', 00H
	DB	'G', 00H, 'C', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'F', 00H, 'S'
	DB	00H, '_', 00H, 'U', 00H, 'N', 00H, 'T', 00H, 'R', 00H, 'A', 00H
	DB	'C', 00H, 'K', 00H, 'E', 00H, 'D', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@
CONST	SEGMENT
??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@ DB 'fileio_dealloc', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_dealloc
_TEXT	SEGMENT
g$64089 = 48
_py_tmp$64102 = 56
tv85 = 64
self$ = 96
fileio_dealloc PROC					; COMDAT

; 451  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 452  :     self->deallocating = 1;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0000e	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00011	0f ba e8 07	 bts	 eax, 7
  00015	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0001a	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 453  :     if (_PyIOBase_finalize((PyObject *) self) < 0)

  0001d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00022	e8 00 00 00 00	 call	 _PyIOBase_finalize
  00027	85 c0		 test	 eax, eax
  00029	7d 05		 jge	 SHORT $LN10@fileio_dea@2

; 454  :         return;

  0002b	e9 7e 01 00 00	 jmp	 $LN11@fileio_dea@2
$LN10@fileio_dea@2:

; 455  :     _PyObject_GC_UNTRACK(self);

  00030	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR self$[rsp]
  0003d	41 b8 c7 01 00
	00		 mov	 r8d, 455		; 000001c7H
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@
  00051	e8 00 00 00 00	 call	 _PyParallel_Guard
  00056	85 c0		 test	 eax, eax
  00058	0f 85 c1 00 00
	00		 jne	 $LN9@fileio_dea@2
$LN8@fileio_dea@2:
  0005e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00066	4c 8b 4c 24 60	 mov	 r9, QWORD PTR self$[rsp]
  0006b	41 b8 c7 01 00
	00		 mov	 r8d, 455		; 000001c7H
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@
  0007f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00084	85 c0		 test	 eax, eax
  00086	74 0b		 je	 SHORT $LN13@fileio_dea@2
  00088	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv85[rsp], 0
  00091	eb 0e		 jmp	 SHORT $LN14@fileio_dea@2
$LN13@fileio_dea@2:
  00093	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00098	48 83 e8 18	 sub	 rax, 24
  0009c	48 89 44 24 40	 mov	 QWORD PTR tv85[rsp], rax
$LN14@fileio_dea@2:
  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR tv85[rsp]
  000a6	48 89 44 24 30	 mov	 QWORD PTR g$64089[rsp], rax
  000ab	48 8b 44 24 30	 mov	 rax, QWORD PTR g$64089[rsp]
  000b0	48 83 78 10 fe	 cmp	 QWORD PTR [rax+16], -2
  000b5	75 1c		 jne	 SHORT $LN15@fileio_dea@2
  000b7	41 b8 c7 01 00
	00		 mov	 r8d, 455		; 000001c7H
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@JIFCJEHP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@HFMJMDDM@?$AAg?$AA?9?$AA?$DO?$AAg?$AAc?$AA?4?$AAg?$AAc?$AA_?$AAr?$AAe?$AAf?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA_?$AAP?$AAy?$AAG?$AAC?$AA_?$AAR?$AAE?$AAF?$AAS?$AA_?$AAU?$AAN?$AAT?$AAR@
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d1	33 c0		 xor	 eax, eax
$LN15@fileio_dea@2:
  000d3	48 8b 44 24 30	 mov	 rax, QWORD PTR g$64089[rsp]
  000d8	48 c7 40 10 fe
	ff ff ff	 mov	 QWORD PTR [rax+16], -2
  000e0	48 8b 44 24 30	 mov	 rax, QWORD PTR g$64089[rsp]
  000e5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000e9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$64089[rsp]
  000ee	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000f1	48 89 08	 mov	 QWORD PTR [rax], rcx
  000f4	48 8b 44 24 30	 mov	 rax, QWORD PTR g$64089[rsp]
  000f9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR g$64089[rsp]
  00101	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00105	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00109	48 8b 44 24 30	 mov	 rax, QWORD PTR g$64089[rsp]
  0010e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00115	33 c0		 xor	 eax, eax
  00117	85 c0		 test	 eax, eax
  00119	0f 85 3f ff ff
	ff		 jne	 $LN8@fileio_dea@2
$LN9@fileio_dea@2:

; 456  :     if (self->weakreflist != NULL)

  0011f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00124	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00129	74 0a		 je	 SHORT $LN5@fileio_dea@2

; 457  :         PyObject_ClearWeakRefs((PyObject *) self);

  0012b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00130	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN5@fileio_dea@2:
$LN4@fileio_dea@2:

; 458  :     Py_CLEAR(self->dict);

  00135	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0013a	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0013f	74 53		 je	 SHORT $LN1@fileio_dea@2
  00141	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00149	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0014e	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00152	41 b8 ca 01 00
	00		 mov	 r8d, 458		; 000001caH
  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@DCGBAKIJ@?4?4?2Modules?2_io?2fileio?4c?$AA@
  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IGKLGLEI@fileio_dealloc?$AA@
  00166	e8 00 00 00 00	 call	 _PyParallel_Guard
  0016b	85 c0		 test	 eax, eax
  0016d	75 25		 jne	 SHORT $LN1@fileio_dea@2
  0016f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00174	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00178	48 89 44 24 38	 mov	 QWORD PTR _py_tmp$64102[rsp], rax
  0017d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00182	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
  0018a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _py_tmp$64102[rsp]
  0018f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@fileio_dea@2:
  00194	33 c0		 xor	 eax, eax
  00196	85 c0		 test	 eax, eax
  00198	75 9b		 jne	 SHORT $LN4@fileio_dea@2

; 459  :     Py_TYPE(self)->tp_free((PyObject *)self);

  0019a	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0019f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001a8	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]
$LN11@fileio_dea@2:

; 460  : }

  001ae	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b2	c3		 ret	 0
fileio_dealloc ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_fileno DD imagerel fileio_fileno
	DD	imagerel fileio_fileno+45
	DD	imagerel $unwind$fileio_fileno
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_fileno DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fileio_fileno
_TEXT	SEGMENT
self$ = 48
fileio_fileno PROC					; COMDAT

; 479  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 480  :     if (self->fd < 0)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00012	7d 07		 jge	 SHORT $LN1@fileio_fil

; 481  :         return err_closed();

  00014	e8 00 00 00 00	 call	 err_closed
  00019	eb 0d		 jmp	 SHORT $LN2@fileio_fil
$LN1@fileio_fil:

; 482  :     return PyLong_FromLong((long) self->fd);

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  00023	e8 00 00 00 00	 call	 PyLong_FromLong
$LN2@fileio_fil:

; 483  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
fileio_fileno ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@EBOEDLCG@I?1O?5operation?5on?5closed?5file?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$err_closed DD imagerel err_closed
	DD	imagerel err_closed+30
	DD	imagerel $unwind$err_closed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$err_closed DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BN@EBOEDLCG@I?1O?5operation?5on?5closed?5file?$AA@
CONST	SEGMENT
??_C@_0BN@EBOEDLCG@I?1O?5operation?5on?5closed?5file?$AA@ DB 'I/O operati'
	DB	'on on closed file', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT err_closed
_TEXT	SEGMENT
err_closed PROC						; COMDAT

; 464  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 465  :     PyErr_SetString(PyExc_ValueError, "I/O operation on closed file");

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@EBOEDLCG@I?1O?5operation?5on?5closed?5file?$AA@
  0000b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 466  :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 467  : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
err_closed ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_readable DD imagerel fileio_readable
	DD	imagerel fileio_readable+52
	DD	imagerel $unwind$fileio_readable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_readable DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fileio_readable
_TEXT	SEGMENT
self$ = 48
fileio_readable PROC					; COMDAT

; 487  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 488  :     if (self->fd < 0)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00012	7d 07		 jge	 SHORT $LN1@fileio_rea

; 489  :         return err_closed();

  00014	e8 00 00 00 00	 call	 err_closed
  00019	eb 14		 jmp	 SHORT $LN2@fileio_rea
$LN1@fileio_rea:

; 490  :     return PyBool_FromLong((long) self->readable);

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00023	d1 e8		 shr	 eax, 1
  00025	83 e0 01	 and	 eax, 1
  00028	8b c8		 mov	 ecx, eax
  0002a	e8 00 00 00 00	 call	 PyBool_FromLong
$LN2@fileio_rea:

; 491  : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
fileio_readable ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_writable DD imagerel fileio_writable
	DD	imagerel fileio_writable+53
	DD	imagerel $unwind$fileio_writable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_writable DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fileio_writable
_TEXT	SEGMENT
self$ = 48
fileio_writable PROC					; COMDAT

; 495  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 496  :     if (self->fd < 0)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00012	7d 07		 jge	 SHORT $LN1@fileio_wri

; 497  :         return err_closed();

  00014	e8 00 00 00 00	 call	 err_closed
  00019	eb 15		 jmp	 SHORT $LN2@fileio_wri
$LN1@fileio_wri:

; 498  :     return PyBool_FromLong((long) self->writable);

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00020	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00023	c1 e8 02	 shr	 eax, 2
  00026	83 e0 01	 and	 eax, 1
  00029	8b c8		 mov	 ecx, eax
  0002b	e8 00 00 00 00	 call	 PyBool_FromLong
$LN2@fileio_wri:

; 499  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
fileio_writable ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_seekable DD imagerel fileio_seekable
	DD	imagerel fileio_seekable+166
	DD	imagerel $unwind$fileio_seekable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_seekable DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fileio_seekable
_TEXT	SEGMENT
pos$64144 = 32
self$ = 64
fileio_seekable PROC					; COMDAT

; 503  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 504  :     if (self->fd < 0)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00012	7d 0a		 jge	 SHORT $LN4@fileio_see

; 505  :         return err_closed();

  00014	e8 00 00 00 00	 call	 err_closed
  00019	e9 83 00 00 00	 jmp	 $LN5@fileio_see
$LN4@fileio_see:

; 506  :     if (self->seekable < 0) {

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00023	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00026	c1 e0 1a	 shl	 eax, 26
  00029	c1 f8 1e	 sar	 eax, 30
  0002c	85 c0		 test	 eax, eax
  0002e	7d 5c		 jge	 SHORT $LN3@fileio_see

; 507  :         PyObject *pos = portable_lseek(self->fd, NULL, SEEK_CUR);

  00030	41 b8 01 00 00
	00		 mov	 r8d, 1
  00036	33 d2		 xor	 edx, edx
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003d	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  00040	e8 00 00 00 00	 call	 portable_lseek
  00045	48 89 44 24 20	 mov	 QWORD PTR pos$64144[rsp], rax

; 508  :         if (pos == NULL) {

  0004a	48 83 7c 24 20
	00		 cmp	 QWORD PTR pos$64144[rsp], 0
  00050	75 1a		 jne	 SHORT $LN2@fileio_see

; 509  :             PyErr_Clear();

  00052	e8 00 00 00 00	 call	 PyErr_Clear

; 510  :             self->seekable = 0;

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0005c	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0005f	83 e0 cf	 and	 eax, -49		; ffffffffffffffcfH
  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00067	89 41 64	 mov	 DWORD PTR [rcx+100], eax

; 511  :         } else {

  0006a	eb 20		 jmp	 SHORT $LN1@fileio_see
$LN2@fileio_see:

; 512  :             Py_DECREF(pos);

  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pos$64144[rsp]
  00071	e8 00 00 00 00	 call	 _Py_DecRef

; 513  :             self->seekable = 1;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0007b	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0007e	83 e0 cf	 and	 eax, -49		; ffffffffffffffcfH
  00081	83 c8 10	 or	 eax, 16
  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00089	89 41 64	 mov	 DWORD PTR [rcx+100], eax
$LN1@fileio_see:
$LN3@fileio_see:

; 514  :         }
; 515  :     }
; 516  :     return PyBool_FromLong((long) self->seekable);

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00091	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00094	c1 e0 1a	 shl	 eax, 26
  00097	c1 f8 1e	 sar	 eax, 30
  0009a	8b c8		 mov	 ecx, eax
  0009c	e8 00 00 00 00	 call	 PyBool_FromLong
$LN5@fileio_see:

; 517  : }

  000a1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a5	c3		 ret	 0
fileio_seekable ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DOGLJEBA@w?$CK?$AA@			; `string'
PUBLIC	??_C@_07CMOHHLII@reading?$AA@			; `string'
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	PyBuffer_Release:PROC
EXTRN	__imp_read:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_readinto DD imagerel fileio_readinto
	DD	imagerel fileio_readinto+372
	DD	imagerel $unwind$fileio_readinto
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_readinto DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_02DOGLJEBA@w?$CK?$AA@
CONST	SEGMENT
??_C@_02DOGLJEBA@w?$CK?$AA@ DB 'w*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CMOHHLII@reading?$AA@
CONST	SEGMENT
??_C@_07CMOHHLII@reading?$AA@ DB 'reading', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_readinto
_TEXT	SEGMENT
n$ = 32
pbuf$ = 48
len$ = 128
err$ = 136
_save$64168 = 144
self$ = 176
args$ = 184
fileio_readinto PROC					; COMDAT

; 521  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 522  :     Py_buffer pbuf;
; 523  :     Py_ssize_t n, len;
; 524  :     int err;
; 525  : 
; 526  :     if (self->fd < 0)

  00011	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00019	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  0001d	7d 0a		 jge	 SHORT $LN8@fileio_rea@2

; 527  :         return err_closed();

  0001f	e8 00 00 00 00	 call	 err_closed
  00024	e9 43 01 00 00	 jmp	 $LN9@fileio_rea@2
$LN8@fileio_rea@2:

; 528  :     if (!self->readable)

  00029	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00031	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00034	d1 e8		 shr	 eax, 1
  00036	83 e0 01	 and	 eax, 1
  00039	85 c0		 test	 eax, eax
  0003b	75 11		 jne	 SHORT $LN7@fileio_rea@2

; 529  :         return err_mode("reading");

  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07CMOHHLII@reading?$AA@
  00044	e8 00 00 00 00	 call	 err_mode
  00049	e9 1e 01 00 00	 jmp	 $LN9@fileio_rea@2
$LN7@fileio_rea@2:

; 530  : 
; 531  :     if (!PyArg_ParseTuple(args, "w*", &pbuf))

  0004e	4c 8d 44 24 30	 lea	 r8, QWORD PTR pbuf$[rsp]
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DOGLJEBA@w?$CK?$AA@
  0005a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00062	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00067	85 c0		 test	 eax, eax
  00069	75 07		 jne	 SHORT $LN6@fileio_rea@2

; 532  :         return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 fa 00 00 00	 jmp	 $LN9@fileio_rea@2
$LN6@fileio_rea@2:

; 533  : 
; 534  :     if (_PyVerify_fd(self->fd)) {

  00072	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0007a	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  0007d	e8 00 00 00 00	 call	 _PyVerify_fd
  00082	85 c0		 test	 eax, eax
  00084	74 74		 je	 SHORT $LN5@fileio_rea@2

; 535  :         len = pbuf.len;

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR pbuf$[rsp+16]
  0008b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 536  :         Py_BEGIN_ALLOW_THREADS

  00093	e8 00 00 00 00	 call	 PyEval_SaveThread
  00098	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR _save$64168[rsp], rax

; 537  :         errno = 0;

  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a6	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 538  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 539  :         if (len > INT_MAX)

  000ac	48 81 bc 24 80
	00 00 00 ff ff
	ff 7f		 cmp	 QWORD PTR len$[rsp], 2147483647 ; 7fffffffH
  000b8	7e 0c		 jle	 SHORT $LN4@fileio_rea@2

; 540  :             len = INT_MAX;

  000ba	48 c7 84 24 80
	00 00 00 ff ff
	ff 7f		 mov	 QWORD PTR len$[rsp], 2147483647 ; 7fffffffH
$LN4@fileio_rea@2:

; 541  :         n = read(self->fd, pbuf.buf, (int)len);

  000c6	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  000ce	48 8b 54 24 30	 mov	 rdx, QWORD PTR pbuf$[rsp]
  000d3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000db	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  000e4	48 98		 cdqe
  000e6	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 542  : #else
; 543  :         n = read(self->fd, pbuf.buf, len);
; 544  : #endif
; 545  :         Py_END_ALLOW_THREADS

  000eb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _save$64168[rsp]
  000f3	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 546  :     } else

  000f8	eb 09		 jmp	 SHORT $LN3@fileio_rea@2
$LN5@fileio_rea@2:

; 547  :         n = -1;

  000fa	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR n$[rsp], -1
$LN3@fileio_rea@2:

; 548  :     err = errno;

  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00109	8b 00		 mov	 eax, DWORD PTR [rax]
  0010b	89 84 24 88 00
	00 00		 mov	 DWORD PTR err$[rsp], eax

; 549  :     PyBuffer_Release(&pbuf);

  00112	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pbuf$[rsp]
  00117	e8 00 00 00 00	 call	 PyBuffer_Release

; 550  :     if (n < 0) {

  0011c	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  00122	7d 3e		 jge	 SHORT $LN2@fileio_rea@2

; 551  :         if (err == EAGAIN)

  00124	83 bc 24 88 00
	00 00 0b	 cmp	 DWORD PTR err$[rsp], 11
  0012c	75 15		 jne	 SHORT $LN1@fileio_rea@2

; 552  :             Py_RETURN_NONE;

  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00135	e8 00 00 00 00	 call	 _Py_IncRef
  0013a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00141	eb 29		 jmp	 SHORT $LN9@fileio_rea@2
$LN1@fileio_rea@2:

; 553  :         errno = err;

  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00149	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR err$[rsp]
  00150	89 08		 mov	 DWORD PTR [rax], ecx

; 554  :         PyErr_SetFromErrno(PyExc_IOError);

  00152	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00159	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 555  :         return NULL;

  0015e	33 c0		 xor	 eax, eax
  00160	eb 0a		 jmp	 SHORT $LN9@fileio_rea@2
$LN2@fileio_rea@2:

; 556  :     }
; 557  : 
; 558  :     return PyLong_FromSsize_t(n);

  00162	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  00167	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN9@fileio_rea@2:

; 559  : }

  0016c	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00173	c3		 ret	 0
fileio_readinto ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@HEANNEGE@File?5not?5open?5for?5?$CFs?$AA@ ; `string'
EXTRN	PyModule_GetState:PROC
EXTRN	PyState_FindModule:PROC
EXTRN	_PyIO_Module:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$err_mode DD imagerel err_mode
	DD	imagerel err_mode+57
	DD	imagerel $unwind$err_mode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$err_mode DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BF@HEANNEGE@File?5not?5open?5for?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BF@HEANNEGE@File?5not?5open?5for?5?$CFs?$AA@ DB 'File not open for'
	DB	' %s', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT err_mode
_TEXT	SEGMENT
action$ = 48
err_mode PROC						; COMDAT

; 471  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 472  :     PyErr_Format(IO_STATE->unsupported_operation,
; 473  :                  "File not open for %s", action);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyIO_Module
  00010	e8 00 00 00 00	 call	 PyState_FindModule
  00015	48 8b c8	 mov	 rcx, rax
  00018	e8 00 00 00 00	 call	 PyModule_GetState
  0001d	4c 8b 44 24 30	 mov	 r8, QWORD PTR action$[rsp]
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@HEANNEGE@File?5not?5open?5for?5?$CFs?$AA@
  00029	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0002d	e8 00 00 00 00	 call	 PyErr_Format

; 474  :     return NULL;

  00032	33 c0		 xor	 eax, eax

; 475  : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
err_mode ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0EC@DJFGBHMB@unbounded?5read?5returned?5more?5byt@ ; `string'
EXTRN	PyErr_CheckSignals:PROC
EXTRN	_PyBytes_Resize:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	__imp__lseeki64:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_readall DD imagerel fileio_readall
	DD	imagerel fileio_readall+903
	DD	imagerel $unwind$fileio_readall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_readall DD 020c01H
	DD	013010cH
xdata	ENDS
;	COMDAT ??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@DJFGBHMB@unbounded?5read?5returned?5more?5byt@
CONST	SEGMENT
??_C@_0EC@DJFGBHMB@unbounded?5read?5returned?5more?5byt@ DB 'unbounded re'
	DB	'ad returned more bytes than a Python string can hold ', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_readall
_TEXT	SEGMENT
n$ = 32
newsize$ = 40
st$ = 48
total$ = 96
end$ = 104
result$ = 112
pos$ = 120
_save$64241 = 128
self$ = 160
fileio_readall PROC					; COMDAT

; 600  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 601  : #ifdef HAVE_FSTAT
; 602  :     struct stat st;
; 603  :     Py_off_t pos, end;
; 604  : #endif
; 605  :     PyObject *result;
; 606  :     Py_ssize_t total = 0;

  0000c	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR total$[rsp], 0

; 607  :     Py_ssize_t n;
; 608  :     size_t newsize;
; 609  : 
; 610  :     if (self->fd < 0)

  00015	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001d	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00021	7d 0a		 jge	 SHORT $LN21@fileio_rea@3

; 611  :         return err_closed();

  00023	e8 00 00 00 00	 call	 err_closed
  00028	e9 52 03 00 00	 jmp	 $LN22@fileio_rea@3
$LN21@fileio_rea@3:

; 612  :     if (!_PyVerify_fd(self->fd))

  0002d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00035	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  00038	e8 00 00 00 00	 call	 _PyVerify_fd
  0003d	85 c0		 test	 eax, eax
  0003f	75 11		 jne	 SHORT $LN20@fileio_rea@3

; 613  :         return PyErr_SetFromErrno(PyExc_IOError);

  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00048	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  0004d	e9 2d 03 00 00	 jmp	 $LN22@fileio_rea@3
$LN20@fileio_rea@3:

; 614  : 
; 615  :     result = PyBytes_FromStringAndSize(NULL, SMALLCHUNK);

  00052	ba 00 20 00 00	 mov	 edx, 8192		; 00002000H
  00057	33 c9		 xor	 ecx, ecx
  00059	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0005e	48 89 44 24 70	 mov	 QWORD PTR result$[rsp], rax

; 616  :     if (result == NULL)

  00063	48 83 7c 24 70
	00		 cmp	 QWORD PTR result$[rsp], 0
  00069	75 07		 jne	 SHORT $LN19@fileio_rea@3

; 617  :         return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 0d 03 00 00	 jmp	 $LN22@fileio_rea@3
$LN19@fileio_rea@3:

; 618  : 
; 619  : #ifdef HAVE_FSTAT
; 620  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 621  :     pos = _lseeki64(self->fd, 0L, SEEK_CUR);

  00072	41 b8 01 00 00
	00		 mov	 r8d, 1
  00078	33 d2		 xor	 edx, edx
  0007a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00082	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  0008b	48 89 44 24 78	 mov	 QWORD PTR pos$[rsp], rax

; 622  : #else
; 623  :     pos = lseek(self->fd, 0L, SEEK_CUR);
; 624  : #endif
; 625  :     if (fstat(self->fd, &st) == 0)

  00090	48 8d 54 24 30	 lea	 rdx, QWORD PTR st$[rsp]
  00095	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0009d	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  000a0	e8 00 00 00 00	 call	 fstat
  000a5	85 c0		 test	 eax, eax
  000a7	75 0c		 jne	 SHORT $LN18@fileio_rea@3

; 626  :         end = st.st_size;

  000a9	48 63 44 24 44	 movsxd	 rax, DWORD PTR st$[rsp+20]
  000ae	48 89 44 24 68	 mov	 QWORD PTR end$[rsp], rax

; 627  :     else

  000b3	eb 09		 jmp	 SHORT $LN17@fileio_rea@3
$LN18@fileio_rea@3:

; 628  :         end = (Py_off_t)-1;

  000b5	48 c7 44 24 68
	ff ff ff ff	 mov	 QWORD PTR end$[rsp], -1
$LN17@fileio_rea@3:
$LN27@fileio_rea@3:
$LN16@fileio_rea@3:

; 629  : #endif
; 630  :     while (1) {

  000be	33 c0		 xor	 eax, eax
  000c0	83 f8 01	 cmp	 eax, 1
  000c3	0f 84 4c 02 00
	00		 je	 $LN15@fileio_rea@3

; 631  : #ifdef HAVE_FSTAT
; 632  :         newsize = new_buffersize(self, total, pos, end);

  000c9	4c 8b 4c 24 68	 mov	 r9, QWORD PTR end$[rsp]
  000ce	4c 8b 44 24 78	 mov	 r8, QWORD PTR pos$[rsp]
  000d3	48 8b 54 24 60	 mov	 rdx, QWORD PTR total$[rsp]
  000d8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  000e0	e8 00 00 00 00	 call	 new_buffersize
  000e5	48 89 44 24 28	 mov	 QWORD PTR newsize$[rsp], rax

; 633  : #else
; 634  :         newsize = new_buffersize(self, total);
; 635  : #endif
; 636  :         if (newsize > PY_SSIZE_T_MAX || newsize <= 0) {

  000ea	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000f4	48 39 44 24 28	 cmp	 QWORD PTR newsize$[rsp], rax
  000f9	77 08		 ja	 SHORT $LN13@fileio_rea@3
  000fb	48 83 7c 24 28
	00		 cmp	 QWORD PTR newsize$[rsp], 0
  00101	77 24		 ja	 SHORT $LN14@fileio_rea@3
$LN13@fileio_rea@3:

; 637  :             PyErr_SetString(PyExc_OverflowError,
; 638  :                 "unbounded read returned more bytes "
; 639  :                 "than a Python string can hold ");

  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EC@DJFGBHMB@unbounded?5read?5returned?5more?5byt@
  0010a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00111	e8 00 00 00 00	 call	 PyErr_SetString

; 640  :             Py_DECREF(result);

  00116	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result$[rsp]
  0011b	e8 00 00 00 00	 call	 _Py_DecRef

; 641  :             return NULL;

  00120	33 c0		 xor	 eax, eax
  00122	e9 58 02 00 00	 jmp	 $LN22@fileio_rea@3
$LN14@fileio_rea@3:

; 642  :         }
; 643  : 
; 644  :         if (PyBytes_GET_SIZE(result) < (Py_ssize_t)newsize) {

  00127	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  0012c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00130	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00136	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0013b	85 c0		 test	 eax, eax
  0013d	75 1c		 jne	 SHORT $LN24@fileio_rea@3
  0013f	41 b8 84 02 00
	00		 mov	 r8d, 644		; 00000284H
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@JIFCJEHP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00159	33 c0		 xor	 eax, eax
$LN24@fileio_rea@3:
  0015b	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  00160	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newsize$[rsp]
  00165	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00169	7d 36		 jge	 SHORT $LN12@fileio_rea@3

; 645  :             if (_PyBytes_Resize(&result, newsize) < 0) {

  0016b	48 8b 54 24 28	 mov	 rdx, QWORD PTR newsize$[rsp]
  00170	48 8d 4c 24 70	 lea	 rcx, QWORD PTR result$[rsp]
  00175	e8 00 00 00 00	 call	 _PyBytes_Resize
  0017a	85 c0		 test	 eax, eax
  0017c	7d 23		 jge	 SHORT $LN11@fileio_rea@3

; 646  :                 if (total == 0) {

  0017e	48 83 7c 24 60
	00		 cmp	 QWORD PTR total$[rsp], 0
  00184	75 11		 jne	 SHORT $LN10@fileio_rea@3

; 647  :                     Py_DECREF(result);

  00186	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result$[rsp]
  0018b	e8 00 00 00 00	 call	 _Py_DecRef

; 648  :                     return NULL;

  00190	33 c0		 xor	 eax, eax
  00192	e9 e8 01 00 00	 jmp	 $LN22@fileio_rea@3
$LN10@fileio_rea@3:

; 649  :                 }
; 650  :                 PyErr_Clear();

  00197	e8 00 00 00 00	 call	 PyErr_Clear

; 651  :                 break;

  0019c	e9 74 01 00 00	 jmp	 $LN15@fileio_rea@3
$LN11@fileio_rea@3:
$LN12@fileio_rea@3:

; 652  :             }
; 653  :         }
; 654  :         Py_BEGIN_ALLOW_THREADS

  001a1	e8 00 00 00 00	 call	 PyEval_SaveThread
  001a6	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR _save$64241[rsp], rax

; 655  :         errno = 0;

  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001b4	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 656  :         n = newsize - total;

  001ba	48 8b 44 24 60	 mov	 rax, QWORD PTR total$[rsp]
  001bf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newsize$[rsp]
  001c4	48 2b c8	 sub	 rcx, rax
  001c7	48 8b c1	 mov	 rax, rcx
  001ca	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 657  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 658  :         if (n > INT_MAX)

  001cf	48 81 7c 24 20
	ff ff ff 7f	 cmp	 QWORD PTR n$[rsp], 2147483647 ; 7fffffffH
  001d8	7e 09		 jle	 SHORT $LN9@fileio_rea@3

; 659  :             n = INT_MAX;

  001da	48 c7 44 24 20
	ff ff ff 7f	 mov	 QWORD PTR n$[rsp], 2147483647 ; 7fffffffH
$LN9@fileio_rea@3:

; 660  :         n = read(self->fd,
; 661  :                  PyBytes_AS_STRING(result) + total,
; 662  :                  (int)n);

  001e3	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  001e8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001ec	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001f2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001f7	85 c0		 test	 eax, eax
  001f9	75 1c		 jne	 SHORT $LN25@fileio_rea@3
  001fb	41 b8 95 02 00
	00		 mov	 r8d, 661		; 00000295H
  00201	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@JIFCJEHP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00215	33 c0		 xor	 eax, eax
$LN25@fileio_rea@3:
  00217	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  0021c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR total$[rsp]
  00221	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  00226	44 8b 44 24 20	 mov	 r8d, DWORD PTR n$[rsp]
  0022b	48 8b d0	 mov	 rdx, rax
  0022e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00236	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  0023f	48 98		 cdqe
  00241	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 663  : #else
; 664  :         n = read(self->fd,
; 665  :                  PyBytes_AS_STRING(result) + total,
; 666  :                  n);
; 667  : #endif
; 668  :         Py_END_ALLOW_THREADS

  00246	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _save$64241[rsp]
  0024e	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 669  :         if (n == 0)

  00253	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  00259	75 05		 jne	 SHORT $LN8@fileio_rea@3

; 670  :             break;

  0025b	e9 b5 00 00 00	 jmp	 $LN15@fileio_rea@3
$LN8@fileio_rea@3:

; 671  :         if (n < 0) {

  00260	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  00266	7d 7e		 jge	 SHORT $LN7@fileio_rea@3

; 672  :             if (errno == EINTR) {

  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0026e	83 38 04	 cmp	 DWORD PTR [rax], 4
  00271	75 1f		 jne	 SHORT $LN6@fileio_rea@3

; 673  :                 if (PyErr_CheckSignals()) {

  00273	e8 00 00 00 00	 call	 PyErr_CheckSignals
  00278	85 c0		 test	 eax, eax
  0027a	74 11		 je	 SHORT $LN5@fileio_rea@3

; 674  :                     Py_DECREF(result);

  0027c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result$[rsp]
  00281	e8 00 00 00 00	 call	 _Py_DecRef

; 675  :                     return NULL;

  00286	33 c0		 xor	 eax, eax
  00288	e9 f2 00 00 00	 jmp	 $LN22@fileio_rea@3
$LN5@fileio_rea@3:

; 676  :                 }
; 677  :                 continue;

  0028d	e9 2c fe ff ff	 jmp	 $LN16@fileio_rea@3
$LN6@fileio_rea@3:

; 678  :             }
; 679  :             if (total > 0)

  00292	48 83 7c 24 60
	00		 cmp	 QWORD PTR total$[rsp], 0
  00298	7e 02		 jle	 SHORT $LN4@fileio_rea@3

; 680  :                 break;

  0029a	eb 79		 jmp	 SHORT $LN15@fileio_rea@3
$LN4@fileio_rea@3:

; 681  :             if (errno == EAGAIN) {

  0029c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a2	83 38 0b	 cmp	 DWORD PTR [rax], 11
  002a5	75 22		 jne	 SHORT $LN3@fileio_rea@3

; 682  :                 Py_DECREF(result);

  002a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result$[rsp]
  002ac	e8 00 00 00 00	 call	 _Py_DecRef

; 683  :                 Py_RETURN_NONE;

  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  002b8	e8 00 00 00 00	 call	 _Py_IncRef
  002bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  002c4	e9 b6 00 00 00	 jmp	 $LN22@fileio_rea@3
$LN3@fileio_rea@3:

; 684  :             }
; 685  :             Py_DECREF(result);

  002c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result$[rsp]
  002ce	e8 00 00 00 00	 call	 _Py_DecRef

; 686  :             PyErr_SetFromErrno(PyExc_IOError);

  002d3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  002da	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 687  :             return NULL;

  002df	33 c0		 xor	 eax, eax
  002e1	e9 99 00 00 00	 jmp	 $LN22@fileio_rea@3
$LN7@fileio_rea@3:

; 688  :         }
; 689  :         total += n;

  002e6	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  002eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR total$[rsp]
  002f0	48 03 c8	 add	 rcx, rax
  002f3	48 8b c1	 mov	 rax, rcx
  002f6	48 89 44 24 60	 mov	 QWORD PTR total$[rsp], rax

; 690  : #ifdef HAVE_FSTAT
; 691  :         pos += n;

  002fb	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00300	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pos$[rsp]
  00305	48 03 c8	 add	 rcx, rax
  00308	48 8b c1	 mov	 rax, rcx
  0030b	48 89 44 24 78	 mov	 QWORD PTR pos$[rsp], rax

; 692  : #endif
; 693  :     }

  00310	e9 a9 fd ff ff	 jmp	 $LN27@fileio_rea@3
$LN15@fileio_rea@3:

; 694  : 
; 695  :     if (PyBytes_GET_SIZE(result) > total) {

  00315	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  0031a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0031e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00324	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00329	85 c0		 test	 eax, eax
  0032b	75 1c		 jne	 SHORT $LN26@fileio_rea@3
  0032d	41 b8 b7 02 00
	00		 mov	 r8d, 695		; 000002b7H
  00333	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@JIFCJEHP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  0033a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  00341	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00347	33 c0		 xor	 eax, eax
$LN26@fileio_rea@3:
  00349	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
  0034e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR total$[rsp]
  00353	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00357	7e 21		 jle	 SHORT $LN2@fileio_rea@3

; 696  :         if (_PyBytes_Resize(&result, total) < 0) {

  00359	48 8b 54 24 60	 mov	 rdx, QWORD PTR total$[rsp]
  0035e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR result$[rsp]
  00363	e8 00 00 00 00	 call	 _PyBytes_Resize
  00368	85 c0		 test	 eax, eax
  0036a	7d 0e		 jge	 SHORT $LN1@fileio_rea@3

; 697  :             /* This should never happen, but just in case */
; 698  :             Py_DECREF(result);

  0036c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result$[rsp]
  00371	e8 00 00 00 00	 call	 _Py_DecRef

; 699  :             return NULL;

  00376	33 c0		 xor	 eax, eax
  00378	eb 05		 jmp	 SHORT $LN22@fileio_rea@3
$LN1@fileio_rea@3:
$LN2@fileio_rea@3:

; 700  :         }
; 701  :     }
; 702  :     return result;

  0037a	48 8b 44 24 70	 mov	 rax, QWORD PTR result$[rsp]
$LN22@fileio_rea@3:

; 703  : }

  0037f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00386	c3		 ret	 0
fileio_readall ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_buffersize DD imagerel new_buffersize
	DD	imagerel new_buffersize+209
	DD	imagerel $unwind$new_buffersize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_buffersize DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT new_buffersize
_TEXT	SEGMENT
addend$ = 0
bufsize$64190 = 8
self$ = 32
currentsize$ = 40
pos$ = 48
end$ = 56
new_buffersize PROC					; COMDAT

; 567  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 568  :     size_t addend;
; 569  : #ifdef HAVE_FSTAT
; 570  :     if (end != (Py_off_t)-1) {

  00018	48 83 7c 24 38
	ff		 cmp	 QWORD PTR end$[rsp], -1
  0001e	74 62		 je	 SHORT $LN7@new_buffer

; 571  :         /* Files claiming a size smaller than SMALLCHUNK may
; 572  :            actually be streaming pseudo-files. In this case, we
; 573  :            apply the more aggressive algorithm below.
; 574  :         */
; 575  :         if (end >= SMALLCHUNK && end >= pos && pos >= 0) {

  00020	48 81 7c 24 38
	00 20 00 00	 cmp	 QWORD PTR end$[rsp], 8192 ; 00002000H
  00029	7c 57		 jl	 SHORT $LN6@new_buffer
  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR pos$[rsp]
  00030	48 39 44 24 38	 cmp	 QWORD PTR end$[rsp], rax
  00035	7c 4b		 jl	 SHORT $LN6@new_buffer
  00037	48 83 7c 24 30
	00		 cmp	 QWORD PTR pos$[rsp], 0
  0003d	7c 43		 jl	 SHORT $LN6@new_buffer

; 576  :             /* Add 1 so if the file were to grow we'd notice. */
; 577  :             Py_off_t bufsize = currentsize + end - pos + 1;

  0003f	48 8b 44 24 38	 mov	 rax, QWORD PTR end$[rsp]
  00044	48 8b 4c 24 28	 mov	 rcx, QWORD PTR currentsize$[rsp]
  00049	48 03 c8	 add	 rcx, rax
  0004c	48 8b c1	 mov	 rax, rcx
  0004f	48 2b 44 24 30	 sub	 rax, QWORD PTR pos$[rsp]
  00054	48 ff c0	 inc	 rax
  00057	48 89 44 24 08	 mov	 QWORD PTR bufsize$64190[rsp], rax

; 578  :             if (bufsize < PY_SSIZE_T_MAX)

  0005c	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00066	48 39 44 24 08	 cmp	 QWORD PTR bufsize$64190[rsp], rax
  0006b	7d 09		 jge	 SHORT $LN5@new_buffer

; 579  :                 return (size_t)bufsize;

  0006d	48 8b 44 24 08	 mov	 rax, QWORD PTR bufsize$64190[rsp]
  00072	eb 58		 jmp	 SHORT $LN8@new_buffer

; 580  :             else

  00074	eb 0c		 jmp	 SHORT $LN4@new_buffer
$LN5@new_buffer:

; 581  :                 return PY_SSIZE_T_MAX;

  00076	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00080	eb 4a		 jmp	 SHORT $LN8@new_buffer
$LN4@new_buffer:
$LN6@new_buffer:
$LN7@new_buffer:

; 582  :         }
; 583  :     }
; 584  : #endif
; 585  :     /* Expand the buffer by an amount proportional to the current size,
; 586  :        giving us amortized linear-time behavior.  For bigger sizes, use a
; 587  :        less-than-double growth factor to avoid excessive allocation. */
; 588  :     if (currentsize > 65536)

  00082	48 81 7c 24 28
	00 00 01 00	 cmp	 QWORD PTR currentsize$[rsp], 65536 ; 00010000H
  0008b	76 0f		 jbe	 SHORT $LN3@new_buffer

; 589  :         addend = currentsize >> 3;

  0008d	48 8b 44 24 28	 mov	 rax, QWORD PTR currentsize$[rsp]
  00092	48 c1 e8 03	 shr	 rax, 3
  00096	48 89 04 24	 mov	 QWORD PTR addend$[rsp], rax

; 590  :     else

  0009a	eb 0f		 jmp	 SHORT $LN2@new_buffer
$LN3@new_buffer:

; 591  :         addend = 256 + currentsize;

  0009c	48 8b 44 24 28	 mov	 rax, QWORD PTR currentsize$[rsp]
  000a1	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  000a7	48 89 04 24	 mov	 QWORD PTR addend$[rsp], rax
$LN2@new_buffer:

; 592  :     if (addend < SMALLCHUNK)

  000ab	48 81 3c 24 00
	20 00 00	 cmp	 QWORD PTR addend$[rsp], 8192 ; 00002000H
  000b3	73 08		 jae	 SHORT $LN1@new_buffer

; 593  :         /* Avoid tiny read() calls. */
; 594  :         addend = SMALLCHUNK;

  000b5	48 c7 04 24 00
	20 00 00	 mov	 QWORD PTR addend$[rsp], 8192 ; 00002000H
$LN1@new_buffer:

; 595  :     return addend + currentsize;

  000bd	48 8b 44 24 28	 mov	 rax, QWORD PTR currentsize$[rsp]
  000c2	48 8b 0c 24	 mov	 rcx, QWORD PTR addend$[rsp]
  000c6	48 03 c8	 add	 rcx, rax
  000c9	48 8b c1	 mov	 rax, rcx
$LN8@new_buffer:

; 596  : }

  000cc	48 83 c4 18	 add	 rsp, 24
  000d0	c3		 ret	 0
new_buffersize ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_03EHEKHGBO@?$HMO?$CG?$AA@			; `string'
EXTRN	_PyIO_ConvertSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_read DD imagerel fileio_read
	DD	imagerel fileio_read+491
	DD	imagerel $unwind$fileio_read
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_read DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03EHEKHGBO@?$HMO?$CG?$AA@
CONST	SEGMENT
??_C@_03EHEKHGBO@?$HMO?$CG?$AA@ DB '|O&', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_read
_TEXT	SEGMENT
n$ = 32
ptr$ = 40
size$ = 48
bytes$ = 56
_save$64292 = 64
err$64296 = 72
self$ = 96
args$ = 104
fileio_read PROC					; COMDAT

; 707  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 708  :     char *ptr;
; 709  :     Py_ssize_t n;
; 710  :     Py_ssize_t size = -1;

  0000e	48 c7 44 24 30
	ff ff ff ff	 mov	 QWORD PTR size$[rsp], -1

; 711  :     PyObject *bytes;
; 712  : 
; 713  :     if (self->fd < 0)

  00017	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0001c	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00020	7d 0a		 jge	 SHORT $LN12@fileio_rea@4

; 714  :         return err_closed();

  00022	e8 00 00 00 00	 call	 err_closed
  00027	e9 ba 01 00 00	 jmp	 $LN13@fileio_rea@4
$LN12@fileio_rea@4:

; 715  :     if (!self->readable)

  0002c	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00031	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00034	d1 e8		 shr	 eax, 1
  00036	83 e0 01	 and	 eax, 1
  00039	85 c0		 test	 eax, eax
  0003b	75 11		 jne	 SHORT $LN11@fileio_rea@4

; 716  :         return err_mode("reading");

  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07CMOHHLII@reading?$AA@
  00044	e8 00 00 00 00	 call	 err_mode
  00049	e9 98 01 00 00	 jmp	 $LN13@fileio_rea@4
$LN11@fileio_rea@4:

; 717  : 
; 718  :     if (!PyArg_ParseTuple(args, "|O&", &_PyIO_ConvertSsize_t, &size))

  0004e	4c 8d 4c 24 30	 lea	 r9, QWORD PTR size$[rsp]
  00053	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_PyIO_ConvertSsize_t
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03EHEKHGBO@?$HMO?$CG?$AA@
  00061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00066	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0006b	85 c0		 test	 eax, eax
  0006d	75 07		 jne	 SHORT $LN10@fileio_rea@4

; 719  :         return NULL;

  0006f	33 c0		 xor	 eax, eax
  00071	e9 70 01 00 00	 jmp	 $LN13@fileio_rea@4
$LN10@fileio_rea@4:

; 720  : 
; 721  :     if (size < 0) {

  00076	48 83 7c 24 30
	00		 cmp	 QWORD PTR size$[rsp], 0
  0007c	7d 0f		 jge	 SHORT $LN9@fileio_rea@4

; 722  :         return fileio_readall(self);

  0007e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00083	e8 00 00 00 00	 call	 fileio_readall
  00088	e9 59 01 00 00	 jmp	 $LN13@fileio_rea@4
$LN9@fileio_rea@4:

; 723  :     }
; 724  : 
; 725  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 726  :     if (size > INT_MAX)

  0008d	48 81 7c 24 30
	ff ff ff 7f	 cmp	 QWORD PTR size$[rsp], 2147483647 ; 7fffffffH
  00096	7e 09		 jle	 SHORT $LN8@fileio_rea@4

; 727  :         size = INT_MAX;

  00098	48 c7 44 24 30
	ff ff ff 7f	 mov	 QWORD PTR size$[rsp], 2147483647 ; 7fffffffH
$LN8@fileio_rea@4:

; 728  : #endif
; 729  :     bytes = PyBytes_FromStringAndSize(NULL, size);

  000a1	48 8b 54 24 30	 mov	 rdx, QWORD PTR size$[rsp]
  000a6	33 c9		 xor	 ecx, ecx
  000a8	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000ad	48 89 44 24 38	 mov	 QWORD PTR bytes$[rsp], rax

; 730  :     if (bytes == NULL)

  000b2	48 83 7c 24 38
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  000b8	75 07		 jne	 SHORT $LN7@fileio_rea@4

; 731  :         return NULL;

  000ba	33 c0		 xor	 eax, eax
  000bc	e9 25 01 00 00	 jmp	 $LN13@fileio_rea@4
$LN7@fileio_rea@4:

; 732  :     ptr = PyBytes_AS_STRING(bytes);

  000c1	48 8b 44 24 38	 mov	 rax, QWORD PTR bytes$[rsp]
  000c6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ca	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000d5	85 c0		 test	 eax, eax
  000d7	75 1c		 jne	 SHORT $LN15@fileio_rea@4
  000d9	41 b8 dc 02 00
	00		 mov	 r8d, 732		; 000002dcH
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@JIFCJEHP@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAi?$AAo?$AA?2?$AAf?$AAi?$AAl?$AAe?$AAi?$AAo?$AA?4?$AAc?$AA?$AA@
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f3	33 c0		 xor	 eax, eax
$LN15@fileio_rea@4:
  000f5	48 8b 44 24 38	 mov	 rax, QWORD PTR bytes$[rsp]
  000fa	48 83 c0 78	 add	 rax, 120		; 00000078H
  000fe	48 89 44 24 28	 mov	 QWORD PTR ptr$[rsp], rax

; 733  : 
; 734  :     if (_PyVerify_fd(self->fd)) {

  00103	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00108	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  0010b	e8 00 00 00 00	 call	 _PyVerify_fd
  00110	85 c0		 test	 eax, eax
  00112	74 41		 je	 SHORT $LN6@fileio_rea@4

; 735  :         Py_BEGIN_ALLOW_THREADS

  00114	e8 00 00 00 00	 call	 PyEval_SaveThread
  00119	48 89 44 24 40	 mov	 QWORD PTR _save$64292[rsp], rax

; 736  :         errno = 0;

  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00124	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 737  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 738  :         n = read(self->fd, ptr, (int)size);

  0012a	44 8b 44 24 30	 mov	 r8d, DWORD PTR size$[rsp]
  0012f	48 8b 54 24 28	 mov	 rdx, QWORD PTR ptr$[rsp]
  00134	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00139	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00142	48 98		 cdqe
  00144	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 739  : #else
; 740  :         n = read(self->fd, ptr, size);
; 741  : #endif
; 742  :         Py_END_ALLOW_THREADS

  00149	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _save$64292[rsp]
  0014e	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 743  :     } else

  00153	eb 09		 jmp	 SHORT $LN5@fileio_rea@4
$LN6@fileio_rea@4:

; 744  :         n = -1;

  00155	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR n$[rsp], -1
$LN5@fileio_rea@4:

; 745  : 
; 746  :     if (n < 0) {

  0015e	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  00164	7d 4e		 jge	 SHORT $LN4@fileio_rea@4

; 747  :         int err = errno;

  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0016c	8b 00		 mov	 eax, DWORD PTR [rax]
  0016e	89 44 24 48	 mov	 DWORD PTR err$64296[rsp], eax

; 748  :         Py_DECREF(bytes);

  00172	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytes$[rsp]
  00177	e8 00 00 00 00	 call	 _Py_DecRef

; 749  :         if (err == EAGAIN)

  0017c	83 7c 24 48 0b	 cmp	 DWORD PTR err$64296[rsp], 11
  00181	75 15		 jne	 SHORT $LN3@fileio_rea@4

; 750  :             Py_RETURN_NONE;

  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0018a	e8 00 00 00 00	 call	 _Py_IncRef
  0018f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00196	eb 4e		 jmp	 SHORT $LN13@fileio_rea@4
$LN3@fileio_rea@4:

; 751  :         errno = err;

  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0019e	8b 4c 24 48	 mov	 ecx, DWORD PTR err$64296[rsp]
  001a2	89 08		 mov	 DWORD PTR [rax], ecx

; 752  :         PyErr_SetFromErrno(PyExc_IOError);

  001a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  001ab	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 753  :         return NULL;

  001b0	33 c0		 xor	 eax, eax
  001b2	eb 32		 jmp	 SHORT $LN13@fileio_rea@4
$LN4@fileio_rea@4:

; 754  :     }
; 755  : 
; 756  :     if (n != size) {

  001b4	48 8b 44 24 30	 mov	 rax, QWORD PTR size$[rsp]
  001b9	48 39 44 24 20	 cmp	 QWORD PTR n$[rsp], rax
  001be	74 21		 je	 SHORT $LN2@fileio_rea@4

; 757  :         if (_PyBytes_Resize(&bytes, n) < 0) {

  001c0	48 8b 54 24 20	 mov	 rdx, QWORD PTR n$[rsp]
  001c5	48 8d 4c 24 38	 lea	 rcx, QWORD PTR bytes$[rsp]
  001ca	e8 00 00 00 00	 call	 _PyBytes_Resize
  001cf	85 c0		 test	 eax, eax
  001d1	7d 0e		 jge	 SHORT $LN1@fileio_rea@4

; 758  :             Py_DECREF(bytes);

  001d3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytes$[rsp]
  001d8	e8 00 00 00 00	 call	 _Py_DecRef

; 759  :             return NULL;

  001dd	33 c0		 xor	 eax, eax
  001df	eb 05		 jmp	 SHORT $LN13@fileio_rea@4
$LN1@fileio_rea@4:
$LN2@fileio_rea@4:

; 760  :         }
; 761  :     }
; 762  : 
; 763  :     return (PyObject *) bytes;

  001e1	48 8b 44 24 38	 mov	 rax, QWORD PTR bytes$[rsp]
$LN13@fileio_rea@4:

; 764  : }

  001e6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ea	c3		 ret	 0
fileio_read ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DEPFLJBK@y?$CK?$AA@			; `string'
PUBLIC	??_C@_07EKMNMCED@writing?$AA@			; `string'
EXTRN	__imp_write:PROC
EXTRN	__imp_isatty:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_write DD imagerel fileio_write
	DD	imagerel fileio_write+426
	DD	imagerel $unwind$fileio_write
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_write DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_02DEPFLJBK@y?$CK?$AA@
CONST	SEGMENT
??_C@_02DEPFLJBK@y?$CK?$AA@ DB 'y*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EKMNMCED@writing?$AA@
CONST	SEGMENT
??_C@_07EKMNMCED@writing?$AA@ DB 'writing', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_write
_TEXT	SEGMENT
n$ = 32
pbuf$ = 48
len$ = 128
err$ = 136
_save$64323 = 144
self$ = 176
args$ = 184
fileio_write PROC					; COMDAT

; 768  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 769  :     Py_buffer pbuf;
; 770  :     Py_ssize_t n, len;
; 771  :     int err;
; 772  : 
; 773  :     if (self->fd < 0)

  00011	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00019	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  0001d	7d 0a		 jge	 SHORT $LN10@fileio_wri@2

; 774  :         return err_closed();

  0001f	e8 00 00 00 00	 call	 err_closed
  00024	e9 79 01 00 00	 jmp	 $LN11@fileio_wri@2
$LN10@fileio_wri@2:

; 775  :     if (!self->writable)

  00029	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00031	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00034	c1 e8 02	 shr	 eax, 2
  00037	83 e0 01	 and	 eax, 1
  0003a	85 c0		 test	 eax, eax
  0003c	75 11		 jne	 SHORT $LN9@fileio_wri@2

; 776  :         return err_mode("writing");

  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EKMNMCED@writing?$AA@
  00045	e8 00 00 00 00	 call	 err_mode
  0004a	e9 53 01 00 00	 jmp	 $LN11@fileio_wri@2
$LN9@fileio_wri@2:

; 777  : 
; 778  :     if (!PyArg_ParseTuple(args, "y*", &pbuf))

  0004f	4c 8d 44 24 30	 lea	 r8, QWORD PTR pbuf$[rsp]
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DEPFLJBK@y?$CK?$AA@
  0005b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00063	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00068	85 c0		 test	 eax, eax
  0006a	75 07		 jne	 SHORT $LN8@fileio_wri@2

; 779  :         return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	e9 2f 01 00 00	 jmp	 $LN11@fileio_wri@2
$LN8@fileio_wri@2:

; 780  : 
; 781  :     if (_PyVerify_fd(self->fd)) {

  00073	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0007b	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  0007e	e8 00 00 00 00	 call	 _PyVerify_fd
  00083	85 c0		 test	 eax, eax
  00085	0f 84 a5 00 00
	00		 je	 $LN7@fileio_wri@2

; 782  :         Py_BEGIN_ALLOW_THREADS

  0008b	e8 00 00 00 00	 call	 PyEval_SaveThread
  00090	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR _save$64323[rsp], rax

; 783  :         errno = 0;

  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0009e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 784  :         len = pbuf.len;

  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR pbuf$[rsp+16]
  000a9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 785  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 786  :         if (len > 32767 && isatty(self->fd)) {

  000b1	48 81 bc 24 80
	00 00 00 ff 7f
	00 00		 cmp	 QWORD PTR len$[rsp], 32767 ; 00007fffH
  000bd	7e 23		 jle	 SHORT $LN6@fileio_wri@2
  000bf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000c7	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  000d0	85 c0		 test	 eax, eax
  000d2	74 0e		 je	 SHORT $LN6@fileio_wri@2

; 787  :             /* Issue #11395: the Windows console returns an error (12: not
; 788  :                enough space error) on writing into stdout if stdout mode is
; 789  :                binary and the length is greater than 66,000 bytes (or less,
; 790  :                depending on heap usage). */
; 791  :             len = 32767;

  000d4	48 c7 84 24 80
	00 00 00 ff 7f
	00 00		 mov	 QWORD PTR len$[rsp], 32767 ; 00007fffH
  000e0	eb 1a		 jmp	 SHORT $LN5@fileio_wri@2
$LN6@fileio_wri@2:

; 792  :         }
; 793  :         else if (len > INT_MAX)

  000e2	48 81 bc 24 80
	00 00 00 ff ff
	ff 7f		 cmp	 QWORD PTR len$[rsp], 2147483647 ; 7fffffffH
  000ee	7e 0c		 jle	 SHORT $LN4@fileio_wri@2

; 794  :             len = INT_MAX;

  000f0	48 c7 84 24 80
	00 00 00 ff ff
	ff 7f		 mov	 QWORD PTR len$[rsp], 2147483647 ; 7fffffffH
$LN4@fileio_wri@2:
$LN5@fileio_wri@2:

; 795  :         n = write(self->fd, pbuf.buf, (int)len);

  000fc	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00104	48 8b 54 24 30	 mov	 rdx, QWORD PTR pbuf$[rsp]
  00109	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00111	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0011a	48 98		 cdqe
  0011c	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 796  : #else
; 797  :         n = write(self->fd, pbuf.buf, len);
; 798  : #endif
; 799  :         Py_END_ALLOW_THREADS

  00121	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _save$64323[rsp]
  00129	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 800  :     } else

  0012e	eb 09		 jmp	 SHORT $LN3@fileio_wri@2
$LN7@fileio_wri@2:

; 801  :         n = -1;

  00130	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR n$[rsp], -1
$LN3@fileio_wri@2:

; 802  :     err = errno;

  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0013f	8b 00		 mov	 eax, DWORD PTR [rax]
  00141	89 84 24 88 00
	00 00		 mov	 DWORD PTR err$[rsp], eax

; 803  : 
; 804  :     PyBuffer_Release(&pbuf);

  00148	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pbuf$[rsp]
  0014d	e8 00 00 00 00	 call	 PyBuffer_Release

; 805  : 
; 806  :     if (n < 0) {

  00152	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  00158	7d 3e		 jge	 SHORT $LN2@fileio_wri@2

; 807  :         if (err == EAGAIN)

  0015a	83 bc 24 88 00
	00 00 0b	 cmp	 DWORD PTR err$[rsp], 11
  00162	75 15		 jne	 SHORT $LN1@fileio_wri@2

; 808  :             Py_RETURN_NONE;

  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0016b	e8 00 00 00 00	 call	 _Py_IncRef
  00170	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00177	eb 29		 jmp	 SHORT $LN11@fileio_wri@2
$LN1@fileio_wri@2:

; 809  :         errno = err;

  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0017f	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR err$[rsp]
  00186	89 08		 mov	 DWORD PTR [rax], ecx

; 810  :         PyErr_SetFromErrno(PyExc_IOError);

  00188	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0018f	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 811  :         return NULL;

  00194	33 c0		 xor	 eax, eax
  00196	eb 0a		 jmp	 SHORT $LN11@fileio_wri@2
$LN2@fileio_wri@2:

; 812  :     }
; 813  : 
; 814  :     return PyLong_FromSsize_t(n);

  00198	48 8b 4c 24 20	 mov	 rcx, QWORD PTR n$[rsp]
  0019d	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN11@fileio_wri@2:

; 815  : }

  001a2	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001a9	c3		 ret	 0
fileio_write ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ ; `string'
EXTRN	PyLong_FromLongLong:PROC
EXTRN	PyLong_AsLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$portable_lseek DD imagerel portable_lseek
	DD	imagerel portable_lseek+249
	DD	imagerel $unwind$portable_lseek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$portable_lseek DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT ??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
CONST	SEGMENT
??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@ DB 'an integer is requi'
	DB	'red', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT portable_lseek
_TEXT	SEGMENT
res$ = 32
pos$ = 40
_save$64358 = 48
tv64 = 56
fd$ = 80
posobj$ = 88
whence$ = 96
portable_lseek PROC					; COMDAT

; 822  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 823  :     Py_off_t pos, res;
; 824  : 
; 825  : #ifdef SEEK_SET
; 826  :     /* Turn 0, 1, 2 into SEEK_{SET,CUR,END} */
; 827  :     switch (whence) {

  00012	8b 44 24 60	 mov	 eax, DWORD PTR whence$[rsp]
  00016	89 44 24 38	 mov	 DWORD PTR tv64[rsp], eax

; 828  : #if SEEK_SET != 0
; 829  :     case 0: whence = SEEK_SET; break;
; 830  : #endif
; 831  : #if SEEK_CUR != 1
; 832  :     case 1: whence = SEEK_CUR; break;
; 833  : #endif
; 834  : #if SEEK_END != 2
; 835  :     case 2: whence = SEEK_END; break;
; 836  : #endif
; 837  :     }
; 838  : #endif /* SEEK_SET */
; 839  : 
; 840  :     if (posobj == NULL)

  0001a	48 83 7c 24 58
	00		 cmp	 QWORD PTR posobj$[rsp], 0
  00020	75 0b		 jne	 SHORT $LN8@portable_l

; 841  :         pos = 0;

  00022	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pos$[rsp], 0

; 842  :     else {

  0002b	eb 62		 jmp	 SHORT $LN7@portable_l
$LN8@portable_l:

; 843  :         if(PyFloat_Check(posobj)) {

  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  00034	48 8b 4c 24 58	 mov	 rcx, QWORD PTR posobj$[rsp]
  00039	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0003d	74 19		 je	 SHORT $LN5@portable_l
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00046	48 8b 44 24 58	 mov	 rax, QWORD PTR posobj$[rsp]
  0004b	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0004f	e8 00 00 00 00	 call	 PyType_IsSubtype
  00054	85 c0		 test	 eax, eax
  00056	74 1a		 je	 SHORT $LN6@portable_l
$LN5@portable_l:

; 844  :             PyErr_SetString(PyExc_TypeError, "an integer is required");

  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LPEFKOAK@an?5integer?5is?5required?$AA@
  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00066	e8 00 00 00 00	 call	 PyErr_SetString

; 845  :             return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 82 00 00 00	 jmp	 $LN11@portable_l
$LN6@portable_l:

; 846  :         }
; 847  : #if defined(HAVE_LARGEFILE_SUPPORT)
; 848  :         pos = PyLong_AsLongLong(posobj);

  00072	48 8b 4c 24 58	 mov	 rcx, QWORD PTR posobj$[rsp]
  00077	e8 00 00 00 00	 call	 PyLong_AsLongLong
  0007c	48 89 44 24 28	 mov	 QWORD PTR pos$[rsp], rax

; 849  : #else
; 850  :         pos = PyLong_AsLong(posobj);
; 851  : #endif
; 852  :         if (PyErr_Occurred())

  00081	e8 00 00 00 00	 call	 PyErr_Occurred
  00086	48 85 c0	 test	 rax, rax
  00089	74 04		 je	 SHORT $LN4@portable_l

; 853  :             return NULL;

  0008b	33 c0		 xor	 eax, eax
  0008d	eb 65		 jmp	 SHORT $LN11@portable_l
$LN4@portable_l:
$LN7@portable_l:

; 854  :     }
; 855  : 
; 856  :     if (_PyVerify_fd(fd)) {

  0008f	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  00093	e8 00 00 00 00	 call	 _PyVerify_fd
  00098	85 c0		 test	 eax, eax
  0009a	74 2f		 je	 SHORT $LN3@portable_l

; 857  :         Py_BEGIN_ALLOW_THREADS

  0009c	e8 00 00 00 00	 call	 PyEval_SaveThread
  000a1	48 89 44 24 30	 mov	 QWORD PTR _save$64358[rsp], rax

; 858  : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 859  :         res = _lseeki64(fd, pos, whence);

  000a6	44 8b 44 24 60	 mov	 r8d, DWORD PTR whence$[rsp]
  000ab	48 8b 54 24 28	 mov	 rdx, QWORD PTR pos$[rsp]
  000b0	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  000ba	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 860  : #else
; 861  :         res = lseek(fd, pos, whence);
; 862  : #endif
; 863  :         Py_END_ALLOW_THREADS

  000bf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _save$64358[rsp]
  000c4	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 864  :     } else

  000c9	eb 09		 jmp	 SHORT $LN2@portable_l
$LN3@portable_l:

; 865  :         res = -1;

  000cb	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR res$[rsp], -1
$LN2@portable_l:

; 866  :     if (res < 0)

  000d4	48 83 7c 24 20
	00		 cmp	 QWORD PTR res$[rsp], 0
  000da	7d 0e		 jge	 SHORT $LN1@portable_l

; 867  :         return PyErr_SetFromErrno(PyExc_IOError);

  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  000e3	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  000e8	eb 0a		 jmp	 SHORT $LN11@portable_l
$LN1@portable_l:

; 868  : 
; 869  : #if defined(HAVE_LARGEFILE_SUPPORT)
; 870  :     return PyLong_FromLongLong(res);

  000ea	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  000ef	e8 00 00 00 00	 call	 PyLong_FromLongLong
$LN11@portable_l:

; 871  : #else
; 872  :     return PyLong_FromLong(res);
; 873  : #endif
; 874  : }

  000f4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f8	c3		 ret	 0
portable_lseek ENDP
_TEXT	ENDS
PUBLIC	??_C@_03PEBICJFC@O?$HMi?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_seek DD imagerel fileio_seek
	DD	imagerel fileio_seek+103
	DD	imagerel $unwind$fileio_seek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_seek DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_03PEBICJFC@O?$HMi?$AA@
CONST	SEGMENT
??_C@_03PEBICJFC@O?$HMi?$AA@ DB 'O|i', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_seek
_TEXT	SEGMENT
posobj$ = 32
whence$ = 40
self$ = 64
args$ = 72
fileio_seek PROC					; COMDAT

; 878  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 879  :     PyObject *posobj;
; 880  :     int whence = 0;

  0000e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR whence$[rsp], 0

; 881  : 
; 882  :     if (self->fd < 0)

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0001b	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  0001f	7d 07		 jge	 SHORT $LN2@fileio_see@2

; 883  :         return err_closed();

  00021	e8 00 00 00 00	 call	 err_closed
  00026	eb 3a		 jmp	 SHORT $LN3@fileio_see@2
$LN2@fileio_see@2:

; 884  : 
; 885  :     if (!PyArg_ParseTuple(args, "O|i", &posobj, &whence))

  00028	4c 8d 4c 24 28	 lea	 r9, QWORD PTR whence$[rsp]
  0002d	4c 8d 44 24 20	 lea	 r8, QWORD PTR posobj$[rsp]
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03PEBICJFC@O?$HMi?$AA@
  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0003e	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00043	85 c0		 test	 eax, eax
  00045	75 04		 jne	 SHORT $LN1@fileio_see@2

; 886  :         return NULL;

  00047	33 c0		 xor	 eax, eax
  00049	eb 17		 jmp	 SHORT $LN3@fileio_see@2
$LN1@fileio_see@2:

; 887  : 
; 888  :     return portable_lseek(self->fd, posobj, whence);

  0004b	44 8b 44 24 28	 mov	 r8d, DWORD PTR whence$[rsp]
  00050	48 8b 54 24 20	 mov	 rdx, QWORD PTR posobj$[rsp]
  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0005a	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  0005d	e8 00 00 00 00	 call	 portable_lseek
$LN3@fileio_see@2:

; 889  : }

  00062	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00066	c3		 ret	 0
fileio_seek ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_tell DD imagerel fileio_tell
	DD	imagerel fileio_tell+58
	DD	imagerel $unwind$fileio_tell
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_tell DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fileio_tell
_TEXT	SEGMENT
self$ = 48
args$ = 56
fileio_tell PROC					; COMDAT

; 893  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 894  :     if (self->fd < 0)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00017	7d 07		 jge	 SHORT $LN1@fileio_tel

; 895  :         return err_closed();

  00019	e8 00 00 00 00	 call	 err_closed
  0001e	eb 15		 jmp	 SHORT $LN2@fileio_tel
$LN1@fileio_tel:

; 896  : 
; 897  :     return portable_lseek(self->fd, NULL, 1);

  00020	41 b8 01 00 00
	00		 mov	 r8d, 1
  00026	33 d2		 xor	 edx, edx
  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0002d	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  00030	e8 00 00 00 00	 call	 portable_lseek
$LN2@fileio_tel:

; 898  : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
fileio_tell ENDP
_TEXT	ENDS
PUBLIC	??_C@_02CKLEOEBD@?$HMO?$AA@			; `string'
EXTRN	__imp_SetEndOfFile:PROC
EXTRN	__imp__get_osfhandle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_truncate DD imagerel fileio_truncate
	DD	imagerel fileio_truncate+560
	DD	imagerel $unwind$fileio_truncate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_truncate DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_02CKLEOEBD@?$HMO?$AA@
CONST	SEGMENT
??_C@_02CKLEOEBD@?$HMO?$AA@ DB '|O', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_truncate
_TEXT	SEGMENT
posobj$ = 32
ret$ = 40
fd$ = 44
hFile$64407 = 48
oldposobj$64405 = 56
tempposobj$64406 = 64
_save$64419 = 72
tv137 = 80
tv142 = 84
self$ = 112
args$ = 120
fileio_truncate PROC					; COMDAT

; 903  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 904  :     PyObject *posobj = NULL; /* the new size wanted by the user */

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR posobj$[rsp], 0

; 905  : #ifndef MS_WINDOWS
; 906  :     Py_off_t pos;
; 907  : #endif
; 908  :     int ret;
; 909  :     int fd;
; 910  : 
; 911  :     fd = self->fd;

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  0001c	8b 40 60	 mov	 eax, DWORD PTR [rax+96]
  0001f	89 44 24 2c	 mov	 DWORD PTR fd$[rsp], eax

; 912  :     if (fd < 0)

  00023	83 7c 24 2c 00	 cmp	 DWORD PTR fd$[rsp], 0
  00028	7d 0a		 jge	 SHORT $LN13@fileio_tru

; 913  :         return err_closed();

  0002a	e8 00 00 00 00	 call	 err_closed
  0002f	e9 f7 01 00 00	 jmp	 $LN14@fileio_tru
$LN13@fileio_tru:

; 914  :     if (!self->writable)

  00034	48 8b 44 24 70	 mov	 rax, QWORD PTR self$[rsp]
  00039	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0003c	c1 e8 02	 shr	 eax, 2
  0003f	83 e0 01	 and	 eax, 1
  00042	85 c0		 test	 eax, eax
  00044	75 11		 jne	 SHORT $LN12@fileio_tru

; 915  :         return err_mode("writing");

  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07EKMNMCED@writing?$AA@
  0004d	e8 00 00 00 00	 call	 err_mode
  00052	e9 d4 01 00 00	 jmp	 $LN14@fileio_tru
$LN12@fileio_tru:

; 916  : 
; 917  :     if (!PyArg_ParseTuple(args, "|O", &posobj))

  00057	4c 8d 44 24 20	 lea	 r8, QWORD PTR posobj$[rsp]
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02CKLEOEBD@?$HMO?$AA@
  00063	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00068	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0006d	85 c0		 test	 eax, eax
  0006f	75 07		 jne	 SHORT $LN11@fileio_tru

; 918  :         return NULL;

  00071	33 c0		 xor	 eax, eax
  00073	e9 b3 01 00 00	 jmp	 $LN14@fileio_tru
$LN11@fileio_tru:

; 919  : 
; 920  :     if (posobj == Py_None || posobj == NULL) {

  00078	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0007f	48 39 44 24 20	 cmp	 QWORD PTR posobj$[rsp], rax
  00084	74 08		 je	 SHORT $LN9@fileio_tru
  00086	48 83 7c 24 20
	00		 cmp	 QWORD PTR posobj$[rsp], 0
  0008c	75 27		 jne	 SHORT $LN10@fileio_tru
$LN9@fileio_tru:

; 921  :         /* Get the current position. */
; 922  :         posobj = portable_lseek(fd, NULL, 1);

  0008e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00094	33 d2		 xor	 edx, edx
  00096	8b 4c 24 2c	 mov	 ecx, DWORD PTR fd$[rsp]
  0009a	e8 00 00 00 00	 call	 portable_lseek
  0009f	48 89 44 24 20	 mov	 QWORD PTR posobj$[rsp], rax

; 923  :         if (posobj == NULL)

  000a4	48 83 7c 24 20
	00		 cmp	 QWORD PTR posobj$[rsp], 0
  000aa	75 07		 jne	 SHORT $LN8@fileio_tru

; 924  :             return NULL;

  000ac	33 c0		 xor	 eax, eax
  000ae	e9 78 01 00 00	 jmp	 $LN14@fileio_tru
$LN8@fileio_tru:

; 925  :     }
; 926  :     else {

  000b3	eb 0a		 jmp	 SHORT $LN7@fileio_tru
$LN10@fileio_tru:

; 927  :         Py_INCREF(posobj);

  000b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR posobj$[rsp]
  000ba	e8 00 00 00 00	 call	 _Py_IncRef
$LN7@fileio_tru:

; 928  :     }
; 929  : 
; 930  : #ifdef MS_WINDOWS
; 931  :     /* MS _chsize doesn't work if newsize doesn't fit in 32 bits,
; 932  :        so don't even try using it. */
; 933  :     {
; 934  :         PyObject *oldposobj, *tempposobj;
; 935  :         HANDLE hFile;
; 936  : 
; 937  :         /* we save the file pointer position */
; 938  :         oldposobj = portable_lseek(fd, NULL, 1);

  000bf	41 b8 01 00 00
	00		 mov	 r8d, 1
  000c5	33 d2		 xor	 edx, edx
  000c7	8b 4c 24 2c	 mov	 ecx, DWORD PTR fd$[rsp]
  000cb	e8 00 00 00 00	 call	 portable_lseek
  000d0	48 89 44 24 38	 mov	 QWORD PTR oldposobj$64405[rsp], rax

; 939  :         if (oldposobj == NULL) {

  000d5	48 83 7c 24 38
	00		 cmp	 QWORD PTR oldposobj$64405[rsp], 0
  000db	75 11		 jne	 SHORT $LN6@fileio_tru

; 940  :             Py_DECREF(posobj);

  000dd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR posobj$[rsp]
  000e2	e8 00 00 00 00	 call	 _Py_DecRef

; 941  :             return NULL;

  000e7	33 c0		 xor	 eax, eax
  000e9	e9 3d 01 00 00	 jmp	 $LN14@fileio_tru
$LN6@fileio_tru:

; 942  :         }
; 943  : 
; 944  :         /* we then move to the truncation position */
; 945  :         tempposobj = portable_lseek(fd, posobj, 0);

  000ee	45 33 c0	 xor	 r8d, r8d
  000f1	48 8b 54 24 20	 mov	 rdx, QWORD PTR posobj$[rsp]
  000f6	8b 4c 24 2c	 mov	 ecx, DWORD PTR fd$[rsp]
  000fa	e8 00 00 00 00	 call	 portable_lseek
  000ff	48 89 44 24 40	 mov	 QWORD PTR tempposobj$64406[rsp], rax

; 946  :         if (tempposobj == NULL) {

  00104	48 83 7c 24 40
	00		 cmp	 QWORD PTR tempposobj$64406[rsp], 0
  0010a	75 1b		 jne	 SHORT $LN5@fileio_tru

; 947  :             Py_DECREF(oldposobj);

  0010c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR oldposobj$64405[rsp]
  00111	e8 00 00 00 00	 call	 _Py_DecRef

; 948  :             Py_DECREF(posobj);

  00116	48 8b 4c 24 20	 mov	 rcx, QWORD PTR posobj$[rsp]
  0011b	e8 00 00 00 00	 call	 _Py_DecRef

; 949  :             return NULL;

  00120	33 c0		 xor	 eax, eax
  00122	e9 04 01 00 00	 jmp	 $LN14@fileio_tru
$LN5@fileio_tru:

; 950  :         }
; 951  :         Py_DECREF(tempposobj);

  00127	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tempposobj$64406[rsp]
  0012c	e8 00 00 00 00	 call	 _Py_DecRef

; 952  : 
; 953  :         /* Truncate.  Note that this may grow the file! */
; 954  :         Py_BEGIN_ALLOW_THREADS

  00131	e8 00 00 00 00	 call	 PyEval_SaveThread
  00136	48 89 44 24 48	 mov	 QWORD PTR _save$64419[rsp], rax

; 955  :         errno = 0;

  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00141	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 956  :         hFile = (HANDLE)_get_osfhandle(fd);

  00147	8b 4c 24 2c	 mov	 ecx, DWORD PTR fd$[rsp]
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  00151	48 89 44 24 30	 mov	 QWORD PTR hFile$64407[rsp], rax

; 957  :         ret = hFile == (HANDLE)-1; /* testing for INVALID_HANDLE value */

  00156	48 83 7c 24 30
	ff		 cmp	 QWORD PTR hFile$64407[rsp], -1
  0015c	75 0a		 jne	 SHORT $LN16@fileio_tru
  0015e	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  00166	eb 08		 jmp	 SHORT $LN17@fileio_tru
$LN16@fileio_tru:
  00168	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN17@fileio_tru:
  00170	8b 44 24 50	 mov	 eax, DWORD PTR tv137[rsp]
  00174	89 44 24 28	 mov	 DWORD PTR ret$[rsp], eax

; 958  :         if (ret == 0) {

  00178	83 7c 24 28 00	 cmp	 DWORD PTR ret$[rsp], 0
  0017d	75 3c		 jne	 SHORT $LN4@fileio_tru

; 959  :             ret = SetEndOfFile(hFile) == 0;

  0017f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hFile$64407[rsp]
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEndOfFile
  0018a	85 c0		 test	 eax, eax
  0018c	75 0a		 jne	 SHORT $LN18@fileio_tru
  0018e	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  00196	eb 08		 jmp	 SHORT $LN19@fileio_tru
$LN18@fileio_tru:
  00198	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN19@fileio_tru:
  001a0	8b 44 24 54	 mov	 eax, DWORD PTR tv142[rsp]
  001a4	89 44 24 28	 mov	 DWORD PTR ret$[rsp], eax

; 960  :             if (ret)

  001a8	83 7c 24 28 00	 cmp	 DWORD PTR ret$[rsp], 0
  001ad	74 0c		 je	 SHORT $LN3@fileio_tru

; 961  :                 errno = EACCES;

  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001b5	c7 00 0d 00 00
	00		 mov	 DWORD PTR [rax], 13
$LN3@fileio_tru:
$LN4@fileio_tru:

; 962  :         }
; 963  :         Py_END_ALLOW_THREADS

  001bb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _save$64419[rsp]
  001c0	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 964  : 
; 965  :         /* we restore the file pointer position in any case */
; 966  :         tempposobj = portable_lseek(fd, oldposobj, 0);

  001c5	45 33 c0	 xor	 r8d, r8d
  001c8	48 8b 54 24 38	 mov	 rdx, QWORD PTR oldposobj$64405[rsp]
  001cd	8b 4c 24 2c	 mov	 ecx, DWORD PTR fd$[rsp]
  001d1	e8 00 00 00 00	 call	 portable_lseek
  001d6	48 89 44 24 40	 mov	 QWORD PTR tempposobj$64406[rsp], rax

; 967  :         Py_DECREF(oldposobj);

  001db	48 8b 4c 24 38	 mov	 rcx, QWORD PTR oldposobj$64405[rsp]
  001e0	e8 00 00 00 00	 call	 _Py_DecRef

; 968  :         if (tempposobj == NULL) {

  001e5	48 83 7c 24 40
	00		 cmp	 QWORD PTR tempposobj$64406[rsp], 0
  001eb	75 0e		 jne	 SHORT $LN2@fileio_tru

; 969  :             Py_DECREF(posobj);

  001ed	48 8b 4c 24 20	 mov	 rcx, QWORD PTR posobj$[rsp]
  001f2	e8 00 00 00 00	 call	 _Py_DecRef

; 970  :             return NULL;

  001f7	33 c0		 xor	 eax, eax
  001f9	eb 30		 jmp	 SHORT $LN14@fileio_tru
$LN2@fileio_tru:

; 971  :         }
; 972  :         Py_DECREF(tempposobj);

  001fb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tempposobj$64406[rsp]
  00200	e8 00 00 00 00	 call	 _Py_DecRef

; 973  :     }
; 974  : #else
; 975  : 
; 976  : #if defined(HAVE_LARGEFILE_SUPPORT)
; 977  :     pos = PyLong_AsLongLong(posobj);
; 978  : #else
; 979  :     pos = PyLong_AsLong(posobj);
; 980  : #endif
; 981  :     if (PyErr_Occurred()){
; 982  :         Py_DECREF(posobj);
; 983  :         return NULL;
; 984  :     }
; 985  : 
; 986  :     Py_BEGIN_ALLOW_THREADS
; 987  :     errno = 0;
; 988  :     ret = ftruncate(fd, pos);
; 989  :     Py_END_ALLOW_THREADS
; 990  : 
; 991  : #endif /* !MS_WINDOWS */
; 992  : 
; 993  :     if (ret != 0) {

  00205	83 7c 24 28 00	 cmp	 DWORD PTR ret$[rsp], 0
  0020a	74 1a		 je	 SHORT $LN1@fileio_tru

; 994  :         Py_DECREF(posobj);

  0020c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR posobj$[rsp]
  00211	e8 00 00 00 00	 call	 _Py_DecRef

; 995  :         PyErr_SetFromErrno(PyExc_IOError);

  00216	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  0021d	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 996  :         return NULL;

  00222	33 c0		 xor	 eax, eax
  00224	eb 05		 jmp	 SHORT $LN14@fileio_tru
$LN1@fileio_tru:

; 997  :     }
; 998  : 
; 999  :     return posobj;

  00226	48 8b 44 24 20	 mov	 rax, QWORD PTR posobj$[rsp]
$LN14@fileio_tru:

; 1000 : }

  0022b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0022f	c3		 ret	 0
fileio_truncate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@ELFDAELB@?$DM_io?4FileIO?5name?$DN?$CFR?5mode?$DN?8?$CFs?8?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BN@BHKNJBBE@?$DM_io?4FileIO?5fd?$DN?$CFd?5mode?$DN?8?$CFs?8?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BG@KHCDCAEB@?$DM_io?4FileIO?5?$FLclosed?$FN?$DO?$AA@ ; `string'
EXTRN	PyExc_AttributeError:QWORD
EXTRN	_PyObject_GetAttrId:PROC
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_repr DD imagerel fileio_repr
	DD	imagerel fileio_repr+211
	DD	imagerel $unwind$fileio_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_repr DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0BP@ELFDAELB@?$DM_io?4FileIO?5name?$DN?$CFR?5mode?$DN?8?$CFs?8?$DO?$AA@
CONST	SEGMENT
??_C@_0BP@ELFDAELB@?$DM_io?4FileIO?5name?$DN?$CFR?5mode?$DN?8?$CFs?8?$DO?$AA@ DB '<'
	DB	'_io.FileIO name=%R mode=''%s''>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BHKNJBBE@?$DM_io?4FileIO?5fd?$DN?$CFd?5mode?$DN?8?$CFs?8?$DO?$AA@
CONST	SEGMENT
??_C@_0BN@BHKNJBBE@?$DM_io?4FileIO?5fd?$DN?$CFd?5mode?$DN?8?$CFs?8?$DO?$AA@ DB '<'
	DB	'_io.FileIO fd=%d mode=''%s''>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KHCDCAEB@?$DM_io?4FileIO?5?$FLclosed?$FN?$DO?$AA@
CONST	SEGMENT
??_C@_0BG@KHCDCAEB@?$DM_io?4FileIO?5?$FLclosed?$FN?$DO?$AA@ DB '<_io.File'
	DB	'IO [closed]>', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_repr
_TEXT	SEGMENT
res$ = 32
nameobj$ = 40
self$ = 64
fileio_repr PROC					; COMDAT

; 1030 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1031 :     _Py_IDENTIFIER(name);
; 1032 :     PyObject *nameobj, *res;
; 1033 : 
; 1034 :     if (self->fd < 0)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00012	7d 11		 jge	 SHORT $LN5@fileio_rep

; 1035 :         return PyUnicode_FromFormat("<_io.FileIO [closed]>");

  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@KHCDCAEB@?$DM_io?4FileIO?5?$FLclosed?$FN?$DO?$AA@
  0001b	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00020	e9 a9 00 00 00	 jmp	 $LN6@fileio_rep
$LN5@fileio_rep:

; 1036 : 
; 1037 :     nameobj = _PyObject_GetAttrId((PyObject *) self, &PyId_name);

  00025	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_name@?1??fileio_repr@@9@9
  0002a	8b c0		 mov	 eax, eax
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00032	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0003b	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0003f	48 8b d0	 mov	 rdx, rax
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00047	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  0004c	48 89 44 24 28	 mov	 QWORD PTR nameobj$[rsp], rax

; 1038 :     if (nameobj == NULL) {

  00051	48 83 7c 24 28
	00		 cmp	 QWORD PTR nameobj$[rsp], 0
  00057	75 43		 jne	 SHORT $LN4@fileio_rep

; 1039 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00060	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00065	85 c0		 test	 eax, eax
  00067	74 07		 je	 SHORT $LN3@fileio_rep

; 1040 :             PyErr_Clear();

  00069	e8 00 00 00 00	 call	 PyErr_Clear

; 1041 :         else

  0006e	eb 04		 jmp	 SHORT $LN2@fileio_rep
$LN3@fileio_rep:

; 1042 :             return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	eb 5a		 jmp	 SHORT $LN6@fileio_rep
$LN2@fileio_rep:

; 1043 :         res = PyUnicode_FromFormat("<_io.FileIO fd=%d mode='%s'>",
; 1044 :                                    self->fd, mode_string(self));

  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00079	e8 00 00 00 00	 call	 mode_string
  0007e	4c 8b c0	 mov	 r8, rax
  00081	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00086	8b 50 60	 mov	 edx, DWORD PTR [rax+96]
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@BHKNJBBE@?$DM_io?4FileIO?5fd?$DN?$CFd?5mode?$DN?8?$CFs?8?$DO?$AA@
  00090	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00095	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 1045 :     }
; 1046 :     else {

  0009a	eb 2d		 jmp	 SHORT $LN1@fileio_rep
$LN4@fileio_rep:

; 1047 :         res = PyUnicode_FromFormat("<_io.FileIO name=%R mode='%s'>",
; 1048 :                                    nameobj, mode_string(self));

  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000a1	e8 00 00 00 00	 call	 mode_string
  000a6	4c 8b c0	 mov	 r8, rax
  000a9	48 8b 54 24 28	 mov	 rdx, QWORD PTR nameobj$[rsp]
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@ELFDAELB@?$DM_io?4FileIO?5name?$DN?$CFR?5mode?$DN?8?$CFs?8?$DO?$AA@
  000b5	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000ba	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 1049 :         Py_DECREF(nameobj);

  000bf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR nameobj$[rsp]
  000c4	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@fileio_rep:

; 1050 :     }
; 1051 :     return res;

  000c9	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
$LN6@fileio_rep:

; 1052 : }

  000ce	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d2	c3		 ret	 0
fileio_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_02GMLFBBN@wb?$AA@				; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_03CCKOKKND@rb?$CL?$AA@			; `string'
PUBLIC	??_C@_02BOGAIONP@ab?$AA@			; `string'
PUBLIC	??_C@_03GAACFCKC@ab?$CL?$AA@			; `string'
PUBLIC	??_C@_02NJHBGCA@xb?$AA@				; `string'
PUBLIC	??_C@_03ENBDEKLH@xb?$CL?$AA@			; `string'
;	COMDAT ??_C@_02GMLFBBN@wb?$AA@
CONST	SEGMENT
??_C@_02GMLFBBN@wb?$AA@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCKOKKND@rb?$CL?$AA@
CONST	SEGMENT
??_C@_03CCKOKKND@rb?$CL?$AA@ DB 'rb+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02BOGAIONP@ab?$AA@
CONST	SEGMENT
??_C@_02BOGAIONP@ab?$AA@ DB 'ab', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03GAACFCKC@ab?$CL?$AA@
CONST	SEGMENT
??_C@_03GAACFCKC@ab?$CL?$AA@ DB 'ab+', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJHBGCA@xb?$AA@
CONST	SEGMENT
??_C@_02NJHBGCA@xb?$AA@ DB 'xb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ENBDEKLH@xb?$CL?$AA@
CONST	SEGMENT
??_C@_03ENBDEKLH@xb?$CL?$AA@ DB 'xb+', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mode_string
_TEXT	SEGMENT
self$ = 8
mode_string PROC					; COMDAT

; 1005 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1006 :     if (self->created) {

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  0000a	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0000d	83 e0 01	 and	 eax, 1
  00010	85 c0		 test	 eax, eax
  00012	74 28		 je	 SHORT $LN11@mode_strin

; 1007 :         if (self->readable)

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  00019	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0001c	d1 e8		 shr	 eax, 1
  0001e	83 e0 01	 and	 eax, 1
  00021	85 c0		 test	 eax, eax
  00023	74 0e		 je	 SHORT $LN10@mode_strin

; 1008 :             return "xb+";

  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03ENBDEKLH@xb?$CL?$AA@
  0002c	e9 84 00 00 00	 jmp	 $LN12@mode_strin

; 1009 :         else

  00031	eb 09		 jmp	 SHORT $LN9@mode_strin
$LN10@mode_strin:

; 1010 :             return "xb";

  00033	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02NJHBGCA@xb?$AA@
  0003a	eb 79		 jmp	 SHORT $LN12@mode_strin
$LN9@mode_strin:
$LN11@mode_strin:

; 1011 :     }
; 1012 :     if (self->appending) {

  0003c	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  00041	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00044	c1 e8 03	 shr	 eax, 3
  00047	83 e0 01	 and	 eax, 1
  0004a	85 c0		 test	 eax, eax
  0004c	74 27		 je	 SHORT $LN8@mode_strin

; 1013 :         if (self->readable)

  0004e	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  00053	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00056	d1 e8		 shr	 eax, 1
  00058	83 e0 01	 and	 eax, 1
  0005b	85 c0		 test	 eax, eax
  0005d	74 0b		 je	 SHORT $LN7@mode_strin

; 1014 :             return "ab+";

  0005f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03GAACFCKC@ab?$CL?$AA@
  00066	eb 4d		 jmp	 SHORT $LN12@mode_strin

; 1015 :         else

  00068	eb 09		 jmp	 SHORT $LN6@mode_strin
$LN7@mode_strin:

; 1016 :             return "ab";

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02BOGAIONP@ab?$AA@
  00071	eb 42		 jmp	 SHORT $LN12@mode_strin
$LN6@mode_strin:

; 1017 :     }
; 1018 :     else if (self->readable) {

  00073	eb 40		 jmp	 SHORT $LN5@mode_strin
$LN8@mode_strin:
  00075	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  0007a	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0007d	d1 e8		 shr	 eax, 1
  0007f	83 e0 01	 and	 eax, 1
  00082	85 c0		 test	 eax, eax
  00084	74 28		 je	 SHORT $LN4@mode_strin

; 1019 :         if (self->writable)

  00086	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  0008b	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0008e	c1 e8 02	 shr	 eax, 2
  00091	83 e0 01	 and	 eax, 1
  00094	85 c0		 test	 eax, eax
  00096	74 0b		 je	 SHORT $LN3@mode_strin

; 1020 :             return "rb+";

  00098	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03CCKOKKND@rb?$CL?$AA@
  0009f	eb 14		 jmp	 SHORT $LN12@mode_strin

; 1021 :         else

  000a1	eb 09		 jmp	 SHORT $LN2@mode_strin
$LN3@mode_strin:

; 1022 :             return "rb";

  000a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02JDPG@rb?$AA@
  000aa	eb 09		 jmp	 SHORT $LN12@mode_strin
$LN2@mode_strin:

; 1023 :     }
; 1024 :     else

  000ac	eb 07		 jmp	 SHORT $LN1@mode_strin
$LN4@mode_strin:

; 1025 :         return "wb";

  000ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02GMLFBBN@wb?$AA@
$LN1@mode_strin:
$LN5@mode_strin:
$LN12@mode_strin:

; 1026 : }

  000b5	f3 c3		 fatret	 0
mode_string ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_isatty DD imagerel fileio_isatty
	DD	imagerel fileio_isatty+79
	DD	imagerel $unwind$fileio_isatty
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_isatty DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fileio_isatty
_TEXT	SEGMENT
res$ = 32
_save$64481 = 40
self$ = 64
fileio_isatty PROC					; COMDAT

; 1056 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1057 :     long res;
; 1058 : 
; 1059 :     if (self->fd < 0)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00012	7d 07		 jge	 SHORT $LN1@fileio_isa

; 1060 :         return err_closed();

  00014	e8 00 00 00 00	 call	 err_closed
  00019	eb 2f		 jmp	 SHORT $LN2@fileio_isa
$LN1@fileio_isa:

; 1061 :     Py_BEGIN_ALLOW_THREADS

  0001b	e8 00 00 00 00	 call	 PyEval_SaveThread
  00020	48 89 44 24 28	 mov	 QWORD PTR _save$64481[rsp], rax

; 1062 :     res = isatty(self->fd);

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002a	8b 48 60	 mov	 ecx, DWORD PTR [rax+96]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  00033	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 1063 :     Py_END_ALLOW_THREADS

  00037	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _save$64481[rsp]
  0003c	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1064 :     return PyBool_FromLong(res);

  00041	8b 4c 24 20	 mov	 ecx, DWORD PTR res$[rsp]
  00045	e8 00 00 00 00	 call	 PyBool_FromLong
$LN2@fileio_isa:

; 1065 : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
fileio_isatty ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$fileio_getstate DD imagerel fileio_getstate
	DD	imagerel fileio_getstate+48
	DD	imagerel $unwind$fileio_getstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fileio_getstate DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@
CONST	SEGMENT
??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@ DB 'cannot s'
	DB	'erialize ''%s'' object', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fileio_getstate
_TEXT	SEGMENT
self$ = 48
fileio_getstate PROC					; COMDAT

; 1069 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1070 :     PyErr_Format(PyExc_TypeError,
; 1071 :                  "cannot serialize '%s' object", Py_TYPE(self)->tp_name);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OMCOKFBI@cannot?5serialize?5?8?$CFs?8?5object?$AA@
  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00024	e8 00 00 00 00	 call	 PyErr_Format

; 1072 :     return NULL;

  00029	33 c0		 xor	 eax, eax

; 1073 : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
fileio_getstate ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_closed DD imagerel get_closed
	DD	imagerel get_closed+57
	DD	imagerel $unwind$get_closed
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_closed DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_closed
_TEXT	SEGMENT
tv67 = 32
self$ = 64
closure$ = 72
get_closed PROC						; COMDAT

; 1183 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1184 :     return PyBool_FromLong((long)(self->fd < 0));

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	83 78 60 00	 cmp	 DWORD PTR [rax+96], 0
  00017	7d 0a		 jge	 SHORT $LN3@get_closed
  00019	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  00021	eb 08		 jmp	 SHORT $LN4@get_closed
$LN3@get_closed:
  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@get_closed:
  0002b	8b 4c 24 20	 mov	 ecx, DWORD PTR tv67[rsp]
  0002f	e8 00 00 00 00	 call	 PyBool_FromLong

; 1185 : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
get_closed ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_closefd DD imagerel get_closefd
	DD	imagerel get_closefd+40
	DD	imagerel $unwind$get_closefd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_closefd DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_closefd
_TEXT	SEGMENT
self$ = 48
closure$ = 56
get_closefd PROC					; COMDAT

; 1189 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1190 :     return PyBool_FromLong((long)(self->closefd));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00016	c1 e8 06	 shr	 eax, 6
  00019	83 e0 01	 and	 eax, 1
  0001c	8b c8		 mov	 ecx, eax
  0001e	e8 00 00 00 00	 call	 PyBool_FromLong

; 1191 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
get_closefd ENDP
_TEXT	ENDS
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_mode DD imagerel get_mode
	DD	imagerel get_mode+37
	DD	imagerel $unwind$get_mode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_mode DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_mode
_TEXT	SEGMENT
self$ = 48
closure$ = 56
get_mode PROC						; COMDAT

; 1195 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1196 :     return PyUnicode_FromString(mode_string(self));

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 mode_string
  00018	48 8b c8	 mov	 rcx, rax
  0001b	e8 00 00 00 00	 call	 PyUnicode_FromString

; 1197 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
get_mode ENDP
_TEXT	ENDS
END
