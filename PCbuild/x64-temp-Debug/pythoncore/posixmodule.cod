; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@FLCPIIDO@MS_WINDOWS?$AA@		; `string'
PUBLIC	??_C@_02JKEHMDF@nt?$AA@				; `string'
PUBLIC	??_C@_0BC@NGEOBJJK@get_terminal_size?$AA@	; `string'
PUBLIC	??_C@_07MHKMJCBA@urandom?$AA@			; `string'
PUBLIC	??_C@_0O@GCOGNGOJ@_getdiskusage?$AA@		; `string'
PUBLIC	??_C@_06MIMMPGNN@_isdir?$AA@			; `string'
PUBLIC	??_C@_0BE@FKJDANNK@_getfileinformation?$AA@	; `string'
PUBLIC	??_C@_0BC@ONBOPOKE@_getfinalpathname?$AA@	; `string'
PUBLIC	??_C@_0BB@JCNCOEJI@_getfullpathname?$AA@	; `string'
PUBLIC	??_C@_05BBAEEBBH@abort?$AA@			; `string'
PUBLIC	??_C@_05DEEMBJFM@fsync?$AA@			; `string'
PUBLIC	??_C@_08MHKKJIBB@strerror?$AA@			; `string'
PUBLIC	??_C@_06OOJCBFLM@putenv?$AA@			; `string'
PUBLIC	??_C@_04MKFKKHBG@pipe?$AA@			; `string'
PUBLIC	??_C@_06BMABDNNN@isatty?$AA@			; `string'
PUBLIC	??_C@_05MIPJACCK@fstat?$AA@			; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_05ELJELHPE@lseek?$AA@			; `string'
PUBLIC	??_C@_04LAAPLFOA@dup2?$AA@			; `string'
PUBLIC	??_C@_03BHPKJDPK@dup?$AA@			; `string'
PUBLIC	??_C@_0BA@PABGBABL@device_encoding?$AA@		; `string'
PUBLIC	??_C@_0L@ICENNBNA@closerange?$AA@		; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
PUBLIC	??_C@_04PMOCAHAA@open?$AA@			; `string'
PUBLIC	??_C@_07BPIIBJED@waitpid?$AA@			; `string'
PUBLIC	??_C@_04BJJEOANI@kill?$AA@			; `string'
PUBLIC	??_C@_09FCFKICPJ@startfile?$AA@			; `string'
PUBLIC	??_C@_08NPAFALFK@getlogin?$AA@			; `string'
PUBLIC	??_C@_07NNLELLPO@getppid?$AA@			; `string'
PUBLIC	??_C@_06FFEBHEJM@getpid?$AA@			; `string'
PUBLIC	??_C@_07EPDPINNO@spawnve?$AA@			; `string'
PUBLIC	??_C@_06NNKHBJHE@spawnv?$AA@			; `string'
PUBLIC	??_C@_06GMNLOHLP@execve?$AA@			; `string'
PUBLIC	??_C@_05OAKKMHID@execv?$AA@			; `string'
PUBLIC	??_C@_05EAOJNIGN@_exit?$AA@			; `string'
PUBLIC	??_C@_05MJOOAIJH@times?$AA@			; `string'
PUBLIC	??_C@_05HCLPLDJ@utime?$AA@			; `string'
PUBLIC	??_C@_06LEMKAMD@remove?$AA@			; `string'
PUBLIC	??_C@_06DAJBMHKE@unlink?$AA@			; `string'
PUBLIC	??_C@_05CHFEIFNB@umask?$AA@			; `string'
PUBLIC	??_C@_07KLDEEJBK@symlink?$AA@			; `string'
PUBLIC	??_C@_0BB@KAJEHDMI@stat_float_times?$AA@	; `string'
PUBLIC	??_C@_04GBLELIND@stat?$AA@			; `string'
PUBLIC	??_C@_05IHDOMKOF@rmdir?$AA@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_06LMEAOBLB@rename?$AA@			; `string'
PUBLIC	??_C@_08DPKANCED@readlink?$AA@			; `string'
PUBLIC	??_C@_05PKPOIPAL@mkdir?$AA@			; `string'
PUBLIC	??_C@_05GJGCCBEM@lstat?$AA@			; `string'
PUBLIC	??_C@_07GMBICOLL@listdir?$AA@			; `string'
PUBLIC	??_C@_04OHHBHOGB@link?$AA@			; `string'
PUBLIC	??_C@_07DJKBFKMA@getcwdb?$AA@			; `string'
PUBLIC	??_C@_06BFFACJH@getcwd?$AA@			; `string'
PUBLIC	??_C@_05OCEJBCEE@chmod?$AA@			; `string'
PUBLIC	??_C@_05IHFEJEKL@chdir?$AA@			; `string'
PUBLIC	??_C@_06EBPNOMLE@access?$AA@			; `string'
PUBLIC	??_C@_0BB@OCNMDDG@os?4terminal_size?$AA@	; `string'
PUBLIC	??_C@_0CM@EGPMDCBH@height?5of?5the?5terminal?5window?5in@ ; `string'
PUBLIC	??_C@_05DENOCHIP@lines?$AA@			; `string'
PUBLIC	??_C@_0CL@CKMLCLCG@width?5of?5the?5terminal?5window?5in?5@ ; `string'
PUBLIC	??_C@_07HIFEPIJN@columns?$AA@			; `string'
PUBLIC	??_C@_05GECEPKB@flags?$AA@			; `string'
PUBLIC	??_C@_0N@BNFIOIGL@times_result?$AA@		; `string'
PUBLIC	??_C@_0DC@LJDHFGAF@elapsed?5time?5since?5an?5arbitrary?5@ ; `string'
PUBLIC	??_C@_07ECLNDMPC@elapsed?$AA@			; `string'
PUBLIC	??_C@_0BI@JHIBAKDA@system?5time?5of?5children?$AA@ ; `string'
PUBLIC	??_C@_0BA@KPAGPIBA@children_system?$AA@		; `string'
PUBLIC	??_C@_0BG@LFEKOICA@user?5time?5of?5children?$AA@ ; `string'
PUBLIC	??_C@_0O@MGJDGJPB@children_user?$AA@		; `string'
PUBLIC	??_C@_0M@IFJPBFHL@system?5time?$AA@		; `string'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	??_C@_09DDJCHFLJ@user?5time?$AA@		; `string'
PUBLIC	??_C@_04CCHAHKJA@user?$AA@			; `string'
PUBLIC	??_C@_0BE@IKDLOEOJ@target_is_directory?$AA@	; `string'
PUBLIC	??_C@_0M@PINLHHEI@environment?$AA@		; `string'
PUBLIC	??_C@_04GIEEDNNN@argv?$AA@			; `string'
PUBLIC	??_C@_0N@HCEBDBKJ@uname_result?$AA@		; `string'
PUBLIC	??_C@_0BE@PPOJDPCN@hardware?5identifier?$AA@	; `string'
PUBLIC	??_C@_07MHDNFCJE@machine?$AA@			; `string'
PUBLIC	??_C@_0BJ@DCDBFEHB@operating?5system?5version?$AA@ ; `string'
PUBLIC	??_C@_07CPCPJPKL@version?$AA@			; `string'
PUBLIC	??_C@_0BJ@FDHLPAHC@operating?5system?5release?$AA@ ; `string'
PUBLIC	??_C@_07EOGFDLKI@release?$AA@			; `string'
PUBLIC	??_C@_0DE@CBKKCAPD@name?5of?5machine?5on?5network?5?$CIimpl@ ; `string'
PUBLIC	??_C@_08FOEBGLLE@nodename?$AA@			; `string'
PUBLIC	??_C@_0BG@JMJLGKC@operating?5system?5name?$AA@	; `string'
PUBLIC	??_C@_07LBFJMCKJ@sysname?$AA@			; `string'
PUBLIC	??_C@_0L@EFPHGFIP@dst_dir_fd?$AA@		; `string'
PUBLIC	??_C@_0L@OFFJPAEB@src_dir_fd?$AA@		; `string'
PUBLIC	??_C@_03HHBLCKEM@dst?$AA@			; `string'
PUBLIC	??_C@_03LOJEKLML@src?$AA@			; `string'
PUBLIC	??_C@_0O@FGNLNFPF@effective_ids?$AA@		; `string'
PUBLIC	??_C@_04GMGOKAFF@mode?$AA@			; `string'
PUBLIC	??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@		; `string'
PUBLIC	??_C@_06GPCGKDIP@dir_fd?$AA@			; `string'
PUBLIC	??_C@_04LNEJFJGI@path?$AA@			; `string'
PUBLIC	??_C@_0P@HMGCCANC@statvfs_result?$AA@		; `string'
PUBLIC	??_C@_09HMAABEP@f_namemax?$AA@			; `string'
PUBLIC	??_C@_06HDAGHFFN@f_flag?$AA@			; `string'
PUBLIC	??_C@_08OKABAGDI@f_favail?$AA@			; `string'
PUBLIC	??_C@_07GLLIAGA@f_ffree?$AA@			; `string'
PUBLIC	??_C@_07CILFICMK@f_files?$AA@			; `string'
PUBLIC	??_C@_08BOEOCCCL@f_bavail?$AA@			; `string'
PUBLIC	??_C@_07JNCKMCHG@f_bfree?$AA@			; `string'
PUBLIC	??_C@_08KLPHNGHN@f_blocks?$AA@			; `string'
PUBLIC	??_C@_08KNLFHHPC@f_frsize?$AA@			; `string'
PUBLIC	??_C@_07KFEIOOFH@f_bsize?$AA@			; `string'
PUBLIC	??_C@_0M@ENKKEMPE@stat_result?$AA@		; `string'
PUBLIC	??_C@_0CD@EICNLNEJ@time?5of?5last?5change?5in?5nanosecon@ ; `string'
PUBLIC	??_C@_0M@LCENIKEP@st_ctime_ns?$AA@		; `string'
PUBLIC	??_C@_0CJ@KAFLJGCI@time?5of?5last?5modification?5in?5nan@ ; `string'
PUBLIC	??_C@_0M@HKIPFBNN@st_mtime_ns?$AA@		; `string'
PUBLIC	??_C@_0CD@MNMGLHJH@time?5of?5last?5access?5in?5nanosecon@ ; `string'
PUBLIC	??_C@_0M@JMLLKCMJ@st_atime_ns?$AA@		; `string'
PUBLIC	??_C@_0BE@BAAMPMAC@time?5of?5last?5change?$AA@	; `string'
PUBLIC	??_C@_08LBMGFGJG@st_ctime?$AA@			; `string'
PUBLIC	??_C@_0BK@EAKCONKC@time?5of?5last?5modification?$AA@ ; `string'
PUBLIC	??_C@_08ILMMDHOG@st_mtime?$AA@			; `string'
PUBLIC	??_C@_0BE@EHCCHHPC@time?5of?5last?5access?$AA@	; `string'
PUBLIC	??_C@_08PMAOPHJN@st_atime?$AA@			; `string'
PUBLIC	??_C@_0BM@BBLCPICP@integer?5time?5of?5last?5change?$AA@ ; `string'
PUBLIC	??_C@_0CC@PCHPAOBE@integer?5time?5of?5last?5modificatio@ ; `string'
PUBLIC	??_C@_0BM@EGJMHDNP@integer?5time?5of?5last?5access?$AA@ ; `string'
PUBLIC	??_C@_0BF@JMDDAJIH@total?5size?0?5in?5bytes?$AA@ ; `string'
PUBLIC	??_C@_07OEENKIAN@st_size?$AA@			; `string'
PUBLIC	??_C@_0BC@BBLBPDMO@group?5ID?5of?5owner?$AA@	; `string'
PUBLIC	??_C@_06HFIFGMEM@st_gid?$AA@			; `string'
PUBLIC	??_C@_0BB@HNDLMFPF@user?5ID?5of?5owner?$AA@	; `string'
PUBLIC	??_C@_06IPJFPDFI@st_uid?$AA@			; `string'
PUBLIC	??_C@_0BF@IOMNLKLM@number?5of?5hard?5links?$AA@	; `string'
PUBLIC	??_C@_08MBANAKNM@st_nlink?$AA@			; `string'
PUBLIC	??_C@_06CHPEJBOD@device?$AA@			; `string'
PUBLIC	??_C@_06BGNOEKBF@st_dev?$AA@			; `string'
PUBLIC	??_C@_05HDNFNCKJ@inode?$AA@			; `string'
PUBLIC	??_C@_06HDOBNEDB@st_ino?$AA@			; `string'
PUBLIC	??_C@_0BA@JDIBEOPL@protection?5bits?$AA@	; `string'
PUBLIC	??_C@_07IEOFAEI@st_mode?$AA@			; `string'
_BSS	SEGMENT
win32_can_symlink DD 01H DUP (?)
	ALIGN	8

?sizeof_ioinfo@?1??_PyVerify_fd@@9@9 DQ 01H DUP (?)	; `_PyVerify_fd'::`2'::sizeof_ioinfo
has_GetFinalPathNameByHandle DD 01H DUP (?)
	ALIGN	8

billion	DQ	01H DUP (?)
Py_CreateSymbolicLinkW DQ 01H DUP (?)
Py_CreateSymbolicLinkA DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0L@FLCPIIDO@MS_WINDOWS?$AA@
CONST	SEGMENT
??_C@_0L@FLCPIIDO@MS_WINDOWS?$AA@ DB 'MS_WINDOWS', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JKEHMDF@nt?$AA@
CONST	SEGMENT
??_C@_02JKEHMDF@nt?$AA@ DB 'nt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NGEOBJJK@get_terminal_size?$AA@
CONST	SEGMENT
??_C@_0BC@NGEOBJJK@get_terminal_size?$AA@ DB 'get_terminal_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHKMJCBA@urandom?$AA@
CONST	SEGMENT
??_C@_07MHKMJCBA@urandom?$AA@ DB 'urandom', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GCOGNGOJ@_getdiskusage?$AA@
CONST	SEGMENT
??_C@_0O@GCOGNGOJ@_getdiskusage?$AA@ DB '_getdiskusage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MIMMPGNN@_isdir?$AA@
CONST	SEGMENT
??_C@_06MIMMPGNN@_isdir?$AA@ DB '_isdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FKJDANNK@_getfileinformation?$AA@
CONST	SEGMENT
??_C@_0BE@FKJDANNK@_getfileinformation?$AA@ DB '_getfileinformation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@ONBOPOKE@_getfinalpathname?$AA@
CONST	SEGMENT
??_C@_0BC@ONBOPOKE@_getfinalpathname?$AA@ DB '_getfinalpathname', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JCNCOEJI@_getfullpathname?$AA@
CONST	SEGMENT
??_C@_0BB@JCNCOEJI@_getfullpathname?$AA@ DB '_getfullpathname', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05BBAEEBBH@abort?$AA@
CONST	SEGMENT
??_C@_05BBAEEBBH@abort?$AA@ DB 'abort', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DEEMBJFM@fsync?$AA@
CONST	SEGMENT
??_C@_05DEEMBJFM@fsync?$AA@ DB 'fsync', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MHKKJIBB@strerror?$AA@
CONST	SEGMENT
??_C@_08MHKKJIBB@strerror?$AA@ DB 'strerror', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OOJCBFLM@putenv?$AA@
CONST	SEGMENT
??_C@_06OOJCBFLM@putenv?$AA@ DB 'putenv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKFKKHBG@pipe?$AA@
CONST	SEGMENT
??_C@_04MKFKKHBG@pipe?$AA@ DB 'pipe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BMABDNNN@isatty?$AA@
CONST	SEGMENT
??_C@_06BMABDNNN@isatty?$AA@ DB 'isatty', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MIPJACCK@fstat?$AA@
CONST	SEGMENT
??_C@_05MIPJACCK@fstat?$AA@ DB 'fstat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ELJELHPE@lseek?$AA@
CONST	SEGMENT
??_C@_05ELJELHPE@lseek?$AA@ DB 'lseek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LAAPLFOA@dup2?$AA@
CONST	SEGMENT
??_C@_04LAAPLFOA@dup2?$AA@ DB 'dup2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BHPKJDPK@dup?$AA@
CONST	SEGMENT
??_C@_03BHPKJDPK@dup?$AA@ DB 'dup', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PABGBABL@device_encoding?$AA@
CONST	SEGMENT
??_C@_0BA@PABGBABL@device_encoding?$AA@ DB 'device_encoding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ICENNBNA@closerange?$AA@
CONST	SEGMENT
??_C@_0L@ICENNBNA@closerange?$AA@ DB 'closerange', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PMOCAHAA@open?$AA@
CONST	SEGMENT
??_C@_04PMOCAHAA@open?$AA@ DB 'open', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BPIIBJED@waitpid?$AA@
CONST	SEGMENT
??_C@_07BPIIBJED@waitpid?$AA@ DB 'waitpid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BJJEOANI@kill?$AA@
CONST	SEGMENT
??_C@_04BJJEOANI@kill?$AA@ DB 'kill', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCFKICPJ@startfile?$AA@
CONST	SEGMENT
??_C@_09FCFKICPJ@startfile?$AA@ DB 'startfile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NPAFALFK@getlogin?$AA@
CONST	SEGMENT
??_C@_08NPAFALFK@getlogin?$AA@ DB 'getlogin', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07NNLELLPO@getppid?$AA@
CONST	SEGMENT
??_C@_07NNLELLPO@getppid?$AA@ DB 'getppid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFEBHEJM@getpid?$AA@
CONST	SEGMENT
??_C@_06FFEBHEJM@getpid?$AA@ DB 'getpid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EPDPINNO@spawnve?$AA@
CONST	SEGMENT
??_C@_07EPDPINNO@spawnve?$AA@ DB 'spawnve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06NNKHBJHE@spawnv?$AA@
CONST	SEGMENT
??_C@_06NNKHBJHE@spawnv?$AA@ DB 'spawnv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GMNLOHLP@execve?$AA@
CONST	SEGMENT
??_C@_06GMNLOHLP@execve?$AA@ DB 'execve', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OAKKMHID@execv?$AA@
CONST	SEGMENT
??_C@_05OAKKMHID@execv?$AA@ DB 'execv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EAOJNIGN@_exit?$AA@
CONST	SEGMENT
??_C@_05EAOJNIGN@_exit?$AA@ DB '_exit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MJOOAIJH@times?$AA@
CONST	SEGMENT
??_C@_05MJOOAIJH@times?$AA@ DB 'times', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HCLPLDJ@utime?$AA@
CONST	SEGMENT
??_C@_05HCLPLDJ@utime?$AA@ DB 'utime', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEMKAMD@remove?$AA@
CONST	SEGMENT
??_C@_06LEMKAMD@remove?$AA@ DB 'remove', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DAJBMHKE@unlink?$AA@
CONST	SEGMENT
??_C@_06DAJBMHKE@unlink?$AA@ DB 'unlink', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CHFEIFNB@umask?$AA@
CONST	SEGMENT
??_C@_05CHFEIFNB@umask?$AA@ DB 'umask', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KLDEEJBK@symlink?$AA@
CONST	SEGMENT
??_C@_07KLDEEJBK@symlink?$AA@ DB 'symlink', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KAJEHDMI@stat_float_times?$AA@
CONST	SEGMENT
??_C@_0BB@KAJEHDMI@stat_float_times?$AA@ DB 'stat_float_times', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GBLELIND@stat?$AA@
CONST	SEGMENT
??_C@_04GBLELIND@stat?$AA@ DB 'stat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHDOMKOF@rmdir?$AA@
CONST	SEGMENT
??_C@_05IHDOMKOF@rmdir?$AA@ DB 'rmdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LMEAOBLB@rename?$AA@
CONST	SEGMENT
??_C@_06LMEAOBLB@rename?$AA@ DB 'rename', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DPKANCED@readlink?$AA@
CONST	SEGMENT
??_C@_08DPKANCED@readlink?$AA@ DB 'readlink', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05PKPOIPAL@mkdir?$AA@
CONST	SEGMENT
??_C@_05PKPOIPAL@mkdir?$AA@ DB 'mkdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GJGCCBEM@lstat?$AA@
CONST	SEGMENT
??_C@_05GJGCCBEM@lstat?$AA@ DB 'lstat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07GMBICOLL@listdir?$AA@
CONST	SEGMENT
??_C@_07GMBICOLL@listdir?$AA@ DB 'listdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHHBHOGB@link?$AA@
CONST	SEGMENT
??_C@_04OHHBHOGB@link?$AA@ DB 'link', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DJKBFKMA@getcwdb?$AA@
CONST	SEGMENT
??_C@_07DJKBFKMA@getcwdb?$AA@ DB 'getcwdb', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BFFACJH@getcwd?$AA@
CONST	SEGMENT
??_C@_06BFFACJH@getcwd?$AA@ DB 'getcwd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OCEJBCEE@chmod?$AA@
CONST	SEGMENT
??_C@_05OCEJBCEE@chmod?$AA@ DB 'chmod', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IHFEJEKL@chdir?$AA@
CONST	SEGMENT
??_C@_05IHFEJEKL@chdir?$AA@ DB 'chdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBPNOMLE@access?$AA@
CONST	SEGMENT
??_C@_06EBPNOMLE@access?$AA@ DB 'access', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@OCNMDDG@os?4terminal_size?$AA@
CONST	SEGMENT
??_C@_0BB@OCNMDDG@os?4terminal_size?$AA@ DB 'os.terminal_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@EGPMDCBH@height?5of?5the?5terminal?5window?5in@
CONST	SEGMENT
??_C@_0CM@EGPMDCBH@height?5of?5the?5terminal?5window?5in@ DB 'height of t'
	DB	'he terminal window in characters', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DENOCHIP@lines?$AA@
CONST	SEGMENT
??_C@_05DENOCHIP@lines?$AA@ DB 'lines', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@CKMLCLCG@width?5of?5the?5terminal?5window?5in?5@
CONST	SEGMENT
??_C@_0CL@CKMLCLCG@width?5of?5the?5terminal?5window?5in?5@ DB 'width of t'
	DB	'he terminal window in characters', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HIFEPIJN@columns?$AA@
CONST	SEGMENT
??_C@_07HIFEPIJN@columns?$AA@ DB 'columns', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GECEPKB@flags?$AA@
CONST	SEGMENT
??_C@_05GECEPKB@flags?$AA@ DB 'flags', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BNFIOIGL@times_result?$AA@
CONST	SEGMENT
??_C@_0N@BNFIOIGL@times_result?$AA@ DB 'times_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@LJDHFGAF@elapsed?5time?5since?5an?5arbitrary?5@
CONST	SEGMENT
??_C@_0DC@LJDHFGAF@elapsed?5time?5since?5an?5arbitrary?5@ DB 'elapsed tim'
	DB	'e since an arbitrary point in the past', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECLNDMPC@elapsed?$AA@
CONST	SEGMENT
??_C@_07ECLNDMPC@elapsed?$AA@ DB 'elapsed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JHIBAKDA@system?5time?5of?5children?$AA@
CONST	SEGMENT
??_C@_0BI@JHIBAKDA@system?5time?5of?5children?$AA@ DB 'system time of chi'
	DB	'ldren', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPAGPIBA@children_system?$AA@
CONST	SEGMENT
??_C@_0BA@KPAGPIBA@children_system?$AA@ DB 'children_system', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LFEKOICA@user?5time?5of?5children?$AA@
CONST	SEGMENT
??_C@_0BG@LFEKOICA@user?5time?5of?5children?$AA@ DB 'user time of childre'
	DB	'n', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@MGJDGJPB@children_user?$AA@
CONST	SEGMENT
??_C@_0O@MGJDGJPB@children_user?$AA@ DB 'children_user', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IFJPBFHL@system?5time?$AA@
CONST	SEGMENT
??_C@_0M@IFJPBFHL@system?5time?$AA@ DB 'system time', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DDJCHFLJ@user?5time?$AA@
CONST	SEGMENT
??_C@_09DDJCHFLJ@user?5time?$AA@ DB 'user time', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04CCHAHKJA@user?$AA@
CONST	SEGMENT
??_C@_04CCHAHKJA@user?$AA@ DB 'user', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IKDLOEOJ@target_is_directory?$AA@
CONST	SEGMENT
??_C@_0BE@IKDLOEOJ@target_is_directory?$AA@ DB 'target_is_directory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PINLHHEI@environment?$AA@
CONST	SEGMENT
??_C@_0M@PINLHHEI@environment?$AA@ DB 'environment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GIEEDNNN@argv?$AA@
CONST	SEGMENT
??_C@_04GIEEDNNN@argv?$AA@ DB 'argv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HCEBDBKJ@uname_result?$AA@
CONST	SEGMENT
??_C@_0N@HCEBDBKJ@uname_result?$AA@ DB 'uname_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@PPOJDPCN@hardware?5identifier?$AA@
CONST	SEGMENT
??_C@_0BE@PPOJDPCN@hardware?5identifier?$AA@ DB 'hardware identifier', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHDNFCJE@machine?$AA@
CONST	SEGMENT
??_C@_07MHDNFCJE@machine?$AA@ DB 'machine', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DCDBFEHB@operating?5system?5version?$AA@
CONST	SEGMENT
??_C@_0BJ@DCDBFEHB@operating?5system?5version?$AA@ DB 'operating system v'
	DB	'ersion', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07CPCPJPKL@version?$AA@
CONST	SEGMENT
??_C@_07CPCPJPKL@version?$AA@ DB 'version', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FDHLPAHC@operating?5system?5release?$AA@
CONST	SEGMENT
??_C@_0BJ@FDHLPAHC@operating?5system?5release?$AA@ DB 'operating system r'
	DB	'elease', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOGFDLKI@release?$AA@
CONST	SEGMENT
??_C@_07EOGFDLKI@release?$AA@ DB 'release', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@CBKKCAPD@name?5of?5machine?5on?5network?5?$CIimpl@
CONST	SEGMENT
??_C@_0DE@CBKKCAPD@name?5of?5machine?5on?5network?5?$CIimpl@ DB 'name of '
	DB	'machine on network (implementation-defined)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FOEBGLLE@nodename?$AA@
CONST	SEGMENT
??_C@_08FOEBGLLE@nodename?$AA@ DB 'nodename', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JMJLGKC@operating?5system?5name?$AA@
CONST	SEGMENT
??_C@_0BG@JMJLGKC@operating?5system?5name?$AA@ DB 'operating system name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LBFJMCKJ@sysname?$AA@
CONST	SEGMENT
??_C@_07LBFJMCKJ@sysname?$AA@ DB 'sysname', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EFPHGFIP@dst_dir_fd?$AA@
CONST	SEGMENT
??_C@_0L@EFPHGFIP@dst_dir_fd?$AA@ DB 'dst_dir_fd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OFFJPAEB@src_dir_fd?$AA@
CONST	SEGMENT
??_C@_0L@OFFJPAEB@src_dir_fd?$AA@ DB 'src_dir_fd', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03HHBLCKEM@dst?$AA@
CONST	SEGMENT
??_C@_03HHBLCKEM@dst?$AA@ DB 'dst', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LOJEKLML@src?$AA@
CONST	SEGMENT
??_C@_03LOJEKLML@src?$AA@ DB 'src', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FGNLNFPF@effective_ids?$AA@
CONST	SEGMENT
??_C@_0O@FGNLNFPF@effective_ids?$AA@ DB 'effective_ids', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GMGOKAFF@mode?$AA@
CONST	SEGMENT
??_C@_04GMGOKAFF@mode?$AA@ DB 'mode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
CONST	SEGMENT
??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@ DB 'follow_symlinks', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06GPCGKDIP@dir_fd?$AA@
CONST	SEGMENT
??_C@_06GPCGKDIP@dir_fd?$AA@ DB 'dir_fd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LNEJFJGI@path?$AA@
CONST	SEGMENT
??_C@_04LNEJFJGI@path?$AA@ DB 'path', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HMGCCANC@statvfs_result?$AA@
CONST	SEGMENT
??_C@_0P@HMGCCANC@statvfs_result?$AA@ DB 'statvfs_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HMAABEP@f_namemax?$AA@
CONST	SEGMENT
??_C@_09HMAABEP@f_namemax?$AA@ DB 'f_namemax', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDAGHFFN@f_flag?$AA@
CONST	SEGMENT
??_C@_06HDAGHFFN@f_flag?$AA@ DB 'f_flag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OKABAGDI@f_favail?$AA@
CONST	SEGMENT
??_C@_08OKABAGDI@f_favail?$AA@ DB 'f_favail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GLLIAGA@f_ffree?$AA@
CONST	SEGMENT
??_C@_07GLLIAGA@f_ffree?$AA@ DB 'f_ffree', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CILFICMK@f_files?$AA@
CONST	SEGMENT
??_C@_07CILFICMK@f_files?$AA@ DB 'f_files', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BOEOCCCL@f_bavail?$AA@
CONST	SEGMENT
??_C@_08BOEOCCCL@f_bavail?$AA@ DB 'f_bavail', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNCKMCHG@f_bfree?$AA@
CONST	SEGMENT
??_C@_07JNCKMCHG@f_bfree?$AA@ DB 'f_bfree', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KLPHNGHN@f_blocks?$AA@
CONST	SEGMENT
??_C@_08KLPHNGHN@f_blocks?$AA@ DB 'f_blocks', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08KNLFHHPC@f_frsize?$AA@
CONST	SEGMENT
??_C@_08KNLFHHPC@f_frsize?$AA@ DB 'f_frsize', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFEIOOFH@f_bsize?$AA@
CONST	SEGMENT
??_C@_07KFEIOOFH@f_bsize?$AA@ DB 'f_bsize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ENKKEMPE@stat_result?$AA@
CONST	SEGMENT
??_C@_0M@ENKKEMPE@stat_result?$AA@ DB 'stat_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@EICNLNEJ@time?5of?5last?5change?5in?5nanosecon@
CONST	SEGMENT
??_C@_0CD@EICNLNEJ@time?5of?5last?5change?5in?5nanosecon@ DB 'time of las'
	DB	't change in nanoseconds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LCENIKEP@st_ctime_ns?$AA@
CONST	SEGMENT
??_C@_0M@LCENIKEP@st_ctime_ns?$AA@ DB 'st_ctime_ns', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KAFLJGCI@time?5of?5last?5modification?5in?5nan@
CONST	SEGMENT
??_C@_0CJ@KAFLJGCI@time?5of?5last?5modification?5in?5nan@ DB 'time of las'
	DB	't modification in nanoseconds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HKIPFBNN@st_mtime_ns?$AA@
CONST	SEGMENT
??_C@_0M@HKIPFBNN@st_mtime_ns?$AA@ DB 'st_mtime_ns', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MNMGLHJH@time?5of?5last?5access?5in?5nanosecon@
CONST	SEGMENT
??_C@_0CD@MNMGLHJH@time?5of?5last?5access?5in?5nanosecon@ DB 'time of las'
	DB	't access in nanoseconds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMLLKCMJ@st_atime_ns?$AA@
CONST	SEGMENT
??_C@_0M@JMLLKCMJ@st_atime_ns?$AA@ DB 'st_atime_ns', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BAAMPMAC@time?5of?5last?5change?$AA@
CONST	SEGMENT
??_C@_0BE@BAAMPMAC@time?5of?5last?5change?$AA@ DB 'time of last change', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LBMGFGJG@st_ctime?$AA@
CONST	SEGMENT
??_C@_08LBMGFGJG@st_ctime?$AA@ DB 'st_ctime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@EAKCONKC@time?5of?5last?5modification?$AA@
CONST	SEGMENT
??_C@_0BK@EAKCONKC@time?5of?5last?5modification?$AA@ DB 'time of last mod'
	DB	'ification', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILMMDHOG@st_mtime?$AA@
CONST	SEGMENT
??_C@_08ILMMDHOG@st_mtime?$AA@ DB 'st_mtime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EHCCHHPC@time?5of?5last?5access?$AA@
CONST	SEGMENT
??_C@_0BE@EHCCHHPC@time?5of?5last?5access?$AA@ DB 'time of last access', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PMAOPHJN@st_atime?$AA@
CONST	SEGMENT
??_C@_08PMAOPHJN@st_atime?$AA@ DB 'st_atime', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BBLCPICP@integer?5time?5of?5last?5change?$AA@
CONST	SEGMENT
??_C@_0BM@BBLCPICP@integer?5time?5of?5last?5change?$AA@ DB 'integer time '
	DB	'of last change', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PCHPAOBE@integer?5time?5of?5last?5modificatio@
CONST	SEGMENT
??_C@_0CC@PCHPAOBE@integer?5time?5of?5last?5modificatio@ DB 'integer time'
	DB	' of last modification', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EGJMHDNP@integer?5time?5of?5last?5access?$AA@
CONST	SEGMENT
??_C@_0BM@EGJMHDNP@integer?5time?5of?5last?5access?$AA@ DB 'integer time '
	DB	'of last access', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JMDDAJIH@total?5size?0?5in?5bytes?$AA@
CONST	SEGMENT
??_C@_0BF@JMDDAJIH@total?5size?0?5in?5bytes?$AA@ DB 'total size, in bytes'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07OEENKIAN@st_size?$AA@
CONST	SEGMENT
??_C@_07OEENKIAN@st_size?$AA@ DB 'st_size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BBLBPDMO@group?5ID?5of?5owner?$AA@
CONST	SEGMENT
??_C@_0BC@BBLBPDMO@group?5ID?5of?5owner?$AA@ DB 'group ID of owner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HFIFGMEM@st_gid?$AA@
CONST	SEGMENT
??_C@_06HFIFGMEM@st_gid?$AA@ DB 'st_gid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HNDLMFPF@user?5ID?5of?5owner?$AA@
CONST	SEGMENT
??_C@_0BB@HNDLMFPF@user?5ID?5of?5owner?$AA@ DB 'user ID of owner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06IPJFPDFI@st_uid?$AA@
CONST	SEGMENT
??_C@_06IPJFPDFI@st_uid?$AA@ DB 'st_uid', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IOMNLKLM@number?5of?5hard?5links?$AA@
CONST	SEGMENT
??_C@_0BF@IOMNLKLM@number?5of?5hard?5links?$AA@ DB 'number of hard links', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MBANAKNM@st_nlink?$AA@
CONST	SEGMENT
??_C@_08MBANAKNM@st_nlink?$AA@ DB 'st_nlink', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CHPEJBOD@device?$AA@
CONST	SEGMENT
??_C@_06CHPEJBOD@device?$AA@ DB 'device', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BGNOEKBF@st_dev?$AA@
CONST	SEGMENT
??_C@_06BGNOEKBF@st_dev?$AA@ DB 'st_dev', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HDNFNCKJ@inode?$AA@
CONST	SEGMENT
??_C@_05HDNFNCKJ@inode?$AA@ DB 'inode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDOBNEDB@st_ino?$AA@
CONST	SEGMENT
??_C@_06HDOBNEDB@st_ino?$AA@ DB 'st_ino', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JDIBEOPL@protection?5bits?$AA@
CONST	SEGMENT
??_C@_0BA@JDIBEOPL@protection?5bits?$AA@ DB 'protection bits', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IEOFAEI@st_mode?$AA@
CONST	SEGMENT
??_C@_07IEOFAEI@st_mode?$AA@ DB 'st_mode', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
posix__doc__ DB	'This module provides access to operating system function'
	DB	'ality that is', 0aH, 'standardized by the C Standard and the '
	DB	'POSIX standard (a thinly', 0aH, 'disguised Unix interface).  '
	DB	'Refer to the library manual and', 0aH, 'corresponding Unix ma'
	DB	'nual entries for more information on calls.', 00H
	ORG $+5
secs_between_epochs DQ 00000002b6109100H
stat_result__doc__ DB 'stat_result: Result from stat, fstat, or lstat.', 0aH
	DB	0aH, 'This object may be accessed either as a tuple of', 0aH, ' '
	DB	' (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)'
	DB	0aH, 'or via the attributes st_mode, st_ino, st_dev, st_nlink,'
	DB	' st_uid, and so on.', 0aH, 0aH, 'Posix/windows: If your platf'
	DB	'orm supports st_blksize, st_blocks, st_rdev,', 0aH, 'or st_fl'
	DB	'ags, they are available as attributes only.', 0aH, 0aH, 'See '
	DB	'os.stat for more information.', 00H
	ORG $+2
stat_result_fields DQ FLAT:??_C@_07IEOFAEI@st_mode?$AA@
	DQ	FLAT:??_C@_0BA@JDIBEOPL@protection?5bits?$AA@
	DQ	FLAT:??_C@_06HDOBNEDB@st_ino?$AA@
	DQ	FLAT:??_C@_05HDNFNCKJ@inode?$AA@
	DQ	FLAT:??_C@_06BGNOEKBF@st_dev?$AA@
	DQ	FLAT:??_C@_06CHPEJBOD@device?$AA@
	DQ	FLAT:??_C@_08MBANAKNM@st_nlink?$AA@
	DQ	FLAT:??_C@_0BF@IOMNLKLM@number?5of?5hard?5links?$AA@
	DQ	FLAT:??_C@_06IPJFPDFI@st_uid?$AA@
	DQ	FLAT:??_C@_0BB@HNDLMFPF@user?5ID?5of?5owner?$AA@
	DQ	FLAT:??_C@_06HFIFGMEM@st_gid?$AA@
	DQ	FLAT:??_C@_0BC@BBLBPDMO@group?5ID?5of?5owner?$AA@
	DQ	FLAT:??_C@_07OEENKIAN@st_size?$AA@
	DQ	FLAT:??_C@_0BF@JMDDAJIH@total?5size?0?5in?5bytes?$AA@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BM@EGJMHDNP@integer?5time?5of?5last?5access?$AA@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0CC@PCHPAOBE@integer?5time?5of?5last?5modificatio@
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BM@BBLCPICP@integer?5time?5of?5last?5change?$AA@
	DQ	FLAT:??_C@_08PMAOPHJN@st_atime?$AA@
	DQ	FLAT:??_C@_0BE@EHCCHHPC@time?5of?5last?5access?$AA@
	DQ	FLAT:??_C@_08ILMMDHOG@st_mtime?$AA@
	DQ	FLAT:??_C@_0BK@EAKCONKC@time?5of?5last?5modification?$AA@
	DQ	FLAT:??_C@_08LBMGFGJG@st_ctime?$AA@
	DQ	FLAT:??_C@_0BE@BAAMPMAC@time?5of?5last?5change?$AA@
	DQ	FLAT:??_C@_0M@JMLLKCMJ@st_atime_ns?$AA@
	DQ	FLAT:??_C@_0CD@MNMGLHJH@time?5of?5last?5access?5in?5nanosecon@
	DQ	FLAT:??_C@_0M@HKIPFBNN@st_mtime_ns?$AA@
	DQ	FLAT:??_C@_0CJ@KAFLJGCI@time?5of?5last?5modification?5in?5nan@
	DQ	FLAT:??_C@_0M@LCENIKEP@st_ctime_ns?$AA@
	DQ	FLAT:??_C@_0CD@EICNLNEJ@time?5of?5last?5change?5in?5nanosecon@
	DQ	0000000000000000H
	ORG $+8
stat_result_desc DQ FLAT:??_C@_0M@ENKKEMPE@stat_result?$AA@
	DQ	FLAT:stat_result__doc__
	DQ	FLAT:stat_result_fields
	DD	0aH
	ORG $+4
statvfs_result__doc__ DB 'statvfs_result: Result from statvfs or fstatvfs'
	DB	'.', 0aH, 0aH, 'This object may be accessed either as a tuple '
	DB	'of', 0aH, '  (bsize, frsize, blocks, bfree, bavail, files, ff'
	DB	'ree, favail, flag, namemax),', 0aH, 'or via the attributes f_'
	DB	'bsize, f_frsize, f_blocks, f_bfree, and so on.', 0aH, 0aH, 'S'
	DB	'ee os.statvfs for more information.', 00H
	ORG $+1
statvfs_result_fields DQ FLAT:??_C@_07KFEIOOFH@f_bsize?$AA@
	ORG $+8
	DQ	FLAT:??_C@_08KNLFHHPC@f_frsize?$AA@
	ORG $+8
	DQ	FLAT:??_C@_08KLPHNGHN@f_blocks?$AA@
	ORG $+8
	DQ	FLAT:??_C@_07JNCKMCHG@f_bfree?$AA@
	ORG $+8
	DQ	FLAT:??_C@_08BOEOCCCL@f_bavail?$AA@
	ORG $+8
	DQ	FLAT:??_C@_07CILFICMK@f_files?$AA@
	ORG $+8
	DQ	FLAT:??_C@_07GLLIAGA@f_ffree?$AA@
	ORG $+8
	DQ	FLAT:??_C@_08OKABAGDI@f_favail?$AA@
	ORG $+8
	DQ	FLAT:??_C@_06HDAGHFFN@f_flag?$AA@
	ORG $+8
	DQ	FLAT:??_C@_09HMAABEP@f_namemax?$AA@
	ORG $+8
	DQ	0000000000000000H
	ORG $+8
statvfs_result_desc DQ FLAT:??_C@_0P@HMGCCANC@statvfs_result?$AA@
	DQ	FLAT:statvfs_result__doc__
	DQ	FLAT:statvfs_result_fields
	DD	0aH
	ORG $+4
_stat_float_times DD 01H
	ORG $+12
stat_float_times__doc__ DB 'stat_float_times([newval]) -> oldval', 0aH, 0aH
	DB	'Determine whether os.[lf]stat represents time stamps as float'
	DB	' objects.', 0aH, 'If newval is True, future calls to stat() r'
	DB	'eturn floats, if it is False,', 0aH, 'future calls return int'
	DB	's. ', 0aH, 'If newval is omitted, return the current setting.'
	DB	0aH, 00H
	ORG $+12
posix_stat__doc__ DB 'stat(path, *, dir_fd=None, follow_symlinks=True) ->'
	DB	' stat result', 0aH, 0aH, 'Perform a stat system call on the g'
	DB	'iven path.', 0aH, 0aH, 'path may be specified as either a str'
	DB	'ing or as an open file descriptor.', 0aH, 0aH, 'If dir_fd is '
	DB	'not None, it should be a file descriptor open to a directory,'
	DB	0aH, '  and path should be relative; path will then be relativ'
	DB	'e to that directory.', 0aH, '  dir_fd may not be supported on'
	DB	' your platform; if it is unavailable, using', 0aH, '  it will'
	DB	' raise a NotImplementedError.', 0aH, 'If follow_symlinks is F'
	DB	'alse, and the last element of the path is a symbolic', 0aH, ' '
	DB	' link, stat will examine the symbolic link itself instead of '
	DB	'the file the', 0aH, '  link points to.', 0aH, 'It is an error'
	DB	' to use dir_fd or follow_symlinks when specifying path as', 0aH
	DB	'  an open file descriptor.', 00H
?keywords@?1??posix_stat@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_stat'::`2'::keywords
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
	DQ	0000000000000000H
posix_lstat__doc__ DB 'lstat(path, *, dir_fd=None) -> stat result', 0aH, 0aH
	DB	'Like stat(), but do not follow symbolic links.', 0aH, 'Equiva'
	DB	'lent to stat(path, follow_symlinks=False).', 00H
	ORG $+4
?keywords@?1??posix_lstat@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_lstat'::`2'::keywords
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_access__doc__ DB 'access(path, mode, *, dir_fd=None, effective_ids='
	DB	'False, follow_symlinks=True)', 0aH, 0aH, 'Use the real uid/gi'
	DB	'd to test for access to a path.  Returns True if granted,', 0aH
	DB	'False otherwise.', 0aH, 0aH, 'If dir_fd is not None, it shoul'
	DB	'd be a file descriptor open to a directory,', 0aH, '  and pat'
	DB	'h should be relative; path will then be relative to that dire'
	DB	'ctory.', 0aH, 'If effective_ids is True, access will use the '
	DB	'effective uid/gid instead of', 0aH, '  the real uid/gid.', 0aH
	DB	'If follow_symlinks is False, and the last element of the path'
	DB	' is a symbolic', 0aH, '  link, access will examine the symbol'
	DB	'ic link itself instead of the file the', 0aH, '  link points '
	DB	'to.', 0aH, 'dir_fd, effective_ids, and follow_symlinks may no'
	DB	't be implemented', 0aH, '  on your platform.  If they are una'
	DB	'vailable, using them will raise a', 0aH, '  NotImplementedErr'
	DB	'or.', 0aH, 0aH, 'Note that most operations will use the effec'
	DB	'tive uid/gid, therefore this', 0aH, '  routine can be used in'
	DB	' a suid/sgid environment to test if the invoking user', 0aH, ' '
	DB	' has the specified access to the path.', 0aH, 'The mode argum'
	DB	'ent can be F_OK to test existence, or the inclusive-OR', 0aH, ' '
	DB	' of R_OK, W_OK, and X_OK.', 00H
	ORG $+1
?keywords@?1??posix_access@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_access'::`2'::keywords
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	FLAT:??_C@_0O@FGNLNFPF@effective_ids?$AA@
	DQ	FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
	DQ	0000000000000000H
posix_chdir__doc__ DB 'chdir(path)', 0aH, 0aH, 'Change the current workin'
	DB	'g directory to the specified path.', 0aH, 0aH, 'path may alwa'
	DB	'ys be specified as a string.', 0aH, 'On some platforms, path '
	DB	'may also be specified as an open file descriptor.', 0aH, '  I'
	DB	'f this functionality is unavailable, using it raises an excep'
	DB	'tion.', 00H
	ORG $+4
?keywords@?1??posix_chdir@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_chdir'::`2'::keywords
	DQ	0000000000000000H
	ORG $+8
posix_chmod__doc__ DB 'chmod(path, mode, *, dir_fd=None, follow_symlinks='
	DB	'True)', 0aH, 0aH, 'Change the access permissions of a file.', 0aH
	DB	0aH, 'path may always be specified as a string.', 0aH, 'On som'
	DB	'e platforms, path may also be specified as an open file descr'
	DB	'iptor.', 0aH, '  If this functionality is unavailable, using '
	DB	'it raises an exception.', 0aH, 'If dir_fd is not None, it sho'
	DB	'uld be a file descriptor open to a directory,', 0aH, '  and p'
	DB	'ath should be relative; path will then be relative to that di'
	DB	'rectory.', 0aH, 'If follow_symlinks is False, and the last el'
	DB	'ement of the path is a symbolic', 0aH, '  link, chmod will mo'
	DB	'dify the symbolic link itself instead of the file the', 0aH, ' '
	DB	' link points to.', 0aH, 'It is an error to use dir_fd or foll'
	DB	'ow_symlinks when specifying path as', 0aH, '  an open file de'
	DB	'scriptor.', 0aH, 'dir_fd and follow_symlinks may not be imple'
	DB	'mented on your platform.', 0aH, '  If they are unavailable, u'
	DB	'sing them will raise a NotImplementedError.', 00H
	ORG $+3
?keywords@?1??posix_chmod@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_chmod'::`2'::keywords
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_fsync__doc__ DB 'fsync(fildes)', 0aH, 0aH, 'force write of file wit'
	DB	'h filedescriptor to disk.', 00H
posix_getcwd__doc__ DB 'getcwd() -> path', 0aH, 0aH, 'Return a unicode st'
	DB	'ring representing the current working directory.', 00H
	ORG $+10
posix_getcwdb__doc__ DB 'getcwdb() -> path', 0aH, 0aH, 'Return a bytes st'
	DB	'ring representing the current working directory.', 00H
	ORG $+11
posix_link__doc__ DB 'link(src, dst, *, src_dir_fd=None, dst_dir_fd=None,'
	DB	' follow_symlinks=True)', 0aH, 0aH, 'Create a hard link to a f'
	DB	'ile.', 0aH, 0aH, 'If either src_dir_fd or dst_dir_fd is not N'
	DB	'one, it should be a file', 0aH, '  descriptor open to a direc'
	DB	'tory, and the respective path string (src or dst)', 0aH, '  s'
	DB	'hould be relative; the path will then be relative to that dir'
	DB	'ectory.', 0aH, 'If follow_symlinks is False, and the last ele'
	DB	'ment of src is a symbolic', 0aH, '  link, link will create a '
	DB	'link to the symbolic link itself instead of the', 0aH, '  fil'
	DB	'e the link points to.', 0aH, 'src_dir_fd, dst_dir_fd, and fol'
	DB	'low_symlinks may not be implemented on your', 0aH, '  platfor'
	DB	'm.  If they are unavailable, using them will raise a', 0aH, ' '
	DB	' NotImplementedError.', 00H
	ORG $+7
?keywords@?1??posix_link@@9@9 DQ FLAT:??_C@_03LOJEKLML@src?$AA@ ; `posix_link'::`2'::keywords
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:??_C@_0L@OFFJPAEB@src_dir_fd?$AA@
	DQ	FLAT:??_C@_0L@EFPHGFIP@dst_dir_fd?$AA@
	DQ	FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_listdir__doc__ DB 'listdir(path=''.'') -> list_of_filenames', 0aH, 0aH
	DB	'Return a list containing the names of the files in the direct'
	DB	'ory.', 0aH, 'The list is in arbitrary order.  It does not inc'
	DB	'lude the special', 0aH, 'entries ''.'' and ''..'' even if the'
	DB	'y are present in the directory.', 0aH, 0aH, 'path can be spec'
	DB	'ified as either str or bytes.  If path is bytes,', 0aH, '  th'
	DB	'e filenames returned will also be bytes; in all other circums'
	DB	'tances', 0aH, '  the filenames returned will be str.', 0aH, 'O'
	DB	'n some platforms, path may also be specified as an open file '
	DB	'descriptor;', 0aH, '  the file descriptor must refer to a dir'
	DB	'ectory.', 0aH, '  If this functionality is unavailable, using'
	DB	' it raises NotImplementedError.', 00H
	ORG $+5
?keywords@?1??posix_listdir@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_listdir'::`2'::keywords
	DQ	0000000000000000H
posix__isdir__doc__ DB 'Return true if the pathname refers to an existing'
	DB	' directory.', 00H
	ORG $+11
posix_mkdir__doc__ DB 'mkdir(path, mode=0o777, *, dir_fd=None)', 0aH, 0aH
	DB	'Create a directory.', 0aH, 0aH, 'If dir_fd is not None, it sh'
	DB	'ould be a file descriptor open to a directory,', 0aH, '  and '
	DB	'path should be relative; path will then be relative to that d'
	DB	'irectory.', 0aH, 'dir_fd may not be implemented on your platf'
	DB	'orm.', 0aH, '  If it is unavailable, using it will raise a No'
	DB	'tImplementedError.', 0aH, 0aH, 'The mode argument is ignored '
	DB	'on Windows.', 00H
	ORG $+5
?keywords@?1??posix_mkdir@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_mkdir'::`2'::keywords
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
?keywords@?1??internal_rename@@9@9 DQ FLAT:??_C@_03LOJEKLML@src?$AA@ ; `internal_rename'::`2'::keywords
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:??_C@_0L@OFFJPAEB@src_dir_fd?$AA@
	DQ	FLAT:??_C@_0L@EFPHGFIP@dst_dir_fd?$AA@
	DQ	0000000000000000H
posix_rename__doc__ DB 'rename(src, dst, *, src_dir_fd=None, dst_dir_fd=N'
	DB	'one)', 0aH, 0aH, 'Rename a file or directory.', 0aH, 0aH, 'If'
	DB	' either src_dir_fd or dst_dir_fd is not None, it should be a '
	DB	'file', 0aH, '  descriptor open to a directory, and the respec'
	DB	'tive path string (src or dst)', 0aH, '  should be relative; t'
	DB	'he path will then be relative to that directory.', 0aH, 'src_'
	DB	'dir_fd and dst_dir_fd, may not be implemented on your platfor'
	DB	'm.', 0aH, '  If they are unavailable, using them will raise a'
	DB	' NotImplementedError.', 00H
	ORG $+6
posix_replace__doc__ DB 'replace(src, dst, *, src_dir_fd=None, dst_dir_fd'
	DB	'=None)', 0aH, 0aH, 'Rename a file or directory, overwriting t'
	DB	'he destination.', 0aH, 0aH, 'If either src_dir_fd or dst_dir_'
	DB	'fd is not None, it should be a file', 0aH, '  descriptor open'
	DB	' to a directory, and the respective path string (src or dst)', 0aH
	DB	'  should be relative; the path will then be relative to that '
	DB	'directory.', 0aH, 'src_dir_fd and dst_dir_fd, may not be impl'
	DB	'emented on your platform.', 0aH, '  If they are unavailable, '
	DB	'using them will raise a NotImplementedError.', 00H
	ORG $+8
posix_rmdir__doc__ DB 'rmdir(path, *, dir_fd=None)', 0aH, 0aH, 'Remove a '
	DB	'directory.', 0aH, 0aH, 'If dir_fd is not None, it should be a'
	DB	' file descriptor open to a directory,', 0aH, '  and path shou'
	DB	'ld be relative; path will then be relative to that directory.'
	DB	0aH, 'dir_fd may not be implemented on your platform.', 0aH, ' '
	DB	' If it is unavailable, using it will raise a NotImplementedEr'
	DB	'ror.', 00H
	ORG $+3
?keywords@?1??posix_rmdir@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_rmdir'::`2'::keywords
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_system__doc__ DB 'system(command) -> exit_status', 0aH, 0aH, 'Execu'
	DB	'te the command (a string) in a subshell.', 00H
	ORG $+2
posix_umask__doc__ DB 'umask(new_mask) -> old_mask', 0aH, 0aH, 'Set the c'
	DB	'urrent numeric umask and return the previous umask.', 00H
	ORG $+6
posix_unlink__doc__ DB 'unlink(path, *, dir_fd=None)', 0aH, 0aH, 'Remove '
	DB	'a file (same as remove()).', 0aH, 0aH, 'If dir_fd is not None'
	DB	', it should be a file descriptor open to a directory,', 0aH, ' '
	DB	' and path should be relative; path will then be relative to t'
	DB	'hat directory.', 0aH, 'dir_fd may not be implemented on your '
	DB	'platform.', 0aH, '  If it is unavailable, using it will raise'
	DB	' a NotImplementedError.', 00H
	ORG $+4
posix_remove__doc__ DB 'remove(path, *, dir_fd=None)', 0aH, 0aH, 'Remove '
	DB	'a file (same as unlink()).', 0aH, 0aH, 'If dir_fd is not None'
	DB	', it should be a file descriptor open to a directory,', 0aH, ' '
	DB	' and path should be relative; path will then be relative to t'
	DB	'hat directory.', 0aH, 'dir_fd may not be implemented on your '
	DB	'platform.', 0aH, '  If it is unavailable, using it will raise'
	DB	' a NotImplementedError.', 00H
	ORG $+4
?keywords@?1??posix_unlink@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_unlink'::`2'::keywords
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_uname__doc__ DB 'uname() -> uname_result', 0aH, 0aH, 'Return an obj'
	DB	'ect identifying the current operating system.', 0aH, 'The obj'
	DB	'ect behaves like a named tuple with the following fields:', 0aH
	DB	'  (sysname, nodename, release, version, machine)', 00H
	ORG $+10
uname_result_fields DQ FLAT:??_C@_07LBFJMCKJ@sysname?$AA@
	DQ	FLAT:??_C@_0BG@JMJLGKC@operating?5system?5name?$AA@
	DQ	FLAT:??_C@_08FOEBGLLE@nodename?$AA@
	DQ	FLAT:??_C@_0DE@CBKKCAPD@name?5of?5machine?5on?5network?5?$CIimpl@
	DQ	FLAT:??_C@_07EOGFDLKI@release?$AA@
	DQ	FLAT:??_C@_0BJ@FDHLPAHC@operating?5system?5release?$AA@
	DQ	FLAT:??_C@_07CPCPJPKL@version?$AA@
	DQ	FLAT:??_C@_0BJ@DCDBFEHB@operating?5system?5version?$AA@
	DQ	FLAT:??_C@_07MHDNFCJE@machine?$AA@
	DQ	FLAT:??_C@_0BE@PPOJDPCN@hardware?5identifier?$AA@
	DQ	0000000000000000H
	ORG $+8
uname_result__doc__ DB 'uname_result: Result from os.uname().', 0aH, 0aH, 'T'
	DB	'his object may be accessed either as a tuple of', 0aH, '  (sy'
	DB	'sname, nodename, release, version, machine),', 0aH, 'or via t'
	DB	'he attributes sysname, nodename, release, version, and machin'
	DB	'e.', 0aH, 0aH, 'See os.uname for more information.', 00H
	ORG $+2
uname_result_desc DQ FLAT:??_C@_0N@HCEBDBKJ@uname_result?$AA@
	DQ	FLAT:uname_result__doc__
	DQ	FLAT:uname_result_fields
	DD	05H
	ORG $+4
	ORG $+8
posix_utime__doc__ DB 'utime(path, times=None, *, ns=None, dir_fd=None, f'
	DB	'ollow_symlinks=True)', 0aH, 'Set the access and modified time'
	DB	' of path.', 0aH, 0aH, 'path may always be specified as a stri'
	DB	'ng.', 0aH, 'On some platforms, path may also be specified as '
	DB	'an open file descriptor.', 0aH, '  If this functionality is u'
	DB	'navailable, using it raises an exception.', 0aH, 0aH, 'If tim'
	DB	'es is not None, it must be a tuple (atime, mtime);', 0aH, '  '
	DB	'  atime and mtime should be expressed as float seconds since '
	DB	'the epoch.', 0aH, 'If ns is not None, it must be a tuple (ati'
	DB	'me_ns, mtime_ns);', 0aH, '    atime_ns and mtime_ns should be'
	DB	' expressed as integer nanoseconds', 0aH, '    since the epoch'
	DB	'.', 0aH, 'If both times and ns are None, utime uses the curre'
	DB	'nt time.', 0aH, 'Specifying tuples for both times and ns is a'
	DB	'n error.', 0aH, 0aH, 'If dir_fd is not None, it should be a f'
	DB	'ile descriptor open to a directory,', 0aH, '  and path should'
	DB	' be relative; path will then be relative to that directory.', 0aH
	DB	'If follow_symlinks is False, and the last element of the path'
	DB	' is a symbolic', 0aH, '  link, utime will modify the symbolic'
	DB	' link itself instead of the file the', 0aH, '  link points to'
	DB	'.', 0aH, 'It is an error to use dir_fd or follow_symlinks whe'
	DB	'n specifying path', 0aH, '  as an open file descriptor.', 0aH
	DB	'dir_fd and follow_symlinks may not be available on your platf'
	DB	'orm.', 0aH, '  If they are unavailable, using them will raise'
	DB	' a NotImplementedError.', 00H
	ORG $+10
posix__exit__doc__ DB '_exit(status)', 0aH, 0aH, 'Exit to the system with'
	DB	' specified status, without normal exit processing.', 00H
	ORG $+7
posix_execv__doc__ DB 'execv(path, args)', 0aH, 0aH, 'Execute an executab'
	DB	'le path with arguments, replacing current process.', 0aH, 0aH
	DB	'    path: path of executable file', 0aH, '    args: tuple or '
	DB	'list of strings', 00H
	ORG $+1
posix_execve__doc__ DB 'execve(path, args, env)', 0aH, 0aH, 'Execute a pa'
	DB	'th with arguments and environment, replacing current process.'
	DB	0aH, 0aH, '    path: path of executable file', 0aH, '    args:'
	DB	' tuple or list of arguments', 0aH, '    env: dictionary of st'
	DB	'rings mapping to strings', 0aH, 0aH, 'On some platforms, you '
	DB	'may specify an open file descriptor for path;', 0aH, '  execv'
	DB	'e will execute the program the file descriptor is open to.', 0aH
	DB	'  If this functionality is unavailable, using it raises NotIm'
	DB	'plementedError.', 00H
	ORG $+6
?keywords@?1??posix_execve@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_execve'::`2'::keywords
	DQ	FLAT:??_C@_04GIEEDNNN@argv?$AA@
	DQ	FLAT:??_C@_0M@PINLHHEI@environment?$AA@
	DQ	0000000000000000H
	ORG $+8
posix_spawnv__doc__ DB 'spawnv(mode, path, args)', 0aH, 0aH, 'Execute the'
	DB	' program ''path'' in a new process.', 0aH, 0aH, '    mode: mo'
	DB	'de of process creation', 0aH, '    path: path of executable f'
	DB	'ile', 0aH, '    args: tuple or list of strings', 00H
posix_spawnve__doc__ DB 'spawnve(mode, path, args, env)', 0aH, 0aH, 'Exec'
	DB	'ute the program ''path'' in a new process.', 0aH, 0aH, '    m'
	DB	'ode: mode of process creation', 0aH, '    path: path of execu'
	DB	'table file', 0aH, '    args: tuple or list of arguments', 0aH
	DB	'    env: dictionary of strings mapping to strings', 00H
	ORG $+6
posix_getpid__doc__ DB 'getpid() -> pid', 0aH, 0aH, 'Return the current p'
	DB	'rocess id', 00H
	ORG $+1
posix_getppid__doc__ DB 'getppid() -> ppid', 0aH, 0aH, 'Return the parent'
	DB	'''s process id.  If the parent process has already exited,', 0aH
	DB	'Windows machines will still return its id; others systems wil'
	DB	'l return the id', 0aH, 'of the ''init'' process (1).', 00H
	ORG $+2
posix_getlogin__doc__ DB 'getlogin() -> string', 0aH, 0aH, 'Return the ac'
	DB	'tual login name.', 00H
	ORG $+4
win32_kill__doc__ DB 'kill(pid, sig)', 0aH, 0aH, 'Kill a process with a s'
	DB	'ignal.', 00H
	ORG $+2
posix_waitpid__doc__ DB 'waitpid(pid, options) -> (pid, status << 8)', 0aH
	DB	0aH, 'Wait for completion of a given process.  options is igno'
	DB	'red on Windows.', 00H
	ORG $+11
readlink__doc__ DB 'readlink(path, *, dir_fd=None) -> path', 0aH, 0aH, 'R'
	DB	'eturn a string representing the path to which the symbolic li'
	DB	'nk points.', 0aH, 0aH, 'If dir_fd is not None, it should be a'
	DB	' file descriptor open to a directory,', 0aH, '  and path shou'
	DB	'ld be relative; path will then be relative to that directory.'
	DB	0aH, 'dir_fd may not be implemented on your platform.', 0aH, ' '
	DB	' If it is unavailable, using it will raise a NotImplementedEr'
	DB	'ror.', 00H
	ORG $+3
posix_symlink__doc__ DB 'symlink(src, dst, target_is_directory=False, *, '
	DB	'dir_fd=None)', 0aH, 0aH, 'Create a symbolic link pointing to '
	DB	'src named dst.', 0aH, 0aH, 'target_is_directory is required o'
	DB	'n Windows if the target is to be', 0aH, '  interpreted as a d'
	DB	'irectory.  (On Windows, symlink requires', 0aH, '  Windows 6.'
	DB	'0 or greater, and raises a NotImplementedError otherwise.)', 0aH
	DB	'  target_is_directory is ignored on non-Windows platforms.', 0aH
	DB	0aH, 'If dir_fd is not None, it should be a file descriptor op'
	DB	'en to a directory,', 0aH, '  and path should be relative; pat'
	DB	'h will then be relative to that directory.', 0aH, 'dir_fd may'
	DB	' not be implemented on your platform.', 0aH, '  If it is unav'
	DB	'ailable, using it will raise a NotImplementedError.', 00H
	ORG $+2
?keywords@?1??posix_symlink@@9@9 DQ FLAT:??_C@_03LOJEKLML@src?$AA@ ; `posix_symlink'::`2'::keywords
	DQ	FLAT:??_C@_03HHBLCKEM@dst?$AA@
	DQ	FLAT:??_C@_0BE@IKDLOEOJ@target_is_directory?$AA@
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
?keywords@?1??win_readlink@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `win_readlink'::`2'::keywords
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
times_result_fields DQ FLAT:??_C@_04CCHAHKJA@user?$AA@
	DQ	FLAT:??_C@_09DDJCHFLJ@user?5time?$AA@
	DQ	FLAT:??_C@_06FHFOAHML@system?$AA@
	DQ	FLAT:??_C@_0M@IFJPBFHL@system?5time?$AA@
	DQ	FLAT:??_C@_0O@MGJDGJPB@children_user?$AA@
	DQ	FLAT:??_C@_0BG@LFEKOICA@user?5time?5of?5children?$AA@
	DQ	FLAT:??_C@_0BA@KPAGPIBA@children_system?$AA@
	DQ	FLAT:??_C@_0BI@JHIBAKDA@system?5time?5of?5children?$AA@
	DQ	FLAT:??_C@_07ECLNDMPC@elapsed?$AA@
	DQ	FLAT:??_C@_0DC@LJDHFGAF@elapsed?5time?5since?5an?5arbitrary?5@
	DQ	0000000000000000H
	ORG $+8
times_result__doc__ DB 'times_result: Result from os.times().', 0aH, 0aH, 'T'
	DB	'his object may be accessed either as a tuple of', 0aH, '  (us'
	DB	'er, system, children_user, children_system, elapsed),', 0aH, 'o'
	DB	'r via the attributes user, system, children_user, children_sy'
	DB	'stem,', 0aH, 'and elapsed.', 0aH, 0aH, 'See os.times for more'
	DB	' information.', 00H
times_result_desc DQ FLAT:??_C@_0N@BNFIOIGL@times_result?$AA@
	DQ	FLAT:times_result__doc__
	DQ	FLAT:times_result_fields
	DD	05H
	ORG $+4
	ORG $+8
posix_times__doc__ DB 'times() -> times_result', 0aH, 0aH, 'Return an obj'
	DB	'ect containing floating point numbers indicating process', 0aH
	DB	'times.  The object behaves like a named tuple with these fiel'
	DB	'ds:', 0aH, '  (utime, stime, cutime, cstime, elapsed_time)', 00H
	ORG $+1
posix_open__doc__ DB 'open(path, flags, mode=0o777, *, dir_fd=None)', 0aH
	DB	0aH, 'Open a file for low level IO.  Returns a file handle (in'
	DB	'teger).', 0aH, 0aH, 'If dir_fd is not None, it should be a fi'
	DB	'le descriptor open to a directory,', 0aH, '  and path should '
	DB	'be relative; path will then be relative to that directory.', 0aH
	DB	'dir_fd may not be implemented on your platform.', 0aH, '  If '
	DB	'it is unavailable, using it will raise a NotImplementedError.'
	DB	00H
	ORG $+5
?keywords@?1??posix_open@@9@9 DQ FLAT:??_C@_04LNEJFJGI@path?$AA@ ; `posix_open'::`2'::keywords
	DQ	FLAT:??_C@_05GECEPKB@flags?$AA@
	DQ	FLAT:??_C@_04GMGOKAFF@mode?$AA@
	DQ	FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
	DQ	0000000000000000H
posix_close__doc__ DB 'close(fd)', 0aH, 0aH, 'Close a file descriptor (fo'
	DB	'r low level IO).', 00H
	ORG $+1
posix_closerange__doc__ DB 'closerange(fd_low, fd_high)', 0aH, 0aH, 'Clos'
	DB	'es all file descriptors in [fd_low, fd_high), ignoring errors'
	DB	'.', 00H
posix_dup__doc__ DB 'dup(fd) -> fd2', 0aH, 0aH, 'Return a duplicate of a '
	DB	'file descriptor.', 00H
	ORG $+7
posix_dup2__doc__ DB 'dup2(old_fd, new_fd)', 0aH, 0aH, 'Duplicate file de'
	DB	'scriptor.', 00H
	ORG $+15
posix_lseek__doc__ DB 'lseek(fd, pos, how) -> newpos', 0aH, 0aH, 'Set the'
	DB	' current position of a file descriptor.', 0aH, 'Return the ne'
	DB	'w cursor position in bytes, starting from the beginning.', 00H
	ORG $+4
posix_read__doc__ DB 'read(fd, buffersize) -> bytes', 0aH, 0aH, 'Read a f'
	DB	'ile descriptor.', 00H
	ORG $+1
posix_write__doc__ DB 'write(fd, data) -> byteswritten', 0aH, 0aH, 'Write'
	DB	' bytes to a file descriptor.', 00H
	ORG $+13
posix_fstat__doc__ DB 'fstat(fd) -> stat result', 0aH, 0aH, 'Like stat(),'
	DB	' but for an open file descriptor.', 0aH, 'Equivalent to stat('
	DB	'fd=fd).', 00H
	ORG $+13
posix_isatty__doc__ DB 'isatty(fd) -> bool', 0aH, 0aH, 'Return True if th'
	DB	'e file descriptor ''fd'' is an open file descriptor', 0aH, 'c'
	DB	'onnected to the slave end of a terminal.', 00H
	ORG $+7
posix_pipe__doc__ DB 'pipe() -> (read_end, write_end)', 0aH, 0aH, 'Create'
	DB	' a pipe.', 00H
posix_putenv__doc__ DB 'putenv(key, value)', 0aH, 0aH, 'Change or add an '
	DB	'environment variable.', 00H
	ORG $+13
posix_strerror__doc__ DB 'strerror(code) -> string', 0aH, 0aH, 'Translate'
	DB	' an error code to a message string.', 00H
	ORG $+9
win32__getdiskusage__doc__ DB '_getdiskusage(path) -> (total, free)', 0aH
	DB	0aH, 'Return disk usage statistics about the given path as (to'
	DB	'tal, free) tuple.', 00H
posix_abort__doc__ DB 'abort() -> does not return!', 0aH, 0aH, 'Abort the'
	DB	' interpreter immediately.  This ''dumps core'' or otherwise f'
	DB	'ails', 0aH, 'in the hardest way possible on the hosting opera'
	DB	'ting system.', 00H
	ORG $+13
win32_startfile__doc__ DB 'startfile(filepath [, operation]) - Start a fi'
	DB	'le with its associated', 0aH, 'application.', 0aH, 0aH, 'When'
	DB	' "operation" is not specified or "open", this acts like', 0aH
	DB	'double-clicking the file in Explorer, or giving the file name'
	DB	' as an', 0aH, 'argument to the DOS "start" command: the file '
	DB	'is opened with whatever', 0aH, 'application (if any) its exte'
	DB	'nsion is associated.', 0aH, 'When another "operation" is give'
	DB	'n, it specifies what should be done with', 0aH, 'the file.  A'
	DB	' typical operation is "print".', 0aH, 0aH, 'startfile returns'
	DB	' as soon as the associated application is launched.', 0aH, 'T'
	DB	'here is no option to wait for the application to close, and n'
	DB	'o way', 0aH, 'to retrieve the application''s exit status.', 0aH
	DB	0aH, 'The filepath is relative to the current directory.  If y'
	DB	'ou want to use', 0aH, 'an absolute path, make sure the first '
	DB	'character is not a slash ("/");', 0aH, 'the underlying Win32 '
	DB	'ShellExecute function doesn''t work if it is.', 00H
	ORG $+12
device_encoding__doc__ DB 'device_encoding(fd) -> str', 0aH, 0aH, 'Return'
	DB	' a string describing the encoding of the device', 0aH, 'if th'
	DB	'e output is a terminal; else return None.', 00H
	ORG $+15
posix_urandom__doc__ DB 'urandom(n) -> str', 0aH, 0aH, 'Return n random b'
	DB	'ytes suitable for cryptographic use.', 00H
	ORG $+7
TerminalSize_docstring DB 'A tuple of (columns, lines) for holding termin'
	DB	'al window size', 00H
	ORG $+3
TerminalSize_fields DQ FLAT:??_C@_07HIFEPIJN@columns?$AA@
	DQ	FLAT:??_C@_0CL@CKMLCLCG@width?5of?5the?5terminal?5window?5in?5@
	DQ	FLAT:??_C@_05DENOCHIP@lines?$AA@
	DQ	FLAT:??_C@_0CM@EGPMDCBH@height?5of?5the?5terminal?5window?5in@
	DQ	0000000000000000H
	DQ	0000000000000000H
TerminalSize_desc DQ FLAT:??_C@_0BB@OCNMDDG@os?4terminal_size?$AA@
	DQ	FLAT:TerminalSize_docstring
	DQ	FLAT:TerminalSize_fields
	DD	02H
	ORG $+4
termsize__doc__ DB 'Return the size of the terminal window as (columns, l'
	DB	'ines).', 0aH, 0aH, 'The optional argument fd (default standar'
	DB	'd output) specifies', 0aH, 'which file descriptor should be q'
	DB	'ueried.', 0aH, 0aH, 'If the file descriptor is not connected '
	DB	'to a terminal, an OSError', 0aH, 'is thrown.', 0aH, 0aH, 'Thi'
	DB	's function will only be defined if an implementation is', 0aH
	DB	'available for this system.', 0aH, 0aH, 'shutil.get_terminal_s'
	DB	'ize is the high-level function which should ', 0aH, 'normally'
	DB	' be used, os.get_terminal_size is the low-level implementatio'
	DB	'n.', 00H
	ORG $+13
posix_methods DQ FLAT:??_C@_06EBPNOMLE@access?$AA@
	DQ	FLAT:posix_access
	DD	03H
	ORG $+4
	DQ	FLAT:posix_access__doc__
	DQ	FLAT:??_C@_05IHFEJEKL@chdir?$AA@
	DQ	FLAT:posix_chdir
	DD	03H
	ORG $+4
	DQ	FLAT:posix_chdir__doc__
	DQ	FLAT:??_C@_05OCEJBCEE@chmod?$AA@
	DQ	FLAT:posix_chmod
	DD	03H
	ORG $+4
	DQ	FLAT:posix_chmod__doc__
	DQ	FLAT:??_C@_06BFFACJH@getcwd?$AA@
	DQ	FLAT:posix_getcwd_unicode
	DD	04H
	ORG $+4
	DQ	FLAT:posix_getcwd__doc__
	DQ	FLAT:??_C@_07DJKBFKMA@getcwdb?$AA@
	DQ	FLAT:posix_getcwd_bytes
	DD	04H
	ORG $+4
	DQ	FLAT:posix_getcwdb__doc__
	DQ	FLAT:??_C@_04OHHBHOGB@link?$AA@
	DQ	FLAT:posix_link
	DD	03H
	ORG $+4
	DQ	FLAT:posix_link__doc__
	DQ	FLAT:??_C@_07GMBICOLL@listdir?$AA@
	DQ	FLAT:posix_listdir
	DD	03H
	ORG $+4
	DQ	FLAT:posix_listdir__doc__
	DQ	FLAT:??_C@_05GJGCCBEM@lstat?$AA@
	DQ	FLAT:posix_lstat
	DD	03H
	ORG $+4
	DQ	FLAT:posix_lstat__doc__
	DQ	FLAT:??_C@_05PKPOIPAL@mkdir?$AA@
	DQ	FLAT:posix_mkdir
	DD	03H
	ORG $+4
	DQ	FLAT:posix_mkdir__doc__
	DQ	FLAT:??_C@_08DPKANCED@readlink?$AA@
	DQ	FLAT:win_readlink
	DD	03H
	ORG $+4
	DQ	FLAT:readlink__doc__
	DQ	FLAT:??_C@_06LMEAOBLB@rename?$AA@
	DQ	FLAT:posix_rename
	DD	03H
	ORG $+4
	DQ	FLAT:posix_rename__doc__
	DQ	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DQ	FLAT:posix_replace
	DD	03H
	ORG $+4
	DQ	FLAT:posix_replace__doc__
	DQ	FLAT:??_C@_05IHDOMKOF@rmdir?$AA@
	DQ	FLAT:posix_rmdir
	DD	03H
	ORG $+4
	DQ	FLAT:posix_rmdir__doc__
	DQ	FLAT:??_C@_04GBLELIND@stat?$AA@
	DQ	FLAT:posix_stat
	DD	03H
	ORG $+4
	DQ	FLAT:posix_stat__doc__
	DQ	FLAT:??_C@_0BB@KAJEHDMI@stat_float_times?$AA@
	DQ	FLAT:stat_float_times
	DD	01H
	ORG $+4
	DQ	FLAT:stat_float_times__doc__
	DQ	FLAT:??_C@_07KLDEEJBK@symlink?$AA@
	DQ	FLAT:posix_symlink
	DD	03H
	ORG $+4
	DQ	FLAT:posix_symlink__doc__
	DQ	FLAT:??_C@_06FHFOAHML@system?$AA@
	DQ	FLAT:posix_system
	DD	01H
	ORG $+4
	DQ	FLAT:posix_system__doc__
	DQ	FLAT:??_C@_05CHFEIFNB@umask?$AA@
	DQ	FLAT:posix_umask
	DD	01H
	ORG $+4
	DQ	FLAT:posix_umask__doc__
	DQ	FLAT:??_C@_06DAJBMHKE@unlink?$AA@
	DQ	FLAT:posix_unlink
	DD	03H
	ORG $+4
	DQ	FLAT:posix_unlink__doc__
	DQ	FLAT:??_C@_06LEMKAMD@remove?$AA@
	DQ	FLAT:posix_unlink
	DD	03H
	ORG $+4
	DQ	FLAT:posix_remove__doc__
	DQ	FLAT:??_C@_05HCLPLDJ@utime?$AA@
	DQ	FLAT:posix_utime
	DD	03H
	ORG $+4
	DQ	FLAT:posix_utime__doc__
	DQ	FLAT:??_C@_05MJOOAIJH@times?$AA@
	DQ	FLAT:posix_times
	DD	04H
	ORG $+4
	DQ	FLAT:posix_times__doc__
	DQ	FLAT:??_C@_05EAOJNIGN@_exit?$AA@
	DQ	FLAT:posix__exit
	DD	01H
	ORG $+4
	DQ	FLAT:posix__exit__doc__
	DQ	FLAT:??_C@_05OAKKMHID@execv?$AA@
	DQ	FLAT:posix_execv
	DD	01H
	ORG $+4
	DQ	FLAT:posix_execv__doc__
	DQ	FLAT:??_C@_06GMNLOHLP@execve?$AA@
	DQ	FLAT:posix_execve
	DD	03H
	ORG $+4
	DQ	FLAT:posix_execve__doc__
	DQ	FLAT:??_C@_06NNKHBJHE@spawnv?$AA@
	DQ	FLAT:posix_spawnv
	DD	01H
	ORG $+4
	DQ	FLAT:posix_spawnv__doc__
	DQ	FLAT:??_C@_07EPDPINNO@spawnve?$AA@
	DQ	FLAT:posix_spawnve
	DD	01H
	ORG $+4
	DQ	FLAT:posix_spawnve__doc__
	DQ	FLAT:??_C@_06FFEBHEJM@getpid?$AA@
	DQ	FLAT:posix_getpid
	DD	04H
	ORG $+4
	DQ	FLAT:posix_getpid__doc__
	DQ	FLAT:??_C@_07NNLELLPO@getppid?$AA@
	DQ	FLAT:posix_getppid
	DD	04H
	ORG $+4
	DQ	FLAT:posix_getppid__doc__
	DQ	FLAT:??_C@_08NPAFALFK@getlogin?$AA@
	DQ	FLAT:posix_getlogin
	DD	04H
	ORG $+4
	DQ	FLAT:posix_getlogin__doc__
	DQ	FLAT:??_C@_09FCFKICPJ@startfile?$AA@
	DQ	FLAT:win32_startfile
	DD	01H
	ORG $+4
	DQ	FLAT:win32_startfile__doc__
	DQ	FLAT:??_C@_04BJJEOANI@kill?$AA@
	DQ	FLAT:win32_kill
	DD	01H
	ORG $+4
	DQ	FLAT:win32_kill__doc__
	DQ	FLAT:??_C@_07BPIIBJED@waitpid?$AA@
	DQ	FLAT:posix_waitpid
	DD	01H
	ORG $+4
	DQ	FLAT:posix_waitpid__doc__
	DQ	FLAT:??_C@_04PMOCAHAA@open?$AA@
	DQ	FLAT:posix_open
	DD	03H
	ORG $+4
	DQ	FLAT:posix_open__doc__
	DQ	FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	FLAT:posix_close_
	DD	01H
	ORG $+4
	DQ	FLAT:posix_close__doc__
	DQ	FLAT:??_C@_0L@ICENNBNA@closerange?$AA@
	DQ	FLAT:posix_closerange
	DD	01H
	ORG $+4
	DQ	FLAT:posix_closerange__doc__
	DQ	FLAT:??_C@_0BA@PABGBABL@device_encoding?$AA@
	DQ	FLAT:device_encoding
	DD	01H
	ORG $+4
	DQ	FLAT:device_encoding__doc__
	DQ	FLAT:??_C@_03BHPKJDPK@dup?$AA@
	DQ	FLAT:posix_dup
	DD	01H
	ORG $+4
	DQ	FLAT:posix_dup__doc__
	DQ	FLAT:??_C@_04LAAPLFOA@dup2?$AA@
	DQ	FLAT:posix_dup2
	DD	01H
	ORG $+4
	DQ	FLAT:posix_dup2__doc__
	DQ	FLAT:??_C@_05ELJELHPE@lseek?$AA@
	DQ	FLAT:posix_lseek
	DD	01H
	ORG $+4
	DQ	FLAT:posix_lseek__doc__
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	FLAT:posix_read
	DD	01H
	ORG $+4
	DQ	FLAT:posix_read__doc__
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	FLAT:posix_write
	DD	01H
	ORG $+4
	DQ	FLAT:posix_write__doc__
	DQ	FLAT:??_C@_05MIPJACCK@fstat?$AA@
	DQ	FLAT:posix_fstat
	DD	01H
	ORG $+4
	DQ	FLAT:posix_fstat__doc__
	DQ	FLAT:??_C@_06BMABDNNN@isatty?$AA@
	DQ	FLAT:posix_isatty
	DD	01H
	ORG $+4
	DQ	FLAT:posix_isatty__doc__
	DQ	FLAT:??_C@_04MKFKKHBG@pipe?$AA@
	DQ	FLAT:posix_pipe
	DD	04H
	ORG $+4
	DQ	FLAT:posix_pipe__doc__
	DQ	FLAT:??_C@_06OOJCBFLM@putenv?$AA@
	DQ	FLAT:posix_putenv
	DD	01H
	ORG $+4
	DQ	FLAT:posix_putenv__doc__
	DQ	FLAT:??_C@_08MHKKJIBB@strerror?$AA@
	DQ	FLAT:posix_strerror
	DD	01H
	ORG $+4
	DQ	FLAT:posix_strerror__doc__
	DQ	FLAT:??_C@_05DEEMBJFM@fsync?$AA@
	DQ	FLAT:posix_fsync
	DD	08H
	ORG $+4
	DQ	FLAT:posix_fsync__doc__
	DQ	FLAT:??_C@_05BBAEEBBH@abort?$AA@
	DQ	FLAT:posix_abort
	DD	04H
	ORG $+4
	DQ	FLAT:posix_abort__doc__
	DQ	FLAT:??_C@_0BB@JCNCOEJI@_getfullpathname?$AA@
	DQ	FLAT:posix__getfullpathname
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BC@ONBOPOKE@_getfinalpathname?$AA@
	DQ	FLAT:posix__getfinalpathname
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0BE@FKJDANNK@_getfileinformation?$AA@
	DQ	FLAT:posix__getfileinformation
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:??_C@_06MIMMPGNN@_isdir?$AA@
	DQ	FLAT:posix__isdir
	DD	01H
	ORG $+4
	DQ	FLAT:posix__isdir__doc__
	DQ	FLAT:??_C@_0O@GCOGNGOJ@_getdiskusage?$AA@
	DQ	FLAT:win32__getdiskusage
	DD	01H
	ORG $+4
	DQ	FLAT:win32__getdiskusage__doc__
	DQ	FLAT:??_C@_07MHKMJCBA@urandom?$AA@
	DQ	FLAT:posix_urandom
	DD	01H
	ORG $+4
	DQ	FLAT:posix_urandom__doc__
	DQ	FLAT:??_C@_0BC@NGEOBJJK@get_terminal_size?$AA@
	DQ	FLAT:get_terminal_size
	DD	01H
	ORG $+4
	DQ	FLAT:termsize__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
posixmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_02JKEHMDF@nt?$AA@
	DQ	FLAT:posix__doc__
	DQ	ffffffffffffffffH
	DQ	FLAT:posix_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
have_functions DQ FLAT:??_C@_0L@FLCPIIDO@MS_WINDOWS?$AA@
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	_PyVerify_fd
EXTRN	__imp__errno:PROC
EXTRN	__imp__msize:PROC
EXTRN	__imp___pioinfo:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\modules\posixmodule.c
pdata	SEGMENT
$pdata$_PyVerify_fd DD imagerel $LN8
	DD	imagerel $LN8+221
	DD	imagerel $unwind$_PyVerify_fd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyVerify_fd DD 010801H
	DD	06208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyVerify_fd
_TEXT	SEGMENT
i1$ = 32
i2$ = 36
info$121251 = 40
fd$ = 64
_PyVerify_fd PROC					; COMDAT

; 972  : {

$LN8:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 973  :     const int i1 = fd >> IOINFO_L2E;

  00008	8b 44 24 40	 mov	 eax, DWORD PTR fd$[rsp]
  0000c	c1 f8 05	 sar	 eax, 5
  0000f	89 44 24 20	 mov	 DWORD PTR i1$[rsp], eax

; 974  :     const int i2 = fd & ((1 << IOINFO_L2E) - 1);

  00013	8b 44 24 40	 mov	 eax, DWORD PTR fd$[rsp]
  00017	83 e0 1f	 and	 eax, 31
  0001a	89 44 24 24	 mov	 DWORD PTR i2$[rsp], eax

; 975  : 
; 976  :     static size_t sizeof_ioinfo = 0;
; 977  : 
; 978  :     /* Determine the actual size of the ioinfo structure,
; 979  :      * as used by the CRT loaded in memory
; 980  :      */
; 981  :     if (sizeof_ioinfo == 0 && __pioinfo[0] != NULL) {

  0001e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?sizeof_ioinfo@?1??_PyVerify_fd@@9@9, 0
  00026	75 2e		 jne	 SHORT $LN5@PyVerify_f
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___pioinfo
  0002f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00033	74 21		 je	 SHORT $LN5@PyVerify_f

; 982  :         sizeof_ioinfo = _msize(__pioinfo[0]) / IOINFO_ARRAY_ELTS;

  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___pioinfo
  0003c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__msize
  00045	33 d2		 xor	 edx, edx
  00047	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004c	48 f7 f1	 div	 rcx
  0004f	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?sizeof_ioinfo@?1??_PyVerify_fd@@9@9, rax
$LN5@PyVerify_f:

; 983  :     }
; 984  :     if (sizeof_ioinfo == 0) {

  00056	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?sizeof_ioinfo@?1??_PyVerify_fd@@9@9, 0
  0005e	75 02		 jne	 SHORT $LN4@PyVerify_f

; 985  :         /* This should not happen... */
; 986  :         goto fail;

  00060	eb 68		 jmp	 SHORT $fail$121246
$LN4@PyVerify_f:

; 987  :     }
; 988  : 
; 989  :     /* See that it isn't a special CLEAR fileno */
; 990  :     if (fd != _NO_CONSOLE_FILENO) {

  00062	48 63 44 24 40	 movsxd	 rax, DWORD PTR fd$[rsp]
  00067	48 83 f8 fe	 cmp	 rax, -2
  0006b	74 5d		 je	 SHORT $LN3@PyVerify_f

; 991  :         /* Microsoft CRT would check that 0<=fd<_nhandle but we can't do that.  Instead
; 992  :          * we check pointer validity and other info
; 993  :          */
; 994  :         if (0 <= i1 && i1 < IOINFO_ARRAYS && __pioinfo[i1] != NULL) {

  0006d	83 7c 24 20 00	 cmp	 DWORD PTR i1$[rsp], 0
  00072	7c 56		 jl	 SHORT $LN2@PyVerify_f
  00074	83 7c 24 20 40	 cmp	 DWORD PTR i1$[rsp], 64	; 00000040H
  00079	7d 4f		 jge	 SHORT $LN2@PyVerify_f
  0007b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i1$[rsp]
  00080	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp___pioinfo
  00087	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0008c	74 3c		 je	 SHORT $LN2@PyVerify_f

; 995  :             /* finally, check that the file is open */
; 996  :             my_ioinfo* info = (my_ioinfo*)(__pioinfo[i1] + i2 * sizeof_ioinfo);

  0008e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i1$[rsp]
  00093	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i2$[rsp]
  00098	48 0f af 0d 00
	00 00 00	 imul	 rcx, QWORD PTR ?sizeof_ioinfo@?1??_PyVerify_fd@@9@9
  000a0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp___pioinfo
  000a7	48 03 0c c2	 add	 rcx, QWORD PTR [rdx+rax*8]
  000ab	48 8b c1	 mov	 rax, rcx
  000ae	48 89 44 24 28	 mov	 QWORD PTR info$121251[rsp], rax

; 997  :             if (info->osfile & FOPEN) {

  000b3	48 8b 44 24 28	 mov	 rax, QWORD PTR info$121251[rsp]
  000b8	0f be 40 08	 movsx	 eax, BYTE PTR [rax+8]
  000bc	83 e0 01	 and	 eax, 1
  000bf	85 c0		 test	 eax, eax
  000c1	74 07		 je	 SHORT $LN1@PyVerify_f

; 998  :                 return 1;

  000c3	b8 01 00 00 00	 mov	 eax, 1
  000c8	eb 0e		 jmp	 SHORT $LN6@PyVerify_f
$LN1@PyVerify_f:
$LN2@PyVerify_f:
$LN3@PyVerify_f:
$fail$121246:

; 999  :             }
; 1000 :         }
; 1001 :     }
; 1002 :   fail:
; 1003 :     errno = EBADF;

  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d0	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 1004 :     return 0;

  000d6	33 c0		 xor	 eax, eax
$LN6@PyVerify_f:

; 1005 : }

  000d8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dc	c3		 ret	 0
_PyVerify_fd ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0CB@NPAHCEDP@stat_float_times?$CI?$CJ?5is?5deprecated@ ; `string'
PUBLIC	??_C@_0BE@KOPFFJGN@?$HMi?3stat_float_times?$AA@	; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyBool_FromLong:PROC
EXTRN	PyErr_WarnEx:PROC
EXTRN	PyExc_DeprecationWarning:QWORD
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$stat_float_times DD imagerel stat_float_times
	DD	imagerel stat_float_times+139
	DD	imagerel $unwind$stat_float_times
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stat_float_times DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CB@NPAHCEDP@stat_float_times?$CI?$CJ?5is?5deprecated@
CONST	SEGMENT
??_C@_0CB@NPAHCEDP@stat_float_times?$CI?$CJ?5is?5deprecated@ DB 'stat_flo'
	DB	'at_times() is deprecated', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KOPFFJGN@?$HMi?3stat_float_times?$AA@
CONST	SEGMENT
??_C@_0BE@KOPFFJGN@?$HMi?3stat_float_times?$AA@ DB '|i:stat_float_times', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT stat_float_times
_TEXT	SEGMENT
newval$ = 32
self$ = 64
args$ = 72
stat_float_times PROC					; COMDAT

; 2212 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2213 :     int newval = -1;

  0000e	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR newval$[rsp], -1

; 2214 :     if (!PyArg_ParseTuple(args, "|i:stat_float_times", &newval))

  00016	4c 8d 44 24 20	 lea	 r8, QWORD PTR newval$[rsp]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@KOPFFJGN@?$HMi?3stat_float_times?$AA@
  00022	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00027	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002c	85 c0		 test	 eax, eax
  0002e	75 04		 jne	 SHORT $LN3@stat_float

; 2215 :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 52		 jmp	 SHORT $LN4@stat_float
$LN3@stat_float:

; 2216 :     if (PyErr_WarnEx(PyExc_DeprecationWarning,
; 2217 :                      "stat_float_times() is deprecated",
; 2218 :                      1))

  00034	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@NPAHCEDP@stat_float_times?$CI?$CJ?5is?5deprecated@
  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_DeprecationWarning
  00048	e8 00 00 00 00	 call	 PyErr_WarnEx
  0004d	85 c0		 test	 eax, eax
  0004f	74 04		 je	 SHORT $LN2@stat_float

; 2219 :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	eb 31		 jmp	 SHORT $LN4@stat_float
$LN2@stat_float:

; 2220 :     if (newval == -1)

  00055	83 7c 24 20 ff	 cmp	 DWORD PTR newval$[rsp], -1
  0005a	75 0d		 jne	 SHORT $LN1@stat_float

; 2221 :         /* Return old value */
; 2222 :         return PyBool_FromLong(_stat_float_times);

  0005c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _stat_float_times
  00062	e8 00 00 00 00	 call	 PyBool_FromLong
  00067	eb 1d		 jmp	 SHORT $LN4@stat_float
$LN1@stat_float:

; 2223 :     _stat_float_times = newval;

  00069	8b 44 24 20	 mov	 eax, DWORD PTR newval$[rsp]
  0006d	89 05 00 00 00
	00		 mov	 DWORD PTR _stat_float_times, eax

; 2224 :     Py_INCREF(Py_None);

  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0007a	e8 00 00 00 00	 call	 _Py_IncRef

; 2225 :     return Py_None;

  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@stat_float:

; 2226 : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
stat_float_times ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@CGADLD@O?$CG?$HM$O?$CGp?3stat?$AA@	; `string'
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
EXTRN	memset:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\posixmodule.c
pdata	SEGMENT
$pdata$posix_stat DD imagerel posix_stat
	DD	imagerel posix_stat+219
	DD	imagerel $unwind$posix_stat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_stat DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_0N@CGADLD@O?$CG?$HM$O?$CGp?3stat?$AA@
CONST	SEGMENT
??_C@_0N@CGADLD@O?$CG?$HM$O?$CGp?3stat?$AA@ DB 'O&|$O&p:stat', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_stat
_TEXT	SEGMENT
dir_fd$ = 80
return_value$ = 88
follow_symlinks$ = 96
path$ = 112
self$ = 208
args$ = 216
kwargs$ = 224
posix_stat PROC						; COMDAT

; 2450 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 2451 :     static char *keywords[] = {"path", "dir_fd", "follow_symlinks", NULL};
; 2452 :     path_t path;
; 2453 :     int dir_fd = DEFAULT_DIR_FD;

  00016	c7 44 24 50 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 2454 :     int follow_symlinks = 1;

  0001e	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR follow_symlinks$[rsp], 1

; 2455 :     PyObject *return_value;
; 2456 : 
; 2457 :     memset(&path, 0, sizeof(path));

  00026	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  0002c	33 d2		 xor	 edx, edx
  0002e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR path$[rsp]
  00033	e8 00 00 00 00	 call	 memset

; 2458 :     path.allow_fd = 1;

  00038	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR path$[rsp+20], 1

; 2459 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|$O&p:stat", keywords,
; 2460 :         path_converter, &path,
; 2461 : #ifdef HAVE_FSTATAT
; 2462 :         dir_fd_converter, &dir_fd,
; 2463 : #else
; 2464 :         dir_fd_unavailable, &dir_fd,
; 2465 : #endif
; 2466 :         &follow_symlinks))

  00043	48 8d 44 24 60	 lea	 rax, QWORD PTR follow_symlinks$[rsp]
  00048	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0004d	48 8d 44 24 50	 lea	 rax, QWORD PTR dir_fd$[rsp]
  00052	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  0005e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00063	48 8d 44 24 70	 lea	 rax, QWORD PTR path$[rsp]
  00068	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  00074	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00079	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_stat@@9@9
  00080	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@CGADLD@O?$CG?$HM$O?$CGp?3stat?$AA@
  00087	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0008f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00097	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0009c	85 c0		 test	 eax, eax
  0009e	75 04		 jne	 SHORT $LN1@posix_stat

; 2467 :         return NULL;

  000a0	33 c0		 xor	 eax, eax
  000a2	eb 2f		 jmp	 SHORT $LN2@posix_stat
$LN1@posix_stat:

; 2468 :     return_value = posix_do_stat("stat", &path, dir_fd, follow_symlinks);

  000a4	44 8b 4c 24 60	 mov	 r9d, DWORD PTR follow_symlinks$[rsp]
  000a9	44 8b 44 24 50	 mov	 r8d, DWORD PTR dir_fd$[rsp]
  000ae	48 8d 54 24 70	 lea	 rdx, QWORD PTR path$[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04GBLELIND@stat?$AA@
  000ba	e8 00 00 00 00	 call	 posix_do_stat
  000bf	48 89 44 24 58	 mov	 QWORD PTR return_value$[rsp], rax

; 2469 :     path_cleanup(&path);

  000c4	48 8d 4c 24 70	 lea	 rcx, QWORD PTR path$[rsp]
  000c9	e8 00 00 00 00	 call	 path_cleanup

; 2470 :     return return_value;

  000ce	48 8b 44 24 58	 mov	 rax, QWORD PTR return_value$[rsp]
$LN2@posix_stat:

; 2471 : }

  000d3	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  000da	c3		 ret	 0
posix_stat ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0N@JAENBMGM@path_cleanup?$AA@		; `string'
PUBLIC	??_C@_0BJ@PKCMKDKF@?4?4?2Modules?2posixmodule?4c?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$path_cleanup DD imagerel path_cleanup
	DD	imagerel path_cleanup+127
	DD	imagerel $unwind$path_cleanup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$path_cleanup DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0N@JAENBMGM@path_cleanup?$AA@
CONST	SEGMENT
??_C@_0N@JAENBMGM@path_cleanup?$AA@ DB 'path_cleanup', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PKCMKDKF@?4?4?2Modules?2posixmodule?4c?$AA@
CONST	SEGMENT
??_C@_0BJ@PKCMKDKF@?4?4?2Modules?2posixmodule?4c?$AA@ DB '..\Modules\posi'
	DB	'xmodule.c', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT path_cleanup
_TEXT	SEGMENT
_py_tmp$121062 = 48
path$ = 80
path_cleanup PROC					; COMDAT

; 694  : path_cleanup(path_t *path) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 695  :     if (path->cleanup) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0000e	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00013	74 65		 je	 SHORT $LN5@path_clean
$LN4@path_clean:

; 696  :         Py_CLEAR(path->cleanup);

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0001a	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  0001f	74 53		 je	 SHORT $LN1@path_clean
  00021	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00029	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0002e	4c 8b 48 40	 mov	 r9, QWORD PTR [rax+64]
  00032	41 b8 b8 02 00
	00		 mov	 r8d, 696		; 000002b8H
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@PKCMKDKF@?4?4?2Modules?2posixmodule?4c?$AA@
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@JAENBMGM@path_cleanup?$AA@
  00046	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004b	85 c0		 test	 eax, eax
  0004d	75 25		 jne	 SHORT $LN1@path_clean
  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00054	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00058	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$121062[rsp], rax
  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00062	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
  0006a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$121062[rsp]
  0006f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@path_clean:
  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	75 9b		 jne	 SHORT $LN4@path_clean
$LN5@path_clean:

; 697  :     }
; 698  : }

  0007a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007e	c3		 ret	 0
path_cleanup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@DNFKOBI@?$CFs?$CFsembedded?5NUL?5character?5in?5?$CFs@ ; `string'
PUBLIC	??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CC@DLOHMHOB@?$CFs?$CFsillegal?5type?5for?5?$CFs?5paramete@ ; `string'
PUBLIC	??_C@_0BJ@PBCOLDFA@string?0?5bytes?5or?5integer?$AA@ ; `string'
PUBLIC	??_C@_0BM@JCGGIPAN@?$CFs?$CFs?$CFs?5too?5long?5for?5Windows?$AA@ ; `string'
PUBLIC	??_C@_1EG@KJPGJPL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAA?$AAS?$AAC?$AAI?$AAI?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAw?$AAs@ ; `string'
PUBLIC	??_C@_1DC@FCOJIGGM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CH@JPFKICII@?$CFs?$CFscan?8t?5specify?5None?5for?5?$CFs?5ar@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	strlen:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyBytes_FromObject:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyUnicode_AsUnicode:PROC
EXTRN	__imp__wassert:PROC
EXTRN	PyUnicode_FromObject:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\posixmodule.c
pdata	SEGMENT
$pdata$path_converter DD imagerel path_converter
	DD	imagerel path_converter+2165
	DD	imagerel $unwind$path_converter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$path_converter DD 021101H
	DD	0210111H
xdata	ENDS
;	COMDAT ??_C@_0CB@DNFKOBI@?$CFs?$CFsembedded?5NUL?5character?5in?5?$CFs@
CONST	SEGMENT
??_C@_0CB@DNFKOBI@?$CFs?$CFsembedded?5NUL?5character?5in?5?$CFs@ DB '%s%s'
	DB	'embedded NUL character in %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'b', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DLOHMHOB@?$CFs?$CFsillegal?5type?5for?5?$CFs?5paramete@
CONST	SEGMENT
??_C@_0CC@DLOHMHOB@?$CFs?$CFsillegal?5type?5for?5?$CFs?5paramete@ DB '%s%'
	DB	'sillegal type for %s parameter', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PBCOLDFA@string?0?5bytes?5or?5integer?$AA@
CONST	SEGMENT
??_C@_0BJ@PBCOLDFA@string?0?5bytes?5or?5integer?$AA@ DB 'string, bytes or'
	DB	' integer', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JCGGIPAN@?$CFs?$CFs?$CFs?5too?5long?5for?5Windows?$AA@
CONST	SEGMENT
??_C@_0BM@JCGGIPAN@?$CFs?$CFs?$CFs?5too?5long?5for?5Windows?$AA@ DB '%s%s'
	DB	'%s too long for Windows', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@KJPGJPL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAA?$AAS?$AAC?$AAI?$AAI?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAw?$AAs@
CONST	SEGMENT
??_C@_1EG@KJPGJPL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAA?$AAS?$AAC?$AAI?$AAI?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAw?$AAs@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'A', 00H, 'S', 00H, 'C', 00H
	DB	'I', 00H, 'I', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, ' ', 00H, '*', 00H, ')', 00H, '(', 00H, 'u', 00H
	DB	'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ')'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'w', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@FCOJIGGM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@FCOJIGGM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'u', 00H, 'n', 00H, 'i', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 'p', 00H, 'o', 00H, 's'
	DB	00H, 'i', 00H, 'x', 00H, 'm', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JPFKICII@?$CFs?$CFscan?8t?5specify?5None?5for?5?$CFs?5ar@
CONST	SEGMENT
??_C@_0CH@JPFKICII@?$CFs?$CFscan?8t?5specify?5None?5for?5?$CFs?5ar@ DB '%'
	DB	's%scan''t specify None for %s argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT path_converter
_TEXT	SEGMENT
length$ = 48
bytes$ = 56
narrow$ = 64
unicode$ = 72
path$ = 80
wide$121091 = 88
result$121125 = 96
fd$121124 = 100
tv74 = 104
tv77 = 112
tv80 = 120
tv142 = 128
tv162 = 136
tv160 = 144
tv168 = 152
tv171 = 160
tv174 = 168
tv217 = 176
tv220 = 184
tv223 = 192
tv243 = 200
tv246 = 208
tv249 = 216
tv269 = 224
tv272 = 232
tv275 = 240
o$ = 272
p$ = 280
path_converter PROC					; COMDAT

; 701  : path_converter(PyObject *o, void *p) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 702  :     path_t *path = (path_t *)p;

  00011	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00019	48 89 44 24 50	 mov	 QWORD PTR path$[rsp], rax

; 703  :     PyObject *unicode, *bytes;
; 704  :     Py_ssize_t length;
; 705  :     char *narrow;
; 706  : 
; 707  : #define FORMAT_EXCEPTION(exc, fmt) \
; 708  :     PyErr_Format(exc, "%s%s" fmt, \
; 709  :         path->function_name ? path->function_name : "", \
; 710  :         path->function_name ? ": "                : "", \
; 711  :         path->argument_name ? path->argument_name : "path")
; 712  : 
; 713  :     /* Py_CLEANUP_SUPPORTED support */
; 714  :     if (o == NULL) {

  0001e	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR o$[rsp], 0
  00027	75 14		 jne	 SHORT $LN17@path_conve

; 715  :         path_cleanup(path);

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR path$[rsp]
  0002e	e8 00 00 00 00	 call	 path_cleanup

; 716  :         return 1;

  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	e9 30 08 00 00	 jmp	 $LN18@path_conve
$LN17@path_conve:

; 717  :     }
; 718  : 
; 719  :     /* ensure it's always safe to call path_cleanup() */
; 720  :     path->cleanup = NULL;

  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00042	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 721  : 
; 722  :     if (o == Py_None) {

  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00051	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR o$[rsp], rax
  00059	0f 85 fe 00 00
	00		 jne	 $LN16@path_conve

; 723  :         if (!path->nullable) {

  0005f	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00064	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00068	0f 85 a1 00 00
	00		 jne	 $LN15@path_conve

; 724  :             FORMAT_EXCEPTION(PyExc_TypeError,
; 725  :                              "can't specify None for %s argument");

  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00073	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00078	74 10		 je	 SHORT $LN20@path_conve
  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0007f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00083	48 89 44 24 68	 mov	 QWORD PTR tv74[rsp], rax
  00088	eb 0c		 jmp	 SHORT $LN21@path_conve
$LN20@path_conve:
  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  00091	48 89 44 24 68	 mov	 QWORD PTR tv74[rsp], rax
$LN21@path_conve:
  00096	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0009b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0009f	74 0e		 je	 SHORT $LN22@path_conve
  000a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  000a8	48 89 44 24 70	 mov	 QWORD PTR tv77[rsp], rax
  000ad	eb 0c		 jmp	 SHORT $LN23@path_conve
$LN22@path_conve:
  000af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000b6	48 89 44 24 70	 mov	 QWORD PTR tv77[rsp], rax
$LN23@path_conve:
  000bb	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  000c0	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000c4	74 0f		 je	 SHORT $LN24@path_conve
  000c6	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  000cb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ce	48 89 44 24 78	 mov	 QWORD PTR tv80[rsp], rax
  000d3	eb 0c		 jmp	 SHORT $LN25@path_conve
$LN24@path_conve:
  000d5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000dc	48 89 44 24 78	 mov	 QWORD PTR tv80[rsp], rax
$LN25@path_conve:
  000e1	48 8b 44 24 68	 mov	 rax, QWORD PTR tv74[rsp]
  000e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000eb	4c 8b 4c 24 70	 mov	 r9, QWORD PTR tv77[rsp]
  000f0	4c 8b 44 24 78	 mov	 r8, QWORD PTR tv80[rsp]
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@JPFKICII@?$CFs?$CFscan?8t?5specify?5None?5for?5?$CFs?5ar@
  000fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00103	e8 00 00 00 00	 call	 PyErr_Format

; 726  :             return 0;

  00108	33 c0		 xor	 eax, eax
  0010a	e9 5e 07 00 00	 jmp	 $LN18@path_conve
$LN15@path_conve:

; 727  :         }
; 728  :         path->wide = NULL;

  0010f	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00114	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 729  :         path->narrow = NULL;

  0011c	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00121	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 730  :         path->length = 0;

  00129	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0012e	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 731  :         path->object = o;

  00136	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0013b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR o$[rsp]
  00143	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 732  :         path->fd = -1;

  00147	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0014c	c7 40 28 ff ff
	ff ff		 mov	 DWORD PTR [rax+40], -1

; 733  :         return 1;

  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	e9 10 07 00 00	 jmp	 $LN18@path_conve
$LN16@path_conve:

; 734  :     }
; 735  : 
; 736  :     unicode = PyUnicode_FromObject(o);

  0015d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR o$[rsp]
  00165	e8 00 00 00 00	 call	 PyUnicode_FromObject
  0016a	48 89 44 24 48	 mov	 QWORD PTR unicode$[rsp], rax

; 737  :     if (unicode) {

  0016f	48 83 7c 24 48
	00		 cmp	 QWORD PTR unicode$[rsp], 0
  00175	0f 84 9a 02 00
	00		 je	 $LN14@path_conve

; 738  : #ifdef MS_WINDOWS
; 739  :         wchar_t *wide;
; 740  :         length = PyUnicode_GET_SIZE(unicode);

  0017b	48 8b 44 24 48	 mov	 rax, QWORD PTR unicode$[rsp]
  00180	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00184	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0018a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0018f	85 c0		 test	 eax, eax
  00191	75 1c		 jne	 SHORT $LN26@path_conve
  00193	41 b8 e4 02 00
	00		 mov	 r8d, 740		; 000002e4H
  00199	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@FCOJIGGM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001ad	33 c0		 xor	 eax, eax
$LN26@path_conve:
  001af	48 8b 44 24 48	 mov	 rax, QWORD PTR unicode$[rsp]
  001b4	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  001b9	74 60		 je	 SHORT $LN32@path_conve
  001bb	48 8b 44 24 48	 mov	 rax, QWORD PTR unicode$[rsp]
  001c0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001c3	c1 e8 06	 shr	 eax, 6
  001c6	83 e0 01	 and	 eax, 1
  001c9	85 c0		 test	 eax, eax
  001cb	74 25		 je	 SHORT $LN27@path_conve
  001cd	48 8b 44 24 48	 mov	 rax, QWORD PTR unicode$[rsp]
  001d2	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001d5	c1 e8 05	 shr	 eax, 5
  001d8	83 e0 01	 and	 eax, 1
  001db	85 c0		 test	 eax, eax
  001dd	74 13		 je	 SHORT $LN27@path_conve
  001df	48 8b 44 24 48	 mov	 rax, QWORD PTR unicode$[rsp]
  001e4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001e8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv142[rsp], rax
  001f0	eb 14		 jmp	 SHORT $LN28@path_conve
$LN27@path_conve:
  001f2	48 8b 44 24 48	 mov	 rax, QWORD PTR unicode$[rsp]
  001f7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  001fe	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv142[rsp], rax
$LN28@path_conve:
  00206	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv142[rsp]
  0020e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv162[rsp], rax
  00216	e9 8d 00 00 00	 jmp	 $LN33@path_conve
$LN32@path_conve:
  0021b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR unicode$[rsp]
  00220	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00225	48 8b 44 24 48	 mov	 rax, QWORD PTR unicode$[rsp]
  0022a	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0022f	75 1c		 jne	 SHORT $LN29@path_conve
  00231	41 b8 e4 02 00
	00		 mov	 r8d, 740		; 000002e4H
  00237	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0023e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@KJPGJPL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAA?$AAS?$AAC?$AAI?$AAI?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?5?$AA?$CK?$AA?$CJ?$AA?$CI?$AAu?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAw?$AAs@
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0024b	33 c0		 xor	 eax, eax
$LN29@path_conve:
  0024d	48 8b 44 24 48	 mov	 rax, QWORD PTR unicode$[rsp]
  00252	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00255	c1 e8 06	 shr	 eax, 6
  00258	83 e0 01	 and	 eax, 1
  0025b	85 c0		 test	 eax, eax
  0025d	74 25		 je	 SHORT $LN30@path_conve
  0025f	48 8b 44 24 48	 mov	 rax, QWORD PTR unicode$[rsp]
  00264	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00267	c1 e8 05	 shr	 eax, 5
  0026a	83 e0 01	 and	 eax, 1
  0026d	85 c0		 test	 eax, eax
  0026f	74 13		 je	 SHORT $LN30@path_conve
  00271	48 8b 44 24 48	 mov	 rax, QWORD PTR unicode$[rsp]
  00276	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0027a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv160[rsp], rax
  00282	eb 14		 jmp	 SHORT $LN31@path_conve
$LN30@path_conve:
  00284	48 8b 44 24 48	 mov	 rax, QWORD PTR unicode$[rsp]
  00289	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00290	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv160[rsp], rax
$LN31@path_conve:
  00298	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv160[rsp]
  002a0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv162[rsp], rax
$LN33@path_conve:
  002a8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv162[rsp]
  002b0	48 89 44 24 30	 mov	 QWORD PTR length$[rsp], rax

; 741  :         if (length > 32767) {

  002b5	48 81 7c 24 30
	ff 7f 00 00	 cmp	 QWORD PTR length$[rsp], 32767 ; 00007fffH
  002be	0f 8e c6 00 00
	00		 jle	 $LN13@path_conve

; 742  :             FORMAT_EXCEPTION(PyExc_ValueError, "%s too long for Windows");

  002c4	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  002c9	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  002ce	74 13		 je	 SHORT $LN34@path_conve
  002d0	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  002d5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002d9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
  002e1	eb 0f		 jmp	 SHORT $LN35@path_conve
$LN34@path_conve:
  002e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  002ea	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
$LN35@path_conve:
  002f2	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  002f7	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  002fb	74 11		 je	 SHORT $LN36@path_conve
  002fd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  00304	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
  0030c	eb 0f		 jmp	 SHORT $LN37@path_conve
$LN36@path_conve:
  0030e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00315	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
$LN37@path_conve:
  0031d	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00322	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00326	74 12		 je	 SHORT $LN38@path_conve
  00328	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0032d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00330	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
  00338	eb 0f		 jmp	 SHORT $LN39@path_conve
$LN38@path_conve:
  0033a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00341	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
$LN39@path_conve:
  00349	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv168[rsp]
  00351	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00356	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR tv171[rsp]
  0035e	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR tv174[rsp]
  00366	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@JCGGIPAN@?$CFs?$CFs?$CFs?5too?5long?5for?5Windows?$AA@
  0036d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00374	e8 00 00 00 00	 call	 PyErr_Format

; 743  :             Py_DECREF(unicode);

  00379	48 8b 4c 24 48	 mov	 rcx, QWORD PTR unicode$[rsp]
  0037e	e8 00 00 00 00	 call	 _Py_DecRef

; 744  :             return 0;

  00383	33 c0		 xor	 eax, eax
  00385	e9 e3 04 00 00	 jmp	 $LN18@path_conve
$LN13@path_conve:

; 745  :         }
; 746  : 
; 747  :         wide = PyUnicode_AsUnicode(unicode);

  0038a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR unicode$[rsp]
  0038f	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00394	48 89 44 24 58	 mov	 QWORD PTR wide$121091[rsp], rax

; 748  :         if (!wide) {

  00399	48 83 7c 24 58
	00		 cmp	 QWORD PTR wide$121091[rsp], 0
  0039f	75 11		 jne	 SHORT $LN12@path_conve

; 749  :             Py_DECREF(unicode);

  003a1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR unicode$[rsp]
  003a6	e8 00 00 00 00	 call	 _Py_DecRef

; 750  :             return 0;

  003ab	33 c0		 xor	 eax, eax
  003ad	e9 bb 04 00 00	 jmp	 $LN18@path_conve
$LN12@path_conve:

; 751  :         }
; 752  : 
; 753  :         path->wide = wide;

  003b2	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  003b7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR wide$121091[rsp]
  003bc	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 754  :         path->narrow = NULL;

  003c0	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  003c5	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 755  :         path->length = length;

  003cd	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  003d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR length$[rsp]
  003d7	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 756  :         path->object = o;

  003db	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  003e0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR o$[rsp]
  003e8	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 757  :         path->fd = -1;

  003ec	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  003f1	c7 40 28 ff ff
	ff ff		 mov	 DWORD PTR [rax+40], -1

; 758  :         path->cleanup = unicode;

  003f8	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  003fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR unicode$[rsp]
  00402	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 759  :         return Py_CLEANUP_SUPPORTED;

  00406	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
  0040b	e9 5d 04 00 00	 jmp	 $LN18@path_conve

; 760  : #else
; 761  :         int converted = PyUnicode_FSConverter(unicode, &bytes);
; 762  :         Py_DECREF(unicode);
; 763  :         if (!converted)
; 764  :             bytes = NULL;
; 765  : #endif
; 766  :     }
; 767  :     else {

  00410	e9 de 00 00 00	 jmp	 $LN11@path_conve
$LN14@path_conve:

; 768  :         PyErr_Clear();

  00415	e8 00 00 00 00	 call	 PyErr_Clear

; 769  :         if (PyObject_CheckBuffer(o))

  0041a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR o$[rsp]
  00422	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00426	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  0042e	74 2d		 je	 SHORT $LN10@path_conve
  00430	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR o$[rsp]
  00438	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0043c	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00443	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00447	74 14		 je	 SHORT $LN10@path_conve

; 770  :             bytes = PyBytes_FromObject(o);

  00449	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR o$[rsp]
  00451	e8 00 00 00 00	 call	 PyBytes_FromObject
  00456	48 89 44 24 38	 mov	 QWORD PTR bytes$[rsp], rax

; 771  :         else

  0045b	eb 09		 jmp	 SHORT $LN9@path_conve
$LN10@path_conve:

; 772  :             bytes = NULL;

  0045d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR bytes$[rsp], 0
$LN9@path_conve:

; 773  :         if (!bytes) {

  00466	48 83 7c 24 38
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  0046c	0f 85 81 00 00
	00		 jne	 $LN8@path_conve

; 774  :             PyErr_Clear();

  00472	e8 00 00 00 00	 call	 PyErr_Clear

; 775  :             if (path->allow_fd) {

  00477	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0047c	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00480	74 71		 je	 SHORT $LN7@path_conve

; 776  :                 int fd;
; 777  :                 int result = _fd_converter(o, &fd,
; 778  :                         "string, bytes or integer");

  00482	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BJ@PBCOLDFA@string?0?5bytes?5or?5integer?$AA@
  00489	48 8d 54 24 64	 lea	 rdx, QWORD PTR fd$121124[rsp]
  0048e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR o$[rsp]
  00496	e8 00 00 00 00	 call	 _fd_converter
  0049b	89 44 24 60	 mov	 DWORD PTR result$121125[rsp], eax

; 779  :                 if (result) {

  0049f	83 7c 24 60 00	 cmp	 DWORD PTR result$121125[rsp], 0
  004a4	74 4d		 je	 SHORT $LN6@path_conve

; 780  :                     path->wide = NULL;

  004a6	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  004ab	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 781  :                     path->narrow = NULL;

  004b3	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  004b8	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 782  :                     path->length = 0;

  004c0	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  004c5	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 783  :                     path->object = o;

  004cd	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  004d2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR o$[rsp]
  004da	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 784  :                     path->fd = fd;

  004de	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  004e3	8b 4c 24 64	 mov	 ecx, DWORD PTR fd$121124[rsp]
  004e7	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 785  :                     return result;

  004ea	8b 44 24 60	 mov	 eax, DWORD PTR result$121125[rsp]
  004ee	e9 7a 03 00 00	 jmp	 $LN18@path_conve
$LN6@path_conve:
$LN7@path_conve:
$LN8@path_conve:
$LN11@path_conve:

; 786  :                 }
; 787  :             }
; 788  :         }
; 789  :     }
; 790  : 
; 791  :     if (!bytes) {

  004f3	48 83 7c 24 38
	00		 cmp	 QWORD PTR bytes$[rsp], 0
  004f9	0f 85 ca 00 00
	00		 jne	 $LN5@path_conve

; 792  :         if (!PyErr_Occurred())

  004ff	e8 00 00 00 00	 call	 PyErr_Occurred
  00504	48 85 c0	 test	 rax, rax
  00507	0f 85 b5 00 00
	00		 jne	 $LN4@path_conve

; 793  :             FORMAT_EXCEPTION(PyExc_TypeError, "illegal type for %s parameter");

  0050d	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00512	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00517	74 13		 je	 SHORT $LN40@path_conve
  00519	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0051e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00522	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv217[rsp], rax
  0052a	eb 0f		 jmp	 SHORT $LN41@path_conve
$LN40@path_conve:
  0052c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  00533	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv217[rsp], rax
$LN41@path_conve:
  0053b	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00540	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00544	74 11		 je	 SHORT $LN42@path_conve
  00546	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  0054d	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv220[rsp], rax
  00555	eb 0f		 jmp	 SHORT $LN43@path_conve
$LN42@path_conve:
  00557	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0055e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv220[rsp], rax
$LN43@path_conve:
  00566	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0056b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0056f	74 12		 je	 SHORT $LN44@path_conve
  00571	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00576	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00579	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv223[rsp], rax
  00581	eb 0f		 jmp	 SHORT $LN45@path_conve
$LN44@path_conve:
  00583	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0058a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv223[rsp], rax
$LN45@path_conve:
  00592	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv217[rsp]
  0059a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0059f	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR tv220[rsp]
  005a7	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR tv223[rsp]
  005af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@DLOHMHOB@?$CFs?$CFsillegal?5type?5for?5?$CFs?5paramete@
  005b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  005bd	e8 00 00 00 00	 call	 PyErr_Format
$LN4@path_conve:

; 794  :         return 0;

  005c2	33 c0		 xor	 eax, eax
  005c4	e9 a4 02 00 00	 jmp	 $LN18@path_conve
$LN5@path_conve:

; 795  :     }
; 796  : 
; 797  : #ifdef MS_WINDOWS
; 798  :     if (win32_warn_bytes_api()) {

  005c9	e8 00 00 00 00	 call	 win32_warn_bytes_api
  005ce	85 c0		 test	 eax, eax
  005d0	74 11		 je	 SHORT $LN3@path_conve

; 799  :         Py_DECREF(bytes);

  005d2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytes$[rsp]
  005d7	e8 00 00 00 00	 call	 _Py_DecRef

; 800  :         return 0;

  005dc	33 c0		 xor	 eax, eax
  005de	e9 8a 02 00 00	 jmp	 $LN18@path_conve
$LN3@path_conve:

; 801  :     }
; 802  : #endif
; 803  : 
; 804  :     length = PyBytes_GET_SIZE(bytes);

  005e3	48 8b 44 24 38	 mov	 rax, QWORD PTR bytes$[rsp]
  005e8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  005ec	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  005f2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  005f7	85 c0		 test	 eax, eax
  005f9	75 1c		 jne	 SHORT $LN46@path_conve
  005fb	41 b8 24 03 00
	00		 mov	 r8d, 804		; 00000324H
  00601	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00608	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  0060f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00615	33 c0		 xor	 eax, eax
$LN46@path_conve:
  00617	48 8b 44 24 38	 mov	 rax, QWORD PTR bytes$[rsp]
  0061c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00620	48 89 44 24 30	 mov	 QWORD PTR length$[rsp], rax

; 805  : #ifdef MS_WINDOWS
; 806  :     if (length > MAX_PATH) {

  00625	48 81 7c 24 30
	04 01 00 00	 cmp	 QWORD PTR length$[rsp], 260 ; 00000104H
  0062e	0f 8e c6 00 00
	00		 jle	 $LN2@path_conve

; 807  :         FORMAT_EXCEPTION(PyExc_ValueError, "%s too long for Windows");

  00634	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00639	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0063e	74 13		 je	 SHORT $LN47@path_conve
  00640	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00645	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00649	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv243[rsp], rax
  00651	eb 0f		 jmp	 SHORT $LN48@path_conve
$LN47@path_conve:
  00653	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  0065a	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv243[rsp], rax
$LN48@path_conve:
  00662	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00667	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0066b	74 11		 je	 SHORT $LN49@path_conve
  0066d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  00674	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv246[rsp], rax
  0067c	eb 0f		 jmp	 SHORT $LN50@path_conve
$LN49@path_conve:
  0067e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00685	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv246[rsp], rax
$LN50@path_conve:
  0068d	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00692	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00696	74 12		 je	 SHORT $LN51@path_conve
  00698	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0069d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006a0	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
  006a8	eb 0f		 jmp	 SHORT $LN52@path_conve
$LN51@path_conve:
  006aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  006b1	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
$LN52@path_conve:
  006b9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv243[rsp]
  006c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006c6	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR tv246[rsp]
  006ce	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR tv249[rsp]
  006d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@JCGGIPAN@?$CFs?$CFs?$CFs?5too?5long?5for?5Windows?$AA@
  006dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  006e4	e8 00 00 00 00	 call	 PyErr_Format

; 808  :         Py_DECREF(bytes);

  006e9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytes$[rsp]
  006ee	e8 00 00 00 00	 call	 _Py_DecRef

; 809  :         return 0;

  006f3	33 c0		 xor	 eax, eax
  006f5	e9 73 01 00 00	 jmp	 $LN18@path_conve
$LN2@path_conve:

; 810  :     }
; 811  : #endif
; 812  : 
; 813  :     narrow = PyBytes_AS_STRING(bytes);

  006fa	48 8b 44 24 38	 mov	 rax, QWORD PTR bytes$[rsp]
  006ff	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00703	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00709	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0070e	85 c0		 test	 eax, eax
  00710	75 1c		 jne	 SHORT $LN53@path_conve
  00712	41 b8 2d 03 00
	00		 mov	 r8d, 813		; 0000032dH
  00718	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0071f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  00726	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0072c	33 c0		 xor	 eax, eax
$LN53@path_conve:
  0072e	48 8b 44 24 38	 mov	 rax, QWORD PTR bytes$[rsp]
  00733	48 83 c0 78	 add	 rax, 120		; 00000078H
  00737	48 89 44 24 40	 mov	 QWORD PTR narrow$[rsp], rax

; 814  :     if (length != strlen(narrow)) {

  0073c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR narrow$[rsp]
  00741	e8 00 00 00 00	 call	 strlen
  00746	48 39 44 24 30	 cmp	 QWORD PTR length$[rsp], rax
  0074b	0f 84 c3 00 00
	00		 je	 $LN1@path_conve

; 815  :         FORMAT_EXCEPTION(PyExc_ValueError, "embedded NUL character in %s");

  00751	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00756	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0075b	74 13		 je	 SHORT $LN54@path_conve
  0075d	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00762	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00766	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv269[rsp], rax
  0076e	eb 0f		 jmp	 SHORT $LN55@path_conve
$LN54@path_conve:
  00770	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  00777	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv269[rsp], rax
$LN55@path_conve:
  0077f	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00784	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00788	74 11		 je	 SHORT $LN56@path_conve
  0078a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  00791	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv272[rsp], rax
  00799	eb 0f		 jmp	 SHORT $LN57@path_conve
$LN56@path_conve:
  0079b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  007a2	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv272[rsp], rax
$LN57@path_conve:
  007aa	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  007af	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  007b3	74 12		 je	 SHORT $LN58@path_conve
  007b5	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  007ba	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007bd	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv275[rsp], rax
  007c5	eb 0f		 jmp	 SHORT $LN59@path_conve
$LN58@path_conve:
  007c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  007ce	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv275[rsp], rax
$LN59@path_conve:
  007d6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv269[rsp]
  007de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007e3	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR tv272[rsp]
  007eb	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR tv275[rsp]
  007f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@DNFKOBI@?$CFs?$CFsembedded?5NUL?5character?5in?5?$CFs@
  007fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00801	e8 00 00 00 00	 call	 PyErr_Format

; 816  :         Py_DECREF(bytes);

  00806	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytes$[rsp]
  0080b	e8 00 00 00 00	 call	 _Py_DecRef

; 817  :         return 0;

  00810	33 c0		 xor	 eax, eax
  00812	eb 59		 jmp	 SHORT $LN18@path_conve
$LN1@path_conve:

; 818  :     }
; 819  : 
; 820  :     path->wide = NULL;

  00814	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00819	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 821  :     path->narrow = narrow;

  00821	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00826	48 8b 4c 24 40	 mov	 rcx, QWORD PTR narrow$[rsp]
  0082b	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 822  :     path->length = length;

  0082f	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00834	48 8b 4c 24 30	 mov	 rcx, QWORD PTR length$[rsp]
  00839	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 823  :     path->object = o;

  0083d	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00842	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR o$[rsp]
  0084a	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 824  :     path->fd = -1;

  0084e	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  00853	c7 40 28 ff ff
	ff ff		 mov	 DWORD PTR [rax+40], -1

; 825  :     path->cleanup = bytes;

  0085a	48 8b 44 24 50	 mov	 rax, QWORD PTR path$[rsp]
  0085f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bytes$[rsp]
  00864	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 826  :     return Py_CLEANUP_SUPPORTED;

  00868	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
$LN18@path_conve:

; 827  : }

  0086d	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00874	c3		 ret	 0
path_converter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EJ@HKOFBHHG@The?5Windows?5bytes?5API?5has?5been?5d@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_warn_bytes_api DD imagerel win32_warn_bytes_api
	DD	imagerel win32_warn_bytes_api+34
	DD	imagerel $unwind$win32_warn_bytes_api
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_warn_bytes_api DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0EJ@HKOFBHHG@The?5Windows?5bytes?5API?5has?5been?5d@
CONST	SEGMENT
??_C@_0EJ@HKOFBHHG@The?5Windows?5bytes?5API?5has?5been?5d@ DB 'The Window'
	DB	's bytes API has been deprecated, use Unicode filenames instea'
	DB	'd', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT win32_warn_bytes_api
_TEXT	SEGMENT
win32_warn_bytes_api PROC				; COMDAT

; 410  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 411  :     return PyErr_WarnEx(PyExc_DeprecationWarning,
; 412  :         "The Windows bytes API has been deprecated, "
; 413  :         "use Unicode filenames instead",
; 414  :         1);

  00004	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EJ@HKOFBHHG@The?5Windows?5bytes?5API?5has?5been?5d@
  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_DeprecationWarning
  00018	e8 00 00 00 00	 call	 PyErr_WarnEx

; 415  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
win32_warn_bytes_api ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@ ; `string'
PUBLIC	??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@ ; `string'
PUBLIC	??_C@_0CC@BGKGJPHI@argument?5should?5be?5?$CFs?0?5not?5?$CF?4200@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyType_IsSubtype:PROC
EXTRN	PyFloat_Type:BYTE
EXTRN	PyLong_AsLongAndOverflow:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_fd_converter DD imagerel _fd_converter
	DD	imagerel _fd_converter+252
	DD	imagerel $unwind$_fd_converter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_fd_converter DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@
CONST	SEGMENT
??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@ DB 'signed inte'
	DB	'ger is less than minimum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@
CONST	SEGMENT
??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@ DB 'signed integ'
	DB	'er is greater than maximum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BGKGJPHI@argument?5should?5be?5?$CFs?0?5not?5?$CF?4200@
CONST	SEGMENT
??_C@_0CC@BGKGJPHI@argument?5should?5be?5?$CFs?0?5not?5?$CF?4200@ DB 'arg'
	DB	'ument should be %s, not %.200s', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _fd_converter
_TEXT	SEGMENT
overflow$ = 32
long_value$ = 36
o$ = 64
p$ = 72
allowed$ = 80
_fd_converter PROC					; COMDAT

; 561  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 562  :     int overflow;
; 563  :     long long_value = PyLong_AsLongAndOverflow(o, &overflow);

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR overflow$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  0001d	e8 00 00 00 00	 call	 PyLong_AsLongAndOverflow
  00022	89 44 24 24	 mov	 DWORD PTR long_value$[rsp], eax

; 564  :     if (PyFloat_Check(o) ||
; 565  :         (long_value == -1 && !overflow && PyErr_Occurred())) {

  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00032	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00036	74 31		 je	 SHORT $LN5@fd_convert
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00044	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00048	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004d	85 c0		 test	 eax, eax
  0004f	75 18		 jne	 SHORT $LN5@fd_convert
  00051	83 7c 24 24 ff	 cmp	 DWORD PTR long_value$[rsp], -1
  00056	75 3f		 jne	 SHORT $LN6@fd_convert
  00058	83 7c 24 20 00	 cmp	 DWORD PTR overflow$[rsp], 0
  0005d	75 38		 jne	 SHORT $LN6@fd_convert
  0005f	e8 00 00 00 00	 call	 PyErr_Occurred
  00064	48 85 c0	 test	 rax, rax
  00067	74 2e		 je	 SHORT $LN6@fd_convert
$LN5@fd_convert:

; 566  :         PyErr_Clear();

  00069	e8 00 00 00 00	 call	 PyErr_Clear

; 567  :         PyErr_Format(PyExc_TypeError,
; 568  :                         "argument should be %s, not %.200s",
; 569  :                         allowed, Py_TYPE(o)->tp_name);

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00073	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00077	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  0007b	4c 8b 44 24 50	 mov	 r8, QWORD PTR allowed$[rsp]
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@BGKGJPHI@argument?5should?5be?5?$CFs?0?5not?5?$CF?4200@
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0008e	e8 00 00 00 00	 call	 PyErr_Format

; 570  :         return 0;

  00093	33 c0		 xor	 eax, eax
  00095	eb 60		 jmp	 SHORT $LN7@fd_convert
$LN6@fd_convert:

; 571  :     }
; 572  :     if (overflow > 0 || long_value > INT_MAX) {

  00097	83 7c 24 20 00	 cmp	 DWORD PTR overflow$[rsp], 0
  0009c	7f 0a		 jg	 SHORT $LN3@fd_convert
  0009e	81 7c 24 24 ff
	ff ff 7f	 cmp	 DWORD PTR long_value$[rsp], 2147483647 ; 7fffffffH
  000a6	7e 17		 jle	 SHORT $LN4@fd_convert
$LN3@fd_convert:

; 573  :         PyErr_SetString(PyExc_OverflowError,
; 574  :                         "signed integer is greater than maximum");

  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@OOIIJIN@signed?5integer?5is?5greater?5than?5m@
  000af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000b6	e8 00 00 00 00	 call	 PyErr_SetString

; 575  :         return 0;

  000bb	33 c0		 xor	 eax, eax
  000bd	eb 38		 jmp	 SHORT $LN7@fd_convert
$LN4@fd_convert:

; 576  :     }
; 577  :     if (overflow < 0 || long_value < INT_MIN) {

  000bf	83 7c 24 20 00	 cmp	 DWORD PTR overflow$[rsp], 0
  000c4	7c 0a		 jl	 SHORT $LN1@fd_convert
  000c6	81 7c 24 24 00
	00 00 80	 cmp	 DWORD PTR long_value$[rsp], -2147483648 ; ffffffff80000000H
  000ce	7d 17		 jge	 SHORT $LN2@fd_convert
$LN1@fd_convert:

; 578  :         PyErr_SetString(PyExc_OverflowError,
; 579  :                         "signed integer is less than minimum");

  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@OIJKLPAI@signed?5integer?5is?5less?5than?5mini@
  000d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000de	e8 00 00 00 00	 call	 PyErr_SetString

; 580  :         return 0;

  000e3	33 c0		 xor	 eax, eax
  000e5	eb 10		 jmp	 SHORT $LN7@fd_convert
$LN2@fd_convert:

; 581  :     }
; 582  :     *p = (int)long_value;

  000e7	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  000ec	8b 4c 24 24	 mov	 ecx, DWORD PTR long_value$[rsp]
  000f0	89 08		 mov	 DWORD PTR [rax], ecx

; 583  :     return 1;

  000f2	b8 01 00 00 00	 mov	 eax, 1
$LN7@fd_convert:

; 584  : }

  000f7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fb	c3		 ret	 0
_fd_converter ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dir_fd_unavailable DD imagerel dir_fd_unavailable
	DD	imagerel dir_fd_unavailable+83
	DD	imagerel $unwind$dir_fd_unavailable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dir_fd_unavailable DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT dir_fd_unavailable
_TEXT	SEGMENT
dir_fd$ = 32
o$ = 64
p$ = 72
dir_fd_unavailable PROC					; COMDAT

; 840  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 841  :     int dir_fd;
; 842  :     if (!dir_fd_converter(o, &dir_fd))

  0000e	48 8d 54 24 20	 lea	 rdx, QWORD PTR dir_fd$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00018	e8 00 00 00 00	 call	 dir_fd_converter
  0001d	85 c0		 test	 eax, eax
  0001f	75 04		 jne	 SHORT $LN2@dir_fd_una

; 843  :         return 0;

  00021	33 c0		 xor	 eax, eax
  00023	eb 29		 jmp	 SHORT $LN3@dir_fd_una
$LN2@dir_fd_una:

; 844  :     if (dir_fd != DEFAULT_DIR_FD) {

  00025	83 7c 24 20 9c	 cmp	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH
  0002a	74 12		 je	 SHORT $LN1@dir_fd_una

; 845  :         argument_unavailable_error(NULL, "dir_fd");

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
  00033	33 c9		 xor	 ecx, ecx
  00035	e8 00 00 00 00	 call	 argument_unavailable_error

; 846  :         return 0;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 10		 jmp	 SHORT $LN3@dir_fd_una
$LN1@dir_fd_una:

; 847  :     }
; 848  :     *(int *)p = dir_fd;

  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  00043	8b 4c 24 20	 mov	 ecx, DWORD PTR dir_fd$[rsp]
  00047	89 08		 mov	 DWORD PTR [rax], ecx

; 849  :     return 1;

  00049	b8 01 00 00 00	 mov	 eax, 1
$LN3@dir_fd_una:

; 850  : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
dir_fd_unavailable ENDP
_TEXT	ENDS
PUBLIC	??_C@_07LKHFMGFB@integer?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$dir_fd_converter DD imagerel dir_fd_converter
	DD	imagerel dir_fd_converter+73
	DD	imagerel $unwind$dir_fd_converter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dir_fd_converter DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_07LKHFMGFB@integer?$AA@
CONST	SEGMENT
??_C@_07LKHFMGFB@integer?$AA@ DB 'integer', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT dir_fd_converter
_TEXT	SEGMENT
o$ = 48
p$ = 56
dir_fd_converter PROC					; COMDAT

; 588  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 589  :     if (o == Py_None) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00015	48 39 44 24 30	 cmp	 QWORD PTR o$[rsp], rax
  0001a	75 12		 jne	 SHORT $LN1@dir_fd_con

; 590  :         *(int *)p = DEFAULT_DIR_FD;

  0001c	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  00021	c7 00 9c ff ff
	ff		 mov	 DWORD PTR [rax], -100	; ffffffffffffff9cH

; 591  :         return 1;

  00027	b8 01 00 00 00	 mov	 eax, 1
  0002c	eb 16		 jmp	 SHORT $LN2@dir_fd_con
$LN1@dir_fd_con:

; 592  :     }
; 593  :     return _fd_converter(o, (int *)p, "integer");

  0002e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07LKHFMGFB@integer?$AA@
  00035	48 8b 54 24 38	 mov	 rdx, QWORD PTR p$[rsp]
  0003a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR o$[rsp]
  0003f	e8 00 00 00 00	 call	 _fd_converter
$LN2@dir_fd_con:

; 594  : }

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
dir_fd_converter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@DLOFAMMF@?$CFs?$CFs?$CFs?5unavailable?5on?5this?5platf@ ; `string'
EXTRN	PyExc_NotImplementedError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$argument_unavailable_error DD imagerel argument_unavailable_error
	DD	imagerel argument_unavailable_error+124
	DD	imagerel $unwind$argument_unavailable_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$argument_unavailable_error DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0CE@DLOFAMMF@?$CFs?$CFs?$CFs?5unavailable?5on?5this?5platf@
CONST	SEGMENT
??_C@_0CE@DLOFAMMF@?$CFs?$CFs?$CFs?5unavailable?5on?5this?5platf@ DB '%s%'
	DB	's%s unavailable on this platform', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT argument_unavailable_error
_TEXT	SEGMENT
tv67 = 48
tv70 = 56
function_name$ = 80
argument_name$ = 88
argument_unavailable_error PROC				; COMDAT

; 830  : argument_unavailable_error(char *function_name, char *argument_name) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 831  :     PyErr_Format(PyExc_NotImplementedError,
; 832  :         "%s%s%s unavailable on this platform",
; 833  :         (function_name != NULL) ? function_name : "",
; 834  :         (function_name != NULL) ? ": ": "",
; 835  :         argument_name);

  0000e	48 83 7c 24 50
	00		 cmp	 QWORD PTR function_name$[rsp], 0
  00014	74 0e		 je	 SHORT $LN3@argument_u
  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  0001d	48 89 44 24 30	 mov	 QWORD PTR tv67[rsp], rax
  00022	eb 0c		 jmp	 SHORT $LN4@argument_u
$LN3@argument_u:
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0002b	48 89 44 24 30	 mov	 QWORD PTR tv67[rsp], rax
$LN4@argument_u:
  00030	48 83 7c 24 50
	00		 cmp	 QWORD PTR function_name$[rsp], 0
  00036	74 0c		 je	 SHORT $LN5@argument_u
  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR function_name$[rsp]
  0003d	48 89 44 24 38	 mov	 QWORD PTR tv70[rsp], rax
  00042	eb 0c		 jmp	 SHORT $LN6@argument_u
$LN5@argument_u:
  00044	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0004b	48 89 44 24 38	 mov	 QWORD PTR tv70[rsp], rax
$LN6@argument_u:
  00050	48 8b 44 24 58	 mov	 rax, QWORD PTR argument_name$[rsp]
  00055	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005a	4c 8b 4c 24 30	 mov	 r9, QWORD PTR tv67[rsp]
  0005f	4c 8b 44 24 38	 mov	 r8, QWORD PTR tv70[rsp]
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@DLOFAMMF@?$CFs?$CFs?$CFs?5unavailable?5on?5this?5platf@
  0006b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00072	e8 00 00 00 00	 call	 PyErr_Format

; 836  : }

  00077	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007b	c3		 ret	 0
argument_unavailable_error ENDP
_TEXT	ENDS
EXTRN	PyEval_RestoreThread:PROC
EXTRN	PyEval_SaveThread:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_do_stat DD imagerel posix_do_stat
	DD	imagerel posix_do_stat+426
	DD	imagerel $unwind$posix_do_stat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_do_stat DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_do_stat
_TEXT	SEGMENT
st$ = 32
result$ = 128
_save$121991 = 136
function_name$ = 160
path$ = 168
dir_fd$ = 176
follow_symlinks$ = 184
posix_do_stat PROC					; COMDAT

; 2385 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2386 :     STRUCT_STAT st;
; 2387 :     int result;
; 2388 : 
; 2389 : #if !defined(MS_WINDOWS) && !defined(HAVE_FSTATAT) && !defined(HAVE_LSTAT)
; 2390 :     if (follow_symlinks_specified(function_name, follow_symlinks))
; 2391 :         return NULL;
; 2392 : #endif
; 2393 : 
; 2394 :     if (path_and_dir_fd_invalid("stat", path, dir_fd) ||
; 2395 :         dir_fd_and_fd_invalid("stat", dir_fd, path->fd) ||
; 2396 :         fd_and_follow_symlinks_invalid("stat", path->fd, follow_symlinks))

  0001b	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR dir_fd$[rsp]
  00023	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04GBLELIND@stat?$AA@
  00032	e8 00 00 00 00	 call	 path_and_dir_fd_invalid
  00037	85 c0		 test	 eax, eax
  00039	75 46		 jne	 SHORT $LN10@posix_do_s
  0003b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR path$[rsp]
  00043	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  00047	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR dir_fd$[rsp]
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04GBLELIND@stat?$AA@
  00055	e8 00 00 00 00	 call	 dir_fd_and_fd_invalid
  0005a	85 c0		 test	 eax, eax
  0005c	75 23		 jne	 SHORT $LN10@posix_do_s
  0005e	44 8b 84 24 b8
	00 00 00	 mov	 r8d, DWORD PTR follow_symlinks$[rsp]
  00066	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR path$[rsp]
  0006e	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04GBLELIND@stat?$AA@
  00078	e8 00 00 00 00	 call	 fd_and_follow_symlinks_invalid
  0007d	85 c0		 test	 eax, eax
  0007f	74 07		 je	 SHORT $LN11@posix_do_s
$LN10@posix_do_s:

; 2397 :         return NULL;

  00081	33 c0		 xor	 eax, eax
  00083	e9 1a 01 00 00	 jmp	 $LN12@posix_do_s
$LN11@posix_do_s:

; 2398 : 
; 2399 :     Py_BEGIN_ALLOW_THREADS

  00088	e8 00 00 00 00	 call	 PyEval_SaveThread
  0008d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR _save$121991[rsp], rax

; 2400 :     if (path->fd != -1)

  00095	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR path$[rsp]
  0009d	83 78 28 ff	 cmp	 DWORD PTR [rax+40], -1
  000a1	74 21		 je	 SHORT $LN9@posix_do_s

; 2401 :         result = FSTAT(path->fd, &st);

  000a3	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$[rsp]
  000a8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR path$[rsp]
  000b0	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  000b3	e8 00 00 00 00	 call	 win32_fstat
  000b8	89 84 24 80 00
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 2402 :     else

  000bf	e9 a7 00 00 00	 jmp	 $LN8@posix_do_s
$LN9@posix_do_s:

; 2403 : #ifdef MS_WINDOWS
; 2404 :     if (path->wide) {

  000c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR path$[rsp]
  000cc	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000d1	74 48		 je	 SHORT $LN7@posix_do_s

; 2405 :         if (follow_symlinks)

  000d3	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR follow_symlinks$[rsp], 0
  000db	74 1f		 je	 SHORT $LN6@posix_do_s

; 2406 :             result = win32_stat_w(path->wide, &st);

  000dd	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$[rsp]
  000e2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR path$[rsp]
  000ea	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000ee	e8 00 00 00 00	 call	 win32_stat_w
  000f3	89 84 24 80 00
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 2407 :         else

  000fa	eb 1d		 jmp	 SHORT $LN5@posix_do_s
$LN6@posix_do_s:

; 2408 :             result = win32_lstat_w(path->wide, &st);

  000fc	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$[rsp]
  00101	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR path$[rsp]
  00109	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0010d	e8 00 00 00 00	 call	 win32_lstat_w
  00112	89 84 24 80 00
	00 00		 mov	 DWORD PTR result$[rsp], eax
$LN5@posix_do_s:

; 2409 :     }
; 2410 :     else

  00119	eb 50		 jmp	 SHORT $LN4@posix_do_s
$LN7@posix_do_s:

; 2411 : #endif
; 2412 : #if defined(HAVE_LSTAT) || defined(MS_WINDOWS)
; 2413 :     if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))

  0011b	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR follow_symlinks$[rsp], 0
  00123	75 29		 jne	 SHORT $LN3@posix_do_s
  00125	83 bc 24 b0 00
	00 00 9c	 cmp	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH
  0012d	75 1f		 jne	 SHORT $LN3@posix_do_s

; 2414 :         result = LSTAT(path->narrow, &st);

  0012f	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$[rsp]
  00134	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR path$[rsp]
  0013c	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00140	e8 00 00 00 00	 call	 win32_lstat
  00145	89 84 24 80 00
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 2415 :     else

  0014c	eb 1d		 jmp	 SHORT $LN2@posix_do_s
$LN3@posix_do_s:

; 2416 : #endif
; 2417 : #ifdef HAVE_FSTATAT
; 2418 :     if ((dir_fd != DEFAULT_DIR_FD) || !follow_symlinks)
; 2419 :         result = fstatat(dir_fd, path->narrow, &st,
; 2420 :                          follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW);
; 2421 :     else
; 2422 : #endif
; 2423 :         result = STAT(path->narrow, &st);

  0014e	48 8d 54 24 20	 lea	 rdx, QWORD PTR st$[rsp]
  00153	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR path$[rsp]
  0015b	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0015f	e8 00 00 00 00	 call	 win32_stat
  00164	89 84 24 80 00
	00 00		 mov	 DWORD PTR result$[rsp], eax
$LN2@posix_do_s:
$LN4@posix_do_s:
$LN8@posix_do_s:

; 2424 :     Py_END_ALLOW_THREADS

  0016b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _save$121991[rsp]
  00173	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 2425 : 
; 2426 :     if (result != 0)

  00178	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR result$[rsp], 0
  00180	74 16		 je	 SHORT $LN1@posix_do_s

; 2427 :         return path_error("stat", path);

  00182	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  0018a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04GBLELIND@stat?$AA@
  00191	e8 00 00 00 00	 call	 path_error
  00196	eb 0a		 jmp	 SHORT $LN12@posix_do_s
$LN1@posix_do_s:

; 2428 : 
; 2429 :     return _pystat_fromstructstat(&st);

  00198	48 8d 4c 24 20	 lea	 rcx, QWORD PTR st$[rsp]
  0019d	e8 00 00 00 00	 call	 _pystat_fromstructstat
$LN12@posix_do_s:

; 2430 : }

  001a2	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001a9	c3		 ret	 0
posix_do_stat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@IKCDEHOG@?$CFs?3?5can?8t?5specify?5dir_fd?5without@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$path_and_dir_fd_invalid DD imagerel path_and_dir_fd_invalid
	DD	imagerel path_and_dir_fd_invalid+88
	DD	imagerel $unwind$path_and_dir_fd_invalid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$path_and_dir_fd_invalid DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_0CP@IKCDEHOG@?$CFs?3?5can?8t?5specify?5dir_fd?5without@
CONST	SEGMENT
??_C@_0CP@IKCDEHOG@?$CFs?3?5can?8t?5specify?5dir_fd?5without@ DB '%s: can'
	DB	'''t specify dir_fd without matching path', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT path_and_dir_fd_invalid
_TEXT	SEGMENT
function_name$ = 48
path$ = 56
dir_fd$ = 64
path_and_dir_fd_invalid PROC				; COMDAT

; 871  : path_and_dir_fd_invalid(char *function_name, path_t *path, int dir_fd) {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 872  :     if (!path->narrow && !path->wide && (dir_fd != DEFAULT_DIR_FD)) {

  00013	48 8b 44 24 38	 mov	 rax, QWORD PTR path$[rsp]
  00018	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0001d	75 32		 jne	 SHORT $LN1@path_and_d
  0001f	48 8b 44 24 38	 mov	 rax, QWORD PTR path$[rsp]
  00024	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00029	75 26		 jne	 SHORT $LN1@path_and_d
  0002b	83 7c 24 40 9c	 cmp	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH
  00030	74 1f		 je	 SHORT $LN1@path_and_d

; 873  :         PyErr_Format(PyExc_ValueError,
; 874  :                      "%s: can't specify dir_fd without matching path",
; 875  :                      function_name);

  00032	4c 8b 44 24 30	 mov	 r8, QWORD PTR function_name$[rsp]
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@IKCDEHOG@?$CFs?3?5can?8t?5specify?5dir_fd?5without@
  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00045	e8 00 00 00 00	 call	 PyErr_Format

; 876  :         return 1;

  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	eb 02		 jmp	 SHORT $LN2@path_and_d
$LN1@path_and_d:

; 877  :     }
; 878  :     return 0;

  00051	33 c0		 xor	 eax, eax
$LN2@path_and_d:

; 879  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
path_and_dir_fd_invalid ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@OAKJNGDG@?$CFs?3?5can?8t?5specify?5both?5dir_fd?5an@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$dir_fd_and_fd_invalid DD imagerel dir_fd_and_fd_invalid
	DD	imagerel dir_fd_and_fd_invalid+70
	DD	imagerel $unwind$dir_fd_and_fd_invalid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dir_fd_and_fd_invalid DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT ??_C@_0CF@OAKJNGDG@?$CFs?3?5can?8t?5specify?5both?5dir_fd?5an@
CONST	SEGMENT
??_C@_0CF@OAKJNGDG@?$CFs?3?5can?8t?5specify?5both?5dir_fd?5an@ DB '%s: ca'
	DB	'n''t specify both dir_fd and fd', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT dir_fd_and_fd_invalid
_TEXT	SEGMENT
function_name$ = 48
dir_fd$ = 56
fd$ = 64
dir_fd_and_fd_invalid PROC				; COMDAT

; 882  : dir_fd_and_fd_invalid(char *function_name, int dir_fd, int fd) {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 883  :     if ((dir_fd != DEFAULT_DIR_FD) && (fd != -1)) {

  00012	83 7c 24 38 9c	 cmp	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH
  00017	74 26		 je	 SHORT $LN1@dir_fd_and
  00019	83 7c 24 40 ff	 cmp	 DWORD PTR fd$[rsp], -1
  0001e	74 1f		 je	 SHORT $LN1@dir_fd_and

; 884  :         PyErr_Format(PyExc_ValueError,
; 885  :                      "%s: can't specify both dir_fd and fd",
; 886  :                      function_name);

  00020	4c 8b 44 24 30	 mov	 r8, QWORD PTR function_name$[rsp]
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@OAKJNGDG@?$CFs?3?5can?8t?5specify?5both?5dir_fd?5an@
  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00033	e8 00 00 00 00	 call	 PyErr_Format

; 887  :         return 1;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	eb 02		 jmp	 SHORT $LN2@dir_fd_and
$LN1@dir_fd_and:

; 888  :     }
; 889  :     return 0;

  0003f	33 c0		 xor	 eax, eax
$LN2@dir_fd_and:

; 890  : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
dir_fd_and_fd_invalid ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@IKLHAPIA@?$CFs?3?5cannot?5use?5fd?5and?5follow_sym@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$fd_and_follow_symlinks_invalid DD imagerel fd_and_follow_symlinks_invalid
	DD	imagerel fd_and_follow_symlinks_invalid+70
	DD	imagerel $unwind$fd_and_follow_symlinks_invalid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fd_and_follow_symlinks_invalid DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT ??_C@_0CP@IKLHAPIA@?$CFs?3?5cannot?5use?5fd?5and?5follow_sym@
CONST	SEGMENT
??_C@_0CP@IKLHAPIA@?$CFs?3?5cannot?5use?5fd?5and?5follow_sym@ DB '%s: can'
	DB	'not use fd and follow_symlinks together', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fd_and_follow_symlinks_invalid
_TEXT	SEGMENT
function_name$ = 48
fd$ = 56
follow_symlinks$ = 64
fd_and_follow_symlinks_invalid PROC			; COMDAT

; 894  :                                int follow_symlinks) {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 895  :     if ((fd > 0) && (!follow_symlinks)) {

  00012	83 7c 24 38 00	 cmp	 DWORD PTR fd$[rsp], 0
  00017	7e 26		 jle	 SHORT $LN1@fd_and_fol
  00019	83 7c 24 40 00	 cmp	 DWORD PTR follow_symlinks$[rsp], 0
  0001e	75 1f		 jne	 SHORT $LN1@fd_and_fol

; 896  :         PyErr_Format(PyExc_ValueError,
; 897  :                      "%s: cannot use fd and follow_symlinks together",
; 898  :                      function_name);

  00020	4c 8b 44 24 30	 mov	 r8, QWORD PTR function_name$[rsp]
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@IKLHAPIA@?$CFs?3?5cannot?5use?5fd?5and?5follow_sym@
  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00033	e8 00 00 00 00	 call	 PyErr_Format

; 899  :         return 1;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	eb 02		 jmp	 SHORT $LN2@fd_and_fol
$LN1@fd_and_fol:

; 900  :     }
; 901  :     return 0;

  0003f	33 c0		 xor	 eax, eax
$LN2@fd_and_fol:

; 902  : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
fd_and_follow_symlinks_invalid ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$path_error DD imagerel path_error
	DD	imagerel path_error+97
	DD	imagerel $unwind$path_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$path_error DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT path_error
_TEXT	SEGMENT
function_name$ = 48
path$ = 56
path_error PROC						; COMDAT

; 1280 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1281 : #ifdef MS_WINDOWS
; 1282 :     if (path->narrow)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR path$[rsp]
  00013	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00018	74 15		 je	 SHORT $LN2@path_error

; 1283 :         return win32_error(function_name, path->narrow);

  0001a	48 8b 44 24 38	 mov	 rax, QWORD PTR path$[rsp]
  0001f	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR function_name$[rsp]
  00028	e8 00 00 00 00	 call	 win32_error
  0002d	eb 2d		 jmp	 SHORT $LN3@path_error
$LN2@path_error:

; 1284 :     if (path->wide)

  0002f	48 8b 44 24 38	 mov	 rax, QWORD PTR path$[rsp]
  00034	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00039	74 15		 je	 SHORT $LN1@path_error

; 1285 :         return win32_error_unicode(function_name, path->wide);

  0003b	48 8b 44 24 38	 mov	 rax, QWORD PTR path$[rsp]
  00040	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR function_name$[rsp]
  00049	e8 00 00 00 00	 call	 win32_error_unicode
  0004e	eb 0c		 jmp	 SHORT $LN3@path_error
$LN1@path_error:

; 1286 :     return win32_error(function_name, NULL);

  00050	33 d2		 xor	 edx, edx
  00052	48 8b 4c 24 30	 mov	 rcx, QWORD PTR function_name$[rsp]
  00057	e8 00 00 00 00	 call	 win32_error
$LN3@path_error:

; 1287 : #else
; 1288 :     return path_posix_error(function_name, path);
; 1289 : #endif
; 1290 : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
path_error ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromWindowsErr:PROC
EXTRN	PyErr_SetFromWindowsErrWithFilename:PROC
EXTRN	__imp_GetLastError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_error DD imagerel win32_error
	DD	imagerel win32_error+84
	DD	imagerel $unwind$win32_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_error DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_error
_TEXT	SEGMENT
tv65 = 32
function$ = 64
filename$ = 72
win32_error PROC					; COMDAT

; 1226 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1227 :     /* XXX We should pass the function name along in the future.
; 1228 :        (winreg.c also wants to pass the function name.)
; 1229 :        This would however require an additional param to the
; 1230 :        Windows error object, which is non-trivial.
; 1231 :     */
; 1232 :     errno = GetLastError();

  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00014	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0001e	8b 4c 24 20	 mov	 ecx, DWORD PTR tv65[rsp]
  00022	89 08		 mov	 DWORD PTR [rax], ecx

; 1233 :     if (filename)

  00024	48 83 7c 24 48
	00		 cmp	 QWORD PTR filename$[rsp], 0
  0002a	74 16		 je	 SHORT $LN2@win32_erro

; 1234 :         return PyErr_SetFromWindowsErrWithFilename(errno, filename);

  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00032	48 8b 54 24 48	 mov	 rdx, QWORD PTR filename$[rsp]
  00037	8b 08		 mov	 ecx, DWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErrWithFilename
  0003e	eb 0f		 jmp	 SHORT $LN3@win32_erro

; 1235 :     else

  00040	eb 0d		 jmp	 SHORT $LN1@win32_erro
$LN2@win32_erro:

; 1236 :         return PyErr_SetFromWindowsErr(errno);

  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00048	8b 08		 mov	 ecx, DWORD PTR [rax]
  0004a	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
$LN1@win32_erro:
$LN3@win32_erro:

; 1237 : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
win32_error ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromWindowsErrWithUnicodeFilename:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_error_unicode DD imagerel win32_error_unicode
	DD	imagerel win32_error_unicode+84
	DD	imagerel $unwind$win32_error_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_error_unicode DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_error_unicode
_TEXT	SEGMENT
tv65 = 32
function$ = 64
filename$ = 72
win32_error_unicode PROC				; COMDAT

; 1241 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1242 :     /* XXX - see win32_error for comments on 'function' */
; 1243 :     errno = GetLastError();

  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00014	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0001e	8b 4c 24 20	 mov	 ecx, DWORD PTR tv65[rsp]
  00022	89 08		 mov	 DWORD PTR [rax], ecx

; 1244 :     if (filename)

  00024	48 83 7c 24 48
	00		 cmp	 QWORD PTR filename$[rsp], 0
  0002a	74 16		 je	 SHORT $LN2@win32_erro@2

; 1245 :         return PyErr_SetFromWindowsErrWithUnicodeFilename(errno, filename);

  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00032	48 8b 54 24 48	 mov	 rdx, QWORD PTR filename$[rsp]
  00037	8b 08		 mov	 ecx, DWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErrWithUnicodeFilename
  0003e	eb 0f		 jmp	 SHORT $LN3@win32_erro@2

; 1246 :     else

  00040	eb 0d		 jmp	 SHORT $LN1@win32_erro@2
$LN2@win32_erro@2:

; 1247 :         return PyErr_SetFromWindowsErr(errno);

  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00048	8b 08		 mov	 ecx, DWORD PTR [rax]
  0004a	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
$LN1@win32_erro@2:
$LN3@win32_erro@2:

; 1248 : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
win32_error_unicode ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_lstat DD imagerel win32_lstat
	DD	imagerel win32_lstat+37
	DD	imagerel $unwind$win32_lstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_lstat DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_lstat
_TEXT	SEGMENT
path$ = 48
result$ = 56
win32_lstat PROC					; COMDAT

; 1944 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1945 :     return win32_xstat(path, result, FALSE);

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR result$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR path$[rsp]
  0001b	e8 00 00 00 00	 call	 win32_xstat

; 1946 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
win32_lstat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_xstat DD imagerel win32_xstat
	DD	imagerel win32_xstat+64
	DD	imagerel $unwind$win32_xstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_xstat DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_xstat
_TEXT	SEGMENT
code$ = 32
path$ = 64
result$ = 72
traverse$ = 80
win32_xstat PROC					; COMDAT

; 1912 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1913 :     /* Protocol violation: we explicitly clear errno, instead of
; 1914 :        setting it to a POSIX error. Callers should use GetLastError. */
; 1915 :     int code = win32_xstat_impl(path, result, traverse);

  00013	44 8b 44 24 50	 mov	 r8d, DWORD PTR traverse$[rsp]
  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR result$[rsp]
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  00022	e8 00 00 00 00	 call	 win32_xstat_impl
  00027	89 44 24 20	 mov	 DWORD PTR code$[rsp], eax

; 1916 :     errno = 0;

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00031	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1917 :     return code;

  00037	8b 44 24 20	 mov	 eax, DWORD PTR code$[rsp]

; 1918 : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
win32_xstat ENDP
_TEXT	ENDS
PUBLIC	??_C@_04PNGHFIJN@?4com?$AA@			; `string'
PUBLIC	??_C@_04JLMDILM@?4exe?$AA@			; `string'
PUBLIC	??_C@_04CPCBDHLK@?4cmd?$AA@			; `string'
PUBLIC	??_C@_04NEEFLLOK@?4bat?$AA@			; `string'
EXTRN	__imp_stricmp:PROC
EXTRN	__imp_strrchr:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_GetFileInformationByHandle:PROC
EXTRN	__imp_SetLastError:PROC
EXTRN	__imp_CreateFileA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_xstat_impl DD imagerel win32_xstat_impl
	DD	imagerel win32_xstat_impl+688
	DD	imagerel $unwind$win32_xstat_impl
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_xstat_impl DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT ??_C@_04PNGHFIJN@?4com?$AA@
CONST	SEGMENT
??_C@_04PNGHFIJN@?4com?$AA@ DB '.com', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLMDILM@?4exe?$AA@
CONST	SEGMENT
??_C@_04JLMDILM@?4exe?$AA@ DB '.exe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CPCBDHLK@?4cmd?$AA@
CONST	SEGMENT
??_C@_04CPCBDHLK@?4cmd?$AA@ DB '.cmd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04NEEFLLOK@?4bat?$AA@
CONST	SEGMENT
??_C@_04NEEFLLOK@?4bat?$AA@ DB '.bat', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT win32_xstat_impl
_TEXT	SEGMENT
dot$ = 64
reparse_tag$ = 72
code$ = 76
target_path$ = 80
hFile$ = 88
hFile2$ = 96
info$ = 104
path$ = 176
result$ = 184
traverse$ = 192
win32_xstat_impl PROC					; COMDAT

; 1721 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1722 :     int code;
; 1723 :     HANDLE hFile, hFile2;
; 1724 :     BY_HANDLE_FILE_INFORMATION info;
; 1725 :     ULONG reparse_tag = 0;

  00016	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR reparse_tag$[rsp], 0

; 1726 :     wchar_t *target_path;
; 1727 :     const char *dot;
; 1728 : 
; 1729 :     if(!check_GetFinalPathNameByHandle()) {

  0001e	e8 00 00 00 00	 call	 check_GetFinalPathNameByHandle
  00023	85 c0		 test	 eax, eax
  00025	75 0b		 jne	 SHORT $LN18@win32_xsta

; 1730 :         /* If the OS doesn't have GetFinalPathNameByHandle, don't
; 1731 :            traverse reparse point. */
; 1732 :         traverse = FALSE;

  00027	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR traverse$[rsp], 0
$LN18@win32_xsta:

; 1733 :     }
; 1734 : 
; 1735 :     hFile = CreateFileA(
; 1736 :         path,
; 1737 :         FILE_READ_ATTRIBUTES, /* desired access */
; 1738 :         0, /* share mode */
; 1739 :         NULL, /* security attributes */
; 1740 :         OPEN_EXISTING,
; 1741 :         /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */
; 1742 :         /* FILE_FLAG_OPEN_REPARSE_POINT does not follow the symlink.
; 1743 :            Because of this, calls like GetFinalPathNameByHandle will return
; 1744 :            the symlink path again and not the actual final path. */
; 1745 :         FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS|
; 1746 :             FILE_FLAG_OPEN_REPARSE_POINT,
; 1747 :         NULL);

  00032	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0003b	c7 44 24 28 80
	00 20 02	 mov	 DWORD PTR [rsp+40], 35651712 ; 02200080H
  00043	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  0004b	45 33 c9	 xor	 r9d, r9d
  0004e	45 33 c0	 xor	 r8d, r8d
  00051	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00056	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00064	48 89 44 24 58	 mov	 QWORD PTR hFile$[rsp], rax

; 1748 : 
; 1749 :     if (hFile == INVALID_HANDLE_VALUE) {

  00069	48 83 7c 24 58
	ff		 cmp	 QWORD PTR hFile$[rsp], -1
  0006f	75 6b		 jne	 SHORT $LN17@win32_xsta

; 1750 :         /* Either the target doesn't exist, or we don't have access to
; 1751 :            get a handle to it. If the former, we need to return an error.
; 1752 :            If the latter, we can use attributes_from_dir. */
; 1753 :         if (GetLastError() != ERROR_SHARING_VIOLATION)

  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00077	83 f8 20	 cmp	 eax, 32			; 00000020H
  0007a	74 0a		 je	 SHORT $LN16@win32_xsta

; 1754 :             return -1;

  0007c	b8 ff ff ff ff	 mov	 eax, -1
  00081	e9 22 02 00 00	 jmp	 $LN19@win32_xsta
$LN16@win32_xsta:

; 1755 :         /* Could not get attributes on open file. Fall back to
; 1756 :            reading the directory. */
; 1757 :         if (!attributes_from_dir(path, &info, &reparse_tag))

  00086	4c 8d 44 24 48	 lea	 r8, QWORD PTR reparse_tag$[rsp]
  0008b	48 8d 54 24 68	 lea	 rdx, QWORD PTR info$[rsp]
  00090	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00098	e8 00 00 00 00	 call	 attributes_from_dir
  0009d	85 c0		 test	 eax, eax
  0009f	75 0a		 jne	 SHORT $LN15@win32_xsta

; 1758 :             /* Very strange. This should not fail now */
; 1759 :             return -1;

  000a1	b8 ff ff ff ff	 mov	 eax, -1
  000a6	e9 fd 01 00 00	 jmp	 $LN19@win32_xsta
$LN15@win32_xsta:

; 1760 :         if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

  000ab	8b 44 24 68	 mov	 eax, DWORD PTR info$[rsp]
  000af	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  000b4	85 c0		 test	 eax, eax
  000b6	74 1f		 je	 SHORT $LN14@win32_xsta

; 1761 :             if (traverse) {

  000b8	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR traverse$[rsp], 0
  000c0	74 15		 je	 SHORT $LN13@win32_xsta

; 1762 :                 /* Should traverse, but could not open reparse point handle */
; 1763 :                 SetLastError(ERROR_SHARING_VIOLATION);

  000c2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError

; 1764 :                 return -1;

  000cd	b8 ff ff ff ff	 mov	 eax, -1
  000d2	e9 d1 01 00 00	 jmp	 $LN19@win32_xsta
$LN13@win32_xsta:
$LN14@win32_xsta:

; 1765 :             }
; 1766 :         }
; 1767 :     } else {

  000d7	e9 21 01 00 00	 jmp	 $LN12@win32_xsta
$LN17@win32_xsta:

; 1768 :         if (!GetFileInformationByHandle(hFile, &info)) {

  000dc	48 8d 54 24 68	 lea	 rdx, QWORD PTR info$[rsp]
  000e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileInformationByHandle
  000ec	85 c0		 test	 eax, eax
  000ee	75 15		 jne	 SHORT $LN11@win32_xsta

; 1769 :             CloseHandle(hFile);

  000f0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 1770 :             return -1;

  000fb	b8 ff ff ff ff	 mov	 eax, -1
  00100	e9 a3 01 00 00	 jmp	 $LN19@win32_xsta
$LN11@win32_xsta:

; 1771 :         }
; 1772 :         if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

  00105	8b 44 24 68	 mov	 eax, DWORD PTR info$[rsp]
  00109	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0010e	85 c0		 test	 eax, eax
  00110	0f 84 dc 00 00
	00		 je	 $LN10@win32_xsta

; 1773 :             if (!win32_get_reparse_tag(hFile, &reparse_tag))

  00116	48 8d 54 24 48	 lea	 rdx, QWORD PTR reparse_tag$[rsp]
  0011b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  00120	e8 00 00 00 00	 call	 win32_get_reparse_tag
  00125	85 c0		 test	 eax, eax
  00127	75 0a		 jne	 SHORT $LN9@win32_xsta

; 1774 :                 return -1;

  00129	b8 ff ff ff ff	 mov	 eax, -1
  0012e	e9 75 01 00 00	 jmp	 $LN19@win32_xsta
$LN9@win32_xsta:

; 1775 : 
; 1776 :             /* Close the outer open file handle now that we're about to
; 1777 :                reopen it with different flags. */
; 1778 :             if (!CloseHandle(hFile))

  00133	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  0013e	85 c0		 test	 eax, eax
  00140	75 0a		 jne	 SHORT $LN8@win32_xsta

; 1779 :                 return -1;

  00142	b8 ff ff ff ff	 mov	 eax, -1
  00147	e9 5c 01 00 00	 jmp	 $LN19@win32_xsta
$LN8@win32_xsta:

; 1780 : 
; 1781 :             if (traverse) {

  0014c	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR traverse$[rsp], 0
  00154	0f 84 96 00 00
	00		 je	 $LN7@win32_xsta

; 1782 :                 /* In order to call GetFinalPathNameByHandle we need to open
; 1783 :                    the file without the reparse handling flag set. */
; 1784 :                 hFile2 = CreateFileA(
; 1785 :                            path, FILE_READ_ATTRIBUTES, FILE_SHARE_READ,
; 1786 :                            NULL, OPEN_EXISTING,
; 1787 :                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS,
; 1788 :                            NULL);

  0015a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00163	c7 44 24 28 80
	00 00 02	 mov	 DWORD PTR [rsp+40], 33554560 ; 02000080H
  0016b	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00173	45 33 c9	 xor	 r9d, r9d
  00176	41 b8 01 00 00
	00		 mov	 r8d, 1
  0017c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00181	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  0018f	48 89 44 24 60	 mov	 QWORD PTR hFile2$[rsp], rax

; 1789 :                 if (hFile2 == INVALID_HANDLE_VALUE)

  00194	48 83 7c 24 60
	ff		 cmp	 QWORD PTR hFile2$[rsp], -1
  0019a	75 0a		 jne	 SHORT $LN6@win32_xsta

; 1790 :                     return -1;

  0019c	b8 ff ff ff ff	 mov	 eax, -1
  001a1	e9 02 01 00 00	 jmp	 $LN19@win32_xsta
$LN6@win32_xsta:

; 1791 : 
; 1792 :                 if (!get_target_path(hFile2, &target_path))

  001a6	48 8d 54 24 50	 lea	 rdx, QWORD PTR target_path$[rsp]
  001ab	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hFile2$[rsp]
  001b0	e8 00 00 00 00	 call	 get_target_path
  001b5	85 c0		 test	 eax, eax
  001b7	75 0a		 jne	 SHORT $LN5@win32_xsta

; 1793 :                     return -1;

  001b9	b8 ff ff ff ff	 mov	 eax, -1
  001be	e9 e5 00 00 00	 jmp	 $LN19@win32_xsta
$LN5@win32_xsta:

; 1794 : 
; 1795 :                 code = win32_xstat_impl_w(target_path, result, FALSE);

  001c3	45 33 c0	 xor	 r8d, r8d
  001c6	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR result$[rsp]
  001ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR target_path$[rsp]
  001d3	e8 00 00 00 00	 call	 win32_xstat_impl_w
  001d8	89 44 24 4c	 mov	 DWORD PTR code$[rsp], eax

; 1796 :                 free(target_path);

  001dc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR target_path$[rsp]
  001e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1797 :                 return code;

  001e7	8b 44 24 4c	 mov	 eax, DWORD PTR code$[rsp]
  001eb	e9 b8 00 00 00	 jmp	 $LN19@win32_xsta
$LN7@win32_xsta:

; 1798 :             }
; 1799 :         } else

  001f0	eb 0b		 jmp	 SHORT $LN4@win32_xsta
$LN10@win32_xsta:

; 1800 :             CloseHandle(hFile);

  001f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN4@win32_xsta:
$LN12@win32_xsta:

; 1801 :     }
; 1802 :     attribute_data_to_stat(&info, reparse_tag, result);

  001fd	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR result$[rsp]
  00205	8b 54 24 48	 mov	 edx, DWORD PTR reparse_tag$[rsp]
  00209	48 8d 4c 24 68	 lea	 rcx, QWORD PTR info$[rsp]
  0020e	e8 00 00 00 00	 call	 attribute_data_to_stat

; 1803 : 
; 1804 :     /* Set S_IEXEC if it is an .exe, .bat, ... */
; 1805 :     dot = strrchr(path, '.');

  00213	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  00218	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr
  00226	48 89 44 24 40	 mov	 QWORD PTR dot$[rsp], rax

; 1806 :     if (dot) {

  0022b	48 83 7c 24 40
	00		 cmp	 QWORD PTR dot$[rsp], 0
  00231	74 73		 je	 SHORT $LN3@win32_xsta

; 1807 :         if (stricmp(dot, ".bat") == 0 || stricmp(dot, ".cmd") == 0 ||
; 1808 :             stricmp(dot, ".exe") == 0 || stricmp(dot, ".com") == 0)

  00233	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04NEEFLLOK@?4bat?$AA@
  0023a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dot$[rsp]
  0023f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_stricmp
  00245	85 c0		 test	 eax, eax
  00247	74 42		 je	 SHORT $LN1@win32_xsta
  00249	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04CPCBDHLK@?4cmd?$AA@
  00250	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dot$[rsp]
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_stricmp
  0025b	85 c0		 test	 eax, eax
  0025d	74 2c		 je	 SHORT $LN1@win32_xsta
  0025f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04JLMDILM@?4exe?$AA@
  00266	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dot$[rsp]
  0026b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_stricmp
  00271	85 c0		 test	 eax, eax
  00273	74 16		 je	 SHORT $LN1@win32_xsta
  00275	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04PNGHFIJN@?4com?$AA@
  0027c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dot$[rsp]
  00281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_stricmp
  00287	85 c0		 test	 eax, eax
  00289	75 1b		 jne	 SHORT $LN2@win32_xsta
$LN1@win32_xsta:

; 1809 :             result->st_mode |= 0111;

  0028b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00293	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00297	83 c8 49	 or	 eax, 73			; 00000049H
  0029a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  002a2	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN2@win32_xsta:
$LN3@win32_xsta:

; 1810 :     }
; 1811 :     return 0;

  002a6	33 c0		 xor	 eax, eax
$LN19@win32_xsta:

; 1812 : }

  002a8	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002af	c3		 ret	 0
win32_xstat_impl ENDP
_TEXT	ENDS
EXTRN	__imp_DeviceIoControl:PROC
EXTRN	__chkstk:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_get_reparse_tag DD imagerel win32_get_reparse_tag
	DD	imagerel win32_get_reparse_tag+144
	DD	imagerel $unwind$win32_get_reparse_tag
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_get_reparse_tag DD 021701H
	DD	080b0117H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_get_reparse_tag
_TEXT	SEGMENT
n_bytes_returned$ = 64
rdb$ = 72
target_buffer$ = 80
reparse_point_handle$ = 16480
reparse_tag$ = 16488
win32_get_reparse_tag PROC				; COMDAT

; 1064 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	b8 58 40 00 00	 mov	 eax, 16472		; 00004058H
  0000f	e8 00 00 00 00	 call	 __chkstk
  00014	48 2b e0	 sub	 rsp, rax

; 1065 :     char target_buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
; 1066 :     REPARSE_DATA_BUFFER *rdb = (REPARSE_DATA_BUFFER *)target_buffer;

  00017	48 8d 44 24 50	 lea	 rax, QWORD PTR target_buffer$[rsp]
  0001c	48 89 44 24 48	 mov	 QWORD PTR rdb$[rsp], rax

; 1067 :     DWORD n_bytes_returned;
; 1068 : 
; 1069 :     if (0 == DeviceIoControl(
; 1070 :         reparse_point_handle,
; 1071 :         FSCTL_GET_REPARSE_POINT,
; 1072 :         NULL, 0, /* in buffer */
; 1073 :         target_buffer, sizeof(target_buffer),
; 1074 :         &n_bytes_returned,
; 1075 :         NULL)) /* we're not using OVERLAPPED_IO */

  00021	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0002a	48 8d 44 24 40	 lea	 rax, QWORD PTR n_bytes_returned$[rsp]
  0002f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00034	c7 44 24 28 00
	40 00 00	 mov	 DWORD PTR [rsp+40], 16384 ; 00004000H
  0003c	48 8d 44 24 50	 lea	 rax, QWORD PTR target_buffer$[rsp]
  00041	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00046	45 33 c9	 xor	 r9d, r9d
  00049	45 33 c0	 xor	 r8d, r8d
  0004c	ba a8 00 09 00	 mov	 edx, 589992		; 000900a8H
  00051	48 8b 8c 24 60
	40 00 00	 mov	 rcx, QWORD PTR reparse_point_handle$[rsp]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeviceIoControl
  0005f	85 c0		 test	 eax, eax
  00061	75 04		 jne	 SHORT $LN2@win32_get_

; 1076 :         return FALSE;

  00063	33 c0		 xor	 eax, eax
  00065	eb 21		 jmp	 SHORT $LN3@win32_get_
$LN2@win32_get_:

; 1077 : 
; 1078 :     if (reparse_tag)

  00067	48 83 bc 24 68
	40 00 00 00	 cmp	 QWORD PTR reparse_tag$[rsp], 0
  00070	74 11		 je	 SHORT $LN1@win32_get_

; 1079 :         *reparse_tag = rdb->ReparseTag;

  00072	48 8b 84 24 68
	40 00 00	 mov	 rax, QWORD PTR reparse_tag$[rsp]
  0007a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rdb$[rsp]
  0007f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00081	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@win32_get_:

; 1080 : 
; 1081 :     return TRUE;

  00083	b8 01 00 00 00	 mov	 eax, 1
$LN3@win32_get_:

; 1082 : }

  00088	48 81 c4 58 40
	00 00		 add	 rsp, 16472		; 00004058H
  0008f	c3		 ret	 0
win32_get_reparse_tag ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$attribute_data_to_stat DD imagerel attribute_data_to_stat
	DD	imagerel attribute_data_to_stat+366
	DD	imagerel $unwind$attribute_data_to_stat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$attribute_data_to_stat DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT attribute_data_to_stat
_TEXT	SEGMENT
tv82 = 32
tv88 = 40
tv94 = 48
info$ = 80
reparse_tag$ = 88
result$ = 96
attribute_data_to_stat PROC				; COMDAT

; 1587 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1588 :     memset(result, 0, sizeof(*result));

  00012	41 b8 60 00 00
	00		 mov	 r8d, 96			; 00000060H
  00018	33 d2		 xor	 edx, edx
  0001a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  0001f	e8 00 00 00 00	 call	 memset

; 1589 :     result->st_mode = attributes_to_mode(info->dwFileAttributes);

  00024	48 8b 44 24 50	 mov	 rax, QWORD PTR info$[rsp]
  00029	8b 08		 mov	 ecx, DWORD PTR [rax]
  0002b	e8 00 00 00 00	 call	 attributes_to_mode
  00030	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  00035	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 1590 :     result->st_size = (((__int64)info->nFileSizeHigh)<<32) + info->nFileSizeLow;

  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR info$[rsp]
  0003e	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00041	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  0004a	8b 49 24	 mov	 ecx, DWORD PTR [rcx+36]
  0004d	48 03 c1	 add	 rax, rcx
  00050	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  00055	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1591 :     FILE_TIME_to_time_t_nsec(&info->ftCreationTime, &result->st_ctime, &result->st_ctime_nsec);

  00059	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
  0005e	48 83 c0 58	 add	 rax, 88			; 00000058H
  00062	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  00067	48 83 c1 50	 add	 rcx, 80			; 00000050H
  0006b	48 8b 54 24 50	 mov	 rdx, QWORD PTR info$[rsp]
  00070	48 83 c2 04	 add	 rdx, 4
  00074	48 89 54 24 20	 mov	 QWORD PTR tv82[rsp], rdx
  00079	4c 8b c0	 mov	 r8, rax
  0007c	48 8b d1	 mov	 rdx, rcx
  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR tv82[rsp]
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 FILE_TIME_to_time_t_nsec

; 1592 :     FILE_TIME_to_time_t_nsec(&info->ftLastWriteTime, &result->st_mtime, &result->st_mtime_nsec);

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
  00091	48 83 c0 48	 add	 rax, 72			; 00000048H
  00095	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  0009a	48 83 c1 40	 add	 rcx, 64			; 00000040H
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR info$[rsp]
  000a3	48 83 c2 14	 add	 rdx, 20
  000a7	48 89 54 24 28	 mov	 QWORD PTR tv88[rsp], rdx
  000ac	4c 8b c0	 mov	 r8, rax
  000af	48 8b d1	 mov	 rdx, rcx
  000b2	48 8b 44 24 28	 mov	 rax, QWORD PTR tv88[rsp]
  000b7	48 8b c8	 mov	 rcx, rax
  000ba	e8 00 00 00 00	 call	 FILE_TIME_to_time_t_nsec

; 1593 :     FILE_TIME_to_time_t_nsec(&info->ftLastAccessTime, &result->st_atime, &result->st_atime_nsec);

  000bf	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
  000c4	48 83 c0 38	 add	 rax, 56			; 00000038H
  000c8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  000cd	48 83 c1 30	 add	 rcx, 48			; 00000030H
  000d1	48 8b 54 24 50	 mov	 rdx, QWORD PTR info$[rsp]
  000d6	48 83 c2 0c	 add	 rdx, 12
  000da	48 89 54 24 30	 mov	 QWORD PTR tv94[rsp], rdx
  000df	4c 8b c0	 mov	 r8, rax
  000e2	48 8b d1	 mov	 rdx, rcx
  000e5	48 8b 44 24 30	 mov	 rax, QWORD PTR tv94[rsp]
  000ea	48 8b c8	 mov	 rcx, rax
  000ed	e8 00 00 00 00	 call	 FILE_TIME_to_time_t_nsec

; 1594 :     result->st_nlink = info->nNumberOfLinks;

  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
  000f7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  000fc	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  000ff	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 1595 :     result->st_ino = (((__int64)info->nFileIndexHigh)<<32) + info->nFileIndexLow;

  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR info$[rsp]
  00107	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0010a	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0010e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR info$[rsp]
  00113	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00116	48 03 c1	 add	 rax, rcx
  00119	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  0011e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1596 :     if (reparse_tag == IO_REPARSE_TAG_SYMLINK) {

  00122	81 7c 24 58 0c
	00 00 a0	 cmp	 DWORD PTR reparse_tag$[rsp], -1610612724 ; a000000cH
  0012a	75 3b		 jne	 SHORT $LN1@attribute_

; 1597 :         /* first clear the S_IFMT bits */
; 1598 :         result->st_mode ^= (result->st_mode & 0170000);

  0012c	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
  00131	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00135	25 00 f0 00 00	 and	 eax, 61440		; 0000f000H
  0013a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  0013f	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00143	33 c8		 xor	 ecx, eax
  00145	8b c1		 mov	 eax, ecx
  00147	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  0014c	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 1599 :         /* now set the bits that make this a symlink */
; 1600 :         result->st_mode |= 0120000;

  00150	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
  00155	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00159	0d 00 a0 00 00	 or	 eax, 40960		; 0000a000H
  0015e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR result$[rsp]
  00163	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN1@attribute_:

; 1601 :     }
; 1602 : 
; 1603 :     return 0;

  00167	33 c0		 xor	 eax, eax

; 1604 : }

  00169	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0016d	c3		 ret	 0
attribute_data_to_stat ENDP
_TEXT	ENDS
PUBLIC	??_C@_1MI@MODNELLC@?$AA?$CI?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAt?$AAi?$AAm?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAn?$AA?5?$AA?1?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0@ ; `string'
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$FILE_TIME_to_time_t_nsec DD imagerel FILE_TIME_to_time_t_nsec
	DD	imagerel FILE_TIME_to_time_t_nsec+190
	DD	imagerel $unwind$FILE_TIME_to_time_t_nsec
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$FILE_TIME_to_time_t_nsec DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1MI@MODNELLC@?$AA?$CI?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAt?$AAi?$AAm?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAn?$AA?5?$AA?1?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0@
CONST	SEGMENT
??_C@_1MI@MODNELLC@?$AA?$CI?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAt?$AAi?$AAm?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAn?$AA?5?$AA?1?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0@ DB '('
	DB	00H, '_', 00H, '_', 00H, 'i', 00H, 'n', 00H, 't', 00H, '6', 00H
	DB	'4', 00H, ')', 00H, '(', 00H, 't', 00H, 'i', 00H, 'm', 00H, 'e'
	DB	00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H, '(', 00H, 'i', 00H
	DB	'n', 00H, ' ', 00H, '/', 00H, ' ', 00H, '1', 00H, '0', 00H, '0'
	DB	00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, ')', 00H
	DB	' ', 00H, '-', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'c', 00H, 's'
	DB	00H, '_', 00H, 'b', 00H, 'e', 00H, 't', 00H, 'w', 00H, 'e', 00H
	DB	'e', 00H, 'n', 00H, '_', 00H, 'e', 00H, 'p', 00H, 'o', 00H, 'c'
	DB	00H, 'h', 00H, 's', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '(', 00H, '(', 00H, 'i', 00H, 'n', 00H, ' ', 00H, '/'
	DB	00H, ' ', 00H, '1', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H
	DB	'0', 00H, '0', 00H, '0', 00H, ')', 00H, ' ', 00H, '-', 00H, ' '
	DB	00H, 's', 00H, 'e', 00H, 'c', 00H, 's', 00H, '_', 00H, 'b', 00H
	DB	'e', 00H, 't', 00H, 'w', 00H, 'e', 00H, 'e', 00H, 'n', 00H, '_'
	DB	00H, 'e', 00H, 'p', 00H, 'o', 00H, 'c', 00H, 'h', 00H, 's', 00H
	DB	')', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT FILE_TIME_to_time_t_nsec
_TEXT	SEGMENT
in$ = 32
tv71 = 40
in_ptr$ = 64
time_out$ = 72
nsec_out$ = 80
FILE_TIME_to_time_t_nsec PROC				; COMDAT

; 1546 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1547 :     /* XXX endianness. Shouldn't matter, as all Windows implementations are little-endian */
; 1548 :     /* Cannot simply cast and dereference in_ptr,
; 1549 :        since it might not be aligned properly */
; 1550 :     __int64 in;
; 1551 :     memcpy(&in, in_ptr, sizeof(in));

  00013	41 b8 08 00 00
	00		 mov	 r8d, 8
  00019	48 8b 54 24 40	 mov	 rdx, QWORD PTR in_ptr$[rsp]
  0001e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR in$[rsp]
  00023	e8 00 00 00 00	 call	 memcpy

; 1552 :     *nsec_out = (int)(in % 10000000) * 100; /* FILETIME is in units of 100 nsec. */

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR in$[rsp]
  0002d	48 99		 cdq
  0002f	b9 80 96 98 00	 mov	 ecx, 10000000		; 00989680H
  00034	48 f7 f9	 idiv	 rcx
  00037	48 8b c2	 mov	 rax, rdx
  0003a	6b c0 64	 imul	 eax, 100		; 00000064H
  0003d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR nsec_out$[rsp]
  00042	89 01		 mov	 DWORD PTR [rcx], eax

; 1553 :     *time_out = Py_SAFE_DOWNCAST((in / 10000000) - secs_between_epochs, __int64, time_t);

  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR in$[rsp]
  00049	48 99		 cdq
  0004b	b9 80 96 98 00	 mov	 ecx, 10000000		; 00989680H
  00050	48 f7 f9	 idiv	 rcx
  00053	48 2b 05 00 00
	00 00		 sub	 rax, QWORD PTR secs_between_epochs
  0005a	48 89 44 24 28	 mov	 QWORD PTR tv71[rsp], rax
  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR in$[rsp]
  00064	48 99		 cdq
  00066	b9 80 96 98 00	 mov	 ecx, 10000000		; 00989680H
  0006b	48 f7 f9	 idiv	 rcx
  0006e	48 2b 05 00 00
	00 00		 sub	 rax, QWORD PTR secs_between_epochs
  00075	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv71[rsp]
  0007a	48 3b c8	 cmp	 rcx, rax
  0007d	74 1c		 je	 SHORT $LN3@FILE_TIME_
  0007f	41 b8 11 06 00
	00		 mov	 r8d, 1553		; 00000611H
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1MI@MODNELLC@?$AA?$CI?$AA_?$AA_?$AAi?$AAn?$AAt?$AA6?$AA4?$AA?$CJ?$AA?$CI?$AAt?$AAi?$AAm?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?$CI?$AAi?$AAn?$AA?5?$AA?1?$AA?5?$AA1?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0?$AA0@
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00099	33 c0		 xor	 eax, eax
$LN3@FILE_TIME_:
  0009b	48 8b 44 24 20	 mov	 rax, QWORD PTR in$[rsp]
  000a0	48 99		 cdq
  000a2	b9 80 96 98 00	 mov	 ecx, 10000000		; 00989680H
  000a7	48 f7 f9	 idiv	 rcx
  000aa	48 2b 05 00 00
	00 00		 sub	 rax, QWORD PTR secs_between_epochs
  000b1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR time_out$[rsp]
  000b6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1554 : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
FILE_TIME_to_time_t_nsec ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$attributes_to_mode DD imagerel attributes_to_mode
	DD	imagerel attributes_to_mode+92
	DD	imagerel $unwind$attributes_to_mode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$attributes_to_mode DD 010801H
	DD	02208H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT attributes_to_mode
_TEXT	SEGMENT
m$ = 0
attr$ = 32
attributes_to_mode PROC					; COMDAT

; 1572 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 1573 :     int m = 0;

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR m$[rsp], 0

; 1574 :     if (attr & FILE_ATTRIBUTE_DIRECTORY)

  0000f	8b 44 24 20	 mov	 eax, DWORD PTR attr$[rsp]
  00013	83 e0 10	 and	 eax, 16
  00016	85 c0		 test	 eax, eax
  00018	74 0d		 je	 SHORT $LN4@attributes

; 1575 :         m |= _S_IFDIR | 0111; /* IFEXEC for user,group,other */

  0001a	8b 04 24	 mov	 eax, DWORD PTR m$[rsp]
  0001d	0d 49 40 00 00	 or	 eax, 16457		; 00004049H
  00022	89 04 24	 mov	 DWORD PTR m$[rsp], eax

; 1576 :     else

  00025	eb 0a		 jmp	 SHORT $LN3@attributes
$LN4@attributes:

; 1577 :         m |= _S_IFREG;

  00027	8b 04 24	 mov	 eax, DWORD PTR m$[rsp]
  0002a	0f ba e8 0f	 bts	 eax, 15
  0002e	89 04 24	 mov	 DWORD PTR m$[rsp], eax
$LN3@attributes:

; 1578 :     if (attr & FILE_ATTRIBUTE_READONLY)

  00031	8b 44 24 20	 mov	 eax, DWORD PTR attr$[rsp]
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 0d		 je	 SHORT $LN2@attributes

; 1579 :         m |= 0444;

  0003c	8b 04 24	 mov	 eax, DWORD PTR m$[rsp]
  0003f	0d 24 01 00 00	 or	 eax, 292		; 00000124H
  00044	89 04 24	 mov	 DWORD PTR m$[rsp], eax

; 1580 :     else

  00047	eb 0b		 jmp	 SHORT $LN1@attributes
$LN2@attributes:

; 1581 :         m |= 0666;

  00049	8b 04 24	 mov	 eax, DWORD PTR m$[rsp]
  0004c	0d b6 01 00 00	 or	 eax, 438		; 000001b6H
  00051	89 04 24	 mov	 DWORD PTR m$[rsp], eax
$LN1@attributes:

; 1582 :     return m;

  00054	8b 04 24	 mov	 eax, DWORD PTR m$[rsp]

; 1583 : }

  00057	48 83 c4 18	 add	 rsp, 24
  0005b	c3		 ret	 0
attributes_to_mode ENDP
_TEXT	ENDS
EXTRN	__imp_FindClose:PROC
EXTRN	__imp_FindFirstFileA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$attributes_from_dir DD imagerel attributes_from_dir
	DD	imagerel attributes_from_dir+242
	DD	imagerel $unwind$attributes_from_dir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$attributes_from_dir DD 021601H
	DD	02f0116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT attributes_from_dir
_TEXT	SEGMENT
hFindFile$ = 32
FileData$ = 48
pszFile$ = 384
info$ = 392
reparse_tag$ = 400
attributes_from_dir PROC				; COMDAT

; 1608 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H

; 1609 :     HANDLE hFindFile;
; 1610 :     WIN32_FIND_DATAA FileData;
; 1611 :     hFindFile = FindFirstFileA(pszFile, &FileData);

  00016	48 8d 54 24 30	 lea	 rdx, QWORD PTR FileData$[rsp]
  0001b	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR pszFile$[rsp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileA
  00029	48 89 44 24 20	 mov	 QWORD PTR hFindFile$[rsp], rax

; 1612 :     if (hFindFile == INVALID_HANDLE_VALUE)

  0002e	48 83 7c 24 20
	ff		 cmp	 QWORD PTR hFindFile$[rsp], -1
  00034	75 07		 jne	 SHORT $LN2@attributes@2

; 1613 :         return FALSE;

  00036	33 c0		 xor	 eax, eax
  00038	e9 ad 00 00 00	 jmp	 $LN3@attributes@2
$LN2@attributes@2:

; 1614 :     FindClose(hFindFile);

  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hFindFile$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindClose

; 1615 :     memset(info, 0, sizeof(*info));

  00048	41 b8 34 00 00
	00		 mov	 r8d, 52			; 00000034H
  0004e	33 d2		 xor	 edx, edx
  00050	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00058	e8 00 00 00 00	 call	 memset

; 1616 :     *reparse_tag = 0;

  0005d	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR reparse_tag$[rsp]
  00065	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1617 :     info->dwFileAttributes = FileData.dwFileAttributes;

  0006b	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00073	8b 4c 24 30	 mov	 ecx, DWORD PTR FileData$[rsp]
  00077	89 08		 mov	 DWORD PTR [rax], ecx

; 1618 :     info->ftCreationTime   = FileData.ftCreationTime;

  00079	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00081	48 8b 4c 24 34	 mov	 rcx, QWORD PTR FileData$[rsp+4]
  00086	48 89 48 04	 mov	 QWORD PTR [rax+4], rcx

; 1619 :     info->ftLastAccessTime = FileData.ftLastAccessTime;

  0008a	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00092	48 8b 4c 24 3c	 mov	 rcx, QWORD PTR FileData$[rsp+12]
  00097	48 89 48 0c	 mov	 QWORD PTR [rax+12], rcx

; 1620 :     info->ftLastWriteTime  = FileData.ftLastWriteTime;

  0009b	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  000a3	48 8b 4c 24 44	 mov	 rcx, QWORD PTR FileData$[rsp+20]
  000a8	48 89 48 14	 mov	 QWORD PTR [rax+20], rcx

; 1621 :     info->nFileSizeHigh    = FileData.nFileSizeHigh;

  000ac	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  000b4	8b 4c 24 4c	 mov	 ecx, DWORD PTR FileData$[rsp+28]
  000b8	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 1622 :     info->nFileSizeLow     = FileData.nFileSizeLow;

  000bb	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  000c3	8b 4c 24 50	 mov	 ecx, DWORD PTR FileData$[rsp+32]
  000c7	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 1623 : /*  info->nNumberOfLinks   = 1; */
; 1624 :     if (FileData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)

  000ca	8b 44 24 30	 mov	 eax, DWORD PTR FileData$[rsp]
  000ce	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  000d3	85 c0		 test	 eax, eax
  000d5	74 0e		 je	 SHORT $LN1@attributes@2

; 1625 :         *reparse_tag = FileData.dwReserved0;

  000d7	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR reparse_tag$[rsp]
  000df	8b 4c 24 54	 mov	 ecx, DWORD PTR FileData$[rsp+36]
  000e3	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@attributes@2:

; 1626 :     return TRUE;

  000e5	b8 01 00 00 00	 mov	 eax, 1
$LN3@attributes@2:

; 1627 : }

  000ea	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  000f1	c3		 ret	 0
attributes_from_dir ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@PDKDDAF@GetFinalPathNameByHandleW?$AA@ ; `string'
PUBLIC	??_C@_0BK@BDKCIGNC@GetFinalPathNameByHandleA?$AA@ ; `string'
PUBLIC	??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@ ; `string'
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_GetModuleHandleW:PROC
_BSS	SEGMENT
Py_GetFinalPathNameByHandleW DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_GetFinalPathNameByHandle DD imagerel check_GetFinalPathNameByHandle
	DD	imagerel check_GetFinalPathNameByHandle+136
	DD	imagerel $unwind$check_GetFinalPathNameByHandle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_GetFinalPathNameByHandle DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT ??_C@_0BK@PDKDDAF@GetFinalPathNameByHandleW?$AA@
CONST	SEGMENT
??_C@_0BK@PDKDDAF@GetFinalPathNameByHandleW?$AA@ DB 'GetFinalPathNameByHa'
	DB	'ndleW', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BDKCIGNC@GetFinalPathNameByHandleA?$AA@
CONST	SEGMENT
??_C@_0BK@BDKCIGNC@GetFinalPathNameByHandleA?$AA@ DB 'GetFinalPathNameByH'
	DB	'andleA', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@ DB 'K'
	DB	00H, 'E', 00H, 'R', 00H, 'N', 00H, 'E', 00H, 'L', 00H, '3', 00H
	DB	'2', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT check_GetFinalPathNameByHandle
_TEXT	SEGMENT
hKernel32$ = 32
Py_GetFinalPathNameByHandleA$ = 40
tv75 = 48
check_GetFinalPathNameByHandle PROC			; COMDAT

; 1658 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1659 :     HINSTANCE hKernel32;
; 1660 :     DWORD (CALLBACK *Py_GetFinalPathNameByHandleA)(HANDLE, LPSTR, DWORD,
; 1661 :                                                    DWORD);
; 1662 : 
; 1663 :     /* only recheck */
; 1664 :     if (!has_GetFinalPathNameByHandle)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR has_GetFinalPathNameByHandle, 0
  0000b	75 70		 jne	 SHORT $LN1@check_GetF

; 1665 :     {
; 1666 :         hKernel32 = GetModuleHandleW(L"KERNEL32");

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleW
  0001a	48 89 44 24 20	 mov	 QWORD PTR hKernel32$[rsp], rax

; 1667 :         *(FARPROC*)&Py_GetFinalPathNameByHandleA = GetProcAddress(hKernel32,
; 1668 :                                                 "GetFinalPathNameByHandleA");

  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@BDKCIGNC@GetFinalPathNameByHandleA?$AA@
  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hKernel32$[rsp]
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00031	48 89 44 24 28	 mov	 QWORD PTR Py_GetFinalPathNameByHandleA$[rsp], rax

; 1669 :         *(FARPROC*)&Py_GetFinalPathNameByHandleW = GetProcAddress(hKernel32,
; 1670 :                                                 "GetFinalPathNameByHandleW");

  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PDKDDAF@GetFinalPathNameByHandleW?$AA@
  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hKernel32$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00048	48 89 05 00 00
	00 00		 mov	 QWORD PTR Py_GetFinalPathNameByHandleW, rax

; 1671 :         has_GetFinalPathNameByHandle = Py_GetFinalPathNameByHandleA &&
; 1672 :                                        Py_GetFinalPathNameByHandleW;

  0004f	48 83 7c 24 28
	00		 cmp	 QWORD PTR Py_GetFinalPathNameByHandleA$[rsp], 0
  00055	74 14		 je	 SHORT $LN4@check_GetF
  00057	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR Py_GetFinalPathNameByHandleW, 0
  0005f	74 0a		 je	 SHORT $LN4@check_GetF
  00061	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00069	eb 08		 jmp	 SHORT $LN5@check_GetF
$LN4@check_GetF:
  0006b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN5@check_GetF:
  00073	8b 44 24 30	 mov	 eax, DWORD PTR tv75[rsp]
  00077	89 05 00 00 00
	00		 mov	 DWORD PTR has_GetFinalPathNameByHandle, eax
$LN1@check_GetF:

; 1673 :     }
; 1674 :     return has_GetFinalPathNameByHandle;

  0007d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR has_GetFinalPathNameByHandle

; 1675 : }

  00083	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00087	c3		 ret	 0
check_GetFinalPathNameByHandle ENDP
_TEXT	ENDS
EXTRN	__imp_malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_target_path DD imagerel get_target_path
	DD	imagerel get_target_path+218
	DD	imagerel $unwind$get_target_path
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_target_path DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_target_path
_TEXT	SEGMENT
buf_size$ = 32
buf$ = 40
result_length$ = 48
hdl$ = 80
target_path$ = 88
get_target_path PROC					; COMDAT

; 1679 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1680 :     int buf_size, result_length;
; 1681 :     wchar_t *buf;
; 1682 : 
; 1683 :     /* We have a good handle to the target, use it to determine
; 1684 :        the target path name (then we'll call lstat on it). */
; 1685 :     buf_size = Py_GetFinalPathNameByHandleW(hdl, 0, 0,
; 1686 :                                             VOLUME_NAME_DOS);

  0000e	45 33 c9	 xor	 r9d, r9d
  00011	45 33 c0	 xor	 r8d, r8d
  00014	33 d2		 xor	 edx, edx
  00016	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hdl$[rsp]
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR Py_GetFinalPathNameByHandleW
  00021	89 44 24 20	 mov	 DWORD PTR buf_size$[rsp], eax

; 1687 :     if(!buf_size)

  00025	83 7c 24 20 00	 cmp	 DWORD PTR buf_size$[rsp], 0
  0002a	75 07		 jne	 SHORT $LN4@get_target

; 1688 :         return FALSE;

  0002c	33 c0		 xor	 eax, eax
  0002e	e9 a2 00 00 00	 jmp	 $LN5@get_target
$LN4@get_target:

; 1689 : 
; 1690 :     buf = (wchar_t *)malloc((buf_size+1)*sizeof(wchar_t));

  00033	8b 44 24 20	 mov	 eax, DWORD PTR buf_size$[rsp]
  00037	ff c0		 inc	 eax
  00039	48 98		 cdqe
  0003b	48 d1 e0	 shl	 rax, 1
  0003e	48 8b c8	 mov	 rcx, rax
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00047	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 1691 :     if (!buf) {

  0004c	48 83 7c 24 28
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00052	75 0f		 jne	 SHORT $LN3@get_target

; 1692 :         SetLastError(ERROR_OUTOFMEMORY);

  00054	b9 0e 00 00 00	 mov	 ecx, 14
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError

; 1693 :         return FALSE;

  0005f	33 c0		 xor	 eax, eax
  00061	eb 72		 jmp	 SHORT $LN5@get_target
$LN3@get_target:

; 1694 :     }
; 1695 : 
; 1696 :     result_length = Py_GetFinalPathNameByHandleW(hdl,
; 1697 :                        buf, buf_size, VOLUME_NAME_DOS);

  00063	45 33 c9	 xor	 r9d, r9d
  00066	44 8b 44 24 20	 mov	 r8d, DWORD PTR buf_size$[rsp]
  0006b	48 8b 54 24 28	 mov	 rdx, QWORD PTR buf$[rsp]
  00070	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hdl$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR Py_GetFinalPathNameByHandleW
  0007b	89 44 24 30	 mov	 DWORD PTR result_length$[rsp], eax

; 1698 : 
; 1699 :     if(!result_length) {

  0007f	83 7c 24 30 00	 cmp	 DWORD PTR result_length$[rsp], 0
  00084	75 0f		 jne	 SHORT $LN2@get_target

; 1700 :         free(buf);

  00086	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buf$[rsp]
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1701 :         return FALSE;

  00091	33 c0		 xor	 eax, eax
  00093	eb 40		 jmp	 SHORT $LN5@get_target
$LN2@get_target:

; 1702 :     }
; 1703 : 
; 1704 :     if(!CloseHandle(hdl)) {

  00095	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hdl$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  000a0	85 c0		 test	 eax, eax
  000a2	75 0f		 jne	 SHORT $LN1@get_target

; 1705 :         free(buf);

  000a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buf$[rsp]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1706 :         return FALSE;

  000af	33 c0		 xor	 eax, eax
  000b1	eb 22		 jmp	 SHORT $LN5@get_target
$LN1@get_target:

; 1707 :     }
; 1708 : 
; 1709 :     buf[result_length] = 0;

  000b3	48 63 44 24 30	 movsxd	 rax, DWORD PTR result_length$[rsp]
  000b8	33 c9		 xor	 ecx, ecx
  000ba	48 8b 54 24 28	 mov	 rdx, QWORD PTR buf$[rsp]
  000bf	66 89 0c 42	 mov	 WORD PTR [rdx+rax*2], cx

; 1710 : 
; 1711 :     *target_path = buf;

  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR target_path$[rsp]
  000c8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buf$[rsp]
  000cd	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1712 :     return TRUE;

  000d0	b8 01 00 00 00	 mov	 eax, 1
$LN5@get_target:

; 1713 : }

  000d5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d9	c3		 ret	 0
get_target_path ENDP
_TEXT	ENDS
PUBLIC	??_C@_19CDGLJBOD@?$AA?4?$AAc?$AAo?$AAm?$AA?$AA@	; `string'
PUBLIC	??_C@_19DOGDICKI@?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@	; `string'
PUBLIC	??_C@_19BDKLHPGC@?$AA?4?$AAc?$AAm?$AAd?$AA?$AA@	; `string'
PUBLIC	??_C@_19PINKOIBI@?$AA?4?$AAb?$AAa?$AAt?$AA?$AA@	; `string'
EXTRN	__imp__wcsicmp:PROC
EXTRN	__imp_wcsrchr:PROC
EXTRN	__imp_CreateFileW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_xstat_impl_w DD imagerel win32_xstat_impl_w
	DD	imagerel win32_xstat_impl_w+687
	DD	imagerel $unwind$win32_xstat_impl_w
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_xstat_impl_w DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT ??_C@_19CDGLJBOD@?$AA?4?$AAc?$AAo?$AAm?$AA?$AA@
CONST	SEGMENT
??_C@_19CDGLJBOD@?$AA?4?$AAc?$AAo?$AAm?$AA?$AA@ DB '.', 00H, 'c', 00H, 'o'
	DB	00H, 'm', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19DOGDICKI@?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_19DOGDICKI@?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@ DB '.', 00H, 'e', 00H, 'x'
	DB	00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19BDKLHPGC@?$AA?4?$AAc?$AAm?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_19BDKLHPGC@?$AA?4?$AAc?$AAm?$AAd?$AA?$AA@ DB '.', 00H, 'c', 00H, 'm'
	DB	00H, 'd', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_19PINKOIBI@?$AA?4?$AAb?$AAa?$AAt?$AA?$AA@
CONST	SEGMENT
??_C@_19PINKOIBI@?$AA?4?$AAb?$AAa?$AAt?$AA?$AA@ DB '.', 00H, 'b', 00H, 'a'
	DB	00H, 't', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT win32_xstat_impl_w
_TEXT	SEGMENT
dot$ = 64
reparse_tag$ = 72
code$ = 76
target_path$ = 80
hFile$ = 88
hFile2$ = 96
info$ = 104
path$ = 176
result$ = 184
traverse$ = 192
win32_xstat_impl_w PROC					; COMDAT

; 1817 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1818 :     int code;
; 1819 :     HANDLE hFile, hFile2;
; 1820 :     BY_HANDLE_FILE_INFORMATION info;
; 1821 :     ULONG reparse_tag = 0;

  00016	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR reparse_tag$[rsp], 0

; 1822 :     wchar_t *target_path;
; 1823 :     const wchar_t *dot;
; 1824 : 
; 1825 :     if(!check_GetFinalPathNameByHandle()) {

  0001e	e8 00 00 00 00	 call	 check_GetFinalPathNameByHandle
  00023	85 c0		 test	 eax, eax
  00025	75 0b		 jne	 SHORT $LN18@win32_xsta@2

; 1826 :         /* If the OS doesn't have GetFinalPathNameByHandle, don't
; 1827 :            traverse reparse point. */
; 1828 :         traverse = FALSE;

  00027	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR traverse$[rsp], 0
$LN18@win32_xsta@2:

; 1829 :     }
; 1830 : 
; 1831 :     hFile = CreateFileW(
; 1832 :         path,
; 1833 :         FILE_READ_ATTRIBUTES, /* desired access */
; 1834 :         0, /* share mode */
; 1835 :         NULL, /* security attributes */
; 1836 :         OPEN_EXISTING,
; 1837 :         /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */
; 1838 :         /* FILE_FLAG_OPEN_REPARSE_POINT does not follow the symlink.
; 1839 :            Because of this, calls like GetFinalPathNameByHandle will return
; 1840 :            the symlink path again and not the actual final path. */
; 1841 :         FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS|
; 1842 :             FILE_FLAG_OPEN_REPARSE_POINT,
; 1843 :         NULL);

  00032	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0003b	c7 44 24 28 80
	00 20 02	 mov	 DWORD PTR [rsp+40], 35651712 ; 02200080H
  00043	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  0004b	45 33 c9	 xor	 r9d, r9d
  0004e	45 33 c0	 xor	 r8d, r8d
  00051	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00056	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW
  00064	48 89 44 24 58	 mov	 QWORD PTR hFile$[rsp], rax

; 1844 : 
; 1845 :     if (hFile == INVALID_HANDLE_VALUE) {

  00069	48 83 7c 24 58
	ff		 cmp	 QWORD PTR hFile$[rsp], -1
  0006f	75 6b		 jne	 SHORT $LN17@win32_xsta@2

; 1846 :         /* Either the target doesn't exist, or we don't have access to
; 1847 :            get a handle to it. If the former, we need to return an error.
; 1848 :            If the latter, we can use attributes_from_dir. */
; 1849 :         if (GetLastError() != ERROR_SHARING_VIOLATION)

  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00077	83 f8 20	 cmp	 eax, 32			; 00000020H
  0007a	74 0a		 je	 SHORT $LN16@win32_xsta@2

; 1850 :             return -1;

  0007c	b8 ff ff ff ff	 mov	 eax, -1
  00081	e9 21 02 00 00	 jmp	 $LN19@win32_xsta@2
$LN16@win32_xsta@2:

; 1851 :         /* Could not get attributes on open file. Fall back to
; 1852 :            reading the directory. */
; 1853 :         if (!attributes_from_dir_w(path, &info, &reparse_tag))

  00086	4c 8d 44 24 48	 lea	 r8, QWORD PTR reparse_tag$[rsp]
  0008b	48 8d 54 24 68	 lea	 rdx, QWORD PTR info$[rsp]
  00090	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00098	e8 00 00 00 00	 call	 attributes_from_dir_w
  0009d	85 c0		 test	 eax, eax
  0009f	75 0a		 jne	 SHORT $LN15@win32_xsta@2

; 1854 :             /* Very strange. This should not fail now */
; 1855 :             return -1;

  000a1	b8 ff ff ff ff	 mov	 eax, -1
  000a6	e9 fc 01 00 00	 jmp	 $LN19@win32_xsta@2
$LN15@win32_xsta@2:

; 1856 :         if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

  000ab	8b 44 24 68	 mov	 eax, DWORD PTR info$[rsp]
  000af	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  000b4	85 c0		 test	 eax, eax
  000b6	74 1f		 je	 SHORT $LN14@win32_xsta@2

; 1857 :             if (traverse) {

  000b8	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR traverse$[rsp], 0
  000c0	74 15		 je	 SHORT $LN13@win32_xsta@2

; 1858 :                 /* Should traverse, but could not open reparse point handle */
; 1859 :                 SetLastError(ERROR_SHARING_VIOLATION);

  000c2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError

; 1860 :                 return -1;

  000cd	b8 ff ff ff ff	 mov	 eax, -1
  000d2	e9 d0 01 00 00	 jmp	 $LN19@win32_xsta@2
$LN13@win32_xsta@2:
$LN14@win32_xsta@2:

; 1861 :             }
; 1862 :         }
; 1863 :     } else {

  000d7	e9 21 01 00 00	 jmp	 $LN12@win32_xsta@2
$LN17@win32_xsta@2:

; 1864 :         if (!GetFileInformationByHandle(hFile, &info)) {

  000dc	48 8d 54 24 68	 lea	 rdx, QWORD PTR info$[rsp]
  000e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileInformationByHandle
  000ec	85 c0		 test	 eax, eax
  000ee	75 15		 jne	 SHORT $LN11@win32_xsta@2

; 1865 :             CloseHandle(hFile);

  000f0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 1866 :             return -1;

  000fb	b8 ff ff ff ff	 mov	 eax, -1
  00100	e9 a2 01 00 00	 jmp	 $LN19@win32_xsta@2
$LN11@win32_xsta@2:

; 1867 :         }
; 1868 :         if (info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

  00105	8b 44 24 68	 mov	 eax, DWORD PTR info$[rsp]
  00109	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0010e	85 c0		 test	 eax, eax
  00110	0f 84 dc 00 00
	00		 je	 $LN10@win32_xsta@2

; 1869 :             if (!win32_get_reparse_tag(hFile, &reparse_tag))

  00116	48 8d 54 24 48	 lea	 rdx, QWORD PTR reparse_tag$[rsp]
  0011b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  00120	e8 00 00 00 00	 call	 win32_get_reparse_tag
  00125	85 c0		 test	 eax, eax
  00127	75 0a		 jne	 SHORT $LN9@win32_xsta@2

; 1870 :                 return -1;

  00129	b8 ff ff ff ff	 mov	 eax, -1
  0012e	e9 74 01 00 00	 jmp	 $LN19@win32_xsta@2
$LN9@win32_xsta@2:

; 1871 : 
; 1872 :             /* Close the outer open file handle now that we're about to
; 1873 :                reopen it with different flags. */
; 1874 :             if (!CloseHandle(hFile))

  00133	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  0013e	85 c0		 test	 eax, eax
  00140	75 0a		 jne	 SHORT $LN8@win32_xsta@2

; 1875 :                 return -1;

  00142	b8 ff ff ff ff	 mov	 eax, -1
  00147	e9 5b 01 00 00	 jmp	 $LN19@win32_xsta@2
$LN8@win32_xsta@2:

; 1876 : 
; 1877 :             if (traverse) {

  0014c	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR traverse$[rsp], 0
  00154	0f 84 96 00 00
	00		 je	 $LN7@win32_xsta@2

; 1878 :                 /* In order to call GetFinalPathNameByHandle we need to open
; 1879 :                    the file without the reparse handling flag set. */
; 1880 :                 hFile2 = CreateFileW(
; 1881 :                            path, FILE_READ_ATTRIBUTES, FILE_SHARE_READ,
; 1882 :                            NULL, OPEN_EXISTING,
; 1883 :                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS,
; 1884 :                            NULL);

  0015a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00163	c7 44 24 28 80
	00 00 02	 mov	 DWORD PTR [rsp+40], 33554560 ; 02000080H
  0016b	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00173	45 33 c9	 xor	 r9d, r9d
  00176	41 b8 01 00 00
	00		 mov	 r8d, 1
  0017c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00181	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW
  0018f	48 89 44 24 60	 mov	 QWORD PTR hFile2$[rsp], rax

; 1885 :                 if (hFile2 == INVALID_HANDLE_VALUE)

  00194	48 83 7c 24 60
	ff		 cmp	 QWORD PTR hFile2$[rsp], -1
  0019a	75 0a		 jne	 SHORT $LN6@win32_xsta@2

; 1886 :                     return -1;

  0019c	b8 ff ff ff ff	 mov	 eax, -1
  001a1	e9 01 01 00 00	 jmp	 $LN19@win32_xsta@2
$LN6@win32_xsta@2:

; 1887 : 
; 1888 :                 if (!get_target_path(hFile2, &target_path))

  001a6	48 8d 54 24 50	 lea	 rdx, QWORD PTR target_path$[rsp]
  001ab	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hFile2$[rsp]
  001b0	e8 00 00 00 00	 call	 get_target_path
  001b5	85 c0		 test	 eax, eax
  001b7	75 0a		 jne	 SHORT $LN5@win32_xsta@2

; 1889 :                     return -1;

  001b9	b8 ff ff ff ff	 mov	 eax, -1
  001be	e9 e4 00 00 00	 jmp	 $LN19@win32_xsta@2
$LN5@win32_xsta@2:

; 1890 : 
; 1891 :                 code = win32_xstat_impl_w(target_path, result, FALSE);

  001c3	45 33 c0	 xor	 r8d, r8d
  001c6	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR result$[rsp]
  001ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR target_path$[rsp]
  001d3	e8 00 00 00 00	 call	 win32_xstat_impl_w
  001d8	89 44 24 4c	 mov	 DWORD PTR code$[rsp], eax

; 1892 :                 free(target_path);

  001dc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR target_path$[rsp]
  001e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1893 :                 return code;

  001e7	8b 44 24 4c	 mov	 eax, DWORD PTR code$[rsp]
  001eb	e9 b7 00 00 00	 jmp	 $LN19@win32_xsta@2
$LN7@win32_xsta@2:

; 1894 :             }
; 1895 :         } else

  001f0	eb 0b		 jmp	 SHORT $LN4@win32_xsta@2
$LN10@win32_xsta@2:

; 1896 :             CloseHandle(hFile);

  001f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hFile$[rsp]
  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN4@win32_xsta@2:
$LN12@win32_xsta@2:

; 1897 :     }
; 1898 :     attribute_data_to_stat(&info, reparse_tag, result);

  001fd	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR result$[rsp]
  00205	8b 54 24 48	 mov	 edx, DWORD PTR reparse_tag$[rsp]
  00209	48 8d 4c 24 68	 lea	 rcx, QWORD PTR info$[rsp]
  0020e	e8 00 00 00 00	 call	 attribute_data_to_stat

; 1899 : 
; 1900 :     /* Set S_IEXEC if it is an .exe, .bat, ... */
; 1901 :     dot = wcsrchr(path, '.');

  00213	66 ba 2e 00	 mov	 dx, 46			; 0000002eH
  00217	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  0021f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsrchr
  00225	48 89 44 24 40	 mov	 QWORD PTR dot$[rsp], rax

; 1902 :     if (dot) {

  0022a	48 83 7c 24 40
	00		 cmp	 QWORD PTR dot$[rsp], 0
  00230	74 73		 je	 SHORT $LN3@win32_xsta@2

; 1903 :         if (_wcsicmp(dot, L".bat") == 0 || _wcsicmp(dot, L".cmd") == 0 ||
; 1904 :             _wcsicmp(dot, L".exe") == 0 || _wcsicmp(dot, L".com") == 0)

  00232	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19PINKOIBI@?$AA?4?$AAb?$AAa?$AAt?$AA?$AA@
  00239	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dot$[rsp]
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wcsicmp
  00244	85 c0		 test	 eax, eax
  00246	74 42		 je	 SHORT $LN1@win32_xsta@2
  00248	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19BDKLHPGC@?$AA?4?$AAc?$AAm?$AAd?$AA?$AA@
  0024f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dot$[rsp]
  00254	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wcsicmp
  0025a	85 c0		 test	 eax, eax
  0025c	74 2c		 je	 SHORT $LN1@win32_xsta@2
  0025e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19DOGDICKI@?$AA?4?$AAe?$AAx?$AAe?$AA?$AA@
  00265	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dot$[rsp]
  0026a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wcsicmp
  00270	85 c0		 test	 eax, eax
  00272	74 16		 je	 SHORT $LN1@win32_xsta@2
  00274	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_19CDGLJBOD@?$AA?4?$AAc?$AAo?$AAm?$AA?$AA@
  0027b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dot$[rsp]
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wcsicmp
  00286	85 c0		 test	 eax, eax
  00288	75 1b		 jne	 SHORT $LN2@win32_xsta@2
$LN1@win32_xsta@2:

; 1905 :             result->st_mode |= 0111;

  0028a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR result$[rsp]
  00292	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00296	83 c8 49	 or	 eax, 73			; 00000049H
  00299	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  002a1	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN2@win32_xsta@2:
$LN3@win32_xsta@2:

; 1906 :     }
; 1907 :     return 0;

  002a5	33 c0		 xor	 eax, eax
$LN19@win32_xsta@2:

; 1908 : }

  002a7	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002ae	c3		 ret	 0
win32_xstat_impl_w ENDP
_TEXT	ENDS
EXTRN	__imp_FindFirstFileW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$attributes_from_dir_w DD imagerel attributes_from_dir_w
	DD	imagerel attributes_from_dir_w+242
	DD	imagerel $unwind$attributes_from_dir_w
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$attributes_from_dir_w DD 021601H
	DD	0510116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT attributes_from_dir_w
_TEXT	SEGMENT
hFindFile$ = 32
FileData$ = 48
pszFile$ = 656
info$ = 664
reparse_tag$ = 672
attributes_from_dir_w PROC				; COMDAT

; 1631 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 02
	00 00		 sub	 rsp, 648		; 00000288H

; 1632 :     HANDLE hFindFile;
; 1633 :     WIN32_FIND_DATAW FileData;
; 1634 :     hFindFile = FindFirstFileW(pszFile, &FileData);

  00016	48 8d 54 24 30	 lea	 rdx, QWORD PTR FileData$[rsp]
  0001b	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pszFile$[rsp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileW
  00029	48 89 44 24 20	 mov	 QWORD PTR hFindFile$[rsp], rax

; 1635 :     if (hFindFile == INVALID_HANDLE_VALUE)

  0002e	48 83 7c 24 20
	ff		 cmp	 QWORD PTR hFindFile$[rsp], -1
  00034	75 07		 jne	 SHORT $LN2@attributes@3

; 1636 :         return FALSE;

  00036	33 c0		 xor	 eax, eax
  00038	e9 ad 00 00 00	 jmp	 $LN3@attributes@3
$LN2@attributes@3:

; 1637 :     FindClose(hFindFile);

  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hFindFile$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindClose

; 1638 :     memset(info, 0, sizeof(*info));

  00048	41 b8 34 00 00
	00		 mov	 r8d, 52			; 00000034H
  0004e	33 d2		 xor	 edx, edx
  00050	48 8b 8c 24 98
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00058	e8 00 00 00 00	 call	 memset

; 1639 :     *reparse_tag = 0;

  0005d	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR reparse_tag$[rsp]
  00065	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1640 :     info->dwFileAttributes = FileData.dwFileAttributes;

  0006b	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00073	8b 4c 24 30	 mov	 ecx, DWORD PTR FileData$[rsp]
  00077	89 08		 mov	 DWORD PTR [rax], ecx

; 1641 :     info->ftCreationTime   = FileData.ftCreationTime;

  00079	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00081	48 8b 4c 24 34	 mov	 rcx, QWORD PTR FileData$[rsp+4]
  00086	48 89 48 04	 mov	 QWORD PTR [rax+4], rcx

; 1642 :     info->ftLastAccessTime = FileData.ftLastAccessTime;

  0008a	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00092	48 8b 4c 24 3c	 mov	 rcx, QWORD PTR FileData$[rsp+12]
  00097	48 89 48 0c	 mov	 QWORD PTR [rax+12], rcx

; 1643 :     info->ftLastWriteTime  = FileData.ftLastWriteTime;

  0009b	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  000a3	48 8b 4c 24 44	 mov	 rcx, QWORD PTR FileData$[rsp+20]
  000a8	48 89 48 14	 mov	 QWORD PTR [rax+20], rcx

; 1644 :     info->nFileSizeHigh    = FileData.nFileSizeHigh;

  000ac	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  000b4	8b 4c 24 4c	 mov	 ecx, DWORD PTR FileData$[rsp+28]
  000b8	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 1645 :     info->nFileSizeLow     = FileData.nFileSizeLow;

  000bb	48 8b 84 24 98
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  000c3	8b 4c 24 50	 mov	 ecx, DWORD PTR FileData$[rsp+32]
  000c7	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 1646 : /*  info->nNumberOfLinks   = 1; */
; 1647 :     if (FileData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)

  000ca	8b 44 24 30	 mov	 eax, DWORD PTR FileData$[rsp]
  000ce	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  000d3	85 c0		 test	 eax, eax
  000d5	74 0e		 je	 SHORT $LN1@attributes@3

; 1648 :         *reparse_tag = FileData.dwReserved0;

  000d7	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR reparse_tag$[rsp]
  000df	8b 4c 24 54	 mov	 ecx, DWORD PTR FileData$[rsp+36]
  000e3	89 08		 mov	 DWORD PTR [rax], ecx
$LN1@attributes@3:

; 1649 :     return TRUE;

  000e5	b8 01 00 00 00	 mov	 eax, 1
$LN3@attributes@3:

; 1650 : }

  000ea	48 81 c4 88 02
	00 00		 add	 rsp, 648		; 00000288H
  000f1	c3		 ret	 0
attributes_from_dir_w ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_lstat_w DD imagerel win32_lstat_w
	DD	imagerel win32_lstat_w+37
	DD	imagerel $unwind$win32_lstat_w
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_lstat_w DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_lstat_w
_TEXT	SEGMENT
path$ = 48
result$ = 56
win32_lstat_w PROC					; COMDAT

; 1950 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1951 :     return win32_xstat_w(path, result, FALSE);

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR result$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR path$[rsp]
  0001b	e8 00 00 00 00	 call	 win32_xstat_w

; 1952 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
win32_lstat_w ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_xstat_w DD imagerel win32_xstat_w
	DD	imagerel win32_xstat_w+64
	DD	imagerel $unwind$win32_xstat_w
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_xstat_w DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_xstat_w
_TEXT	SEGMENT
code$ = 32
path$ = 64
result$ = 72
traverse$ = 80
win32_xstat_w PROC					; COMDAT

; 1922 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1923 :     /* Protocol violation: we explicitly clear errno, instead of
; 1924 :        setting it to a POSIX error. Callers should use GetLastError. */
; 1925 :     int code = win32_xstat_impl_w(path, result, traverse);

  00013	44 8b 44 24 50	 mov	 r8d, DWORD PTR traverse$[rsp]
  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR result$[rsp]
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  00022	e8 00 00 00 00	 call	 win32_xstat_impl_w
  00027	89 44 24 20	 mov	 DWORD PTR code$[rsp], eax

; 1926 :     errno = 0;

  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00031	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1927 :     return code;

  00037	8b 44 24 20	 mov	 eax, DWORD PTR code$[rsp]

; 1928 : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
win32_xstat_w ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_stat DD imagerel win32_stat
	DD	imagerel win32_stat+40
	DD	imagerel $unwind$win32_stat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_stat DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_stat
_TEXT	SEGMENT
path$ = 48
result$ = 56
win32_stat PROC						; COMDAT

; 1956 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1957 :     return win32_xstat(path, result, TRUE);

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR result$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR path$[rsp]
  0001e	e8 00 00 00 00	 call	 win32_xstat

; 1958 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
win32_stat ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_stat_w DD imagerel win32_stat_w
	DD	imagerel win32_stat_w+40
	DD	imagerel $unwind$win32_stat_w
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_stat_w DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_stat_w
_TEXT	SEGMENT
path$ = 48
result$ = 56
win32_stat_w PROC					; COMDAT

; 1962 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1963 :     return win32_xstat_w(path, result, TRUE);

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR result$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR path$[rsp]
  0001e	e8 00 00 00 00	 call	 win32_xstat_w

; 1964 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
win32_stat_w ENDP
_TEXT	ENDS
EXTRN	__imp_GetFileType:PROC
EXTRN	__imp__get_osfhandle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_fstat DD imagerel win32_fstat
	DD	imagerel win32_fstat+311
	DD	imagerel $unwind$win32_fstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_fstat DD 010d01H
	DD	0e20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_fstat
_TEXT	SEGMENT
h$ = 32
type$ = 40
info$ = 48
error$121784 = 104
file_number$ = 128
result$ = 136
win32_fstat PROC					; COMDAT

; 1968 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1969 :     BY_HANDLE_FILE_INFORMATION info;
; 1970 :     HANDLE h;
; 1971 :     int type;
; 1972 : 
; 1973 :     if (!_PyVerify_fd(file_number))

  0000d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR file_number$[rsp]
  00014	e8 00 00 00 00	 call	 _PyVerify_fd
  00019	85 c0		 test	 eax, eax
  0001b	75 0b		 jne	 SHORT $LN10@win32_fsta

; 1974 :         h = INVALID_HANDLE_VALUE;

  0001d	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR h$[rsp], -1

; 1975 :     else

  00026	eb 12		 jmp	 SHORT $LN9@win32_fsta
$LN10@win32_fsta:

; 1976 :         h = (HANDLE)_get_osfhandle(file_number);

  00028	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR file_number$[rsp]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  00035	48 89 44 24 20	 mov	 QWORD PTR h$[rsp], rax
$LN9@win32_fsta:

; 1977 : 
; 1978 :     /* Protocol violation: we explicitly clear errno, instead of
; 1979 :        setting it to a POSIX error. Callers should use GetLastError. */
; 1980 :     errno = 0;

  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1981 : 
; 1982 :     if (h == INVALID_HANDLE_VALUE) {

  00046	48 83 7c 24 20
	ff		 cmp	 QWORD PTR h$[rsp], -1
  0004c	75 15		 jne	 SHORT $LN8@win32_fsta

; 1983 :         /* This is really a C library error (invalid file handle).
; 1984 :            We set the Win32 error to the closes one matching. */
; 1985 :         SetLastError(ERROR_INVALID_HANDLE);

  0004e	b9 06 00 00 00	 mov	 ecx, 6
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError

; 1986 :         return -1;

  00059	b8 ff ff ff ff	 mov	 eax, -1
  0005e	e9 cf 00 00 00	 jmp	 $LN11@win32_fsta
$LN8@win32_fsta:

; 1987 :     }
; 1988 :     memset(result, 0, sizeof(*result));

  00063	41 b8 60 00 00
	00		 mov	 r8d, 96			; 00000060H
  00069	33 d2		 xor	 edx, edx
  0006b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00073	e8 00 00 00 00	 call	 memset

; 1989 : 
; 1990 :     type = GetFileType(h);

  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR h$[rsp]
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileType
  00083	89 44 24 28	 mov	 DWORD PTR type$[rsp], eax

; 1991 :     if (type == FILE_TYPE_UNKNOWN) {

  00087	83 7c 24 28 00	 cmp	 DWORD PTR type$[rsp], 0
  0008c	75 1b		 jne	 SHORT $LN7@win32_fsta

; 1992 :         DWORD error = GetLastError();

  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00094	89 44 24 68	 mov	 DWORD PTR error$121784[rsp], eax

; 1993 :         if (error != 0) {

  00098	83 7c 24 68 00	 cmp	 DWORD PTR error$121784[rsp], 0
  0009d	74 0a		 je	 SHORT $LN6@win32_fsta

; 1994 :             return -1;

  0009f	b8 ff ff ff ff	 mov	 eax, -1
  000a4	e9 89 00 00 00	 jmp	 $LN11@win32_fsta
$LN6@win32_fsta:
$LN7@win32_fsta:

; 1995 :         }
; 1996 :         /* else: valid but unknown file */
; 1997 :     }
; 1998 : 
; 1999 :     if (type != FILE_TYPE_DISK) {

  000a9	83 7c 24 28 01	 cmp	 DWORD PTR type$[rsp], 1
  000ae	74 36		 je	 SHORT $LN5@win32_fsta

; 2000 :         if (type == FILE_TYPE_CHAR)

  000b0	83 7c 24 28 02	 cmp	 DWORD PTR type$[rsp], 2
  000b5	75 13		 jne	 SHORT $LN4@win32_fsta

; 2001 :             result->st_mode = _S_IFCHR;

  000b7	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  000bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  000c4	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
  000c8	eb 18		 jmp	 SHORT $LN3@win32_fsta
$LN4@win32_fsta:

; 2002 :         else if (type == FILE_TYPE_PIPE)

  000ca	83 7c 24 28 03	 cmp	 DWORD PTR type$[rsp], 3
  000cf	75 11		 jne	 SHORT $LN2@win32_fsta

; 2003 :             result->st_mode = _S_IFIFO;

  000d1	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  000d6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  000de	66 89 41 10	 mov	 WORD PTR [rcx+16], ax
$LN2@win32_fsta:
$LN3@win32_fsta:

; 2004 :         return 0;

  000e2	33 c0		 xor	 eax, eax
  000e4	eb 4c		 jmp	 SHORT $LN11@win32_fsta
$LN5@win32_fsta:

; 2005 :     }
; 2006 : 
; 2007 :     if (!GetFileInformationByHandle(h, &info)) {

  000e6	48 8d 54 24 30	 lea	 rdx, QWORD PTR info$[rsp]
  000eb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR h$[rsp]
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileInformationByHandle
  000f6	85 c0		 test	 eax, eax
  000f8	75 07		 jne	 SHORT $LN1@win32_fsta

; 2008 :         return -1;

  000fa	b8 ff ff ff ff	 mov	 eax, -1
  000ff	eb 31		 jmp	 SHORT $LN11@win32_fsta
$LN1@win32_fsta:

; 2009 :     }
; 2010 : 
; 2011 :     attribute_data_to_stat(&info, 0, result);

  00101	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR result$[rsp]
  00109	33 d2		 xor	 edx, edx
  0010b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR info$[rsp]
  00110	e8 00 00 00 00	 call	 attribute_data_to_stat

; 2012 :     /* specific to fstat() */
; 2013 :     result->st_ino = (((__int64)info.nFileIndexHigh)<<32) + info.nFileIndexLow;

  00115	8b 44 24 5c	 mov	 eax, DWORD PTR info$[rsp+44]
  00119	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0011d	8b 4c 24 60	 mov	 ecx, DWORD PTR info$[rsp+48]
  00121	48 03 c1	 add	 rax, rcx
  00124	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  0012c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2014 :     return 0;

  00130	33 c0		 xor	 eax, eax
$LN11@win32_fsta:

; 2015 : }

  00132	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00136	c3		 ret	 0
win32_fstat ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLongLong:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyStructSequence_New:PROC
_BSS	SEGMENT
StatResultType DB 01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_pystat_fromstructstat DD imagerel _pystat_fromstructstat
	DD	imagerel _pystat_fromstructstat+359
	DD	imagerel $unwind$_pystat_fromstructstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_pystat_fromstructstat DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _pystat_fromstructstat
_TEXT	SEGMENT
v$ = 32
cnsec$ = 40
mnsec$ = 44
ansec$ = 48
st$ = 80
_pystat_fromstructstat PROC				; COMDAT

; 2278 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2279 :     unsigned long ansec, mnsec, cnsec;
; 2280 :     PyObject *v = PyStructSequence_New(&StatResultType);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StatResultType
  00010	e8 00 00 00 00	 call	 PyStructSequence_New
  00015	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2281 :     if (v == NULL)

  0001a	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00020	75 07		 jne	 SHORT $LN2@pystat_fro

; 2282 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 39 01 00 00	 jmp	 $LN3@pystat_fro
$LN2@pystat_fro:

; 2283 : 
; 2284 :     PyStructSequence_SET_ITEM(v, 0, PyLong_FromLong((long)st->st_mode));

  00029	48 8b 44 24 50	 mov	 rax, QWORD PTR st$[rsp]
  0002e	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 PyLong_FromLong
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0003e	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 2285 : #ifdef HAVE_LARGEFILE_SUPPORT
; 2286 :     PyStructSequence_SET_ITEM(v, 1,
; 2287 :                               PyLong_FromLongLong((PY_LONG_LONG)st->st_ino));

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR st$[rsp]
  00047	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0004b	e8 00 00 00 00	 call	 PyLong_FromLongLong
  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00055	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax

; 2288 : #else
; 2289 :     PyStructSequence_SET_ITEM(v, 1, PyLong_FromLong((long)st->st_ino));
; 2290 : #endif
; 2291 : #if defined(HAVE_LONG_LONG) && !defined(MS_WINDOWS)
; 2292 :     PyStructSequence_SET_ITEM(v, 2,
; 2293 :                               PyLong_FromLongLong((PY_LONG_LONG)st->st_dev));
; 2294 : #else
; 2295 :     PyStructSequence_SET_ITEM(v, 2, PyLong_FromLong((long)st->st_dev));

  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR st$[rsp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00060	e8 00 00 00 00	 call	 PyLong_FromLong
  00065	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0006a	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 2296 : #endif
; 2297 :     PyStructSequence_SET_ITEM(v, 3, PyLong_FromLong((long)st->st_nlink));

  00071	48 8b 44 24 50	 mov	 rax, QWORD PTR st$[rsp]
  00076	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  00079	e8 00 00 00 00	 call	 PyLong_FromLong
  0007e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00083	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 2298 : #if defined(MS_WINDOWS)
; 2299 :     PyStructSequence_SET_ITEM(v, 4, PyLong_FromLong(0));

  0008a	33 c9		 xor	 ecx, ecx
  0008c	e8 00 00 00 00	 call	 PyLong_FromLong
  00091	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00096	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 2300 :     PyStructSequence_SET_ITEM(v, 5, PyLong_FromLong(0));

  0009d	33 c9		 xor	 ecx, ecx
  0009f	e8 00 00 00 00	 call	 PyLong_FromLong
  000a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  000a9	48 89 81 98 00
	00 00		 mov	 QWORD PTR [rcx+152], rax

; 2301 : #else
; 2302 :     PyStructSequence_SET_ITEM(v, 4, _PyLong_FromUid(st->st_uid));
; 2303 :     PyStructSequence_SET_ITEM(v, 5, _PyLong_FromGid(st->st_gid));
; 2304 : #endif
; 2305 : #ifdef HAVE_LARGEFILE_SUPPORT
; 2306 :     PyStructSequence_SET_ITEM(v, 6,
; 2307 :                               PyLong_FromLongLong((PY_LONG_LONG)st->st_size));

  000b0	48 8b 44 24 50	 mov	 rax, QWORD PTR st$[rsp]
  000b5	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000b9	e8 00 00 00 00	 call	 PyLong_FromLongLong
  000be	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  000c3	48 89 81 a0 00
	00 00		 mov	 QWORD PTR [rcx+160], rax

; 2308 : #else
; 2309 :     PyStructSequence_SET_ITEM(v, 6, PyLong_FromLong(st->st_size));
; 2310 : #endif
; 2311 : 
; 2312 : #if defined(HAVE_STAT_TV_NSEC)
; 2313 :     ansec = st->st_atim.tv_nsec;
; 2314 :     mnsec = st->st_mtim.tv_nsec;
; 2315 :     cnsec = st->st_ctim.tv_nsec;
; 2316 : #elif defined(HAVE_STAT_TV_NSEC2)
; 2317 :     ansec = st->st_atimespec.tv_nsec;
; 2318 :     mnsec = st->st_mtimespec.tv_nsec;
; 2319 :     cnsec = st->st_ctimespec.tv_nsec;
; 2320 : #elif defined(HAVE_STAT_NSEC)
; 2321 :     ansec = st->st_atime_nsec;

  000ca	48 8b 44 24 50	 mov	 rax, QWORD PTR st$[rsp]
  000cf	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  000d2	89 44 24 30	 mov	 DWORD PTR ansec$[rsp], eax

; 2322 :     mnsec = st->st_mtime_nsec;

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR st$[rsp]
  000db	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000de	89 44 24 2c	 mov	 DWORD PTR mnsec$[rsp], eax

; 2323 :     cnsec = st->st_ctime_nsec;

  000e2	48 8b 44 24 50	 mov	 rax, QWORD PTR st$[rsp]
  000e7	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  000ea	89 44 24 28	 mov	 DWORD PTR cnsec$[rsp], eax

; 2324 : #else
; 2325 :     ansec = mnsec = cnsec = 0;
; 2326 : #endif
; 2327 :     fill_time(v, 7, st->st_atime, ansec);

  000ee	44 8b 4c 24 30	 mov	 r9d, DWORD PTR ansec$[rsp]
  000f3	48 8b 44 24 50	 mov	 rax, QWORD PTR st$[rsp]
  000f8	4c 8b 40 30	 mov	 r8, QWORD PTR [rax+48]
  000fc	ba 07 00 00 00	 mov	 edx, 7
  00101	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00106	e8 00 00 00 00	 call	 fill_time

; 2328 :     fill_time(v, 8, st->st_mtime, mnsec);

  0010b	44 8b 4c 24 2c	 mov	 r9d, DWORD PTR mnsec$[rsp]
  00110	48 8b 44 24 50	 mov	 rax, QWORD PTR st$[rsp]
  00115	4c 8b 40 40	 mov	 r8, QWORD PTR [rax+64]
  00119	ba 08 00 00 00	 mov	 edx, 8
  0011e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00123	e8 00 00 00 00	 call	 fill_time

; 2329 :     fill_time(v, 9, st->st_ctime, cnsec);

  00128	44 8b 4c 24 28	 mov	 r9d, DWORD PTR cnsec$[rsp]
  0012d	48 8b 44 24 50	 mov	 rax, QWORD PTR st$[rsp]
  00132	4c 8b 40 50	 mov	 r8, QWORD PTR [rax+80]
  00136	ba 09 00 00 00	 mov	 edx, 9
  0013b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00140	e8 00 00 00 00	 call	 fill_time

; 2330 : 
; 2331 : #ifdef HAVE_STRUCT_STAT_ST_BLKSIZE
; 2332 :     PyStructSequence_SET_ITEM(v, ST_BLKSIZE_IDX,
; 2333 :                               PyLong_FromLong((long)st->st_blksize));
; 2334 : #endif
; 2335 : #ifdef HAVE_STRUCT_STAT_ST_BLOCKS
; 2336 :     PyStructSequence_SET_ITEM(v, ST_BLOCKS_IDX,
; 2337 :                               PyLong_FromLong((long)st->st_blocks));
; 2338 : #endif
; 2339 : #ifdef HAVE_STRUCT_STAT_ST_RDEV
; 2340 :     PyStructSequence_SET_ITEM(v, ST_RDEV_IDX,
; 2341 :                               PyLong_FromLong((long)st->st_rdev));
; 2342 : #endif
; 2343 : #ifdef HAVE_STRUCT_STAT_ST_GEN
; 2344 :     PyStructSequence_SET_ITEM(v, ST_GEN_IDX,
; 2345 :                               PyLong_FromLong((long)st->st_gen));
; 2346 : #endif
; 2347 : #ifdef HAVE_STRUCT_STAT_ST_BIRTHTIME
; 2348 :     {
; 2349 :       PyObject *val;
; 2350 :       unsigned long bsec,bnsec;
; 2351 :       bsec = (long)st->st_birthtime;
; 2352 : #ifdef HAVE_STAT_TV_NSEC2
; 2353 :       bnsec = st->st_birthtimespec.tv_nsec;
; 2354 : #else
; 2355 :       bnsec = 0;
; 2356 : #endif
; 2357 :       if (_stat_float_times) {
; 2358 :         val = PyFloat_FromDouble(bsec + 1e-9*bnsec);
; 2359 :       } else {
; 2360 :         val = PyLong_FromLong((long)bsec);
; 2361 :       }
; 2362 :       PyStructSequence_SET_ITEM(v, ST_BIRTHTIME_IDX,
; 2363 :                                 val);
; 2364 :     }
; 2365 : #endif
; 2366 : #ifdef HAVE_STRUCT_STAT_ST_FLAGS
; 2367 :     PyStructSequence_SET_ITEM(v, ST_FLAGS_IDX,
; 2368 :                               PyLong_FromLong((long)st->st_flags));
; 2369 : #endif
; 2370 : 
; 2371 :     if (PyErr_Occurred()) {

  00145	e8 00 00 00 00	 call	 PyErr_Occurred
  0014a	48 85 c0	 test	 rax, rax
  0014d	74 0e		 je	 SHORT $LN1@pystat_fro

; 2372 :         Py_DECREF(v);

  0014f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00154	e8 00 00 00 00	 call	 _Py_DecRef

; 2373 :         return NULL;

  00159	33 c0		 xor	 eax, eax
  0015b	eb 05		 jmp	 SHORT $LN3@pystat_fro
$LN1@pystat_fro:

; 2374 :     }
; 2375 : 
; 2376 :     return v;

  0015d	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN3@pystat_fro:

; 2377 : }

  00162	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00166	c3		 ret	 0
_pystat_fromstructstat ENDP
_TEXT	ENDS
PUBLIC	__real@3e112e0be826d695
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyNumber_Add:PROC
EXTRN	PyNumber_Multiply:PROC
EXTRN	PyLong_FromUnsignedLong:PROC
EXTRN	_PyLong_FromTime_t:PROC
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_time DD imagerel fill_time
	DD	imagerel fill_time+483
	DD	imagerel $unwind$fill_time
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_time DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT __real@3e112e0be826d695
CONST	SEGMENT
__real@3e112e0be826d695 DQ 03e112e0be826d695r	; 1e-009
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fill_time
_TEXT	SEGMENT
float_s$ = 32
s_in_ns$ = 40
ns_fractional$ = 48
s$ = 56
ns_total$ = 64
v$ = 96
index$ = 104
sec$ = 112
nsec$ = 120
fill_time PROC						; COMDAT

; 2232 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2233 :     PyObject *s = _PyLong_FromTime_t(sec);

  00017	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sec$[rsp]
  0001c	e8 00 00 00 00	 call	 _PyLong_FromTime_t
  00021	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 2234 :     PyObject *ns_fractional = PyLong_FromUnsignedLong(nsec);

  00026	8b 4c 24 78	 mov	 ecx, DWORD PTR nsec$[rsp]
  0002a	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  0002f	48 89 44 24 30	 mov	 QWORD PTR ns_fractional$[rsp], rax

; 2235 :     PyObject *s_in_ns = NULL;

  00034	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR s_in_ns$[rsp], 0

; 2236 :     PyObject *ns_total = NULL;

  0003d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR ns_total$[rsp], 0

; 2237 :     PyObject *float_s = NULL;

  00046	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR float_s$[rsp], 0

; 2238 : 
; 2239 :     if (!(s && ns_fractional))

  0004f	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  00055	74 08		 je	 SHORT $LN26@fill_time
  00057	48 83 7c 24 30
	00		 cmp	 QWORD PTR ns_fractional$[rsp], 0
  0005d	75 05		 jne	 SHORT $LN27@fill_time
$LN26@fill_time:

; 2240 :         goto exit;

  0005f	e9 02 01 00 00	 jmp	 $exit$121911
$LN27@fill_time:

; 2241 : 
; 2242 :     s_in_ns = PyNumber_Multiply(s, billion);

  00064	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR billion
  0006b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00070	e8 00 00 00 00	 call	 PyNumber_Multiply
  00075	48 89 44 24 28	 mov	 QWORD PTR s_in_ns$[rsp], rax

; 2243 :     if (!s_in_ns)

  0007a	48 83 7c 24 28
	00		 cmp	 QWORD PTR s_in_ns$[rsp], 0
  00080	75 05		 jne	 SHORT $LN25@fill_time

; 2244 :         goto exit;

  00082	e9 df 00 00 00	 jmp	 $exit$121911
$LN25@fill_time:

; 2245 : 
; 2246 :     ns_total = PyNumber_Add(s_in_ns, ns_fractional);

  00087	48 8b 54 24 30	 mov	 rdx, QWORD PTR ns_fractional$[rsp]
  0008c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s_in_ns$[rsp]
  00091	e8 00 00 00 00	 call	 PyNumber_Add
  00096	48 89 44 24 40	 mov	 QWORD PTR ns_total$[rsp], rax

; 2247 :     if (!ns_total)

  0009b	48 83 7c 24 40
	00		 cmp	 QWORD PTR ns_total$[rsp], 0
  000a1	75 05		 jne	 SHORT $LN24@fill_time

; 2248 :         goto exit;

  000a3	e9 be 00 00 00	 jmp	 $exit$121911
$LN24@fill_time:

; 2249 : 
; 2250 :     if (_stat_float_times) {

  000a8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _stat_float_times, 0
  000af	74 42		 je	 SHORT $LN23@fill_time

; 2251 :         float_s = PyFloat_FromDouble(sec + 1e-9*nsec);

  000b1	66 0f ef c0	 pxor	 xmm0, xmm0
  000b5	f2 48 0f 2a 44
	24 70		 cvtsi2sd xmm0, QWORD PTR sec$[rsp]
  000bc	8b 44 24 78	 mov	 eax, DWORD PTR nsec$[rsp]
  000c0	66 0f ef c9	 pxor	 xmm1, xmm1
  000c4	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  000c9	f2 0f 10 15 00
	00 00 00	 movsdx	 xmm2, QWORD PTR __real@3e112e0be826d695
  000d1	f2 0f 59 d1	 mulsd	 xmm2, xmm1
  000d5	66 0f 28 ca	 movapd	 xmm1, xmm2
  000d9	f2 0f 58 c1	 addsd	 xmm0, xmm1
  000dd	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000e2	48 89 44 24 20	 mov	 QWORD PTR float_s$[rsp], rax

; 2252 :         if (!float_s)

  000e7	48 83 7c 24 20
	00		 cmp	 QWORD PTR float_s$[rsp], 0
  000ed	75 02		 jne	 SHORT $LN22@fill_time

; 2253 :             goto exit;

  000ef	eb 75		 jmp	 SHORT $exit$121911
$LN22@fill_time:

; 2254 :     }
; 2255 :     else {

  000f1	eb 14		 jmp	 SHORT $LN21@fill_time
$LN23@fill_time:

; 2256 :         float_s = s;

  000f3	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000f8	48 89 44 24 20	 mov	 QWORD PTR float_s$[rsp], rax

; 2257 :         Py_INCREF(float_s);

  000fd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR float_s$[rsp]
  00102	e8 00 00 00 00	 call	 _Py_IncRef
$LN21@fill_time:

; 2258 :     }
; 2259 : 
; 2260 :     PyStructSequence_SET_ITEM(v, index, s);

  00107	48 63 44 24 68	 movsxd	 rax, DWORD PTR index$[rsp]
  0010c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  00111	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$[rsp]
  00116	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 2261 :     PyStructSequence_SET_ITEM(v, index+3, float_s);

  0011b	8b 44 24 68	 mov	 eax, DWORD PTR index$[rsp]
  0011f	83 c0 03	 add	 eax, 3
  00122	48 98		 cdqe
  00124	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  00129	48 8b 54 24 20	 mov	 rdx, QWORD PTR float_s$[rsp]
  0012e	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 2262 :     PyStructSequence_SET_ITEM(v, index+6, ns_total);

  00133	8b 44 24 68	 mov	 eax, DWORD PTR index$[rsp]
  00137	83 c0 06	 add	 eax, 6
  0013a	48 98		 cdqe
  0013c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  00141	48 8b 54 24 40	 mov	 rdx, QWORD PTR ns_total$[rsp]
  00146	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 2263 :     s = NULL;

  0014b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR s$[rsp], 0

; 2264 :     float_s = NULL;

  00154	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR float_s$[rsp], 0

; 2265 :     ns_total = NULL;

  0015d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR ns_total$[rsp], 0
$exit$121911:
$LN20@fill_time:

; 2266 : exit:
; 2267 :     Py_XDECREF(s);

  00166	48 83 7c 24 38
	00		 cmp	 QWORD PTR s$[rsp], 0
  0016c	74 0a		 je	 SHORT $LN17@fill_time
  0016e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00173	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@fill_time:
  00178	33 c0		 xor	 eax, eax
  0017a	85 c0		 test	 eax, eax
  0017c	75 e8		 jne	 SHORT $LN20@fill_time
$LN16@fill_time:

; 2268 :     Py_XDECREF(ns_fractional);

  0017e	48 83 7c 24 30
	00		 cmp	 QWORD PTR ns_fractional$[rsp], 0
  00184	74 0a		 je	 SHORT $LN13@fill_time
  00186	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ns_fractional$[rsp]
  0018b	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@fill_time:
  00190	33 c0		 xor	 eax, eax
  00192	85 c0		 test	 eax, eax
  00194	75 e8		 jne	 SHORT $LN16@fill_time
$LN12@fill_time:

; 2269 :     Py_XDECREF(s_in_ns);

  00196	48 83 7c 24 28
	00		 cmp	 QWORD PTR s_in_ns$[rsp], 0
  0019c	74 0a		 je	 SHORT $LN9@fill_time
  0019e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s_in_ns$[rsp]
  001a3	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@fill_time:
  001a8	33 c0		 xor	 eax, eax
  001aa	85 c0		 test	 eax, eax
  001ac	75 e8		 jne	 SHORT $LN12@fill_time
$LN8@fill_time:

; 2270 :     Py_XDECREF(ns_total);

  001ae	48 83 7c 24 40
	00		 cmp	 QWORD PTR ns_total$[rsp], 0
  001b4	74 0a		 je	 SHORT $LN5@fill_time
  001b6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ns_total$[rsp]
  001bb	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@fill_time:
  001c0	33 c0		 xor	 eax, eax
  001c2	85 c0		 test	 eax, eax
  001c4	75 e8		 jne	 SHORT $LN8@fill_time
$LN4@fill_time:

; 2271 :     Py_XDECREF(float_s);

  001c6	48 83 7c 24 20
	00		 cmp	 QWORD PTR float_s$[rsp], 0
  001cc	74 0a		 je	 SHORT $LN1@fill_time
  001ce	48 8b 4c 24 20	 mov	 rcx, QWORD PTR float_s$[rsp]
  001d3	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@fill_time:
  001d8	33 c0		 xor	 eax, eax
  001da	85 c0		 test	 eax, eax
  001dc	75 e8		 jne	 SHORT $LN4@fill_time

; 2272 : }

  001de	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e2	c3		 ret	 0
fill_time ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@DKIKMCGO@O?$CG?$HM$O?$CG?3lstat?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_lstat DD imagerel posix_lstat
	DD	imagerel posix_lstat+198
	DD	imagerel $unwind$posix_lstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_lstat DD 021601H
	DD	0170116H
xdata	ENDS
;	COMDAT ??_C@_0N@DKIKMCGO@O?$CG?$HM$O?$CG?3lstat?$AA@
CONST	SEGMENT
??_C@_0N@DKIKMCGO@O?$CG?$HM$O?$CG?3lstat?$AA@ DB 'O&|$O&:lstat', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_lstat
_TEXT	SEGMENT
dir_fd$ = 64
return_value$ = 72
follow_symlinks$ = 80
path$ = 96
self$ = 192
args$ = 200
kwargs$ = 208
posix_lstat PROC					; COMDAT

; 2480 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2481 :     static char *keywords[] = {"path", "dir_fd", NULL};
; 2482 :     path_t path;
; 2483 :     int dir_fd = DEFAULT_DIR_FD;

  00016	c7 44 24 40 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 2484 :     int follow_symlinks = 0;

  0001e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR follow_symlinks$[rsp], 0

; 2485 :     PyObject *return_value;
; 2486 : 
; 2487 :     memset(&path, 0, sizeof(path));

  00026	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  0002c	33 d2		 xor	 edx, edx
  0002e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR path$[rsp]
  00033	e8 00 00 00 00	 call	 memset

; 2488 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|$O&:lstat", keywords,
; 2489 :         path_converter, &path,
; 2490 : #ifdef HAVE_FSTATAT
; 2491 :         dir_fd_converter, &dir_fd
; 2492 : #else
; 2493 :         dir_fd_unavailable, &dir_fd
; 2494 : #endif
; 2495 :         ))

  00038	48 8d 44 24 40	 lea	 rax, QWORD PTR dir_fd$[rsp]
  0003d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00042	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  00049	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0004e	48 8d 44 24 60	 lea	 rax, QWORD PTR path$[rsp]
  00053	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  0005f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00064	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_lstat@@9@9
  0006b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@DKIKMCGO@O?$CG?$HM$O?$CG?3lstat?$AA@
  00072	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0007a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00082	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00087	85 c0		 test	 eax, eax
  00089	75 04		 jne	 SHORT $LN1@posix_lsta

; 2496 :         return NULL;

  0008b	33 c0		 xor	 eax, eax
  0008d	eb 2f		 jmp	 SHORT $LN2@posix_lsta
$LN1@posix_lsta:

; 2497 :     return_value = posix_do_stat("stat", &path, dir_fd, follow_symlinks);

  0008f	44 8b 4c 24 50	 mov	 r9d, DWORD PTR follow_symlinks$[rsp]
  00094	44 8b 44 24 40	 mov	 r8d, DWORD PTR dir_fd$[rsp]
  00099	48 8d 54 24 60	 lea	 rdx, QWORD PTR path$[rsp]
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04GBLELIND@stat?$AA@
  000a5	e8 00 00 00 00	 call	 posix_do_stat
  000aa	48 89 44 24 48	 mov	 QWORD PTR return_value$[rsp], rax

; 2498 :     path_cleanup(&path);

  000af	48 8d 4c 24 60	 lea	 rcx, QWORD PTR path$[rsp]
  000b4	e8 00 00 00 00	 call	 path_cleanup

; 2499 :     return return_value;

  000b9	48 8b 44 24 48	 mov	 rax, QWORD PTR return_value$[rsp]
$LN2@posix_lsta:

; 2500 : }

  000be	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  000c5	c3		 ret	 0
posix_lstat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@HDDMLDKF@O?$CGi?$HM$O?$CGpp?3access?$AA@ ; `string'
EXTRN	__imp_GetFileAttributesA:PROC
EXTRN	__imp_GetFileAttributesW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_access DD imagerel posix_access
	DD	imagerel posix_access+437
	DD	imagerel $unwind$posix_access
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_access DD 021601H
	DD	01d0116H
xdata	ENDS
;	COMDAT ??_C@_0BB@HDDMLDKF@O?$CGi?$HM$O?$CGpp?3access?$AA@
CONST	SEGMENT
??_C@_0BB@HDDMLDKF@O?$CGi?$HM$O?$CGpp?3access?$AA@ DB 'O&i|$O&pp:access', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_access
_TEXT	SEGMENT
dir_fd$ = 96
effective_ids$ = 100
attr$ = 104
mode$ = 108
return_value$ = 112
follow_symlinks$ = 120
path$ = 128
_save$122068 = 208
tv134 = 216
self$ = 240
args$ = 248
kwargs$ = 256
posix_access PROC					; COMDAT

; 2527 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 2528 :     static char *keywords[] = {"path", "mode", "dir_fd", "effective_ids",
; 2529 :                                 "follow_symlinks", NULL};
; 2530 :     path_t path;
; 2531 :     int mode;
; 2532 :     int dir_fd = DEFAULT_DIR_FD;

  00016	c7 44 24 60 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 2533 :     int effective_ids = 0;

  0001e	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR effective_ids$[rsp], 0

; 2534 :     int follow_symlinks = 1;

  00026	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR follow_symlinks$[rsp], 1

; 2535 :     PyObject *return_value = NULL;

  0002e	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR return_value$[rsp], 0

; 2536 : 
; 2537 : #ifdef MS_WINDOWS
; 2538 :     DWORD attr;
; 2539 : #else
; 2540 :     int result;
; 2541 : #endif
; 2542 : 
; 2543 :     memset(&path, 0, sizeof(path));

  00037	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  0003d	33 d2		 xor	 edx, edx
  0003f	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  00047	e8 00 00 00 00	 call	 memset

; 2544 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&i|$O&pp:access", keywords,
; 2545 :         path_converter, &path, &mode,
; 2546 : #ifdef HAVE_FACCESSAT
; 2547 :         dir_fd_converter, &dir_fd,
; 2548 : #else
; 2549 :         dir_fd_unavailable, &dir_fd,
; 2550 : #endif
; 2551 :         &effective_ids, &follow_symlinks))

  0004c	48 8d 44 24 78	 lea	 rax, QWORD PTR follow_symlinks$[rsp]
  00051	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00056	48 8d 44 24 64	 lea	 rax, QWORD PTR effective_ids$[rsp]
  0005b	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00060	48 8d 44 24 60	 lea	 rax, QWORD PTR dir_fd$[rsp]
  00065	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  00071	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00076	48 8d 44 24 6c	 lea	 rax, QWORD PTR mode$[rsp]
  0007b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00080	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR path$[rsp]
  00088	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_access@@9@9
  000a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@HDDMLDKF@O?$CGi?$HM$O?$CGpp?3access?$AA@
  000a7	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  000af	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000b7	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000bc	85 c0		 test	 eax, eax
  000be	75 07		 jne	 SHORT $LN5@posix_acce

; 2552 :         return NULL;

  000c0	33 c0		 xor	 eax, eax
  000c2	e9 e6 00 00 00	 jmp	 $LN6@posix_acce
$LN5@posix_acce:

; 2553 : 
; 2554 : #ifndef HAVE_FACCESSAT
; 2555 :     if (follow_symlinks_specified("access", follow_symlinks))

  000c7	8b 54 24 78	 mov	 edx, DWORD PTR follow_symlinks$[rsp]
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06EBPNOMLE@access?$AA@
  000d2	e8 00 00 00 00	 call	 follow_symlinks_specified
  000d7	85 c0		 test	 eax, eax
  000d9	74 05		 je	 SHORT $LN4@posix_acce

; 2556 :         goto exit;

  000db	e9 bb 00 00 00	 jmp	 $exit$122066
$LN4@posix_acce:

; 2557 : 
; 2558 :     if (effective_ids) {

  000e0	83 7c 24 64 00	 cmp	 DWORD PTR effective_ids$[rsp], 0
  000e5	74 18		 je	 SHORT $LN3@posix_acce

; 2559 :         argument_unavailable_error("access", "effective_ids");

  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@FGNLNFPF@effective_ids?$AA@
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06EBPNOMLE@access?$AA@
  000f5	e8 00 00 00 00	 call	 argument_unavailable_error

; 2560 :         goto exit;

  000fa	e9 9c 00 00 00	 jmp	 $exit$122066
$LN3@posix_acce:

; 2561 :     }
; 2562 : #endif
; 2563 : 
; 2564 : #ifdef MS_WINDOWS
; 2565 :     Py_BEGIN_ALLOW_THREADS

  000ff	e8 00 00 00 00	 call	 PyEval_SaveThread
  00104	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR _save$122068[rsp], rax

; 2566 :     if (path.wide != NULL)

  0010c	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR path$[rsp+24], 0
  00115	74 14		 je	 SHORT $LN2@posix_acce

; 2567 :         attr = GetFileAttributesW(path.wide);

  00117	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+24]
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesW
  00125	89 44 24 68	 mov	 DWORD PTR attr$[rsp], eax

; 2568 :     else

  00129	eb 12		 jmp	 SHORT $LN1@posix_acce
$LN2@posix_acce:

; 2569 :         attr = GetFileAttributesA(path.narrow);

  0012b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesA
  00139	89 44 24 68	 mov	 DWORD PTR attr$[rsp], eax
$LN1@posix_acce:

; 2570 :     Py_END_ALLOW_THREADS

  0013d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _save$122068[rsp]
  00145	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 2571 : 
; 2572 :     /*
; 2573 :      * Access is possible if
; 2574 :      *   * we didn't get a -1, and
; 2575 :      *     * write access wasn't requested,
; 2576 :      *     * or the file isn't read-only,
; 2577 :      *     * or it's a directory.
; 2578 :      * (Directories cannot be read-only on Windows.)
; 2579 :     */
; 2580 :     return_value = PyBool_FromLong(
; 2581 :         (attr != 0xFFFFFFFF) &&
; 2582 :             (!(mode & 2) ||
; 2583 :             !(attr & FILE_ATTRIBUTE_READONLY) ||
; 2584 :             (attr & FILE_ATTRIBUTE_DIRECTORY)));

  0014a	83 7c 24 68 ff	 cmp	 DWORD PTR attr$[rsp], -1 ; ffffffffH
  0014f	74 2e		 je	 SHORT $LN9@posix_acce
  00151	8b 44 24 6c	 mov	 eax, DWORD PTR mode$[rsp]
  00155	83 e0 02	 and	 eax, 2
  00158	85 c0		 test	 eax, eax
  0015a	74 16		 je	 SHORT $LN8@posix_acce
  0015c	8b 44 24 68	 mov	 eax, DWORD PTR attr$[rsp]
  00160	83 e0 01	 and	 eax, 1
  00163	85 c0		 test	 eax, eax
  00165	74 0b		 je	 SHORT $LN8@posix_acce
  00167	8b 44 24 68	 mov	 eax, DWORD PTR attr$[rsp]
  0016b	83 e0 10	 and	 eax, 16
  0016e	85 c0		 test	 eax, eax
  00170	74 0d		 je	 SHORT $LN9@posix_acce
$LN8@posix_acce:
  00172	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv134[rsp], 1
  0017d	eb 0b		 jmp	 SHORT $LN10@posix_acce
$LN9@posix_acce:
  0017f	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv134[rsp], 0
$LN10@posix_acce:
  0018a	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv134[rsp]
  00191	e8 00 00 00 00	 call	 PyBool_FromLong
  00196	48 89 44 24 70	 mov	 QWORD PTR return_value$[rsp], rax
$exit$122066:

; 2585 : #else
; 2586 : 
; 2587 :     Py_BEGIN_ALLOW_THREADS
; 2588 : #ifdef HAVE_FACCESSAT
; 2589 :     if ((dir_fd != DEFAULT_DIR_FD) ||
; 2590 :         effective_ids ||
; 2591 :         !follow_symlinks) {
; 2592 :         int flags = 0;
; 2593 :         if (!follow_symlinks)
; 2594 :             flags |= AT_SYMLINK_NOFOLLOW;
; 2595 :         if (effective_ids)
; 2596 :             flags |= AT_EACCESS;
; 2597 :         result = faccessat(dir_fd, path.narrow, mode, flags);
; 2598 :     }
; 2599 :     else
; 2600 : #endif
; 2601 :         result = access(path.narrow, mode);
; 2602 :     Py_END_ALLOW_THREADS
; 2603 :     return_value = PyBool_FromLong(!result);
; 2604 : #endif
; 2605 : 
; 2606 : #ifndef HAVE_FACCESSAT
; 2607 : exit:
; 2608 : #endif
; 2609 :     path_cleanup(&path);

  0019b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  001a3	e8 00 00 00 00	 call	 path_cleanup

; 2610 :     return return_value;

  001a8	48 8b 44 24 70	 mov	 rax, QWORD PTR return_value$[rsp]
$LN6@posix_acce:

; 2611 : }

  001ad	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  001b4	c3		 ret	 0
posix_access ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$follow_symlinks_specified DD imagerel follow_symlinks_specified
	DD	imagerel follow_symlinks_specified+51
	DD	imagerel $unwind$follow_symlinks_specified
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$follow_symlinks_specified DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT follow_symlinks_specified
_TEXT	SEGMENT
function_name$ = 48
follow_symlinks$ = 56
follow_symlinks_specified PROC				; COMDAT

; 862  : follow_symlinks_specified(char *function_name, int follow_symlinks) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 863  :     if (follow_symlinks)

  0000d	83 7c 24 38 00	 cmp	 DWORD PTR follow_symlinks$[rsp], 0
  00012	74 04		 je	 SHORT $LN1@follow_sym

; 864  :         return 0;

  00014	33 c0		 xor	 eax, eax
  00016	eb 16		 jmp	 SHORT $LN2@follow_sym
$LN1@follow_sym:

; 865  : 
; 866  :     argument_unavailable_error(function_name, "follow_symlinks");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR function_name$[rsp]
  00024	e8 00 00 00 00	 call	 argument_unavailable_error

; 867  :     return 1;

  00029	b8 01 00 00 00	 mov	 eax, 1
$LN2@follow_sym:

; 868  : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
follow_symlinks_specified ENDP
_TEXT	ENDS
PUBLIC	??_C@_08OCLOHMLN@O?$CG?3chdir?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_chdir DD imagerel posix_chdir
	DD	imagerel posix_chdir+301
	DD	imagerel $unwind$posix_chdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_chdir DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT ??_C@_08OCLOHMLN@O?$CG?3chdir?$AA@
CONST	SEGMENT
??_C@_08OCLOHMLN@O?$CG?3chdir?$AA@ DB 'O&:chdir', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_chdir
_TEXT	SEGMENT
return_value$ = 48
result$ = 56
path$ = 64
_save$122095 = 144
tv82 = 152
self$ = 176
args$ = 184
kwargs$ = 192
posix_chdir PROC					; COMDAT

; 2689 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2690 :     path_t path;
; 2691 :     int result;
; 2692 :     PyObject *return_value = NULL;

  00016	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR return_value$[rsp], 0

; 2693 :     static char *keywords[] = {"path", NULL};
; 2694 : 
; 2695 :     memset(&path, 0, sizeof(path));

  0001f	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00025	33 d2		 xor	 edx, edx
  00027	48 8d 4c 24 40	 lea	 rcx, QWORD PTR path$[rsp]
  0002c	e8 00 00 00 00	 call	 memset

; 2696 : #ifdef HAVE_FCHDIR
; 2697 :     path.allow_fd = 1;
; 2698 : #endif
; 2699 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&:chdir", keywords,
; 2700 :         path_converter, &path
; 2701 :         ))

  00031	48 8d 44 24 40	 lea	 rax, QWORD PTR path$[rsp]
  00036	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_chdir@@9@9
  0004e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08OCLOHMLN@O?$CG?3chdir?$AA@
  00055	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0005d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00065	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0006a	85 c0		 test	 eax, eax
  0006c	75 07		 jne	 SHORT $LN4@posix_chdi

; 2702 :         return NULL;

  0006e	33 c0		 xor	 eax, eax
  00070	e9 b0 00 00 00	 jmp	 $LN5@posix_chdi
$LN4@posix_chdi:

; 2703 : 
; 2704 :     Py_BEGIN_ALLOW_THREADS

  00075	e8 00 00 00 00	 call	 PyEval_SaveThread
  0007a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR _save$122095[rsp], rax

; 2705 : #ifdef MS_WINDOWS
; 2706 :     if (path.wide)

  00082	48 83 7c 24 58
	00		 cmp	 QWORD PTR path$[rsp+24], 0
  00088	74 10		 je	 SHORT $LN3@posix_chdi

; 2707 :         result = win32_wchdir(path.wide);

  0008a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR path$[rsp+24]
  0008f	e8 00 00 00 00	 call	 win32_wchdir
  00094	89 44 24 38	 mov	 DWORD PTR result$[rsp], eax

; 2708 :     else

  00098	eb 0e		 jmp	 SHORT $LN2@posix_chdi
$LN3@posix_chdi:

; 2709 :         result = win32_chdir(path.narrow);

  0009a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR path$[rsp+32]
  0009f	e8 00 00 00 00	 call	 win32_chdir
  000a4	89 44 24 38	 mov	 DWORD PTR result$[rsp], eax
$LN2@posix_chdi:

; 2710 :     result = !result; /* on unix, success = 0, on windows, success = !0 */

  000a8	83 7c 24 38 00	 cmp	 DWORD PTR result$[rsp], 0
  000ad	75 0d		 jne	 SHORT $LN7@posix_chdi
  000af	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv82[rsp], 1
  000ba	eb 0b		 jmp	 SHORT $LN8@posix_chdi
$LN7@posix_chdi:
  000bc	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv82[rsp], 0
$LN8@posix_chdi:
  000c7	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv82[rsp]
  000ce	89 44 24 38	 mov	 DWORD PTR result$[rsp], eax

; 2711 : #elif defined(PYOS_OS2) && defined(PYCC_GCC)
; 2712 :     result = _chdir2(path.narrow);
; 2713 : #else
; 2714 : #ifdef HAVE_FCHDIR
; 2715 :     if (path.fd != -1)
; 2716 :         result = fchdir(path.fd);
; 2717 :     else
; 2718 : #endif
; 2719 :         result = chdir(path.narrow);
; 2720 : #endif
; 2721 :     Py_END_ALLOW_THREADS

  000d2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _save$122095[rsp]
  000da	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 2722 : 
; 2723 :     if (result) {

  000df	83 7c 24 38 00	 cmp	 DWORD PTR result$[rsp], 0
  000e4	74 18		 je	 SHORT $LN1@posix_chdi

; 2724 :         return_value = path_error("chdir", &path);

  000e6	48 8d 54 24 40	 lea	 rdx, QWORD PTR path$[rsp]
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IHFEJEKL@chdir?$AA@
  000f2	e8 00 00 00 00	 call	 path_error
  000f7	48 89 44 24 30	 mov	 QWORD PTR return_value$[rsp], rax

; 2725 :         goto exit;

  000fc	eb 18		 jmp	 SHORT $exit$122100
$LN1@posix_chdi:

; 2726 :     }
; 2727 : 
; 2728 :     return_value = Py_None;

  000fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00105	48 89 44 24 30	 mov	 QWORD PTR return_value$[rsp], rax

; 2729 :     Py_INCREF(Py_None);

  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00111	e8 00 00 00 00	 call	 _Py_IncRef
$exit$122100:

; 2730 : 
; 2731 : exit:
; 2732 :     path_cleanup(&path);

  00116	48 8d 4c 24 40	 lea	 rcx, QWORD PTR path$[rsp]
  0011b	e8 00 00 00 00	 call	 path_cleanup

; 2733 :     return return_value;

  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR return_value$[rsp]
$LN5@posix_chdi:

; 2734 : }

  00125	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0012c	c3		 ret	 0
posix_chdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_02CBLDBPFN@?1?1?$AA@			; `string'
PUBLIC	??_C@_02HDBGODGB@?2?2?$AA@			; `string'
PUBLIC	??_C@_1CK@BPHMBLKD@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAP?$AAA?$AAT?$AAH?$AA?$CL?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_03KDLBOHAO@?$DNx?3?$AA@			; `string'
EXTRN	__imp_SetEnvironmentVariableA:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_GetCurrentDirectoryA:PROC
EXTRN	__imp_SetCurrentDirectoryA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_chdir DD imagerel win32_chdir
	DD	imagerel win32_chdir+224
	DD	imagerel $unwind$win32_chdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_chdir DD 020c01H
	DD	02b010cH
xdata	ENDS
;	COMDAT ??_C@_02CBLDBPFN@?1?1?$AA@
CONST	SEGMENT
??_C@_02CBLDBPFN@?1?1?$AA@ DB '//', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HDBGODGB@?2?2?$AA@
CONST	SEGMENT
??_C@_02HDBGODGB@?2?2?$AA@ DB '\\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@BPHMBLKD@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAP?$AAA?$AAT?$AAH?$AA?$CL?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@BPHMBLKD@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAP?$AAA?$AAT?$AAH?$AA?$CL?$AA1?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, 'M', 00H, 'A', 00H, 'X', 00H, '_'
	DB	00H, 'P', 00H, 'A', 00H, 'T', 00H, 'H', 00H, '+', 00H, '1', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_03KDLBOHAO@?$DNx?3?$AA@
CONST	SEGMENT
??_C@_03KDLBOHAO@?$DNx?3?$AA@ DB '=x:', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT win32_chdir
_TEXT	SEGMENT
env$ = 32
new_path$ = 48
result$ = 320
path$ = 352
win32_chdir PROC					; COMDAT

; 1457 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H

; 1458 :     char new_path[MAX_PATH+1];
; 1459 :     int result;
; 1460 :     char env[4] = "=x:";

  0000c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_03KDLBOHAO@?$DNx?3?$AA@
  00012	89 44 24 20	 mov	 DWORD PTR env$[rsp], eax

; 1461 : 
; 1462 :     if(!SetCurrentDirectoryA(path))

  00016	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetCurrentDirectoryA
  00024	85 c0		 test	 eax, eax
  00026	75 07		 jne	 SHORT $LN4@win32_chdi

; 1463 :         return FALSE;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 a9 00 00 00	 jmp	 $LN5@win32_chdi
$LN4@win32_chdi:

; 1464 :     result = GetCurrentDirectoryA(MAX_PATH+1, new_path);

  0002f	48 8d 54 24 30	 lea	 rdx, QWORD PTR new_path$[rsp]
  00034	b9 05 01 00 00	 mov	 ecx, 261		; 00000105H
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentDirectoryA
  0003f	89 84 24 40 01
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 1465 :     if (!result)

  00046	83 bc 24 40 01
	00 00 00	 cmp	 DWORD PTR result$[rsp], 0
  0004e	75 07		 jne	 SHORT $LN3@win32_chdi

; 1466 :         return FALSE;

  00050	33 c0		 xor	 eax, eax
  00052	e9 81 00 00 00	 jmp	 $LN5@win32_chdi
$LN3@win32_chdi:

; 1467 :     /* In the ANSI API, there should not be any paths longer
; 1468 :        than MAX_PATH. */
; 1469 :     assert(result <= MAX_PATH+1);

  00057	81 bc 24 40 01
	00 00 05 01 00
	00		 cmp	 DWORD PTR result$[rsp], 261 ; 00000105H
  00062	7e 1c		 jle	 SHORT $LN7@win32_chdi
  00064	41 b8 bd 05 00
	00		 mov	 r8d, 1469		; 000005bdH
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@BPHMBLKD@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAM?$AAA?$AAX?$AA_?$AAP?$AAA?$AAT?$AAH?$AA?$CL?$AA1?$AA?$AA@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN7@win32_chdi:

; 1470 :     if (strncmp(new_path, "\\\\", 2) == 0 ||
; 1471 :         strncmp(new_path, "//", 2) == 0)

  00080	41 b8 02 00 00
	00		 mov	 r8d, 2
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02HDBGODGB@?2?2?$AA@
  0008d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR new_path$[rsp]
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00098	85 c0		 test	 eax, eax
  0009a	74 1c		 je	 SHORT $LN1@win32_chdi
  0009c	41 b8 02 00 00
	00		 mov	 r8d, 2
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02CBLDBPFN@?1?1?$AA@
  000a9	48 8d 4c 24 30	 lea	 rcx, QWORD PTR new_path$[rsp]
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  000b4	85 c0		 test	 eax, eax
  000b6	75 07		 jne	 SHORT $LN2@win32_chdi
$LN1@win32_chdi:

; 1472 :         /* UNC path, nothing to do. */
; 1473 :         return TRUE;

  000b8	b8 01 00 00 00	 mov	 eax, 1
  000bd	eb 19		 jmp	 SHORT $LN5@win32_chdi
$LN2@win32_chdi:

; 1474 :     env[1] = new_path[0];

  000bf	0f b6 44 24 30	 movzx	 eax, BYTE PTR new_path$[rsp]
  000c4	88 44 24 21	 mov	 BYTE PTR env$[rsp+1], al

; 1475 :     return SetEnvironmentVariableA(env, new_path);

  000c8	48 8d 54 24 30	 lea	 rdx, QWORD PTR new_path$[rsp]
  000cd	48 8d 4c 24 20	 lea	 rcx, QWORD PTR env$[rsp]
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEnvironmentVariableA
$LN5@win32_chdi:

; 1476 : }

  000d8	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000df	c3		 ret	 0
win32_chdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_15EAJGFGNH@?$AA?1?$AA?1?$AA?$AA@		; `string'
PUBLIC	??_C@_15LEKKCGMK@?$AA?2?$AA?2?$AA?$AA@		; `string'
PUBLIC	??_C@_17PMPCPBFD@?$AA?$DN?$AAx?$AA?3?$AA?$AA@	; `string'
EXTRN	__imp_SetEnvironmentVariableW:PROC
EXTRN	__imp_wcsncmp:PROC
EXTRN	__imp_GetCurrentDirectoryW:PROC
EXTRN	__imp_SetCurrentDirectoryW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_wchdir DD imagerel win32_wchdir
	DD	imagerel win32_wchdir+353
	DD	imagerel $unwind$win32_wchdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_wchdir DD 020c01H
	DD	04b010cH
xdata	ENDS
;	COMDAT ??_C@_15EAJGFGNH@?$AA?1?$AA?1?$AA?$AA@
CONST	SEGMENT
??_C@_15EAJGFGNH@?$AA?1?$AA?1?$AA?$AA@ DB '/', 00H, '/', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15LEKKCGMK@?$AA?2?$AA?2?$AA?$AA@
CONST	SEGMENT
??_C@_15LEKKCGMK@?$AA?2?$AA?2?$AA?$AA@ DB '\', 00H, '\', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17PMPCPBFD@?$AA?$DN?$AAx?$AA?3?$AA?$AA@
CONST	SEGMENT
??_C@_17PMPCPBFD@?$AA?$DN?$AAx?$AA?3?$AA?$AA@ DB '=', 00H, 'x', 00H, ':', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT win32_wchdir
_TEXT	SEGMENT
env$ = 32
new_path$ = 40
_new_path$ = 48
result$ = 576
path$ = 608
win32_wchdir PROC					; COMDAT

; 1482 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H

; 1483 :     wchar_t _new_path[MAX_PATH+1], *new_path = _new_path;

  0000c	48 8d 44 24 30	 lea	 rax, QWORD PTR _new_path$[rsp]
  00011	48 89 44 24 28	 mov	 QWORD PTR new_path$[rsp], rax

; 1484 :     int result;
; 1485 :     wchar_t env[4] = L"=x:";

  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ??_C@_17PMPCPBFD@?$AA?$DN?$AAx?$AA?3?$AA?$AA@
  0001d	48 89 44 24 20	 mov	 QWORD PTR env$[rsp], rax

; 1486 : 
; 1487 :     if(!SetCurrentDirectoryW(path))

  00022	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetCurrentDirectoryW
  00030	85 c0		 test	 eax, eax
  00032	75 07		 jne	 SHORT $LN8@win32_wchd

; 1488 :         return FALSE;

  00034	33 c0		 xor	 eax, eax
  00036	e9 1e 01 00 00	 jmp	 $LN9@win32_wchd
$LN8@win32_wchd:

; 1489 :     result = GetCurrentDirectoryW(MAX_PATH+1, new_path);

  0003b	48 8b 54 24 28	 mov	 rdx, QWORD PTR new_path$[rsp]
  00040	b9 05 01 00 00	 mov	 ecx, 261		; 00000105H
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentDirectoryW
  0004b	89 84 24 40 02
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 1490 :     if (!result)

  00052	83 bc 24 40 02
	00 00 00	 cmp	 DWORD PTR result$[rsp], 0
  0005a	75 07		 jne	 SHORT $LN7@win32_wchd

; 1491 :         return FALSE;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 f6 00 00 00	 jmp	 $LN9@win32_wchd
$LN7@win32_wchd:

; 1492 :     if (result > MAX_PATH+1) {

  00063	81 bc 24 40 02
	00 00 05 01 00
	00		 cmp	 DWORD PTR result$[rsp], 261 ; 00000105H
  0006e	7e 68		 jle	 SHORT $LN6@win32_wchd

; 1493 :         new_path = malloc(result * sizeof(wchar_t));

  00070	48 63 84 24 40
	02 00 00	 movsxd	 rax, DWORD PTR result$[rsp]
  00078	48 d1 e0	 shl	 rax, 1
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00084	48 89 44 24 28	 mov	 QWORD PTR new_path$[rsp], rax

; 1494 :         if (!new_path) {

  00089	48 83 7c 24 28
	00		 cmp	 QWORD PTR new_path$[rsp], 0
  0008f	75 12		 jne	 SHORT $LN5@win32_wchd

; 1495 :             SetLastError(ERROR_OUTOFMEMORY);

  00091	b9 0e 00 00 00	 mov	 ecx, 14
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError

; 1496 :             return FALSE;

  0009c	33 c0		 xor	 eax, eax
  0009e	e9 b6 00 00 00	 jmp	 $LN9@win32_wchd
$LN5@win32_wchd:

; 1497 :         }
; 1498 :         result = GetCurrentDirectoryW(result, new_path);

  000a3	48 8b 54 24 28	 mov	 rdx, QWORD PTR new_path$[rsp]
  000a8	8b 8c 24 40 02
	00 00		 mov	 ecx, DWORD PTR result$[rsp]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentDirectoryW
  000b5	89 84 24 40 02
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 1499 :         if (!result) {

  000bc	83 bc 24 40 02
	00 00 00	 cmp	 DWORD PTR result$[rsp], 0
  000c4	75 12		 jne	 SHORT $LN4@win32_wchd

; 1500 :             free(new_path);

  000c6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_path$[rsp]
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1501 :             return FALSE;

  000d1	33 c0		 xor	 eax, eax
  000d3	e9 81 00 00 00	 jmp	 $LN9@win32_wchd
$LN4@win32_wchd:
$LN6@win32_wchd:

; 1502 :         }
; 1503 :     }
; 1504 :     if (wcsncmp(new_path, L"\\\\", 2) == 0 ||
; 1505 :         wcsncmp(new_path, L"//", 2) == 0)

  000d8	41 b8 02 00 00
	00		 mov	 r8d, 2
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15LEKKCGMK@?$AA?2?$AA?2?$AA?$AA@
  000e5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_path$[rsp]
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncmp
  000f0	85 c0		 test	 eax, eax
  000f2	74 1c		 je	 SHORT $LN2@win32_wchd
  000f4	41 b8 02 00 00
	00		 mov	 r8d, 2
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15EAJGFGNH@?$AA?1?$AA?1?$AA?$AA@
  00101	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_path$[rsp]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcsncmp
  0010c	85 c0		 test	 eax, eax
  0010e	75 07		 jne	 SHORT $LN3@win32_wchd
$LN2@win32_wchd:

; 1506 :         /* UNC path, nothing to do. */
; 1507 :         return TRUE;

  00110	b8 01 00 00 00	 mov	 eax, 1
  00115	eb 42		 jmp	 SHORT $LN9@win32_wchd
$LN3@win32_wchd:

; 1508 :     env[1] = new_path[0];

  00117	48 8b 44 24 28	 mov	 rax, QWORD PTR new_path$[rsp]
  0011c	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0011f	66 89 44 24 22	 mov	 WORD PTR env$[rsp+2], ax

; 1509 :     result = SetEnvironmentVariableW(env, new_path);

  00124	48 8b 54 24 28	 mov	 rdx, QWORD PTR new_path$[rsp]
  00129	48 8d 4c 24 20	 lea	 rcx, QWORD PTR env$[rsp]
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEnvironmentVariableW
  00134	89 84 24 40 02
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 1510 :     if (new_path != _new_path)

  0013b	48 8d 44 24 30	 lea	 rax, QWORD PTR _new_path$[rsp]
  00140	48 39 44 24 28	 cmp	 QWORD PTR new_path$[rsp], rax
  00145	74 0b		 je	 SHORT $LN1@win32_wchd

; 1511 :         free(new_path);

  00147	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_path$[rsp]
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@win32_wchd:

; 1512 :     return result;

  00152	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR result$[rsp]
$LN9@win32_wchd:

; 1513 : }

  00159	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  00160	c3		 ret	 0
win32_wchdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@IPPHBHJA@O?$CGi?$HM$O?$CGp?3chmod?$AA@	; `string'
EXTRN	__imp_SetFileAttributesA:PROC
EXTRN	__imp_SetFileAttributesW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_chmod DD imagerel posix_chmod
	DD	imagerel posix_chmod+467
	DD	imagerel $unwind$posix_chmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_chmod DD 021601H
	DD	01b0116H
xdata	ENDS
;	COMDAT ??_C@_0P@IPPHBHJA@O?$CGi?$HM$O?$CGp?3chmod?$AA@
CONST	SEGMENT
??_C@_0P@IPPHBHJA@O?$CGi?$HM$O?$CGp?3chmod?$AA@ DB 'O&i|$O&p:chmod', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_chmod
_TEXT	SEGMENT
dir_fd$ = 80
attr$ = 84
mode$ = 88
return_value$ = 96
follow_symlinks$ = 104
result$ = 108
path$ = 112
_save$122128 = 192
self$ = 224
args$ = 232
kwargs$ = 240
posix_chmod PROC					; COMDAT

; 2769 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 2770 :     path_t path;
; 2771 :     int mode;
; 2772 :     int dir_fd = DEFAULT_DIR_FD;

  00016	c7 44 24 50 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 2773 :     int follow_symlinks = 1;

  0001e	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR follow_symlinks$[rsp], 1

; 2774 :     int result;
; 2775 :     PyObject *return_value = NULL;

  00026	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR return_value$[rsp], 0

; 2776 :     static char *keywords[] = {"path", "mode", "dir_fd",
; 2777 :                                "follow_symlinks", NULL};
; 2778 : 
; 2779 : #ifdef MS_WINDOWS
; 2780 :     DWORD attr;
; 2781 : #endif
; 2782 : 
; 2783 : #ifdef HAVE_FCHMODAT
; 2784 :     int fchmodat_nofollow_unsupported = 0;
; 2785 : #endif
; 2786 : 
; 2787 :     memset(&path, 0, sizeof(path));

  0002f	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00035	33 d2		 xor	 edx, edx
  00037	48 8d 4c 24 70	 lea	 rcx, QWORD PTR path$[rsp]
  0003c	e8 00 00 00 00	 call	 memset

; 2788 : #ifdef HAVE_FCHMOD
; 2789 :     path.allow_fd = 1;
; 2790 : #endif
; 2791 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&i|$O&p:chmod", keywords,
; 2792 :         path_converter, &path,
; 2793 :         &mode,
; 2794 : #ifdef HAVE_FCHMODAT
; 2795 :         dir_fd_converter, &dir_fd,
; 2796 : #else
; 2797 :         dir_fd_unavailable, &dir_fd,
; 2798 : #endif
; 2799 :         &follow_symlinks))

  00041	48 8d 44 24 68	 lea	 rax, QWORD PTR follow_symlinks$[rsp]
  00046	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0004b	48 8d 44 24 50	 lea	 rax, QWORD PTR dir_fd$[rsp]
  00050	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  0005c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00061	48 8d 44 24 58	 lea	 rax, QWORD PTR mode$[rsp]
  00066	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0006b	48 8d 44 24 70	 lea	 rax, QWORD PTR path$[rsp]
  00070	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00075	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  0007c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00081	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_chmod@@9@9
  00088	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@IPPHBHJA@O?$CGi?$HM$O?$CGp?3chmod?$AA@
  0008f	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  00097	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0009f	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000a4	85 c0		 test	 eax, eax
  000a6	75 07		 jne	 SHORT $LN11@posix_chmo

; 2800 :         return NULL;

  000a8	33 c0		 xor	 eax, eax
  000aa	e9 1c 01 00 00	 jmp	 $LN12@posix_chmo
$LN11@posix_chmo:

; 2801 : 
; 2802 : #if !(defined(HAVE_FCHMODAT) || defined(HAVE_LCHMOD))
; 2803 :     if (follow_symlinks_specified("chmod", follow_symlinks))

  000af	8b 54 24 68	 mov	 edx, DWORD PTR follow_symlinks$[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05OCEJBCEE@chmod?$AA@
  000ba	e8 00 00 00 00	 call	 follow_symlinks_specified
  000bf	85 c0		 test	 eax, eax
  000c1	74 05		 je	 SHORT $LN10@posix_chmo

; 2804 :         goto exit;

  000c3	e9 f4 00 00 00	 jmp	 $exit$122127
$LN10@posix_chmo:

; 2805 : #endif
; 2806 : 
; 2807 : #ifdef MS_WINDOWS
; 2808 :     Py_BEGIN_ALLOW_THREADS

  000c8	e8 00 00 00 00	 call	 PyEval_SaveThread
  000cd	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR _save$122128[rsp], rax

; 2809 :     if (path.wide)

  000d5	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR path$[rsp+24], 0
  000de	74 14		 je	 SHORT $LN9@posix_chmo

; 2810 :         attr = GetFileAttributesW(path.wide);

  000e0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+24]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesW
  000ee	89 44 24 54	 mov	 DWORD PTR attr$[rsp], eax

; 2811 :     else

  000f2	eb 12		 jmp	 SHORT $LN8@posix_chmo
$LN9@posix_chmo:

; 2812 :         attr = GetFileAttributesA(path.narrow);

  000f4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesA
  00102	89 44 24 54	 mov	 DWORD PTR attr$[rsp], eax
$LN8@posix_chmo:

; 2813 :     if (attr == 0xFFFFFFFF)

  00106	83 7c 24 54 ff	 cmp	 DWORD PTR attr$[rsp], -1 ; ffffffffH
  0010b	75 0a		 jne	 SHORT $LN7@posix_chmo

; 2814 :         result = 0;

  0010d	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 2815 :     else {

  00115	eb 5e		 jmp	 SHORT $LN6@posix_chmo
$LN7@posix_chmo:

; 2816 :         if (mode & _S_IWRITE)

  00117	8b 44 24 58	 mov	 eax, DWORD PTR mode$[rsp]
  0011b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00120	85 c0		 test	 eax, eax
  00122	74 0d		 je	 SHORT $LN5@posix_chmo

; 2817 :             attr &= ~FILE_ATTRIBUTE_READONLY;

  00124	8b 44 24 54	 mov	 eax, DWORD PTR attr$[rsp]
  00128	83 e0 fe	 and	 eax, -2			; fffffffeH
  0012b	89 44 24 54	 mov	 DWORD PTR attr$[rsp], eax

; 2818 :         else

  0012f	eb 0b		 jmp	 SHORT $LN4@posix_chmo
$LN5@posix_chmo:

; 2819 :             attr |= FILE_ATTRIBUTE_READONLY;

  00131	8b 44 24 54	 mov	 eax, DWORD PTR attr$[rsp]
  00135	83 c8 01	 or	 eax, 1
  00138	89 44 24 54	 mov	 DWORD PTR attr$[rsp], eax
$LN4@posix_chmo:

; 2820 :         if (path.wide)

  0013c	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR path$[rsp+24], 0
  00145	74 18		 je	 SHORT $LN3@posix_chmo

; 2821 :             result = SetFileAttributesW(path.wide, attr);

  00147	8b 54 24 54	 mov	 edx, DWORD PTR attr$[rsp]
  0014b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+24]
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetFileAttributesW
  00159	89 44 24 6c	 mov	 DWORD PTR result$[rsp], eax

; 2822 :         else

  0015d	eb 16		 jmp	 SHORT $LN2@posix_chmo
$LN3@posix_chmo:

; 2823 :             result = SetFileAttributesA(path.narrow, attr);

  0015f	8b 54 24 54	 mov	 edx, DWORD PTR attr$[rsp]
  00163	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetFileAttributesA
  00171	89 44 24 6c	 mov	 DWORD PTR result$[rsp], eax
$LN2@posix_chmo:
$LN6@posix_chmo:

; 2824 :     }
; 2825 :     Py_END_ALLOW_THREADS

  00175	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR _save$122128[rsp]
  0017d	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 2826 : 
; 2827 :     if (!result) {

  00182	83 7c 24 6c 00	 cmp	 DWORD PTR result$[rsp], 0
  00187	75 1b		 jne	 SHORT $LN1@posix_chmo

; 2828 :         return_value = win32_error_object("chmod", path.object);

  00189	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR path$[rsp+56]
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05OCEJBCEE@chmod?$AA@
  00198	e8 00 00 00 00	 call	 win32_error_object
  0019d	48 89 44 24 60	 mov	 QWORD PTR return_value$[rsp], rax

; 2829 :         goto exit;

  001a2	eb 18		 jmp	 SHORT $exit$122127
$LN1@posix_chmo:

; 2830 :     }
; 2831 : #else /* MS_WINDOWS */
; 2832 :     Py_BEGIN_ALLOW_THREADS
; 2833 : #ifdef HAVE_FCHMOD
; 2834 :     if (path.fd != -1)
; 2835 :         result = fchmod(path.fd, mode);
; 2836 :     else
; 2837 : #endif
; 2838 : #ifdef HAVE_LCHMOD
; 2839 :     if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))
; 2840 :         result = lchmod(path.narrow, mode);
; 2841 :     else
; 2842 : #endif
; 2843 : #ifdef HAVE_FCHMODAT
; 2844 :     if ((dir_fd != DEFAULT_DIR_FD) || !follow_symlinks) {
; 2845 :         /*
; 2846 :          * fchmodat() doesn't currently support AT_SYMLINK_NOFOLLOW!
; 2847 :          * The documentation specifically shows how to use it,
; 2848 :          * and then says it isn't implemented yet.
; 2849 :          * (true on linux with glibc 2.15, and openindiana 3.x)
; 2850 :          *
; 2851 :          * Once it is supported, os.chmod will automatically
; 2852 :          * support dir_fd and follow_symlinks=False.  (Hopefully.)
; 2853 :          * Until then, we need to be careful what exception we raise.
; 2854 :          */
; 2855 :         result = fchmodat(dir_fd, path.narrow, mode,
; 2856 :                           follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW);
; 2857 :         /*
; 2858 :          * But wait!  We can't throw the exception without allowing threads,
; 2859 :          * and we can't do that in this nested scope.  (Macro trickery, sigh.)
; 2860 :          */
; 2861 :         fchmodat_nofollow_unsupported =
; 2862 :                          result &&
; 2863 :                          ((errno == ENOTSUP) || (errno == EOPNOTSUPP)) &&
; 2864 :                          !follow_symlinks;
; 2865 :     }
; 2866 :     else
; 2867 : #endif
; 2868 :         result = chmod(path.narrow, mode);
; 2869 :     Py_END_ALLOW_THREADS
; 2870 : 
; 2871 :     if (result) {
; 2872 : #ifdef HAVE_FCHMODAT
; 2873 :         if (fchmodat_nofollow_unsupported) {
; 2874 :             if (dir_fd != DEFAULT_DIR_FD)
; 2875 :                 dir_fd_and_follow_symlinks_invalid("chmod",
; 2876 :                                                    dir_fd, follow_symlinks);
; 2877 :             else
; 2878 :                 follow_symlinks_specified("chmod", follow_symlinks);
; 2879 :         }
; 2880 :         else
; 2881 : #endif
; 2882 :             return_value = path_error("chmod", &path);
; 2883 :         goto exit;
; 2884 :     }
; 2885 : #endif
; 2886 : 
; 2887 :     Py_INCREF(Py_None);

  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  001ab	e8 00 00 00 00	 call	 _Py_IncRef

; 2888 :     return_value = Py_None;

  001b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001b7	48 89 44 24 60	 mov	 QWORD PTR return_value$[rsp], rax
$exit$122127:

; 2889 : exit:
; 2890 :     path_cleanup(&path);

  001bc	48 8d 4c 24 70	 lea	 rcx, QWORD PTR path$[rsp]
  001c1	e8 00 00 00 00	 call	 path_cleanup

; 2891 :     return return_value;

  001c6	48 8b 44 24 60	 mov	 rax, QWORD PTR return_value$[rsp]
$LN12@posix_chmo:

; 2892 : }

  001cb	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  001d2	c3		 ret	 0
posix_chmod ENDP
_TEXT	ENDS
EXTRN	PyErr_SetExcFromWindowsErrWithFilenameObject:PROC
EXTRN	PyExc_WindowsError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_error_object DD imagerel win32_error_object
	DD	imagerel win32_error_object+91
	DD	imagerel $unwind$win32_error_object
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_error_object DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_error_object
_TEXT	SEGMENT
tv65 = 32
function$ = 64
filename$ = 72
win32_error_object PROC					; COMDAT

; 1252 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1253 :     /* XXX - see win32_error for comments on 'function' */
; 1254 :     errno = GetLastError();

  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00014	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0001e	8b 4c 24 20	 mov	 ecx, DWORD PTR tv65[rsp]
  00022	89 08		 mov	 DWORD PTR [rax], ecx

; 1255 :     if (filename)

  00024	48 83 7c 24 48
	00		 cmp	 QWORD PTR filename$[rsp], 0
  0002a	74 1d		 je	 SHORT $LN2@win32_erro@3

; 1256 :         return PyErr_SetExcFromWindowsErrWithFilenameObject(
; 1257 :                     PyExc_WindowsError,
; 1258 :                     errno,
; 1259 :                     filename);

  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00032	4c 8b 44 24 48	 mov	 r8, QWORD PTR filename$[rsp]
  00037	8b 10		 mov	 edx, DWORD PTR [rax]
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_WindowsError
  00040	e8 00 00 00 00	 call	 PyErr_SetExcFromWindowsErrWithFilenameObject
  00045	eb 0f		 jmp	 SHORT $LN3@win32_erro@3

; 1260 :     else

  00047	eb 0d		 jmp	 SHORT $LN1@win32_erro@3
$LN2@win32_erro@3:

; 1261 :         return PyErr_SetFromWindowsErr(errno);

  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00051	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
$LN1@win32_erro@3:
$LN3@win32_erro@3:

; 1262 : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
win32_error_object ENDP
_TEXT	ENDS
EXTRN	__imp__commit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_fsync DD imagerel posix_fsync
	DD	imagerel posix_fsync+36
	DD	imagerel $unwind$posix_fsync
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_fsync DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_fsync
_TEXT	SEGMENT
self$ = 48
fdobj$ = 56
posix_fsync PROC					; COMDAT

; 3048 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3049 :     return posix_fildes(fdobj, fsync);

  0000e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp__commit
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR fdobj$[rsp]
  0001a	e8 00 00 00 00	 call	 posix_fildes

; 3050 : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
posix_fsync ENDP
_TEXT	ENDS
EXTRN	PyObject_AsFileDescriptor:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_fildes DD imagerel posix_fildes
	DD	imagerel posix_fildes+129
	DD	imagerel $unwind$posix_fildes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_fildes DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_fildes
_TEXT	SEGMENT
res$ = 32
fd$ = 36
_save$121412 = 40
fdobj$ = 64
func$ = 72
posix_fildes PROC					; COMDAT

; 1373 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1374 :     int fd;
; 1375 :     int res;
; 1376 :     fd = PyObject_AsFileDescriptor(fdobj);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fdobj$[rsp]
  00013	e8 00 00 00 00	 call	 PyObject_AsFileDescriptor
  00018	89 44 24 24	 mov	 DWORD PTR fd$[rsp], eax

; 1377 :     if (fd < 0)

  0001c	83 7c 24 24 00	 cmp	 DWORD PTR fd$[rsp], 0
  00021	7d 04		 jge	 SHORT $LN3@posix_fild

; 1378 :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 55		 jmp	 SHORT $LN4@posix_fild
$LN3@posix_fild:

; 1379 :     if (!_PyVerify_fd(fd))

  00027	8b 4c 24 24	 mov	 ecx, DWORD PTR fd$[rsp]
  0002b	e8 00 00 00 00	 call	 _PyVerify_fd
  00030	85 c0		 test	 eax, eax
  00032	75 07		 jne	 SHORT $LN2@posix_fild

; 1380 :         return posix_error();

  00034	e8 00 00 00 00	 call	 posix_error
  00039	eb 41		 jmp	 SHORT $LN4@posix_fild
$LN2@posix_fild:

; 1381 :     Py_BEGIN_ALLOW_THREADS

  0003b	e8 00 00 00 00	 call	 PyEval_SaveThread
  00040	48 89 44 24 28	 mov	 QWORD PTR _save$121412[rsp], rax

; 1382 :     res = (*func)(fd);

  00045	8b 4c 24 24	 mov	 ecx, DWORD PTR fd$[rsp]
  00049	ff 54 24 48	 call	 QWORD PTR func$[rsp]
  0004d	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 1383 :     Py_END_ALLOW_THREADS

  00051	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _save$121412[rsp]
  00056	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 1384 :     if (res < 0)

  0005b	83 7c 24 20 00	 cmp	 DWORD PTR res$[rsp], 0
  00060	7d 07		 jge	 SHORT $LN1@posix_fild

; 1385 :         return posix_error();

  00062	e8 00 00 00 00	 call	 posix_error
  00067	eb 13		 jmp	 SHORT $LN4@posix_fild
$LN1@posix_fild:

; 1386 :     Py_INCREF(Py_None);

  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00070	e8 00 00 00 00	 call	 _Py_IncRef

; 1387 :     return Py_None;

  00075	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@posix_fild:

; 1388 : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
posix_fildes ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OSError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_error DD imagerel posix_error
	DD	imagerel posix_error+21
	DD	imagerel $unwind$posix_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_error DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_error
_TEXT	SEGMENT
posix_error PROC					; COMDAT

; 1200 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1201 :     return PyErr_SetFromErrno(PyExc_OSError);

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  0000b	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 1202 : }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
posix_error ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_getcwd_unicode DD imagerel posix_getcwd_unicode
	DD	imagerel posix_getcwd_unicode+21
	DD	imagerel $unwind$posix_getcwd_unicode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_getcwd_unicode DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_getcwd_unicode
_TEXT	SEGMENT
self$ = 48
posix_getcwd_unicode PROC				; COMDAT

; 3309 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3310 :     return posix_getcwd(0);

  00009	33 c9		 xor	 ecx, ecx
  0000b	e8 00 00 00 00	 call	 posix_getcwd

; 3311 : }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
posix_getcwd_unicode ENDP
_TEXT	ENDS
PUBLIC	??_C@_07DMCCNOFG@getcwdu?$AA@			; `string'
EXTRN	PyUnicode_DecodeFSDefault:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	__imp_getcwd:PROC
EXTRN	PyUnicode_FromWideChar:PROC
EXTRN	PyErr_NoMemory:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_getcwd DD imagerel posix_getcwd
	DD	imagerel posix_getcwd+458
	DD	imagerel $unwind$posix_getcwd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_getcwd DD 020b01H
	DD	0191010bH
xdata	ENDS
;	COMDAT ??_C@_07DMCCNOFG@getcwdu?$AA@
CONST	SEGMENT
??_C@_07DMCCNOFG@getcwdu?$AA@ DB 'getcwdu', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_getcwd
_TEXT	SEGMENT
res$ = 32
buf$ = 48
resobj$122155 = 1088
len$122156 = 1096
wbuf2$122154 = 1104
wbuf$122153 = 1120
_save$122157 = 3184
_save$122170 = 3192
use_bytes$ = 3216
posix_getcwd PROC					; COMDAT

; 3251 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec 88 0c
	00 00		 sub	 rsp, 3208		; 00000c88H

; 3252 :     char buf[1026];
; 3253 :     char *res;
; 3254 : 
; 3255 : #ifdef MS_WINDOWS
; 3256 :     if (!use_bytes) {

  0000b	83 bc 24 90 0c
	00 00 00	 cmp	 DWORD PTR use_bytes$[rsp], 0
  00013	0f 85 31 01 00
	00		 jne	 $LN10@posix_getc

; 3257 :         wchar_t wbuf[1026];
; 3258 :         wchar_t *wbuf2 = wbuf;

  00019	48 8d 84 24 60
	04 00 00	 lea	 rax, QWORD PTR wbuf$122153[rsp]
  00021	48 89 84 24 50
	04 00 00	 mov	 QWORD PTR wbuf2$122154[rsp], rax

; 3259 :         PyObject *resobj;
; 3260 :         DWORD len;
; 3261 :         Py_BEGIN_ALLOW_THREADS

  00029	e8 00 00 00 00	 call	 PyEval_SaveThread
  0002e	48 89 84 24 70
	0c 00 00	 mov	 QWORD PTR _save$122157[rsp], rax

; 3262 :         len = GetCurrentDirectoryW(sizeof wbuf/ sizeof wbuf[0], wbuf);

  00036	48 8d 94 24 60
	04 00 00	 lea	 rdx, QWORD PTR wbuf$122153[rsp]
  0003e	b9 02 04 00 00	 mov	 ecx, 1026		; 00000402H
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentDirectoryW
  00049	89 84 24 48 04
	00 00		 mov	 DWORD PTR len$122156[rsp], eax

; 3263 :         /* If the buffer is large enough, len does not include the
; 3264 :            terminating \0. If the buffer is too small, len includes
; 3265 :            the space needed for the terminator. */
; 3266 :         if (len >= sizeof wbuf/ sizeof wbuf[0]) {

  00050	8b 84 24 48 04
	00 00		 mov	 eax, DWORD PTR len$122156[rsp]
  00057	48 3d 02 04 00
	00		 cmp	 rax, 1026		; 00000402H
  0005d	72 42		 jb	 SHORT $LN9@posix_getc

; 3267 :             wbuf2 = malloc(len * sizeof(wchar_t));

  0005f	8b 84 24 48 04
	00 00		 mov	 eax, DWORD PTR len$122156[rsp]
  00066	48 d1 e0	 shl	 rax, 1
  00069	48 8b c8	 mov	 rcx, rax
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00072	48 89 84 24 50
	04 00 00	 mov	 QWORD PTR wbuf2$122154[rsp], rax

; 3268 :             if (wbuf2)

  0007a	48 83 bc 24 50
	04 00 00 00	 cmp	 QWORD PTR wbuf2$122154[rsp], 0
  00083	74 1c		 je	 SHORT $LN8@posix_getc

; 3269 :                 len = GetCurrentDirectoryW(len, wbuf2);

  00085	48 8b 94 24 50
	04 00 00	 mov	 rdx, QWORD PTR wbuf2$122154[rsp]
  0008d	8b 8c 24 48 04
	00 00		 mov	 ecx, DWORD PTR len$122156[rsp]
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentDirectoryW
  0009a	89 84 24 48 04
	00 00		 mov	 DWORD PTR len$122156[rsp], eax
$LN8@posix_getc:
$LN9@posix_getc:

; 3270 :         }
; 3271 :         Py_END_ALLOW_THREADS

  000a1	48 8b 8c 24 70
	0c 00 00	 mov	 rcx, QWORD PTR _save$122157[rsp]
  000a9	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3272 :         if (!wbuf2) {

  000ae	48 83 bc 24 50
	04 00 00 00	 cmp	 QWORD PTR wbuf2$122154[rsp], 0
  000b7	75 0c		 jne	 SHORT $LN7@posix_getc

; 3273 :             PyErr_NoMemory();

  000b9	e8 00 00 00 00	 call	 PyErr_NoMemory

; 3274 :             return NULL;

  000be	33 c0		 xor	 eax, eax
  000c0	e9 fd 00 00 00	 jmp	 $LN11@posix_getc
$LN7@posix_getc:

; 3275 :         }
; 3276 :         if (!len) {

  000c5	83 bc 24 48 04
	00 00 00	 cmp	 DWORD PTR len$122156[rsp], 0
  000cd	75 33		 jne	 SHORT $LN6@posix_getc

; 3277 :             if (wbuf2 != wbuf) free(wbuf2);

  000cf	48 8d 84 24 60
	04 00 00	 lea	 rax, QWORD PTR wbuf$122153[rsp]
  000d7	48 39 84 24 50
	04 00 00	 cmp	 QWORD PTR wbuf2$122154[rsp], rax
  000df	74 0e		 je	 SHORT $LN5@posix_getc
  000e1	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR wbuf2$122154[rsp]
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@posix_getc:

; 3278 :             return win32_error("getcwdu", NULL);

  000ef	33 d2		 xor	 edx, edx
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07DMCCNOFG@getcwdu?$AA@
  000f8	e8 00 00 00 00	 call	 win32_error
  000fd	e9 c0 00 00 00	 jmp	 $LN11@posix_getc
$LN6@posix_getc:

; 3279 :         }
; 3280 :         resobj = PyUnicode_FromWideChar(wbuf2, len);

  00102	8b 84 24 48 04
	00 00		 mov	 eax, DWORD PTR len$122156[rsp]
  00109	8b d0		 mov	 edx, eax
  0010b	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR wbuf2$122154[rsp]
  00113	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  00118	48 89 84 24 40
	04 00 00	 mov	 QWORD PTR resobj$122155[rsp], rax

; 3281 :         if (wbuf2 != wbuf) free(wbuf2);

  00120	48 8d 84 24 60
	04 00 00	 lea	 rax, QWORD PTR wbuf$122153[rsp]
  00128	48 39 84 24 50
	04 00 00	 cmp	 QWORD PTR wbuf2$122154[rsp], rax
  00130	74 0e		 je	 SHORT $LN4@posix_getc
  00132	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR wbuf2$122154[rsp]
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@posix_getc:

; 3282 :         return resobj;

  00140	48 8b 84 24 40
	04 00 00	 mov	 rax, QWORD PTR resobj$122155[rsp]
  00148	eb 78		 jmp	 SHORT $LN11@posix_getc
$LN10@posix_getc:

; 3283 :     }
; 3284 : 
; 3285 :     if (win32_warn_bytes_api())

  0014a	e8 00 00 00 00	 call	 win32_warn_bytes_api
  0014f	85 c0		 test	 eax, eax
  00151	74 04		 je	 SHORT $LN3@posix_getc

; 3286 :         return NULL;

  00153	33 c0		 xor	 eax, eax
  00155	eb 6b		 jmp	 SHORT $LN11@posix_getc
$LN3@posix_getc:

; 3287 : #endif
; 3288 : 
; 3289 :     Py_BEGIN_ALLOW_THREADS

  00157	e8 00 00 00 00	 call	 PyEval_SaveThread
  0015c	48 89 84 24 78
	0c 00 00	 mov	 QWORD PTR _save$122170[rsp], rax

; 3290 : #if defined(PYOS_OS2) && defined(PYCC_GCC)
; 3291 :     res = _getcwd2(buf, sizeof buf);
; 3292 : #else
; 3293 :     res = getcwd(buf, sizeof buf);

  00164	ba 02 04 00 00	 mov	 edx, 1026		; 00000402H
  00169	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getcwd
  00174	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 3294 : #endif
; 3295 :     Py_END_ALLOW_THREADS

  00179	48 8b 8c 24 78
	0c 00 00	 mov	 rcx, QWORD PTR _save$122170[rsp]
  00181	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3296 :     if (res == NULL)

  00186	48 83 7c 24 20
	00		 cmp	 QWORD PTR res$[rsp], 0
  0018c	75 07		 jne	 SHORT $LN2@posix_getc

; 3297 :         return posix_error();

  0018e	e8 00 00 00 00	 call	 posix_error
  00193	eb 2d		 jmp	 SHORT $LN11@posix_getc
$LN2@posix_getc:

; 3298 :     if (use_bytes)

  00195	83 bc 24 90 0c
	00 00 00	 cmp	 DWORD PTR use_bytes$[rsp], 0
  0019d	74 19		 je	 SHORT $LN1@posix_getc

; 3299 :         return PyBytes_FromStringAndSize(buf, strlen(buf));

  0019f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  001a4	e8 00 00 00 00	 call	 strlen
  001a9	48 8b d0	 mov	 rdx, rax
  001ac	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  001b1	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  001b6	eb 0a		 jmp	 SHORT $LN11@posix_getc
$LN1@posix_getc:

; 3300 :     return PyUnicode_DecodeFSDefault(buf);

  001b8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  001bd	e8 00 00 00 00	 call	 PyUnicode_DecodeFSDefault
$LN11@posix_getc:

; 3301 : }

  001c2	48 81 c4 88 0c
	00 00		 add	 rsp, 3208		; 00000c88H
  001c9	c3		 ret	 0
posix_getcwd ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_getcwd_bytes DD imagerel posix_getcwd_bytes
	DD	imagerel posix_getcwd_bytes+24
	DD	imagerel $unwind$posix_getcwd_bytes
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_getcwd_bytes DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_getcwd_bytes
_TEXT	SEGMENT
self$ = 48
posix_getcwd_bytes PROC					; COMDAT

; 3319 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3320 :     return posix_getcwd(1);

  00009	b9 01 00 00 00	 mov	 ecx, 1
  0000e	e8 00 00 00 00	 call	 posix_getcwd

; 3321 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
posix_getcwd_bytes ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@HNKNKFGO@link?3?5src?5and?5dst?5must?5be?5the?5sa@ ; `string'
PUBLIC	??_C@_0BK@OIHNMKCA@src_dir_fd?5and?5dst_dir_fd?$AA@ ; `string'
PUBLIC	??_C@_0BA@JCPNGPIG@O?$CGO?$CG?$HMO?$CGO?$CGp?3link?$AA@ ; `string'
EXTRN	__imp_CreateHardLinkA:PROC
EXTRN	__imp_CreateHardLinkW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_link DD imagerel posix_link
	DD	imagerel posix_link+583
	DD	imagerel $unwind$posix_link
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_link DD 021601H
	DD	02b0116H
xdata	ENDS
;	COMDAT ??_C@_0CI@HNKNKFGO@link?3?5src?5and?5dst?5must?5be?5the?5sa@
CONST	SEGMENT
??_C@_0CI@HNKNKFGO@link?3?5src?5and?5dst?5must?5be?5the?5sa@ DB 'link: sr'
	DB	'c and dst must be the same type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@OIHNMKCA@src_dir_fd?5and?5dst_dir_fd?$AA@
CONST	SEGMENT
??_C@_0BK@OIHNMKCA@src_dir_fd?5and?5dst_dir_fd?$AA@ DB 'src_dir_fd and ds'
	DB	't_dir_fd', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCPNGPIG@O?$CGO?$CG?$HMO?$CGO?$CGp?3link?$AA@
CONST	SEGMENT
??_C@_0BA@JCPNGPIG@O?$CGO?$CG?$HMO?$CGO?$CGp?3link?$AA@ DB 'O&O&|O&O&p:li'
	DB	'nk', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_link
_TEXT	SEGMENT
src_dir_fd$ = 112
dst$ = 128
return_value$ = 208
dst_dir_fd$ = 216
follow_symlinks$ = 220
result$ = 224
src$ = 240
_save$122221 = 320
self$ = 352
args$ = 360
kwargs$ = 368
posix_link PROC						; COMDAT

; 3345 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H

; 3346 :     path_t src, dst;
; 3347 :     int src_dir_fd = DEFAULT_DIR_FD;

  00016	c7 44 24 70 9c
	ff ff ff	 mov	 DWORD PTR src_dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 3348 :     int dst_dir_fd = DEFAULT_DIR_FD;

  0001e	c7 84 24 d8 00
	00 00 9c ff ff
	ff		 mov	 DWORD PTR dst_dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 3349 :     int follow_symlinks = 1;

  00029	c7 84 24 dc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR follow_symlinks$[rsp], 1

; 3350 :     PyObject *return_value = NULL;

  00034	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR return_value$[rsp], 0

; 3351 :     static char *keywords[] = {"src", "dst", "src_dir_fd", "dst_dir_fd",
; 3352 :                                "follow_symlinks", NULL};
; 3353 : #ifdef MS_WINDOWS
; 3354 :     BOOL result;
; 3355 : #else
; 3356 :     int result;
; 3357 : #endif
; 3358 : 
; 3359 :     memset(&src, 0, sizeof(src));

  00040	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00046	33 d2		 xor	 edx, edx
  00048	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR src$[rsp]
  00050	e8 00 00 00 00	 call	 memset

; 3360 :     memset(&dst, 0, sizeof(dst));

  00055	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  0005b	33 d2		 xor	 edx, edx
  0005d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR dst$[rsp]
  00065	e8 00 00 00 00	 call	 memset

; 3361 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&O&|O&O&p:link", keywords,
; 3362 :             path_converter, &src,
; 3363 :             path_converter, &dst,
; 3364 :             dir_fd_converter, &src_dir_fd,
; 3365 :             dir_fd_converter, &dst_dir_fd,
; 3366 :             &follow_symlinks))

  0006a	48 8d 84 24 dc
	00 00 00	 lea	 rax, QWORD PTR follow_symlinks$[rsp]
  00072	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00077	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR dst_dir_fd$[rsp]
  0007f	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_converter
  0008b	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00090	48 8d 44 24 70	 lea	 rax, QWORD PTR src_dir_fd$[rsp]
  00095	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_converter
  000a1	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000a6	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR dst$[rsp]
  000ae	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  000ba	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000bf	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR src$[rsp]
  000c7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  000d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_link@@9@9
  000df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@JCPNGPIG@O?$CGO?$CG?$HMO?$CGO?$CGp?3link?$AA@
  000e6	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  000ee	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000f6	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000fb	85 c0		 test	 eax, eax
  000fd	75 07		 jne	 SHORT $LN9@posix_link

; 3367 :         return NULL;

  000ff	33 c0		 xor	 eax, eax
  00101	e9 39 01 00 00	 jmp	 $LN10@posix_link
$LN9@posix_link:

; 3368 : 
; 3369 : #ifndef HAVE_LINKAT
; 3370 :     if ((src_dir_fd != DEFAULT_DIR_FD) || (dst_dir_fd != DEFAULT_DIR_FD)) {

  00106	83 7c 24 70 9c	 cmp	 DWORD PTR src_dir_fd$[rsp], -100 ; ffffffffffffff9cH
  0010b	75 0a		 jne	 SHORT $LN7@posix_link
  0010d	83 bc 24 d8 00
	00 00 9c	 cmp	 DWORD PTR dst_dir_fd$[rsp], -100 ; ffffffffffffff9cH
  00115	74 18		 je	 SHORT $LN8@posix_link
$LN7@posix_link:

; 3371 :         argument_unavailable_error("link", "src_dir_fd and dst_dir_fd");

  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@OIHNMKCA@src_dir_fd?5and?5dst_dir_fd?$AA@
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04OHHBHOGB@link?$AA@
  00125	e8 00 00 00 00	 call	 argument_unavailable_error

; 3372 :         goto exit;

  0012a	e9 ee 00 00 00	 jmp	 $exit$122216
$LN8@posix_link:

; 3373 :     }
; 3374 : #endif
; 3375 : 
; 3376 :     if ((src.narrow && dst.wide) || (src.wide && dst.narrow)) {

  0012f	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR src$[rsp+32], 0
  00138	74 0b		 je	 SHORT $LN4@posix_link
  0013a	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR dst$[rsp+24], 0
  00143	75 16		 jne	 SHORT $LN5@posix_link
$LN4@posix_link:
  00145	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR src$[rsp+24], 0
  0014e	74 23		 je	 SHORT $LN6@posix_link
  00150	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dst$[rsp+32], 0
  00159	74 18		 je	 SHORT $LN6@posix_link
$LN5@posix_link:

; 3377 :         PyErr_SetString(PyExc_NotImplementedError,
; 3378 :                         "link: src and dst must be the same type");

  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@HNKNKFGO@link?3?5src?5and?5dst?5must?5be?5the?5sa@
  00162	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00169	e8 00 00 00 00	 call	 PyErr_SetString

; 3379 :         goto exit;

  0016e	e9 aa 00 00 00	 jmp	 $exit$122216
$LN6@posix_link:

; 3380 :     }
; 3381 : 
; 3382 : #ifdef MS_WINDOWS
; 3383 :     Py_BEGIN_ALLOW_THREADS

  00173	e8 00 00 00 00	 call	 PyEval_SaveThread
  00178	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR _save$122221[rsp], rax

; 3384 :     if (src.wide)

  00180	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR src$[rsp+24], 0
  00189	74 22		 je	 SHORT $LN3@posix_link

; 3385 :         result = CreateHardLinkW(dst.wide, src.wide, NULL);

  0018b	45 33 c0	 xor	 r8d, r8d
  0018e	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR src$[rsp+24]
  00196	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dst$[rsp+24]
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateHardLinkW
  001a4	89 84 24 e0 00
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 3386 :     else

  001ab	eb 20		 jmp	 SHORT $LN2@posix_link
$LN3@posix_link:

; 3387 :         result = CreateHardLinkA(dst.narrow, src.narrow, NULL);

  001ad	45 33 c0	 xor	 r8d, r8d
  001b0	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR src$[rsp+32]
  001b8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dst$[rsp+32]
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateHardLinkA
  001c6	89 84 24 e0 00
	00 00		 mov	 DWORD PTR result$[rsp], eax
$LN2@posix_link:

; 3388 :     Py_END_ALLOW_THREADS

  001cd	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR _save$122221[rsp]
  001d5	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3389 : 
; 3390 :     if (!result) {

  001da	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR result$[rsp], 0
  001e2	75 1e		 jne	 SHORT $LN1@posix_link

; 3391 :         return_value = win32_error_object("link", dst.object);

  001e4	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR dst$[rsp+56]
  001ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04OHHBHOGB@link?$AA@
  001f3	e8 00 00 00 00	 call	 win32_error_object
  001f8	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR return_value$[rsp], rax

; 3392 :         goto exit;

  00200	eb 1b		 jmp	 SHORT $exit$122216
$LN1@posix_link:

; 3393 :     }
; 3394 : #else
; 3395 :     Py_BEGIN_ALLOW_THREADS
; 3396 : #ifdef HAVE_LINKAT
; 3397 :     if ((src_dir_fd != DEFAULT_DIR_FD) ||
; 3398 :         (dst_dir_fd != DEFAULT_DIR_FD) ||
; 3399 :         (!follow_symlinks))
; 3400 :         result = linkat(src_dir_fd, src.narrow,
; 3401 :             dst_dir_fd, dst.narrow,
; 3402 :             follow_symlinks ? AT_SYMLINK_FOLLOW : 0);
; 3403 :     else
; 3404 : #endif
; 3405 :         result = link(src.narrow, dst.narrow);
; 3406 :     Py_END_ALLOW_THREADS
; 3407 : 
; 3408 :     if (result) {
; 3409 :         return_value = path_error("link", &dst);
; 3410 :         goto exit;
; 3411 :     }
; 3412 : #endif
; 3413 : 
; 3414 :     return_value = Py_None;

  00202	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00209	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR return_value$[rsp], rax

; 3415 :     Py_INCREF(Py_None);

  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00218	e8 00 00 00 00	 call	 _Py_IncRef
$exit$122216:

; 3416 : 
; 3417 : exit:
; 3418 :     path_cleanup(&src);

  0021d	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR src$[rsp]
  00225	e8 00 00 00 00	 call	 path_cleanup

; 3419 :     path_cleanup(&dst);

  0022a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR dst$[rsp]
  00232	e8 00 00 00 00	 call	 path_cleanup

; 3420 :     return return_value;

  00237	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR return_value$[rsp]
$LN10@posix_link:

; 3421 : }

  0023f	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  00246	c3		 ret	 0
posix_link ENDP
_TEXT	ENDS
PUBLIC	??_C@_09DNPPEBNO@FindClose?$AA@			; `string'
PUBLIC	??_C@_0N@ILADKHLB@FindNextFile?$AA@		; `string'
PUBLIC	??_C@_02DJGKEECL@?4?4?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0O@DHMPFLDH@FindFirstFile?$AA@		; `string'
PUBLIC	??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@		; `string'
PUBLIC	??_C@_0O@EJBHELCO@FindNextFileW?$AA@		; `string'
PUBLIC	??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@		; `string'
PUBLIC	??_C@_0P@ENHAKBMH@FindFirstFileW?$AA@		; `string'
PUBLIC	??_C@_17ECHFBE@?$AA?$CK?$AA?4?$AA?$CK?$AA?$AA@	; `string'
PUBLIC	??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@		; `string'
PUBLIC	??_C@_0M@OPEDCPDK@?$HMO?$CG?3listdir?$AA@	; `string'
EXTRN	__imp_FindNextFileA:PROC
EXTRN	PyBytes_FromString:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	__imp_FindNextFileW:PROC
EXTRN	PyList_Append:PROC
EXTRN	__imp_wcscmp:PROC
EXTRN	PyList_New:PROC
EXTRN	__imp_wcscpy:PROC
EXTRN	__imp_wcslen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_listdir DD imagerel posix_listdir
	DD	imagerel posix_listdir+1810
	DD	imagerel $unwind$posix_listdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_listdir DD 021601H
	DD	0b90116H
xdata	ENDS
;	COMDAT ??_C@_09DNPPEBNO@FindClose?$AA@
CONST	SEGMENT
??_C@_09DNPPEBNO@FindClose?$AA@ DB 'FindClose', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ILADKHLB@FindNextFile?$AA@
CONST	SEGMENT
??_C@_0N@ILADKHLB@FindNextFile?$AA@ DB 'FindNextFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DJGKEECL@?4?4?$AA@
CONST	SEGMENT
??_C@_02DJGKEECL@?4?4?$AA@ DB '..', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DHMPFLDH@FindFirstFile?$AA@
CONST	SEGMENT
??_C@_0O@DHMPFLDH@FindFirstFile?$AA@ DB 'FindFirstFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@
CONST	SEGMENT
??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@ DB '*.*', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EJBHELCO@FindNextFileW?$AA@
CONST	SEGMENT
??_C@_0O@EJBHELCO@FindNextFileW?$AA@ DB 'FindNextFileW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@
CONST	SEGMENT
??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@ DB '.', 00H, '.', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@ENHAKBMH@FindFirstFileW?$AA@
CONST	SEGMENT
??_C@_0P@ENHAKBMH@FindFirstFileW?$AA@ DB 'FindFirstFileW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17ECHFBE@?$AA?$CK?$AA?4?$AA?$CK?$AA?$AA@
CONST	SEGMENT
??_C@_17ECHFBE@?$AA?$CK?$AA?4?$AA?$CK?$AA?$AA@ DB '*', 00H, '.', 00H, '*', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@
CONST	SEGMENT
??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@ DB '.', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OPEDCPDK@?$HMO?$CG?3listdir?$AA@
CONST	SEGMENT
??_C@_0M@OPEDCPDK@?$HMO?$CG?3listdir?$AA@ DB '|O&:listdir', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_listdir
_TEXT	SEGMENT
v$ = 48
hFindFile$ = 56
FileData$ = 64
len$ = 384
namebuf$ = 400
list$ = 672
wnamebuf$ = 680
po$ = 688
result$ = 696
bufptr$ = 704
path$ = 720
po_wchars$122261 = 800
wFileData$122260 = 816
wch$122269 = 1408
_save$122274 = 1416
error$122278 = 1424
_save$122297 = 1432
ch$122302 = 1440
_save$122308 = 1448
error$122312 = 1456
_save$122331 = 1464
self$ = 1488
args$ = 1496
kwargs$ = 1504
posix_listdir PROC					; COMDAT

; 3441 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 05
	00 00		 sub	 rsp, 1480		; 000005c8H

; 3442 :     path_t path;
; 3443 :     PyObject *list = NULL;

  00016	48 c7 84 24 a0
	02 00 00 00 00
	00 00		 mov	 QWORD PTR list$[rsp], 0

; 3444 :     static char *keywords[] = {"path", NULL};
; 3445 : #ifdef HAVE_FDOPENDIR
; 3446 :     int fd = -1;
; 3447 : #endif /* HAVE_FDOPENDIR */
; 3448 : 
; 3449 : #if defined(MS_WINDOWS) && !defined(HAVE_OPENDIR)
; 3450 :     PyObject *v;
; 3451 :     HANDLE hFindFile = INVALID_HANDLE_VALUE;

  00022	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR hFindFile$[rsp], -1

; 3452 :     BOOL result;
; 3453 :     WIN32_FIND_DATA FileData;
; 3454 :     char namebuf[MAX_PATH+5]; /* Overallocate for \\*.*\0 */
; 3455 :     char *bufptr = namebuf;

  0002b	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR namebuf$[rsp]
  00033	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR bufptr$[rsp], rax

; 3456 :     /* only claim to have space for MAX_PATH */
; 3457 :     Py_ssize_t len = sizeof(namebuf)-5;

  0003b	48 c7 84 24 80
	01 00 00 04 01
	00 00		 mov	 QWORD PTR len$[rsp], 260 ; 00000104H

; 3458 :     PyObject *po = NULL;

  00047	48 c7 84 24 b0
	02 00 00 00 00
	00 00		 mov	 QWORD PTR po$[rsp], 0

; 3459 :     wchar_t *wnamebuf = NULL;

  00053	48 c7 84 24 a8
	02 00 00 00 00
	00 00		 mov	 QWORD PTR wnamebuf$[rsp], 0

; 3460 : #elif defined(PYOS_OS2)
; 3461 : #ifndef MAX_PATH
; 3462 : #define MAX_PATH    CCHMAXPATH
; 3463 : #endif
; 3464 :     char *pt;
; 3465 :     PyObject *v;
; 3466 :     char namebuf[MAX_PATH+5];
; 3467 :     HDIR  hdir = 1;
; 3468 :     ULONG srchcnt = 1;
; 3469 :     FILEFINDBUF3   ep;
; 3470 :     APIRET rc;
; 3471 : #else
; 3472 :     PyObject *v;
; 3473 :     DIR *dirp = NULL;
; 3474 :     struct dirent *ep;
; 3475 :     int return_str; /* if false, return bytes */
; 3476 : #endif
; 3477 : 
; 3478 :     memset(&path, 0, sizeof(path));

  0005f	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00065	33 d2		 xor	 edx, edx
  00067	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  0006f	e8 00 00 00 00	 call	 memset

; 3479 :     path.nullable = 1;

  00074	c7 84 24 e0 02
	00 00 01 00 00
	00		 mov	 DWORD PTR path$[rsp+16], 1

; 3480 : #ifdef HAVE_FDOPENDIR
; 3481 :     path.allow_fd = 1;
; 3482 :     path.fd = -1;
; 3483 : #endif
; 3484 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O&:listdir", keywords,
; 3485 :         path_converter, &path
; 3486 :         ))

  0007f	48 8d 84 24 d0
	02 00 00	 lea	 rax, QWORD PTR path$[rsp]
  00087	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  00093	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00098	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_listdir@@9@9
  0009f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@OPEDCPDK@?$HMO?$CG?3listdir?$AA@
  000a6	48 8b 94 24 e0
	05 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  000ae	48 8b 8c 24 d8
	05 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000b6	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000bb	85 c0		 test	 eax, eax
  000bd	75 07		 jne	 SHORT $LN33@posix_list

; 3487 :         return NULL;

  000bf	33 c0		 xor	 eax, eax
  000c1	e9 44 06 00 00	 jmp	 $LN34@posix_list
$LN33@posix_list:

; 3488 : 
; 3489 :     /* XXX Should redo this putting the (now four) versions of opendir
; 3490 :        in separate files instead of having them all here... */
; 3491 : #if defined(MS_WINDOWS) && !defined(HAVE_OPENDIR)
; 3492 :     if (!path.narrow) {

  000c6	48 83 bc 24 f0
	02 00 00 00	 cmp	 QWORD PTR path$[rsp+32], 0
  000cf	0f 85 39 03 00
	00		 jne	 $LN32@posix_list

; 3493 :         WIN32_FIND_DATAW wFileData;
; 3494 :         wchar_t *po_wchars;
; 3495 : 
; 3496 :         if (!path.wide) { /* Default arg: "." */

  000d5	48 83 bc 24 e8
	02 00 00 00	 cmp	 QWORD PTR path$[rsp+24], 0
  000de	75 1d		 jne	 SHORT $LN31@posix_list

; 3497 :             po_wchars = L".";

  000e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@
  000e7	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR po_wchars$122261[rsp], rax

; 3498 :             len = 1;

  000ef	48 c7 84 24 80
	01 00 00 01 00
	00 00		 mov	 QWORD PTR len$[rsp], 1

; 3499 :         } else {

  000fb	eb 26		 jmp	 SHORT $LN30@posix_list
$LN31@posix_list:

; 3500 :             po_wchars = path.wide;

  000fd	48 8b 84 24 e8
	02 00 00	 mov	 rax, QWORD PTR path$[rsp+24]
  00105	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR po_wchars$122261[rsp], rax

; 3501 :             len = wcslen(path.wide);

  0010d	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR path$[rsp+24]
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  0011b	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR len$[rsp], rax
$LN30@posix_list:

; 3502 :         }
; 3503 :         /* The +5 is so we can append "\\*.*\0" */
; 3504 :         wnamebuf = malloc((len + 5) * sizeof(wchar_t));

  00123	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0012b	48 8d 44 00 0a	 lea	 rax, QWORD PTR [rax+rax+10]
  00130	48 8b c8	 mov	 rcx, rax
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00139	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR wnamebuf$[rsp], rax

; 3505 :         if (!wnamebuf) {

  00141	48 83 bc 24 a8
	02 00 00 00	 cmp	 QWORD PTR wnamebuf$[rsp], 0
  0014a	75 0a		 jne	 SHORT $LN29@posix_list

; 3506 :             PyErr_NoMemory();

  0014c	e8 00 00 00 00	 call	 PyErr_NoMemory

; 3507 :             goto exit;

  00151	e9 3b 05 00 00	 jmp	 $exit$122267
$LN29@posix_list:

; 3508 :         }
; 3509 :         wcscpy(wnamebuf, po_wchars);

  00156	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR po_wchars$122261[rsp]
  0015e	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR wnamebuf$[rsp]
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 3510 :         if (len > 0) {

  0016c	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR len$[rsp], 0
  00175	0f 8e 94 00 00
	00		 jle	 $LN28@posix_list

; 3511 :             wchar_t wch = wnamebuf[len-1];

  0017b	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR wnamebuf$[rsp]
  00183	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  0018b	0f b7 44 48 fe	 movzx	 eax, WORD PTR [rax+rcx*2-2]
  00190	66 89 84 24 80
	05 00 00	 mov	 WORD PTR wch$122269[rsp], ax

; 3512 :             if (wch != L'/' && wch != L'\\' && wch != L':')

  00198	0f b7 84 24 80
	05 00 00	 movzx	 eax, WORD PTR wch$122269[rsp]
  001a0	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  001a3	74 46		 je	 SHORT $LN27@posix_list
  001a5	0f b7 84 24 80
	05 00 00	 movzx	 eax, WORD PTR wch$122269[rsp]
  001ad	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  001b0	74 39		 je	 SHORT $LN27@posix_list
  001b2	0f b7 84 24 80
	05 00 00	 movzx	 eax, WORD PTR wch$122269[rsp]
  001ba	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  001bd	74 2c		 je	 SHORT $LN27@posix_list

; 3513 :                 wnamebuf[len++] = L'\\';

  001bf	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  001c4	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR wnamebuf$[rsp]
  001cc	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR len$[rsp]
  001d4	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  001d8	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len$[rsp]
  001e0	48 ff c0	 inc	 rax
  001e3	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR len$[rsp], rax
$LN27@posix_list:

; 3514 :             wcscpy(wnamebuf + len, L"*.*");

  001eb	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR wnamebuf$[rsp]
  001f3	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  001fb	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  001ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_17ECHFBE@?$AA?$CK?$AA?4?$AA?$CK?$AA?$AA@
  00206	48 8b c8	 mov	 rcx, rax
  00209	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy
$LN28@posix_list:

; 3515 :         }
; 3516 :         if ((list = PyList_New(0)) == NULL) {

  0020f	33 c9		 xor	 ecx, ecx
  00211	e8 00 00 00 00	 call	 PyList_New
  00216	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR list$[rsp], rax
  0021e	48 83 bc 24 a0
	02 00 00 00	 cmp	 QWORD PTR list$[rsp], 0
  00227	75 05		 jne	 SHORT $LN26@posix_list

; 3517 :             goto exit;

  00229	e9 63 04 00 00	 jmp	 $exit$122267
$LN26@posix_list:

; 3518 :         }
; 3519 :         Py_BEGIN_ALLOW_THREADS

  0022e	e8 00 00 00 00	 call	 PyEval_SaveThread
  00233	48 89 84 24 88
	05 00 00	 mov	 QWORD PTR _save$122274[rsp], rax

; 3520 :         hFindFile = FindFirstFileW(wnamebuf, &wFileData);

  0023b	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR wFileData$122260[rsp]
  00243	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR wnamebuf$[rsp]
  0024b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileW
  00251	48 89 44 24 38	 mov	 QWORD PTR hFindFile$[rsp], rax

; 3521 :         Py_END_ALLOW_THREADS

  00256	48 8b 8c 24 88
	05 00 00	 mov	 rcx, QWORD PTR _save$122274[rsp]
  0025e	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3522 :         if (hFindFile == INVALID_HANDLE_VALUE) {

  00263	48 83 7c 24 38
	ff		 cmp	 QWORD PTR hFindFile$[rsp], -1
  00269	75 4e		 jne	 SHORT $LN25@posix_list

; 3523 :             int error = GetLastError();

  0026b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00271	89 84 24 90 05
	00 00		 mov	 DWORD PTR error$122278[rsp], eax

; 3524 :             if (error == ERROR_FILE_NOT_FOUND)

  00278	83 bc 24 90 05
	00 00 02	 cmp	 DWORD PTR error$122278[rsp], 2
  00280	75 05		 jne	 SHORT $LN24@posix_list

; 3525 :                 goto exit;

  00282	e9 0a 04 00 00	 jmp	 $exit$122267
$LN24@posix_list:

; 3526 :             Py_DECREF(list);

  00287	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  0028f	e8 00 00 00 00	 call	 _Py_DecRef

; 3527 :             list = NULL;

  00294	48 c7 84 24 a0
	02 00 00 00 00
	00 00		 mov	 QWORD PTR list$[rsp], 0

; 3528 :             win32_error_unicode("FindFirstFileW", wnamebuf);

  002a0	48 8b 94 24 a8
	02 00 00	 mov	 rdx, QWORD PTR wnamebuf$[rsp]
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@ENHAKBMH@FindFirstFileW?$AA@
  002af	e8 00 00 00 00	 call	 win32_error_unicode

; 3529 :             goto exit;

  002b4	e9 d8 03 00 00	 jmp	 $exit$122267
$LN25@posix_list:
$LN23@posix_list:

; 3530 :         }
; 3531 :         do {
; 3532 :             /* Skip over . and .. */
; 3533 :             if (wcscmp(wFileData.cFileName, L".") != 0 &&
; 3534 :                 wcscmp(wFileData.cFileName, L"..") != 0) {

  002b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_13JOFGPIOO@?$AA?4?$AA?$AA@
  002c0	48 8d 8c 24 5c
	03 00 00	 lea	 rcx, QWORD PTR wFileData$122260[rsp+44]
  002c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscmp
  002ce	85 c0		 test	 eax, eax
  002d0	0f 84 ae 00 00
	00		 je	 $LN20@posix_list
  002d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_15DDHGOCBH@?$AA?4?$AA?4?$AA?$AA@
  002dd	48 8d 8c 24 5c
	03 00 00	 lea	 rcx, QWORD PTR wFileData$122260[rsp+44]
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscmp
  002eb	85 c0		 test	 eax, eax
  002ed	0f 84 91 00 00
	00		 je	 $LN20@posix_list

; 3535 :                 v = PyUnicode_FromWideChar(wFileData.cFileName,
; 3536 :                                            wcslen(wFileData.cFileName));

  002f3	48 8d 8c 24 5c
	03 00 00	 lea	 rcx, QWORD PTR wFileData$122260[rsp+44]
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00301	48 8b d0	 mov	 rdx, rax
  00304	48 8d 8c 24 5c
	03 00 00	 lea	 rcx, QWORD PTR wFileData$122260[rsp+44]
  0030c	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  00311	48 89 44 24 30	 mov	 QWORD PTR v$[rsp], rax

; 3537 :                 if (v == NULL) {

  00316	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$[rsp], 0
  0031c	75 1e		 jne	 SHORT $LN19@posix_list

; 3538 :                     Py_DECREF(list);

  0031e	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  00326	e8 00 00 00 00	 call	 _Py_DecRef

; 3539 :                     list = NULL;

  0032b	48 c7 84 24 a0
	02 00 00 00 00
	00 00		 mov	 QWORD PTR list$[rsp], 0

; 3540 :                     break;

  00337	e9 cd 00 00 00	 jmp	 $LN21@posix_list
$LN19@posix_list:

; 3541 :                 }
; 3542 :                 if (PyList_Append(list, v) != 0) {

  0033c	48 8b 54 24 30	 mov	 rdx, QWORD PTR v$[rsp]
  00341	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  00349	e8 00 00 00 00	 call	 PyList_Append
  0034e	85 c0		 test	 eax, eax
  00350	74 28		 je	 SHORT $LN18@posix_list

; 3543 :                     Py_DECREF(v);

  00352	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00357	e8 00 00 00 00	 call	 _Py_DecRef

; 3544 :                     Py_DECREF(list);

  0035c	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  00364	e8 00 00 00 00	 call	 _Py_DecRef

; 3545 :                     list = NULL;

  00369	48 c7 84 24 a0
	02 00 00 00 00
	00 00		 mov	 QWORD PTR list$[rsp], 0

; 3546 :                     break;

  00375	e9 8f 00 00 00	 jmp	 $LN21@posix_list
$LN18@posix_list:

; 3547 :                 }
; 3548 :                 Py_DECREF(v);

  0037a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0037f	e8 00 00 00 00	 call	 _Py_DecRef
$LN20@posix_list:

; 3549 :             }
; 3550 :             Py_BEGIN_ALLOW_THREADS

  00384	e8 00 00 00 00	 call	 PyEval_SaveThread
  00389	48 89 84 24 98
	05 00 00	 mov	 QWORD PTR _save$122297[rsp], rax

; 3551 :             result = FindNextFileW(hFindFile, &wFileData);

  00391	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR wFileData$122260[rsp]
  00399	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hFindFile$[rsp]
  0039e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindNextFileW
  003a4	89 84 24 b8 02
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 3552 :             Py_END_ALLOW_THREADS

  003ab	48 8b 8c 24 98
	05 00 00	 mov	 rcx, QWORD PTR _save$122297[rsp]
  003b3	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3553 :             /* FindNextFile sets error to ERROR_NO_MORE_FILES if
; 3554 :                it got to the end of the directory. */
; 3555 :             if (!result && GetLastError() != ERROR_NO_MORE_FILES) {

  003b8	83 bc 24 b8 02
	00 00 00	 cmp	 DWORD PTR result$[rsp], 0
  003c0	75 39		 jne	 SHORT $LN17@posix_list
  003c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  003c8	83 f8 12	 cmp	 eax, 18
  003cb	74 2e		 je	 SHORT $LN17@posix_list

; 3556 :                 Py_DECREF(list);

  003cd	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  003d5	e8 00 00 00 00	 call	 _Py_DecRef

; 3557 :                 list = win32_error_unicode("FindNextFileW", wnamebuf);

  003da	48 8b 94 24 a8
	02 00 00	 mov	 rdx, QWORD PTR wnamebuf$[rsp]
  003e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@EJBHELCO@FindNextFileW?$AA@
  003e9	e8 00 00 00 00	 call	 win32_error_unicode
  003ee	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR list$[rsp], rax

; 3558 :                 goto exit;

  003f6	e9 96 02 00 00	 jmp	 $exit$122267
$LN17@posix_list:

; 3559 :             }
; 3560 :         } while (result == TRUE);

  003fb	83 bc 24 b8 02
	00 00 01	 cmp	 DWORD PTR result$[rsp], 1
  00403	0f 84 b0 fe ff
	ff		 je	 $LN23@posix_list
$LN21@posix_list:

; 3561 : 
; 3562 :         goto exit;

  00409	e9 83 02 00 00	 jmp	 $exit$122267
$LN32@posix_list:

; 3563 :     }
; 3564 :     strcpy(namebuf, path.narrow);

  0040e	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR path$[rsp+32]
  00416	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR namebuf$[rsp]
  0041e	e8 00 00 00 00	 call	 strcpy

; 3565 :     len = path.length;

  00423	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR path$[rsp+48]
  0042b	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR len$[rsp], rax

; 3566 :     if (len > 0) {

  00433	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR len$[rsp], 0
  0043c	0f 8e 80 00 00
	00		 jle	 $LN16@posix_list

; 3567 :         char ch = namebuf[len-1];

  00442	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0044a	0f b6 84 04 8f
	01 00 00	 movzx	 eax, BYTE PTR namebuf$[rsp+rax-1]
  00452	88 84 24 a0 05
	00 00		 mov	 BYTE PTR ch$122302[rsp], al

; 3568 :         if (ch != SEP && ch != ALTSEP && ch != ':')

  00459	0f be 84 24 a0
	05 00 00	 movsx	 eax, BYTE PTR ch$122302[rsp]
  00461	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00464	74 3d		 je	 SHORT $LN15@posix_list
  00466	0f be 84 24 a0
	05 00 00	 movsx	 eax, BYTE PTR ch$122302[rsp]
  0046e	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00471	74 30		 je	 SHORT $LN15@posix_list
  00473	0f be 84 24 a0
	05 00 00	 movsx	 eax, BYTE PTR ch$122302[rsp]
  0047b	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0047e	74 23		 je	 SHORT $LN15@posix_list

; 3569 :             namebuf[len++] = '/';

  00480	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len$[rsp]
  00488	c6 84 04 90 01
	00 00 2f	 mov	 BYTE PTR namebuf$[rsp+rax], 47 ; 0000002fH
  00490	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len$[rsp]
  00498	48 ff c0	 inc	 rax
  0049b	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR len$[rsp], rax
$LN15@posix_list:

; 3570 :         strcpy(namebuf + len, "*.*");

  004a3	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR len$[rsp]
  004ab	48 8d 84 04 90
	01 00 00	 lea	 rax, QWORD PTR namebuf$[rsp+rax]
  004b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03EMIMMIHL@?$CK?4?$CK?$AA@
  004ba	48 8b c8	 mov	 rcx, rax
  004bd	e8 00 00 00 00	 call	 strcpy
$LN16@posix_list:

; 3571 :     }
; 3572 : 
; 3573 :     if ((list = PyList_New(0)) == NULL)

  004c2	33 c9		 xor	 ecx, ecx
  004c4	e8 00 00 00 00	 call	 PyList_New
  004c9	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR list$[rsp], rax
  004d1	48 83 bc 24 a0
	02 00 00 00	 cmp	 QWORD PTR list$[rsp], 0
  004da	75 07		 jne	 SHORT $LN14@posix_list

; 3574 :         return NULL;

  004dc	33 c0		 xor	 eax, eax
  004de	e9 27 02 00 00	 jmp	 $LN34@posix_list
$LN14@posix_list:

; 3575 : 
; 3576 :     Py_BEGIN_ALLOW_THREADS

  004e3	e8 00 00 00 00	 call	 PyEval_SaveThread
  004e8	48 89 84 24 a8
	05 00 00	 mov	 QWORD PTR _save$122308[rsp], rax

; 3577 :     hFindFile = FindFirstFile(namebuf, &FileData);

  004f0	48 8d 54 24 40	 lea	 rdx, QWORD PTR FileData$[rsp]
  004f5	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR namebuf$[rsp]
  004fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileA
  00503	48 89 44 24 38	 mov	 QWORD PTR hFindFile$[rsp], rax

; 3578 :     Py_END_ALLOW_THREADS

  00508	48 8b 8c 24 a8
	05 00 00	 mov	 rcx, QWORD PTR _save$122308[rsp]
  00510	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3579 :     if (hFindFile == INVALID_HANDLE_VALUE) {

  00515	48 83 7c 24 38
	ff		 cmp	 QWORD PTR hFindFile$[rsp], -1
  0051b	75 4a		 jne	 SHORT $LN13@posix_list

; 3580 :         int error = GetLastError();

  0051d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00523	89 84 24 b0 05
	00 00		 mov	 DWORD PTR error$122312[rsp], eax

; 3581 :         if (error == ERROR_FILE_NOT_FOUND)

  0052a	83 bc 24 b0 05
	00 00 02	 cmp	 DWORD PTR error$122312[rsp], 2
  00532	75 05		 jne	 SHORT $LN12@posix_list

; 3582 :             goto exit;

  00534	e9 58 01 00 00	 jmp	 $exit$122267
$LN12@posix_list:

; 3583 :         Py_DECREF(list);

  00539	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  00541	e8 00 00 00 00	 call	 _Py_DecRef

; 3584 :         list = win32_error("FindFirstFile", namebuf);

  00546	48 8d 94 24 90
	01 00 00	 lea	 rdx, QWORD PTR namebuf$[rsp]
  0054e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@DHMPFLDH@FindFirstFile?$AA@
  00555	e8 00 00 00 00	 call	 win32_error
  0055a	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR list$[rsp], rax

; 3585 :         goto exit;

  00562	e9 2a 01 00 00	 jmp	 $exit$122267
$LN13@posix_list:
$LN11@posix_list:

; 3586 :     }
; 3587 :     do {
; 3588 :         /* Skip over . and .. */
; 3589 :         if (strcmp(FileData.cFileName, ".") != 0 &&
; 3590 :             strcmp(FileData.cFileName, "..") != 0) {

  00567	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LFCBOECM@?4?$AA@
  0056e	48 8d 4c 24 6c	 lea	 rcx, QWORD PTR FileData$[rsp+44]
  00573	e8 00 00 00 00	 call	 strcmp
  00578	85 c0		 test	 eax, eax
  0057a	0f 84 92 00 00
	00		 je	 $LN8@posix_list
  00580	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DJGKEECL@?4?4?$AA@
  00587	48 8d 4c 24 6c	 lea	 rcx, QWORD PTR FileData$[rsp+44]
  0058c	e8 00 00 00 00	 call	 strcmp
  00591	85 c0		 test	 eax, eax
  00593	74 7d		 je	 SHORT $LN8@posix_list

; 3591 :             v = PyBytes_FromString(FileData.cFileName);

  00595	48 8d 4c 24 6c	 lea	 rcx, QWORD PTR FileData$[rsp+44]
  0059a	e8 00 00 00 00	 call	 PyBytes_FromString
  0059f	48 89 44 24 30	 mov	 QWORD PTR v$[rsp], rax

; 3592 :             if (v == NULL) {

  005a4	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$[rsp], 0
  005aa	75 1e		 jne	 SHORT $LN7@posix_list

; 3593 :                 Py_DECREF(list);

  005ac	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  005b4	e8 00 00 00 00	 call	 _Py_DecRef

; 3594 :                 list = NULL;

  005b9	48 c7 84 24 a0
	02 00 00 00 00
	00 00		 mov	 QWORD PTR list$[rsp], 0

; 3595 :                 break;

  005c5	e9 c7 00 00 00	 jmp	 $LN9@posix_list
$LN7@posix_list:

; 3596 :             }
; 3597 :             if (PyList_Append(list, v) != 0) {

  005ca	48 8b 54 24 30	 mov	 rdx, QWORD PTR v$[rsp]
  005cf	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  005d7	e8 00 00 00 00	 call	 PyList_Append
  005dc	85 c0		 test	 eax, eax
  005de	74 28		 je	 SHORT $LN6@posix_list

; 3598 :                 Py_DECREF(v);

  005e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  005e5	e8 00 00 00 00	 call	 _Py_DecRef

; 3599 :                 Py_DECREF(list);

  005ea	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  005f2	e8 00 00 00 00	 call	 _Py_DecRef

; 3600 :                 list = NULL;

  005f7	48 c7 84 24 a0
	02 00 00 00 00
	00 00		 mov	 QWORD PTR list$[rsp], 0

; 3601 :                 break;

  00603	e9 89 00 00 00	 jmp	 $LN9@posix_list
$LN6@posix_list:

; 3602 :             }
; 3603 :             Py_DECREF(v);

  00608	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0060d	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@posix_list:

; 3604 :         }
; 3605 :         Py_BEGIN_ALLOW_THREADS

  00612	e8 00 00 00 00	 call	 PyEval_SaveThread
  00617	48 89 84 24 b8
	05 00 00	 mov	 QWORD PTR _save$122331[rsp], rax

; 3606 :         result = FindNextFile(hFindFile, &FileData);

  0061f	48 8d 54 24 40	 lea	 rdx, QWORD PTR FileData$[rsp]
  00624	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hFindFile$[rsp]
  00629	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindNextFileA
  0062f	89 84 24 b8 02
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 3607 :         Py_END_ALLOW_THREADS

  00636	48 8b 8c 24 b8
	05 00 00	 mov	 rcx, QWORD PTR _save$122331[rsp]
  0063e	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 3608 :         /* FindNextFile sets error to ERROR_NO_MORE_FILES if
; 3609 :            it got to the end of the directory. */
; 3610 :         if (!result && GetLastError() != ERROR_NO_MORE_FILES) {

  00643	83 bc 24 b8 02
	00 00 00	 cmp	 DWORD PTR result$[rsp], 0
  0064b	75 36		 jne	 SHORT $LN5@posix_list
  0064d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00653	83 f8 12	 cmp	 eax, 18
  00656	74 2b		 je	 SHORT $LN5@posix_list

; 3611 :             Py_DECREF(list);

  00658	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  00660	e8 00 00 00 00	 call	 _Py_DecRef

; 3612 :             list = win32_error("FindNextFile", namebuf);

  00665	48 8d 94 24 90
	01 00 00	 lea	 rdx, QWORD PTR namebuf$[rsp]
  0066d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@ILADKHLB@FindNextFile?$AA@
  00674	e8 00 00 00 00	 call	 win32_error
  00679	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR list$[rsp], rax

; 3613 :             goto exit;

  00681	eb 0e		 jmp	 SHORT $exit$122267
$LN5@posix_list:

; 3614 :         }
; 3615 :     } while (result == TRUE);

  00683	83 bc 24 b8 02
	00 00 01	 cmp	 DWORD PTR result$[rsp], 1
  0068b	0f 84 d6 fe ff
	ff		 je	 $LN11@posix_list
$LN9@posix_list:
$exit$122267:

; 3616 : 
; 3617 : exit:
; 3618 :     if (hFindFile != INVALID_HANDLE_VALUE) {

  00691	48 83 7c 24 38
	ff		 cmp	 QWORD PTR hFindFile$[rsp], -1
  00697	74 43		 je	 SHORT $LN4@posix_list

; 3619 :         if (FindClose(hFindFile) == FALSE) {

  00699	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hFindFile$[rsp]
  0069e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindClose
  006a4	85 c0		 test	 eax, eax
  006a6	75 34		 jne	 SHORT $LN3@posix_list

; 3620 :             if (list != NULL) {

  006a8	48 83 bc 24 a0
	02 00 00 00	 cmp	 QWORD PTR list$[rsp], 0
  006b1	74 29		 je	 SHORT $LN2@posix_list

; 3621 :                 Py_DECREF(list);

  006b3	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  006bb	e8 00 00 00 00	 call	 _Py_DecRef

; 3622 :                 list = win32_error_object("FindClose", path.object);

  006c0	48 8b 94 24 08
	03 00 00	 mov	 rdx, QWORD PTR path$[rsp+56]
  006c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09DNPPEBNO@FindClose?$AA@
  006cf	e8 00 00 00 00	 call	 win32_error_object
  006d4	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR list$[rsp], rax
$LN2@posix_list:
$LN3@posix_list:
$LN4@posix_list:

; 3623 :             }
; 3624 :         }
; 3625 :     }
; 3626 :     if (wnamebuf)

  006dc	48 83 bc 24 a8
	02 00 00 00	 cmp	 QWORD PTR wnamebuf$[rsp], 0
  006e5	74 0e		 je	 SHORT $LN1@posix_list

; 3627 :         free(wnamebuf);

  006e7	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR wnamebuf$[rsp]
  006ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@posix_list:

; 3628 :     path_cleanup(&path);

  006f5	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  006fd	e8 00 00 00 00	 call	 path_cleanup

; 3629 : 
; 3630 :     return list;

  00702	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR list$[rsp]
$LN34@posix_list:

; 3631 : 
; 3632 : #elif defined(PYOS_OS2)
; 3633 :     if (path.length >= MAX_PATH) {
; 3634 :         PyErr_SetString(PyExc_ValueError, "path too long");
; 3635 :         goto exit;
; 3636 :     }
; 3637 :     strcpy(namebuf, path.narrow);
; 3638 :     for (pt = namebuf; *pt; pt++)
; 3639 :         if (*pt == ALTSEP)
; 3640 :             *pt = SEP;
; 3641 :     if (namebuf[len-1] != SEP)
; 3642 :         namebuf[len++] = SEP;
; 3643 :     strcpy(namebuf + len, "*.*");
; 3644 : 
; 3645 :     if ((list = PyList_New(0)) == NULL) {
; 3646 :         goto exit;
; 3647 :     }
; 3648 : 
; 3649 :     rc = DosFindFirst(namebuf,         /* Wildcard Pattern to Match */
; 3650 :                       &hdir,           /* Handle to Use While Search Directory */
; 3651 :                       FILE_READONLY | FILE_HIDDEN | FILE_SYSTEM | FILE_DIRECTORY,
; 3652 :                       &ep, sizeof(ep), /* Structure to Receive Directory Entry */
; 3653 :                       &srchcnt,        /* Max and Actual Count of Entries Per Iteration */
; 3654 :                       FIL_STANDARD);   /* Format of Entry (EAs or Not) */
; 3655 : 
; 3656 :     if (rc != NO_ERROR) {
; 3657 :         errno = ENOENT;
; 3658 :         Py_DECREF(list);
; 3659 :         list = posix_error_with_filename(path.narrow);
; 3660 :         goto exit;
; 3661 :     }
; 3662 : 
; 3663 :     if (srchcnt > 0) { /* If Directory is NOT Totally Empty, */
; 3664 :         do {
; 3665 :             if (ep.achName[0] == '.'
; 3666 :             && (ep.achName[1] == '\0' || (ep.achName[1] == '.' && ep.achName[2] == '\0')))
; 3667 :                 continue; /* Skip Over "." and ".." Names */
; 3668 : 
; 3669 :             strcpy(namebuf, ep.achName);
; 3670 : 
; 3671 :             /* Leave Case of Name Alone -- In Native Form */
; 3672 :             /* (Removed Forced Lowercasing Code) */
; 3673 : 
; 3674 :             v = PyBytes_FromString(namebuf);
; 3675 :             if (v == NULL) {
; 3676 :                 Py_DECREF(list);
; 3677 :                 list = NULL;
; 3678 :                 break;
; 3679 :             }
; 3680 :             if (PyList_Append(list, v) != 0) {
; 3681 :                 Py_DECREF(v);
; 3682 :                 Py_DECREF(list);
; 3683 :                 list = NULL;
; 3684 :                 break;
; 3685 :             }
; 3686 :             Py_DECREF(v);
; 3687 :         } while (DosFindNext(hdir, &ep, sizeof(ep), &srchcnt) == NO_ERROR && srchcnt > 0);
; 3688 :     }
; 3689 : 
; 3690 : exit:
; 3691 :     path_cleanup(&path);
; 3692 : 
; 3693 :     return list;
; 3694 : #else
; 3695 : 
; 3696 :     errno = 0;
; 3697 : #ifdef HAVE_FDOPENDIR
; 3698 :     if (path.fd != -1) {
; 3699 :         /* closedir() closes the FD, so we duplicate it */
; 3700 :         Py_BEGIN_ALLOW_THREADS
; 3701 :         fd = dup(path.fd);
; 3702 :         Py_END_ALLOW_THREADS
; 3703 : 
; 3704 :         if (fd == -1) {
; 3705 :             list = posix_error();
; 3706 :             goto exit;
; 3707 :         }
; 3708 : 
; 3709 :         return_str = 1;
; 3710 : 
; 3711 :         Py_BEGIN_ALLOW_THREADS
; 3712 :         dirp = fdopendir(fd);
; 3713 :         Py_END_ALLOW_THREADS
; 3714 :     }
; 3715 :     else
; 3716 : #endif
; 3717 :     {
; 3718 :         char *name;
; 3719 :         if (path.narrow) {
; 3720 :             name = path.narrow;
; 3721 :             /* only return bytes if they specified a bytes object */
; 3722 :             return_str = !(PyBytes_Check(path.object));
; 3723 :         }
; 3724 :         else {
; 3725 :             name = ".";
; 3726 :             return_str = 1;
; 3727 :         }
; 3728 : 
; 3729 :         Py_BEGIN_ALLOW_THREADS
; 3730 :         dirp = opendir(name);
; 3731 :         Py_END_ALLOW_THREADS
; 3732 :     }
; 3733 : 
; 3734 :     if (dirp == NULL) {
; 3735 :         list = path_error("listdir", &path);
; 3736 : #ifdef HAVE_FDOPENDIR
; 3737 :         if (fd != -1) {
; 3738 :             Py_BEGIN_ALLOW_THREADS
; 3739 :             close(fd);
; 3740 :             Py_END_ALLOW_THREADS
; 3741 :         }
; 3742 : #endif /* HAVE_FDOPENDIR */
; 3743 :         goto exit;
; 3744 :     }
; 3745 :     if ((list = PyList_New(0)) == NULL) {
; 3746 :         goto exit;
; 3747 :     }
; 3748 :     for (;;) {
; 3749 :         errno = 0;
; 3750 :         Py_BEGIN_ALLOW_THREADS
; 3751 :         ep = readdir(dirp);
; 3752 :         Py_END_ALLOW_THREADS
; 3753 :         if (ep == NULL) {
; 3754 :             if (errno == 0) {
; 3755 :                 break;
; 3756 :             } else {
; 3757 :                 Py_DECREF(list);
; 3758 :                 list = path_error("listdir", &path);
; 3759 :                 goto exit;
; 3760 :             }
; 3761 :         }
; 3762 :         if (ep->d_name[0] == '.' &&
; 3763 :             (NAMLEN(ep) == 1 ||
; 3764 :              (ep->d_name[1] == '.' && NAMLEN(ep) == 2)))
; 3765 :             continue;
; 3766 :         if (return_str)
; 3767 :             v = PyUnicode_DecodeFSDefaultAndSize(ep->d_name, NAMLEN(ep));
; 3768 :         else
; 3769 :             v = PyBytes_FromStringAndSize(ep->d_name, NAMLEN(ep));
; 3770 :         if (v == NULL) {
; 3771 :             Py_CLEAR(list);
; 3772 :             break;
; 3773 :         }
; 3774 :         if (PyList_Append(list, v) != 0) {
; 3775 :             Py_DECREF(v);
; 3776 :             Py_CLEAR(list);
; 3777 :             break;
; 3778 :         }
; 3779 :         Py_DECREF(v);
; 3780 :     }
; 3781 : 
; 3782 : exit:
; 3783 :     if (dirp != NULL) {
; 3784 :         Py_BEGIN_ALLOW_THREADS
; 3785 : #ifdef HAVE_FDOPENDIR
; 3786 :         if (fd > -1)
; 3787 :             rewinddir(dirp);
; 3788 : #endif /* HAVE_FDOPENDIR */
; 3789 :         closedir(dirp);
; 3790 :         Py_END_ALLOW_THREADS
; 3791 :     }
; 3792 : 
; 3793 :     path_cleanup(&path);
; 3794 : 
; 3795 :     return list;
; 3796 : 
; 3797 : #endif /* which OS */
; 3798 : }  /* end of posix_listdir */

  0070a	48 81 c4 c8 05
	00 00		 add	 rsp, 1480		; 000005c8H
  00711	c3		 ret	 0
posix_listdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@NMGCAMAD@GetFullPathName?$AA@		; `string'
PUBLIC	??_C@_0BD@EGNIMBAG@y?3_getfullpathname?$AA@	; `string'
PUBLIC	??_C@_0BB@GMCPPICF@GetFullPathNameW?$AA@	; `string'
PUBLIC	??_C@_0BE@FDDLMFHC@U?$HM?3_getfullpathname?$AA@	; `string'
EXTRN	PyUnicode_Decode:PROC
EXTRN	Py_FileSystemDefaultEncoding:QWORD
EXTRN	PyTuple_GetItem:PROC
EXTRN	__imp_GetFullPathNameA:PROC
EXTRN	__imp_GetFullPathNameW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix__getfullpathname DD imagerel posix__getfullpathname
	DD	imagerel posix__getfullpathname+587
	DD	imagerel $unwind$posix__getfullpathname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix__getfullpathname DD 021101H
	DD	0d30111H
xdata	ENDS
;	COMDAT ??_C@_0BA@NMGCAMAD@GetFullPathName?$AA@
CONST	SEGMENT
??_C@_0BA@NMGCAMAD@GetFullPathName?$AA@ DB 'GetFullPathName', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EGNIMBAG@y?3_getfullpathname?$AA@
CONST	SEGMENT
??_C@_0BD@EGNIMBAG@y?3_getfullpathname?$AA@ DB 'y:_getfullpathname', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GMCPPICF@GetFullPathNameW?$AA@
CONST	SEGMENT
??_C@_0BB@GMCPPICF@GetFullPathNameW?$AA@ DB 'GetFullPathNameW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FDDLMFHC@U?$HM?3_getfullpathname?$AA@
CONST	SEGMENT
??_C@_0BE@FDDLMFHC@U?$HM?3_getfullpathname?$AA@ DB 'U|:_getfullpathname', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix__getfullpathname
_TEXT	SEGMENT
outbuf$ = 32
temp$ = 560
po$ = 568
path$ = 576
v$122361 = 584
wpath$122356 = 592
wtemp$122359 = 600
result$122360 = 608
woutbuf$122357 = 624
woutbufp$122358 = 1664
self$ = 1696
args$ = 1704
posix__getfullpathname PROC				; COMDAT

; 3804 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 06
	00 00		 sub	 rsp, 1688		; 00000698H

; 3805 :     const char *path;
; 3806 :     char outbuf[MAX_PATH*2];
; 3807 :     char *temp;
; 3808 :     PyObject *po;
; 3809 : 
; 3810 :     if (PyArg_ParseTuple(args, "U|:_getfullpathname", &po))

  00011	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR po$[rsp]
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@FDDLMFHC@U?$HM?3_getfullpathname?$AA@
  00020	48 8b 8c 24 a8
	06 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 47 01 00
	00		 je	 $LN11@posix__get

; 3811 :     {
; 3812 :         wchar_t *wpath;
; 3813 :         wchar_t woutbuf[MAX_PATH*2], *woutbufp = woutbuf;

  00035	48 8d 84 24 70
	02 00 00	 lea	 rax, QWORD PTR woutbuf$122357[rsp]
  0003d	48 89 84 24 80
	06 00 00	 mov	 QWORD PTR woutbufp$122358[rsp], rax

; 3814 :         wchar_t *wtemp;
; 3815 :         DWORD result;
; 3816 :         PyObject *v;
; 3817 : 
; 3818 :         wpath = PyUnicode_AsUnicode(po);

  00045	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR po$[rsp]
  0004d	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00052	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR wpath$122356[rsp], rax

; 3819 :         if (wpath == NULL)

  0005a	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR wpath$122356[rsp], 0
  00063	75 07		 jne	 SHORT $LN10@posix__get

; 3820 :             return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	e9 d7 01 00 00	 jmp	 $LN12@posix__get
$LN10@posix__get:

; 3821 :         result = GetFullPathNameW(wpath,
; 3822 :                                   Py_ARRAY_LENGTH(woutbuf),
; 3823 :                                   woutbuf, &wtemp);

  0006c	4c 8d 8c 24 58
	02 00 00	 lea	 r9, QWORD PTR wtemp$122359[rsp]
  00074	4c 8d 84 24 70
	02 00 00	 lea	 r8, QWORD PTR woutbuf$122357[rsp]
  0007c	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  00081	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR wpath$122356[rsp]
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFullPathNameW
  0008f	89 84 24 60 02
	00 00		 mov	 DWORD PTR result$122360[rsp], eax

; 3824 :         if (result > Py_ARRAY_LENGTH(woutbuf)) {

  00096	8b 84 24 60 02
	00 00		 mov	 eax, DWORD PTR result$122360[rsp]
  0009d	48 3d 08 02 00
	00		 cmp	 rax, 520		; 00000208H
  000a3	76 5c		 jbe	 SHORT $LN9@posix__get

; 3825 :             woutbufp = malloc(result * sizeof(wchar_t));

  000a5	8b 84 24 60 02
	00 00		 mov	 eax, DWORD PTR result$122360[rsp]
  000ac	48 d1 e0	 shl	 rax, 1
  000af	48 8b c8	 mov	 rcx, rax
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000b8	48 89 84 24 80
	06 00 00	 mov	 QWORD PTR woutbufp$122358[rsp], rax

; 3826 :             if (!woutbufp)

  000c0	48 83 bc 24 80
	06 00 00 00	 cmp	 QWORD PTR woutbufp$122358[rsp], 0
  000c9	75 0a		 jne	 SHORT $LN8@posix__get

; 3827 :                 return PyErr_NoMemory();

  000cb	e8 00 00 00 00	 call	 PyErr_NoMemory
  000d0	e9 6e 01 00 00	 jmp	 $LN12@posix__get
$LN8@posix__get:

; 3828 :             result = GetFullPathNameW(wpath, result, woutbufp, &wtemp);

  000d5	4c 8d 8c 24 58
	02 00 00	 lea	 r9, QWORD PTR wtemp$122359[rsp]
  000dd	4c 8b 84 24 80
	06 00 00	 mov	 r8, QWORD PTR woutbufp$122358[rsp]
  000e5	8b 94 24 60 02
	00 00		 mov	 edx, DWORD PTR result$122360[rsp]
  000ec	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR wpath$122356[rsp]
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFullPathNameW
  000fa	89 84 24 60 02
	00 00		 mov	 DWORD PTR result$122360[rsp], eax
$LN9@posix__get:

; 3829 :         }
; 3830 :         if (result)

  00101	83 bc 24 60 02
	00 00 00	 cmp	 DWORD PTR result$122360[rsp], 0
  00109	74 28		 je	 SHORT $LN7@posix__get

; 3831 :             v = PyUnicode_FromWideChar(woutbufp, wcslen(woutbufp));

  0010b	48 8b 8c 24 80
	06 00 00	 mov	 rcx, QWORD PTR woutbufp$122358[rsp]
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00119	48 8b d0	 mov	 rdx, rax
  0011c	48 8b 8c 24 80
	06 00 00	 mov	 rcx, QWORD PTR woutbufp$122358[rsp]
  00124	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  00129	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR v$122361[rsp], rax

; 3832 :         else

  00131	eb 1c		 jmp	 SHORT $LN6@posix__get
$LN7@posix__get:

; 3833 :             v = win32_error_object("GetFullPathNameW", po);

  00133	48 8b 94 24 38
	02 00 00	 mov	 rdx, QWORD PTR po$[rsp]
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GMCPPICF@GetFullPathNameW?$AA@
  00142	e8 00 00 00 00	 call	 win32_error_object
  00147	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR v$122361[rsp], rax
$LN6@posix__get:

; 3834 :         if (woutbufp != woutbuf)

  0014f	48 8d 84 24 70
	02 00 00	 lea	 rax, QWORD PTR woutbuf$122357[rsp]
  00157	48 39 84 24 80
	06 00 00	 cmp	 QWORD PTR woutbufp$122358[rsp], rax
  0015f	74 0e		 je	 SHORT $LN5@posix__get

; 3835 :             free(woutbufp);

  00161	48 8b 8c 24 80
	06 00 00	 mov	 rcx, QWORD PTR woutbufp$122358[rsp]
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@posix__get:

; 3836 :         return v;

  0016f	48 8b 84 24 48
	02 00 00	 mov	 rax, QWORD PTR v$122361[rsp]
  00177	e9 c7 00 00 00	 jmp	 $LN12@posix__get
$LN11@posix__get:

; 3837 :     }
; 3838 :     /* Drop the argument parsing error as narrow strings
; 3839 :        are also valid. */
; 3840 :     PyErr_Clear();

  0017c	e8 00 00 00 00	 call	 PyErr_Clear

; 3841 : 
; 3842 :     if (!PyArg_ParseTuple (args, "y:_getfullpathname",
; 3843 :                            &path))

  00181	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR path$[rsp]
  00189	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@EGNIMBAG@y?3_getfullpathname?$AA@
  00190	48 8b 8c 24 a8
	06 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00198	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0019d	85 c0		 test	 eax, eax
  0019f	75 07		 jne	 SHORT $LN4@posix__get

; 3844 :         return NULL;

  001a1	33 c0		 xor	 eax, eax
  001a3	e9 9b 00 00 00	 jmp	 $LN12@posix__get
$LN4@posix__get:

; 3845 :     if (win32_warn_bytes_api())

  001a8	e8 00 00 00 00	 call	 win32_warn_bytes_api
  001ad	85 c0		 test	 eax, eax
  001af	74 07		 je	 SHORT $LN3@posix__get

; 3846 :         return NULL;

  001b1	33 c0		 xor	 eax, eax
  001b3	e9 8b 00 00 00	 jmp	 $LN12@posix__get
$LN3@posix__get:

; 3847 :     if (!GetFullPathName(path, Py_ARRAY_LENGTH(outbuf),
; 3848 :                          outbuf, &temp)) {

  001b8	4c 8d 8c 24 30
	02 00 00	 lea	 r9, QWORD PTR temp$[rsp]
  001c0	4c 8d 44 24 20	 lea	 r8, QWORD PTR outbuf$[rsp]
  001c5	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  001ca	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFullPathNameA
  001d8	85 c0		 test	 eax, eax
  001da	75 18		 jne	 SHORT $LN2@posix__get

; 3849 :         win32_error("GetFullPathName", path);

  001dc	48 8b 94 24 40
	02 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@NMGCAMAD@GetFullPathName?$AA@
  001eb	e8 00 00 00 00	 call	 win32_error

; 3850 :         return NULL;

  001f0	33 c0		 xor	 eax, eax
  001f2	eb 4f		 jmp	 SHORT $LN12@posix__get
$LN2@posix__get:

; 3851 :     }
; 3852 :     if (PyUnicode_Check(PyTuple_GetItem(args, 0))) {

  001f4	33 d2		 xor	 edx, edx
  001f6	48 8b 8c 24 a8
	06 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  001fe	e8 00 00 00 00	 call	 PyTuple_GetItem
  00203	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00207	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0020d	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00212	85 c0		 test	 eax, eax
  00214	74 23		 je	 SHORT $LN1@posix__get

; 3853 :         return PyUnicode_Decode(outbuf, strlen(outbuf),
; 3854 :                                 Py_FileSystemDefaultEncoding, NULL);

  00216	48 8d 4c 24 20	 lea	 rcx, QWORD PTR outbuf$[rsp]
  0021b	e8 00 00 00 00	 call	 strlen
  00220	45 33 c9	 xor	 r9d, r9d
  00223	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR Py_FileSystemDefaultEncoding
  0022a	48 8b d0	 mov	 rdx, rax
  0022d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR outbuf$[rsp]
  00232	e8 00 00 00 00	 call	 PyUnicode_Decode
  00237	eb 0a		 jmp	 SHORT $LN12@posix__get
$LN1@posix__get:

; 3855 :     }
; 3856 :     return PyBytes_FromString(outbuf);

  00239	48 8d 4c 24 20	 lea	 rcx, QWORD PTR outbuf$[rsp]
  0023e	e8 00 00 00 00	 call	 PyBytes_FromString
$LN12@posix__get:

; 3857 : } /* end of posix__getfullpathname */

  00243	48 81 c4 98 06
	00 00		 add	 rsp, 1688		; 00000698H
  0024a	c3		 ret	 0
posix__getfullpathname ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@JHJNLFGC@CloseHandle?$AA@		; `string'
PUBLIC	??_C@_0BJ@PCFHJEHI@GetFinalPathNamyByHandle?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MPMFPFBO@GetFinalPathNameByHandle?$AA@ ; `string'
PUBLIC	??_C@_0M@GPOOGHPH@CreateFileW?$AA@		; `string'
PUBLIC	??_C@_0DI@HKGHJJO@GetFinalPathNameByHandle?5not?5ava@ ; `string'
PUBLIC	??_C@_0BF@KNAABMOD@U?$HM?3_getfinalpathname?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix__getfinalpathname DD imagerel posix__getfinalpathname
	DD	imagerel posix__getfinalpathname+444
	DD	imagerel $unwind$posix__getfinalpathname
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix__getfinalpathname DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_0M@JHJNLFGC@CloseHandle?$AA@
CONST	SEGMENT
??_C@_0M@JHJNLFGC@CloseHandle?$AA@ DB 'CloseHandle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PCFHJEHI@GetFinalPathNamyByHandle?$AA@
CONST	SEGMENT
??_C@_0BJ@PCFHJEHI@GetFinalPathNamyByHandle?$AA@ DB 'GetFinalPathNamyByHa'
	DB	'ndle', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MPMFPFBO@GetFinalPathNameByHandle?$AA@
CONST	SEGMENT
??_C@_0BJ@MPMFPFBO@GetFinalPathNameByHandle?$AA@ DB 'GetFinalPathNameByHa'
	DB	'ndle', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPOOGHPH@CreateFileW?$AA@
CONST	SEGMENT
??_C@_0M@GPOOGHPH@CreateFileW?$AA@ DB 'CreateFileW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HKGHJJO@GetFinalPathNameByHandle?5not?5ava@
CONST	SEGMENT
??_C@_0DI@HKGHJJO@GetFinalPathNameByHandle?5not?5ava@ DB 'GetFinalPathNam'
	DB	'eByHandle not available on this platform', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KNAABMOD@U?$HM?3_getfinalpathname?$AA@
CONST	SEGMENT
??_C@_0BF@KNAABMOD@U?$HM?3_getfinalpathname?$AA@ DB 'U|:_getfinalpathname'
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix__getfinalpathname
_TEXT	SEGMENT
buf_size$ = 64
target_path$ = 72
hFile$ = 80
po$ = 88
result$ = 96
path$ = 104
result_length$ = 112
self$ = 144
args$ = 152
posix__getfinalpathname PROC				; COMDAT

; 3864 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 3865 :     HANDLE hFile;
; 3866 :     int buf_size;
; 3867 :     wchar_t *target_path;
; 3868 :     int result_length;
; 3869 :     PyObject *po, *result;
; 3870 :     wchar_t *path;
; 3871 : 
; 3872 :     if (!PyArg_ParseTuple(args, "U|:_getfinalpathname", &po))

  00011	4c 8d 44 24 58	 lea	 r8, QWORD PTR po$[rsp]
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@KNAABMOD@U?$HM?3_getfinalpathname?$AA@
  0001d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN8@posix__get@2

; 3873 :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 7f 01 00 00	 jmp	 $LN9@posix__get@2
$LN8@posix__get@2:

; 3874 :     path = PyUnicode_AsUnicode(po);

  00035	48 8b 4c 24 58	 mov	 rcx, QWORD PTR po$[rsp]
  0003a	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  0003f	48 89 44 24 68	 mov	 QWORD PTR path$[rsp], rax

; 3875 :     if (path == NULL)

  00044	48 83 7c 24 68
	00		 cmp	 QWORD PTR path$[rsp], 0
  0004a	75 07		 jne	 SHORT $LN7@posix__get@2

; 3876 :         return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	e9 61 01 00 00	 jmp	 $LN9@posix__get@2
$LN7@posix__get@2:

; 3877 : 
; 3878 :     if(!check_GetFinalPathNameByHandle()) {

  00053	e8 00 00 00 00	 call	 check_GetFinalPathNameByHandle
  00058	85 c0		 test	 eax, eax
  0005a	75 18		 jne	 SHORT $LN6@posix__get@2

; 3879 :         /* If the OS doesn't have GetFinalPathNameByHandle, return a
; 3880 :            NotImplementedError. */
; 3881 :         return PyErr_Format(PyExc_NotImplementedError,
; 3882 :             "GetFinalPathNameByHandle not available on this platform");

  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DI@HKGHJJO@GetFinalPathNameByHandle?5not?5ava@
  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  0006a	e8 00 00 00 00	 call	 PyErr_Format
  0006f	e9 40 01 00 00	 jmp	 $LN9@posix__get@2
$LN6@posix__get@2:

; 3883 :     }
; 3884 : 
; 3885 :     hFile = CreateFileW(
; 3886 :         path,
; 3887 :         0, /* desired access */
; 3888 :         0, /* share mode */
; 3889 :         NULL, /* security attributes */
; 3890 :         OPEN_EXISTING,
; 3891 :         /* FILE_FLAG_BACKUP_SEMANTICS is required to open a directory */
; 3892 :         FILE_FLAG_BACKUP_SEMANTICS,
; 3893 :         NULL);

  00074	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0007d	c7 44 24 28 00
	00 00 02	 mov	 DWORD PTR [rsp+40], 33554432 ; 02000000H
  00085	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  0008d	45 33 c9	 xor	 r9d, r9d
  00090	45 33 c0	 xor	 r8d, r8d
  00093	33 d2		 xor	 edx, edx
  00095	48 8b 4c 24 68	 mov	 rcx, QWORD PTR path$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW
  000a0	48 89 44 24 50	 mov	 QWORD PTR hFile$[rsp], rax

; 3894 : 
; 3895 :     if(hFile == INVALID_HANDLE_VALUE)

  000a5	48 83 7c 24 50
	ff		 cmp	 QWORD PTR hFile$[rsp], -1
  000ab	75 16		 jne	 SHORT $LN5@posix__get@2

; 3896 :         return win32_error_object("CreateFileW", po);

  000ad	48 8b 54 24 58	 mov	 rdx, QWORD PTR po$[rsp]
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@GPOOGHPH@CreateFileW?$AA@
  000b9	e8 00 00 00 00	 call	 win32_error_object
  000be	e9 f1 00 00 00	 jmp	 $LN9@posix__get@2
$LN5@posix__get@2:

; 3897 : 
; 3898 :     /* We have a good handle to the target, use it to determine the
; 3899 :        target path name. */
; 3900 :     buf_size = Py_GetFinalPathNameByHandleW(hFile, 0, 0, VOLUME_NAME_NT);

  000c3	41 b9 02 00 00
	00		 mov	 r9d, 2
  000c9	45 33 c0	 xor	 r8d, r8d
  000cc	33 d2		 xor	 edx, edx
  000ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hFile$[rsp]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR Py_GetFinalPathNameByHandleW
  000d9	89 44 24 40	 mov	 DWORD PTR buf_size$[rsp], eax

; 3901 : 
; 3902 :     if(!buf_size)

  000dd	83 7c 24 40 00	 cmp	 DWORD PTR buf_size$[rsp], 0
  000e2	75 16		 jne	 SHORT $LN4@posix__get@2

; 3903 :         return win32_error_object("GetFinalPathNameByHandle", po);

  000e4	48 8b 54 24 58	 mov	 rdx, QWORD PTR po$[rsp]
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@MPMFPFBO@GetFinalPathNameByHandle?$AA@
  000f0	e8 00 00 00 00	 call	 win32_error_object
  000f5	e9 ba 00 00 00	 jmp	 $LN9@posix__get@2
$LN4@posix__get@2:

; 3904 : 
; 3905 :     target_path = (wchar_t *)malloc((buf_size+1)*sizeof(wchar_t));

  000fa	8b 44 24 40	 mov	 eax, DWORD PTR buf_size$[rsp]
  000fe	ff c0		 inc	 eax
  00100	48 98		 cdqe
  00102	48 d1 e0	 shl	 rax, 1
  00105	48 8b c8	 mov	 rcx, rax
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0010e	48 89 44 24 48	 mov	 QWORD PTR target_path$[rsp], rax

; 3906 :     if(!target_path)

  00113	48 83 7c 24 48
	00		 cmp	 QWORD PTR target_path$[rsp], 0
  00119	75 0a		 jne	 SHORT $LN3@posix__get@2

; 3907 :         return PyErr_NoMemory();

  0011b	e8 00 00 00 00	 call	 PyErr_NoMemory
  00120	e9 8f 00 00 00	 jmp	 $LN9@posix__get@2
$LN3@posix__get@2:

; 3908 : 
; 3909 :     result_length = Py_GetFinalPathNameByHandleW(hFile, target_path,
; 3910 :                                                  buf_size, VOLUME_NAME_DOS);

  00125	45 33 c9	 xor	 r9d, r9d
  00128	44 8b 44 24 40	 mov	 r8d, DWORD PTR buf_size$[rsp]
  0012d	48 8b 54 24 48	 mov	 rdx, QWORD PTR target_path$[rsp]
  00132	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hFile$[rsp]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR Py_GetFinalPathNameByHandleW
  0013d	89 44 24 70	 mov	 DWORD PTR result_length$[rsp], eax

; 3911 :     if(!result_length)

  00141	83 7c 24 70 00	 cmp	 DWORD PTR result_length$[rsp], 0
  00146	75 13		 jne	 SHORT $LN2@posix__get@2

; 3912 :         return win32_error_object("GetFinalPathNamyByHandle", po);

  00148	48 8b 54 24 58	 mov	 rdx, QWORD PTR po$[rsp]
  0014d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@PCFHJEHI@GetFinalPathNamyByHandle?$AA@
  00154	e8 00 00 00 00	 call	 win32_error_object
  00159	eb 59		 jmp	 SHORT $LN9@posix__get@2
$LN2@posix__get@2:

; 3913 : 
; 3914 :     if(!CloseHandle(hFile))

  0015b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hFile$[rsp]
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00166	85 c0		 test	 eax, eax
  00168	75 13		 jne	 SHORT $LN1@posix__get@2

; 3915 :         return win32_error_object("CloseHandle", po);

  0016a	48 8b 54 24 58	 mov	 rdx, QWORD PTR po$[rsp]
  0016f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@JHJNLFGC@CloseHandle?$AA@
  00176	e8 00 00 00 00	 call	 win32_error_object
  0017b	eb 37		 jmp	 SHORT $LN9@posix__get@2
$LN1@posix__get@2:

; 3916 : 
; 3917 :     target_path[result_length] = 0;

  0017d	48 63 44 24 70	 movsxd	 rax, DWORD PTR result_length$[rsp]
  00182	33 c9		 xor	 ecx, ecx
  00184	48 8b 54 24 48	 mov	 rdx, QWORD PTR target_path$[rsp]
  00189	66 89 0c 42	 mov	 WORD PTR [rdx+rax*2], cx

; 3918 :     result = PyUnicode_FromWideChar(target_path, result_length);

  0018d	48 63 44 24 70	 movsxd	 rax, DWORD PTR result_length$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	48 8b 4c 24 48	 mov	 rcx, QWORD PTR target_path$[rsp]
  0019a	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  0019f	48 89 44 24 60	 mov	 QWORD PTR result$[rsp], rax

; 3919 :     free(target_path);

  001a4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR target_path$[rsp]
  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3920 :     return result;

  001af	48 8b 44 24 60	 mov	 rax, QWORD PTR result$[rsp]
$LN9@posix__get@2:

; 3921 : 
; 3922 : } /* end of posix__getfinalpathname */

  001b4	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001bb	c3		 ret	 0
posix__getfinalpathname ENDP
_TEXT	ENDS
PUBLIC	??_C@_03GLKMLICL@iii?$AA@			; `string'
PUBLIC	??_C@_0BG@MMPOLEM@i?3_getfileinformation?$AA@	; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix__getfileinformation DD imagerel posix__getfileinformation
	DD	imagerel posix__getfileinformation+164
	DD	imagerel $unwind$posix__getfileinformation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix__getfileinformation DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_03GLKMLICL@iii?$AA@
CONST	SEGMENT
??_C@_03GLKMLICL@iii?$AA@ DB 'iii', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MMPOLEM@i?3_getfileinformation?$AA@
CONST	SEGMENT
??_C@_0BG@MMPOLEM@i?3_getfileinformation?$AA@ DB 'i:_getfileinformation', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix__getfileinformation
_TEXT	SEGMENT
hFile$ = 32
info$ = 40
fd$ = 96
self$ = 128
args$ = 136
posix__getfileinformation PROC				; COMDAT

; 3926 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 3927 :     HANDLE hFile;
; 3928 :     BY_HANDLE_FILE_INFORMATION info;
; 3929 :     int fd;
; 3930 : 
; 3931 :     if (!PyArg_ParseTuple(args, "i:_getfileinformation", &fd))

  0000e	4c 8d 44 24 60	 lea	 r8, QWORD PTR fd$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@MMPOLEM@i?3_getfileinformation?$AA@
  0001a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00022	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00027	85 c0		 test	 eax, eax
  00029	75 04		 jne	 SHORT $LN4@posix__get@3

; 3932 :         return NULL;

  0002b	33 c0		 xor	 eax, eax
  0002d	eb 70		 jmp	 SHORT $LN5@posix__get@3
$LN4@posix__get@3:

; 3933 : 
; 3934 :     if (!_PyVerify_fd(fd))

  0002f	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  00033	e8 00 00 00 00	 call	 _PyVerify_fd
  00038	85 c0		 test	 eax, eax
  0003a	75 07		 jne	 SHORT $LN3@posix__get@3

; 3935 :         return posix_error();

  0003c	e8 00 00 00 00	 call	 posix_error
  00041	eb 5c		 jmp	 SHORT $LN5@posix__get@3
$LN3@posix__get@3:

; 3936 : 
; 3937 :     hFile = (HANDLE)_get_osfhandle(fd);

  00043	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  0004d	48 89 44 24 20	 mov	 QWORD PTR hFile$[rsp], rax

; 3938 :     if (hFile == INVALID_HANDLE_VALUE)

  00052	48 83 7c 24 20
	ff		 cmp	 QWORD PTR hFile$[rsp], -1
  00058	75 07		 jne	 SHORT $LN2@posix__get@3

; 3939 :         return posix_error();

  0005a	e8 00 00 00 00	 call	 posix_error
  0005f	eb 3e		 jmp	 SHORT $LN5@posix__get@3
$LN2@posix__get@3:

; 3940 : 
; 3941 :     if (!GetFileInformationByHandle(hFile, &info))

  00061	48 8d 54 24 28	 lea	 rdx, QWORD PTR info$[rsp]
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hFile$[rsp]
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileInformationByHandle
  00071	85 c0		 test	 eax, eax
  00073	75 10		 jne	 SHORT $LN1@posix__get@3

; 3942 :         return win32_error("_getfileinformation", NULL);

  00075	33 d2		 xor	 edx, edx
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@FKJDANNK@_getfileinformation?$AA@
  0007e	e8 00 00 00 00	 call	 win32_error
  00083	eb 1a		 jmp	 SHORT $LN5@posix__get@3
$LN1@posix__get@3:

; 3943 : 
; 3944 :     return Py_BuildValue("iii", info.dwVolumeSerialNumber,
; 3945 :                                 info.nFileIndexHigh,
; 3946 :                                 info.nFileIndexLow);

  00085	44 8b 4c 24 58	 mov	 r9d, DWORD PTR info$[rsp+48]
  0008a	44 8b 44 24 54	 mov	 r8d, DWORD PTR info$[rsp+44]
  0008f	8b 54 24 44	 mov	 edx, DWORD PTR info$[rsp+28]
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03GLKMLICL@iii?$AA@
  0009a	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
$LN5@posix__get@3:

; 3947 : }

  0009f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000a3	c3		 ret	 0
posix__getfileinformation ENDP
_TEXT	ENDS
PUBLIC	??_C@_08PLKEAHDG@y?3_isdir?$AA@			; `string'
PUBLIC	??_C@_09OLINHDKN@U?$HM?3_isdir?$AA@		; `string'
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix__isdir DD imagerel posix__isdir
	DD	imagerel posix__isdir+267
	DD	imagerel $unwind$posix__isdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix__isdir DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_08PLKEAHDG@y?3_isdir?$AA@
CONST	SEGMENT
??_C@_08PLKEAHDG@y?3_isdir?$AA@ DB 'y:_isdir', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OLINHDKN@U?$HM?3_isdir?$AA@
CONST	SEGMENT
??_C@_09OLINHDKN@U?$HM?3_isdir?$AA@ DB 'U|:_isdir', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix__isdir
_TEXT	SEGMENT
attributes$ = 32
po$ = 40
path$ = 48
wpath$122452 = 56
self$ = 80
args$ = 88
posix__isdir PROC					; COMDAT

; 3954 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3955 :     const char *path;
; 3956 :     PyObject *po;
; 3957 :     DWORD attributes;
; 3958 : 
; 3959 :     if (PyArg_ParseTuple(args, "U|:_isdir", &po)) {

  0000e	4c 8d 44 24 28	 lea	 r8, QWORD PTR po$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09OLINHDKN@U?$HM?3_isdir?$AA@
  0001a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	74 4e		 je	 SHORT $LN8@posix__isd

; 3960 :         wchar_t *wpath = PyUnicode_AsUnicode(po);

  00028	48 8b 4c 24 28	 mov	 rcx, QWORD PTR po$[rsp]
  0002d	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00032	48 89 44 24 38	 mov	 QWORD PTR wpath$122452[rsp], rax

; 3961 :         if (wpath == NULL)

  00037	48 83 7c 24 38
	00		 cmp	 QWORD PTR wpath$122452[rsp], 0
  0003d	75 07		 jne	 SHORT $LN7@posix__isd

; 3962 :             return NULL;

  0003f	33 c0		 xor	 eax, eax
  00041	e9 c0 00 00 00	 jmp	 $LN9@posix__isd
$LN7@posix__isd:

; 3963 : 
; 3964 :         attributes = GetFileAttributesW(wpath);

  00046	48 8b 4c 24 38	 mov	 rcx, QWORD PTR wpath$122452[rsp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesW
  00051	89 44 24 20	 mov	 DWORD PTR attributes$[rsp], eax

; 3965 :         if (attributes == INVALID_FILE_ATTRIBUTES)

  00055	83 7c 24 20 ff	 cmp	 DWORD PTR attributes$[rsp], -1 ; ffffffffH
  0005a	75 18		 jne	 SHORT $LN6@posix__isd

; 3966 :             Py_RETURN_FALSE;

  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00063	e8 00 00 00 00	 call	 _Py_IncRef
  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  0006f	e9 92 00 00 00	 jmp	 $LN9@posix__isd
$LN6@posix__isd:

; 3967 :         goto check;

  00074	eb 5b		 jmp	 SHORT $check$122461
$LN8@posix__isd:

; 3968 :     }
; 3969 :     /* Drop the argument parsing error as narrow strings
; 3970 :        are also valid. */
; 3971 :     PyErr_Clear();

  00076	e8 00 00 00 00	 call	 PyErr_Clear

; 3972 : 
; 3973 :     if (!PyArg_ParseTuple(args, "y:_isdir", &path))

  0007b	4c 8d 44 24 30	 lea	 r8, QWORD PTR path$[rsp]
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08PLKEAHDG@y?3_isdir?$AA@
  00087	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0008c	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00091	85 c0		 test	 eax, eax
  00093	75 04		 jne	 SHORT $LN5@posix__isd

; 3974 :         return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	eb 6d		 jmp	 SHORT $LN9@posix__isd
$LN5@posix__isd:

; 3975 :     if (win32_warn_bytes_api())

  00099	e8 00 00 00 00	 call	 win32_warn_bytes_api
  0009e	85 c0		 test	 eax, eax
  000a0	74 04		 je	 SHORT $LN4@posix__isd

; 3976 :         return NULL;

  000a2	33 c0		 xor	 eax, eax
  000a4	eb 60		 jmp	 SHORT $LN9@posix__isd
$LN4@posix__isd:

; 3977 :     attributes = GetFileAttributesA(path);

  000a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR path$[rsp]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesA
  000b1	89 44 24 20	 mov	 DWORD PTR attributes$[rsp], eax

; 3978 :     if (attributes == INVALID_FILE_ATTRIBUTES)

  000b5	83 7c 24 20 ff	 cmp	 DWORD PTR attributes$[rsp], -1 ; ffffffffH
  000ba	75 15		 jne	 SHORT $LN3@posix__isd

; 3979 :         Py_RETURN_FALSE;

  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000c3	e8 00 00 00 00	 call	 _Py_IncRef
  000c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  000cf	eb 35		 jmp	 SHORT $LN9@posix__isd
$LN3@posix__isd:
$check$122461:

; 3980 : 
; 3981 : check:
; 3982 :     if (attributes & FILE_ATTRIBUTE_DIRECTORY)

  000d1	8b 44 24 20	 mov	 eax, DWORD PTR attributes$[rsp]
  000d5	83 e0 10	 and	 eax, 16
  000d8	85 c0		 test	 eax, eax
  000da	74 17		 je	 SHORT $LN2@posix__isd

; 3983 :         Py_RETURN_TRUE;

  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  000e3	e8 00 00 00 00	 call	 _Py_IncRef
  000e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  000ef	eb 15		 jmp	 SHORT $LN9@posix__isd

; 3984 :     else

  000f1	eb 13		 jmp	 SHORT $LN1@posix__isd
$LN2@posix__isd:

; 3985 :         Py_RETURN_FALSE;

  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  000fa	e8 00 00 00 00	 call	 _Py_IncRef
  000ff	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
$LN1@posix__isd:
$LN9@posix__isd:

; 3986 : }

  00106	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010a	c3		 ret	 0
posix__isdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@OAHPBKDJ@O?$CG?$HMi$O?$CG?3mkdir?$AA@	; `string'
EXTRN	__imp_CreateDirectoryA:PROC
EXTRN	__imp_CreateDirectoryW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_mkdir DD imagerel posix_mkdir
	DD	imagerel posix_mkdir+325
	DD	imagerel $unwind$posix_mkdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_mkdir DD 021601H
	DD	01b0116H
xdata	ENDS
;	COMDAT ??_C@_0O@OAHPBKDJ@O?$CG?$HMi$O?$CG?3mkdir?$AA@
CONST	SEGMENT
??_C@_0O@OAHPBKDJ@O?$CG?$HMi$O?$CG?3mkdir?$AA@ DB 'O&|i$O&:mkdir', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_mkdir
_TEXT	SEGMENT
dir_fd$ = 80
mode$ = 84
return_value$ = 88
result$ = 96
path$ = 112
_save$122501 = 192
self$ = 224
args$ = 232
kwargs$ = 240
posix_mkdir PROC					; COMDAT

; 4002 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 4003 :     path_t path;
; 4004 :     int mode = 0777;

  00016	c7 44 24 54 ff
	01 00 00	 mov	 DWORD PTR mode$[rsp], 511 ; 000001ffH

; 4005 :     int dir_fd = DEFAULT_DIR_FD;

  0001e	c7 44 24 50 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 4006 :     static char *keywords[] = {"path", "mode", "dir_fd", NULL};
; 4007 :     PyObject *return_value = NULL;

  00026	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR return_value$[rsp], 0

; 4008 :     int result;
; 4009 : 
; 4010 :     memset(&path, 0, sizeof(path));

  0002f	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00035	33 d2		 xor	 edx, edx
  00037	48 8d 4c 24 70	 lea	 rcx, QWORD PTR path$[rsp]
  0003c	e8 00 00 00 00	 call	 memset

; 4011 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|i$O&:mkdir", keywords,
; 4012 :         path_converter, &path, &mode,
; 4013 : #ifdef HAVE_MKDIRAT
; 4014 :         dir_fd_converter, &dir_fd
; 4015 : #else
; 4016 :         dir_fd_unavailable, &dir_fd
; 4017 : #endif
; 4018 :         ))

  00041	48 8d 44 24 50	 lea	 rax, QWORD PTR dir_fd$[rsp]
  00046	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  00052	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00057	48 8d 44 24 54	 lea	 rax, QWORD PTR mode$[rsp]
  0005c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00061	48 8d 44 24 70	 lea	 rax, QWORD PTR path$[rsp]
  00066	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  00072	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00077	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_mkdir@@9@9
  0007e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@OAHPBKDJ@O?$CG?$HMi$O?$CG?3mkdir?$AA@
  00085	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0008d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00095	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0009a	85 c0		 test	 eax, eax
  0009c	75 07		 jne	 SHORT $LN4@posix_mkdi

; 4019 :         return NULL;

  0009e	33 c0		 xor	 eax, eax
  000a0	e9 98 00 00 00	 jmp	 $LN5@posix_mkdi
$LN4@posix_mkdi:

; 4020 : 
; 4021 : #ifdef MS_WINDOWS
; 4022 :     Py_BEGIN_ALLOW_THREADS

  000a5	e8 00 00 00 00	 call	 PyEval_SaveThread
  000aa	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR _save$122501[rsp], rax

; 4023 :     if (path.wide)

  000b2	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR path$[rsp+24], 0
  000bb	74 16		 je	 SHORT $LN3@posix_mkdi

; 4024 :         result = CreateDirectoryW(path.wide, NULL);

  000bd	33 d2		 xor	 edx, edx
  000bf	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+24]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateDirectoryW
  000cd	89 44 24 60	 mov	 DWORD PTR result$[rsp], eax

; 4025 :     else

  000d1	eb 14		 jmp	 SHORT $LN2@posix_mkdi
$LN3@posix_mkdi:

; 4026 :         result = CreateDirectoryA(path.narrow, NULL);

  000d3	33 d2		 xor	 edx, edx
  000d5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateDirectoryA
  000e3	89 44 24 60	 mov	 DWORD PTR result$[rsp], eax
$LN2@posix_mkdi:

; 4027 :     Py_END_ALLOW_THREADS

  000e7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR _save$122501[rsp]
  000ef	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 4028 : 
; 4029 :     if (!result) {

  000f4	83 7c 24 60 00	 cmp	 DWORD PTR result$[rsp], 0
  000f9	75 1b		 jne	 SHORT $LN1@posix_mkdi

; 4030 :         return_value = win32_error_object("mkdir", path.object);

  000fb	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR path$[rsp+56]
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05PKPOIPAL@mkdir?$AA@
  0010a	e8 00 00 00 00	 call	 win32_error_object
  0010f	48 89 44 24 58	 mov	 QWORD PTR return_value$[rsp], rax

; 4031 :         goto exit;

  00114	eb 18		 jmp	 SHORT $exit$122508
$LN1@posix_mkdi:

; 4032 :     }
; 4033 : #else
; 4034 :     Py_BEGIN_ALLOW_THREADS
; 4035 : #if HAVE_MKDIRAT
; 4036 :     if (dir_fd != DEFAULT_DIR_FD)
; 4037 :         result = mkdirat(dir_fd, path.narrow, mode);
; 4038 :     else
; 4039 : #endif
; 4040 : #if ( defined(__WATCOMC__) || defined(PYCC_VACPP) ) && !defined(__QNX__)
; 4041 :         result = mkdir(path.narrow);
; 4042 : #else
; 4043 :         result = mkdir(path.narrow, mode);
; 4044 : #endif
; 4045 :     Py_END_ALLOW_THREADS
; 4046 :     if (result < 0) {
; 4047 :         return_value = path_error("mkdir", &path);
; 4048 :         goto exit;
; 4049 :     }
; 4050 : #endif
; 4051 :     return_value = Py_None;

  00116	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0011d	48 89 44 24 58	 mov	 QWORD PTR return_value$[rsp], rax

; 4052 :     Py_INCREF(Py_None);

  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00129	e8 00 00 00 00	 call	 _Py_IncRef
$exit$122508:

; 4053 : exit:
; 4054 :     path_cleanup(&path);

  0012e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR path$[rsp]
  00133	e8 00 00 00 00	 call	 path_cleanup

; 4055 :     return return_value;

  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR return_value$[rsp]
$LN5@posix_mkdi:

; 4056 : }

  0013d	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00144	c3		 ret	 0
posix_mkdir ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_rename DD imagerel posix_rename
	DD	imagerel posix_rename+42
	DD	imagerel $unwind$posix_rename
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_rename DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_rename
_TEXT	SEGMENT
self$ = 48
args$ = 56
kwargs$ = 64
posix_rename PROC					; COMDAT

; 4238 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4239 :     return internal_rename(args, kwargs, 0);

  00013	45 33 c0	 xor	 r8d, r8d
  00016	48 8b 54 24 40	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0001b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  00020	e8 00 00 00 00	 call	 internal_rename

; 4240 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
posix_rename ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@PACFLBJI@?$CFs?3?5src?5and?5dst?5must?5be?5the?5same@ ; `string'
PUBLIC	??_C@_0M@JMDCKEIM@O?$CGO?$CG?$HM$O?$CGO?$CG?3?$AA@ ; `string'
EXTRN	__imp_MoveFileExA:PROC
EXTRN	__imp_MoveFileExW:PROC
EXTRN	strcat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$internal_rename DD imagerel internal_rename
	DD	imagerel internal_rename+757
	DD	imagerel $unwind$internal_rename
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$internal_rename DD 021601H
	DD	02f0116H
xdata	ENDS
;	COMDAT ??_C@_0CG@PACFLBJI@?$CFs?3?5src?5and?5dst?5must?5be?5the?5same@
CONST	SEGMENT
??_C@_0CG@PACFLBJI@?$CFs?3?5src?5and?5dst?5must?5be?5the?5same@ DB '%s: s'
	DB	'rc and dst must be the same type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMDCKEIM@O?$CGO?$CG?$HM$O?$CGO?$CG?3?$AA@
CONST	SEGMENT
??_C@_0M@JMDCKEIM@O?$CGO?$CG?$HM$O?$CGO?$CG?3?$AA@ DB 'O&O&|$O&O&:', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT internal_rename
_TEXT	SEGMENT
src_dir_fd$ = 96
flags$ = 100
dst$ = 112
dir_fd_specified$ = 192
return_value$ = 200
function_name$ = 208
format$ = 216
dst_dir_fd$ = 240
result$ = 244
src$ = 256
_save$122543 = 336
tv65 = 344
tv67 = 352
tv94 = 356
args$ = 384
kwargs$ = 392
is_replace$ = 400
internal_rename PROC					; COMDAT

; 4145 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H

; 4146 :     char *function_name = is_replace ? "replace" : "rename";

  00016	83 bc 24 90 01
	00 00 00	 cmp	 DWORD PTR is_replace$[rsp], 0
  0001e	74 11		 je	 SHORT $LN11@internal_r
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07CLEHDIEJ@replace?$AA@
  00027	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv65[rsp], rax
  0002f	eb 0f		 jmp	 SHORT $LN12@internal_r
$LN11@internal_r:
  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06LMEAOBLB@rename?$AA@
  00038	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv65[rsp], rax
$LN12@internal_r:
  00040	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR tv65[rsp]
  00048	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR function_name$[rsp], rax

; 4147 :     path_t src;
; 4148 :     path_t dst;
; 4149 :     int src_dir_fd = DEFAULT_DIR_FD;

  00050	c7 44 24 60 9c
	ff ff ff	 mov	 DWORD PTR src_dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 4150 :     int dst_dir_fd = DEFAULT_DIR_FD;

  00058	c7 84 24 f0 00
	00 00 9c ff ff
	ff		 mov	 DWORD PTR dst_dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 4151 :     int dir_fd_specified;
; 4152 :     PyObject *return_value = NULL;

  00063	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR return_value$[rsp], 0

; 4153 :     char format[24];
; 4154 :     static char *keywords[] = {"src", "dst", "src_dir_fd", "dst_dir_fd", NULL};
; 4155 : 
; 4156 : #ifdef MS_WINDOWS
; 4157 :     BOOL result;
; 4158 :     int flags = is_replace ? MOVEFILE_REPLACE_EXISTING : 0;

  0006f	83 bc 24 90 01
	00 00 00	 cmp	 DWORD PTR is_replace$[rsp], 0
  00077	74 0d		 je	 SHORT $LN13@internal_r
  00079	c7 84 24 60 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv67[rsp], 1
  00084	eb 0b		 jmp	 SHORT $LN14@internal_r
$LN13@internal_r:
  00086	c7 84 24 60 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv67[rsp], 0
$LN14@internal_r:
  00091	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR tv67[rsp]
  00098	89 44 24 64	 mov	 DWORD PTR flags$[rsp], eax

; 4159 : #else
; 4160 :     int result;
; 4161 : #endif
; 4162 : 
; 4163 :     memset(&src, 0, sizeof(src));

  0009c	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  000a2	33 d2		 xor	 edx, edx
  000a4	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR src$[rsp]
  000ac	e8 00 00 00 00	 call	 memset

; 4164 :     memset(&dst, 0, sizeof(dst));

  000b1	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  000b7	33 d2		 xor	 edx, edx
  000b9	48 8d 4c 24 70	 lea	 rcx, QWORD PTR dst$[rsp]
  000be	e8 00 00 00 00	 call	 memset

; 4165 :     strcpy(format, "O&O&|$O&O&:");

  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@JMDCKEIM@O?$CGO?$CG?$HM$O?$CGO?$CG?3?$AA@
  000ca	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR format$[rsp]
  000d2	e8 00 00 00 00	 call	 strcpy

; 4166 :     strcat(format, function_name);

  000d7	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR function_name$[rsp]
  000df	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR format$[rsp]
  000e7	e8 00 00 00 00	 call	 strcat

; 4167 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, format, keywords,
; 4168 :         path_converter, &src,
; 4169 :         path_converter, &dst,
; 4170 :         dir_fd_converter, &src_dir_fd,
; 4171 :         dir_fd_converter, &dst_dir_fd))

  000ec	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR dst_dir_fd$[rsp]
  000f4	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  000f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_converter
  00100	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00105	48 8d 44 24 60	 lea	 rax, QWORD PTR src_dir_fd$[rsp]
  0010a	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0010f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_converter
  00116	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0011b	48 8d 44 24 70	 lea	 rax, QWORD PTR dst$[rsp]
  00120	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00125	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  0012c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00131	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR src$[rsp]
  00139	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0013e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  00145	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??internal_rename@@9@9
  00151	4c 8d 84 24 d8
	00 00 00	 lea	 r8, QWORD PTR format$[rsp]
  00159	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  00161	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00169	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0016e	85 c0		 test	 eax, eax
  00170	75 07		 jne	 SHORT $LN8@internal_r

; 4172 :         return NULL;

  00172	33 c0		 xor	 eax, eax
  00174	e9 74 01 00 00	 jmp	 $LN9@internal_r
$LN8@internal_r:

; 4173 : 
; 4174 :     dir_fd_specified = (src_dir_fd != DEFAULT_DIR_FD) ||
; 4175 :                        (dst_dir_fd != DEFAULT_DIR_FD);

  00179	83 7c 24 60 9c	 cmp	 DWORD PTR src_dir_fd$[rsp], -100 ; ffffffffffffff9cH
  0017e	75 17		 jne	 SHORT $LN15@internal_r
  00180	83 bc 24 f0 00
	00 00 9c	 cmp	 DWORD PTR dst_dir_fd$[rsp], -100 ; ffffffffffffff9cH
  00188	75 0d		 jne	 SHORT $LN15@internal_r
  0018a	c7 84 24 64 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv94[rsp], 0
  00195	eb 0b		 jmp	 SHORT $LN16@internal_r
$LN15@internal_r:
  00197	c7 84 24 64 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv94[rsp], 1
$LN16@internal_r:
  001a2	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR tv94[rsp]
  001a9	89 84 24 c0 00
	00 00		 mov	 DWORD PTR dir_fd_specified$[rsp], eax

; 4176 : #ifndef HAVE_RENAMEAT
; 4177 :     if (dir_fd_specified) {

  001b0	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR dir_fd_specified$[rsp], 0
  001b8	74 19		 je	 SHORT $LN7@internal_r

; 4178 :         argument_unavailable_error(function_name, "src_dir_fd and dst_dir_fd");

  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@OIHNMKCA@src_dir_fd?5and?5dst_dir_fd?$AA@
  001c1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR function_name$[rsp]
  001c9	e8 00 00 00 00	 call	 argument_unavailable_error

; 4179 :         goto exit;

  001ce	e9 fb 00 00 00	 jmp	 $exit$122538
$LN7@internal_r:

; 4180 :     }
; 4181 : #endif
; 4182 : 
; 4183 :     if ((src.narrow && dst.wide) || (src.wide && dst.narrow)) {

  001d3	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR src$[rsp+32], 0
  001dc	74 0b		 je	 SHORT $LN4@internal_r
  001de	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dst$[rsp+24], 0
  001e7	75 16		 jne	 SHORT $LN5@internal_r
$LN4@internal_r:
  001e9	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR src$[rsp+24], 0
  001f2	74 2b		 je	 SHORT $LN6@internal_r
  001f4	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dst$[rsp+32], 0
  001fd	74 20		 je	 SHORT $LN6@internal_r
$LN5@internal_r:

; 4184 :         PyErr_Format(PyExc_ValueError,
; 4185 :                      "%s: src and dst must be the same type", function_name);

  001ff	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR function_name$[rsp]
  00207	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@PACFLBJI@?$CFs?3?5src?5and?5dst?5must?5be?5the?5same@
  0020e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00215	e8 00 00 00 00	 call	 PyErr_Format

; 4186 :         goto exit;

  0021a	e9 af 00 00 00	 jmp	 $exit$122538
$LN6@internal_r:

; 4187 :     }
; 4188 : 
; 4189 : #ifdef MS_WINDOWS
; 4190 :     Py_BEGIN_ALLOW_THREADS

  0021f	e8 00 00 00 00	 call	 PyEval_SaveThread
  00224	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR _save$122543[rsp], rax

; 4191 :     if (src.wide)

  0022c	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR src$[rsp+24], 0
  00235	74 24		 je	 SHORT $LN3@internal_r

; 4192 :         result = MoveFileExW(src.wide, dst.wide, flags);

  00237	44 8b 44 24 64	 mov	 r8d, DWORD PTR flags$[rsp]
  0023c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR dst$[rsp+24]
  00244	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR src$[rsp+24]
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MoveFileExW
  00252	89 84 24 f4 00
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 4193 :     else

  00259	eb 22		 jmp	 SHORT $LN2@internal_r
$LN3@internal_r:

; 4194 :         result = MoveFileExA(src.narrow, dst.narrow, flags);

  0025b	44 8b 44 24 64	 mov	 r8d, DWORD PTR flags$[rsp]
  00260	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR dst$[rsp+32]
  00268	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR src$[rsp+32]
  00270	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MoveFileExA
  00276	89 84 24 f4 00
	00 00		 mov	 DWORD PTR result$[rsp], eax
$LN2@internal_r:

; 4195 :     Py_END_ALLOW_THREADS

  0027d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR _save$122543[rsp]
  00285	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 4196 : 
; 4197 :     if (!result) {

  0028a	83 bc 24 f4 00
	00 00 00	 cmp	 DWORD PTR result$[rsp], 0
  00292	75 1f		 jne	 SHORT $LN1@internal_r

; 4198 :         return_value = win32_error_object(function_name, dst.object);

  00294	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR dst$[rsp+56]
  0029c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR function_name$[rsp]
  002a4	e8 00 00 00 00	 call	 win32_error_object
  002a9	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR return_value$[rsp], rax

; 4199 :         goto exit;

  002b1	eb 1b		 jmp	 SHORT $exit$122538
$LN1@internal_r:

; 4200 :     }
; 4201 : 
; 4202 : #else
; 4203 :     Py_BEGIN_ALLOW_THREADS
; 4204 : #ifdef HAVE_RENAMEAT
; 4205 :     if (dir_fd_specified)
; 4206 :         result = renameat(src_dir_fd, src.narrow, dst_dir_fd, dst.narrow);
; 4207 :     else
; 4208 : #endif
; 4209 :         result = rename(src.narrow, dst.narrow);
; 4210 :     Py_END_ALLOW_THREADS
; 4211 : 
; 4212 :     if (result) {
; 4213 :         return_value = path_error(function_name, &dst);
; 4214 :         goto exit;
; 4215 :     }
; 4216 : #endif
; 4217 : 
; 4218 :     Py_INCREF(Py_None);

  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  002ba	e8 00 00 00 00	 call	 _Py_IncRef

; 4219 :     return_value = Py_None;

  002bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  002c6	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR return_value$[rsp], rax
$exit$122538:

; 4220 : exit:
; 4221 :     path_cleanup(&src);

  002ce	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR src$[rsp]
  002d6	e8 00 00 00 00	 call	 path_cleanup

; 4222 :     path_cleanup(&dst);

  002db	48 8d 4c 24 70	 lea	 rcx, QWORD PTR dst$[rsp]
  002e0	e8 00 00 00 00	 call	 path_cleanup

; 4223 :     return return_value;

  002e5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR return_value$[rsp]
$LN9@internal_r:

; 4224 : }

  002ed	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  002f4	c3		 ret	 0
internal_rename ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_replace DD imagerel posix_replace
	DD	imagerel posix_replace+45
	DD	imagerel $unwind$posix_replace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_replace DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_replace
_TEXT	SEGMENT
self$ = 48
args$ = 56
kwargs$ = 64
posix_replace PROC					; COMDAT

; 4254 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4255 :     return internal_rename(args, kwargs, 1);

  00013	41 b8 01 00 00
	00		 mov	 r8d, 1
  00019	48 8b 54 24 40	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0001e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  00023	e8 00 00 00 00	 call	 internal_rename

; 4256 : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
posix_replace ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@NENGCJMH@O?$CG?$HM$O?$CG?3rmdir?$AA@	; `string'
EXTRN	__imp_RemoveDirectoryA:PROC
EXTRN	__imp_RemoveDirectoryW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_rmdir DD imagerel posix_rmdir
	DD	imagerel posix_rmdir+336
	DD	imagerel $unwind$posix_rmdir
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_rmdir DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_0N@NENGCJMH@O?$CG?$HM$O?$CG?3rmdir?$AA@
CONST	SEGMENT
??_C@_0N@NENGCJMH@O?$CG?$HM$O?$CG?3rmdir?$AA@ DB 'O&|$O&:rmdir', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_rmdir
_TEXT	SEGMENT
dir_fd$ = 64
return_value$ = 72
result$ = 80
path$ = 96
_save$122586 = 176
tv84 = 184
self$ = 208
args$ = 216
kwargs$ = 224
posix_rmdir PROC					; COMDAT

; 4269 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 4270 :     path_t path;
; 4271 :     int dir_fd = DEFAULT_DIR_FD;

  00016	c7 44 24 40 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 4272 :     static char *keywords[] = {"path", "dir_fd", NULL};
; 4273 :     int result;
; 4274 :     PyObject *return_value = NULL;

  0001e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR return_value$[rsp], 0

; 4275 : 
; 4276 :     memset(&path, 0, sizeof(path));

  00027	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  0002d	33 d2		 xor	 edx, edx
  0002f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR path$[rsp]
  00034	e8 00 00 00 00	 call	 memset

; 4277 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|$O&:rmdir", keywords,
; 4278 :             path_converter, &path,
; 4279 : #ifdef HAVE_UNLINKAT
; 4280 :             dir_fd_converter, &dir_fd
; 4281 : #else
; 4282 :             dir_fd_unavailable, &dir_fd
; 4283 : #endif
; 4284 :             ))

  00039	48 8d 44 24 40	 lea	 rax, QWORD PTR dir_fd$[rsp]
  0003e	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00043	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  0004a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0004f	48 8d 44 24 60	 lea	 rax, QWORD PTR path$[rsp]
  00054	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00059	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  00060	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00065	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_rmdir@@9@9
  0006c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@NENGCJMH@O?$CG?$HM$O?$CG?3rmdir?$AA@
  00073	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0007b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00083	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00088	85 c0		 test	 eax, eax
  0008a	75 07		 jne	 SHORT $LN4@posix_rmdi

; 4285 :         return NULL;

  0008c	33 c0		 xor	 eax, eax
  0008e	e9 b5 00 00 00	 jmp	 $LN5@posix_rmdi
$LN4@posix_rmdi:

; 4286 : 
; 4287 :     Py_BEGIN_ALLOW_THREADS

  00093	e8 00 00 00 00	 call	 PyEval_SaveThread
  00098	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR _save$122586[rsp], rax

; 4288 : #ifdef MS_WINDOWS
; 4289 :     if (path.wide)

  000a0	48 83 7c 24 78
	00		 cmp	 QWORD PTR path$[rsp+24], 0
  000a6	74 11		 je	 SHORT $LN3@posix_rmdi

; 4290 :         result = RemoveDirectoryW(path.wide);

  000a8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR path$[rsp+24]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RemoveDirectoryW
  000b3	89 44 24 50	 mov	 DWORD PTR result$[rsp], eax

; 4291 :     else

  000b7	eb 12		 jmp	 SHORT $LN2@posix_rmdi
$LN3@posix_rmdi:

; 4292 :         result = RemoveDirectoryA(path.narrow);

  000b9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RemoveDirectoryA
  000c7	89 44 24 50	 mov	 DWORD PTR result$[rsp], eax
$LN2@posix_rmdi:

; 4293 :     result = !result; /* Windows, success=1, UNIX, success=0 */

  000cb	83 7c 24 50 00	 cmp	 DWORD PTR result$[rsp], 0
  000d0	75 0d		 jne	 SHORT $LN7@posix_rmdi
  000d2	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv84[rsp], 1
  000dd	eb 0b		 jmp	 SHORT $LN8@posix_rmdi
$LN7@posix_rmdi:
  000df	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv84[rsp], 0
$LN8@posix_rmdi:
  000ea	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv84[rsp]
  000f1	89 44 24 50	 mov	 DWORD PTR result$[rsp], eax

; 4294 : #else
; 4295 : #ifdef HAVE_UNLINKAT
; 4296 :     if (dir_fd != DEFAULT_DIR_FD)
; 4297 :         result = unlinkat(dir_fd, path.narrow, AT_REMOVEDIR);
; 4298 :     else
; 4299 : #endif
; 4300 :         result = rmdir(path.narrow);
; 4301 : #endif
; 4302 :     Py_END_ALLOW_THREADS

  000f5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR _save$122586[rsp]
  000fd	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 4303 : 
; 4304 :     if (result) {

  00102	83 7c 24 50 00	 cmp	 DWORD PTR result$[rsp], 0
  00107	74 18		 je	 SHORT $LN1@posix_rmdi

; 4305 :         return_value = path_error("rmdir", &path);

  00109	48 8d 54 24 60	 lea	 rdx, QWORD PTR path$[rsp]
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IHDOMKOF@rmdir?$AA@
  00115	e8 00 00 00 00	 call	 path_error
  0011a	48 89 44 24 48	 mov	 QWORD PTR return_value$[rsp], rax

; 4306 :         goto exit;

  0011f	eb 18		 jmp	 SHORT $exit$122591
$LN1@posix_rmdi:

; 4307 :     }
; 4308 : 
; 4309 :     return_value = Py_None;

  00121	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00128	48 89 44 24 48	 mov	 QWORD PTR return_value$[rsp], rax

; 4310 :     Py_INCREF(Py_None);

  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00134	e8 00 00 00 00	 call	 _Py_IncRef
$exit$122591:

; 4311 : 
; 4312 : exit:
; 4313 :     path_cleanup(&path);

  00139	48 8d 4c 24 60	 lea	 rcx, QWORD PTR path$[rsp]
  0013e	e8 00 00 00 00	 call	 path_cleanup

; 4314 :     return return_value;

  00143	48 8b 44 24 48	 mov	 rax, QWORD PTR return_value$[rsp]
$LN5@posix_rmdi:

; 4315 : }

  00148	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0014f	c3		 ret	 0
posix_rmdir ENDP
_TEXT	ENDS
PUBLIC	??_C@_08ICACAFDE@u?3system?$AA@			; `string'
EXTRN	__imp__wsystem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_system DD imagerel posix_system
	DD	imagerel posix_system+93
	DD	imagerel $unwind$posix_system
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_system DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_08ICACAFDE@u?3system?$AA@
CONST	SEGMENT
??_C@_08ICACAFDE@u?3system?$AA@ DB 'u:system', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_system
_TEXT	SEGMENT
sts$ = 32
command$ = 40
_save$122605 = 48
self$ = 80
args$ = 88
posix_system PROC					; COMDAT

; 4325 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4326 :     long sts;
; 4327 : #ifdef MS_WINDOWS
; 4328 :     wchar_t *command;
; 4329 :     if (!PyArg_ParseTuple(args, "u:system", &command))

  0000e	4c 8d 44 24 28	 lea	 r8, QWORD PTR command$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08ICACAFDE@u?3system?$AA@
  0001a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN1@posix_syst

; 4330 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 2c		 jmp	 SHORT $LN2@posix_syst
$LN1@posix_syst:

; 4331 : 
; 4332 :     Py_BEGIN_ALLOW_THREADS

  0002c	e8 00 00 00 00	 call	 PyEval_SaveThread
  00031	48 89 44 24 30	 mov	 QWORD PTR _save$122605[rsp], rax

; 4333 :     sts = _wsystem(command);

  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR command$[rsp]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wsystem
  00041	89 44 24 20	 mov	 DWORD PTR sts$[rsp], eax

; 4334 :     Py_END_ALLOW_THREADS

  00045	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _save$122605[rsp]
  0004a	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 4335 : #else
; 4336 :     PyObject *command_obj;
; 4337 :     char *command;
; 4338 :     if (!PyArg_ParseTuple(args, "O&:system",
; 4339 :                           PyUnicode_FSConverter, &command_obj))
; 4340 :         return NULL;
; 4341 : 
; 4342 :     command = PyBytes_AsString(command_obj);
; 4343 :     Py_BEGIN_ALLOW_THREADS
; 4344 :     sts = system(command);
; 4345 :     Py_END_ALLOW_THREADS
; 4346 :     Py_DECREF(command_obj);
; 4347 : #endif
; 4348 :     return PyLong_FromLong(sts);

  0004f	8b 4c 24 20	 mov	 ecx, DWORD PTR sts$[rsp]
  00053	e8 00 00 00 00	 call	 PyLong_FromLong
$LN2@posix_syst:

; 4349 : }

  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
posix_system ENDP
_TEXT	ENDS
PUBLIC	??_C@_07DAADLKJH@i?3umask?$AA@			; `string'
EXTRN	__imp_umask:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_umask DD imagerel posix_umask
	DD	imagerel posix_umask+86
	DD	imagerel $unwind$posix_umask
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_umask DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_07DAADLKJH@i?3umask?$AA@
CONST	SEGMENT
??_C@_07DAADLKJH@i?3umask?$AA@ DB 'i:umask', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_umask
_TEXT	SEGMENT
i$ = 32
self$ = 64
args$ = 72
posix_umask PROC					; COMDAT

; 4359 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4360 :     int i;
; 4361 :     if (!PyArg_ParseTuple(args, "i:umask", &i))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR i$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07DAADLKJH@i?3umask?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@posix_umas

; 4362 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 25		 jmp	 SHORT $LN3@posix_umas
$LN2@posix_umas:

; 4363 :     i = (int)umask(i);

  0002c	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_umask
  00036	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 4364 :     if (i < 0)

  0003a	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0003f	7d 07		 jge	 SHORT $LN1@posix_umas

; 4365 :         return posix_error();

  00041	e8 00 00 00 00	 call	 posix_error
  00046	eb 09		 jmp	 SHORT $LN3@posix_umas
$LN1@posix_umas:

; 4366 :     return PyLong_FromLong((long)i);

  00048	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0004c	e8 00 00 00 00	 call	 PyLong_FromLong
$LN3@posix_umas:

; 4367 : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
posix_umask ENDP
_TEXT	ENDS
PUBLIC	Py_DeleteFileW
EXTRN	__imp_DeleteFileW:PROC
EXTRN	__imp_GetFileAttributesExW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_DeleteFileW DD imagerel $LN9
	DD	imagerel $LN9+255
	DD	imagerel $unwind$Py_DeleteFileW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_DeleteFileW DD 020c01H
	DD	059010cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT Py_DeleteFileW
_TEXT	SEGMENT
is_directory$ = 32
find_data$ = 48
find_data_handle$ = 640
info$ = 648
is_link$ = 688
tv78 = 692
lpFileName$ = 720
Py_DeleteFileW PROC					; COMDAT

; 4375 : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H

; 4376 :     WIN32_FILE_ATTRIBUTE_DATA info;
; 4377 :     WIN32_FIND_DATAW find_data;
; 4378 :     HANDLE find_data_handle;
; 4379 :     int is_directory = 0;

  0000c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR is_directory$[rsp], 0

; 4380 :     int is_link = 0;

  00014	c7 84 24 b0 02
	00 00 00 00 00
	00		 mov	 DWORD PTR is_link$[rsp], 0

; 4381 : 
; 4382 :     if (GetFileAttributesExW(lpFileName, GetFileExInfoStandard, &info)) {

  0001f	4c 8d 84 24 88
	02 00 00	 lea	 r8, QWORD PTR info$[rsp]
  00027	33 d2		 xor	 edx, edx
  00029	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR lpFileName$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesExW
  00037	85 c0		 test	 eax, eax
  00039	0f 84 89 00 00
	00		 je	 $LN4@Py_DeleteF

; 4383 :         is_directory = info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY;

  0003f	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR info$[rsp]
  00046	83 e0 10	 and	 eax, 16
  00049	89 44 24 20	 mov	 DWORD PTR is_directory$[rsp], eax

; 4384 : 
; 4385 :         /* Get WIN32_FIND_DATA structure for the path to determine if
; 4386 :            it is a symlink */
; 4387 :         if(is_directory &&
; 4388 :            info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {

  0004d	83 7c 24 20 00	 cmp	 DWORD PTR is_directory$[rsp], 0
  00052	74 74		 je	 SHORT $LN3@Py_DeleteF
  00054	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR info$[rsp]
  0005b	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00060	85 c0		 test	 eax, eax
  00062	74 64		 je	 SHORT $LN3@Py_DeleteF

; 4389 :             find_data_handle = FindFirstFileW(lpFileName, &find_data);

  00064	48 8d 54 24 30	 lea	 rdx, QWORD PTR find_data$[rsp]
  00069	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR lpFileName$[rsp]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileW
  00077	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR find_data_handle$[rsp], rax

; 4390 : 
; 4391 :             if(find_data_handle != INVALID_HANDLE_VALUE) {

  0007f	48 83 bc 24 80
	02 00 00 ff	 cmp	 QWORD PTR find_data_handle$[rsp], -1
  00088	74 3e		 je	 SHORT $LN2@Py_DeleteF

; 4392 :                 is_link = find_data.dwReserved0 == IO_REPARSE_TAG_SYMLINK;

  0008a	81 7c 24 54 0c
	00 00 a0	 cmp	 DWORD PTR find_data$[rsp+36], -1610612724 ; a000000cH
  00092	75 0d		 jne	 SHORT $LN7@Py_DeleteF
  00094	c7 84 24 b4 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv78[rsp], 1
  0009f	eb 0b		 jmp	 SHORT $LN8@Py_DeleteF
$LN7@Py_DeleteF:
  000a1	c7 84 24 b4 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv78[rsp], 0
$LN8@Py_DeleteF:
  000ac	8b 84 24 b4 02
	00 00		 mov	 eax, DWORD PTR tv78[rsp]
  000b3	89 84 24 b0 02
	00 00		 mov	 DWORD PTR is_link$[rsp], eax

; 4393 :                 FindClose(find_data_handle);

  000ba	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR find_data_handle$[rsp]
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindClose
$LN2@Py_DeleteF:
$LN3@Py_DeleteF:
$LN4@Py_DeleteF:

; 4394 :             }
; 4395 :         }
; 4396 :     }
; 4397 : 
; 4398 :     if (is_directory && is_link)

  000c8	83 7c 24 20 00	 cmp	 DWORD PTR is_directory$[rsp], 0
  000cd	74 1a		 je	 SHORT $LN1@Py_DeleteF
  000cf	83 bc 24 b0 02
	00 00 00	 cmp	 DWORD PTR is_link$[rsp], 0
  000d7	74 10		 je	 SHORT $LN1@Py_DeleteF

; 4399 :         return RemoveDirectoryW(lpFileName);

  000d9	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR lpFileName$[rsp]
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RemoveDirectoryW
  000e7	eb 0e		 jmp	 SHORT $LN5@Py_DeleteF
$LN1@Py_DeleteF:

; 4400 : 
; 4401 :     return DeleteFileW(lpFileName);

  000e9	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR lpFileName$[rsp]
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteFileW
$LN5@Py_DeleteF:

; 4402 : }

  000f7	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  000fe	c3		 ret	 0
Py_DeleteFileW ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@OFKCGOKD@O?$CG?$HM$O?$CG?3unlink?$AA@	; `string'
EXTRN	__imp_DeleteFileA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_unlink DD imagerel posix_unlink
	DD	imagerel posix_unlink+335
	DD	imagerel $unwind$posix_unlink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_unlink DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_0O@OFKCGOKD@O?$CG?$HM$O?$CG?3unlink?$AA@
CONST	SEGMENT
??_C@_0O@OFKCGOKD@O?$CG?$HM$O?$CG?3unlink?$AA@ DB 'O&|$O&:unlink', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_unlink
_TEXT	SEGMENT
dir_fd$ = 64
return_value$ = 72
result$ = 80
path$ = 96
_save$122656 = 176
tv84 = 184
self$ = 208
args$ = 216
kwargs$ = 224
posix_unlink PROC					; COMDAT

; 4425 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 4426 :     path_t path;
; 4427 :     int dir_fd = DEFAULT_DIR_FD;

  00016	c7 44 24 40 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 4428 :     static char *keywords[] = {"path", "dir_fd", NULL};
; 4429 :     int result;
; 4430 :     PyObject *return_value = NULL;

  0001e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR return_value$[rsp], 0

; 4431 : 
; 4432 :     memset(&path, 0, sizeof(path));

  00027	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  0002d	33 d2		 xor	 edx, edx
  0002f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR path$[rsp]
  00034	e8 00 00 00 00	 call	 memset

; 4433 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|$O&:unlink", keywords,
; 4434 :             path_converter, &path,
; 4435 : #ifdef HAVE_UNLINKAT
; 4436 :             dir_fd_converter, &dir_fd
; 4437 : #else
; 4438 :             dir_fd_unavailable, &dir_fd
; 4439 : #endif
; 4440 :             ))

  00039	48 8d 44 24 40	 lea	 rax, QWORD PTR dir_fd$[rsp]
  0003e	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00043	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  0004a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0004f	48 8d 44 24 60	 lea	 rax, QWORD PTR path$[rsp]
  00054	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00059	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  00060	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00065	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_unlink@@9@9
  0006c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@OFKCGOKD@O?$CG?$HM$O?$CG?3unlink?$AA@
  00073	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0007b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00083	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00088	85 c0		 test	 eax, eax
  0008a	75 07		 jne	 SHORT $LN4@posix_unli

; 4441 :         return NULL;

  0008c	33 c0		 xor	 eax, eax
  0008e	e9 b4 00 00 00	 jmp	 $LN5@posix_unli
$LN4@posix_unli:

; 4442 : 
; 4443 :     Py_BEGIN_ALLOW_THREADS

  00093	e8 00 00 00 00	 call	 PyEval_SaveThread
  00098	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR _save$122656[rsp], rax

; 4444 : #ifdef MS_WINDOWS
; 4445 :     if (path.wide)

  000a0	48 83 7c 24 78
	00		 cmp	 QWORD PTR path$[rsp+24], 0
  000a6	74 10		 je	 SHORT $LN3@posix_unli

; 4446 :         result = Py_DeleteFileW(path.wide);

  000a8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR path$[rsp+24]
  000ad	e8 00 00 00 00	 call	 Py_DeleteFileW
  000b2	89 44 24 50	 mov	 DWORD PTR result$[rsp], eax

; 4447 :     else

  000b6	eb 12		 jmp	 SHORT $LN2@posix_unli
$LN3@posix_unli:

; 4448 :         result = DeleteFileA(path.narrow);

  000b8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteFileA
  000c6	89 44 24 50	 mov	 DWORD PTR result$[rsp], eax
$LN2@posix_unli:

; 4449 :     result = !result; /* Windows, success=1, UNIX, success=0 */

  000ca	83 7c 24 50 00	 cmp	 DWORD PTR result$[rsp], 0
  000cf	75 0d		 jne	 SHORT $LN7@posix_unli
  000d1	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv84[rsp], 1
  000dc	eb 0b		 jmp	 SHORT $LN8@posix_unli
$LN7@posix_unli:
  000de	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv84[rsp], 0
$LN8@posix_unli:
  000e9	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv84[rsp]
  000f0	89 44 24 50	 mov	 DWORD PTR result$[rsp], eax

; 4450 : #else
; 4451 : #ifdef HAVE_UNLINKAT
; 4452 :     if (dir_fd != DEFAULT_DIR_FD)
; 4453 :         result = unlinkat(dir_fd, path.narrow, 0);
; 4454 :     else
; 4455 : #endif /* HAVE_UNLINKAT */
; 4456 :         result = unlink(path.narrow);
; 4457 : #endif
; 4458 :     Py_END_ALLOW_THREADS

  000f4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR _save$122656[rsp]
  000fc	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 4459 : 
; 4460 :     if (result) {

  00101	83 7c 24 50 00	 cmp	 DWORD PTR result$[rsp], 0
  00106	74 18		 je	 SHORT $LN1@posix_unli

; 4461 :         return_value = path_error("unlink", &path);

  00108	48 8d 54 24 60	 lea	 rdx, QWORD PTR path$[rsp]
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06DAJBMHKE@unlink?$AA@
  00114	e8 00 00 00 00	 call	 path_error
  00119	48 89 44 24 48	 mov	 QWORD PTR return_value$[rsp], rax

; 4462 :         goto exit;

  0011e	eb 18		 jmp	 SHORT $exit$122661
$LN1@posix_unli:

; 4463 :     }
; 4464 : 
; 4465 :     return_value = Py_None;

  00120	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00127	48 89 44 24 48	 mov	 QWORD PTR return_value$[rsp], rax

; 4466 :     Py_INCREF(Py_None);

  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00133	e8 00 00 00 00	 call	 _Py_IncRef
$exit$122661:

; 4467 : 
; 4468 : exit:
; 4469 :     path_cleanup(&path);

  00138	48 8d 4c 24 60	 lea	 rcx, QWORD PTR path$[rsp]
  0013d	e8 00 00 00 00	 call	 path_cleanup

; 4470 :     return return_value;

  00142	48 8b 44 24 48	 mov	 rax, QWORD PTR return_value$[rsp]
$LN5@posix_unli:

; 4471 : }

  00147	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0014e	c3		 ret	 0
posix_unlink ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@ONDHDFNE@utime?3?5cannot?5use?5dir_fd?5and?5fol@ ; `string'
PUBLIC	??_C@_0CI@HLLNEJKH@utime?3?5?8ns?8?5must?5be?5a?5tuple?5of?5t@ ; `string'
PUBLIC	??_C@_0DK@EPILIDOI@utime?3?5?8times?8?5must?5be?5either?5a?5@ ; `string'
PUBLIC	??_C@_0DL@BAJOEJPJ@utime?3?5you?5may?5specify?5either?5?8t@ ; `string'
PUBLIC	??_C@_0BA@GKAAMNLD@O?$CG?$HMO$OO?$CGp?3utime?$AA@ ; `string'
PUBLIC	??_C@_02EGOFOKPC@ns?$AA@			; `string'
EXTRN	__imp_SetFileTime:PROC
EXTRN	__imp_SystemTimeToFileTime:PROC
EXTRN	__imp_GetSystemTime:PROC
EXTRN	_PyTime_ObjectToTimespec:PROC
EXTRN	PyTuple_Size:PROC
EXTRN	PyTuple_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_utime DD imagerel posix_utime
	DD	imagerel posix_utime+1432
	DD	imagerel $unwind$posix_utime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_utime DD 021601H
	DD	0330116H
xdata	ENDS
;	COMDAT ??_C@_0EH@ONDHDFNE@utime?3?5cannot?5use?5dir_fd?5and?5fol@
CONST	SEGMENT
??_C@_0EH@ONDHDFNE@utime?3?5cannot?5use?5dir_fd?5and?5fol@ DB 'utime: can'
	DB	'not use dir_fd and follow_symlinks together on this platform', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HLLNEJKH@utime?3?5?8ns?8?5must?5be?5a?5tuple?5of?5t@
CONST	SEGMENT
??_C@_0CI@HLLNEJKH@utime?3?5?8ns?8?5must?5be?5a?5tuple?5of?5t@ DB 'utime:'
	DB	' ''ns'' must be a tuple of two ints', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@EPILIDOI@utime?3?5?8times?8?5must?5be?5either?5a?5@
CONST	SEGMENT
??_C@_0DK@EPILIDOI@utime?3?5?8times?8?5must?5be?5either?5a?5@ DB 'utime: '
	DB	'''times'' must be either a tuple of two ints or None', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@BAJOEJPJ@utime?3?5you?5may?5specify?5either?5?8t@
CONST	SEGMENT
??_C@_0DL@BAJOEJPJ@utime?3?5you?5may?5specify?5either?5?8t@ DB 'utime: yo'
	DB	'u may specify either ''times'' or ''ns'' but not both', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GKAAMNLD@O?$CG?$HMO$OO?$CGp?3utime?$AA@
CONST	SEGMENT
??_C@_0BA@GKAAMNLD@O?$CG?$HMO$OO?$CGp?3utime?$AA@ DB 'O&|O$OO&p:utime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGOFOKPC@ns?$AA@
CONST	SEGMENT
??_C@_02EGOFOKPC@ns?$AA@ DB 'ns', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_utime
_TEXT	SEGMENT
ns$ = 96
dir_fd$ = 104
return_value$ = 112
utime$ = 120
keywords$ = 160
mtime$ = 208
hFile$ = 216
times$ = 224
atime$ = 232
follow_symlinks$ = 240
path$ = 256
a_sec$122749 = 336
a_nsec$122751 = 344
m_sec$122750 = 352
m_nsec$122752 = 360
_save$122778 = 368
now$122789 = 376
self$ = 416
args$ = 424
kwargs$ = 432
posix_utime PROC					; COMDAT

; 4743 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H

; 4744 :     path_t path;
; 4745 :     PyObject *times = NULL;

  00016	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR times$[rsp], 0

; 4746 :     PyObject *ns = NULL;

  00022	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR ns$[rsp], 0

; 4747 :     int dir_fd = DEFAULT_DIR_FD;

  0002b	c7 44 24 68 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 4748 :     int follow_symlinks = 1;

  00033	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR follow_symlinks$[rsp], 1

; 4749 :     char *keywords[] = {"path", "times", "ns", "dir_fd",

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04LNEJFJGI@path?$AA@
  00045	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR keywords$[rsp], rax
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05MJOOAIJH@times?$AA@
  00054	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR keywords$[rsp+8], rax
  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02EGOFOKPC@ns?$AA@
  00063	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR keywords$[rsp+16], rax
  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06GPCGKDIP@dir_fd?$AA@
  00072	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR keywords$[rsp+24], rax

; 4750 :                         "follow_symlinks", NULL};

  0007a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BA@HIKOMOIN@follow_symlinks?$AA@
  00081	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR keywords$[rsp+32], rax
  00089	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR keywords$[rsp+40], 0

; 4751 : 
; 4752 :     utime_t utime;
; 4753 : 
; 4754 : #ifdef MS_WINDOWS
; 4755 :     HANDLE hFile;
; 4756 :     FILETIME atime, mtime;
; 4757 : #else
; 4758 :     int result;
; 4759 : #endif
; 4760 : 
; 4761 :     PyObject *return_value = NULL;

  00095	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR return_value$[rsp], 0

; 4762 : 
; 4763 :     memset(&path, 0, sizeof(path));

  0009e	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  000a4	33 d2		 xor	 edx, edx
  000a6	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  000ae	e8 00 00 00 00	 call	 memset

; 4764 :     memset(&utime, 0, sizeof(utime_t));

  000b3	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  000b9	33 d2		 xor	 edx, edx
  000bb	48 8d 4c 24 78	 lea	 rcx, QWORD PTR utime$[rsp]
  000c0	e8 00 00 00 00	 call	 memset

; 4765 : #if UTIME_HAVE_FD
; 4766 :     path.allow_fd = 1;
; 4767 : #endif
; 4768 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs,
; 4769 :             "O&|O$OO&p:utime", keywords,
; 4770 :             path_converter, &path,
; 4771 :             &times, &ns,
; 4772 : #if UTIME_HAVE_DIR_FD
; 4773 :             dir_fd_converter, &dir_fd,
; 4774 : #else
; 4775 :             dir_fd_unavailable, &dir_fd,
; 4776 : #endif
; 4777 :             &follow_symlinks
; 4778 :             ))

  000c5	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR follow_symlinks$[rsp]
  000cd	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  000d2	48 8d 44 24 68	 lea	 rax, QWORD PTR dir_fd$[rsp]
  000d7	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  000dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  000e3	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000e8	48 8d 44 24 60	 lea	 rax, QWORD PTR ns$[rsp]
  000ed	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000f2	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR times$[rsp]
  000fa	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000ff	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR path$[rsp]
  00107	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0010c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  00113	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00118	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR keywords$[rsp]
  00120	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@GKAAMNLD@O?$CG?$HMO$OO?$CGp?3utime?$AA@
  00127	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0012f	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00137	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0013c	85 c0		 test	 eax, eax
  0013e	75 07		 jne	 SHORT $LN27@posix_utim

; 4779 :         return NULL;

  00140	33 c0		 xor	 eax, eax
  00142	e9 49 04 00 00	 jmp	 $LN28@posix_utim
$LN27@posix_utim:

; 4780 : 
; 4781 :     if (times && (times != Py_None) && ns) {

  00147	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR times$[rsp], 0
  00150	74 31		 je	 SHORT $LN26@posix_utim
  00152	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00159	48 39 84 24 e0
	00 00 00	 cmp	 QWORD PTR times$[rsp], rax
  00161	74 20		 je	 SHORT $LN26@posix_utim
  00163	48 83 7c 24 60
	00		 cmp	 QWORD PTR ns$[rsp], 0
  00169	74 18		 je	 SHORT $LN26@posix_utim

; 4782 :         PyErr_SetString(PyExc_ValueError,
; 4783 :                      "utime: you may specify either 'times'"
; 4784 :                      " or 'ns' but not both");

  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@BAJOEJPJ@utime?3?5you?5may?5specify?5either?5?8t@
  00172	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00179	e8 00 00 00 00	 call	 PyErr_SetString

; 4785 :         goto exit;

  0017e	e9 e2 03 00 00	 jmp	 $exit$122747
$LN26@posix_utim:

; 4786 :     }
; 4787 : 
; 4788 :     if (times && (times != Py_None)) {

  00183	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR times$[rsp], 0
  0018c	0f 84 ef 00 00
	00		 je	 $LN25@posix_utim
  00192	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00199	48 39 84 24 e0
	00 00 00	 cmp	 QWORD PTR times$[rsp], rax
  001a1	0f 84 da 00 00
	00		 je	 $LN25@posix_utim

; 4789 :         time_t a_sec, m_sec;
; 4790 :         long a_nsec, m_nsec;
; 4791 :         if (!PyTuple_CheckExact(times) || (PyTuple_Size(times) != 2)) {

  001a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  001ae	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR times$[rsp]
  001b6	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  001ba	75 13		 jne	 SHORT $LN23@posix_utim
  001bc	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR times$[rsp]
  001c4	e8 00 00 00 00	 call	 PyTuple_Size
  001c9	48 83 f8 02	 cmp	 rax, 2
  001cd	74 18		 je	 SHORT $LN24@posix_utim
$LN23@posix_utim:

; 4792 :             PyErr_SetString(PyExc_TypeError,
; 4793 :                          "utime: 'times' must be either"
; 4794 :                          " a tuple of two ints or None");

  001cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DK@EPILIDOI@utime?3?5?8times?8?5must?5be?5either?5a?5@
  001d6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001dd	e8 00 00 00 00	 call	 PyErr_SetString

; 4795 :             goto exit;

  001e2	e9 7e 03 00 00	 jmp	 $exit$122747
$LN24@posix_utim:

; 4796 :         }
; 4797 :         utime.now = 0;

  001e7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR utime$[rsp], 0

; 4798 :         if (_PyTime_ObjectToTimespec(PyTuple_GET_ITEM(times, 0),
; 4799 :                                      &a_sec, &a_nsec) == -1 ||
; 4800 :             _PyTime_ObjectToTimespec(PyTuple_GET_ITEM(times, 1),
; 4801 :                                      &m_sec, &m_nsec) == -1) {

  001ef	4c 8d 84 24 58
	01 00 00	 lea	 r8, QWORD PTR a_nsec$122751[rsp]
  001f7	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR a_sec$122749[rsp]
  001ff	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR times$[rsp]
  00207	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0020b	e8 00 00 00 00	 call	 _PyTime_ObjectToTimespec
  00210	83 f8 ff	 cmp	 eax, -1
  00213	74 26		 je	 SHORT $LN21@posix_utim
  00215	4c 8d 84 24 68
	01 00 00	 lea	 r8, QWORD PTR m_nsec$122752[rsp]
  0021d	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR m_sec$122750[rsp]
  00225	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR times$[rsp]
  0022d	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00231	e8 00 00 00 00	 call	 _PyTime_ObjectToTimespec
  00236	83 f8 ff	 cmp	 eax, -1
  00239	75 05		 jne	 SHORT $LN22@posix_utim
$LN21@posix_utim:

; 4802 :             goto exit;

  0023b	e9 25 03 00 00	 jmp	 $exit$122747
$LN22@posix_utim:

; 4803 :         }
; 4804 :         utime.atime_s = a_sec;

  00240	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR a_sec$122749[rsp]
  00248	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR utime$[rsp+8], rax

; 4805 :         utime.atime_ns = a_nsec;

  00250	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR a_nsec$122751[rsp]
  00257	89 84 24 88 00
	00 00		 mov	 DWORD PTR utime$[rsp+16], eax

; 4806 :         utime.mtime_s = m_sec;

  0025e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR m_sec$122750[rsp]
  00266	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR utime$[rsp+24], rax

; 4807 :         utime.mtime_ns = m_nsec;

  0026e	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR m_nsec$122752[rsp]
  00275	89 84 24 98 00
	00 00		 mov	 DWORD PTR utime$[rsp+32], eax
  0027c	e9 a1 00 00 00	 jmp	 $LN20@posix_utim
$LN25@posix_utim:

; 4808 :     }
; 4809 :     else if (ns) {

  00281	48 83 7c 24 60
	00		 cmp	 QWORD PTR ns$[rsp], 0
  00287	0f 84 8d 00 00
	00		 je	 $LN19@posix_utim

; 4810 :         if (!PyTuple_CheckExact(ns) || (PyTuple_Size(ns) != 2)) {

  0028d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  00294	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ns$[rsp]
  00299	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0029d	75 10		 jne	 SHORT $LN17@posix_utim
  0029f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ns$[rsp]
  002a4	e8 00 00 00 00	 call	 PyTuple_Size
  002a9	48 83 f8 02	 cmp	 rax, 2
  002ad	74 18		 je	 SHORT $LN18@posix_utim
$LN17@posix_utim:

; 4811 :             PyErr_SetString(PyExc_TypeError,
; 4812 :                          "utime: 'ns' must be a tuple of two ints");

  002af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@HLLNEJKH@utime?3?5?8ns?8?5must?5be?5a?5tuple?5of?5t@
  002b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002bd	e8 00 00 00 00	 call	 PyErr_SetString

; 4813 :             goto exit;

  002c2	e9 9e 02 00 00	 jmp	 $exit$122747
$LN18@posix_utim:

; 4814 :         }
; 4815 :         utime.now = 0;

  002c7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR utime$[rsp], 0

; 4816 :         if (!split_py_long_to_s_and_ns(PyTuple_GET_ITEM(ns, 0),
; 4817 :                                       &utime.atime_s, &utime.atime_ns) ||
; 4818 :             !split_py_long_to_s_and_ns(PyTuple_GET_ITEM(ns, 1),
; 4819 :                                        &utime.mtime_s, &utime.mtime_ns)) {

  002cf	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR utime$[rsp+16]
  002d7	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR utime$[rsp+8]
  002df	48 8b 44 24 60	 mov	 rax, QWORD PTR ns$[rsp]
  002e4	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  002e8	e8 00 00 00 00	 call	 split_py_long_to_s_and_ns
  002ed	85 c0		 test	 eax, eax
  002ef	74 22		 je	 SHORT $LN15@posix_utim
  002f1	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR utime$[rsp+32]
  002f9	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR utime$[rsp+24]
  00301	48 8b 44 24 60	 mov	 rax, QWORD PTR ns$[rsp]
  00306	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  0030a	e8 00 00 00 00	 call	 split_py_long_to_s_and_ns
  0030f	85 c0		 test	 eax, eax
  00311	75 05		 jne	 SHORT $LN16@posix_utim
$LN15@posix_utim:

; 4820 :             goto exit;

  00313	e9 4d 02 00 00	 jmp	 $exit$122747
$LN16@posix_utim:

; 4821 :         }
; 4822 :     }
; 4823 :     else {

  00318	eb 08		 jmp	 SHORT $LN14@posix_utim
$LN19@posix_utim:

; 4824 :         /* times and ns are both None/unspecified. use "now". */
; 4825 :         utime.now = 1;

  0031a	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR utime$[rsp], 1
$LN14@posix_utim:
$LN20@posix_utim:

; 4826 :     }
; 4827 : 
; 4828 : #if !UTIME_HAVE_NOFOLLOW_SYMLINKS
; 4829 :     if (follow_symlinks_specified("utime", follow_symlinks))

  00322	8b 94 24 f0 00
	00 00		 mov	 edx, DWORD PTR follow_symlinks$[rsp]
  00329	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HCLPLDJ@utime?$AA@
  00330	e8 00 00 00 00	 call	 follow_symlinks_specified
  00335	85 c0		 test	 eax, eax
  00337	74 05		 je	 SHORT $LN13@posix_utim

; 4830 :         goto exit;

  00339	e9 27 02 00 00	 jmp	 $exit$122747
$LN13@posix_utim:

; 4831 : #endif
; 4832 : 
; 4833 :     if (path_and_dir_fd_invalid("utime", &path, dir_fd) ||
; 4834 :         dir_fd_and_fd_invalid("utime", dir_fd, path.fd) ||
; 4835 :         fd_and_follow_symlinks_invalid("utime", path.fd, follow_symlinks))

  0033e	44 8b 44 24 68	 mov	 r8d, DWORD PTR dir_fd$[rsp]
  00343	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR path$[rsp]
  0034b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HCLPLDJ@utime?$AA@
  00352	e8 00 00 00 00	 call	 path_and_dir_fd_invalid
  00357	85 c0		 test	 eax, eax
  00359	75 3b		 jne	 SHORT $LN11@posix_utim
  0035b	44 8b 84 24 28
	01 00 00	 mov	 r8d, DWORD PTR path$[rsp+40]
  00363	8b 54 24 68	 mov	 edx, DWORD PTR dir_fd$[rsp]
  00367	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HCLPLDJ@utime?$AA@
  0036e	e8 00 00 00 00	 call	 dir_fd_and_fd_invalid
  00373	85 c0		 test	 eax, eax
  00375	75 1f		 jne	 SHORT $LN11@posix_utim
  00377	44 8b 84 24 f0
	00 00 00	 mov	 r8d, DWORD PTR follow_symlinks$[rsp]
  0037f	8b 94 24 28 01
	00 00		 mov	 edx, DWORD PTR path$[rsp+40]
  00386	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HCLPLDJ@utime?$AA@
  0038d	e8 00 00 00 00	 call	 fd_and_follow_symlinks_invalid
  00392	85 c0		 test	 eax, eax
  00394	74 05		 je	 SHORT $LN12@posix_utim
$LN11@posix_utim:

; 4836 :         goto exit;

  00396	e9 ca 01 00 00	 jmp	 $exit$122747
$LN12@posix_utim:

; 4837 : 
; 4838 : #if !defined(HAVE_UTIMENSAT)
; 4839 :     if ((dir_fd != DEFAULT_DIR_FD) && (!follow_symlinks)) {

  0039b	83 7c 24 68 9c	 cmp	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH
  003a0	74 22		 je	 SHORT $LN10@posix_utim
  003a2	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR follow_symlinks$[rsp], 0
  003aa	75 18		 jne	 SHORT $LN10@posix_utim

; 4840 :         PyErr_SetString(PyExc_ValueError,
; 4841 :                      "utime: cannot use dir_fd and follow_symlinks "
; 4842 :                      "together on this platform");

  003ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EH@ONDHDFNE@utime?3?5cannot?5use?5dir_fd?5and?5fol@
  003b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  003ba	e8 00 00 00 00	 call	 PyErr_SetString

; 4843 :         goto exit;

  003bf	e9 a1 01 00 00	 jmp	 $exit$122747
$LN10@posix_utim:

; 4844 :     }
; 4845 : #endif
; 4846 : 
; 4847 : #ifdef MS_WINDOWS
; 4848 :     Py_BEGIN_ALLOW_THREADS

  003c4	e8 00 00 00 00	 call	 PyEval_SaveThread
  003c9	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR _save$122778[rsp], rax

; 4849 :     if (path.wide)

  003d1	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR path$[rsp+24], 0
  003da	74 3c		 je	 SHORT $LN9@posix_utim

; 4850 :         hFile = CreateFileW(path.wide, FILE_WRITE_ATTRIBUTES, 0,
; 4851 :                             NULL, OPEN_EXISTING,
; 4852 :                             FILE_FLAG_BACKUP_SEMANTICS, NULL);

  003dc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003e5	c7 44 24 28 00
	00 00 02	 mov	 DWORD PTR [rsp+40], 33554432 ; 02000000H
  003ed	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  003f5	45 33 c9	 xor	 r9d, r9d
  003f8	45 33 c0	 xor	 r8d, r8d
  003fb	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00400	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR path$[rsp+24]
  00408	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW
  0040e	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR hFile$[rsp], rax

; 4853 :     else

  00416	eb 3a		 jmp	 SHORT $LN8@posix_utim
$LN9@posix_utim:

; 4854 :         hFile = CreateFileA(path.narrow, FILE_WRITE_ATTRIBUTES, 0,
; 4855 :                             NULL, OPEN_EXISTING,
; 4856 :                             FILE_FLAG_BACKUP_SEMANTICS, NULL);

  00418	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00421	c7 44 24 28 00
	00 00 02	 mov	 DWORD PTR [rsp+40], 33554432 ; 02000000H
  00429	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00431	45 33 c9	 xor	 r9d, r9d
  00434	45 33 c0	 xor	 r8d, r8d
  00437	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0043c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  00444	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  0044a	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR hFile$[rsp], rax
$LN8@posix_utim:

; 4857 :     Py_END_ALLOW_THREADS

  00452	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR _save$122778[rsp]
  0045a	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 4858 :     if (hFile == INVALID_HANDLE_VALUE) {

  0045f	48 83 bc 24 d8
	00 00 00 ff	 cmp	 QWORD PTR hFile$[rsp], -1
  00468	75 19		 jne	 SHORT $LN7@posix_utim

; 4859 :         win32_error_object("utime", path.object);

  0046a	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR path$[rsp+56]
  00472	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HCLPLDJ@utime?$AA@
  00479	e8 00 00 00 00	 call	 win32_error_object

; 4860 :         goto exit;

  0047e	e9 e2 00 00 00	 jmp	 $exit$122747
$LN7@posix_utim:

; 4861 :     }
; 4862 : 
; 4863 :     if (utime.now) {

  00483	83 7c 24 78 00	 cmp	 DWORD PTR utime$[rsp], 0
  00488	74 57		 je	 SHORT $LN6@posix_utim

; 4864 :         SYSTEMTIME now;
; 4865 :         GetSystemTime(&now);

  0048a	48 8d 8c 24 78
	01 00 00	 lea	 rcx, QWORD PTR now$122789[rsp]
  00492	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemTime

; 4866 :         if (!SystemTimeToFileTime(&now, &mtime) ||
; 4867 :             !SystemTimeToFileTime(&now, &atime)) {

  00498	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR mtime$[rsp]
  004a0	48 8d 8c 24 78
	01 00 00	 lea	 rcx, QWORD PTR now$122789[rsp]
  004a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SystemTimeToFileTime
  004ae	85 c0		 test	 eax, eax
  004b0	74 1a		 je	 SHORT $LN4@posix_utim
  004b2	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR atime$[rsp]
  004ba	48 8d 8c 24 78
	01 00 00	 lea	 rcx, QWORD PTR now$122789[rsp]
  004c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SystemTimeToFileTime
  004c8	85 c0		 test	 eax, eax
  004ca	75 13		 jne	 SHORT $LN5@posix_utim
$LN4@posix_utim:

; 4868 :             win32_error("utime", NULL);

  004cc	33 d2		 xor	 edx, edx
  004ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HCLPLDJ@utime?$AA@
  004d5	e8 00 00 00 00	 call	 win32_error

; 4869 :             goto exit;

  004da	e9 86 00 00 00	 jmp	 $exit$122747
$LN5@posix_utim:

; 4870 :         }
; 4871 :     }
; 4872 :     else {

  004df	eb 38		 jmp	 SHORT $LN3@posix_utim
$LN6@posix_utim:

; 4873 :         time_t_to_FILE_TIME(utime.atime_s, utime.atime_ns, &atime);

  004e1	4c 8d 84 24 e8
	00 00 00	 lea	 r8, QWORD PTR atime$[rsp]
  004e9	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR utime$[rsp+16]
  004f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR utime$[rsp+8]
  004f8	e8 00 00 00 00	 call	 time_t_to_FILE_TIME

; 4874 :         time_t_to_FILE_TIME(utime.mtime_s, utime.mtime_ns, &mtime);

  004fd	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR mtime$[rsp]
  00505	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR utime$[rsp+32]
  0050c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR utime$[rsp+24]
  00514	e8 00 00 00 00	 call	 time_t_to_FILE_TIME
$LN3@posix_utim:

; 4875 :     }
; 4876 :     if (!SetFileTime(hFile, NULL, &atime, &mtime)) {

  00519	4c 8d 8c 24 d0
	00 00 00	 lea	 r9, QWORD PTR mtime$[rsp]
  00521	4c 8d 84 24 e8
	00 00 00	 lea	 r8, QWORD PTR atime$[rsp]
  00529	33 d2		 xor	 edx, edx
  0052b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  00533	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetFileTime
  00539	85 c0		 test	 eax, eax
  0053b	75 10		 jne	 SHORT $LN2@posix_utim

; 4877 :         /* Avoid putting the file name into the error here,
; 4878 :            as that may confuse the user into believing that
; 4879 :            something is wrong with the file, when it also
; 4880 :            could be the time stamp that gives a problem. */
; 4881 :         win32_error("utime", NULL);

  0053d	33 d2		 xor	 edx, edx
  0053f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HCLPLDJ@utime?$AA@
  00546	e8 00 00 00 00	 call	 win32_error

; 4882 :         goto exit;

  0054b	eb 18		 jmp	 SHORT $exit$122747
$LN2@posix_utim:

; 4883 :     }
; 4884 : #else /* MS_WINDOWS */
; 4885 :     Py_BEGIN_ALLOW_THREADS
; 4886 : 
; 4887 : #if UTIME_HAVE_NOFOLLOW_SYMLINKS
; 4888 :     if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))
; 4889 :         result = utime_nofollow_symlinks(&utime, path.narrow);
; 4890 :     else
; 4891 : #endif
; 4892 : 
; 4893 : #if UTIME_HAVE_DIR_FD
; 4894 :     if ((dir_fd != DEFAULT_DIR_FD) || (!follow_symlinks))
; 4895 :         result = utime_dir_fd(&utime, dir_fd, path.narrow, follow_symlinks);
; 4896 :     else
; 4897 : #endif
; 4898 : 
; 4899 : #if UTIME_HAVE_FD
; 4900 :     if (path.fd != -1)
; 4901 :         result = utime_fd(&utime, path.fd);
; 4902 :     else
; 4903 : #endif
; 4904 : 
; 4905 :     result = utime_default(&utime, path.narrow);
; 4906 : 
; 4907 :     Py_END_ALLOW_THREADS
; 4908 : 
; 4909 :     if (result < 0) {
; 4910 :         /* see previous comment about not putting filename in error here */
; 4911 :         return_value = posix_error();
; 4912 :         goto exit;
; 4913 :     }
; 4914 : 
; 4915 : #endif /* MS_WINDOWS */
; 4916 : 
; 4917 :     Py_INCREF(Py_None);

  0054d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00554	e8 00 00 00 00	 call	 _Py_IncRef

; 4918 :     return_value = Py_None;

  00559	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00560	48 89 44 24 70	 mov	 QWORD PTR return_value$[rsp], rax
$exit$122747:

; 4919 : 
; 4920 : exit:
; 4921 :     path_cleanup(&path);

  00565	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  0056d	e8 00 00 00 00	 call	 path_cleanup

; 4922 : #ifdef MS_WINDOWS
; 4923 :     if (hFile != INVALID_HANDLE_VALUE)

  00572	48 83 bc 24 d8
	00 00 00 ff	 cmp	 QWORD PTR hFile$[rsp], -1
  0057b	74 0e		 je	 SHORT $LN1@posix_utim

; 4924 :         CloseHandle(hFile);

  0057d	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR hFile$[rsp]
  00585	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN1@posix_utim:

; 4925 : #endif
; 4926 :     return return_value;

  0058b	48 8b 44 24 70	 mov	 rax, QWORD PTR return_value$[rsp]
$LN28@posix_utim:

; 4927 : }

  00590	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00597	c3		 ret	 0
posix_utime ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$time_t_to_FILE_TIME DD imagerel time_t_to_FILE_TIME
	DD	imagerel time_t_to_FILE_TIME+114
	DD	imagerel $unwind$time_t_to_FILE_TIME
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$time_t_to_FILE_TIME DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT time_t_to_FILE_TIME
_TEXT	SEGMENT
out$ = 32
tv65 = 40
time_in$ = 64
nsec_in$ = 72
out_ptr$ = 80
time_t_to_FILE_TIME PROC				; COMDAT

; 1558 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1559 :     /* XXX endianness */
; 1560 :     __int64 out;
; 1561 :     out = time_in + secs_between_epochs;

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR secs_between_epochs
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR time_in$[rsp]
  0001e	48 03 c8	 add	 rcx, rax
  00021	48 8b c1	 mov	 rax, rcx
  00024	48 89 44 24 20	 mov	 QWORD PTR out$[rsp], rax

; 1562 :     out = out * 10000000 + nsec_in / 100;

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]
  0002e	48 69 c0 80 96
	98 00		 imul	 rax, 10000000		; 00989680H
  00035	48 89 44 24 28	 mov	 QWORD PTR tv65[rsp], rax
  0003a	8b 44 24 48	 mov	 eax, DWORD PTR nsec_in$[rsp]
  0003e	99		 cdq
  0003f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00044	f7 f9		 idiv	 ecx
  00046	48 98		 cdqe
  00048	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv65[rsp]
  0004d	48 03 c8	 add	 rcx, rax
  00050	48 8b c1	 mov	 rax, rcx
  00053	48 89 44 24 20	 mov	 QWORD PTR out$[rsp], rax

; 1563 :     memcpy(out_ptr, &out, sizeof(out));

  00058	41 b8 08 00 00
	00		 mov	 r8d, 8
  0005e	48 8d 54 24 20	 lea	 rdx, QWORD PTR out$[rsp]
  00063	48 8b 4c 24 50	 mov	 rcx, QWORD PTR out_ptr$[rsp]
  00068	e8 00 00 00 00	 call	 memcpy

; 1564 : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
time_t_to_FILE_TIME ENDP
_TEXT	ENDS
EXTRN	PyLong_AsLong:PROC
EXTRN	_PyLong_AsTime_t:PROC
EXTRN	PyNumber_Divmod:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$split_py_long_to_s_and_ns DD imagerel split_py_long_to_s_and_ns
	DD	imagerel split_py_long_to_s_and_ns+188
	DD	imagerel $unwind$split_py_long_to_s_and_ns
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$split_py_long_to_s_and_ns DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT split_py_long_to_s_and_ns
_TEXT	SEGMENT
divmod$ = 32
result$ = 40
py_long$ = 64
s$ = 72
ns$ = 80
split_py_long_to_s_and_ns PROC				; COMDAT

; 4722 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4723 :     int result = 0;

  00013	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 4724 :     PyObject *divmod;
; 4725 :     divmod = PyNumber_Divmod(py_long, billion);

  0001b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR billion
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR py_long$[rsp]
  00027	e8 00 00 00 00	 call	 PyNumber_Divmod
  0002c	48 89 44 24 20	 mov	 QWORD PTR divmod$[rsp], rax

; 4726 :     if (!divmod)

  00031	48 83 7c 24 20
	00		 cmp	 QWORD PTR divmod$[rsp], 0
  00037	75 02		 jne	 SHORT $LN7@split_py_l

; 4727 :         goto exit;

  00039	eb 60		 jmp	 SHORT $exit$122706
$LN7@split_py_l:

; 4728 :     *s = _PyLong_AsTime_t(PyTuple_GET_ITEM(divmod, 0));

  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR divmod$[rsp]
  00040	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00044	e8 00 00 00 00	 call	 _PyLong_AsTime_t
  00049	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0004e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 4729 :     if ((*s == -1) && PyErr_Occurred())

  00051	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00056	48 83 38 ff	 cmp	 QWORD PTR [rax], -1
  0005a	75 0c		 jne	 SHORT $LN6@split_py_l
  0005c	e8 00 00 00 00	 call	 PyErr_Occurred
  00061	48 85 c0	 test	 rax, rax
  00064	74 02		 je	 SHORT $LN6@split_py_l

; 4730 :         goto exit;

  00066	eb 33		 jmp	 SHORT $exit$122706
$LN6@split_py_l:

; 4731 :     *ns = PyLong_AsLong(PyTuple_GET_ITEM(divmod, 1));

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR divmod$[rsp]
  0006d	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00071	e8 00 00 00 00	 call	 PyLong_AsLong
  00076	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ns$[rsp]
  0007b	89 01		 mov	 DWORD PTR [rcx], eax

; 4732 :     if ((*ns == -1) && PyErr_Occurred())

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR ns$[rsp]
  00082	83 38 ff	 cmp	 DWORD PTR [rax], -1
  00085	75 0c		 jne	 SHORT $LN5@split_py_l
  00087	e8 00 00 00 00	 call	 PyErr_Occurred
  0008c	48 85 c0	 test	 rax, rax
  0008f	74 02		 je	 SHORT $LN5@split_py_l

; 4733 :         goto exit;

  00091	eb 08		 jmp	 SHORT $exit$122706
$LN5@split_py_l:

; 4734 : 
; 4735 :     result = 1;

  00093	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR result$[rsp], 1
$exit$122706:
$LN4@split_py_l:

; 4736 : exit:
; 4737 :     Py_XDECREF(divmod);

  0009b	48 83 7c 24 20
	00		 cmp	 QWORD PTR divmod$[rsp], 0
  000a1	74 0a		 je	 SHORT $LN1@split_py_l
  000a3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR divmod$[rsp]
  000a8	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@split_py_l:
  000ad	33 c0		 xor	 eax, eax
  000af	85 c0		 test	 eax, eax
  000b1	75 e8		 jne	 SHORT $LN4@split_py_l

; 4738 :     return result;

  000b3	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]

; 4739 : }

  000b7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bb	c3		 ret	 0
split_py_long_to_s_and_ns ENDP
_TEXT	ENDS
PUBLIC	??_C@_07FHLOOHCL@i?3_exit?$AA@			; `string'
EXTRN	__imp__exit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix__exit DD imagerel posix__exit
	DD	imagerel posix__exit+61
	DD	imagerel $unwind$posix__exit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix__exit DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_07FHLOOHCL@i?3_exit?$AA@
CONST	SEGMENT
??_C@_07FHLOOHCL@i?3_exit?$AA@ DB 'i:_exit', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix__exit
_TEXT	SEGMENT
sts$ = 32
self$ = 64
args$ = 72
posix__exit PROC					; COMDAT

; 4937 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4938 :     int sts;
; 4939 :     if (!PyArg_ParseTuple(args, "i:_exit", &sts))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR sts$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07FHLOOHCL@i?3_exit?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN1@posix__exi

; 4940 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 0c		 jmp	 SHORT $LN2@posix__exi
$LN1@posix__exi:

; 4941 :     _exit(sts);

  0002c	8b 4c 24 20	 mov	 ecx, DWORD PTR sts$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__exit

; 4942 :     return NULL; /* Make gcc -Wall happy */

  00036	33 c0		 xor	 eax, eax
$LN2@posix__exi:
$LN3@posix__exi:

; 4943 : }

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	c3		 ret	 0
posix__exit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@GNLAHJII@execv?$CI?$CJ?5arg?52?5must?5not?5be?5empty?$AA@ ; `string'
PUBLIC	??_C@_0CG@OHPHFDOP@execv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5or@ ; `string'
PUBLIC	??_C@_09NABGIDAP@O?$CGO?3execv?$AA@		; `string'
EXTRN	__imp_execv:PROC
EXTRN	PySequence_Size:PROC
EXTRN	PyBytes_AsString:PROC
EXTRN	PyUnicode_FSConverter:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_execv DD imagerel posix_execv
	DD	imagerel posix_execv+312
	DD	imagerel $unwind$posix_execv
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_execv DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0CA@GNLAHJII@execv?$CI?$CJ?5arg?52?5must?5not?5be?5empty?$AA@
CONST	SEGMENT
??_C@_0CA@GNLAHJII@execv?$CI?$CJ?5arg?52?5must?5not?5be?5empty?$AA@ DB 'e'
	DB	'xecv() arg 2 must not be empty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@OHPHFDOP@execv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5or@
CONST	SEGMENT
??_C@_0CG@OHPHFDOP@execv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5or@ DB 'exe'
	DB	'cv() arg 2 must be a tuple or list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NABGIDAP@O?$CGO?3execv?$AA@
CONST	SEGMENT
??_C@_09NABGIDAP@O?$CGO?3execv?$AA@ DB 'O&O:execv', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_execv
_TEXT	SEGMENT
argc$ = 48
argv$ = 56
opath$ = 64
path$ = 72
argvlist$ = 80
self$ = 112
args$ = 120
posix_execv PROC					; COMDAT

; 5092 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 5093 :     PyObject *opath;
; 5094 :     char *path;
; 5095 :     PyObject *argv;
; 5096 :     char **argvlist;
; 5097 :     Py_ssize_t argc;
; 5098 : 
; 5099 :     /* execv has two arguments: (path, argv), where
; 5100 :        argv is a list or tuple of strings. */
; 5101 : 
; 5102 :     if (!PyArg_ParseTuple(args, "O&O:execv",
; 5103 :                           PyUnicode_FSConverter,
; 5104 :                           &opath, &argv))

  0000e	48 8d 44 24 38	 lea	 rax, QWORD PTR argv$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00018	4c 8d 4c 24 40	 lea	 r9, QWORD PTR opath$[rsp]
  0001d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyUnicode_FSConverter
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09NABGIDAP@O?$CGO?3execv?$AA@
  0002b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00030	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN4@posix_exec

; 5105 :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 f3 00 00 00	 jmp	 $LN5@posix_exec
$LN4@posix_exec:

; 5106 :     path = PyBytes_AsString(opath);

  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR opath$[rsp]
  00045	e8 00 00 00 00	 call	 PyBytes_AsString
  0004a	48 89 44 24 48	 mov	 QWORD PTR path$[rsp], rax

; 5107 :     if (!PyList_Check(argv) && !PyTuple_Check(argv)) {

  0004f	48 8b 44 24 38	 mov	 rax, QWORD PTR argv$[rsp]
  00054	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00058	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005e	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00063	85 c0		 test	 eax, eax
  00065	75 3c		 jne	 SHORT $LN3@posix_exec
  00067	48 8b 44 24 38	 mov	 rax, QWORD PTR argv$[rsp]
  0006c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00070	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00076	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0007b	85 c0		 test	 eax, eax
  0007d	75 24		 jne	 SHORT $LN3@posix_exec

; 5108 :         PyErr_SetString(PyExc_TypeError,
; 5109 :                         "execv() arg 2 must be a tuple or list");

  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@OHPHFDOP@execv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5or@
  00086	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0008d	e8 00 00 00 00	 call	 PyErr_SetString

; 5110 :         Py_DECREF(opath);

  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR opath$[rsp]
  00097	e8 00 00 00 00	 call	 _Py_DecRef

; 5111 :         return NULL;

  0009c	33 c0		 xor	 eax, eax
  0009e	e9 90 00 00 00	 jmp	 $LN5@posix_exec
$LN3@posix_exec:

; 5112 :     }
; 5113 :     argc = PySequence_Size(argv);

  000a3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR argv$[rsp]
  000a8	e8 00 00 00 00	 call	 PySequence_Size
  000ad	48 89 44 24 30	 mov	 QWORD PTR argc$[rsp], rax

; 5114 :     if (argc < 1) {

  000b2	48 83 7c 24 30
	01		 cmp	 QWORD PTR argc$[rsp], 1
  000b8	7d 21		 jge	 SHORT $LN2@posix_exec

; 5115 :         PyErr_SetString(PyExc_ValueError, "execv() arg 2 must not be empty");

  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@GNLAHJII@execv?$CI?$CJ?5arg?52?5must?5not?5be?5empty?$AA@
  000c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000c8	e8 00 00 00 00	 call	 PyErr_SetString

; 5116 :         Py_DECREF(opath);

  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR opath$[rsp]
  000d2	e8 00 00 00 00	 call	 _Py_DecRef

; 5117 :         return NULL;

  000d7	33 c0		 xor	 eax, eax
  000d9	eb 58		 jmp	 SHORT $LN5@posix_exec
$LN2@posix_exec:

; 5118 :     }
; 5119 : 
; 5120 :     argvlist = parse_arglist(argv, &argc);

  000db	48 8d 54 24 30	 lea	 rdx, QWORD PTR argc$[rsp]
  000e0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR argv$[rsp]
  000e5	e8 00 00 00 00	 call	 parse_arglist
  000ea	48 89 44 24 50	 mov	 QWORD PTR argvlist$[rsp], rax

; 5121 :     if (argvlist == NULL) {

  000ef	48 83 7c 24 50
	00		 cmp	 QWORD PTR argvlist$[rsp], 0
  000f5	75 0e		 jne	 SHORT $LN1@posix_exec

; 5122 :         Py_DECREF(opath);

  000f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR opath$[rsp]
  000fc	e8 00 00 00 00	 call	 _Py_DecRef

; 5123 :         return NULL;

  00101	33 c0		 xor	 eax, eax
  00103	eb 2e		 jmp	 SHORT $LN5@posix_exec
$LN1@posix_exec:

; 5124 :     }
; 5125 : 
; 5126 :     execv(path, argvlist);

  00105	48 8b 54 24 50	 mov	 rdx, QWORD PTR argvlist$[rsp]
  0010a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR path$[rsp]
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_execv

; 5127 : 
; 5128 :     /* If we get here it's definitely an error */
; 5129 : 
; 5130 :     free_string_array(argvlist, argc);

  00115	48 8b 54 24 30	 mov	 rdx, QWORD PTR argc$[rsp]
  0011a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR argvlist$[rsp]
  0011f	e8 00 00 00 00	 call	 free_string_array

; 5131 :     Py_DECREF(opath);

  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR opath$[rsp]
  00129	e8 00 00 00 00	 call	 _Py_DecRef

; 5132 :     return posix_error();

  0012e	e8 00 00 00 00	 call	 posix_error
$LN5@posix_exec:

; 5133 : }

  00133	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00137	c3		 ret	 0
posix_execv ENDP
_TEXT	ENDS
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	PyMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$free_string_array DD imagerel free_string_array
	DD	imagerel free_string_array+123
	DD	imagerel $unwind$free_string_array
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$free_string_array DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT free_string_array
_TEXT	SEGMENT
i$ = 32
tv73 = 40
array$ = 64
count$ = 72
free_string_array PROC					; COMDAT

; 4948 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4949 :     Py_ssize_t i;
; 4950 :     for (i = 0; i < count; i++)

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	eb 0d		 jmp	 SHORT $LN3@free_strin
$LN2@free_strin:
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0001e	48 ff c0	 inc	 rax
  00021	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@free_strin:
  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR count$[rsp]
  0002b	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00030	7d 15		 jge	 SHORT $LN1@free_strin

; 4951 :         PyMem_Free(array[i]);

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR array$[rsp]
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0003c	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00040	e8 00 00 00 00	 call	 PyMem_Free
  00045	eb d2		 jmp	 SHORT $LN2@free_strin
$LN1@free_strin:

; 4952 :     PyMem_DEL(array);

  00047	e8 00 00 00 00	 call	 _Py_PXCTX
  0004c	85 c0		 test	 eax, eax
  0004e	74 14		 je	 SHORT $LN6@free_strin
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR array$[rsp]
  00055	e8 00 00 00 00	 call	 _PxMem_Free
  0005a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  00062	eb 12		 jmp	 SHORT $LN7@free_strin
$LN6@free_strin:
  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR array$[rsp]
  00069	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0006e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN7@free_strin:

; 4953 : }

  00076	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007a	c3		 ret	 0
free_string_array ENDP
_TEXT	ENDS
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_arglist DD imagerel parse_arglist
	DD	imagerel parse_arglist+376
	DD	imagerel $unwind$parse_arglist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_arglist DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT parse_arglist
_TEXT	SEGMENT
i$ = 32
argvlist$ = 40
item$122955 = 48
tv77 = 56
tv76 = 64
tv137 = 72
argv$ = 96
argc$ = 104
parse_arglist PROC					; COMDAT

; 5056 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5057 :     int i;
; 5058 :     char **argvlist = PyMem_NEW(char *, *argc+1);

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR argc$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 ff c0	 inc	 rax
  00019	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  00023	48 3b c1	 cmp	 rax, rcx
  00026	76 0b		 jbe	 SHORT $LN11@parse_argl
  00028	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv77[rsp], 0
  00031	eb 4f		 jmp	 SHORT $LN12@parse_argl
$LN11@parse_argl:
  00033	e8 00 00 00 00	 call	 _Py_PXCTX
  00038	85 c0		 test	 eax, eax
  0003a	74 1f		 je	 SHORT $LN9@parse_argl
  0003c	48 8b 44 24 68	 mov	 rax, QWORD PTR argc$[rsp]
  00041	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00044	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	e8 00 00 00 00	 call	 _PxMem_Malloc
  00054	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
  00059	eb 1d		 jmp	 SHORT $LN10@parse_argl
$LN9@parse_argl:
  0005b	48 8b 44 24 68	 mov	 rax, QWORD PTR argc$[rsp]
  00060	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00063	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  0006b	48 8b c8	 mov	 rcx, rax
  0006e	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00073	48 89 44 24 40	 mov	 QWORD PTR tv76[rsp], rax
$LN10@parse_argl:
  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR tv76[rsp]
  0007d	48 89 44 24 38	 mov	 QWORD PTR tv77[rsp], rax
$LN12@parse_argl:
  00082	48 8b 44 24 38	 mov	 rax, QWORD PTR tv77[rsp]
  00087	48 89 44 24 28	 mov	 QWORD PTR argvlist$[rsp], rax

; 5059 :     if (argvlist == NULL) {

  0008c	48 83 7c 24 28
	00		 cmp	 QWORD PTR argvlist$[rsp], 0
  00092	75 0c		 jne	 SHORT $LN6@parse_argl

; 5060 :         PyErr_NoMemory();

  00094	e8 00 00 00 00	 call	 PyErr_NoMemory

; 5061 :         return NULL;

  00099	33 c0		 xor	 eax, eax
  0009b	e9 d3 00 00 00	 jmp	 $LN7@parse_argl
$LN6@parse_argl:

; 5062 :     }
; 5063 :     for (i = 0; i < *argc; i++) {

  000a0	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000a8	eb 0a		 jmp	 SHORT $LN5@parse_argl
$LN4@parse_argl:
  000aa	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000ae	ff c0		 inc	 eax
  000b0	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN5@parse_argl:
  000b4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argc$[rsp]
  000be	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  000c1	7d 73		 jge	 SHORT $LN3@parse_argl

; 5064 :         PyObject* item = PySequence_ITEM(argv, i);

  000c3	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000c8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR argv$[rsp]
  000cd	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  000d1	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  000d8	48 89 4c 24 48	 mov	 QWORD PTR tv137[rsp], rcx
  000dd	48 8b d0	 mov	 rdx, rax
  000e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR argv$[rsp]
  000e5	48 8b 44 24 48	 mov	 rax, QWORD PTR tv137[rsp]
  000ea	ff 50 18	 call	 QWORD PTR [rax+24]
  000ed	48 89 44 24 30	 mov	 QWORD PTR item$122955[rsp], rax

; 5065 :         if (item == NULL)

  000f2	48 83 7c 24 30
	00		 cmp	 QWORD PTR item$122955[rsp], 0
  000f8	75 02		 jne	 SHORT $LN2@parse_argl

; 5066 :             goto fail;

  000fa	eb 56		 jmp	 SHORT $fail$122959
$LN2@parse_argl:

; 5067 :         if (!fsconvert_strdup(item, &argvlist[i])) {

  000fc	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00101	48 8b 4c 24 28	 mov	 rcx, QWORD PTR argvlist$[rsp]
  00106	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0010a	48 8b d0	 mov	 rdx, rax
  0010d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$122955[rsp]
  00112	e8 00 00 00 00	 call	 fsconvert_strdup
  00117	85 c0		 test	 eax, eax
  00119	75 0c		 jne	 SHORT $LN1@parse_argl

; 5068 :             Py_DECREF(item);

  0011b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$122955[rsp]
  00120	e8 00 00 00 00	 call	 _Py_DecRef

; 5069 :             goto fail;

  00125	eb 2b		 jmp	 SHORT $fail$122959
$LN1@parse_argl:

; 5070 :         }
; 5071 :         Py_DECREF(item);

  00127	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$122955[rsp]
  0012c	e8 00 00 00 00	 call	 _Py_DecRef

; 5072 :     }

  00131	e9 74 ff ff ff	 jmp	 $LN4@parse_argl
$LN3@parse_argl:

; 5073 :     argvlist[*argc] = NULL;

  00136	48 8b 44 24 68	 mov	 rax, QWORD PTR argc$[rsp]
  0013b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0013e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR argvlist$[rsp]
  00143	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 5074 :     return argvlist;

  0014b	48 8b 44 24 28	 mov	 rax, QWORD PTR argvlist$[rsp]
  00150	eb 21		 jmp	 SHORT $LN7@parse_argl
$fail$122959:

; 5075 : fail:
; 5076 :     *argc = i;

  00152	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00157	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argc$[rsp]
  0015c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 5077 :     free_string_array(argvlist, *argc);

  0015f	48 8b 44 24 68	 mov	 rax, QWORD PTR argc$[rsp]
  00164	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00167	48 8b 4c 24 28	 mov	 rcx, QWORD PTR argvlist$[rsp]
  0016c	e8 00 00 00 00	 call	 free_string_array

; 5078 :     return NULL;

  00171	33 c0		 xor	 eax, eax
$LN7@parse_argl:

; 5079 : }

  00173	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00177	c3		 ret	 0
parse_arglist ENDP
_TEXT	ENDS
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fsconvert_strdup DD imagerel fsconvert_strdup
	DD	imagerel fsconvert_strdup+212
	DD	imagerel $unwind$fsconvert_strdup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fsconvert_strdup DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fsconvert_strdup
_TEXT	SEGMENT
size$ = 32
bytes$ = 40
tv82 = 48
o$ = 80
out$ = 88
fsconvert_strdup PROC					; COMDAT

; 4957 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4958 :     PyObject *bytes;
; 4959 :     Py_ssize_t size;
; 4960 :     if (!PyUnicode_FSConverter(o, &bytes))

  0000e	48 8d 54 24 28	 lea	 rdx, QWORD PTR bytes$[rsp]
  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00018	e8 00 00 00 00	 call	 PyUnicode_FSConverter
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN2@fsconvert_

; 4961 :         return 0;

  00021	33 c0		 xor	 eax, eax
  00023	e9 a7 00 00 00	 jmp	 $LN3@fsconvert_
$LN2@fsconvert_:

; 4962 :     size = PyBytes_GET_SIZE(bytes);

  00028	48 8b 44 24 28	 mov	 rax, QWORD PTR bytes$[rsp]
  0002d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00031	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00037	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0003c	85 c0		 test	 eax, eax
  0003e	75 1c		 jne	 SHORT $LN5@fsconvert_
  00040	41 b8 62 13 00
	00		 mov	 r8d, 4962		; 00001362H
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@FILHOKME@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAy?$AAt?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005a	33 c0		 xor	 eax, eax
$LN5@fsconvert_:
  0005c	48 8b 44 24 28	 mov	 rax, QWORD PTR bytes$[rsp]
  00061	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00065	48 89 44 24 20	 mov	 QWORD PTR size$[rsp], rax

; 4963 :     *out = PyMem_Malloc(size+1);

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR size$[rsp]
  0006f	48 ff c0	 inc	 rax
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 PyMem_Malloc
  0007a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR out$[rsp]
  0007f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 4964 :     if (!*out)

  00082	48 8b 44 24 58	 mov	 rax, QWORD PTR out$[rsp]
  00087	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008b	75 04		 jne	 SHORT $LN1@fsconvert_

; 4965 :         return 0;

  0008d	33 c0		 xor	 eax, eax
  0008f	eb 3e		 jmp	 SHORT $LN3@fsconvert_
$LN1@fsconvert_:

; 4966 :     memcpy(*out, PyBytes_AsString(bytes), size+1);

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR size$[rsp]
  00096	48 ff c0	 inc	 rax
  00099	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
  0009e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  000a3	e8 00 00 00 00	 call	 PyBytes_AsString
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv82[rsp]
  000ad	4c 8b c1	 mov	 r8, rcx
  000b0	48 8b d0	 mov	 rdx, rax
  000b3	48 8b 44 24 58	 mov	 rax, QWORD PTR out$[rsp]
  000b8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000bb	e8 00 00 00 00	 call	 memcpy

; 4967 :     Py_DECREF(bytes);

  000c0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  000c5	e8 00 00 00 00	 call	 _Py_DecRef

; 4968 :     return 1;

  000ca	b8 01 00 00 00	 mov	 eax, 1
$LN3@fsconvert_:

; 4969 : }

  000cf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d3	c3		 ret	 0
fsconvert_strdup ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@FOMNEEHL@execve?3?5environment?5must?5be?5a?5ma@ ; `string'
PUBLIC	??_C@_0CF@IBGHFDEE@execve?3?5argv?5must?5be?5a?5tuple?5or?5@ ; `string'
PUBLIC	??_C@_0M@NMCLEMPF@O?$CGOO?3execve?$AA@		; `string'
EXTRN	__imp_execve:PROC
EXTRN	PyMapping_Check:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_execve DD imagerel posix_execve
	DD	imagerel posix_execve+577
	DD	imagerel $unwind$posix_execve
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_execve DD 021601H
	DD	01b0116H
xdata	ENDS
;	COMDAT ??_C@_0CN@FOMNEEHL@execve?3?5environment?5must?5be?5a?5ma@
CONST	SEGMENT
??_C@_0CN@FOMNEEHL@execve?3?5environment?5must?5be?5a?5ma@ DB 'execve: en'
	DB	'vironment must be a mapping object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@IBGHFDEE@execve?3?5argv?5must?5be?5a?5tuple?5or?5@
CONST	SEGMENT
??_C@_0CF@IBGHFDEE@execve?3?5argv?5must?5be?5a?5tuple?5or?5@ DB 'execve: '
	DB	'argv must be a tuple or list', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NMCLEMPF@O?$CGOO?3execve?$AA@
CONST	SEGMENT
??_C@_0M@NMCLEMPF@O?$CGOO?3execve?$AA@ DB 'O&OO:execve', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_execve
_TEXT	SEGMENT
envlist$ = 64
envc$ = 72
argc$ = 80
env$ = 88
argv$ = 96
path$ = 112
argvlist$ = 192
tv149 = 200
tv154 = 204
self$ = 224
args$ = 232
kwargs$ = 240
posix_execve PROC					; COMDAT

; 5149 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 5150 :     path_t path;
; 5151 :     PyObject *argv, *env;
; 5152 :     char **argvlist = NULL;

  00016	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR argvlist$[rsp], 0

; 5153 :     char **envlist;
; 5154 :     Py_ssize_t argc, envc;
; 5155 :     static char *keywords[] = {"path", "argv", "environment", NULL};
; 5156 : 
; 5157 :     /* execve has three arguments: (path, argv, env), where
; 5158 :        argv is a list or tuple of strings and env is a dictionary
; 5159 :        like posix.environ. */
; 5160 : 
; 5161 :     memset(&path, 0, sizeof(path));

  00022	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00028	33 d2		 xor	 edx, edx
  0002a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR path$[rsp]
  0002f	e8 00 00 00 00	 call	 memset

; 5162 : #ifdef HAVE_FEXECVE
; 5163 :     path.allow_fd = 1;
; 5164 : #endif
; 5165 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&OO:execve", keywords,
; 5166 :                           path_converter, &path,
; 5167 :                           &argv, &env
; 5168 :                           ))

  00034	48 8d 44 24 58	 lea	 rax, QWORD PTR env$[rsp]
  00039	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0003e	48 8d 44 24 60	 lea	 rax, QWORD PTR argv$[rsp]
  00043	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00048	48 8d 44 24 70	 lea	 rax, QWORD PTR path$[rsp]
  0004d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  00059	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_execve@@9@9
  00065	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@NMCLEMPF@O?$CGOO?3execve?$AA@
  0006c	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  00074	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0007c	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00081	85 c0		 test	 eax, eax
  00083	75 07		 jne	 SHORT $LN8@posix_exec@2

; 5169 :         return NULL;

  00085	33 c0		 xor	 eax, eax
  00087	e9 ad 01 00 00	 jmp	 $LN9@posix_exec@2
$LN8@posix_exec@2:

; 5170 : 
; 5171 :     if (!PyList_Check(argv) && !PyTuple_Check(argv)) {

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR argv$[rsp]
  00091	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00095	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009b	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  000a0	85 c0		 test	 eax, eax
  000a2	75 30		 jne	 SHORT $LN7@posix_exec@2
  000a4	48 8b 44 24 60	 mov	 rax, QWORD PTR argv$[rsp]
  000a9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ad	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000b3	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  000b8	85 c0		 test	 eax, eax
  000ba	75 18		 jne	 SHORT $LN7@posix_exec@2

; 5172 :         PyErr_SetString(PyExc_TypeError,
; 5173 :                         "execve: argv must be a tuple or list");

  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@IBGHFDEE@execve?3?5argv?5must?5be?5a?5tuple?5or?5@
  000c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ca	e8 00 00 00 00	 call	 PyErr_SetString

; 5174 :         goto fail;

  000cf	e9 3c 01 00 00	 jmp	 $fail$123024
$LN7@posix_exec@2:

; 5175 :     }
; 5176 :     argc = PySequence_Size(argv);

  000d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR argv$[rsp]
  000d9	e8 00 00 00 00	 call	 PySequence_Size
  000de	48 89 44 24 50	 mov	 QWORD PTR argc$[rsp], rax

; 5177 :     if (!PyMapping_Check(env)) {

  000e3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR env$[rsp]
  000e8	e8 00 00 00 00	 call	 PyMapping_Check
  000ed	85 c0		 test	 eax, eax
  000ef	75 18		 jne	 SHORT $LN6@posix_exec@2

; 5178 :         PyErr_SetString(PyExc_TypeError,
; 5179 :                         "execve: environment must be a mapping object");

  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@FOMNEEHL@execve?3?5environment?5must?5be?5a?5ma@
  000f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ff	e8 00 00 00 00	 call	 PyErr_SetString

; 5180 :         goto fail;

  00104	e9 07 01 00 00	 jmp	 $fail$123024
$LN6@posix_exec@2:

; 5181 :     }
; 5182 : 
; 5183 :     argvlist = parse_arglist(argv, &argc);

  00109	48 8d 54 24 50	 lea	 rdx, QWORD PTR argc$[rsp]
  0010e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR argv$[rsp]
  00113	e8 00 00 00 00	 call	 parse_arglist
  00118	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR argvlist$[rsp], rax

; 5184 :     if (argvlist == NULL) {

  00120	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR argvlist$[rsp], 0
  00129	75 05		 jne	 SHORT $LN5@posix_exec@2

; 5185 :         goto fail;

  0012b	e9 e0 00 00 00	 jmp	 $fail$123024
$LN5@posix_exec@2:

; 5186 :     }
; 5187 : 
; 5188 :     envlist = parse_envlist(env, &envc);

  00130	48 8d 54 24 48	 lea	 rdx, QWORD PTR envc$[rsp]
  00135	48 8b 4c 24 58	 mov	 rcx, QWORD PTR env$[rsp]
  0013a	e8 00 00 00 00	 call	 parse_envlist
  0013f	48 89 44 24 40	 mov	 QWORD PTR envlist$[rsp], rax

; 5189 :     if (envlist == NULL)

  00144	48 83 7c 24 40
	00		 cmp	 QWORD PTR envlist$[rsp], 0
  0014a	75 05		 jne	 SHORT $LN4@posix_exec@2

; 5190 :         goto fail;

  0014c	e9 bf 00 00 00	 jmp	 $fail$123024
$LN4@posix_exec@2:

; 5191 : 
; 5192 : #ifdef HAVE_FEXECVE
; 5193 :     if (path.fd > -1)
; 5194 :         fexecve(path.fd, argvlist, envlist);
; 5195 :     else
; 5196 : #endif
; 5197 :         execve(path.narrow, argvlist, envlist);

  00151	4c 8b 44 24 40	 mov	 r8, QWORD PTR envlist$[rsp]
  00156	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR argvlist$[rsp]
  0015e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_execve

; 5198 : 
; 5199 :     /* If we get here it's definitely an error */
; 5200 : 
; 5201 :     path_posix_error("execve", &path);

  0016c	48 8d 54 24 70	 lea	 rdx, QWORD PTR path$[rsp]
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06GMNLOHLP@execve?$AA@
  00178	e8 00 00 00 00	 call	 path_posix_error
$LN3@posix_exec@2:

; 5202 : 
; 5203 :     while (--envc >= 0)

  0017d	48 8b 44 24 48	 mov	 rax, QWORD PTR envc$[rsp]
  00182	48 ff c8	 dec	 rax
  00185	48 89 44 24 48	 mov	 QWORD PTR envc$[rsp], rax
  0018a	48 83 7c 24 48
	00		 cmp	 QWORD PTR envc$[rsp], 0
  00190	7c 49		 jl	 SHORT $LN2@posix_exec@2

; 5204 :         PyMem_DEL(envlist[envc]);

  00192	e8 00 00 00 00	 call	 _Py_PXCTX
  00197	85 c0		 test	 eax, eax
  00199	74 20		 je	 SHORT $LN11@posix_exec@2
  0019b	48 8b 44 24 40	 mov	 rax, QWORD PTR envlist$[rsp]
  001a0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR envc$[rsp]
  001a5	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  001a9	e8 00 00 00 00	 call	 _PxMem_Free
  001ae	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv149[rsp], 0
  001b9	eb 1e		 jmp	 SHORT $LN12@posix_exec@2
$LN11@posix_exec@2:
  001bb	48 8b 44 24 40	 mov	 rax, QWORD PTR envlist$[rsp]
  001c0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR envc$[rsp]
  001c5	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  001c9	e8 00 00 00 00	 call	 _PyMem_DebugFree
  001ce	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv149[rsp], 0
$LN12@posix_exec@2:
  001d9	eb a2		 jmp	 SHORT $LN3@posix_exec@2
$LN2@posix_exec@2:

; 5205 :     PyMem_DEL(envlist);

  001db	e8 00 00 00 00	 call	 _Py_PXCTX
  001e0	85 c0		 test	 eax, eax
  001e2	74 17		 je	 SHORT $LN13@posix_exec@2
  001e4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR envlist$[rsp]
  001e9	e8 00 00 00 00	 call	 _PxMem_Free
  001ee	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv154[rsp], 0
  001f9	eb 15		 jmp	 SHORT $LN14@posix_exec@2
$LN13@posix_exec@2:
  001fb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR envlist$[rsp]
  00200	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00205	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv154[rsp], 0
$LN14@posix_exec@2:
$fail$123024:

; 5206 :   fail:
; 5207 :     if (argvlist)

  00210	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR argvlist$[rsp], 0
  00219	74 12		 je	 SHORT $LN1@posix_exec@2

; 5208 :         free_string_array(argvlist, argc);

  0021b	48 8b 54 24 50	 mov	 rdx, QWORD PTR argc$[rsp]
  00220	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR argvlist$[rsp]
  00228	e8 00 00 00 00	 call	 free_string_array
$LN1@posix_exec@2:

; 5209 :     path_cleanup(&path);

  0022d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR path$[rsp]
  00232	e8 00 00 00 00	 call	 path_cleanup

; 5210 :     return NULL;

  00237	33 c0		 xor	 eax, eax
$LN9@posix_exec@2:

; 5211 : }

  00239	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00240	c3		 ret	 0
posix_execve ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$path_posix_error DD imagerel path_posix_error
	DD	imagerel path_posix_error+52
	DD	imagerel $unwind$path_posix_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$path_posix_error DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT path_posix_error
_TEXT	SEGMENT
function_name$ = 48
path$ = 56
path_posix_error PROC					; COMDAT

; 1272 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1273 :     if (path->narrow)

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR path$[rsp]
  00013	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00018	74 10		 je	 SHORT $LN1@path_posix

; 1274 :         return posix_error_with_filename(path->narrow);

  0001a	48 8b 44 24 38	 mov	 rax, QWORD PTR path$[rsp]
  0001f	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00023	e8 00 00 00 00	 call	 posix_error_with_filename
  00028	eb 05		 jmp	 SHORT $LN2@path_posix
$LN1@path_posix:

; 1275 :     return posix_error();

  0002a	e8 00 00 00 00	 call	 posix_error
$LN2@path_posix:

; 1276 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
path_posix_error ENDP
_TEXT	ENDS
EXTRN	PyErr_SetFromErrnoWithFilename:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_error_with_filename DD imagerel posix_error_with_filename
	DD	imagerel posix_error_with_filename+31
	DD	imagerel $unwind$posix_error_with_filename
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_error_with_filename DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_error_with_filename
_TEXT	SEGMENT
name$ = 48
posix_error_with_filename PROC				; COMDAT

; 1205 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1206 :     return PyErr_SetFromErrnoWithFilename(PyExc_OSError, name);

  00009	48 8b 54 24 30	 mov	 rdx, QWORD PTR name$[rsp]
  0000e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  00015	e8 00 00 00 00	 call	 PyErr_SetFromErrnoWithFilename

; 1207 : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
posix_error_with_filename ENDP
_TEXT	ENDS
PUBLIC	??_C@_05JPPLNOIE@?$CFs?$DN?$CFs?$AA@		; `string'
PUBLIC	??_C@_1CI@KDHOILMP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AA2?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CI@MHJPIOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAk?$AAe?$AAy?$AA2?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CJ@NDOMLJAA@env?4keys?$CI?$CJ?5or?5env?4values?$CI?$CJ?5is?5no@ ; `string'
EXTRN	PyOS_snprintf:PROC
EXTRN	PyList_GetItem:PROC
EXTRN	PyMapping_Values:PROC
EXTRN	PyMapping_Keys:PROC
EXTRN	PyMapping_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$parse_envlist DD imagerel parse_envlist
	DD	imagerel parse_envlist+1247
	DD	imagerel $unwind$parse_envlist
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parse_envlist DD 021101H
	DD	01b0111H
xdata	ENDS
;	COMDAT ??_C@_05JPPLNOIE@?$CFs?$DN?$CFs?$AA@
CONST	SEGMENT
??_C@_05JPPLNOIE@?$CFs?$DN?$CFs?$AA@ DB '%s=%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@KDHOILMP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AA2?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@KDHOILMP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AA2?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'v', 00H, 'a', 00H, 'l', 00H, '2', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@MHJPIOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAk?$AAe?$AAy?$AA2?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@MHJPIOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAk?$AAe?$AAy?$AA2?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'k', 00H, 'e', 00H, 'y', 00H, '2', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NDOMLJAA@env?4keys?$CI?$CJ?5or?5env?4values?$CI?$CJ?5is?5no@
CONST	SEGMENT
??_C@_0CJ@NDOMLJAA@env?4keys?$CI?$CJ?5or?5env?4values?$CI?$CJ?5is?5no@ DB 'e'
	DB	'nv.keys() or env.values() is not a list', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT parse_envlist
_TEXT	SEGMENT
p$ = 48
envlist$ = 56
v$ = 64
envc$ = 72
i$ = 80
vals$ = 88
key$ = 96
len$ = 104
key2$ = 112
val2$ = 120
val$ = 128
k$ = 136
keys$ = 144
pos$ = 152
tv80 = 160
tv79 = 168
tv181 = 176
tv180 = 184
tv215 = 192
tv220 = 196
env$ = 224
envc_ptr$ = 232
parse_envlist PROC					; COMDAT

; 4975 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 4976 :     char **envlist;
; 4977 :     Py_ssize_t i, pos, envc;
; 4978 :     PyObject *keys=NULL, *vals=NULL;

  00011	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR keys$[rsp], 0
  0001d	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR vals$[rsp], 0

; 4979 :     PyObject *key, *val, *key2, *val2;
; 4980 :     char *p, *k, *v;
; 4981 :     size_t len;
; 4982 : 
; 4983 :     i = PyMapping_Size(env);

  00026	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR env$[rsp]
  0002e	e8 00 00 00 00	 call	 PyMapping_Size
  00033	48 89 44 24 50	 mov	 QWORD PTR i$[rsp], rax

; 4984 :     if (i < 0)

  00038	48 83 7c 24 50
	00		 cmp	 QWORD PTR i$[rsp], 0
  0003e	7d 07		 jge	 SHORT $LN24@parse_envl

; 4985 :         return NULL;

  00040	33 c0		 xor	 eax, eax
  00042	e9 90 04 00 00	 jmp	 $LN25@parse_envl
$LN24@parse_envl:

; 4986 :     envlist = PyMem_NEW(char *, i + 1);

  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  0004c	48 ff c0	 inc	 rax
  0004f	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  00059	48 3b c1	 cmp	 rax, rcx
  0005c	76 0e		 jbe	 SHORT $LN29@parse_envl
  0005e	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv80[rsp], 0
  0006a	eb 55		 jmp	 SHORT $LN30@parse_envl
$LN29@parse_envl:
  0006c	e8 00 00 00 00	 call	 _Py_PXCTX
  00071	85 c0		 test	 eax, eax
  00073	74 1f		 je	 SHORT $LN27@parse_envl
  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  0007a	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  00082	48 8b c8	 mov	 rcx, rax
  00085	e8 00 00 00 00	 call	 _PxMem_Malloc
  0008a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  00092	eb 1d		 jmp	 SHORT $LN28@parse_envl
$LN27@parse_envl:
  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  00099	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  000a1	48 8b c8	 mov	 rcx, rax
  000a4	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  000a9	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
$LN28@parse_envl:
  000b1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv79[rsp]
  000b9	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
$LN30@parse_envl:
  000c1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv80[rsp]
  000c9	48 89 44 24 38	 mov	 QWORD PTR envlist$[rsp], rax

; 4987 :     if (envlist == NULL) {

  000ce	48 83 7c 24 38
	00		 cmp	 QWORD PTR envlist$[rsp], 0
  000d4	75 0c		 jne	 SHORT $LN23@parse_envl

; 4988 :         PyErr_NoMemory();

  000d6	e8 00 00 00 00	 call	 PyErr_NoMemory

; 4989 :         return NULL;

  000db	33 c0		 xor	 eax, eax
  000dd	e9 f5 03 00 00	 jmp	 $LN25@parse_envl
$LN23@parse_envl:

; 4990 :     }
; 4991 :     envc = 0;

  000e2	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR envc$[rsp], 0

; 4992 :     keys = PyMapping_Keys(env);

  000eb	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR env$[rsp]
  000f3	e8 00 00 00 00	 call	 PyMapping_Keys
  000f8	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR keys$[rsp], rax

; 4993 :     vals = PyMapping_Values(env);

  00100	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR env$[rsp]
  00108	e8 00 00 00 00	 call	 PyMapping_Values
  0010d	48 89 44 24 58	 mov	 QWORD PTR vals$[rsp], rax

; 4994 :     if (!keys || !vals)

  00112	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR keys$[rsp], 0
  0011b	74 08		 je	 SHORT $LN21@parse_envl
  0011d	48 83 7c 24 58
	00		 cmp	 QWORD PTR vals$[rsp], 0
  00123	75 05		 jne	 SHORT $LN22@parse_envl
$LN21@parse_envl:

; 4995 :         goto error;

  00125	e9 e2 02 00 00	 jmp	 $error$122876
$LN22@parse_envl:

; 4996 :     if (!PyList_Check(keys) || !PyList_Check(vals)) {

  0012a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR keys$[rsp]
  00132	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00136	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0013c	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00141	85 c0		 test	 eax, eax
  00143	74 18		 je	 SHORT $LN19@parse_envl
  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR vals$[rsp]
  0014a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0014e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00154	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00159	85 c0		 test	 eax, eax
  0015b	75 18		 jne	 SHORT $LN20@parse_envl
$LN19@parse_envl:

; 4997 :         PyErr_Format(PyExc_TypeError,
; 4998 :                      "env.keys() or env.values() is not a list");

  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@NDOMLJAA@env?4keys?$CI?$CJ?5or?5env?4values?$CI?$CJ?5is?5no@
  00164	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0016b	e8 00 00 00 00	 call	 PyErr_Format

; 4999 :         goto error;

  00170	e9 97 02 00 00	 jmp	 $error$122876
$LN20@parse_envl:

; 5000 :     }
; 5001 : 
; 5002 :     for (pos = 0; pos < i; pos++) {

  00175	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pos$[rsp], 0
  00181	eb 13		 jmp	 SHORT $LN18@parse_envl
$LN17@parse_envl:
  00183	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pos$[rsp]
  0018b	48 ff c0	 inc	 rax
  0018e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax
$LN18@parse_envl:
  00196	48 8b 44 24 50	 mov	 rax, QWORD PTR i$[rsp]
  0019b	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR pos$[rsp], rax
  001a3	0f 8d 20 02 00
	00		 jge	 $LN16@parse_envl

; 5003 :         key = PyList_GetItem(keys, pos);

  001a9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR pos$[rsp]
  001b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR keys$[rsp]
  001b9	e8 00 00 00 00	 call	 PyList_GetItem
  001be	48 89 44 24 60	 mov	 QWORD PTR key$[rsp], rax

; 5004 :         val = PyList_GetItem(vals, pos);

  001c3	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR pos$[rsp]
  001cb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vals$[rsp]
  001d0	e8 00 00 00 00	 call	 PyList_GetItem
  001d5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR val$[rsp], rax

; 5005 :         if (!key || !val)

  001dd	48 83 7c 24 60
	00		 cmp	 QWORD PTR key$[rsp], 0
  001e3	74 0b		 je	 SHORT $LN14@parse_envl
  001e5	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR val$[rsp], 0
  001ee	75 05		 jne	 SHORT $LN15@parse_envl
$LN14@parse_envl:

; 5006 :             goto error;

  001f0	e9 17 02 00 00	 jmp	 $error$122876
$LN15@parse_envl:

; 5007 : 
; 5008 :         if (PyUnicode_FSConverter(key, &key2) == 0)

  001f5	48 8d 54 24 70	 lea	 rdx, QWORD PTR key2$[rsp]
  001fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR key$[rsp]
  001ff	e8 00 00 00 00	 call	 PyUnicode_FSConverter
  00204	85 c0		 test	 eax, eax
  00206	75 05		 jne	 SHORT $LN13@parse_envl

; 5009 :             goto error;

  00208	e9 ff 01 00 00	 jmp	 $error$122876
$LN13@parse_envl:

; 5010 :         if (PyUnicode_FSConverter(val, &val2) == 0) {

  0020d	48 8d 54 24 78	 lea	 rdx, QWORD PTR val2$[rsp]
  00212	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR val$[rsp]
  0021a	e8 00 00 00 00	 call	 PyUnicode_FSConverter
  0021f	85 c0		 test	 eax, eax
  00221	75 0f		 jne	 SHORT $LN12@parse_envl

; 5011 :             Py_DECREF(key2);

  00223	48 8b 4c 24 70	 mov	 rcx, QWORD PTR key2$[rsp]
  00228	e8 00 00 00 00	 call	 _Py_DecRef

; 5012 :             goto error;

  0022d	e9 da 01 00 00	 jmp	 $error$122876
$LN12@parse_envl:

; 5013 :         }
; 5014 : 
; 5015 : #if defined(PYOS_OS2)
; 5016 :         /* Omit Pseudo-Env Vars that Would Confuse Programs if Passed On */
; 5017 :         if (stricmp(k, "BEGINLIBPATH") != 0 && stricmp(k, "ENDLIBPATH") != 0) {
; 5018 : #endif
; 5019 :         k = PyBytes_AsString(key2);

  00232	48 8b 4c 24 70	 mov	 rcx, QWORD PTR key2$[rsp]
  00237	e8 00 00 00 00	 call	 PyBytes_AsString
  0023c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR k$[rsp], rax

; 5020 :         v = PyBytes_AsString(val2);

  00244	48 8b 4c 24 78	 mov	 rcx, QWORD PTR val2$[rsp]
  00249	e8 00 00 00 00	 call	 PyBytes_AsString
  0024e	48 89 44 24 40	 mov	 QWORD PTR v$[rsp], rax

; 5021 :         len = PyBytes_GET_SIZE(key2) + PyBytes_GET_SIZE(val2) + 2;

  00253	48 8b 44 24 70	 mov	 rax, QWORD PTR key2$[rsp]
  00258	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0025c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00262	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00267	85 c0		 test	 eax, eax
  00269	75 1c		 jne	 SHORT $LN31@parse_envl
  0026b	41 b8 9d 13 00
	00		 mov	 r8d, 5021		; 0000139dH
  00271	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@MHJPIOI@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAk?$AAe?$AAy?$AA2?$AA?$CJ?$AA?$AA@
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00285	33 c0		 xor	 eax, eax
$LN31@parse_envl:
  00287	48 8b 44 24 78	 mov	 rax, QWORD PTR val2$[rsp]
  0028c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00290	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00296	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0029b	85 c0		 test	 eax, eax
  0029d	75 1c		 jne	 SHORT $LN32@parse_envl
  0029f	41 b8 9d 13 00
	00		 mov	 r8d, 5021		; 0000139dH
  002a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KDHOILMP@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AA2?$AA?$CJ?$AA?$AA@
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002b9	33 c0		 xor	 eax, eax
$LN32@parse_envl:
  002bb	48 8b 44 24 70	 mov	 rax, QWORD PTR key2$[rsp]
  002c0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR val2$[rsp]
  002c9	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  002cd	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  002d2	48 89 44 24 68	 mov	 QWORD PTR len$[rsp], rax

; 5022 : 
; 5023 :         p = PyMem_NEW(char, len);

  002d7	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  002e1	48 39 44 24 68	 cmp	 QWORD PTR len$[rsp], rax
  002e6	76 0e		 jbe	 SHORT $LN35@parse_envl
  002e8	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv181[rsp], 0
  002f4	eb 3f		 jmp	 SHORT $LN36@parse_envl
$LN35@parse_envl:
  002f6	e8 00 00 00 00	 call	 _Py_PXCTX
  002fb	85 c0		 test	 eax, eax
  002fd	74 14		 je	 SHORT $LN33@parse_envl
  002ff	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$[rsp]
  00304	e8 00 00 00 00	 call	 _PxMem_Malloc
  00309	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv180[rsp], rax
  00311	eb 12		 jmp	 SHORT $LN34@parse_envl
$LN33@parse_envl:
  00313	48 8b 4c 24 68	 mov	 rcx, QWORD PTR len$[rsp]
  00318	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0031d	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv180[rsp], rax
$LN34@parse_envl:
  00325	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv180[rsp]
  0032d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv181[rsp], rax
$LN36@parse_envl:
  00335	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv181[rsp]
  0033d	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 5024 :         if (p == NULL) {

  00342	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  00348	75 1e		 jne	 SHORT $LN11@parse_envl

; 5025 :             PyErr_NoMemory();

  0034a	e8 00 00 00 00	 call	 PyErr_NoMemory

; 5026 :             Py_DECREF(key2);

  0034f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR key2$[rsp]
  00354	e8 00 00 00 00	 call	 _Py_DecRef

; 5027 :             Py_DECREF(val2);

  00359	48 8b 4c 24 78	 mov	 rcx, QWORD PTR val2$[rsp]
  0035e	e8 00 00 00 00	 call	 _Py_DecRef

; 5028 :             goto error;

  00363	e9 a4 00 00 00	 jmp	 $error$122876
$LN11@parse_envl:

; 5029 :         }
; 5030 :         PyOS_snprintf(p, len, "%s=%s", k, v);

  00368	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0036d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00372	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR k$[rsp]
  0037a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05JPPLNOIE@?$CFs?$DN?$CFs?$AA@
  00381	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00386	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  0038b	e8 00 00 00 00	 call	 PyOS_snprintf

; 5031 :         envlist[envc++] = p;

  00390	48 8b 44 24 38	 mov	 rax, QWORD PTR envlist$[rsp]
  00395	48 8b 4c 24 48	 mov	 rcx, QWORD PTR envc$[rsp]
  0039a	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  0039f	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  003a3	48 8b 44 24 48	 mov	 rax, QWORD PTR envc$[rsp]
  003a8	48 ff c0	 inc	 rax
  003ab	48 89 44 24 48	 mov	 QWORD PTR envc$[rsp], rax

; 5032 :         Py_DECREF(key2);

  003b0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR key2$[rsp]
  003b5	e8 00 00 00 00	 call	 _Py_DecRef

; 5033 :         Py_DECREF(val2);

  003ba	48 8b 4c 24 78	 mov	 rcx, QWORD PTR val2$[rsp]
  003bf	e8 00 00 00 00	 call	 _Py_DecRef

; 5034 : #if defined(PYOS_OS2)
; 5035 :         }
; 5036 : #endif
; 5037 :     }

  003c4	e9 ba fd ff ff	 jmp	 $LN17@parse_envl
$LN16@parse_envl:

; 5038 :     Py_DECREF(vals);

  003c9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vals$[rsp]
  003ce	e8 00 00 00 00	 call	 _Py_DecRef

; 5039 :     Py_DECREF(keys);

  003d3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR keys$[rsp]
  003db	e8 00 00 00 00	 call	 _Py_DecRef

; 5040 : 
; 5041 :     envlist[envc] = 0;

  003e0	48 8b 44 24 38	 mov	 rax, QWORD PTR envlist$[rsp]
  003e5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR envc$[rsp]
  003ea	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0

; 5042 :     *envc_ptr = envc;

  003f2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR envc_ptr$[rsp]
  003fa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR envc$[rsp]
  003ff	48 89 08	 mov	 QWORD PTR [rax], rcx

; 5043 :     return envlist;

  00402	48 8b 44 24 38	 mov	 rax, QWORD PTR envlist$[rsp]
  00407	e9 cb 00 00 00	 jmp	 $LN25@parse_envl
$error$122876:
$LN10@parse_envl:

; 5044 : 
; 5045 : error:
; 5046 :     Py_XDECREF(keys);

  0040c	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR keys$[rsp], 0
  00415	74 0d		 je	 SHORT $LN7@parse_envl
  00417	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR keys$[rsp]
  0041f	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@parse_envl:
  00424	33 c0		 xor	 eax, eax
  00426	85 c0		 test	 eax, eax
  00428	75 e2		 jne	 SHORT $LN10@parse_envl
$LN6@parse_envl:

; 5047 :     Py_XDECREF(vals);

  0042a	48 83 7c 24 58
	00		 cmp	 QWORD PTR vals$[rsp], 0
  00430	74 0a		 je	 SHORT $LN3@parse_envl
  00432	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vals$[rsp]
  00437	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@parse_envl:
  0043c	33 c0		 xor	 eax, eax
  0043e	85 c0		 test	 eax, eax
  00440	75 e8		 jne	 SHORT $LN6@parse_envl
$LN2@parse_envl:

; 5048 :     while (--envc >= 0)

  00442	48 8b 44 24 48	 mov	 rax, QWORD PTR envc$[rsp]
  00447	48 ff c8	 dec	 rax
  0044a	48 89 44 24 48	 mov	 QWORD PTR envc$[rsp], rax
  0044f	48 83 7c 24 48
	00		 cmp	 QWORD PTR envc$[rsp], 0
  00455	7c 49		 jl	 SHORT $LN1@parse_envl

; 5049 :         PyMem_DEL(envlist[envc]);

  00457	e8 00 00 00 00	 call	 _Py_PXCTX
  0045c	85 c0		 test	 eax, eax
  0045e	74 20		 je	 SHORT $LN37@parse_envl
  00460	48 8b 44 24 38	 mov	 rax, QWORD PTR envlist$[rsp]
  00465	48 8b 4c 24 48	 mov	 rcx, QWORD PTR envc$[rsp]
  0046a	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0046e	e8 00 00 00 00	 call	 _PxMem_Free
  00473	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv215[rsp], 0
  0047e	eb 1e		 jmp	 SHORT $LN38@parse_envl
$LN37@parse_envl:
  00480	48 8b 44 24 38	 mov	 rax, QWORD PTR envlist$[rsp]
  00485	48 8b 4c 24 48	 mov	 rcx, QWORD PTR envc$[rsp]
  0048a	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0048e	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00493	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv215[rsp], 0
$LN38@parse_envl:
  0049e	eb a2		 jmp	 SHORT $LN2@parse_envl
$LN1@parse_envl:

; 5050 :     PyMem_DEL(envlist);

  004a0	e8 00 00 00 00	 call	 _Py_PXCTX
  004a5	85 c0		 test	 eax, eax
  004a7	74 17		 je	 SHORT $LN39@parse_envl
  004a9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR envlist$[rsp]
  004ae	e8 00 00 00 00	 call	 _PxMem_Free
  004b3	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv220[rsp], 0
  004be	eb 15		 jmp	 SHORT $LN40@parse_envl
$LN39@parse_envl:
  004c0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR envlist$[rsp]
  004c5	e8 00 00 00 00	 call	 _PyMem_DebugFree
  004ca	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv220[rsp], 0
$LN40@parse_envl:

; 5051 :     return NULL;

  004d5	33 c0		 xor	 eax, eax
$LN25@parse_envl:

; 5052 : }

  004d7	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  004de	c3		 ret	 0
parse_envlist ENDP
_TEXT	ENDS
PUBLIC	??_C@_01OCOKONAJ@L?$AA@				; `string'
PUBLIC	??_C@_0CJ@DHABGLNI@spawnv?$CI?$CJ?5arg?52?5must?5contain?5only@ ; `string'
PUBLIC	??_C@_0CH@HGBGFAKF@spawnv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5o@ ; `string'
PUBLIC	??_C@_0M@JMDAELCB@iO?$CGO?3spawnv?$AA@		; `string'
EXTRN	__imp__spawnv:PROC
EXTRN	PyList_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_spawnv DD imagerel posix_spawnv
	DD	imagerel posix_spawnv+689
	DD	imagerel $unwind$posix_spawnv
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_spawnv DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_01OCOKONAJ@L?$AA@
CONST	SEGMENT
??_C@_01OCOKONAJ@L?$AA@ DB 'L', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DHABGLNI@spawnv?$CI?$CJ?5arg?52?5must?5contain?5only@
CONST	SEGMENT
??_C@_0CJ@DHABGLNI@spawnv?$CI?$CJ?5arg?52?5must?5contain?5only@ DB 'spawn'
	DB	'v() arg 2 must contain only strings', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@HGBGFAKF@spawnv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5o@
CONST	SEGMENT
??_C@_0CH@HGBGFAKF@spawnv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5o@ DB 'spa'
	DB	'wnv() arg 2 must be a tuple or list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMDAELCB@iO?$CGO?3spawnv?$AA@
CONST	SEGMENT
??_C@_0M@JMDAELCB@iO?$CGO?3spawnv?$AA@ DB 'iO&O:spawnv', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_spawnv
_TEXT	SEGMENT
spawnval$ = 48
argc$ = 56
i$ = 64
mode$ = 68
argv$ = 72
getitem$ = 80
opath$ = 88
path$ = 96
argvlist$ = 104
_save$123089 = 112
tv134 = 120
tv133 = 128
tv144 = 136
self$ = 160
args$ = 168
posix_spawnv PROC					; COMDAT

; 5226 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 5227 :     PyObject *opath;
; 5228 :     char *path;
; 5229 :     PyObject *argv;
; 5230 :     char **argvlist;
; 5231 :     int mode, i;
; 5232 :     Py_ssize_t argc;
; 5233 :     Py_intptr_t spawnval;
; 5234 :     PyObject *(*getitem)(PyObject *, Py_ssize_t);
; 5235 : 
; 5236 :     /* spawnv has three arguments: (mode, path, argv), where
; 5237 :        argv is a list or tuple of strings. */
; 5238 : 
; 5239 :     if (!PyArg_ParseTuple(args, "iO&O:spawnv", &mode,
; 5240 :                           PyUnicode_FSConverter,
; 5241 :                           &opath, &argv))

  00011	48 8d 44 24 48	 lea	 rax, QWORD PTR argv$[rsp]
  00016	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0001b	48 8d 44 24 58	 lea	 rax, QWORD PTR opath$[rsp]
  00020	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00025	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyUnicode_FSConverter
  0002c	4c 8d 44 24 44	 lea	 r8, QWORD PTR mode$[rsp]
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@JMDAELCB@iO?$CGO?3spawnv?$AA@
  00038	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00040	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00045	85 c0		 test	 eax, eax
  00047	75 07		 jne	 SHORT $LN13@posix_spaw

; 5242 :         return NULL;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 59 02 00 00	 jmp	 $LN14@posix_spaw
$LN13@posix_spaw:

; 5243 :     path = PyBytes_AsString(opath);

  00050	48 8b 4c 24 58	 mov	 rcx, QWORD PTR opath$[rsp]
  00055	e8 00 00 00 00	 call	 PyBytes_AsString
  0005a	48 89 44 24 60	 mov	 QWORD PTR path$[rsp], rax

; 5244 :     if (PyList_Check(argv)) {

  0005f	48 8b 44 24 48	 mov	 rax, QWORD PTR argv$[rsp]
  00064	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00068	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0006e	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00073	85 c0		 test	 eax, eax
  00075	74 1d		 je	 SHORT $LN12@posix_spaw

; 5245 :         argc = PyList_Size(argv);

  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR argv$[rsp]
  0007c	e8 00 00 00 00	 call	 PyList_Size
  00081	48 89 44 24 38	 mov	 QWORD PTR argc$[rsp], rax

; 5246 :         getitem = PyList_GetItem;

  00086	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_GetItem
  0008d	48 89 44 24 50	 mov	 QWORD PTR getitem$[rsp], rax
  00092	eb 59		 jmp	 SHORT $LN11@posix_spaw
$LN12@posix_spaw:

; 5247 :     }
; 5248 :     else if (PyTuple_Check(argv)) {

  00094	48 8b 44 24 48	 mov	 rax, QWORD PTR argv$[rsp]
  00099	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000a3	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  000a8	85 c0		 test	 eax, eax
  000aa	74 1d		 je	 SHORT $LN10@posix_spaw

; 5249 :         argc = PyTuple_Size(argv);

  000ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR argv$[rsp]
  000b1	e8 00 00 00 00	 call	 PyTuple_Size
  000b6	48 89 44 24 38	 mov	 QWORD PTR argc$[rsp], rax

; 5250 :         getitem = PyTuple_GetItem;

  000bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_GetItem
  000c2	48 89 44 24 50	 mov	 QWORD PTR getitem$[rsp], rax

; 5251 :     }
; 5252 :     else {

  000c7	eb 24		 jmp	 SHORT $LN9@posix_spaw
$LN10@posix_spaw:

; 5253 :         PyErr_SetString(PyExc_TypeError,
; 5254 :                         "spawnv() arg 2 must be a tuple or list");

  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@HGBGFAKF@spawnv?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5o@
  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d7	e8 00 00 00 00	 call	 PyErr_SetString

; 5255 :         Py_DECREF(opath);

  000dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR opath$[rsp]
  000e1	e8 00 00 00 00	 call	 _Py_DecRef

; 5256 :         return NULL;

  000e6	33 c0		 xor	 eax, eax
  000e8	e9 bc 01 00 00	 jmp	 $LN14@posix_spaw
$LN9@posix_spaw:
$LN11@posix_spaw:

; 5257 :     }
; 5258 : 
; 5259 :     argvlist = PyMem_NEW(char *, argc+1);

  000ed	48 8b 44 24 38	 mov	 rax, QWORD PTR argc$[rsp]
  000f2	48 ff c0	 inc	 rax
  000f5	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  000ff	48 3b c1	 cmp	 rax, rcx
  00102	76 0b		 jbe	 SHORT $LN18@posix_spaw
  00104	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv134[rsp], 0
  0010d	eb 52		 jmp	 SHORT $LN19@posix_spaw
$LN18@posix_spaw:
  0010f	e8 00 00 00 00	 call	 _Py_PXCTX
  00114	85 c0		 test	 eax, eax
  00116	74 1f		 je	 SHORT $LN16@posix_spaw
  00118	48 8b 44 24 38	 mov	 rax, QWORD PTR argc$[rsp]
  0011d	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  00125	48 8b c8	 mov	 rcx, rax
  00128	e8 00 00 00 00	 call	 _PxMem_Malloc
  0012d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  00135	eb 1d		 jmp	 SHORT $LN17@posix_spaw
$LN16@posix_spaw:
  00137	48 8b 44 24 38	 mov	 rax, QWORD PTR argc$[rsp]
  0013c	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  00144	48 8b c8	 mov	 rcx, rax
  00147	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  0014c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
$LN17@posix_spaw:
  00154	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv133[rsp]
  0015c	48 89 44 24 78	 mov	 QWORD PTR tv134[rsp], rax
$LN19@posix_spaw:
  00161	48 8b 44 24 78	 mov	 rax, QWORD PTR tv134[rsp]
  00166	48 89 44 24 68	 mov	 QWORD PTR argvlist$[rsp], rax

; 5260 :     if (argvlist == NULL) {

  0016b	48 83 7c 24 68
	00		 cmp	 QWORD PTR argvlist$[rsp], 0
  00171	75 14		 jne	 SHORT $LN8@posix_spaw

; 5261 :         Py_DECREF(opath);

  00173	48 8b 4c 24 58	 mov	 rcx, QWORD PTR opath$[rsp]
  00178	e8 00 00 00 00	 call	 _Py_DecRef

; 5262 :         return PyErr_NoMemory();

  0017d	e8 00 00 00 00	 call	 PyErr_NoMemory
  00182	e9 22 01 00 00	 jmp	 $LN14@posix_spaw
$LN8@posix_spaw:

; 5263 :     }
; 5264 :     for (i = 0; i < argc; i++) {

  00187	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0018f	eb 0a		 jmp	 SHORT $LN7@posix_spaw
$LN6@posix_spaw:
  00191	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00195	ff c0		 inc	 eax
  00197	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN7@posix_spaw:
  0019b	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001a0	48 3b 44 24 38	 cmp	 rax, QWORD PTR argc$[rsp]
  001a5	7d 79		 jge	 SHORT $LN5@posix_spaw

; 5265 :         if (!fsconvert_strdup((*getitem)(argv, i),
; 5266 :                               &argvlist[i])) {

  001a7	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argvlist$[rsp]
  001b1	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  001b5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv144[rsp], rax
  001bd	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  001c2	48 8b d1	 mov	 rdx, rcx
  001c5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR argv$[rsp]
  001ca	ff 54 24 50	 call	 QWORD PTR getitem$[rsp]
  001ce	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv144[rsp]
  001d6	48 8b d1	 mov	 rdx, rcx
  001d9	48 8b c8	 mov	 rcx, rax
  001dc	e8 00 00 00 00	 call	 fsconvert_strdup
  001e1	85 c0		 test	 eax, eax
  001e3	75 36		 jne	 SHORT $LN4@posix_spaw

; 5267 :             free_string_array(argvlist, i);

  001e5	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001ea	48 8b d0	 mov	 rdx, rax
  001ed	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argvlist$[rsp]
  001f2	e8 00 00 00 00	 call	 free_string_array

; 5268 :             PyErr_SetString(
; 5269 :                 PyExc_TypeError,
; 5270 :                 "spawnv() arg 2 must contain only strings");

  001f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@DHABGLNI@spawnv?$CI?$CJ?5arg?52?5must?5contain?5only@
  001fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00205	e8 00 00 00 00	 call	 PyErr_SetString

; 5271 :             Py_DECREF(opath);

  0020a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR opath$[rsp]
  0020f	e8 00 00 00 00	 call	 _Py_DecRef

; 5272 :             return NULL;

  00214	33 c0		 xor	 eax, eax
  00216	e9 8e 00 00 00	 jmp	 $LN14@posix_spaw
$LN4@posix_spaw:

; 5273 :         }
; 5274 :     }

  0021b	e9 71 ff ff ff	 jmp	 $LN6@posix_spaw
$LN5@posix_spaw:

; 5275 :     argvlist[argc] = NULL;

  00220	48 8b 44 24 68	 mov	 rax, QWORD PTR argvlist$[rsp]
  00225	48 8b 4c 24 38	 mov	 rcx, QWORD PTR argc$[rsp]
  0022a	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0

; 5276 : 
; 5277 : #if defined(PYOS_OS2) && defined(PYCC_GCC)
; 5278 :     Py_BEGIN_ALLOW_THREADS
; 5279 :     spawnval = spawnv(mode, path, argvlist);
; 5280 :     Py_END_ALLOW_THREADS
; 5281 : #else
; 5282 :     if (mode == _OLD_P_OVERLAY)

  00232	83 7c 24 44 02	 cmp	 DWORD PTR mode$[rsp], 2
  00237	75 08		 jne	 SHORT $LN3@posix_spaw

; 5283 :         mode = _P_OVERLAY;

  00239	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR mode$[rsp], 2
$LN3@posix_spaw:

; 5284 : 
; 5285 :     Py_BEGIN_ALLOW_THREADS

  00241	e8 00 00 00 00	 call	 PyEval_SaveThread
  00246	48 89 44 24 70	 mov	 QWORD PTR _save$123089[rsp], rax

; 5286 :     spawnval = _spawnv(mode, path, argvlist);

  0024b	4c 8b 44 24 68	 mov	 r8, QWORD PTR argvlist$[rsp]
  00250	48 8b 54 24 60	 mov	 rdx, QWORD PTR path$[rsp]
  00255	8b 4c 24 44	 mov	 ecx, DWORD PTR mode$[rsp]
  00259	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__spawnv
  0025f	48 89 44 24 30	 mov	 QWORD PTR spawnval$[rsp], rax

; 5287 :     Py_END_ALLOW_THREADS

  00264	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _save$123089[rsp]
  00269	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 5288 : #endif
; 5289 : 
; 5290 :     free_string_array(argvlist, argc);

  0026e	48 8b 54 24 38	 mov	 rdx, QWORD PTR argc$[rsp]
  00273	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argvlist$[rsp]
  00278	e8 00 00 00 00	 call	 free_string_array

; 5291 :     Py_DECREF(opath);

  0027d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR opath$[rsp]
  00282	e8 00 00 00 00	 call	 _Py_DecRef

; 5292 : 
; 5293 :     if (spawnval == -1)

  00287	48 83 7c 24 30
	ff		 cmp	 QWORD PTR spawnval$[rsp], -1
  0028d	75 09		 jne	 SHORT $LN2@posix_spaw

; 5294 :         return posix_error();

  0028f	e8 00 00 00 00	 call	 posix_error
  00294	eb 13		 jmp	 SHORT $LN14@posix_spaw

; 5295 :     else

  00296	eb 11		 jmp	 SHORT $LN1@posix_spaw
$LN2@posix_spaw:

; 5296 : #if SIZEOF_LONG == SIZEOF_VOID_P
; 5297 :         return Py_BuildValue("l", (long) spawnval);
; 5298 : #else
; 5299 :         return Py_BuildValue("L", (PY_LONG_LONG) spawnval);

  00298	48 8b 54 24 30	 mov	 rdx, QWORD PTR spawnval$[rsp]
  0029d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01OCOKONAJ@L?$AA@
  002a4	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
$LN1@posix_spaw:
$LN14@posix_spaw:

; 5300 : #endif
; 5301 : }

  002a9	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002b0	c3		 ret	 0
posix_spawnv ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@GLIECBIH@spawnve?$CI?$CJ?5arg?53?5must?5be?5a?5mappin@ ; `string'
PUBLIC	??_C@_0CI@GCNDBANM@spawnve?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5@ ; `string'
PUBLIC	??_C@_0O@CFMCJKNH@iO?$CGOO?3spawnve?$AA@	; `string'
EXTRN	__imp__spawnve:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_spawnve DD imagerel posix_spawnve
	DD	imagerel posix_spawnve+982
	DD	imagerel $unwind$posix_spawnve
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_spawnve DD 021101H
	DD	01d0111H
xdata	ENDS
;	COMDAT ??_C@_0CJ@GLIECBIH@spawnve?$CI?$CJ?5arg?53?5must?5be?5a?5mappin@
CONST	SEGMENT
??_C@_0CJ@GLIECBIH@spawnve?$CI?$CJ?5arg?53?5must?5be?5a?5mappin@ DB 'spaw'
	DB	'nve() arg 3 must be a mapping object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GCNDBANM@spawnve?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5@
CONST	SEGMENT
??_C@_0CI@GCNDBANM@spawnve?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5@ DB 'spa'
	DB	'wnve() arg 2 must be a tuple or list', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CFMCJKNH@iO?$CGOO?3spawnve?$AA@
CONST	SEGMENT
??_C@_0O@CFMCJKNH@iO?$CGOO?3spawnve?$AA@ DB 'iO&OO:spawnve', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_spawnve
_TEXT	SEGMENT
spawnval$ = 64
envlist$ = 72
envc$ = 80
argc$ = 88
res$ = 96
env$ = 104
i$ = 112
mode$ = 120
argv$ = 128
getitem$ = 136
opath$ = 144
path$ = 152
lastarg$ = 160
argvlist$ = 168
_save$123153 = 176
tv139 = 184
tv138 = 192
tv145 = 200
tv180 = 208
tv185 = 212
self$ = 240
args$ = 248
posix_spawnve PROC					; COMDAT

; 5315 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 5316 :     PyObject *opath;
; 5317 :     char *path;
; 5318 :     PyObject *argv, *env;
; 5319 :     char **argvlist;
; 5320 :     char **envlist;
; 5321 :     PyObject *res = NULL;

  00011	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR res$[rsp], 0

; 5322 :     int mode;
; 5323 :     Py_ssize_t argc, i, envc;
; 5324 :     Py_intptr_t spawnval;
; 5325 :     PyObject *(*getitem)(PyObject *, Py_ssize_t);
; 5326 :     Py_ssize_t lastarg = 0;

  0001a	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR lastarg$[rsp], 0

; 5327 : 
; 5328 :     /* spawnve has four arguments: (mode, path, argv, env), where
; 5329 :        argv is a list or tuple of strings and env is a dictionary
; 5330 :        like posix.environ. */
; 5331 : 
; 5332 :     if (!PyArg_ParseTuple(args, "iO&OO:spawnve", &mode,
; 5333 :                           PyUnicode_FSConverter,
; 5334 :                           &opath, &argv, &env))

  00026	48 8d 44 24 68	 lea	 rax, QWORD PTR env$[rsp]
  0002b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00030	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR argv$[rsp]
  00038	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003d	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR opath$[rsp]
  00045	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyUnicode_FSConverter
  00051	4c 8d 44 24 78	 lea	 r8, QWORD PTR mode$[rsp]
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@CFMCJKNH@iO?$CGOO?3spawnve?$AA@
  0005d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00065	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0006a	85 c0		 test	 eax, eax
  0006c	75 07		 jne	 SHORT $LN17@posix_spaw@2

; 5335 :         return NULL;

  0006e	33 c0		 xor	 eax, eax
  00070	e9 59 03 00 00	 jmp	 $LN18@posix_spaw@2
$LN17@posix_spaw@2:

; 5336 :     path = PyBytes_AsString(opath);

  00075	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR opath$[rsp]
  0007d	e8 00 00 00 00	 call	 PyBytes_AsString
  00082	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR path$[rsp], rax

; 5337 :     if (PyList_Check(argv)) {

  0008a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00092	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00096	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0009c	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  000a1	85 c0		 test	 eax, eax
  000a3	74 23		 je	 SHORT $LN16@posix_spaw@2

; 5338 :         argc = PyList_Size(argv);

  000a5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000ad	e8 00 00 00 00	 call	 PyList_Size
  000b2	48 89 44 24 58	 mov	 QWORD PTR argc$[rsp], rax

; 5339 :         getitem = PyList_GetItem;

  000b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_GetItem
  000be	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR getitem$[rsp], rax
  000c6	eb 56		 jmp	 SHORT $LN15@posix_spaw@2
$LN16@posix_spaw@2:

; 5340 :     }
; 5341 :     else if (PyTuple_Check(argv)) {

  000c8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000d0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d4	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000da	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  000df	85 c0		 test	 eax, eax
  000e1	74 23		 je	 SHORT $LN14@posix_spaw@2

; 5342 :         argc = PyTuple_Size(argv);

  000e3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000eb	e8 00 00 00 00	 call	 PyTuple_Size
  000f0	48 89 44 24 58	 mov	 QWORD PTR argc$[rsp], rax

; 5343 :         getitem = PyTuple_GetItem;

  000f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_GetItem
  000fc	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR getitem$[rsp], rax

; 5344 :     }
; 5345 :     else {

  00104	eb 18		 jmp	 SHORT $LN13@posix_spaw@2
$LN14@posix_spaw@2:

; 5346 :         PyErr_SetString(PyExc_TypeError,
; 5347 :                         "spawnve() arg 2 must be a tuple or list");

  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@GCNDBANM@spawnve?$CI?$CJ?5arg?52?5must?5be?5a?5tuple?5@
  0010d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00114	e8 00 00 00 00	 call	 PyErr_SetString

; 5348 :         goto fail_0;

  00119	e9 9e 02 00 00	 jmp	 $fail_0$123129
$LN13@posix_spaw@2:
$LN15@posix_spaw@2:

; 5349 :     }
; 5350 :     if (!PyMapping_Check(env)) {

  0011e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR env$[rsp]
  00123	e8 00 00 00 00	 call	 PyMapping_Check
  00128	85 c0		 test	 eax, eax
  0012a	75 18		 jne	 SHORT $LN12@posix_spaw@2

; 5351 :         PyErr_SetString(PyExc_TypeError,
; 5352 :                         "spawnve() arg 3 must be a mapping object");

  0012c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@GLIECBIH@spawnve?$CI?$CJ?5arg?53?5must?5be?5a?5mappin@
  00133	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0013a	e8 00 00 00 00	 call	 PyErr_SetString

; 5353 :         goto fail_0;

  0013f	e9 78 02 00 00	 jmp	 $fail_0$123129
$LN12@posix_spaw@2:

; 5354 :     }
; 5355 : 
; 5356 :     argvlist = PyMem_NEW(char *, argc+1);

  00144	48 8b 44 24 58	 mov	 rax, QWORD PTR argc$[rsp]
  00149	48 ff c0	 inc	 rax
  0014c	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  00156	48 3b c1	 cmp	 rax, rcx
  00159	76 0e		 jbe	 SHORT $LN22@posix_spaw@2
  0015b	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv139[rsp], 0
  00167	eb 55		 jmp	 SHORT $LN23@posix_spaw@2
$LN22@posix_spaw@2:
  00169	e8 00 00 00 00	 call	 _Py_PXCTX
  0016e	85 c0		 test	 eax, eax
  00170	74 1f		 je	 SHORT $LN20@posix_spaw@2
  00172	48 8b 44 24 58	 mov	 rax, QWORD PTR argc$[rsp]
  00177	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  0017f	48 8b c8	 mov	 rcx, rax
  00182	e8 00 00 00 00	 call	 _PxMem_Malloc
  00187	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv138[rsp], rax
  0018f	eb 1d		 jmp	 SHORT $LN21@posix_spaw@2
$LN20@posix_spaw@2:
  00191	48 8b 44 24 58	 mov	 rax, QWORD PTR argc$[rsp]
  00196	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  0019e	48 8b c8	 mov	 rcx, rax
  001a1	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  001a6	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv138[rsp], rax
$LN21@posix_spaw@2:
  001ae	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv138[rsp]
  001b6	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv139[rsp], rax
$LN23@posix_spaw@2:
  001be	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv139[rsp]
  001c6	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR argvlist$[rsp], rax

; 5357 :     if (argvlist == NULL) {

  001ce	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR argvlist$[rsp], 0
  001d7	75 0a		 jne	 SHORT $LN11@posix_spaw@2

; 5358 :         PyErr_NoMemory();

  001d9	e8 00 00 00 00	 call	 PyErr_NoMemory

; 5359 :         goto fail_0;

  001de	e9 d9 01 00 00	 jmp	 $fail_0$123129
$LN11@posix_spaw@2:

; 5360 :     }
; 5361 :     for (i = 0; i < argc; i++) {

  001e3	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001ec	eb 0d		 jmp	 SHORT $LN10@posix_spaw@2
$LN9@posix_spaw@2:
  001ee	48 8b 44 24 70	 mov	 rax, QWORD PTR i$[rsp]
  001f3	48 ff c0	 inc	 rax
  001f6	48 89 44 24 70	 mov	 QWORD PTR i$[rsp], rax
$LN10@posix_spaw@2:
  001fb	48 8b 44 24 58	 mov	 rax, QWORD PTR argc$[rsp]
  00200	48 39 44 24 70	 cmp	 QWORD PTR i$[rsp], rax
  00205	7d 58		 jge	 SHORT $LN8@posix_spaw@2

; 5362 :         if (!fsconvert_strdup((*getitem)(argv, i),
; 5363 :                               &argvlist[i]))

  00207	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR argvlist$[rsp]
  0020f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR i$[rsp]
  00214	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  00218	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv145[rsp], rax
  00220	48 8b 54 24 70	 mov	 rdx, QWORD PTR i$[rsp]
  00225	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0022d	ff 94 24 88 00
	00 00		 call	 QWORD PTR getitem$[rsp]
  00234	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv145[rsp]
  0023c	48 8b d1	 mov	 rdx, rcx
  0023f	48 8b c8	 mov	 rcx, rax
  00242	e8 00 00 00 00	 call	 fsconvert_strdup
  00247	85 c0		 test	 eax, eax
  00249	75 12		 jne	 SHORT $LN7@posix_spaw@2

; 5364 :         {
; 5365 :             lastarg = i;

  0024b	48 8b 44 24 70	 mov	 rax, QWORD PTR i$[rsp]
  00250	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR lastarg$[rsp], rax

; 5366 :             goto fail_1;

  00258	e9 4a 01 00 00	 jmp	 $fail_1$123148
$LN7@posix_spaw@2:

; 5367 :         }
; 5368 :     }

  0025d	eb 8f		 jmp	 SHORT $LN9@posix_spaw@2
$LN8@posix_spaw@2:

; 5369 :     lastarg = argc;

  0025f	48 8b 44 24 58	 mov	 rax, QWORD PTR argc$[rsp]
  00264	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR lastarg$[rsp], rax

; 5370 :     argvlist[argc] = NULL;

  0026c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR argvlist$[rsp]
  00274	48 8b 4c 24 58	 mov	 rcx, QWORD PTR argc$[rsp]
  00279	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0

; 5371 : 
; 5372 :     envlist = parse_envlist(env, &envc);

  00281	48 8d 54 24 50	 lea	 rdx, QWORD PTR envc$[rsp]
  00286	48 8b 4c 24 68	 mov	 rcx, QWORD PTR env$[rsp]
  0028b	e8 00 00 00 00	 call	 parse_envlist
  00290	48 89 44 24 48	 mov	 QWORD PTR envlist$[rsp], rax

; 5373 :     if (envlist == NULL)

  00295	48 83 7c 24 48
	00		 cmp	 QWORD PTR envlist$[rsp], 0
  0029b	75 05		 jne	 SHORT $LN6@posix_spaw@2

; 5374 :         goto fail_1;

  0029d	e9 05 01 00 00	 jmp	 $fail_1$123148
$LN6@posix_spaw@2:

; 5375 : 
; 5376 : #if defined(PYOS_OS2) && defined(PYCC_GCC)
; 5377 :     Py_BEGIN_ALLOW_THREADS
; 5378 :     spawnval = spawnve(mode, path, argvlist, envlist);
; 5379 :     Py_END_ALLOW_THREADS
; 5380 : #else
; 5381 :     if (mode == _OLD_P_OVERLAY)

  002a2	83 7c 24 78 02	 cmp	 DWORD PTR mode$[rsp], 2
  002a7	75 08		 jne	 SHORT $LN5@posix_spaw@2

; 5382 :         mode = _P_OVERLAY;

  002a9	c7 44 24 78 02
	00 00 00	 mov	 DWORD PTR mode$[rsp], 2
$LN5@posix_spaw@2:

; 5383 : 
; 5384 :     Py_BEGIN_ALLOW_THREADS

  002b1	e8 00 00 00 00	 call	 PyEval_SaveThread
  002b6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR _save$123153[rsp], rax

; 5385 :     spawnval = _spawnve(mode, path, argvlist, envlist);

  002be	4c 8b 4c 24 48	 mov	 r9, QWORD PTR envlist$[rsp]
  002c3	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR argvlist$[rsp]
  002cb	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  002d3	8b 4c 24 78	 mov	 ecx, DWORD PTR mode$[rsp]
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__spawnve
  002dd	48 89 44 24 40	 mov	 QWORD PTR spawnval$[rsp], rax

; 5386 :     Py_END_ALLOW_THREADS

  002e2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR _save$123153[rsp]
  002ea	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 5387 : #endif
; 5388 : 
; 5389 :     if (spawnval == -1)

  002ef	48 83 7c 24 40
	ff		 cmp	 QWORD PTR spawnval$[rsp], -1
  002f5	75 07		 jne	 SHORT $LN4@posix_spaw@2

; 5390 :         (void) posix_error();

  002f7	e8 00 00 00 00	 call	 posix_error

; 5391 :     else

  002fc	eb 16		 jmp	 SHORT $LN3@posix_spaw@2
$LN4@posix_spaw@2:

; 5392 : #if SIZEOF_LONG == SIZEOF_VOID_P
; 5393 :         res = Py_BuildValue("l", (long) spawnval);
; 5394 : #else
; 5395 :         res = Py_BuildValue("L", (PY_LONG_LONG) spawnval);

  002fe	48 8b 54 24 40	 mov	 rdx, QWORD PTR spawnval$[rsp]
  00303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01OCOKONAJ@L?$AA@
  0030a	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  0030f	48 89 44 24 60	 mov	 QWORD PTR res$[rsp], rax
$LN3@posix_spaw@2:
$LN2@posix_spaw@2:

; 5396 : #endif
; 5397 : 
; 5398 :     while (--envc >= 0)

  00314	48 8b 44 24 50	 mov	 rax, QWORD PTR envc$[rsp]
  00319	48 ff c8	 dec	 rax
  0031c	48 89 44 24 50	 mov	 QWORD PTR envc$[rsp], rax
  00321	48 83 7c 24 50
	00		 cmp	 QWORD PTR envc$[rsp], 0
  00327	7c 49		 jl	 SHORT $LN1@posix_spaw@2

; 5399 :         PyMem_DEL(envlist[envc]);

  00329	e8 00 00 00 00	 call	 _Py_PXCTX
  0032e	85 c0		 test	 eax, eax
  00330	74 20		 je	 SHORT $LN24@posix_spaw@2
  00332	48 8b 44 24 48	 mov	 rax, QWORD PTR envlist$[rsp]
  00337	48 8b 4c 24 50	 mov	 rcx, QWORD PTR envc$[rsp]
  0033c	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00340	e8 00 00 00 00	 call	 _PxMem_Free
  00345	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv180[rsp], 0
  00350	eb 1e		 jmp	 SHORT $LN25@posix_spaw@2
$LN24@posix_spaw@2:
  00352	48 8b 44 24 48	 mov	 rax, QWORD PTR envlist$[rsp]
  00357	48 8b 4c 24 50	 mov	 rcx, QWORD PTR envc$[rsp]
  0035c	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00360	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00365	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv180[rsp], 0
$LN25@posix_spaw@2:
  00370	eb a2		 jmp	 SHORT $LN2@posix_spaw@2
$LN1@posix_spaw@2:

; 5400 :     PyMem_DEL(envlist);

  00372	e8 00 00 00 00	 call	 _Py_PXCTX
  00377	85 c0		 test	 eax, eax
  00379	74 17		 je	 SHORT $LN26@posix_spaw@2
  0037b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR envlist$[rsp]
  00380	e8 00 00 00 00	 call	 _PxMem_Free
  00385	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
  00390	eb 15		 jmp	 SHORT $LN27@posix_spaw@2
$LN26@posix_spaw@2:
  00392	48 8b 4c 24 48	 mov	 rcx, QWORD PTR envlist$[rsp]
  00397	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0039c	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
$LN27@posix_spaw@2:
$fail_1$123148:

; 5401 :   fail_1:
; 5402 :     free_string_array(argvlist, lastarg);

  003a7	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR lastarg$[rsp]
  003af	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argvlist$[rsp]
  003b7	e8 00 00 00 00	 call	 free_string_array
$fail_0$123129:

; 5403 :   fail_0:
; 5404 :     Py_DECREF(opath);

  003bc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR opath$[rsp]
  003c4	e8 00 00 00 00	 call	 _Py_DecRef

; 5405 :     return res;

  003c9	48 8b 44 24 60	 mov	 rax, QWORD PTR res$[rsp]
$LN18@posix_spaw@2:

; 5406 : }

  003ce	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  003d5	c3		 ret	 0
posix_spawnve ENDP
_TEXT	ENDS
EXTRN	__imp_getpid:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_getpid DD imagerel posix_getpid
	DD	imagerel posix_getpid+32
	DD	imagerel $unwind$posix_getpid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_getpid DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_getpid
_TEXT	SEGMENT
self$ = 48
noargs$ = 56
posix_getpid PROC					; COMDAT

; 6225 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6226 :     return PyLong_FromPid(getpid());

  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  00014	8b c8		 mov	 ecx, eax
  00016	e8 00 00 00 00	 call	 PyLong_FromLong

; 6227 : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
posix_getpid ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_getppid DD imagerel posix_getppid
	DD	imagerel posix_getppid+24
	DD	imagerel $unwind$posix_getppid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_getppid DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_getppid
_TEXT	SEGMENT
self$ = 48
noargs$ = 56
posix_getppid PROC					; COMDAT

; 6560 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6561 : #ifdef MS_WINDOWS
; 6562 :     return win32_getppid();

  0000e	e8 00 00 00 00	 call	 win32_getppid

; 6563 : #else
; 6564 :     return PyLong_FromPid(getppid());
; 6565 : #endif
; 6566 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
posix_getppid ENDP
_TEXT	ENDS
EXTRN	Process32Next:PROC
EXTRN	Process32First:PROC
EXTRN	CreateToolhelp32Snapshot:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_getppid DD imagerel win32_getppid
	DD	imagerel win32_getppid+197
	DD	imagerel $unwind$win32_getppid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_getppid DD 020701H
	DD	02f0107H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT win32_getppid
_TEXT	SEGMENT
mypid$ = 32
snapshot$ = 40
have_record$ = 48
result$ = 56
pe$ = 64
win32_getppid PROC					; COMDAT

; 6515 : {

  00000	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H

; 6516 :     HANDLE snapshot;
; 6517 :     pid_t mypid;
; 6518 :     PyObject* result = NULL;

  00007	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 6519 :     BOOL have_record;
; 6520 :     PROCESSENTRY32 pe;
; 6521 : 
; 6522 :     mypid = getpid(); /* This function never fails */

  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  00016	89 44 24 20	 mov	 DWORD PTR mypid$[rsp], eax

; 6523 : 
; 6524 :     snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

  0001a	33 d2		 xor	 edx, edx
  0001c	b9 02 00 00 00	 mov	 ecx, 2
  00021	e8 00 00 00 00	 call	 CreateToolhelp32Snapshot
  00026	48 89 44 24 28	 mov	 QWORD PTR snapshot$[rsp], rax

; 6525 :     if (snapshot == INVALID_HANDLE_VALUE)

  0002b	48 83 7c 24 28
	ff		 cmp	 QWORD PTR snapshot$[rsp], -1
  00031	75 0f		 jne	 SHORT $LN5@win32_getp

; 6526 :         return PyErr_SetFromWindowsErr(GetLastError());

  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00040	eb 7b		 jmp	 SHORT $LN6@win32_getp
$LN5@win32_getp:

; 6527 : 
; 6528 :     pe.dwSize = sizeof(pe);

  00042	c7 44 24 40 30
	01 00 00	 mov	 DWORD PTR pe$[rsp], 304	; 00000130H

; 6529 :     have_record = Process32First(snapshot, &pe);

  0004a	48 8d 54 24 40	 lea	 rdx, QWORD PTR pe$[rsp]
  0004f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR snapshot$[rsp]
  00054	e8 00 00 00 00	 call	 Process32First
  00059	89 44 24 30	 mov	 DWORD PTR have_record$[rsp], eax
$LN4@win32_getp:

; 6530 :     while (have_record) {

  0005d	83 7c 24 30 00	 cmp	 DWORD PTR have_record$[rsp], 0
  00062	74 2f		 je	 SHORT $LN3@win32_getp

; 6531 :         if (mypid == (pid_t)pe.th32ProcessID) {

  00064	8b 44 24 48	 mov	 eax, DWORD PTR pe$[rsp+8]
  00068	39 44 24 20	 cmp	 DWORD PTR mypid$[rsp], eax
  0006c	75 10		 jne	 SHORT $LN2@win32_getp

; 6532 :             /* We could cache the ulong value in a static variable. */
; 6533 :             result = PyLong_FromPid((pid_t)pe.th32ParentProcessID);

  0006e	8b 4c 24 60	 mov	 ecx, DWORD PTR pe$[rsp+32]
  00072	e8 00 00 00 00	 call	 PyLong_FromLong
  00077	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 6534 :             break;

  0007c	eb 15		 jmp	 SHORT $LN3@win32_getp
$LN2@win32_getp:

; 6535 :         }
; 6536 : 
; 6537 :         have_record = Process32Next(snapshot, &pe);

  0007e	48 8d 54 24 40	 lea	 rdx, QWORD PTR pe$[rsp]
  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR snapshot$[rsp]
  00088	e8 00 00 00 00	 call	 Process32Next
  0008d	89 44 24 30	 mov	 DWORD PTR have_record$[rsp], eax

; 6538 :     }

  00091	eb ca		 jmp	 SHORT $LN4@win32_getp
$LN3@win32_getp:

; 6539 : 
; 6540 :     /* If our loop exits and our pid was not found (result will be NULL)
; 6541 :      * then GetLastError will return ERROR_NO_MORE_FILES. This is an
; 6542 :      * error anyway, so let's raise it. */
; 6543 :     if (!result)

  00093	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  00099	75 12		 jne	 SHORT $LN1@win32_getp

; 6544 :         result = PyErr_SetFromWindowsErr(GetLastError());

  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  000a1	8b c8		 mov	 ecx, eax
  000a3	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000a8	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax
$LN1@win32_getp:

; 6545 : 
; 6546 :     CloseHandle(snapshot);

  000ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR snapshot$[rsp]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 6547 : 
; 6548 :     return result;

  000b8	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN6@win32_getp:

; 6549 : }

  000bd	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  000c4	c3		 ret	 0
win32_getppid ENDP
_TEXT	ENDS
EXTRN	__imp_GetUserNameW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_getlogin DD imagerel posix_getlogin
	DD	imagerel posix_getlogin+124
	DD	imagerel $unwind$posix_getlogin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_getlogin DD 021101H
	DD	04b0111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT posix_getlogin
_TEXT	SEGMENT
num_chars$ = 32
user_name$ = 48
result$ = 576
self$ = 608
noargs$ = 616
posix_getlogin PROC					; COMDAT

; 6577 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H

; 6578 :     PyObject *result = NULL;

  00011	48 c7 84 24 40
	02 00 00 00 00
	00 00		 mov	 QWORD PTR result$[rsp], 0

; 6579 : #ifdef MS_WINDOWS
; 6580 :     wchar_t user_name[UNLEN + 1];
; 6581 :     DWORD num_chars = Py_ARRAY_LENGTH(user_name);

  0001d	c7 44 24 20 01
	01 00 00	 mov	 DWORD PTR num_chars$[rsp], 257 ; 00000101H

; 6582 : 
; 6583 :     if (GetUserNameW(user_name, &num_chars)) {

  00025	48 8d 54 24 20	 lea	 rdx, QWORD PTR num_chars$[rsp]
  0002a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR user_name$[rsp]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetUserNameW
  00035	85 c0		 test	 eax, eax
  00037	74 1e		 je	 SHORT $LN2@posix_getl

; 6584 :         /* num_chars is the number of unicode chars plus null terminator */
; 6585 :         result = PyUnicode_FromWideChar(user_name, num_chars - 1);

  00039	8b 44 24 20	 mov	 eax, DWORD PTR num_chars$[rsp]
  0003d	ff c8		 dec	 eax
  0003f	8b c0		 mov	 eax, eax
  00041	8b d0		 mov	 edx, eax
  00043	48 8d 4c 24 30	 lea	 rcx, QWORD PTR user_name$[rsp]
  00048	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  0004d	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR result$[rsp], rax

; 6586 :     }
; 6587 :     else

  00055	eb 15		 jmp	 SHORT $LN1@posix_getl
$LN2@posix_getl:

; 6588 :         result = PyErr_SetFromWindowsErr(GetLastError());

  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0005d	8b c8		 mov	 ecx, eax
  0005f	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00064	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR result$[rsp], rax
$LN1@posix_getl:

; 6589 : #else
; 6590 :     char *name;
; 6591 :     int old_errno = errno;
; 6592 : 
; 6593 :     errno = 0;
; 6594 :     name = getlogin();
; 6595 :     if (name == NULL) {
; 6596 :         if (errno)
; 6597 :             posix_error();
; 6598 :         else
; 6599 :             PyErr_SetString(PyExc_OSError, "unable to determine login name");
; 6600 :     }
; 6601 :     else
; 6602 :         result = PyUnicode_DecodeFSDefault(name);
; 6603 :     errno = old_errno;
; 6604 : #endif
; 6605 :     return result;

  0006c	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR result$[rsp]

; 6606 : }

  00074	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  0007b	c3		 ret	 0
posix_getlogin ENDP
_TEXT	ENDS
PUBLIC	??_C@_07BLEFEIJF@kk?3kill?$AA@			; `string'
EXTRN	__imp_TerminateProcess:PROC
EXTRN	__imp_OpenProcess:PROC
EXTRN	__imp_GenerateConsoleCtrlEvent:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_kill DD imagerel win32_kill
	DD	imagerel win32_kill+271
	DD	imagerel $unwind$win32_kill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_kill DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_07BLEFEIJF@kk?3kill?$AA@
CONST	SEGMENT
??_C@_07BLEFEIJF@kk?3kill?$AA@ DB 'kk:kill', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT win32_kill
_TEXT	SEGMENT
sig$ = 32
pid$ = 36
err$ = 40
result$ = 48
handle$ = 56
self$ = 80
args$ = 88
win32_kill PROC						; COMDAT

; 6686 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 6687 :     PyObject *result;
; 6688 :     DWORD pid, sig, err;
; 6689 :     HANDLE handle;
; 6690 : 
; 6691 :     if (!PyArg_ParseTuple(args, "kk:kill", &pid, &sig))

  0000e	4c 8d 4c 24 20	 lea	 r9, QWORD PTR sig$[rsp]
  00013	4c 8d 44 24 24	 lea	 r8, QWORD PTR pid$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07BLEFEIJF@kk?3kill?$AA@
  0001f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN8@win32_kill

; 6692 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 d6 00 00 00	 jmp	 $LN9@win32_kill
$LN8@win32_kill:

; 6693 : 
; 6694 :     /* Console processes which share a common console can be sent CTRL+C or
; 6695 :        CTRL+BREAK events, provided they handle said events. */
; 6696 :     if (sig == CTRL_C_EVENT || sig == CTRL_BREAK_EVENT) {

  00034	83 7c 24 20 00	 cmp	 DWORD PTR sig$[rsp], 0
  00039	74 07		 je	 SHORT $LN6@win32_kill
  0003b	83 7c 24 20 01	 cmp	 DWORD PTR sig$[rsp], 1
  00040	75 3f		 jne	 SHORT $LN7@win32_kill
$LN6@win32_kill:

; 6697 :         if (GenerateConsoleCtrlEvent(sig, pid) == 0) {

  00042	8b 54 24 24	 mov	 edx, DWORD PTR pid$[rsp]
  00046	8b 4c 24 20	 mov	 ecx, DWORD PTR sig$[rsp]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GenerateConsoleCtrlEvent
  00050	85 c0		 test	 eax, eax
  00052	75 15		 jne	 SHORT $LN5@win32_kill

; 6698 :             err = GetLastError();

  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0005a	89 44 24 28	 mov	 DWORD PTR err$[rsp], eax

; 6699 :             PyErr_SetFromWindowsErr(err);

  0005e	8b 4c 24 28	 mov	 ecx, DWORD PTR err$[rsp]
  00062	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 6700 :         }
; 6701 :         else

  00067	eb 18		 jmp	 SHORT $LN4@win32_kill
$LN5@win32_kill:

; 6702 :             Py_RETURN_NONE;

  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00070	e8 00 00 00 00	 call	 _Py_IncRef
  00075	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0007c	e9 89 00 00 00	 jmp	 $LN9@win32_kill
$LN4@win32_kill:
$LN7@win32_kill:

; 6703 :     }
; 6704 : 
; 6705 :     /* If the signal is outside of what GenerateConsoleCtrlEvent can use,
; 6706 :        attempt to open and terminate the process. */
; 6707 :     handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);

  00081	44 8b 44 24 24	 mov	 r8d, DWORD PTR pid$[rsp]
  00086	33 d2		 xor	 edx, edx
  00088	b9 ff ff 1f 00	 mov	 ecx, 2097151		; 001fffffH
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OpenProcess
  00093	48 89 44 24 38	 mov	 QWORD PTR handle$[rsp], rax

; 6708 :     if (handle == NULL) {

  00098	48 83 7c 24 38
	00		 cmp	 QWORD PTR handle$[rsp], 0
  0009e	75 15		 jne	 SHORT $LN3@win32_kill

; 6709 :         err = GetLastError();

  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  000a6	89 44 24 28	 mov	 DWORD PTR err$[rsp], eax

; 6710 :         return PyErr_SetFromWindowsErr(err);

  000aa	8b 4c 24 28	 mov	 ecx, DWORD PTR err$[rsp]
  000ae	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000b3	eb 55		 jmp	 SHORT $LN9@win32_kill
$LN3@win32_kill:

; 6711 :     }
; 6712 : 
; 6713 :     if (TerminateProcess(handle, sig) == 0) {

  000b5	8b 54 24 20	 mov	 edx, DWORD PTR sig$[rsp]
  000b9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR handle$[rsp]
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TerminateProcess
  000c4	85 c0		 test	 eax, eax
  000c6	75 1a		 jne	 SHORT $LN2@win32_kill

; 6714 :         err = GetLastError();

  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  000ce	89 44 24 28	 mov	 DWORD PTR err$[rsp], eax

; 6715 :         result = PyErr_SetFromWindowsErr(err);

  000d2	8b 4c 24 28	 mov	 ecx, DWORD PTR err$[rsp]
  000d6	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000db	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 6716 :     } else {

  000e0	eb 18		 jmp	 SHORT $LN1@win32_kill
$LN2@win32_kill:

; 6717 :         Py_INCREF(Py_None);

  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000e9	e8 00 00 00 00	 call	 _Py_IncRef

; 6718 :         result = Py_None;

  000ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000f5	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax
$LN1@win32_kill:

; 6719 :     }
; 6720 : 
; 6721 :     CloseHandle(handle);

  000fa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR handle$[rsp]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 6722 :     return result;

  00105	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN9@win32_kill:

; 6723 : }

  0010a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010e	c3		 ret	 0
win32_kill ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MOIFFGMJ@Ni?$AA@			; `string'
PUBLIC	??_C@_0L@KMFJLKIN@ii?3waitpid?$AA@		; `string'
EXTRN	__imp__cwait:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_waitpid DD imagerel posix_waitpid
	DD	imagerel posix_waitpid+157
	DD	imagerel $unwind$posix_waitpid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_waitpid DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_02MOIFFGMJ@Ni?$AA@
CONST	SEGMENT
??_C@_02MOIFFGMJ@Ni?$AA@ DB 'Ni', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KMFJLKIN@ii?3waitpid?$AA@
CONST	SEGMENT
??_C@_0L@KMFJLKIN@ii?3waitpid?$AA@ DB 'ii:waitpid', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_waitpid
_TEXT	SEGMENT
options$ = 32
pid$ = 40
status$ = 48
_save$123435 = 56
tv79 = 64
self$ = 96
args$ = 104
posix_waitpid PROC					; COMDAT

; 7109 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 7110 :     Py_intptr_t pid;
; 7111 :     int status, options;
; 7112 : 
; 7113 :     if (!PyArg_ParseTuple(args, _Py_PARSE_PID "i:waitpid", &pid, &options))

  0000e	4c 8d 4c 24 20	 lea	 r9, QWORD PTR options$[rsp]
  00013	4c 8d 44 24 28	 lea	 r8, QWORD PTR pid$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@KMFJLKIN@ii?3waitpid?$AA@
  0001f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN2@posix_wait

; 7114 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 67		 jmp	 SHORT $LN3@posix_wait
$LN2@posix_wait:

; 7115 :     Py_BEGIN_ALLOW_THREADS

  00031	e8 00 00 00 00	 call	 PyEval_SaveThread
  00036	48 89 44 24 38	 mov	 QWORD PTR _save$123435[rsp], rax

; 7116 :     pid = _cwait(&status, pid, options);

  0003b	44 8b 44 24 20	 mov	 r8d, DWORD PTR options$[rsp]
  00040	48 8b 54 24 28	 mov	 rdx, QWORD PTR pid$[rsp]
  00045	48 8d 4c 24 30	 lea	 rcx, QWORD PTR status$[rsp]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__cwait
  00050	48 89 44 24 28	 mov	 QWORD PTR pid$[rsp], rax

; 7117 :     Py_END_ALLOW_THREADS

  00055	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _save$123435[rsp]
  0005a	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7118 :     if (pid == -1)

  0005f	48 83 7c 24 28
	ff		 cmp	 QWORD PTR pid$[rsp], -1
  00065	75 07		 jne	 SHORT $LN1@posix_wait

; 7119 :         return posix_error();

  00067	e8 00 00 00 00	 call	 posix_error
  0006c	eb 2a		 jmp	 SHORT $LN3@posix_wait
$LN1@posix_wait:

; 7120 : 
; 7121 :     /* shift the status left a byte so this is more like the POSIX waitpid */
; 7122 :     return Py_BuildValue("Ni", PyLong_FromPid(pid), status << 8);

  0006e	8b 44 24 30	 mov	 eax, DWORD PTR status$[rsp]
  00072	c1 e0 08	 shl	 eax, 8
  00075	89 44 24 40	 mov	 DWORD PTR tv79[rsp], eax
  00079	8b 4c 24 28	 mov	 ecx, DWORD PTR pid$[rsp]
  0007d	e8 00 00 00 00	 call	 PyLong_FromLong
  00082	8b 4c 24 40	 mov	 ecx, DWORD PTR tv79[rsp]
  00086	44 8b c1	 mov	 r8d, ecx
  00089	48 8b d0	 mov	 rdx, rax
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02MOIFFGMJ@Ni?$AA@
  00093	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
$LN3@posix_wait:

; 7123 : }

  00098	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0009c	c3		 ret	 0
posix_waitpid ENDP
_TEXT	ENDS
PUBLIC	??_C@_13CGOKJPIL@?$AA?1?$AA?$AA@		; `string'
PUBLIC	??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@		; `string'
PUBLIC	_dirnameW
;	COMDAT pdata
pdata	SEGMENT
$pdata$_dirnameW DD imagerel $LN8
	DD	imagerel $LN8+119
	DD	imagerel $unwind$_dirnameW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_dirnameW DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_13CGOKJPIL@?$AA?1?$AA?$AA@
CONST	SEGMENT
??_C@_13CGOKJPIL@?$AA?1?$AA?$AA@ DB '/', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@
CONST	SEGMENT
??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@ DB '\', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _dirnameW
_TEXT	SEGMENT
ptr$ = 32
path$ = 64
_dirnameW PROC						; COMDAT

; 7244 : void _dirnameW(WCHAR *path) {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7245 :     /* Remove the last portion of the path */
; 7246 : 
; 7247 :     WCHAR *ptr;
; 7248 : 
; 7249 :     /* walk the path from the end until a backslash is encountered */
; 7250 :     for(ptr = path + wcslen(path); ptr != path; ptr--)

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  00019	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  0001d	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax
  00022	eb 0e		 jmp	 SHORT $LN5@dirnameW
$LN4@dirnameW:
  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  00029	48 83 e8 02	 sub	 rax, 2
  0002d	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax
$LN5@dirnameW:
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR path$[rsp]
  00037	48 39 44 24 20	 cmp	 QWORD PTR ptr$[rsp], rax
  0003c	74 2a		 je	 SHORT $LN3@dirnameW

; 7251 :     {
; 7252 :         if(*ptr == *L"\\" || *ptr == *L"/") {

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  00043	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00046	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@
  0004d	3b c1		 cmp	 eax, ecx
  0004f	74 13		 je	 SHORT $LN1@dirnameW
  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  00056	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00059	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ??_C@_13CGOKJPIL@?$AA?1?$AA?$AA@
  00060	3b c1		 cmp	 eax, ecx
  00062	75 02		 jne	 SHORT $LN2@dirnameW
$LN1@dirnameW:

; 7253 :             break;

  00064	eb 02		 jmp	 SHORT $LN3@dirnameW
$LN2@dirnameW:

; 7254 :         }
; 7255 :     }

  00066	eb bc		 jmp	 SHORT $LN4@dirnameW
$LN3@dirnameW:

; 7256 :     *ptr = 0;

  00068	33 c0		 xor	 eax, eax
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  0006f	66 89 01	 mov	 WORD PTR [rcx], ax

; 7257 : }

  00072	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00076	c3		 ret	 0
_dirnameW ENDP
_TEXT	ENDS
PUBLIC	_dirnameA
;	COMDAT pdata
pdata	SEGMENT
$pdata$_dirnameA DD imagerel $LN8
	DD	imagerel $LN8+105
	DD	imagerel $unwind$_dirnameA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_dirnameA DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _dirnameA
_TEXT	SEGMENT
ptr$ = 32
path$ = 64
_dirnameA PROC						; COMDAT

; 7259 : void _dirnameA(char *path) {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7260 :     /* Remove the last portion of the path */
; 7261 : 
; 7262 :     char *ptr;
; 7263 : 
; 7264 :     /* walk the path from the end until a backslash is encountered */
; 7265 :     for(ptr = path + strlen(path); ptr != path; ptr--)

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  0000e	e8 00 00 00 00	 call	 strlen
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR path$[rsp]
  00018	48 03 c8	 add	 rcx, rax
  0001b	48 8b c1	 mov	 rax, rcx
  0001e	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax
  00023	eb 0d		 jmp	 SHORT $LN5@dirnameA
$LN4@dirnameA:
  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0002a	48 ff c8	 dec	 rax
  0002d	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax
$LN5@dirnameA:
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR path$[rsp]
  00037	48 39 44 24 20	 cmp	 QWORD PTR ptr$[rsp], rax
  0003c	74 1e		 je	 SHORT $LN3@dirnameA

; 7266 :     {
; 7267 :         if(*ptr == '\\' || *ptr == '/') {

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  00043	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00046	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00049	74 0d		 je	 SHORT $LN1@dirnameA
  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  00050	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00053	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00056	75 02		 jne	 SHORT $LN2@dirnameA
$LN1@dirnameA:

; 7268 :             break;

  00058	eb 02		 jmp	 SHORT $LN3@dirnameA
$LN2@dirnameA:

; 7269 :         }
; 7270 :     }

  0005a	eb c9		 jmp	 SHORT $LN4@dirnameA
$LN3@dirnameA:

; 7271 :     *ptr = 0;

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  00061	c6 00 00	 mov	 BYTE PTR [rax], 0

; 7272 : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
_dirnameA ENDP
_TEXT	ENDS
PUBLIC	_is_absW
;	COMDAT pdata
pdata	SEGMENT
$pdata$_is_absW DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$_is_absW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_is_absW DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _is_absW
_TEXT	SEGMENT
tv71 = 0
path$ = 32
_is_absW PROC						; COMDAT

; 7274 : int _is_absW(WCHAR *path) {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 7275 :     /* Is this path absolute? */
; 7276 : 
; 7277 :     return path[0] == L'\\' || path[0] == L'/' || path[1] == L':';

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR path$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00014	74 24		 je	 SHORT $LN3@is_absW
  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR path$[rsp]
  0001b	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0001e	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00021	74 17		 je	 SHORT $LN3@is_absW
  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR path$[rsp]
  00028	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  0002c	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0002f	74 09		 je	 SHORT $LN3@is_absW
  00031	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv71[rsp], 0
  00038	eb 07		 jmp	 SHORT $LN4@is_absW
$LN3@is_absW:
  0003a	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv71[rsp], 1
$LN4@is_absW:
  00041	8b 04 24	 mov	 eax, DWORD PTR tv71[rsp]

; 7278 : 
; 7279 : }

  00044	48 83 c4 18	 add	 rsp, 24
  00048	c3		 ret	 0
_is_absW ENDP
_TEXT	ENDS
PUBLIC	_is_absA
;	COMDAT pdata
pdata	SEGMENT
$pdata$_is_absA DD imagerel $LN5
	DD	imagerel $LN5+73
	DD	imagerel $unwind$_is_absA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_is_absA DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _is_absA
_TEXT	SEGMENT
tv71 = 0
path$ = 32
_is_absA PROC						; COMDAT

; 7281 : int _is_absA(char *path) {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 7282 :     /* Is this path absolute? */
; 7283 : 
; 7284 :     return path[0] == '\\' || path[0] == '/' || path[1] == ':';

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR path$[rsp]
  0000e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00011	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00014	74 24		 je	 SHORT $LN3@is_absA
  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR path$[rsp]
  0001b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0001e	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00021	74 17		 je	 SHORT $LN3@is_absA
  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR path$[rsp]
  00028	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  0002c	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0002f	74 09		 je	 SHORT $LN3@is_absA
  00031	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv71[rsp], 0
  00038	eb 07		 jmp	 SHORT $LN4@is_absA
$LN3@is_absA:
  0003a	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv71[rsp], 1
$LN4@is_absA:
  00041	8b 04 24	 mov	 eax, DWORD PTR tv71[rsp]

; 7285 : 
; 7286 : }

  00044	48 83 c4 18	 add	 rsp, 24
  00048	c3		 ret	 0
_is_absA ENDP
_TEXT	ENDS
PUBLIC	_joinW
;	COMDAT pdata
pdata	SEGMENT
$pdata$_joinW DD imagerel $LN5
	DD	imagerel $LN5+153
	DD	imagerel $unwind$_joinW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_joinW DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _joinW
_TEXT	SEGMENT
root_len$ = 32
dest_path$ = 64
root$ = 72
rest$ = 80
_joinW	PROC						; COMDAT

; 7288 : void _joinW(WCHAR *dest_path, const WCHAR *root, const WCHAR *rest) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7289 :     /* join root and rest with a backslash */
; 7290 :     int root_len;
; 7291 : 
; 7292 :     if(_is_absW(rest)) {

  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rest$[rsp]
  00018	e8 00 00 00 00	 call	 _is_absW
  0001d	85 c0		 test	 eax, eax
  0001f	74 12		 je	 SHORT $LN2@joinW

; 7293 :         wcscpy(dest_path, rest);

  00021	48 8b 54 24 50	 mov	 rdx, QWORD PTR rest$[rsp]
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest_path$[rsp]
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 7294 :         return;

  00031	eb 61		 jmp	 SHORT $LN3@joinW
$LN2@joinW:

; 7295 :     }
; 7296 : 
; 7297 :     root_len = wcslen(root);

  00033	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  0003e	89 44 24 20	 mov	 DWORD PTR root_len$[rsp], eax

; 7298 : 
; 7299 :     wcscpy(dest_path, root);

  00042	48 8b 54 24 48	 mov	 rdx, QWORD PTR root$[rsp]
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest_path$[rsp]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 7300 :     if(root_len) {

  00052	83 7c 24 20 00	 cmp	 DWORD PTR root_len$[rsp], 0
  00057	74 1f		 je	 SHORT $LN1@joinW

; 7301 :         dest_path[root_len] = *L"\\";

  00059	48 63 44 24 20	 movsxd	 rax, DWORD PTR root_len$[rsp]
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest_path$[rsp]
  00063	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR ??_C@_13FPGAJAPJ@?$AA?2?$AA?$AA@
  0006a	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 7302 :         root_len += 1;

  0006e	8b 44 24 20	 mov	 eax, DWORD PTR root_len$[rsp]
  00072	ff c0		 inc	 eax
  00074	89 44 24 20	 mov	 DWORD PTR root_len$[rsp], eax
$LN1@joinW:

; 7303 :     }
; 7304 :     wcscpy(dest_path+root_len, rest);

  00078	48 63 44 24 20	 movsxd	 rax, DWORD PTR root_len$[rsp]
  0007d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest_path$[rsp]
  00082	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00086	48 8b 54 24 50	 mov	 rdx, QWORD PTR rest$[rsp]
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy
$LN3@joinW:

; 7305 : }

  00094	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00098	c3		 ret	 0
_joinW	ENDP
_TEXT	ENDS
PUBLIC	_joinA
;	COMDAT pdata
pdata	SEGMENT
$pdata$_joinA DD imagerel $LN5
	DD	imagerel $LN5+144
	DD	imagerel $unwind$_joinA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_joinA DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _joinA
_TEXT	SEGMENT
root_len$ = 32
dest_path$ = 64
root$ = 72
rest$ = 80
_joinA	PROC						; COMDAT

; 7307 : void _joinA(char *dest_path, const char *root, const char *rest) {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7308 :     /* join root and rest with a backslash */
; 7309 :     int root_len;
; 7310 : 
; 7311 :     if(_is_absA(rest)) {

  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rest$[rsp]
  00018	e8 00 00 00 00	 call	 _is_absA
  0001d	85 c0		 test	 eax, eax
  0001f	74 11		 je	 SHORT $LN2@joinA

; 7312 :         strcpy(dest_path, rest);

  00021	48 8b 54 24 50	 mov	 rdx, QWORD PTR rest$[rsp]
  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest_path$[rsp]
  0002b	e8 00 00 00 00	 call	 strcpy

; 7313 :         return;

  00030	eb 59		 jmp	 SHORT $LN3@joinA
$LN2@joinA:

; 7314 :     }
; 7315 : 
; 7316 :     root_len = strlen(root);

  00032	48 8b 4c 24 48	 mov	 rcx, QWORD PTR root$[rsp]
  00037	e8 00 00 00 00	 call	 strlen
  0003c	89 44 24 20	 mov	 DWORD PTR root_len$[rsp], eax

; 7317 : 
; 7318 :     strcpy(dest_path, root);

  00040	48 8b 54 24 48	 mov	 rdx, QWORD PTR root$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest_path$[rsp]
  0004a	e8 00 00 00 00	 call	 strcpy

; 7319 :     if(root_len) {

  0004f	83 7c 24 20 00	 cmp	 DWORD PTR root_len$[rsp], 0
  00054	74 18		 je	 SHORT $LN1@joinA

; 7320 :         dest_path[root_len] = '\\';

  00056	48 63 44 24 20	 movsxd	 rax, DWORD PTR root_len$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest_path$[rsp]
  00060	c6 04 01 5c	 mov	 BYTE PTR [rcx+rax], 92	; 0000005cH

; 7321 :         root_len += 1;

  00064	8b 44 24 20	 mov	 eax, DWORD PTR root_len$[rsp]
  00068	ff c0		 inc	 eax
  0006a	89 44 24 20	 mov	 DWORD PTR root_len$[rsp], eax
$LN1@joinA:

; 7322 :     }
; 7323 :     strcpy(dest_path+root_len, rest);

  0006e	48 63 44 24 20	 movsxd	 rax, DWORD PTR root_len$[rsp]
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest_path$[rsp]
  00078	48 03 c8	 add	 rcx, rax
  0007b	48 8b c1	 mov	 rax, rcx
  0007e	48 8b 54 24 50	 mov	 rdx, QWORD PTR rest$[rsp]
  00083	48 8b c8	 mov	 rcx, rax
  00086	e8 00 00 00 00	 call	 strcpy
$LN3@joinA:

; 7324 : }

  0008b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008f	c3		 ret	 0
_joinA	ENDP
_TEXT	ENDS
PUBLIC	??_C@_11LOCGONAA@?$AA?$AA@			; `string'
PUBLIC	_check_dirW
;	COMDAT pdata
pdata	SEGMENT
$pdata$_check_dirW DD imagerel $LN5
	DD	imagerel $LN5+187
	DD	imagerel $unwind$_check_dirW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_check_dirW DD 031201H
	DD	08e0112H
	DD	0700bH
xdata	ENDS
;	COMDAT ??_C@_11LOCGONAA@?$AA?$AA@
CONST	SEGMENT
??_C@_11LOCGONAA@?$AA?$AA@ DB 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _check_dirW
_TEXT	SEGMENT
src_resolved$ = 32
dest_parent$ = 560
src_info$ = 1088
tv88 = 1128
src$ = 1152
dest$ = 1160
_check_dirW PROC					; COMDAT

; 7327 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 70 04
	00 00		 sub	 rsp, 1136		; 00000470H

; 7328 :     /* Return True if the path at src relative to dest is a directory */
; 7329 :     WIN32_FILE_ATTRIBUTE_DATA src_info;
; 7330 :     WCHAR dest_parent[MAX_PATH];
; 7331 :     WCHAR src_resolved[MAX_PATH] = L"";

  00012	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_11LOCGONAA@?$AA?$AA@
  00019	66 89 44 24 20	 mov	 WORD PTR src_resolved$[rsp], ax
  0001e	48 8d 44 24 22	 lea	 rax, QWORD PTR src_resolved$[rsp+2]
  00023	48 8b f8	 mov	 rdi, rax
  00026	33 c0		 xor	 eax, eax
  00028	b9 06 02 00 00	 mov	 ecx, 518		; 00000206H
  0002d	f3 aa		 rep stosb

; 7332 : 
; 7333 :     /* dest_parent = os.path.dirname(dest) */
; 7334 :     wcscpy(dest_parent, dest);

  0002f	48 8b 94 24 88
	04 00 00	 mov	 rdx, QWORD PTR dest$[rsp]
  00037	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR dest_parent$[rsp]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcscpy

; 7335 :     _dirnameW(dest_parent);

  00045	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR dest_parent$[rsp]
  0004d	e8 00 00 00 00	 call	 _dirnameW

; 7336 :     /* src_resolved = os.path.join(dest_parent, src) */
; 7337 :     _joinW(src_resolved, dest_parent, src);

  00052	4c 8b 84 24 80
	04 00 00	 mov	 r8, QWORD PTR src$[rsp]
  0005a	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR dest_parent$[rsp]
  00062	48 8d 4c 24 20	 lea	 rcx, QWORD PTR src_resolved$[rsp]
  00067	e8 00 00 00 00	 call	 _joinW

; 7338 :     return (
; 7339 :         GetFileAttributesExW(src_resolved, GetFileExInfoStandard, &src_info)
; 7340 :         && src_info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
; 7341 :     );

  0006c	4c 8d 84 24 40
	04 00 00	 lea	 r8, QWORD PTR src_info$[rsp]
  00074	33 d2		 xor	 edx, edx
  00076	48 8d 4c 24 20	 lea	 rcx, QWORD PTR src_resolved$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesExW
  00081	85 c0		 test	 eax, eax
  00083	74 1b		 je	 SHORT $LN3@check_dirW
  00085	8b 84 24 40 04
	00 00		 mov	 eax, DWORD PTR src_info$[rsp]
  0008c	83 e0 10	 and	 eax, 16
  0008f	85 c0		 test	 eax, eax
  00091	74 0d		 je	 SHORT $LN3@check_dirW
  00093	c7 84 24 68 04
	00 00 01 00 00
	00		 mov	 DWORD PTR tv88[rsp], 1
  0009e	eb 0b		 jmp	 SHORT $LN4@check_dirW
$LN3@check_dirW:
  000a0	c7 84 24 68 04
	00 00 00 00 00
	00		 mov	 DWORD PTR tv88[rsp], 0
$LN4@check_dirW:
  000ab	8b 84 24 68 04
	00 00		 mov	 eax, DWORD PTR tv88[rsp]

; 7342 : }

  000b2	48 81 c4 70 04
	00 00		 add	 rsp, 1136		; 00000470H
  000b9	5f		 pop	 rdi
  000ba	c3		 ret	 0
_check_dirW ENDP
_TEXT	ENDS
PUBLIC	_check_dirA
EXTRN	__imp_GetFileAttributesExA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_check_dirA DD imagerel $LN5
	DD	imagerel $LN5+185
	DD	imagerel $unwind$_check_dirA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_check_dirA DD 031201H
	DD	04e0112H
	DD	0700bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _check_dirA
_TEXT	SEGMENT
src_resolved$ = 32
dest_parent$ = 304
src_info$ = 576
tv88 = 616
src$ = 640
dest$ = 648
_check_dirA PROC					; COMDAT

; 7345 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 70 02
	00 00		 sub	 rsp, 624		; 00000270H

; 7346 :     /* Return True if the path at src relative to dest is a directory */
; 7347 :     WIN32_FILE_ATTRIBUTE_DATA src_info;
; 7348 :     char dest_parent[MAX_PATH];
; 7349 :     char src_resolved[MAX_PATH] = "";

  00012	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_00CNPNBAHC@?$AA@
  00019	88 44 24 20	 mov	 BYTE PTR src_resolved$[rsp], al
  0001d	48 8d 44 24 21	 lea	 rax, QWORD PTR src_resolved$[rsp+1]
  00022	48 8b f8	 mov	 rdi, rax
  00025	33 c0		 xor	 eax, eax
  00027	b9 03 01 00 00	 mov	 ecx, 259		; 00000103H
  0002c	f3 aa		 rep stosb

; 7350 : 
; 7351 :     /* dest_parent = os.path.dirname(dest) */
; 7352 :     strcpy(dest_parent, dest);

  0002e	48 8b 94 24 88
	02 00 00	 mov	 rdx, QWORD PTR dest$[rsp]
  00036	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR dest_parent$[rsp]
  0003e	e8 00 00 00 00	 call	 strcpy

; 7353 :     _dirnameW(dest_parent);

  00043	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR dest_parent$[rsp]
  0004b	e8 00 00 00 00	 call	 _dirnameW

; 7354 :     /* src_resolved = os.path.join(dest_parent, src) */
; 7355 :     _joinW(src_resolved, dest_parent, src);

  00050	4c 8b 84 24 80
	02 00 00	 mov	 r8, QWORD PTR src$[rsp]
  00058	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR dest_parent$[rsp]
  00060	48 8d 4c 24 20	 lea	 rcx, QWORD PTR src_resolved$[rsp]
  00065	e8 00 00 00 00	 call	 _joinW

; 7356 :     return (
; 7357 :         GetFileAttributesExA(src_resolved, GetFileExInfoStandard, &src_info)
; 7358 :         && src_info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
; 7359 :     );

  0006a	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR src_info$[rsp]
  00072	33 d2		 xor	 edx, edx
  00074	48 8d 4c 24 20	 lea	 rcx, QWORD PTR src_resolved$[rsp]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileAttributesExA
  0007f	85 c0		 test	 eax, eax
  00081	74 1b		 je	 SHORT $LN3@check_dirA
  00083	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR src_info$[rsp]
  0008a	83 e0 10	 and	 eax, 16
  0008d	85 c0		 test	 eax, eax
  0008f	74 0d		 je	 SHORT $LN3@check_dirA
  00091	c7 84 24 68 02
	00 00 01 00 00
	00		 mov	 DWORD PTR tv88[rsp], 1
  0009c	eb 0b		 jmp	 SHORT $LN4@check_dirA
$LN3@check_dirA:
  0009e	c7 84 24 68 02
	00 00 00 00 00
	00		 mov	 DWORD PTR tv88[rsp], 0
$LN4@check_dirA:
  000a9	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR tv88[rsp]

; 7360 : }

  000b0	48 81 c4 70 02
	00 00		 add	 rsp, 624		; 00000270H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
_check_dirA ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@ECPFDIAK@symlink?3?5src?5and?5dst?5must?5be?5the@ ; `string'
PUBLIC	??_C@_0BC@IIOELFMD@O?$CGO?$CG?$HMi$O?$CG?3symlink?$AA@ ; `string'
PUBLIC	??_C@_0CB@INJPGKAM@symbolic?5link?5privilege?5not?5held@ ; `string'
PUBLIC	??_C@_0CH@KMFPEGOB@CreateSymbolicLink?5functions?5not@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_symlink DD imagerel posix_symlink
	DD	imagerel posix_symlink+682
	DD	imagerel $unwind$posix_symlink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_symlink DD 021601H
	DD	0270116H
xdata	ENDS
;	COMDAT ??_C@_0CL@ECPFDIAK@symlink?3?5src?5and?5dst?5must?5be?5the@
CONST	SEGMENT
??_C@_0CL@ECPFDIAK@symlink?3?5src?5and?5dst?5must?5be?5the@ DB 'symlink: '
	DB	'src and dst must be the same type', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IIOELFMD@O?$CGO?$CG?$HMi$O?$CG?3symlink?$AA@
CONST	SEGMENT
??_C@_0BC@IIOELFMD@O?$CGO?$CG?$HMi$O?$CG?3symlink?$AA@ DB 'O&O&|i$O&:syml'
	DB	'ink', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@INJPGKAM@symbolic?5link?5privilege?5not?5held@
CONST	SEGMENT
??_C@_0CB@INJPGKAM@symbolic?5link?5privilege?5not?5held@ DB 'symbolic lin'
	DB	'k privilege not held', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@KMFPEGOB@CreateSymbolicLink?5functions?5not@
CONST	SEGMENT
??_C@_0CH@KMFPEGOB@CreateSymbolicLink?5functions?5not@ DB 'CreateSymbolic'
	DB	'Link functions not found', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_symlink
_TEXT	SEGMENT
dir_fd$ = 96
dst$ = 112
return_value$ = 192
result$ = 200
target_is_directory$ = 204
src$ = 208
_save$123561 = 288
self$ = 320
args$ = 328
kwargs$ = 336
posix_symlink PROC					; COMDAT

; 7366 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 7367 :     path_t src;
; 7368 :     path_t dst;
; 7369 :     int dir_fd = DEFAULT_DIR_FD;

  00016	c7 44 24 60 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 7370 :     int target_is_directory = 0;

  0001e	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR target_is_directory$[rsp], 0

; 7371 :     static char *keywords[] = {"src", "dst", "target_is_directory",
; 7372 :                                "dir_fd", NULL};
; 7373 :     PyObject *return_value;
; 7374 : #ifdef MS_WINDOWS
; 7375 :     DWORD result;
; 7376 : #else
; 7377 :     int result;
; 7378 : #endif
; 7379 : 
; 7380 :     memset(&src, 0, sizeof(src));

  00029	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  0002f	33 d2		 xor	 edx, edx
  00031	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR src$[rsp]
  00039	e8 00 00 00 00	 call	 memset

; 7381 :     src.argument_name = "src";

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03LOJEKLML@src?$AA@
  00045	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR src$[rsp+8], rax

; 7382 :     memset(&dst, 0, sizeof(dst));

  0004d	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00053	33 d2		 xor	 edx, edx
  00055	48 8d 4c 24 70	 lea	 rcx, QWORD PTR dst$[rsp]
  0005a	e8 00 00 00 00	 call	 memset

; 7383 :     dst.argument_name = "dst";

  0005f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03HHBLCKEM@dst?$AA@
  00066	48 89 44 24 78	 mov	 QWORD PTR dst$[rsp+8], rax

; 7384 : 
; 7385 : #ifdef MS_WINDOWS
; 7386 :     if (!check_CreateSymbolicLink()) {

  0006b	e8 00 00 00 00	 call	 check_CreateSymbolicLink
  00070	85 c0		 test	 eax, eax
  00072	75 1a		 jne	 SHORT $LN9@posix_syml

; 7387 :         PyErr_SetString(PyExc_NotImplementedError,
; 7388 :             "CreateSymbolicLink functions not found");

  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@KMFPEGOB@CreateSymbolicLink?5functions?5not@
  0007b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NotImplementedError
  00082	e8 00 00 00 00	 call	 PyErr_SetString

; 7389 :                 return NULL;

  00087	33 c0		 xor	 eax, eax
  00089	e9 14 02 00 00	 jmp	 $LN10@posix_syml
$LN9@posix_syml:

; 7390 :         }
; 7391 :     if (!win32_can_symlink) {

  0008e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR win32_can_symlink, 0
  00095	75 1a		 jne	 SHORT $LN8@posix_syml

; 7392 :         PyErr_SetString(PyExc_OSError, "symbolic link privilege not held");

  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@INJPGKAM@symbolic?5link?5privilege?5not?5held@
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  000a5	e8 00 00 00 00	 call	 PyErr_SetString

; 7393 :                 return NULL;

  000aa	33 c0		 xor	 eax, eax
  000ac	e9 f1 01 00 00	 jmp	 $LN10@posix_syml
$LN8@posix_syml:

; 7394 :         }
; 7395 : #endif
; 7396 : 
; 7397 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&O&|i$O&:symlink",
; 7398 :             keywords,
; 7399 :             path_converter, &src,
; 7400 :             path_converter, &dst,
; 7401 :             &target_is_directory,
; 7402 : #ifdef HAVE_SYMLINKAT
; 7403 :             dir_fd_converter, &dir_fd
; 7404 : #else
; 7405 :             dir_fd_unavailable, &dir_fd
; 7406 : #endif
; 7407 :             ))

  000b1	48 8d 44 24 60	 lea	 rax, QWORD PTR dir_fd$[rsp]
  000b6	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  000bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  000c2	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  000c7	48 8d 84 24 cc
	00 00 00	 lea	 rax, QWORD PTR target_is_directory$[rsp]
  000cf	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000d4	48 8d 44 24 70	 lea	 rax, QWORD PTR dst$[rsp]
  000d9	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  000e5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000ea	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR src$[rsp]
  000f2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  000fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00103	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_symlink@@9@9
  0010a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BC@IIOELFMD@O?$CGO?$CG?$HMi$O?$CG?3symlink?$AA@
  00111	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  00119	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00121	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00126	85 c0		 test	 eax, eax
  00128	75 07		 jne	 SHORT $LN7@posix_syml

; 7408 :         return NULL;

  0012a	33 c0		 xor	 eax, eax
  0012c	e9 71 01 00 00	 jmp	 $LN10@posix_syml
$LN7@posix_syml:

; 7409 : 
; 7410 :     if ((src.narrow && dst.wide) || (src.wide && dst.narrow)) {

  00131	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR src$[rsp+32], 0
  0013a	74 0b		 je	 SHORT $LN4@posix_syml
  0013c	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dst$[rsp+24], 0
  00145	75 16		 jne	 SHORT $LN5@posix_syml
$LN4@posix_syml:
  00147	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR src$[rsp+24], 0
  00150	74 2f		 je	 SHORT $LN6@posix_syml
  00152	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dst$[rsp+32], 0
  0015b	74 24		 je	 SHORT $LN6@posix_syml
$LN5@posix_syml:

; 7411 :         PyErr_SetString(PyExc_ValueError,
; 7412 :             "symlink: src and dst must be the same type");

  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@ECPFDIAK@symlink?3?5src?5and?5dst?5must?5be?5the@
  00164	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0016b	e8 00 00 00 00	 call	 PyErr_SetString

; 7413 :         return_value = NULL;

  00170	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR return_value$[rsp], 0

; 7414 :         goto exit;

  0017c	e9 02 01 00 00	 jmp	 $exit$123560
$LN6@posix_syml:

; 7415 :     }
; 7416 : 
; 7417 : #ifdef MS_WINDOWS
; 7418 : 
; 7419 :     Py_BEGIN_ALLOW_THREADS

  00181	e8 00 00 00 00	 call	 PyEval_SaveThread
  00186	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR _save$123561[rsp], rax

; 7420 :     if (dst.wide) {

  0018e	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dst$[rsp+24], 0
  00197	74 4e		 je	 SHORT $LN3@posix_syml

; 7421 :         /* if src is a directory, ensure target_is_directory==1 */
; 7422 :         target_is_directory |= _check_dirW(src.wide, dst.wide);

  00199	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR dst$[rsp+24]
  001a1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR src$[rsp+24]
  001a9	e8 00 00 00 00	 call	 _check_dirW
  001ae	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR target_is_directory$[rsp]
  001b5	0b c8		 or	 ecx, eax
  001b7	8b c1		 mov	 eax, ecx
  001b9	89 84 24 cc 00
	00 00		 mov	 DWORD PTR target_is_directory$[rsp], eax

; 7423 :         result = Py_CreateSymbolicLinkW(dst.wide, src.wide,
; 7424 :                                         target_is_directory);

  001c0	44 8b 84 24 cc
	00 00 00	 mov	 r8d, DWORD PTR target_is_directory$[rsp]
  001c8	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp+24]
  001d0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dst$[rsp+24]
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR Py_CreateSymbolicLinkW
  001de	89 84 24 c8 00
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 7425 :     }
; 7426 :     else {

  001e5	eb 4c		 jmp	 SHORT $LN2@posix_syml
$LN3@posix_syml:

; 7427 :         /* if src is a directory, ensure target_is_directory==1 */
; 7428 :         target_is_directory |= _check_dirA(src.narrow, dst.narrow);

  001e7	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR dst$[rsp+32]
  001ef	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR src$[rsp+32]
  001f7	e8 00 00 00 00	 call	 _check_dirA
  001fc	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR target_is_directory$[rsp]
  00203	0b c8		 or	 ecx, eax
  00205	8b c1		 mov	 eax, ecx
  00207	89 84 24 cc 00
	00 00		 mov	 DWORD PTR target_is_directory$[rsp], eax

; 7429 :         result = Py_CreateSymbolicLinkA(dst.narrow, src.narrow,
; 7430 :                                         target_is_directory);

  0020e	44 8b 84 24 cc
	00 00 00	 mov	 r8d, DWORD PTR target_is_directory$[rsp]
  00216	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp+32]
  0021e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dst$[rsp+32]
  00226	ff 15 00 00 00
	00		 call	 QWORD PTR Py_CreateSymbolicLinkA
  0022c	89 84 24 c8 00
	00 00		 mov	 DWORD PTR result$[rsp], eax
$LN2@posix_syml:

; 7431 :     }
; 7432 :     Py_END_ALLOW_THREADS

  00233	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR _save$123561[rsp]
  0023b	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7433 : 
; 7434 :     if (!result) {

  00240	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR result$[rsp], 0
  00248	75 1e		 jne	 SHORT $LN1@posix_syml

; 7435 :         return_value = win32_error_object("symlink", src.object);

  0024a	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR src$[rsp+56]
  00252	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07KLDEEJBK@symlink?$AA@
  00259	e8 00 00 00 00	 call	 win32_error_object
  0025e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR return_value$[rsp], rax

; 7436 :         goto exit;

  00266	eb 1b		 jmp	 SHORT $exit$123560
$LN1@posix_syml:

; 7437 :     }
; 7438 : 
; 7439 : #else
; 7440 : 
; 7441 :     Py_BEGIN_ALLOW_THREADS
; 7442 : #if HAVE_SYMLINKAT
; 7443 :     if (dir_fd != DEFAULT_DIR_FD)
; 7444 :         result = symlinkat(src.narrow, dir_fd, dst.narrow);
; 7445 :     else
; 7446 : #endif
; 7447 :         result = symlink(src.narrow, dst.narrow);
; 7448 :     Py_END_ALLOW_THREADS
; 7449 : 
; 7450 :     if (result) {
; 7451 :         return_value = path_error("symlink", &dst);
; 7452 :         goto exit;
; 7453 :     }
; 7454 : #endif
; 7455 : 
; 7456 :     return_value = Py_None;

  00268	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0026f	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR return_value$[rsp], rax

; 7457 :     Py_INCREF(Py_None);

  00277	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0027e	e8 00 00 00 00	 call	 _Py_IncRef
$exit$123560:

; 7458 :     goto exit; /* silence "unused label" warning */
; 7459 : exit:
; 7460 :     path_cleanup(&src);

  00283	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR src$[rsp]
  0028b	e8 00 00 00 00	 call	 path_cleanup

; 7461 :     path_cleanup(&dst);

  00290	48 8d 4c 24 70	 lea	 rcx, QWORD PTR dst$[rsp]
  00295	e8 00 00 00 00	 call	 path_cleanup

; 7462 :     return return_value;

  0029a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR return_value$[rsp]
$LN10@posix_syml:

; 7463 : }

  002a2	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  002a9	c3		 ret	 0
posix_symlink ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@EGDDAAGL@CreateSymbolicLinkA?$AA@	; `string'
PUBLIC	??_C@_0BE@FKKLLFLM@CreateSymbolicLinkW?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_CreateSymbolicLink DD imagerel check_CreateSymbolicLink
	DD	imagerel check_CreateSymbolicLink+146
	DD	imagerel $unwind$check_CreateSymbolicLink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_CreateSymbolicLink DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0BE@EGDDAAGL@CreateSymbolicLinkA?$AA@
CONST	SEGMENT
??_C@_0BE@EGDDAAGL@CreateSymbolicLinkA?$AA@ DB 'CreateSymbolicLinkA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@FKKLLFLM@CreateSymbolicLinkW?$AA@
CONST	SEGMENT
??_C@_0BE@FKKLLFLM@CreateSymbolicLinkW?$AA@ DB 'CreateSymbolicLinkW', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT check_CreateSymbolicLink
_TEXT	SEGMENT
hKernel32$ = 32
tv76 = 40
check_CreateSymbolicLink PROC				; COMDAT

; 7231 : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7232 :     HINSTANCE hKernel32;
; 7233 :     /* only recheck */
; 7234 :     if (Py_CreateSymbolicLinkW && Py_CreateSymbolicLinkA)

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR Py_CreateSymbolicLinkW, 0
  0000c	74 11		 je	 SHORT $LN1@check_Crea
  0000e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR Py_CreateSymbolicLinkA, 0
  00016	74 07		 je	 SHORT $LN1@check_Crea

; 7235 :         return 1;

  00018	b8 01 00 00 00	 mov	 eax, 1
  0001d	eb 6e		 jmp	 SHORT $LN2@check_Crea
$LN1@check_Crea:

; 7236 :     hKernel32 = GetModuleHandleW(L"KERNEL32");

  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@EKMDCNOB@?$AAK?$AAE?$AAR?$AAN?$AAE?$AAL?$AA3?$AA2?$AA?$AA@
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleW
  0002c	48 89 44 24 20	 mov	 QWORD PTR hKernel32$[rsp], rax

; 7237 :     *(FARPROC*)&Py_CreateSymbolicLinkW = GetProcAddress(hKernel32,
; 7238 :                                                         "CreateSymbolicLinkW");

  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@FKKLLFLM@CreateSymbolicLinkW?$AA@
  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hKernel32$[rsp]
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00043	48 89 05 00 00
	00 00		 mov	 QWORD PTR Py_CreateSymbolicLinkW, rax

; 7239 :     *(FARPROC*)&Py_CreateSymbolicLinkA = GetProcAddress(hKernel32,
; 7240 :                                                         "CreateSymbolicLinkA");

  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EGDDAAGL@CreateSymbolicLinkA?$AA@
  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hKernel32$[rsp]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  0005c	48 89 05 00 00
	00 00		 mov	 QWORD PTR Py_CreateSymbolicLinkA, rax

; 7241 :     return (Py_CreateSymbolicLinkW && Py_CreateSymbolicLinkA);

  00063	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR Py_CreateSymbolicLinkW, 0
  0006b	74 14		 je	 SHORT $LN4@check_Crea
  0006d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR Py_CreateSymbolicLinkA, 0
  00075	74 0a		 je	 SHORT $LN4@check_Crea
  00077	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  0007f	eb 08		 jmp	 SHORT $LN5@check_Crea
$LN4@check_Crea:
  00081	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN5@check_Crea:
  00089	8b 44 24 28	 mov	 eax, DWORD PTR tv76[rsp]
$LN2@check_Crea:

; 7242 : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
check_CreateSymbolicLink ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@DOCBJBDL@not?5a?5symbolic?5link?$AA@	; `string'
PUBLIC	??_C@_0P@FDDGODFM@U?$HM$O?$CG?3readlink?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$win_readlink DD imagerel win_readlink
	DD	imagerel win_readlink+499
	DD	imagerel $unwind$win_readlink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win_readlink DD 021c01H
	DD	0813011cH
xdata	ENDS
;	COMDAT ??_C@_0BE@DOCBJBDL@not?5a?5symbolic?5link?$AA@
CONST	SEGMENT
??_C@_0BE@DOCBJBDL@not?5a?5symbolic?5link?$AA@ DB 'not a symbolic link', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FDDGODFM@U?$HM$O?$CG?3readlink?$AA@
CONST	SEGMENT
??_C@_0P@FDDGODFM@U?$HM$O?$CG?3readlink?$AA@ DB 'U|$O&:readlink', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT win_readlink
_TEXT	SEGMENT
io_result$ = 64
dir_fd$ = 68
n_bytes_returned$ = 72
rdb$ = 80
print_name$ = 88
reparse_point_handle$ = 96
po$ = 104
target_buffer$ = 112
result$ = 16496
path$ = 16504
_save$123595 = 16512
_save$123600 = 16520
self$ = 16544
args$ = 16552
kwargs$ = 16560
win_readlink PROC					; COMDAT

; 7472 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	b8 98 40 00 00	 mov	 eax, 16536		; 00004098H
  00014	e8 00 00 00 00	 call	 __chkstk
  00019	48 2b e0	 sub	 rsp, rax

; 7473 :     wchar_t *path;
; 7474 :     DWORD n_bytes_returned;
; 7475 :     DWORD io_result;
; 7476 :     PyObject *po, *result;
; 7477 :         int dir_fd;
; 7478 :     HANDLE reparse_point_handle;
; 7479 : 
; 7480 :     char target_buffer[MAXIMUM_REPARSE_DATA_BUFFER_SIZE];
; 7481 :     REPARSE_DATA_BUFFER *rdb = (REPARSE_DATA_BUFFER *)target_buffer;

  0001c	48 8d 44 24 70	 lea	 rax, QWORD PTR target_buffer$[rsp]
  00021	48 89 44 24 50	 mov	 QWORD PTR rdb$[rsp], rax

; 7482 :     wchar_t *print_name;
; 7483 : 
; 7484 :     static char *keywords[] = {"path", "dir_fd", NULL};
; 7485 : 
; 7486 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "U|$O&:readlink", keywords,
; 7487 :                           &po,
; 7488 :                           dir_fd_unavailable, &dir_fd
; 7489 :                           ))

  00026	48 8d 44 24 44	 lea	 rax, QWORD PTR dir_fd$[rsp]
  0002b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00030	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  00037	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003c	48 8d 44 24 68	 lea	 rax, QWORD PTR po$[rsp]
  00041	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00046	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??win_readlink@@9@9
  0004d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@FDDGODFM@U?$HM$O?$CG?3readlink?$AA@
  00054	48 8b 94 24 b0
	40 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0005c	48 8b 8c 24 a8
	40 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00064	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00069	85 c0		 test	 eax, eax
  0006b	75 07		 jne	 SHORT $LN5@win_readli

; 7490 :         return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	e9 77 01 00 00	 jmp	 $LN6@win_readli
$LN5@win_readli:

; 7491 : 
; 7492 :     path = PyUnicode_AsUnicode(po);

  00074	48 8b 4c 24 68	 mov	 rcx, QWORD PTR po$[rsp]
  00079	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  0007e	48 89 84 24 78
	40 00 00	 mov	 QWORD PTR path$[rsp], rax

; 7493 :     if (path == NULL)

  00086	48 83 bc 24 78
	40 00 00 00	 cmp	 QWORD PTR path$[rsp], 0
  0008f	75 07		 jne	 SHORT $LN4@win_readli

; 7494 :         return NULL;

  00091	33 c0		 xor	 eax, eax
  00093	e9 53 01 00 00	 jmp	 $LN6@win_readli
$LN4@win_readli:

; 7495 : 
; 7496 :     /* First get a handle to the reparse point */
; 7497 :     Py_BEGIN_ALLOW_THREADS

  00098	e8 00 00 00 00	 call	 PyEval_SaveThread
  0009d	48 89 84 24 80
	40 00 00	 mov	 QWORD PTR _save$123595[rsp], rax

; 7498 :     reparse_point_handle = CreateFileW(
; 7499 :         path,
; 7500 :         0,
; 7501 :         0,
; 7502 :         0,
; 7503 :         OPEN_EXISTING,
; 7504 :         FILE_FLAG_OPEN_REPARSE_POINT|FILE_FLAG_BACKUP_SEMANTICS,
; 7505 :         0);

  000a5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000ae	c7 44 24 28 00
	00 20 02	 mov	 DWORD PTR [rsp+40], 35651584 ; 02200000H
  000b6	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  000be	45 33 c9	 xor	 r9d, r9d
  000c1	45 33 c0	 xor	 r8d, r8d
  000c4	33 d2		 xor	 edx, edx
  000c6	48 8b 8c 24 78
	40 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW
  000d4	48 89 44 24 60	 mov	 QWORD PTR reparse_point_handle$[rsp], rax

; 7506 :     Py_END_ALLOW_THREADS

  000d9	48 8b 8c 24 80
	40 00 00	 mov	 rcx, QWORD PTR _save$123595[rsp]
  000e1	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7507 : 
; 7508 :     if (reparse_point_handle==INVALID_HANDLE_VALUE)

  000e6	48 83 7c 24 60
	ff		 cmp	 QWORD PTR reparse_point_handle$[rsp], -1
  000ec	75 16		 jne	 SHORT $LN3@win_readli

; 7509 :         return win32_error_object("readlink", po);

  000ee	48 8b 54 24 68	 mov	 rdx, QWORD PTR po$[rsp]
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08DPKANCED@readlink?$AA@
  000fa	e8 00 00 00 00	 call	 win32_error_object
  000ff	e9 e7 00 00 00	 jmp	 $LN6@win_readli
$LN3@win_readli:

; 7510 : 
; 7511 :     Py_BEGIN_ALLOW_THREADS

  00104	e8 00 00 00 00	 call	 PyEval_SaveThread
  00109	48 89 84 24 88
	40 00 00	 mov	 QWORD PTR _save$123600[rsp], rax

; 7512 :     /* New call DeviceIoControl to read the reparse point */
; 7513 :     io_result = DeviceIoControl(
; 7514 :         reparse_point_handle,
; 7515 :         FSCTL_GET_REPARSE_POINT,
; 7516 :         0, 0, /* in buffer */
; 7517 :         target_buffer, sizeof(target_buffer),
; 7518 :         &n_bytes_returned,
; 7519 :         0 /* we're not using OVERLAPPED_IO */
; 7520 :         );

  00111	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0011a	48 8d 44 24 48	 lea	 rax, QWORD PTR n_bytes_returned$[rsp]
  0011f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00124	c7 44 24 28 00
	40 00 00	 mov	 DWORD PTR [rsp+40], 16384 ; 00004000H
  0012c	48 8d 44 24 70	 lea	 rax, QWORD PTR target_buffer$[rsp]
  00131	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00136	45 33 c9	 xor	 r9d, r9d
  00139	45 33 c0	 xor	 r8d, r8d
  0013c	ba a8 00 09 00	 mov	 edx, 589992		; 000900a8H
  00141	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reparse_point_handle$[rsp]
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeviceIoControl
  0014c	89 44 24 40	 mov	 DWORD PTR io_result$[rsp], eax

; 7521 :     CloseHandle(reparse_point_handle);

  00150	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reparse_point_handle$[rsp]
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 7522 :     Py_END_ALLOW_THREADS

  0015b	48 8b 8c 24 88
	40 00 00	 mov	 rcx, QWORD PTR _save$123600[rsp]
  00163	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7523 : 
; 7524 :     if (io_result==0)

  00168	83 7c 24 40 00	 cmp	 DWORD PTR io_result$[rsp], 0
  0016d	75 13		 jne	 SHORT $LN2@win_readli

; 7525 :         return win32_error_object("readlink", po);

  0016f	48 8b 54 24 68	 mov	 rdx, QWORD PTR po$[rsp]
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08DPKANCED@readlink?$AA@
  0017b	e8 00 00 00 00	 call	 win32_error_object
  00180	eb 69		 jmp	 SHORT $LN6@win_readli
$LN2@win_readli:

; 7526 : 
; 7527 :     if (rdb->ReparseTag != IO_REPARSE_TAG_SYMLINK)

  00182	48 8b 44 24 50	 mov	 rax, QWORD PTR rdb$[rsp]
  00187	81 38 0c 00 00
	a0		 cmp	 DWORD PTR [rax], -1610612724 ; a000000cH
  0018d	74 17		 je	 SHORT $LN1@win_readli

; 7528 :     {
; 7529 :         PyErr_SetString(PyExc_ValueError,
; 7530 :                 "not a symbolic link");

  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@DOCBJBDL@not?5a?5symbolic?5link?$AA@
  00196	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0019d	e8 00 00 00 00	 call	 PyErr_SetString

; 7531 :         return NULL;

  001a2	33 c0		 xor	 eax, eax
  001a4	eb 45		 jmp	 SHORT $LN6@win_readli
$LN1@win_readli:

; 7532 :     }
; 7533 :     print_name = rdb->SymbolicLinkReparseBuffer.PathBuffer +
; 7534 :                  rdb->SymbolicLinkReparseBuffer.PrintNameOffset;

  001a6	48 8b 44 24 50	 mov	 rax, QWORD PTR rdb$[rsp]
  001ab	0f b7 40 0c	 movzx	 eax, WORD PTR [rax+12]
  001af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rdb$[rsp]
  001b4	48 8d 44 41 14	 lea	 rax, QWORD PTR [rcx+rax*2+20]
  001b9	48 89 44 24 58	 mov	 QWORD PTR print_name$[rsp], rax

; 7535 : 
; 7536 :     result = PyUnicode_FromWideChar(print_name,
; 7537 :                     rdb->SymbolicLinkReparseBuffer.PrintNameLength/2);

  001be	48 8b 44 24 50	 mov	 rax, QWORD PTR rdb$[rsp]
  001c3	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  001c7	99		 cdq
  001c8	2b c2		 sub	 eax, edx
  001ca	d1 f8		 sar	 eax, 1
  001cc	48 98		 cdqe
  001ce	48 8b d0	 mov	 rdx, rax
  001d1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR print_name$[rsp]
  001d6	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  001db	48 89 84 24 70
	40 00 00	 mov	 QWORD PTR result$[rsp], rax

; 7538 :     return result;

  001e3	48 8b 84 24 70
	40 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN6@win_readli:

; 7539 : }

  001eb	48 81 c4 98 40
	00 00		 add	 rsp, 16536		; 00004098H
  001f2	c3		 ret	 0
win_readlink ENDP
_TEXT	ENDS
PUBLIC	__real@3e7ad7f29abcaf48
PUBLIC	__real@407ad7f29abcaf48
EXTRN	__imp_GetProcessTimes:PROC
EXTRN	__imp_GetCurrentProcess:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_times DD imagerel posix_times
	DD	imagerel posix_times+197
	DD	imagerel $unwind$posix_times
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_times DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT __real@3e7ad7f29abcaf48
CONST	SEGMENT
__real@3e7ad7f29abcaf48 DQ 03e7ad7f29abcaf48r	; 1e-007
CONST	ENDS
;	COMDAT __real@407ad7f29abcaf48
CONST	SEGMENT
__real@407ad7f29abcaf48 DQ 0407ad7f29abcaf48r	; 429.497
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_times
_TEXT	SEGMENT
exit$ = 48
kernel$ = 56
user$ = 64
create$ = 72
hProc$ = 80
tv86 = 88
self$ = 112
noargs$ = 120
posix_times PROC					; COMDAT

; 7640 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 7641 :     FILETIME create, exit, kernel, user;
; 7642 :     HANDLE hProc;
; 7643 :     hProc = GetCurrentProcess();

  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcess
  00014	48 89 44 24 50	 mov	 QWORD PTR hProc$[rsp], rax

; 7644 :     GetProcessTimes(hProc, &create, &exit, &kernel, &user);

  00019	48 8d 44 24 40	 lea	 rax, QWORD PTR user$[rsp]
  0001e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00023	4c 8d 4c 24 38	 lea	 r9, QWORD PTR kernel$[rsp]
  00028	4c 8d 44 24 30	 lea	 r8, QWORD PTR exit$[rsp]
  0002d	48 8d 54 24 48	 lea	 rdx, QWORD PTR create$[rsp]
  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hProc$[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcessTimes

; 7645 :     /* The fields of a FILETIME structure are the hi and lo part
; 7646 :        of a 64-bit value expressed in 100 nanosecond units.
; 7647 :        1e7 is one second in such units; 1e-7 the inverse.
; 7648 :        429.4967296 is 2**32 / 1e7 or 2**32 * 1e-7.
; 7649 :     */
; 7650 :     return build_times_result(
; 7651 :         (double)(user.dwHighDateTime*429.4967296 +
; 7652 :                  user.dwLowDateTime*1e-7),
; 7653 :         (double)(kernel.dwHighDateTime*429.4967296 +
; 7654 :                  kernel.dwLowDateTime*1e-7),
; 7655 :         (double)0,
; 7656 :         (double)0,
; 7657 :         (double)0);

  0003d	8b 44 24 3c	 mov	 eax, DWORD PTR kernel$[rsp+4]
  00041	66 0f ef c0	 pxor	 xmm0, xmm0
  00045	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  0004a	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@407ad7f29abcaf48
  00052	8b 44 24 38	 mov	 eax, DWORD PTR kernel$[rsp]
  00056	66 0f ef c9	 pxor	 xmm1, xmm1
  0005a	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  0005f	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@3e7ad7f29abcaf48
  00067	f2 0f 58 c1	 addsd	 xmm0, xmm1
  0006b	8b 44 24 44	 mov	 eax, DWORD PTR user$[rsp+4]
  0006f	66 0f ef c9	 pxor	 xmm1, xmm1
  00073	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  00078	f2 0f 59 0d 00
	00 00 00	 mulsd	 xmm1, QWORD PTR __real@407ad7f29abcaf48
  00080	8b 44 24 40	 mov	 eax, DWORD PTR user$[rsp]
  00084	66 0f ef d2	 pxor	 xmm2, xmm2
  00088	f2 48 0f 2a d0	 cvtsi2sd xmm2, rax
  0008d	f2 0f 59 15 00
	00 00 00	 mulsd	 xmm2, QWORD PTR __real@3e7ad7f29abcaf48
  00095	f2 0f 58 ca	 addsd	 xmm1, xmm2
  00099	f2 0f 11 4c 24
	58		 movsdx	 QWORD PTR tv86[rsp], xmm1
  0009f	66 0f 57 d2	 xorpd	 xmm2, xmm2
  000a3	f2 0f 11 54 24
	20		 movsdx	 QWORD PTR [rsp+32], xmm2
  000a9	66 0f 57 db	 xorpd	 xmm3, xmm3
  000ad	66 0f 57 d2	 xorpd	 xmm2, xmm2
  000b1	66 0f 28 c8	 movapd	 xmm1, xmm0
  000b5	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR tv86[rsp]
  000bb	e8 00 00 00 00	 call	 build_times_result

; 7658 : }

  000c0	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000c4	c3		 ret	 0
posix_times ENDP
_TEXT	ENDS
_BSS	SEGMENT
TimesResultType DB 01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$build_times_result DD imagerel build_times_result
	DD	imagerel build_times_result+351
	DD	imagerel $unwind$build_times_result
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$build_times_result DD 011c01H
	DD	0a21cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT build_times_result
_TEXT	SEGMENT
value$ = 32
o$123639 = 40
o$123644 = 48
o$123649 = 56
o$123654 = 64
o$123659 = 72
user$ = 96
system$ = 104
children_user$ = 112
children_system$ = 120
elapsed$ = 128
build_times_result PROC					; COMDAT

; 7581 : {

  00000	f2 0f 11 5c 24
	20		 movsdx	 QWORD PTR [rsp+32], xmm3
  00006	f2 0f 11 54 24
	18		 movsdx	 QWORD PTR [rsp+24], xmm2
  0000c	f2 0f 11 4c 24
	10		 movsdx	 QWORD PTR [rsp+16], xmm1
  00012	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00018	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 7582 :     PyObject *value = PyStructSequence_New(&TimesResultType);

  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TimesResultType
  00023	e8 00 00 00 00	 call	 PyStructSequence_New
  00028	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 7583 :     if (value == NULL)

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  00033	75 07		 jne	 SHORT $LN6@build_time

; 7584 :         return NULL;

  00035	33 c0		 xor	 eax, eax
  00037	e9 1e 01 00 00	 jmp	 $LN7@build_time
$LN6@build_time:

; 7585 : 
; 7586 : #define SET(i, field) \
; 7587 :     { \
; 7588 :     PyObject *o = PyFloat_FromDouble(field); \
; 7589 :     if (!o) { \
; 7590 :         Py_DECREF(value); \
; 7591 :         return NULL; \
; 7592 :     } \
; 7593 :     PyStructSequence_SET_ITEM(value, i, o); \
; 7594 :     } \
; 7595 : 
; 7596 :     SET(0, user);

  0003c	f2 0f 10 44 24
	60		 movsdx	 xmm0, QWORD PTR user$[rsp]
  00042	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00047	48 89 44 24 28	 mov	 QWORD PTR o$123639[rsp], rax
  0004c	48 83 7c 24 28
	00		 cmp	 QWORD PTR o$123639[rsp], 0
  00052	75 11		 jne	 SHORT $LN5@build_time
  00054	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  00059	e8 00 00 00 00	 call	 _Py_DecRef
  0005e	33 c0		 xor	 eax, eax
  00060	e9 f5 00 00 00	 jmp	 $LN7@build_time
$LN5@build_time:
  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  0006a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR o$123639[rsp]
  0006f	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 7597 :     SET(1, system);

  00073	f2 0f 10 44 24
	68		 movsdx	 xmm0, QWORD PTR system$[rsp]
  00079	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0007e	48 89 44 24 30	 mov	 QWORD PTR o$123644[rsp], rax
  00083	48 83 7c 24 30
	00		 cmp	 QWORD PTR o$123644[rsp], 0
  00089	75 11		 jne	 SHORT $LN4@build_time
  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  00090	e8 00 00 00 00	 call	 _Py_DecRef
  00095	33 c0		 xor	 eax, eax
  00097	e9 be 00 00 00	 jmp	 $LN7@build_time
$LN4@build_time:
  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  000a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR o$123644[rsp]
  000a6	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 7598 :     SET(2, children_user);

  000aa	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR children_user$[rsp]
  000b0	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000b5	48 89 44 24 38	 mov	 QWORD PTR o$123649[rsp], rax
  000ba	48 83 7c 24 38
	00		 cmp	 QWORD PTR o$123649[rsp], 0
  000c0	75 11		 jne	 SHORT $LN3@build_time
  000c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  000c7	e8 00 00 00 00	 call	 _Py_DecRef
  000cc	33 c0		 xor	 eax, eax
  000ce	e9 87 00 00 00	 jmp	 $LN7@build_time
$LN3@build_time:
  000d3	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  000d8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR o$123649[rsp]
  000dd	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 7599 :     SET(3, children_system);

  000e4	f2 0f 10 44 24
	78		 movsdx	 xmm0, QWORD PTR children_system$[rsp]
  000ea	e8 00 00 00 00	 call	 PyFloat_FromDouble
  000ef	48 89 44 24 40	 mov	 QWORD PTR o$123654[rsp], rax
  000f4	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$123654[rsp], 0
  000fa	75 0e		 jne	 SHORT $LN2@build_time
  000fc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  00101	e8 00 00 00 00	 call	 _Py_DecRef
  00106	33 c0		 xor	 eax, eax
  00108	eb 50		 jmp	 SHORT $LN7@build_time
$LN2@build_time:
  0010a	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  0010f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$123654[rsp]
  00114	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 7600 :     SET(4, elapsed);

  0011b	f2 0f 10 84 24
	80 00 00 00	 movsdx	 xmm0, QWORD PTR elapsed$[rsp]
  00124	e8 00 00 00 00	 call	 PyFloat_FromDouble
  00129	48 89 44 24 48	 mov	 QWORD PTR o$123659[rsp], rax
  0012e	48 83 7c 24 48
	00		 cmp	 QWORD PTR o$123659[rsp], 0
  00134	75 0e		 jne	 SHORT $LN1@build_time
  00136	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  0013b	e8 00 00 00 00	 call	 _Py_DecRef
  00140	33 c0		 xor	 eax, eax
  00142	eb 16		 jmp	 SHORT $LN7@build_time
$LN1@build_time:
  00144	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  00149	48 8b 4c 24 48	 mov	 rcx, QWORD PTR o$123659[rsp]
  0014e	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 7601 : 
; 7602 : #undef SET
; 7603 : 
; 7604 :     return value;

  00155	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
$LN7@build_time:

; 7605 : }

  0015a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0015e	c3		 ret	 0
build_times_result ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@KFNAMMGB@O?$CGi?$HMi$O?$CG?3open?$AA@	; `string'
EXTRN	__imp_open:PROC
EXTRN	__imp__wopen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_open DD imagerel posix_open
	DD	imagerel posix_open+371
	DD	imagerel $unwind$posix_open
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_open DD 021601H
	DD	01b0116H
xdata	ENDS
;	COMDAT ??_C@_0O@KFNAMMGB@O?$CGi?$HMi$O?$CG?3open?$AA@
CONST	SEGMENT
??_C@_0O@KFNAMMGB@O?$CGi?$HMi$O?$CG?3open?$AA@ DB 'O&i|i$O&:open', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_open
_TEXT	SEGMENT
dir_fd$ = 80
flags$ = 84
mode$ = 88
return_value$ = 96
path$ = 112
fd$ = 192
_save$123704 = 200
self$ = 224
args$ = 232
kwargs$ = 240
posix_open PROC						; COMDAT

; 7790 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 7791 :     path_t path;
; 7792 :     int flags;
; 7793 :     int mode = 0777;

  00016	c7 44 24 58 ff
	01 00 00	 mov	 DWORD PTR mode$[rsp], 511 ; 000001ffH

; 7794 :     int dir_fd = DEFAULT_DIR_FD;

  0001e	c7 44 24 50 9c
	ff ff ff	 mov	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH

; 7795 :     int fd;
; 7796 :     PyObject *return_value = NULL;

  00026	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR return_value$[rsp], 0

; 7797 :     static char *keywords[] = {"path", "flags", "mode", "dir_fd", NULL};
; 7798 : 
; 7799 :     memset(&path, 0, sizeof(path));

  0002f	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00035	33 d2		 xor	 edx, edx
  00037	48 8d 4c 24 70	 lea	 rcx, QWORD PTR path$[rsp]
  0003c	e8 00 00 00 00	 call	 memset

; 7800 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&i|i$O&:open", keywords,
; 7801 :         path_converter, &path,
; 7802 :         &flags, &mode,
; 7803 : #ifdef HAVE_OPENAT
; 7804 :         dir_fd_converter, &dir_fd
; 7805 : #else
; 7806 :         dir_fd_unavailable, &dir_fd
; 7807 : #endif
; 7808 :         ))

  00041	48 8d 44 24 50	 lea	 rax, QWORD PTR dir_fd$[rsp]
  00046	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dir_fd_unavailable
  00052	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00057	48 8d 44 24 58	 lea	 rax, QWORD PTR mode$[rsp]
  0005c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00061	48 8d 44 24 54	 lea	 rax, QWORD PTR flags$[rsp]
  00066	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0006b	48 8d 44 24 70	 lea	 rax, QWORD PTR path$[rsp]
  00070	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00075	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:path_converter
  0007c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00081	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??posix_open@@9@9
  00088	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@KFNAMMGB@O?$CGi?$HMi$O?$CG?3open?$AA@
  0008f	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  00097	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0009f	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000a4	85 c0		 test	 eax, eax
  000a6	75 07		 jne	 SHORT $LN6@posix_open

; 7809 :         return NULL;

  000a8	33 c0		 xor	 eax, eax
  000aa	e9 bc 00 00 00	 jmp	 $LN7@posix_open
$LN6@posix_open:

; 7810 : 
; 7811 :     Py_BEGIN_ALLOW_THREADS

  000af	e8 00 00 00 00	 call	 PyEval_SaveThread
  000b4	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR _save$123704[rsp], rax

; 7812 : #ifdef MS_WINDOWS
; 7813 :     if (path.wide)

  000bc	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR path$[rsp+24], 0
  000c5	74 20		 je	 SHORT $LN5@posix_open

; 7814 :         fd = _wopen(path.wide, flags, mode);

  000c7	44 8b 44 24 58	 mov	 r8d, DWORD PTR mode$[rsp]
  000cc	8b 54 24 54	 mov	 edx, DWORD PTR flags$[rsp]
  000d0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+24]
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wopen
  000de	89 84 24 c0 00
	00 00		 mov	 DWORD PTR fd$[rsp], eax

; 7815 :     else

  000e5	eb 1e		 jmp	 SHORT $LN4@posix_open
$LN5@posix_open:

; 7816 : #endif
; 7817 : #ifdef HAVE_OPENAT
; 7818 :     if (dir_fd != DEFAULT_DIR_FD)
; 7819 :         fd = openat(dir_fd, path.narrow, flags, mode);
; 7820 :     else
; 7821 : #endif
; 7822 :         fd = open(path.narrow, flags, mode);

  000e7	44 8b 44 24 58	 mov	 r8d, DWORD PTR mode$[rsp]
  000ec	8b 54 24 54	 mov	 edx, DWORD PTR flags$[rsp]
  000f0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR path$[rsp+32]
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open
  000fe	89 84 24 c0 00
	00 00		 mov	 DWORD PTR fd$[rsp], eax
$LN4@posix_open:

; 7823 :     Py_END_ALLOW_THREADS

  00105	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR _save$123704[rsp]
  0010d	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7824 : 
; 7825 :     if (fd == -1) {

  00112	83 bc 24 c0 00
	00 00 ff	 cmp	 DWORD PTR fd$[rsp], -1
  0011a	75 2f		 jne	 SHORT $LN3@posix_open

; 7826 : #ifdef MS_WINDOWS
; 7827 :         /* force use of posix_error here for exact backwards compatibility */
; 7828 :         if (path.wide)

  0011c	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR path$[rsp+24], 0
  00125	74 0c		 je	 SHORT $LN2@posix_open

; 7829 :             return_value = posix_error();

  00127	e8 00 00 00 00	 call	 posix_error
  0012c	48 89 44 24 60	 mov	 QWORD PTR return_value$[rsp], rax

; 7830 :         else

  00131	eb 16		 jmp	 SHORT $LN1@posix_open
$LN2@posix_open:

; 7831 : #endif
; 7832 :         return_value = path_error("open", &path);

  00133	48 8d 54 24 70	 lea	 rdx, QWORD PTR path$[rsp]
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04PMOCAHAA@open?$AA@
  0013f	e8 00 00 00 00	 call	 path_error
  00144	48 89 44 24 60	 mov	 QWORD PTR return_value$[rsp], rax
$LN1@posix_open:

; 7833 :         goto exit;

  00149	eb 11		 jmp	 SHORT $exit$123711
$LN3@posix_open:

; 7834 :     }
; 7835 : 
; 7836 :     return_value = PyLong_FromLong((long)fd);

  0014b	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00152	e8 00 00 00 00	 call	 PyLong_FromLong
  00157	48 89 44 24 60	 mov	 QWORD PTR return_value$[rsp], rax
$exit$123711:

; 7837 : 
; 7838 : exit:
; 7839 :     path_cleanup(&path);

  0015c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR path$[rsp]
  00161	e8 00 00 00 00	 call	 path_cleanup

; 7840 :     return return_value;

  00166	48 8b 44 24 60	 mov	 rax, QWORD PTR return_value$[rsp]
$LN7@posix_open:

; 7841 : }

  0016b	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00172	c3		 ret	 0
posix_open ENDP
_TEXT	ENDS
PUBLIC	??_C@_07KGLACIBM@i?3close?$AA@			; `string'
EXTRN	__imp_close:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_close_ DD imagerel posix_close_
	DD	imagerel posix_close_+136
	DD	imagerel $unwind$posix_close_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_close_ DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_07KGLACIBM@i?3close?$AA@
CONST	SEGMENT
??_C@_07KGLACIBM@i?3close?$AA@ DB 'i:close', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_close_
_TEXT	SEGMENT
res$ = 32
fd$ = 36
_save$123726 = 40
self$ = 64
args$ = 72
posix_close_ PROC					; COMDAT

; 7853 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7854 :     int fd, res;
; 7855 :     if (!PyArg_ParseTuple(args, "i:close", &fd))

  0000e	4c 8d 44 24 24	 lea	 r8, QWORD PTR fd$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KGLACIBM@i?3close?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN3@posix_clos

; 7856 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 57		 jmp	 SHORT $LN4@posix_clos
$LN3@posix_clos:

; 7857 :     if (!_PyVerify_fd(fd))

  0002c	8b 4c 24 24	 mov	 ecx, DWORD PTR fd$[rsp]
  00030	e8 00 00 00 00	 call	 _PyVerify_fd
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN2@posix_clos

; 7858 :         return posix_error();

  00039	e8 00 00 00 00	 call	 posix_error
  0003e	eb 43		 jmp	 SHORT $LN4@posix_clos
$LN2@posix_clos:

; 7859 :     Py_BEGIN_ALLOW_THREADS

  00040	e8 00 00 00 00	 call	 PyEval_SaveThread
  00045	48 89 44 24 28	 mov	 QWORD PTR _save$123726[rsp], rax

; 7860 :     res = close(fd);

  0004a	8b 4c 24 24	 mov	 ecx, DWORD PTR fd$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  00054	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 7861 :     Py_END_ALLOW_THREADS

  00058	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _save$123726[rsp]
  0005d	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7862 :     if (res < 0)

  00062	83 7c 24 20 00	 cmp	 DWORD PTR res$[rsp], 0
  00067	7d 07		 jge	 SHORT $LN1@posix_clos

; 7863 :         return posix_error();

  00069	e8 00 00 00 00	 call	 posix_error
  0006e	eb 13		 jmp	 SHORT $LN4@posix_clos
$LN1@posix_clos:

; 7864 :     Py_INCREF(Py_None);

  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00077	e8 00 00 00 00	 call	 _Py_IncRef

; 7865 :     return Py_None;

  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@posix_clos:

; 7866 : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
posix_close_ ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@GNICGHEB@ii?3closerange?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_closerange DD imagerel posix_closerange
	DD	imagerel posix_closerange+148
	DD	imagerel $unwind$posix_closerange
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_closerange DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0O@GNICGHEB@ii?3closerange?$AA@
CONST	SEGMENT
??_C@_0O@GNICGHEB@ii?3closerange?$AA@ DB 'ii:closerange', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_closerange
_TEXT	SEGMENT
i$ = 32
fd_to$ = 36
fd_from$ = 40
_save$123742 = 48
self$ = 80
args$ = 88
posix_closerange PROC					; COMDAT

; 7875 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 7876 :     int fd_from, fd_to, i;
; 7877 :     if (!PyArg_ParseTuple(args, "ii:closerange", &fd_from, &fd_to))

  0000e	4c 8d 4c 24 24	 lea	 r9, QWORD PTR fd_to$[rsp]
  00013	4c 8d 44 24 28	 lea	 r8, QWORD PTR fd_from$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@GNICGHEB@ii?3closerange?$AA@
  0001f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN5@posix_clos@2

; 7878 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 5e		 jmp	 SHORT $LN6@posix_clos@2
$LN5@posix_clos@2:

; 7879 :     Py_BEGIN_ALLOW_THREADS

  00031	e8 00 00 00 00	 call	 PyEval_SaveThread
  00036	48 89 44 24 30	 mov	 QWORD PTR _save$123742[rsp], rax

; 7880 :     for (i = fd_from; i < fd_to; i++)

  0003b	8b 44 24 28	 mov	 eax, DWORD PTR fd_from$[rsp]
  0003f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00043	eb 0a		 jmp	 SHORT $LN4@posix_clos@2
$LN3@posix_clos@2:
  00045	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00049	ff c0		 inc	 eax
  0004b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@posix_clos@2:
  0004f	8b 44 24 24	 mov	 eax, DWORD PTR fd_to$[rsp]
  00053	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00057	7d 19		 jge	 SHORT $LN2@posix_clos@2

; 7881 :         if (_PyVerify_fd(i))

  00059	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0005d	e8 00 00 00 00	 call	 _PyVerify_fd
  00062	85 c0		 test	 eax, eax
  00064	74 0a		 je	 SHORT $LN1@posix_clos@2

; 7882 :             close(i);

  00066	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
$LN1@posix_clos@2:

; 7883 :     Py_END_ALLOW_THREADS

  00070	eb d3		 jmp	 SHORT $LN3@posix_clos@2
$LN2@posix_clos@2:
  00072	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _save$123742[rsp]
  00077	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7884 :     Py_RETURN_NONE;

  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00083	e8 00 00 00 00	 call	 _Py_IncRef
  00088	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN6@posix_clos@2:

; 7885 : }

  0008f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00093	c3		 ret	 0
posix_closerange ENDP
_TEXT	ENDS
PUBLIC	??_C@_05EDBGBDPA@i?3dup?$AA@			; `string'
EXTRN	__imp_dup:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_dup DD imagerel posix_dup
	DD	imagerel posix_dup+106
	DD	imagerel $unwind$posix_dup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_dup DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_05EDBGBDPA@i?3dup?$AA@
CONST	SEGMENT
??_C@_05EDBGBDPA@i?3dup?$AA@ DB 'i:dup', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_dup
_TEXT	SEGMENT
fd$ = 32
self$ = 64
args$ = 72
posix_dup PROC						; COMDAT

; 7894 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7895 :     int fd;
; 7896 :     if (!PyArg_ParseTuple(args, "i:dup", &fd))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR fd$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05EDBGBDPA@i?3dup?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN3@posix_dup

; 7897 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 39		 jmp	 SHORT $LN4@posix_dup
$LN3@posix_dup:

; 7898 :     if (!_PyVerify_fd(fd))

  0002c	8b 4c 24 20	 mov	 ecx, DWORD PTR fd$[rsp]
  00030	e8 00 00 00 00	 call	 _PyVerify_fd
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN2@posix_dup

; 7899 :         return posix_error();

  00039	e8 00 00 00 00	 call	 posix_error
  0003e	eb 25		 jmp	 SHORT $LN4@posix_dup
$LN2@posix_dup:

; 7900 :     fd = dup(fd);

  00040	8b 4c 24 20	 mov	 ecx, DWORD PTR fd$[rsp]
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup
  0004a	89 44 24 20	 mov	 DWORD PTR fd$[rsp], eax

; 7901 :     if (fd < 0)

  0004e	83 7c 24 20 00	 cmp	 DWORD PTR fd$[rsp], 0
  00053	7d 07		 jge	 SHORT $LN1@posix_dup

; 7902 :         return posix_error();

  00055	e8 00 00 00 00	 call	 posix_error
  0005a	eb 09		 jmp	 SHORT $LN4@posix_dup
$LN1@posix_dup:

; 7903 :     return PyLong_FromLong((long)fd);

  0005c	8b 4c 24 20	 mov	 ecx, DWORD PTR fd$[rsp]
  00060	e8 00 00 00 00	 call	 PyLong_FromLong
$LN4@posix_dup:

; 7904 : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
posix_dup ENDP
_TEXT	ENDS
PUBLIC	??_C@_07GHGEALPJ@ii?3dup2?$AA@			; `string'
EXTRN	__imp_dup2:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_dup2 DD imagerel posix_dup2
	DD	imagerel posix_dup2+129
	DD	imagerel $unwind$posix_dup2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_dup2 DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_07GHGEALPJ@ii?3dup2?$AA@
CONST	SEGMENT
??_C@_07GHGEALPJ@ii?3dup2?$AA@ DB 'ii:dup2', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_dup2
_TEXT	SEGMENT
res$ = 32
fd2$ = 36
fd$ = 40
self$ = 64
args$ = 72
posix_dup2 PROC						; COMDAT

; 7913 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7914 :     int fd, fd2, res;
; 7915 :     if (!PyArg_ParseTuple(args, "ii:dup2", &fd, &fd2))

  0000e	4c 8d 4c 24 24	 lea	 r9, QWORD PTR fd2$[rsp]
  00013	4c 8d 44 24 28	 lea	 r8, QWORD PTR fd$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07GHGEALPJ@ii?3dup2?$AA@
  0001f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN3@posix_dup2

; 7916 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 4b		 jmp	 SHORT $LN4@posix_dup2
$LN3@posix_dup2:

; 7917 :     if (!_PyVerify_fd_dup2(fd, fd2))

  00031	8b 54 24 24	 mov	 edx, DWORD PTR fd2$[rsp]
  00035	8b 4c 24 28	 mov	 ecx, DWORD PTR fd$[rsp]
  00039	e8 00 00 00 00	 call	 _PyVerify_fd_dup2
  0003e	85 c0		 test	 eax, eax
  00040	75 07		 jne	 SHORT $LN2@posix_dup2

; 7918 :         return posix_error();

  00042	e8 00 00 00 00	 call	 posix_error
  00047	eb 33		 jmp	 SHORT $LN4@posix_dup2
$LN2@posix_dup2:

; 7919 :     res = dup2(fd, fd2);

  00049	8b 54 24 24	 mov	 edx, DWORD PTR fd2$[rsp]
  0004d	8b 4c 24 28	 mov	 ecx, DWORD PTR fd$[rsp]
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup2
  00057	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 7920 :     if (res < 0)

  0005b	83 7c 24 20 00	 cmp	 DWORD PTR res$[rsp], 0
  00060	7d 07		 jge	 SHORT $LN1@posix_dup2

; 7921 :         return posix_error();

  00062	e8 00 00 00 00	 call	 posix_error
  00067	eb 13		 jmp	 SHORT $LN4@posix_dup2
$LN1@posix_dup2:

; 7922 :     Py_INCREF(Py_None);

  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00070	e8 00 00 00 00	 call	 _Py_IncRef

; 7923 :     return Py_None;

  00075	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN4@posix_dup2:

; 7924 : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
posix_dup2 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyVerify_fd_dup2 DD imagerel _PyVerify_fd_dup2
	DD	imagerel _PyVerify_fd_dup2+70
	DD	imagerel $unwind$_PyVerify_fd_dup2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyVerify_fd_dup2 DD 010c01H
	DD	0420cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyVerify_fd_dup2
_TEXT	SEGMENT
fd1$ = 48
fd2$ = 56
_PyVerify_fd_dup2 PROC					; COMDAT

; 1010 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1011 :     if (!_PyVerify_fd(fd1))

  0000c	8b 4c 24 30	 mov	 ecx, DWORD PTR fd1$[rsp]
  00010	e8 00 00 00 00	 call	 _PyVerify_fd
  00015	85 c0		 test	 eax, eax
  00017	75 04		 jne	 SHORT $LN4@PyVerify_f@2

; 1012 :         return 0;

  00019	33 c0		 xor	 eax, eax
  0001b	eb 24		 jmp	 SHORT $LN5@PyVerify_f@2
$LN4@PyVerify_f@2:

; 1013 :     if (fd2 == _NO_CONSOLE_FILENO)

  0001d	48 63 44 24 38	 movsxd	 rax, DWORD PTR fd2$[rsp]
  00022	48 83 f8 fe	 cmp	 rax, -2
  00026	75 04		 jne	 SHORT $LN3@PyVerify_f@2

; 1014 :         return 0;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 15		 jmp	 SHORT $LN5@PyVerify_f@2
$LN3@PyVerify_f@2:

; 1015 :     if ((unsigned)fd2 < _NHANDLE_)

  0002c	81 7c 24 38 00
	08 00 00	 cmp	 DWORD PTR fd2$[rsp], 2048 ; 00000800H
  00034	73 09		 jae	 SHORT $LN2@PyVerify_f@2

; 1016 :         return 1;

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	eb 04		 jmp	 SHORT $LN5@PyVerify_f@2

; 1017 :     else

  0003d	eb 02		 jmp	 SHORT $LN1@PyVerify_f@2
$LN2@PyVerify_f@2:

; 1018 :         return 0;

  0003f	33 c0		 xor	 eax, eax
$LN1@PyVerify_f@2:
$LN5@PyVerify_f@2:

; 1019 : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
_PyVerify_fd_dup2 ENDP
_TEXT	ENDS
PUBLIC	??_C@_09PGLCNMMB@iOi?3lseek?$AA@		; `string'
EXTRN	__imp__lseeki64:PROC
EXTRN	PyLong_AsLongLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_lseek DD imagerel posix_lseek
	DD	imagerel posix_lseek+248
	DD	imagerel $unwind$posix_lseek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_lseek DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_09PGLCNMMB@iOi?3lseek?$AA@
CONST	SEGMENT
??_C@_09PGLCNMMB@iOi?3lseek?$AA@ DB 'iOi:lseek', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_lseek
_TEXT	SEGMENT
posobj$ = 48
res$ = 56
how$ = 64
pos$ = 72
fd$ = 80
_save$123803 = 88
tv71 = 96
self$ = 128
args$ = 136
posix_lseek PROC					; COMDAT

; 7963 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 7964 :     int fd, how;
; 7965 : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 7966 :     PY_LONG_LONG pos, res;
; 7967 : #else
; 7968 :     off_t pos, res;
; 7969 : #endif
; 7970 :     PyObject *posobj;
; 7971 :     if (!PyArg_ParseTuple(args, "iOi:lseek", &fd, &posobj, &how))

  0000e	48 8d 44 24 40	 lea	 rax, QWORD PTR how$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00018	4c 8d 4c 24 30	 lea	 r9, QWORD PTR posobj$[rsp]
  0001d	4c 8d 44 24 50	 lea	 r8, QWORD PTR fd$[rsp]
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09PGLCNMMB@iOi?3lseek?$AA@
  00029	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00031	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00036	85 c0		 test	 eax, eax
  00038	75 07		 jne	 SHORT $LN9@posix_lsee

; 7972 :         return NULL;

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 b2 00 00 00	 jmp	 $LN10@posix_lsee
$LN9@posix_lsee:

; 7973 : #ifdef SEEK_SET
; 7974 :     /* Turn 0, 1, 2 into SEEK_{SET,CUR,END} */
; 7975 :     switch (how) {

  00041	8b 44 24 40	 mov	 eax, DWORD PTR how$[rsp]
  00045	89 44 24 60	 mov	 DWORD PTR tv71[rsp], eax
  00049	83 7c 24 60 00	 cmp	 DWORD PTR tv71[rsp], 0
  0004e	74 10		 je	 SHORT $LN6@posix_lsee
  00050	83 7c 24 60 01	 cmp	 DWORD PTR tv71[rsp], 1
  00055	74 13		 je	 SHORT $LN5@posix_lsee
  00057	83 7c 24 60 02	 cmp	 DWORD PTR tv71[rsp], 2
  0005c	74 16		 je	 SHORT $LN4@posix_lsee
  0005e	eb 1c		 jmp	 SHORT $LN7@posix_lsee
$LN6@posix_lsee:

; 7976 :     case 0: how = SEEK_SET; break;

  00060	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR how$[rsp], 0
  00068	eb 12		 jmp	 SHORT $LN7@posix_lsee
$LN5@posix_lsee:

; 7977 :     case 1: how = SEEK_CUR; break;

  0006a	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR how$[rsp], 1
  00072	eb 08		 jmp	 SHORT $LN7@posix_lsee
$LN4@posix_lsee:

; 7978 :     case 2: how = SEEK_END; break;

  00074	c7 44 24 40 02
	00 00 00	 mov	 DWORD PTR how$[rsp], 2
$LN7@posix_lsee:

; 7979 :     }
; 7980 : #endif /* SEEK_END */
; 7981 : 
; 7982 : #if !defined(HAVE_LARGEFILE_SUPPORT)
; 7983 :     pos = PyLong_AsLong(posobj);
; 7984 : #else
; 7985 :     pos = PyLong_AsLongLong(posobj);

  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR posobj$[rsp]
  00081	e8 00 00 00 00	 call	 PyLong_AsLongLong
  00086	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 7986 : #endif
; 7987 :     if (PyErr_Occurred())

  0008b	e8 00 00 00 00	 call	 PyErr_Occurred
  00090	48 85 c0	 test	 rax, rax
  00093	74 04		 je	 SHORT $LN3@posix_lsee

; 7988 :         return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	eb 5a		 jmp	 SHORT $LN10@posix_lsee
$LN3@posix_lsee:

; 7989 : 
; 7990 :     if (!_PyVerify_fd(fd))

  00099	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0009d	e8 00 00 00 00	 call	 _PyVerify_fd
  000a2	85 c0		 test	 eax, eax
  000a4	75 07		 jne	 SHORT $LN2@posix_lsee

; 7991 :         return posix_error();

  000a6	e8 00 00 00 00	 call	 posix_error
  000ab	eb 46		 jmp	 SHORT $LN10@posix_lsee
$LN2@posix_lsee:

; 7992 :     Py_BEGIN_ALLOW_THREADS

  000ad	e8 00 00 00 00	 call	 PyEval_SaveThread
  000b2	48 89 44 24 58	 mov	 QWORD PTR _save$123803[rsp], rax

; 7993 : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 7994 :     res = _lseeki64(fd, pos, how);

  000b7	44 8b 44 24 40	 mov	 r8d, DWORD PTR how$[rsp]
  000bc	48 8b 54 24 48	 mov	 rdx, QWORD PTR pos$[rsp]
  000c1	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  000cb	48 89 44 24 38	 mov	 QWORD PTR res$[rsp], rax

; 7995 : #else
; 7996 :     res = lseek(fd, pos, how);
; 7997 : #endif
; 7998 :     Py_END_ALLOW_THREADS

  000d0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _save$123803[rsp]
  000d5	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 7999 :     if (res < 0)

  000da	48 83 7c 24 38
	00		 cmp	 QWORD PTR res$[rsp], 0
  000e0	7d 07		 jge	 SHORT $LN1@posix_lsee

; 8000 :         return posix_error();

  000e2	e8 00 00 00 00	 call	 posix_error
  000e7	eb 0a		 jmp	 SHORT $LN10@posix_lsee
$LN1@posix_lsee:

; 8001 : 
; 8002 : #if !defined(HAVE_LARGEFILE_SUPPORT)
; 8003 :     return PyLong_FromLong(res);
; 8004 : #else
; 8005 :     return PyLong_FromLongLong(res);

  000e9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR res$[rsp]
  000ee	e8 00 00 00 00	 call	 PyLong_FromLongLong
$LN10@posix_lsee:

; 8006 : #endif
; 8007 : }

  000f3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000f7	c3		 ret	 0
posix_lseek ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@MPAPDIPK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_07CJNIANNB@ii?3read?$AA@			; `string'
EXTRN	_PyBytes_Resize:PROC
EXTRN	__imp_read:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_read DD imagerel posix_read
	DD	imagerel posix_read+317
	DD	imagerel $unwind$posix_read
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_read DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_1CM@MPAPDIPK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@MPAPDIPK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'b', 00H, 'u', 00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07CJNIANNB@ii?3read?$AA@
CONST	SEGMENT
??_C@_07CJNIANNB@ii?3read?$AA@ DB 'ii:read', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_read
_TEXT	SEGMENT
n$ = 32
size$ = 40
buffer$ = 48
fd$ = 56
_save$123827 = 64
self$ = 96
args$ = 104
posix_read PROC						; COMDAT

; 8016 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 8017 :     int fd, size;
; 8018 :     Py_ssize_t n;
; 8019 :     PyObject *buffer;
; 8020 :     if (!PyArg_ParseTuple(args, "ii:read", &fd, &size))

  0000e	4c 8d 4c 24 28	 lea	 r9, QWORD PTR size$[rsp]
  00013	4c 8d 44 24 38	 lea	 r8, QWORD PTR fd$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07CJNIANNB@ii?3read?$AA@
  0001f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN6@posix_read

; 8021 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 04 01 00 00	 jmp	 $LN7@posix_read
$LN6@posix_read:

; 8022 :     if (size < 0) {

  00034	83 7c 24 28 00	 cmp	 DWORD PTR size$[rsp], 0
  00039	7d 16		 jge	 SHORT $LN5@posix_read

; 8023 :         errno = EINVAL;

  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00041	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 8024 :         return posix_error();

  00047	e8 00 00 00 00	 call	 posix_error
  0004c	e9 e7 00 00 00	 jmp	 $LN7@posix_read
$LN5@posix_read:

; 8025 :     }
; 8026 :     buffer = PyBytes_FromStringAndSize((char *)NULL, size);

  00051	48 63 44 24 28	 movsxd	 rax, DWORD PTR size$[rsp]
  00056	48 8b d0	 mov	 rdx, rax
  00059	33 c9		 xor	 ecx, ecx
  0005b	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00060	48 89 44 24 30	 mov	 QWORD PTR buffer$[rsp], rax

; 8027 :     if (buffer == NULL)

  00065	48 83 7c 24 30
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  0006b	75 07		 jne	 SHORT $LN4@posix_read

; 8028 :         return NULL;

  0006d	33 c0		 xor	 eax, eax
  0006f	e9 c4 00 00 00	 jmp	 $LN7@posix_read
$LN4@posix_read:

; 8029 :     if (!_PyVerify_fd(fd)) {

  00074	8b 4c 24 38	 mov	 ecx, DWORD PTR fd$[rsp]
  00078	e8 00 00 00 00	 call	 _PyVerify_fd
  0007d	85 c0		 test	 eax, eax
  0007f	75 14		 jne	 SHORT $LN3@posix_read

; 8030 :         Py_DECREF(buffer);

  00081	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buffer$[rsp]
  00086	e8 00 00 00 00	 call	 _Py_DecRef

; 8031 :         return posix_error();

  0008b	e8 00 00 00 00	 call	 posix_error
  00090	e9 a3 00 00 00	 jmp	 $LN7@posix_read
$LN3@posix_read:

; 8032 :     }
; 8033 :     Py_BEGIN_ALLOW_THREADS

  00095	e8 00 00 00 00	 call	 PyEval_SaveThread
  0009a	48 89 44 24 40	 mov	 QWORD PTR _save$123827[rsp], rax

; 8034 :     n = read(fd, PyBytes_AS_STRING(buffer), size);

  0009f	48 8b 44 24 30	 mov	 rax, QWORD PTR buffer$[rsp]
  000a4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000ae	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000b3	85 c0		 test	 eax, eax
  000b5	75 1c		 jne	 SHORT $LN9@posix_read
  000b7	41 b8 62 1f 00
	00		 mov	 r8d, 8034		; 00001f62H
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@MPAPDIPK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAb?$AAu?$AAf?$AAf?$AAe?$AAr?$AA?$CJ?$AA?$AA@
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d1	33 c0		 xor	 eax, eax
$LN9@posix_read:
  000d3	48 8b 44 24 30	 mov	 rax, QWORD PTR buffer$[rsp]
  000d8	48 83 c0 78	 add	 rax, 120		; 00000078H
  000dc	44 8b 44 24 28	 mov	 r8d, DWORD PTR size$[rsp]
  000e1	48 8b d0	 mov	 rdx, rax
  000e4	8b 4c 24 38	 mov	 ecx, DWORD PTR fd$[rsp]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  000ee	48 98		 cdqe
  000f0	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 8035 :     Py_END_ALLOW_THREADS

  000f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _save$123827[rsp]
  000fa	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 8036 :     if (n < 0) {

  000ff	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  00105	7d 11		 jge	 SHORT $LN2@posix_read

; 8037 :         Py_DECREF(buffer);

  00107	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buffer$[rsp]
  0010c	e8 00 00 00 00	 call	 _Py_DecRef

; 8038 :         return posix_error();

  00111	e8 00 00 00 00	 call	 posix_error
  00116	eb 20		 jmp	 SHORT $LN7@posix_read
$LN2@posix_read:

; 8039 :     }
; 8040 :     if (n != size)

  00118	48 63 44 24 28	 movsxd	 rax, DWORD PTR size$[rsp]
  0011d	48 39 44 24 20	 cmp	 QWORD PTR n$[rsp], rax
  00122	74 0f		 je	 SHORT $LN1@posix_read

; 8041 :         _PyBytes_Resize(&buffer, n);

  00124	48 8b 54 24 20	 mov	 rdx, QWORD PTR n$[rsp]
  00129	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buffer$[rsp]
  0012e	e8 00 00 00 00	 call	 _PyBytes_Resize
$LN1@posix_read:

; 8042 :     return buffer;

  00133	48 8b 44 24 30	 mov	 rax, QWORD PTR buffer$[rsp]
$LN7@posix_read:

; 8043 : }

  00138	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013c	c3		 ret	 0
posix_read ENDP
_TEXT	ENDS
PUBLIC	??_C@_09JBELCAAO@iy?$CK?3write?$AA@		; `string'
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	__imp_write:PROC
EXTRN	PyBuffer_Release:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_write DD imagerel posix_write
	DD	imagerel posix_write+223
	DD	imagerel $unwind$posix_write
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_write DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_09JBELCAAO@iy?$CK?3write?$AA@
CONST	SEGMENT
??_C@_09JBELCAAO@iy?$CK?3write?$AA@ DB 'iy*:write', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_write
_TEXT	SEGMENT
pbuf$ = 32
len$ = 112
size$ = 120
fd$ = 128
_save$123850 = 136
self$ = 160
args$ = 168
posix_write PROC					; COMDAT

; 8192 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 8193 :     Py_buffer pbuf;
; 8194 :     int fd;
; 8195 :     Py_ssize_t size, len;
; 8196 : 
; 8197 :     if (!PyArg_ParseTuple(args, "iy*:write", &fd, &pbuf))

  00011	4c 8d 4c 24 20	 lea	 r9, QWORD PTR pbuf$[rsp]
  00016	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR fd$[rsp]
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09JBELCAAO@iy?$CK?3write?$AA@
  00025	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0002d	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN4@posix_writ

; 8198 :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 9a 00 00 00	 jmp	 $LN5@posix_writ
$LN4@posix_writ:

; 8199 :     if (!_PyVerify_fd(fd)) {

  0003d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00044	e8 00 00 00 00	 call	 _PyVerify_fd
  00049	85 c0		 test	 eax, eax
  0004b	75 11		 jne	 SHORT $LN3@posix_writ

; 8200 :         PyBuffer_Release(&pbuf);

  0004d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbuf$[rsp]
  00052	e8 00 00 00 00	 call	 PyBuffer_Release

; 8201 :         return posix_error();

  00057	e8 00 00 00 00	 call	 posix_error
  0005c	eb 79		 jmp	 SHORT $LN5@posix_writ
$LN3@posix_writ:

; 8202 :     }
; 8203 :     len = pbuf.len;

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp+16]
  00063	48 89 44 24 70	 mov	 QWORD PTR len$[rsp], rax

; 8204 :     Py_BEGIN_ALLOW_THREADS

  00068	e8 00 00 00 00	 call	 PyEval_SaveThread
  0006d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR _save$123850[rsp], rax

; 8205 : #if defined(MS_WIN64) || defined(MS_WINDOWS)
; 8206 :     if (len > INT_MAX)

  00075	48 81 7c 24 70
	ff ff ff 7f	 cmp	 QWORD PTR len$[rsp], 2147483647 ; 7fffffffH
  0007e	7e 09		 jle	 SHORT $LN2@posix_writ

; 8207 :         len = INT_MAX;

  00080	48 c7 44 24 70
	ff ff ff 7f	 mov	 QWORD PTR len$[rsp], 2147483647 ; 7fffffffH
$LN2@posix_writ:

; 8208 :     size = write(fd, pbuf.buf, (int)len);

  00089	44 8b 44 24 70	 mov	 r8d, DWORD PTR len$[rsp]
  0008e	48 8b 54 24 20	 mov	 rdx, QWORD PTR pbuf$[rsp]
  00093	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  000a0	48 98		 cdqe
  000a2	48 89 44 24 78	 mov	 QWORD PTR size$[rsp], rax

; 8209 : #else
; 8210 :     size = write(fd, pbuf.buf, len);
; 8211 : #endif
; 8212 :     Py_END_ALLOW_THREADS

  000a7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _save$123850[rsp]
  000af	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 8213 :     PyBuffer_Release(&pbuf);

  000b4	48 8d 4c 24 20	 lea	 rcx, QWORD PTR pbuf$[rsp]
  000b9	e8 00 00 00 00	 call	 PyBuffer_Release

; 8214 :     if (size < 0)

  000be	48 83 7c 24 78
	00		 cmp	 QWORD PTR size$[rsp], 0
  000c4	7d 07		 jge	 SHORT $LN1@posix_writ

; 8215 :         return posix_error();

  000c6	e8 00 00 00 00	 call	 posix_error
  000cb	eb 0a		 jmp	 SHORT $LN5@posix_writ
$LN1@posix_writ:

; 8216 :     return PyLong_FromSsize_t(size);

  000cd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR size$[rsp]
  000d2	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN5@posix_writ:

; 8217 : }

  000d7	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  000de	c3		 ret	 0
posix_write ENDP
_TEXT	ENDS
PUBLIC	??_C@_07NPKODNGM@i?3fstat?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_fstat DD imagerel posix_fstat
	DD	imagerel posix_fstat+141
	DD	imagerel $unwind$posix_fstat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_fstat DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_07NPKODNGM@i?3fstat?$AA@
CONST	SEGMENT
??_C@_07NPKODNGM@i?3fstat?$AA@ DB 'i:fstat', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_fstat
_TEXT	SEGMENT
res$ = 32
st$ = 48
fd$ = 144
_save$123867 = 152
self$ = 176
args$ = 184
posix_fstat PROC					; COMDAT

; 8365 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 8366 :     int fd;
; 8367 :     STRUCT_STAT st;
; 8368 :     int res;
; 8369 :     if (!PyArg_ParseTuple(args, "i:fstat", &fd))

  00011	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR fd$[rsp]
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07NPKODNGM@i?3fstat?$AA@
  00020	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00028	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002d	85 c0		 test	 eax, eax
  0002f	75 04		 jne	 SHORT $LN2@posix_fsta

; 8370 :         return NULL;

  00031	33 c0		 xor	 eax, eax
  00033	eb 50		 jmp	 SHORT $LN3@posix_fsta
$LN2@posix_fsta:

; 8371 : #ifdef __VMS
; 8372 :     /* on OpenVMS we must ensure that all bytes are written to the file */
; 8373 :     fsync(fd);
; 8374 : #endif
; 8375 :     Py_BEGIN_ALLOW_THREADS

  00035	e8 00 00 00 00	 call	 PyEval_SaveThread
  0003a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR _save$123867[rsp], rax

; 8376 :     res = FSTAT(fd, &st);

  00042	48 8d 54 24 30	 lea	 rdx, QWORD PTR st$[rsp]
  00047	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0004e	e8 00 00 00 00	 call	 win32_fstat
  00053	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 8377 :     Py_END_ALLOW_THREADS

  00057	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR _save$123867[rsp]
  0005f	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 8378 :     if (res != 0) {

  00064	83 7c 24 20 00	 cmp	 DWORD PTR res$[rsp], 0
  00069	74 10		 je	 SHORT $LN1@posix_fsta

; 8379 : #ifdef MS_WINDOWS
; 8380 :         return win32_error("fstat", NULL);

  0006b	33 d2		 xor	 edx, edx
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05MIPJACCK@fstat?$AA@
  00074	e8 00 00 00 00	 call	 win32_error
  00079	eb 0a		 jmp	 SHORT $LN3@posix_fsta
$LN1@posix_fsta:

; 8381 : #else
; 8382 :         return posix_error();
; 8383 : #endif
; 8384 :     }
; 8385 : 
; 8386 :     return _pystat_fromstructstat(&st);

  0007b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR st$[rsp]
  00080	e8 00 00 00 00	 call	 _pystat_fromstructstat
$LN3@posix_fsta:

; 8387 : }

  00085	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0008c	c3		 ret	 0
posix_fstat ENDP
_TEXT	ENDS
PUBLIC	??_C@_08IDKJIOEH@i?3isatty?$AA@			; `string'
EXTRN	__imp_isatty:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_isatty DD imagerel posix_isatty
	DD	imagerel posix_isatty+88
	DD	imagerel $unwind$posix_isatty
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_isatty DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_08IDKJIOEH@i?3isatty?$AA@
CONST	SEGMENT
??_C@_08IDKJIOEH@i?3isatty?$AA@ DB 'i:isatty', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_isatty
_TEXT	SEGMENT
fd$ = 32
self$ = 64
args$ = 72
posix_isatty PROC					; COMDAT

; 8396 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 8397 :     int fd;
; 8398 :     if (!PyArg_ParseTuple(args, "i:isatty", &fd))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR fd$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08IDKJIOEH@i?3isatty?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@posix_isat

; 8399 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 27		 jmp	 SHORT $LN3@posix_isat
$LN2@posix_isat:

; 8400 :     if (!_PyVerify_fd(fd))

  0002c	8b 4c 24 20	 mov	 ecx, DWORD PTR fd$[rsp]
  00030	e8 00 00 00 00	 call	 _PyVerify_fd
  00035	85 c0		 test	 eax, eax
  00037	75 09		 jne	 SHORT $LN1@posix_isat

; 8401 :         return PyBool_FromLong(0);

  00039	33 c9		 xor	 ecx, ecx
  0003b	e8 00 00 00 00	 call	 PyBool_FromLong
  00040	eb 11		 jmp	 SHORT $LN3@posix_isat
$LN1@posix_isat:

; 8402 :     return PyBool_FromLong(isatty(fd));

  00042	8b 4c 24 20	 mov	 ecx, DWORD PTR fd$[rsp]
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  0004c	8b c8		 mov	 ecx, eax
  0004e	e8 00 00 00 00	 call	 PyBool_FromLong
$LN3@posix_isat:

; 8403 : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
posix_isatty ENDP
_TEXT	ENDS
PUBLIC	??_C@_04INACLLOK@?$CIii?$CJ?$AA@		; `string'
PUBLIC	??_C@_0L@FBIDOKLH@CreatePipe?$AA@		; `string'
EXTRN	__imp__open_osfhandle:PROC
EXTRN	__imp_CreatePipe:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_pipe DD imagerel posix_pipe
	DD	imagerel posix_pipe+126
	DD	imagerel $unwind$posix_pipe
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_pipe DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_04INACLLOK@?$CIii?$CJ?$AA@
CONST	SEGMENT
??_C@_04INACLLOK@?$CIii?$CJ?$AA@ DB '(ii)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FBIDOKLH@CreatePipe?$AA@
CONST	SEGMENT
??_C@_0L@FBIDOKLH@CreatePipe?$AA@ DB 'CreatePipe', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_pipe
_TEXT	SEGMENT
read_fd$ = 32
read$ = 40
ok$ = 48
write_fd$ = 52
write$ = 56
self$ = 80
noargs$ = 88
posix_pipe PROC						; COMDAT

; 8412 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 8413 : #if defined(PYOS_OS2)
; 8414 :     HFILE read, write;
; 8415 :     APIRET rc;
; 8416 : 
; 8417 :     rc = DosCreatePipe( &read, &write, 4096);
; 8418 :     if (rc != NO_ERROR)
; 8419 :         return os2_error(rc);
; 8420 : 
; 8421 :     return Py_BuildValue("(ii)", read, write);
; 8422 : #else
; 8423 : #if !defined(MS_WINDOWS)
; 8424 :     int fds[2];
; 8425 :     int res;
; 8426 :     res = pipe(fds);
; 8427 :     if (res != 0)
; 8428 :         return posix_error();
; 8429 :     return Py_BuildValue("(ii)", fds[0], fds[1]);
; 8430 : #else /* MS_WINDOWS */
; 8431 :     HANDLE read, write;
; 8432 :     int read_fd, write_fd;
; 8433 :     BOOL ok;
; 8434 :     ok = CreatePipe(&read, &write, NULL, 0);

  0000e	45 33 c9	 xor	 r9d, r9d
  00011	45 33 c0	 xor	 r8d, r8d
  00014	48 8d 54 24 38	 lea	 rdx, QWORD PTR write$[rsp]
  00019	48 8d 4c 24 28	 lea	 rcx, QWORD PTR read$[rsp]
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreatePipe
  00024	89 44 24 30	 mov	 DWORD PTR ok$[rsp], eax

; 8435 :     if (!ok)

  00028	83 7c 24 30 00	 cmp	 DWORD PTR ok$[rsp], 0
  0002d	75 10		 jne	 SHORT $LN1@posix_pipe

; 8436 :         return win32_error("CreatePipe", NULL);

  0002f	33 d2		 xor	 edx, edx
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@FBIDOKLH@CreatePipe?$AA@
  00038	e8 00 00 00 00	 call	 win32_error
  0003d	eb 3a		 jmp	 SHORT $LN2@posix_pipe
$LN1@posix_pipe:

; 8437 :     read_fd = _open_osfhandle((Py_intptr_t)read, 0);

  0003f	33 d2		 xor	 edx, edx
  00041	48 8b 4c 24 28	 mov	 rcx, QWORD PTR read$[rsp]
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__open_osfhandle
  0004c	89 44 24 20	 mov	 DWORD PTR read_fd$[rsp], eax

; 8438 :     write_fd = _open_osfhandle((Py_intptr_t)write, 1);

  00050	ba 01 00 00 00	 mov	 edx, 1
  00055	48 8b 4c 24 38	 mov	 rcx, QWORD PTR write$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__open_osfhandle
  00060	89 44 24 34	 mov	 DWORD PTR write_fd$[rsp], eax

; 8439 :     return Py_BuildValue("(ii)", read_fd, write_fd);

  00064	44 8b 44 24 34	 mov	 r8d, DWORD PTR write_fd$[rsp]
  00069	8b 54 24 20	 mov	 edx, DWORD PTR read_fd$[rsp]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04INACLLOK@?$CIii?$CJ?$AA@
  00074	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
$LN2@posix_pipe:

; 8440 : #endif /* MS_WINDOWS */
; 8441 : #endif
; 8442 : }

  00079	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007d	c3		 ret	 0
posix_pipe ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@BEHIAFCC@the?5environment?5variable?5is?5long@ ; `string'
PUBLIC	??_C@_1DG@BBJJCAFP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@IKNFFLIF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_05BCKEIHAE@?$CFU?$DN?$CFU?$AA@		; `string'
PUBLIC	??_C@_09ODIBKEDE@UU?3putenv?$AA@		; `string'
EXTRN	PyDict_SetItem:PROC
EXTRN	__imp__wputenv:PROC
EXTRN	PyUnicode_FromFormat:PROC
_BSS	SEGMENT
posix_putenv_garbage DQ 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_putenv DD imagerel posix_putenv
	DD	imagerel posix_putenv+388
	DD	imagerel $unwind$posix_putenv
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_putenv DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0DG@BEHIAFCC@the?5environment?5variable?5is?5long@
CONST	SEGMENT
??_C@_0DG@BEHIAFCC@the?5environment?5variable?5is?5long@ DB 'the environm'
	DB	'ent variable is longer than %u characters', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@BBJJCAFP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@BBJJCAFP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'n', 00H
	DB	'e', 00H, 'w', 00H, 's', 00H, 't', 00H, 'r', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@IKNFFLIF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@IKNFFLIF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'n', 00H, 'e', 00H, 'w', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05BCKEIHAE@?$CFU?$DN?$CFU?$AA@
CONST	SEGMENT
??_C@_05BCKEIHAE@?$CFU?$DN?$CFU?$AA@ DB '%U=%U', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09ODIBKEDE@UU?3putenv?$AA@
CONST	SEGMENT
??_C@_09ODIBKEDE@UU?3putenv?$AA@ DB 'UU:putenv', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_putenv
_TEXT	SEGMENT
newstr$ = 32
os2$ = 40
newenv$ = 48
os1$ = 56
self$ = 80
args$ = 88
posix_putenv PROC					; COMDAT

; 8841 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 8842 :     PyObject *newstr = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR newstr$[rsp], 0

; 8843 : #ifdef MS_WINDOWS
; 8844 :     PyObject *os1, *os2;
; 8845 :     wchar_t *newenv;
; 8846 : 
; 8847 :     if (!PyArg_ParseTuple(args,
; 8848 :                           "UU:putenv",
; 8849 :                           &os1, &os2))

  00017	4c 8d 4c 24 28	 lea	 r9, QWORD PTR os2$[rsp]
  0001c	4c 8d 44 24 38	 lea	 r8, QWORD PTR os1$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09ODIBKEDE@UU?3putenv?$AA@
  00028	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0002d	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN11@posix_pute

; 8850 :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 42 01 00 00	 jmp	 $LN12@posix_pute
$LN11@posix_pute:

; 8851 : 
; 8852 :     newstr = PyUnicode_FromFormat("%U=%U", os1, os2);

  0003d	4c 8b 44 24 28	 mov	 r8, QWORD PTR os2$[rsp]
  00042	48 8b 54 24 38	 mov	 rdx, QWORD PTR os1$[rsp]
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05BCKEIHAE@?$CFU?$DN?$CFU?$AA@
  0004e	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00053	48 89 44 24 20	 mov	 QWORD PTR newstr$[rsp], rax

; 8853 :     if (newstr == NULL) {

  00058	48 83 7c 24 20
	00		 cmp	 QWORD PTR newstr$[rsp], 0
  0005e	75 0a		 jne	 SHORT $LN10@posix_pute

; 8854 :         PyErr_NoMemory();

  00060	e8 00 00 00 00	 call	 PyErr_NoMemory

; 8855 :         goto error;

  00065	e9 fb 00 00 00	 jmp	 $error$123921
$LN10@posix_pute:

; 8856 :     }
; 8857 :     if (_MAX_ENV < PyUnicode_GET_LENGTH(newstr)) {

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR newstr$[rsp]
  0006f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00073	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00079	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0007e	85 c0		 test	 eax, eax
  00080	75 1c		 jne	 SHORT $LN14@posix_pute
  00082	41 b8 99 22 00
	00		 mov	 r8d, 8857		; 00002299H
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IKNFFLIF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009c	33 c0		 xor	 eax, eax
$LN14@posix_pute:
  0009e	48 8b 44 24 20	 mov	 rax, QWORD PTR newstr$[rsp]
  000a3	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000a6	c1 e8 07	 shr	 eax, 7
  000a9	83 e0 01	 and	 eax, 1
  000ac	85 c0		 test	 eax, eax
  000ae	75 1c		 jne	 SHORT $LN15@posix_pute
  000b0	41 b8 99 22 00
	00		 mov	 r8d, 8857		; 00002299H
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@BBJJCAFP@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAe?$AAw?$AAs?$AAt?$AAr?$AA?$CJ?$AA?$AA@
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ca	33 c0		 xor	 eax, eax
$LN15@posix_pute:
  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR newstr$[rsp]
  000d1	48 81 78 60 ff
	7f 00 00	 cmp	 QWORD PTR [rax+96], 32767 ; 00007fffH
  000d9	7e 1b		 jle	 SHORT $LN9@posix_pute

; 8858 :         PyErr_Format(PyExc_ValueError,
; 8859 :                      "the environment variable is longer than %u characters",
; 8860 :                      _MAX_ENV);

  000db	41 b8 ff 7f 00
	00		 mov	 r8d, 32767		; 00007fffH
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@BEHIAFCC@the?5environment?5variable?5is?5long@
  000e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000ef	e8 00 00 00 00	 call	 PyErr_Format

; 8861 :         goto error;

  000f4	eb 6f		 jmp	 SHORT $error$123921
$LN9@posix_pute:

; 8862 :     }
; 8863 : 
; 8864 :     newenv = PyUnicode_AsUnicode(newstr);

  000f6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newstr$[rsp]
  000fb	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00100	48 89 44 24 30	 mov	 QWORD PTR newenv$[rsp], rax

; 8865 :     if (newenv == NULL)

  00105	48 83 7c 24 30
	00		 cmp	 QWORD PTR newenv$[rsp], 0
  0010b	75 02		 jne	 SHORT $LN8@posix_pute

; 8866 :         goto error;

  0010d	eb 56		 jmp	 SHORT $error$123921
$LN8@posix_pute:

; 8867 :     if (_wputenv(newenv)) {

  0010f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newenv$[rsp]
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wputenv
  0011a	85 c0		 test	 eax, eax
  0011c	74 07		 je	 SHORT $LN7@posix_pute

; 8868 :         posix_error();

  0011e	e8 00 00 00 00	 call	 posix_error

; 8869 :         goto error;

  00123	eb 40		 jmp	 SHORT $error$123921
$LN7@posix_pute:

; 8870 :     }
; 8871 : #else
; 8872 :     PyObject *os1, *os2;
; 8873 :     char *s1, *s2;
; 8874 :     char *newenv;
; 8875 : 
; 8876 :     if (!PyArg_ParseTuple(args,
; 8877 :                           "O&O&:putenv",
; 8878 :                           PyUnicode_FSConverter, &os1,
; 8879 :                           PyUnicode_FSConverter, &os2))
; 8880 :         return NULL;
; 8881 :     s1 = PyBytes_AsString(os1);
; 8882 :     s2 = PyBytes_AsString(os2);
; 8883 : 
; 8884 :     newstr = PyBytes_FromFormat("%s=%s", s1, s2);
; 8885 :     if (newstr == NULL) {
; 8886 :         PyErr_NoMemory();
; 8887 :         goto error;
; 8888 :     }
; 8889 : 
; 8890 :     newenv = PyBytes_AS_STRING(newstr);
; 8891 :     if (putenv(newenv)) {
; 8892 :         posix_error();
; 8893 :         goto error;
; 8894 :     }
; 8895 : #endif
; 8896 : 
; 8897 :     /* Install the first arg and newstr in posix_putenv_garbage;
; 8898 :      * this will cause previous value to be collected.  This has to
; 8899 :      * happen after the real putenv() call because the old value
; 8900 :      * was still accessible until then. */
; 8901 :     if (PyDict_SetItem(posix_putenv_garbage, os1, newstr)) {

  00125	4c 8b 44 24 20	 mov	 r8, QWORD PTR newstr$[rsp]
  0012a	48 8b 54 24 38	 mov	 rdx, QWORD PTR os1$[rsp]
  0012f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR posix_putenv_garbage
  00136	e8 00 00 00 00	 call	 PyDict_SetItem
  0013b	85 c0		 test	 eax, eax
  0013d	74 07		 je	 SHORT $LN6@posix_pute

; 8902 :         /* really not much we can do; just leak */
; 8903 :         PyErr_Clear();

  0013f	e8 00 00 00 00	 call	 PyErr_Clear

; 8904 :     }
; 8905 :     else {

  00144	eb 0a		 jmp	 SHORT $LN5@posix_pute
$LN6@posix_pute:

; 8906 :         Py_DECREF(newstr);

  00146	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newstr$[rsp]
  0014b	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@posix_pute:

; 8907 :     }
; 8908 : 
; 8909 : #ifndef MS_WINDOWS
; 8910 :     Py_DECREF(os1);
; 8911 :     Py_DECREF(os2);
; 8912 : #endif
; 8913 :     Py_RETURN_NONE;

  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00157	e8 00 00 00 00	 call	 _Py_IncRef
  0015c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00163	eb 1a		 jmp	 SHORT $LN12@posix_pute
$error$123921:
$LN4@posix_pute:

; 8914 : 
; 8915 : error:
; 8916 : #ifndef MS_WINDOWS
; 8917 :     Py_DECREF(os1);
; 8918 :     Py_DECREF(os2);
; 8919 : #endif
; 8920 :     Py_XDECREF(newstr);

  00165	48 83 7c 24 20
	00		 cmp	 QWORD PTR newstr$[rsp], 0
  0016b	74 0a		 je	 SHORT $LN1@posix_pute
  0016d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newstr$[rsp]
  00172	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@posix_pute:
  00177	33 c0		 xor	 eax, eax
  00179	85 c0		 test	 eax, eax
  0017b	75 e8		 jne	 SHORT $LN4@posix_pute

; 8921 :     return NULL;

  0017d	33 c0		 xor	 eax, eax
$LN12@posix_pute:

; 8922 : }

  0017f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00183	c3		 ret	 0
posix_putenv ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@GMJLDMKP@surrogateescape?$AA@		; `string'
PUBLIC	??_C@_0CB@EANPBAEB@strerror?$CI?$CJ?5argument?5out?5of?5range@ ; `string'
PUBLIC	??_C@_0L@BOGMIHBP@i?3strerror?$AA@		; `string'
EXTRN	PyUnicode_DecodeLocale:PROC
EXTRN	__imp_strerror:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_strerror DD imagerel posix_strerror
	DD	imagerel posix_strerror+112
	DD	imagerel $unwind$posix_strerror
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_strerror DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
CONST	SEGMENT
??_C@_0BA@GMJLDMKP@surrogateescape?$AA@ DB 'surrogateescape', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EANPBAEB@strerror?$CI?$CJ?5argument?5out?5of?5range@
CONST	SEGMENT
??_C@_0CB@EANPBAEB@strerror?$CI?$CJ?5argument?5out?5of?5range@ DB 'strerr'
	DB	'or() argument out of range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BOGMIHBP@i?3strerror?$AA@
CONST	SEGMENT
??_C@_0L@BOGMIHBP@i?3strerror?$AA@ DB 'i:strerror', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_strerror
_TEXT	SEGMENT
code$ = 32
message$ = 40
self$ = 64
args$ = 72
posix_strerror PROC					; COMDAT

; 8973 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 8974 :     int code;
; 8975 :     char *message;
; 8976 :     if (!PyArg_ParseTuple(args, "i:strerror", &code))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR code$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@BOGMIHBP@i?3strerror?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@posix_stre

; 8977 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 3f		 jmp	 SHORT $LN3@posix_stre
$LN2@posix_stre:

; 8978 :     message = strerror(code);

  0002c	8b 4c 24 20	 mov	 ecx, DWORD PTR code$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00036	48 89 44 24 28	 mov	 QWORD PTR message$[rsp], rax

; 8979 :     if (message == NULL) {

  0003b	48 83 7c 24 28
	00		 cmp	 QWORD PTR message$[rsp], 0
  00041	75 17		 jne	 SHORT $LN1@posix_stre

; 8980 :         PyErr_SetString(PyExc_ValueError,
; 8981 :                         "strerror() argument out of range");

  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@EANPBAEB@strerror?$CI?$CJ?5argument?5out?5of?5range@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00051	e8 00 00 00 00	 call	 PyErr_SetString

; 8982 :         return NULL;

  00056	33 c0		 xor	 eax, eax
  00058	eb 11		 jmp	 SHORT $LN3@posix_stre
$LN1@posix_stre:

; 8983 :     }
; 8984 :     return PyUnicode_DecodeLocale(message, "surrogateescape");

  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GMJLDMKP@surrogateescape?$AA@
  00061	48 8b 4c 24 28	 mov	 rcx, QWORD PTR message$[rsp]
  00066	e8 00 00 00 00	 call	 PyUnicode_DecodeLocale
$LN3@posix_stre:

; 8985 : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
posix_strerror ENDP
_TEXT	ENDS
PUBLIC	??_C@_04CEGIGAON@?$CILL?$CJ?$AA@		; `string'
PUBLIC	??_C@_01OMGOGALD@u?$AA@				; `string'
EXTRN	__imp_GetDiskFreeSpaceExW:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32__getdiskusage DD imagerel win32__getdiskusage
	DD	imagerel win32__getdiskusage+137
	DD	imagerel $unwind$win32__getdiskusage
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32__getdiskusage DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_04CEGIGAON@?$CILL?$CJ?$AA@
CONST	SEGMENT
??_C@_04CEGIGAON@?$CILL?$CJ?$AA@ DB '(LL)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OMGOGALD@u?$AA@
CONST	SEGMENT
??_C@_01OMGOGALD@u?$AA@ DB 'u', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT win32__getdiskusage
_TEXT	SEGMENT
free$ = 32
retval$ = 40
total$ = 48
path$ = 56
_$ = 64
_save$123976 = 72
self$ = 96
args$ = 104
win32__getdiskusage PROC				; COMDAT

; 9278 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 9279 :     BOOL retval;
; 9280 :     ULARGE_INTEGER _, total, free;
; 9281 :     const wchar_t *path;
; 9282 : 
; 9283 :     if (! PyArg_ParseTuple(args, "u", &path))

  0000e	4c 8d 44 24 38	 lea	 r8, QWORD PTR path$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01OMGOGALD@u?$AA@
  0001a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@win32__get

; 9284 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 58		 jmp	 SHORT $LN3@win32__get
$LN2@win32__get:

; 9285 : 
; 9286 :     Py_BEGIN_ALLOW_THREADS

  0002c	e8 00 00 00 00	 call	 PyEval_SaveThread
  00031	48 89 44 24 48	 mov	 QWORD PTR _save$123976[rsp], rax

; 9287 :     retval = GetDiskFreeSpaceExW(path, &_, &total, &free);

  00036	4c 8d 4c 24 20	 lea	 r9, QWORD PTR free$[rsp]
  0003b	4c 8d 44 24 30	 lea	 r8, QWORD PTR total$[rsp]
  00040	48 8d 54 24 40	 lea	 rdx, QWORD PTR _$[rsp]
  00045	48 8b 4c 24 38	 mov	 rcx, QWORD PTR path$[rsp]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetDiskFreeSpaceExW
  00050	89 44 24 28	 mov	 DWORD PTR retval$[rsp], eax

; 9288 :     Py_END_ALLOW_THREADS

  00054	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _save$123976[rsp]
  00059	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 9289 :     if (retval == 0)

  0005e	83 7c 24 28 00	 cmp	 DWORD PTR retval$[rsp], 0
  00063	75 09		 jne	 SHORT $LN1@win32__get

; 9290 :         return PyErr_SetFromWindowsErr(0);

  00065	33 c9		 xor	 ecx, ecx
  00067	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  0006c	eb 16		 jmp	 SHORT $LN3@win32__get
$LN1@win32__get:

; 9291 : 
; 9292 :     return Py_BuildValue("(LL)", total.QuadPart, free.QuadPart);

  0006e	4c 8b 44 24 20	 mov	 r8, QWORD PTR free$[rsp]
  00073	48 8b 54 24 30	 mov	 rdx, QWORD PTR total$[rsp]
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04CEGIGAON@?$CILL?$CJ?$AA@
  0007f	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
$LN3@win32__get:

; 9293 : }

  00084	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00088	c3		 ret	 0
win32__getdiskusage ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@CCJFMGCG@abort?$CI?$CJ?5called?5from?5Python?5code?5@ ; `string'
EXTRN	Py_FatalError:PROC
EXTRN	__imp_abort:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_abort DD imagerel posix_abort
	DD	imagerel posix_abort+39
	DD	imagerel $unwind$posix_abort
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_abort DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0CO@CCJFMGCG@abort?$CI?$CJ?5called?5from?5Python?5code?5@
CONST	SEGMENT
??_C@_0CO@CCJFMGCG@abort?$CI?$CJ?5called?5from?5Python?5code?5@ DB 'abort'
	DB	'() called from Python code didn''t abort!', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_abort
_TEXT	SEGMENT
self$ = 48
noargs$ = 56
posix_abort PROC					; COMDAT

; 10340: {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 10341:     abort();

  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_abort

; 10342:     /*NOTREACHED*/
; 10343:     Py_FatalError("abort() called from Python code didn't abort!");

  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@CCJFMGCG@abort?$CI?$CJ?5called?5from?5Python?5code?5@
  0001b	e8 00 00 00 00	 call	 Py_FatalError

; 10344:     return NULL;

  00020	33 c0		 xor	 eax, eax

; 10345: }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
posix_abort ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@HEIJOHAF@O?$CG?$HMs?3startfile?$AA@	; `string'
PUBLIC	??_C@_0O@HKJMLDFL@U?$HMs?3startfile?$AA@	; `string'
EXTRN	__imp_ShellExecuteA:PROC
EXTRN	__imp_ShellExecuteW:PROC
EXTRN	PyUnicode_DecodeASCII:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$win32_startfile DD imagerel win32_startfile
	DD	imagerel win32_startfile+610
	DD	imagerel $unwind$win32_startfile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win32_startfile DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0P@HEIJOHAF@O?$CG?$HMs?3startfile?$AA@
CONST	SEGMENT
??_C@_0P@HEIJOHAF@O?$CG?$HMs?3startfile?$AA@ DB 'O&|s:startfile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@HKJMLDFL@U?$HMs?3startfile?$AA@
CONST	SEGMENT
??_C@_0O@HKJMLDFL@U?$HMs?3startfile?$AA@ DB 'U|s:startfile', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT win32_startfile
_TEXT	SEGMENT
uoperation$ = 48
woperation$ = 56
operation$ = 64
rc$ = 72
wpath$ = 80
filepath$ = 88
ofilepath$ = 96
unipath$ = 104
_save$124097 = 112
_save$124117 = 120
errval$124123 = 128
self$ = 160
args$ = 168
win32_startfile PROC					; COMDAT

; 10369: {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 10370:     PyObject *ofilepath;
; 10371:     char *filepath;
; 10372:     char *operation = NULL;

  00011	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR operation$[rsp], 0

; 10373:     wchar_t *wpath, *woperation;
; 10374:     HINSTANCE rc;
; 10375: 
; 10376:     PyObject *unipath, *uoperation = NULL;

  0001a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR uoperation$[rsp], 0

; 10377:     if (!PyArg_ParseTuple(args, "U|s:startfile",
; 10378:                           &unipath, &operation)) {

  00023	4c 8d 4c 24 40	 lea	 r9, QWORD PTR operation$[rsp]
  00028	4c 8d 44 24 68	 lea	 r8, QWORD PTR unipath$[rsp]
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@HKJMLDFL@U?$HMs?3startfile?$AA@
  00034	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0003c	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00041	85 c0		 test	 eax, eax
  00043	75 0a		 jne	 SHORT $LN15@win32_star

; 10379:         PyErr_Clear();

  00045	e8 00 00 00 00	 call	 PyErr_Clear

; 10380:         goto normal;

  0004a	e9 1c 01 00 00	 jmp	 $normal$124085
$LN15@win32_star:

; 10381:     }
; 10382: 
; 10383:     if (operation) {

  0004f	48 83 7c 24 40
	00		 cmp	 QWORD PTR operation$[rsp], 0
  00055	74 3a		 je	 SHORT $LN14@win32_star

; 10384:         uoperation = PyUnicode_DecodeASCII(operation,
; 10385:                                            strlen(operation), NULL);

  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR operation$[rsp]
  0005c	e8 00 00 00 00	 call	 strlen
  00061	45 33 c0	 xor	 r8d, r8d
  00064	48 8b d0	 mov	 rdx, rax
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR operation$[rsp]
  0006c	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  00071	48 89 44 24 30	 mov	 QWORD PTR uoperation$[rsp], rax

; 10386:         if (!uoperation) {

  00076	48 83 7c 24 30
	00		 cmp	 QWORD PTR uoperation$[rsp], 0
  0007c	75 13		 jne	 SHORT $LN13@win32_star

; 10387:             PyErr_Clear();

  0007e	e8 00 00 00 00	 call	 PyErr_Clear

; 10388:             operation = NULL;

  00083	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR operation$[rsp], 0

; 10389:             goto normal;

  0008c	e9 da 00 00 00	 jmp	 $normal$124085
$LN13@win32_star:
$LN14@win32_star:

; 10390:         }
; 10391:     }
; 10392: 
; 10393:     wpath = PyUnicode_AsUnicode(unipath);

  00091	48 8b 4c 24 68	 mov	 rcx, QWORD PTR unipath$[rsp]
  00096	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  0009b	48 89 44 24 50	 mov	 QWORD PTR wpath$[rsp], rax

; 10394:     if (wpath == NULL)

  000a0	48 83 7c 24 50
	00		 cmp	 QWORD PTR wpath$[rsp], 0
  000a6	75 05		 jne	 SHORT $LN12@win32_star

; 10395:         goto normal;

  000a8	e9 be 00 00 00	 jmp	 $normal$124085
$LN12@win32_star:

; 10396:     if (uoperation) {

  000ad	48 83 7c 24 30
	00		 cmp	 QWORD PTR uoperation$[rsp], 0
  000b3	74 1e		 je	 SHORT $LN11@win32_star

; 10397:         woperation = PyUnicode_AsUnicode(uoperation);

  000b5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR uoperation$[rsp]
  000ba	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  000bf	48 89 44 24 38	 mov	 QWORD PTR woperation$[rsp], rax

; 10398:         if (woperation == NULL)

  000c4	48 83 7c 24 38
	00		 cmp	 QWORD PTR woperation$[rsp], 0
  000ca	75 05		 jne	 SHORT $LN10@win32_star

; 10399:             goto normal;

  000cc	e9 9a 00 00 00	 jmp	 $normal$124085
$LN10@win32_star:

; 10400:     }
; 10401:     else

  000d1	eb 09		 jmp	 SHORT $LN9@win32_star
$LN11@win32_star:

; 10402:         woperation = NULL;

  000d3	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR woperation$[rsp], 0
$LN9@win32_star:

; 10403: 
; 10404:     Py_BEGIN_ALLOW_THREADS

  000dc	e8 00 00 00 00	 call	 PyEval_SaveThread
  000e1	48 89 44 24 70	 mov	 QWORD PTR _save$124097[rsp], rax

; 10405:     rc = ShellExecuteW((HWND)0, woperation, wpath,
; 10406:                        NULL, NULL, SW_SHOWNORMAL);

  000e6	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  000ee	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000f7	45 33 c9	 xor	 r9d, r9d
  000fa	4c 8b 44 24 50	 mov	 r8, QWORD PTR wpath$[rsp]
  000ff	48 8b 54 24 38	 mov	 rdx, QWORD PTR woperation$[rsp]
  00104	33 c9		 xor	 ecx, ecx
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ShellExecuteW
  0010c	48 89 44 24 48	 mov	 QWORD PTR rc$[rsp], rax

; 10407:     Py_END_ALLOW_THREADS

  00111	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _save$124097[rsp]
  00116	e8 00 00 00 00	 call	 PyEval_RestoreThread
$LN8@win32_star:

; 10408: 
; 10409:     Py_XDECREF(uoperation);

  0011b	48 83 7c 24 30
	00		 cmp	 QWORD PTR uoperation$[rsp], 0
  00121	74 0a		 je	 SHORT $LN5@win32_star
  00123	48 8b 4c 24 30	 mov	 rcx, QWORD PTR uoperation$[rsp]
  00128	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@win32_star:
  0012d	33 c0		 xor	 eax, eax
  0012f	85 c0		 test	 eax, eax
  00131	75 e8		 jne	 SHORT $LN8@win32_star

; 10410:     if (rc <= (HINSTANCE)32) {

  00133	48 83 7c 24 48
	20		 cmp	 QWORD PTR rc$[rsp], 32	; 00000020H
  00139	77 18		 ja	 SHORT $LN4@win32_star

; 10411:         win32_error_object("startfile", unipath);

  0013b	48 8b 54 24 68	 mov	 rdx, QWORD PTR unipath$[rsp]
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09FCFKICPJ@startfile?$AA@
  00147	e8 00 00 00 00	 call	 win32_error_object

; 10412:         return NULL;

  0014c	33 c0		 xor	 eax, eax
  0014e	e9 07 01 00 00	 jmp	 $LN16@win32_star
$LN4@win32_star:

; 10413:     }
; 10414:     Py_INCREF(Py_None);

  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0015a	e8 00 00 00 00	 call	 _Py_IncRef

; 10415:     return Py_None;

  0015f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00166	e9 ef 00 00 00	 jmp	 $LN16@win32_star
$normal$124085:

; 10416: 
; 10417: normal:
; 10418:     if (!PyArg_ParseTuple(args, "O&|s:startfile",
; 10419:                           PyUnicode_FSConverter, &ofilepath,
; 10420:                           &operation))

  0016b	48 8d 44 24 40	 lea	 rax, QWORD PTR operation$[rsp]
  00170	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00175	4c 8d 4c 24 60	 lea	 r9, QWORD PTR ofilepath$[rsp]
  0017a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyUnicode_FSConverter
  00181	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@HEIJOHAF@O?$CG?$HMs?3startfile?$AA@
  00188	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00190	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00195	85 c0		 test	 eax, eax
  00197	75 07		 jne	 SHORT $LN3@win32_star

; 10421:         return NULL;

  00199	33 c0		 xor	 eax, eax
  0019b	e9 ba 00 00 00	 jmp	 $LN16@win32_star
$LN3@win32_star:

; 10422:     if (win32_warn_bytes_api()) {

  001a0	e8 00 00 00 00	 call	 win32_warn_bytes_api
  001a5	85 c0		 test	 eax, eax
  001a7	74 11		 je	 SHORT $LN2@win32_star

; 10423:         Py_DECREF(ofilepath);

  001a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ofilepath$[rsp]
  001ae	e8 00 00 00 00	 call	 _Py_DecRef

; 10424:         return NULL;

  001b3	33 c0		 xor	 eax, eax
  001b5	e9 a0 00 00 00	 jmp	 $LN16@win32_star
$LN2@win32_star:

; 10425:     }
; 10426:     filepath = PyBytes_AsString(ofilepath);

  001ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ofilepath$[rsp]
  001bf	e8 00 00 00 00	 call	 PyBytes_AsString
  001c4	48 89 44 24 58	 mov	 QWORD PTR filepath$[rsp], rax

; 10427:     Py_BEGIN_ALLOW_THREADS

  001c9	e8 00 00 00 00	 call	 PyEval_SaveThread
  001ce	48 89 44 24 78	 mov	 QWORD PTR _save$124117[rsp], rax

; 10428:     rc = ShellExecute((HWND)0, operation, filepath,
; 10429:                       NULL, NULL, SW_SHOWNORMAL);

  001d3	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  001db	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  001e4	45 33 c9	 xor	 r9d, r9d
  001e7	4c 8b 44 24 58	 mov	 r8, QWORD PTR filepath$[rsp]
  001ec	48 8b 54 24 40	 mov	 rdx, QWORD PTR operation$[rsp]
  001f1	33 c9		 xor	 ecx, ecx
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ShellExecuteA
  001f9	48 89 44 24 48	 mov	 QWORD PTR rc$[rsp], rax

; 10430:     Py_END_ALLOW_THREADS

  001fe	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _save$124117[rsp]
  00203	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 10431:     if (rc <= (HINSTANCE)32) {

  00208	48 83 7c 24 48
	20		 cmp	 QWORD PTR rc$[rsp], 32	; 00000020H
  0020e	77 2d		 ja	 SHORT $LN1@win32_star

; 10432:         PyObject *errval = win32_error("startfile", filepath);

  00210	48 8b 54 24 58	 mov	 rdx, QWORD PTR filepath$[rsp]
  00215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09FCFKICPJ@startfile?$AA@
  0021c	e8 00 00 00 00	 call	 win32_error
  00221	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR errval$124123[rsp], rax

; 10433:         Py_DECREF(ofilepath);

  00229	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ofilepath$[rsp]
  0022e	e8 00 00 00 00	 call	 _Py_DecRef

; 10434:         return errval;

  00233	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR errval$124123[rsp]
  0023b	eb 1d		 jmp	 SHORT $LN16@win32_star
$LN1@win32_star:

; 10435:     }
; 10436:     Py_DECREF(ofilepath);

  0023d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ofilepath$[rsp]
  00242	e8 00 00 00 00	 call	 _Py_DecRef

; 10437:     Py_INCREF(Py_None);

  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0024e	e8 00 00 00 00	 call	 _Py_IncRef

; 10438:     return Py_None;

  00253	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN16@win32_star:

; 10439: }

  0025a	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00261	c3		 ret	 0
win32_startfile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@GPKADAGA@i?3device_encoding?$AA@	; `string'
EXTRN	_Py_device_encoding:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$device_encoding DD imagerel device_encoding
	DD	imagerel device_encoding+58
	DD	imagerel $unwind$device_encoding
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$device_encoding DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BC@GPKADAGA@i?3device_encoding?$AA@
CONST	SEGMENT
??_C@_0BC@GPKADAGA@i?3device_encoding?$AA@ DB 'i:device_encoding', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT device_encoding
_TEXT	SEGMENT
fd$ = 32
self$ = 64
args$ = 72
device_encoding PROC					; COMDAT

; 10468: {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 10469:     int fd;
; 10470: 
; 10471:     if (!PyArg_ParseTuple(args, "i:device_encoding", &fd))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR fd$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@GPKADAGA@i?3device_encoding?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN1@device_enc

; 10472:         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 09		 jmp	 SHORT $LN2@device_enc
$LN1@device_enc:

; 10473: 
; 10474:     return _Py_device_encoding(fd);

  0002c	8b 4c 24 20	 mov	 ecx, DWORD PTR fd$[rsp]
  00030	e8 00 00 00 00	 call	 _Py_device_encoding
$LN2@device_enc:

; 10475: }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
device_encoding ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@ ; `string'
PUBLIC	??_C@_09DFDFFLIA@n?3urandom?$AA@		; `string'
EXTRN	_PyOS_URandom:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$posix_urandom DD imagerel posix_urandom
	DD	imagerel posix_urandom+276
	DD	imagerel $unwind$posix_urandom
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$posix_urandom DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@
CONST	SEGMENT
??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@ DB 'negative arg'
	DB	'ument not allowed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DFDFFLIA@n?3urandom?$AA@
CONST	SEGMENT
??_C@_09DFDFFLIA@n?3urandom?$AA@ DB 'n:urandom', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT posix_urandom
_TEXT	SEGMENT
size$ = 32
ret$ = 40
result$ = 48
self$ = 80
args$ = 88
posix_urandom PROC					; COMDAT

; 10861: {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 10862:     Py_ssize_t size;
; 10863:     PyObject *result;
; 10864:     int ret;
; 10865: 
; 10866:      /* Read arguments */
; 10867:     if (!PyArg_ParseTuple(args, "n:urandom", &size))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR size$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09DFDFFLIA@n?3urandom?$AA@
  0001a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00024	85 c0		 test	 eax, eax
  00026	75 07		 jne	 SHORT $LN4@posix_uran

; 10868:         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 e0 00 00 00	 jmp	 $LN5@posix_uran
$LN4@posix_uran:

; 10869:     if (size < 0)

  0002f	48 83 7c 24 20
	00		 cmp	 QWORD PTR size$[rsp], 0
  00035	7d 18		 jge	 SHORT $LN3@posix_uran

; 10870:         return PyErr_Format(PyExc_ValueError,
; 10871:                             "negative argument not allowed");

  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@IMHOBKLC@negative?5argument?5not?5allowed?$AA@
  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00045	e8 00 00 00 00	 call	 PyErr_Format
  0004a	e9 c0 00 00 00	 jmp	 $LN5@posix_uran
$LN3@posix_uran:

; 10872:     result = PyBytes_FromStringAndSize(NULL, size);

  0004f	48 8b 54 24 20	 mov	 rdx, QWORD PTR size$[rsp]
  00054	33 c9		 xor	 ecx, ecx
  00056	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0005b	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 10873:     if (result == NULL)

  00060	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  00066	75 07		 jne	 SHORT $LN2@posix_uran

; 10874:         return NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 a0 00 00 00	 jmp	 $LN5@posix_uran
$LN2@posix_uran:

; 10875: 
; 10876:     ret = _PyOS_URandom(PyBytes_AS_STRING(result),
; 10877:                         PyBytes_GET_SIZE(result));

  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  00074	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00078	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0007e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00083	85 c0		 test	 eax, eax
  00085	75 1c		 jne	 SHORT $LN7@posix_uran
  00087	41 b8 7d 2a 00
	00		 mov	 r8d, 10877		; 00002a7dH
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000a1	33 c0		 xor	 eax, eax
$LN7@posix_uran:
  000a3	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  000a8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ac	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000b2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000b7	85 c0		 test	 eax, eax
  000b9	75 1c		 jne	 SHORT $LN8@posix_uran
  000bb	41 b8 7c 2a 00
	00		 mov	 r8d, 10876		; 00002a7cH
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DC@LLFFNLFI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAp?$AAo?$AAs?$AAi?$AAx?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NOKOGCDJ@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?$AA@
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000d5	33 c0		 xor	 eax, eax
$LN8@posix_uran:
  000d7	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  000dc	48 83 c0 78	 add	 rax, 120		; 00000078H
  000e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  000e5	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  000e9	48 8b c8	 mov	 rcx, rax
  000ec	e8 00 00 00 00	 call	 _PyOS_URandom
  000f1	89 44 24 28	 mov	 DWORD PTR ret$[rsp], eax

; 10878:     if (ret == -1) {

  000f5	83 7c 24 28 ff	 cmp	 DWORD PTR ret$[rsp], -1
  000fa	75 0e		 jne	 SHORT $LN1@posix_uran

; 10879:         Py_DECREF(result);

  000fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00101	e8 00 00 00 00	 call	 _Py_DecRef

; 10880:         return NULL;

  00106	33 c0		 xor	 eax, eax
  00108	eb 05		 jmp	 SHORT $LN5@posix_uran
$LN1@posix_uran:

; 10881:     }
; 10882:     return result;

  0010a	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN5@posix_uran:

; 10883: }

  0010f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00113	c3		 ret	 0
posix_urandom ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@GHEGOGPK@handle?5cannot?5be?5retrieved?$AA@ ; `string'
PUBLIC	??_C@_0BE@MPJPGCEO@bad?5file?5descriptor?$AA@	; `string'
PUBLIC	??_C@_02OJGKGHDH@?$HMi?$AA@			; `string'
EXTRN	__imp_GetConsoleScreenBufferInfo:PROC
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_fileno:PROC
EXTRN	__imp___iob_func:PROC
_BSS	SEGMENT
TerminalSizeType DB 01e0H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_terminal_size DD imagerel get_terminal_size
	DD	imagerel get_terminal_size+392
	DD	imagerel $unwind$get_terminal_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_terminal_size DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0BL@GHEGOGPK@handle?5cannot?5be?5retrieved?$AA@
CONST	SEGMENT
??_C@_0BL@GHEGOGPK@handle?5cannot?5be?5retrieved?$AA@ DB 'handle cannot b'
	DB	'e retrieved', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MPJPGCEO@bad?5file?5descriptor?$AA@
CONST	SEGMENT
??_C@_0BE@MPJPGCEO@bad?5file?5descriptor?$AA@ DB 'bad file descriptor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02OJGKGHDH@?$HMi?$AA@
CONST	SEGMENT
??_C@_02OJGKGHDH@?$HMi?$AA@ DB '|i', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT get_terminal_size
_TEXT	SEGMENT
termsize$ = 32
lines$ = 40
fd$ = 44
columns$ = 48
csbi$124194 = 56
nhandle$124192 = 80
handle$124193 = 88
tv73 = 96
self$ = 128
args$ = 136
get_terminal_size PROC					; COMDAT

; 10923: {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 10924:     int columns, lines;
; 10925:     PyObject *termsize;
; 10926: 
; 10927:     int fd = fileno(stdout);

  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00014	48 83 c0 30	 add	 rax, 48			; 00000030H
  00018	48 8b c8	 mov	 rcx, rax
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  00021	89 44 24 2c	 mov	 DWORD PTR fd$[rsp], eax

; 10928:     /* Under some conditions stdout may not be connected and
; 10929:      * fileno(stdout) may point to an invalid file descriptor. For example
; 10930:      * GUI apps don't have valid standard streams by default.
; 10931:      *
; 10932:      * If this happens, and the optional fd argument is not present,
; 10933:      * the ioctl below will fail returning EBADF. This is what we want.
; 10934:      */
; 10935: 
; 10936:     if (!PyArg_ParseTuple(args, "|i", &fd))

  00025	4c 8d 44 24 2c	 lea	 r8, QWORD PTR fd$[rsp]
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02OJGKGHDH@?$HMi?$AA@
  00031	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00039	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003e	85 c0		 test	 eax, eax
  00040	75 07		 jne	 SHORT $LN12@get_termin

; 10937:         return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	e9 3a 01 00 00	 jmp	 $LN13@get_termin
$LN12@get_termin:

; 10938: 
; 10939: #ifdef TERMSIZE_USE_IOCTL
; 10940:     {
; 10941:         struct winsize w;
; 10942:         if (ioctl(fd, TIOCGWINSZ, &w))
; 10943:             return PyErr_SetFromErrno(PyExc_OSError);
; 10944:         columns = w.ws_col;
; 10945:         lines = w.ws_row;
; 10946:     }
; 10947: #endif /* TERMSIZE_USE_IOCTL */
; 10948: 
; 10949: #ifdef TERMSIZE_USE_CONIO
; 10950:     {
; 10951:         DWORD nhandle;
; 10952:         HANDLE handle;
; 10953:         CONSOLE_SCREEN_BUFFER_INFO csbi;
; 10954:         switch (fd) {

  00049	8b 44 24 2c	 mov	 eax, DWORD PTR fd$[rsp]
  0004d	89 44 24 60	 mov	 DWORD PTR tv73[rsp], eax
  00051	83 7c 24 60 00	 cmp	 DWORD PTR tv73[rsp], 0
  00056	74 10		 je	 SHORT $LN9@get_termin
  00058	83 7c 24 60 01	 cmp	 DWORD PTR tv73[rsp], 1
  0005d	74 13		 je	 SHORT $LN8@get_termin
  0005f	83 7c 24 60 02	 cmp	 DWORD PTR tv73[rsp], 2
  00064	74 16		 je	 SHORT $LN7@get_termin
  00066	eb 1e		 jmp	 SHORT $LN6@get_termin
$LN9@get_termin:

; 10955:         case 0: nhandle = STD_INPUT_HANDLE;

  00068	c7 44 24 50 f6
	ff ff ff	 mov	 DWORD PTR nhandle$124192[rsp], -10 ; fffffff6H

; 10956:             break;

  00070	eb 2c		 jmp	 SHORT $LN10@get_termin
$LN8@get_termin:

; 10957:         case 1: nhandle = STD_OUTPUT_HANDLE;

  00072	c7 44 24 50 f5
	ff ff ff	 mov	 DWORD PTR nhandle$124192[rsp], -11 ; fffffff5H

; 10958:             break;

  0007a	eb 22		 jmp	 SHORT $LN10@get_termin
$LN7@get_termin:

; 10959:         case 2: nhandle = STD_ERROR_HANDLE;

  0007c	c7 44 24 50 f4
	ff ff ff	 mov	 DWORD PTR nhandle$124192[rsp], -12 ; fffffff4H

; 10960:             break;

  00084	eb 18		 jmp	 SHORT $LN10@get_termin
$LN6@get_termin:

; 10961:         default:
; 10962:             return PyErr_Format(PyExc_ValueError, "bad file descriptor");

  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@MPJPGCEO@bad?5file?5descriptor?$AA@
  0008d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00094	e8 00 00 00 00	 call	 PyErr_Format
  00099	e9 e5 00 00 00	 jmp	 $LN13@get_termin
$LN10@get_termin:

; 10963:         }
; 10964:         handle = GetStdHandle(nhandle);

  0009e	8b 4c 24 50	 mov	 ecx, DWORD PTR nhandle$124192[rsp]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle
  000a8	48 89 44 24 58	 mov	 QWORD PTR handle$124193[rsp], rax

; 10965:         if (handle == NULL)

  000ad	48 83 7c 24 58
	00		 cmp	 QWORD PTR handle$124193[rsp], 0
  000b3	75 18		 jne	 SHORT $LN5@get_termin

; 10966:             return PyErr_Format(PyExc_OSError, "handle cannot be retrieved");

  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@GHEGOGPK@handle?5cannot?5be?5retrieved?$AA@
  000bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  000c3	e8 00 00 00 00	 call	 PyErr_Format
  000c8	e9 b6 00 00 00	 jmp	 $LN13@get_termin
$LN5@get_termin:

; 10967:         if (handle == INVALID_HANDLE_VALUE)

  000cd	48 83 7c 24 58
	ff		 cmp	 QWORD PTR handle$124193[rsp], -1
  000d3	75 0c		 jne	 SHORT $LN4@get_termin

; 10968:             return PyErr_SetFromWindowsErr(0);

  000d5	33 c9		 xor	 ecx, ecx
  000d7	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000dc	e9 a2 00 00 00	 jmp	 $LN13@get_termin
$LN4@get_termin:

; 10969: 
; 10970:         if (!GetConsoleScreenBufferInfo(handle, &csbi))

  000e1	48 8d 54 24 38	 lea	 rdx, QWORD PTR csbi$124194[rsp]
  000e6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR handle$124193[rsp]
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleScreenBufferInfo
  000f1	85 c0		 test	 eax, eax
  000f3	75 0c		 jne	 SHORT $LN3@get_termin

; 10971:             return PyErr_SetFromWindowsErr(0);

  000f5	33 c9		 xor	 ecx, ecx
  000f7	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  000fc	e9 82 00 00 00	 jmp	 $LN13@get_termin
$LN3@get_termin:

; 10972: 
; 10973:         columns = csbi.srWindow.Right - csbi.srWindow.Left + 1;

  00101	0f bf 44 24 46	 movsx	 eax, WORD PTR csbi$124194[rsp+14]
  00106	0f bf 4c 24 42	 movsx	 ecx, WORD PTR csbi$124194[rsp+10]
  0010b	2b c1		 sub	 eax, ecx
  0010d	ff c0		 inc	 eax
  0010f	89 44 24 30	 mov	 DWORD PTR columns$[rsp], eax

; 10974:         lines = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;

  00113	0f bf 44 24 48	 movsx	 eax, WORD PTR csbi$124194[rsp+16]
  00118	0f bf 4c 24 44	 movsx	 ecx, WORD PTR csbi$124194[rsp+12]
  0011d	2b c1		 sub	 eax, ecx
  0011f	ff c0		 inc	 eax
  00121	89 44 24 28	 mov	 DWORD PTR lines$[rsp], eax

; 10975:     }
; 10976: #endif /* TERMSIZE_USE_CONIO */
; 10977: 
; 10978:     termsize = PyStructSequence_New(&TerminalSizeType);

  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TerminalSizeType
  0012c	e8 00 00 00 00	 call	 PyStructSequence_New
  00131	48 89 44 24 20	 mov	 QWORD PTR termsize$[rsp], rax

; 10979:     if (termsize == NULL)

  00136	48 83 7c 24 20
	00		 cmp	 QWORD PTR termsize$[rsp], 0
  0013c	75 04		 jne	 SHORT $LN2@get_termin

; 10980:         return NULL;

  0013e	33 c0		 xor	 eax, eax
  00140	eb 41		 jmp	 SHORT $LN13@get_termin
$LN2@get_termin:

; 10981:     PyStructSequence_SET_ITEM(termsize, 0, PyLong_FromLong(columns));

  00142	8b 4c 24 30	 mov	 ecx, DWORD PTR columns$[rsp]
  00146	e8 00 00 00 00	 call	 PyLong_FromLong
  0014b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR termsize$[rsp]
  00150	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 10982:     PyStructSequence_SET_ITEM(termsize, 1, PyLong_FromLong(lines));

  00154	8b 4c 24 28	 mov	 ecx, DWORD PTR lines$[rsp]
  00158	e8 00 00 00 00	 call	 PyLong_FromLong
  0015d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR termsize$[rsp]
  00162	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax

; 10983:     if (PyErr_Occurred()) {

  00166	e8 00 00 00 00	 call	 PyErr_Occurred
  0016b	48 85 c0	 test	 rax, rax
  0016e	74 0e		 je	 SHORT $LN1@get_termin

; 10984:         Py_DECREF(termsize);

  00170	48 8b 4c 24 20	 mov	 rcx, QWORD PTR termsize$[rsp]
  00175	e8 00 00 00 00	 call	 _Py_DecRef

; 10985:         return NULL;

  0017a	33 c0		 xor	 eax, eax
  0017c	eb 05		 jmp	 SHORT $LN13@get_termin
$LN1@get_termin:

; 10986:     }
; 10987:     return termsize;

  0017e	48 8b 44 24 20	 mov	 rax, QWORD PTR termsize$[rsp]
$LN13@get_termin:

; 10988: }

  00183	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00187	c3		 ret	 0
get_terminal_size ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@LAEJAKJB@_have_functions?$AA@		; `string'
PUBLIC	??_C@_0O@DAAGAOJH@terminal_size?$AA@		; `string'
PUBLIC	??_C@_0BA@CJCNFMF@nt?4uname_result?$AA@		; `string'
PUBLIC	??_C@_0BA@GNILAMAH@nt?4times_result?$AA@	; `string'
PUBLIC	??_C@_0BC@BCENFCML@nt?4statvfs_result?$AA@	; `string'
PUBLIC	??_C@_0P@PELKKPPB@nt?4stat_result?$AA@		; `string'
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	??_C@_07OJMFOADC@environ?$AA@			; `string'
PUBLIC	PyInit_nt
EXTRN	PyStructSequence_InitType:PROC
EXTRN	PyStructSequence_UnnamedField:QWORD
EXTRN	PyDict_New:PROC
EXTRN	PyModule_AddObject:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
_BSS	SEGMENT
UnameResultType DB 01e0H DUP (?)
StatVFSResultType DB 01e0H DUP (?)
structseq_new DQ 01H DUP (?)
initialized DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_nt DD imagerel $LN21
	DD	imagerel $LN21+962
	DD	imagerel $unwind$PyInit_nt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_nt DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0BA@LAEJAKJB@_have_functions?$AA@
CONST	SEGMENT
??_C@_0BA@LAEJAKJB@_have_functions?$AA@ DB '_have_functions', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DAAGAOJH@terminal_size?$AA@
CONST	SEGMENT
??_C@_0O@DAAGAOJH@terminal_size?$AA@ DB 'terminal_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CJCNFMF@nt?4uname_result?$AA@
CONST	SEGMENT
??_C@_0BA@CJCNFMF@nt?4uname_result?$AA@ DB 'nt.uname_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNILAMAH@nt?4times_result?$AA@
CONST	SEGMENT
??_C@_0BA@GNILAMAH@nt?4times_result?$AA@ DB 'nt.times_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BCENFCML@nt?4statvfs_result?$AA@
CONST	SEGMENT
??_C@_0BC@BCENFCML@nt?4statvfs_result?$AA@ DB 'nt.statvfs_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@PELKKPPB@nt?4stat_result?$AA@
CONST	SEGMENT
??_C@_0P@PELKKPPB@nt?4stat_result?$AA@ DB 'nt.stat_result', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OJMFOADC@environ?$AA@
CONST	SEGMENT
??_C@_07OJMFOADC@environ?$AA@ DB 'environ', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit_nt
_TEXT	SEGMENT
v$ = 32
trace$ = 40
list$ = 48
m$ = 56
ignored$124457 = 64
unicode$124463 = 72
PyInit_nt PROC						; COMDAT

; 12091: {

$LN21:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 12092:     PyObject *m, *v;
; 12093:     PyObject *list;
; 12094:     char **trace;
; 12095: 
; 12096: #if defined(HAVE_SYMLINK) && defined(MS_WINDOWS)
; 12097:     win32_can_symlink = enable_symlink();

  00004	e8 00 00 00 00	 call	 enable_symlink
  00009	89 05 00 00 00
	00		 mov	 DWORD PTR win32_can_symlink, eax

; 12098: #endif
; 12099: 
; 12100:     m = PyModule_Create(&posixmodule);

  0000f	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:posixmodule
  0001b	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00020	48 89 44 24 38	 mov	 QWORD PTR m$[rsp], rax

; 12101:     if (m == NULL)

  00025	48 83 7c 24 38
	00		 cmp	 QWORD PTR m$[rsp], 0
  0002b	75 07		 jne	 SHORT $LN18@PyInit_nt

; 12102:         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 89 03 00 00	 jmp	 $LN19@PyInit_nt
$LN18@PyInit_nt:

; 12103: 
; 12104:     /* Initialize environ dictionary */
; 12105:     v = convertenviron();

  00034	e8 00 00 00 00	 call	 convertenviron
  00039	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax
$LN17@PyInit_nt:

; 12106:     Py_XINCREF(v);

  0003e	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00044	74 0a		 je	 SHORT $LN14@PyInit_nt
  00046	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0004b	e8 00 00 00 00	 call	 _Py_IncRef
$LN14@PyInit_nt:
  00050	33 c0		 xor	 eax, eax
  00052	85 c0		 test	 eax, eax
  00054	75 e8		 jne	 SHORT $LN17@PyInit_nt

; 12107:     if (v == NULL || PyModule_AddObject(m, "environ", v) != 0)

  00056	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  0005c	74 1a		 je	 SHORT $LN12@PyInit_nt
  0005e	4c 8b 44 24 20	 mov	 r8, QWORD PTR v$[rsp]
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07OJMFOADC@environ?$AA@
  0006a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  0006f	e8 00 00 00 00	 call	 PyModule_AddObject
  00074	85 c0		 test	 eax, eax
  00076	74 07		 je	 SHORT $LN13@PyInit_nt
$LN12@PyInit_nt:

; 12108:         return NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	e9 3e 03 00 00	 jmp	 $LN19@PyInit_nt
$LN13@PyInit_nt:

; 12109:     Py_DECREF(v);

  0007f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00084	e8 00 00 00 00	 call	 _Py_DecRef

; 12110: 
; 12111:     if (all_ins(m))

  00089	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  0008e	e8 00 00 00 00	 call	 all_ins
  00093	85 c0		 test	 eax, eax
  00095	74 07		 je	 SHORT $LN11@PyInit_nt

; 12112:         return NULL;

  00097	33 c0		 xor	 eax, eax
  00099	e9 1f 03 00 00	 jmp	 $LN19@PyInit_nt
$LN11@PyInit_nt:

; 12113: 
; 12114:     if (setup_confname_tables(m))

  0009e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  000a3	e8 00 00 00 00	 call	 setup_confname_tables
  000a8	85 c0		 test	 eax, eax
  000aa	74 07		 je	 SHORT $LN10@PyInit_nt

; 12115:         return NULL;

  000ac	33 c0		 xor	 eax, eax
  000ae	e9 0a 03 00 00	 jmp	 $LN19@PyInit_nt
$LN10@PyInit_nt:

; 12116: 
; 12117:     Py_INCREF(PyExc_OSError);

  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  000ba	e8 00 00 00 00	 call	 _Py_IncRef

; 12118:     PyModule_AddObject(m, "error", PyExc_OSError);

  000bf	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR PyExc_OSError
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  000cd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  000d2	e8 00 00 00 00	 call	 PyModule_AddObject

; 12119: 
; 12120: #ifdef HAVE_PUTENV
; 12121:     if (posix_putenv_garbage == NULL)

  000d7	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR posix_putenv_garbage, 0
  000df	75 0c		 jne	 SHORT $LN9@PyInit_nt

; 12122:         posix_putenv_garbage = PyDict_New();

  000e1	e8 00 00 00 00	 call	 PyDict_New
  000e6	48 89 05 00 00
	00 00		 mov	 QWORD PTR posix_putenv_garbage, rax
$LN9@PyInit_nt:

; 12123: #endif
; 12124: 
; 12125:     if (!initialized) {

  000ed	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR initialized, 0
  000f4	0f 85 ad 00 00
	00		 jne	 $LN8@PyInit_nt

; 12126: #if defined(HAVE_WAITID) && !defined(__APPLE__)
; 12127:         waitid_result_desc.name = MODNAME ".waitid_result";
; 12128:         PyStructSequence_InitType(&WaitidResultType, &waitid_result_desc);
; 12129: #endif
; 12130: 
; 12131:         stat_result_desc.name = MODNAME ".stat_result";

  000fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0P@PELKKPPB@nt?4stat_result?$AA@
  00101	48 89 05 00 00
	00 00		 mov	 QWORD PTR stat_result_desc, rax

; 12132:         stat_result_desc.fields[7].name = PyStructSequence_UnnamedField;

  00108	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR stat_result_desc+16
  0010f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyStructSequence_UnnamedField
  00116	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 12133:         stat_result_desc.fields[8].name = PyStructSequence_UnnamedField;

  0011a	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR stat_result_desc+16
  00121	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyStructSequence_UnnamedField
  00128	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 12134:         stat_result_desc.fields[9].name = PyStructSequence_UnnamedField;

  0012f	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR stat_result_desc+16
  00136	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyStructSequence_UnnamedField
  0013d	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 12135:         PyStructSequence_InitType(&StatResultType, &stat_result_desc);

  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:stat_result_desc
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StatResultType
  00152	e8 00 00 00 00	 call	 PyStructSequence_InitType

; 12136:         structseq_new = StatResultType.tp_new;

  00157	48 8b 05 90 01
	00 00		 mov	 rax, QWORD PTR StatResultType+400
  0015e	48 89 05 00 00
	00 00		 mov	 QWORD PTR structseq_new, rax

; 12137:         StatResultType.tp_new = statresult_new;

  00165	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:statresult_new
  0016c	48 89 05 90 01
	00 00		 mov	 QWORD PTR StatResultType+400, rax

; 12138: 
; 12139:         statvfs_result_desc.name = MODNAME ".statvfs_result";

  00173	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@BCENFCML@nt?4statvfs_result?$AA@
  0017a	48 89 05 00 00
	00 00		 mov	 QWORD PTR statvfs_result_desc, rax

; 12140:         PyStructSequence_InitType(&StatVFSResultType, &statvfs_result_desc);

  00181	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:statvfs_result_desc
  00188	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StatVFSResultType
  0018f	e8 00 00 00 00	 call	 PyStructSequence_InitType

; 12141: #ifdef NEED_TICKS_PER_SECOND
; 12142: #  if defined(HAVE_SYSCONF) && defined(_SC_CLK_TCK)
; 12143:         ticks_per_second = sysconf(_SC_CLK_TCK);
; 12144: #  elif defined(HZ)
; 12145:         ticks_per_second = HZ;
; 12146: #  else
; 12147:         ticks_per_second = 60; /* magic fallback value; may be bogus */
; 12148: #  endif
; 12149: #endif
; 12150: 
; 12151: #if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER)
; 12152:         sched_param_desc.name = MODNAME ".sched_param";
; 12153:         PyStructSequence_InitType(&SchedParamType, &sched_param_desc);
; 12154:         SchedParamType.tp_new = sched_param_new;
; 12155: #endif
; 12156: 
; 12157:         /* initialize TerminalSize_info */
; 12158:         PyStructSequence_InitType(&TerminalSizeType, &TerminalSize_desc);

  00194	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:TerminalSize_desc
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TerminalSizeType
  001a2	e8 00 00 00 00	 call	 PyStructSequence_InitType
$LN8@PyInit_nt:

; 12159:     }
; 12160: #if defined(HAVE_WAITID) && !defined(__APPLE__)
; 12161:     Py_INCREF((PyObject*) &WaitidResultType);
; 12162:     PyModule_AddObject(m, "waitid_result", (PyObject*) &WaitidResultType);
; 12163: #endif
; 12164:     Py_INCREF((PyObject*) &StatResultType);

  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StatResultType
  001ae	e8 00 00 00 00	 call	 _Py_IncRef

; 12165:     PyModule_AddObject(m, "stat_result", (PyObject*) &StatResultType);

  001b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:StatResultType
  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@ENKKEMPE@stat_result?$AA@
  001c1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  001c6	e8 00 00 00 00	 call	 PyModule_AddObject

; 12166:     Py_INCREF((PyObject*) &StatVFSResultType);

  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StatVFSResultType
  001d2	e8 00 00 00 00	 call	 _Py_IncRef

; 12167:     PyModule_AddObject(m, "statvfs_result",
; 12168:                        (PyObject*) &StatVFSResultType);

  001d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:StatVFSResultType
  001de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@HMGCCANC@statvfs_result?$AA@
  001e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  001ea	e8 00 00 00 00	 call	 PyModule_AddObject

; 12169: 
; 12170: #if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER)
; 12171:     Py_INCREF(&SchedParamType);
; 12172:     PyModule_AddObject(m, "sched_param", (PyObject *)&SchedParamType);
; 12173: #endif
; 12174: 
; 12175:     times_result_desc.name = MODNAME ".times_result";

  001ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BA@GNILAMAH@nt?4times_result?$AA@
  001f6	48 89 05 00 00
	00 00		 mov	 QWORD PTR times_result_desc, rax

; 12176:     PyStructSequence_InitType(&TimesResultType, &times_result_desc);

  001fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:times_result_desc
  00204	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TimesResultType
  0020b	e8 00 00 00 00	 call	 PyStructSequence_InitType

; 12177:     PyModule_AddObject(m, "times_result", (PyObject *)&TimesResultType);

  00210	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:TimesResultType
  00217	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@BNFIOIGL@times_result?$AA@
  0021e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00223	e8 00 00 00 00	 call	 PyModule_AddObject

; 12178: 
; 12179:     uname_result_desc.name = MODNAME ".uname_result";

  00228	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BA@CJCNFMF@nt?4uname_result?$AA@
  0022f	48 89 05 00 00
	00 00		 mov	 QWORD PTR uname_result_desc, rax

; 12180:     PyStructSequence_InitType(&UnameResultType, &uname_result_desc);

  00236	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:uname_result_desc
  0023d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UnameResultType
  00244	e8 00 00 00 00	 call	 PyStructSequence_InitType

; 12181:     PyModule_AddObject(m, "uname_result", (PyObject *)&UnameResultType);

  00249	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:UnameResultType
  00250	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@HCEBDBKJ@uname_result?$AA@
  00257	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  0025c	e8 00 00 00 00	 call	 PyModule_AddObject

; 12182: 
; 12183: #ifdef __APPLE__
; 12184:     /*
; 12185:      * Step 2 of weak-linking support on Mac OS X.
; 12186:      *
; 12187:      * The code below removes functions that are not available on the
; 12188:      * currently active platform.
; 12189:      *
; 12190:      * This block allow one to use a python binary that was build on
; 12191:      * OSX 10.4 on OSX 10.3, without losing access to new APIs on
; 12192:      * OSX 10.4.
; 12193:      */
; 12194: #ifdef HAVE_FSTATVFS
; 12195:     if (fstatvfs == NULL) {
; 12196:         if (PyObject_DelAttrString(m, "fstatvfs") == -1) {
; 12197:             return NULL;
; 12198:         }
; 12199:     }
; 12200: #endif /* HAVE_FSTATVFS */
; 12201: 
; 12202: #ifdef HAVE_STATVFS
; 12203:     if (statvfs == NULL) {
; 12204:         if (PyObject_DelAttrString(m, "statvfs") == -1) {
; 12205:             return NULL;
; 12206:         }
; 12207:     }
; 12208: #endif /* HAVE_STATVFS */
; 12209: 
; 12210: # ifdef HAVE_LCHOWN
; 12211:     if (lchown == NULL) {
; 12212:         if (PyObject_DelAttrString(m, "lchown") == -1) {
; 12213:             return NULL;
; 12214:         }
; 12215:     }
; 12216: #endif /* HAVE_LCHOWN */
; 12217: 
; 12218: 
; 12219: #endif /* __APPLE__ */
; 12220: 
; 12221:     Py_INCREF(&TerminalSizeType);

  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TerminalSizeType
  00268	e8 00 00 00 00	 call	 _Py_IncRef

; 12222:     PyModule_AddObject(m, "terminal_size", (PyObject*) &TerminalSizeType);

  0026d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:TerminalSizeType
  00274	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@DAAGAOJH@terminal_size?$AA@
  0027b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  00280	e8 00 00 00 00	 call	 PyModule_AddObject

; 12223: 
; 12224:     billion = PyLong_FromLong(1000000000);

  00285	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  0028a	e8 00 00 00 00	 call	 PyLong_FromLong
  0028f	48 89 05 00 00
	00 00		 mov	 QWORD PTR billion, rax

; 12225:     if (!billion)

  00296	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR billion, 0
  0029e	75 07		 jne	 SHORT $LN7@PyInit_nt

; 12226:         return NULL;

  002a0	33 c0		 xor	 eax, eax
  002a2	e9 16 01 00 00	 jmp	 $LN19@PyInit_nt
$LN7@PyInit_nt:

; 12227: 
; 12228:     /* suppress "function not used" warnings */
; 12229:     {
; 12230:     int ignored;
; 12231:     fd_specified("", -1);

  002a7	ba ff ff ff ff	 mov	 edx, -1
  002ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  002b3	e8 00 00 00 00	 call	 fd_specified

; 12232:     follow_symlinks_specified("", 1);

  002b8	ba 01 00 00 00	 mov	 edx, 1
  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  002c4	e8 00 00 00 00	 call	 follow_symlinks_specified

; 12233:     dir_fd_and_follow_symlinks_invalid("chmod", DEFAULT_DIR_FD, 1);

  002c9	41 b8 01 00 00
	00		 mov	 r8d, 1
  002cf	ba 9c ff ff ff	 mov	 edx, -100		; ffffffffffffff9cH
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05OCEJBCEE@chmod?$AA@
  002db	e8 00 00 00 00	 call	 dir_fd_and_follow_symlinks_invalid

; 12234:     dir_fd_converter(Py_None, &ignored);

  002e0	48 8d 54 24 40	 lea	 rdx, QWORD PTR ignored$124457[rsp]
  002e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  002ec	e8 00 00 00 00	 call	 dir_fd_converter

; 12235:     dir_fd_unavailable(Py_None, &ignored);

  002f1	48 8d 54 24 40	 lea	 rdx, QWORD PTR ignored$124457[rsp]
  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  002fd	e8 00 00 00 00	 call	 dir_fd_unavailable

; 12236:     }
; 12237: 
; 12238:     /*
; 12239:      * provide list of locally available functions
; 12240:      * so os.py can populate support_* lists
; 12241:      */
; 12242:     list = PyList_New(0);

  00302	33 c9		 xor	 ecx, ecx
  00304	e8 00 00 00 00	 call	 PyList_New
  00309	48 89 44 24 30	 mov	 QWORD PTR list$[rsp], rax

; 12243:     if (!list)

  0030e	48 83 7c 24 30
	00		 cmp	 QWORD PTR list$[rsp], 0
  00314	75 07		 jne	 SHORT $LN6@PyInit_nt

; 12244:         return NULL;

  00316	33 c0		 xor	 eax, eax
  00318	e9 a0 00 00 00	 jmp	 $LN19@PyInit_nt
$LN6@PyInit_nt:

; 12245:     for (trace = have_functions; *trace; trace++) {

  0031d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:have_functions
  00324	48 89 44 24 28	 mov	 QWORD PTR trace$[rsp], rax
  00329	eb 0e		 jmp	 SHORT $LN5@PyInit_nt
$LN4@PyInit_nt:
  0032b	48 8b 44 24 28	 mov	 rax, QWORD PTR trace$[rsp]
  00330	48 83 c0 08	 add	 rax, 8
  00334	48 89 44 24 28	 mov	 QWORD PTR trace$[rsp], rax
$LN5@PyInit_nt:
  00339	48 8b 44 24 28	 mov	 rax, QWORD PTR trace$[rsp]
  0033e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00342	74 54		 je	 SHORT $LN3@PyInit_nt

; 12246:         PyObject *unicode = PyUnicode_DecodeASCII(*trace, strlen(*trace), NULL);

  00344	48 8b 44 24 28	 mov	 rax, QWORD PTR trace$[rsp]
  00349	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0034c	e8 00 00 00 00	 call	 strlen
  00351	45 33 c0	 xor	 r8d, r8d
  00354	48 8b d0	 mov	 rdx, rax
  00357	48 8b 44 24 28	 mov	 rax, QWORD PTR trace$[rsp]
  0035c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0035f	e8 00 00 00 00	 call	 PyUnicode_DecodeASCII
  00364	48 89 44 24 48	 mov	 QWORD PTR unicode$124463[rsp], rax

; 12247:         if (!unicode)

  00369	48 83 7c 24 48
	00		 cmp	 QWORD PTR unicode$124463[rsp], 0
  0036f	75 04		 jne	 SHORT $LN2@PyInit_nt

; 12248:             return NULL;

  00371	33 c0		 xor	 eax, eax
  00373	eb 48		 jmp	 SHORT $LN19@PyInit_nt
$LN2@PyInit_nt:

; 12249:         if (PyList_Append(list, unicode))

  00375	48 8b 54 24 48	 mov	 rdx, QWORD PTR unicode$124463[rsp]
  0037a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR list$[rsp]
  0037f	e8 00 00 00 00	 call	 PyList_Append
  00384	85 c0		 test	 eax, eax
  00386	74 04		 je	 SHORT $LN1@PyInit_nt

; 12250:             return NULL;

  00388	33 c0		 xor	 eax, eax
  0038a	eb 31		 jmp	 SHORT $LN19@PyInit_nt
$LN1@PyInit_nt:

; 12251:         Py_DECREF(unicode);

  0038c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR unicode$124463[rsp]
  00391	e8 00 00 00 00	 call	 _Py_DecRef

; 12252:     }

  00396	eb 93		 jmp	 SHORT $LN4@PyInit_nt
$LN3@PyInit_nt:

; 12253:     PyModule_AddObject(m, "_have_functions", list);

  00398	4c 8b 44 24 30	 mov	 r8, QWORD PTR list$[rsp]
  0039d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@LAEJAKJB@_have_functions?$AA@
  003a4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR m$[rsp]
  003a9	e8 00 00 00 00	 call	 PyModule_AddObject

; 12254: 
; 12255:     initialized = 1;

  003ae	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR initialized, 1

; 12256: 
; 12257:     return m;

  003b8	48 8b 44 24 38	 mov	 rax, QWORD PTR m$[rsp]
$LN19@PyInit_nt:

; 12258: 
; 12259: }

  003bd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003c1	c3		 ret	 0
PyInit_nt ENDP
_TEXT	ENDS
PUBLIC	??_C@_02ENHFDPNM@fd?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$fd_specified DD imagerel fd_specified
	DD	imagerel fd_specified+51
	DD	imagerel $unwind$fd_specified
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fd_specified DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT ??_C@_02ENHFDPNM@fd?$AA@
CONST	SEGMENT
??_C@_02ENHFDPNM@fd?$AA@ DB 'fd', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fd_specified
_TEXT	SEGMENT
function_name$ = 48
fd$ = 56
fd_specified PROC					; COMDAT

; 853  : fd_specified(char *function_name, int fd) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 854  :     if (fd == -1)

  0000d	83 7c 24 38 ff	 cmp	 DWORD PTR fd$[rsp], -1
  00012	75 04		 jne	 SHORT $LN1@fd_specifi

; 855  :         return 0;

  00014	33 c0		 xor	 eax, eax
  00016	eb 16		 jmp	 SHORT $LN2@fd_specifi
$LN1@fd_specifi:

; 856  : 
; 857  :     argument_unavailable_error(function_name, "fd");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02ENHFDPNM@fd?$AA@
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR function_name$[rsp]
  00024	e8 00 00 00 00	 call	 argument_unavailable_error

; 858  :     return 1;

  00029	b8 01 00 00 00	 mov	 eax, 1
$LN2@fd_specifi:

; 859  : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
fd_specified ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DD@BCDPAJEI@?$CFs?3?5cannot?5use?5dir_fd?5and?5follow@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$dir_fd_and_follow_symlinks_invalid DD imagerel dir_fd_and_follow_symlinks_invalid
	DD	imagerel dir_fd_and_follow_symlinks_invalid+70
	DD	imagerel $unwind$dir_fd_and_follow_symlinks_invalid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dir_fd_and_follow_symlinks_invalid DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT ??_C@_0DD@BCDPAJEI@?$CFs?3?5cannot?5use?5dir_fd?5and?5follow@
CONST	SEGMENT
??_C@_0DD@BCDPAJEI@?$CFs?3?5cannot?5use?5dir_fd?5and?5follow@ DB '%s: can'
	DB	'not use dir_fd and follow_symlinks together', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT dir_fd_and_follow_symlinks_invalid
_TEXT	SEGMENT
function_name$ = 48
dir_fd$ = 56
follow_symlinks$ = 64
dir_fd_and_follow_symlinks_invalid PROC			; COMDAT

; 906  :                                    int follow_symlinks) {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 907  :     if ((dir_fd != DEFAULT_DIR_FD) && (!follow_symlinks)) {

  00012	83 7c 24 38 9c	 cmp	 DWORD PTR dir_fd$[rsp], -100 ; ffffffffffffff9cH
  00017	74 26		 je	 SHORT $LN1@dir_fd_and@2
  00019	83 7c 24 40 00	 cmp	 DWORD PTR follow_symlinks$[rsp], 0
  0001e	75 1f		 jne	 SHORT $LN1@dir_fd_and@2

; 908  :         PyErr_Format(PyExc_ValueError,
; 909  :                      "%s: cannot use dir_fd and follow_symlinks together",
; 910  :                      function_name);

  00020	4c 8b 44 24 30	 mov	 r8, QWORD PTR function_name$[rsp]
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@BCDPAJEI@?$CFs?3?5cannot?5use?5dir_fd?5and?5follow@
  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00033	e8 00 00 00 00	 call	 PyErr_Format

; 911  :         return 1;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	eb 02		 jmp	 SHORT $LN2@dir_fd_and@2
$LN1@dir_fd_and@2:

; 912  :     }
; 913  :     return 0;

  0003f	33 c0		 xor	 eax, eax
$LN2@dir_fd_and@2:

; 914  : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
dir_fd_and_follow_symlinks_invalid ENDP
_TEXT	ENDS
EXTRN	PyDict_GetItem:PROC
EXTRN	__imp_wcschr:PROC
EXTRN	__imp__wenviron:QWORD
EXTRN	__imp__wgetenv:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$convertenviron DD imagerel convertenviron
	DD	imagerel convertenviron+354
	DD	imagerel $unwind$convertenviron
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$convertenviron DD 010401H
	DD	0a204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT convertenviron
_TEXT	SEGMENT
d$ = 32
e$ = 40
p$121323 = 48
v$121322 = 56
k$121321 = 64
convertenviron PROC					; COMDAT

; 1100 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1101 :     PyObject *d;
; 1102 : #ifdef MS_WINDOWS
; 1103 :     wchar_t **e;
; 1104 : #else
; 1105 :     char **e;
; 1106 : #endif
; 1107 : #if defined(PYOS_OS2)
; 1108 :     APIRET rc;
; 1109 :     char   buffer[1024]; /* OS/2 Provides a Documented Max of 1024 Chars */
; 1110 : #endif
; 1111 : 
; 1112 :     d = PyDict_New();

  00004	e8 00 00 00 00	 call	 PyDict_New
  00009	48 89 44 24 20	 mov	 QWORD PTR d$[rsp], rax

; 1113 :     if (d == NULL)

  0000e	48 83 7c 24 20
	00		 cmp	 QWORD PTR d$[rsp], 0
  00014	75 07		 jne	 SHORT $LN10@convertenv

; 1114 :         return NULL;

  00016	33 c0		 xor	 eax, eax
  00018	e9 40 01 00 00	 jmp	 $LN11@convertenv
$LN10@convertenv:

; 1115 : #if defined(WITH_NEXT_FRAMEWORK) || (defined(__APPLE__) && defined(Py_ENABLE_SHARED))
; 1116 :     if (environ == NULL)
; 1117 :         environ = *_NSGetEnviron();
; 1118 : #endif
; 1119 : #ifdef MS_WINDOWS
; 1120 :     /* _wenviron must be initialized in this way if the program is started
; 1121 :        through main() instead of wmain(). */
; 1122 :     _wgetenv(L"");

  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_11LOCGONAA@?$AA?$AA@
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wgetenv

; 1123 :     if (_wenviron == NULL)

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__wenviron
  00031	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00035	75 0a		 jne	 SHORT $LN9@convertenv

; 1124 :         return d;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR d$[rsp]
  0003c	e9 1c 01 00 00	 jmp	 $LN11@convertenv
$LN9@convertenv:

; 1125 :     /* This part ignores errors */
; 1126 :     for (e = _wenviron; *e != NULL; e++) {

  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp__wenviron
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	48 89 44 24 28	 mov	 QWORD PTR e$[rsp], rax
  00050	eb 0e		 jmp	 SHORT $LN8@convertenv
$LN7@convertenv:
  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR e$[rsp]
  00057	48 83 c0 08	 add	 rax, 8
  0005b	48 89 44 24 28	 mov	 QWORD PTR e$[rsp], rax
$LN8@convertenv:
  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR e$[rsp]
  00065	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00069	0f 84 e9 00 00
	00		 je	 $LN6@convertenv

; 1127 :         PyObject *k;
; 1128 :         PyObject *v;
; 1129 :         wchar_t *p = wcschr(*e, L'=');

  0006f	66 ba 3d 00	 mov	 dx, 61			; 0000003dH
  00073	48 8b 44 24 28	 mov	 rax, QWORD PTR e$[rsp]
  00078	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcschr
  00081	48 89 44 24 30	 mov	 QWORD PTR p$121323[rsp], rax

; 1130 :         if (p == NULL)

  00086	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$121323[rsp], 0
  0008c	75 02		 jne	 SHORT $LN5@convertenv

; 1131 :             continue;

  0008e	eb c2		 jmp	 SHORT $LN7@convertenv
$LN5@convertenv:

; 1132 :         k = PyUnicode_FromWideChar(*e, (Py_ssize_t)(p-*e));

  00090	48 8b 44 24 28	 mov	 rax, QWORD PTR e$[rsp]
  00095	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00098	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$121323[rsp]
  0009d	48 2b c8	 sub	 rcx, rax
  000a0	48 8b c1	 mov	 rax, rcx
  000a3	48 d1 f8	 sar	 rax, 1
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	48 8b 44 24 28	 mov	 rax, QWORD PTR e$[rsp]
  000ae	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000b1	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  000b6	48 89 44 24 40	 mov	 QWORD PTR k$121321[rsp], rax

; 1133 :         if (k == NULL) {

  000bb	48 83 7c 24 40
	00		 cmp	 QWORD PTR k$121321[rsp], 0
  000c1	75 07		 jne	 SHORT $LN4@convertenv

; 1134 :             PyErr_Clear();

  000c3	e8 00 00 00 00	 call	 PyErr_Clear

; 1135 :             continue;

  000c8	eb 88		 jmp	 SHORT $LN7@convertenv
$LN4@convertenv:

; 1136 :         }
; 1137 :         v = PyUnicode_FromWideChar(p+1, wcslen(p+1));

  000ca	48 8b 44 24 30	 mov	 rax, QWORD PTR p$121323[rsp]
  000cf	48 83 c0 02	 add	 rax, 2
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wcslen
  000dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$121323[rsp]
  000e1	48 83 c1 02	 add	 rcx, 2
  000e5	48 8b d0	 mov	 rdx, rax
  000e8	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  000ed	48 89 44 24 38	 mov	 QWORD PTR v$121322[rsp], rax

; 1138 :         if (v == NULL) {

  000f2	48 83 7c 24 38
	00		 cmp	 QWORD PTR v$121322[rsp], 0
  000f8	75 14		 jne	 SHORT $LN3@convertenv

; 1139 :             PyErr_Clear();

  000fa	e8 00 00 00 00	 call	 PyErr_Clear

; 1140 :             Py_DECREF(k);

  000ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR k$121321[rsp]
  00104	e8 00 00 00 00	 call	 _Py_DecRef

; 1141 :             continue;

  00109	e9 44 ff ff ff	 jmp	 $LN7@convertenv
$LN3@convertenv:

; 1142 :         }
; 1143 :         if (PyDict_GetItem(d, k) == NULL) {

  0010e	48 8b 54 24 40	 mov	 rdx, QWORD PTR k$121321[rsp]
  00113	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00118	e8 00 00 00 00	 call	 PyDict_GetItem
  0011d	48 85 c0	 test	 rax, rax
  00120	75 1d		 jne	 SHORT $LN2@convertenv

; 1144 :             if (PyDict_SetItem(d, k, v) != 0)

  00122	4c 8b 44 24 38	 mov	 r8, QWORD PTR v$121322[rsp]
  00127	48 8b 54 24 40	 mov	 rdx, QWORD PTR k$121321[rsp]
  0012c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00131	e8 00 00 00 00	 call	 PyDict_SetItem
  00136	85 c0		 test	 eax, eax
  00138	74 05		 je	 SHORT $LN1@convertenv

; 1145 :                 PyErr_Clear();

  0013a	e8 00 00 00 00	 call	 PyErr_Clear
$LN1@convertenv:
$LN2@convertenv:

; 1146 :         }
; 1147 :         Py_DECREF(k);

  0013f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR k$121321[rsp]
  00144	e8 00 00 00 00	 call	 _Py_DecRef

; 1148 :         Py_DECREF(v);

  00149	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$121322[rsp]
  0014e	e8 00 00 00 00	 call	 _Py_DecRef

; 1149 :     }

  00153	e9 fa fe ff ff	 jmp	 $LN7@convertenv
$LN6@convertenv:

; 1150 : #else
; 1151 :     if (environ == NULL)
; 1152 :         return d;
; 1153 :     /* This part ignores errors */
; 1154 :     for (e = environ; *e != NULL; e++) {
; 1155 :         PyObject *k;
; 1156 :         PyObject *v;
; 1157 :         char *p = strchr(*e, '=');
; 1158 :         if (p == NULL)
; 1159 :             continue;
; 1160 :         k = PyBytes_FromStringAndSize(*e, (int)(p-*e));
; 1161 :         if (k == NULL) {
; 1162 :             PyErr_Clear();
; 1163 :             continue;
; 1164 :         }
; 1165 :         v = PyBytes_FromStringAndSize(p+1, strlen(p+1));
; 1166 :         if (v == NULL) {
; 1167 :             PyErr_Clear();
; 1168 :             Py_DECREF(k);
; 1169 :             continue;
; 1170 :         }
; 1171 :         if (PyDict_GetItem(d, k) == NULL) {
; 1172 :             if (PyDict_SetItem(d, k, v) != 0)
; 1173 :                 PyErr_Clear();
; 1174 :         }
; 1175 :         Py_DECREF(k);
; 1176 :         Py_DECREF(v);
; 1177 :     }
; 1178 : #endif
; 1179 : #if defined(PYOS_OS2)
; 1180 :     rc = DosQueryExtLIBPATH(buffer, BEGIN_LIBPATH);
; 1181 :     if (rc == NO_ERROR) { /* (not a type, envname is NOT 'BEGIN_LIBPATH') */
; 1182 :         PyObject *v = PyBytes_FromString(buffer);
; 1183 :         PyDict_SetItemString(d, "BEGINLIBPATH", v);
; 1184 :         Py_DECREF(v);
; 1185 :     }
; 1186 :     rc = DosQueryExtLIBPATH(buffer, END_LIBPATH);
; 1187 :     if (rc == NO_ERROR) { /* (not a typo, envname is NOT 'END_LIBPATH') */
; 1188 :         PyObject *v = PyBytes_FromString(buffer);
; 1189 :         PyDict_SetItemString(d, "ENDLIBPATH", v);
; 1190 :         Py_DECREF(v);
; 1191 :     }
; 1192 : #endif
; 1193 :     return d;

  00158	48 8b 44 24 20	 mov	 rax, QWORD PTR d$[rsp]
$LN11@convertenv:

; 1194 : }

  0015d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00161	c3		 ret	 0
convertenviron ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$statresult_new DD imagerel statresult_new
	DD	imagerel statresult_new+194
	DD	imagerel $unwind$statresult_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$statresult_new DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT statresult_new
_TEXT	SEGMENT
i$ = 32
result$ = 40
type$ = 64
args$ = 72
kwds$ = 80
statresult_new PROC					; COMDAT

; 2178 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2179 :     PyStructSequence *result;
; 2180 :     int i;
; 2181 : 
; 2182 :     result = (PyStructSequence*)structseq_new(type, args, kwds);

  00013	4c 8b 44 24 50	 mov	 r8, QWORD PTR kwds$[rsp]
  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR structseq_new
  00028	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 2183 :     if (!result)

  0002d	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  00033	75 07		 jne	 SHORT $LN5@statresult

; 2184 :         return NULL;

  00035	33 c0		 xor	 eax, eax
  00037	e9 81 00 00 00	 jmp	 $LN6@statresult
$LN5@statresult:

; 2185 :     /* If we have been initialized from a tuple,
; 2186 :        st_?time might be set to None. Initialize it
; 2187 :        from the int slots.  */
; 2188 :     for (i = 7; i <= 9; i++) {

  0003c	c7 44 24 20 07
	00 00 00	 mov	 DWORD PTR i$[rsp], 7
  00044	eb 0a		 jmp	 SHORT $LN4@statresult
$LN3@statresult:
  00046	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0004a	ff c0		 inc	 eax
  0004c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@statresult:
  00050	83 7c 24 20 09	 cmp	 DWORD PTR i$[rsp], 9
  00055	7f 61		 jg	 SHORT $LN2@statresult

; 2189 :         if (result->ob_item[i+3] == Py_None) {

  00057	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0005b	83 c0 03	 add	 eax, 3
  0005e	48 98		 cdqe
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00067	48 8b 54 24 28	 mov	 rdx, QWORD PTR result$[rsp]
  0006c	48 39 4c c2 70	 cmp	 QWORD PTR [rdx+rax*8+112], rcx
  00071	75 43		 jne	 SHORT $LN1@statresult

; 2190 :             Py_DECREF(Py_None);

  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0007a	e8 00 00 00 00	 call	 _Py_DecRef

; 2191 :             Py_INCREF(result->ob_item[i]);

  0007f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00084	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00089	48 8b 4c c1 70	 mov	 rcx, QWORD PTR [rcx+rax*8+112]
  0008e	e8 00 00 00 00	 call	 _Py_IncRef

; 2192 :             result->ob_item[i+3] = result->ob_item[i];

  00093	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00098	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0009c	83 c1 03	 add	 ecx, 3
  0009f	48 63 c9	 movsxd	 rcx, ecx
  000a2	48 8b 54 24 28	 mov	 rdx, QWORD PTR result$[rsp]
  000a7	4c 8b 44 24 28	 mov	 r8, QWORD PTR result$[rsp]
  000ac	49 8b 44 c0 70	 mov	 rax, QWORD PTR [r8+rax*8+112]
  000b1	48 89 44 ca 70	 mov	 QWORD PTR [rdx+rcx*8+112], rax
$LN1@statresult:

; 2193 :         }
; 2194 :     }

  000b6	eb 8e		 jmp	 SHORT $LN3@statresult
$LN2@statresult:

; 2195 :     return (PyObject*)result;

  000b8	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN6@statresult:

; 2196 : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
statresult_new ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT setup_confname_tables
_TEXT	SEGMENT
module$ = 8
setup_confname_tables PROC				; COMDAT

; 10307: {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 10308: #if defined(HAVE_FPATHCONF) || defined(HAVE_PATHCONF)
; 10309:     if (setup_confname_table(posix_constants_pathconf,
; 10310:                              sizeof(posix_constants_pathconf)
; 10311:                                / sizeof(struct constdef),
; 10312:                              "pathconf_names", module))
; 10313:         return -1;
; 10314: #endif
; 10315: #ifdef HAVE_CONFSTR
; 10316:     if (setup_confname_table(posix_constants_confstr,
; 10317:                              sizeof(posix_constants_confstr)
; 10318:                                / sizeof(struct constdef),
; 10319:                              "confstr_names", module))
; 10320:         return -1;
; 10321: #endif
; 10322: #ifdef HAVE_SYSCONF
; 10323:     if (setup_confname_table(posix_constants_sysconf,
; 10324:                              sizeof(posix_constants_sysconf)
; 10325:                                / sizeof(struct constdef),
; 10326:                              "sysconf_names", module))
; 10327:         return -1;
; 10328: #endif
; 10329:     return 0;

  00005	33 c0		 xor	 eax, eax

; 10330: }

  00007	c3		 ret	 0
setup_confname_tables ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@JMOKIFMN@SeCreateSymbolicLinkPrivilege?$AA@ ; `string'
EXTRN	__imp_AdjustTokenPrivileges:PROC
EXTRN	__imp_LookupPrivilegeValueA:PROC
EXTRN	__imp_OpenProcessToken:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$enable_symlink DD imagerel enable_symlink
	DD	imagerel enable_symlink+192
	DD	imagerel $unwind$enable_symlink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$enable_symlink DD 010401H
	DD	0c204H
xdata	ENDS
;	COMDAT ??_C@_0BO@JMOKIFMN@SeCreateSymbolicLinkPrivilege?$AA@
CONST	SEGMENT
??_C@_0BO@JMOKIFMN@SeCreateSymbolicLinkPrivilege?$AA@ DB 'SeCreateSymboli'
	DB	'cLinkPrivilege', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT enable_symlink
_TEXT	SEGMENT
tok$ = 48
tok_priv$ = 56
meth_idx$ = 72
luid$ = 80
tv85 = 88
enable_symlink PROC					; COMDAT

; 11507: {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 11508:     HANDLE tok;
; 11509:     TOKEN_PRIVILEGES tok_priv;
; 11510:     LUID luid;
; 11511:     int meth_idx = 0;

  00004	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR meth_idx$[rsp], 0

; 11512: 
; 11513:     if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &tok))

  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcess
  00012	4c 8d 44 24 30	 lea	 r8, QWORD PTR tok$[rsp]
  00017	ba ff 01 0f 00	 mov	 edx, 983551		; 000f01ffH
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OpenProcessToken
  00025	85 c0		 test	 eax, eax
  00027	75 07		 jne	 SHORT $LN3@enable_sym

; 11514:         return 0;

  00029	33 c0		 xor	 eax, eax
  0002b	e9 8b 00 00 00	 jmp	 $LN4@enable_sym
$LN3@enable_sym:

; 11515: 
; 11516:     if (!LookupPrivilegeValue(NULL, SE_CREATE_SYMBOLIC_LINK_NAME, &luid))

  00030	4c 8d 44 24 50	 lea	 r8, QWORD PTR luid$[rsp]
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@JMOKIFMN@SeCreateSymbolicLinkPrivilege?$AA@
  0003c	33 c9		 xor	 ecx, ecx
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LookupPrivilegeValueA
  00044	85 c0		 test	 eax, eax
  00046	75 04		 jne	 SHORT $LN2@enable_sym

; 11517:         return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 6f		 jmp	 SHORT $LN4@enable_sym
$LN2@enable_sym:

; 11518: 
; 11519:     tok_priv.PrivilegeCount = 1;

  0004c	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tok_priv$[rsp], 1

; 11520:     tok_priv.Privileges[0].Luid = luid;

  00054	48 8b 44 24 50	 mov	 rax, QWORD PTR luid$[rsp]
  00059	48 89 44 24 3c	 mov	 QWORD PTR tok_priv$[rsp+4], rax

; 11521:     tok_priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

  0005e	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tok_priv$[rsp+12], 2

; 11522: 
; 11523:     if (!AdjustTokenPrivileges(tok, FALSE, &tok_priv,
; 11524:                                sizeof(TOKEN_PRIVILEGES),
; 11525:                                (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL))

  00066	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0006f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00078	41 b9 10 00 00
	00		 mov	 r9d, 16
  0007e	4c 8d 44 24 38	 lea	 r8, QWORD PTR tok_priv$[rsp]
  00083	33 d2		 xor	 edx, edx
  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tok$[rsp]
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AdjustTokenPrivileges
  00090	85 c0		 test	 eax, eax
  00092	75 04		 jne	 SHORT $LN1@enable_sym

; 11526:         return 0;

  00094	33 c0		 xor	 eax, eax
  00096	eb 23		 jmp	 SHORT $LN4@enable_sym
$LN1@enable_sym:

; 11527: 
; 11528:     /* ERROR_NOT_ALL_ASSIGNED returned when the privilege can't be assigned. */
; 11529:     return GetLastError() == ERROR_NOT_ALL_ASSIGNED ? 0 : 1;

  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0009e	3d 14 05 00 00	 cmp	 eax, 1300		; 00000514H
  000a3	75 0a		 jne	 SHORT $LN6@enable_sym
  000a5	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
  000ad	eb 08		 jmp	 SHORT $LN7@enable_sym
$LN6@enable_sym:
  000af	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
$LN7@enable_sym:
  000b7	8b 44 24 58	 mov	 eax, DWORD PTR tv85[rsp]
$LN4@enable_sym:

; 11530: }

  000bb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000bf	c3		 ret	 0
enable_symlink ENDP
_TEXT	ENDS
PUBLIC	??_C@_08KMDECBDP@P_DETACH?$AA@			; `string'
PUBLIC	??_C@_09IIOMBIO@P_NOWAITO?$AA@			; `string'
PUBLIC	??_C@_09GOJHHCLB@P_OVERLAY?$AA@			; `string'
PUBLIC	??_C@_08FJPPPEM@P_NOWAIT?$AA@			; `string'
PUBLIC	??_C@_06LEJJHBII@P_WAIT?$AA@			; `string'
PUBLIC	??_C@_0N@OAMDEPEI@O_SEQUENTIAL?$AA@		; `string'
PUBLIC	??_C@_08CJDBDFEN@O_RANDOM?$AA@			; `string'
PUBLIC	??_C@_0M@DBIGBIL@O_TEMPORARY?$AA@		; `string'
PUBLIC	??_C@_0O@CGECGDOJ@O_SHORT_LIVED?$AA@		; `string'
PUBLIC	??_C@_0M@DNKFKCNK@O_NOINHERIT?$AA@		; `string'
PUBLIC	??_C@_06PACJLJGP@O_TEXT?$AA@			; `string'
PUBLIC	??_C@_08KPDCDMKK@O_BINARY?$AA@			; `string'
PUBLIC	??_C@_07DHLCPMFP@O_TRUNC?$AA@			; `string'
PUBLIC	??_C@_06JNLCFMNH@O_EXCL?$AA@			; `string'
PUBLIC	??_C@_07HHKHFKEI@O_CREAT?$AA@			; `string'
PUBLIC	??_C@_08OBPNNI@O_APPEND?$AA@			; `string'
PUBLIC	??_C@_06JKNDMLBB@O_RDWR?$AA@			; `string'
PUBLIC	??_C@_08IAHOMKAH@O_WRONLY?$AA@			; `string'
PUBLIC	??_C@_08HMJAECG@O_RDONLY?$AA@			; `string'
PUBLIC	??_C@_07LCOECJLF@TMP_MAX?$AA@			; `string'
PUBLIC	??_C@_04MKJLMPCP@X_OK?$AA@			; `string'
PUBLIC	??_C@_04EIMLFIPO@W_OK?$AA@			; `string'
PUBLIC	??_C@_04IACLNHIO@R_OK?$AA@			; `string'
PUBLIC	??_C@_04BFELOGMM@F_OK?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$all_ins DD imagerel all_ins
	DD	imagerel all_ins+883
	DD	imagerel $unwind$all_ins
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$all_ins DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_08KMDECBDP@P_DETACH?$AA@
CONST	SEGMENT
??_C@_08KMDECBDP@P_DETACH?$AA@ DB 'P_DETACH', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09IIOMBIO@P_NOWAITO?$AA@
CONST	SEGMENT
??_C@_09IIOMBIO@P_NOWAITO?$AA@ DB 'P_NOWAITO', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09GOJHHCLB@P_OVERLAY?$AA@
CONST	SEGMENT
??_C@_09GOJHHCLB@P_OVERLAY?$AA@ DB 'P_OVERLAY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08FJPPPEM@P_NOWAIT?$AA@
CONST	SEGMENT
??_C@_08FJPPPEM@P_NOWAIT?$AA@ DB 'P_NOWAIT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06LEJJHBII@P_WAIT?$AA@
CONST	SEGMENT
??_C@_06LEJJHBII@P_WAIT?$AA@ DB 'P_WAIT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OAMDEPEI@O_SEQUENTIAL?$AA@
CONST	SEGMENT
??_C@_0N@OAMDEPEI@O_SEQUENTIAL?$AA@ DB 'O_SEQUENTIAL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CJDBDFEN@O_RANDOM?$AA@
CONST	SEGMENT
??_C@_08CJDBDFEN@O_RANDOM?$AA@ DB 'O_RANDOM', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DBIGBIL@O_TEMPORARY?$AA@
CONST	SEGMENT
??_C@_0M@DBIGBIL@O_TEMPORARY?$AA@ DB 'O_TEMPORARY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CGECGDOJ@O_SHORT_LIVED?$AA@
CONST	SEGMENT
??_C@_0O@CGECGDOJ@O_SHORT_LIVED?$AA@ DB 'O_SHORT_LIVED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DNKFKCNK@O_NOINHERIT?$AA@
CONST	SEGMENT
??_C@_0M@DNKFKCNK@O_NOINHERIT?$AA@ DB 'O_NOINHERIT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06PACJLJGP@O_TEXT?$AA@
CONST	SEGMENT
??_C@_06PACJLJGP@O_TEXT?$AA@ DB 'O_TEXT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KPDCDMKK@O_BINARY?$AA@
CONST	SEGMENT
??_C@_08KPDCDMKK@O_BINARY?$AA@ DB 'O_BINARY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DHLCPMFP@O_TRUNC?$AA@
CONST	SEGMENT
??_C@_07DHLCPMFP@O_TRUNC?$AA@ DB 'O_TRUNC', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JNLCFMNH@O_EXCL?$AA@
CONST	SEGMENT
??_C@_06JNLCFMNH@O_EXCL?$AA@ DB 'O_EXCL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HHKHFKEI@O_CREAT?$AA@
CONST	SEGMENT
??_C@_07HHKHFKEI@O_CREAT?$AA@ DB 'O_CREAT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08OBPNNI@O_APPEND?$AA@
CONST	SEGMENT
??_C@_08OBPNNI@O_APPEND?$AA@ DB 'O_APPEND', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JKNDMLBB@O_RDWR?$AA@
CONST	SEGMENT
??_C@_06JKNDMLBB@O_RDWR?$AA@ DB 'O_RDWR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IAHOMKAH@O_WRONLY?$AA@
CONST	SEGMENT
??_C@_08IAHOMKAH@O_WRONLY?$AA@ DB 'O_WRONLY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08HMJAECG@O_RDONLY?$AA@
CONST	SEGMENT
??_C@_08HMJAECG@O_RDONLY?$AA@ DB 'O_RDONLY', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCOECJLF@TMP_MAX?$AA@
CONST	SEGMENT
??_C@_07LCOECJLF@TMP_MAX?$AA@ DB 'TMP_MAX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKJLMPCP@X_OK?$AA@
CONST	SEGMENT
??_C@_04MKJLMPCP@X_OK?$AA@ DB 'X_OK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EIMLFIPO@W_OK?$AA@
CONST	SEGMENT
??_C@_04EIMLFIPO@W_OK?$AA@ DB 'W_OK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IACLNHIO@R_OK?$AA@
CONST	SEGMENT
??_C@_04IACLNHIO@R_OK?$AA@ DB 'R_OK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04BFELOGMM@F_OK?$AA@
CONST	SEGMENT
??_C@_04BFELOGMM@F_OK?$AA@ DB 'F_OK', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT all_ins
_TEXT	SEGMENT
d$ = 48
all_ins	PROC						; COMDAT

; 11535: {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 11536: #ifdef F_OK
; 11537:     if (ins(d, "F_OK", (long)F_OK)) return -1;

  00009	45 33 c0	 xor	 r8d, r8d
  0000c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04BFELOGMM@F_OK?$AA@
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00018	e8 00 00 00 00	 call	 ins
  0001d	85 c0		 test	 eax, eax
  0001f	74 0a		 je	 SHORT $LN24@all_ins
  00021	b8 ff ff ff ff	 mov	 eax, -1
  00026	e9 43 03 00 00	 jmp	 $LN25@all_ins
$LN24@all_ins:

; 11538: #endif
; 11539: #ifdef R_OK
; 11540:     if (ins(d, "R_OK", (long)R_OK)) return -1;

  0002b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04IACLNHIO@R_OK?$AA@
  00038	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  0003d	e8 00 00 00 00	 call	 ins
  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $LN23@all_ins
  00046	b8 ff ff ff ff	 mov	 eax, -1
  0004b	e9 1e 03 00 00	 jmp	 $LN25@all_ins
$LN23@all_ins:

; 11541: #endif
; 11542: #ifdef W_OK
; 11543:     if (ins(d, "W_OK", (long)W_OK)) return -1;

  00050	41 b8 02 00 00
	00		 mov	 r8d, 2
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04EIMLFIPO@W_OK?$AA@
  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00062	e8 00 00 00 00	 call	 ins
  00067	85 c0		 test	 eax, eax
  00069	74 0a		 je	 SHORT $LN22@all_ins
  0006b	b8 ff ff ff ff	 mov	 eax, -1
  00070	e9 f9 02 00 00	 jmp	 $LN25@all_ins
$LN22@all_ins:

; 11544: #endif
; 11545: #ifdef X_OK
; 11546:     if (ins(d, "X_OK", (long)X_OK)) return -1;

  00075	41 b8 01 00 00
	00		 mov	 r8d, 1
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MKJLMPCP@X_OK?$AA@
  00082	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00087	e8 00 00 00 00	 call	 ins
  0008c	85 c0		 test	 eax, eax
  0008e	74 0a		 je	 SHORT $LN21@all_ins
  00090	b8 ff ff ff ff	 mov	 eax, -1
  00095	e9 d4 02 00 00	 jmp	 $LN25@all_ins
$LN21@all_ins:

; 11547: #endif
; 11548: #ifdef NGROUPS_MAX
; 11549:     if (ins(d, "NGROUPS_MAX", (long)NGROUPS_MAX)) return -1;
; 11550: #endif
; 11551: #ifdef TMP_MAX
; 11552:     if (ins(d, "TMP_MAX", (long)TMP_MAX)) return -1;

  0009a	41 b8 ff 7f 00
	00		 mov	 r8d, 32767		; 00007fffH
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07LCOECJLF@TMP_MAX?$AA@
  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  000ac	e8 00 00 00 00	 call	 ins
  000b1	85 c0		 test	 eax, eax
  000b3	74 0a		 je	 SHORT $LN20@all_ins
  000b5	b8 ff ff ff ff	 mov	 eax, -1
  000ba	e9 af 02 00 00	 jmp	 $LN25@all_ins
$LN20@all_ins:

; 11553: #endif
; 11554: #ifdef WCONTINUED
; 11555:     if (ins(d, "WCONTINUED", (long)WCONTINUED)) return -1;
; 11556: #endif
; 11557: #ifdef WNOHANG
; 11558:     if (ins(d, "WNOHANG", (long)WNOHANG)) return -1;
; 11559: #endif
; 11560: #ifdef WUNTRACED
; 11561:     if (ins(d, "WUNTRACED", (long)WUNTRACED)) return -1;
; 11562: #endif
; 11563: #ifdef O_RDONLY
; 11564:     if (ins(d, "O_RDONLY", (long)O_RDONLY)) return -1;

  000bf	45 33 c0	 xor	 r8d, r8d
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08HMJAECG@O_RDONLY?$AA@
  000c9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  000ce	e8 00 00 00 00	 call	 ins
  000d3	85 c0		 test	 eax, eax
  000d5	74 0a		 je	 SHORT $LN19@all_ins
  000d7	b8 ff ff ff ff	 mov	 eax, -1
  000dc	e9 8d 02 00 00	 jmp	 $LN25@all_ins
$LN19@all_ins:

; 11565: #endif
; 11566: #ifdef O_WRONLY
; 11567:     if (ins(d, "O_WRONLY", (long)O_WRONLY)) return -1;

  000e1	41 b8 01 00 00
	00		 mov	 r8d, 1
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08IAHOMKAH@O_WRONLY?$AA@
  000ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  000f3	e8 00 00 00 00	 call	 ins
  000f8	85 c0		 test	 eax, eax
  000fa	74 0a		 je	 SHORT $LN18@all_ins
  000fc	b8 ff ff ff ff	 mov	 eax, -1
  00101	e9 68 02 00 00	 jmp	 $LN25@all_ins
$LN18@all_ins:

; 11568: #endif
; 11569: #ifdef O_RDWR
; 11570:     if (ins(d, "O_RDWR", (long)O_RDWR)) return -1;

  00106	41 b8 02 00 00
	00		 mov	 r8d, 2
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JKNDMLBB@O_RDWR?$AA@
  00113	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00118	e8 00 00 00 00	 call	 ins
  0011d	85 c0		 test	 eax, eax
  0011f	74 0a		 je	 SHORT $LN17@all_ins
  00121	b8 ff ff ff ff	 mov	 eax, -1
  00126	e9 43 02 00 00	 jmp	 $LN25@all_ins
$LN17@all_ins:

; 11571: #endif
; 11572: #ifdef O_NDELAY
; 11573:     if (ins(d, "O_NDELAY", (long)O_NDELAY)) return -1;
; 11574: #endif
; 11575: #ifdef O_NONBLOCK
; 11576:     if (ins(d, "O_NONBLOCK", (long)O_NONBLOCK)) return -1;
; 11577: #endif
; 11578: #ifdef O_APPEND
; 11579:     if (ins(d, "O_APPEND", (long)O_APPEND)) return -1;

  0012b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00131	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OBPNNI@O_APPEND?$AA@
  00138	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  0013d	e8 00 00 00 00	 call	 ins
  00142	85 c0		 test	 eax, eax
  00144	74 0a		 je	 SHORT $LN16@all_ins
  00146	b8 ff ff ff ff	 mov	 eax, -1
  0014b	e9 1e 02 00 00	 jmp	 $LN25@all_ins
$LN16@all_ins:

; 11580: #endif
; 11581: #ifdef O_DSYNC
; 11582:     if (ins(d, "O_DSYNC", (long)O_DSYNC)) return -1;
; 11583: #endif
; 11584: #ifdef O_RSYNC
; 11585:     if (ins(d, "O_RSYNC", (long)O_RSYNC)) return -1;
; 11586: #endif
; 11587: #ifdef O_SYNC
; 11588:     if (ins(d, "O_SYNC", (long)O_SYNC)) return -1;
; 11589: #endif
; 11590: #ifdef O_NOCTTY
; 11591:     if (ins(d, "O_NOCTTY", (long)O_NOCTTY)) return -1;
; 11592: #endif
; 11593: #ifdef O_CREAT
; 11594:     if (ins(d, "O_CREAT", (long)O_CREAT)) return -1;

  00150	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07HHKHFKEI@O_CREAT?$AA@
  0015d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00162	e8 00 00 00 00	 call	 ins
  00167	85 c0		 test	 eax, eax
  00169	74 0a		 je	 SHORT $LN15@all_ins
  0016b	b8 ff ff ff ff	 mov	 eax, -1
  00170	e9 f9 01 00 00	 jmp	 $LN25@all_ins
$LN15@all_ins:

; 11595: #endif
; 11596: #ifdef O_EXCL
; 11597:     if (ins(d, "O_EXCL", (long)O_EXCL)) return -1;

  00175	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  0017b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JNLCFMNH@O_EXCL?$AA@
  00182	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00187	e8 00 00 00 00	 call	 ins
  0018c	85 c0		 test	 eax, eax
  0018e	74 0a		 je	 SHORT $LN14@all_ins
  00190	b8 ff ff ff ff	 mov	 eax, -1
  00195	e9 d4 01 00 00	 jmp	 $LN25@all_ins
$LN14@all_ins:

; 11598: #endif
; 11599: #ifdef O_TRUNC
; 11600:     if (ins(d, "O_TRUNC", (long)O_TRUNC)) return -1;

  0019a	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07DHLCPMFP@O_TRUNC?$AA@
  001a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  001ac	e8 00 00 00 00	 call	 ins
  001b1	85 c0		 test	 eax, eax
  001b3	74 0a		 je	 SHORT $LN13@all_ins
  001b5	b8 ff ff ff ff	 mov	 eax, -1
  001ba	e9 af 01 00 00	 jmp	 $LN25@all_ins
$LN13@all_ins:

; 11601: #endif
; 11602: #ifdef O_BINARY
; 11603:     if (ins(d, "O_BINARY", (long)O_BINARY)) return -1;

  001bf	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08KPDCDMKK@O_BINARY?$AA@
  001cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  001d1	e8 00 00 00 00	 call	 ins
  001d6	85 c0		 test	 eax, eax
  001d8	74 0a		 je	 SHORT $LN12@all_ins
  001da	b8 ff ff ff ff	 mov	 eax, -1
  001df	e9 8a 01 00 00	 jmp	 $LN25@all_ins
$LN12@all_ins:

; 11604: #endif
; 11605: #ifdef O_TEXT
; 11606:     if (ins(d, "O_TEXT", (long)O_TEXT)) return -1;

  001e4	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  001ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06PACJLJGP@O_TEXT?$AA@
  001f1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  001f6	e8 00 00 00 00	 call	 ins
  001fb	85 c0		 test	 eax, eax
  001fd	74 0a		 je	 SHORT $LN11@all_ins
  001ff	b8 ff ff ff ff	 mov	 eax, -1
  00204	e9 65 01 00 00	 jmp	 $LN25@all_ins
$LN11@all_ins:

; 11607: #endif
; 11608: #ifdef O_XATTR
; 11609:     if (ins(d, "O_XATTR", (long)O_XATTR)) return -1;
; 11610: #endif
; 11611: #ifdef O_LARGEFILE
; 11612:     if (ins(d, "O_LARGEFILE", (long)O_LARGEFILE)) return -1;
; 11613: #endif
; 11614: #ifdef O_SHLOCK
; 11615:     if (ins(d, "O_SHLOCK", (long)O_SHLOCK)) return -1;
; 11616: #endif
; 11617: #ifdef O_EXLOCK
; 11618:     if (ins(d, "O_EXLOCK", (long)O_EXLOCK)) return -1;
; 11619: #endif
; 11620: #ifdef O_EXEC
; 11621:     if (ins(d, "O_EXEC", (long)O_EXEC)) return -1;
; 11622: #endif
; 11623: #ifdef O_SEARCH
; 11624:     if (ins(d, "O_SEARCH", (long)O_SEARCH)) return -1;
; 11625: #endif
; 11626: #ifdef O_TTY_INIT
; 11627:     if (ins(d, "O_TTY_INIT", (long)O_TTY_INIT)) return -1;
; 11628: #endif
; 11629: #ifdef PRIO_PROCESS
; 11630:     if (ins(d, "PRIO_PROCESS", (long)PRIO_PROCESS)) return -1;
; 11631: #endif
; 11632: #ifdef PRIO_PGRP
; 11633:     if (ins(d, "PRIO_PGRP", (long)PRIO_PGRP)) return -1;
; 11634: #endif
; 11635: #ifdef PRIO_USER
; 11636:     if (ins(d, "PRIO_USER", (long)PRIO_USER)) return -1;
; 11637: #endif
; 11638: #ifdef O_CLOEXEC
; 11639:     if (ins(d, "O_CLOEXEC", (long)O_CLOEXEC)) return -1;
; 11640: #endif
; 11641: #ifdef O_ACCMODE
; 11642:     if (ins(d, "O_ACCMODE", (long)O_ACCMODE)) return -1;
; 11643: #endif
; 11644: 
; 11645: 
; 11646: #ifdef SEEK_HOLE
; 11647:     if (ins(d, "SEEK_HOLE", (long)SEEK_HOLE)) return -1;
; 11648: #endif
; 11649: #ifdef SEEK_DATA
; 11650:     if (ins(d, "SEEK_DATA", (long)SEEK_DATA)) return -1;
; 11651: #endif
; 11652: 
; 11653: /* MS Windows */
; 11654: #ifdef O_NOINHERIT
; 11655:     /* Don't inherit in child processes. */
; 11656:     if (ins(d, "O_NOINHERIT", (long)O_NOINHERIT)) return -1;

  00209	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0020f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@DNKFKCNK@O_NOINHERIT?$AA@
  00216	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  0021b	e8 00 00 00 00	 call	 ins
  00220	85 c0		 test	 eax, eax
  00222	74 0a		 je	 SHORT $LN10@all_ins
  00224	b8 ff ff ff ff	 mov	 eax, -1
  00229	e9 40 01 00 00	 jmp	 $LN25@all_ins
$LN10@all_ins:

; 11657: #endif
; 11658: #ifdef _O_SHORT_LIVED
; 11659:     /* Optimize for short life (keep in memory). */
; 11660:     /* MS forgot to define this one with a non-underscore form too. */
; 11661:     if (ins(d, "O_SHORT_LIVED", (long)_O_SHORT_LIVED)) return -1;

  0022e	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00234	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@CGECGDOJ@O_SHORT_LIVED?$AA@
  0023b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00240	e8 00 00 00 00	 call	 ins
  00245	85 c0		 test	 eax, eax
  00247	74 0a		 je	 SHORT $LN9@all_ins
  00249	b8 ff ff ff ff	 mov	 eax, -1
  0024e	e9 1b 01 00 00	 jmp	 $LN25@all_ins
$LN9@all_ins:

; 11662: #endif
; 11663: #ifdef O_TEMPORARY
; 11664:     /* Automatically delete when last handle is closed. */
; 11665:     if (ins(d, "O_TEMPORARY", (long)O_TEMPORARY)) return -1;

  00253	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@DBIGBIL@O_TEMPORARY?$AA@
  00260	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00265	e8 00 00 00 00	 call	 ins
  0026a	85 c0		 test	 eax, eax
  0026c	74 0a		 je	 SHORT $LN8@all_ins
  0026e	b8 ff ff ff ff	 mov	 eax, -1
  00273	e9 f6 00 00 00	 jmp	 $LN25@all_ins
$LN8@all_ins:

; 11666: #endif
; 11667: #ifdef O_RANDOM
; 11668:     /* Optimize for random access. */
; 11669:     if (ins(d, "O_RANDOM", (long)O_RANDOM)) return -1;

  00278	41 b8 10 00 00
	00		 mov	 r8d, 16
  0027e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08CJDBDFEN@O_RANDOM?$AA@
  00285	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  0028a	e8 00 00 00 00	 call	 ins
  0028f	85 c0		 test	 eax, eax
  00291	74 0a		 je	 SHORT $LN7@all_ins
  00293	b8 ff ff ff ff	 mov	 eax, -1
  00298	e9 d1 00 00 00	 jmp	 $LN25@all_ins
$LN7@all_ins:

; 11670: #endif
; 11671: #ifdef O_SEQUENTIAL
; 11672:     /* Optimize for sequential access. */
; 11673:     if (ins(d, "O_SEQUENTIAL", (long)O_SEQUENTIAL)) return -1;

  0029d	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  002a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@OAMDEPEI@O_SEQUENTIAL?$AA@
  002aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  002af	e8 00 00 00 00	 call	 ins
  002b4	85 c0		 test	 eax, eax
  002b6	74 0a		 je	 SHORT $LN6@all_ins
  002b8	b8 ff ff ff ff	 mov	 eax, -1
  002bd	e9 ac 00 00 00	 jmp	 $LN25@all_ins
$LN6@all_ins:

; 11674: #endif
; 11675: 
; 11676: /* GNU extensions. */
; 11677: #ifdef O_ASYNC
; 11678:     /* Send a SIGIO signal whenever input or output
; 11679:        becomes available on file descriptor */
; 11680:     if (ins(d, "O_ASYNC", (long)O_ASYNC)) return -1;
; 11681: #endif
; 11682: #ifdef O_DIRECT
; 11683:     /* Direct disk access. */
; 11684:     if (ins(d, "O_DIRECT", (long)O_DIRECT)) return -1;
; 11685: #endif
; 11686: #ifdef O_DIRECTORY
; 11687:     /* Must be a directory.      */
; 11688:     if (ins(d, "O_DIRECTORY", (long)O_DIRECTORY)) return -1;
; 11689: #endif
; 11690: #ifdef O_NOFOLLOW
; 11691:     /* Do not follow links.      */
; 11692:     if (ins(d, "O_NOFOLLOW", (long)O_NOFOLLOW)) return -1;
; 11693: #endif
; 11694: #ifdef O_NOLINKS
; 11695:     /* Fails if link count of the named file is greater than 1 */
; 11696:     if (ins(d, "O_NOLINKS", (long)O_NOLINKS)) return -1;
; 11697: #endif
; 11698: #ifdef O_NOATIME
; 11699:     /* Do not update the access time. */
; 11700:     if (ins(d, "O_NOATIME", (long)O_NOATIME)) return -1;
; 11701: #endif
; 11702: 
; 11703:     /* These come from sysexits.h */
; 11704: #ifdef EX_OK
; 11705:     if (ins(d, "EX_OK", (long)EX_OK)) return -1;
; 11706: #endif /* EX_OK */
; 11707: #ifdef EX_USAGE
; 11708:     if (ins(d, "EX_USAGE", (long)EX_USAGE)) return -1;
; 11709: #endif /* EX_USAGE */
; 11710: #ifdef EX_DATAERR
; 11711:     if (ins(d, "EX_DATAERR", (long)EX_DATAERR)) return -1;
; 11712: #endif /* EX_DATAERR */
; 11713: #ifdef EX_NOINPUT
; 11714:     if (ins(d, "EX_NOINPUT", (long)EX_NOINPUT)) return -1;
; 11715: #endif /* EX_NOINPUT */
; 11716: #ifdef EX_NOUSER
; 11717:     if (ins(d, "EX_NOUSER", (long)EX_NOUSER)) return -1;
; 11718: #endif /* EX_NOUSER */
; 11719: #ifdef EX_NOHOST
; 11720:     if (ins(d, "EX_NOHOST", (long)EX_NOHOST)) return -1;
; 11721: #endif /* EX_NOHOST */
; 11722: #ifdef EX_UNAVAILABLE
; 11723:     if (ins(d, "EX_UNAVAILABLE", (long)EX_UNAVAILABLE)) return -1;
; 11724: #endif /* EX_UNAVAILABLE */
; 11725: #ifdef EX_SOFTWARE
; 11726:     if (ins(d, "EX_SOFTWARE", (long)EX_SOFTWARE)) return -1;
; 11727: #endif /* EX_SOFTWARE */
; 11728: #ifdef EX_OSERR
; 11729:     if (ins(d, "EX_OSERR", (long)EX_OSERR)) return -1;
; 11730: #endif /* EX_OSERR */
; 11731: #ifdef EX_OSFILE
; 11732:     if (ins(d, "EX_OSFILE", (long)EX_OSFILE)) return -1;
; 11733: #endif /* EX_OSFILE */
; 11734: #ifdef EX_CANTCREAT
; 11735:     if (ins(d, "EX_CANTCREAT", (long)EX_CANTCREAT)) return -1;
; 11736: #endif /* EX_CANTCREAT */
; 11737: #ifdef EX_IOERR
; 11738:     if (ins(d, "EX_IOERR", (long)EX_IOERR)) return -1;
; 11739: #endif /* EX_IOERR */
; 11740: #ifdef EX_TEMPFAIL
; 11741:     if (ins(d, "EX_TEMPFAIL", (long)EX_TEMPFAIL)) return -1;
; 11742: #endif /* EX_TEMPFAIL */
; 11743: #ifdef EX_PROTOCOL
; 11744:     if (ins(d, "EX_PROTOCOL", (long)EX_PROTOCOL)) return -1;
; 11745: #endif /* EX_PROTOCOL */
; 11746: #ifdef EX_NOPERM
; 11747:     if (ins(d, "EX_NOPERM", (long)EX_NOPERM)) return -1;
; 11748: #endif /* EX_NOPERM */
; 11749: #ifdef EX_CONFIG
; 11750:     if (ins(d, "EX_CONFIG", (long)EX_CONFIG)) return -1;
; 11751: #endif /* EX_CONFIG */
; 11752: #ifdef EX_NOTFOUND
; 11753:     if (ins(d, "EX_NOTFOUND", (long)EX_NOTFOUND)) return -1;
; 11754: #endif /* EX_NOTFOUND */
; 11755: 
; 11756:     /* statvfs */
; 11757: #ifdef ST_RDONLY
; 11758:     if (ins(d, "ST_RDONLY", (long)ST_RDONLY)) return -1;
; 11759: #endif /* ST_RDONLY */
; 11760: #ifdef ST_NOSUID
; 11761:     if (ins(d, "ST_NOSUID", (long)ST_NOSUID)) return -1;
; 11762: #endif /* ST_NOSUID */
; 11763: 
; 11764:     /* FreeBSD sendfile() constants */
; 11765: #ifdef SF_NODISKIO
; 11766:     if (ins(d, "SF_NODISKIO", (long)SF_NODISKIO)) return -1;
; 11767: #endif
; 11768: #ifdef SF_MNOWAIT
; 11769:     if (ins(d, "SF_MNOWAIT", (long)SF_MNOWAIT)) return -1;
; 11770: #endif
; 11771: #ifdef SF_SYNC
; 11772:     if (ins(d, "SF_SYNC", (long)SF_SYNC)) return -1;
; 11773: #endif
; 11774: 
; 11775:     /* constants for posix_fadvise */
; 11776: #ifdef POSIX_FADV_NORMAL
; 11777:     if (ins(d, "POSIX_FADV_NORMAL", (long)POSIX_FADV_NORMAL)) return -1;
; 11778: #endif
; 11779: #ifdef POSIX_FADV_SEQUENTIAL
; 11780:     if (ins(d, "POSIX_FADV_SEQUENTIAL", (long)POSIX_FADV_SEQUENTIAL)) return -1;
; 11781: #endif
; 11782: #ifdef POSIX_FADV_RANDOM
; 11783:     if (ins(d, "POSIX_FADV_RANDOM", (long)POSIX_FADV_RANDOM)) return -1;
; 11784: #endif
; 11785: #ifdef POSIX_FADV_NOREUSE
; 11786:     if (ins(d, "POSIX_FADV_NOREUSE", (long)POSIX_FADV_NOREUSE)) return -1;
; 11787: #endif
; 11788: #ifdef POSIX_FADV_WILLNEED
; 11789:     if (ins(d, "POSIX_FADV_WILLNEED", (long)POSIX_FADV_WILLNEED)) return -1;
; 11790: #endif
; 11791: #ifdef POSIX_FADV_DONTNEED
; 11792:     if (ins(d, "POSIX_FADV_DONTNEED", (long)POSIX_FADV_DONTNEED)) return -1;
; 11793: #endif
; 11794: 
; 11795:     /* constants for waitid */
; 11796: #if defined(HAVE_SYS_WAIT_H) && defined(HAVE_WAITID)
; 11797:     if (ins(d, "P_PID", (long)P_PID)) return -1;
; 11798:     if (ins(d, "P_PGID", (long)P_PGID)) return -1;
; 11799:     if (ins(d, "P_ALL", (long)P_ALL)) return -1;
; 11800: #endif
; 11801: #ifdef WEXITED
; 11802:     if (ins(d, "WEXITED", (long)WEXITED)) return -1;
; 11803: #endif
; 11804: #ifdef WNOWAIT
; 11805:     if (ins(d, "WNOWAIT", (long)WNOWAIT)) return -1;
; 11806: #endif
; 11807: #ifdef WSTOPPED
; 11808:     if (ins(d, "WSTOPPED", (long)WSTOPPED)) return -1;
; 11809: #endif
; 11810: #ifdef CLD_EXITED
; 11811:     if (ins(d, "CLD_EXITED", (long)CLD_EXITED)) return -1;
; 11812: #endif
; 11813: #ifdef CLD_DUMPED
; 11814:     if (ins(d, "CLD_DUMPED", (long)CLD_DUMPED)) return -1;
; 11815: #endif
; 11816: #ifdef CLD_TRAPPED
; 11817:     if (ins(d, "CLD_TRAPPED", (long)CLD_TRAPPED)) return -1;
; 11818: #endif
; 11819: #ifdef CLD_CONTINUED
; 11820:     if (ins(d, "CLD_CONTINUED", (long)CLD_CONTINUED)) return -1;
; 11821: #endif
; 11822: 
; 11823:     /* constants for lockf */
; 11824: #ifdef F_LOCK
; 11825:     if (ins(d, "F_LOCK", (long)F_LOCK)) return -1;
; 11826: #endif
; 11827: #ifdef F_TLOCK
; 11828:     if (ins(d, "F_TLOCK", (long)F_TLOCK)) return -1;
; 11829: #endif
; 11830: #ifdef F_ULOCK
; 11831:     if (ins(d, "F_ULOCK", (long)F_ULOCK)) return -1;
; 11832: #endif
; 11833: #ifdef F_TEST
; 11834:     if (ins(d, "F_TEST", (long)F_TEST)) return -1;
; 11835: #endif
; 11836: 
; 11837: #ifdef HAVE_SPAWNV
; 11838: #if defined(PYOS_OS2) && defined(PYCC_GCC)
; 11839:     if (ins(d, "P_WAIT", (long)P_WAIT)) return -1;
; 11840:     if (ins(d, "P_NOWAIT", (long)P_NOWAIT)) return -1;
; 11841:     if (ins(d, "P_OVERLAY", (long)P_OVERLAY)) return -1;
; 11842:     if (ins(d, "P_DEBUG", (long)P_DEBUG)) return -1;
; 11843:     if (ins(d, "P_SESSION", (long)P_SESSION)) return -1;
; 11844:     if (ins(d, "P_DETACH", (long)P_DETACH)) return -1;
; 11845:     if (ins(d, "P_PM", (long)P_PM)) return -1;
; 11846:     if (ins(d, "P_DEFAULT", (long)P_DEFAULT)) return -1;
; 11847:     if (ins(d, "P_MINIMIZE", (long)P_MINIMIZE)) return -1;
; 11848:     if (ins(d, "P_MAXIMIZE", (long)P_MAXIMIZE)) return -1;
; 11849:     if (ins(d, "P_FULLSCREEN", (long)P_FULLSCREEN)) return -1;
; 11850:     if (ins(d, "P_WINDOWED", (long)P_WINDOWED)) return -1;
; 11851:     if (ins(d, "P_FOREGROUND", (long)P_FOREGROUND)) return -1;
; 11852:     if (ins(d, "P_BACKGROUND", (long)P_BACKGROUND)) return -1;
; 11853:     if (ins(d, "P_NOCLOSE", (long)P_NOCLOSE)) return -1;
; 11854:     if (ins(d, "P_NOSESSION", (long)P_NOSESSION)) return -1;
; 11855:     if (ins(d, "P_QUOTE", (long)P_QUOTE)) return -1;
; 11856:     if (ins(d, "P_TILDE", (long)P_TILDE)) return -1;
; 11857:     if (ins(d, "P_UNRELATED", (long)P_UNRELATED)) return -1;
; 11858:     if (ins(d, "P_DEBUGDESC", (long)P_DEBUGDESC)) return -1;
; 11859: #else
; 11860:     if (ins(d, "P_WAIT", (long)_P_WAIT)) return -1;

  002c2	45 33 c0	 xor	 r8d, r8d
  002c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06LEJJHBII@P_WAIT?$AA@
  002cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  002d1	e8 00 00 00 00	 call	 ins
  002d6	85 c0		 test	 eax, eax
  002d8	74 0a		 je	 SHORT $LN5@all_ins
  002da	b8 ff ff ff ff	 mov	 eax, -1
  002df	e9 8a 00 00 00	 jmp	 $LN25@all_ins
$LN5@all_ins:

; 11861:     if (ins(d, "P_NOWAIT", (long)_P_NOWAIT)) return -1;

  002e4	41 b8 01 00 00
	00		 mov	 r8d, 1
  002ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08FJPPPEM@P_NOWAIT?$AA@
  002f1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  002f6	e8 00 00 00 00	 call	 ins
  002fb	85 c0		 test	 eax, eax
  002fd	74 07		 je	 SHORT $LN4@all_ins
  002ff	b8 ff ff ff ff	 mov	 eax, -1
  00304	eb 68		 jmp	 SHORT $LN25@all_ins
$LN4@all_ins:

; 11862:     if (ins(d, "P_OVERLAY", (long)_OLD_P_OVERLAY)) return -1;

  00306	41 b8 02 00 00
	00		 mov	 r8d, 2
  0030c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09GOJHHCLB@P_OVERLAY?$AA@
  00313	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  00318	e8 00 00 00 00	 call	 ins
  0031d	85 c0		 test	 eax, eax
  0031f	74 07		 je	 SHORT $LN3@all_ins
  00321	b8 ff ff ff ff	 mov	 eax, -1
  00326	eb 46		 jmp	 SHORT $LN25@all_ins
$LN3@all_ins:

; 11863:     if (ins(d, "P_NOWAITO", (long)_P_NOWAITO)) return -1;

  00328	41 b8 03 00 00
	00		 mov	 r8d, 3
  0032e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09IIOMBIO@P_NOWAITO?$AA@
  00335	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  0033a	e8 00 00 00 00	 call	 ins
  0033f	85 c0		 test	 eax, eax
  00341	74 07		 je	 SHORT $LN2@all_ins
  00343	b8 ff ff ff ff	 mov	 eax, -1
  00348	eb 24		 jmp	 SHORT $LN25@all_ins
$LN2@all_ins:

; 11864:     if (ins(d, "P_DETACH", (long)_P_DETACH)) return -1;

  0034a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00350	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08KMDECBDP@P_DETACH?$AA@
  00357	48 8b 4c 24 30	 mov	 rcx, QWORD PTR d$[rsp]
  0035c	e8 00 00 00 00	 call	 ins
  00361	85 c0		 test	 eax, eax
  00363	74 07		 je	 SHORT $LN1@all_ins
  00365	b8 ff ff ff ff	 mov	 eax, -1
  0036a	eb 02		 jmp	 SHORT $LN25@all_ins
$LN1@all_ins:

; 11865: #endif
; 11866: #endif
; 11867: 
; 11868: #ifdef HAVE_SCHED_H
; 11869:     if (ins(d, "SCHED_OTHER", (long)SCHED_OTHER)) return -1;
; 11870:     if (ins(d, "SCHED_FIFO", (long)SCHED_FIFO)) return -1;
; 11871:     if (ins(d, "SCHED_RR", (long)SCHED_RR)) return -1;
; 11872: #ifdef SCHED_SPORADIC
; 11873:     if (ins(d, "SCHED_SPORADIC", (long)SCHED_SPORADIC)) return -1;
; 11874: #endif
; 11875: #ifdef SCHED_BATCH
; 11876:     if (ins(d, "SCHED_BATCH", (long)SCHED_BATCH)) return -1;
; 11877: #endif
; 11878: #ifdef SCHED_IDLE
; 11879:     if (ins(d, "SCHED_IDLE", (long)SCHED_IDLE)) return -1;
; 11880: #endif
; 11881: #ifdef SCHED_RESET_ON_FORK
; 11882:     if (ins(d, "SCHED_RESET_ON_FORK", (long)SCHED_RESET_ON_FORK)) return -1;
; 11883: #endif
; 11884: #ifdef SCHED_SYS
; 11885:     if (ins(d, "SCHED_SYS", (long)SCHED_SYS)) return -1;
; 11886: #endif
; 11887: #ifdef SCHED_IA
; 11888:     if (ins(d, "SCHED_IA", (long)SCHED_IA)) return -1;
; 11889: #endif
; 11890: #ifdef SCHED_FSS
; 11891:     if (ins(d, "SCHED_FSS", (long)SCHED_FSS)) return -1;
; 11892: #endif
; 11893: #ifdef SCHED_FX
; 11894:     if (ins(d, "SCHED_FX", (long)SCHED_FSS)) return -1;
; 11895: #endif
; 11896: #endif
; 11897: 
; 11898: #ifdef USE_XATTRS
; 11899:     if (ins(d, "XATTR_CREATE", (long)XATTR_CREATE)) return -1;
; 11900:     if (ins(d, "XATTR_REPLACE", (long)XATTR_REPLACE)) return -1;
; 11901:     if (ins(d, "XATTR_SIZE_MAX", (long)XATTR_SIZE_MAX)) return -1;
; 11902: #endif
; 11903: 
; 11904: #ifdef RTLD_LAZY
; 11905:     if (PyModule_AddIntMacro(d, RTLD_LAZY)) return -1;
; 11906: #endif
; 11907: #ifdef RTLD_NOW
; 11908:     if (PyModule_AddIntMacro(d, RTLD_NOW)) return -1;
; 11909: #endif
; 11910: #ifdef RTLD_GLOBAL
; 11911:     if (PyModule_AddIntMacro(d, RTLD_GLOBAL)) return -1;
; 11912: #endif
; 11913: #ifdef RTLD_LOCAL
; 11914:     if (PyModule_AddIntMacro(d, RTLD_LOCAL)) return -1;
; 11915: #endif
; 11916: #ifdef RTLD_NODELETE
; 11917:     if (PyModule_AddIntMacro(d, RTLD_NODELETE)) return -1;
; 11918: #endif
; 11919: #ifdef RTLD_NOLOAD
; 11920:     if (PyModule_AddIntMacro(d, RTLD_NOLOAD)) return -1;
; 11921: #endif
; 11922: #ifdef RTLD_DEEPBIND
; 11923:     if (PyModule_AddIntMacro(d, RTLD_DEEPBIND)) return -1;
; 11924: #endif
; 11925: 
; 11926: #if defined(PYOS_OS2)
; 11927:     if (insertvalues(d)) return -1;
; 11928: #endif
; 11929:     return 0;

  0036c	33 c0		 xor	 eax, eax
$LN25@all_ins:

; 11930: }

  0036e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00372	c3		 ret	 0
all_ins	ENDP
_TEXT	ENDS
EXTRN	PyModule_AddIntConstant:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ins DD	imagerel ins
	DD	imagerel ins+44
	DD	imagerel $unwind$ins
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ins DD	011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ins
_TEXT	SEGMENT
module$ = 48
symbol$ = 56
value$ = 64
ins	PROC						; COMDAT

; 11447: {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 11448:     return PyModule_AddIntConstant(module, symbol, value);

  00013	44 8b 44 24 40	 mov	 r8d, DWORD PTR value$[rsp]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR symbol$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR module$[rsp]
  00022	e8 00 00 00 00	 call	 PyModule_AddIntConstant

; 11449: }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
ins	ENDP
_TEXT	ENDS
END
