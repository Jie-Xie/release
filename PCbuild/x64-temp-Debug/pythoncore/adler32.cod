; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	adler32
;	COMDAT pdata
; File c:\src\pyparallel\modules\zlib\adler32.c
pdata	SEGMENT
$pdata$adler32 DD imagerel $LN21
	DD	imagerel $LN21+1786
	DD	imagerel $unwind$adler32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32 DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT adler32
_TEXT	SEGMENT
n$ = 0
sum2$ = 4
adler$ = 32
buf$ = 40
len$ = 48
adler32	PROC						; COMDAT

; 64   : {

$LN21:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 65   :     unsigned long sum2;
; 66   :     unsigned n;
; 67   : 
; 68   :     /* split Adler-32 into component sums */
; 69   :     sum2 = (adler >> 16) & 0xffff;

  00012	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00016	c1 e8 10	 shr	 eax, 16
  00019	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0001e	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 70   :     adler &= 0xffff;

  00022	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00026	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002b	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax

; 71   : 
; 72   :     /* in case user likes doing a byte at a time, keep it fast */
; 73   :     if (len == 1) {

  0002f	83 7c 24 30 01	 cmp	 DWORD PTR len$[rsp], 1
  00034	75 66		 jne	 SHORT $LN18@adler32

; 74   :         adler += buf[0];

  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003e	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00042	03 c8		 add	 ecx, eax
  00044	8b c1		 mov	 eax, ecx
  00046	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax

; 75   :         if (adler >= BASE)

  0004a	81 7c 24 20 f1
	ff 00 00	 cmp	 DWORD PTR adler$[rsp], 65521 ; 0000fff1H
  00052	72 0d		 jb	 SHORT $LN17@adler32

; 76   :             adler -= BASE;

  00054	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00058	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  0005d	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
$LN17@adler32:

; 77   :         sum2 += adler;

  00061	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00065	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00069	03 c8		 add	 ecx, eax
  0006b	8b c1		 mov	 eax, ecx
  0006d	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 78   :         if (sum2 >= BASE)

  00071	81 7c 24 04 f1
	ff 00 00	 cmp	 DWORD PTR sum2$[rsp], 65521 ; 0000fff1H
  00079	72 0d		 jb	 SHORT $LN16@adler32

; 79   :             sum2 -= BASE;

  0007b	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0007f	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  00084	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
$LN16@adler32:

; 80   :         return adler | (sum2 << 16);

  00088	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0008c	c1 e0 10	 shl	 eax, 16
  0008f	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00093	0b c8		 or	 ecx, eax
  00095	8b c1		 mov	 eax, ecx
  00097	e9 59 06 00 00	 jmp	 $LN19@adler32
$LN18@adler32:

; 81   :     }
; 82   : 
; 83   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 84   :     if (buf == Z_NULL)

  0009c	48 83 7c 24 28
	00		 cmp	 QWORD PTR buf$[rsp], 0
  000a2	75 0a		 jne	 SHORT $LN15@adler32

; 85   :         return 1L;

  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	e9 47 06 00 00	 jmp	 $LN19@adler32
$LN15@adler32:

; 86   : 
; 87   :     /* in case short lengths are provided, keep it somewhat fast */
; 88   :     if (len < 16) {

  000ae	83 7c 24 30 10	 cmp	 DWORD PTR len$[rsp], 16
  000b3	0f 83 83 00 00
	00		 jae	 $LN14@adler32
$LN13@adler32:

; 89   :         while (len--) {

  000b9	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  000bd	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000c1	ff c9		 dec	 ecx
  000c3	89 4c 24 30	 mov	 DWORD PTR len$[rsp], ecx
  000c7	85 c0		 test	 eax, eax
  000c9	74 33		 je	 SHORT $LN12@adler32

; 90   :             adler += *buf++;

  000cb	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  000d0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d3	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  000d7	03 c8		 add	 ecx, eax
  000d9	8b c1		 mov	 eax, ecx
  000db	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  000df	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  000e4	48 ff c0	 inc	 rax
  000e7	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 91   :             sum2 += adler;

  000ec	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  000f0	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  000f4	03 c8		 add	 ecx, eax
  000f6	8b c1		 mov	 eax, ecx
  000f8	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 92   :         }

  000fc	eb bb		 jmp	 SHORT $LN13@adler32
$LN12@adler32:

; 93   :         if (adler >= BASE)

  000fe	81 7c 24 20 f1
	ff 00 00	 cmp	 DWORD PTR adler$[rsp], 65521 ; 0000fff1H
  00106	72 0d		 jb	 SHORT $LN11@adler32

; 94   :             adler -= BASE;

  00108	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0010c	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  00111	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
$LN11@adler32:

; 95   :         MOD4(sum2);             /* only added so many BASE's */

  00115	33 d2		 xor	 edx, edx
  00117	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0011b	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00120	f7 f1		 div	 ecx
  00122	8b c2		 mov	 eax, edx
  00124	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 96   :         return adler | (sum2 << 16);

  00128	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0012c	c1 e0 10	 shl	 eax, 16
  0012f	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00133	0b c8		 or	 ecx, eax
  00135	8b c1		 mov	 eax, ecx
  00137	e9 b9 05 00 00	 jmp	 $LN19@adler32
$LN14@adler32:
$LN10@adler32:

; 97   :     }
; 98   : 
; 99   :     /* do length NMAX blocks -- requires just one modulo operation */
; 100  :     while (len >= NMAX) {

  0013c	81 7c 24 30 b0
	15 00 00	 cmp	 DWORD PTR len$[rsp], 5552 ; 000015b0H
  00144	0f 82 ae 02 00
	00		 jb	 $LN9@adler32

; 101  :         len -= NMAX;

  0014a	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0014e	2d b0 15 00 00	 sub	 eax, 5552		; 000015b0H
  00153	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 102  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  00157	c7 04 24 5b 01
	00 00		 mov	 DWORD PTR n$[rsp], 347	; 0000015bH
$LN8@adler32:

; 103  :         do {
; 104  :             DO16(buf);          /* 16 sums unrolled */

  0015e	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00163	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00166	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0016a	03 c8		 add	 ecx, eax
  0016c	8b c1		 mov	 eax, ecx
  0016e	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00172	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00176	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  0017a	03 c8		 add	 ecx, eax
  0017c	8b c1		 mov	 eax, ecx
  0017e	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00182	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00187	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0018b	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0018f	03 c8		 add	 ecx, eax
  00191	8b c1		 mov	 eax, ecx
  00193	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00197	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0019b	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  0019f	03 c8		 add	 ecx, eax
  001a1	8b c1		 mov	 eax, ecx
  001a3	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  001a7	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  001ac	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001b0	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  001b4	03 c8		 add	 ecx, eax
  001b6	8b c1		 mov	 eax, ecx
  001b8	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  001bc	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  001c0	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  001c4	03 c8		 add	 ecx, eax
  001c6	8b c1		 mov	 eax, ecx
  001c8	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  001cc	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  001d1	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001d5	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  001d9	03 c8		 add	 ecx, eax
  001db	8b c1		 mov	 eax, ecx
  001dd	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  001e1	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  001e5	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  001e9	03 c8		 add	 ecx, eax
  001eb	8b c1		 mov	 eax, ecx
  001ed	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  001f1	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  001f6	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001fa	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  001fe	03 c8		 add	 ecx, eax
  00200	8b c1		 mov	 eax, ecx
  00202	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00206	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0020a	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  0020e	03 c8		 add	 ecx, eax
  00210	8b c1		 mov	 eax, ecx
  00212	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00216	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0021b	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0021f	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00223	03 c8		 add	 ecx, eax
  00225	8b c1		 mov	 eax, ecx
  00227	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0022b	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0022f	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00233	03 c8		 add	 ecx, eax
  00235	8b c1		 mov	 eax, ecx
  00237	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0023b	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00240	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00244	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00248	03 c8		 add	 ecx, eax
  0024a	8b c1		 mov	 eax, ecx
  0024c	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00250	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00254	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00258	03 c8		 add	 ecx, eax
  0025a	8b c1		 mov	 eax, ecx
  0025c	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00260	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00265	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  00269	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0026d	03 c8		 add	 ecx, eax
  0026f	8b c1		 mov	 eax, ecx
  00271	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00275	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00279	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  0027d	03 c8		 add	 ecx, eax
  0027f	8b c1		 mov	 eax, ecx
  00281	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00285	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0028a	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0028e	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00292	03 c8		 add	 ecx, eax
  00294	8b c1		 mov	 eax, ecx
  00296	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0029a	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0029e	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  002a2	03 c8		 add	 ecx, eax
  002a4	8b c1		 mov	 eax, ecx
  002a6	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  002aa	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  002af	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  002b3	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  002b7	03 c8		 add	 ecx, eax
  002b9	8b c1		 mov	 eax, ecx
  002bb	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  002bf	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  002c3	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  002c7	03 c8		 add	 ecx, eax
  002c9	8b c1		 mov	 eax, ecx
  002cb	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  002cf	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  002d4	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  002d8	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  002dc	03 c8		 add	 ecx, eax
  002de	8b c1		 mov	 eax, ecx
  002e0	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  002e4	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  002e8	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  002ec	03 c8		 add	 ecx, eax
  002ee	8b c1		 mov	 eax, ecx
  002f0	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  002f4	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  002f9	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  002fd	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00301	03 c8		 add	 ecx, eax
  00303	8b c1		 mov	 eax, ecx
  00305	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00309	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0030d	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00311	03 c8		 add	 ecx, eax
  00313	8b c1		 mov	 eax, ecx
  00315	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00319	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0031e	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  00322	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00326	03 c8		 add	 ecx, eax
  00328	8b c1		 mov	 eax, ecx
  0032a	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0032e	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00332	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00336	03 c8		 add	 ecx, eax
  00338	8b c1		 mov	 eax, ecx
  0033a	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0033e	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00343	0f b6 40 0d	 movzx	 eax, BYTE PTR [rax+13]
  00347	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0034b	03 c8		 add	 ecx, eax
  0034d	8b c1		 mov	 eax, ecx
  0034f	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00353	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00357	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  0035b	03 c8		 add	 ecx, eax
  0035d	8b c1		 mov	 eax, ecx
  0035f	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00363	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00368	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  0036c	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00370	03 c8		 add	 ecx, eax
  00372	8b c1		 mov	 eax, ecx
  00374	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00378	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0037c	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00380	03 c8		 add	 ecx, eax
  00382	8b c1		 mov	 eax, ecx
  00384	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00388	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0038d	0f b6 40 0f	 movzx	 eax, BYTE PTR [rax+15]
  00391	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00395	03 c8		 add	 ecx, eax
  00397	8b c1		 mov	 eax, ecx
  00399	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0039d	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  003a1	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  003a5	03 c8		 add	 ecx, eax
  003a7	8b c1		 mov	 eax, ecx
  003a9	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 105  :             buf += 16;

  003ad	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  003b2	48 83 c0 10	 add	 rax, 16
  003b6	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 106  :         } while (--n);

  003bb	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  003be	ff c8		 dec	 eax
  003c0	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  003c3	83 3c 24 00	 cmp	 DWORD PTR n$[rsp], 0
  003c7	0f 85 91 fd ff
	ff		 jne	 $LN8@adler32

; 107  :         MOD(adler);

  003cd	33 d2		 xor	 edx, edx
  003cf	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  003d3	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  003d8	f7 f1		 div	 ecx
  003da	8b c2		 mov	 eax, edx
  003dc	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax

; 108  :         MOD(sum2);

  003e0	33 d2		 xor	 edx, edx
  003e2	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  003e6	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  003eb	f7 f1		 div	 ecx
  003ed	8b c2		 mov	 eax, edx
  003ef	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 109  :     }

  003f3	e9 44 fd ff ff	 jmp	 $LN10@adler32
$LN9@adler32:

; 110  : 
; 111  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 112  :     if (len) {                  /* avoid modulos if none remaining */

  003f8	83 7c 24 30 00	 cmp	 DWORD PTR len$[rsp], 0
  003fd	0f 84 e3 02 00
	00		 je	 $LN5@adler32
$LN4@adler32:

; 113  :         while (len >= 16) {

  00403	83 7c 24 30 10	 cmp	 DWORD PTR len$[rsp], 16
  00408	0f 82 6d 02 00
	00		 jb	 $LN3@adler32

; 114  :             len -= 16;

  0040e	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00412	83 e8 10	 sub	 eax, 16
  00415	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 115  :             DO16(buf);

  00419	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0041e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00421	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00425	03 c8		 add	 ecx, eax
  00427	8b c1		 mov	 eax, ecx
  00429	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0042d	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00431	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00435	03 c8		 add	 ecx, eax
  00437	8b c1		 mov	 eax, ecx
  00439	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0043d	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00442	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00446	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0044a	03 c8		 add	 ecx, eax
  0044c	8b c1		 mov	 eax, ecx
  0044e	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00452	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00456	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  0045a	03 c8		 add	 ecx, eax
  0045c	8b c1		 mov	 eax, ecx
  0045e	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00462	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00467	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0046b	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0046f	03 c8		 add	 ecx, eax
  00471	8b c1		 mov	 eax, ecx
  00473	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00477	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0047b	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  0047f	03 c8		 add	 ecx, eax
  00481	8b c1		 mov	 eax, ecx
  00483	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00487	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0048c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00490	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00494	03 c8		 add	 ecx, eax
  00496	8b c1		 mov	 eax, ecx
  00498	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0049c	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  004a0	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  004a4	03 c8		 add	 ecx, eax
  004a6	8b c1		 mov	 eax, ecx
  004a8	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  004ac	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  004b1	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  004b5	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  004b9	03 c8		 add	 ecx, eax
  004bb	8b c1		 mov	 eax, ecx
  004bd	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  004c1	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  004c5	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  004c9	03 c8		 add	 ecx, eax
  004cb	8b c1		 mov	 eax, ecx
  004cd	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  004d1	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  004d6	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  004da	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  004de	03 c8		 add	 ecx, eax
  004e0	8b c1		 mov	 eax, ecx
  004e2	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  004e6	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  004ea	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  004ee	03 c8		 add	 ecx, eax
  004f0	8b c1		 mov	 eax, ecx
  004f2	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  004f6	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  004fb	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  004ff	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00503	03 c8		 add	 ecx, eax
  00505	8b c1		 mov	 eax, ecx
  00507	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0050b	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0050f	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00513	03 c8		 add	 ecx, eax
  00515	8b c1		 mov	 eax, ecx
  00517	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0051b	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00520	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  00524	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00528	03 c8		 add	 ecx, eax
  0052a	8b c1		 mov	 eax, ecx
  0052c	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00530	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00534	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00538	03 c8		 add	 ecx, eax
  0053a	8b c1		 mov	 eax, ecx
  0053c	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00540	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00545	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00549	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0054d	03 c8		 add	 ecx, eax
  0054f	8b c1		 mov	 eax, ecx
  00551	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00555	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00559	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  0055d	03 c8		 add	 ecx, eax
  0055f	8b c1		 mov	 eax, ecx
  00561	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00565	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0056a	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  0056e	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00572	03 c8		 add	 ecx, eax
  00574	8b c1		 mov	 eax, ecx
  00576	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0057a	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0057e	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00582	03 c8		 add	 ecx, eax
  00584	8b c1		 mov	 eax, ecx
  00586	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0058a	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0058f	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  00593	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00597	03 c8		 add	 ecx, eax
  00599	8b c1		 mov	 eax, ecx
  0059b	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0059f	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  005a3	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  005a7	03 c8		 add	 ecx, eax
  005a9	8b c1		 mov	 eax, ecx
  005ab	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  005af	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  005b4	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  005b8	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  005bc	03 c8		 add	 ecx, eax
  005be	8b c1		 mov	 eax, ecx
  005c0	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  005c4	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  005c8	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  005cc	03 c8		 add	 ecx, eax
  005ce	8b c1		 mov	 eax, ecx
  005d0	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  005d4	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  005d9	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  005dd	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  005e1	03 c8		 add	 ecx, eax
  005e3	8b c1		 mov	 eax, ecx
  005e5	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  005e9	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  005ed	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  005f1	03 c8		 add	 ecx, eax
  005f3	8b c1		 mov	 eax, ecx
  005f5	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  005f9	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  005fe	0f b6 40 0d	 movzx	 eax, BYTE PTR [rax+13]
  00602	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00606	03 c8		 add	 ecx, eax
  00608	8b c1		 mov	 eax, ecx
  0060a	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0060e	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00612	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00616	03 c8		 add	 ecx, eax
  00618	8b c1		 mov	 eax, ecx
  0061a	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0061e	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00623	0f b6 40 0e	 movzx	 eax, BYTE PTR [rax+14]
  00627	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0062b	03 c8		 add	 ecx, eax
  0062d	8b c1		 mov	 eax, ecx
  0062f	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00633	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00637	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  0063b	03 c8		 add	 ecx, eax
  0063d	8b c1		 mov	 eax, ecx
  0063f	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00643	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00648	0f b6 40 0f	 movzx	 eax, BYTE PTR [rax+15]
  0064c	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00650	03 c8		 add	 ecx, eax
  00652	8b c1		 mov	 eax, ecx
  00654	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00658	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0065c	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00660	03 c8		 add	 ecx, eax
  00662	8b c1		 mov	 eax, ecx
  00664	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 116  :             buf += 16;

  00668	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0066d	48 83 c0 10	 add	 rax, 16
  00671	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 117  :         }

  00676	e9 88 fd ff ff	 jmp	 $LN4@adler32
$LN3@adler32:
$LN2@adler32:

; 118  :         while (len--) {

  0067b	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0067f	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00683	ff c9		 dec	 ecx
  00685	89 4c 24 30	 mov	 DWORD PTR len$[rsp], ecx
  00689	85 c0		 test	 eax, eax
  0068b	74 33		 je	 SHORT $LN1@adler32

; 119  :             adler += *buf++;

  0068d	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00692	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00695	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00699	03 c8		 add	 ecx, eax
  0069b	8b c1		 mov	 eax, ecx
  0069d	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  006a1	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  006a6	48 ff c0	 inc	 rax
  006a9	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 120  :             sum2 += adler;

  006ae	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  006b2	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  006b6	03 c8		 add	 ecx, eax
  006b8	8b c1		 mov	 eax, ecx
  006ba	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 121  :         }

  006be	eb bb		 jmp	 SHORT $LN2@adler32
$LN1@adler32:

; 122  :         MOD(adler);

  006c0	33 d2		 xor	 edx, edx
  006c2	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  006c6	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  006cb	f7 f1		 div	 ecx
  006cd	8b c2		 mov	 eax, edx
  006cf	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax

; 123  :         MOD(sum2);

  006d3	33 d2		 xor	 edx, edx
  006d5	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  006d9	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  006de	f7 f1		 div	 ecx
  006e0	8b c2		 mov	 eax, edx
  006e2	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
$LN5@adler32:

; 124  :     }
; 125  : 
; 126  :     /* return recombined sums */
; 127  :     return adler | (sum2 << 16);

  006e6	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  006ea	c1 e0 10	 shl	 eax, 16
  006ed	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  006f1	0b c8		 or	 ecx, eax
  006f3	8b c1		 mov	 eax, ecx
$LN19@adler32:

; 128  : }

  006f5	48 83 c4 18	 add	 rsp, 24
  006f9	c3		 ret	 0
adler32	ENDP
_TEXT	ENDS
PUBLIC	adler32_combine
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_combine DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$adler32_combine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine DD 011101H
	DD	04211H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT adler32_combine
_TEXT	SEGMENT
adler1$ = 48
adler2$ = 56
len2$ = 64
adler32_combine PROC					; COMDAT

; 159  : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 160  :     return adler32_combine_(adler1, adler2, len2);

  00011	44 8b 44 24 40	 mov	 r8d, DWORD PTR len2$[rsp]
  00016	8b 54 24 38	 mov	 edx, DWORD PTR adler2$[rsp]
  0001a	8b 4c 24 30	 mov	 ecx, DWORD PTR adler1$[rsp]
  0001e	e8 00 00 00 00	 call	 adler32_combine_

; 161  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
adler32_combine ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_combine_ DD imagerel adler32_combine_
	DD	imagerel adler32_combine_+254
	DD	imagerel $unwind$adler32_combine_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine_ DD 011101H
	DD	02211H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT adler32_combine_
_TEXT	SEGMENT
sum1$ = 0
rem$ = 4
sum2$ = 8
adler1$ = 32
adler2$ = 40
len2$ = 48
adler32_combine_ PROC					; COMDAT

; 135  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 18	 sub	 rsp, 24

; 136  :     unsigned long sum1;
; 137  :     unsigned long sum2;
; 138  :     unsigned rem;
; 139  : 
; 140  :     /* the derivation of this formula is left as an exercise for the reader */
; 141  :     rem = (unsigned)(len2 % BASE);

  00011	33 d2		 xor	 edx, edx
  00013	8b 44 24 30	 mov	 eax, DWORD PTR len2$[rsp]
  00017	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0001c	f7 f1		 div	 ecx
  0001e	8b c2		 mov	 eax, edx
  00020	89 44 24 04	 mov	 DWORD PTR rem$[rsp], eax

; 142  :     sum1 = adler1 & 0xffff;

  00024	8b 44 24 20	 mov	 eax, DWORD PTR adler1$[rsp]
  00028	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002d	89 04 24	 mov	 DWORD PTR sum1$[rsp], eax

; 143  :     sum2 = rem * sum1;

  00030	8b 44 24 04	 mov	 eax, DWORD PTR rem$[rsp]
  00034	0f af 04 24	 imul	 eax, DWORD PTR sum1$[rsp]
  00038	89 44 24 08	 mov	 DWORD PTR sum2$[rsp], eax

; 144  :     MOD(sum2);

  0003c	33 d2		 xor	 edx, edx
  0003e	8b 44 24 08	 mov	 eax, DWORD PTR sum2$[rsp]
  00042	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	89 44 24 08	 mov	 DWORD PTR sum2$[rsp], eax

; 145  :     sum1 += (adler2 & 0xffff) + BASE - 1;

  0004f	8b 44 24 28	 mov	 eax, DWORD PTR adler2$[rsp]
  00053	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00058	8b 0c 24	 mov	 ecx, DWORD PTR sum1$[rsp]
  0005b	8d 84 01 f0 ff
	00 00		 lea	 eax, DWORD PTR [rcx+rax+65520]
  00062	89 04 24	 mov	 DWORD PTR sum1$[rsp], eax

; 146  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  00065	8b 44 24 20	 mov	 eax, DWORD PTR adler1$[rsp]
  00069	c1 e8 10	 shr	 eax, 16
  0006c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00071	8b 4c 24 28	 mov	 ecx, DWORD PTR adler2$[rsp]
  00075	c1 e9 10	 shr	 ecx, 16
  00078	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0007e	8d 84 08 f1 ff
	00 00		 lea	 eax, DWORD PTR [rax+rcx+65521]
  00085	2b 44 24 04	 sub	 eax, DWORD PTR rem$[rsp]
  00089	8b 4c 24 08	 mov	 ecx, DWORD PTR sum2$[rsp]
  0008d	03 c8		 add	 ecx, eax
  0008f	8b c1		 mov	 eax, ecx
  00091	89 44 24 08	 mov	 DWORD PTR sum2$[rsp], eax

; 147  :     if (sum1 >= BASE) sum1 -= BASE;

  00095	81 3c 24 f1 ff
	00 00		 cmp	 DWORD PTR sum1$[rsp], 65521 ; 0000fff1H
  0009c	72 0b		 jb	 SHORT $LN4@adler32_co
  0009e	8b 04 24	 mov	 eax, DWORD PTR sum1$[rsp]
  000a1	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  000a6	89 04 24	 mov	 DWORD PTR sum1$[rsp], eax
$LN4@adler32_co:

; 148  :     if (sum1 >= BASE) sum1 -= BASE;

  000a9	81 3c 24 f1 ff
	00 00		 cmp	 DWORD PTR sum1$[rsp], 65521 ; 0000fff1H
  000b0	72 0b		 jb	 SHORT $LN3@adler32_co
  000b2	8b 04 24	 mov	 eax, DWORD PTR sum1$[rsp]
  000b5	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  000ba	89 04 24	 mov	 DWORD PTR sum1$[rsp], eax
$LN3@adler32_co:

; 149  :     if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);

  000bd	81 7c 24 08 e2
	ff 01 00	 cmp	 DWORD PTR sum2$[rsp], 131042 ; 0001ffe2H
  000c5	72 0d		 jb	 SHORT $LN2@adler32_co
  000c7	8b 44 24 08	 mov	 eax, DWORD PTR sum2$[rsp]
  000cb	2d e2 ff 01 00	 sub	 eax, 131042		; 0001ffe2H
  000d0	89 44 24 08	 mov	 DWORD PTR sum2$[rsp], eax
$LN2@adler32_co:

; 150  :     if (sum2 >= BASE) sum2 -= BASE;

  000d4	81 7c 24 08 f1
	ff 00 00	 cmp	 DWORD PTR sum2$[rsp], 65521 ; 0000fff1H
  000dc	72 0d		 jb	 SHORT $LN1@adler32_co
  000de	8b 44 24 08	 mov	 eax, DWORD PTR sum2$[rsp]
  000e2	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  000e7	89 44 24 08	 mov	 DWORD PTR sum2$[rsp], eax
$LN1@adler32_co:

; 151  :     return sum1 | (sum2 << 16);

  000eb	8b 44 24 08	 mov	 eax, DWORD PTR sum2$[rsp]
  000ef	c1 e0 10	 shl	 eax, 16
  000f2	8b 0c 24	 mov	 ecx, DWORD PTR sum1$[rsp]
  000f5	0b c8		 or	 ecx, eax
  000f7	8b c1		 mov	 eax, ecx

; 152  : }

  000f9	48 83 c4 18	 add	 rsp, 24
  000fd	c3		 ret	 0
adler32_combine_ ENDP
_TEXT	ENDS
PUBLIC	adler32_combine64
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_combine64 DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$adler32_combine64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine64 DD 011101H
	DD	04211H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT adler32_combine64
_TEXT	SEGMENT
adler1$ = 48
adler2$ = 56
len2$ = 64
adler32_combine64 PROC					; COMDAT

; 167  : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 168  :     return adler32_combine_(adler1, adler2, len2);

  00011	44 8b 44 24 40	 mov	 r8d, DWORD PTR len2$[rsp]
  00016	8b 54 24 38	 mov	 edx, DWORD PTR adler2$[rsp]
  0001a	8b 4c 24 30	 mov	 ecx, DWORD PTR adler1$[rsp]
  0001e	e8 00 00 00 00	 call	 adler32_combine_

; 169  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
adler32_combine64 ENDP
_TEXT	ENDS
END
