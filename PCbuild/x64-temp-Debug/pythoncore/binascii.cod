; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_08NIDOPABH@binascii?$AA@			; `string'
PUBLIC	??_C@_06HKDIOBHD@b2a_qp?$AA@			; `string'
PUBLIC	??_C@_06MHAIBDO@a2b_qp?$AA@			; `string'
PUBLIC	??_C@_05KBIBMHFC@crc32?$AA@			; `string'
PUBLIC	??_C@_07MHCKENFH@crc_hqx?$AA@			; `string'
PUBLIC	??_C@_0O@GLNPCMOF@rledecode_hqx?$AA@		; `string'
PUBLIC	??_C@_0M@JMLKGCDG@rlecode_hqx?$AA@		; `string'
PUBLIC	??_C@_09NAOIDGL@unhexlify?$AA@			; `string'
PUBLIC	??_C@_07PGHCAJO@hexlify?$AA@			; `string'
PUBLIC	??_C@_07BBHHOHFK@a2b_hex?$AA@			; `string'
PUBLIC	??_C@_07BJGMJCBH@b2a_hex?$AA@			; `string'
PUBLIC	??_C@_07CEDJJLL@b2a_hqx?$AA@			; `string'
PUBLIC	??_C@_07KFIOMPG@a2b_hqx?$AA@			; `string'
PUBLIC	??_C@_0L@MBBPDBKK@b2a_base64?$AA@		; `string'
PUBLIC	??_C@_0L@GBHAGLGO@a2b_base64?$AA@		; `string'
PUBLIC	??_C@_06EGLNOK@b2a_uu?$AA@			; `string'
PUBLIC	??_C@_06HGAONNKH@a2b_uu?$AA@			; `string'
PUBLIC	??_C@_06OABAJCPM@istext?$AA@			; `string'
PUBLIC	??_C@_09DGJGMEGB@quotetabs?$AA@			; `string'
PUBLIC	??_C@_06MBPAJAPM@header?$AA@			; `string'
PUBLIC	??_C@_04PJOLNDGD@data?$AA@			; `string'
;	COMDAT ??_C@_08NIDOPABH@binascii?$AA@
CONST	SEGMENT
??_C@_08NIDOPABH@binascii?$AA@ DB 'binascii', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HKDIOBHD@b2a_qp?$AA@
CONST	SEGMENT
??_C@_06HKDIOBHD@b2a_qp?$AA@ DB 'b2a_qp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MHAIBDO@a2b_qp?$AA@
CONST	SEGMENT
??_C@_06MHAIBDO@a2b_qp?$AA@ DB 'a2b_qp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KBIBMHFC@crc32?$AA@
CONST	SEGMENT
??_C@_05KBIBMHFC@crc32?$AA@ DB 'crc32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHCKENFH@crc_hqx?$AA@
CONST	SEGMENT
??_C@_07MHCKENFH@crc_hqx?$AA@ DB 'crc_hqx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLNPCMOF@rledecode_hqx?$AA@
CONST	SEGMENT
??_C@_0O@GLNPCMOF@rledecode_hqx?$AA@ DB 'rledecode_hqx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JMLKGCDG@rlecode_hqx?$AA@
CONST	SEGMENT
??_C@_0M@JMLKGCDG@rlecode_hqx?$AA@ DB 'rlecode_hqx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09NAOIDGL@unhexlify?$AA@
CONST	SEGMENT
??_C@_09NAOIDGL@unhexlify?$AA@ DB 'unhexlify', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07PGHCAJO@hexlify?$AA@
CONST	SEGMENT
??_C@_07PGHCAJO@hexlify?$AA@ DB 'hexlify', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BBHHOHFK@a2b_hex?$AA@
CONST	SEGMENT
??_C@_07BBHHOHFK@a2b_hex?$AA@ DB 'a2b_hex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJGMJCBH@b2a_hex?$AA@
CONST	SEGMENT
??_C@_07BJGMJCBH@b2a_hex?$AA@ DB 'b2a_hex', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CEDJJLL@b2a_hqx?$AA@
CONST	SEGMENT
??_C@_07CEDJJLL@b2a_hqx?$AA@ DB 'b2a_hqx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KFIOMPG@a2b_hqx?$AA@
CONST	SEGMENT
??_C@_07KFIOMPG@a2b_hqx?$AA@ DB 'a2b_hqx', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MBBPDBKK@b2a_base64?$AA@
CONST	SEGMENT
??_C@_0L@MBBPDBKK@b2a_base64?$AA@ DB 'b2a_base64', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GBHAGLGO@a2b_base64?$AA@
CONST	SEGMENT
??_C@_0L@GBHAGLGO@a2b_base64?$AA@ DB 'a2b_base64', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06EGLNOK@b2a_uu?$AA@
CONST	SEGMENT
??_C@_06EGLNOK@b2a_uu?$AA@ DB 'b2a_uu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06HGAONNKH@a2b_uu?$AA@
CONST	SEGMENT
??_C@_06HGAONNKH@a2b_uu?$AA@ DB 'a2b_uu', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OABAJCPM@istext?$AA@
CONST	SEGMENT
??_C@_06OABAJCPM@istext?$AA@ DB 'istext', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09DGJGMEGB@quotetabs?$AA@
CONST	SEGMENT
??_C@_09DGJGMEGB@quotetabs?$AA@ DB 'quotetabs', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MBPAJAPM@header?$AA@
CONST	SEGMENT
??_C@_06MBPAJAPM@header?$AA@ DB 'header', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data?$AA@
CONST	SEGMENT
??_C@_04PJOLNDGD@data?$AA@ DB 'data', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
table_a2b_hqx DB 07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07eH
	DB	07dH
	DB	07dH
	DB	07eH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	07dH
	DB	07dH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	07dH
	DB	014H
	DB	015H
	DB	07fH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	07dH
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	07dH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	07dH
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	07dH
	DB	07dH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
	DB	07dH
table_b2a_hqx DB '!"#$%&''()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcde'
	DB	'fhijklmpqr', 00H
	ORG $+15
table_a2b_base64 DB 0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	03eH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	03fH
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
table_b2a_base64 DB 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
	DB	'0123456789+/', 00H
	ORG $+15
crctab_hqx DW	00H
	DW	01021H
	DW	02042H
	DW	03063H
	DW	04084H
	DW	050a5H
	DW	060c6H
	DW	070e7H
	DW	08108H
	DW	09129H
	DW	0a14aH
	DW	0b16bH
	DW	0c18cH
	DW	0d1adH
	DW	0e1ceH
	DW	0f1efH
	DW	01231H
	DW	0210H
	DW	03273H
	DW	02252H
	DW	052b5H
	DW	04294H
	DW	072f7H
	DW	062d6H
	DW	09339H
	DW	08318H
	DW	0b37bH
	DW	0a35aH
	DW	0d3bdH
	DW	0c39cH
	DW	0f3ffH
	DW	0e3deH
	DW	02462H
	DW	03443H
	DW	0420H
	DW	01401H
	DW	064e6H
	DW	074c7H
	DW	044a4H
	DW	05485H
	DW	0a56aH
	DW	0b54bH
	DW	08528H
	DW	09509H
	DW	0e5eeH
	DW	0f5cfH
	DW	0c5acH
	DW	0d58dH
	DW	03653H
	DW	02672H
	DW	01611H
	DW	0630H
	DW	076d7H
	DW	066f6H
	DW	05695H
	DW	046b4H
	DW	0b75bH
	DW	0a77aH
	DW	09719H
	DW	08738H
	DW	0f7dfH
	DW	0e7feH
	DW	0d79dH
	DW	0c7bcH
	DW	048c4H
	DW	058e5H
	DW	06886H
	DW	078a7H
	DW	0840H
	DW	01861H
	DW	02802H
	DW	03823H
	DW	0c9ccH
	DW	0d9edH
	DW	0e98eH
	DW	0f9afH
	DW	08948H
	DW	09969H
	DW	0a90aH
	DW	0b92bH
	DW	05af5H
	DW	04ad4H
	DW	07ab7H
	DW	06a96H
	DW	01a71H
	DW	0a50H
	DW	03a33H
	DW	02a12H
	DW	0dbfdH
	DW	0cbdcH
	DW	0fbbfH
	DW	0eb9eH
	DW	09b79H
	DW	08b58H
	DW	0bb3bH
	DW	0ab1aH
	DW	06ca6H
	DW	07c87H
	DW	04ce4H
	DW	05cc5H
	DW	02c22H
	DW	03c03H
	DW	0c60H
	DW	01c41H
	DW	0edaeH
	DW	0fd8fH
	DW	0cdecH
	DW	0ddcdH
	DW	0ad2aH
	DW	0bd0bH
	DW	08d68H
	DW	09d49H
	DW	07e97H
	DW	06eb6H
	DW	05ed5H
	DW	04ef4H
	DW	03e13H
	DW	02e32H
	DW	01e51H
	DW	0e70H
	DW	0ff9fH
	DW	0efbeH
	DW	0dfddH
	DW	0cffcH
	DW	0bf1bH
	DW	0af3aH
	DW	09f59H
	DW	08f78H
	DW	09188H
	DW	081a9H
	DW	0b1caH
	DW	0a1ebH
	DW	0d10cH
	DW	0c12dH
	DW	0f14eH
	DW	0e16fH
	DW	01080H
	DW	0a1H
	DW	030c2H
	DW	020e3H
	DW	05004H
	DW	04025H
	DW	07046H
	DW	06067H
	DW	083b9H
	DW	09398H
	DW	0a3fbH
	DW	0b3daH
	DW	0c33dH
	DW	0d31cH
	DW	0e37fH
	DW	0f35eH
	DW	02b1H
	DW	01290H
	DW	022f3H
	DW	032d2H
	DW	04235H
	DW	05214H
	DW	06277H
	DW	07256H
	DW	0b5eaH
	DW	0a5cbH
	DW	095a8H
	DW	08589H
	DW	0f56eH
	DW	0e54fH
	DW	0d52cH
	DW	0c50dH
	DW	034e2H
	DW	024c3H
	DW	014a0H
	DW	0481H
	DW	07466H
	DW	06447H
	DW	05424H
	DW	04405H
	DW	0a7dbH
	DW	0b7faH
	DW	08799H
	DW	097b8H
	DW	0e75fH
	DW	0f77eH
	DW	0c71dH
	DW	0d73cH
	DW	026d3H
	DW	036f2H
	DW	0691H
	DW	016b0H
	DW	06657H
	DW	07676H
	DW	04615H
	DW	05634H
	DW	0d94cH
	DW	0c96dH
	DW	0f90eH
	DW	0e92fH
	DW	099c8H
	DW	089e9H
	DW	0b98aH
	DW	0a9abH
	DW	05844H
	DW	04865H
	DW	07806H
	DW	06827H
	DW	018c0H
	DW	08e1H
	DW	03882H
	DW	028a3H
	DW	0cb7dH
	DW	0db5cH
	DW	0eb3fH
	DW	0fb1eH
	DW	08bf9H
	DW	09bd8H
	DW	0abbbH
	DW	0bb9aH
	DW	04a75H
	DW	05a54H
	DW	06a37H
	DW	07a16H
	DW	0af1H
	DW	01ad0H
	DW	02ab3H
	DW	03a92H
	DW	0fd2eH
	DW	0ed0fH
	DW	0dd6cH
	DW	0cd4dH
	DW	0bdaaH
	DW	0ad8bH
	DW	09de8H
	DW	08dc9H
	DW	07c26H
	DW	06c07H
	DW	05c64H
	DW	04c45H
	DW	03ca2H
	DW	02c83H
	DW	01ce0H
	DW	0cc1H
	DW	0ef1fH
	DW	0ff3eH
	DW	0cf5dH
	DW	0df7cH
	DW	0af9bH
	DW	0bfbaH
	DW	08fd9H
	DW	09ff8H
	DW	06e17H
	DW	07e36H
	DW	04e55H
	DW	05e74H
	DW	02e93H
	DW	03eb2H
	DW	0ed1H
	DW	01ef0H
doc_a2b_uu DB	'(ascii) -> bin. Decode a line of uuencoded data', 00H
doc_b2a_uu DB	'(bin) -> ascii. Uuencode line of data', 00H
	ORG $+2
doc_a2b_base64 DB '(ascii) -> bin. Decode a line of base64 data', 00H
	ORG $+3
doc_b2a_base64 DB '(bin) -> ascii. Base64-code line of data', 00H
	ORG $+7
doc_a2b_hqx DB	'ascii -> bin, done. Decode .hqx coding', 00H
	ORG $+1
doc_rlecode_hqx DB 'Binhex RLE-code binary data', 00H
	ORG $+4
doc_b2a_hqx DB	'Encode .hqx data', 00H
	ORG $+7
doc_rledecode_hqx DB 'Decode hexbin RLE-coded string', 00H
	ORG $+1
doc_crc_hqx DB	'(data, oldcrc) -> newcrc. Compute hqx CRC incrementally', 00H
doc_crc32 DB	'(data, oldcrc = 0) -> newcrc. Compute CRC-32 incremental'
	DB	'ly', 00H
	ORG $+5
crc_32_tab DD	00H
	DD	077073096H
	DD	0ee0e612cH
	DD	0990951baH
	DD	076dc419H
	DD	0706af48fH
	DD	0e963a535H
	DD	09e6495a3H
	DD	0edb8832H
	DD	079dcb8a4H
	DD	0e0d5e91eH
	DD	097d2d988H
	DD	09b64c2bH
	DD	07eb17cbdH
	DD	0e7b82d07H
	DD	090bf1d91H
	DD	01db71064H
	DD	06ab020f2H
	DD	0f3b97148H
	DD	084be41deH
	DD	01adad47dH
	DD	06ddde4ebH
	DD	0f4d4b551H
	DD	083d385c7H
	DD	0136c9856H
	DD	0646ba8c0H
	DD	0fd62f97aH
	DD	08a65c9ecH
	DD	014015c4fH
	DD	063066cd9H
	DD	0fa0f3d63H
	DD	08d080df5H
	DD	03b6e20c8H
	DD	04c69105eH
	DD	0d56041e4H
	DD	0a2677172H
	DD	03c03e4d1H
	DD	04b04d447H
	DD	0d20d85fdH
	DD	0a50ab56bH
	DD	035b5a8faH
	DD	042b2986cH
	DD	0dbbbc9d6H
	DD	0acbcf940H
	DD	032d86ce3H
	DD	045df5c75H
	DD	0dcd60dcfH
	DD	0abd13d59H
	DD	026d930acH
	DD	051de003aH
	DD	0c8d75180H
	DD	0bfd06116H
	DD	021b4f4b5H
	DD	056b3c423H
	DD	0cfba9599H
	DD	0b8bda50fH
	DD	02802b89eH
	DD	05f058808H
	DD	0c60cd9b2H
	DD	0b10be924H
	DD	02f6f7c87H
	DD	058684c11H
	DD	0c1611dabH
	DD	0b6662d3dH
	DD	076dc4190H
	DD	01db7106H
	DD	098d220bcH
	DD	0efd5102aH
	DD	071b18589H
	DD	06b6b51fH
	DD	09fbfe4a5H
	DD	0e8b8d433H
	DD	07807c9a2H
	DD	0f00f934H
	DD	09609a88eH
	DD	0e10e9818H
	DD	07f6a0dbbH
	DD	086d3d2dH
	DD	091646c97H
	DD	0e6635c01H
	DD	06b6b51f4H
	DD	01c6c6162H
	DD	0856530d8H
	DD	0f262004eH
	DD	06c0695edH
	DD	01b01a57bH
	DD	08208f4c1H
	DD	0f50fc457H
	DD	065b0d9c6H
	DD	012b7e950H
	DD	08bbeb8eaH
	DD	0fcb9887cH
	DD	062dd1ddfH
	DD	015da2d49H
	DD	08cd37cf3H
	DD	0fbd44c65H
	DD	04db26158H
	DD	03ab551ceH
	DD	0a3bc0074H
	DD	0d4bb30e2H
	DD	04adfa541H
	DD	03dd895d7H
	DD	0a4d1c46dH
	DD	0d3d6f4fbH
	DD	04369e96aH
	DD	0346ed9fcH
	DD	0ad678846H
	DD	0da60b8d0H
	DD	044042d73H
	DD	033031de5H
	DD	0aa0a4c5fH
	DD	0dd0d7cc9H
	DD	05005713cH
	DD	0270241aaH
	DD	0be0b1010H
	DD	0c90c2086H
	DD	05768b525H
	DD	0206f85b3H
	DD	0b966d409H
	DD	0ce61e49fH
	DD	05edef90eH
	DD	029d9c998H
	DD	0b0d09822H
	DD	0c7d7a8b4H
	DD	059b33d17H
	DD	02eb40d81H
	DD	0b7bd5c3bH
	DD	0c0ba6cadH
	DD	0edb88320H
	DD	09abfb3b6H
	DD	03b6e20cH
	DD	074b1d29aH
	DD	0ead54739H
	DD	09dd277afH
	DD	04db2615H
	DD	073dc1683H
	DD	0e3630b12H
	DD	094643b84H
	DD	0d6d6a3eH
	DD	07a6a5aa8H
	DD	0e40ecf0bH
	DD	09309ff9dH
	DD	0a00ae27H
	DD	07d079eb1H
	DD	0f00f9344H
	DD	08708a3d2H
	DD	01e01f268H
	DD	06906c2feH
	DD	0f762575dH
	DD	0806567cbH
	DD	0196c3671H
	DD	06e6b06e7H
	DD	0fed41b76H
	DD	089d32be0H
	DD	010da7a5aH
	DD	067dd4accH
	DD	0f9b9df6fH
	DD	08ebeeff9H
	DD	017b7be43H
	DD	060b08ed5H
	DD	0d6d6a3e8H
	DD	0a1d1937eH
	DD	038d8c2c4H
	DD	04fdff252H
	DD	0d1bb67f1H
	DD	0a6bc5767H
	DD	03fb506ddH
	DD	048b2364bH
	DD	0d80d2bdaH
	DD	0af0a1b4cH
	DD	036034af6H
	DD	041047a60H
	DD	0df60efc3H
	DD	0a867df55H
	DD	0316e8eefH
	DD	04669be79H
	DD	0cb61b38cH
	DD	0bc66831aH
	DD	0256fd2a0H
	DD	05268e236H
	DD	0cc0c7795H
	DD	0bb0b4703H
	DD	0220216b9H
	DD	05505262fH
	DD	0c5ba3bbeH
	DD	0b2bd0b28H
	DD	02bb45a92H
	DD	05cb36a04H
	DD	0c2d7ffa7H
	DD	0b5d0cf31H
	DD	02cd99e8bH
	DD	05bdeae1dH
	DD	09b64c2b0H
	DD	0ec63f226H
	DD	0756aa39cH
	DD	026d930aH
	DD	09c0906a9H
	DD	0eb0e363fH
	DD	072076785H
	DD	05005713H
	DD	095bf4a82H
	DD	0e2b87a14H
	DD	07bb12baeH
	DD	0cb61b38H
	DD	092d28e9bH
	DD	0e5d5be0dH
	DD	07cdcefb7H
	DD	0bdbdf21H
	DD	086d3d2d4H
	DD	0f1d4e242H
	DD	068ddb3f8H
	DD	01fda836eH
	DD	081be16cdH
	DD	0f6b9265bH
	DD	06fb077e1H
	DD	018b74777H
	DD	088085ae6H
	DD	0ff0f6a70H
	DD	066063bcaH
	DD	011010b5cH
	DD	08f659effH
	DD	0f862ae69H
	DD	0616bffd3H
	DD	0166ccf45H
	DD	0a00ae278H
	DD	0d70dd2eeH
	DD	04e048354H
	DD	03903b3c2H
	DD	0a7672661H
	DD	0d06016f7H
	DD	04969474dH
	DD	03e6e77dbH
	DD	0aed16a4aH
	DD	0d9d65adcH
	DD	040df0b66H
	DD	037d83bf0H
	DD	0a9bcae53H
	DD	0debb9ec5H
	DD	047b2cf7fH
	DD	030b5ffe9H
	DD	0bdbdf21cH
	DD	0cabac28aH
	DD	053b39330H
	DD	024b4a3a6H
	DD	0bad03605H
	DD	0cdd70693H
	DD	054de5729H
	DD	023d967bfH
	DD	0b3667a2eH
	DD	0c4614ab8H
	DD	05d681b02H
	DD	02a6f2b94H
	DD	0b40bbe37H
	DD	0c30c8ea1H
	DD	05a05df1bH
	DD	02d02ef8dH
doc_hexlify DB	'b2a_hex(data) -> s; Hexadecimal representation of binary'
	DB	' data.', 0aH, 0aH, 'The return value is a bytes object.  This'
	DB	' function is also', 0aH, 'available as "hexlify()".', 00H
	ORG $+11
doc_unhexlify DB 'a2b_hex(hexstr) -> s; Binary data of hexadecimal repres'
	DB	'entation.', 0aH, 0aH, 'hexstr must contain an even number of '
	DB	'hex digits (upper or lower case).', 0aH, 'This function is al'
	DB	'so available as "unhexlify()"', 00H
	ORG $+5
table_hex DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0aH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
doc_a2b_qp DB	'Decode a string of qp-encoded data', 00H
	ORG $+5
?kwlist@?1??binascii_a2b_qp@@9@9 DQ FLAT:??_C@_04PJOLNDGD@data?$AA@ ; `binascii_a2b_qp'::`2'::kwlist
	DQ	FLAT:??_C@_06MBPAJAPM@header?$AA@
	DQ	0000000000000000H
doc_b2a_qp DB	'b2a_qp(data, quotetabs=0, istext=1, header=0) -> s; ', 0aH
	DB	' Encode a string using quoted-printable encoding. ', 0aH, 0aH
	DB	'On encoding, when istext is set, newlines are not encoded, an'
	DB	'd white ', 0aH, 'space at end of lines is.  When istext is no'
	DB	't set, \r and \n (CR/LF) are ', 0aH, 'both encoded.  When quo'
	DB	'tetabs is set, space and tabs are encoded.', 00H
	ORG $+5
?kwlist@?1??binascii_b2a_qp@@9@9 DQ FLAT:??_C@_04PJOLNDGD@data?$AA@ ; `binascii_b2a_qp'::`2'::kwlist
	DQ	FLAT:??_C@_09DGJGMEGB@quotetabs?$AA@
	DQ	FLAT:??_C@_06OABAJCPM@istext?$AA@
	DQ	FLAT:??_C@_06MBPAJAPM@header?$AA@
	DQ	0000000000000000H
	ORG $+8
binascii_module_methods DQ FLAT:??_C@_06HGAONNKH@a2b_uu?$AA@
	DQ	FLAT:binascii_a2b_uu
	DD	01H
	ORG $+4
	DQ	FLAT:doc_a2b_uu
	DQ	FLAT:??_C@_06EGLNOK@b2a_uu?$AA@
	DQ	FLAT:binascii_b2a_uu
	DD	01H
	ORG $+4
	DQ	FLAT:doc_b2a_uu
	DQ	FLAT:??_C@_0L@GBHAGLGO@a2b_base64?$AA@
	DQ	FLAT:binascii_a2b_base64
	DD	01H
	ORG $+4
	DQ	FLAT:doc_a2b_base64
	DQ	FLAT:??_C@_0L@MBBPDBKK@b2a_base64?$AA@
	DQ	FLAT:binascii_b2a_base64
	DD	01H
	ORG $+4
	DQ	FLAT:doc_b2a_base64
	DQ	FLAT:??_C@_07KFIOMPG@a2b_hqx?$AA@
	DQ	FLAT:binascii_a2b_hqx
	DD	01H
	ORG $+4
	DQ	FLAT:doc_a2b_hqx
	DQ	FLAT:??_C@_07CEDJJLL@b2a_hqx?$AA@
	DQ	FLAT:binascii_b2a_hqx
	DD	01H
	ORG $+4
	DQ	FLAT:doc_b2a_hqx
	DQ	FLAT:??_C@_07BJGMJCBH@b2a_hex?$AA@
	DQ	FLAT:binascii_hexlify
	DD	01H
	ORG $+4
	DQ	FLAT:doc_hexlify
	DQ	FLAT:??_C@_07BBHHOHFK@a2b_hex?$AA@
	DQ	FLAT:binascii_unhexlify
	DD	01H
	ORG $+4
	DQ	FLAT:doc_unhexlify
	DQ	FLAT:??_C@_07PGHCAJO@hexlify?$AA@
	DQ	FLAT:binascii_hexlify
	DD	01H
	ORG $+4
	DQ	FLAT:doc_hexlify
	DQ	FLAT:??_C@_09NAOIDGL@unhexlify?$AA@
	DQ	FLAT:binascii_unhexlify
	DD	01H
	ORG $+4
	DQ	FLAT:doc_unhexlify
	DQ	FLAT:??_C@_0M@JMLKGCDG@rlecode_hqx?$AA@
	DQ	FLAT:binascii_rlecode_hqx
	DD	01H
	ORG $+4
	DQ	FLAT:doc_rlecode_hqx
	DQ	FLAT:??_C@_0O@GLNPCMOF@rledecode_hqx?$AA@
	DQ	FLAT:binascii_rledecode_hqx
	DD	01H
	ORG $+4
	DQ	FLAT:doc_rledecode_hqx
	DQ	FLAT:??_C@_07MHCKENFH@crc_hqx?$AA@
	DQ	FLAT:binascii_crc_hqx
	DD	01H
	ORG $+4
	DQ	FLAT:doc_crc_hqx
	DQ	FLAT:??_C@_05KBIBMHFC@crc32?$AA@
	DQ	FLAT:binascii_crc32
	DD	01H
	ORG $+4
	DQ	FLAT:doc_crc32
	DQ	FLAT:??_C@_06MHAIBDO@a2b_qp?$AA@
	DQ	FLAT:binascii_a2b_qp
	DD	03H
	ORG $+4
	DQ	FLAT:doc_a2b_qp
	DQ	FLAT:??_C@_06HKDIOBHD@b2a_qp?$AA@
	DQ	FLAT:binascii_b2a_qp
	DD	03H
	ORG $+4
	DQ	FLAT:doc_b2a_qp
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
doc_binascii DB	'Conversion between binary data and ASCII', 00H
	ORG $+7
binasciimodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_08NIDOPABH@binascii?$AA@
	DQ	FLAT:doc_binascii
	DQ	ffffffffffffffffH
	DQ	FLAT:binascii_module_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	??_C@_0BB@JICCAMIB@Trailing?5garbage?$AA@	; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0N@JBCOMPIB@Illegal?5char?$AA@		; `string'
PUBLIC	??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BO@HHIKJINI@?$AAa?$AAs?$AAc?$AAi?$AAi?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	??_C@_09ICLPICBO@O?$CG?3a2b_uu?$AA@		; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyBuffer_Release:PROC
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	__imp__wassert:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
_BSS	SEGMENT
Error	DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\binascii.c
pdata	SEGMENT
$pdata$binascii_a2b_uu DD imagerel binascii_a2b_uu
	DD	imagerel binascii_a2b_uu+828
	DD	imagerel $unwind$binascii_a2b_uu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_a2b_uu DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_0BB@JICCAMIB@Trailing?5garbage?$AA@
CONST	SEGMENT
??_C@_0BB@JICCAMIB@Trailing?5garbage?$AA@ DB 'Trailing garbage', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JBCOMPIB@Illegal?5char?$AA@
CONST	SEGMENT
??_C@_0N@JBCOMPIB@Illegal?5char?$AA@ DB 'Illegal char', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'r', 00H, 'v', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@HHIKJINI@?$AAa?$AAs?$AAc?$AAi?$AAi?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@HHIKJINI@?$AAa?$AAs?$AAc?$AAi?$AAi?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'a'
	DB	00H, 's', 00H, 'c', 00H, 'i', 00H, 'i', 00H, '_', 00H, 'l', 00H
	DB	'e', 00H, 'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 'b', 00H, 'i', 00H, 'n'
	DB	00H, 'a', 00H, 's', 00H, 'c', 00H, 'i', 00H, 'i', 00H, '.', 00H
	DB	'c', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09ICLPICBO@O?$CG?3a2b_uu?$AA@
CONST	SEGMENT
??_C@_09ICLPICBO@O?$CG?3a2b_uu?$AA@ DB 'O&:a2b_uu', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_a2b_uu
_TEXT	SEGMENT
bin_len$ = 32
this_ch$ = 40
leftchar$ = 44
bin_data$ = 48
ascii_data$ = 56
rv$ = 64
leftbits$ = 72
pascii$ = 80
ascii_len$ = 160
tv132 = 168
tv217 = 172
self$ = 192
args$ = 200
binascii_a2b_uu PROC					; COMDAT

; 228  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 229  :     Py_buffer pascii;
; 230  :     unsigned char *ascii_data, *bin_data;
; 231  :     int leftbits = 0;

  00011	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR leftbits$[rsp], 0

; 232  :     unsigned char this_ch;
; 233  :     unsigned int leftchar = 0;

  00019	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR leftchar$[rsp], 0

; 234  :     PyObject *rv;
; 235  :     Py_ssize_t ascii_len, bin_len;
; 236  : 
; 237  :     if ( !PyArg_ParseTuple(args, "O&:a2b_uu", ascii_buffer_converter, &pascii) )

  00021	4c 8d 4c 24 50	 lea	 r9, QWORD PTR pascii$[rsp]
  00026	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ascii_buffer_converter
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09ICLPICBO@O?$CG?3a2b_uu?$AA@
  00034	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0003c	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00041	85 c0		 test	 eax, eax
  00043	75 07		 jne	 SHORT $LN14@binascii_a

; 238  :         return NULL;

  00045	33 c0		 xor	 eax, eax
  00047	e9 e8 02 00 00	 jmp	 $LN15@binascii_a
$LN14@binascii_a:

; 239  :     ascii_data = pascii.buf;

  0004c	48 8b 44 24 50	 mov	 rax, QWORD PTR pascii$[rsp]
  00051	48 89 44 24 38	 mov	 QWORD PTR ascii_data$[rsp], rax

; 240  :     ascii_len = pascii.len;

  00056	48 8b 44 24 60	 mov	 rax, QWORD PTR pascii$[rsp+16]
  0005b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR ascii_len$[rsp], rax

; 241  : 
; 242  :     assert(ascii_len >= 0);

  00063	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR ascii_len$[rsp], 0
  0006c	7d 1c		 jge	 SHORT $LN17@binascii_a
  0006e	41 b8 f2 00 00
	00		 mov	 r8d, 242		; 000000f2H
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@HHIKJINI@?$AAa?$AAs?$AAc?$AAi?$AAi?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00088	33 c0		 xor	 eax, eax
$LN17@binascii_a:

; 243  : 
; 244  :     /* First byte: binary data length (in bytes) */
; 245  :     bin_len = (*ascii_data++ - ' ') & 077;

  0008a	48 8b 44 24 38	 mov	 rax, QWORD PTR ascii_data$[rsp]
  0008f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00092	83 e8 20	 sub	 eax, 32			; 00000020H
  00095	83 e0 3f	 and	 eax, 63			; 0000003fH
  00098	48 98		 cdqe
  0009a	48 89 44 24 20	 mov	 QWORD PTR bin_len$[rsp], rax
  0009f	48 8b 44 24 38	 mov	 rax, QWORD PTR ascii_data$[rsp]
  000a4	48 ff c0	 inc	 rax
  000a7	48 89 44 24 38	 mov	 QWORD PTR ascii_data$[rsp], rax

; 246  :     ascii_len--;

  000ac	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ascii_len$[rsp]
  000b4	48 ff c8	 dec	 rax
  000b7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR ascii_len$[rsp], rax

; 247  : 
; 248  :     /* Allocate the buffer */
; 249  :     if ( (rv=PyBytes_FromStringAndSize(NULL, bin_len)) == NULL ) {

  000bf	48 8b 54 24 20	 mov	 rdx, QWORD PTR bin_len$[rsp]
  000c4	33 c9		 xor	 ecx, ecx
  000c6	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000cb	48 89 44 24 40	 mov	 QWORD PTR rv$[rsp], rax
  000d0	48 83 7c 24 40
	00		 cmp	 QWORD PTR rv$[rsp], 0
  000d6	75 11		 jne	 SHORT $LN13@binascii_a

; 250  :         PyBuffer_Release(&pascii);

  000d8	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pascii$[rsp]
  000dd	e8 00 00 00 00	 call	 PyBuffer_Release

; 251  :         return NULL;

  000e2	33 c0		 xor	 eax, eax
  000e4	e9 4b 02 00 00	 jmp	 $LN15@binascii_a
$LN13@binascii_a:

; 252  :     }
; 253  :     bin_data = (unsigned char *)PyBytes_AS_STRING(rv);

  000e9	48 8b 44 24 40	 mov	 rax, QWORD PTR rv$[rsp]
  000ee	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f8	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000fd	85 c0		 test	 eax, eax
  000ff	75 1c		 jne	 SHORT $LN18@binascii_a
  00101	41 b8 fd 00 00
	00		 mov	 r8d, 253		; 000000fdH
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0011b	33 c0		 xor	 eax, eax
$LN18@binascii_a:
  0011d	48 8b 44 24 40	 mov	 rax, QWORD PTR rv$[rsp]
  00122	48 83 c0 78	 add	 rax, 120		; 00000078H
  00126	48 89 44 24 30	 mov	 QWORD PTR bin_data$[rsp], rax

; 254  : 
; 255  :     for( ; bin_len > 0 ; ascii_len--, ascii_data++ ) {

  0012b	eb 20		 jmp	 SHORT $LN12@binascii_a
$LN11@binascii_a:
  0012d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ascii_len$[rsp]
  00135	48 ff c8	 dec	 rax
  00138	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR ascii_len$[rsp], rax
  00140	48 8b 44 24 38	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00145	48 ff c0	 inc	 rax
  00148	48 89 44 24 38	 mov	 QWORD PTR ascii_data$[rsp], rax
$LN12@binascii_a:
  0014d	48 83 7c 24 20
	00		 cmp	 QWORD PTR bin_len$[rsp], 0
  00153	0f 8e 3b 01 00
	00		 jle	 $LN10@binascii_a

; 256  :         /* XXX is it really best to add NULs if there's no more data */
; 257  :         this_ch = (ascii_len > 0) ? *ascii_data : 0;

  00159	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR ascii_len$[rsp], 0
  00162	7e 11		 jle	 SHORT $LN19@binascii_a
  00164	48 8b 44 24 38	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00169	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0016c	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv132[rsp], eax
  00173	eb 0b		 jmp	 SHORT $LN20@binascii_a
$LN19@binascii_a:
  00175	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
$LN20@binascii_a:
  00180	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR tv132[rsp]
  00188	88 44 24 28	 mov	 BYTE PTR this_ch$[rsp], al

; 258  :         if ( this_ch == '\n' || this_ch == '\r' || ascii_len <= 0) {

  0018c	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  00191	83 f8 0a	 cmp	 eax, 10
  00194	74 15		 je	 SHORT $LN8@binascii_a
  00196	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  0019b	83 f8 0d	 cmp	 eax, 13
  0019e	74 0b		 je	 SHORT $LN8@binascii_a
  001a0	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR ascii_len$[rsp], 0
  001a9	7f 07		 jg	 SHORT $LN9@binascii_a
$LN8@binascii_a:

; 259  :             /*
; 260  :             ** Whitespace. Assume some spaces got eaten at
; 261  :             ** end-of-line. (We check this later)
; 262  :             */
; 263  :             this_ch = 0;

  001ab	c6 44 24 28 00	 mov	 BYTE PTR this_ch$[rsp], 0

; 264  :         } else {

  001b0	eb 51		 jmp	 SHORT $LN7@binascii_a
$LN9@binascii_a:

; 265  :             /* Check the character for legality
; 266  :             ** The 64 in stead of the expected 63 is because
; 267  :             ** there are a few uuencodes out there that use
; 268  :             ** '`' as zero instead of space.
; 269  :             */
; 270  :             if ( this_ch < ' ' || this_ch > (' ' + 64)) {

  001b2	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  001b7	83 f8 20	 cmp	 eax, 32			; 00000020H
  001ba	7c 0a		 jl	 SHORT $LN5@binascii_a
  001bc	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  001c1	83 f8 60	 cmp	 eax, 96			; 00000060H
  001c4	7e 2e		 jle	 SHORT $LN6@binascii_a
$LN5@binascii_a:

; 271  :                 PyErr_SetString(Error, "Illegal char");

  001c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JBCOMPIB@Illegal?5char?$AA@
  001cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  001d4	e8 00 00 00 00	 call	 PyErr_SetString

; 272  :                 PyBuffer_Release(&pascii);

  001d9	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pascii$[rsp]
  001de	e8 00 00 00 00	 call	 PyBuffer_Release

; 273  :                 Py_DECREF(rv);

  001e3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rv$[rsp]
  001e8	e8 00 00 00 00	 call	 _Py_DecRef

; 274  :                 return NULL;

  001ed	33 c0		 xor	 eax, eax
  001ef	e9 40 01 00 00	 jmp	 $LN15@binascii_a
$LN6@binascii_a:

; 275  :             }
; 276  :             this_ch = (this_ch - ' ') & 077;

  001f4	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  001f9	83 e8 20	 sub	 eax, 32			; 00000020H
  001fc	83 e0 3f	 and	 eax, 63			; 0000003fH
  001ff	88 44 24 28	 mov	 BYTE PTR this_ch$[rsp], al
$LN7@binascii_a:

; 277  :         }
; 278  :         /*
; 279  :         ** Shift it in on the low end, and see if there's
; 280  :         ** a byte ready for output.
; 281  :         */
; 282  :         leftchar = (leftchar << 6) | (this_ch);

  00203	8b 44 24 2c	 mov	 eax, DWORD PTR leftchar$[rsp]
  00207	c1 e0 06	 shl	 eax, 6
  0020a	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR this_ch$[rsp]
  0020f	0b c1		 or	 eax, ecx
  00211	89 44 24 2c	 mov	 DWORD PTR leftchar$[rsp], eax

; 283  :         leftbits += 6;

  00215	8b 44 24 48	 mov	 eax, DWORD PTR leftbits$[rsp]
  00219	83 c0 06	 add	 eax, 6
  0021c	89 44 24 48	 mov	 DWORD PTR leftbits$[rsp], eax

; 284  :         if ( leftbits >= 8 ) {

  00220	83 7c 24 48 08	 cmp	 DWORD PTR leftbits$[rsp], 8
  00225	7c 68		 jl	 SHORT $LN4@binascii_a

; 285  :             leftbits -= 8;

  00227	8b 44 24 48	 mov	 eax, DWORD PTR leftbits$[rsp]
  0022b	83 e8 08	 sub	 eax, 8
  0022e	89 44 24 48	 mov	 DWORD PTR leftbits$[rsp], eax

; 286  :             *bin_data++ = (leftchar >> leftbits) & 0xff;

  00232	8b 44 24 48	 mov	 eax, DWORD PTR leftbits$[rsp]
  00236	0f b6 c8	 movzx	 ecx, al
  00239	8b 44 24 2c	 mov	 eax, DWORD PTR leftchar$[rsp]
  0023d	d3 e8		 shr	 eax, cl
  0023f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00244	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bin_data$[rsp]
  00249	88 01		 mov	 BYTE PTR [rcx], al
  0024b	48 8b 44 24 30	 mov	 rax, QWORD PTR bin_data$[rsp]
  00250	48 ff c0	 inc	 rax
  00253	48 89 44 24 30	 mov	 QWORD PTR bin_data$[rsp], rax

; 287  :             leftchar &= ((1 << leftbits) - 1);

  00258	8b 44 24 48	 mov	 eax, DWORD PTR leftbits$[rsp]
  0025c	b9 01 00 00 00	 mov	 ecx, 1
  00261	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv217[rsp], ecx
  00268	0f b6 c8	 movzx	 ecx, al
  0026b	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv217[rsp]
  00272	d3 e0		 shl	 eax, cl
  00274	ff c8		 dec	 eax
  00276	8b 4c 24 2c	 mov	 ecx, DWORD PTR leftchar$[rsp]
  0027a	23 c8		 and	 ecx, eax
  0027c	8b c1		 mov	 eax, ecx
  0027e	89 44 24 2c	 mov	 DWORD PTR leftchar$[rsp], eax

; 288  :             bin_len--;

  00282	48 8b 44 24 20	 mov	 rax, QWORD PTR bin_len$[rsp]
  00287	48 ff c8	 dec	 rax
  0028a	48 89 44 24 20	 mov	 QWORD PTR bin_len$[rsp], rax
$LN4@binascii_a:

; 289  :         }
; 290  :     }

  0028f	e9 99 fe ff ff	 jmp	 $LN11@binascii_a
$LN10@binascii_a:
$LN3@binascii_a:

; 291  :     /*
; 292  :     ** Finally, check that if there's anything left on the line
; 293  :     ** that it's whitespace only.
; 294  :     */
; 295  :     while( ascii_len-- > 0 ) {

  00294	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ascii_len$[rsp]
  0029c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR ascii_len$[rsp]
  002a4	48 ff c9	 dec	 rcx
  002a7	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR ascii_len$[rsp], rcx
  002af	48 85 c0	 test	 rax, rax
  002b2	7e 71		 jle	 SHORT $LN2@binascii_a

; 296  :         this_ch = *ascii_data++;

  002b4	48 8b 44 24 38	 mov	 rax, QWORD PTR ascii_data$[rsp]
  002b9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002bc	88 44 24 28	 mov	 BYTE PTR this_ch$[rsp], al
  002c0	48 8b 44 24 38	 mov	 rax, QWORD PTR ascii_data$[rsp]
  002c5	48 ff c0	 inc	 rax
  002c8	48 89 44 24 38	 mov	 QWORD PTR ascii_data$[rsp], rax

; 297  :         /* Extra '`' may be written as padding in some cases */
; 298  :         if ( this_ch != ' ' && this_ch != ' '+64 &&
; 299  :              this_ch != '\n' && this_ch != '\r' ) {

  002cd	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  002d2	83 f8 20	 cmp	 eax, 32			; 00000020H
  002d5	74 49		 je	 SHORT $LN1@binascii_a
  002d7	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  002dc	83 f8 60	 cmp	 eax, 96			; 00000060H
  002df	74 3f		 je	 SHORT $LN1@binascii_a
  002e1	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  002e6	83 f8 0a	 cmp	 eax, 10
  002e9	74 35		 je	 SHORT $LN1@binascii_a
  002eb	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  002f0	83 f8 0d	 cmp	 eax, 13
  002f3	74 2b		 je	 SHORT $LN1@binascii_a

; 300  :             PyErr_SetString(Error, "Trailing garbage");

  002f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@JICCAMIB@Trailing?5garbage?$AA@
  002fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  00303	e8 00 00 00 00	 call	 PyErr_SetString

; 301  :             PyBuffer_Release(&pascii);

  00308	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pascii$[rsp]
  0030d	e8 00 00 00 00	 call	 PyBuffer_Release

; 302  :             Py_DECREF(rv);

  00312	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rv$[rsp]
  00317	e8 00 00 00 00	 call	 _Py_DecRef

; 303  :             return NULL;

  0031c	33 c0		 xor	 eax, eax
  0031e	eb 14		 jmp	 SHORT $LN15@binascii_a
$LN1@binascii_a:

; 304  :         }
; 305  :     }

  00320	e9 6f ff ff ff	 jmp	 $LN3@binascii_a
$LN2@binascii_a:

; 306  :     PyBuffer_Release(&pascii);

  00325	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pascii$[rsp]
  0032a	e8 00 00 00 00	 call	 PyBuffer_Release

; 307  :     return rv;

  0032f	48 8b 44 24 40	 mov	 rax, QWORD PTR rv$[rsp]
$LN15@binascii_a:

; 308  : }

  00334	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0033b	c3		 ret	 0
binascii_a2b_uu ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@DIBACIBP@argument?5should?5be?5a?5contiguous?5@ ; `string'
PUBLIC	??_C@_0DJ@KJEFFGLI@argument?5should?5be?5bytes?0?5buffer@ ; `string'
PUBLIC	??_C@_1EI@IHJBJEGE@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@ ; `string'
PUBLIC	??_C@_1FI@LJNJKGJE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAK?$AAI?$AAN?$AAD?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe@ ; `string'
PUBLIC	??_C@_0DF@JFKKDLIG@string?5argument?5should?5contain?5o@ ; `string'
PUBLIC	??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyBuffer_IsContiguous:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyObject_GetBuffer:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	_PyUnicode_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\binascii.c
pdata	SEGMENT
$pdata$ascii_buffer_converter DD imagerel ascii_buffer_converter
	DD	imagerel ascii_buffer_converter+1032
	DD	imagerel $unwind$ascii_buffer_converter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ascii_buffer_converter DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0CP@DIBACIBP@argument?5should?5be?5a?5contiguous?5@
CONST	SEGMENT
??_C@_0CP@DIBACIBP@argument?5should?5be?5a?5contiguous?5@ DB 'argument sh'
	DB	'ould be a contiguous buffer, not %R', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@KJEFFGLI@argument?5should?5be?5bytes?0?5buffer@
CONST	SEGMENT
??_C@_0DJ@KJEFFGLI@argument?5should?5be?5bytes?0?5buffer@ DB 'argument sh'
	DB	'ould be bytes, buffer or ASCII string, not %R', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@IHJBJEGE@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
CONST	SEGMENT
??_C@_1EI@IHJBJEGE@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'a', 00H, 'r', 00H, 'g', 00H, ')', 00H, ')', 00H, '-', 00H, '>'
	DB	00H, 'd', 00H, 'a', 00H, 't', 00H, 'a', 00H, '.', 00H, 'a', 00H
	DB	'n', 00H, 'y', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@LJNJKGJE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAK?$AAI?$AAN?$AAD?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe@
CONST	SEGMENT
??_C@_1FI@LJNJKGJE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAK?$AAI?$AAN?$AAD?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'K', 00H, 'I', 00H, 'N', 00H, 'D'
	DB	00H, '(', 00H, 'a', 00H, 'r', 00H, 'g', 00H, ')', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n'
	DB	00H, 'i', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H
	DB	'1', 00H, 'B', 00H, 'Y', 00H, 'T', 00H, 'E', 00H, '_', 00H, 'K'
	DB	00H, 'I', 00H, 'N', 00H, 'D', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@JFKKDLIG@string?5argument?5should?5contain?5o@
CONST	SEGMENT
??_C@_0DF@JFKKDLIG@string?5argument?5should?5contain?5o@ DB 'string argum'
	DB	'ent should contain only ASCII characters', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'a', 00H
	DB	'r', 00H, 'g', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'a', 00H, 'r', 00H, 'g', 00H, ')', 00H
	DB	00H, 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ascii_buffer_converter
_TEXT	SEGMENT
tv84 = 32
tv197 = 40
tv206 = 48
arg$ = 80
buf$ = 88
ascii_buffer_converter PROC				; COMDAT

; 188  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 189  :     if (arg == NULL) {

  0000e	48 83 7c 24 50
	00		 cmp	 QWORD PTR arg$[rsp], 0
  00014	75 14		 jne	 SHORT $LN6@ascii_buff

; 190  :         PyBuffer_Release(buf);

  00016	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0001b	e8 00 00 00 00	 call	 PyBuffer_Release

; 191  :         return 1;

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	e9 d9 03 00 00	 jmp	 $LN7@ascii_buff
$LN6@ascii_buff:

; 192  :     }
; 193  :     if (PyUnicode_Check(arg)) {

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  0002f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00033	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00039	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0003e	85 c0		 test	 eax, eax
  00040	0f 84 48 03 00
	00		 je	 $LN5@ascii_buff

; 194  :         if (PyUnicode_READY(arg) < 0)

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  0004b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00055	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0005a	85 c0		 test	 eax, eax
  0005c	75 1c		 jne	 SHORT $LN9@ascii_buff
  0005e	41 b8 c2 00 00
	00		 mov	 r8d, 194		; 000000c2H
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00078	33 c0		 xor	 eax, eax
$LN9@ascii_buff:
  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  0007f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00082	c1 e8 07	 shr	 eax, 7
  00085	83 e0 01	 and	 eax, 1
  00088	85 c0		 test	 eax, eax
  0008a	74 0a		 je	 SHORT $LN10@ascii_buff
  0008c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
  00094	eb 0e		 jmp	 SHORT $LN11@ascii_buff
$LN10@ascii_buff:
  00096	48 8b 4c 24 50	 mov	 rcx, QWORD PTR arg$[rsp]
  0009b	e8 00 00 00 00	 call	 _PyUnicode_Ready
  000a0	89 44 24 20	 mov	 DWORD PTR tv84[rsp], eax
$LN11@ascii_buff:
  000a4	83 7c 24 20 00	 cmp	 DWORD PTR tv84[rsp], 0
  000a9	7d 07		 jge	 SHORT $LN4@ascii_buff

; 195  :             return 0;

  000ab	33 c0		 xor	 eax, eax
  000ad	e9 51 03 00 00	 jmp	 $LN7@ascii_buff
$LN4@ascii_buff:

; 196  :         if (!PyUnicode_IS_ASCII(arg)) {

  000b2	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  000b7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000bb	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000c1	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000c6	85 c0		 test	 eax, eax
  000c8	75 1c		 jne	 SHORT $LN12@ascii_buff
  000ca	41 b8 c4 00 00
	00		 mov	 r8d, 196		; 000000c4H
  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000e4	33 c0		 xor	 eax, eax
$LN12@ascii_buff:
  000e6	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  000eb	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000ee	c1 e8 07	 shr	 eax, 7
  000f1	83 e0 01	 and	 eax, 1
  000f4	85 c0		 test	 eax, eax
  000f6	75 1c		 jne	 SHORT $LN13@ascii_buff
  000f8	41 b8 c4 00 00
	00		 mov	 r8d, 196		; 000000c4H
  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00112	33 c0		 xor	 eax, eax
$LN13@ascii_buff:
  00114	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  00119	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0011c	c1 e8 06	 shr	 eax, 6
  0011f	83 e0 01	 and	 eax, 1
  00122	85 c0		 test	 eax, eax
  00124	75 1a		 jne	 SHORT $LN3@ascii_buff

; 197  :             PyErr_SetString(PyExc_ValueError,
; 198  :                             "string argument should contain only ASCII characters");

  00126	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@JFKKDLIG@string?5argument?5should?5contain?5o@
  0012d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00134	e8 00 00 00 00	 call	 PyErr_SetString

; 199  :             return 0;

  00139	33 c0		 xor	 eax, eax
  0013b	e9 c3 02 00 00	 jmp	 $LN7@ascii_buff
$LN3@ascii_buff:

; 200  :         }
; 201  :         assert(PyUnicode_KIND(arg) == PyUnicode_1BYTE_KIND);

  00140	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  00145	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00149	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0014f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00154	85 c0		 test	 eax, eax
  00156	75 1c		 jne	 SHORT $LN14@ascii_buff
  00158	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00172	33 c0		 xor	 eax, eax
$LN14@ascii_buff:
  00174	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  00179	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0017c	c1 e8 07	 shr	 eax, 7
  0017f	83 e0 01	 and	 eax, 1
  00182	85 c0		 test	 eax, eax
  00184	75 1c		 jne	 SHORT $LN15@ascii_buff
  00186	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  0018c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001a0	33 c0		 xor	 eax, eax
$LN15@ascii_buff:
  001a2	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  001a7	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001aa	c1 e8 02	 shr	 eax, 2
  001ad	83 e0 07	 and	 eax, 7
  001b0	83 f8 01	 cmp	 eax, 1
  001b3	74 1c		 je	 SHORT $LN16@ascii_buff
  001b5	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  001bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FI@LJNJKGJE@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAK?$AAI?$AAN?$AAD?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe@
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001cf	33 c0		 xor	 eax, eax
$LN16@ascii_buff:

; 202  :         buf->buf = (void *) PyUnicode_1BYTE_DATA(arg);

  001d1	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  001d6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001da	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001e0	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  001e5	85 c0		 test	 eax, eax
  001e7	75 1c		 jne	 SHORT $LN17@ascii_buff
  001e9	41 b8 ca 00 00
	00		 mov	 r8d, 202		; 000000caH
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00203	33 c0		 xor	 eax, eax
$LN17@ascii_buff:
  00205	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  0020a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0020d	c1 e8 05	 shr	 eax, 5
  00210	83 e0 01	 and	 eax, 1
  00213	85 c0		 test	 eax, eax
  00215	0f 84 a2 00 00
	00		 je	 $LN23@ascii_buff
  0021b	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  00220	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00224	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0022a	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0022f	85 c0		 test	 eax, eax
  00231	75 1c		 jne	 SHORT $LN18@ascii_buff
  00233	41 b8 ca 00 00
	00		 mov	 r8d, 202		; 000000caH
  00239	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00240	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0024d	33 c0		 xor	 eax, eax
$LN18@ascii_buff:
  0024f	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  00254	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00257	c1 e8 07	 shr	 eax, 7
  0025a	83 e0 01	 and	 eax, 1
  0025d	85 c0		 test	 eax, eax
  0025f	75 1c		 jne	 SHORT $LN19@ascii_buff
  00261	41 b8 ca 00 00
	00		 mov	 r8d, 202		; 000000caH
  00267	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0027b	33 c0		 xor	 eax, eax
$LN19@ascii_buff:
  0027d	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  00282	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00285	c1 e8 06	 shr	 eax, 6
  00288	83 e0 01	 and	 eax, 1
  0028b	85 c0		 test	 eax, eax
  0028d	74 12		 je	 SHORT $LN20@ascii_buff
  0028f	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  00294	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0029a	48 89 44 24 28	 mov	 QWORD PTR tv197[rsp], rax
  0029f	eb 10		 jmp	 SHORT $LN21@ascii_buff
$LN20@ascii_buff:
  002a1	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  002a6	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  002ac	48 89 44 24 28	 mov	 QWORD PTR tv197[rsp], rax
$LN21@ascii_buff:
  002b1	48 8b 44 24 28	 mov	 rax, QWORD PTR tv197[rsp]
  002b6	48 89 44 24 30	 mov	 QWORD PTR tv206[rsp], rax
  002bb	eb 3c		 jmp	 SHORT $LN24@ascii_buff
$LN23@ascii_buff:
  002bd	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  002c2	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  002ca	75 1c		 jne	 SHORT $LN22@ascii_buff
  002cc	41 b8 ca 00 00
	00		 mov	 r8d, 202		; 000000caH
  002d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  002d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@IHJBJEGE@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa?$AAt?$AAa?$AA?4@
  002e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002e6	33 c0		 xor	 eax, eax
$LN22@ascii_buff:
  002e8	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  002ed	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  002f4	48 89 44 24 30	 mov	 QWORD PTR tv206[rsp], rax
$LN24@ascii_buff:
  002f9	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  002fe	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv206[rsp]
  00303	48 89 08	 mov	 QWORD PTR [rax], rcx

; 203  :         buf->len = PyUnicode_GET_LENGTH(arg);

  00306	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  0030b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0030f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00315	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0031a	85 c0		 test	 eax, eax
  0031c	75 1c		 jne	 SHORT $LN25@ascii_buff
  0031e	41 b8 cb 00 00
	00		 mov	 r8d, 203		; 000000cbH
  00324	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0032b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@HLDJJOFK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00332	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00338	33 c0		 xor	 eax, eax
$LN25@ascii_buff:
  0033a	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  0033f	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00342	c1 e8 07	 shr	 eax, 7
  00345	83 e0 01	 and	 eax, 1
  00348	85 c0		 test	 eax, eax
  0034a	75 1c		 jne	 SHORT $LN26@ascii_buff
  0034c	41 b8 cb 00 00
	00		 mov	 r8d, 203		; 000000cbH
  00352	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00359	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@DMIAHOHA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAa?$AAr?$AAg?$AA?$CJ?$AA?$AA@
  00360	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00366	33 c0		 xor	 eax, eax
$LN26@ascii_buff:
  00368	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  0036d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR arg$[rsp]
  00372	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00376	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 204  :         buf->obj = NULL;

  0037a	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  0037f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 205  :         return 1;

  00387	b8 01 00 00 00	 mov	 eax, 1
  0038c	eb 75		 jmp	 SHORT $LN7@ascii_buff
$LN5@ascii_buff:

; 206  :     }
; 207  :     if (PyObject_GetBuffer(arg, buf, PyBUF_SIMPLE) != 0) {

  0038e	45 33 c0	 xor	 r8d, r8d
  00391	48 8b 54 24 58	 mov	 rdx, QWORD PTR buf$[rsp]
  00396	48 8b 4c 24 50	 mov	 rcx, QWORD PTR arg$[rsp]
  0039b	e8 00 00 00 00	 call	 PyObject_GetBuffer
  003a0	85 c0		 test	 eax, eax
  003a2	74 20		 je	 SHORT $LN2@ascii_buff

; 208  :         PyErr_Format(PyExc_TypeError,
; 209  :                      "argument should be bytes, buffer or ASCII string, "
; 210  :                      "not %R", Py_TYPE(arg));

  003a4	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  003a9	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  003ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@KJEFFGLI@argument?5should?5be?5bytes?0?5buffer@
  003b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  003bb	e8 00 00 00 00	 call	 PyErr_Format

; 211  :         return 0;

  003c0	33 c0		 xor	 eax, eax
  003c2	eb 3f		 jmp	 SHORT $LN7@ascii_buff
$LN2@ascii_buff:

; 212  :     }
; 213  :     if (!PyBuffer_IsContiguous(buf, 'C')) {

  003c4	b2 43		 mov	 dl, 67			; 00000043H
  003c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  003cb	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  003d0	85 c0		 test	 eax, eax
  003d2	75 2a		 jne	 SHORT $LN1@ascii_buff

; 214  :         PyErr_Format(PyExc_TypeError,
; 215  :                      "argument should be a contiguous buffer, "
; 216  :                      "not %R", Py_TYPE(arg));

  003d4	48 8b 44 24 50	 mov	 rax, QWORD PTR arg$[rsp]
  003d9	4c 8b 40 58	 mov	 r8, QWORD PTR [rax+88]
  003dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@DIBACIBP@argument?5should?5be?5a?5contiguous?5@
  003e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  003eb	e8 00 00 00 00	 call	 PyErr_Format

; 217  :         PyBuffer_Release(buf);

  003f0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  003f5	e8 00 00 00 00	 call	 PyBuffer_Release

; 218  :         return 0;

  003fa	33 c0		 xor	 eax, eax
  003fc	eb 05		 jmp	 SHORT $LN7@ascii_buff
$LN1@ascii_buff:

; 219  :     }
; 220  :     return Py_CLEANUP_SUPPORTED;

  003fe	b8 00 00 02 00	 mov	 eax, 131072		; 00020000H
$LN7@ascii_buff:

; 221  : }

  00403	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00407	c3		 ret	 0
ascii_buffer_converter ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@OGBOGGHJ@At?5most?545?5bytes?5at?5once?$AA@ ; `string'
PUBLIC	??_C@_09HHCOODDI@y?$CK?3b2a_uu?$AA@		; `string'
EXTRN	_PyBytes_Resize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_b2a_uu DD imagerel binascii_b2a_uu
	DD	imagerel binascii_b2a_uu+714
	DD	imagerel $unwind$binascii_b2a_uu
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_b2a_uu DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_0BJ@OGBOGGHJ@At?5most?545?5bytes?5at?5once?$AA@
CONST	SEGMENT
??_C@_0BJ@OGBOGGHJ@At?5most?545?5bytes?5at?5once?$AA@ DB 'At most 45 byte'
	DB	's at once', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09HHCOODDI@y?$CK?3b2a_uu?$AA@
CONST	SEGMENT
??_C@_09HHCOODDI@y?$CK?3b2a_uu?$AA@ DB 'y*:b2a_uu', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_b2a_uu
_TEXT	SEGMENT
bin_len$ = 32
this_ch$ = 40
leftchar$ = 44
bin_data$ = 48
pbin$ = 64
ascii_data$ = 144
rv$ = 152
leftbits$ = 160
self$ = 192
args$ = 200
binascii_b2a_uu PROC					; COMDAT

; 314  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 315  :     Py_buffer pbin;
; 316  :     unsigned char *ascii_data, *bin_data;
; 317  :     int leftbits = 0;

  00011	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR leftbits$[rsp], 0

; 318  :     unsigned char this_ch;
; 319  :     unsigned int leftchar = 0;

  0001c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR leftchar$[rsp], 0

; 320  :     PyObject *rv;
; 321  :     Py_ssize_t bin_len;
; 322  : 
; 323  :     if ( !PyArg_ParseTuple(args, "y*:b2a_uu", &pbin) )

  00024	4c 8d 44 24 40	 lea	 r8, QWORD PTR pbin$[rsp]
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09HHCOODDI@y?$CK?3b2a_uu?$AA@
  00030	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00038	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003d	85 c0		 test	 eax, eax
  0003f	75 07		 jne	 SHORT $LN12@binascii_b

; 324  :         return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	e9 7a 02 00 00	 jmp	 $LN13@binascii_b
$LN12@binascii_b:

; 325  :     bin_data = pbin.buf;

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR pbin$[rsp]
  0004d	48 89 44 24 30	 mov	 QWORD PTR bin_data$[rsp], rax

; 326  :     bin_len = pbin.len;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR pbin$[rsp+16]
  00057	48 89 44 24 20	 mov	 QWORD PTR bin_len$[rsp], rax

; 327  :     if ( bin_len > 45 ) {

  0005c	48 83 7c 24 20
	2d		 cmp	 QWORD PTR bin_len$[rsp], 45 ; 0000002dH
  00062	7e 24		 jle	 SHORT $LN11@binascii_b

; 328  :         /* The 45 is a limit that appears in all uuencode's */
; 329  :         PyErr_SetString(Error, "At most 45 bytes at once");

  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@OGBOGGHJ@At?5most?545?5bytes?5at?5once?$AA@
  0006b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  00072	e8 00 00 00 00	 call	 PyErr_SetString

; 330  :         PyBuffer_Release(&pbin);

  00077	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pbin$[rsp]
  0007c	e8 00 00 00 00	 call	 PyBuffer_Release

; 331  :         return NULL;

  00081	33 c0		 xor	 eax, eax
  00083	e9 3a 02 00 00	 jmp	 $LN13@binascii_b
$LN11@binascii_b:

; 332  :     }
; 333  : 
; 334  :     /* We're lazy and allocate to much (fixed up later) */
; 335  :     if ( (rv=PyBytes_FromStringAndSize(NULL, 2 + (bin_len+2)/3*4)) == NULL ) {

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR bin_len$[rsp]
  0008d	48 83 c0 02	 add	 rax, 2
  00091	48 99		 cdq
  00093	b9 03 00 00 00	 mov	 ecx, 3
  00098	48 f7 f9	 idiv	 rcx
  0009b	48 8d 04 85 02
	00 00 00	 lea	 rax, QWORD PTR [rax*4+2]
  000a3	48 8b d0	 mov	 rdx, rax
  000a6	33 c9		 xor	 ecx, ecx
  000a8	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000ad	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  000b5	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR rv$[rsp], 0
  000be	75 11		 jne	 SHORT $LN10@binascii_b

; 336  :         PyBuffer_Release(&pbin);

  000c0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pbin$[rsp]
  000c5	e8 00 00 00 00	 call	 PyBuffer_Release

; 337  :         return NULL;

  000ca	33 c0		 xor	 eax, eax
  000cc	e9 f1 01 00 00	 jmp	 $LN13@binascii_b
$LN10@binascii_b:

; 338  :     }
; 339  :     ascii_data = (unsigned char *)PyBytes_AS_STRING(rv);

  000d1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  000d9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000dd	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000e3	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000e8	85 c0		 test	 eax, eax
  000ea	75 1c		 jne	 SHORT $LN15@binascii_b
  000ec	41 b8 53 01 00
	00		 mov	 r8d, 339		; 00000153H
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00106	33 c0		 xor	 eax, eax
$LN15@binascii_b:
  00108	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00110	48 83 c0 78	 add	 rax, 120		; 00000078H
  00114	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 340  : 
; 341  :     /* Store the length */
; 342  :     *ascii_data++ = ' ' + (bin_len & 077);

  0011c	48 8b 44 24 20	 mov	 rax, QWORD PTR bin_len$[rsp]
  00121	48 83 e0 3f	 and	 rax, 63			; 0000003fH
  00125	48 83 c0 20	 add	 rax, 32			; 00000020H
  00129	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ascii_data$[rsp]
  00131	88 01		 mov	 BYTE PTR [rcx], al
  00133	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  0013b	48 ff c0	 inc	 rax
  0013e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 343  : 
; 344  :     for( ; bin_len > 0 || leftbits != 0 ; bin_len--, bin_data++ ) {

  00146	eb 1a		 jmp	 SHORT $LN9@binascii_b
$LN8@binascii_b:
  00148	48 8b 44 24 20	 mov	 rax, QWORD PTR bin_len$[rsp]
  0014d	48 ff c8	 dec	 rax
  00150	48 89 44 24 20	 mov	 QWORD PTR bin_len$[rsp], rax
  00155	48 8b 44 24 30	 mov	 rax, QWORD PTR bin_data$[rsp]
  0015a	48 ff c0	 inc	 rax
  0015d	48 89 44 24 30	 mov	 QWORD PTR bin_data$[rsp], rax
$LN9@binascii_b:
  00162	48 83 7c 24 20
	00		 cmp	 QWORD PTR bin_len$[rsp], 0
  00168	7f 0e		 jg	 SHORT $LN6@binascii_b
  0016a	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR leftbits$[rsp], 0
  00172	0f 84 9c 00 00
	00		 je	 $LN7@binascii_b
$LN6@binascii_b:

; 345  :         /* Shift the data (or padding) into our buffer */
; 346  :         if ( bin_len > 0 )              /* Data */

  00178	48 83 7c 24 20
	00		 cmp	 QWORD PTR bin_len$[rsp], 0
  0017e	7e 17		 jle	 SHORT $LN5@binascii_b

; 347  :             leftchar = (leftchar << 8) | *bin_data;

  00180	8b 44 24 2c	 mov	 eax, DWORD PTR leftchar$[rsp]
  00184	c1 e0 08	 shl	 eax, 8
  00187	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bin_data$[rsp]
  0018c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0018f	0b c1		 or	 eax, ecx
  00191	89 44 24 2c	 mov	 DWORD PTR leftchar$[rsp], eax

; 348  :         else                            /* Padding */

  00195	eb 0b		 jmp	 SHORT $LN4@binascii_b
$LN5@binascii_b:

; 349  :             leftchar <<= 8;

  00197	8b 44 24 2c	 mov	 eax, DWORD PTR leftchar$[rsp]
  0019b	c1 e0 08	 shl	 eax, 8
  0019e	89 44 24 2c	 mov	 DWORD PTR leftchar$[rsp], eax
$LN4@binascii_b:

; 350  :         leftbits += 8;

  001a2	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR leftbits$[rsp]
  001a9	83 c0 08	 add	 eax, 8
  001ac	89 84 24 a0 00
	00 00		 mov	 DWORD PTR leftbits$[rsp], eax
$LN3@binascii_b:

; 351  : 
; 352  :         /* See if there are 6-bit groups ready */
; 353  :         while ( leftbits >= 6 ) {

  001b3	83 bc 24 a0 00
	00 00 06	 cmp	 DWORD PTR leftbits$[rsp], 6
  001bb	7c 52		 jl	 SHORT $LN2@binascii_b

; 354  :             this_ch = (leftchar >> (leftbits-6)) & 0x3f;

  001bd	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR leftbits$[rsp]
  001c4	83 e8 06	 sub	 eax, 6
  001c7	0f b6 c8	 movzx	 ecx, al
  001ca	8b 44 24 2c	 mov	 eax, DWORD PTR leftchar$[rsp]
  001ce	d3 e8		 shr	 eax, cl
  001d0	83 e0 3f	 and	 eax, 63			; 0000003fH
  001d3	88 44 24 28	 mov	 BYTE PTR this_ch$[rsp], al

; 355  :             leftbits -= 6;

  001d7	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR leftbits$[rsp]
  001de	83 e8 06	 sub	 eax, 6
  001e1	89 84 24 a0 00
	00 00		 mov	 DWORD PTR leftbits$[rsp], eax

; 356  :             *ascii_data++ = this_ch + ' ';

  001e8	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  001ed	83 c0 20	 add	 eax, 32			; 00000020H
  001f0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ascii_data$[rsp]
  001f8	88 01		 mov	 BYTE PTR [rcx], al
  001fa	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00202	48 ff c0	 inc	 rax
  00205	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 357  :         }

  0020d	eb a4		 jmp	 SHORT $LN3@binascii_b
$LN2@binascii_b:

; 358  :     }

  0020f	e9 34 ff ff ff	 jmp	 $LN8@binascii_b
$LN7@binascii_b:

; 359  :     *ascii_data++ = '\n';       /* Append a courtesy newline */

  00214	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  0021c	c6 00 0a	 mov	 BYTE PTR [rax], 10
  0021f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00227	48 ff c0	 inc	 rax
  0022a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 360  : 
; 361  :     if (_PyBytes_Resize(&rv,
; 362  :                        (ascii_data -
; 363  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  00232	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  0023a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0023e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00244	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00249	85 c0		 test	 eax, eax
  0024b	75 1c		 jne	 SHORT $LN16@binascii_b
  0024d	41 b8 6b 01 00
	00		 mov	 r8d, 363		; 0000016bH
  00253	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0025a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00267	33 c0		 xor	 eax, eax
$LN16@binascii_b:
  00269	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00271	48 83 c0 78	 add	 rax, 120		; 00000078H
  00275	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ascii_data$[rsp]
  0027d	48 2b c8	 sub	 rcx, rax
  00280	48 8b c1	 mov	 rax, rcx
  00283	48 8b d0	 mov	 rdx, rax
  00286	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  0028e	e8 00 00 00 00	 call	 _PyBytes_Resize
  00293	85 c0		 test	 eax, eax
  00295	7d 19		 jge	 SHORT $LN1@binascii_b

; 364  :         Py_DECREF(rv);

  00297	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  0029f	e8 00 00 00 00	 call	 _Py_DecRef

; 365  :         rv = NULL;

  002a4	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0
$LN1@binascii_b:

; 366  :     }
; 367  :     PyBuffer_Release(&pbin);

  002b0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pbin$[rsp]
  002b5	e8 00 00 00 00	 call	 PyBuffer_Release

; 368  :     return rv;

  002ba	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN13@binascii_b:

; 369  : }

  002c2	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002c9	c3		 ret	 0
binascii_b2a_uu ENDP
_TEXT	ENDS
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BC@GLDEFDCI@Incorrect?5padding?$AA@	; `string'
PUBLIC	??_C@_0O@CBOEKKAP@O?$CG?3a2b_base64?$AA@	; `string'
EXTRN	PyErr_NoMemory:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_a2b_base64 DD imagerel binascii_a2b_base64
	DD	imagerel binascii_a2b_base64+861
	DD	imagerel $unwind$binascii_a2b_base64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_a2b_base64 DD 021101H
	DD	0190111H
xdata	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GLDEFDCI@Incorrect?5padding?$AA@
CONST	SEGMENT
??_C@_0BC@GLDEFDCI@Incorrect?5padding?$AA@ DB 'Incorrect padding', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CBOEKKAP@O?$CG?3a2b_base64?$AA@
CONST	SEGMENT
??_C@_0O@CBOEKKAP@O?$CG?3a2b_base64?$AA@ DB 'O&:a2b_base64', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_a2b_base64
_TEXT	SEGMENT
bin_len$ = 32
this_ch$ = 40
leftchar$ = 44
bin_data$ = 48
quad_pos$ = 56
ascii_data$ = 64
rv$ = 72
leftbits$ = 80
pascii$ = 96
ascii_len$ = 176
tv229 = 184
self$ = 208
args$ = 216
binascii_a2b_base64 PROC				; COMDAT

; 401  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 402  :     Py_buffer pascii;
; 403  :     unsigned char *ascii_data, *bin_data;
; 404  :     int leftbits = 0;

  00011	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR leftbits$[rsp], 0

; 405  :     unsigned char this_ch;
; 406  :     unsigned int leftchar = 0;

  00019	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR leftchar$[rsp], 0

; 407  :     PyObject *rv;
; 408  :     Py_ssize_t ascii_len, bin_len;
; 409  :     int quad_pos = 0;

  00021	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR quad_pos$[rsp], 0

; 410  : 
; 411  :     if ( !PyArg_ParseTuple(args, "O&:a2b_base64", ascii_buffer_converter, &pascii) )

  00029	4c 8d 4c 24 60	 lea	 r9, QWORD PTR pascii$[rsp]
  0002e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ascii_buffer_converter
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@CBOEKKAP@O?$CG?3a2b_base64?$AA@
  0003c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00044	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00049	85 c0		 test	 eax, eax
  0004b	75 07		 jne	 SHORT $LN18@binascii_a@2

; 412  :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	e9 01 03 00 00	 jmp	 $LN19@binascii_a@2
$LN18@binascii_a@2:

; 413  :     ascii_data = pascii.buf;

  00054	48 8b 44 24 60	 mov	 rax, QWORD PTR pascii$[rsp]
  00059	48 89 44 24 40	 mov	 QWORD PTR ascii_data$[rsp], rax

; 414  :     ascii_len = pascii.len;

  0005e	48 8b 44 24 70	 mov	 rax, QWORD PTR pascii$[rsp+16]
  00063	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ascii_len$[rsp], rax

; 415  : 
; 416  :     assert(ascii_len >= 0);

  0006b	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR ascii_len$[rsp], 0
  00074	7d 1c		 jge	 SHORT $LN21@binascii_a@2
  00076	41 b8 a0 01 00
	00		 mov	 r8d, 416		; 000001a0H
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@HHIKJINI@?$AAa?$AAs?$AAc?$AAi?$AAi?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00090	33 c0		 xor	 eax, eax
$LN21@binascii_a@2:

; 417  : 
; 418  :     if (ascii_len > PY_SSIZE_T_MAX - 3) {

  00092	48 b8 fc ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775804 ; 7ffffffffffffffcH
  0009c	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR ascii_len$[rsp], rax
  000a4	7e 14		 jle	 SHORT $LN17@binascii_a@2

; 419  :         PyBuffer_Release(&pascii);

  000a6	48 8d 4c 24 60	 lea	 rcx, QWORD PTR pascii$[rsp]
  000ab	e8 00 00 00 00	 call	 PyBuffer_Release

; 420  :         return PyErr_NoMemory();

  000b0	e8 00 00 00 00	 call	 PyErr_NoMemory
  000b5	e9 9b 02 00 00	 jmp	 $LN19@binascii_a@2
$LN17@binascii_a@2:

; 421  :     }
; 422  : 
; 423  :     bin_len = ((ascii_len+3)/4)*3; /* Upper bound, corrected later */

  000ba	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ascii_len$[rsp]
  000c2	48 83 c0 03	 add	 rax, 3
  000c6	48 99		 cdq
  000c8	48 83 e2 03	 and	 rdx, 3
  000cc	48 03 c2	 add	 rax, rdx
  000cf	48 c1 f8 02	 sar	 rax, 2
  000d3	48 6b c0 03	 imul	 rax, 3
  000d7	48 89 44 24 20	 mov	 QWORD PTR bin_len$[rsp], rax

; 424  : 
; 425  :     /* Allocate the buffer */
; 426  :     if ( (rv=PyBytes_FromStringAndSize(NULL, bin_len)) == NULL ) {

  000dc	48 8b 54 24 20	 mov	 rdx, QWORD PTR bin_len$[rsp]
  000e1	33 c9		 xor	 ecx, ecx
  000e3	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000e8	48 89 44 24 48	 mov	 QWORD PTR rv$[rsp], rax
  000ed	48 83 7c 24 48
	00		 cmp	 QWORD PTR rv$[rsp], 0
  000f3	75 11		 jne	 SHORT $LN16@binascii_a@2

; 427  :         PyBuffer_Release(&pascii);

  000f5	48 8d 4c 24 60	 lea	 rcx, QWORD PTR pascii$[rsp]
  000fa	e8 00 00 00 00	 call	 PyBuffer_Release

; 428  :         return NULL;

  000ff	33 c0		 xor	 eax, eax
  00101	e9 4f 02 00 00	 jmp	 $LN19@binascii_a@2
$LN16@binascii_a@2:

; 429  :     }
; 430  :     bin_data = (unsigned char *)PyBytes_AS_STRING(rv);

  00106	48 8b 44 24 48	 mov	 rax, QWORD PTR rv$[rsp]
  0010b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0010f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00115	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0011a	85 c0		 test	 eax, eax
  0011c	75 1c		 jne	 SHORT $LN22@binascii_a@2
  0011e	41 b8 ae 01 00
	00		 mov	 r8d, 430		; 000001aeH
  00124	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0012b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00138	33 c0		 xor	 eax, eax
$LN22@binascii_a@2:
  0013a	48 8b 44 24 48	 mov	 rax, QWORD PTR rv$[rsp]
  0013f	48 83 c0 78	 add	 rax, 120		; 00000078H
  00143	48 89 44 24 30	 mov	 QWORD PTR bin_data$[rsp], rax

; 431  :     bin_len = 0;

  00148	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR bin_len$[rsp], 0

; 432  : 
; 433  :     for( ; ascii_len > 0; ascii_len--, ascii_data++) {

  00151	eb 20		 jmp	 SHORT $LN15@binascii_a@2
$LN14@binascii_a@2:
  00153	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ascii_len$[rsp]
  0015b	48 ff c8	 dec	 rax
  0015e	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ascii_len$[rsp], rax
  00166	48 8b 44 24 40	 mov	 rax, QWORD PTR ascii_data$[rsp]
  0016b	48 ff c0	 inc	 rax
  0016e	48 89 44 24 40	 mov	 QWORD PTR ascii_data$[rsp], rax
$LN15@binascii_a@2:
  00173	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR ascii_len$[rsp], 0
  0017c	0f 8e 45 01 00
	00		 jle	 $LN13@binascii_a@2

; 434  :         this_ch = *ascii_data;

  00182	48 8b 44 24 40	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00187	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0018a	88 44 24 28	 mov	 BYTE PTR this_ch$[rsp], al

; 435  : 
; 436  :         if (this_ch > 0x7f ||
; 437  :             this_ch == '\r' || this_ch == '\n' || this_ch == ' ')

  0018e	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  00193	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00196	7f 1e		 jg	 SHORT $LN11@binascii_a@2
  00198	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  0019d	83 f8 0d	 cmp	 eax, 13
  001a0	74 14		 je	 SHORT $LN11@binascii_a@2
  001a2	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  001a7	83 f8 0a	 cmp	 eax, 10
  001aa	74 0a		 je	 SHORT $LN11@binascii_a@2
  001ac	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  001b1	83 f8 20	 cmp	 eax, 32			; 00000020H
  001b4	75 02		 jne	 SHORT $LN12@binascii_a@2
$LN11@binascii_a@2:

; 438  :             continue;

  001b6	eb 9b		 jmp	 SHORT $LN14@binascii_a@2
$LN12@binascii_a@2:

; 439  : 
; 440  :         /* Check for pad sequences and ignore
; 441  :         ** the invalid ones.
; 442  :         */
; 443  :         if (this_ch == BASE64_PAD) {

  001b8	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  001bd	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  001c0	75 3f		 jne	 SHORT $LN10@binascii_a@2

; 444  :             if ( (quad_pos < 2) ||
; 445  :                  ((quad_pos == 2) &&
; 446  :                   (binascii_find_valid(ascii_data, ascii_len, 1)
; 447  :                    != BASE64_PAD)) )

  001c2	83 7c 24 38 02	 cmp	 DWORD PTR quad_pos$[rsp], 2
  001c7	7c 24		 jl	 SHORT $LN8@binascii_a@2
  001c9	83 7c 24 38 02	 cmp	 DWORD PTR quad_pos$[rsp], 2
  001ce	75 24		 jne	 SHORT $LN9@binascii_a@2
  001d0	41 b8 01 00 00
	00		 mov	 r8d, 1
  001d6	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ascii_len$[rsp]
  001de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ascii_data$[rsp]
  001e3	e8 00 00 00 00	 call	 binascii_find_valid
  001e8	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  001eb	74 07		 je	 SHORT $LN9@binascii_a@2
$LN8@binascii_a@2:

; 448  :             {
; 449  :                 continue;

  001ed	e9 61 ff ff ff	 jmp	 $LN14@binascii_a@2

; 450  :             }
; 451  :             else {

  001f2	eb 0d		 jmp	 SHORT $LN7@binascii_a@2
$LN9@binascii_a@2:

; 452  :                 /* A pad sequence means no more input.
; 453  :                 ** We've already interpreted the data
; 454  :                 ** from the quad at this point.
; 455  :                 */
; 456  :                 leftbits = 0;

  001f4	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR leftbits$[rsp], 0

; 457  :                 break;

  001fc	e9 c6 00 00 00	 jmp	 $LN13@binascii_a@2
$LN7@binascii_a@2:
$LN10@binascii_a@2:

; 458  :             }
; 459  :         }
; 460  : 
; 461  :         this_ch = table_a2b_base64[*ascii_data];

  00201	48 8b 44 24 40	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00206	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:table_a2b_base64
  00210	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00214	88 44 24 28	 mov	 BYTE PTR this_ch$[rsp], al

; 462  :         if ( this_ch == (unsigned char) -1 )

  00218	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  0021d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00222	75 05		 jne	 SHORT $LN6@binascii_a@2

; 463  :             continue;

  00224	e9 2a ff ff ff	 jmp	 $LN14@binascii_a@2
$LN6@binascii_a@2:

; 464  : 
; 465  :         /*
; 466  :         ** Shift it in on the low end, and see if there's
; 467  :         ** a byte ready for output.
; 468  :         */
; 469  :         quad_pos = (quad_pos + 1) & 0x03;

  00229	8b 44 24 38	 mov	 eax, DWORD PTR quad_pos$[rsp]
  0022d	ff c0		 inc	 eax
  0022f	83 e0 03	 and	 eax, 3
  00232	89 44 24 38	 mov	 DWORD PTR quad_pos$[rsp], eax

; 470  :         leftchar = (leftchar << 6) | (this_ch);

  00236	8b 44 24 2c	 mov	 eax, DWORD PTR leftchar$[rsp]
  0023a	c1 e0 06	 shl	 eax, 6
  0023d	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR this_ch$[rsp]
  00242	0b c1		 or	 eax, ecx
  00244	89 44 24 2c	 mov	 DWORD PTR leftchar$[rsp], eax

; 471  :         leftbits += 6;

  00248	8b 44 24 50	 mov	 eax, DWORD PTR leftbits$[rsp]
  0024c	83 c0 06	 add	 eax, 6
  0024f	89 44 24 50	 mov	 DWORD PTR leftbits$[rsp], eax

; 472  : 
; 473  :         if ( leftbits >= 8 ) {

  00253	83 7c 24 50 08	 cmp	 DWORD PTR leftbits$[rsp], 8
  00258	7c 68		 jl	 SHORT $LN5@binascii_a@2

; 474  :             leftbits -= 8;

  0025a	8b 44 24 50	 mov	 eax, DWORD PTR leftbits$[rsp]
  0025e	83 e8 08	 sub	 eax, 8
  00261	89 44 24 50	 mov	 DWORD PTR leftbits$[rsp], eax

; 475  :             *bin_data++ = (leftchar >> leftbits) & 0xff;

  00265	8b 44 24 50	 mov	 eax, DWORD PTR leftbits$[rsp]
  00269	0f b6 c8	 movzx	 ecx, al
  0026c	8b 44 24 2c	 mov	 eax, DWORD PTR leftchar$[rsp]
  00270	d3 e8		 shr	 eax, cl
  00272	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00277	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bin_data$[rsp]
  0027c	88 01		 mov	 BYTE PTR [rcx], al
  0027e	48 8b 44 24 30	 mov	 rax, QWORD PTR bin_data$[rsp]
  00283	48 ff c0	 inc	 rax
  00286	48 89 44 24 30	 mov	 QWORD PTR bin_data$[rsp], rax

; 476  :             bin_len++;

  0028b	48 8b 44 24 20	 mov	 rax, QWORD PTR bin_len$[rsp]
  00290	48 ff c0	 inc	 rax
  00293	48 89 44 24 20	 mov	 QWORD PTR bin_len$[rsp], rax

; 477  :             leftchar &= ((1 << leftbits) - 1);

  00298	8b 44 24 50	 mov	 eax, DWORD PTR leftbits$[rsp]
  0029c	b9 01 00 00 00	 mov	 ecx, 1
  002a1	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv229[rsp], ecx
  002a8	0f b6 c8	 movzx	 ecx, al
  002ab	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv229[rsp]
  002b2	d3 e0		 shl	 eax, cl
  002b4	ff c8		 dec	 eax
  002b6	8b 4c 24 2c	 mov	 ecx, DWORD PTR leftchar$[rsp]
  002ba	23 c8		 and	 ecx, eax
  002bc	8b c1		 mov	 eax, ecx
  002be	89 44 24 2c	 mov	 DWORD PTR leftchar$[rsp], eax
$LN5@binascii_a@2:

; 478  :         }
; 479  :     }

  002c2	e9 8c fe ff ff	 jmp	 $LN14@binascii_a@2
$LN13@binascii_a@2:

; 480  : 
; 481  :     if (leftbits != 0) {

  002c7	83 7c 24 50 00	 cmp	 DWORD PTR leftbits$[rsp], 0
  002cc	74 2b		 je	 SHORT $LN4@binascii_a@2

; 482  :         PyBuffer_Release(&pascii);

  002ce	48 8d 4c 24 60	 lea	 rcx, QWORD PTR pascii$[rsp]
  002d3	e8 00 00 00 00	 call	 PyBuffer_Release

; 483  :         PyErr_SetString(Error, "Incorrect padding");

  002d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@GLDEFDCI@Incorrect?5padding?$AA@
  002df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  002e6	e8 00 00 00 00	 call	 PyErr_SetString

; 484  :         Py_DECREF(rv);

  002eb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rv$[rsp]
  002f0	e8 00 00 00 00	 call	 _Py_DecRef

; 485  :         return NULL;

  002f5	33 c0		 xor	 eax, eax
  002f7	eb 5c		 jmp	 SHORT $LN19@binascii_a@2
$LN4@binascii_a@2:

; 486  :     }
; 487  : 
; 488  :     /* And set string size correctly. If the result string is empty
; 489  :     ** (because the input was all invalid) return the shared empty
; 490  :     ** string instead; _PyBytes_Resize() won't do this for us.
; 491  :     */
; 492  :     if (bin_len > 0) {

  002f9	48 83 7c 24 20
	00		 cmp	 QWORD PTR bin_len$[rsp], 0
  002ff	7e 28		 jle	 SHORT $LN3@binascii_a@2

; 493  :         if (_PyBytes_Resize(&rv, bin_len) < 0) {

  00301	48 8b 54 24 20	 mov	 rdx, QWORD PTR bin_len$[rsp]
  00306	48 8d 4c 24 48	 lea	 rcx, QWORD PTR rv$[rsp]
  0030b	e8 00 00 00 00	 call	 _PyBytes_Resize
  00310	85 c0		 test	 eax, eax
  00312	7d 13		 jge	 SHORT $LN2@binascii_a@2

; 494  :             Py_DECREF(rv);

  00314	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rv$[rsp]
  00319	e8 00 00 00 00	 call	 _Py_DecRef

; 495  :             rv = NULL;

  0031e	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR rv$[rsp], 0
$LN2@binascii_a@2:

; 496  :         }
; 497  :     }
; 498  :     else {

  00327	eb 1d		 jmp	 SHORT $LN1@binascii_a@2
$LN3@binascii_a@2:

; 499  :         Py_DECREF(rv);

  00329	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rv$[rsp]
  0032e	e8 00 00 00 00	 call	 _Py_DecRef

; 500  :         rv = PyBytes_FromStringAndSize("", 0);

  00333	33 d2		 xor	 edx, edx
  00335	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0033c	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00341	48 89 44 24 48	 mov	 QWORD PTR rv$[rsp], rax
$LN1@binascii_a@2:

; 501  :     }
; 502  :     PyBuffer_Release(&pascii);

  00346	48 8d 4c 24 60	 lea	 rcx, QWORD PTR pascii$[rsp]
  0034b	e8 00 00 00 00	 call	 PyBuffer_Release

; 503  :     return rv;

  00350	48 8b 44 24 48	 mov	 rax, QWORD PTR rv$[rsp]
$LN19@binascii_a@2:

; 504  : }

  00355	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0035c	c3		 ret	 0
binascii_a2b_base64 ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_find_valid DD imagerel binascii_find_valid
	DD	imagerel binascii_find_valid+168
	DD	imagerel $unwind$binascii_find_valid
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_find_valid DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT binascii_find_valid
_TEXT	SEGMENT
b64val$ = 0
ret$ = 4
c$ = 8
s$ = 32
slen$ = 40
num$ = 48
binascii_find_valid PROC				; COMDAT

; 374  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 375  :     /* Finds & returns the (num+1)th
; 376  :     ** valid character for base64, or -1 if none.
; 377  :     */
; 378  : 
; 379  :     int ret = -1;

  00013	c7 44 24 04 ff
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -1
$LN4@binascii_f:

; 380  :     unsigned char c, b64val;
; 381  : 
; 382  :     while ((slen > 0) && (ret == -1)) {

  0001b	48 83 7c 24 28
	00		 cmp	 QWORD PTR slen$[rsp], 0
  00021	7e 7c		 jle	 SHORT $LN3@binascii_f
  00023	83 7c 24 04 ff	 cmp	 DWORD PTR ret$[rsp], -1
  00028	75 75		 jne	 SHORT $LN3@binascii_f

; 383  :         c = *s;

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	88 44 24 08	 mov	 BYTE PTR c$[rsp], al

; 384  :         b64val = table_a2b_base64[c & 0x7f];

  00036	0f b6 44 24 08	 movzx	 eax, BYTE PTR c$[rsp]
  0003b	83 e0 7f	 and	 eax, 127		; 0000007fH
  0003e	48 98		 cdqe
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:table_a2b_base64
  00047	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004b	88 04 24	 mov	 BYTE PTR b64val$[rsp], al

; 385  :         if ( ((c <= 0x7f) && (b64val != (unsigned char)-1)) ) {

  0004e	0f b6 44 24 08	 movzx	 eax, BYTE PTR c$[rsp]
  00053	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00056	7f 28		 jg	 SHORT $LN2@binascii_f
  00058	0f b6 04 24	 movzx	 eax, BYTE PTR b64val$[rsp]
  0005c	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00061	74 1d		 je	 SHORT $LN2@binascii_f

; 386  :             if (num == 0)

  00063	83 7c 24 30 00	 cmp	 DWORD PTR num$[rsp], 0
  00068	75 0c		 jne	 SHORT $LN1@binascii_f

; 387  :                 ret = *s;

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0006f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00072	89 44 24 04	 mov	 DWORD PTR ret$[rsp], eax
$LN1@binascii_f:

; 388  :             num--;

  00076	8b 44 24 30	 mov	 eax, DWORD PTR num$[rsp]
  0007a	ff c8		 dec	 eax
  0007c	89 44 24 30	 mov	 DWORD PTR num$[rsp], eax
$LN2@binascii_f:

; 389  :         }
; 390  : 
; 391  :         s++;

  00080	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00085	48 ff c0	 inc	 rax
  00088	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 392  :         slen--;

  0008d	48 8b 44 24 28	 mov	 rax, QWORD PTR slen$[rsp]
  00092	48 ff c8	 dec	 rax
  00095	48 89 44 24 28	 mov	 QWORD PTR slen$[rsp], rax

; 393  :     }

  0009a	e9 7c ff ff ff	 jmp	 $LN4@binascii_f
$LN3@binascii_f:

; 394  :     return ret;

  0009f	8b 44 24 04	 mov	 eax, DWORD PTR ret$[rsp]

; 395  : }

  000a3	48 83 c4 18	 add	 rsp, 24
  000a7	c3		 ret	 0
binascii_find_valid ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@OLCDJGOJ@Too?5much?5data?5for?5base64?5line?$AA@ ; `string'
PUBLIC	??_C@_1BK@NNJONPNK@?$AAb?$AAi?$AAn?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0O@EICFEGDC@y?$CK?3b2a_base64?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_b2a_base64 DD imagerel binascii_b2a_base64
	DD	imagerel binascii_b2a_base64+893
	DD	imagerel $unwind$binascii_b2a_base64
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_b2a_base64 DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_0BO@OLCDJGOJ@Too?5much?5data?5for?5base64?5line?$AA@
CONST	SEGMENT
??_C@_0BO@OLCDJGOJ@Too?5much?5data?5for?5base64?5line?$AA@ DB 'Too much d'
	DB	'ata for base64 line', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NNJONPNK@?$AAb?$AAi?$AAn?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NNJONPNK@?$AAb?$AAi?$AAn?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'b'
	DB	00H, 'i', 00H, 'n', 00H, '_', 00H, 'l', 00H, 'e', 00H, 'n', 00H
	DB	' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EICFEGDC@y?$CK?3b2a_base64?$AA@
CONST	SEGMENT
??_C@_0O@EICFEGDC@y?$CK?3b2a_base64?$AA@ DB 'y*:b2a_base64', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_b2a_base64
_TEXT	SEGMENT
bin_len$ = 32
this_ch$ = 40
leftchar$ = 44
bin_data$ = 48
pbuf$ = 64
ascii_data$ = 144
rv$ = 152
leftbits$ = 160
self$ = 192
args$ = 200
binascii_b2a_base64 PROC				; COMDAT

; 510  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 511  :     Py_buffer pbuf;
; 512  :     unsigned char *ascii_data, *bin_data;
; 513  :     int leftbits = 0;

  00011	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR leftbits$[rsp], 0

; 514  :     unsigned char this_ch;
; 515  :     unsigned int leftchar = 0;

  0001c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR leftchar$[rsp], 0

; 516  :     PyObject *rv;
; 517  :     Py_ssize_t bin_len;
; 518  : 
; 519  :     if ( !PyArg_ParseTuple(args, "y*:b2a_base64", &pbuf) )

  00024	4c 8d 44 24 40	 lea	 r8, QWORD PTR pbuf$[rsp]
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@EICFEGDC@y?$CK?3b2a_base64?$AA@
  00030	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00038	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003d	85 c0		 test	 eax, eax
  0003f	75 07		 jne	 SHORT $LN12@binascii_b@2

; 520  :         return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	e9 2d 03 00 00	 jmp	 $LN13@binascii_b@2
$LN12@binascii_b@2:

; 521  :     bin_data = pbuf.buf;

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR pbuf$[rsp]
  0004d	48 89 44 24 30	 mov	 QWORD PTR bin_data$[rsp], rax

; 522  :     bin_len = pbuf.len;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR pbuf$[rsp+16]
  00057	48 89 44 24 20	 mov	 QWORD PTR bin_len$[rsp], rax

; 523  : 
; 524  :     assert(bin_len >= 0);

  0005c	48 83 7c 24 20
	00		 cmp	 QWORD PTR bin_len$[rsp], 0
  00062	7d 1c		 jge	 SHORT $LN15@binascii_b@2
  00064	41 b8 0c 02 00
	00		 mov	 r8d, 524		; 0000020cH
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@NNJONPNK@?$AAb?$AAi?$AAn?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN15@binascii_b@2:

; 525  : 
; 526  :     if ( bin_len > BASE64_MAXBIN ) {

  00080	48 b8 fe ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387902 ; 3ffffffffffffffeH
  0008a	48 39 44 24 20	 cmp	 QWORD PTR bin_len$[rsp], rax
  0008f	7e 24		 jle	 SHORT $LN11@binascii_b@2

; 527  :         PyErr_SetString(Error, "Too much data for base64 line");

  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@OLCDJGOJ@Too?5much?5data?5for?5base64?5line?$AA@
  00098	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  0009f	e8 00 00 00 00	 call	 PyErr_SetString

; 528  :         PyBuffer_Release(&pbuf);

  000a4	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pbuf$[rsp]
  000a9	e8 00 00 00 00	 call	 PyBuffer_Release

; 529  :         return NULL;

  000ae	33 c0		 xor	 eax, eax
  000b0	e9 c0 02 00 00	 jmp	 $LN13@binascii_b@2
$LN11@binascii_b@2:

; 530  :     }
; 531  : 
; 532  :     /* We're lazy and allocate too much (fixed up later).
; 533  :        "+3" leaves room for up to two pad characters and a trailing
; 534  :        newline.  Note that 'b' gets encoded as 'Yg==\n' (1 in, 5 out). */
; 535  :     if ( (rv=PyBytes_FromStringAndSize(NULL, bin_len*2 + 3)) == NULL ) {

  000b5	48 8b 44 24 20	 mov	 rax, QWORD PTR bin_len$[rsp]
  000ba	48 8d 44 00 03	 lea	 rax, QWORD PTR [rax+rax+3]
  000bf	48 8b d0	 mov	 rdx, rax
  000c2	33 c9		 xor	 ecx, ecx
  000c4	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000c9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  000d1	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR rv$[rsp], 0
  000da	75 11		 jne	 SHORT $LN10@binascii_b@2

; 536  :         PyBuffer_Release(&pbuf);

  000dc	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pbuf$[rsp]
  000e1	e8 00 00 00 00	 call	 PyBuffer_Release

; 537  :         return NULL;

  000e6	33 c0		 xor	 eax, eax
  000e8	e9 88 02 00 00	 jmp	 $LN13@binascii_b@2
$LN10@binascii_b@2:

; 538  :     }
; 539  :     ascii_data = (unsigned char *)PyBytes_AS_STRING(rv);

  000ed	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  000f5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000ff	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00104	85 c0		 test	 eax, eax
  00106	75 1c		 jne	 SHORT $LN16@binascii_b@2
  00108	41 b8 1b 02 00
	00		 mov	 r8d, 539		; 0000021bH
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00122	33 c0		 xor	 eax, eax
$LN16@binascii_b@2:
  00124	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  0012c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00130	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 540  : 
; 541  :     for( ; bin_len > 0 ; bin_len--, bin_data++ ) {

  00138	eb 1a		 jmp	 SHORT $LN9@binascii_b@2
$LN8@binascii_b@2:
  0013a	48 8b 44 24 20	 mov	 rax, QWORD PTR bin_len$[rsp]
  0013f	48 ff c8	 dec	 rax
  00142	48 89 44 24 20	 mov	 QWORD PTR bin_len$[rsp], rax
  00147	48 8b 44 24 30	 mov	 rax, QWORD PTR bin_data$[rsp]
  0014c	48 ff c0	 inc	 rax
  0014f	48 89 44 24 30	 mov	 QWORD PTR bin_data$[rsp], rax
$LN9@binascii_b@2:
  00154	48 83 7c 24 20
	00		 cmp	 QWORD PTR bin_len$[rsp], 0
  0015a	0f 8e 8f 00 00
	00		 jle	 $LN7@binascii_b@2

; 542  :         /* Shift the data into our buffer */
; 543  :         leftchar = (leftchar << 8) | *bin_data;

  00160	8b 44 24 2c	 mov	 eax, DWORD PTR leftchar$[rsp]
  00164	c1 e0 08	 shl	 eax, 8
  00167	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bin_data$[rsp]
  0016c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0016f	0b c1		 or	 eax, ecx
  00171	89 44 24 2c	 mov	 DWORD PTR leftchar$[rsp], eax

; 544  :         leftbits += 8;

  00175	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR leftbits$[rsp]
  0017c	83 c0 08	 add	 eax, 8
  0017f	89 84 24 a0 00
	00 00		 mov	 DWORD PTR leftbits$[rsp], eax
$LN6@binascii_b@2:

; 545  : 
; 546  :         /* See if there are 6-bit groups ready */
; 547  :         while ( leftbits >= 6 ) {

  00186	83 bc 24 a0 00
	00 00 06	 cmp	 DWORD PTR leftbits$[rsp], 6
  0018e	7c 5a		 jl	 SHORT $LN5@binascii_b@2

; 548  :             this_ch = (leftchar >> (leftbits-6)) & 0x3f;

  00190	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR leftbits$[rsp]
  00197	83 e8 06	 sub	 eax, 6
  0019a	0f b6 c8	 movzx	 ecx, al
  0019d	8b 44 24 2c	 mov	 eax, DWORD PTR leftchar$[rsp]
  001a1	d3 e8		 shr	 eax, cl
  001a3	83 e0 3f	 and	 eax, 63			; 0000003fH
  001a6	88 44 24 28	 mov	 BYTE PTR this_ch$[rsp], al

; 549  :             leftbits -= 6;

  001aa	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR leftbits$[rsp]
  001b1	83 e8 06	 sub	 eax, 6
  001b4	89 84 24 a0 00
	00 00		 mov	 DWORD PTR leftbits$[rsp], eax

; 550  :             *ascii_data++ = table_b2a_base64[this_ch];

  001bb	0f b6 44 24 28	 movzx	 eax, BYTE PTR this_ch$[rsp]
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:table_b2a_base64
  001c7	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ascii_data$[rsp]
  001cf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d3	88 02		 mov	 BYTE PTR [rdx], al
  001d5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  001dd	48 ff c0	 inc	 rax
  001e0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 551  :         }

  001e8	eb 9c		 jmp	 SHORT $LN6@binascii_b@2
$LN5@binascii_b@2:

; 552  :     }

  001ea	e9 4b ff ff ff	 jmp	 $LN8@binascii_b@2
$LN7@binascii_b@2:

; 553  :     if ( leftbits == 2 ) {

  001ef	83 bc 24 a0 00
	00 00 02	 cmp	 DWORD PTR leftbits$[rsp], 2
  001f7	75 72		 jne	 SHORT $LN4@binascii_b@2

; 554  :         *ascii_data++ = table_b2a_base64[(leftchar&3) << 4];

  001f9	8b 44 24 2c	 mov	 eax, DWORD PTR leftchar$[rsp]
  001fd	83 e0 03	 and	 eax, 3
  00200	c1 e0 04	 shl	 eax, 4
  00203	8b c0		 mov	 eax, eax
  00205	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:table_b2a_base64
  0020c	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ascii_data$[rsp]
  00214	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00218	88 02		 mov	 BYTE PTR [rdx], al
  0021a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00222	48 ff c0	 inc	 rax
  00225	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 555  :         *ascii_data++ = BASE64_PAD;

  0022d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00235	c6 00 3d	 mov	 BYTE PTR [rax], 61	; 0000003dH
  00238	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00240	48 ff c0	 inc	 rax
  00243	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 556  :         *ascii_data++ = BASE64_PAD;

  0024b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00253	c6 00 3d	 mov	 BYTE PTR [rax], 61	; 0000003dH
  00256	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  0025e	48 ff c0	 inc	 rax
  00261	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax
  00269	eb 5c		 jmp	 SHORT $LN3@binascii_b@2
$LN4@binascii_b@2:

; 557  :     } else if ( leftbits == 4 ) {

  0026b	83 bc 24 a0 00
	00 00 04	 cmp	 DWORD PTR leftbits$[rsp], 4
  00273	75 52		 jne	 SHORT $LN2@binascii_b@2

; 558  :         *ascii_data++ = table_b2a_base64[(leftchar&0xf) << 2];

  00275	8b 44 24 2c	 mov	 eax, DWORD PTR leftchar$[rsp]
  00279	83 e0 0f	 and	 eax, 15
  0027c	c1 e0 02	 shl	 eax, 2
  0027f	8b c0		 mov	 eax, eax
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:table_b2a_base64
  00288	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ascii_data$[rsp]
  00290	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00294	88 02		 mov	 BYTE PTR [rdx], al
  00296	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  0029e	48 ff c0	 inc	 rax
  002a1	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 559  :         *ascii_data++ = BASE64_PAD;

  002a9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  002b1	c6 00 3d	 mov	 BYTE PTR [rax], 61	; 0000003dH
  002b4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  002bc	48 ff c0	 inc	 rax
  002bf	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax
$LN2@binascii_b@2:
$LN3@binascii_b@2:

; 560  :     }
; 561  :     *ascii_data++ = '\n';       /* Append a courtesy newline */

  002c7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  002cf	c6 00 0a	 mov	 BYTE PTR [rax], 10
  002d2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  002da	48 ff c0	 inc	 rax
  002dd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 562  : 
; 563  :     if (_PyBytes_Resize(&rv,
; 564  :                        (ascii_data -
; 565  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  002e5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  002ed	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002f1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002f7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002fc	85 c0		 test	 eax, eax
  002fe	75 1c		 jne	 SHORT $LN17@binascii_b@2
  00300	41 b8 35 02 00
	00		 mov	 r8d, 565		; 00000235H
  00306	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0031a	33 c0		 xor	 eax, eax
$LN17@binascii_b@2:
  0031c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00324	48 83 c0 78	 add	 rax, 120		; 00000078H
  00328	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ascii_data$[rsp]
  00330	48 2b c8	 sub	 rcx, rax
  00333	48 8b c1	 mov	 rax, rcx
  00336	48 8b d0	 mov	 rdx, rax
  00339	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  00341	e8 00 00 00 00	 call	 _PyBytes_Resize
  00346	85 c0		 test	 eax, eax
  00348	7d 19		 jge	 SHORT $LN1@binascii_b@2

; 566  :         Py_DECREF(rv);

  0034a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00352	e8 00 00 00 00	 call	 _Py_DecRef

; 567  :         rv = NULL;

  00357	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0
$LN1@binascii_b@2:

; 568  :     }
; 569  :     PyBuffer_Release(&pbuf);

  00363	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pbuf$[rsp]
  00368	e8 00 00 00 00	 call	 PyBuffer_Release

; 570  :     return rv;

  0036d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN13@binascii_b@2:

; 571  : }

  00375	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0037c	c3		 ret	 0
binascii_b2a_base64 ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MPEHDMPO@Oi?$AA@			; `string'
PUBLIC	??_C@_0CG@GGPHDJNH@String?5has?5incomplete?5number?5of?5@ ; `string'
PUBLIC	??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0L@LIBBFGIB@O?$CG?3a2b_hqx?$AA@		; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
_BSS	SEGMENT
Incomplete DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_a2b_hqx DD imagerel binascii_a2b_hqx
	DD	imagerel binascii_a2b_hqx+834
	DD	imagerel $unwind$binascii_a2b_hqx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_a2b_hqx DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_02MPEHDMPO@Oi?$AA@
CONST	SEGMENT
??_C@_02MPEHDMPO@Oi?$AA@ DB 'Oi', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GGPHDJNH@String?5has?5incomplete?5number?5of?5@
CONST	SEGMENT
??_C@_0CG@GGPHDJNH@String?5has?5incomplete?5number?5of?5@ DB 'String has '
	DB	'incomplete number of bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'l'
	DB	00H, 'e', 00H, 'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LIBBFGIB@O?$CG?3a2b_hqx?$AA@
CONST	SEGMENT
??_C@_0L@LIBBFGIB@O?$CG?3a2b_hqx?$AA@ DB 'O&:a2b_hqx', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_a2b_hqx
_TEXT	SEGMENT
this_ch$ = 32
leftchar$ = 36
bin_data$ = 40
len$ = 48
ascii_data$ = 56
rv$ = 64
done$ = 72
leftbits$ = 76
pascii$ = 80
rrv$20634 = 160
tv218 = 168
self$ = 192
args$ = 200
binascii_a2b_hqx PROC					; COMDAT

; 577  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 578  :     Py_buffer pascii;
; 579  :     unsigned char *ascii_data, *bin_data;
; 580  :     int leftbits = 0;

  00011	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR leftbits$[rsp], 0

; 581  :     unsigned char this_ch;
; 582  :     unsigned int leftchar = 0;

  00019	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR leftchar$[rsp], 0

; 583  :     PyObject *rv;
; 584  :     Py_ssize_t len;
; 585  :     int done = 0;

  00021	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR done$[rsp], 0

; 586  : 
; 587  :     if ( !PyArg_ParseTuple(args, "O&:a2b_hqx", ascii_buffer_converter, &pascii) )

  00029	4c 8d 4c 24 50	 lea	 r9, QWORD PTR pascii$[rsp]
  0002e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ascii_buffer_converter
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@LIBBFGIB@O?$CG?3a2b_hqx?$AA@
  0003c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00044	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00049	85 c0		 test	 eax, eax
  0004b	75 07		 jne	 SHORT $LN13@binascii_a@3

; 588  :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	e9 e6 02 00 00	 jmp	 $LN14@binascii_a@3
$LN13@binascii_a@3:

; 589  :     ascii_data = pascii.buf;

  00054	48 8b 44 24 50	 mov	 rax, QWORD PTR pascii$[rsp]
  00059	48 89 44 24 38	 mov	 QWORD PTR ascii_data$[rsp], rax

; 590  :     len = pascii.len;

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR pascii$[rsp+16]
  00063	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax

; 591  : 
; 592  :     assert(len >= 0);

  00068	48 83 7c 24 30
	00		 cmp	 QWORD PTR len$[rsp], 0
  0006e	7d 1c		 jge	 SHORT $LN16@binascii_a@3
  00070	41 b8 50 02 00
	00		 mov	 r8d, 592		; 00000250H
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008a	33 c0		 xor	 eax, eax
$LN16@binascii_a@3:

; 593  : 
; 594  :     if (len > PY_SSIZE_T_MAX - 2) {

  0008c	48 b8 fd ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775805 ; 7ffffffffffffffdH
  00096	48 39 44 24 30	 cmp	 QWORD PTR len$[rsp], rax
  0009b	7e 14		 jle	 SHORT $LN12@binascii_a@3

; 595  :         PyBuffer_Release(&pascii);

  0009d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pascii$[rsp]
  000a2	e8 00 00 00 00	 call	 PyBuffer_Release

; 596  :         return PyErr_NoMemory();

  000a7	e8 00 00 00 00	 call	 PyErr_NoMemory
  000ac	e9 89 02 00 00	 jmp	 $LN14@binascii_a@3
$LN12@binascii_a@3:

; 597  :     }
; 598  : 
; 599  :     /* Allocate a string that is too big (fixed later)
; 600  :        Add two to the initial length to prevent interning which
; 601  :        would preclude subsequent resizing.  */
; 602  :     if ( (rv=PyBytes_FromStringAndSize(NULL, len+2)) == NULL ) {

  000b1	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  000b6	48 83 c0 02	 add	 rax, 2
  000ba	48 8b d0	 mov	 rdx, rax
  000bd	33 c9		 xor	 ecx, ecx
  000bf	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000c4	48 89 44 24 40	 mov	 QWORD PTR rv$[rsp], rax
  000c9	48 83 7c 24 40
	00		 cmp	 QWORD PTR rv$[rsp], 0
  000cf	75 11		 jne	 SHORT $LN11@binascii_a@3

; 603  :         PyBuffer_Release(&pascii);

  000d1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pascii$[rsp]
  000d6	e8 00 00 00 00	 call	 PyBuffer_Release

; 604  :         return NULL;

  000db	33 c0		 xor	 eax, eax
  000dd	e9 58 02 00 00	 jmp	 $LN14@binascii_a@3
$LN11@binascii_a@3:

; 605  :     }
; 606  :     bin_data = (unsigned char *)PyBytes_AS_STRING(rv);

  000e2	48 8b 44 24 40	 mov	 rax, QWORD PTR rv$[rsp]
  000e7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000eb	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 1c		 jne	 SHORT $LN17@binascii_a@3
  000fa	41 b8 5e 02 00
	00		 mov	 r8d, 606		; 0000025eH
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00114	33 c0		 xor	 eax, eax
$LN17@binascii_a@3:
  00116	48 8b 44 24 40	 mov	 rax, QWORD PTR rv$[rsp]
  0011b	48 83 c0 78	 add	 rax, 120		; 00000078H
  0011f	48 89 44 24 28	 mov	 QWORD PTR bin_data$[rsp], rax

; 607  : 
; 608  :     for( ; len > 0 ; len--, ascii_data++ ) {

  00124	eb 1a		 jmp	 SHORT $LN10@binascii_a@3
$LN9@binascii_a@3:
  00126	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  0012b	48 ff c8	 dec	 rax
  0012e	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax
  00133	48 8b 44 24 38	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00138	48 ff c0	 inc	 rax
  0013b	48 89 44 24 38	 mov	 QWORD PTR ascii_data$[rsp], rax
$LN10@binascii_a@3:
  00140	48 83 7c 24 30
	00		 cmp	 QWORD PTR len$[rsp], 0
  00146	0f 8e f6 00 00
	00		 jle	 $LN8@binascii_a@3

; 609  :         /* Get the byte and look it up */
; 610  :         this_ch = table_a2b_hqx[*ascii_data];

  0014c	48 8b 44 24 38	 mov	 rax, QWORD PTR ascii_data$[rsp]
  00151	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00154	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:table_a2b_hqx
  0015b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0015f	88 44 24 20	 mov	 BYTE PTR this_ch$[rsp], al

; 611  :         if ( this_ch == SKIP )

  00163	0f b6 44 24 20	 movzx	 eax, BYTE PTR this_ch$[rsp]
  00168	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  0016b	75 02		 jne	 SHORT $LN7@binascii_a@3

; 612  :             continue;

  0016d	eb b7		 jmp	 SHORT $LN9@binascii_a@3
$LN7@binascii_a@3:

; 613  :         if ( this_ch == FAIL ) {

  0016f	0f b6 44 24 20	 movzx	 eax, BYTE PTR this_ch$[rsp]
  00174	83 f8 7d	 cmp	 eax, 125		; 0000007dH
  00177	75 2e		 jne	 SHORT $LN6@binascii_a@3

; 614  :             PyErr_SetString(Error, "Illegal char");

  00179	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@JBCOMPIB@Illegal?5char?$AA@
  00180	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  00187	e8 00 00 00 00	 call	 PyErr_SetString

; 615  :             PyBuffer_Release(&pascii);

  0018c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pascii$[rsp]
  00191	e8 00 00 00 00	 call	 PyBuffer_Release

; 616  :             Py_DECREF(rv);

  00196	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rv$[rsp]
  0019b	e8 00 00 00 00	 call	 _Py_DecRef

; 617  :             return NULL;

  001a0	33 c0		 xor	 eax, eax
  001a2	e9 93 01 00 00	 jmp	 $LN14@binascii_a@3
$LN6@binascii_a@3:

; 618  :         }
; 619  :         if ( this_ch == DONE ) {

  001a7	0f b6 44 24 20	 movzx	 eax, BYTE PTR this_ch$[rsp]
  001ac	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  001af	75 0d		 jne	 SHORT $LN5@binascii_a@3

; 620  :             /* The terminating colon */
; 621  :             done = 1;

  001b1	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR done$[rsp], 1

; 622  :             break;

  001b9	e9 84 00 00 00	 jmp	 $LN8@binascii_a@3
$LN5@binascii_a@3:

; 623  :         }
; 624  : 
; 625  :         /* Shift it into the buffer and see if any bytes are ready */
; 626  :         leftchar = (leftchar << 6) | (this_ch);

  001be	8b 44 24 24	 mov	 eax, DWORD PTR leftchar$[rsp]
  001c2	c1 e0 06	 shl	 eax, 6
  001c5	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR this_ch$[rsp]
  001ca	0b c1		 or	 eax, ecx
  001cc	89 44 24 24	 mov	 DWORD PTR leftchar$[rsp], eax

; 627  :         leftbits += 6;

  001d0	8b 44 24 4c	 mov	 eax, DWORD PTR leftbits$[rsp]
  001d4	83 c0 06	 add	 eax, 6
  001d7	89 44 24 4c	 mov	 DWORD PTR leftbits$[rsp], eax

; 628  :         if ( leftbits >= 8 ) {

  001db	83 7c 24 4c 08	 cmp	 DWORD PTR leftbits$[rsp], 8
  001e0	7c 5b		 jl	 SHORT $LN4@binascii_a@3

; 629  :             leftbits -= 8;

  001e2	8b 44 24 4c	 mov	 eax, DWORD PTR leftbits$[rsp]
  001e6	83 e8 08	 sub	 eax, 8
  001e9	89 44 24 4c	 mov	 DWORD PTR leftbits$[rsp], eax

; 630  :             *bin_data++ = (leftchar >> leftbits) & 0xff;

  001ed	8b 44 24 4c	 mov	 eax, DWORD PTR leftbits$[rsp]
  001f1	0f b6 c8	 movzx	 ecx, al
  001f4	8b 44 24 24	 mov	 eax, DWORD PTR leftchar$[rsp]
  001f8	d3 e8		 shr	 eax, cl
  001fa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bin_data$[rsp]
  00204	88 01		 mov	 BYTE PTR [rcx], al
  00206	48 8b 44 24 28	 mov	 rax, QWORD PTR bin_data$[rsp]
  0020b	48 ff c0	 inc	 rax
  0020e	48 89 44 24 28	 mov	 QWORD PTR bin_data$[rsp], rax

; 631  :             leftchar &= ((1 << leftbits) - 1);

  00213	8b 44 24 4c	 mov	 eax, DWORD PTR leftbits$[rsp]
  00217	b9 01 00 00 00	 mov	 ecx, 1
  0021c	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv218[rsp], ecx
  00223	0f b6 c8	 movzx	 ecx, al
  00226	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv218[rsp]
  0022d	d3 e0		 shl	 eax, cl
  0022f	ff c8		 dec	 eax
  00231	8b 4c 24 24	 mov	 ecx, DWORD PTR leftchar$[rsp]
  00235	23 c8		 and	 ecx, eax
  00237	8b c1		 mov	 eax, ecx
  00239	89 44 24 24	 mov	 DWORD PTR leftchar$[rsp], eax
$LN4@binascii_a@3:

; 632  :         }
; 633  :     }

  0023d	e9 e4 fe ff ff	 jmp	 $LN9@binascii_a@3
$LN8@binascii_a@3:

; 634  : 
; 635  :     if ( leftbits && !done ) {

  00242	83 7c 24 4c 00	 cmp	 DWORD PTR leftbits$[rsp], 0
  00247	74 35		 je	 SHORT $LN3@binascii_a@3
  00249	83 7c 24 48 00	 cmp	 DWORD PTR done$[rsp], 0
  0024e	75 2e		 jne	 SHORT $LN3@binascii_a@3

; 636  :         PyErr_SetString(Incomplete,
; 637  :                         "String has incomplete number of bytes");

  00250	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@GGPHDJNH@String?5has?5incomplete?5number?5of?5@
  00257	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Incomplete
  0025e	e8 00 00 00 00	 call	 PyErr_SetString

; 638  :         PyBuffer_Release(&pascii);

  00263	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pascii$[rsp]
  00268	e8 00 00 00 00	 call	 PyBuffer_Release

; 639  :         Py_DECREF(rv);

  0026d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rv$[rsp]
  00272	e8 00 00 00 00	 call	 _Py_DecRef

; 640  :         return NULL;

  00277	33 c0		 xor	 eax, eax
  00279	e9 bc 00 00 00	 jmp	 $LN14@binascii_a@3
$LN3@binascii_a@3:

; 641  :     }
; 642  :     if (_PyBytes_Resize(&rv,
; 643  :                        (bin_data -
; 644  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  0027e	48 8b 44 24 40	 mov	 rax, QWORD PTR rv$[rsp]
  00283	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00287	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0028d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00292	85 c0		 test	 eax, eax
  00294	75 1c		 jne	 SHORT $LN18@binascii_a@3
  00296	41 b8 84 02 00
	00		 mov	 r8d, 644		; 00000284H
  0029c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  002a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  002aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002b0	33 c0		 xor	 eax, eax
$LN18@binascii_a@3:
  002b2	48 8b 44 24 40	 mov	 rax, QWORD PTR rv$[rsp]
  002b7	48 83 c0 78	 add	 rax, 120		; 00000078H
  002bb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bin_data$[rsp]
  002c0	48 2b c8	 sub	 rcx, rax
  002c3	48 8b c1	 mov	 rax, rcx
  002c6	48 8b d0	 mov	 rdx, rax
  002c9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR rv$[rsp]
  002ce	e8 00 00 00 00	 call	 _PyBytes_Resize
  002d3	85 c0		 test	 eax, eax
  002d5	7d 13		 jge	 SHORT $LN2@binascii_a@3

; 645  :         Py_DECREF(rv);

  002d7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rv$[rsp]
  002dc	e8 00 00 00 00	 call	 _Py_DecRef

; 646  :         rv = NULL;

  002e1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR rv$[rsp], 0
$LN2@binascii_a@3:

; 647  :     }
; 648  :     if (rv) {

  002ea	48 83 7c 24 40
	00		 cmp	 QWORD PTR rv$[rsp], 0
  002f0	74 3c		 je	 SHORT $LN1@binascii_a@3

; 649  :         PyObject *rrv = Py_BuildValue("Oi", rv, done);

  002f2	44 8b 44 24 48	 mov	 r8d, DWORD PTR done$[rsp]
  002f7	48 8b 54 24 40	 mov	 rdx, QWORD PTR rv$[rsp]
  002fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02MPEHDMPO@Oi?$AA@
  00303	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00308	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rrv$20634[rsp], rax

; 650  :         PyBuffer_Release(&pascii);

  00310	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pascii$[rsp]
  00315	e8 00 00 00 00	 call	 PyBuffer_Release

; 651  :         Py_DECREF(rv);

  0031a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rv$[rsp]
  0031f	e8 00 00 00 00	 call	 _Py_DecRef

; 652  :         return rrv;

  00324	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rrv$20634[rsp]
  0032c	eb 0c		 jmp	 SHORT $LN14@binascii_a@3
$LN1@binascii_a@3:

; 653  :     }
; 654  : 
; 655  :     PyBuffer_Release(&pascii);

  0032e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pascii$[rsp]
  00333	e8 00 00 00 00	 call	 PyBuffer_Release

; 656  :     return NULL;

  00338	33 c0		 xor	 eax, eax
$LN14@binascii_a@3:

; 657  : }

  0033a	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00341	c3		 ret	 0
binascii_a2b_hqx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@GCOHEDDH@y?$CK?3rlecode_hqx?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_rlecode_hqx DD imagerel binascii_rlecode_hqx
	DD	imagerel binascii_rlecode_hqx+881
	DD	imagerel $unwind$binascii_rlecode_hqx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_rlecode_hqx DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_0P@GCOHEDDH@y?$CK?3rlecode_hqx?$AA@
CONST	SEGMENT
??_C@_0P@GCOHEDDH@y?$CK?3rlecode_hqx?$AA@ DB 'y*:rlecode_hqx', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_rlecode_hqx
_TEXT	SEGMENT
out_data$ = 32
pbuf$ = 48
inend$ = 128
in$ = 136
len$ = 144
in_data$ = 152
rv$ = 160
ch$ = 168
self$ = 192
args$ = 200
binascii_rlecode_hqx PROC				; COMDAT

; 663  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 664  :     Py_buffer pbuf;
; 665  :     unsigned char *in_data, *out_data;
; 666  :     PyObject *rv;
; 667  :     unsigned char ch;
; 668  :     Py_ssize_t in, inend, len;
; 669  : 
; 670  :     if ( !PyArg_ParseTuple(args, "y*:rlecode_hqx", &pbuf) )

  00011	4c 8d 44 24 30	 lea	 r8, QWORD PTR pbuf$[rsp]
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@GCOHEDDH@y?$CK?3rlecode_hqx?$AA@
  0001d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN14@binascii_r

; 671  :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 34 03 00 00	 jmp	 $LN15@binascii_r
$LN14@binascii_r:

; 672  :     in_data = pbuf.buf;

  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR pbuf$[rsp]
  0003a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR in_data$[rsp], rax

; 673  :     len = pbuf.len;

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR pbuf$[rsp+16]
  00047	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 674  : 
; 675  :     assert(len >= 0);

  0004f	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR len$[rsp], 0
  00058	7d 1c		 jge	 SHORT $LN17@binascii_r
  0005a	41 b8 a3 02 00
	00		 mov	 r8d, 675		; 000002a3H
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00074	33 c0		 xor	 eax, eax
$LN17@binascii_r:

; 676  : 
; 677  :     if (len > PY_SSIZE_T_MAX / 2 - 2) {

  00076	48 b8 fd ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387901 ; 3ffffffffffffffdH
  00080	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR len$[rsp], rax
  00088	7e 14		 jle	 SHORT $LN13@binascii_r

; 678  :         PyBuffer_Release(&pbuf);

  0008a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pbuf$[rsp]
  0008f	e8 00 00 00 00	 call	 PyBuffer_Release

; 679  :         return PyErr_NoMemory();

  00094	e8 00 00 00 00	 call	 PyErr_NoMemory
  00099	e9 cb 02 00 00	 jmp	 $LN15@binascii_r
$LN13@binascii_r:

; 680  :     }
; 681  : 
; 682  :     /* Worst case: output is twice as big as input (fixed later) */
; 683  :     if ( (rv=PyBytes_FromStringAndSize(NULL, len*2+2)) == NULL ) {

  0009e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  000a6	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  000ab	48 8b d0	 mov	 rdx, rax
  000ae	33 c9		 xor	 ecx, ecx
  000b0	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000b5	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  000bd	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rv$[rsp], 0
  000c6	75 11		 jne	 SHORT $LN12@binascii_r

; 684  :         PyBuffer_Release(&pbuf);

  000c8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pbuf$[rsp]
  000cd	e8 00 00 00 00	 call	 PyBuffer_Release

; 685  :         return NULL;

  000d2	33 c0		 xor	 eax, eax
  000d4	e9 90 02 00 00	 jmp	 $LN15@binascii_r
$LN12@binascii_r:

; 686  :     }
; 687  :     out_data = (unsigned char *)PyBytes_AS_STRING(rv);

  000d9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  000e1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000e5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000eb	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000f0	85 c0		 test	 eax, eax
  000f2	75 1c		 jne	 SHORT $LN18@binascii_r
  000f4	41 b8 af 02 00
	00		 mov	 r8d, 687		; 000002afH
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00101	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0010e	33 c0		 xor	 eax, eax
$LN18@binascii_r:
  00110	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00118	48 83 c0 78	 add	 rax, 120		; 00000078H
  0011c	48 89 44 24 20	 mov	 QWORD PTR out_data$[rsp], rax

; 688  : 
; 689  :     for( in=0; in<len; in++) {

  00121	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR in$[rsp], 0
  0012d	eb 13		 jmp	 SHORT $LN11@binascii_r
$LN10@binascii_r:
  0012f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00137	48 ff c0	 inc	 rax
  0013a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR in$[rsp], rax
$LN11@binascii_r:
  00142	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0014a	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR in$[rsp], rax
  00152	0f 8d 84 01 00
	00		 jge	 $LN9@binascii_r

; 690  :         ch = in_data[in];

  00158	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00160	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_data$[rsp]
  00168	48 03 c8	 add	 rcx, rax
  0016b	48 8b c1	 mov	 rax, rcx
  0016e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00171	88 84 24 a8 00
	00 00		 mov	 BYTE PTR ch$[rsp], al

; 691  :         if ( ch == RUNCHAR ) {

  00178	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR ch$[rsp]
  00180	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  00185	75 2f		 jne	 SHORT $LN8@binascii_r

; 692  :             /* RUNCHAR. Escape it. */
; 693  :             *out_data++ = RUNCHAR;

  00187	48 8b 44 24 20	 mov	 rax, QWORD PTR out_data$[rsp]
  0018c	c6 00 90	 mov	 BYTE PTR [rax], 144	; 00000090H
  0018f	48 8b 44 24 20	 mov	 rax, QWORD PTR out_data$[rsp]
  00194	48 ff c0	 inc	 rax
  00197	48 89 44 24 20	 mov	 QWORD PTR out_data$[rsp], rax

; 694  :             *out_data++ = 0;

  0019c	48 8b 44 24 20	 mov	 rax, QWORD PTR out_data$[rsp]
  001a1	c6 00 00	 mov	 BYTE PTR [rax], 0
  001a4	48 8b 44 24 20	 mov	 rax, QWORD PTR out_data$[rsp]
  001a9	48 ff c0	 inc	 rax
  001ac	48 89 44 24 20	 mov	 QWORD PTR out_data$[rsp], rax

; 695  :         } else {

  001b1	e9 21 01 00 00	 jmp	 $LN7@binascii_r
$LN8@binascii_r:

; 696  :             /* Check how many following are the same */
; 697  :             for(inend=in+1;
; 698  :                 inend<len && in_data[inend] == ch &&
; 699  :                     inend < in+255;
; 700  :                 inend++) ;

  001b6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  001be	48 ff c0	 inc	 rax
  001c1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR inend$[rsp], rax
  001c9	eb 13		 jmp	 SHORT $LN6@binascii_r
$LN5@binascii_r:
  001cb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inend$[rsp]
  001d3	48 ff c0	 inc	 rax
  001d6	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR inend$[rsp], rax
$LN6@binascii_r:
  001de	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  001e6	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR inend$[rsp], rax
  001ee	7d 3f		 jge	 SHORT $LN4@binascii_r
  001f0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inend$[rsp]
  001f8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR in_data$[rsp]
  00200	48 03 c8	 add	 rcx, rax
  00203	48 8b c1	 mov	 rax, rcx
  00206	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00209	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR ch$[rsp]
  00211	3b c1		 cmp	 eax, ecx
  00213	75 1a		 jne	 SHORT $LN4@binascii_r
  00215	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0021d	48 05 ff 00 00
	00		 add	 rax, 255		; 000000ffH
  00223	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR inend$[rsp], rax
  0022b	7d 02		 jge	 SHORT $LN4@binascii_r
  0022d	eb 9c		 jmp	 SHORT $LN5@binascii_r
$LN4@binascii_r:

; 701  :             if ( inend - in > 3 ) {

  0022f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00237	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inend$[rsp]
  0023f	48 2b c8	 sub	 rcx, rax
  00242	48 8b c1	 mov	 rax, rcx
  00245	48 83 f8 03	 cmp	 rax, 3
  00249	7e 70		 jle	 SHORT $LN3@binascii_r

; 702  :                 /* More than 3 in a row. Output RLE. */
; 703  :                 *out_data++ = ch;

  0024b	48 8b 44 24 20	 mov	 rax, QWORD PTR out_data$[rsp]
  00250	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR ch$[rsp]
  00258	88 08		 mov	 BYTE PTR [rax], cl
  0025a	48 8b 44 24 20	 mov	 rax, QWORD PTR out_data$[rsp]
  0025f	48 ff c0	 inc	 rax
  00262	48 89 44 24 20	 mov	 QWORD PTR out_data$[rsp], rax

; 704  :                 *out_data++ = RUNCHAR;

  00267	48 8b 44 24 20	 mov	 rax, QWORD PTR out_data$[rsp]
  0026c	c6 00 90	 mov	 BYTE PTR [rax], 144	; 00000090H
  0026f	48 8b 44 24 20	 mov	 rax, QWORD PTR out_data$[rsp]
  00274	48 ff c0	 inc	 rax
  00277	48 89 44 24 20	 mov	 QWORD PTR out_data$[rsp], rax

; 705  :                 *out_data++ = (unsigned char) (inend-in);

  0027c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00284	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inend$[rsp]
  0028c	48 2b c8	 sub	 rcx, rax
  0028f	48 8b c1	 mov	 rax, rcx
  00292	48 8b 4c 24 20	 mov	 rcx, QWORD PTR out_data$[rsp]
  00297	88 01		 mov	 BYTE PTR [rcx], al
  00299	48 8b 44 24 20	 mov	 rax, QWORD PTR out_data$[rsp]
  0029e	48 ff c0	 inc	 rax
  002a1	48 89 44 24 20	 mov	 QWORD PTR out_data$[rsp], rax

; 706  :                 in = inend-1;

  002a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inend$[rsp]
  002ae	48 ff c8	 dec	 rax
  002b1	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 707  :             } else {

  002b9	eb 1c		 jmp	 SHORT $LN2@binascii_r
$LN3@binascii_r:

; 708  :                 /* Less than 3. Output the byte itself */
; 709  :                 *out_data++ = ch;

  002bb	48 8b 44 24 20	 mov	 rax, QWORD PTR out_data$[rsp]
  002c0	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR ch$[rsp]
  002c8	88 08		 mov	 BYTE PTR [rax], cl
  002ca	48 8b 44 24 20	 mov	 rax, QWORD PTR out_data$[rsp]
  002cf	48 ff c0	 inc	 rax
  002d2	48 89 44 24 20	 mov	 QWORD PTR out_data$[rsp], rax
$LN2@binascii_r:
$LN7@binascii_r:

; 710  :             }
; 711  :         }
; 712  :     }

  002d7	e9 53 fe ff ff	 jmp	 $LN10@binascii_r
$LN9@binascii_r:

; 713  :     if (_PyBytes_Resize(&rv,
; 714  :                        (out_data -
; 715  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  002dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  002e4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002e8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002ee	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  002f3	85 c0		 test	 eax, eax
  002f5	75 1c		 jne	 SHORT $LN19@binascii_r
  002f7	41 b8 cb 02 00
	00		 mov	 r8d, 715		; 000002cbH
  002fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00304	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  0030b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00311	33 c0		 xor	 eax, eax
$LN19@binascii_r:
  00313	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  0031b	48 83 c0 78	 add	 rax, 120		; 00000078H
  0031f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR out_data$[rsp]
  00324	48 2b c8	 sub	 rcx, rax
  00327	48 8b c1	 mov	 rax, rcx
  0032a	48 8b d0	 mov	 rdx, rax
  0032d	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  00335	e8 00 00 00 00	 call	 _PyBytes_Resize
  0033a	85 c0		 test	 eax, eax
  0033c	7d 19		 jge	 SHORT $LN1@binascii_r

; 716  :         Py_DECREF(rv);

  0033e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00346	e8 00 00 00 00	 call	 _Py_DecRef

; 717  :         rv = NULL;

  0034b	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0
$LN1@binascii_r:

; 718  :     }
; 719  :     PyBuffer_Release(&pbuf);

  00357	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pbuf$[rsp]
  0035c	e8 00 00 00 00	 call	 PyBuffer_Release

; 720  :     return rv;

  00361	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN15@binascii_r:

; 721  : }

  00369	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00370	c3		 ret	 0
binascii_rlecode_hqx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@GKOJECBN@y?$CK?3b2a_hqx?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_b2a_hqx DD imagerel binascii_b2a_hqx
	DD	imagerel binascii_b2a_hqx+736
	DD	imagerel $unwind$binascii_b2a_hqx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_b2a_hqx DD 021101H
	DD	0150111H
xdata	ENDS
;	COMDAT ??_C@_0L@GKOJECBN@y?$CK?3b2a_hqx?$AA@
CONST	SEGMENT
??_C@_0L@GKOJECBN@y?$CK?3b2a_hqx?$AA@ DB 'y*:b2a_hqx', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_b2a_hqx
_TEXT	SEGMENT
this_ch$ = 32
leftchar$ = 36
bin_data$ = 40
pbin$ = 48
len$ = 128
ascii_data$ = 136
rv$ = 144
leftbits$ = 152
self$ = 176
args$ = 184
binascii_b2a_hqx PROC					; COMDAT

; 727  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 728  :     Py_buffer pbin;
; 729  :     unsigned char *ascii_data, *bin_data;
; 730  :     int leftbits = 0;

  00011	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR leftbits$[rsp], 0

; 731  :     unsigned char this_ch;
; 732  :     unsigned int leftchar = 0;

  0001c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR leftchar$[rsp], 0

; 733  :     PyObject *rv;
; 734  :     Py_ssize_t len;
; 735  : 
; 736  :     if ( !PyArg_ParseTuple(args, "y*:b2a_hqx", &pbin) )

  00024	4c 8d 44 24 30	 lea	 r8, QWORD PTR pbin$[rsp]
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@GKOJECBN@y?$CK?3b2a_hqx?$AA@
  00030	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00038	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0003d	85 c0		 test	 eax, eax
  0003f	75 07		 jne	 SHORT $LN10@binascii_b@3

; 737  :         return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	e9 90 02 00 00	 jmp	 $LN11@binascii_b@3
$LN10@binascii_b@3:

; 738  :     bin_data = pbin.buf;

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR pbin$[rsp]
  0004d	48 89 44 24 28	 mov	 QWORD PTR bin_data$[rsp], rax

; 739  :     len = pbin.len;

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR pbin$[rsp+16]
  00057	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 740  : 
; 741  :     assert(len >= 0);

  0005f	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR len$[rsp], 0
  00068	7d 1c		 jge	 SHORT $LN13@binascii_b@3
  0006a	41 b8 e5 02 00
	00		 mov	 r8d, 741		; 000002e5H
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@OAMMNJJI@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00084	33 c0		 xor	 eax, eax
$LN13@binascii_b@3:

; 742  : 
; 743  :     if (len > PY_SSIZE_T_MAX / 2 - 2) {

  00086	48 b8 fd ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387901 ; 3ffffffffffffffdH
  00090	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR len$[rsp], rax
  00098	7e 14		 jle	 SHORT $LN9@binascii_b@3

; 744  :         PyBuffer_Release(&pbin);

  0009a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pbin$[rsp]
  0009f	e8 00 00 00 00	 call	 PyBuffer_Release

; 745  :         return PyErr_NoMemory();

  000a4	e8 00 00 00 00	 call	 PyErr_NoMemory
  000a9	e9 2a 02 00 00	 jmp	 $LN11@binascii_b@3
$LN9@binascii_b@3:

; 746  :     }
; 747  : 
; 748  :     /* Allocate a buffer that is at least large enough */
; 749  :     if ( (rv=PyBytes_FromStringAndSize(NULL, len*2+2)) == NULL ) {

  000ae	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  000b6	48 8d 44 00 02	 lea	 rax, QWORD PTR [rax+rax+2]
  000bb	48 8b d0	 mov	 rdx, rax
  000be	33 c9		 xor	 ecx, ecx
  000c0	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000c5	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  000cd	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR rv$[rsp], 0
  000d6	75 11		 jne	 SHORT $LN8@binascii_b@3

; 750  :         PyBuffer_Release(&pbin);

  000d8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pbin$[rsp]
  000dd	e8 00 00 00 00	 call	 PyBuffer_Release

; 751  :         return NULL;

  000e2	33 c0		 xor	 eax, eax
  000e4	e9 ef 01 00 00	 jmp	 $LN11@binascii_b@3
$LN8@binascii_b@3:

; 752  :     }
; 753  :     ascii_data = (unsigned char *)PyBytes_AS_STRING(rv);

  000e9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  000f1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000fb	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00100	85 c0		 test	 eax, eax
  00102	75 1c		 jne	 SHORT $LN14@binascii_b@3
  00104	41 b8 f1 02 00
	00		 mov	 r8d, 753		; 000002f1H
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0011e	33 c0		 xor	 eax, eax
$LN14@binascii_b@3:
  00120	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00128	48 83 c0 78	 add	 rax, 120		; 00000078H
  0012c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 754  : 
; 755  :     for( ; len > 0 ; len--, bin_data++ ) {

  00134	eb 20		 jmp	 SHORT $LN7@binascii_b@3
$LN6@binascii_b@3:
  00136	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0013e	48 ff c8	 dec	 rax
  00141	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR len$[rsp], rax
  00149	48 8b 44 24 28	 mov	 rax, QWORD PTR bin_data$[rsp]
  0014e	48 ff c0	 inc	 rax
  00151	48 89 44 24 28	 mov	 QWORD PTR bin_data$[rsp], rax
$LN7@binascii_b@3:
  00156	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR len$[rsp], 0
  0015f	0f 8e 8f 00 00
	00		 jle	 $LN5@binascii_b@3

; 756  :         /* Shift into our buffer, and output any 6bits ready */
; 757  :         leftchar = (leftchar << 8) | *bin_data;

  00165	8b 44 24 24	 mov	 eax, DWORD PTR leftchar$[rsp]
  00169	c1 e0 08	 shl	 eax, 8
  0016c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bin_data$[rsp]
  00171	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00174	0b c1		 or	 eax, ecx
  00176	89 44 24 24	 mov	 DWORD PTR leftchar$[rsp], eax

; 758  :         leftbits += 8;

  0017a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR leftbits$[rsp]
  00181	83 c0 08	 add	 eax, 8
  00184	89 84 24 98 00
	00 00		 mov	 DWORD PTR leftbits$[rsp], eax
$LN4@binascii_b@3:

; 759  :         while ( leftbits >= 6 ) {

  0018b	83 bc 24 98 00
	00 00 06	 cmp	 DWORD PTR leftbits$[rsp], 6
  00193	7c 5a		 jl	 SHORT $LN3@binascii_b@3

; 760  :             this_ch = (leftchar >> (leftbits-6)) & 0x3f;

  00195	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR leftbits$[rsp]
  0019c	83 e8 06	 sub	 eax, 6
  0019f	0f b6 c8	 movzx	 ecx, al
  001a2	8b 44 24 24	 mov	 eax, DWORD PTR leftchar$[rsp]
  001a6	d3 e8		 shr	 eax, cl
  001a8	83 e0 3f	 and	 eax, 63			; 0000003fH
  001ab	88 44 24 20	 mov	 BYTE PTR this_ch$[rsp], al

; 761  :             leftbits -= 6;

  001af	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR leftbits$[rsp]
  001b6	83 e8 06	 sub	 eax, 6
  001b9	89 84 24 98 00
	00 00		 mov	 DWORD PTR leftbits$[rsp], eax

; 762  :             *ascii_data++ = table_b2a_hqx[this_ch];

  001c0	0f b6 44 24 20	 movzx	 eax, BYTE PTR this_ch$[rsp]
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:table_b2a_hqx
  001cc	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR ascii_data$[rsp]
  001d4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d8	88 02		 mov	 BYTE PTR [rdx], al
  001da	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  001e2	48 ff c0	 inc	 rax
  001e5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax

; 763  :         }

  001ed	eb 9c		 jmp	 SHORT $LN4@binascii_b@3
$LN3@binascii_b@3:

; 764  :     }

  001ef	e9 42 ff ff ff	 jmp	 $LN6@binascii_b@3
$LN5@binascii_b@3:

; 765  :     /* Output a possible runt byte */
; 766  :     if ( leftbits ) {

  001f4	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR leftbits$[rsp], 0
  001fc	74 4a		 je	 SHORT $LN2@binascii_b@3

; 767  :         leftchar <<= (6-leftbits);

  001fe	b8 06 00 00 00	 mov	 eax, 6
  00203	2b 84 24 98 00
	00 00		 sub	 eax, DWORD PTR leftbits$[rsp]
  0020a	0f b6 c8	 movzx	 ecx, al
  0020d	8b 44 24 24	 mov	 eax, DWORD PTR leftchar$[rsp]
  00211	d3 e0		 shl	 eax, cl
  00213	89 44 24 24	 mov	 DWORD PTR leftchar$[rsp], eax

; 768  :         *ascii_data++ = table_b2a_hqx[leftchar & 0x3f];

  00217	8b 44 24 24	 mov	 eax, DWORD PTR leftchar$[rsp]
  0021b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0021e	8b c0		 mov	 eax, eax
  00220	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:table_b2a_hqx
  00227	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR ascii_data$[rsp]
  0022f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00233	88 02		 mov	 BYTE PTR [rdx], al
  00235	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ascii_data$[rsp]
  0023d	48 ff c0	 inc	 rax
  00240	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ascii_data$[rsp], rax
$LN2@binascii_b@3:

; 769  :     }
; 770  :     if (_PyBytes_Resize(&rv,
; 771  :                        (ascii_data -
; 772  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  00248	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00250	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00254	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0025a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0025f	85 c0		 test	 eax, eax
  00261	75 1c		 jne	 SHORT $LN15@binascii_b@3
  00263	41 b8 04 03 00
	00		 mov	 r8d, 772		; 00000304H
  00269	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00270	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  00277	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0027d	33 c0		 xor	 eax, eax
$LN15@binascii_b@3:
  0027f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00287	48 83 c0 78	 add	 rax, 120		; 00000078H
  0028b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ascii_data$[rsp]
  00293	48 2b c8	 sub	 rcx, rax
  00296	48 8b c1	 mov	 rax, rcx
  00299	48 8b d0	 mov	 rdx, rax
  0029c	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  002a4	e8 00 00 00 00	 call	 _PyBytes_Resize
  002a9	85 c0		 test	 eax, eax
  002ab	7d 19		 jge	 SHORT $LN1@binascii_b@3

; 773  :         Py_DECREF(rv);

  002ad	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  002b5	e8 00 00 00 00	 call	 _Py_DecRef

; 774  :         rv = NULL;

  002ba	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0
$LN1@binascii_b@3:

; 775  :     }
; 776  :     PyBuffer_Release(&pbin);

  002c6	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pbin$[rsp]
  002cb	e8 00 00 00 00	 call	 PyBuffer_Release

; 777  :     return rv;

  002d0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN11@binascii_b@3:

; 778  : }

  002d8	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002df	c3		 ret	 0
binascii_b2a_hqx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@ONDJCFPN@Orphaned?5RLE?5code?5at?5start?$AA@ ; `string'
PUBLIC	??_C@_1BI@IPPGDHDF@?$AAi?$AAn?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BB@DOKNPDKH@y?$CK?3rledecode_hqx?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_rledecode_hqx DD imagerel binascii_rledecode_hqx
	DD	imagerel binascii_rledecode_hqx+2373
	DD	imagerel $unwind$binascii_rledecode_hqx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_rledecode_hqx DD 021101H
	DD	0190111H
xdata	ENDS
;	COMDAT ??_C@_0BL@ONDJCFPN@Orphaned?5RLE?5code?5at?5start?$AA@
CONST	SEGMENT
??_C@_0BL@ONDJCFPN@Orphaned?5RLE?5code?5at?5start?$AA@ DB 'Orphaned RLE c'
	DB	'ode at start', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@IPPGDHDF@?$AAi?$AAn?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@IPPGDHDF@?$AAi?$AAn?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, '_', 00H, 'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DOKNPDKH@y?$CK?3rledecode_hqx?$AA@
CONST	SEGMENT
??_C@_0BB@DOKNPDKH@y?$CK?3rledecode_hqx?$AA@ DB 'y*:rledecode_hqx', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_rledecode_hqx
_TEXT	SEGMENT
out_len_left$ = 32
out_data$ = 40
out_len$ = 48
in_repeat$ = 56
in_data$ = 64
pin$ = 80
rv$ = 160
in_len$ = 168
in_byte$ = 176
self$ = 208
args$ = 216
binascii_rledecode_hqx PROC				; COMDAT

; 784  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 785  :     Py_buffer pin;
; 786  :     unsigned char *in_data, *out_data;
; 787  :     unsigned char in_byte, in_repeat;
; 788  :     PyObject *rv;
; 789  :     Py_ssize_t in_len, out_len, out_len_left;
; 790  : 
; 791  :     if ( !PyArg_ParseTuple(args, "y*:rledecode_hqx", &pin) )

  00011	4c 8d 44 24 50	 lea	 r8, QWORD PTR pin$[rsp]
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@DOKNPDKH@y?$CK?3rledecode_hqx?$AA@
  0001d	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN63@binascii_r@2

; 792  :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 08 09 00 00	 jmp	 $LN64@binascii_r@2
$LN63@binascii_r@2:

; 793  :     in_data = pin.buf;

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR pin$[rsp]
  0003a	48 89 44 24 40	 mov	 QWORD PTR in_data$[rsp], rax

; 794  :     in_len = pin.len;

  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR pin$[rsp+16]
  00044	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR in_len$[rsp], rax

; 795  : 
; 796  :     assert(in_len >= 0);

  0004c	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR in_len$[rsp], 0
  00055	7d 1c		 jge	 SHORT $LN66@binascii_r@2
  00057	41 b8 1c 03 00
	00		 mov	 r8d, 796		; 0000031cH
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@IPPGDHDF@?$AAi?$AAn?$AA_?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00071	33 c0		 xor	 eax, eax
$LN66@binascii_r@2:

; 797  : 
; 798  :     /* Empty string is a special case */
; 799  :     if ( in_len == 0 ) {

  00073	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR in_len$[rsp], 0
  0007c	75 1f		 jne	 SHORT $LN62@binascii_r@2

; 800  :         PyBuffer_Release(&pin);

  0007e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  00083	e8 00 00 00 00	 call	 PyBuffer_Release

; 801  :         return PyBytes_FromStringAndSize("", 0);

  00088	33 d2		 xor	 edx, edx
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00091	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00096	e9 a2 08 00 00	 jmp	 $LN64@binascii_r@2
  0009b	eb 28		 jmp	 SHORT $LN61@binascii_r@2
$LN62@binascii_r@2:

; 802  :     }
; 803  :     else if (in_len > PY_SSIZE_T_MAX / 2) {

  0009d	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  000a7	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR in_len$[rsp], rax
  000af	7e 14		 jle	 SHORT $LN60@binascii_r@2

; 804  :         PyBuffer_Release(&pin);

  000b1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  000b6	e8 00 00 00 00	 call	 PyBuffer_Release

; 805  :         return PyErr_NoMemory();

  000bb	e8 00 00 00 00	 call	 PyErr_NoMemory
  000c0	e9 78 08 00 00	 jmp	 $LN64@binascii_r@2
$LN60@binascii_r@2:
$LN61@binascii_r@2:

; 806  :     }
; 807  : 
; 808  :     /* Allocate a buffer of reasonable size. Resized when needed */
; 809  :     out_len = in_len*2;

  000c5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR in_len$[rsp]
  000cd	48 d1 e0	 shl	 rax, 1
  000d0	48 89 44 24 30	 mov	 QWORD PTR out_len$[rsp], rax

; 810  :     if ( (rv=PyBytes_FromStringAndSize(NULL, out_len)) == NULL ) {

  000d5	48 8b 54 24 30	 mov	 rdx, QWORD PTR out_len$[rsp]
  000da	33 c9		 xor	 ecx, ecx
  000dc	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000e1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  000e9	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rv$[rsp], 0
  000f2	75 11		 jne	 SHORT $LN59@binascii_r@2

; 811  :         PyBuffer_Release(&pin);

  000f4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  000f9	e8 00 00 00 00	 call	 PyBuffer_Release

; 812  :         return NULL;

  000fe	33 c0		 xor	 eax, eax
  00100	e9 38 08 00 00	 jmp	 $LN64@binascii_r@2
$LN59@binascii_r@2:

; 813  :     }
; 814  :     out_len_left = out_len;

  00105	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  0010a	48 89 44 24 20	 mov	 QWORD PTR out_len_left$[rsp], rax

; 815  :     out_data = (unsigned char *)PyBytes_AS_STRING(rv);

  0010f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00117	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0011b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00121	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00126	85 c0		 test	 eax, eax
  00128	75 1c		 jne	 SHORT $LN67@binascii_r@2
  0012a	41 b8 2f 03 00
	00		 mov	 r8d, 815		; 0000032fH
  00130	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00137	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00144	33 c0		 xor	 eax, eax
$LN67@binascii_r@2:
  00146	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  0014e	48 83 c0 78	 add	 rax, 120		; 00000078H
  00152	48 89 44 24 28	 mov	 QWORD PTR out_data$[rsp], rax
$LN58@binascii_r@2:

; 816  : 
; 817  :     /*
; 818  :     ** We need two macros here to get/put bytes and handle
; 819  :     ** end-of-buffer for input and output strings.
; 820  :     */
; 821  : #define INBYTE(b) \
; 822  :     do { \
; 823  :              if ( --in_len < 0 ) { \
; 824  :                        PyErr_SetString(Incomplete, ""); \
; 825  :                        Py_DECREF(rv); \
; 826  :                        PyBuffer_Release(&pin); \
; 827  :                        return NULL; \
; 828  :              } \
; 829  :              b = *in_data++; \
; 830  :     } while(0)
; 831  : 
; 832  : #define OUTBYTE(b) \
; 833  :     do { \
; 834  :              if ( --out_len_left < 0 ) { \
; 835  :                       if ( out_len > PY_SSIZE_T_MAX / 2) return PyErr_NoMemory(); \
; 836  :                       if (_PyBytes_Resize(&rv, 2*out_len) < 0) \
; 837  :                         { Py_DECREF(rv); PyBuffer_Release(&pin); return NULL; } \
; 838  :                       out_data = (unsigned char *)PyBytes_AS_STRING(rv) \
; 839  :                                                              + out_len; \
; 840  :                       out_len_left = out_len-1; \
; 841  :                       out_len = out_len * 2; \
; 842  :              } \
; 843  :              *out_data++ = b; \
; 844  :     } while(0)
; 845  : 
; 846  :         /*
; 847  :         ** Handle first byte separately (since we have to get angry
; 848  :         ** in case of an orphaned RLE code).
; 849  :         */
; 850  :         INBYTE(in_byte);

  00157	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR in_len$[rsp]
  0015f	48 ff c8	 dec	 rax
  00162	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR in_len$[rsp], rax
  0016a	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR in_len$[rsp], 0
  00173	7d 31		 jge	 SHORT $LN55@binascii_r@2
  00175	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0017c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Incomplete
  00183	e8 00 00 00 00	 call	 PyErr_SetString
  00188	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00190	e8 00 00 00 00	 call	 _Py_DecRef
  00195	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  0019a	e8 00 00 00 00	 call	 PyBuffer_Release
  0019f	33 c0		 xor	 eax, eax
  001a1	e9 97 07 00 00	 jmp	 $LN64@binascii_r@2
$LN55@binascii_r@2:
  001a6	48 8b 44 24 40	 mov	 rax, QWORD PTR in_data$[rsp]
  001ab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001ae	88 84 24 b0 00
	00 00		 mov	 BYTE PTR in_byte$[rsp], al
  001b5	48 8b 44 24 40	 mov	 rax, QWORD PTR in_data$[rsp]
  001ba	48 ff c0	 inc	 rax
  001bd	48 89 44 24 40	 mov	 QWORD PTR in_data$[rsp], rax
  001c2	33 c0		 xor	 eax, eax
  001c4	85 c0		 test	 eax, eax
  001c6	75 8f		 jne	 SHORT $LN58@binascii_r@2

; 851  : 
; 852  :     if (in_byte == RUNCHAR) {

  001c8	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR in_byte$[rsp]
  001d0	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  001d5	0f 85 a2 01 00
	00		 jne	 $LN54@binascii_r@2
$LN53@binascii_r@2:

; 853  :         INBYTE(in_repeat);

  001db	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR in_len$[rsp]
  001e3	48 ff c8	 dec	 rax
  001e6	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR in_len$[rsp], rax
  001ee	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR in_len$[rsp], 0
  001f7	7d 31		 jge	 SHORT $LN50@binascii_r@2
  001f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00200	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Incomplete
  00207	e8 00 00 00 00	 call	 PyErr_SetString
  0020c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00214	e8 00 00 00 00	 call	 _Py_DecRef
  00219	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  0021e	e8 00 00 00 00	 call	 PyBuffer_Release
  00223	33 c0		 xor	 eax, eax
  00225	e9 13 07 00 00	 jmp	 $LN64@binascii_r@2
$LN50@binascii_r@2:
  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR in_data$[rsp]
  0022f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00232	88 44 24 38	 mov	 BYTE PTR in_repeat$[rsp], al
  00236	48 8b 44 24 40	 mov	 rax, QWORD PTR in_data$[rsp]
  0023b	48 ff c0	 inc	 rax
  0023e	48 89 44 24 40	 mov	 QWORD PTR in_data$[rsp], rax
  00243	33 c0		 xor	 eax, eax
  00245	85 c0		 test	 eax, eax
  00247	75 92		 jne	 SHORT $LN53@binascii_r@2

; 854  :         if (in_repeat != 0) {

  00249	0f b6 44 24 38	 movzx	 eax, BYTE PTR in_repeat$[rsp]
  0024e	85 c0		 test	 eax, eax
  00250	74 31		 je	 SHORT $LN49@binascii_r@2

; 855  :             /* Note Error, not Incomplete (which is at the end
; 856  :             ** of the string only). This is a programmer error.
; 857  :             */
; 858  :             PyErr_SetString(Error, "Orphaned RLE code at start");

  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@ONDJCFPN@Orphaned?5RLE?5code?5at?5start?$AA@
  00259	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  00260	e8 00 00 00 00	 call	 PyErr_SetString

; 859  :             PyBuffer_Release(&pin);

  00265	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  0026a	e8 00 00 00 00	 call	 PyBuffer_Release

; 860  :             Py_DECREF(rv);

  0026f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00277	e8 00 00 00 00	 call	 _Py_DecRef

; 861  :             return NULL;

  0027c	33 c0		 xor	 eax, eax
  0027e	e9 ba 06 00 00	 jmp	 $LN64@binascii_r@2
$LN49@binascii_r@2:
$LN48@binascii_r@2:

; 862  :         }
; 863  :         OUTBYTE(RUNCHAR);

  00283	48 8b 44 24 20	 mov	 rax, QWORD PTR out_len_left$[rsp]
  00288	48 ff c8	 dec	 rax
  0028b	48 89 44 24 20	 mov	 QWORD PTR out_len_left$[rsp], rax
  00290	48 83 7c 24 20
	00		 cmp	 QWORD PTR out_len_left$[rsp], 0
  00296	0f 8d bd 00 00
	00		 jge	 $LN45@binascii_r@2
  0029c	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  002a6	48 39 44 24 30	 cmp	 QWORD PTR out_len$[rsp], rax
  002ab	7e 0a		 jle	 SHORT $LN44@binascii_r@2
  002ad	e8 00 00 00 00	 call	 PyErr_NoMemory
  002b2	e9 86 06 00 00	 jmp	 $LN64@binascii_r@2
$LN44@binascii_r@2:
  002b7	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  002bc	48 03 c0	 add	 rax, rax
  002bf	48 8b d0	 mov	 rdx, rax
  002c2	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  002ca	e8 00 00 00 00	 call	 _PyBytes_Resize
  002cf	85 c0		 test	 eax, eax
  002d1	7d 1e		 jge	 SHORT $LN43@binascii_r@2
  002d3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  002db	e8 00 00 00 00	 call	 _Py_DecRef
  002e0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  002e5	e8 00 00 00 00	 call	 PyBuffer_Release
  002ea	33 c0		 xor	 eax, eax
  002ec	e9 4c 06 00 00	 jmp	 $LN64@binascii_r@2
$LN43@binascii_r@2:
  002f1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  002f9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002fd	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00303	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00308	85 c0		 test	 eax, eax
  0030a	75 1c		 jne	 SHORT $LN68@binascii_r@2
  0030c	41 b8 5f 03 00
	00		 mov	 r8d, 863		; 0000035fH
  00312	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00319	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  00320	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00326	33 c0		 xor	 eax, eax
$LN68@binascii_r@2:
  00328	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00330	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out_len$[rsp]
  00335	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  0033a	48 89 44 24 28	 mov	 QWORD PTR out_data$[rsp], rax
  0033f	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  00344	48 ff c8	 dec	 rax
  00347	48 89 44 24 20	 mov	 QWORD PTR out_len_left$[rsp], rax
  0034c	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  00351	48 03 c0	 add	 rax, rax
  00354	48 89 44 24 30	 mov	 QWORD PTR out_len$[rsp], rax
$LN45@binascii_r@2:
  00359	48 8b 44 24 28	 mov	 rax, QWORD PTR out_data$[rsp]
  0035e	c6 00 90	 mov	 BYTE PTR [rax], 144	; 00000090H
  00361	48 8b 44 24 28	 mov	 rax, QWORD PTR out_data$[rsp]
  00366	48 ff c0	 inc	 rax
  00369	48 89 44 24 28	 mov	 QWORD PTR out_data$[rsp], rax
  0036e	33 c0		 xor	 eax, eax
  00370	85 c0		 test	 eax, eax
  00372	0f 85 0b ff ff
	ff		 jne	 $LN48@binascii_r@2

; 864  :     } else {

  00378	e9 fc 00 00 00	 jmp	 $LN42@binascii_r@2
$LN54@binascii_r@2:
$LN41@binascii_r@2:

; 865  :         OUTBYTE(in_byte);

  0037d	48 8b 44 24 20	 mov	 rax, QWORD PTR out_len_left$[rsp]
  00382	48 ff c8	 dec	 rax
  00385	48 89 44 24 20	 mov	 QWORD PTR out_len_left$[rsp], rax
  0038a	48 83 7c 24 20
	00		 cmp	 QWORD PTR out_len_left$[rsp], 0
  00390	0f 8d bd 00 00
	00		 jge	 $LN38@binascii_r@2
  00396	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  003a0	48 39 44 24 30	 cmp	 QWORD PTR out_len$[rsp], rax
  003a5	7e 0a		 jle	 SHORT $LN37@binascii_r@2
  003a7	e8 00 00 00 00	 call	 PyErr_NoMemory
  003ac	e9 8c 05 00 00	 jmp	 $LN64@binascii_r@2
$LN37@binascii_r@2:
  003b1	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  003b6	48 03 c0	 add	 rax, rax
  003b9	48 8b d0	 mov	 rdx, rax
  003bc	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  003c4	e8 00 00 00 00	 call	 _PyBytes_Resize
  003c9	85 c0		 test	 eax, eax
  003cb	7d 1e		 jge	 SHORT $LN36@binascii_r@2
  003cd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  003d5	e8 00 00 00 00	 call	 _Py_DecRef
  003da	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  003df	e8 00 00 00 00	 call	 PyBuffer_Release
  003e4	33 c0		 xor	 eax, eax
  003e6	e9 52 05 00 00	 jmp	 $LN64@binascii_r@2
$LN36@binascii_r@2:
  003eb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  003f3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003f7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003fd	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00402	85 c0		 test	 eax, eax
  00404	75 1c		 jne	 SHORT $LN69@binascii_r@2
  00406	41 b8 61 03 00
	00		 mov	 r8d, 865		; 00000361H
  0040c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00413	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  0041a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00420	33 c0		 xor	 eax, eax
$LN69@binascii_r@2:
  00422	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  0042a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out_len$[rsp]
  0042f	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  00434	48 89 44 24 28	 mov	 QWORD PTR out_data$[rsp], rax
  00439	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  0043e	48 ff c8	 dec	 rax
  00441	48 89 44 24 20	 mov	 QWORD PTR out_len_left$[rsp], rax
  00446	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  0044b	48 03 c0	 add	 rax, rax
  0044e	48 89 44 24 30	 mov	 QWORD PTR out_len$[rsp], rax
$LN38@binascii_r@2:
  00453	48 8b 44 24 28	 mov	 rax, QWORD PTR out_data$[rsp]
  00458	0f b6 8c 24 b0
	00 00 00	 movzx	 ecx, BYTE PTR in_byte$[rsp]
  00460	88 08		 mov	 BYTE PTR [rax], cl
  00462	48 8b 44 24 28	 mov	 rax, QWORD PTR out_data$[rsp]
  00467	48 ff c0	 inc	 rax
  0046a	48 89 44 24 28	 mov	 QWORD PTR out_data$[rsp], rax
  0046f	33 c0		 xor	 eax, eax
  00471	85 c0		 test	 eax, eax
  00473	0f 85 04 ff ff
	ff		 jne	 $LN41@binascii_r@2
$LN42@binascii_r@2:
$LN35@binascii_r@2:

; 866  :     }
; 867  : 
; 868  :     while( in_len > 0 ) {

  00479	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR in_len$[rsp], 0
  00482	0f 8e 28 04 00
	00		 jle	 $LN34@binascii_r@2
$LN33@binascii_r@2:

; 869  :         INBYTE(in_byte);

  00488	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR in_len$[rsp]
  00490	48 ff c8	 dec	 rax
  00493	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR in_len$[rsp], rax
  0049b	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR in_len$[rsp], 0
  004a4	7d 31		 jge	 SHORT $LN30@binascii_r@2
  004a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  004ad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Incomplete
  004b4	e8 00 00 00 00	 call	 PyErr_SetString
  004b9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  004c1	e8 00 00 00 00	 call	 _Py_DecRef
  004c6	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  004cb	e8 00 00 00 00	 call	 PyBuffer_Release
  004d0	33 c0		 xor	 eax, eax
  004d2	e9 66 04 00 00	 jmp	 $LN64@binascii_r@2
$LN30@binascii_r@2:
  004d7	48 8b 44 24 40	 mov	 rax, QWORD PTR in_data$[rsp]
  004dc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004df	88 84 24 b0 00
	00 00		 mov	 BYTE PTR in_byte$[rsp], al
  004e6	48 8b 44 24 40	 mov	 rax, QWORD PTR in_data$[rsp]
  004eb	48 ff c0	 inc	 rax
  004ee	48 89 44 24 40	 mov	 QWORD PTR in_data$[rsp], rax
  004f3	33 c0		 xor	 eax, eax
  004f5	85 c0		 test	 eax, eax
  004f7	75 8f		 jne	 SHORT $LN33@binascii_r@2

; 870  : 
; 871  :         if (in_byte == RUNCHAR) {

  004f9	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR in_byte$[rsp]
  00501	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  00506	0f 85 a3 02 00
	00		 jne	 $LN29@binascii_r@2
$LN28@binascii_r@2:

; 872  :             INBYTE(in_repeat);

  0050c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR in_len$[rsp]
  00514	48 ff c8	 dec	 rax
  00517	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR in_len$[rsp], rax
  0051f	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR in_len$[rsp], 0
  00528	7d 31		 jge	 SHORT $LN25@binascii_r@2
  0052a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00531	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Incomplete
  00538	e8 00 00 00 00	 call	 PyErr_SetString
  0053d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00545	e8 00 00 00 00	 call	 _Py_DecRef
  0054a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  0054f	e8 00 00 00 00	 call	 PyBuffer_Release
  00554	33 c0		 xor	 eax, eax
  00556	e9 e2 03 00 00	 jmp	 $LN64@binascii_r@2
$LN25@binascii_r@2:
  0055b	48 8b 44 24 40	 mov	 rax, QWORD PTR in_data$[rsp]
  00560	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00563	88 44 24 38	 mov	 BYTE PTR in_repeat$[rsp], al
  00567	48 8b 44 24 40	 mov	 rax, QWORD PTR in_data$[rsp]
  0056c	48 ff c0	 inc	 rax
  0056f	48 89 44 24 40	 mov	 QWORD PTR in_data$[rsp], rax
  00574	33 c0		 xor	 eax, eax
  00576	85 c0		 test	 eax, eax
  00578	75 92		 jne	 SHORT $LN28@binascii_r@2

; 873  :             if ( in_repeat == 0 ) {

  0057a	0f b6 44 24 38	 movzx	 eax, BYTE PTR in_repeat$[rsp]
  0057f	85 c0		 test	 eax, eax
  00581	0f 85 fa 00 00
	00		 jne	 $LN24@binascii_r@2
$LN23@binascii_r@2:

; 874  :                 /* Just an escaped RUNCHAR value */
; 875  :                 OUTBYTE(RUNCHAR);

  00587	48 8b 44 24 20	 mov	 rax, QWORD PTR out_len_left$[rsp]
  0058c	48 ff c8	 dec	 rax
  0058f	48 89 44 24 20	 mov	 QWORD PTR out_len_left$[rsp], rax
  00594	48 83 7c 24 20
	00		 cmp	 QWORD PTR out_len_left$[rsp], 0
  0059a	0f 8d bd 00 00
	00		 jge	 $LN20@binascii_r@2
  005a0	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  005aa	48 39 44 24 30	 cmp	 QWORD PTR out_len$[rsp], rax
  005af	7e 0a		 jle	 SHORT $LN19@binascii_r@2
  005b1	e8 00 00 00 00	 call	 PyErr_NoMemory
  005b6	e9 82 03 00 00	 jmp	 $LN64@binascii_r@2
$LN19@binascii_r@2:
  005bb	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  005c0	48 03 c0	 add	 rax, rax
  005c3	48 8b d0	 mov	 rdx, rax
  005c6	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  005ce	e8 00 00 00 00	 call	 _PyBytes_Resize
  005d3	85 c0		 test	 eax, eax
  005d5	7d 1e		 jge	 SHORT $LN18@binascii_r@2
  005d7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  005df	e8 00 00 00 00	 call	 _Py_DecRef
  005e4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  005e9	e8 00 00 00 00	 call	 PyBuffer_Release
  005ee	33 c0		 xor	 eax, eax
  005f0	e9 48 03 00 00	 jmp	 $LN64@binascii_r@2
$LN18@binascii_r@2:
  005f5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  005fd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00601	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00607	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0060c	85 c0		 test	 eax, eax
  0060e	75 1c		 jne	 SHORT $LN70@binascii_r@2
  00610	41 b8 6b 03 00
	00		 mov	 r8d, 875		; 0000036bH
  00616	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0061d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  00624	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0062a	33 c0		 xor	 eax, eax
$LN70@binascii_r@2:
  0062c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00634	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out_len$[rsp]
  00639	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  0063e	48 89 44 24 28	 mov	 QWORD PTR out_data$[rsp], rax
  00643	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  00648	48 ff c8	 dec	 rax
  0064b	48 89 44 24 20	 mov	 QWORD PTR out_len_left$[rsp], rax
  00650	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  00655	48 03 c0	 add	 rax, rax
  00658	48 89 44 24 30	 mov	 QWORD PTR out_len$[rsp], rax
$LN20@binascii_r@2:
  0065d	48 8b 44 24 28	 mov	 rax, QWORD PTR out_data$[rsp]
  00662	c6 00 90	 mov	 BYTE PTR [rax], 144	; 00000090H
  00665	48 8b 44 24 28	 mov	 rax, QWORD PTR out_data$[rsp]
  0066a	48 ff c0	 inc	 rax
  0066d	48 89 44 24 28	 mov	 QWORD PTR out_data$[rsp], rax
  00672	33 c0		 xor	 eax, eax
  00674	85 c0		 test	 eax, eax
  00676	0f 85 0b ff ff
	ff		 jne	 $LN23@binascii_r@2

; 876  :             } else {

  0067c	e9 29 01 00 00	 jmp	 $LN17@binascii_r@2
$LN24@binascii_r@2:

; 877  :                 /* Pick up value and output a sequence of it */
; 878  :                 in_byte = out_data[-1];

  00681	48 8b 44 24 28	 mov	 rax, QWORD PTR out_data$[rsp]
  00686	0f b6 40 ff	 movzx	 eax, BYTE PTR [rax-1]
  0068a	88 84 24 b0 00
	00 00		 mov	 BYTE PTR in_byte$[rsp], al
$LN16@binascii_r@2:

; 879  :                 while ( --in_repeat > 0 )

  00691	0f b6 44 24 38	 movzx	 eax, BYTE PTR in_repeat$[rsp]
  00696	fe c8		 dec	 al
  00698	88 44 24 38	 mov	 BYTE PTR in_repeat$[rsp], al
  0069c	0f b6 44 24 38	 movzx	 eax, BYTE PTR in_repeat$[rsp]
  006a1	85 c0		 test	 eax, eax
  006a3	0f 8e 01 01 00
	00		 jle	 $LN15@binascii_r@2
$LN14@binascii_r@2:

; 880  :                     OUTBYTE(in_byte);

  006a9	48 8b 44 24 20	 mov	 rax, QWORD PTR out_len_left$[rsp]
  006ae	48 ff c8	 dec	 rax
  006b1	48 89 44 24 20	 mov	 QWORD PTR out_len_left$[rsp], rax
  006b6	48 83 7c 24 20
	00		 cmp	 QWORD PTR out_len_left$[rsp], 0
  006bc	0f 8d bd 00 00
	00		 jge	 $LN11@binascii_r@2
  006c2	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  006cc	48 39 44 24 30	 cmp	 QWORD PTR out_len$[rsp], rax
  006d1	7e 0a		 jle	 SHORT $LN10@binascii_r@2
  006d3	e8 00 00 00 00	 call	 PyErr_NoMemory
  006d8	e9 60 02 00 00	 jmp	 $LN64@binascii_r@2
$LN10@binascii_r@2:
  006dd	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  006e2	48 03 c0	 add	 rax, rax
  006e5	48 8b d0	 mov	 rdx, rax
  006e8	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  006f0	e8 00 00 00 00	 call	 _PyBytes_Resize
  006f5	85 c0		 test	 eax, eax
  006f7	7d 1e		 jge	 SHORT $LN9@binascii_r@2
  006f9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00701	e8 00 00 00 00	 call	 _Py_DecRef
  00706	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  0070b	e8 00 00 00 00	 call	 PyBuffer_Release
  00710	33 c0		 xor	 eax, eax
  00712	e9 26 02 00 00	 jmp	 $LN64@binascii_r@2
$LN9@binascii_r@2:
  00717	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  0071f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00723	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00729	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0072e	85 c0		 test	 eax, eax
  00730	75 1c		 jne	 SHORT $LN71@binascii_r@2
  00732	41 b8 70 03 00
	00		 mov	 r8d, 880		; 00000370H
  00738	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0073f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  00746	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0074c	33 c0		 xor	 eax, eax
$LN71@binascii_r@2:
  0074e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00756	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out_len$[rsp]
  0075b	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  00760	48 89 44 24 28	 mov	 QWORD PTR out_data$[rsp], rax
  00765	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  0076a	48 ff c8	 dec	 rax
  0076d	48 89 44 24 20	 mov	 QWORD PTR out_len_left$[rsp], rax
  00772	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  00777	48 03 c0	 add	 rax, rax
  0077a	48 89 44 24 30	 mov	 QWORD PTR out_len$[rsp], rax
$LN11@binascii_r@2:
  0077f	48 8b 44 24 28	 mov	 rax, QWORD PTR out_data$[rsp]
  00784	0f b6 8c 24 b0
	00 00 00	 movzx	 ecx, BYTE PTR in_byte$[rsp]
  0078c	88 08		 mov	 BYTE PTR [rax], cl
  0078e	48 8b 44 24 28	 mov	 rax, QWORD PTR out_data$[rsp]
  00793	48 ff c0	 inc	 rax
  00796	48 89 44 24 28	 mov	 QWORD PTR out_data$[rsp], rax
  0079b	33 c0		 xor	 eax, eax
  0079d	85 c0		 test	 eax, eax
  0079f	0f 85 04 ff ff
	ff		 jne	 $LN14@binascii_r@2
  007a5	e9 e7 fe ff ff	 jmp	 $LN16@binascii_r@2
$LN15@binascii_r@2:
$LN17@binascii_r@2:

; 881  :             }
; 882  :         } else {

  007aa	e9 fc 00 00 00	 jmp	 $LN8@binascii_r@2
$LN29@binascii_r@2:
$LN7@binascii_r@2:

; 883  :             /* Normal byte */
; 884  :             OUTBYTE(in_byte);

  007af	48 8b 44 24 20	 mov	 rax, QWORD PTR out_len_left$[rsp]
  007b4	48 ff c8	 dec	 rax
  007b7	48 89 44 24 20	 mov	 QWORD PTR out_len_left$[rsp], rax
  007bc	48 83 7c 24 20
	00		 cmp	 QWORD PTR out_len_left$[rsp], 0
  007c2	0f 8d bd 00 00
	00		 jge	 $LN4@binascii_r@2
  007c8	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  007d2	48 39 44 24 30	 cmp	 QWORD PTR out_len$[rsp], rax
  007d7	7e 0a		 jle	 SHORT $LN3@binascii_r@2
  007d9	e8 00 00 00 00	 call	 PyErr_NoMemory
  007de	e9 5a 01 00 00	 jmp	 $LN64@binascii_r@2
$LN3@binascii_r@2:
  007e3	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  007e8	48 03 c0	 add	 rax, rax
  007eb	48 8b d0	 mov	 rdx, rax
  007ee	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  007f6	e8 00 00 00 00	 call	 _PyBytes_Resize
  007fb	85 c0		 test	 eax, eax
  007fd	7d 1e		 jge	 SHORT $LN2@binascii_r@2
  007ff	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  00807	e8 00 00 00 00	 call	 _Py_DecRef
  0080c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  00811	e8 00 00 00 00	 call	 PyBuffer_Release
  00816	33 c0		 xor	 eax, eax
  00818	e9 20 01 00 00	 jmp	 $LN64@binascii_r@2
$LN2@binascii_r@2:
  0081d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  00825	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00829	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0082f	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00834	85 c0		 test	 eax, eax
  00836	75 1c		 jne	 SHORT $LN72@binascii_r@2
  00838	41 b8 74 03 00
	00		 mov	 r8d, 884		; 00000374H
  0083e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00845	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  0084c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00852	33 c0		 xor	 eax, eax
$LN72@binascii_r@2:
  00854	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  0085c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out_len$[rsp]
  00861	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  00866	48 89 44 24 28	 mov	 QWORD PTR out_data$[rsp], rax
  0086b	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  00870	48 ff c8	 dec	 rax
  00873	48 89 44 24 20	 mov	 QWORD PTR out_len_left$[rsp], rax
  00878	48 8b 44 24 30	 mov	 rax, QWORD PTR out_len$[rsp]
  0087d	48 d1 e0	 shl	 rax, 1
  00880	48 89 44 24 30	 mov	 QWORD PTR out_len$[rsp], rax
$LN4@binascii_r@2:
  00885	48 8b 44 24 28	 mov	 rax, QWORD PTR out_data$[rsp]
  0088a	0f b6 8c 24 b0
	00 00 00	 movzx	 ecx, BYTE PTR in_byte$[rsp]
  00892	88 08		 mov	 BYTE PTR [rax], cl
  00894	48 8b 44 24 28	 mov	 rax, QWORD PTR out_data$[rsp]
  00899	48 ff c0	 inc	 rax
  0089c	48 89 44 24 28	 mov	 QWORD PTR out_data$[rsp], rax
  008a1	33 c0		 xor	 eax, eax
  008a3	85 c0		 test	 eax, eax
  008a5	0f 85 04 ff ff
	ff		 jne	 $LN7@binascii_r@2
$LN8@binascii_r@2:

; 885  :         }
; 886  :     }

  008ab	e9 c9 fb ff ff	 jmp	 $LN35@binascii_r@2
$LN34@binascii_r@2:

; 887  :     if (_PyBytes_Resize(&rv,
; 888  :                        (out_data -
; 889  :                         (unsigned char *)PyBytes_AS_STRING(rv))) < 0) {

  008b0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  008b8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  008bc	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  008c2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  008c7	85 c0		 test	 eax, eax
  008c9	75 1c		 jne	 SHORT $LN73@binascii_r@2
  008cb	41 b8 79 03 00
	00		 mov	 r8d, 889		; 00000379H
  008d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  008d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@BGMMCGBK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAv?$AA?$CJ?$AA?$AA@
  008df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  008e5	33 c0		 xor	 eax, eax
$LN73@binascii_r@2:
  008e7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
  008ef	48 83 c0 78	 add	 rax, 120		; 00000078H
  008f3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR out_data$[rsp]
  008f8	48 2b c8	 sub	 rcx, rax
  008fb	48 8b c1	 mov	 rax, rcx
  008fe	48 8b d0	 mov	 rdx, rax
  00901	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR rv$[rsp]
  00909	e8 00 00 00 00	 call	 _PyBytes_Resize
  0090e	85 c0		 test	 eax, eax
  00910	7d 19		 jge	 SHORT $LN1@binascii_r@2

; 890  :         Py_DECREF(rv);

  00912	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rv$[rsp]
  0091a	e8 00 00 00 00	 call	 _Py_DecRef

; 891  :         rv = NULL;

  0091f	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rv$[rsp], 0
$LN1@binascii_r@2:

; 892  :     }
; 893  :     PyBuffer_Release(&pin);

  0092b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pin$[rsp]
  00930	e8 00 00 00 00	 call	 PyBuffer_Release

; 894  :     return rv;

  00935	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN64@binascii_r@2:

; 895  : }

  0093d	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00944	c3		 ret	 0
binascii_rledecode_hqx ENDP
_TEXT	ENDS
PUBLIC	??_C@_01KBJDNOO@i?$AA@				; `string'
PUBLIC	??_C@_0M@JCOAFNJB@y?$CKi?3crc_hqx?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_crc_hqx DD imagerel binascii_crc_hqx
	DD	imagerel binascii_crc_hqx+204
	DD	imagerel $unwind$binascii_crc_hqx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_crc_hqx DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_01KBJDNOO@i?$AA@
CONST	SEGMENT
??_C@_01KBJDNOO@i?$AA@ DB 'i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@JCOAFNJB@y?$CKi?3crc_hqx?$AA@
CONST	SEGMENT
??_C@_0M@JCOAFNJB@y?$CKi?3crc_hqx?$AA@ DB 'y*i:crc_hqx', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_crc_hqx
_TEXT	SEGMENT
crc$ = 32
bin_data$ = 40
len$ = 48
pin$ = 64
self$ = 160
args$ = 168
binascii_crc_hqx PROC					; COMDAT

; 902  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 903  :     Py_buffer pin;
; 904  :     unsigned char *bin_data;
; 905  :     unsigned int crc;
; 906  :     Py_ssize_t len;
; 907  : 
; 908  :     if ( !PyArg_ParseTuple(args, "y*i:crc_hqx", &pin, &crc) )

  00011	4c 8d 4c 24 20	 lea	 r9, QWORD PTR crc$[rsp]
  00016	4c 8d 44 24 40	 lea	 r8, QWORD PTR pin$[rsp]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@JCOAFNJB@y?$CKi?3crc_hqx?$AA@
  00022	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0002a	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002f	85 c0		 test	 eax, eax
  00031	75 07		 jne	 SHORT $LN3@binascii_c

; 909  :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	e9 8a 00 00 00	 jmp	 $LN4@binascii_c
$LN3@binascii_c:

; 910  :     bin_data = pin.buf;

  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR pin$[rsp]
  0003f	48 89 44 24 28	 mov	 QWORD PTR bin_data$[rsp], rax

; 911  :     len = pin.len;

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR pin$[rsp+16]
  00049	48 89 44 24 30	 mov	 QWORD PTR len$[rsp], rax
$LN2@binascii_c:

; 912  : 
; 913  :     while(len-- > 0) {

  0004e	48 8b 44 24 30	 mov	 rax, QWORD PTR len$[rsp]
  00053	48 8b 4c 24 30	 mov	 rcx, QWORD PTR len$[rsp]
  00058	48 ff c9	 dec	 rcx
  0005b	48 89 4c 24 30	 mov	 QWORD PTR len$[rsp], rcx
  00060	48 85 c0	 test	 rax, rax
  00063	7e 45		 jle	 SHORT $LN1@binascii_c

; 914  :         crc=((crc<<8)&0xff00)^crctab_hqx[((crc>>8)&0xff)^*bin_data++];

  00065	8b 44 24 20	 mov	 eax, DWORD PTR crc$[rsp]
  00069	c1 e0 08	 shl	 eax, 8
  0006c	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00071	8b 4c 24 20	 mov	 ecx, DWORD PTR crc$[rsp]
  00075	c1 e9 08	 shr	 ecx, 8
  00078	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0007e	48 8b 54 24 28	 mov	 rdx, QWORD PTR bin_data$[rsp]
  00083	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00086	33 ca		 xor	 ecx, edx
  00088	8b c9		 mov	 ecx, ecx
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:crctab_hqx
  00091	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  00095	33 c1		 xor	 eax, ecx
  00097	89 44 24 20	 mov	 DWORD PTR crc$[rsp], eax
  0009b	48 8b 44 24 28	 mov	 rax, QWORD PTR bin_data$[rsp]
  000a0	48 ff c0	 inc	 rax
  000a3	48 89 44 24 28	 mov	 QWORD PTR bin_data$[rsp], rax

; 915  :     }

  000a8	eb a4		 jmp	 SHORT $LN2@binascii_c
$LN1@binascii_c:

; 916  : 
; 917  :     PyBuffer_Release(&pin);

  000aa	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pin$[rsp]
  000af	e8 00 00 00 00	 call	 PyBuffer_Release

; 918  :     return Py_BuildValue("i", crc);

  000b4	8b 54 24 20	 mov	 edx, DWORD PTR crc$[rsp]
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01KBJDNOO@i?$AA@
  000bf	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
$LN4@binascii_c:

; 919  : }

  000c4	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  000cb	c3		 ret	 0
binascii_crc_hqx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@IKICDLGJ@y?$CK?$HMI?3crc32?$AA@	; `string'
EXTRN	PyLong_FromUnsignedLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_crc32 DD imagerel binascii_crc32
	DD	imagerel binascii_crc32+236
	DD	imagerel $unwind$binascii_crc32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_crc32 DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0L@IKICDLGJ@y?$CK?$HMI?3crc32?$AA@
CONST	SEGMENT
??_C@_0L@IKICDLGJ@y?$CK?$HMI?3crc32?$AA@ DB 'y*|I:crc32', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_crc32
_TEXT	SEGMENT
crc$ = 32
bin_data$ = 40
pbin$ = 48
len$ = 128
result$ = 136
self$ = 160
args$ = 168
binascii_crc32 PROC					; COMDAT

; 1064 : { /* By Jim Ahlstrom; All rights transferred to CNRI */

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1065 :     Py_buffer pbin;
; 1066 :     unsigned char *bin_data;
; 1067 :     unsigned int crc = 0;       /* initial value of CRC */

  00011	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR crc$[rsp], 0

; 1068 :     Py_ssize_t len;
; 1069 :     unsigned int result;
; 1070 : 
; 1071 :     if ( !PyArg_ParseTuple(args, "y*|I:crc32", &pbin, &crc) )

  00019	4c 8d 4c 24 20	 lea	 r9, QWORD PTR crc$[rsp]
  0001e	4c 8d 44 24 30	 lea	 r8, QWORD PTR pbin$[rsp]
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@IKICDLGJ@y?$CK?$HMI?3crc32?$AA@
  0002a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00032	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00037	85 c0		 test	 eax, eax
  00039	75 07		 jne	 SHORT $LN3@binascii_c@2

; 1072 :         return NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	e9 a2 00 00 00	 jmp	 $LN4@binascii_c@2
$LN3@binascii_c@2:

; 1073 :     bin_data = pbin.buf;

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR pbin$[rsp]
  00047	48 89 44 24 28	 mov	 QWORD PTR bin_data$[rsp], rax

; 1074 :     len = pbin.len;

  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR pbin$[rsp+16]
  00051	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 1075 : 
; 1076 :     crc = ~ crc;

  00059	8b 44 24 20	 mov	 eax, DWORD PTR crc$[rsp]
  0005d	f7 d0		 not	 eax
  0005f	89 44 24 20	 mov	 DWORD PTR crc$[rsp], eax
$LN2@binascii_c@2:

; 1077 :     while (len-- > 0) {

  00063	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0006b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00073	48 ff c9	 dec	 rcx
  00076	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR len$[rsp], rcx
  0007e	48 85 c0	 test	 rax, rax
  00081	7e 3d		 jle	 SHORT $LN1@binascii_c@2

; 1078 :         crc = crc_32_tab[(crc ^ *bin_data++) & 0xff] ^ (crc >> 8);

  00083	48 8b 44 24 28	 mov	 rax, QWORD PTR bin_data$[rsp]
  00088	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0008b	8b 4c 24 20	 mov	 ecx, DWORD PTR crc$[rsp]
  0008f	33 c8		 xor	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00098	8b c0		 mov	 eax, eax
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:crc_32_tab
  000a1	8b 54 24 20	 mov	 edx, DWORD PTR crc$[rsp]
  000a5	c1 ea 08	 shr	 edx, 8
  000a8	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000ab	33 c2		 xor	 eax, edx
  000ad	89 44 24 20	 mov	 DWORD PTR crc$[rsp], eax
  000b1	48 8b 44 24 28	 mov	 rax, QWORD PTR bin_data$[rsp]
  000b6	48 ff c0	 inc	 rax
  000b9	48 89 44 24 28	 mov	 QWORD PTR bin_data$[rsp], rax

; 1079 :         /* Note:  (crc >> 8) MUST zero fill on left */
; 1080 :     }

  000be	eb a3		 jmp	 SHORT $LN2@binascii_c@2
$LN1@binascii_c@2:

; 1081 : 
; 1082 :     result = (crc ^ 0xFFFFFFFF);

  000c0	8b 44 24 20	 mov	 eax, DWORD PTR crc$[rsp]
  000c4	83 f0 ff	 xor	 eax, -1			; ffffffffH
  000c7	89 84 24 88 00
	00 00		 mov	 DWORD PTR result$[rsp], eax

; 1083 :     PyBuffer_Release(&pbin);

  000ce	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pbin$[rsp]
  000d3	e8 00 00 00 00	 call	 PyBuffer_Release

; 1084 :     return PyLong_FromUnsignedLong(result & 0xffffffff);

  000d8	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR result$[rsp]
  000df	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
$LN4@binascii_c@2:

; 1085 : }

  000e4	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  000eb	c3		 ret	 0
binascii_crc32 ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@DFIBKFJC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BI@HGAPNJFG@?$AAa?$AAr?$AAg?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0L@HBMGEJLB@y?$CK?3b2a_hex?$AA@		; `string'
EXTRN	Py_hexdigits:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_hexlify DD imagerel binascii_hexlify
	DD	imagerel binascii_hexlify+547
	DD	imagerel $unwind$binascii_hexlify
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_hexlify DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_1CM@DFIBKFJC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@DFIBKFJC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'r', 00H, 'e', 00H, 't', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@HGAPNJFG@?$AAa?$AAr?$AAg?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@HGAPNJFG@?$AAa?$AAr?$AAg?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'a'
	DB	00H, 'r', 00H, 'g', 00H, 'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HBMGEJLB@y?$CK?3b2a_hex?$AA@
CONST	SEGMENT
??_C@_0L@HBMGEJLB@y?$CK?3b2a_hex?$AA@ DB 'y*:b2a_hex', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_hexlify
_TEXT	SEGMENT
i$ = 32
retval$ = 40
argbuf$ = 48
parg$ = 64
arglen$ = 144
retbuf$ = 152
j$ = 160
c$20951 = 168
self$ = 192
args$ = 200
binascii_hexlify PROC					; COMDAT

; 1091 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1092 :     Py_buffer parg;
; 1093 :     char* argbuf;
; 1094 :     Py_ssize_t arglen;
; 1095 :     PyObject *retval;
; 1096 :     char* retbuf;
; 1097 :     Py_ssize_t i, j;
; 1098 : 
; 1099 :     if (!PyArg_ParseTuple(args, "y*:b2a_hex", &parg))

  00011	4c 8d 44 24 40	 lea	 r8, QWORD PTR parg$[rsp]
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@HBMGEJLB@y?$CK?3b2a_hex?$AA@
  0001d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00025	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN6@binascii_h

; 1100 :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 e6 01 00 00	 jmp	 $LN7@binascii_h
$LN6@binascii_h:

; 1101 :     argbuf = parg.buf;

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR parg$[rsp]
  0003a	48 89 44 24 30	 mov	 QWORD PTR argbuf$[rsp], rax

; 1102 :     arglen = parg.len;

  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR parg$[rsp+16]
  00044	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR arglen$[rsp], rax

; 1103 : 
; 1104 :     assert(arglen >= 0);

  0004c	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR arglen$[rsp], 0
  00055	7d 1c		 jge	 SHORT $LN9@binascii_h
  00057	41 b8 50 04 00
	00		 mov	 r8d, 1104		; 00000450H
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@HGAPNJFG@?$AAa?$AAr?$AAg?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00071	33 c0		 xor	 eax, eax
$LN9@binascii_h:

; 1105 :     if (arglen > PY_SSIZE_T_MAX / 2) {

  00073	48 b8 ff ff ff
	ff ff ff ff 3f	 mov	 rax, 4611686018427387903 ; 3fffffffffffffffH
  0007d	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR arglen$[rsp], rax
  00085	7e 14		 jle	 SHORT $LN5@binascii_h

; 1106 :         PyBuffer_Release(&parg);

  00087	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parg$[rsp]
  0008c	e8 00 00 00 00	 call	 PyBuffer_Release

; 1107 :         return PyErr_NoMemory();

  00091	e8 00 00 00 00	 call	 PyErr_NoMemory
  00096	e9 80 01 00 00	 jmp	 $LN7@binascii_h
$LN5@binascii_h:

; 1108 :     }
; 1109 : 
; 1110 :     retval = PyBytes_FromStringAndSize(NULL, arglen*2);

  0009b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR arglen$[rsp]
  000a3	48 d1 e0	 shl	 rax, 1
  000a6	48 8b d0	 mov	 rdx, rax
  000a9	33 c9		 xor	 ecx, ecx
  000ab	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000b0	48 89 44 24 28	 mov	 QWORD PTR retval$[rsp], rax

; 1111 :     if (!retval) {

  000b5	48 83 7c 24 28
	00		 cmp	 QWORD PTR retval$[rsp], 0
  000bb	75 11		 jne	 SHORT $LN4@binascii_h

; 1112 :         PyBuffer_Release(&parg);

  000bd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parg$[rsp]
  000c2	e8 00 00 00 00	 call	 PyBuffer_Release

; 1113 :         return NULL;

  000c7	33 c0		 xor	 eax, eax
  000c9	e9 4d 01 00 00	 jmp	 $LN7@binascii_h
$LN4@binascii_h:

; 1114 :     }
; 1115 :     retbuf = PyBytes_AS_STRING(retval);

  000ce	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  000d3	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d7	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000dd	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000e2	85 c0		 test	 eax, eax
  000e4	75 1c		 jne	 SHORT $LN10@binascii_h
  000e6	41 b8 5b 04 00
	00		 mov	 r8d, 1115		; 0000045bH
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DFIBKFJC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00100	33 c0		 xor	 eax, eax
$LN10@binascii_h:
  00102	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  00107	48 83 c0 78	 add	 rax, 120		; 00000078H
  0010b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR retbuf$[rsp], rax

; 1116 : 
; 1117 :     /* make hex version of string, taken from shamodule.c */
; 1118 :     for (i=j=0; i < arglen; i++) {

  00113	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR j$[rsp], 0
  0011f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00127	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  0012c	eb 0d		 jmp	 SHORT $LN3@binascii_h
$LN2@binascii_h:
  0012e	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00133	48 ff c0	 inc	 rax
  00136	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@binascii_h:
  0013b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR arglen$[rsp]
  00143	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00148	0f 8d be 00 00
	00		 jge	 $LN1@binascii_h

; 1119 :         unsigned char c;
; 1120 :         c = (argbuf[i] >> 4) & 0xf;

  0014e	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00153	48 8b 4c 24 30	 mov	 rcx, QWORD PTR argbuf$[rsp]
  00158	48 03 c8	 add	 rcx, rax
  0015b	48 8b c1	 mov	 rax, rcx
  0015e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00161	c1 f8 04	 sar	 eax, 4
  00164	83 e0 0f	 and	 eax, 15
  00167	88 84 24 a8 00
	00 00		 mov	 BYTE PTR c$20951[rsp], al

; 1121 :         retbuf[j++] = Py_hexdigits[c];

  0016e	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR c$20951[rsp]
  00176	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0017e	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR retbuf$[rsp]
  00186	48 03 d1	 add	 rdx, rcx
  00189	48 8b ca	 mov	 rcx, rdx
  0018c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  00193	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00197	88 01		 mov	 BYTE PTR [rcx], al
  00199	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  001a1	48 ff c0	 inc	 rax
  001a4	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR j$[rsp], rax

; 1122 :         c = argbuf[i] & 0xf;

  001ac	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  001b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR argbuf$[rsp]
  001b6	48 03 c8	 add	 rcx, rax
  001b9	48 8b c1	 mov	 rax, rcx
  001bc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001bf	83 e0 0f	 and	 eax, 15
  001c2	88 84 24 a8 00
	00 00		 mov	 BYTE PTR c$20951[rsp], al

; 1123 :         retbuf[j++] = Py_hexdigits[c];

  001c9	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR c$20951[rsp]
  001d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  001d9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR retbuf$[rsp]
  001e1	48 03 d1	 add	 rdx, rcx
  001e4	48 8b ca	 mov	 rcx, rdx
  001e7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR Py_hexdigits
  001ee	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  001f2	88 01		 mov	 BYTE PTR [rcx], al
  001f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  001fc	48 ff c0	 inc	 rax
  001ff	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR j$[rsp], rax

; 1124 :     }

  00207	e9 22 ff ff ff	 jmp	 $LN2@binascii_h
$LN1@binascii_h:

; 1125 :     PyBuffer_Release(&parg);

  0020c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parg$[rsp]
  00211	e8 00 00 00 00	 call	 PyBuffer_Release

; 1126 :     return retval;

  00216	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
$LN7@binascii_h:

; 1127 : }

  0021b	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00222	c3		 ret	 0
binascii_hexlify ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@MEIKJPBP@Non?9hexadecimal?5digit?5found?$AA@ ; `string'
PUBLIC	??_C@_0BC@EBKNKDAI@Odd?9length?5string?$AA@	; `string'
PUBLIC	??_C@_0L@KDDOFNCN@O?$CG?3a2b_hex?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_unhexlify DD imagerel binascii_unhexlify
	DD	imagerel binascii_unhexlify+604
	DD	imagerel $unwind$binascii_unhexlify
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_unhexlify DD 021101H
	DD	0170111H
xdata	ENDS
;	COMDAT ??_C@_0BM@MEIKJPBP@Non?9hexadecimal?5digit?5found?$AA@
CONST	SEGMENT
??_C@_0BM@MEIKJPBP@Non?9hexadecimal?5digit?5found?$AA@ DB 'Non-hexadecima'
	DB	'l digit found', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EBKNKDAI@Odd?9length?5string?$AA@
CONST	SEGMENT
??_C@_0BC@EBKNKDAI@Odd?9length?5string?$AA@ DB 'Odd-length string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KDDOFNCN@O?$CG?3a2b_hex?$AA@
CONST	SEGMENT
??_C@_0L@KDDOFNCN@O?$CG?3a2b_hex?$AA@ DB 'O&:a2b_hex', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_unhexlify
_TEXT	SEGMENT
i$ = 32
retval$ = 40
argbuf$ = 48
parg$ = 64
arglen$ = 144
retbuf$ = 152
j$ = 160
bot$20995 = 168
top$20993 = 172
self$ = 192
args$ = 200
binascii_unhexlify PROC					; COMDAT

; 1153 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1154 :     Py_buffer parg;
; 1155 :     char* argbuf;
; 1156 :     Py_ssize_t arglen;
; 1157 :     PyObject *retval;
; 1158 :     char* retbuf;
; 1159 :     Py_ssize_t i, j;
; 1160 : 
; 1161 :     if (!PyArg_ParseTuple(args, "O&:a2b_hex", ascii_buffer_converter, &parg))

  00011	4c 8d 4c 24 40	 lea	 r9, QWORD PTR parg$[rsp]
  00016	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ascii_buffer_converter
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@KDDOFNCN@O?$CG?3a2b_hex?$AA@
  00024	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0002c	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00031	85 c0		 test	 eax, eax
  00033	75 07		 jne	 SHORT $LN8@binascii_u

; 1162 :         return NULL;

  00035	33 c0		 xor	 eax, eax
  00037	e9 18 02 00 00	 jmp	 $LN9@binascii_u
$LN8@binascii_u:

; 1163 :     argbuf = parg.buf;

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR parg$[rsp]
  00041	48 89 44 24 30	 mov	 QWORD PTR argbuf$[rsp], rax

; 1164 :     arglen = parg.len;

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR parg$[rsp+16]
  0004b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR arglen$[rsp], rax

; 1165 : 
; 1166 :     assert(arglen >= 0);

  00053	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR arglen$[rsp], 0
  0005c	7d 1c		 jge	 SHORT $LN11@binascii_u
  0005e	41 b8 8e 04 00
	00		 mov	 r8d, 1166		; 0000048eH
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@HGAPNJFG@?$AAa?$AAr?$AAg?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00078	33 c0		 xor	 eax, eax
$LN11@binascii_u:

; 1167 : 
; 1168 :     /* XXX What should we do about strings with an odd length?  Should
; 1169 :      * we add an implicit leading zero, or a trailing zero?  For now,
; 1170 :      * raise an exception.
; 1171 :      */
; 1172 :     if (arglen % 2) {

  0007a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR arglen$[rsp]
  00082	48 99		 cdq
  00084	48 83 e0 01	 and	 rax, 1
  00088	48 33 c2	 xor	 rax, rdx
  0008b	48 2b c2	 sub	 rax, rdx
  0008e	48 85 c0	 test	 rax, rax
  00091	74 24		 je	 SHORT $LN7@binascii_u

; 1173 :         PyBuffer_Release(&parg);

  00093	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parg$[rsp]
  00098	e8 00 00 00 00	 call	 PyBuffer_Release

; 1174 :         PyErr_SetString(Error, "Odd-length string");

  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EBKNKDAI@Odd?9length?5string?$AA@
  000a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  000ab	e8 00 00 00 00	 call	 PyErr_SetString

; 1175 :         return NULL;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 9d 01 00 00	 jmp	 $LN9@binascii_u
$LN7@binascii_u:

; 1176 :     }
; 1177 : 
; 1178 :     retval = PyBytes_FromStringAndSize(NULL, (arglen/2));

  000b7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR arglen$[rsp]
  000bf	48 99		 cdq
  000c1	48 2b c2	 sub	 rax, rdx
  000c4	48 d1 f8	 sar	 rax, 1
  000c7	48 8b d0	 mov	 rdx, rax
  000ca	33 c9		 xor	 ecx, ecx
  000cc	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000d1	48 89 44 24 28	 mov	 QWORD PTR retval$[rsp], rax

; 1179 :     if (!retval) {

  000d6	48 83 7c 24 28
	00		 cmp	 QWORD PTR retval$[rsp], 0
  000dc	75 11		 jne	 SHORT $LN6@binascii_u

; 1180 :         PyBuffer_Release(&parg);

  000de	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parg$[rsp]
  000e3	e8 00 00 00 00	 call	 PyBuffer_Release

; 1181 :         return NULL;

  000e8	33 c0		 xor	 eax, eax
  000ea	e9 65 01 00 00	 jmp	 $LN9@binascii_u
$LN6@binascii_u:

; 1182 :     }
; 1183 :     retbuf = PyBytes_AS_STRING(retval);

  000ef	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  000f4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000fe	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00103	85 c0		 test	 eax, eax
  00105	75 1c		 jne	 SHORT $LN12@binascii_u
  00107	41 b8 9f 04 00
	00		 mov	 r8d, 1183		; 0000049fH
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@BKGJJKIC@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAb?$AAi?$AAn?$AAa?$AAs?$AAc?$AAi?$AAi?$AA?4?$AAc?$AA?$AA@
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@DFIBKFJC@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@
  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00121	33 c0		 xor	 eax, eax
$LN12@binascii_u:
  00123	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  00128	48 83 c0 78	 add	 rax, 120		; 00000078H
  0012c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR retbuf$[rsp], rax

; 1184 : 
; 1185 :     for (i=j=0; i < arglen; i += 2) {

  00134	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR j$[rsp], 0
  00140	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00148	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
  0014d	eb 0e		 jmp	 SHORT $LN5@binascii_u
$LN4@binascii_u:
  0014f	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00154	48 83 c0 02	 add	 rax, 2
  00158	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN5@binascii_u:
  0015d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR arglen$[rsp]
  00165	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  0016a	0f 8d bd 00 00
	00		 jge	 $LN3@binascii_u

; 1186 :         int top = to_int(Py_CHARMASK(argbuf[i]));

  00170	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00175	48 8b 4c 24 30	 mov	 rcx, QWORD PTR argbuf$[rsp]
  0017a	48 03 c8	 add	 rcx, rax
  0017d	48 8b c1	 mov	 rax, rcx
  00180	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00183	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00188	0f b6 c0	 movzx	 eax, al
  0018b	8b c8		 mov	 ecx, eax
  0018d	e8 00 00 00 00	 call	 to_int
  00192	89 84 24 ac 00
	00 00		 mov	 DWORD PTR top$20993[rsp], eax

; 1187 :         int bot = to_int(Py_CHARMASK(argbuf[i+1]));

  00199	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0019e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR argbuf$[rsp]
  001a3	48 03 c8	 add	 rcx, rax
  001a6	48 8b c1	 mov	 rax, rcx
  001a9	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  001ad	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001b2	0f b6 c0	 movzx	 eax, al
  001b5	8b c8		 mov	 ecx, eax
  001b7	e8 00 00 00 00	 call	 to_int
  001bc	89 84 24 a8 00
	00 00		 mov	 DWORD PTR bot$20995[rsp], eax

; 1188 :         if (top == -1 || bot == -1) {

  001c3	83 bc 24 ac 00
	00 00 ff	 cmp	 DWORD PTR top$20993[rsp], -1
  001cb	74 0a		 je	 SHORT $LN1@binascii_u
  001cd	83 bc 24 a8 00
	00 00 ff	 cmp	 DWORD PTR bot$20995[rsp], -1
  001d5	75 15		 jne	 SHORT $LN2@binascii_u
$LN1@binascii_u:

; 1189 :             PyErr_SetString(Error,
; 1190 :                             "Non-hexadecimal digit found");

  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@MEIKJPBP@Non?9hexadecimal?5digit?5found?$AA@
  001de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR Error
  001e5	e8 00 00 00 00	 call	 PyErr_SetString

; 1191 :             goto finally;

  001ea	eb 52		 jmp	 SHORT $finally$21000
$LN2@binascii_u:

; 1192 :         }
; 1193 :         retbuf[j++] = (top << 4) + bot;

  001ec	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR top$20993[rsp]
  001f3	c1 e0 04	 shl	 eax, 4
  001f6	03 84 24 a8 00
	00 00		 add	 eax, DWORD PTR bot$20995[rsp]
  001fd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00205	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR retbuf$[rsp]
  0020d	48 03 d1	 add	 rdx, rcx
  00210	48 8b ca	 mov	 rcx, rdx
  00213	88 01		 mov	 BYTE PTR [rcx], al
  00215	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0021d	48 ff c0	 inc	 rax
  00220	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR j$[rsp], rax

; 1194 :     }

  00228	e9 22 ff ff ff	 jmp	 $LN4@binascii_u
$LN3@binascii_u:

; 1195 :     PyBuffer_Release(&parg);

  0022d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parg$[rsp]
  00232	e8 00 00 00 00	 call	 PyBuffer_Release

; 1196 :     return retval;

  00237	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  0023c	eb 16		 jmp	 SHORT $LN9@binascii_u
$finally$21000:

; 1197 : 
; 1198 :   finally:
; 1199 :     PyBuffer_Release(&parg);

  0023e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parg$[rsp]
  00243	e8 00 00 00 00	 call	 PyBuffer_Release

; 1200 :     Py_DECREF(retval);

  00248	48 8b 4c 24 28	 mov	 rcx, QWORD PTR retval$[rsp]
  0024d	e8 00 00 00 00	 call	 _Py_DecRef

; 1201 :     return NULL;

  00252	33 c0		 xor	 eax, eax
$LN9@binascii_u:

; 1202 : }

  00254	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0025b	c3		 ret	 0
binascii_unhexlify ENDP
_TEXT	ENDS
EXTRN	_Py_ctype_tolower:BYTE
EXTRN	_Py_ctype_table:BYTE
; Function compile flags: /Odtp
;	COMDAT to_int
_TEXT	SEGMENT
c$ = 8
to_int	PROC						; COMDAT

; 1138 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1139 :     if (Py_ISDIGIT(c))

  00004	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00008	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0000d	0f b6 c0	 movzx	 eax, al
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  00017	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0001a	83 e0 04	 and	 eax, 4
  0001d	85 c0		 test	 eax, eax
  0001f	74 0b		 je	 SHORT $LN4@to_int

; 1140 :         return c - '0';

  00021	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00025	83 e8 30	 sub	 eax, 48			; 00000030H
  00028	eb 56		 jmp	 SHORT $LN5@to_int

; 1141 :     else {

  0002a	eb 4f		 jmp	 SHORT $LN3@to_int
$LN4@to_int:

; 1142 :         if (Py_ISUPPER(c))

  0002c	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00030	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00035	0f b6 c0	 movzx	 eax, al
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_table
  0003f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00042	83 e0 02	 and	 eax, 2
  00045	85 c0		 test	 eax, eax
  00047	74 1b		 je	 SHORT $LN2@to_int

; 1143 :             c = Py_TOLOWER(c);

  00049	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  0004d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00052	0f b6 c0	 movzx	 eax, al
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_ctype_tolower
  0005c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00060	89 44 24 08	 mov	 DWORD PTR c$[rsp], eax
$LN2@to_int:

; 1144 :         if (c >= 'a' && c <= 'f')

  00064	83 7c 24 08 61	 cmp	 DWORD PTR c$[rsp], 97	; 00000061H
  00069	7c 10		 jl	 SHORT $LN1@to_int
  0006b	83 7c 24 08 66	 cmp	 DWORD PTR c$[rsp], 102	; 00000066H
  00070	7f 09		 jg	 SHORT $LN1@to_int

; 1145 :             return c - 'a' + 10;

  00072	8b 44 24 08	 mov	 eax, DWORD PTR c$[rsp]
  00076	83 e8 57	 sub	 eax, 87			; 00000057H
  00079	eb 05		 jmp	 SHORT $LN5@to_int
$LN1@to_int:
$LN3@to_int:

; 1146 :     }
; 1147 :     return -1;

  0007b	b8 ff ff ff ff	 mov	 eax, -1
$LN5@to_int:

; 1148 : }

  00080	f3 c3		 fatret	 0
to_int	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@MOKPOIGG@O?$CG?$HMi?3a2b_qp?$AA@	; `string'
EXTRN	PyMem_Free:PROC
EXTRN	memset:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_a2b_qp DD imagerel binascii_a2b_qp
	DD	imagerel binascii_a2b_qp+1564
	DD	imagerel $unwind$binascii_a2b_qp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_a2b_qp DD 021601H
	DD	01d0116H
xdata	ENDS
;	COMDAT ??_C@_0M@MOKPOIGG@O?$CG?$HMi?3a2b_qp?$AA@
CONST	SEGMENT
??_C@_0M@MOKPOIGG@O?$CG?$HMi?3a2b_qp?$AA@ DB 'O&|i:a2b_qp', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_a2b_qp
_TEXT	SEGMENT
datalen$ = 64
pdata$ = 80
in$ = 160
rv$ = 168
data$ = 176
odata$ = 184
ch$ = 192
out$ = 200
header$ = 208
self$ = 240
args$ = 248
kwargs$ = 256
binascii_a2b_qp PROC					; COMDAT

; 1229 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 1230 :     Py_ssize_t in, out;
; 1231 :     char ch;
; 1232 :     Py_buffer pdata;
; 1233 :     unsigned char *data, *odata;
; 1234 :     Py_ssize_t datalen = 0;

  00016	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR datalen$[rsp], 0

; 1235 :     PyObject *rv;
; 1236 :     static char *kwlist[] = {"data", "header", NULL};
; 1237 :     int header = 0;

  0001f	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR header$[rsp], 0

; 1238 : 
; 1239 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O&|i:a2b_qp", kwlist,
; 1240 :                                      ascii_buffer_converter, &pdata, &header))

  0002a	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR header$[rsp]
  00032	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00037	48 8d 44 24 50	 lea	 rax, QWORD PTR pdata$[rsp]
  0003c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ascii_buffer_converter
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??binascii_a2b_qp@@9@9
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@MOKPOIGG@O?$CG?$HMi?3a2b_qp?$AA@
  0005b	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  00063	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  0006b	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00070	85 c0		 test	 eax, eax
  00072	75 07		 jne	 SHORT $LN27@binascii_a@4

; 1241 :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	e9 99 05 00 00	 jmp	 $LN28@binascii_a@4
$LN27@binascii_a@4:

; 1242 :     data = pdata.buf;

  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR pdata$[rsp]
  00080	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR data$[rsp], rax

; 1243 :     datalen = pdata.len;

  00088	48 8b 44 24 60	 mov	 rax, QWORD PTR pdata$[rsp+16]
  0008d	48 89 44 24 40	 mov	 QWORD PTR datalen$[rsp], rax

; 1244 : 
; 1245 :     /* We allocate the output same size as input, this is overkill.
; 1246 :      * The previous implementation used calloc() so we'll zero out the
; 1247 :      * memory here too, since PyMem_Malloc() does not guarantee that.
; 1248 :      */
; 1249 :     odata = (unsigned char *) PyMem_Malloc(datalen);

  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR datalen$[rsp]
  00097	e8 00 00 00 00	 call	 PyMem_Malloc
  0009c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR odata$[rsp], rax

; 1250 :     if (odata == NULL) {

  000a4	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR odata$[rsp], 0
  000ad	75 16		 jne	 SHORT $LN26@binascii_a@4

; 1251 :         PyBuffer_Release(&pdata);

  000af	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pdata$[rsp]
  000b4	e8 00 00 00 00	 call	 PyBuffer_Release

; 1252 :         PyErr_NoMemory();

  000b9	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1253 :         return NULL;

  000be	33 c0		 xor	 eax, eax
  000c0	e9 4f 05 00 00	 jmp	 $LN28@binascii_a@4
$LN26@binascii_a@4:

; 1254 :     }
; 1255 :     memset(odata, 0, datalen);

  000c5	4c 8b 44 24 40	 mov	 r8, QWORD PTR datalen$[rsp]
  000ca	33 d2		 xor	 edx, edx
  000cc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  000d4	e8 00 00 00 00	 call	 memset

; 1256 : 
; 1257 :     in = out = 0;

  000d9	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR out$[rsp], 0
  000e5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  000ed	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax
$LN25@binascii_a@4:

; 1258 :     while (in < datalen) {

  000f5	48 8b 44 24 40	 mov	 rax, QWORD PTR datalen$[rsp]
  000fa	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR in$[rsp], rax
  00102	0f 8d aa 04 00
	00		 jge	 $LN24@binascii_a@4

; 1259 :         if (data[in] == '=') {

  00108	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00110	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00118	48 03 c8	 add	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00121	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  00124	0f 85 c3 03 00
	00		 jne	 $LN23@binascii_a@4

; 1260 :             in++;

  0012a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00132	48 ff c0	 inc	 rax
  00135	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 1261 :             if (in >= datalen) break;

  0013d	48 8b 44 24 40	 mov	 rax, QWORD PTR datalen$[rsp]
  00142	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR in$[rsp], rax
  0014a	7c 05		 jl	 SHORT $LN22@binascii_a@4
  0014c	e9 61 04 00 00	 jmp	 $LN24@binascii_a@4
$LN22@binascii_a@4:

; 1262 :             /* Soft line breaks */
; 1263 :             if ((data[in] == '\n') || (data[in] == '\r')) {

  00151	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00159	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00161	48 03 c8	 add	 rcx, rax
  00164	48 8b c1	 mov	 rax, rcx
  00167	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0016a	83 f8 0a	 cmp	 eax, 10
  0016d	74 22		 je	 SHORT $LN20@binascii_a@4
  0016f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00177	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0017f	48 03 c8	 add	 rcx, rax
  00182	48 8b c1	 mov	 rax, rcx
  00185	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00188	83 f8 0d	 cmp	 eax, 13
  0018b	0f 85 87 00 00
	00		 jne	 $LN21@binascii_a@4
$LN20@binascii_a@4:

; 1264 :                 if (data[in] != '\n') {

  00191	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00199	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  001a1	48 03 c8	 add	 rcx, rax
  001a4	48 8b c1	 mov	 rax, rcx
  001a7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001aa	83 f8 0a	 cmp	 eax, 10
  001ad	74 42		 je	 SHORT $LN19@binascii_a@4
$LN18@binascii_a@4:

; 1265 :                     while (in < datalen && data[in] != '\n') in++;

  001af	48 8b 44 24 40	 mov	 rax, QWORD PTR datalen$[rsp]
  001b4	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR in$[rsp], rax
  001bc	7d 33		 jge	 SHORT $LN17@binascii_a@4
  001be	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  001c6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  001ce	48 03 c8	 add	 rcx, rax
  001d1	48 8b c1	 mov	 rax, rcx
  001d4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d7	83 f8 0a	 cmp	 eax, 10
  001da	74 15		 je	 SHORT $LN17@binascii_a@4
  001dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  001e4	48 ff c0	 inc	 rax
  001e7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax
  001ef	eb be		 jmp	 SHORT $LN18@binascii_a@4
$LN17@binascii_a@4:
$LN19@binascii_a@4:

; 1266 :                 }
; 1267 :                 if (in < datalen) in++;

  001f1	48 8b 44 24 40	 mov	 rax, QWORD PTR datalen$[rsp]
  001f6	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR in$[rsp], rax
  001fe	7d 13		 jge	 SHORT $LN16@binascii_a@4
  00200	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00208	48 ff c0	 inc	 rax
  0020b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax
$LN16@binascii_a@4:

; 1268 :             }
; 1269 :             else if (data[in] == '=') {

  00213	e9 d0 02 00 00	 jmp	 $LN15@binascii_a@4
$LN21@binascii_a@4:
  00218	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00220	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00228	48 03 c8	 add	 rcx, rax
  0022b	48 8b c1	 mov	 rax, rcx
  0022e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00231	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  00234	75 44		 jne	 SHORT $LN14@binascii_a@4

; 1270 :                 /* broken case from broken python qp */
; 1271 :                 odata[out++] = '=';

  00236	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0023e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00246	48 03 c8	 add	 rcx, rax
  00249	48 8b c1	 mov	 rax, rcx
  0024c	c6 00 3d	 mov	 BYTE PTR [rax], 61	; 0000003dH
  0024f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00257	48 ff c0	 inc	 rax
  0025a	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR out$[rsp], rax

; 1272 :                 in++;

  00262	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0026a	48 ff c0	 inc	 rax
  0026d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 1273 :             }
; 1274 :             else if (((data[in] >= 'A' && data[in] <= 'F') ||

  00275	e9 6e 02 00 00	 jmp	 $LN13@binascii_a@4
$LN14@binascii_a@4:

; 1275 :                       (data[in] >= 'a' && data[in] <= 'f') ||
; 1276 :                       (data[in] >= '0' && data[in] <= '9')) &&
; 1277 :                      ((data[in+1] >= 'A' && data[in+1] <= 'F') ||
; 1278 :                       (data[in+1] >= 'a' && data[in+1] <= 'f') ||
; 1279 :                       (data[in+1] >= '0' && data[in+1] <= '9'))) {

  0027a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00282	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0028a	48 03 c8	 add	 rcx, rax
  0028d	48 8b c1	 mov	 rax, rcx
  00290	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00293	83 f8 41	 cmp	 eax, 65			; 00000041H
  00296	7c 22		 jl	 SHORT $LN10@binascii_a@4
  00298	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  002a0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  002a8	48 03 c8	 add	 rcx, rax
  002ab	48 8b c1	 mov	 rax, rcx
  002ae	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002b1	83 f8 46	 cmp	 eax, 70			; 00000046H
  002b4	0f 8e 80 00 00
	00		 jle	 $LN11@binascii_a@4
$LN10@binascii_a@4:
  002ba	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  002c2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  002ca	48 03 c8	 add	 rcx, rax
  002cd	48 8b c1	 mov	 rax, rcx
  002d0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002d3	83 f8 61	 cmp	 eax, 97			; 00000061H
  002d6	7c 1e		 jl	 SHORT $LN9@binascii_a@4
  002d8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  002e0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  002e8	48 03 c8	 add	 rcx, rax
  002eb	48 8b c1	 mov	 rax, rcx
  002ee	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f1	83 f8 66	 cmp	 eax, 102		; 00000066H
  002f4	7e 44		 jle	 SHORT $LN11@binascii_a@4
$LN9@binascii_a@4:
  002f6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  002fe	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00306	48 03 c8	 add	 rcx, rax
  00309	48 8b c1	 mov	 rax, rcx
  0030c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0030f	83 f8 30	 cmp	 eax, 48			; 00000030H
  00312	0f 8c a4 01 00
	00		 jl	 $LN12@binascii_a@4
  00318	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00320	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00328	48 03 c8	 add	 rcx, rax
  0032b	48 8b c1	 mov	 rax, rcx
  0032e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00331	83 f8 39	 cmp	 eax, 57			; 00000039H
  00334	0f 8f 82 01 00
	00		 jg	 $LN12@binascii_a@4
$LN11@binascii_a@4:
  0033a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00342	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0034a	48 03 c8	 add	 rcx, rax
  0034d	48 8b c1	 mov	 rax, rcx
  00350	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00354	83 f8 41	 cmp	 eax, 65			; 00000041H
  00357	7c 23		 jl	 SHORT $LN7@binascii_a@4
  00359	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00361	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00369	48 03 c8	 add	 rcx, rax
  0036c	48 8b c1	 mov	 rax, rcx
  0036f	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00373	83 f8 46	 cmp	 eax, 70			; 00000046H
  00376	0f 8e 84 00 00
	00		 jle	 $LN8@binascii_a@4
$LN7@binascii_a@4:
  0037c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00384	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0038c	48 03 c8	 add	 rcx, rax
  0038f	48 8b c1	 mov	 rax, rcx
  00392	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00396	83 f8 61	 cmp	 eax, 97			; 00000061H
  00399	7c 1f		 jl	 SHORT $LN6@binascii_a@4
  0039b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  003a3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  003ab	48 03 c8	 add	 rcx, rax
  003ae	48 8b c1	 mov	 rax, rcx
  003b1	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  003b5	83 f8 66	 cmp	 eax, 102		; 00000066H
  003b8	7e 46		 jle	 SHORT $LN8@binascii_a@4
$LN6@binascii_a@4:
  003ba	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  003c2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  003ca	48 03 c8	 add	 rcx, rax
  003cd	48 8b c1	 mov	 rax, rcx
  003d0	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  003d4	83 f8 30	 cmp	 eax, 48			; 00000030H
  003d7	0f 8c df 00 00
	00		 jl	 $LN12@binascii_a@4
  003dd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  003e5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  003ed	48 03 c8	 add	 rcx, rax
  003f0	48 8b c1	 mov	 rax, rcx
  003f3	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  003f7	83 f8 39	 cmp	 eax, 57			; 00000039H
  003fa	0f 8f bc 00 00
	00		 jg	 $LN12@binascii_a@4
$LN8@binascii_a@4:

; 1280 :                 /* hexval */
; 1281 :                 ch = hexval(data[in]) << 4;

  00400	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00408	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00410	48 03 c8	 add	 rcx, rax
  00413	48 8b c1	 mov	 rax, rcx
  00416	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00419	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:table_hex
  00420	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00423	c1 e0 04	 shl	 eax, 4
  00426	88 84 24 c0 00
	00 00		 mov	 BYTE PTR ch$[rsp], al

; 1282 :                 in++;

  0042d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00435	48 ff c0	 inc	 rax
  00438	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 1283 :                 ch |= hexval(data[in]);

  00440	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00448	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00450	48 03 c8	 add	 rcx, rax
  00453	48 8b c1	 mov	 rax, rcx
  00456	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00459	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:table_hex
  00460	0f be 94 24 c0
	00 00 00	 movsx	 edx, BYTE PTR ch$[rsp]
  00468	0b 14 81	 or	 edx, DWORD PTR [rcx+rax*4]
  0046b	8b c2		 mov	 eax, edx
  0046d	88 84 24 c0 00
	00 00		 mov	 BYTE PTR ch$[rsp], al

; 1284 :                 in++;

  00474	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0047c	48 ff c0	 inc	 rax
  0047f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 1285 :                 odata[out++] = ch;

  00487	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0048f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00497	48 03 c8	 add	 rcx, rax
  0049a	48 8b c1	 mov	 rax, rcx
  0049d	0f b6 8c 24 c0
	00 00 00	 movzx	 ecx, BYTE PTR ch$[rsp]
  004a5	88 08		 mov	 BYTE PTR [rax], cl
  004a7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  004af	48 ff c0	 inc	 rax
  004b2	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR out$[rsp], rax

; 1286 :             }
; 1287 :             else {

  004ba	eb 2c		 jmp	 SHORT $LN5@binascii_a@4
$LN12@binascii_a@4:

; 1288 :               odata[out++] = '=';

  004bc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  004c4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  004cc	48 03 c8	 add	 rcx, rax
  004cf	48 8b c1	 mov	 rax, rcx
  004d2	c6 00 3d	 mov	 BYTE PTR [rax], 61	; 0000003dH
  004d5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  004dd	48 ff c0	 inc	 rax
  004e0	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR out$[rsp], rax
$LN5@binascii_a@4:
$LN13@binascii_a@4:
$LN15@binascii_a@4:

; 1289 :             }

  004e8	e9 c0 00 00 00	 jmp	 $LN4@binascii_a@4
$LN23@binascii_a@4:

; 1290 :         }
; 1291 :         else if (header && data[in] == '_') {

  004ed	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR header$[rsp], 0
  004f5	74 5f		 je	 SHORT $LN3@binascii_a@4
  004f7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  004ff	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00507	48 03 c8	 add	 rcx, rax
  0050a	48 8b c1	 mov	 rax, rcx
  0050d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00510	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00513	75 41		 jne	 SHORT $LN3@binascii_a@4

; 1292 :             odata[out++] = ' ';

  00515	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0051d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00525	48 03 c8	 add	 rcx, rax
  00528	48 8b c1	 mov	 rax, rcx
  0052b	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H
  0052e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00536	48 ff c0	 inc	 rax
  00539	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR out$[rsp], rax

; 1293 :             in++;

  00541	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00549	48 ff c0	 inc	 rax
  0054c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 1294 :         }
; 1295 :         else {

  00554	eb 57		 jmp	 SHORT $LN2@binascii_a@4
$LN3@binascii_a@4:

; 1296 :             odata[out] = data[in];

  00556	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0055e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00566	48 03 c8	 add	 rcx, rax
  00569	48 8b c1	 mov	 rax, rcx
  0056c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  00574	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  0057c	48 03 d1	 add	 rdx, rcx
  0057f	48 8b ca	 mov	 rcx, rdx
  00582	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00585	88 08		 mov	 BYTE PTR [rax], cl

; 1297 :             in++;

  00587	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0058f	48 ff c0	 inc	 rax
  00592	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 1298 :             out++;

  0059a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  005a2	48 ff c0	 inc	 rax
  005a5	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR out$[rsp], rax
$LN2@binascii_a@4:
$LN4@binascii_a@4:

; 1299 :         }
; 1300 :     }

  005ad	e9 43 fb ff ff	 jmp	 $LN25@binascii_a@4
$LN24@binascii_a@4:

; 1301 :     if ((rv = PyBytes_FromStringAndSize((char *)odata, out)) == NULL) {

  005b2	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  005ba	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  005c2	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  005c7	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  005cf	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR rv$[rsp], 0
  005d8	75 1b		 jne	 SHORT $LN1@binascii_a@4

; 1302 :         PyBuffer_Release(&pdata);

  005da	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pdata$[rsp]
  005df	e8 00 00 00 00	 call	 PyBuffer_Release

; 1303 :         PyMem_Free(odata);

  005e4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  005ec	e8 00 00 00 00	 call	 PyMem_Free

; 1304 :         return NULL;

  005f1	33 c0		 xor	 eax, eax
  005f3	eb 1f		 jmp	 SHORT $LN28@binascii_a@4
$LN1@binascii_a@4:

; 1305 :     }
; 1306 :     PyBuffer_Release(&pdata);

  005f5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR pdata$[rsp]
  005fa	e8 00 00 00 00	 call	 PyBuffer_Release

; 1307 :     PyMem_Free(odata);

  005ff	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00607	e8 00 00 00 00	 call	 PyMem_Free

; 1308 :     return rv;

  0060c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN28@binascii_a@4:

; 1309 : }

  00614	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0061b	c3		 ret	 0
binascii_a2b_qp ENDP
_TEXT	ENDS
PUBLIC	??_C@_06DEGBAGCP@y?$CK?$HMiii?$AA@		; `string'
EXTRN	__imp_memchr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$binascii_b2a_qp DD imagerel binascii_b2a_qp
	DD	imagerel binascii_b2a_qp+3727
	DD	imagerel $unwind$binascii_b2a_qp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binascii_b2a_qp DD 021601H
	DD	0210116H
xdata	ENDS
;	COMDAT ??_C@_06DEGBAGCP@y?$CK?$HMiii?$AA@
CONST	SEGMENT
??_C@_06DEGBAGCP@y?$CK?$HMiii?$AA@ DB 'y*|iii', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binascii_b2a_qp
_TEXT	SEGMENT
p$ = 64
crlf$ = 72
datalen$ = 80
pdata$ = 96
in$ = 176
linelen$ = 184
rv$ = 192
data$ = 200
odatalen$ = 208
ch$ = 216
quotetabs$ = 220
istext$ = 224
odata$ = 232
out$ = 240
header$ = 248
self$ = 272
args$ = 280
kwargs$ = 288
binascii_b2a_qp PROC					; COMDAT

; 1335 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 1336 :     Py_ssize_t in, out;
; 1337 :     Py_buffer pdata;
; 1338 :     unsigned char *data, *odata;
; 1339 :     Py_ssize_t datalen = 0, odatalen = 0;

  00016	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR datalen$[rsp], 0
  0001f	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR odatalen$[rsp], 0

; 1340 :     PyObject *rv;
; 1341 :     unsigned int linelen = 0;

  0002b	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR linelen$[rsp], 0

; 1342 :     static char *kwlist[] = {"data", "quotetabs", "istext",
; 1343 :                                    "header", NULL};
; 1344 :     int istext = 1;

  00036	c7 84 24 e0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR istext$[rsp], 1

; 1345 :     int quotetabs = 0;

  00041	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR quotetabs$[rsp], 0

; 1346 :     int header = 0;

  0004c	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR header$[rsp], 0

; 1347 :     unsigned char ch;
; 1348 :     int crlf = 0;

  00057	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR crlf$[rsp], 0

; 1349 :     unsigned char *p;
; 1350 : 
; 1351 :     if (!PyArg_ParseTupleAndKeywords(args, kwargs, "y*|iii", kwlist, &pdata,
; 1352 :           &quotetabs, &istext, &header))

  0005f	48 8d 84 24 f8
	00 00 00	 lea	 rax, QWORD PTR header$[rsp]
  00067	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0006c	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR istext$[rsp]
  00074	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00079	48 8d 84 24 dc
	00 00 00	 lea	 rax, QWORD PTR quotetabs$[rsp]
  00081	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00086	48 8d 44 24 60	 lea	 rax, QWORD PTR pdata$[rsp]
  0008b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00090	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??binascii_b2a_qp@@9@9
  00097	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06DEGBAGCP@y?$CK?$HMiii?$AA@
  0009e	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  000a6	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000ae	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000b3	85 c0		 test	 eax, eax
  000b5	75 07		 jne	 SHORT $LN55@binascii_b@4

; 1353 :         return NULL;

  000b7	33 c0		 xor	 eax, eax
  000b9	e9 c9 0d 00 00	 jmp	 $LN56@binascii_b@4
$LN55@binascii_b@4:

; 1354 :     data = pdata.buf;

  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR pdata$[rsp]
  000c3	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR data$[rsp], rax

; 1355 :     datalen = pdata.len;

  000cb	48 8b 44 24 70	 mov	 rax, QWORD PTR pdata$[rsp+16]
  000d0	48 89 44 24 50	 mov	 QWORD PTR datalen$[rsp], rax

; 1356 : 
; 1357 :     /* See if this string is using CRLF line ends */
; 1358 :     /* XXX: this function has the side effect of converting all of
; 1359 :      * the end of lines to be the same depending on this detection
; 1360 :      * here */
; 1361 :     p = (unsigned char *) memchr(data, '\n', datalen);

  000d5	4c 8b 44 24 50	 mov	 r8, QWORD PTR datalen$[rsp]
  000da	ba 0a 00 00 00	 mov	 edx, 10
  000df	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000ed	48 89 44 24 40	 mov	 QWORD PTR p$[rsp], rax

; 1362 :     if ((p != NULL) && (p > data) && (*(p-1) == '\r'))

  000f2	48 83 7c 24 40
	00		 cmp	 QWORD PTR p$[rsp], 0
  000f8	74 25		 je	 SHORT $LN54@binascii_b@4
  000fa	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00102	48 39 44 24 40	 cmp	 QWORD PTR p$[rsp], rax
  00107	76 16		 jbe	 SHORT $LN54@binascii_b@4
  00109	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
  0010e	0f b6 40 ff	 movzx	 eax, BYTE PTR [rax-1]
  00112	83 f8 0d	 cmp	 eax, 13
  00115	75 08		 jne	 SHORT $LN54@binascii_b@4

; 1363 :         crlf = 1;

  00117	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR crlf$[rsp], 1
$LN54@binascii_b@4:

; 1364 : 
; 1365 :     /* First, scan to see how many characters need to be encoded */
; 1366 :     in = 0;

  0011f	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR in$[rsp], 0
$LN53@binascii_b@4:

; 1367 :     while (in < datalen) {

  0012b	48 8b 44 24 50	 mov	 rax, QWORD PTR datalen$[rsp]
  00130	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR in$[rsp], rax
  00138	0f 8d fd 04 00
	00		 jge	 $LN52@binascii_b@4

; 1368 :         if ((data[in] > 126) ||
; 1369 :             (data[in] == '=') ||
; 1370 :             (header && data[in] == '_') ||
; 1371 :             ((data[in] == '.') && (linelen == 0) &&
; 1372 :              (data[in+1] == '\n' || data[in+1] == '\r' || data[in+1] == 0)) ||
; 1373 :             (!istext && ((data[in] == '\r') || (data[in] == '\n'))) ||
; 1374 :             ((data[in] == '\t' || data[in] == ' ') && (in + 1 == datalen)) ||
; 1375 :             ((data[in] < 33) &&
; 1376 :              (data[in] != '\r') && (data[in] != '\n') &&
; 1377 :              (quotetabs || ((data[in] != '\t') && (data[in] != ' ')))))

  0013e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00146	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0014e	48 03 c8	 add	 rcx, rax
  00151	48 8b c1	 mov	 rax, rcx
  00154	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00157	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  0015a	0f 8f 32 02 00
	00		 jg	 $LN50@binascii_b@4
  00160	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00168	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00170	48 03 c8	 add	 rcx, rax
  00173	48 8b c1	 mov	 rax, rcx
  00176	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00179	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  0017c	0f 84 10 02 00
	00		 je	 $LN50@binascii_b@4
  00182	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR header$[rsp], 0
  0018a	74 22		 je	 SHORT $LN49@binascii_b@4
  0018c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00194	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0019c	48 03 c8	 add	 rcx, rax
  0019f	48 8b c1	 mov	 rax, rcx
  001a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a5	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  001a8	0f 84 e4 01 00
	00		 je	 $LN50@binascii_b@4
$LN49@binascii_b@4:
  001ae	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  001b6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  001be	48 03 c8	 add	 rcx, rax
  001c1	48 8b c1	 mov	 rax, rcx
  001c4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001c7	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001ca	75 72		 jne	 SHORT $LN48@binascii_b@4
  001cc	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR linelen$[rsp], 0
  001d4	75 68		 jne	 SHORT $LN48@binascii_b@4
  001d6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  001de	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  001e6	48 03 c8	 add	 rcx, rax
  001e9	48 8b c1	 mov	 rax, rcx
  001ec	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001f0	83 f8 0a	 cmp	 eax, 10
  001f3	0f 84 99 01 00
	00		 je	 $LN50@binascii_b@4
  001f9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00201	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00209	48 03 c8	 add	 rcx, rax
  0020c	48 8b c1	 mov	 rax, rcx
  0020f	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00213	83 f8 0d	 cmp	 eax, 13
  00216	0f 84 76 01 00
	00		 je	 $LN50@binascii_b@4
  0021c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00224	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0022c	48 03 c8	 add	 rcx, rax
  0022f	48 8b c1	 mov	 rax, rcx
  00232	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00236	85 c0		 test	 eax, eax
  00238	0f 84 54 01 00
	00		 je	 $LN50@binascii_b@4
$LN48@binascii_b@4:
  0023e	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR istext$[rsp], 0
  00246	75 44		 jne	 SHORT $LN47@binascii_b@4
  00248	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00250	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00258	48 03 c8	 add	 rcx, rax
  0025b	48 8b c1	 mov	 rax, rcx
  0025e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00261	83 f8 0d	 cmp	 eax, 13
  00264	0f 84 28 01 00
	00		 je	 $LN50@binascii_b@4
  0026a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00272	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0027a	48 03 c8	 add	 rcx, rax
  0027d	48 8b c1	 mov	 rax, rcx
  00280	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00283	83 f8 0a	 cmp	 eax, 10
  00286	0f 84 06 01 00
	00		 je	 $LN50@binascii_b@4
$LN47@binascii_b@4:
  0028c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00294	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0029c	48 03 c8	 add	 rcx, rax
  0029f	48 8b c1	 mov	 rax, rcx
  002a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002a5	83 f8 09	 cmp	 eax, 9
  002a8	74 1e		 je	 SHORT $LN45@binascii_b@4
  002aa	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  002b2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  002ba	48 03 c8	 add	 rcx, rax
  002bd	48 8b c1	 mov	 rax, rcx
  002c0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002c3	83 f8 20	 cmp	 eax, 32			; 00000020H
  002c6	75 16		 jne	 SHORT $LN46@binascii_b@4
$LN45@binascii_b@4:
  002c8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  002d0	48 ff c0	 inc	 rax
  002d3	48 3b 44 24 50	 cmp	 rax, QWORD PTR datalen$[rsp]
  002d8	0f 84 b4 00 00
	00		 je	 $LN50@binascii_b@4
$LN46@binascii_b@4:
  002de	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  002e6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  002ee	48 03 c8	 add	 rcx, rax
  002f1	48 8b c1	 mov	 rax, rcx
  002f4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f7	83 f8 21	 cmp	 eax, 33			; 00000021H
  002fa	0f 8d 1a 01 00
	00		 jge	 $LN51@binascii_b@4
  00300	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00308	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00310	48 03 c8	 add	 rcx, rax
  00313	48 8b c1	 mov	 rax, rcx
  00316	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00319	83 f8 0d	 cmp	 eax, 13
  0031c	0f 84 f8 00 00
	00		 je	 $LN51@binascii_b@4
  00322	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0032a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00332	48 03 c8	 add	 rcx, rax
  00335	48 8b c1	 mov	 rax, rcx
  00338	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0033b	83 f8 0a	 cmp	 eax, 10
  0033e	0f 84 d6 00 00
	00		 je	 $LN51@binascii_b@4
  00344	83 bc 24 dc 00
	00 00 00	 cmp	 DWORD PTR quotetabs$[rsp], 0
  0034c	75 44		 jne	 SHORT $LN44@binascii_b@4
  0034e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00356	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0035e	48 03 c8	 add	 rcx, rax
  00361	48 8b c1	 mov	 rax, rcx
  00364	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00367	83 f8 09	 cmp	 eax, 9
  0036a	0f 84 aa 00 00
	00		 je	 $LN51@binascii_b@4
  00370	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00378	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00380	48 03 c8	 add	 rcx, rax
  00383	48 8b c1	 mov	 rax, rcx
  00386	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00389	83 f8 20	 cmp	 eax, 32			; 00000020H
  0038c	0f 84 88 00 00
	00		 je	 $LN51@binascii_b@4
$LN44@binascii_b@4:
$LN50@binascii_b@4:

; 1378 :         {
; 1379 :             if ((linelen + 3) >= MAXLINESIZE) {

  00392	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR linelen$[rsp]
  00399	83 c0 03	 add	 eax, 3
  0039c	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  0039f	72 3c		 jb	 SHORT $LN43@binascii_b@4

; 1380 :                 linelen = 0;

  003a1	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR linelen$[rsp], 0

; 1381 :                 if (crlf)

  003ac	83 7c 24 48 00	 cmp	 DWORD PTR crlf$[rsp], 0
  003b1	74 16		 je	 SHORT $LN42@binascii_b@4

; 1382 :                     odatalen += 3;

  003b3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR odatalen$[rsp]
  003bb	48 83 c0 03	 add	 rax, 3
  003bf	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR odatalen$[rsp], rax

; 1383 :                 else

  003c7	eb 14		 jmp	 SHORT $LN41@binascii_b@4
$LN42@binascii_b@4:

; 1384 :                     odatalen += 2;

  003c9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR odatalen$[rsp]
  003d1	48 83 c0 02	 add	 rax, 2
  003d5	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR odatalen$[rsp], rax
$LN41@binascii_b@4:
$LN43@binascii_b@4:

; 1385 :             }
; 1386 :             linelen += 3;

  003dd	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR linelen$[rsp]
  003e4	83 c0 03	 add	 eax, 3
  003e7	89 84 24 b8 00
	00 00		 mov	 DWORD PTR linelen$[rsp], eax

; 1387 :             odatalen += 3;

  003ee	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR odatalen$[rsp]
  003f6	48 83 c0 03	 add	 rax, 3
  003fa	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR odatalen$[rsp], rax

; 1388 :             in++;

  00402	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0040a	48 ff c0	 inc	 rax
  0040d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 1389 :         }
; 1390 :         else {

  00415	e9 1c 02 00 00	 jmp	 $LN40@binascii_b@4
$LN51@binascii_b@4:

; 1391 :             if (istext &&
; 1392 :                 ((data[in] == '\n') ||
; 1393 :                  ((in+1 < datalen) && (data[in] == '\r') &&
; 1394 :                  (data[in+1] == '\n'))))

  0041a	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR istext$[rsp], 0
  00422	0f 84 5d 01 00
	00		 je	 $LN39@binascii_b@4
  00428	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00430	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00438	48 03 c8	 add	 rcx, rax
  0043b	48 8b c1	 mov	 rax, rcx
  0043e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00441	83 f8 0a	 cmp	 eax, 10
  00444	74 5b		 je	 SHORT $LN38@binascii_b@4
  00446	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0044e	48 ff c0	 inc	 rax
  00451	48 3b 44 24 50	 cmp	 rax, QWORD PTR datalen$[rsp]
  00456	0f 8d 29 01 00
	00		 jge	 $LN39@binascii_b@4
  0045c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00464	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0046c	48 03 c8	 add	 rcx, rax
  0046f	48 8b c1	 mov	 rax, rcx
  00472	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00475	83 f8 0d	 cmp	 eax, 13
  00478	0f 85 07 01 00
	00		 jne	 $LN39@binascii_b@4
  0047e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00486	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0048e	48 03 c8	 add	 rcx, rax
  00491	48 8b c1	 mov	 rax, rcx
  00494	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00498	83 f8 0a	 cmp	 eax, 10
  0049b	0f 85 e4 00 00
	00		 jne	 $LN39@binascii_b@4
$LN38@binascii_b@4:

; 1395 :             {
; 1396 :                 linelen = 0;

  004a1	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR linelen$[rsp], 0

; 1397 :                 /* Protect against whitespace on end of line */
; 1398 :                 if (in && ((data[in-1] == ' ') || (data[in-1] == '\t')))

  004ac	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR in$[rsp], 0
  004b5	74 52		 je	 SHORT $LN37@binascii_b@4
  004b7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  004bf	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  004c7	48 03 c8	 add	 rcx, rax
  004ca	48 8b c1	 mov	 rax, rcx
  004cd	0f b6 40 ff	 movzx	 eax, BYTE PTR [rax-1]
  004d1	83 f8 20	 cmp	 eax, 32			; 00000020H
  004d4	74 1f		 je	 SHORT $LN36@binascii_b@4
  004d6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  004de	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  004e6	48 03 c8	 add	 rcx, rax
  004e9	48 8b c1	 mov	 rax, rcx
  004ec	0f b6 40 ff	 movzx	 eax, BYTE PTR [rax-1]
  004f0	83 f8 09	 cmp	 eax, 9
  004f3	75 14		 jne	 SHORT $LN37@binascii_b@4
$LN36@binascii_b@4:

; 1399 :                     odatalen += 2;

  004f5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR odatalen$[rsp]
  004fd	48 83 c0 02	 add	 rax, 2
  00501	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR odatalen$[rsp], rax
$LN37@binascii_b@4:

; 1400 :                 if (crlf)

  00509	83 7c 24 48 00	 cmp	 DWORD PTR crlf$[rsp], 0
  0050e	74 16		 je	 SHORT $LN35@binascii_b@4

; 1401 :                     odatalen += 2;

  00510	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR odatalen$[rsp]
  00518	48 83 c0 02	 add	 rax, 2
  0051c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR odatalen$[rsp], rax

; 1402 :                 else

  00524	eb 13		 jmp	 SHORT $LN34@binascii_b@4
$LN35@binascii_b@4:

; 1403 :                     odatalen += 1;

  00526	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR odatalen$[rsp]
  0052e	48 ff c0	 inc	 rax
  00531	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR odatalen$[rsp], rax
$LN34@binascii_b@4:

; 1404 :                 if (data[in] == '\r')

  00539	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00541	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00549	48 03 c8	 add	 rcx, rax
  0054c	48 8b c1	 mov	 rax, rcx
  0054f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00552	83 f8 0d	 cmp	 eax, 13
  00555	75 16		 jne	 SHORT $LN33@binascii_b@4

; 1405 :                     in += 2;

  00557	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0055f	48 83 c0 02	 add	 rax, 2
  00563	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 1406 :                 else

  0056b	eb 13		 jmp	 SHORT $LN32@binascii_b@4
$LN33@binascii_b@4:

; 1407 :                     in++;

  0056d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00575	48 ff c0	 inc	 rax
  00578	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax
$LN32@binascii_b@4:

; 1408 :             }
; 1409 :             else {

  00580	e9 b1 00 00 00	 jmp	 $LN31@binascii_b@4
$LN39@binascii_b@4:

; 1410 :                 if ((in + 1 != datalen) &&
; 1411 :                     (data[in+1] != '\n') &&
; 1412 :                     (linelen + 1) >= MAXLINESIZE) {

  00585	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0058d	48 ff c0	 inc	 rax
  00590	48 3b 44 24 50	 cmp	 rax, QWORD PTR datalen$[rsp]
  00595	74 69		 je	 SHORT $LN30@binascii_b@4
  00597	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0059f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  005a7	48 03 c8	 add	 rcx, rax
  005aa	48 8b c1	 mov	 rax, rcx
  005ad	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  005b1	83 f8 0a	 cmp	 eax, 10
  005b4	74 4a		 je	 SHORT $LN30@binascii_b@4
  005b6	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR linelen$[rsp]
  005bd	ff c0		 inc	 eax
  005bf	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  005c2	72 3c		 jb	 SHORT $LN30@binascii_b@4

; 1413 :                     linelen = 0;

  005c4	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR linelen$[rsp], 0

; 1414 :                     if (crlf)

  005cf	83 7c 24 48 00	 cmp	 DWORD PTR crlf$[rsp], 0
  005d4	74 16		 je	 SHORT $LN29@binascii_b@4

; 1415 :                         odatalen += 3;

  005d6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR odatalen$[rsp]
  005de	48 83 c0 03	 add	 rax, 3
  005e2	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR odatalen$[rsp], rax

; 1416 :                     else

  005ea	eb 14		 jmp	 SHORT $LN28@binascii_b@4
$LN29@binascii_b@4:

; 1417 :                         odatalen += 2;

  005ec	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR odatalen$[rsp]
  005f4	48 83 c0 02	 add	 rax, 2
  005f8	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR odatalen$[rsp], rax
$LN28@binascii_b@4:
$LN30@binascii_b@4:

; 1418 :                 }
; 1419 :                 linelen++;

  00600	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR linelen$[rsp]
  00607	ff c0		 inc	 eax
  00609	89 84 24 b8 00
	00 00		 mov	 DWORD PTR linelen$[rsp], eax

; 1420 :                 odatalen++;

  00610	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR odatalen$[rsp]
  00618	48 ff c0	 inc	 rax
  0061b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR odatalen$[rsp], rax

; 1421 :                 in++;

  00623	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0062b	48 ff c0	 inc	 rax
  0062e	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax
$LN31@binascii_b@4:
$LN40@binascii_b@4:

; 1422 :             }
; 1423 :         }
; 1424 :     }

  00636	e9 f0 fa ff ff	 jmp	 $LN53@binascii_b@4
$LN52@binascii_b@4:

; 1425 : 
; 1426 :     /* We allocate the output same size as input, this is overkill.
; 1427 :      * The previous implementation used calloc() so we'll zero out the
; 1428 :      * memory here too, since PyMem_Malloc() does not guarantee that.
; 1429 :      */
; 1430 :     odata = (unsigned char *) PyMem_Malloc(odatalen);

  0063b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR odatalen$[rsp]
  00643	e8 00 00 00 00	 call	 PyMem_Malloc
  00648	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR odata$[rsp], rax

; 1431 :     if (odata == NULL) {

  00650	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR odata$[rsp], 0
  00659	75 16		 jne	 SHORT $LN27@binascii_b@4

; 1432 :         PyBuffer_Release(&pdata);

  0065b	48 8d 4c 24 60	 lea	 rcx, QWORD PTR pdata$[rsp]
  00660	e8 00 00 00 00	 call	 PyBuffer_Release

; 1433 :         PyErr_NoMemory();

  00665	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1434 :         return NULL;

  0066a	33 c0		 xor	 eax, eax
  0066c	e9 16 08 00 00	 jmp	 $LN56@binascii_b@4
$LN27@binascii_b@4:

; 1435 :     }
; 1436 :     memset(odata, 0, odatalen);

  00671	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR odatalen$[rsp]
  00679	33 d2		 xor	 edx, edx
  0067b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00683	e8 00 00 00 00	 call	 memset

; 1437 : 
; 1438 :     in = out = linelen = 0;

  00688	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR linelen$[rsp], 0
  00693	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR linelen$[rsp]
  0069a	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax
  006a2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  006aa	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax
$LN26@binascii_b@4:

; 1439 :     while (in < datalen) {

  006b2	48 8b 44 24 50	 mov	 rax, QWORD PTR datalen$[rsp]
  006b7	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR in$[rsp], rax
  006bf	0f 8d 60 07 00
	00		 jge	 $LN25@binascii_b@4

; 1440 :         if ((data[in] > 126) ||
; 1441 :             (data[in] == '=') ||
; 1442 :             (header && data[in] == '_') ||
; 1443 :             ((data[in] == '.') && (linelen == 0) &&
; 1444 :              (data[in+1] == '\n' || data[in+1] == '\r' || data[in+1] == 0)) ||
; 1445 :             (!istext && ((data[in] == '\r') || (data[in] == '\n'))) ||
; 1446 :             ((data[in] == '\t' || data[in] == ' ') && (in + 1 == datalen)) ||
; 1447 :             ((data[in] < 33) &&
; 1448 :              (data[in] != '\r') && (data[in] != '\n') &&
; 1449 :              (quotetabs ||
; 1450 :             (!quotetabs && ((data[in] != '\t') && (data[in] != ' '))))))

  006c5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  006cd	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  006d5	48 03 c8	 add	 rcx, rax
  006d8	48 8b c1	 mov	 rax, rcx
  006db	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006de	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  006e1	0f 8f 40 02 00
	00		 jg	 $LN23@binascii_b@4
  006e7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  006ef	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  006f7	48 03 c8	 add	 rcx, rax
  006fa	48 8b c1	 mov	 rax, rcx
  006fd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00700	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  00703	0f 84 1e 02 00
	00		 je	 $LN23@binascii_b@4
  00709	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR header$[rsp], 0
  00711	74 22		 je	 SHORT $LN22@binascii_b@4
  00713	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0071b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00723	48 03 c8	 add	 rcx, rax
  00726	48 8b c1	 mov	 rax, rcx
  00729	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0072c	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  0072f	0f 84 f2 01 00
	00		 je	 $LN23@binascii_b@4
$LN22@binascii_b@4:
  00735	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0073d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00745	48 03 c8	 add	 rcx, rax
  00748	48 8b c1	 mov	 rax, rcx
  0074b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0074e	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00751	75 72		 jne	 SHORT $LN21@binascii_b@4
  00753	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR linelen$[rsp], 0
  0075b	75 68		 jne	 SHORT $LN21@binascii_b@4
  0075d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00765	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0076d	48 03 c8	 add	 rcx, rax
  00770	48 8b c1	 mov	 rax, rcx
  00773	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00777	83 f8 0a	 cmp	 eax, 10
  0077a	0f 84 a7 01 00
	00		 je	 $LN23@binascii_b@4
  00780	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00788	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00790	48 03 c8	 add	 rcx, rax
  00793	48 8b c1	 mov	 rax, rcx
  00796	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0079a	83 f8 0d	 cmp	 eax, 13
  0079d	0f 84 84 01 00
	00		 je	 $LN23@binascii_b@4
  007a3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  007ab	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  007b3	48 03 c8	 add	 rcx, rax
  007b6	48 8b c1	 mov	 rax, rcx
  007b9	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  007bd	85 c0		 test	 eax, eax
  007bf	0f 84 62 01 00
	00		 je	 $LN23@binascii_b@4
$LN21@binascii_b@4:
  007c5	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR istext$[rsp], 0
  007cd	75 44		 jne	 SHORT $LN20@binascii_b@4
  007cf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  007d7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  007df	48 03 c8	 add	 rcx, rax
  007e2	48 8b c1	 mov	 rax, rcx
  007e5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007e8	83 f8 0d	 cmp	 eax, 13
  007eb	0f 84 36 01 00
	00		 je	 $LN23@binascii_b@4
  007f1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  007f9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00801	48 03 c8	 add	 rcx, rax
  00804	48 8b c1	 mov	 rax, rcx
  00807	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0080a	83 f8 0a	 cmp	 eax, 10
  0080d	0f 84 14 01 00
	00		 je	 $LN23@binascii_b@4
$LN20@binascii_b@4:
  00813	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0081b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00823	48 03 c8	 add	 rcx, rax
  00826	48 8b c1	 mov	 rax, rcx
  00829	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0082c	83 f8 09	 cmp	 eax, 9
  0082f	74 1e		 je	 SHORT $LN18@binascii_b@4
  00831	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00839	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00841	48 03 c8	 add	 rcx, rax
  00844	48 8b c1	 mov	 rax, rcx
  00847	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0084a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0084d	75 16		 jne	 SHORT $LN19@binascii_b@4
$LN18@binascii_b@4:
  0084f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00857	48 ff c0	 inc	 rax
  0085a	48 3b 44 24 50	 cmp	 rax, QWORD PTR datalen$[rsp]
  0085f	0f 84 c2 00 00
	00		 je	 $LN23@binascii_b@4
$LN19@binascii_b@4:
  00865	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0086d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00875	48 03 c8	 add	 rcx, rax
  00878	48 8b c1	 mov	 rax, rcx
  0087b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0087e	83 f8 21	 cmp	 eax, 33			; 00000021H
  00881	0f 8d e9 01 00
	00		 jge	 $LN24@binascii_b@4
  00887	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0088f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00897	48 03 c8	 add	 rcx, rax
  0089a	48 8b c1	 mov	 rax, rcx
  0089d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  008a0	83 f8 0d	 cmp	 eax, 13
  008a3	0f 84 c7 01 00
	00		 je	 $LN24@binascii_b@4
  008a9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  008b1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  008b9	48 03 c8	 add	 rcx, rax
  008bc	48 8b c1	 mov	 rax, rcx
  008bf	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  008c2	83 f8 0a	 cmp	 eax, 10
  008c5	0f 84 a5 01 00
	00		 je	 $LN24@binascii_b@4
  008cb	83 bc 24 dc 00
	00 00 00	 cmp	 DWORD PTR quotetabs$[rsp], 0
  008d3	75 52		 jne	 SHORT $LN17@binascii_b@4
  008d5	83 bc 24 dc 00
	00 00 00	 cmp	 DWORD PTR quotetabs$[rsp], 0
  008dd	0f 85 8d 01 00
	00		 jne	 $LN24@binascii_b@4
  008e3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  008eb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  008f3	48 03 c8	 add	 rcx, rax
  008f6	48 8b c1	 mov	 rax, rcx
  008f9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  008fc	83 f8 09	 cmp	 eax, 9
  008ff	0f 84 6b 01 00
	00		 je	 $LN24@binascii_b@4
  00905	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  0090d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00915	48 03 c8	 add	 rcx, rax
  00918	48 8b c1	 mov	 rax, rcx
  0091b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0091e	83 f8 20	 cmp	 eax, 32			; 00000020H
  00921	0f 84 49 01 00
	00		 je	 $LN24@binascii_b@4
$LN17@binascii_b@4:
$LN23@binascii_b@4:

; 1451 :         {
; 1452 :             if ((linelen + 3 )>= MAXLINESIZE) {

  00927	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR linelen$[rsp]
  0092e	83 c0 03	 add	 eax, 3
  00931	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  00934	0f 82 96 00 00
	00		 jb	 $LN16@binascii_b@4

; 1453 :                 odata[out++] = '=';

  0093a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00942	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  0094a	48 03 c8	 add	 rcx, rax
  0094d	48 8b c1	 mov	 rax, rcx
  00950	c6 00 3d	 mov	 BYTE PTR [rax], 61	; 0000003dH
  00953	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0095b	48 ff c0	 inc	 rax
  0095e	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax

; 1454 :                 if (crlf) odata[out++] = '\r';

  00966	83 7c 24 48 00	 cmp	 DWORD PTR crlf$[rsp], 0
  0096b	74 2c		 je	 SHORT $LN15@binascii_b@4
  0096d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00975	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  0097d	48 03 c8	 add	 rcx, rax
  00980	48 8b c1	 mov	 rax, rcx
  00983	c6 00 0d	 mov	 BYTE PTR [rax], 13
  00986	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0098e	48 ff c0	 inc	 rax
  00991	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax
$LN15@binascii_b@4:

; 1455 :                 odata[out++] = '\n';

  00999	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  009a1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  009a9	48 03 c8	 add	 rcx, rax
  009ac	48 8b c1	 mov	 rax, rcx
  009af	c6 00 0a	 mov	 BYTE PTR [rax], 10
  009b2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  009ba	48 ff c0	 inc	 rax
  009bd	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax

; 1456 :                 linelen = 0;

  009c5	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR linelen$[rsp], 0
$LN16@binascii_b@4:

; 1457 :             }
; 1458 :             odata[out++] = '=';

  009d0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  009d8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  009e0	48 03 c8	 add	 rcx, rax
  009e3	48 8b c1	 mov	 rax, rcx
  009e6	c6 00 3d	 mov	 BYTE PTR [rax], 61	; 0000003dH
  009e9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  009f1	48 ff c0	 inc	 rax
  009f4	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax

; 1459 :             to_hex(data[in], &odata[out]);

  009fc	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00a04	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00a0c	48 03 c8	 add	 rcx, rax
  00a0f	48 8b c1	 mov	 rax, rcx
  00a12	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  00a1a	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  00a22	48 03 d1	 add	 rdx, rcx
  00a25	48 8b ca	 mov	 rcx, rdx
  00a28	48 8b d0	 mov	 rdx, rax
  00a2b	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00a2e	e8 00 00 00 00	 call	 to_hex

; 1460 :             out += 2;

  00a33	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00a3b	48 83 c0 02	 add	 rax, 2
  00a3f	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax

; 1461 :             in++;

  00a47	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00a4f	48 ff c0	 inc	 rax
  00a52	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 1462 :             linelen += 3;

  00a5a	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR linelen$[rsp]
  00a61	83 c0 03	 add	 eax, 3
  00a64	89 84 24 b8 00
	00 00		 mov	 DWORD PTR linelen$[rsp], eax

; 1463 :         }
; 1464 :         else {

  00a6b	e9 b0 03 00 00	 jmp	 $LN14@binascii_b@4
$LN24@binascii_b@4:

; 1465 :             if (istext &&
; 1466 :                 ((data[in] == '\n') ||
; 1467 :                  ((in+1 < datalen) && (data[in] == '\r') &&
; 1468 :                  (data[in+1] == '\n'))))

  00a70	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR istext$[rsp], 0
  00a78	0f 84 f1 01 00
	00		 je	 $LN13@binascii_b@4
  00a7e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00a86	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00a8e	48 03 c8	 add	 rcx, rax
  00a91	48 8b c1	 mov	 rax, rcx
  00a94	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a97	83 f8 0a	 cmp	 eax, 10
  00a9a	74 5b		 je	 SHORT $LN12@binascii_b@4
  00a9c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00aa4	48 ff c0	 inc	 rax
  00aa7	48 3b 44 24 50	 cmp	 rax, QWORD PTR datalen$[rsp]
  00aac	0f 8d bd 01 00
	00		 jge	 $LN13@binascii_b@4
  00ab2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00aba	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00ac2	48 03 c8	 add	 rcx, rax
  00ac5	48 8b c1	 mov	 rax, rcx
  00ac8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00acb	83 f8 0d	 cmp	 eax, 13
  00ace	0f 85 9b 01 00
	00		 jne	 $LN13@binascii_b@4
  00ad4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00adc	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00ae4	48 03 c8	 add	 rcx, rax
  00ae7	48 8b c1	 mov	 rax, rcx
  00aea	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00aee	83 f8 0a	 cmp	 eax, 10
  00af1	0f 85 78 01 00
	00		 jne	 $LN13@binascii_b@4
$LN12@binascii_b@4:

; 1469 :             {
; 1470 :                 linelen = 0;

  00af7	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR linelen$[rsp], 0

; 1471 :                 /* Protect against whitespace on end of line */
; 1472 :                 if (out && ((odata[out-1] == ' ') || (odata[out-1] == '\t'))) {

  00b02	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR out$[rsp], 0
  00b0b	0f 84 b3 00 00
	00		 je	 $LN11@binascii_b@4
  00b11	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00b19	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00b21	48 03 c8	 add	 rcx, rax
  00b24	48 8b c1	 mov	 rax, rcx
  00b27	0f b6 40 ff	 movzx	 eax, BYTE PTR [rax-1]
  00b2b	83 f8 20	 cmp	 eax, 32			; 00000020H
  00b2e	74 1f		 je	 SHORT $LN10@binascii_b@4
  00b30	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00b38	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00b40	48 03 c8	 add	 rcx, rax
  00b43	48 8b c1	 mov	 rax, rcx
  00b46	0f b6 40 ff	 movzx	 eax, BYTE PTR [rax-1]
  00b4a	83 f8 09	 cmp	 eax, 9
  00b4d	75 75		 jne	 SHORT $LN11@binascii_b@4
$LN10@binascii_b@4:

; 1473 :                     ch = odata[out-1];

  00b4f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00b57	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00b5f	48 03 c8	 add	 rcx, rax
  00b62	48 8b c1	 mov	 rax, rcx
  00b65	0f b6 40 ff	 movzx	 eax, BYTE PTR [rax-1]
  00b69	88 84 24 d8 00
	00 00		 mov	 BYTE PTR ch$[rsp], al

; 1474 :                     odata[out-1] = '=';

  00b70	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00b78	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00b80	48 03 c8	 add	 rcx, rax
  00b83	48 8b c1	 mov	 rax, rcx
  00b86	c6 40 ff 3d	 mov	 BYTE PTR [rax-1], 61	; 0000003dH

; 1475 :                     to_hex(ch, &odata[out]);

  00b8a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00b92	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00b9a	48 03 c8	 add	 rcx, rax
  00b9d	48 8b c1	 mov	 rax, rcx
  00ba0	48 8b d0	 mov	 rdx, rax
  00ba3	0f b6 8c 24 d8
	00 00 00	 movzx	 ecx, BYTE PTR ch$[rsp]
  00bab	e8 00 00 00 00	 call	 to_hex

; 1476 :                     out += 2;

  00bb0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00bb8	48 83 c0 02	 add	 rax, 2
  00bbc	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax
$LN11@binascii_b@4:

; 1477 :                 }
; 1478 : 
; 1479 :                 if (crlf) odata[out++] = '\r';

  00bc4	83 7c 24 48 00	 cmp	 DWORD PTR crlf$[rsp], 0
  00bc9	74 2c		 je	 SHORT $LN9@binascii_b@4
  00bcb	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00bd3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00bdb	48 03 c8	 add	 rcx, rax
  00bde	48 8b c1	 mov	 rax, rcx
  00be1	c6 00 0d	 mov	 BYTE PTR [rax], 13
  00be4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00bec	48 ff c0	 inc	 rax
  00bef	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax
$LN9@binascii_b@4:

; 1480 :                 odata[out++] = '\n';

  00bf7	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00bff	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00c07	48 03 c8	 add	 rcx, rax
  00c0a	48 8b c1	 mov	 rax, rcx
  00c0d	c6 00 0a	 mov	 BYTE PTR [rax], 10
  00c10	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00c18	48 ff c0	 inc	 rax
  00c1b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax

; 1481 :                 if (data[in] == '\r')

  00c23	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00c2b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00c33	48 03 c8	 add	 rcx, rax
  00c36	48 8b c1	 mov	 rax, rcx
  00c39	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c3c	83 f8 0d	 cmp	 eax, 13
  00c3f	75 16		 jne	 SHORT $LN8@binascii_b@4

; 1482 :                     in += 2;

  00c41	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00c49	48 83 c0 02	 add	 rax, 2
  00c4d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 1483 :                 else

  00c55	eb 13		 jmp	 SHORT $LN7@binascii_b@4
$LN8@binascii_b@4:

; 1484 :                     in++;

  00c57	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00c5f	48 ff c0	 inc	 rax
  00c62	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax
$LN7@binascii_b@4:

; 1485 :             }
; 1486 :             else {

  00c6a	e9 b1 01 00 00	 jmp	 $LN6@binascii_b@4
$LN13@binascii_b@4:

; 1487 :                 if ((in + 1 != datalen) &&
; 1488 :                     (data[in+1] != '\n') &&
; 1489 :                     (linelen + 1) >= MAXLINESIZE) {

  00c6f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00c77	48 ff c0	 inc	 rax
  00c7a	48 3b 44 24 50	 cmp	 rax, QWORD PTR datalen$[rsp]
  00c7f	0f 84 cb 00 00
	00		 je	 $LN5@binascii_b@4
  00c85	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00c8d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00c95	48 03 c8	 add	 rcx, rax
  00c98	48 8b c1	 mov	 rax, rcx
  00c9b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00c9f	83 f8 0a	 cmp	 eax, 10
  00ca2	0f 84 a8 00 00
	00		 je	 $LN5@binascii_b@4
  00ca8	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR linelen$[rsp]
  00caf	ff c0		 inc	 eax
  00cb1	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  00cb4	0f 82 96 00 00
	00		 jb	 $LN5@binascii_b@4

; 1490 :                     odata[out++] = '=';

  00cba	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00cc2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00cca	48 03 c8	 add	 rcx, rax
  00ccd	48 8b c1	 mov	 rax, rcx
  00cd0	c6 00 3d	 mov	 BYTE PTR [rax], 61	; 0000003dH
  00cd3	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00cdb	48 ff c0	 inc	 rax
  00cde	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax

; 1491 :                     if (crlf) odata[out++] = '\r';

  00ce6	83 7c 24 48 00	 cmp	 DWORD PTR crlf$[rsp], 0
  00ceb	74 2c		 je	 SHORT $LN4@binascii_b@4
  00ced	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00cf5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00cfd	48 03 c8	 add	 rcx, rax
  00d00	48 8b c1	 mov	 rax, rcx
  00d03	c6 00 0d	 mov	 BYTE PTR [rax], 13
  00d06	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00d0e	48 ff c0	 inc	 rax
  00d11	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax
$LN4@binascii_b@4:

; 1492 :                     odata[out++] = '\n';

  00d19	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00d21	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00d29	48 03 c8	 add	 rcx, rax
  00d2c	48 8b c1	 mov	 rax, rcx
  00d2f	c6 00 0a	 mov	 BYTE PTR [rax], 10
  00d32	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00d3a	48 ff c0	 inc	 rax
  00d3d	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax

; 1493 :                     linelen = 0;

  00d45	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR linelen$[rsp], 0
$LN5@binascii_b@4:

; 1494 :                 }
; 1495 :                 linelen++;

  00d50	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR linelen$[rsp]
  00d57	ff c0		 inc	 eax
  00d59	89 84 24 b8 00
	00 00		 mov	 DWORD PTR linelen$[rsp], eax

; 1496 :                 if (header && data[in] == ' ') {

  00d60	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR header$[rsp], 0
  00d68	74 5f		 je	 SHORT $LN3@binascii_b@4
  00d6a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00d72	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00d7a	48 03 c8	 add	 rcx, rax
  00d7d	48 8b c1	 mov	 rax, rcx
  00d80	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00d83	83 f8 20	 cmp	 eax, 32			; 00000020H
  00d86	75 41		 jne	 SHORT $LN3@binascii_b@4

; 1497 :                     odata[out++] = '_';

  00d88	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00d90	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00d98	48 03 c8	 add	 rcx, rax
  00d9b	48 8b c1	 mov	 rax, rcx
  00d9e	c6 00 5f	 mov	 BYTE PTR [rax], 95	; 0000005fH
  00da1	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00da9	48 ff c0	 inc	 rax
  00dac	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax

; 1498 :                     in++;

  00db4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00dbc	48 ff c0	 inc	 rax
  00dbf	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax

; 1499 :                 }
; 1500 :                 else {

  00dc7	eb 57		 jmp	 SHORT $LN2@binascii_b@4
$LN3@binascii_b@4:

; 1501 :                     odata[out++] = data[in++];

  00dc9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00dd1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00dd9	48 03 c8	 add	 rcx, rax
  00ddc	48 8b c1	 mov	 rax, rcx
  00ddf	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in$[rsp]
  00de7	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  00def	48 03 d1	 add	 rdx, rcx
  00df2	48 8b ca	 mov	 rcx, rdx
  00df5	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00df8	88 08		 mov	 BYTE PTR [rax], cl
  00dfa	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00e02	48 ff c0	 inc	 rax
  00e05	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR out$[rsp], rax
  00e0d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR in$[rsp]
  00e15	48 ff c0	 inc	 rax
  00e18	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR in$[rsp], rax
$LN2@binascii_b@4:
$LN6@binascii_b@4:
$LN14@binascii_b@4:

; 1502 :                 }
; 1503 :             }
; 1504 :         }
; 1505 :     }

  00e20	e9 8d f8 ff ff	 jmp	 $LN26@binascii_b@4
$LN25@binascii_b@4:

; 1506 :     if ((rv = PyBytes_FromStringAndSize((char *)odata, out)) == NULL) {

  00e25	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00e2d	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00e35	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  00e3a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR rv$[rsp], rax
  00e42	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR rv$[rsp], 0
  00e4b	75 1b		 jne	 SHORT $LN1@binascii_b@4

; 1507 :         PyBuffer_Release(&pdata);

  00e4d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR pdata$[rsp]
  00e52	e8 00 00 00 00	 call	 PyBuffer_Release

; 1508 :         PyMem_Free(odata);

  00e57	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00e5f	e8 00 00 00 00	 call	 PyMem_Free

; 1509 :         return NULL;

  00e64	33 c0		 xor	 eax, eax
  00e66	eb 1f		 jmp	 SHORT $LN56@binascii_b@4
$LN1@binascii_b@4:

; 1510 :     }
; 1511 :     PyBuffer_Release(&pdata);

  00e68	48 8d 4c 24 60	 lea	 rcx, QWORD PTR pdata$[rsp]
  00e6d	e8 00 00 00 00	 call	 PyBuffer_Release

; 1512 :     PyMem_Free(odata);

  00e72	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR odata$[rsp]
  00e7a	e8 00 00 00 00	 call	 PyMem_Free

; 1513 :     return rv;

  00e7f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR rv$[rsp]
$LN56@binascii_b@4:

; 1514 : }

  00e87	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00e8e	c3		 ret	 0
binascii_b2a_qp ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$to_hex DD imagerel to_hex
	DD	imagerel to_hex+112
	DD	imagerel $unwind$to_hex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$to_hex DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT ??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@
CONST	SEGMENT
??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@ DB '0123456789ABCDEF', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT to_hex
_TEXT	SEGMENT
uvalue$ = 0
ch$ = 32
s$ = 40
to_hex	PROC						; COMDAT

; 1313 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 18	 sub	 rsp, 24

; 1314 :     unsigned int uvalue = ch;

  0000d	0f b6 44 24 20	 movzx	 eax, BYTE PTR ch$[rsp]
  00012	89 04 24	 mov	 DWORD PTR uvalue$[rsp], eax

; 1315 : 
; 1316 :     s[1] = "0123456789ABCDEF"[uvalue % 16];

  00015	33 d2		 xor	 edx, edx
  00017	8b 04 24	 mov	 eax, DWORD PTR uvalue$[rsp]
  0001a	b9 10 00 00 00	 mov	 ecx, 16
  0001f	f7 f1		 div	 ecx
  00021	8b c2		 mov	 eax, edx
  00023	8b c0		 mov	 eax, eax
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@
  0002c	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	88 42 01	 mov	 BYTE PTR [rdx+1], al

; 1317 :     uvalue = (uvalue / 16);

  00038	33 d2		 xor	 edx, edx
  0003a	8b 04 24	 mov	 eax, DWORD PTR uvalue$[rsp]
  0003d	b9 10 00 00 00	 mov	 ecx, 16
  00042	f7 f1		 div	 ecx
  00044	89 04 24	 mov	 DWORD PTR uvalue$[rsp], eax

; 1318 :     s[0] = "0123456789ABCDEF"[uvalue % 16];

  00047	33 d2		 xor	 edx, edx
  00049	8b 04 24	 mov	 eax, DWORD PTR uvalue$[rsp]
  0004c	b9 10 00 00 00	 mov	 ecx, 16
  00051	f7 f1		 div	 ecx
  00053	8b c2		 mov	 eax, edx
  00055	8b c0		 mov	 eax, eax
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@
  0005e	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  00063	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00067	88 02		 mov	 BYTE PTR [rdx], al

; 1319 :     return 0;

  00069	33 c0		 xor	 eax, eax

; 1320 : }

  0006b	48 83 c4 18	 add	 rsp, 24
  0006f	c3		 ret	 0
to_hex	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@GAHNLADL@Incomplete?$AA@		; `string'
PUBLIC	??_C@_0BE@KBIPNNPG@binascii?4Incomplete?$AA@	; `string'
PUBLIC	??_C@_05NAOIJFC@Error?$AA@			; `string'
PUBLIC	??_C@_0P@BJDIBMKL@binascii?4Error?$AA@		; `string'
PUBLIC	PyInit_binascii
EXTRN	PyErr_Occurred:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyErr_NewException:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_binascii DD imagerel $LN5
	DD	imagerel $LN5+196
	DD	imagerel $unwind$PyInit_binascii
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_binascii DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0L@GAHNLADL@Incomplete?$AA@
CONST	SEGMENT
??_C@_0L@GAHNLADL@Incomplete?$AA@ DB 'Incomplete', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KBIPNNPG@binascii?4Incomplete?$AA@
CONST	SEGMENT
??_C@_0BE@KBIPNNPG@binascii?4Incomplete?$AA@ DB 'binascii.Incomplete', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05NAOIJFC@Error?$AA@
CONST	SEGMENT
??_C@_05NAOIJFC@Error?$AA@ DB 'Error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@BJDIBMKL@binascii?4Error?$AA@
CONST	SEGMENT
??_C@_0P@BJDIBMKL@binascii?4Error?$AA@ DB 'binascii.Error', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit_binascii
_TEXT	SEGMENT
d$ = 32
m$ = 40
PyInit_binascii PROC					; COMDAT

; 1560 : {

$LN5:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1561 :     PyObject *m, *d;
; 1562 : 
; 1563 :     /* Create the module and add the functions */
; 1564 :     m = PyModule_Create(&binasciimodule);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:binasciimodule
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00015	48 89 44 24 28	 mov	 QWORD PTR m$[rsp], rax

; 1565 :     if (m == NULL)

  0001a	48 83 7c 24 28
	00		 cmp	 QWORD PTR m$[rsp], 0
  00020	75 07		 jne	 SHORT $LN2@PyInit_bin

; 1566 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 96 00 00 00	 jmp	 $LN3@PyInit_bin
$LN2@PyInit_bin:

; 1567 : 
; 1568 :     d = PyModule_GetDict(m);

  00029	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  0002e	e8 00 00 00 00	 call	 PyModule_GetDict
  00033	48 89 44 24 20	 mov	 QWORD PTR d$[rsp], rax

; 1569 : 
; 1570 :     Error = PyErr_NewException("binascii.Error", PyExc_ValueError, NULL);

  00038	45 33 c0	 xor	 r8d, r8d
  0003b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_ValueError
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@BJDIBMKL@binascii?4Error?$AA@
  00049	e8 00 00 00 00	 call	 PyErr_NewException
  0004e	48 89 05 00 00
	00 00		 mov	 QWORD PTR Error, rax

; 1571 :     PyDict_SetItemString(d, "Error", Error);

  00055	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR Error
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05NAOIJFC@Error?$AA@
  00063	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00068	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1572 :     Incomplete = PyErr_NewException("binascii.Incomplete", NULL, NULL);

  0006d	45 33 c0	 xor	 r8d, r8d
  00070	33 d2		 xor	 edx, edx
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@KBIPNNPG@binascii?4Incomplete?$AA@
  00079	e8 00 00 00 00	 call	 PyErr_NewException
  0007e	48 89 05 00 00
	00 00		 mov	 QWORD PTR Incomplete, rax

; 1573 :     PyDict_SetItemString(d, "Incomplete", Incomplete);

  00085	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR Incomplete
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@GAHNLADL@Incomplete?$AA@
  00093	48 8b 4c 24 20	 mov	 rcx, QWORD PTR d$[rsp]
  00098	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1574 :     if (PyErr_Occurred()) {

  0009d	e8 00 00 00 00	 call	 PyErr_Occurred
  000a2	48 85 c0	 test	 rax, rax
  000a5	74 13		 je	 SHORT $LN1@PyInit_bin

; 1575 :         Py_DECREF(m);

  000a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  000ac	e8 00 00 00 00	 call	 _Py_DecRef

; 1576 :         m = NULL;

  000b1	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR m$[rsp], 0
$LN1@PyInit_bin:

; 1577 :     }
; 1578 :     return m;

  000ba	48 8b 44 24 28	 mov	 rax, QWORD PTR m$[rsp]
$LN3@PyInit_bin:

; 1579 : }

  000bf	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c3	c3		 ret	 0
PyInit_binascii ENDP
_TEXT	ENDS
END
