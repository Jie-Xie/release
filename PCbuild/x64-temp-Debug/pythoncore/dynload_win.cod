; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06GLBEDIBG@_d?4pyd?$AA@			; `string'
PUBLIC	_PyImport_DynLoadFiletab
_DATA	SEGMENT
_PyImport_DynLoadFiletab DQ FLAT:??_C@_06GLBEDIBG@_d?4pyd?$AA@
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_06GLBEDIBG@_d?4pyd?$AA@
CONST	SEGMENT
??_C@_06GLBEDIBG@_d?4pyd?$AA@ DB '_d.pyd', 00H		; `string'
CONST	ENDS
PUBLIC	??_C@_0DM@LKDKPELF@Module?5use?5of?5?$CF?4150s?5conflicts?5w@ ; `string'
PUBLIC	??_C@_0BB@DMDFDOKF@python?$CFd?$CFd_d?4dll?$AA@	; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0BC@HIMEBECO@DLL?5load?5failed?3?5?$AA@	; `string'
PUBLIC	??_C@_0CD@DECNJACN@DLL?5load?5failed?5with?5error?5code?5@ ; `string'
PUBLIC	??_C@_0O@DMGNPJAA@PyInit_?$CF?4200s?$AA@	; `string'
PUBLIC	_PyImport_GetDynLoadWindows
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_FreeLibrary:PROC
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_ImportError:QWORD
EXTRN	PyErr_SetImportError:PROC
EXTRN	PyUnicode_AppendAndDel:PROC
EXTRN	PyUnicode_FromWideChar:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	__imp_FormatMessageW:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_LoadLibraryExW:PROC
EXTRN	__imp_SetErrorMode:PROC
EXTRN	PyOS_snprintf:PROC
EXTRN	PyUnicode_AsUnicode:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\dynload_win.c
pdata	SEGMENT
$pdata$_PyImport_GetDynLoadWindows DD imagerel $LN15
	DD	imagerel $LN15+725
	DD	imagerel $unwind$_PyImport_GetDynLoadWindows
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyImport_GetDynLoadWindows DD 021601H
	DD	0950116H
xdata	ENDS
;	COMDAT ??_C@_0DM@LKDKPELF@Module?5use?5of?5?$CF?4150s?5conflicts?5w@
CONST	SEGMENT
??_C@_0DM@LKDKPELF@Module?5use?5of?5?$CF?4150s?5conflicts?5w@ DB 'Module '
	DB	'use of %.150s conflicts with this version of Python.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DMDFDOKF@python?$CFd?$CFd_d?4dll?$AA@
CONST	SEGMENT
??_C@_0BB@DMDFDOKF@python?$CFd?$CFd_d?4dll?$AA@ DB 'python%d%d_d.dll', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HIMEBECO@DLL?5load?5failed?3?5?$AA@
CONST	SEGMENT
??_C@_0BC@HIMEBECO@DLL?5load?5failed?3?5?$AA@ DB 'DLL load failed: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DECNJACN@DLL?5load?5failed?5with?5error?5code?5@
CONST	SEGMENT
??_C@_0CD@DECNJACN@DLL?5load?5failed?5with?5error?5code?5@ DB 'DLL load f'
	DB	'ailed with error code %d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DMGNPJAA@PyInit_?$CF?4200s?$AA@
CONST	SEGMENT
??_C@_0O@DMGNPJAA@PyInit_?$CF?4200s?$AA@ DB 'PyInit_%.200s', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyImport_GetDynLoadWindows
_TEXT	SEGMENT
p$ = 64
wpathname$ = 72
import_python$ = 80
funcname$ = 96
old_mode$120555 = 368
hDLL$120553 = 376
theInfo$120561 = 384
theLength$120562 = 896
errorCode$120560 = 900
message$120559 = 904
shortname_obj$120575 = 912
buffer$120584 = 928
shortname$ = 1200
pathname$ = 1208
fp$ = 1216
_PyImport_GetDynLoadWindows PROC			; COMDAT

; 178  : {

$LN15:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 04
	00 00		 sub	 rsp, 1192		; 000004a8H

; 179  :     dl_funcptr p;
; 180  :     char funcname[258], *import_python;
; 181  :     wchar_t *wpathname;
; 182  : 
; 183  : #ifndef _DEBUG
; 184  :     _Py_CheckPython3();
; 185  : #endif
; 186  : 
; 187  :     wpathname = PyUnicode_AsUnicode(pathname);

  00016	48 8b 8c 24 b8
	04 00 00	 mov	 rcx, QWORD PTR pathname$[rsp]
  0001e	e8 00 00 00 00	 call	 PyUnicode_AsUnicode
  00023	48 89 44 24 48	 mov	 QWORD PTR wpathname$[rsp], rax

; 188  :     if (wpathname == NULL)

  00028	48 83 7c 24 48
	00		 cmp	 QWORD PTR wpathname$[rsp], 0
  0002e	75 07		 jne	 SHORT $LN12@PyImport_G

; 189  :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	e9 96 02 00 00	 jmp	 $LN13@PyImport_G
$LN12@PyImport_G:

; 190  : 
; 191  :     PyOS_snprintf(funcname, sizeof(funcname), "PyInit_%.200s", shortname);

  00037	4c 8b 8c 24 b0
	04 00 00	 mov	 r9, QWORD PTR shortname$[rsp]
  0003f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@DMGNPJAA@PyInit_?$CF?4200s?$AA@
  00046	ba 02 01 00 00	 mov	 edx, 258		; 00000102H
  0004b	48 8d 4c 24 60	 lea	 rcx, QWORD PTR funcname$[rsp]
  00050	e8 00 00 00 00	 call	 PyOS_snprintf

; 192  : 
; 193  :     {
; 194  :         HINSTANCE hDLL = NULL;

  00055	48 c7 84 24 78
	01 00 00 00 00
	00 00		 mov	 QWORD PTR hDLL$120553[rsp], 0

; 195  :         unsigned int old_mode;
; 196  : #if HAVE_SXS
; 197  :         ULONG_PTR cookie = 0;
; 198  : #endif
; 199  : 
; 200  :         /* Don't display a message box when Python can't load a DLL */
; 201  :         old_mode = SetErrorMode(SEM_FAILCRITICALERRORS);

  00061	b9 01 00 00 00	 mov	 ecx, 1
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetErrorMode
  0006c	89 84 24 70 01
	00 00		 mov	 DWORD PTR old_mode$120555[rsp], eax

; 202  : 
; 203  : #if HAVE_SXS
; 204  :         cookie = _Py_ActivateActCtx();
; 205  : #endif
; 206  :         /* We use LoadLibraryEx so Windows looks for dependent DLLs
; 207  :             in directory of pathname first. */
; 208  :         /* XXX This call doesn't exist in Windows CE */
; 209  :         hDLL = LoadLibraryExW(wpathname, NULL,
; 210  :                               LOAD_WITH_ALTERED_SEARCH_PATH);

  00073	41 b8 08 00 00
	00		 mov	 r8d, 8
  00079	33 d2		 xor	 edx, edx
  0007b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR wpathname$[rsp]
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryExW
  00086	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR hDLL$120553[rsp], rax

; 211  : #if HAVE_SXS
; 212  :         _Py_DeactivateActCtx(cookie);
; 213  : #endif
; 214  : 
; 215  :         /* restore old error mode settings */
; 216  :         SetErrorMode(old_mode);

  0008e	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR old_mode$120555[rsp]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetErrorMode

; 217  : 
; 218  :         if (hDLL==NULL){

  0009b	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR hDLL$120553[rsp], 0
  000a4	0f 85 85 01 00
	00		 jne	 $LN11@PyImport_G

; 219  :             PyObject *message;
; 220  :             unsigned int errorCode;
; 221  : 
; 222  :             /* Get an error string from Win32 error code */
; 223  :             wchar_t theInfo[256]; /* Pointer to error text
; 224  :                                   from system */
; 225  :             int theLength; /* Length of error text */
; 226  : 
; 227  :             errorCode = GetLastError();

  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  000b0	89 84 24 84 03
	00 00		 mov	 DWORD PTR errorCode$120560[rsp], eax

; 228  : 
; 229  :             theLength = FormatMessageW(
; 230  :                 FORMAT_MESSAGE_FROM_SYSTEM |
; 231  :                 FORMAT_MESSAGE_IGNORE_INSERTS, /* flags */
; 232  :                 NULL, /* message source */
; 233  :                 errorCode, /* the message (error) ID */
; 234  :                 MAKELANGID(LANG_NEUTRAL,
; 235  :                            SUBLANG_DEFAULT),
; 236  :                            /* Default language */
; 237  :                 theInfo, /* the buffer */
; 238  :                 sizeof(theInfo) / sizeof(wchar_t), /* size in wchars */
; 239  :                 NULL); /* no additional format args. */

  000b7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000c0	c7 44 24 28 00
	01 00 00	 mov	 DWORD PTR [rsp+40], 256	; 00000100H
  000c8	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR theInfo$120561[rsp]
  000d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d5	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  000db	44 8b 84 24 84
	03 00 00	 mov	 r8d, DWORD PTR errorCode$120560[rsp]
  000e3	33 d2		 xor	 edx, edx
  000e5	b9 00 12 00 00	 mov	 ecx, 4608		; 00001200H
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageW
  000f0	89 84 24 80 03
	00 00		 mov	 DWORD PTR theLength$120562[rsp], eax

; 240  : 
; 241  :             /* Problem: could not get the error message.
; 242  :                This should not happen if called correctly. */
; 243  :             if (theLength == 0) {

  000f7	83 bc 24 80 03
	00 00 00	 cmp	 DWORD PTR theLength$120562[rsp], 0
  000ff	75 20		 jne	 SHORT $LN10@PyImport_G

; 244  :                 message = PyUnicode_FromFormat(
; 245  :                     "DLL load failed with error code %d",
; 246  :                     errorCode);

  00101	8b 94 24 84 03
	00 00		 mov	 edx, DWORD PTR errorCode$120560[rsp]
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@DECNJACN@DLL?5load?5failed?5with?5error?5code?5@
  0010f	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00114	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR message$120559[rsp], rax

; 247  :             } else {

  0011c	e9 9a 00 00 00	 jmp	 $LN9@PyImport_G
$LN10@PyImport_G:

; 248  :                 /* For some reason a \r\n
; 249  :                    is appended to the text */
; 250  :                 if (theLength >= 2 &&
; 251  :                     theInfo[theLength-2] == '\r' &&
; 252  :                     theInfo[theLength-1] == '\n') {

  00121	83 bc 24 80 03
	00 00 02	 cmp	 DWORD PTR theLength$120562[rsp], 2
  00129	7c 54		 jl	 SHORT $LN8@PyImport_G
  0012b	8b 84 24 80 03
	00 00		 mov	 eax, DWORD PTR theLength$120562[rsp]
  00132	83 e8 02	 sub	 eax, 2
  00135	48 98		 cdqe
  00137	0f b7 84 44 80
	01 00 00	 movzx	 eax, WORD PTR theInfo$120561[rsp+rax*2]
  0013f	83 f8 0d	 cmp	 eax, 13
  00142	75 3b		 jne	 SHORT $LN8@PyImport_G
  00144	8b 84 24 80 03
	00 00		 mov	 eax, DWORD PTR theLength$120562[rsp]
  0014b	ff c8		 dec	 eax
  0014d	48 98		 cdqe
  0014f	0f b7 84 44 80
	01 00 00	 movzx	 eax, WORD PTR theInfo$120561[rsp+rax*2]
  00157	83 f8 0a	 cmp	 eax, 10
  0015a	75 23		 jne	 SHORT $LN8@PyImport_G

; 253  :                     theLength -= 2;

  0015c	8b 84 24 80 03
	00 00		 mov	 eax, DWORD PTR theLength$120562[rsp]
  00163	83 e8 02	 sub	 eax, 2
  00166	89 84 24 80 03
	00 00		 mov	 DWORD PTR theLength$120562[rsp], eax

; 254  :                     theInfo[theLength] = '\0';

  0016d	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR theLength$120562[rsp]
  00175	33 c9		 xor	 ecx, ecx
  00177	66 89 8c 44 80
	01 00 00	 mov	 WORD PTR theInfo$120561[rsp+rax*2], cx
$LN8@PyImport_G:

; 255  :                 }
; 256  :                 message = PyUnicode_FromString(
; 257  :                     "DLL load failed: ");

  0017f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@HIMEBECO@DLL?5load?5failed?3?5?$AA@
  00186	e8 00 00 00 00	 call	 PyUnicode_FromString
  0018b	48 89 84 24 88
	03 00 00	 mov	 QWORD PTR message$120559[rsp], rax

; 258  : 
; 259  :                 PyUnicode_AppendAndDel(&message,
; 260  :                     PyUnicode_FromWideChar(
; 261  :                         theInfo,
; 262  :                         theLength));

  00193	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR theLength$120562[rsp]
  0019b	48 8b d0	 mov	 rdx, rax
  0019e	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR theInfo$120561[rsp]
  001a6	e8 00 00 00 00	 call	 PyUnicode_FromWideChar
  001ab	48 8b d0	 mov	 rdx, rax
  001ae	48 8d 8c 24 88
	03 00 00	 lea	 rcx, QWORD PTR message$120559[rsp]
  001b6	e8 00 00 00 00	 call	 PyUnicode_AppendAndDel
$LN9@PyImport_G:

; 263  :             }
; 264  :             if (message != NULL) {

  001bb	48 83 bc 24 88
	03 00 00 00	 cmp	 QWORD PTR message$120559[rsp], 0
  001c4	74 5d		 je	 SHORT $LN7@PyImport_G

; 265  :                 PyObject *shortname_obj = PyUnicode_FromString(shortname);

  001c6	48 8b 8c 24 b0
	04 00 00	 mov	 rcx, QWORD PTR shortname$[rsp]
  001ce	e8 00 00 00 00	 call	 PyUnicode_FromString
  001d3	48 89 84 24 90
	03 00 00	 mov	 QWORD PTR shortname_obj$120575[rsp], rax

; 266  :                 PyErr_SetImportError(message, shortname_obj, pathname);

  001db	4c 8b 84 24 b8
	04 00 00	 mov	 r8, QWORD PTR pathname$[rsp]
  001e3	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR shortname_obj$120575[rsp]
  001eb	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR message$120559[rsp]
  001f3	e8 00 00 00 00	 call	 PyErr_SetImportError
$LN6@PyImport_G:

; 267  :                 Py_XDECREF(shortname_obj);

  001f8	48 83 bc 24 90
	03 00 00 00	 cmp	 QWORD PTR shortname_obj$120575[rsp], 0
  00201	74 0d		 je	 SHORT $LN3@PyImport_G
  00203	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR shortname_obj$120575[rsp]
  0020b	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyImport_G:
  00210	33 c0		 xor	 eax, eax
  00212	85 c0		 test	 eax, eax
  00214	75 e2		 jne	 SHORT $LN6@PyImport_G

; 268  :                 Py_DECREF(message);

  00216	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR message$120559[rsp]
  0021e	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@PyImport_G:

; 269  :             }
; 270  :             return NULL;

  00223	33 c0		 xor	 eax, eax
  00225	e9 a3 00 00 00	 jmp	 $LN13@PyImport_G

; 271  :         } else {

  0022a	e9 81 00 00 00	 jmp	 $LN2@PyImport_G
$LN11@PyImport_G:

; 272  :             char buffer[256];
; 273  : 
; 274  :             PyOS_snprintf(buffer, sizeof(buffer),
; 275  : #ifdef _DEBUG
; 276  :                           "python%d%d_d.dll",
; 277  : #else
; 278  :                           "python%d%d.dll",
; 279  : #endif
; 280  :                           PY_MAJOR_VERSION,PY_MINOR_VERSION);

  0022f	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  00237	41 b9 03 00 00
	00		 mov	 r9d, 3
  0023d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@DMDFDOKF@python?$CFd?$CFd_d?4dll?$AA@
  00244	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00249	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR buffer$120584[rsp]
  00251	e8 00 00 00 00	 call	 PyOS_snprintf

; 281  :             import_python = GetPythonImport(hDLL);

  00256	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR hDLL$120553[rsp]
  0025e	e8 00 00 00 00	 call	 GetPythonImport
  00263	48 89 44 24 50	 mov	 QWORD PTR import_python$[rsp], rax

; 282  : 
; 283  :             if (import_python &&
; 284  :                 strcasecmp(buffer,import_python)) {

  00268	48 83 7c 24 50
	00		 cmp	 QWORD PTR import_python$[rsp], 0
  0026e	74 40		 je	 SHORT $LN1@PyImport_G
  00270	48 8b 54 24 50	 mov	 rdx, QWORD PTR import_python$[rsp]
  00275	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR buffer$120584[rsp]
  0027d	e8 00 00 00 00	 call	 strcasecmp
  00282	85 c0		 test	 eax, eax
  00284	74 2a		 je	 SHORT $LN1@PyImport_G

; 285  :                 PyErr_Format(PyExc_ImportError,
; 286  :                              "Module use of %.150s conflicts "
; 287  :                              "with this version of Python.",
; 288  :                              import_python);

  00286	4c 8b 44 24 50	 mov	 r8, QWORD PTR import_python$[rsp]
  0028b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DM@LKDKPELF@Module?5use?5of?5?$CF?4150s?5conflicts?5w@
  00292	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  00299	e8 00 00 00 00	 call	 PyErr_Format

; 289  :                 FreeLibrary(hDLL);

  0029e	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR hDLL$120553[rsp]
  002a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FreeLibrary

; 290  :                 return NULL;

  002ac	33 c0		 xor	 eax, eax
  002ae	eb 1d		 jmp	 SHORT $LN13@PyImport_G
$LN1@PyImport_G:
$LN2@PyImport_G:

; 291  :             }
; 292  :         }
; 293  :         p = GetProcAddress(hDLL, funcname);

  002b0	48 8d 54 24 60	 lea	 rdx, QWORD PTR funcname$[rsp]
  002b5	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR hDLL$120553[rsp]
  002bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  002c3	48 89 44 24 40	 mov	 QWORD PTR p$[rsp], rax

; 294  :     }
; 295  : 
; 296  :     return p;

  002c8	48 8b 44 24 40	 mov	 rax, QWORD PTR p$[rsp]
$LN13@PyImport_G:

; 297  : }

  002cd	48 81 c4 a8 04
	00 00		 add	 rsp, 1192		; 000004a8H
  002d4	c3		 ret	 0
_PyImport_GetDynLoadWindows ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	__imp_tolower:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\dynload_win.c
pdata	SEGMENT
$pdata$strcasecmp DD imagerel strcasecmp
	DD	imagerel strcasecmp+114
	DD	imagerel $unwind$strcasecmp
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$strcasecmp DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT strcasecmp
_TEXT	SEGMENT
first$ = 32
second$ = 36
string1$ = 64
string2$ = 72
strcasecmp PROC						; COMDAT

; 34   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@strcasecmp:

; 35   :     int first, second;
; 36   : 
; 37   :     do {
; 38   :         first  = tolower(*string1);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR string1$[rsp]
  00013	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00016	8b c8		 mov	 ecx, eax
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower
  0001e	89 44 24 20	 mov	 DWORD PTR first$[rsp], eax

; 39   :         second = tolower(*string2);

  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR string2$[rsp]
  00027	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002a	8b c8		 mov	 ecx, eax
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower
  00032	89 44 24 24	 mov	 DWORD PTR second$[rsp], eax

; 40   :         string1++;

  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR string1$[rsp]
  0003b	48 ff c0	 inc	 rax
  0003e	48 89 44 24 40	 mov	 QWORD PTR string1$[rsp], rax

; 41   :         string2++;

  00043	48 8b 44 24 48	 mov	 rax, QWORD PTR string2$[rsp]
  00048	48 ff c0	 inc	 rax
  0004b	48 89 44 24 48	 mov	 QWORD PTR string2$[rsp], rax

; 42   :     } while (first && first == second);

  00050	83 7c 24 20 00	 cmp	 DWORD PTR first$[rsp], 0
  00055	74 0a		 je	 SHORT $LN1@strcasecmp
  00057	8b 44 24 24	 mov	 eax, DWORD PTR second$[rsp]
  0005b	39 44 24 20	 cmp	 DWORD PTR first$[rsp], eax
  0005f	74 ad		 je	 SHORT $LN4@strcasecmp
$LN1@strcasecmp:

; 43   : 
; 44   :     return (first - second);

  00061	8b 44 24 24	 mov	 eax, DWORD PTR second$[rsp]
  00065	8b 4c 24 20	 mov	 ecx, DWORD PTR first$[rsp]
  00069	2b c8		 sub	 ecx, eax
  0006b	8b c1		 mov	 eax, ecx

; 45   : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
strcasecmp ENDP
_TEXT	ENDS
PUBLIC	??_C@_06OIODPPHE@python?$AA@			; `string'
PUBLIC	??_C@_04KNAEGPCG@PE?$AA?$AA?$AA@		; `string'
EXTRN	__imp_strncmp:PROC
EXTRN	strlen:PROC
EXTRN	memcmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetPythonImport DD imagerel GetPythonImport
	DD	imagerel GetPythonImport+544
	DD	imagerel $unwind$GetPythonImport
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetPythonImport DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_06OIODPPHE@python?$AA@
CONST	SEGMENT
??_C@_06OIODPPHE@python?$AA@ DB 'python', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04KNAEGPCG@PE?$AA?$AA?$AA@
CONST	SEGMENT
??_C@_04KNAEGPCG@PE?$AA?$AA?$AA@ DB 'PE', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT GetPythonImport
_TEXT	SEGMENT
import_name$ = 32
opt_magic$ = 40
import_data$ = 48
opt_offset$ = 56
pe_offset$ = 60
dllbase$ = 64
import_off$ = 72
num_dict_off$ = 76
pch$120528 = 80
hModule$ = 112
GetPythonImport PROC					; COMDAT

; 70   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 71   :     unsigned char *dllbase, *import_data, *import_name;
; 72   :     DWORD pe_offset, opt_offset;
; 73   :     WORD opt_magic;
; 74   :     int num_dict_off, import_off;
; 75   : 
; 76   :     /* Safety check input */
; 77   :     if (hModule == NULL) {

  00009	48 83 7c 24 70
	00		 cmp	 QWORD PTR hModule$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN16@GetPythonI

; 78   :         return NULL;

  00011	33 c0		 xor	 eax, eax
  00013	e9 03 02 00 00	 jmp	 $LN17@GetPythonI
$LN16@GetPythonI:

; 79   :     }
; 80   : 
; 81   :     /* Module instance is also the base load address.  First portion of
; 82   :        memory is the MS-DOS loader, which holds the offset to the PE
; 83   :        header (from the load base) at 0x3C */
; 84   :     dllbase = (unsigned char *)hModule;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR hModule$[rsp]
  0001d	48 89 44 24 40	 mov	 QWORD PTR dllbase$[rsp], rax

; 85   :     pe_offset = DWORD_AT(dllbase + 0x3C);

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR dllbase$[rsp]
  00027	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0002a	89 44 24 3c	 mov	 DWORD PTR pe_offset$[rsp], eax

; 86   : 
; 87   :     /* The PE signature must be "PE\0\0" */
; 88   :     if (memcmp(dllbase+pe_offset,"PE\0\0",4)) {

  0002e	8b 44 24 3c	 mov	 eax, DWORD PTR pe_offset$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dllbase$[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	41 b8 04 00 00
	00		 mov	 r8d, 4
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04KNAEGPCG@PE?$AA?$AA?$AA@
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 memcmp
  00052	85 c0		 test	 eax, eax
  00054	74 07		 je	 SHORT $LN15@GetPythonI

; 89   :         return NULL;

  00056	33 c0		 xor	 eax, eax
  00058	e9 be 01 00 00	 jmp	 $LN17@GetPythonI
$LN15@GetPythonI:

; 90   :     }
; 91   : 
; 92   :     /* Following the PE signature is the standard COFF header (20
; 93   :        bytes) and then the optional header.  The optional header starts
; 94   :        with a magic value of 0x10B for PE32 or 0x20B for PE32+ (PE32+
; 95   :        uses 64-bits for some fields).  It might also be 0x107 for a ROM
; 96   :        image, but we don't process that here.
; 97   : 
; 98   :        The optional header ends with a data dictionary that directly
; 99   :        points to certain types of data, among them the import entries
; 100  :        (in the second table entry). Based on the header type, we
; 101  :        determine offsets for the data dictionary count and the entry
; 102  :        within the dictionary pointing to the imports. */
; 103  : 
; 104  :     opt_offset = pe_offset + 4 + 20;

  0005d	8b 44 24 3c	 mov	 eax, DWORD PTR pe_offset$[rsp]
  00061	83 c0 18	 add	 eax, 24
  00064	89 44 24 38	 mov	 DWORD PTR opt_offset$[rsp], eax

; 105  :     opt_magic = WORD_AT(dllbase+opt_offset);

  00068	8b 44 24 38	 mov	 eax, DWORD PTR opt_offset$[rsp]
  0006c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dllbase$[rsp]
  00071	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00075	66 89 44 24 28	 mov	 WORD PTR opt_magic$[rsp], ax

; 106  :     if (opt_magic == 0x10B) {

  0007a	0f b7 44 24 28	 movzx	 eax, WORD PTR opt_magic$[rsp]
  0007f	3d 0b 01 00 00	 cmp	 eax, 267		; 0000010bH
  00084	75 12		 jne	 SHORT $LN14@GetPythonI

; 107  :         /* PE32 */
; 108  :         num_dict_off = 92;

  00086	c7 44 24 4c 5c
	00 00 00	 mov	 DWORD PTR num_dict_off$[rsp], 92 ; 0000005cH

; 109  :         import_off   = 104;

  0008e	c7 44 24 48 68
	00 00 00	 mov	 DWORD PTR import_off$[rsp], 104 ; 00000068H
  00096	eb 25		 jmp	 SHORT $LN13@GetPythonI
$LN14@GetPythonI:

; 110  :     } else if (opt_magic == 0x20B) {

  00098	0f b7 44 24 28	 movzx	 eax, WORD PTR opt_magic$[rsp]
  0009d	3d 0b 02 00 00	 cmp	 eax, 523		; 0000020bH
  000a2	75 12		 jne	 SHORT $LN12@GetPythonI

; 111  :         /* PE32+ */
; 112  :         num_dict_off = 108;

  000a4	c7 44 24 4c 6c
	00 00 00	 mov	 DWORD PTR num_dict_off$[rsp], 108 ; 0000006cH

; 113  :         import_off   = 120;

  000ac	c7 44 24 48 78
	00 00 00	 mov	 DWORD PTR import_off$[rsp], 120 ; 00000078H

; 114  :     } else {

  000b4	eb 07		 jmp	 SHORT $LN11@GetPythonI
$LN12@GetPythonI:

; 115  :         /* Unsupported */
; 116  :         return NULL;

  000b6	33 c0		 xor	 eax, eax
  000b8	e9 5e 01 00 00	 jmp	 $LN17@GetPythonI
$LN11@GetPythonI:
$LN13@GetPythonI:

; 117  :     }
; 118  : 
; 119  :     /* Now if an import table exists, offset to it and walk the list of
; 120  :        imports.  The import table is an array (ending when an entry has
; 121  :        empty values) of structures (20 bytes each), which contains (at
; 122  :        offset 12) a relative address (to the module base) at which a
; 123  :        string constant holding the import name is located. */
; 124  : 
; 125  :     if (DWORD_AT(dllbase + opt_offset + num_dict_off) >= 2) {

  000bd	8b 44 24 38	 mov	 eax, DWORD PTR opt_offset$[rsp]
  000c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dllbase$[rsp]
  000c6	48 03 c8	 add	 rcx, rax
  000c9	48 8b c1	 mov	 rax, rcx
  000cc	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR num_dict_off$[rsp]
  000d1	83 3c 08 02	 cmp	 DWORD PTR [rax+rcx], 2
  000d5	0f 82 3e 01 00
	00		 jb	 $LN10@GetPythonI

; 126  :         /* We have at least 2 tables - the import table is the second
; 127  :            one.  But still it may be that the table size is zero */
; 128  :         if (0 == DWORD_AT(dllbase + opt_offset + import_off + sizeof(DWORD)))

  000db	8b 44 24 38	 mov	 eax, DWORD PTR opt_offset$[rsp]
  000df	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dllbase$[rsp]
  000e4	48 03 c8	 add	 rcx, rax
  000e7	48 8b c1	 mov	 rax, rcx
  000ea	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR import_off$[rsp]
  000ef	83 7c 08 04 00	 cmp	 DWORD PTR [rax+rcx+4], 0
  000f4	75 07		 jne	 SHORT $LN9@GetPythonI

; 129  :             return NULL;

  000f6	33 c0		 xor	 eax, eax
  000f8	e9 1e 01 00 00	 jmp	 $LN17@GetPythonI
$LN9@GetPythonI:

; 130  :         import_data = dllbase + DWORD_AT(dllbase +
; 131  :                                          opt_offset +
; 132  :                                          import_off);

  000fd	8b 44 24 38	 mov	 eax, DWORD PTR opt_offset$[rsp]
  00101	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dllbase$[rsp]
  00106	48 03 c8	 add	 rcx, rax
  00109	48 8b c1	 mov	 rax, rcx
  0010c	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR import_off$[rsp]
  00111	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00114	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dllbase$[rsp]
  00119	48 03 c8	 add	 rcx, rax
  0011c	48 8b c1	 mov	 rax, rcx
  0011f	48 89 44 24 30	 mov	 QWORD PTR import_data$[rsp], rax
$LN8@GetPythonI:

; 133  :         while (DWORD_AT(import_data)) {

  00124	48 8b 44 24 30	 mov	 rax, QWORD PTR import_data$[rsp]
  00129	83 38 00	 cmp	 DWORD PTR [rax], 0
  0012c	0f 84 e7 00 00
	00		 je	 $LN7@GetPythonI

; 134  :             import_name = dllbase + DWORD_AT(import_data+12);

  00132	48 8b 44 24 30	 mov	 rax, QWORD PTR import_data$[rsp]
  00137	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0013a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dllbase$[rsp]
  0013f	48 03 c8	 add	 rcx, rax
  00142	48 8b c1	 mov	 rax, rcx
  00145	48 89 44 24 20	 mov	 QWORD PTR import_name$[rsp], rax

; 135  :             if (strlen(import_name) >= 6 &&
; 136  :                 !strncmp(import_name,"python",6)) {

  0014a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR import_name$[rsp]
  0014f	e8 00 00 00 00	 call	 strlen
  00154	48 83 f8 06	 cmp	 rax, 6
  00158	0f 82 a8 00 00
	00		 jb	 $LN6@GetPythonI
  0015e	41 b8 06 00 00
	00		 mov	 r8d, 6
  00164	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06OIODPPHE@python?$AA@
  0016b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR import_name$[rsp]
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00176	85 c0		 test	 eax, eax
  00178	0f 85 88 00 00
	00		 jne	 $LN6@GetPythonI

; 137  :                 char *pch;
; 138  : 
; 139  : #ifndef _DEBUG
; 140  :                 /* In a release version, don't claim that python3.dll is
; 141  :                    a Python DLL. */
; 142  :                 if (strcmp(import_name, "python3.dll") == 0) {
; 143  :                     import_data += 20;
; 144  :                     continue;
; 145  :                 }
; 146  : #endif
; 147  : 
; 148  :                 /* Ensure python prefix is followed only
; 149  :                    by numbers to the end of the basename */
; 150  :                 pch = import_name + 6;

  0017e	48 8b 44 24 20	 mov	 rax, QWORD PTR import_name$[rsp]
  00183	48 83 c0 06	 add	 rax, 6
  00187	48 89 44 24 50	 mov	 QWORD PTR pch$120528[rsp], rax
$LN5@GetPythonI:

; 151  : #ifdef _DEBUG
; 152  :                 while (*pch && pch[0] != '_' && pch[1] != 'd' && pch[2] != '.') {

  0018c	48 8b 44 24 50	 mov	 rax, QWORD PTR pch$120528[rsp]
  00191	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00194	85 c0		 test	 eax, eax
  00196	74 5f		 je	 SHORT $LN4@GetPythonI
  00198	48 8b 44 24 50	 mov	 rax, QWORD PTR pch$120528[rsp]
  0019d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001a0	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  001a3	74 52		 je	 SHORT $LN4@GetPythonI
  001a5	48 8b 44 24 50	 mov	 rax, QWORD PTR pch$120528[rsp]
  001aa	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  001ae	83 f8 64	 cmp	 eax, 100		; 00000064H
  001b1	74 44		 je	 SHORT $LN4@GetPythonI
  001b3	48 8b 44 24 50	 mov	 rax, QWORD PTR pch$120528[rsp]
  001b8	0f be 40 02	 movsx	 eax, BYTE PTR [rax+2]
  001bc	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001bf	74 36		 je	 SHORT $LN4@GetPythonI

; 153  : #else
; 154  :                 while (*pch && *pch != '.') {
; 155  : #endif
; 156  :                     if (*pch >= '0' && *pch <= '9') {

  001c1	48 8b 44 24 50	 mov	 rax, QWORD PTR pch$120528[rsp]
  001c6	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001c9	83 f8 30	 cmp	 eax, 48			; 00000030H
  001cc	7c 1c		 jl	 SHORT $LN3@GetPythonI
  001ce	48 8b 44 24 50	 mov	 rax, QWORD PTR pch$120528[rsp]
  001d3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001d6	83 f8 39	 cmp	 eax, 57			; 00000039H
  001d9	7f 0f		 jg	 SHORT $LN3@GetPythonI

; 157  :                         pch++;

  001db	48 8b 44 24 50	 mov	 rax, QWORD PTR pch$120528[rsp]
  001e0	48 ff c0	 inc	 rax
  001e3	48 89 44 24 50	 mov	 QWORD PTR pch$120528[rsp], rax

; 158  :                     } else {

  001e8	eb 0b		 jmp	 SHORT $LN2@GetPythonI
$LN3@GetPythonI:

; 159  :                         pch = NULL;

  001ea	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR pch$120528[rsp], 0

; 160  :                         break;

  001f3	eb 02		 jmp	 SHORT $LN4@GetPythonI
$LN2@GetPythonI:

; 161  :                     }
; 162  :                 }

  001f5	eb 95		 jmp	 SHORT $LN5@GetPythonI
$LN4@GetPythonI:

; 163  : 
; 164  :                 if (pch) {

  001f7	48 83 7c 24 50
	00		 cmp	 QWORD PTR pch$120528[rsp], 0
  001fd	74 07		 je	 SHORT $LN1@GetPythonI

; 165  :                     /* Found it - return the name */
; 166  :                     return import_name;

  001ff	48 8b 44 24 20	 mov	 rax, QWORD PTR import_name$[rsp]
  00204	eb 15		 jmp	 SHORT $LN17@GetPythonI
$LN1@GetPythonI:
$LN6@GetPythonI:

; 167  :                 }
; 168  :             }
; 169  :             import_data += 20;

  00206	48 8b 44 24 30	 mov	 rax, QWORD PTR import_data$[rsp]
  0020b	48 83 c0 14	 add	 rax, 20
  0020f	48 89 44 24 30	 mov	 QWORD PTR import_data$[rsp], rax

; 170  :         }

  00214	e9 0b ff ff ff	 jmp	 $LN8@GetPythonI
$LN7@GetPythonI:
$LN10@GetPythonI:

; 171  :     }
; 172  : 
; 173  :     return NULL;

  00219	33 c0		 xor	 eax, eax
$LN17@GetPythonI:

; 174  : }

  0021b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0021f	c3		 ret	 0
GetPythonImport ENDP
_TEXT	ENDS
END
