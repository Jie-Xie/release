; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0N@FGONANPD@faulthandler?$AA@		; `string'
PUBLIC	??_C@_0DD@JHJFEDEP@_fatal_error?$CImessage?$CJ?3?5call?5Py_F@ ; `string'
PUBLIC	??_C@_0N@CKLIJFLO@_fatal_error?$AA@		; `string'
PUBLIC	??_C@_0CB@GEBDCIHK@_sigill?$CI?$CJ?3?5raise?5a?5SIGILL?5signal@ ; `string'
PUBLIC	??_C@_07BBJFAOD@_sigill?$AA@			; `string'
PUBLIC	??_C@_0CB@IGEJMHBJ@_sigfpe?$CI?$CJ?3?5raise?5a?5SIGFPE?5signal@ ; `string'
PUBLIC	??_C@_07JNIEKBOI@_sigfpe?$AA@			; `string'
PUBLIC	??_C@_0CD@ENHLFCIP@_sigabrt?$CI?$CJ?3?5raise?5a?5SIGABRT?5sign@ ; `string'
PUBLIC	??_C@_08LEEGKEOI@_sigabrt?$AA@			; `string'
PUBLIC	??_C@_0CD@JMELGPAF@_sigsegv?$CI?$CJ?3?5raise?5a?5SIGSEGV?5sign@ ; `string'
PUBLIC	??_C@_08BLGKFLKK@_sigsegv?$AA@			; `string'
PUBLIC	??_C@_0GK@LMJPNIJI@_read_null?$CIrelease_gil?$DNFalse?$CJ?3?5r@ ; `string'
PUBLIC	??_C@_0L@PHHAALCD@_read_null?$AA@		; `string'
PUBLIC	??_C@_0FD@JGJPAFG@cancel_dump_traceback_later?$CI?$CJ?3?6c@ ; `string'
PUBLIC	??_C@_0BM@JNJHDNLB@cancel_dump_traceback_later?$AA@ ; `string'
PUBLIC	??_C@_0NO@BKDMFNGL@dump_traceback_later?$CItimeout?0?5re@ ; `string'
PUBLIC	??_C@_0BF@OCONLHGP@dump_traceback_later?$AA@	; `string'
PUBLIC	??_C@_0JB@NOGGBNCA@dump_traceback?$CIfile?$DNsys?4stderr?0?5@ ; `string'
PUBLIC	??_C@_0P@HLFAMGNN@dump_traceback?$AA@		; `string'
PUBLIC	??_C@_0DE@FEHGNHKL@is_enabled?$CI?$CJ?9?$DObool?3?5check?5if?5the@ ; `string'
PUBLIC	??_C@_0L@FCNBNIPE@is_enabled?$AA@		; `string'
PUBLIC	??_C@_0CF@KKBBMCEK@disable?$CI?$CJ?3?5disable?5the?5fault?5han@ ; `string'
PUBLIC	??_C@_07DBNODEFN@disable?$AA@			; `string'
PUBLIC	??_C@_0EE@EJHGCLAL@enable?$CIfile?$DNsys?4stderr?0?5all_thre@ ; `string'
PUBLIC	??_C@_06OFNJOBDK@enable?$AA@			; `string'
PUBLIC	??_C@_04MKNBDEPB@exit?$AA@			; `string'
PUBLIC	??_C@_06LGDBIFHB@repeat?$AA@			; `string'
PUBLIC	??_C@_07DDHNKDGP@timeout?$AA@			; `string'
PUBLIC	??_C@_0M@EEAOGHOB@all_threads?$AA@		; `string'
PUBLIC	??_C@_04DAMGJPCA@file?$AA@			; `string'
PUBLIC	??_C@_05GLCAEPFP@flush?$AA@			; `string'
PUBLIC	??_C@_06FFBIALPD@fileno?$AA@			; `string'
PUBLIC	??_C@_0BD@IBGMJKIK@Segmentation?5fault?$AA@	; `string'
PUBLIC	??_C@_07LCKDCBKK@Aborted?$AA@			; `string'
PUBLIC	??_C@_0BJ@HEAFBDK@Floating?5point?5exception?$AA@ ; `string'
PUBLIC	??_C@_0BE@MLNNHANJ@Illegal?5instruction?$AA@	; `string'
;	COMDAT ??_C@_0N@FGONANPD@faulthandler?$AA@
CONST	SEGMENT
??_C@_0N@FGONANPD@faulthandler?$AA@ DB 'faulthandler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@JHJFEDEP@_fatal_error?$CImessage?$CJ?3?5call?5Py_F@
CONST	SEGMENT
??_C@_0DD@JHJFEDEP@_fatal_error?$CImessage?$CJ?3?5call?5Py_F@ DB '_fatal_'
	DB	'error(message): call Py_FatalError(message)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CKLIJFLO@_fatal_error?$AA@
CONST	SEGMENT
??_C@_0N@CKLIJFLO@_fatal_error?$AA@ DB '_fatal_error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@GEBDCIHK@_sigill?$CI?$CJ?3?5raise?5a?5SIGILL?5signal@
CONST	SEGMENT
??_C@_0CB@GEBDCIHK@_sigill?$CI?$CJ?3?5raise?5a?5SIGILL?5signal@ DB '_sigi'
	DB	'll(): raise a SIGILL signal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BBJFAOD@_sigill?$AA@
CONST	SEGMENT
??_C@_07BBJFAOD@_sigill?$AA@ DB '_sigill', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@IGEJMHBJ@_sigfpe?$CI?$CJ?3?5raise?5a?5SIGFPE?5signal@
CONST	SEGMENT
??_C@_0CB@IGEJMHBJ@_sigfpe?$CI?$CJ?3?5raise?5a?5SIGFPE?5signal@ DB '_sigf'
	DB	'pe(): raise a SIGFPE signal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07JNIEKBOI@_sigfpe?$AA@
CONST	SEGMENT
??_C@_07JNIEKBOI@_sigfpe?$AA@ DB '_sigfpe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@ENHLFCIP@_sigabrt?$CI?$CJ?3?5raise?5a?5SIGABRT?5sign@
CONST	SEGMENT
??_C@_0CD@ENHLFCIP@_sigabrt?$CI?$CJ?3?5raise?5a?5SIGABRT?5sign@ DB '_siga'
	DB	'brt(): raise a SIGABRT signal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LEEGKEOI@_sigabrt?$AA@
CONST	SEGMENT
??_C@_08LEEGKEOI@_sigabrt?$AA@ DB '_sigabrt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JMELGPAF@_sigsegv?$CI?$CJ?3?5raise?5a?5SIGSEGV?5sign@
CONST	SEGMENT
??_C@_0CD@JMELGPAF@_sigsegv?$CI?$CJ?3?5raise?5a?5SIGSEGV?5sign@ DB '_sigs'
	DB	'egv(): raise a SIGSEGV signal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08BLGKFLKK@_sigsegv?$AA@
CONST	SEGMENT
??_C@_08BLGKFLKK@_sigsegv?$AA@ DB '_sigsegv', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@LMJPNIJI@_read_null?$CIrelease_gil?$DNFalse?$CJ?3?5r@
CONST	SEGMENT
??_C@_0GK@LMJPNIJI@_read_null?$CIrelease_gil?$DNFalse?$CJ?3?5r@ DB '_read'
	DB	'_null(release_gil=False): read from NULL, raise a SIGSEGV or '
	DB	'SIGBUS signal depending on the platform', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PHHAALCD@_read_null?$AA@
CONST	SEGMENT
??_C@_0L@PHHAALCD@_read_null?$AA@ DB '_read_null', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@JGJPAFG@cancel_dump_traceback_later?$CI?$CJ?3?6c@
CONST	SEGMENT
??_C@_0FD@JGJPAFG@cancel_dump_traceback_later?$CI?$CJ?3?6c@ DB 'cancel_du'
	DB	'mp_traceback_later():', 0aH, 'cancel the previous call to dum'
	DB	'p_traceback_later().', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JNJHDNLB@cancel_dump_traceback_later?$AA@
CONST	SEGMENT
??_C@_0BM@JNJHDNLB@cancel_dump_traceback_later?$AA@ DB 'cancel_dump_trace'
	DB	'back_later', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0NO@BKDMFNGL@dump_traceback_later?$CItimeout?0?5re@
CONST	SEGMENT
??_C@_0NO@BKDMFNGL@dump_traceback_later?$CItimeout?0?5re@ DB 'dump_traceb'
	DB	'ack_later(timeout, repeat=False, file=sys.stderrn, exit=False'
	DB	'):', 0aH, 'dump the traceback of all threads in timeout secon'
	DB	'ds,', 0aH, 'or each timeout seconds if repeat is True. If exi'
	DB	't is True, call _exit(1) which is not safe.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OCONLHGP@dump_traceback_later?$AA@
CONST	SEGMENT
??_C@_0BF@OCONLHGP@dump_traceback_later?$AA@ DB 'dump_traceback_later', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JB@NOGGBNCA@dump_traceback?$CIfile?$DNsys?4stderr?0?5@
CONST	SEGMENT
??_C@_0JB@NOGGBNCA@dump_traceback?$CIfile?$DNsys?4stderr?0?5@ DB 'dump_tr'
	DB	'aceback(file=sys.stderr, all_threads=True): dump the tracebac'
	DB	'k of the current thread, or of all threads if all_threads is '
	DB	'True, into file', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HLFAMGNN@dump_traceback?$AA@
CONST	SEGMENT
??_C@_0P@HLFAMGNN@dump_traceback?$AA@ DB 'dump_traceback', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FEHGNHKL@is_enabled?$CI?$CJ?9?$DObool?3?5check?5if?5the@
CONST	SEGMENT
??_C@_0DE@FEHGNHKL@is_enabled?$CI?$CJ?9?$DObool?3?5check?5if?5the@ DB 'is'
	DB	'_enabled()->bool: check if the handler is enabled', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FCNBNIPE@is_enabled?$AA@
CONST	SEGMENT
??_C@_0L@FCNBNIPE@is_enabled?$AA@ DB 'is_enabled', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@KKBBMCEK@disable?$CI?$CJ?3?5disable?5the?5fault?5han@
CONST	SEGMENT
??_C@_0CF@KKBBMCEK@disable?$CI?$CJ?3?5disable?5the?5fault?5han@ DB 'disab'
	DB	'le(): disable the fault handler', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07DBNODEFN@disable?$AA@
CONST	SEGMENT
??_C@_07DBNODEFN@disable?$AA@ DB 'disable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@EJHGCLAL@enable?$CIfile?$DNsys?4stderr?0?5all_thre@
CONST	SEGMENT
??_C@_0EE@EJHGCLAL@enable?$CIfile?$DNsys?4stderr?0?5all_thre@ DB 'enable('
	DB	'file=sys.stderr, all_threads=True): enable the fault handler', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06OFNJOBDK@enable?$AA@
CONST	SEGMENT
??_C@_06OFNJOBDK@enable?$AA@ DB 'enable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit?$AA@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit?$AA@ DB 'exit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGDBIFHB@repeat?$AA@
CONST	SEGMENT
??_C@_06LGDBIFHB@repeat?$AA@ DB 'repeat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DDHNKDGP@timeout?$AA@
CONST	SEGMENT
??_C@_07DDHNKDGP@timeout?$AA@ DB 'timeout', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEAOGHOB@all_threads?$AA@
CONST	SEGMENT
??_C@_0M@EEAOGHOB@all_threads?$AA@ DB 'all_threads', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DAMGJPCA@file?$AA@
CONST	SEGMENT
??_C@_04DAMGJPCA@file?$AA@ DB 'file', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GLCAEPFP@flush?$AA@
CONST	SEGMENT
??_C@_05GLCAEPFP@flush?$AA@ DB 'flush', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_enable@?1??faulthandler_env_options@@9@9 DQ 0000000000000000H ; `faulthandler_env_options'::`2'::PyId_enable
	DQ	FLAT:??_C@_06OFNJOBDK@enable?$AA@
	DQ	0000000000000000H
?PyId_flush@?1??faulthandler_get_fileno@@9@9 DQ 0000000000000000H ; `faulthandler_get_fileno'::`2'::PyId_flush
	DQ	FLAT:??_C@_05GLCAEPFP@flush?$AA@
	DQ	0000000000000000H
?PyId_fileno@?1??faulthandler_get_fileno@@9@9 DQ 0000000000000000H ; `faulthandler_get_fileno'::`2'::PyId_fileno
	DQ	FLAT:??_C@_06FFBIALPD@fileno?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_06FFBIALPD@fileno?$AA@
CONST	SEGMENT
??_C@_06FFBIALPD@fileno?$AA@ DB 'fileno', 00H		; `string'
CONST	ENDS
CONST	SEGMENT
faulthandler_nsignals DB 04H
CONST	ENDS
;	COMDAT ??_C@_0BD@IBGMJKIK@Segmentation?5fault?$AA@
CONST	SEGMENT
??_C@_0BD@IBGMJKIK@Segmentation?5fault?$AA@ DB 'Segmentation fault', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCKDCBKK@Aborted?$AA@
CONST	SEGMENT
??_C@_07LCKDCBKK@Aborted?$AA@ DB 'Aborted', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HEAFBDK@Floating?5point?5exception?$AA@
CONST	SEGMENT
??_C@_0BJ@HEAFBDK@Floating?5point?5exception?$AA@ DB 'Floating point exce'
	DB	'ption', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MLNNHANJ@Illegal?5instruction?$AA@
CONST	SEGMENT
??_C@_0BE@MLNNHANJ@Illegal?5instruction?$AA@ DB 'Illegal instruction', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
fatal_error DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	0ffffffffH
	DD	00H
	ORG $+8
faulthandler_handlers DD 04H
	DD	00H
	DQ	FLAT:??_C@_0BE@MLNNHANJ@Illegal?5instruction?$AA@
	ORG $+16
	DD	08H
	DD	00H
	DQ	FLAT:??_C@_0BJ@HEAFBDK@Floating?5point?5exception?$AA@
	ORG $+16
	DD	016H
	DD	00H
	DQ	FLAT:??_C@_07LCKDCBKK@Aborted?$AA@
	ORG $+16
	DD	0bH
	DD	00H
	DQ	FLAT:??_C@_0BD@IBGMJKIK@Segmentation?5fault?$AA@
	ORG $+16
?kwlist@?1??faulthandler_dump_traceback_py@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `faulthandler_dump_traceback_py'::`2'::kwlist
	DQ	FLAT:??_C@_0M@EEAOGHOB@all_threads?$AA@
	DQ	0000000000000000H
?kwlist@?1??faulthandler_enable@@9@9 DQ FLAT:??_C@_04DAMGJPCA@file?$AA@ ; `faulthandler_enable'::`2'::kwlist
	DQ	FLAT:??_C@_0M@EEAOGHOB@all_threads?$AA@
	DQ	0000000000000000H
?kwlist@?1??faulthandler_dump_traceback_later@@9@9 DQ FLAT:??_C@_07DDHNKDGP@timeout?$AA@ ; `faulthandler_dump_traceback_later'::`2'::kwlist
	DQ	FLAT:??_C@_06LGDBIFHB@repeat?$AA@
	DQ	FLAT:??_C@_04DAMGJPCA@file?$AA@
	DQ	FLAT:??_C@_04MKNBDEPB@exit?$AA@
	DQ	0000000000000000H
module_doc DB	'faulthandler module.', 00H
	ORG $+3
module_methods DQ FLAT:??_C@_06OFNJOBDK@enable?$AA@
	DQ	FLAT:faulthandler_enable
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0EE@EJHGCLAL@enable?$CIfile?$DNsys?4stderr?0?5all_thre@
	DQ	FLAT:??_C@_07DBNODEFN@disable?$AA@
	DQ	FLAT:faulthandler_disable_py
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CF@KKBBMCEK@disable?$CI?$CJ?3?5disable?5the?5fault?5han@
	DQ	FLAT:??_C@_0L@FCNBNIPE@is_enabled?$AA@
	DQ	FLAT:faulthandler_is_enabled
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0DE@FEHGNHKL@is_enabled?$CI?$CJ?9?$DObool?3?5check?5if?5the@
	DQ	FLAT:??_C@_0P@HLFAMGNN@dump_traceback?$AA@
	DQ	FLAT:faulthandler_dump_traceback_py
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0JB@NOGGBNCA@dump_traceback?$CIfile?$DNsys?4stderr?0?5@
	DQ	FLAT:??_C@_0BF@OCONLHGP@dump_traceback_later?$AA@
	DQ	FLAT:faulthandler_dump_traceback_later
	DD	03H
	ORG $+4
	DQ	FLAT:??_C@_0NO@BKDMFNGL@dump_traceback_later?$CItimeout?0?5re@
	DQ	FLAT:??_C@_0BM@JNJHDNLB@cancel_dump_traceback_later?$AA@
	DQ	FLAT:faulthandler_cancel_dump_traceback_later_py
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0FD@JGJPAFG@cancel_dump_traceback_later?$CI?$CJ?3?6c@
	DQ	FLAT:??_C@_0L@PHHAALCD@_read_null?$AA@
	DQ	FLAT:faulthandler_read_null
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0GK@LMJPNIJI@_read_null?$CIrelease_gil?$DNFalse?$CJ?3?5r@
	DQ	FLAT:??_C@_08BLGKFLKK@_sigsegv?$AA@
	DQ	FLAT:faulthandler_sigsegv
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CD@JMELGPAF@_sigsegv?$CI?$CJ?3?5raise?5a?5SIGSEGV?5sign@
	DQ	FLAT:??_C@_08LEEGKEOI@_sigabrt?$AA@
	DQ	FLAT:faulthandler_sigabrt
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0CD@ENHLFCIP@_sigabrt?$CI?$CJ?3?5raise?5a?5SIGABRT?5sign@
	DQ	FLAT:??_C@_07JNIEKBOI@_sigfpe?$AA@
	DQ	FLAT:faulthandler_sigfpe
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@IGEJMHBJ@_sigfpe?$CI?$CJ?3?5raise?5a?5SIGFPE?5signal@
	DQ	FLAT:??_C@_07BBJFAOD@_sigill?$AA@
	DQ	FLAT:faulthandler_sigill
	DD	04H
	ORG $+4
	DQ	FLAT:??_C@_0CB@GEBDCIHK@_sigill?$CI?$CJ?3?5raise?5a?5SIGILL?5signal@
	DQ	FLAT:??_C@_0N@CKLIJFLO@_fatal_error?$AA@
	DQ	FLAT:faulthandler_fatal_error_py
	DD	01H
	ORG $+4
	DQ	FLAT:??_C@_0DD@JHJFEDEP@_fatal_error?$CImessage?$CJ?3?5call?5Py_F@
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
module_def DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0N@FGONANPD@faulthandler?$AA@
	DQ	FLAT:module_doc
	DQ	0000000000000000H
	DQ	FLAT:module_methods
	DQ	0000000000000000H
	DQ	FLAT:faulthandler_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0BD@LFIGEFBA@?$HMOi?3dump_traceback?$AA@	; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	_Py_DumpTraceback:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	_Py_DumpTracebackThreads:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\faulthandler.c
pdata	SEGMENT
$pdata$faulthandler_dump_traceback_py DD imagerel faulthandler_dump_traceback_py
	DD	imagerel faulthandler_dump_traceback_py+257
	DD	imagerel $unwind$faulthandler_dump_traceback_py
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_dump_traceback_py DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0BD@LFIGEFBA@?$HMOi?3dump_traceback?$AA@
CONST	SEGMENT
??_C@_0BD@LFIGEFBA@?$HMOi?3dump_traceback?$AA@ DB '|Oi:dump_traceback', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT faulthandler_dump_traceback_py
_TEXT	SEGMENT
all_threads$ = 48
errmsg$ = 56
file$ = 64
tstate$ = 72
fd$ = 80
self$ = 112
args$ = 120
kwargs$ = 128
faulthandler_dump_traceback_py PROC			; COMDAT

; 193  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 194  :     static char *kwlist[] = {"file", "all_threads", NULL};
; 195  :     PyObject *file = NULL;

  00013	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR file$[rsp], 0

; 196  :     int all_threads = 1;

  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR all_threads$[rsp], 1

; 197  :     PyThreadState *tstate;
; 198  :     const char *errmsg;
; 199  :     int fd;
; 200  : 
; 201  :     if (!PyArg_ParseTupleAndKeywords(args, kwargs,
; 202  :         "|Oi:dump_traceback", kwlist,
; 203  :         &file, &all_threads))

  00024	48 8d 44 24 30	 lea	 rax, QWORD PTR all_threads$[rsp]
  00029	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002e	48 8d 44 24 40	 lea	 rax, QWORD PTR file$[rsp]
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??faulthandler_dump_traceback_py@@9@9
  0003f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BD@LFIGEFBA@?$HMOi?3dump_traceback?$AA@
  00046	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0004e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00053	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00058	85 c0		 test	 eax, eax
  0005a	75 07		 jne	 SHORT $LN6@faulthandl

; 204  :         return NULL;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 99 00 00 00	 jmp	 $LN7@faulthandl
$LN6@faulthandl:

; 205  : 
; 206  :     file = faulthandler_get_fileno(file, &fd);

  00063	48 8d 54 24 50	 lea	 rdx, QWORD PTR fd$[rsp]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0006d	e8 00 00 00 00	 call	 faulthandler_get_fileno
  00072	48 89 44 24 40	 mov	 QWORD PTR file$[rsp], rax

; 207  :     if (file == NULL)

  00077	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  0007d	75 04		 jne	 SHORT $LN5@faulthandl

; 208  :         return NULL;

  0007f	33 c0		 xor	 eax, eax
  00081	eb 79		 jmp	 SHORT $LN7@faulthandl
$LN5@faulthandl:

; 209  : 
; 210  :     tstate = get_thread_state();

  00083	e8 00 00 00 00	 call	 get_thread_state
  00088	48 89 44 24 48	 mov	 QWORD PTR tstate$[rsp], rax

; 211  :     if (tstate == NULL)

  0008d	48 83 7c 24 48
	00		 cmp	 QWORD PTR tstate$[rsp], 0
  00093	75 04		 jne	 SHORT $LN4@faulthandl

; 212  :         return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	eb 63		 jmp	 SHORT $LN7@faulthandl
$LN4@faulthandl:

; 213  : 
; 214  :     if (all_threads) {

  00099	83 7c 24 30 00	 cmp	 DWORD PTR all_threads$[rsp], 0
  0009e	74 3b		 je	 SHORT $LN3@faulthandl

; 215  :         errmsg = _Py_DumpTracebackThreads(fd, tstate->interp, tstate);

  000a0	4c 8b 44 24 48	 mov	 r8, QWORD PTR tstate$[rsp]
  000a5	48 8b 44 24 48	 mov	 rax, QWORD PTR tstate$[rsp]
  000aa	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000ae	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  000b2	e8 00 00 00 00	 call	 _Py_DumpTracebackThreads
  000b7	48 89 44 24 38	 mov	 QWORD PTR errmsg$[rsp], rax

; 216  :         if (errmsg != NULL) {

  000bc	48 83 7c 24 38
	00		 cmp	 QWORD PTR errmsg$[rsp], 0
  000c2	74 15		 je	 SHORT $LN2@faulthandl

; 217  :             PyErr_SetString(PyExc_RuntimeError, errmsg);

  000c4	48 8b 54 24 38	 mov	 rdx, QWORD PTR errmsg$[rsp]
  000c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  000d0	e8 00 00 00 00	 call	 PyErr_SetString

; 218  :             return NULL;

  000d5	33 c0		 xor	 eax, eax
  000d7	eb 23		 jmp	 SHORT $LN7@faulthandl
$LN2@faulthandl:

; 219  :         }
; 220  :     }
; 221  :     else {

  000d9	eb 0e		 jmp	 SHORT $LN1@faulthandl
$LN3@faulthandl:

; 222  :         _Py_DumpTraceback(fd, tstate);

  000db	48 8b 54 24 48	 mov	 rdx, QWORD PTR tstate$[rsp]
  000e0	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  000e4	e8 00 00 00 00	 call	 _Py_DumpTraceback
$LN1@faulthandl:

; 223  :     }
; 224  :     Py_RETURN_NONE;

  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000f0	e8 00 00 00 00	 call	 _Py_IncRef
  000f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN7@faulthandl:

; 225  : }

  000fc	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00100	c3		 ret	 0
faulthandler_dump_traceback_py ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CN@GALNIDCJ@file?4fileno?$CI?$CJ?5is?5not?5a?5valid?5fil@ ; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BJ@NLDDNMBJ@unable?5to?5get?5sys?4stderr?$AA@ ; `string'
PUBLIC	??_C@_06FJGNEBG@stderr?$AA@			; `string'
EXTRN	PyErr_Clear:PROC
EXTRN	PyLong_AsLong:PROC
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	PySys_GetObject:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\faulthandler.c
pdata	SEGMENT
$pdata$faulthandler_get_fileno DD imagerel faulthandler_get_fileno
	DD	imagerel faulthandler_get_fileno+361
	DD	imagerel $unwind$faulthandler_get_fileno
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_get_fileno DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0CN@GALNIDCJ@file?4fileno?$CI?$CJ?5is?5not?5a?5valid?5fil@
CONST	SEGMENT
??_C@_0CN@GALNIDCJ@file?4fileno?$CI?$CJ?5is?5not?5a?5valid?5fil@ DB 'file'
	DB	'.fileno() is not a valid file descriptor', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NLDDNMBJ@unable?5to?5get?5sys?4stderr?$AA@
CONST	SEGMENT
??_C@_0BJ@NLDDNMBJ@unable?5to?5get?5sys?4stderr?$AA@ DB 'unable to get sy'
	DB	's.stderr', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06FJGNEBG@stderr?$AA@
CONST	SEGMENT
??_C@_06FJGNEBG@stderr?$AA@ DB 'stderr', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT faulthandler_get_fileno
_TEXT	SEGMENT
fd_long$ = 32
result$ = 40
fd$ = 48
file$ = 80
p_fd$ = 88
faulthandler_get_fileno PROC				; COMDAT

; 132  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 133  :     PyObject *result;
; 134  :     _Py_IDENTIFIER(fileno);
; 135  :     _Py_IDENTIFIER(flush);
; 136  :     long fd_long;
; 137  :     int fd;
; 138  : 
; 139  :     if (file == NULL || file == Py_None) {

  0000e	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  00014	74 0e		 je	 SHORT $LN8@faulthandl@2
  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001d	48 39 44 24 50	 cmp	 QWORD PTR file$[rsp], rax
  00022	75 33		 jne	 SHORT $LN9@faulthandl@2
$LN8@faulthandl@2:

; 140  :         file = PySys_GetObject("stderr");

  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06FJGNEBG@stderr?$AA@
  0002b	e8 00 00 00 00	 call	 PySys_GetObject
  00030	48 89 44 24 50	 mov	 QWORD PTR file$[rsp], rax

; 141  :         if (file == NULL) {

  00035	48 83 7c 24 50
	00		 cmp	 QWORD PTR file$[rsp], 0
  0003b	75 1a		 jne	 SHORT $LN7@faulthandl@2

; 142  :             PyErr_SetString(PyExc_RuntimeError, "unable to get sys.stderr");

  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@NLDDNMBJ@unable?5to?5get?5sys?4stderr?$AA@
  00044	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0004b	e8 00 00 00 00	 call	 PyErr_SetString

; 143  :             return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	e9 0d 01 00 00	 jmp	 $LN10@faulthandl@2
$LN7@faulthandl@2:
$LN9@faulthandl@2:

; 144  :         }
; 145  :     }
; 146  : 
; 147  :     result = _PyObject_CallMethodId(file, &PyId_fileno, "");

  00057	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_fileno@?1??faulthandler_get_fileno@@9@9
  0005c	8b c0		 mov	 eax, eax
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00064	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0006d	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00071	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00078	48 8b d0	 mov	 rdx, rax
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  00080	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00085	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 148  :     if (result == NULL)

  0008a	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  00090	75 07		 jne	 SHORT $LN6@faulthandl@2

; 149  :         return NULL;

  00092	33 c0		 xor	 eax, eax
  00094	e9 cb 00 00 00	 jmp	 $LN10@faulthandl@2
$LN6@faulthandl@2:

; 150  : 
; 151  :     fd = -1;

  00099	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR fd$[rsp], -1

; 152  :     if (PyLong_Check(result)) {

  000a1	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
  000a6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000aa	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000b0	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000b5	85 c0		 test	 eax, eax
  000b7	74 27		 je	 SHORT $LN5@faulthandl@2

; 153  :         fd_long = PyLong_AsLong(result);

  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  000be	e8 00 00 00 00	 call	 PyLong_AsLong
  000c3	89 44 24 20	 mov	 DWORD PTR fd_long$[rsp], eax

; 154  :         if (0 <= fd_long && fd_long < INT_MAX)

  000c7	83 7c 24 20 00	 cmp	 DWORD PTR fd_long$[rsp], 0
  000cc	7c 12		 jl	 SHORT $LN4@faulthandl@2
  000ce	81 7c 24 20 ff
	ff ff 7f	 cmp	 DWORD PTR fd_long$[rsp], 2147483647 ; 7fffffffH
  000d6	7d 08		 jge	 SHORT $LN4@faulthandl@2

; 155  :             fd = (int)fd_long;

  000d8	8b 44 24 20	 mov	 eax, DWORD PTR fd_long$[rsp]
  000dc	89 44 24 30	 mov	 DWORD PTR fd$[rsp], eax
$LN4@faulthandl@2:
$LN5@faulthandl@2:

; 156  :     }
; 157  :     Py_DECREF(result);

  000e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  000e5	e8 00 00 00 00	 call	 _Py_DecRef

; 158  : 
; 159  :     if (fd == -1) {

  000ea	83 7c 24 30 ff	 cmp	 DWORD PTR fd$[rsp], -1
  000ef	75 17		 jne	 SHORT $LN3@faulthandl@2

; 160  :         PyErr_SetString(PyExc_RuntimeError,
; 161  :                         "file.fileno() is not a valid file descriptor");

  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GALNIDCJ@file?4fileno?$CI?$CJ?5is?5not?5a?5valid?5fil@
  000f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  000ff	e8 00 00 00 00	 call	 PyErr_SetString

; 162  :         return NULL;

  00104	33 c0		 xor	 eax, eax
  00106	eb 5c		 jmp	 SHORT $LN10@faulthandl@2
$LN3@faulthandl@2:

; 163  :     }
; 164  : 
; 165  :     result = _PyObject_CallMethodId(file, &PyId_flush, "");

  00108	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_flush@?1??faulthandler_get_fileno@@9@9
  0010d	8b c0		 mov	 eax, eax
  0010f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00115	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0011e	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00122	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00129	48 8b d0	 mov	 rdx, rax
  0012c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  00131	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00136	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 166  :     if (result != NULL)

  0013b	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  00141	74 0c		 je	 SHORT $LN2@faulthandl@2

; 167  :         Py_DECREF(result);

  00143	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00148	e8 00 00 00 00	 call	 _Py_DecRef

; 168  :     else {

  0014d	eb 05		 jmp	 SHORT $LN1@faulthandl@2
$LN2@faulthandl@2:

; 169  :         /* ignore flush() error */
; 170  :         PyErr_Clear();

  0014f	e8 00 00 00 00	 call	 PyErr_Clear
$LN1@faulthandl@2:

; 171  :     }
; 172  :     *p_fd = fd;

  00154	48 8b 44 24 58	 mov	 rax, QWORD PTR p_fd$[rsp]
  00159	8b 4c 24 30	 mov	 ecx, DWORD PTR fd$[rsp]
  0015d	89 08		 mov	 DWORD PTR [rax], ecx

; 173  :     return file;

  0015f	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
$LN10@faulthandl@2:

; 174  : }

  00164	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00168	c3		 ret	 0
faulthandler_get_fileno ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@KHOKNBLG@unable?5to?5get?5the?5current?5thread@ ; `string'
EXTRN	PyThreadState_Get:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\faulthandler.c
pdata	SEGMENT
$pdata$get_thread_state DD imagerel get_thread_state
	DD	imagerel get_thread_state+55
	DD	imagerel $unwind$get_thread_state
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_thread_state DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0CH@KHOKNBLG@unable?5to?5get?5the?5current?5thread@
CONST	SEGMENT
??_C@_0CH@KHOKNBLG@unable?5to?5get?5the?5current?5thread@ DB 'unable to g'
	DB	'et the current thread state', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT get_thread_state
_TEXT	SEGMENT
tstate$ = 32
get_thread_state PROC					; COMDAT

; 180  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 181  :     PyThreadState *tstate = PyThreadState_Get();

  00004	e8 00 00 00 00	 call	 PyThreadState_Get
  00009	48 89 44 24 20	 mov	 QWORD PTR tstate$[rsp], rax

; 182  :     if (tstate == NULL) {

  0000e	48 83 7c 24 20
	00		 cmp	 QWORD PTR tstate$[rsp], 0
  00014	75 17		 jne	 SHORT $LN1@get_thread

; 183  :         PyErr_SetString(PyExc_RuntimeError,
; 184  :                         "unable to get the current thread state");

  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@KHOKNBLG@unable?5to?5get?5the?5current?5thread@
  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00024	e8 00 00 00 00	 call	 PyErr_SetString

; 185  :         return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 05		 jmp	 SHORT $LN2@get_thread
$LN1@get_thread:

; 186  :     }
; 187  :     return tstate;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR tstate$[rsp]
$LN2@get_thread:

; 188  : }

  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
get_thread_state ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@GMHGGLPL@?$HMOi?3enable?$AA@		; `string'
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	__imp_signal:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_enable DD imagerel faulthandler_enable
	DD	imagerel faulthandler_enable+462
	DD	imagerel $unwind$faulthandler_enable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_enable DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0L@GMHGGLPL@?$HMOi?3enable?$AA@
CONST	SEGMENT
??_C@_0L@GMHGGLPL@?$HMOi?3enable?$AA@ DB '|Oi:enable', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT faulthandler_enable
_TEXT	SEGMENT
handler$ = 48
i$ = 56
all_threads$ = 60
file$ = 64
tstate$ = 72
err$ = 80
fd$ = 84
tv128 = 88
self$ = 112
args$ = 120
kwargs$ = 128
faulthandler_enable PROC				; COMDAT

; 313  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 314  :     static char *kwlist[] = {"file", "all_threads", NULL};
; 315  :     PyObject *file = NULL;

  00013	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR file$[rsp], 0

; 316  :     int all_threads = 1;

  0001c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR all_threads$[rsp], 1

; 317  :     unsigned int i;
; 318  :     fault_handler_t *handler;
; 319  : #ifdef HAVE_SIGACTION
; 320  :     struct sigaction action;
; 321  : #endif
; 322  :     int err;
; 323  :     int fd;
; 324  :     PyThreadState *tstate;
; 325  : 
; 326  :     if (!PyArg_ParseTupleAndKeywords(args, kwargs,
; 327  :         "|Oi:enable", kwlist, &file, &all_threads))

  00024	48 8d 44 24 3c	 lea	 rax, QWORD PTR all_threads$[rsp]
  00029	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002e	48 8d 44 24 40	 lea	 rax, QWORD PTR file$[rsp]
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??faulthandler_enable@@9@9
  0003f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@GMHGGLPL@?$HMOi?3enable?$AA@
  00046	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0004e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00053	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00058	85 c0		 test	 eax, eax
  0005a	75 07		 jne	 SHORT $LN12@faulthandl@3

; 328  :         return NULL;

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 66 01 00 00	 jmp	 $LN13@faulthandl@3
$LN12@faulthandl@3:

; 329  : 
; 330  :     file = faulthandler_get_fileno(file, &fd);

  00063	48 8d 54 24 54	 lea	 rdx, QWORD PTR fd$[rsp]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0006d	e8 00 00 00 00	 call	 faulthandler_get_fileno
  00072	48 89 44 24 40	 mov	 QWORD PTR file$[rsp], rax

; 331  :     if (file == NULL)

  00077	48 83 7c 24 40
	00		 cmp	 QWORD PTR file$[rsp], 0
  0007d	75 07		 jne	 SHORT $LN11@faulthandl@3

; 332  :         return NULL;

  0007f	33 c0		 xor	 eax, eax
  00081	e9 43 01 00 00	 jmp	 $LN13@faulthandl@3
$LN11@faulthandl@3:

; 333  : 
; 334  :     tstate = get_thread_state();

  00086	e8 00 00 00 00	 call	 get_thread_state
  0008b	48 89 44 24 48	 mov	 QWORD PTR tstate$[rsp], rax

; 335  :     if (tstate == NULL)

  00090	48 83 7c 24 48
	00		 cmp	 QWORD PTR tstate$[rsp], 0
  00096	75 07		 jne	 SHORT $LN10@faulthandl@3

; 336  :         return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	e9 2a 01 00 00	 jmp	 $LN13@faulthandl@3
$LN10@faulthandl@3:
$LN9@faulthandl@3:

; 337  : 
; 338  :     Py_XDECREF(fatal_error.file);

  0009f	48 83 3d 08 00
	00 00 00	 cmp	 QWORD PTR fatal_error+8, 0
  000a7	74 0c		 je	 SHORT $LN6@faulthandl@3
  000a9	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR fatal_error+8
  000b0	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@faulthandl@3:
  000b5	33 c0		 xor	 eax, eax
  000b7	85 c0		 test	 eax, eax
  000b9	75 e4		 jne	 SHORT $LN9@faulthandl@3

; 339  :     Py_INCREF(file);

  000bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  000c0	e8 00 00 00 00	 call	 _Py_IncRef

; 340  :     fatal_error.file = file;

  000c5	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  000ca	48 89 05 08 00
	00 00		 mov	 QWORD PTR fatal_error+8, rax

; 341  :     fatal_error.fd = fd;

  000d1	8b 44 24 54	 mov	 eax, DWORD PTR fd$[rsp]
  000d5	89 05 10 00 00
	00		 mov	 DWORD PTR fatal_error+16, eax

; 342  :     fatal_error.all_threads = all_threads;

  000db	8b 44 24 3c	 mov	 eax, DWORD PTR all_threads$[rsp]
  000df	89 05 14 00 00
	00		 mov	 DWORD PTR fatal_error+20, eax

; 343  :     fatal_error.interp = tstate->interp;

  000e5	48 8b 44 24 48	 mov	 rax, QWORD PTR tstate$[rsp]
  000ea	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ee	48 89 05 18 00
	00 00		 mov	 QWORD PTR fatal_error+24, rax

; 344  : 
; 345  :     if (!fatal_error.enabled) {

  000f5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR fatal_error, 0
  000fc	0f 85 b4 00 00
	00		 jne	 $LN5@faulthandl@3

; 346  :         fatal_error.enabled = 1;

  00102	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR fatal_error, 1

; 347  : 
; 348  :         for (i=0; i < faulthandler_nsignals; i++) {

  0010c	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00114	eb 0a		 jmp	 SHORT $LN4@faulthandl@3
$LN3@faulthandl@3:
  00116	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0011a	ff c0		 inc	 eax
  0011c	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN4@faulthandl@3:
  00120	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR faulthandler_nsignals
  00127	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  0012b	0f 83 85 00 00
	00		 jae	 $LN2@faulthandl@3

; 349  :             handler = &faulthandler_handlers[i];

  00131	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00135	48 6b c0 20	 imul	 rax, 32			; 00000020H
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:faulthandler_handlers
  00140	48 03 c8	 add	 rcx, rax
  00143	48 8b c1	 mov	 rax, rcx
  00146	48 89 44 24 30	 mov	 QWORD PTR handler$[rsp], rax

; 350  : #ifdef HAVE_SIGACTION
; 351  :             action.sa_handler = faulthandler_fatal_error;
; 352  :             sigemptyset(&action.sa_mask);
; 353  :             /* Do not prevent the signal from being received from within
; 354  :                its own signal handler */
; 355  :             action.sa_flags = SA_NODEFER;
; 356  : #ifdef HAVE_SIGALTSTACK
; 357  :             if (stack.ss_sp != NULL) {
; 358  :                 /* Call the signal handler on an alternate signal stack
; 359  :                    provided by sigaltstack() */
; 360  :                 action.sa_flags |= SA_ONSTACK;
; 361  :             }
; 362  : #endif
; 363  :             err = sigaction(handler->signum, &action, &handler->previous);
; 364  : #else
; 365  :             handler->previous = signal(handler->signum,
; 366  :                                        faulthandler_fatal_error);

  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:faulthandler_fatal_error
  00152	48 8b 44 24 30	 mov	 rax, QWORD PTR handler$[rsp]
  00157	8b 08		 mov	 ecx, DWORD PTR [rax]
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_signal
  0015f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR handler$[rsp]
  00164	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 367  :             err = (handler->previous == SIG_ERR);

  00168	48 8b 44 24 30	 mov	 rax, QWORD PTR handler$[rsp]
  0016d	48 83 78 10 ff	 cmp	 QWORD PTR [rax+16], -1
  00172	75 0a		 jne	 SHORT $LN15@faulthandl@3
  00174	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  0017c	eb 08		 jmp	 SHORT $LN16@faulthandl@3
$LN15@faulthandl@3:
  0017e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN16@faulthandl@3:
  00186	8b 44 24 58	 mov	 eax, DWORD PTR tv128[rsp]
  0018a	89 44 24 50	 mov	 DWORD PTR err$[rsp], eax

; 368  : #endif
; 369  :             if (err) {

  0018e	83 7c 24 50 00	 cmp	 DWORD PTR err$[rsp], 0
  00193	74 10		 je	 SHORT $LN1@faulthandl@3

; 370  :                 PyErr_SetFromErrno(PyExc_RuntimeError);

  00195	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0019c	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 371  :                 return NULL;

  001a1	33 c0		 xor	 eax, eax
  001a3	eb 24		 jmp	 SHORT $LN13@faulthandl@3
$LN1@faulthandl@3:

; 372  :             }
; 373  :             handler->enabled = 1;

  001a5	48 8b 44 24 30	 mov	 rax, QWORD PTR handler$[rsp]
  001aa	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1

; 374  :         }

  001b1	e9 60 ff ff ff	 jmp	 $LN3@faulthandl@3
$LN2@faulthandl@3:
$LN5@faulthandl@3:

; 375  :     }
; 376  :     Py_RETURN_NONE;

  001b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  001bd	e8 00 00 00 00	 call	 _Py_IncRef
  001c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN13@faulthandl@3:

; 377  : }

  001c9	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001cd	c3		 ret	 0
faulthandler_enable ENDP
_TEXT	ENDS
PUBLIC	??_C@_02PHMGELLB@?6?6?$AA@			; `string'
PUBLIC	??_C@_0BF@ENMDFAGK@Fatal?5Python?5error?3?5?$AA@ ; `string'
EXTRN	__imp_raise:PROC
EXTRN	PyGILState_GetThisThreadState:PROC
EXTRN	__imp_write:PROC
EXTRN	strlen:PROC
EXTRN	__imp__errno:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_fatal_error DD imagerel faulthandler_fatal_error
	DD	imagerel faulthandler_fatal_error+373
	DD	imagerel $unwind$faulthandler_fatal_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_fatal_error DD 010801H
	DD	08208H
xdata	ENDS
;	COMDAT ??_C@_02PHMGELLB@?6?6?$AA@
CONST	SEGMENT
??_C@_02PHMGELLB@?6?6?$AA@ DB 0aH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@ENMDFAGK@Fatal?5Python?5error?3?5?$AA@
CONST	SEGMENT
??_C@_0BF@ENMDFAGK@Fatal?5Python?5error?3?5?$AA@ DB 'Fatal Python error: '
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT faulthandler_fatal_error
_TEXT	SEGMENT
handler$ = 32
i$ = 40
tstate$ = 48
save_errno$ = 56
fd$ = 60
signum$ = 80
faulthandler_fatal_error PROC				; COMDAT

; 243  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 244  :     const int fd = fatal_error.fd;

  00008	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR fatal_error+16
  0000e	89 44 24 3c	 mov	 DWORD PTR fd$[rsp], eax

; 245  :     unsigned int i;
; 246  :     fault_handler_t *handler = NULL;

  00012	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR handler$[rsp], 0

; 247  :     PyThreadState *tstate;
; 248  :     int save_errno = errno;

  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00021	8b 00		 mov	 eax, DWORD PTR [rax]
  00023	89 44 24 38	 mov	 DWORD PTR save_errno$[rsp], eax

; 249  : 
; 250  :     if (!fatal_error.enabled)

  00027	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR fatal_error, 0
  0002e	75 05		 jne	 SHORT $LN10@faulthandl@4

; 251  :         return;

  00030	e9 3b 01 00 00	 jmp	 $LN11@faulthandl@4
$LN10@faulthandl@4:

; 252  : 
; 253  :     for (i=0; i < faulthandler_nsignals; i++) {

  00035	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0003d	eb 0a		 jmp	 SHORT $LN9@faulthandl@4
$LN8@faulthandl@4:
  0003f	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00043	ff c0		 inc	 eax
  00045	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN9@faulthandl@4:
  00049	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR faulthandler_nsignals
  00050	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00054	73 2b		 jae	 SHORT $LN7@faulthandl@4

; 254  :         handler = &faulthandler_handlers[i];

  00056	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0005a	48 6b c0 20	 imul	 rax, 32			; 00000020H
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:faulthandler_handlers
  00065	48 03 c8	 add	 rcx, rax
  00068	48 8b c1	 mov	 rax, rcx
  0006b	48 89 44 24 20	 mov	 QWORD PTR handler$[rsp], rax

; 255  :         if (handler->signum == signum)

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR handler$[rsp]
  00075	8b 4c 24 50	 mov	 ecx, DWORD PTR signum$[rsp]
  00079	39 08		 cmp	 DWORD PTR [rax], ecx
  0007b	75 02		 jne	 SHORT $LN6@faulthandl@4

; 256  :             break;

  0007d	eb 02		 jmp	 SHORT $LN7@faulthandl@4
$LN6@faulthandl@4:

; 257  :     }

  0007f	eb be		 jmp	 SHORT $LN8@faulthandl@4
$LN7@faulthandl@4:

; 258  :     if (handler == NULL) {

  00081	48 83 7c 24 20
	00		 cmp	 QWORD PTR handler$[rsp], 0
  00087	75 05		 jne	 SHORT $LN5@faulthandl@4

; 259  :         /* faulthandler_nsignals == 0 (unlikely) */
; 260  :         return;

  00089	e9 e2 00 00 00	 jmp	 $LN11@faulthandl@4
$LN5@faulthandl@4:

; 261  :     }
; 262  : 
; 263  :     /* restore the previous handler */
; 264  : #ifdef HAVE_SIGACTION
; 265  :     (void)sigaction(signum, &handler->previous, NULL);
; 266  : #else
; 267  :     (void)signal(signum, handler->previous);

  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR handler$[rsp]
  00093	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00097	8b 4c 24 50	 mov	 ecx, DWORD PTR signum$[rsp]
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_signal

; 268  : #endif
; 269  :     handler->enabled = 0;

  000a1	48 8b 44 24 20	 mov	 rax, QWORD PTR handler$[rsp]
  000a6	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 270  : 
; 271  :     PUTS(fd, "Fatal Python error: ");

  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@ENMDFAGK@Fatal?5Python?5error?3?5?$AA@
  000b4	e8 00 00 00 00	 call	 strlen
  000b9	44 8b c0	 mov	 r8d, eax
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@ENMDFAGK@Fatal?5Python?5error?3?5?$AA@
  000c3	8b 4c 24 3c	 mov	 ecx, DWORD PTR fd$[rsp]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 272  :     PUTS(fd, handler->name);

  000cd	48 8b 44 24 20	 mov	 rax, QWORD PTR handler$[rsp]
  000d2	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000d6	e8 00 00 00 00	 call	 strlen
  000db	44 8b c0	 mov	 r8d, eax
  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR handler$[rsp]
  000e3	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000e7	8b 4c 24 3c	 mov	 ecx, DWORD PTR fd$[rsp]
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 273  :     PUTS(fd, "\n\n");

  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02PHMGELLB@?6?6?$AA@
  000f8	e8 00 00 00 00	 call	 strlen
  000fd	44 8b c0	 mov	 r8d, eax
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PHMGELLB@?6?6?$AA@
  00107	8b 4c 24 3c	 mov	 ecx, DWORD PTR fd$[rsp]
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 274  : 
; 275  : #ifdef WITH_THREAD
; 276  :     /* SIGSEGV, SIGFPE, SIGABRT, SIGBUS and SIGILL are synchronous signals and
; 277  :        are thus delivered to the thread that caused the fault. Get the Python
; 278  :        thread state of the current thread.
; 279  : 
; 280  :        PyThreadState_Get() doesn't give the state of the thread that caused the
; 281  :        fault if the thread released the GIL, and so this function cannot be
; 282  :        used. Read the thread local storage (TLS) instead: call
; 283  :        PyGILState_GetThisThreadState(). */
; 284  :     tstate = PyGILState_GetThisThreadState();

  00111	e8 00 00 00 00	 call	 PyGILState_GetThisThreadState
  00116	48 89 44 24 30	 mov	 QWORD PTR tstate$[rsp], rax

; 285  : #else
; 286  :     tstate = PyThreadState_Get();
; 287  : #endif
; 288  : 
; 289  :     if (fatal_error.all_threads)

  0011b	83 3d 14 00 00
	00 00		 cmp	 DWORD PTR fatal_error+20, 0
  00122	74 17		 je	 SHORT $LN4@faulthandl@4

; 290  :         _Py_DumpTracebackThreads(fd, fatal_error.interp, tstate);

  00124	4c 8b 44 24 30	 mov	 r8, QWORD PTR tstate$[rsp]
  00129	48 8b 15 18 00
	00 00		 mov	 rdx, QWORD PTR fatal_error+24
  00130	8b 4c 24 3c	 mov	 ecx, DWORD PTR fd$[rsp]
  00134	e8 00 00 00 00	 call	 _Py_DumpTracebackThreads

; 291  :     else {

  00139	eb 16		 jmp	 SHORT $LN3@faulthandl@4
$LN4@faulthandl@4:

; 292  :         if (tstate != NULL)

  0013b	48 83 7c 24 30
	00		 cmp	 QWORD PTR tstate$[rsp], 0
  00141	74 0e		 je	 SHORT $LN2@faulthandl@4

; 293  :             _Py_DumpTraceback(fd, tstate);

  00143	48 8b 54 24 30	 mov	 rdx, QWORD PTR tstate$[rsp]
  00148	8b 4c 24 3c	 mov	 ecx, DWORD PTR fd$[rsp]
  0014c	e8 00 00 00 00	 call	 _Py_DumpTraceback
$LN2@faulthandl@4:
$LN3@faulthandl@4:

; 294  :     }
; 295  : 
; 296  :     errno = save_errno;

  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00157	8b 4c 24 38	 mov	 ecx, DWORD PTR save_errno$[rsp]
  0015b	89 08		 mov	 DWORD PTR [rax], ecx

; 297  : #ifdef MS_WINDOWS
; 298  :     if (signum == SIGSEGV) {

  0015d	83 7c 24 50 0b	 cmp	 DWORD PTR signum$[rsp], 11
  00162	75 02		 jne	 SHORT $LN1@faulthandl@4

; 299  :         /* don't explicitly call the previous handler for SIGSEGV in this signal
; 300  :            handler, because the Windows signal handler would not be called */
; 301  :         return;

  00164	eb 0a		 jmp	 SHORT $LN11@faulthandl@4
$LN1@faulthandl@4:

; 302  :     }
; 303  : #endif
; 304  :     /* call the previous signal handler: it is called immediately if we use
; 305  :        sigaction() thanks to SA_NODEFER flag, otherwise it is deferred */
; 306  :     raise(signum);

  00166	8b 4c 24 50	 mov	 ecx, DWORD PTR signum$[rsp]
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_raise
$LN11@faulthandl@4:

; 307  : }

  00170	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00174	c3		 ret	 0
faulthandler_fatal_error ENDP
_TEXT	ENDS
EXTRN	_Py_TrueStruct:BYTE
EXTRN	_Py_FalseStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_disable_py DD imagerel faulthandler_disable_py
	DD	imagerel faulthandler_disable_py+68
	DD	imagerel $unwind$faulthandler_disable_py
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_disable_py DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT faulthandler_disable_py
_TEXT	SEGMENT
self$ = 48
faulthandler_disable_py PROC				; COMDAT

; 405  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 406  :     if (!fatal_error.enabled) {

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR fatal_error, 0
  00010	75 15		 jne	 SHORT $LN1@faulthandl@5

; 407  :         Py_INCREF(Py_False);

  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00019	e8 00 00 00 00	 call	 _Py_IncRef

; 408  :         return Py_False;

  0001e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00025	eb 18		 jmp	 SHORT $LN2@faulthandl@5
$LN1@faulthandl@5:

; 409  :     }
; 410  :     faulthandler_disable();

  00027	e8 00 00 00 00	 call	 faulthandler_disable

; 411  :     Py_INCREF(Py_True);

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00033	e8 00 00 00 00	 call	 _Py_IncRef

; 412  :     return Py_True;

  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
$LN2@faulthandl@5:

; 413  : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
faulthandler_disable_py ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@LFCNKDC@faulthandler_disable?$AA@	; `string'
PUBLIC	??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_disable DD imagerel faulthandler_disable
	DD	imagerel faulthandler_disable+229
	DD	imagerel $unwind$faulthandler_disable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_disable DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0BF@LFCNKDC@faulthandler_disable?$AA@
CONST	SEGMENT
??_C@_0BF@LFCNKDC@faulthandler_disable?$AA@ DB 'faulthandler_disable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
CONST	SEGMENT
??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@ DB '..\Modules\fau'
	DB	'lthandler.c', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT faulthandler_disable
_TEXT	SEGMENT
handler$ = 48
i$ = 56
_py_tmp$20637 = 64
faulthandler_disable PROC				; COMDAT

; 381  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 382  :     unsigned int i;
; 383  :     fault_handler_t *handler;
; 384  : 
; 385  :     if (fatal_error.enabled) {

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR fatal_error, 0
  0000b	74 76		 je	 SHORT $LN9@faulthandl@6

; 386  :         fatal_error.enabled = 0;

  0000d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR fatal_error, 0

; 387  :         for (i=0; i < faulthandler_nsignals; i++) {

  00017	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001f	eb 0a		 jmp	 SHORT $LN8@faulthandl@6
$LN7@faulthandl@6:
  00021	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00025	ff c0		 inc	 eax
  00027	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN8@faulthandl@6:
  0002b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR faulthandler_nsignals
  00032	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00036	73 4b		 jae	 SHORT $LN6@faulthandl@6

; 388  :             handler = &faulthandler_handlers[i];

  00038	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0003c	48 6b c0 20	 imul	 rax, 32			; 00000020H
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:faulthandler_handlers
  00047	48 03 c8	 add	 rcx, rax
  0004a	48 8b c1	 mov	 rax, rcx
  0004d	48 89 44 24 30	 mov	 QWORD PTR handler$[rsp], rax

; 389  :             if (!handler->enabled)

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR handler$[rsp]
  00057	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0005b	75 02		 jne	 SHORT $LN5@faulthandl@6

; 390  :                 continue;

  0005d	eb c2		 jmp	 SHORT $LN7@faulthandl@6
$LN5@faulthandl@6:

; 391  : #ifdef HAVE_SIGACTION
; 392  :             (void)sigaction(handler->signum, &handler->previous, NULL);
; 393  : #else
; 394  :             (void)signal(handler->signum, handler->previous);

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR handler$[rsp]
  00064	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR handler$[rsp]
  0006d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_signal

; 395  : #endif
; 396  :             handler->enabled = 0;

  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR handler$[rsp]
  0007a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 397  :         }

  00081	eb 9e		 jmp	 SHORT $LN7@faulthandl@6
$LN6@faulthandl@6:
$LN9@faulthandl@6:
$LN4@faulthandl@6:

; 398  :     }
; 399  : 
; 400  :     Py_CLEAR(fatal_error.file);

  00083	48 83 3d 08 00
	00 00 00	 cmp	 QWORD PTR fatal_error+8, 0
  0008b	74 4d		 je	 SHORT $LN1@faulthandl@6
  0008d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00095	4c 8b 0d 08 00
	00 00		 mov	 r9, QWORD PTR fatal_error+8
  0009c	41 b8 90 01 00
	00		 mov	 r8d, 400		; 00000190H
  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@LFCNKDC@faulthandler_disable?$AA@
  000b0	e8 00 00 00 00	 call	 _PyParallel_Guard
  000b5	85 c0		 test	 eax, eax
  000b7	75 21		 jne	 SHORT $LN1@faulthandl@6
  000b9	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR fatal_error+8
  000c0	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$20637[rsp], rax
  000c5	48 c7 05 08 00
	00 00 00 00 00
	00		 mov	 QWORD PTR fatal_error+8, 0
  000d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$20637[rsp]
  000d5	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@faulthandl@6:
  000da	33 c0		 xor	 eax, eax
  000dc	85 c0		 test	 eax, eax
  000de	75 a3		 jne	 SHORT $LN4@faulthandl@6

; 401  : }

  000e0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e4	c3		 ret	 0
faulthandler_disable ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_is_enabled DD imagerel faulthandler_is_enabled
	DD	imagerel faulthandler_is_enabled+25
	DD	imagerel $unwind$faulthandler_is_enabled
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_is_enabled DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT faulthandler_is_enabled
_TEXT	SEGMENT
self$ = 48
faulthandler_is_enabled PROC				; COMDAT

; 417  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 418  :     return PyBool_FromLong(fatal_error.enabled);

  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fatal_error
  0000f	e8 00 00 00 00	 call	 PyBool_FromLong

; 419  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
faulthandler_is_enabled ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@FONLKIBM@unable?5to?5start?5watchdog?5thread?$AA@ ; `string'
PUBLIC	??_C@_0CC@GIOANNFL@faulthandler_dump_traceback_late@ ; `string'
PUBLIC	??_C@_0BP@FGFKIEPN@timeout?5must?5be?5greater?5than?50?$AA@ ; `string'
PUBLIC	??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@ ; `string'
PUBLIC	__real@428f3fffffe0c000
PUBLIC	__real@412e848000000000
PUBLIC	??_C@_0BL@DFKMCNJN@d?$HMiOi?3dump_traceback_later?$AA@ ; `string'
EXTRN	__imp_free:PROC
EXTRN	PyThread_release_lock:PROC
EXTRN	PyThread_start_new_thread:PROC
EXTRN	PyThread_acquire_lock:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyExc_OverflowError:QWORD
EXTRN	_fltused:DWORD
_BSS	SEGMENT
thread	DB	050H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_dump_traceback_later DD imagerel faulthandler_dump_traceback_later
	DD	imagerel faulthandler_dump_traceback_later+716
	DD	imagerel $unwind$faulthandler_dump_traceback_later
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_dump_traceback_later DD 021601H
	DD	0130116H
xdata	ENDS
;	COMDAT ??_C@_0CA@FONLKIBM@unable?5to?5start?5watchdog?5thread?$AA@
CONST	SEGMENT
??_C@_0CA@FONLKIBM@unable?5to?5start?5watchdog?5thread?$AA@ DB 'unable to'
	DB	' start watchdog thread', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GIOANNFL@faulthandler_dump_traceback_late@
CONST	SEGMENT
??_C@_0CC@GIOANNFL@faulthandler_dump_traceback_late@ DB 'faulthandler_dum'
	DB	'p_traceback_later', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@FGFKIEPN@timeout?5must?5be?5greater?5than?50?$AA@
CONST	SEGMENT
??_C@_0BP@FGFKIEPN@timeout?5must?5be?5greater?5than?50?$AA@ DB 'timeout m'
	DB	'ust be greater than 0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@ DB 'timeout value '
	DB	'is too large', 00H				; `string'
CONST	ENDS
;	COMDAT __real@428f3fffffe0c000
CONST	SEGMENT
__real@428f3fffffe0c000 DQ 0428f3fffffe0c000r	; 4.29497e+012
CONST	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+006
CONST	ENDS
;	COMDAT ??_C@_0BL@DFKMCNJN@d?$HMiOi?3dump_traceback_later?$AA@
CONST	SEGMENT
??_C@_0BL@DFKMCNJN@d?$HMiOi?3dump_traceback_later?$AA@ DB 'd|iOi:dump_tra'
	DB	'ceback_later', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT faulthandler_dump_traceback_later
_TEXT	SEGMENT
exit$ = 64
header_len$ = 72
repeat$ = 80
file$ = 88
tstate$ = 96
timeout_us$ = 104
timeout$ = 112
header$ = 120
fd$ = 128
_py_tmp$20761 = 136
self$ = 160
args$ = 168
kwargs$ = 176
faulthandler_dump_traceback_later PROC			; COMDAT

; 514  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 515  :     static char *kwlist[] = {"timeout", "repeat", "file", "exit", NULL};
; 516  :     double timeout;
; 517  :     PY_TIMEOUT_T timeout_us;
; 518  :     int repeat = 0;

  00016	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR repeat$[rsp], 0

; 519  :     PyObject *file = NULL;

  0001e	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR file$[rsp], 0

; 520  :     int fd;
; 521  :     int exit = 0;

  00027	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR exit$[rsp], 0

; 522  :     PyThreadState *tstate;
; 523  :     char *header;
; 524  :     size_t header_len;
; 525  : 
; 526  :     if (!PyArg_ParseTupleAndKeywords(args, kwargs,
; 527  :         "d|iOi:dump_traceback_later", kwlist,
; 528  :         &timeout, &repeat, &file, &exit))

  0002f	48 8d 44 24 40	 lea	 rax, QWORD PTR exit$[rsp]
  00034	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00039	48 8d 44 24 58	 lea	 rax, QWORD PTR file$[rsp]
  0003e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00043	48 8d 44 24 50	 lea	 rax, QWORD PTR repeat$[rsp]
  00048	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004d	48 8d 44 24 70	 lea	 rax, QWORD PTR timeout$[rsp]
  00052	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00057	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??faulthandler_dump_traceback_later@@9@9
  0005e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BL@DFKMCNJN@d?$HMiOi?3dump_traceback_later?$AA@
  00065	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR kwargs$[rsp]
  0006d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00075	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0007a	85 c0		 test	 eax, eax
  0007c	75 07		 jne	 SHORT $LN15@faulthandl@7

; 529  :         return NULL;

  0007e	33 c0		 xor	 eax, eax
  00080	e9 3f 02 00 00	 jmp	 $LN16@faulthandl@7
$LN15@faulthandl@7:

; 530  :     if ((timeout * 1e6) >= (double) PY_TIMEOUT_MAX) {

  00085	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  0008b	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@412e848000000000
  00093	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@428f3fffffe0c000
  0009b	72 1a		 jb	 SHORT $LN14@faulthandl@7

; 531  :         PyErr_SetString(PyExc_OverflowError,  "timeout value is too large");

  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@DOGKBCNL@timeout?5value?5is?5too?5large?$AA@
  000a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  000ab	e8 00 00 00 00	 call	 PyErr_SetString

; 532  :         return NULL;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 0d 02 00 00	 jmp	 $LN16@faulthandl@7
$LN14@faulthandl@7:

; 533  :     }
; 534  :     timeout_us = (PY_TIMEOUT_T)(timeout * 1e6);

  000b7	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  000bd	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@412e848000000000
  000c5	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  000ca	48 89 44 24 68	 mov	 QWORD PTR timeout_us$[rsp], rax

; 535  :     if (timeout_us <= 0) {

  000cf	48 83 7c 24 68
	00		 cmp	 QWORD PTR timeout_us$[rsp], 0
  000d5	7f 1a		 jg	 SHORT $LN13@faulthandl@7

; 536  :         PyErr_SetString(PyExc_ValueError, "timeout must be greater than 0");

  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@FGFKIEPN@timeout?5must?5be?5greater?5than?50?$AA@
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000e5	e8 00 00 00 00	 call	 PyErr_SetString

; 537  :         return NULL;

  000ea	33 c0		 xor	 eax, eax
  000ec	e9 d3 01 00 00	 jmp	 $LN16@faulthandl@7
$LN13@faulthandl@7:

; 538  :     }
; 539  : 
; 540  :     tstate = get_thread_state();

  000f1	e8 00 00 00 00	 call	 get_thread_state
  000f6	48 89 44 24 60	 mov	 QWORD PTR tstate$[rsp], rax

; 541  :     if (tstate == NULL)

  000fb	48 83 7c 24 60
	00		 cmp	 QWORD PTR tstate$[rsp], 0
  00101	75 07		 jne	 SHORT $LN12@faulthandl@7

; 542  :         return NULL;

  00103	33 c0		 xor	 eax, eax
  00105	e9 ba 01 00 00	 jmp	 $LN16@faulthandl@7
$LN12@faulthandl@7:

; 543  : 
; 544  :     file = faulthandler_get_fileno(file, &fd);

  0010a	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR fd$[rsp]
  00112	48 8b 4c 24 58	 mov	 rcx, QWORD PTR file$[rsp]
  00117	e8 00 00 00 00	 call	 faulthandler_get_fileno
  0011c	48 89 44 24 58	 mov	 QWORD PTR file$[rsp], rax

; 545  :     if (file == NULL)

  00121	48 83 7c 24 58
	00		 cmp	 QWORD PTR file$[rsp], 0
  00127	75 07		 jne	 SHORT $LN11@faulthandl@7

; 546  :         return NULL;

  00129	33 c0		 xor	 eax, eax
  0012b	e9 94 01 00 00	 jmp	 $LN16@faulthandl@7
$LN11@faulthandl@7:

; 547  : 
; 548  :     /* format the timeout */
; 549  :     header = format_timeout(timeout);

  00130	f2 0f 10 44 24
	70		 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  00136	e8 00 00 00 00	 call	 format_timeout
  0013b	48 89 44 24 78	 mov	 QWORD PTR header$[rsp], rax

; 550  :     if (header == NULL)

  00140	48 83 7c 24 78
	00		 cmp	 QWORD PTR header$[rsp], 0
  00146	75 0a		 jne	 SHORT $LN10@faulthandl@7

; 551  :         return PyErr_NoMemory();

  00148	e8 00 00 00 00	 call	 PyErr_NoMemory
  0014d	e9 72 01 00 00	 jmp	 $LN16@faulthandl@7
$LN10@faulthandl@7:

; 552  :     header_len = strlen(header);

  00152	48 8b 4c 24 78	 mov	 rcx, QWORD PTR header$[rsp]
  00157	e8 00 00 00 00	 call	 strlen
  0015c	48 89 44 24 48	 mov	 QWORD PTR header_len$[rsp], rax

; 553  : 
; 554  :     /* Cancel previous thread, if running */
; 555  :     cancel_dump_traceback_later();

  00161	e8 00 00 00 00	 call	 cancel_dump_traceback_later
$LN9@faulthandl@7:

; 556  : 
; 557  :     Py_XDECREF(thread.file);

  00166	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR thread, 0
  0016e	74 0c		 je	 SHORT $LN6@faulthandl@7
  00170	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR thread
  00177	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@faulthandl@7:
  0017c	33 c0		 xor	 eax, eax
  0017e	85 c0		 test	 eax, eax
  00180	75 e4		 jne	 SHORT $LN9@faulthandl@7

; 558  :     Py_INCREF(file);

  00182	48 8b 4c 24 58	 mov	 rcx, QWORD PTR file$[rsp]
  00187	e8 00 00 00 00	 call	 _Py_IncRef

; 559  :     thread.file = file;

  0018c	48 8b 44 24 58	 mov	 rax, QWORD PTR file$[rsp]
  00191	48 89 05 00 00
	00 00		 mov	 QWORD PTR thread, rax

; 560  :     thread.fd = fd;

  00198	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fd$[rsp]
  0019f	89 05 08 00 00
	00		 mov	 DWORD PTR thread+8, eax

; 561  :     thread.timeout_us = timeout_us;

  001a5	48 8b 44 24 68	 mov	 rax, QWORD PTR timeout_us$[rsp]
  001aa	48 89 05 10 00
	00 00		 mov	 QWORD PTR thread+16, rax

; 562  :     thread.repeat = repeat;

  001b1	8b 44 24 50	 mov	 eax, DWORD PTR repeat$[rsp]
  001b5	89 05 18 00 00
	00		 mov	 DWORD PTR thread+24, eax

; 563  :     thread.interp = tstate->interp;

  001bb	48 8b 44 24 60	 mov	 rax, QWORD PTR tstate$[rsp]
  001c0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001c4	48 89 05 20 00
	00 00		 mov	 QWORD PTR thread+32, rax

; 564  :     thread.exit = exit;

  001cb	8b 44 24 40	 mov	 eax, DWORD PTR exit$[rsp]
  001cf	89 05 28 00 00
	00		 mov	 DWORD PTR thread+40, eax

; 565  :     thread.header = header;

  001d5	48 8b 44 24 78	 mov	 rax, QWORD PTR header$[rsp]
  001da	48 89 05 30 00
	00 00		 mov	 QWORD PTR thread+48, rax

; 566  :     thread.header_len = header_len;

  001e1	48 8b 44 24 48	 mov	 rax, QWORD PTR header_len$[rsp]
  001e6	48 89 05 38 00
	00 00		 mov	 QWORD PTR thread+56, rax

; 567  : 
; 568  :     /* Arm these locks to serve as events when released */
; 569  :     PyThread_acquire_lock(thread.running, 1);

  001ed	ba 01 00 00 00	 mov	 edx, 1
  001f2	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  001f9	e8 00 00 00 00	 call	 PyThread_acquire_lock

; 570  : 
; 571  :     if (PyThread_start_new_thread(faulthandler_thread, NULL) == -1) {

  001fe	33 d2		 xor	 edx, edx
  00200	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:faulthandler_thread
  00207	e8 00 00 00 00	 call	 PyThread_start_new_thread
  0020c	83 f8 ff	 cmp	 eax, -1
  0020f	0f 85 9c 00 00
	00		 jne	 $LN5@faulthandl@7

; 572  :         PyThread_release_lock(thread.running);

  00215	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  0021c	e8 00 00 00 00	 call	 PyThread_release_lock
$LN4@faulthandl@7:

; 573  :         Py_CLEAR(thread.file);

  00221	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR thread, 0
  00229	74 53		 je	 SHORT $LN1@faulthandl@7
  0022b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00233	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR thread
  0023a	41 b8 3d 02 00
	00		 mov	 r8d, 573		; 0000023dH
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@GIOANNFL@faulthandler_dump_traceback_late@
  0024e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00253	85 c0		 test	 eax, eax
  00255	75 27		 jne	 SHORT $LN1@faulthandl@7
  00257	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR thread
  0025e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR _py_tmp$20761[rsp], rax
  00266	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread, 0
  00271	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$20761[rsp]
  00279	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@faulthandl@7:
  0027e	33 c0		 xor	 eax, eax
  00280	85 c0		 test	 eax, eax
  00282	75 9d		 jne	 SHORT $LN4@faulthandl@7

; 574  :         free(header);

  00284	48 8b 4c 24 78	 mov	 rcx, QWORD PTR header$[rsp]
  00289	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 575  :         thread.header = NULL;

  0028f	48 c7 05 30 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread+48, 0

; 576  :         PyErr_SetString(PyExc_RuntimeError,
; 577  :                         "unable to start watchdog thread");

  0029a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@FONLKIBM@unable?5to?5start?5watchdog?5thread?$AA@
  002a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  002a8	e8 00 00 00 00	 call	 PyErr_SetString

; 578  :         return NULL;

  002ad	33 c0		 xor	 eax, eax
  002af	eb 13		 jmp	 SHORT $LN16@faulthandl@7
$LN5@faulthandl@7:

; 579  :     }
; 580  : 
; 581  :     Py_RETURN_NONE;

  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  002b8	e8 00 00 00 00	 call	 _Py_IncRef
  002bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN16@faulthandl@7:

; 582  : }

  002c4	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002cb	c3		 ret	 0
faulthandler_dump_traceback_later ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CM@EBDGFMIC@?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAL?$AAO?$AAC?$AAK?$AA_?$AAF?$AAA?$AAI?$AAL?$AAU?$AAR?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DE@FLEGGHO@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAf?$AAa?$AAu?$AAl?$AAt?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	__imp__exit:PROC
EXTRN	_PyThreadState_Current:QWORD
EXTRN	__imp__wassert:PROC
EXTRN	PyThread_acquire_lock_timed:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_thread DD imagerel faulthandler_thread
	DD	imagerel faulthandler_thread+251
	DD	imagerel $unwind$faulthandler_thread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_thread DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_1CM@EBDGFMIC@?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAL?$AAO?$AAC?$AAK?$AA_?$AAF?$AAA?$AAI?$AAL?$AAU?$AAR?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@EBDGFMIC@?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAL?$AAO?$AAC?$AAK?$AA_?$AAF?$AAA?$AAI?$AAL?$AAU?$AAR?$AAE?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'P', 00H
	DB	'Y', 00H, '_', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'K', 00H, '_'
	DB	00H, 'F', 00H, 'A', 00H, 'I', 00H, 'L', 00H, 'U', 00H, 'R', 00H
	DB	'E', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DE@FLEGGHO@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAf?$AAa?$AAu?$AAl?$AAt?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DE@FLEGGHO@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAf?$AAa?$AAu?$AAl?$AAt?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 'f', 00H, 'a', 00H, 'u'
	DB	00H, 'l', 00H, 't', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H
	DB	'l', 00H, 'e', 00H, 'r', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT faulthandler_thread
_TEXT	SEGMENT
current$ = 32
ok$ = 40
errmsg$ = 48
st$ = 56
tv83 = 60
unused$ = 80
faulthandler_thread PROC				; COMDAT

; 425  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN6@faulthandl@8:

; 426  :     PyLockStatus st;
; 427  :     const char* errmsg;
; 428  :     PyThreadState *current;
; 429  :     int ok;
; 430  : #if defined(HAVE_PTHREAD_SIGMASK) && !defined(HAVE_BROKEN_PTHREAD_SIGMASK)
; 431  :     sigset_t set;
; 432  : 
; 433  :     /* we don't want to receive any signal */
; 434  :     sigfillset(&set);
; 435  :     pthread_sigmask(SIG_SETMASK, &set, NULL);
; 436  : #endif
; 437  : 
; 438  :     do {
; 439  :         st = PyThread_acquire_lock_timed(thread.cancel_event,
; 440  :                                          thread.timeout_us, 0);

  00009	45 33 c0	 xor	 r8d, r8d
  0000c	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR thread+16
  00013	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  0001a	e8 00 00 00 00	 call	 PyThread_acquire_lock_timed
  0001f	89 44 24 38	 mov	 DWORD PTR st$[rsp], eax

; 441  :         if (st == PY_LOCK_ACQUIRED) {

  00023	83 7c 24 38 01	 cmp	 DWORD PTR st$[rsp], 1
  00028	75 11		 jne	 SHORT $LN3@faulthandl@8

; 442  :             PyThread_release_lock(thread.cancel_event);

  0002a	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  00031	e8 00 00 00 00	 call	 PyThread_release_lock

; 443  :             break;

  00036	e9 af 00 00 00	 jmp	 $LN4@faulthandl@8
$LN3@faulthandl@8:

; 444  :         }
; 445  :         /* Timeout => dump traceback */
; 446  :         assert(st == PY_LOCK_FAILURE);

  0003b	83 7c 24 38 00	 cmp	 DWORD PTR st$[rsp], 0
  00040	74 1c		 je	 SHORT $LN9@faulthandl@8
  00042	41 b8 be 01 00
	00		 mov	 r8d, 446		; 000001beH
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DE@FLEGGHO@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAf?$AAa?$AAu?$AAl?$AAt?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@EBDGFMIC@?$AAs?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAL?$AAO?$AAC?$AAK?$AA_?$AAF?$AAA?$AAI?$AAL?$AAU?$AAR?$AAE?$AA?$AA@
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005c	33 c0		 xor	 eax, eax
$LN9@faulthandl@8:

; 447  : 
; 448  :         /* get the thread holding the GIL, NULL if no thread hold the GIL */
; 449  :         current = _Py_atomic_load_relaxed(&_PyThreadState_Current);

  0005e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _PyThreadState_Current
  00065	48 89 44 24 20	 mov	 QWORD PTR current$[rsp], rax

; 450  : 
; 451  :         write(thread.fd, thread.header, thread.header_len);

  0006a	44 8b 05 38 00
	00 00		 mov	 r8d, DWORD PTR thread+56
  00071	48 8b 15 30 00
	00 00		 mov	 rdx, QWORD PTR thread+48
  00078	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR thread+8
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write

; 452  : 
; 453  :         errmsg = _Py_DumpTracebackThreads(thread.fd, thread.interp, current);

  00084	4c 8b 44 24 20	 mov	 r8, QWORD PTR current$[rsp]
  00089	48 8b 15 20 00
	00 00		 mov	 rdx, QWORD PTR thread+32
  00090	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR thread+8
  00096	e8 00 00 00 00	 call	 _Py_DumpTracebackThreads
  0009b	48 89 44 24 30	 mov	 QWORD PTR errmsg$[rsp], rax

; 454  :         ok = (errmsg == NULL);

  000a0	48 83 7c 24 30
	00		 cmp	 QWORD PTR errmsg$[rsp], 0
  000a6	75 0a		 jne	 SHORT $LN10@faulthandl@8
  000a8	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  000b0	eb 08		 jmp	 SHORT $LN11@faulthandl@8
$LN10@faulthandl@8:
  000b2	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN11@faulthandl@8:
  000ba	8b 44 24 3c	 mov	 eax, DWORD PTR tv83[rsp]
  000be	89 44 24 28	 mov	 DWORD PTR ok$[rsp], eax

; 455  : 
; 456  :         if (thread.exit)

  000c2	83 3d 28 00 00
	00 00		 cmp	 DWORD PTR thread+40, 0
  000c9	74 0b		 je	 SHORT $LN2@faulthandl@8

; 457  :             _exit(1);

  000cb	b9 01 00 00 00	 mov	 ecx, 1
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__exit
$LN2@faulthandl@8:

; 458  :     } while (ok && thread.repeat);

  000d6	83 7c 24 28 00	 cmp	 DWORD PTR ok$[rsp], 0
  000db	74 0d		 je	 SHORT $LN1@faulthandl@8
  000dd	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR thread+24, 0
  000e4	0f 85 1f ff ff
	ff		 jne	 $LN6@faulthandl@8
$LN1@faulthandl@8:
$LN4@faulthandl@8:

; 459  : 
; 460  :     /* The only way out */
; 461  :     PyThread_release_lock(thread.running);

  000ea	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  000f1	e8 00 00 00 00	 call	 PyThread_release_lock
$LN8@faulthandl@8:

; 462  : }

  000f6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fa	c3		 ret	 0
faulthandler_thread ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cancel_dump_traceback_later DD imagerel cancel_dump_traceback_later
	DD	imagerel cancel_dump_traceback_later+194
	DD	imagerel $unwind$cancel_dump_traceback_later
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cancel_dump_traceback_later DD 010401H
	DD	08204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT cancel_dump_traceback_later
_TEXT	SEGMENT
_py_tmp$20682 = 48
cancel_dump_traceback_later PROC			; COMDAT

; 466  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 467  :     /* Notify cancellation */
; 468  :     PyThread_release_lock(thread.cancel_event);

  00004	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  0000b	e8 00 00 00 00	 call	 PyThread_release_lock

; 469  : 
; 470  :     /* Wait for thread to join */
; 471  :     PyThread_acquire_lock(thread.running, 1);

  00010	ba 01 00 00 00	 mov	 edx, 1
  00015	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  0001c	e8 00 00 00 00	 call	 PyThread_acquire_lock

; 472  :     PyThread_release_lock(thread.running);

  00021	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  00028	e8 00 00 00 00	 call	 PyThread_release_lock

; 473  : 
; 474  :     /* The main thread should always hold the cancel_event lock */
; 475  :     PyThread_acquire_lock(thread.cancel_event, 1);

  0002d	ba 01 00 00 00	 mov	 edx, 1
  00032	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  00039	e8 00 00 00 00	 call	 PyThread_acquire_lock
$LN5@cancel_dum:

; 476  : 
; 477  :     Py_CLEAR(thread.file);

  0003e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR thread, 0
  00046	74 4d		 je	 SHORT $LN2@cancel_dum
  00048	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00050	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR thread
  00057	41 b8 dd 01 00
	00		 mov	 r8d, 477		; 000001ddH
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@JNJHDNLB@cancel_dump_traceback_later?$AA@
  0006b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00070	85 c0		 test	 eax, eax
  00072	75 21		 jne	 SHORT $LN2@cancel_dum
  00074	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR thread
  0007b	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$20682[rsp], rax
  00080	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread, 0
  0008b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$20682[rsp]
  00090	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@cancel_dum:
  00095	33 c0		 xor	 eax, eax
  00097	85 c0		 test	 eax, eax
  00099	75 a3		 jne	 SHORT $LN5@cancel_dum

; 478  :     if (thread.header) {

  0009b	48 83 3d 30 00
	00 00 00	 cmp	 QWORD PTR thread+48, 0
  000a3	74 18		 je	 SHORT $LN1@cancel_dum

; 479  :         free(thread.header);

  000a5	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR thread+48
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 480  :         thread.header = NULL;

  000b2	48 c7 05 30 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread+48, 0
$LN1@cancel_dum:

; 481  :     }
; 482  : }

  000bd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c1	c3		 ret	 0
cancel_dump_traceback_later ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@MEGKGBOF@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?$CJ?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@BADGOMOI@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?4?$CF06lu?$CJ?$CB@ ; `string'
EXTRN	__imp_strdup:PROC
EXTRN	PyOS_snprintf:PROC
EXTRN	__imp_modf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_timeout DD imagerel format_timeout
	DD	imagerel format_timeout+267
	DD	imagerel $unwind$format_timeout
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_timeout DD 020d01H
	DD	01d010dH
xdata	ENDS
;	COMDAT ??_C@_0BM@MEGKGBOF@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?$CJ?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BM@MEGKGBOF@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?$CJ?$CB?6?$AA@ DB 'T'
	DB	'imeout (%lu:%02lu:%02lu)!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@BADGOMOI@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?4?$CF06lu?$CJ?$CB@
CONST	SEGMENT
??_C@_0CC@BADGOMOI@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?4?$CF06lu?$CJ?$CB@ DB 'T'
	DB	'imeout (%lu:%02lu:%02lu.%06lu)!', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT format_timeout
_TEXT	SEGMENT
intpart$ = 64
min$ = 72
sec$ = 76
hour$ = 80
fracpart$ = 88
us$ = 96
buffer$ = 112
timeout$ = 240
format_timeout PROC					; COMDAT

; 486  : {

  00000	f2 0f 11 44 24
	08		 movsdx	 QWORD PTR [rsp+8], xmm0
  00006	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 487  :     unsigned long us, sec, min, hour;
; 488  :     double intpart, fracpart;
; 489  :     char buffer[100];
; 490  : 
; 491  :     fracpart = modf(timeout, &intpart);

  0000d	48 8d 54 24 40	 lea	 rdx, QWORD PTR intpart$[rsp]
  00012	f2 0f 10 84 24
	f0 00 00 00	 movsdx	 xmm0, QWORD PTR timeout$[rsp]
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_modf
  00021	f2 0f 11 44 24
	58		 movsdx	 QWORD PTR fracpart$[rsp], xmm0

; 492  :     sec = (unsigned long)intpart;

  00027	f2 48 0f 2c 44
	24 40		 cvttsd2si rax, QWORD PTR intpart$[rsp]
  0002e	89 44 24 4c	 mov	 DWORD PTR sec$[rsp], eax

; 493  :     us = (unsigned long)(fracpart * 1e6);

  00032	f2 0f 10 44 24
	58		 movsdx	 xmm0, QWORD PTR fracpart$[rsp]
  00038	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@412e848000000000
  00040	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  00045	89 44 24 60	 mov	 DWORD PTR us$[rsp], eax

; 494  :     min = sec / 60;

  00049	33 d2		 xor	 edx, edx
  0004b	8b 44 24 4c	 mov	 eax, DWORD PTR sec$[rsp]
  0004f	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00054	f7 f1		 div	 ecx
  00056	89 44 24 48	 mov	 DWORD PTR min$[rsp], eax

; 495  :     sec %= 60;

  0005a	33 d2		 xor	 edx, edx
  0005c	8b 44 24 4c	 mov	 eax, DWORD PTR sec$[rsp]
  00060	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00065	f7 f1		 div	 ecx
  00067	8b c2		 mov	 eax, edx
  00069	89 44 24 4c	 mov	 DWORD PTR sec$[rsp], eax

; 496  :     hour = min / 60;

  0006d	33 d2		 xor	 edx, edx
  0006f	8b 44 24 48	 mov	 eax, DWORD PTR min$[rsp]
  00073	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00078	f7 f1		 div	 ecx
  0007a	89 44 24 50	 mov	 DWORD PTR hour$[rsp], eax

; 497  :     min %= 60;

  0007e	33 d2		 xor	 edx, edx
  00080	8b 44 24 48	 mov	 eax, DWORD PTR min$[rsp]
  00084	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00089	f7 f1		 div	 ecx
  0008b	8b c2		 mov	 eax, edx
  0008d	89 44 24 48	 mov	 DWORD PTR min$[rsp], eax

; 498  : 
; 499  :     if (us != 0)

  00091	83 7c 24 60 00	 cmp	 DWORD PTR us$[rsp], 0
  00096	74 35		 je	 SHORT $LN2@format_tim

; 500  :         PyOS_snprintf(buffer, sizeof(buffer),
; 501  :                       "Timeout (%lu:%02lu:%02lu.%06lu)!\n",
; 502  :                       hour, min, sec, us);

  00098	8b 44 24 60	 mov	 eax, DWORD PTR us$[rsp]
  0009c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000a0	8b 44 24 4c	 mov	 eax, DWORD PTR sec$[rsp]
  000a4	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000a8	8b 44 24 48	 mov	 eax, DWORD PTR min$[rsp]
  000ac	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b0	44 8b 4c 24 50	 mov	 r9d, DWORD PTR hour$[rsp]
  000b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CC@BADGOMOI@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?4?$CF06lu?$CJ?$CB@
  000bc	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000c1	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buffer$[rsp]
  000c6	e8 00 00 00 00	 call	 PyOS_snprintf

; 503  :     else

  000cb	eb 2b		 jmp	 SHORT $LN1@format_tim
$LN2@format_tim:

; 504  :         PyOS_snprintf(buffer, sizeof(buffer),
; 505  :                       "Timeout (%lu:%02lu:%02lu)!\n",
; 506  :                       hour, min, sec);

  000cd	8b 44 24 4c	 mov	 eax, DWORD PTR sec$[rsp]
  000d1	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000d5	8b 44 24 48	 mov	 eax, DWORD PTR min$[rsp]
  000d9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000dd	44 8b 4c 24 50	 mov	 r9d, DWORD PTR hour$[rsp]
  000e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BM@MEGKGBOF@Timeout?5?$CI?$CFlu?3?$CF02lu?3?$CF02lu?$CJ?$CB?6?$AA@
  000e9	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  000ee	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buffer$[rsp]
  000f3	e8 00 00 00 00	 call	 PyOS_snprintf
$LN1@format_tim:

; 507  : 
; 508  :     return strdup(buffer);

  000f8	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buffer$[rsp]
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup

; 509  : }

  00103	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0010a	c3		 ret	 0
format_timeout ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_cancel_dump_traceback_later_py DD imagerel faulthandler_cancel_dump_traceback_later_py
	DD	imagerel faulthandler_cancel_dump_traceback_later_py+38
	DD	imagerel $unwind$faulthandler_cancel_dump_traceback_later_py
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_cancel_dump_traceback_later_py DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT faulthandler_cancel_dump_traceback_later_py
_TEXT	SEGMENT
self$ = 48
faulthandler_cancel_dump_traceback_later_py PROC	; COMDAT

; 586  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 587  :     cancel_dump_traceback_later();

  00009	e8 00 00 00 00	 call	 cancel_dump_traceback_later

; 588  :     Py_RETURN_NONE;

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00015	e8 00 00 00 00	 call	 _Py_IncRef
  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 589  : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
faulthandler_cancel_dump_traceback_later_py ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@PKKOOPLD@?$HMi?3_read_null?$AA@	; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	PyEval_RestoreThread:PROC
EXTRN	PyEval_SaveThread:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_read_null DD imagerel faulthandler_read_null
	DD	imagerel faulthandler_read_null+126
	DD	imagerel $unwind$faulthandler_read_null
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_read_null DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0O@PKKOOPLD@?$HMi?3_read_null?$AA@
CONST	SEGMENT
??_C@_0O@PKKOOPLD@?$HMi?3_read_null?$AA@ DB '|i:_read_null', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT faulthandler_read_null
_TEXT	SEGMENT
y$ = 32
x$ = 40
release_gil$ = 48
_save$20788 = 56
self$ = 80
args$ = 88
faulthandler_read_null PROC				; COMDAT

; 802  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 803  :     volatile int *x;
; 804  :     volatile int y;
; 805  :     int release_gil = 0;

  0000e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR release_gil$[rsp], 0

; 806  :     if (!PyArg_ParseTuple(args, "|i:_read_null", &release_gil))

  00016	4c 8d 44 24 30	 lea	 r8, QWORD PTR release_gil$[rsp]
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@PKKOOPLD@?$HMi?3_read_null?$AA@
  00022	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00027	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002c	85 c0		 test	 eax, eax
  0002e	75 04		 jne	 SHORT $LN3@faulthandl@9

; 807  :         return NULL;

  00030	33 c0		 xor	 eax, eax
  00032	eb 45		 jmp	 SHORT $LN4@faulthandl@9
$LN3@faulthandl@9:

; 808  : 
; 809  :     x = NULL;

  00034	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 810  :     if (release_gil) {

  0003d	83 7c 24 30 00	 cmp	 DWORD PTR release_gil$[rsp], 0
  00042	74 21		 je	 SHORT $LN2@faulthandl@9

; 811  :         Py_BEGIN_ALLOW_THREADS

  00044	e8 00 00 00 00	 call	 PyEval_SaveThread
  00049	48 89 44 24 38	 mov	 QWORD PTR _save$20788[rsp], rax

; 812  :         y = *x;

  0004e	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  00053	8b 00		 mov	 eax, DWORD PTR [rax]
  00055	89 44 24 20	 mov	 DWORD PTR y$[rsp], eax

; 813  :         Py_END_ALLOW_THREADS

  00059	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _save$20788[rsp]
  0005e	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 814  :     } else

  00063	eb 0b		 jmp	 SHORT $LN1@faulthandl@9
$LN2@faulthandl@9:

; 815  :         y = *x;

  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR x$[rsp]
  0006a	8b 00		 mov	 eax, DWORD PTR [rax]
  0006c	89 44 24 20	 mov	 DWORD PTR y$[rsp], eax
$LN1@faulthandl@9:

; 816  :     return PyLong_FromLong(y);

  00070	8b 4c 24 20	 mov	 ecx, DWORD PTR y$[rsp]
  00074	e8 00 00 00 00	 call	 PyLong_FromLong
$LN4@faulthandl@9:

; 817  : 
; 818  : }

  00079	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007d	c3		 ret	 0
faulthandler_read_null ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_sigsegv DD imagerel faulthandler_sigsegv
	DD	imagerel faulthandler_sigsegv+58
	DD	imagerel $unwind$faulthandler_sigsegv
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_sigsegv DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT faulthandler_sigsegv
_TEXT	SEGMENT
self$ = 48
args$ = 56
faulthandler_sigsegv PROC				; COMDAT

; 822  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN2@faulthandl@10:

; 823  : #if defined(MS_WINDOWS)
; 824  :     /* For SIGSEGV, faulthandler_fatal_error() restores the previous signal
; 825  :        handler and then gives back the execution flow to the program (without
; 826  :        explicitly calling the previous error handler). In a normal case, the
; 827  :        SIGSEGV was raised by the kernel because of a fault, and so if the
; 828  :        program retries to execute the same instruction, the fault will be
; 829  :        raised again.
; 830  : 
; 831  :        Here the fault is simulated by a fake SIGSEGV signal raised by the
; 832  :        application. We have to raise SIGSEGV at lease twice: once for
; 833  :        faulthandler_fatal_error(), and one more time for the previous signal
; 834  :        handler. */
; 835  :     while(1)

  0000e	33 c0		 xor	 eax, eax
  00010	83 f8 01	 cmp	 eax, 1
  00013	74 0d		 je	 SHORT $LN1@faulthandl@10

; 836  :         raise(SIGSEGV);

  00015	b9 0b 00 00 00	 mov	 ecx, 11
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_raise
  00020	eb ec		 jmp	 SHORT $LN2@faulthandl@10
$LN1@faulthandl@10:

; 837  : #else
; 838  :     raise(SIGSEGV);
; 839  : #endif
; 840  :     Py_RETURN_NONE;

  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00029	e8 00 00 00 00	 call	 _Py_IncRef
  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 841  : }

  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
faulthandler_sigsegv ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_sigfpe DD imagerel faulthandler_sigfpe
	DD	imagerel faulthandler_sigfpe+70
	DD	imagerel $unwind$faulthandler_sigfpe
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_sigfpe DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT faulthandler_sigfpe
_TEXT	SEGMENT
y$ = 32
x$ = 36
z$ = 40
self$ = 64
args$ = 72
faulthandler_sigfpe PROC				; COMDAT

; 845  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 846  :     /* Do an integer division by zero: raise a SIGFPE on Intel CPU, but not on
; 847  :        PowerPC. Use volatile to disable compile-time optimizations. */
; 848  :     volatile int x = 1, y = 0, z;

  0000e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR x$[rsp], 1
  00016	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR y$[rsp], 0

; 849  :     z = x / y;

  0001e	8b 44 24 24	 mov	 eax, DWORD PTR x$[rsp]
  00022	8b 4c 24 20	 mov	 ecx, DWORD PTR y$[rsp]
  00026	99		 cdq
  00027	f7 f9		 idiv	 ecx
  00029	89 44 24 28	 mov	 DWORD PTR z$[rsp], eax

; 850  :     /* If the division by zero didn't raise a SIGFPE (e.g. on PowerPC),
; 851  :        raise it manually. */
; 852  :     raise(SIGFPE);

  0002d	b9 08 00 00 00	 mov	 ecx, 8
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_raise

; 853  :     /* This line is never reached, but we pretend to make something with z
; 854  :        to silence a compiler warning. */
; 855  :     return PyLong_FromLong(z);

  00038	8b 4c 24 28	 mov	 ecx, DWORD PTR z$[rsp]
  0003c	e8 00 00 00 00	 call	 PyLong_FromLong

; 856  : }

  00041	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00045	c3		 ret	 0
faulthandler_sigfpe ENDP
_TEXT	ENDS
EXTRN	__imp_abort:PROC
EXTRN	__imp__set_abort_behavior:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_sigabrt DD imagerel faulthandler_sigabrt
	DD	imagerel faulthandler_sigabrt+57
	DD	imagerel $unwind$faulthandler_sigabrt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_sigabrt DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT faulthandler_sigabrt
_TEXT	SEGMENT
self$ = 48
args$ = 56
faulthandler_sigabrt PROC				; COMDAT

; 860  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 861  : #ifdef _MSC_VER
; 862  :     /* Visual Studio: configure abort() to not display an error message nor
; 863  :        open a popup asking to report the fault. */
; 864  :     _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);

  0000e	ba 03 00 00 00	 mov	 edx, 3
  00013	33 c9		 xor	 ecx, ecx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__set_abort_behavior

; 865  : #endif
; 866  :     abort();

  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_abort

; 867  :     Py_RETURN_NONE;

  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00028	e8 00 00 00 00	 call	 _Py_IncRef
  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 868  : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
faulthandler_sigabrt ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_sigill DD imagerel faulthandler_sigill
	DD	imagerel faulthandler_sigill+49
	DD	imagerel $unwind$faulthandler_sigill
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_sigill DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT faulthandler_sigill
_TEXT	SEGMENT
self$ = 48
args$ = 56
faulthandler_sigill PROC				; COMDAT

; 882  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 883  :     raise(SIGILL);

  0000e	b9 04 00 00 00	 mov	 ecx, 4
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_raise

; 884  :     Py_RETURN_NONE;

  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00020	e8 00 00 00 00	 call	 _Py_IncRef
  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 885  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
faulthandler_sigill ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@KDJCIPLD@y?3fatal_error?$AA@		; `string'
EXTRN	Py_FatalError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_fatal_error_py DD imagerel faulthandler_fatal_error_py
	DD	imagerel faulthandler_fatal_error_py+78
	DD	imagerel $unwind$faulthandler_fatal_error_py
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_fatal_error_py DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0O@KDJCIPLD@y?3fatal_error?$AA@
CONST	SEGMENT
??_C@_0O@KDJCIPLD@y?3fatal_error?$AA@ DB 'y:fatal_error', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT faulthandler_fatal_error_py
_TEXT	SEGMENT
message$ = 32
self$ = 64
args$ = 72
faulthandler_fatal_error_py PROC			; COMDAT

; 890  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 891  :     char *message;
; 892  :     if (!PyArg_ParseTuple(args, "y:fatal_error", &message))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR message$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@KDJCIPLD@y?3fatal_error?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN1@faulthandl@11

; 893  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 1d		 jmp	 SHORT $LN2@faulthandl@11
$LN1@faulthandl@11:

; 894  :     Py_FatalError(message);

  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR message$[rsp]
  00031	e8 00 00 00 00	 call	 Py_FatalError

; 895  :     Py_RETURN_NONE;

  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0003d	e8 00 00 00 00	 call	 _Py_IncRef
  00042	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@faulthandl@11:

; 896  : }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
faulthandler_fatal_error_py ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@KJJIGPAO@faulthandler_traverse?$AA@	; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_traverse DD imagerel faulthandler_traverse
	DD	imagerel faulthandler_traverse+198
	DD	imagerel $unwind$faulthandler_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BG@KJJIGPAO@faulthandler_traverse?$AA@
CONST	SEGMENT
??_C@_0BG@KJJIGPAO@faulthandler_traverse?$AA@ DB 'faulthandler_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT faulthandler_traverse
_TEXT	SEGMENT
vret$20848 = 32
vret$20856 = 36
module$ = 64
visit$ = 72
arg$ = 80
faulthandler_traverse PROC				; COMDAT

; 938  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@faulthandl@12:

; 939  : #ifdef FAULTHANDLER_USER
; 940  :     unsigned int signum;
; 941  : #endif
; 942  : 
; 943  : #ifdef FAULTHANDLER_LATER
; 944  :     Py_VISIT(thread.file);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@faulthandl@12
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 b0 03 00
	00		 mov	 r8d, 944		; 000003b0H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@KJJIGPAO@faulthandler_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@faulthandl@12:
  00038	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR thread, 0
  00040	74 21		 je	 SHORT $LN8@faulthandl@12
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR thread
  0004e	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00052	89 44 24 20	 mov	 DWORD PTR vret$20848[rsp], eax
  00056	83 7c 24 20 00	 cmp	 DWORD PTR vret$20848[rsp], 0
  0005b	74 06		 je	 SHORT $LN7@faulthandl@12
  0005d	8b 44 24 20	 mov	 eax, DWORD PTR vret$20848[rsp]
  00061	eb 5e		 jmp	 SHORT $LN13@faulthandl@12
$LN7@faulthandl@12:
$LN8@faulthandl@12:
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 aa		 jne	 SHORT $LN12@faulthandl@12
$LN6@faulthandl@12:

; 945  : #endif
; 946  : #ifdef FAULTHANDLER_USER
; 947  :     if (user_signals != NULL) {
; 948  :         for (signum=0; signum < NSIG; signum++)
; 949  :             Py_VISIT(user_signals[signum].file);
; 950  :     }
; 951  : #endif
; 952  :     Py_VISIT(fatal_error.file);

  00069	e8 00 00 00 00	 call	 _Py_PXCTX
  0006e	85 c0		 test	 eax, eax
  00070	74 1c		 je	 SHORT $LN3@faulthandl@12
  00072	45 33 c9	 xor	 r9d, r9d
  00075	41 b8 b8 03 00
	00		 mov	 r8d, 952		; 000003b8H
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PANCFCHK@?4?4?2Modules?2faulthandler?4c?$AA@
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@KJJIGPAO@faulthandler_traverse?$AA@
  00089	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@faulthandl@12:
  0008e	48 83 3d 08 00
	00 00 00	 cmp	 QWORD PTR fatal_error+8, 0
  00096	74 21		 je	 SHORT $LN2@faulthandl@12
  00098	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  0009d	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR fatal_error+8
  000a4	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000a8	89 44 24 24	 mov	 DWORD PTR vret$20856[rsp], eax
  000ac	83 7c 24 24 00	 cmp	 DWORD PTR vret$20856[rsp], 0
  000b1	74 06		 je	 SHORT $LN1@faulthandl@12
  000b3	8b 44 24 24	 mov	 eax, DWORD PTR vret$20856[rsp]
  000b7	eb 08		 jmp	 SHORT $LN13@faulthandl@12
$LN1@faulthandl@12:
$LN2@faulthandl@12:
  000b9	33 c0		 xor	 eax, eax
  000bb	85 c0		 test	 eax, eax
  000bd	75 aa		 jne	 SHORT $LN6@faulthandl@12

; 953  :     return 0;

  000bf	33 c0		 xor	 eax, eax
$LN13@faulthandl@12:

; 954  : }

  000c1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c5	c3		 ret	 0
faulthandler_traverse ENDP
_TEXT	ENDS
PUBLIC	PyInit_faulthandler
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_faulthandler DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$PyInit_faulthandler
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_faulthandler DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyInit_faulthandler
_TEXT	SEGMENT
PyInit_faulthandler PROC				; COMDAT

; 1039 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1040 :     return PyModule_Create(&module_def);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:module_def
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs

; 1041 : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
PyInit_faulthandler ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@GNBCPOLG@could?5not?5allocate?5locks?5for?5fau@ ; `string'
PUBLIC	_PyFaulthandler_Init
EXTRN	PyThread_allocate_lock:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFaulthandler_Init DD imagerel $LN5
	DD	imagerel $LN5+112
	DD	imagerel $unwind$_PyFaulthandler_Init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFaulthandler_Init DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CK@GNBCPOLG@could?5not?5allocate?5locks?5for?5fau@
CONST	SEGMENT
??_C@_0CK@GNBCPOLG@could?5not?5allocate?5locks?5for?5fau@ DB 'could not a'
	DB	'llocate locks for faulthandler', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyFaulthandler_Init
_TEXT	SEGMENT
_PyFaulthandler_Init PROC				; COMDAT

; 1082 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1083 : #ifdef HAVE_SIGALTSTACK
; 1084 :     int err;
; 1085 : 
; 1086 :     /* Try to allocate an alternate stack for faulthandler() signal handler to
; 1087 :      * be able to allocate memory on the stack, even on a stack overflow. If it
; 1088 :      * fails, ignore the error. */
; 1089 :     stack.ss_flags = 0;
; 1090 :     stack.ss_size = SIGSTKSZ;
; 1091 :     stack.ss_sp = PyMem_Malloc(stack.ss_size);
; 1092 :     if (stack.ss_sp != NULL) {
; 1093 :         err = sigaltstack(&stack, NULL);
; 1094 :         if (err) {
; 1095 :             PyMem_Free(stack.ss_sp);
; 1096 :             stack.ss_sp = NULL;
; 1097 :         }
; 1098 :     }
; 1099 : #endif
; 1100 : #ifdef FAULTHANDLER_LATER
; 1101 :     thread.file = NULL;

  00004	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread, 0

; 1102 :     thread.cancel_event = PyThread_allocate_lock();

  0000f	e8 00 00 00 00	 call	 PyThread_allocate_lock
  00014	48 89 05 40 00
	00 00		 mov	 QWORD PTR thread+64, rax

; 1103 :     thread.running = PyThread_allocate_lock();

  0001b	e8 00 00 00 00	 call	 PyThread_allocate_lock
  00020	48 89 05 48 00
	00 00		 mov	 QWORD PTR thread+72, rax

; 1104 :     if (!thread.cancel_event || !thread.running) {

  00027	48 83 3d 40 00
	00 00 00	 cmp	 QWORD PTR thread+64, 0
  0002f	74 0a		 je	 SHORT $LN1@PyFaulthan
  00031	48 83 3d 48 00
	00 00 00	 cmp	 QWORD PTR thread+72, 0
  00039	75 1a		 jne	 SHORT $LN2@PyFaulthan
$LN1@PyFaulthan:

; 1105 :         PyErr_SetString(PyExc_RuntimeError,
; 1106 :                         "could not allocate locks for faulthandler");

  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@GNBCPOLG@could?5not?5allocate?5locks?5for?5fau@
  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00049	e8 00 00 00 00	 call	 PyErr_SetString

; 1107 :         return -1;

  0004e	b8 ff ff ff ff	 mov	 eax, -1
  00053	eb 16		 jmp	 SHORT $LN3@PyFaulthan
$LN2@PyFaulthan:

; 1108 :     }
; 1109 :     PyThread_acquire_lock(thread.cancel_event, 1);

  00055	ba 01 00 00 00	 mov	 edx, 1
  0005a	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  00061	e8 00 00 00 00	 call	 PyThread_acquire_lock

; 1110 : #endif
; 1111 : 
; 1112 :     return faulthandler_env_options();

  00066	e8 00 00 00 00	 call	 faulthandler_env_options
$LN3@PyFaulthan:

; 1113 : }

  0006b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006f	c3		 ret	 0
_PyFaulthandler_Init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@NMPHOLOG@PYTHONFAULTHANDLER?$AA@	; `string'
EXTRN	PyImport_ImportModule:PROC
EXTRN	PyDict_Contains:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	PySys_GetXOptions:PROC
EXTRN	__imp_getenv:PROC
EXTRN	Py_IgnoreEnvironmentFlag:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$faulthandler_env_options DD imagerel faulthandler_env_options
	DD	imagerel faulthandler_env_options+278
	DD	imagerel $unwind$faulthandler_env_options
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$faulthandler_env_options DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0BD@NMPHOLOG@PYTHONFAULTHANDLER?$AA@
CONST	SEGMENT
??_C@_0BD@NMPHOLOG@PYTHONFAULTHANDLER?$AA@ DB 'PYTHONFAULTHANDLER', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT faulthandler_env_options
_TEXT	SEGMENT
res$ = 32
xoptions$ = 40
key$ = 48
module$ = 56
has_key$20929 = 64
tv67 = 72
faulthandler_env_options PROC				; COMDAT

; 1048 : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1049 :     PyObject *xoptions, *key, *module, *res;
; 1050 :     _Py_IDENTIFIER(enable);
; 1051 : 
; 1052 :     if (!Py_GETENV("PYTHONFAULTHANDLER")) {

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  0000b	74 0b		 je	 SHORT $LN9@faulthandl@13
  0000d	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv67[rsp], 0
  00016	eb 12		 jmp	 SHORT $LN10@faulthandl@13
$LN9@faulthandl@13:
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@NMPHOLOG@PYTHONFAULTHANDLER?$AA@
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  00025	48 89 44 24 48	 mov	 QWORD PTR tv67[rsp], rax
$LN10@faulthandl@13:
  0002a	48 83 7c 24 48
	00		 cmp	 QWORD PTR tv67[rsp], 0
  00030	75 67		 jne	 SHORT $LN6@faulthandl@13

; 1053 :         int has_key;
; 1054 : 
; 1055 :         xoptions = PySys_GetXOptions();

  00032	e8 00 00 00 00	 call	 PySys_GetXOptions
  00037	48 89 44 24 28	 mov	 QWORD PTR xoptions$[rsp], rax

; 1056 :         if (xoptions == NULL)

  0003c	48 83 7c 24 28
	00		 cmp	 QWORD PTR xoptions$[rsp], 0
  00042	75 0a		 jne	 SHORT $LN5@faulthandl@13

; 1057 :             return -1;

  00044	b8 ff ff ff ff	 mov	 eax, -1
  00049	e9 c3 00 00 00	 jmp	 $LN7@faulthandl@13
$LN5@faulthandl@13:

; 1058 : 
; 1059 :         key = PyUnicode_FromString("faulthandler");

  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FGONANPD@faulthandler?$AA@
  00055	e8 00 00 00 00	 call	 PyUnicode_FromString
  0005a	48 89 44 24 30	 mov	 QWORD PTR key$[rsp], rax

; 1060 :         if (key == NULL)

  0005f	48 83 7c 24 30
	00		 cmp	 QWORD PTR key$[rsp], 0
  00065	75 0a		 jne	 SHORT $LN4@faulthandl@13

; 1061 :             return -1;

  00067	b8 ff ff ff ff	 mov	 eax, -1
  0006c	e9 a0 00 00 00	 jmp	 $LN7@faulthandl@13
$LN4@faulthandl@13:

; 1062 : 
; 1063 :         has_key = PyDict_Contains(xoptions, key);

  00071	48 8b 54 24 30	 mov	 rdx, QWORD PTR key$[rsp]
  00076	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xoptions$[rsp]
  0007b	e8 00 00 00 00	 call	 PyDict_Contains
  00080	89 44 24 40	 mov	 DWORD PTR has_key$20929[rsp], eax

; 1064 :         Py_DECREF(key);

  00084	48 8b 4c 24 30	 mov	 rcx, QWORD PTR key$[rsp]
  00089	e8 00 00 00 00	 call	 _Py_DecRef

; 1065 :         if (!has_key)

  0008e	83 7c 24 40 00	 cmp	 DWORD PTR has_key$20929[rsp], 0
  00093	75 04		 jne	 SHORT $LN3@faulthandl@13

; 1066 :             return 0;

  00095	33 c0		 xor	 eax, eax
  00097	eb 78		 jmp	 SHORT $LN7@faulthandl@13
$LN3@faulthandl@13:
$LN6@faulthandl@13:

; 1067 :     }
; 1068 : 
; 1069 :     module = PyImport_ImportModule("faulthandler");

  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FGONANPD@faulthandler?$AA@
  000a0	e8 00 00 00 00	 call	 PyImport_ImportModule
  000a5	48 89 44 24 38	 mov	 QWORD PTR module$[rsp], rax

; 1070 :     if (module == NULL) {

  000aa	48 83 7c 24 38
	00		 cmp	 QWORD PTR module$[rsp], 0
  000b0	75 07		 jne	 SHORT $LN2@faulthandl@13

; 1071 :         return -1;

  000b2	b8 ff ff ff ff	 mov	 eax, -1
  000b7	eb 58		 jmp	 SHORT $LN7@faulthandl@13
$LN2@faulthandl@13:

; 1072 :     }
; 1073 :     res = _PyObject_CallMethodId(module, &PyId_enable, "");

  000b9	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_enable@?1??faulthandler_env_options@@9@9
  000be	8b c0		 mov	 eax, eax
  000c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000c6	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000cf	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000d3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000da	48 8b d0	 mov	 rdx, rax
  000dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR module$[rsp]
  000e2	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  000e7	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 1074 :     Py_DECREF(module);

  000ec	48 8b 4c 24 38	 mov	 rcx, QWORD PTR module$[rsp]
  000f1	e8 00 00 00 00	 call	 _Py_DecRef

; 1075 :     if (res == NULL)

  000f6	48 83 7c 24 20
	00		 cmp	 QWORD PTR res$[rsp], 0
  000fc	75 07		 jne	 SHORT $LN1@faulthandl@13

; 1076 :         return -1;

  000fe	b8 ff ff ff ff	 mov	 eax, -1
  00103	eb 0c		 jmp	 SHORT $LN7@faulthandl@13
$LN1@faulthandl@13:

; 1077 :     Py_DECREF(res);

  00105	48 8b 4c 24 20	 mov	 rcx, QWORD PTR res$[rsp]
  0010a	e8 00 00 00 00	 call	 _Py_DecRef

; 1078 :     return 0;

  0010f	33 c0		 xor	 eax, eax
$LN7@faulthandl@13:

; 1079 : }

  00111	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00115	c3		 ret	 0
faulthandler_env_options ENDP
_TEXT	ENDS
PUBLIC	_PyFaulthandler_Fini
EXTRN	PyThread_free_lock:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyFaulthandler_Fini DD imagerel $LN5
	DD	imagerel $LN5+97
	DD	imagerel $unwind$_PyFaulthandler_Fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyFaulthandler_Fini DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyFaulthandler_Fini
_TEXT	SEGMENT
_PyFaulthandler_Fini PROC				; COMDAT

; 1116 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1117 : #ifdef FAULTHANDLER_USER
; 1118 :     unsigned int signum;
; 1119 : #endif
; 1120 : 
; 1121 : #ifdef FAULTHANDLER_LATER
; 1122 :     /* later */
; 1123 :     if (thread.cancel_event) {

  00004	48 83 3d 40 00
	00 00 00	 cmp	 QWORD PTR thread+64, 0
  0000c	74 28		 je	 SHORT $LN2@PyFaulthan@2

; 1124 :         cancel_dump_traceback_later();

  0000e	e8 00 00 00 00	 call	 cancel_dump_traceback_later

; 1125 :         PyThread_release_lock(thread.cancel_event);

  00013	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  0001a	e8 00 00 00 00	 call	 PyThread_release_lock

; 1126 :         PyThread_free_lock(thread.cancel_event);

  0001f	48 8b 0d 40 00
	00 00		 mov	 rcx, QWORD PTR thread+64
  00026	e8 00 00 00 00	 call	 PyThread_free_lock

; 1127 :         thread.cancel_event = NULL;

  0002b	48 c7 05 40 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread+64, 0
$LN2@PyFaulthan@2:

; 1128 :     }
; 1129 :     if (thread.running) {

  00036	48 83 3d 48 00
	00 00 00	 cmp	 QWORD PTR thread+72, 0
  0003e	74 17		 je	 SHORT $LN1@PyFaulthan@2

; 1130 :         PyThread_free_lock(thread.running);

  00040	48 8b 0d 48 00
	00 00		 mov	 rcx, QWORD PTR thread+72
  00047	e8 00 00 00 00	 call	 PyThread_free_lock

; 1131 :         thread.running = NULL;

  0004c	48 c7 05 48 00
	00 00 00 00 00
	00		 mov	 QWORD PTR thread+72, 0
$LN1@PyFaulthan@2:

; 1132 :     }
; 1133 : #endif
; 1134 : 
; 1135 : #ifdef FAULTHANDLER_USER
; 1136 :     /* user */
; 1137 :     if (user_signals != NULL) {
; 1138 :         for (signum=0; signum < NSIG; signum++)
; 1139 :             faulthandler_unregister(&user_signals[signum], signum);
; 1140 :         free(user_signals);
; 1141 :         user_signals = NULL;
; 1142 :     }
; 1143 : #endif
; 1144 : 
; 1145 :     /* fatal */
; 1146 :     faulthandler_disable();

  00057	e8 00 00 00 00	 call	 faulthandler_disable

; 1147 : #ifdef HAVE_SIGALTSTACK
; 1148 :     if (stack.ss_sp != NULL) {
; 1149 :         PyMem_Free(stack.ss_sp);
; 1150 :         stack.ss_sp = NULL;
; 1151 :     }
; 1152 : #endif
; 1153 : }

  0005c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00060	c3		 ret	 0
_PyFaulthandler_Fini ENDP
_TEXT	ENDS
END
