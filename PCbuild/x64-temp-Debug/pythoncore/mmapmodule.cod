; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04PHBJEMCB@mmap?$AA@			; `string'
PUBLIC	??_C@_06KLHHMIGM@offset?$AA@			; `string'
PUBLIC	??_C@_06EBPNOMLE@access?$AA@			; `string'
PUBLIC	??_C@_07HHOKFJJE@tagname?$AA@			; `string'
PUBLIC	??_C@_06IJDLPEM@length?$AA@			; `string'
PUBLIC	??_C@_06FFBIALPD@fileno?$AA@			; `string'
PUBLIC	??_C@_09JGALCODB@mmap?4mmap?$AA@		; `string'
PUBLIC	??_C@_06IKJOPBFO@closed?$AA@			; `string'
PUBLIC	??_C@_08CMFIGCJD@__exit__?$AA@			; `string'
PUBLIC	??_C@_09OAJHKKGH@__enter__?$AA@			; `string'
PUBLIC	??_C@_0L@PDOGLJGG@write_byte?$AA@		; `string'
PUBLIC	??_C@_05NGFEDHGN@write?$AA@			; `string'
PUBLIC	??_C@_04LBPCFPDD@tell?$AA@			; `string'
PUBLIC	??_C@_04IAGNFIBA@size?$AA@			; `string'
PUBLIC	??_C@_04EDECCOGL@seek?$AA@			; `string'
PUBLIC	??_C@_06PIONCPJI@resize?$AA@			; `string'
PUBLIC	??_C@_08KBCDPPMN@readline?$AA@			; `string'
PUBLIC	??_C@_09NIOKOAGD@read_byte?$AA@			; `string'
PUBLIC	??_C@_04POLDLDMI@read?$AA@			; `string'
PUBLIC	??_C@_04HDMMNHEL@move?$AA@			; `string'
PUBLIC	??_C@_05GLCAEPFP@flush?$AA@			; `string'
PUBLIC	??_C@_05BLFDIAHL@rfind?$AA@			; `string'
PUBLIC	??_C@_04CKFJHKAP@find?$AA@			; `string'
PUBLIC	??_C@_05LBOHBHFK@close?$AA@			; `string'
EXTRN	_PyObject_DebugFree:PROC
EXTRN	PyType_GenericAlloc:PROC
EXTRN	PyObject_GenericGetAttr:PROC
;	COMDAT ??_C@_04PHBJEMCB@mmap?$AA@
CONST	SEGMENT
??_C@_04PHBJEMCB@mmap?$AA@ DB 'mmap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KLHHMIGM@offset?$AA@
CONST	SEGMENT
??_C@_06KLHHMIGM@offset?$AA@ DB 'offset', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EBPNOMLE@access?$AA@
CONST	SEGMENT
??_C@_06EBPNOMLE@access?$AA@ DB 'access', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HHOKFJJE@tagname?$AA@
CONST	SEGMENT
??_C@_07HHOKFJJE@tagname?$AA@ DB 'tagname', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJDLPEM@length?$AA@
CONST	SEGMENT
??_C@_06IJDLPEM@length?$AA@ DB 'length', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FFBIALPD@fileno?$AA@
CONST	SEGMENT
??_C@_06FFBIALPD@fileno?$AA@ DB 'fileno', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09JGALCODB@mmap?4mmap?$AA@
CONST	SEGMENT
??_C@_09JGALCODB@mmap?4mmap?$AA@ DB 'mmap.mmap', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJOPBFO@closed?$AA@
CONST	SEGMENT
??_C@_06IKJOPBFO@closed?$AA@ DB 'closed', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
mmap_object_methods DQ FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	FLAT:mmap_close_method
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_04CKFJHKAP@find?$AA@
	DQ	FLAT:mmap_find_method
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05BLFDIAHL@rfind?$AA@
	DQ	FLAT:mmap_rfind_method
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05GLCAEPFP@flush?$AA@
	DQ	FLAT:mmap_flush_method
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_04HDMMNHEL@move?$AA@
	DQ	FLAT:mmap_move_method
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_04POLDLDMI@read?$AA@
	DQ	FLAT:mmap_read_method
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_09NIOKOAGD@read_byte?$AA@
	DQ	FLAT:mmap_read_byte_method
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08KBCDPPMN@readline?$AA@
	DQ	FLAT:mmap_read_line_method
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06PIONCPJI@resize?$AA@
	DQ	FLAT:mmap_resize_method
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_04EDECCOGL@seek?$AA@
	DQ	FLAT:mmap_seek_method
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_04IAGNFIBA@size?$AA@
	DQ	FLAT:mmap_size_method
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_04LBPCFPDD@tell?$AA@
	DQ	FLAT:mmap_tell_method
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05NGFEDHGN@write?$AA@
	DQ	FLAT:mmap_write_method
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0L@PDOGLJGG@write_byte?$AA@
	DQ	FLAT:mmap_write_byte_method
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_09OAJHKKGH@__enter__?$AA@
	DQ	FLAT:mmap__enter__method
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08CMFIGCJD@__exit__?$AA@
	DQ	FLAT:mmap__exit__method
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
mmap_object_getset DQ FLAT:??_C@_06IKJOPBFO@closed?$AA@
	DQ	FLAT:mmap_closed_get
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
mmap_as_sequence DQ FLAT:mmap_length
	DQ	FLAT:mmap_concat
	DQ	FLAT:mmap_repeat
	DQ	FLAT:mmap_item
	DQ	0000000000000000H
	DQ	FLAT:mmap_ass_item
	DQ	0000000000000000H
	ORG $+24
mmap_as_mapping DQ FLAT:mmap_length
	DQ	FLAT:mmap_subscript
	DQ	FLAT:mmap_ass_subscript
mmap_as_buffer DQ FLAT:mmap_buffer_getbuf
	DQ	FLAT:mmap_buffer_releasebuf
	ORG $+8
mmap_doc DB	'Windows: mmap(fileno, length[, tagname[, access[, offset'
	DB	']]])', 0aH, 0aH, 'Maps length bytes from the file specified b'
	DB	'y the file handle fileno,', 0aH, 'and returns a mmap object. '
	DB	' If length is larger than the current size', 0aH, 'of the fil'
	DB	'e, the file is extended to contain length bytes.  If length', 0aH
	DB	'is 0, the maximum length of the map is the current size of th'
	DB	'e file,', 0aH, 'except that if the file is empty Windows rais'
	DB	'es an exception (you cannot', 0aH, 'create an empty mapping o'
	DB	'n Windows).', 0aH, 0aH, 'Unix: mmap(fileno, length[, flags[, '
	DB	'prot[, access[, offset]]]])', 0aH, 0aH, 'Maps length bytes fr'
	DB	'om the file specified by the file descriptor fileno,', 0aH, 'a'
	DB	'nd returns a mmap object.  If length is 0, the maximum length'
	DB	' of the map', 0aH, 'will be the current size of the file when'
	DB	' mmap is called.', 0aH, 'flags specifies the nature of the ma'
	DB	'pping. MAP_PRIVATE creates a', 0aH, 'private copy-on-write ma'
	DB	'pping, so changes to the contents of the mmap', 0aH, 'object '
	DB	'will be private to this process, and MAP_SHARED creates a map'
	DB	'ping', 0aH, 'that''s shared with all other processes mapping '
	DB	'the same areas of the file.', 0aH, 'The default value is MAP_'
	DB	'SHARED.', 0aH, 0aH, 'To map anonymous memory, pass -1 as the '
	DB	'fileno (both versions).', 00H
	ORG $+2
mmap_object_type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_09JGALCODB@mmap?4mmap?$AA@
	DQ	00000000000000b0H
	DQ	0000000000000000H
	DQ	FLAT:mmap_object_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:mmap_as_sequence
	DQ	FLAT:mmap_as_mapping
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	FLAT:mmap_as_buffer
	DD	040400H
	ORG $+4
	DQ	FLAT:mmap_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:mmap_object_methods
	DQ	0000000000000000H
	DQ	FLAT:mmap_object_getset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyType_GenericAlloc
	DQ	FLAT:new_mmap_object
	DQ	FLAT:_PyObject_DebugFree
	ORG $+64
?keywords@?1??new_mmap_object@@9@9 DQ FLAT:??_C@_06FFBIALPD@fileno?$AA@ ; `new_mmap_object'::`2'::keywords
	DQ	FLAT:??_C@_06IJDLPEM@length?$AA@
	DQ	FLAT:??_C@_07HHOKFJJE@tagname?$AA@
	DQ	FLAT:??_C@_06EBPNOMLE@access?$AA@
	DQ	FLAT:??_C@_06KLHHMIGM@offset?$AA@
	DQ	0000000000000000H
mmapmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_04PHBJEMCB@mmap?$AA@
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_08CMFIGCJD@__exit__?$AA@
CONST	SEGMENT
??_C@_08CMFIGCJD@__exit__?$AA@ DB '__exit__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAJHKKGH@__enter__?$AA@
CONST	SEGMENT
??_C@_09OAJHKKGH@__enter__?$AA@ DB '__enter__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PDOGLJGG@write_byte?$AA@
CONST	SEGMENT
??_C@_0L@PDOGLJGG@write_byte?$AA@ DB 'write_byte', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05NGFEDHGN@write?$AA@
CONST	SEGMENT
??_C@_05NGFEDHGN@write?$AA@ DB 'write', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LBPCFPDD@tell?$AA@
CONST	SEGMENT
??_C@_04LBPCFPDD@tell?$AA@ DB 'tell', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IAGNFIBA@size?$AA@
CONST	SEGMENT
??_C@_04IAGNFIBA@size?$AA@ DB 'size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EDECCOGL@seek?$AA@
CONST	SEGMENT
??_C@_04EDECCOGL@seek?$AA@ DB 'seek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PIONCPJI@resize?$AA@
CONST	SEGMENT
??_C@_06PIONCPJI@resize?$AA@ DB 'resize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08KBCDPPMN@readline?$AA@
CONST	SEGMENT
??_C@_08KBCDPPMN@readline?$AA@ DB 'readline', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09NIOKOAGD@read_byte?$AA@
CONST	SEGMENT
??_C@_09NIOKOAGD@read_byte?$AA@ DB 'read_byte', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04POLDLDMI@read?$AA@
CONST	SEGMENT
??_C@_04POLDLDMI@read?$AA@ DB 'read', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDMMNHEL@move?$AA@
CONST	SEGMENT
??_C@_04HDMMNHEL@move?$AA@ DB 'move', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GLCAEPFP@flush?$AA@
CONST	SEGMENT
??_C@_05GLCAEPFP@flush?$AA@ DB 'flush', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BLFDIAHL@rfind?$AA@
CONST	SEGMENT
??_C@_05BLFDIAHL@rfind?$AA@ DB 'rfind', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CKFJHKAP@find?$AA@
CONST	SEGMENT
??_C@_04CKFJHKAP@find?$AA@ DB 'find', 00H		; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId_close@?1??mmap__exit__method@@9@9 DQ 0000000000000000H ; `mmap__exit__method'::`2'::PyId_close
	DQ	FLAT:??_C@_05LBOHBHFK@close?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_05LBOHBHFK@close?$AA@
CONST	SEGMENT
??_C@_05LBOHBHFK@close?$AA@ DB 'close', 00H		; `string'
CONST	ENDS
EXTRN	PyMem_Free:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_UnmapViewOfFile:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\mmapmodule.c
pdata	SEGMENT
$pdata$mmap_object_dealloc DD imagerel mmap_object_dealloc
	DD	imagerel mmap_object_dealloc+159
	DD	imagerel $unwind$mmap_object_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_object_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mmap_object_dealloc
_TEXT	SEGMENT
m_obj$ = 48
mmap_object_dealloc PROC				; COMDAT

; 117  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 118  : #ifdef MS_WINDOWS
; 119  :     if (m_obj->data != NULL)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR m_obj$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 0f		 je	 SHORT $LN4@mmap_objec

; 120  :         UnmapViewOfFile (m_obj->data);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR m_obj$[rsp]
  0001a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_UnmapViewOfFile
$LN4@mmap_objec:

; 121  :     if (m_obj->map_handle != NULL)

  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR m_obj$[rsp]
  00029	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00031	74 12		 je	 SHORT $LN3@mmap_objec

; 122  :         CloseHandle (m_obj->map_handle);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR m_obj$[rsp]
  00038	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN3@mmap_objec:

; 123  :     if (m_obj->file_handle != INVALID_HANDLE_VALUE)

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR m_obj$[rsp]
  0004a	48 83 b8 90 00
	00 00 ff	 cmp	 QWORD PTR [rax+144], -1
  00052	74 12		 je	 SHORT $LN2@mmap_objec

; 124  :         CloseHandle (m_obj->file_handle);

  00054	48 8b 44 24 30	 mov	 rax, QWORD PTR m_obj$[rsp]
  00059	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN2@mmap_objec:

; 125  :     if (m_obj->tagname)

  00066	48 8b 44 24 30	 mov	 rax, QWORD PTR m_obj$[rsp]
  0006b	48 83 b8 98 00
	00 00 00	 cmp	 QWORD PTR [rax+152], 0
  00073	74 11		 je	 SHORT $LN1@mmap_objec

; 126  :         PyMem_Free(m_obj->tagname);

  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR m_obj$[rsp]
  0007a	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00081	e8 00 00 00 00	 call	 PyMem_Free
$LN1@mmap_objec:

; 127  : #endif /* MS_WINDOWS */
; 128  : 
; 129  : #ifdef UNIX
; 130  :     if (m_obj->fd >= 0)
; 131  :         (void) close(m_obj->fd);
; 132  :     if (m_obj->data!=NULL) {
; 133  :         munmap(m_obj->data, m_obj->size);
; 134  :     }
; 135  : #endif /* UNIX */
; 136  : 
; 137  :     Py_TYPE(m_obj)->tp_free((PyObject*)m_obj);

  00086	48 8b 44 24 30	 mov	 rax, QWORD PTR m_obj$[rsp]
  0008b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR m_obj$[rsp]
  00094	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 138  : }

  0009a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009e	c3		 ret	 0
mmap_object_dealloc ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0CF@EJIMDHDP@cannot?5close?5exported?5pointers?5e@ ; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_BufferError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_close_method DD imagerel mmap_close_method
	DD	imagerel mmap_close_method+216
	DD	imagerel $unwind$mmap_close_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_close_method DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0CF@EJIMDHDP@cannot?5close?5exported?5pointers?5e@
CONST	SEGMENT
??_C@_0CF@EJIMDHDP@cannot?5close?5exported?5pointers?5e@ DB 'cannot close'
	DB	' exported pointers exist', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_close_method
_TEXT	SEGMENT
self$ = 48
unused$ = 56
mmap_close_method PROC					; COMDAT

; 142  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 143  :     if (self->exports > 0) {

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [rax+128], 0
  0001a	7e 1a		 jle	 SHORT $LN4@mmap_close

; 144  :         PyErr_SetString(PyExc_BufferError, "cannot close "\
; 145  :                         "exported pointers exist");

  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@EJIMDHDP@cannot?5close?5exported?5pointers?5e@
  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0002a	e8 00 00 00 00	 call	 PyErr_SetString

; 146  :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	e9 9d 00 00 00	 jmp	 $LN5@mmap_close
$LN4@mmap_close:

; 147  :     }
; 148  : #ifdef MS_WINDOWS
; 149  :     /* For each resource we maintain, we need to check
; 150  :        the value is valid, and if so, free the resource
; 151  :        and set the member value to an invalid value so
; 152  :        the dealloc does not attempt to resource clearing
; 153  :        again.
; 154  :        TODO - should we check for errors in the close operations???
; 155  :     */
; 156  :     if (self->data != NULL) {

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003b	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00040	74 1c		 je	 SHORT $LN3@mmap_close

; 157  :         UnmapViewOfFile(self->data);

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00047	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_UnmapViewOfFile

; 158  :         self->data = NULL;

  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00056	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
$LN3@mmap_close:

; 159  :     }
; 160  :     if (self->map_handle != NULL) {

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00063	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0006b	74 22		 je	 SHORT $LN2@mmap_close

; 161  :         CloseHandle(self->map_handle);

  0006d	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00072	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 162  :         self->map_handle = NULL;

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00084	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0
$LN2@mmap_close:

; 163  :     }
; 164  :     if (self->file_handle != INVALID_HANDLE_VALUE) {

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00094	48 83 b8 90 00
	00 00 ff	 cmp	 QWORD PTR [rax+144], -1
  0009c	74 22		 je	 SHORT $LN1@mmap_close

; 165  :         CloseHandle(self->file_handle);

  0009e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000a3	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 166  :         self->file_handle = INVALID_HANDLE_VALUE;

  000b0	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  000b5	48 c7 80 90 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+144], -1
$LN1@mmap_close:

; 167  :     }
; 168  : #endif /* MS_WINDOWS */
; 169  : 
; 170  : #ifdef UNIX
; 171  :     if (0 <= self->fd)
; 172  :         (void) close(self->fd);
; 173  :     self->fd = -1;
; 174  :     if (self->data != NULL) {
; 175  :         munmap(self->data, self->size);
; 176  :         self->data = NULL;
; 177  :     }
; 178  : #endif
; 179  : 
; 180  :     Py_INCREF(Py_None);

  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000c7	e8 00 00 00 00	 call	 _Py_IncRef

; 181  :     return Py_None;

  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN5@mmap_close:

; 182  : }

  000d3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d7	c3		 ret	 0
mmap_close_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@CGLJPLHN@read?5byte?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@ ; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
EXTRN	PyExc_ValueError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\modules\mmapmodule.c
pdata	SEGMENT
$pdata$mmap_read_byte_method DD imagerel mmap_read_byte_method
	DD	imagerel mmap_read_byte_method+174
	DD	imagerel $unwind$mmap_read_byte_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_read_byte_method DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BH@CGLJPLHN@read?5byte?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BH@CGLJPLHN@read?5byte?5out?5of?5range?$AA@ DB 'read byte out of r'
	DB	'ange', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
CONST	SEGMENT
??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@ DB 'mmap closed or inva'
	DB	'lid', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_read_byte_method
_TEXT	SEGMENT
value$120477 = 32
self$ = 64
unused$ = 72
mmap_read_byte_method PROC				; COMDAT

; 207  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@mmap_read_:

; 208  :     CHECK_VALID(NULL);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	75 17		 jne	 SHORT $LN3@mmap_read_
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString
  00030	33 c0		 xor	 eax, eax
  00032	eb 75		 jmp	 SHORT $LN7@mmap_read_
$LN3@mmap_read_:
  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 d4		 jne	 SHORT $LN6@mmap_read_

; 209  :     if (self->pos < self->size) {

  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00044	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00048	48 39 48 70	 cmp	 QWORD PTR [rax+112], rcx
  0004c	73 46		 jae	 SHORT $LN2@mmap_read_

; 210  :         char value = self->data[self->pos];

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00053	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00060	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00064	88 44 24 20	 mov	 BYTE PTR value$120477[rsp], al

; 211  :         self->pos += 1;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0006d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00071	48 ff c0	 inc	 rax
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00079	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 212  :         return Py_BuildValue("B", (unsigned char)value);

  0007d	0f b6 44 24 20	 movzx	 eax, BYTE PTR value$120477[rsp]
  00082	8b d0		 mov	 edx, eax
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01HMGJMAIH@B?$AA@
  0008b	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  00090	eb 17		 jmp	 SHORT $LN7@mmap_read_

; 213  :     } else {

  00092	eb 15		 jmp	 SHORT $LN1@mmap_read_
$LN2@mmap_read_:

; 214  :         PyErr_SetString(PyExc_ValueError, "read byte out of range");

  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@CGLJPLHN@read?5byte?5out?5of?5range?$AA@
  0009b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a2	e8 00 00 00 00	 call	 PyErr_SetString

; 215  :         return NULL;

  000a7	33 c0		 xor	 eax, eax
$LN1@mmap_read_:
$LN7@mmap_read_:

; 216  :     }
; 217  : }

  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	c3		 ret	 0
mmap_read_byte_method ENDP
_TEXT	ENDS
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	__imp_memchr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_read_line_method DD imagerel mmap_read_line_method
	DD	imagerel mmap_read_line_method+263
	DD	imagerel $unwind$mmap_read_line_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_read_line_method DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mmap_read_line_method
_TEXT	SEGMENT
eol$ = 32
start$ = 40
result$ = 48
eof$ = 56
self$ = 80
unused$ = 88
mmap_read_line_method PROC				; COMDAT

; 222  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 223  :     char *start = self->data+self->pos;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  0001c	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  00020	48 89 44 24 28	 mov	 QWORD PTR start$[rsp], rax

; 224  :     char *eof = self->data+self->size;

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0002a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00033	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  00037	48 89 44 24 38	 mov	 QWORD PTR eof$[rsp], rax
$LN6@mmap_read_@2:

; 225  :     char *eol;
; 226  :     PyObject *result;
; 227  : 
; 228  :     CHECK_VALID(NULL);

  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00041	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00049	75 1a		 jne	 SHORT $LN3@mmap_read_@2
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00059	e8 00 00 00 00	 call	 PyErr_SetString
  0005e	33 c0		 xor	 eax, eax
  00060	e9 9d 00 00 00	 jmp	 $LN7@mmap_read_@2
$LN3@mmap_read_@2:
  00065	33 c0		 xor	 eax, eax
  00067	85 c0		 test	 eax, eax
  00069	75 d1		 jne	 SHORT $LN6@mmap_read_@2

; 229  : 
; 230  :     eol = memchr(start, '\n', self->size - self->pos);

  0006b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00070	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00075	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00079	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007d	48 2b c1	 sub	 rax, rcx
  00080	4c 8b c0	 mov	 r8, rax
  00083	ba 0a 00 00 00	 mov	 edx, 10
  00088	48 8b 4c 24 28	 mov	 rcx, QWORD PTR start$[rsp]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00093	48 89 44 24 20	 mov	 QWORD PTR eol$[rsp], rax

; 231  :     if (!eol)

  00098	48 83 7c 24 20
	00		 cmp	 QWORD PTR eol$[rsp], 0
  0009e	75 0c		 jne	 SHORT $LN2@mmap_read_@2

; 232  :         eol = eof;

  000a0	48 8b 44 24 38	 mov	 rax, QWORD PTR eof$[rsp]
  000a5	48 89 44 24 20	 mov	 QWORD PTR eol$[rsp], rax

; 233  :     else

  000aa	eb 0d		 jmp	 SHORT $LN1@mmap_read_@2
$LN2@mmap_read_@2:

; 234  :         ++eol;                  /* we're interested in the position after the

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR eol$[rsp]
  000b1	48 ff c0	 inc	 rax
  000b4	48 89 44 24 20	 mov	 QWORD PTR eol$[rsp], rax
$LN1@mmap_read_@2:

; 235  :                            newline. */
; 236  :     result = PyBytes_FromStringAndSize(start, (eol - start));

  000b9	48 8b 44 24 28	 mov	 rax, QWORD PTR start$[rsp]
  000be	48 8b 4c 24 20	 mov	 rcx, QWORD PTR eol$[rsp]
  000c3	48 2b c8	 sub	 rcx, rax
  000c6	48 8b c1	 mov	 rax, rcx
  000c9	48 8b d0	 mov	 rdx, rax
  000cc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR start$[rsp]
  000d1	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  000d6	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 237  :     self->pos += (eol - start);

  000db	48 8b 44 24 28	 mov	 rax, QWORD PTR start$[rsp]
  000e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR eol$[rsp]
  000e5	48 2b c8	 sub	 rcx, rax
  000e8	48 8b c1	 mov	 rax, rcx
  000eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000f0	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  000f4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000f9	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 238  :     return result;

  000fd	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN7@mmap_read_@2:

; 239  : }

  00102	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00106	c3		 ret	 0
mmap_read_line_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DA@PJFDNMNP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@CFAPIFCK@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAm?$AAa?$AAp?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	??_C@_08DBDOJIJG@?$HMO?$CG?3read?$AA@		; `string'
EXTRN	__imp__wassert:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_read_method DD imagerel mmap_read_method
	DD	imagerel mmap_read_method+306
	DD	imagerel $unwind$mmap_read_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_read_method DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_1DA@PJFDNMNP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@PJFDNMNP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?$AA@ DB 's'
	DB	00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, ' ', 00H, '>', 00H, '=', 00H, ' '
	DB	00H, 's', 00H, 'e', 00H, 'l', 00H, 'f', 00H, '-', 00H, '>', 00H
	DB	'p', 00H, 'o', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@CFAPIFCK@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAm?$AAa?$AAp?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@CFAPIFCK@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAm?$AAa?$AAp?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 'm', 00H, 'm', 00H, 'a'
	DB	00H, 'p', 00H, 'm', 00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H
	DB	'e', 00H, '.', 00H, 'c', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DBDOJIJG@?$HMO?$CG?3read?$AA@
CONST	SEGMENT
??_C@_08DBDOJIJG@?$HMO?$CG?3read?$AA@ DB '|O&:read', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_read_method
_TEXT	SEGMENT
n$ = 32
num_bytes$ = 40
result$ = 48
self$ = 80
args$ = 88
mmap_read_method PROC					; COMDAT

; 266  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 267  :     Py_ssize_t num_bytes = -1, n;

  0000e	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR num_bytes$[rsp], -1
$LN8@mmap_read_@3:

; 268  :     PyObject *result;
; 269  : 
; 270  :     CHECK_VALID(NULL);

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001c	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00024	75 1a		 jne	 SHORT $LN5@mmap_read_@3
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  0002d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00034	e8 00 00 00 00	 call	 PyErr_SetString
  00039	33 c0		 xor	 eax, eax
  0003b	e9 ed 00 00 00	 jmp	 $LN9@mmap_read_@3
$LN5@mmap_read_@3:
  00040	33 c0		 xor	 eax, eax
  00042	85 c0		 test	 eax, eax
  00044	75 d1		 jne	 SHORT $LN8@mmap_read_@3

; 271  :     if (!PyArg_ParseTuple(args, "|O&:read", mmap_convert_ssize_t, &num_bytes))

  00046	4c 8d 4c 24 28	 lea	 r9, QWORD PTR num_bytes$[rsp]
  0004b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:mmap_convert_ssize_t
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08DBDOJIJG@?$HMO?$CG?3read?$AA@
  00059	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0005e	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00063	85 c0		 test	 eax, eax
  00065	75 07		 jne	 SHORT $LN4@mmap_read_@3

; 272  :         return(NULL);

  00067	33 c0		 xor	 eax, eax
  00069	e9 bf 00 00 00	 jmp	 $LN9@mmap_read_@3
$LN4@mmap_read_@3:

; 273  : 
; 274  :     /* silently 'adjust' out-of-range requests */
; 275  :     assert(self->size >= self->pos);

  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00078	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0007c	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00080	73 1c		 jae	 SHORT $LN11@mmap_read_@3
  00082	41 b8 13 01 00
	00		 mov	 r8d, 275		; 00000113H
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@CFAPIFCK@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAm?$AAm?$AAa?$AAp?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@PJFDNMNP@?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAs?$AAi?$AAz?$AAe?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAs?$AAe?$AAl?$AAf?$AA?9?$AA?$DO?$AAp?$AAo?$AAs?$AA?$AA@
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0009c	33 c0		 xor	 eax, eax
$LN11@mmap_read_@3:

; 276  :     n = self->size - self->pos;

  0009e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000a8	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000ac	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b0	48 2b c1	 sub	 rax, rcx
  000b3	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 277  :     /* The difference can overflow, only if self->size is greater than
; 278  :      * PY_SSIZE_T_MAX.  But then the operation cannot possibly succeed,
; 279  :      * because the mapped area and the returned string each need more
; 280  :      * than half of the addressable memory.  So we clip the size, and let
; 281  :      * the code below raise MemoryError.
; 282  :      */
; 283  :     if (n < 0)

  000b8	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  000be	7d 0f		 jge	 SHORT $LN3@mmap_read_@3

; 284  :         n = PY_SSIZE_T_MAX;

  000c0	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000ca	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax
$LN3@mmap_read_@3:

; 285  :     if (num_bytes < 0 || num_bytes > n) {

  000cf	48 83 7c 24 28
	00		 cmp	 QWORD PTR num_bytes$[rsp], 0
  000d5	7c 0c		 jl	 SHORT $LN1@mmap_read_@3
  000d7	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000dc	48 39 44 24 28	 cmp	 QWORD PTR num_bytes$[rsp], rax
  000e1	7e 0a		 jle	 SHORT $LN2@mmap_read_@3
$LN1@mmap_read_@3:

; 286  :         num_bytes = n;

  000e3	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000e8	48 89 44 24 28	 mov	 QWORD PTR num_bytes$[rsp], rax
$LN2@mmap_read_@3:

; 287  :     }
; 288  :     result = PyBytes_FromStringAndSize(self->data+self->pos, num_bytes);

  000ed	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000f2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000fb	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  000ff	48 8b 54 24 28	 mov	 rdx, QWORD PTR num_bytes$[rsp]
  00104	48 8b c8	 mov	 rcx, rax
  00107	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0010c	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 289  :     self->pos += num_bytes;

  00111	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00116	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0011a	48 03 44 24 28	 add	 rax, QWORD PTR num_bytes$[rsp]
  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00124	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 290  :     return result;

  00128	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN9@mmap_read_@3:

; 291  : }

  0012d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00131	c3		 ret	 0
mmap_read_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@INOFDAGI@integer?5argument?5expected?0?5got?5?8@ ; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	PyNumber_AsSsize_t:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	PyNumber_Check:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_convert_ssize_t DD imagerel mmap_convert_ssize_t
	DD	imagerel mmap_convert_ssize_t+158
	DD	imagerel $unwind$mmap_convert_ssize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_convert_ssize_t DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CI@INOFDAGI@integer?5argument?5expected?0?5got?5?8@
CONST	SEGMENT
??_C@_0CI@INOFDAGI@integer?5argument?5expected?0?5got?5?8@ DB 'integer ar'
	DB	'gument expected, got ''%.200s''', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_convert_ssize_t
_TEXT	SEGMENT
limit$ = 32
obj$ = 64
result$ = 72
mmap_convert_ssize_t PROC				; COMDAT

; 243  : mmap_convert_ssize_t(PyObject *obj, void *result) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 244  :     Py_ssize_t limit;
; 245  :     if (obj == Py_None) {

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00015	48 39 44 24 40	 cmp	 QWORD PTR obj$[rsp], rax
  0001a	75 0b		 jne	 SHORT $LN5@mmap_conve

; 246  :         limit = -1;

  0001c	48 c7 44 24 20
	ff ff ff ff	 mov	 QWORD PTR limit$[rsp], -1
  00025	eb 60		 jmp	 SHORT $LN4@mmap_conve
$LN5@mmap_conve:

; 247  :     }
; 248  :     else if (PyNumber_Check(obj)) {

  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  0002c	e8 00 00 00 00	 call	 PyNumber_Check
  00031	85 c0		 test	 eax, eax
  00033	74 2e		 je	 SHORT $LN3@mmap_conve

; 249  :         limit = PyNumber_AsSsize_t(obj, PyExc_OverflowError);

  00035	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  00041	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00046	48 89 44 24 20	 mov	 QWORD PTR limit$[rsp], rax

; 250  :         if (limit == -1 && PyErr_Occurred())

  0004b	48 83 7c 24 20
	ff		 cmp	 QWORD PTR limit$[rsp], -1
  00051	75 0e		 jne	 SHORT $LN2@mmap_conve
  00053	e8 00 00 00 00	 call	 PyErr_Occurred
  00058	48 85 c0	 test	 rax, rax
  0005b	74 04		 je	 SHORT $LN2@mmap_conve

; 251  :             return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 38		 jmp	 SHORT $LN6@mmap_conve
$LN2@mmap_conve:

; 252  :     }
; 253  :     else {

  00061	eb 24		 jmp	 SHORT $LN1@mmap_conve
$LN3@mmap_conve:

; 254  :         PyErr_Format(PyExc_TypeError,
; 255  :                      "integer argument expected, got '%.200s'",
; 256  :                      Py_TYPE(obj)->tp_name);

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  00068	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006c	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@INOFDAGI@integer?5argument?5expected?0?5got?5?8@
  00077	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0007e	e8 00 00 00 00	 call	 PyErr_Format

; 257  :         return 0;

  00083	33 c0		 xor	 eax, eax
  00085	eb 12		 jmp	 SHORT $LN6@mmap_conve
$LN1@mmap_conve:
$LN4@mmap_conve:

; 258  :     }
; 259  :     *((Py_ssize_t *)result) = limit;

  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR limit$[rsp]
  00091	48 89 08	 mov	 QWORD PTR [rax], rcx

; 260  :     return 1;

  00094	b8 01 00 00 00	 mov	 eax, 1
$LN6@mmap_conve:

; 261  : }

  00099	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009d	c3		 ret	 0
mmap_convert_ssize_t ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_find_method DD imagerel mmap_find_method
	DD	imagerel mmap_find_method+37
	DD	imagerel $unwind$mmap_find_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_find_method DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mmap_find_method
_TEXT	SEGMENT
self$ = 48
args$ = 56
mmap_find_method PROC					; COMDAT

; 344  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 345  :     return mmap_gfind(self, args, 0);

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR args$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0001b	e8 00 00 00 00	 call	 mmap_gfind

; 346  : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
mmap_find_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@LGHHJGA@y?$CD?$HMnn?3find?$AA@		; `string'
PUBLIC	??_C@_0M@MGHPMCLB@y?$CD?$HMnn?3rfind?$AA@	; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_gfind DD imagerel mmap_gfind
	DD	imagerel mmap_gfind+753
	DD	imagerel $unwind$mmap_gfind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_gfind DD 021601H
	DD	0130116H
xdata	ENDS
;	COMDAT ??_C@_0L@LGHHJGA@y?$CD?$HMnn?3find?$AA@
CONST	SEGMENT
??_C@_0L@LGHHJGA@y?$CD?$HMnn?3find?$AA@ DB 'y#|nn:find', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MGHPMCLB@y?$CD?$HMnn?3rfind?$AA@
CONST	SEGMENT
??_C@_0M@MGHPMCLB@y?$CD?$HMnn?3rfind?$AA@ DB 'y#|nn:rfind', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_gfind
_TEXT	SEGMENT
needle$ = 48
len$ = 56
end$ = 64
start$ = 72
p$120565 = 80
end_p$120567 = 88
start_p$120566 = 96
sign$120568 = 104
i$120582 = 112
tv77 = 120
tv82 = 128
tv135 = 136
self$ = 160
args$ = 168
reverse$ = 176
mmap_gfind PROC						; COMDAT

; 297  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 298  :     Py_ssize_t start = self->pos;

  00016	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00022	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax

; 299  :     Py_ssize_t end = self->size;

  00027	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0002f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00033	48 89 44 24 40	 mov	 QWORD PTR end$[rsp], rax
$LN21@mmap_gfind:

; 300  :     const char *needle;
; 301  :     Py_ssize_t len;
; 302  : 
; 303  :     CHECK_VALID(NULL);

  00038	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00040	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00048	75 1a		 jne	 SHORT $LN18@mmap_gfind
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00058	e8 00 00 00 00	 call	 PyErr_SetString
  0005d	33 c0		 xor	 eax, eax
  0005f	e9 85 02 00 00	 jmp	 $LN22@mmap_gfind
$LN18@mmap_gfind:
  00064	33 c0		 xor	 eax, eax
  00066	85 c0		 test	 eax, eax
  00068	75 ce		 jne	 SHORT $LN21@mmap_gfind

; 304  :     if (!PyArg_ParseTuple(args, reverse ? "y#|nn:rfind" : "y#|nn:find",
; 305  :                           &needle, &len, &start, &end)) {

  0006a	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR reverse$[rsp], 0
  00072	74 0e		 je	 SHORT $LN24@mmap_gfind
  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@MGHPMCLB@y?$CD?$HMnn?3rfind?$AA@
  0007b	48 89 44 24 78	 mov	 QWORD PTR tv77[rsp], rax
  00080	eb 0c		 jmp	 SHORT $LN25@mmap_gfind
$LN24@mmap_gfind:
  00082	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0L@LGHHJGA@y?$CD?$HMnn?3find?$AA@
  00089	48 89 44 24 78	 mov	 QWORD PTR tv77[rsp], rax
$LN25@mmap_gfind:
  0008e	48 8d 44 24 40	 lea	 rax, QWORD PTR end$[rsp]
  00093	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00098	48 8d 44 24 48	 lea	 rax, QWORD PTR start$[rsp]
  0009d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a2	4c 8d 4c 24 38	 lea	 r9, QWORD PTR len$[rsp]
  000a7	4c 8d 44 24 30	 lea	 r8, QWORD PTR needle$[rsp]
  000ac	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv77[rsp]
  000b1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000b9	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  000be	85 c0		 test	 eax, eax
  000c0	75 0c		 jne	 SHORT $LN17@mmap_gfind

; 306  :         return NULL;

  000c2	33 c0		 xor	 eax, eax
  000c4	e9 20 02 00 00	 jmp	 $LN22@mmap_gfind

; 307  :     } else {

  000c9	e9 1b 02 00 00	 jmp	 $LN16@mmap_gfind
$LN17@mmap_gfind:

; 308  :         const char *p, *start_p, *end_p;
; 309  :         int sign = reverse ? -1 : 1;

  000ce	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR reverse$[rsp], 0
  000d6	74 0d		 je	 SHORT $LN26@mmap_gfind
  000d8	c7 84 24 80 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR tv82[rsp], -1
  000e3	eb 0b		 jmp	 SHORT $LN27@mmap_gfind
$LN26@mmap_gfind:
  000e5	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv82[rsp], 1
$LN27@mmap_gfind:
  000f0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv82[rsp]
  000f7	89 44 24 68	 mov	 DWORD PTR sign$120568[rsp], eax

; 310  : 
; 311  :         if (start < 0)

  000fb	48 83 7c 24 48
	00		 cmp	 QWORD PTR start$[rsp], 0
  00101	7d 1c		 jge	 SHORT $LN15@mmap_gfind

; 312  :             start += self->size;

  00103	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0010b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR start$[rsp]
  00114	48 03 c8	 add	 rcx, rax
  00117	48 8b c1	 mov	 rax, rcx
  0011a	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax
$LN15@mmap_gfind:

; 313  :         if (start < 0)

  0011f	48 83 7c 24 48
	00		 cmp	 QWORD PTR start$[rsp], 0
  00125	7d 0b		 jge	 SHORT $LN14@mmap_gfind

; 314  :             start = 0;

  00127	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
  00130	eb 24		 jmp	 SHORT $LN13@mmap_gfind
$LN14@mmap_gfind:

; 315  :         else if ((size_t)start > self->size)

  00132	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0013a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0013e	48 39 44 24 48	 cmp	 QWORD PTR start$[rsp], rax
  00143	76 11		 jbe	 SHORT $LN12@mmap_gfind

; 316  :             start = self->size;

  00145	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0014d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00151	48 89 44 24 48	 mov	 QWORD PTR start$[rsp], rax
$LN12@mmap_gfind:
$LN13@mmap_gfind:

; 317  : 
; 318  :         if (end < 0)

  00156	48 83 7c 24 40
	00		 cmp	 QWORD PTR end$[rsp], 0
  0015c	7d 1c		 jge	 SHORT $LN11@mmap_gfind

; 319  :             end += self->size;

  0015e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00166	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0016a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR end$[rsp]
  0016f	48 03 c8	 add	 rcx, rax
  00172	48 8b c1	 mov	 rax, rcx
  00175	48 89 44 24 40	 mov	 QWORD PTR end$[rsp], rax
$LN11@mmap_gfind:

; 320  :         if (end < 0)

  0017a	48 83 7c 24 40
	00		 cmp	 QWORD PTR end$[rsp], 0
  00180	7d 0b		 jge	 SHORT $LN10@mmap_gfind

; 321  :             end = 0;

  00182	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR end$[rsp], 0
  0018b	eb 24		 jmp	 SHORT $LN9@mmap_gfind
$LN10@mmap_gfind:

; 322  :         else if ((size_t)end > self->size)

  0018d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00195	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00199	48 39 44 24 40	 cmp	 QWORD PTR end$[rsp], rax
  0019e	76 11		 jbe	 SHORT $LN8@mmap_gfind

; 323  :             end = self->size;

  001a0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001a8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001ac	48 89 44 24 40	 mov	 QWORD PTR end$[rsp], rax
$LN8@mmap_gfind:
$LN9@mmap_gfind:

; 324  : 
; 325  :         start_p = self->data + start;

  001b1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001b9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001bd	48 03 44 24 48	 add	 rax, QWORD PTR start$[rsp]
  001c2	48 89 44 24 60	 mov	 QWORD PTR start_p$120566[rsp], rax

; 326  :         end_p = self->data + end;

  001c7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001cf	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001d3	48 03 44 24 40	 add	 rax, QWORD PTR end$[rsp]
  001d8	48 89 44 24 58	 mov	 QWORD PTR end_p$120567[rsp], rax

; 327  : 
; 328  :         for (p = (reverse ? end_p - len : start_p);
; 329  :              (p >= start_p) && (p + len <= end_p); p += sign) {

  001dd	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR reverse$[rsp], 0
  001e5	74 1a		 je	 SHORT $LN28@mmap_gfind
  001e7	48 8b 44 24 38	 mov	 rax, QWORD PTR len$[rsp]
  001ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR end_p$120567[rsp]
  001f1	48 2b c8	 sub	 rcx, rax
  001f4	48 8b c1	 mov	 rax, rcx
  001f7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
  001ff	eb 0d		 jmp	 SHORT $LN29@mmap_gfind
$LN28@mmap_gfind:
  00201	48 8b 44 24 60	 mov	 rax, QWORD PTR start_p$120566[rsp]
  00206	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
$LN29@mmap_gfind:
  0020e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv135[rsp]
  00216	48 89 44 24 50	 mov	 QWORD PTR p$120565[rsp], rax
  0021b	eb 15		 jmp	 SHORT $LN7@mmap_gfind
$LN6@mmap_gfind:
  0021d	48 63 44 24 68	 movsxd	 rax, DWORD PTR sign$120568[rsp]
  00222	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$120565[rsp]
  00227	48 03 c8	 add	 rcx, rax
  0022a	48 8b c1	 mov	 rax, rcx
  0022d	48 89 44 24 50	 mov	 QWORD PTR p$120565[rsp], rax
$LN7@mmap_gfind:
  00232	48 8b 44 24 60	 mov	 rax, QWORD PTR start_p$120566[rsp]
  00237	48 39 44 24 50	 cmp	 QWORD PTR p$120565[rsp], rax
  0023c	0f 82 9d 00 00
	00		 jb	 $LN5@mmap_gfind
  00242	48 8b 44 24 38	 mov	 rax, QWORD PTR len$[rsp]
  00247	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$120565[rsp]
  0024c	48 03 c8	 add	 rcx, rax
  0024f	48 8b c1	 mov	 rax, rcx
  00252	48 3b 44 24 58	 cmp	 rax, QWORD PTR end_p$120567[rsp]
  00257	0f 87 82 00 00
	00		 ja	 $LN5@mmap_gfind

; 330  :             Py_ssize_t i;
; 331  :             for (i = 0; i < len && needle[i] == p[i]; ++i)

  0025d	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR i$120582[rsp], 0
  00266	eb 0d		 jmp	 SHORT $LN4@mmap_gfind
$LN3@mmap_gfind:
  00268	48 8b 44 24 70	 mov	 rax, QWORD PTR i$120582[rsp]
  0026d	48 ff c0	 inc	 rax
  00270	48 89 44 24 70	 mov	 QWORD PTR i$120582[rsp], rax
$LN4@mmap_gfind:
  00275	48 8b 44 24 38	 mov	 rax, QWORD PTR len$[rsp]
  0027a	48 39 44 24 70	 cmp	 QWORD PTR i$120582[rsp], rax
  0027f	7d 2c		 jge	 SHORT $LN2@mmap_gfind
  00281	48 8b 44 24 70	 mov	 rax, QWORD PTR i$120582[rsp]
  00286	48 8b 4c 24 30	 mov	 rcx, QWORD PTR needle$[rsp]
  0028b	48 03 c8	 add	 rcx, rax
  0028e	48 8b c1	 mov	 rax, rcx
  00291	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00294	48 8b 4c 24 70	 mov	 rcx, QWORD PTR i$120582[rsp]
  00299	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$120565[rsp]
  0029e	48 03 d1	 add	 rdx, rcx
  002a1	48 8b ca	 mov	 rcx, rdx
  002a4	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  002a7	3b c1		 cmp	 eax, ecx
  002a9	75 02		 jne	 SHORT $LN2@mmap_gfind

; 332  :                 /* nothing */;

  002ab	eb bb		 jmp	 SHORT $LN3@mmap_gfind
$LN2@mmap_gfind:

; 333  :             if (i == len) {

  002ad	48 8b 44 24 38	 mov	 rax, QWORD PTR len$[rsp]
  002b2	48 39 44 24 70	 cmp	 QWORD PTR i$120582[rsp], rax
  002b7	75 21		 jne	 SHORT $LN1@mmap_gfind

; 334  :                 return PyLong_FromSsize_t(p - self->data);

  002b9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  002c1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002c5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$120565[rsp]
  002ca	48 2b c8	 sub	 rcx, rax
  002cd	48 8b c1	 mov	 rax, rcx
  002d0	48 8b c8	 mov	 rcx, rax
  002d3	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  002d8	eb 0f		 jmp	 SHORT $LN22@mmap_gfind
$LN1@mmap_gfind:

; 335  :             }
; 336  :         }

  002da	e9 3e ff ff ff	 jmp	 $LN6@mmap_gfind
$LN5@mmap_gfind:

; 337  :         return PyLong_FromLong(-1);

  002df	b9 ff ff ff ff	 mov	 ecx, -1
  002e4	e8 00 00 00 00	 call	 PyLong_FromLong
$LN16@mmap_gfind:
$LN22@mmap_gfind:

; 338  :     }
; 339  : }

  002e9	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002f0	c3		 ret	 0
mmap_gfind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_rfind_method DD imagerel mmap_rfind_method
	DD	imagerel mmap_rfind_method+40
	DD	imagerel $unwind$mmap_rfind_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_rfind_method DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mmap_rfind_method
_TEXT	SEGMENT
self$ = 48
args$ = 56
mmap_rfind_method PROC					; COMDAT

; 351  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 352  :     return mmap_gfind(self, args, 1);

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR args$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0001e	e8 00 00 00 00	 call	 mmap_gfind

; 353  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
mmap_rfind_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@BPEOJPFP@data?5out?5of?5range?$AA@	; `string'
PUBLIC	??_C@_08KGHFGIEH@y?$CD?3write?$AA@		; `string'
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_write_method DD imagerel mmap_write_method
	DD	imagerel mmap_write_method+248
	DD	imagerel $unwind$mmap_write_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_write_method DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BC@BPEOJPFP@data?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BC@BPEOJPFP@data?5out?5of?5range?$AA@ DB 'data out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08KGHFGIEH@y?$CD?3write?$AA@
CONST	SEGMENT
??_C@_08KGHFGIEH@y?$CD?3write?$AA@ DB 'y#:write', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_write_method
_TEXT	SEGMENT
length$ = 32
data$ = 40
self$ = 64
args$ = 72
mmap_write_method PROC					; COMDAT

; 383  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN7@mmap_write:

; 384  :     Py_ssize_t length;
; 385  :     char *data;
; 386  : 
; 387  :     CHECK_VALID(NULL);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	75 1a		 jne	 SHORT $LN4@mmap_write
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString
  00030	33 c0		 xor	 eax, eax
  00032	e9 bc 00 00 00	 jmp	 $LN8@mmap_write
$LN4@mmap_write:
  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 d1		 jne	 SHORT $LN7@mmap_write

; 388  :     if (!PyArg_ParseTuple(args, "y#:write", &data, &length))

  0003d	4c 8d 4c 24 20	 lea	 r9, QWORD PTR length$[rsp]
  00042	4c 8d 44 24 28	 lea	 r8, QWORD PTR data$[rsp]
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08KGHFGIEH@y?$CD?3write?$AA@
  0004e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00053	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00058	85 c0		 test	 eax, eax
  0005a	75 07		 jne	 SHORT $LN3@mmap_write

; 389  :         return(NULL);

  0005c	33 c0		 xor	 eax, eax
  0005e	e9 90 00 00 00	 jmp	 $LN8@mmap_write
$LN3@mmap_write:

; 390  : 
; 391  :     if (!is_writable(self))

  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00068	e8 00 00 00 00	 call	 is_writable
  0006d	85 c0		 test	 eax, eax
  0006f	75 04		 jne	 SHORT $LN2@mmap_write

; 392  :         return NULL;

  00071	33 c0		 xor	 eax, eax
  00073	eb 7e		 jmp	 SHORT $LN8@mmap_write
$LN2@mmap_write:

; 393  : 
; 394  :     if ((self->pos + length) > self->size) {

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0007a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0007e	48 03 44 24 20	 add	 rax, QWORD PTR length$[rsp]
  00083	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00088	48 3b 41 68	 cmp	 rax, QWORD PTR [rcx+104]
  0008c	76 17		 jbe	 SHORT $LN1@mmap_write

; 395  :         PyErr_SetString(PyExc_ValueError, "data out of range");

  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@BPEOJPFP@data?5out?5of?5range?$AA@
  00095	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0009c	e8 00 00 00 00	 call	 PyErr_SetString

; 396  :         return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	eb 4e		 jmp	 SHORT $LN8@mmap_write
$LN1@mmap_write:

; 397  :     }
; 398  :     memcpy(self->data+self->pos, data, length);

  000a5	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000aa	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ae	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000b3	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  000b7	4c 8b 44 24 20	 mov	 r8, QWORD PTR length$[rsp]
  000bc	48 8b 54 24 28	 mov	 rdx, QWORD PTR data$[rsp]
  000c1	48 8b c8	 mov	 rcx, rax
  000c4	e8 00 00 00 00	 call	 memcpy

; 399  :     self->pos = self->pos+length;

  000c9	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000ce	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000d2	48 03 44 24 20	 add	 rax, QWORD PTR length$[rsp]
  000d7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000dc	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 400  :     Py_INCREF(Py_None);

  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000e7	e8 00 00 00 00	 call	 _Py_IncRef

; 401  :     return Py_None;

  000ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN8@mmap_write:

; 402  : }

  000f3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f7	c3		 ret	 0
mmap_write_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@MFMLCJHP@mmap?5can?8t?5modify?5a?5readonly?5mem@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_writable DD imagerel is_writable
	DD	imagerel is_writable+56
	DD	imagerel $unwind$is_writable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_writable DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0CJ@MFMLCJHP@mmap?5can?8t?5modify?5a?5readonly?5mem@
CONST	SEGMENT
??_C@_0CJ@MFMLCJHP@mmap?5can?8t?5modify?5a?5readonly?5mem@ DB 'mmap can'''
	DB	't modify a readonly memory map.', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT is_writable
_TEXT	SEGMENT
self$ = 48
is_writable PROC					; COMDAT

; 357  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 358  :     if (self->access != ACCESS_READ)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 b8 a0 00 00
	00 01		 cmp	 DWORD PTR [rax+160], 1
  00015	74 07		 je	 SHORT $LN1@is_writabl

; 359  :         return 1;

  00017	b8 01 00 00 00	 mov	 eax, 1
  0001c	eb 15		 jmp	 SHORT $LN2@is_writabl
$LN1@is_writabl:

; 360  :     PyErr_Format(PyExc_TypeError, "mmap can't modify a readonly memory map.");

  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@MFMLCJHP@mmap?5can?8t?5modify?5a?5readonly?5mem@
  00025	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0002c	e8 00 00 00 00	 call	 PyErr_Format

; 361  :     return 0;

  00031	33 c0		 xor	 eax, eax
$LN2@is_writabl:

; 362  : }

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	c3		 ret	 0
is_writable ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@CHODECBD@write?5byte?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_0N@HKEPPHI@b?3write_byte?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_write_byte_method DD imagerel mmap_write_byte_method
	DD	imagerel mmap_write_byte_method+228
	DD	imagerel $unwind$mmap_write_byte_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_write_byte_method DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BI@CHODECBD@write?5byte?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BI@CHODECBD@write?5byte?5out?5of?5range?$AA@ DB 'write byte out of'
	DB	' range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HKEPPHI@b?3write_byte?$AA@
CONST	SEGMENT
??_C@_0N@HKEPPHI@b?3write_byte?$AA@ DB 'b:write_byte', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_write_byte_method
_TEXT	SEGMENT
value$ = 32
self$ = 64
args$ = 72
mmap_write_byte_method PROC				; COMDAT

; 407  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN8@mmap_write@2:

; 408  :     char value;
; 409  : 
; 410  :     CHECK_VALID(NULL);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	75 1a		 jne	 SHORT $LN5@mmap_write@2
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString
  00030	33 c0		 xor	 eax, eax
  00032	e9 a8 00 00 00	 jmp	 $LN9@mmap_write@2
$LN5@mmap_write@2:
  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 d1		 jne	 SHORT $LN8@mmap_write@2

; 411  :     if (!PyArg_ParseTuple(args, "b:write_byte", &value))

  0003d	4c 8d 44 24 20	 lea	 r8, QWORD PTR value$[rsp]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@HKEPPHI@b?3write_byte?$AA@
  00049	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0004e	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00053	85 c0		 test	 eax, eax
  00055	75 07		 jne	 SHORT $LN4@mmap_write@2

; 412  :         return(NULL);

  00057	33 c0		 xor	 eax, eax
  00059	e9 81 00 00 00	 jmp	 $LN9@mmap_write@2
$LN4@mmap_write@2:

; 413  : 
; 414  :     if (!is_writable(self))

  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00063	e8 00 00 00 00	 call	 is_writable
  00068	85 c0		 test	 eax, eax
  0006a	75 04		 jne	 SHORT $LN3@mmap_write@2

; 415  :         return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	eb 6f		 jmp	 SHORT $LN9@mmap_write@2
$LN3@mmap_write@2:

; 416  : 
; 417  :     if (self->pos < self->size) {

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0007a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0007e	48 39 48 70	 cmp	 QWORD PTR [rax+112], rcx
  00082	73 46		 jae	 SHORT $LN2@mmap_write@2

; 418  :         *(self->data+self->pos) = value;

  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00089	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00092	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00096	0f b6 54 24 20	 movzx	 edx, BYTE PTR value$[rsp]
  0009b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 419  :         self->pos += 1;

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000a3	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000a7	48 ff c0	 inc	 rax
  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000af	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 420  :         Py_INCREF(Py_None);

  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000ba	e8 00 00 00 00	 call	 _Py_IncRef

; 421  :         return Py_None;

  000bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000c6	eb 17		 jmp	 SHORT $LN9@mmap_write@2

; 422  :     }
; 423  :     else {

  000c8	eb 15		 jmp	 SHORT $LN1@mmap_write@2
$LN2@mmap_write@2:

; 424  :         PyErr_SetString(PyExc_ValueError, "write byte out of range");

  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@CHODECBD@write?5byte?5out?5of?5range?$AA@
  000d1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000d8	e8 00 00 00 00	 call	 PyErr_SetString

; 425  :         return NULL;

  000dd	33 c0		 xor	 eax, eax
$LN1@mmap_write@2:
$LN9@mmap_write@2:

; 426  :     }
; 427  : }

  000df	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e3	c3		 ret	 0
mmap_write_byte_method ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLongLong:PROC
EXTRN	PyErr_SetFromWindowsErr:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_GetFileSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_size_method DD imagerel mmap_size_method
	DD	imagerel mmap_size_method+219
	DD	imagerel $unwind$mmap_size_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_size_method DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mmap_size_method
_TEXT	SEGMENT
high$120676 = 32
size$120677 = 40
low$120675 = 48
error$120680 = 52
self$ = 80
unused$ = 88
mmap_size_method PROC					; COMDAT

; 432  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN9@mmap_size_:

; 433  :     CHECK_VALID(NULL);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	75 1a		 jne	 SHORT $LN6@mmap_size_
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString
  00030	33 c0		 xor	 eax, eax
  00032	e9 9f 00 00 00	 jmp	 $LN10@mmap_size_
$LN6@mmap_size_:
  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 d1		 jne	 SHORT $LN9@mmap_size_

; 434  : 
; 435  : #ifdef MS_WINDOWS
; 436  :     if (self->file_handle != INVALID_HANDLE_VALUE) {

  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00042	48 83 b8 90 00
	00 00 ff	 cmp	 QWORD PTR [rax+144], -1
  0004a	74 7c		 je	 SHORT $LN5@mmap_size_

; 437  :         DWORD low,high;
; 438  :         PY_LONG_LONG size;
; 439  :         low = GetFileSize(self->file_handle, &high);

  0004c	48 8d 54 24 20	 lea	 rdx, QWORD PTR high$120676[rsp]
  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00056	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileSize
  00063	89 44 24 30	 mov	 DWORD PTR low$120675[rsp], eax

; 440  :         if (low == INVALID_FILE_SIZE) {

  00067	83 7c 24 30 ff	 cmp	 DWORD PTR low$120675[rsp], -1 ; ffffffffH
  0006c	75 1c		 jne	 SHORT $LN4@mmap_size_

; 441  :             /* It might be that the function appears to have failed,
; 442  :                when indeed its size equals INVALID_FILE_SIZE */
; 443  :             DWORD error = GetLastError();

  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00074	89 44 24 34	 mov	 DWORD PTR error$120680[rsp], eax

; 444  :             if (error != NO_ERROR)

  00078	83 7c 24 34 00	 cmp	 DWORD PTR error$120680[rsp], 0
  0007d	74 0b		 je	 SHORT $LN3@mmap_size_

; 445  :                 return PyErr_SetFromWindowsErr(error);

  0007f	8b 4c 24 34	 mov	 ecx, DWORD PTR error$120680[rsp]
  00083	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  00088	eb 4c		 jmp	 SHORT $LN10@mmap_size_
$LN3@mmap_size_:
$LN4@mmap_size_:

; 446  :         }
; 447  :         if (!high && low < LONG_MAX)

  0008a	83 7c 24 20 00	 cmp	 DWORD PTR high$120676[rsp], 0
  0008f	75 15		 jne	 SHORT $LN2@mmap_size_
  00091	81 7c 24 30 ff
	ff ff 7f	 cmp	 DWORD PTR low$120675[rsp], 2147483647 ; 7fffffffH
  00099	73 0b		 jae	 SHORT $LN2@mmap_size_

; 448  :             return PyLong_FromLong((long)low);

  0009b	8b 4c 24 30	 mov	 ecx, DWORD PTR low$120675[rsp]
  0009f	e8 00 00 00 00	 call	 PyLong_FromLong
  000a4	eb 30		 jmp	 SHORT $LN10@mmap_size_
$LN2@mmap_size_:

; 449  :         size = (((PY_LONG_LONG)high)<<32) + low;

  000a6	8b 44 24 20	 mov	 eax, DWORD PTR high$120676[rsp]
  000aa	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  000ae	8b 4c 24 30	 mov	 ecx, DWORD PTR low$120675[rsp]
  000b2	48 03 c1	 add	 rax, rcx
  000b5	48 89 44 24 28	 mov	 QWORD PTR size$120677[rsp], rax

; 450  :         return PyLong_FromLongLong(size);

  000ba	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$120677[rsp]
  000bf	e8 00 00 00 00	 call	 PyLong_FromLongLong
  000c4	eb 10		 jmp	 SHORT $LN10@mmap_size_

; 451  :     } else {

  000c6	eb 0e		 jmp	 SHORT $LN1@mmap_size_
$LN5@mmap_size_:

; 452  :         return PyLong_FromSsize_t(self->size);

  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000cd	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000d1	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN1@mmap_size_:
$LN10@mmap_size_:

; 453  :     }
; 454  : #endif /* MS_WINDOWS */
; 455  : 
; 456  : #ifdef UNIX
; 457  :     {
; 458  :         struct stat buf;
; 459  :         if (-1 == fstat(self->fd, &buf)) {
; 460  :             PyErr_SetFromErrno(PyExc_OSError);
; 461  :             return NULL;
; 462  :         }
; 463  : #ifdef HAVE_LARGEFILE_SUPPORT
; 464  :         return PyLong_FromLongLong(buf.st_size);
; 465  : #else
; 466  :         return PyLong_FromLong(buf.st_size);
; 467  : #endif
; 468  :     }
; 469  : #endif /* UNIX */
; 470  : }

  000d6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000da	c3		 ret	 0
mmap_size_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_08DCEPBML@n?3resize?$AA@			; `string'
EXTRN	__imp_MapViewOfFile:PROC
EXTRN	__imp_CreateFileMappingA:PROC
EXTRN	__imp_SetEndOfFile:PROC
EXTRN	__imp_SetFilePointer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_resize_method DD imagerel mmap_resize_method
	DD	imagerel mmap_resize_method+575
	DD	imagerel $unwind$mmap_resize_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_resize_method DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_08DCEPBML@n?3resize?$AA@
CONST	SEGMENT
??_C@_08DCEPBML@n?3resize?$AA@ DB 'n:resize', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_resize_method
_TEXT	SEGMENT
new_size$ = 48
off_hi$120705 = 56
off_lo$120706 = 60
newSizeHigh$120708 = 64
dwErrCode$120704 = 68
newSizeLow$120707 = 72
self$ = 96
args$ = 104
mmap_resize_method PROC					; COMDAT

; 484  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN11@mmap_resiz:

; 485  :     Py_ssize_t new_size;
; 486  :     CHECK_VALID(NULL);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	75 1a		 jne	 SHORT $LN8@mmap_resiz
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString
  00030	33 c0		 xor	 eax, eax
  00032	e9 03 02 00 00	 jmp	 $LN12@mmap_resiz
$LN8@mmap_resiz:
  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 d1		 jne	 SHORT $LN11@mmap_resiz

; 487  :     if (!PyArg_ParseTuple(args, "n:resize", &new_size) ||
; 488  :         !is_resizeable(self)) {

  0003d	4c 8d 44 24 30	 lea	 r8, QWORD PTR new_size$[rsp]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08DCEPBML@n?3resize?$AA@
  00049	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0004e	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00053	85 c0		 test	 eax, eax
  00055	74 0e		 je	 SHORT $LN6@mmap_resiz
  00057	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0005c	e8 00 00 00 00	 call	 is_resizeable
  00061	85 c0		 test	 eax, eax
  00063	75 0c		 jne	 SHORT $LN7@mmap_resiz
$LN6@mmap_resiz:

; 489  :         return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	e9 ce 01 00 00	 jmp	 $LN12@mmap_resiz

; 490  : #ifdef MS_WINDOWS
; 491  :     } else {

  0006c	e9 c9 01 00 00	 jmp	 $LN5@mmap_resiz
$LN7@mmap_resiz:

; 492  :         DWORD dwErrCode = 0;

  00071	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR dwErrCode$120704[rsp], 0

; 493  :         DWORD off_hi, off_lo, newSizeLow, newSizeHigh;
; 494  :         /* First, unmap the file view */
; 495  :         UnmapViewOfFile(self->data);

  00079	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0007e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_UnmapViewOfFile

; 496  :         self->data = NULL;

  00088	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0008d	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 497  :         /* Close the mapping object */
; 498  :         CloseHandle(self->map_handle);

  00095	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0009a	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 499  :         self->map_handle = NULL;

  000a7	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000ac	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 500  :         /* Move to the desired EOF position */
; 501  :         newSizeHigh = (DWORD)((self->offset + new_size) >> 32);

  000b7	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000bc	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000c0	48 03 44 24 30	 add	 rax, QWORD PTR new_size$[rsp]
  000c5	48 c1 f8 20	 sar	 rax, 32			; 00000020H
  000c9	89 44 24 40	 mov	 DWORD PTR newSizeHigh$120708[rsp], eax

; 502  :         newSizeLow = (DWORD)((self->offset + new_size) & 0xFFFFFFFF);

  000cd	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000d2	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000d6	48 03 44 24 30	 add	 rax, QWORD PTR new_size$[rsp]
  000db	b9 ff ff ff ff	 mov	 ecx, -1
  000e0	48 23 c1	 and	 rax, rcx
  000e3	89 44 24 48	 mov	 DWORD PTR newSizeLow$120707[rsp], eax

; 503  :         off_hi = (DWORD)(self->offset >> 32);

  000e7	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000ec	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000f0	48 c1 f8 20	 sar	 rax, 32			; 00000020H
  000f4	89 44 24 38	 mov	 DWORD PTR off_hi$120705[rsp], eax

; 504  :         off_lo = (DWORD)(self->offset & 0xFFFFFFFF);

  000f8	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  000fd	b9 ff ff ff ff	 mov	 ecx, -1
  00102	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00106	48 23 c1	 and	 rax, rcx
  00109	89 44 24 3c	 mov	 DWORD PTR off_lo$120706[rsp], eax

; 505  :         SetFilePointer(self->file_handle,
; 506  :                        newSizeLow, &newSizeHigh, FILE_BEGIN);

  0010d	45 33 c9	 xor	 r9d, r9d
  00110	4c 8d 44 24 40	 lea	 r8, QWORD PTR newSizeHigh$120708[rsp]
  00115	8b 54 24 48	 mov	 edx, DWORD PTR newSizeLow$120707[rsp]
  00119	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  0011e	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetFilePointer

; 507  :         /* Change the size of the file */
; 508  :         SetEndOfFile(self->file_handle);

  0012b	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00130	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEndOfFile

; 509  :         /* Create another mapping object and remap the file view */
; 510  :         self->map_handle = CreateFileMapping(
; 511  :             self->file_handle,
; 512  :             NULL,
; 513  :             PAGE_READWRITE,
; 514  :             0,
; 515  :             0,
; 516  :             self->tagname);

  0013d	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00142	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00149	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0014e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00156	45 33 c9	 xor	 r9d, r9d
  00159	41 b8 04 00 00
	00		 mov	 r8d, 4
  0015f	33 d2		 xor	 edx, edx
  00161	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00166	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileMappingA
  00173	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00178	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 517  :         if (self->map_handle != NULL) {

  0017f	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00184	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0018c	0f 84 93 00 00
	00		 je	 $LN4@mmap_resiz

; 518  :             self->data = (char *) MapViewOfFile(self->map_handle,
; 519  :                                                 FILE_MAP_WRITE,
; 520  :                                                 off_hi,
; 521  :                                                 off_lo,
; 522  :                                                 new_size);

  00192	48 8b 44 24 30	 mov	 rax, QWORD PTR new_size$[rsp]
  00197	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019c	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR off_lo$120706[rsp]
  001a1	44 8b 44 24 38	 mov	 r8d, DWORD PTR off_hi$120705[rsp]
  001a6	ba 02 00 00 00	 mov	 edx, 2
  001ab	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001b0	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MapViewOfFile
  001bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  001c2	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 523  :             if (self->data != NULL) {

  001c6	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001cb	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  001d0	74 25		 je	 SHORT $LN3@mmap_resiz

; 524  :                 self->size = new_size;

  001d2	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  001d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR new_size$[rsp]
  001dc	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 525  :                 Py_INCREF(Py_None);

  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  001e7	e8 00 00 00 00	 call	 _Py_IncRef

; 526  :                 return Py_None;

  001ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001f3	eb 45		 jmp	 SHORT $LN12@mmap_resiz

; 527  :             } else {

  001f5	eb 2c		 jmp	 SHORT $LN2@mmap_resiz
$LN3@mmap_resiz:

; 528  :                 dwErrCode = GetLastError();

  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  001fd	89 44 24 44	 mov	 DWORD PTR dwErrCode$120704[rsp], eax

; 529  :                 CloseHandle(self->map_handle);

  00201	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00206	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 530  :                 self->map_handle = NULL;

  00213	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00218	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0
$LN2@mmap_resiz:

; 531  :             }
; 532  :         } else {

  00223	eb 0a		 jmp	 SHORT $LN1@mmap_resiz
$LN4@mmap_resiz:

; 533  :             dwErrCode = GetLastError();

  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0022b	89 44 24 44	 mov	 DWORD PTR dwErrCode$120704[rsp], eax
$LN1@mmap_resiz:

; 534  :         }
; 535  :         PyErr_SetFromWindowsErr(dwErrCode);

  0022f	8b 4c 24 44	 mov	 ecx, DWORD PTR dwErrCode$120704[rsp]
  00233	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 536  :         return NULL;

  00238	33 c0		 xor	 eax, eax
$LN5@mmap_resiz:
$LN12@mmap_resiz:

; 537  : #endif /* MS_WINDOWS */
; 538  : 
; 539  : #ifdef UNIX
; 540  : #ifndef HAVE_MREMAP
; 541  :     } else {
; 542  :         PyErr_SetString(PyExc_SystemError,
; 543  :                         "mmap: resizing not available--no mremap()");
; 544  :         return NULL;
; 545  : #else
; 546  :     } else {
; 547  :         void *newmap;
; 548  : 
; 549  :         if (ftruncate(self->fd, self->offset + new_size) == -1) {
; 550  :             PyErr_SetFromErrno(PyExc_OSError);
; 551  :             return NULL;
; 552  :         }
; 553  : 
; 554  : #ifdef MREMAP_MAYMOVE
; 555  :         newmap = mremap(self->data, self->size, new_size, MREMAP_MAYMOVE);
; 556  : #else
; 557  :         #if defined(__NetBSD__)
; 558  :             newmap = mremap(self->data, self->size, self->data, new_size, 0);
; 559  :         #else
; 560  :             newmap = mremap(self->data, self->size, new_size, 0);
; 561  :         #endif /* __NetBSD__ */
; 562  : #endif
; 563  :         if (newmap == (void *)-1)
; 564  :         {
; 565  :             PyErr_SetFromErrno(PyExc_OSError);
; 566  :             return NULL;
; 567  :         }
; 568  :         self->data = newmap;
; 569  :         self->size = new_size;
; 570  :         Py_INCREF(Py_None);
; 571  :         return Py_None;
; 572  : #endif /* HAVE_MREMAP */
; 573  : #endif /* UNIX */
; 574  :     }
; 575  : }

  0023a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0023e	c3		 ret	 0
mmap_resize_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DK@MOJPDOHG@mmap?5can?8t?5resize?5a?5readonly?5or?5@ ; `string'
PUBLIC	??_C@_0DA@BLDNJAKJ@mmap?5can?8t?5resize?5with?5extant?5bu@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_resizeable DD imagerel is_resizeable
	DD	imagerel is_resizeable+107
	DD	imagerel $unwind$is_resizeable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_resizeable DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0DK@MOJPDOHG@mmap?5can?8t?5resize?5a?5readonly?5or?5@
CONST	SEGMENT
??_C@_0DK@MOJPDOHG@mmap?5can?8t?5resize?5a?5readonly?5or?5@ DB 'mmap can'''
	DB	't resize a readonly or copy-on-write memory map.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BLDNJAKJ@mmap?5can?8t?5resize?5with?5extant?5bu@
CONST	SEGMENT
??_C@_0DA@BLDNJAKJ@mmap?5can?8t?5resize?5with?5extant?5bu@ DB 'mmap can'''
	DB	't resize with extant buffers exported.', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT is_resizeable
_TEXT	SEGMENT
self$ = 48
is_resizeable PROC					; COMDAT

; 366  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 367  :     if (self->exports > 0) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [rax+128], 0
  00015	7e 17		 jle	 SHORT $LN3@is_resizea

; 368  :         PyErr_SetString(PyExc_BufferError,
; 369  :                         "mmap can't resize with extant buffers exported.");

  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@BLDNJAKJ@mmap?5can?8t?5resize?5with?5extant?5bu@
  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00025	e8 00 00 00 00	 call	 PyErr_SetString

; 370  :         return 0;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 38		 jmp	 SHORT $LN4@is_resizea
$LN3@is_resizea:

; 371  :     }
; 372  :     if ((self->access == ACCESS_WRITE) || (self->access == ACCESS_DEFAULT))

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00033	83 b8 a0 00 00
	00 02		 cmp	 DWORD PTR [rax+160], 2
  0003a	74 0e		 je	 SHORT $LN1@is_resizea
  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00041	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [rax+160], 0
  00048	75 07		 jne	 SHORT $LN2@is_resizea
$LN1@is_resizea:

; 373  :         return 1;

  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	eb 15		 jmp	 SHORT $LN4@is_resizea
$LN2@is_resizea:

; 374  :     PyErr_Format(PyExc_TypeError,
; 375  :                  "mmap can't resize a readonly or copy-on-write memory map.");

  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DK@MOJPDOHG@mmap?5can?8t?5resize?5a?5readonly?5or?5@
  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0005f	e8 00 00 00 00	 call	 PyErr_Format

; 376  :     return 0;

  00064	33 c0		 xor	 eax, eax
$LN4@is_resizea:

; 377  : }

  00066	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006a	c3		 ret	 0
is_resizeable ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_tell_method DD imagerel mmap_tell_method
	DD	imagerel mmap_tell_method+77
	DD	imagerel $unwind$mmap_tell_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_tell_method DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mmap_tell_method
_TEXT	SEGMENT
self$ = 48
unused$ = 56
mmap_tell_method PROC					; COMDAT

; 579  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@mmap_tell_:

; 580  :     CHECK_VALID(NULL);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	75 17		 jne	 SHORT $LN1@mmap_tell_
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString
  00030	33 c0		 xor	 eax, eax
  00032	eb 14		 jmp	 SHORT $LN5@mmap_tell_
$LN1@mmap_tell_:
  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 d4		 jne	 SHORT $LN4@mmap_tell_

; 581  :     return PyLong_FromSize_t(self->pos);

  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003f	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00043	e8 00 00 00 00	 call	 PyLong_FromSize_t
$LN5@mmap_tell_:

; 582  : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
mmap_tell_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@MFBDNAD@flush?5values?5out?5of?5range?$AA@ ; `string'
PUBLIC	??_C@_09IIMOPBDP@?$HMnn?3flush?$AA@		; `string'
EXTRN	__imp_FlushViewOfFile:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_flush_method DD imagerel mmap_flush_method
	DD	imagerel mmap_flush_method+246
	DD	imagerel $unwind$mmap_flush_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_flush_method DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BK@MFBDNAD@flush?5values?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BK@MFBDNAD@flush?5values?5out?5of?5range?$AA@ DB 'flush values out'
	DB	' of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_09IIMOPBDP@?$HMnn?3flush?$AA@
CONST	SEGMENT
??_C@_09IIMOPBDP@?$HMnn?3flush?$AA@ DB '|nn:flush', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_flush_method
_TEXT	SEGMENT
size$ = 32
offset$ = 40
self$ = 64
args$ = 72
mmap_flush_method PROC					; COMDAT

; 586  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 587  :     Py_ssize_t offset = 0;

  0000e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR offset$[rsp], 0

; 588  :     Py_ssize_t size = self->size;

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0001c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00020	48 89 44 24 20	 mov	 QWORD PTR size$[rsp], rax
$LN8@mmap_flush:

; 589  :     CHECK_VALID(NULL);

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0002a	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00032	75 1a		 jne	 SHORT $LN5@mmap_flush
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00042	e8 00 00 00 00	 call	 PyErr_SetString
  00047	33 c0		 xor	 eax, eax
  00049	e9 a3 00 00 00	 jmp	 $LN9@mmap_flush
$LN5@mmap_flush:
  0004e	33 c0		 xor	 eax, eax
  00050	85 c0		 test	 eax, eax
  00052	75 d1		 jne	 SHORT $LN8@mmap_flush

; 590  :     if (!PyArg_ParseTuple(args, "|nn:flush", &offset, &size))

  00054	4c 8d 4c 24 20	 lea	 r9, QWORD PTR size$[rsp]
  00059	4c 8d 44 24 28	 lea	 r8, QWORD PTR offset$[rsp]
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09IIMOPBDP@?$HMnn?3flush?$AA@
  00065	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0006a	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0006f	85 c0		 test	 eax, eax
  00071	75 04		 jne	 SHORT $LN4@mmap_flush

; 591  :         return NULL;

  00073	33 c0		 xor	 eax, eax
  00075	eb 7a		 jmp	 SHORT $LN9@mmap_flush
$LN4@mmap_flush:

; 592  :     if ((size_t)(offset + size) > self->size) {

  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR size$[rsp]
  0007c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR offset$[rsp]
  00081	48 03 c8	 add	 rcx, rax
  00084	48 8b c1	 mov	 rax, rcx
  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  0008c	48 3b 41 68	 cmp	 rax, QWORD PTR [rcx+104]
  00090	76 17		 jbe	 SHORT $LN3@mmap_flush

; 593  :         PyErr_SetString(PyExc_ValueError, "flush values out of range");

  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@MFBDNAD@flush?5values?5out?5of?5range?$AA@
  00099	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000a0	e8 00 00 00 00	 call	 PyErr_SetString

; 594  :         return NULL;

  000a5	33 c0		 xor	 eax, eax
  000a7	eb 48		 jmp	 SHORT $LN9@mmap_flush
$LN3@mmap_flush:

; 595  :     }
; 596  : 
; 597  :     if (self->access == ACCESS_READ || self->access == ACCESS_COPY)

  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000ae	83 b8 a0 00 00
	00 01		 cmp	 DWORD PTR [rax+160], 1
  000b5	74 0e		 je	 SHORT $LN1@mmap_flush
  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000bc	83 b8 a0 00 00
	00 03		 cmp	 DWORD PTR [rax+160], 3
  000c3	75 09		 jne	 SHORT $LN2@mmap_flush
$LN1@mmap_flush:

; 598  :         return PyLong_FromLong(0);

  000c5	33 c9		 xor	 ecx, ecx
  000c7	e8 00 00 00 00	 call	 PyLong_FromLong
  000cc	eb 23		 jmp	 SHORT $LN9@mmap_flush
$LN2@mmap_flush:

; 599  : 
; 600  : #ifdef MS_WINDOWS
; 601  :     return PyLong_FromLong((long) FlushViewOfFile(self->data+offset, size));

  000ce	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  000d3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d7	48 03 44 24 28	 add	 rax, QWORD PTR offset$[rsp]
  000dc	48 8b 54 24 20	 mov	 rdx, QWORD PTR size$[rsp]
  000e1	48 8b c8	 mov	 rcx, rax
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FlushViewOfFile
  000ea	8b c8		 mov	 ecx, eax
  000ec	e8 00 00 00 00	 call	 PyLong_FromLong
$LN9@mmap_flush:

; 602  : #elif defined(UNIX)
; 603  :     /* XXX semantics of return value? */
; 604  :     /* XXX flags for msync? */
; 605  :     if (-1 == msync(self->data + offset, size, MS_SYNC)) {
; 606  :         PyErr_SetFromErrno(PyExc_OSError);
; 607  :         return NULL;
; 608  :     }
; 609  :     return PyLong_FromLong(0);
; 610  : #else
; 611  :     PyErr_SetString(PyExc_ValueError, "flush not supported on this system");
; 612  :     return NULL;
; 613  : #endif
; 614  : }

  000f1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f5	c3		 ret	 0
mmap_flush_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@IMILDMPF@seek?5out?5of?5range?$AA@	; `string'
PUBLIC	??_C@_0BC@FKNDPHMG@unknown?5seek?5type?$AA@	; `string'
PUBLIC	??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_seek_method DD imagerel mmap_seek_method
	DD	imagerel mmap_seek_method+357
	DD	imagerel $unwind$mmap_seek_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_seek_method DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BC@IMILDMPF@seek?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BC@IMILDMPF@seek?5out?5of?5range?$AA@ DB 'seek out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FKNDPHMG@unknown?5seek?5type?$AA@
CONST	SEGMENT
??_C@_0BC@FKNDPHMG@unknown?5seek?5type?$AA@ DB 'unknown seek type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@
CONST	SEGMENT
??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@ DB 'n|i:seek', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_seek_method
_TEXT	SEGMENT
how$ = 32
dist$ = 40
where$120780 = 48
tv75 = 56
self$ = 80
args$ = 88
mmap_seek_method PROC					; COMDAT

; 618  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 619  :     Py_ssize_t dist;
; 620  :     int how=0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR how$[rsp], 0
$LN16@mmap_seek_:

; 621  :     CHECK_VALID(NULL);

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0001b	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00023	75 1a		 jne	 SHORT $LN13@mmap_seek_
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00033	e8 00 00 00 00	 call	 PyErr_SetString
  00038	33 c0		 xor	 eax, eax
  0003a	e9 21 01 00 00	 jmp	 $LN17@mmap_seek_
$LN13@mmap_seek_:
  0003f	33 c0		 xor	 eax, eax
  00041	85 c0		 test	 eax, eax
  00043	75 d1		 jne	 SHORT $LN16@mmap_seek_

; 622  :     if (!PyArg_ParseTuple(args, "n|i:seek", &dist, &how))

  00045	4c 8d 4c 24 20	 lea	 r9, QWORD PTR how$[rsp]
  0004a	4c 8d 44 24 28	 lea	 r8, QWORD PTR dist$[rsp]
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08LHPIDOMM@n?$HMi?3seek?$AA@
  00056	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  0005b	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00060	85 c0		 test	 eax, eax
  00062	75 0c		 jne	 SHORT $LN12@mmap_seek_

; 623  :         return NULL;

  00064	33 c0		 xor	 eax, eax
  00066	e9 f5 00 00 00	 jmp	 $LN17@mmap_seek_

; 624  :     else {

  0006b	e9 db 00 00 00	 jmp	 $LN11@mmap_seek_
$LN12@mmap_seek_:

; 625  :         size_t where;
; 626  :         switch (how) {

  00070	8b 44 24 20	 mov	 eax, DWORD PTR how$[rsp]
  00074	89 44 24 38	 mov	 DWORD PTR tv75[rsp], eax
  00078	83 7c 24 38 00	 cmp	 DWORD PTR tv75[rsp], 0
  0007d	74 10		 je	 SHORT $LN8@mmap_seek_
  0007f	83 7c 24 38 01	 cmp	 DWORD PTR tv75[rsp], 1
  00084	74 22		 je	 SHORT $LN6@mmap_seek_
  00086	83 7c 24 38 02	 cmp	 DWORD PTR tv75[rsp], 2
  0008b	74 48		 je	 SHORT $LN4@mmap_seek_
  0008d	eb 70		 jmp	 SHORT $LN2@mmap_seek_
$LN8@mmap_seek_:

; 627  :         case 0: /* relative to start */
; 628  :             if (dist < 0)

  0008f	48 83 7c 24 28
	00		 cmp	 QWORD PTR dist$[rsp], 0
  00095	7d 05		 jge	 SHORT $LN7@mmap_seek_

; 629  :                 goto onoutofrange;

  00097	e9 af 00 00 00	 jmp	 $onoutofrange$120787
$LN7@mmap_seek_:

; 630  :             where = dist;

  0009c	48 8b 44 24 28	 mov	 rax, QWORD PTR dist$[rsp]
  000a1	48 89 44 24 30	 mov	 QWORD PTR where$120780[rsp], rax

; 631  :             break;

  000a6	eb 6e		 jmp	 SHORT $LN9@mmap_seek_
$LN6@mmap_seek_:

; 632  :         case 1: /* relative to current position */
; 633  :             if ((Py_ssize_t)self->pos + dist < 0)

  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000ad	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000b1	48 03 44 24 28	 add	 rax, QWORD PTR dist$[rsp]
  000b6	48 85 c0	 test	 rax, rax
  000b9	7d 05		 jge	 SHORT $LN5@mmap_seek_

; 634  :                 goto onoutofrange;

  000bb	e9 8b 00 00 00	 jmp	 $onoutofrange$120787
$LN5@mmap_seek_:

; 635  :             where = self->pos + dist;

  000c0	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000c5	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000c9	48 03 44 24 28	 add	 rax, QWORD PTR dist$[rsp]
  000ce	48 89 44 24 30	 mov	 QWORD PTR where$120780[rsp], rax

; 636  :             break;

  000d3	eb 41		 jmp	 SHORT $LN9@mmap_seek_
$LN4@mmap_seek_:

; 637  :         case 2: /* relative to end */
; 638  :             if ((Py_ssize_t)self->size + dist < 0)

  000d5	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000da	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000de	48 03 44 24 28	 add	 rax, QWORD PTR dist$[rsp]
  000e3	48 85 c0	 test	 rax, rax
  000e6	7d 02		 jge	 SHORT $LN3@mmap_seek_

; 639  :                 goto onoutofrange;

  000e8	eb 61		 jmp	 SHORT $onoutofrange$120787
$LN3@mmap_seek_:

; 640  :             where = self->size + dist;

  000ea	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000ef	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f3	48 03 44 24 28	 add	 rax, QWORD PTR dist$[rsp]
  000f8	48 89 44 24 30	 mov	 QWORD PTR where$120780[rsp], rax

; 641  :             break;

  000fd	eb 17		 jmp	 SHORT $LN9@mmap_seek_
$LN2@mmap_seek_:

; 642  :         default:
; 643  :             PyErr_SetString(PyExc_ValueError, "unknown seek type");

  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@FKNDPHMG@unknown?5seek?5type?$AA@
  00106	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0010d	e8 00 00 00 00	 call	 PyErr_SetString

; 644  :             return NULL;

  00112	33 c0		 xor	 eax, eax
  00114	eb 4a		 jmp	 SHORT $LN17@mmap_seek_
$LN9@mmap_seek_:

; 645  :         }
; 646  :         if (where > self->size)

  00116	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0011b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011f	48 39 44 24 30	 cmp	 QWORD PTR where$120780[rsp], rax
  00124	76 02		 jbe	 SHORT $LN1@mmap_seek_

; 647  :             goto onoutofrange;

  00126	eb 23		 jmp	 SHORT $onoutofrange$120787
$LN1@mmap_seek_:

; 648  :         self->pos = where;

  00128	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  0012d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR where$120780[rsp]
  00132	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 649  :         Py_INCREF(Py_None);

  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0013d	e8 00 00 00 00	 call	 _Py_IncRef

; 650  :         return Py_None;

  00142	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00149	eb 15		 jmp	 SHORT $LN17@mmap_seek_
$LN11@mmap_seek_:
$onoutofrange$120787:

; 651  :     }
; 652  : 
; 653  :   onoutofrange:
; 654  :     PyErr_SetString(PyExc_ValueError, "seek out of range");

  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@IMILDMPF@seek?5out?5of?5range?$AA@
  00152	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00159	e8 00 00 00 00	 call	 PyErr_SetString

; 655  :     return NULL;

  0015e	33 c0		 xor	 eax, eax
$LN17@mmap_seek_:

; 656  : }

  00160	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00164	c3		 ret	 0
mmap_seek_method ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@GLEHCJNM@source?0?5destination?0?5or?5count?5ou@ ; `string'
PUBLIC	??_C@_08CMAAKLLI@kkk?3move?$AA@			; `string'
EXTRN	__imp_memmove:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_move_method DD imagerel mmap_move_method
	DD	imagerel mmap_move_method+346
	DD	imagerel $unwind$mmap_move_method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_move_method DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0CL@GLEHCJNM@source?0?5destination?0?5or?5count?5ou@
CONST	SEGMENT
??_C@_0CL@GLEHCJNM@source?0?5destination?0?5or?5count?5ou@ DB 'source, de'
	DB	'stination, or count out of range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CMAAKLLI@kkk?3move?$AA@
CONST	SEGMENT
??_C@_08CMAAKLLI@kkk?3move?$AA@ DB 'kkk:move', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_move_method
_TEXT	SEGMENT
cnt$ = 48
dest$ = 52
src$ = 56
tv140 = 64
self$ = 96
args$ = 104
mmap_move_method PROC					; COMDAT

; 660  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN9@mmap_move_:

; 661  :     unsigned long dest, src, cnt;
; 662  :     CHECK_VALID(NULL);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	75 1a		 jne	 SHORT $LN6@mmap_move_
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString
  00030	33 c0		 xor	 eax, eax
  00032	e9 1e 01 00 00	 jmp	 $LN10@mmap_move_
$LN6@mmap_move_:
  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 d1		 jne	 SHORT $LN9@mmap_move_

; 663  :     if (!PyArg_ParseTuple(args, "kkk:move", &dest, &src, &cnt) ||
; 664  :         !is_writable(self)) {

  0003d	48 8d 44 24 30	 lea	 rax, QWORD PTR cnt$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	4c 8d 4c 24 38	 lea	 r9, QWORD PTR src$[rsp]
  0004c	4c 8d 44 24 34	 lea	 r8, QWORD PTR dest$[rsp]
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08CMAAKLLI@kkk?3move?$AA@
  00058	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0005d	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00062	85 c0		 test	 eax, eax
  00064	74 0e		 je	 SHORT $LN4@mmap_move_
  00066	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  0006b	e8 00 00 00 00	 call	 is_writable
  00070	85 c0		 test	 eax, eax
  00072	75 0c		 jne	 SHORT $LN5@mmap_move_
$LN4@mmap_move_:

; 665  :         return NULL;

  00074	33 c0		 xor	 eax, eax
  00076	e9 da 00 00 00	 jmp	 $LN10@mmap_move_

; 666  :     } else {

  0007b	e9 d5 00 00 00	 jmp	 $LN3@mmap_move_
$LN5@mmap_move_:

; 667  :         /* bounds check the values */
; 668  :         if ((cnt + dest) < cnt || (cnt + src) < cnt ||
; 669  :            src > self->size || (src + cnt) > self->size ||
; 670  :            dest > self->size || (dest + cnt) > self->size) {

  00080	8b 44 24 34	 mov	 eax, DWORD PTR dest$[rsp]
  00084	8b 4c 24 30	 mov	 ecx, DWORD PTR cnt$[rsp]
  00088	03 c8		 add	 ecx, eax
  0008a	8b c1		 mov	 eax, ecx
  0008c	3b 44 24 30	 cmp	 eax, DWORD PTR cnt$[rsp]
  00090	72 62		 jb	 SHORT $LN1@mmap_move_
  00092	8b 44 24 38	 mov	 eax, DWORD PTR src$[rsp]
  00096	8b 4c 24 30	 mov	 ecx, DWORD PTR cnt$[rsp]
  0009a	03 c8		 add	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	3b 44 24 30	 cmp	 eax, DWORD PTR cnt$[rsp]
  000a2	72 50		 jb	 SHORT $LN1@mmap_move_
  000a4	8b 44 24 38	 mov	 eax, DWORD PTR src$[rsp]
  000a8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000ad	48 3b 41 68	 cmp	 rax, QWORD PTR [rcx+104]
  000b1	77 41		 ja	 SHORT $LN1@mmap_move_
  000b3	8b 44 24 30	 mov	 eax, DWORD PTR cnt$[rsp]
  000b7	8b 4c 24 38	 mov	 ecx, DWORD PTR src$[rsp]
  000bb	03 c8		 add	 ecx, eax
  000bd	8b c1		 mov	 eax, ecx
  000bf	8b c0		 mov	 eax, eax
  000c1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000c6	48 3b 41 68	 cmp	 rax, QWORD PTR [rcx+104]
  000ca	77 28		 ja	 SHORT $LN1@mmap_move_
  000cc	8b 44 24 34	 mov	 eax, DWORD PTR dest$[rsp]
  000d0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000d5	48 3b 41 68	 cmp	 rax, QWORD PTR [rcx+104]
  000d9	77 19		 ja	 SHORT $LN1@mmap_move_
  000db	8b 44 24 30	 mov	 eax, DWORD PTR cnt$[rsp]
  000df	8b 4c 24 34	 mov	 ecx, DWORD PTR dest$[rsp]
  000e3	03 c8		 add	 ecx, eax
  000e5	8b c1		 mov	 eax, ecx
  000e7	8b c0		 mov	 eax, eax
  000e9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000ee	48 3b 41 68	 cmp	 rax, QWORD PTR [rcx+104]
  000f2	76 17		 jbe	 SHORT $LN2@mmap_move_
$LN1@mmap_move_:

; 671  :             PyErr_SetString(PyExc_ValueError,
; 672  :                 "source, destination, or count out of range");

  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@GLEHCJNM@source?0?5destination?0?5or?5count?5ou@
  000fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00102	e8 00 00 00 00	 call	 PyErr_SetString

; 673  :             return NULL;

  00107	33 c0		 xor	 eax, eax
  00109	eb 4a		 jmp	 SHORT $LN10@mmap_move_
$LN2@mmap_move_:

; 674  :         }
; 675  :         memmove(self->data+dest, self->data+src, cnt);

  0010b	8b 44 24 30	 mov	 eax, DWORD PTR cnt$[rsp]
  0010f	8b 4c 24 38	 mov	 ecx, DWORD PTR src$[rsp]
  00113	48 8b 54 24 60	 mov	 rdx, QWORD PTR self$[rsp]
  00118	48 03 4a 60	 add	 rcx, QWORD PTR [rdx+96]
  0011c	8b 54 24 34	 mov	 edx, DWORD PTR dest$[rsp]
  00120	4c 8b 44 24 60	 mov	 r8, QWORD PTR self$[rsp]
  00125	49 03 50 60	 add	 rdx, QWORD PTR [r8+96]
  00129	48 89 54 24 40	 mov	 QWORD PTR tv140[rsp], rdx
  0012e	44 8b c0	 mov	 r8d, eax
  00131	48 8b d1	 mov	 rdx, rcx
  00134	48 8b 44 24 40	 mov	 rax, QWORD PTR tv140[rsp]
  00139	48 8b c8	 mov	 rcx, rax
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 676  :         Py_INCREF(Py_None);

  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00149	e8 00 00 00 00	 call	 _Py_IncRef

; 677  :         return Py_None;

  0014e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@mmap_move_:
$LN10@mmap_move_:

; 678  :     }
; 679  : }

  00155	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00159	c3		 ret	 0
mmap_move_method ENDP
_TEXT	ENDS
EXTRN	PyBool_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_closed_get DD imagerel mmap_closed_get
	DD	imagerel mmap_closed_get+56
	DD	imagerel $unwind$mmap_closed_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_closed_get DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mmap_closed_get
_TEXT	SEGMENT
tv67 = 32
self$ = 64
mmap_closed_get PROC					; COMDAT

; 683  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 684  : #ifdef MS_WINDOWS
; 685  :     return PyBool_FromLong(self->map_handle == NULL ? 1 : 0);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00016	75 0a		 jne	 SHORT $LN3@mmap_close@2
  00018	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  00020	eb 08		 jmp	 SHORT $LN4@mmap_close@2
$LN3@mmap_close@2:
  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@mmap_close@2:
  0002a	8b 4c 24 20	 mov	 ecx, DWORD PTR tv67[rsp]
  0002e	e8 00 00 00 00	 call	 PyBool_FromLong

; 686  : #elif defined(UNIX)
; 687  :     return PyBool_FromLong(self->data == NULL ? 1 : 0);
; 688  : #endif
; 689  : }

  00033	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00037	c3		 ret	 0
mmap_closed_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap__enter__method DD imagerel mmap__enter__method
	DD	imagerel mmap__enter__method+78
	DD	imagerel $unwind$mmap__enter__method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap__enter__method DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mmap__enter__method
_TEXT	SEGMENT
self$ = 48
args$ = 56
mmap__enter__method PROC				; COMDAT

; 693  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@mmap__ente:

; 694  :     CHECK_VALID(NULL);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	75 17		 jne	 SHORT $LN1@mmap__ente
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString
  00030	33 c0		 xor	 eax, eax
  00032	eb 15		 jmp	 SHORT $LN5@mmap__ente
$LN1@mmap__ente:
  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 d4		 jne	 SHORT $LN4@mmap__ente

; 695  : 
; 696  :     Py_INCREF(self);

  0003a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  0003f	e8 00 00 00 00	 call	 _Py_IncRef

; 697  :     return (PyObject *)self;

  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
$LN5@mmap__ente:

; 698  : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
mmap__enter__method ENDP
_TEXT	ENDS
EXTRN	_PyObject_CallMethodId_SizeT:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap__exit__method DD imagerel mmap__exit__method
	DD	imagerel mmap__exit__method+61
	DD	imagerel $unwind$mmap__exit__method
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap__exit__method DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mmap__exit__method
_TEXT	SEGMENT
self$ = 48
args$ = 56
mmap__exit__method PROC					; COMDAT

; 702  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 703  :     _Py_IDENTIFIER(close);
; 704  : 
; 705  :     return _PyObject_CallMethodId(self, &PyId_close, NULL);

  0000e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_close@?1??mmap__exit__method@@9@9
  00013	8b c0		 mov	 eax, eax
  00015	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0001b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00024	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00028	45 33 c0	 xor	 r8d, r8d
  0002b	48 8b d0	 mov	 rdx, rax
  0002e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR self$[rsp]
  00033	e8 00 00 00 00	 call	 _PyObject_CallMethodId_SizeT

; 706  : }

  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	c3		 ret	 0
mmap__exit__method ENDP
_TEXT	ENDS
EXTRN	PyBuffer_FillInfo:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_buffer_getbuf DD imagerel mmap_buffer_getbuf
	DD	imagerel mmap_buffer_getbuf+189
	DD	imagerel $unwind$mmap_buffer_getbuf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_buffer_getbuf DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mmap_buffer_getbuf
_TEXT	SEGMENT
tv73 = 48
self$ = 80
view$ = 88
flags$ = 96
mmap_buffer_getbuf PROC					; COMDAT

; 738  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN5@mmap_buffe:

; 739  :     CHECK_VALID(-1);

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00020	75 1a		 jne	 SHORT $LN2@mmap_buffe
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00030	e8 00 00 00 00	 call	 PyErr_SetString
  00035	b8 ff ff ff ff	 mov	 eax, -1
  0003a	eb 7c		 jmp	 SHORT $LN6@mmap_buffe
$LN2@mmap_buffe:
  0003c	33 c0		 xor	 eax, eax
  0003e	85 c0		 test	 eax, eax
  00040	75 d1		 jne	 SHORT $LN5@mmap_buffe

; 740  :     if (PyBuffer_FillInfo(view, (PyObject*)self, self->data, self->size,
; 741  :                           (self->access == ACCESS_READ), flags) < 0)

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00047	83 b8 a0 00 00
	00 01		 cmp	 DWORD PTR [rax+160], 1
  0004e	75 0a		 jne	 SHORT $LN8@mmap_buffe
  00050	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00058	eb 08		 jmp	 SHORT $LN9@mmap_buffe
$LN8@mmap_buffe:
  0005a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN9@mmap_buffe:
  00062	8b 44 24 60	 mov	 eax, DWORD PTR flags$[rsp]
  00066	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0006a	8b 44 24 30	 mov	 eax, DWORD PTR tv73[rsp]
  0006e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00072	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00077	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  00080	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00084	48 8b 54 24 50	 mov	 rdx, QWORD PTR self$[rsp]
  00089	48 8b 4c 24 58	 mov	 rcx, QWORD PTR view$[rsp]
  0008e	e8 00 00 00 00	 call	 PyBuffer_FillInfo
  00093	85 c0		 test	 eax, eax
  00095	7d 07		 jge	 SHORT $LN1@mmap_buffe

; 742  :         return -1;

  00097	b8 ff ff ff ff	 mov	 eax, -1
  0009c	eb 1a		 jmp	 SHORT $LN6@mmap_buffe
$LN1@mmap_buffe:

; 743  :     self->exports++;

  0009e	48 8b 44 24 50	 mov	 rax, QWORD PTR self$[rsp]
  000a3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000a9	ff c0		 inc	 eax
  000ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  000b0	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 744  :     return 0;

  000b6	33 c0		 xor	 eax, eax
$LN6@mmap_buffe:

; 745  : }

  000b8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bc	c3		 ret	 0
mmap_buffer_getbuf ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT mmap_buffer_releasebuf
_TEXT	SEGMENT
self$ = 8
view$ = 16
mmap_buffer_releasebuf PROC				; COMDAT

; 749  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 750  :     self->exports--;

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR self$[rsp]
  0000f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00015	ff c8		 dec	 eax
  00017	48 8b 4c 24 08	 mov	 rcx, QWORD PTR self$[rsp]
  0001c	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 751  : }

  00022	c3		 ret	 0
mmap_buffer_releasebuf ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_length DD imagerel mmap_length
	DD	imagerel mmap_length+72
	DD	imagerel $unwind$mmap_length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_length DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT mmap_length
_TEXT	SEGMENT
self$ = 48
mmap_length PROC					; COMDAT

; 755  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@mmap_lengt:

; 756  :     CHECK_VALID(-1);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0000e	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00016	75 1c		 jne	 SHORT $LN1@mmap_lengt
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  0001f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00026	e8 00 00 00 00	 call	 PyErr_SetString
  0002b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00032	eb 0f		 jmp	 SHORT $LN5@mmap_lengt
$LN1@mmap_lengt:
  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 cf		 jne	 SHORT $LN4@mmap_lengt

; 757  :     return self->size;

  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0003f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
$LN5@mmap_lengt:

; 758  : }

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
mmap_length ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@OLHKLCDF@mmap?5index?5out?5of?5range?$AA@ ; `string'
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_item DD imagerel mmap_item
	DD	imagerel mmap_item+137
	DD	imagerel $unwind$mmap_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_item DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0BI@OLHKLCDF@mmap?5index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BI@OLHKLCDF@mmap?5index?5out?5of?5range?$AA@ DB 'mmap index out of'
	DB	' range', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_item
_TEXT	SEGMENT
self$ = 48
i$ = 56
mmap_item PROC						; COMDAT

; 762  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN6@mmap_item:

; 763  :     CHECK_VALID(NULL);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	75 17		 jne	 SHORT $LN3@mmap_item
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString
  00030	33 c0		 xor	 eax, eax
  00032	eb 50		 jmp	 SHORT $LN7@mmap_item
$LN3@mmap_item:
  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 d4		 jne	 SHORT $LN6@mmap_item

; 764  :     if (i < 0 || (size_t)i >= self->size) {

  0003a	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$[rsp], 0
  00040	7c 10		 jl	 SHORT $LN1@mmap_item
  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00047	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004b	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00050	72 17		 jb	 SHORT $LN2@mmap_item
$LN1@mmap_item:

; 765  :         PyErr_SetString(PyExc_IndexError, "mmap index out of range");

  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@OLHKLCDF@mmap?5index?5out?5of?5range?$AA@
  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00060	e8 00 00 00 00	 call	 PyErr_SetString

; 766  :         return NULL;

  00065	33 c0		 xor	 eax, eax
  00067	eb 1b		 jmp	 SHORT $LN7@mmap_item
$LN2@mmap_item:

; 767  :     }
; 768  :     return PyBytes_FromStringAndSize(self->data + i, 1);

  00069	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  0006e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00072	48 03 44 24 38	 add	 rax, QWORD PTR i$[rsp]
  00077	ba 01 00 00 00	 mov	 edx, 1
  0007c	48 8b c8	 mov	 rcx, rax
  0007f	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
$LN7@mmap_item:

; 769  : }

  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
mmap_item ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@CNGHHAPG@mmap?5indices?5must?5be?5integers?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	PySlice_GetIndicesEx:PROC
EXTRN	PySlice_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_subscript DD imagerel mmap_subscript
	DD	imagerel mmap_subscript+691
	DD	imagerel $unwind$mmap_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_subscript DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_0BO@CNGHHAPG@mmap?5indices?5must?5be?5integers?$AA@
CONST	SEGMENT
??_C@_0BO@CNGHHAPG@mmap?5indices?5must?5be?5integers?$AA@ DB 'mmap indice'
	DB	's must be integers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_subscript
_TEXT	SEGMENT
i$120957 = 48
step$120971 = 56
stop$120970 = 64
start$120969 = 72
slicelen$120972 = 80
i$120983 = 88
cur$120982 = 96
result$120984 = 104
result_buf$120980 = 112
self$ = 144
item$ = 152
mmap_subscript PROC					; COMDAT

; 773  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
$LN21@mmap_subsc:

; 774  :     CHECK_VALID(NULL);

  00011	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00019	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00021	75 1a		 jne	 SHORT $LN18@mmap_subsc
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00031	e8 00 00 00 00	 call	 PyErr_SetString
  00036	33 c0		 xor	 eax, eax
  00038	e9 6e 02 00 00	 jmp	 $LN22@mmap_subsc
$LN18@mmap_subsc:
  0003d	33 c0		 xor	 eax, eax
  0003f	85 c0		 test	 eax, eax
  00041	75 ce		 jne	 SHORT $LN21@mmap_subsc

; 775  :     if (PyIndex_Check(item)) {

  00043	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  0004b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004f	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00057	0f 84 da 00 00
	00		 je	 $LN17@mmap_subsc
  0005d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00065	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00069	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00070	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00078	0f 84 b9 00 00
	00		 je	 $LN17@mmap_subsc

; 776  :         Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  0007e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  00085	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  0008d	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00092	48 89 44 24 30	 mov	 QWORD PTR i$120957[rsp], rax

; 777  :         if (i == -1 && PyErr_Occurred())

  00097	48 83 7c 24 30
	ff		 cmp	 QWORD PTR i$120957[rsp], -1
  0009d	75 11		 jne	 SHORT $LN16@mmap_subsc
  0009f	e8 00 00 00 00	 call	 PyErr_Occurred
  000a4	48 85 c0	 test	 rax, rax
  000a7	74 07		 je	 SHORT $LN16@mmap_subsc

; 778  :             return NULL;

  000a9	33 c0		 xor	 eax, eax
  000ab	e9 fb 01 00 00	 jmp	 $LN22@mmap_subsc
$LN16@mmap_subsc:

; 779  :         if (i < 0)

  000b0	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$120957[rsp], 0
  000b6	7d 1c		 jge	 SHORT $LN15@mmap_subsc

; 780  :             i += self->size;

  000b8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000c0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$120957[rsp]
  000c9	48 03 c8	 add	 rcx, rax
  000cc	48 8b c1	 mov	 rax, rcx
  000cf	48 89 44 24 30	 mov	 QWORD PTR i$120957[rsp], rax
$LN15@mmap_subsc:

; 781  :         if (i < 0 || (size_t)i >= self->size) {

  000d4	48 83 7c 24 30
	00		 cmp	 QWORD PTR i$120957[rsp], 0
  000da	7c 13		 jl	 SHORT $LN13@mmap_subsc
  000dc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000e4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e8	48 39 44 24 30	 cmp	 QWORD PTR i$120957[rsp], rax
  000ed	72 1a		 jb	 SHORT $LN14@mmap_subsc
$LN13@mmap_subsc:

; 782  :             PyErr_SetString(PyExc_IndexError,
; 783  :                 "mmap index out of range");

  000ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@OLHKLCDF@mmap?5index?5out?5of?5range?$AA@
  000f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000fd	e8 00 00 00 00	 call	 PyErr_SetString

; 784  :             return NULL;

  00102	33 c0		 xor	 eax, eax
  00104	e9 a2 01 00 00	 jmp	 $LN22@mmap_subsc
$LN14@mmap_subsc:

; 785  :         }
; 786  :         return PyLong_FromLong(Py_CHARMASK(self->data[i]));

  00109	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00111	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00115	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$120957[rsp]
  0011a	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0011e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00123	0f b6 c0	 movzx	 eax, al
  00126	8b c8		 mov	 ecx, eax
  00128	e8 00 00 00 00	 call	 PyLong_FromLong
  0012d	e9 79 01 00 00	 jmp	 $LN22@mmap_subsc
  00132	e9 74 01 00 00	 jmp	 $LN12@mmap_subsc
$LN17@mmap_subsc:

; 787  :     }
; 788  :     else if (PySlice_Check(item)) {

  00137	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  0013e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00146	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0014a	0f 85 46 01 00
	00		 jne	 $LN11@mmap_subsc

; 789  :         Py_ssize_t start, stop, step, slicelen;
; 790  : 
; 791  :         if (PySlice_GetIndicesEx(item, self->size,
; 792  :                          &start, &stop, &step, &slicelen) < 0) {

  00150	48 8d 44 24 50	 lea	 rax, QWORD PTR slicelen$120972[rsp]
  00155	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0015a	48 8d 44 24 38	 lea	 rax, QWORD PTR step$120971[rsp]
  0015f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00164	4c 8d 4c 24 40	 lea	 r9, QWORD PTR stop$120970[rsp]
  00169	4c 8d 44 24 48	 lea	 r8, QWORD PTR start$120969[rsp]
  0016e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00176	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  0017a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00182	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  00187	85 c0		 test	 eax, eax
  00189	7d 07		 jge	 SHORT $LN10@mmap_subsc

; 793  :             return NULL;

  0018b	33 c0		 xor	 eax, eax
  0018d	e9 19 01 00 00	 jmp	 $LN22@mmap_subsc
$LN10@mmap_subsc:

; 794  :         }
; 795  : 
; 796  :         if (slicelen <= 0)

  00192	48 83 7c 24 50
	00		 cmp	 QWORD PTR slicelen$120972[rsp], 0
  00198	7f 18		 jg	 SHORT $LN9@mmap_subsc

; 797  :             return PyBytes_FromStringAndSize("", 0);

  0019a	33 d2		 xor	 edx, edx
  0019c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  001a3	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  001a8	e9 fe 00 00 00	 jmp	 $LN22@mmap_subsc
  001ad	e9 e2 00 00 00	 jmp	 $LN8@mmap_subsc
$LN9@mmap_subsc:

; 798  :         else if (step == 1)

  001b2	48 83 7c 24 38
	01		 cmp	 QWORD PTR step$120971[rsp], 1
  001b8	75 28		 jne	 SHORT $LN7@mmap_subsc

; 799  :             return PyBytes_FromStringAndSize(self->data + start,
; 800  :                                               slicelen);

  001ba	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  001c2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001c6	48 03 44 24 48	 add	 rax, QWORD PTR start$120969[rsp]
  001cb	48 8b 54 24 50	 mov	 rdx, QWORD PTR slicelen$120972[rsp]
  001d0	48 8b c8	 mov	 rcx, rax
  001d3	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  001d8	e9 ce 00 00 00	 jmp	 $LN22@mmap_subsc

; 801  :         else {

  001dd	e9 b2 00 00 00	 jmp	 $LN6@mmap_subsc
$LN7@mmap_subsc:

; 802  :             char *result_buf = (char *)PyMem_Malloc(slicelen);

  001e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR slicelen$120972[rsp]
  001e7	e8 00 00 00 00	 call	 PyMem_Malloc
  001ec	48 89 44 24 70	 mov	 QWORD PTR result_buf$120980[rsp], rax

; 803  :             Py_ssize_t cur, i;
; 804  :             PyObject *result;
; 805  : 
; 806  :             if (result_buf == NULL)

  001f1	48 83 7c 24 70
	00		 cmp	 QWORD PTR result_buf$120980[rsp], 0
  001f7	75 0a		 jne	 SHORT $LN5@mmap_subsc

; 807  :                 return PyErr_NoMemory();

  001f9	e8 00 00 00 00	 call	 PyErr_NoMemory
  001fe	e9 a8 00 00 00	 jmp	 $LN22@mmap_subsc
$LN5@mmap_subsc:

; 808  :             for (cur = start, i = 0; i < slicelen;
; 809  :                  cur += step, i++) {

  00203	48 8b 44 24 48	 mov	 rax, QWORD PTR start$120969[rsp]
  00208	48 89 44 24 60	 mov	 QWORD PTR cur$120982[rsp], rax
  0020d	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR i$120983[rsp], 0
  00216	eb 22		 jmp	 SHORT $LN4@mmap_subsc
$LN3@mmap_subsc:
  00218	48 8b 44 24 38	 mov	 rax, QWORD PTR step$120971[rsp]
  0021d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cur$120982[rsp]
  00222	48 03 c8	 add	 rcx, rax
  00225	48 8b c1	 mov	 rax, rcx
  00228	48 89 44 24 60	 mov	 QWORD PTR cur$120982[rsp], rax
  0022d	48 8b 44 24 58	 mov	 rax, QWORD PTR i$120983[rsp]
  00232	48 ff c0	 inc	 rax
  00235	48 89 44 24 58	 mov	 QWORD PTR i$120983[rsp], rax
$LN4@mmap_subsc:
  0023a	48 8b 44 24 50	 mov	 rax, QWORD PTR slicelen$120972[rsp]
  0023f	48 39 44 24 58	 cmp	 QWORD PTR i$120983[rsp], rax
  00244	7d 29		 jge	 SHORT $LN2@mmap_subsc

; 810  :                 result_buf[i] = self->data[cur];

  00246	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0024e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00252	48 8b 4c 24 58	 mov	 rcx, QWORD PTR i$120983[rsp]
  00257	48 8b 54 24 70	 mov	 rdx, QWORD PTR result_buf$120980[rsp]
  0025c	48 03 d1	 add	 rdx, rcx
  0025f	48 8b ca	 mov	 rcx, rdx
  00262	48 8b 54 24 60	 mov	 rdx, QWORD PTR cur$120982[rsp]
  00267	0f b6 04 10	 movzx	 eax, BYTE PTR [rax+rdx]
  0026b	88 01		 mov	 BYTE PTR [rcx], al

; 811  :             }

  0026d	eb a9		 jmp	 SHORT $LN3@mmap_subsc
$LN2@mmap_subsc:

; 812  :             result = PyBytes_FromStringAndSize(result_buf,
; 813  :                                                 slicelen);

  0026f	48 8b 54 24 50	 mov	 rdx, QWORD PTR slicelen$120972[rsp]
  00274	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result_buf$120980[rsp]
  00279	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
  0027e	48 89 44 24 68	 mov	 QWORD PTR result$120984[rsp], rax

; 814  :             PyMem_Free(result_buf);

  00283	48 8b 4c 24 70	 mov	 rcx, QWORD PTR result_buf$120980[rsp]
  00288	e8 00 00 00 00	 call	 PyMem_Free

; 815  :             return result;

  0028d	48 8b 44 24 68	 mov	 rax, QWORD PTR result$120984[rsp]
  00292	eb 17		 jmp	 SHORT $LN22@mmap_subsc
$LN6@mmap_subsc:
$LN8@mmap_subsc:

; 816  :         }
; 817  :     }
; 818  :     else {

  00294	eb 15		 jmp	 SHORT $LN1@mmap_subsc
$LN11@mmap_subsc:

; 819  :         PyErr_SetString(PyExc_TypeError,
; 820  :                         "mmap indices must be integers");

  00296	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@CNGHHAPG@mmap?5indices?5must?5be?5integers?$AA@
  0029d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002a4	e8 00 00 00 00	 call	 PyErr_SetString

; 821  :         return NULL;

  002a9	33 c0		 xor	 eax, eax
$LN1@mmap_subsc:
$LN12@mmap_subsc:
$LN22@mmap_subsc:

; 822  :     }
; 823  : }

  002ab	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002b2	c3		 ret	 0
mmap_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@EDMKIJGP@mmaps?5don?8t?5support?5concatenatio@ ; `string'
EXTRN	PyExc_SystemError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_concat DD imagerel mmap_concat
	DD	imagerel mmap_concat+84
	DD	imagerel $unwind$mmap_concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_concat DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0CC@EDMKIJGP@mmaps?5don?8t?5support?5concatenatio@
CONST	SEGMENT
??_C@_0CC@EDMKIJGP@mmaps?5don?8t?5support?5concatenatio@ DB 'mmaps don''t'
	DB	' support concatenation', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_concat
_TEXT	SEGMENT
self$ = 48
bb$ = 56
mmap_concat PROC					; COMDAT

; 827  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@mmap_conca:

; 828  :     CHECK_VALID(NULL);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	75 17		 jne	 SHORT $LN1@mmap_conca
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString
  00030	33 c0		 xor	 eax, eax
  00032	eb 1b		 jmp	 SHORT $LN5@mmap_conca
$LN1@mmap_conca:
  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 d4		 jne	 SHORT $LN4@mmap_conca

; 829  :     PyErr_SetString(PyExc_SystemError,
; 830  :                     "mmaps don't support concatenation");

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@EDMKIJGP@mmaps?5don?8t?5support?5concatenatio@
  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00048	e8 00 00 00 00	 call	 PyErr_SetString

; 831  :     return NULL;

  0004d	33 c0		 xor	 eax, eax
$LN5@mmap_conca:

; 832  : }

  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
mmap_concat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@CPMDENKC@mmaps?5don?8t?5support?5repeat?5opera@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_repeat DD imagerel mmap_repeat
	DD	imagerel mmap_repeat+84
	DD	imagerel $unwind$mmap_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_repeat DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0CF@CPMDENKC@mmaps?5don?8t?5support?5repeat?5opera@
CONST	SEGMENT
??_C@_0CF@CPMDENKC@mmaps?5don?8t?5support?5repeat?5opera@ DB 'mmaps don'''
	DB	't support repeat operation', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_repeat
_TEXT	SEGMENT
self$ = 48
n$ = 56
mmap_repeat PROC					; COMDAT

; 836  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@mmap_repea:

; 837  :     CHECK_VALID(NULL);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR self$[rsp]
  00013	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0001b	75 17		 jne	 SHORT $LN1@mmap_repea
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0002b	e8 00 00 00 00	 call	 PyErr_SetString
  00030	33 c0		 xor	 eax, eax
  00032	eb 1b		 jmp	 SHORT $LN5@mmap_repea
$LN1@mmap_repea:
  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 d4		 jne	 SHORT $LN4@mmap_repea

; 838  :     PyErr_SetString(PyExc_SystemError,
; 839  :                     "mmaps don't support repeat operation");

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@CPMDENKC@mmaps?5don?8t?5support?5repeat?5opera@
  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00048	e8 00 00 00 00	 call	 PyErr_SetString

; 840  :     return NULL;

  0004d	33 c0		 xor	 eax, eax
$LN5@mmap_repea:

; 841  : }

  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
mmap_repeat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@GAHJEJOI@mmap?5assignment?5must?5be?5length?91@ ; `string'
PUBLIC	??_C@_0CK@KBIEBJOM@mmap?5object?5doesn?8t?5support?5item@ ; `string'
EXTRN	PyBytes_AsString:PROC
EXTRN	PyBytes_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_ass_item DD imagerel mmap_ass_item
	DD	imagerel mmap_ass_item+293
	DD	imagerel $unwind$mmap_ass_item
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_ass_item DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0CJ@GAHJEJOI@mmap?5assignment?5must?5be?5length?91@
CONST	SEGMENT
??_C@_0CJ@GAHJEJOI@mmap?5assignment?5must?5be?5length?91@ DB 'mmap assign'
	DB	'ment must be length-1 bytes()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KBIEBJOM@mmap?5object?5doesn?8t?5support?5item@
CONST	SEGMENT
??_C@_0CK@KBIEBJOM@mmap?5object?5doesn?8t?5support?5item@ DB 'mmap object'
	DB	' doesn''t support item deletion', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_ass_item
_TEXT	SEGMENT
buf$ = 32
self$ = 64
i$ = 72
v$ = 80
mmap_ass_item PROC					; COMDAT

; 845  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN10@mmap_ass_i:

; 846  :     const char *buf;
; 847  : 
; 848  :     CHECK_VALID(-1);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00018	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00020	75 1d		 jne	 SHORT $LN7@mmap_ass_i
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00030	e8 00 00 00 00	 call	 PyErr_SetString
  00035	b8 ff ff ff ff	 mov	 eax, -1
  0003a	e9 e1 00 00 00	 jmp	 $LN11@mmap_ass_i
$LN7@mmap_ass_i:
  0003f	33 c0		 xor	 eax, eax
  00041	85 c0		 test	 eax, eax
  00043	75 ce		 jne	 SHORT $LN10@mmap_ass_i

; 849  :     if (i < 0 || (size_t)i >= self->size) {

  00045	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  0004b	7c 10		 jl	 SHORT $LN5@mmap_ass_i
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  00052	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00056	48 39 44 24 48	 cmp	 QWORD PTR i$[rsp], rax
  0005b	72 1d		 jb	 SHORT $LN6@mmap_ass_i
$LN5@mmap_ass_i:

; 850  :         PyErr_SetString(PyExc_IndexError, "mmap index out of range");

  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@OLHKLCDF@mmap?5index?5out?5of?5range?$AA@
  00064	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0006b	e8 00 00 00 00	 call	 PyErr_SetString

; 851  :         return -1;

  00070	b8 ff ff ff ff	 mov	 eax, -1
  00075	e9 a6 00 00 00	 jmp	 $LN11@mmap_ass_i
$LN6@mmap_ass_i:

; 852  :     }
; 853  :     if (v == NULL) {

  0007a	48 83 7c 24 50
	00		 cmp	 QWORD PTR v$[rsp], 0
  00080	75 1d		 jne	 SHORT $LN4@mmap_ass_i

; 854  :         PyErr_SetString(PyExc_TypeError,
; 855  :                         "mmap object doesn't support item deletion");

  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@KBIEBJOM@mmap?5object?5doesn?8t?5support?5item@
  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00090	e8 00 00 00 00	 call	 PyErr_SetString

; 856  :         return -1;

  00095	b8 ff ff ff ff	 mov	 eax, -1
  0009a	e9 81 00 00 00	 jmp	 $LN11@mmap_ass_i
$LN4@mmap_ass_i:

; 857  :     }
; 858  :     if (! (PyBytes_Check(v) && PyBytes_Size(v)==1) ) {

  0009f	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  000a4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a8	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000ae	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  000b3	85 c0		 test	 eax, eax
  000b5	74 10		 je	 SHORT $LN2@mmap_ass_i
  000b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000bc	e8 00 00 00 00	 call	 PyBytes_Size
  000c1	48 83 f8 01	 cmp	 rax, 1
  000c5	74 1a		 je	 SHORT $LN3@mmap_ass_i
$LN2@mmap_ass_i:

; 859  :         PyErr_SetString(PyExc_IndexError,
; 860  :                         "mmap assignment must be length-1 bytes()");

  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@GAHJEJOI@mmap?5assignment?5must?5be?5length?91@
  000ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  000d5	e8 00 00 00 00	 call	 PyErr_SetString

; 861  :         return -1;

  000da	b8 ff ff ff ff	 mov	 eax, -1
  000df	eb 3f		 jmp	 SHORT $LN11@mmap_ass_i
$LN3@mmap_ass_i:

; 862  :     }
; 863  :     if (!is_writable(self))

  000e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  000e6	e8 00 00 00 00	 call	 is_writable
  000eb	85 c0		 test	 eax, eax
  000ed	75 07		 jne	 SHORT $LN1@mmap_ass_i

; 864  :         return -1;

  000ef	b8 ff ff ff ff	 mov	 eax, -1
  000f4	eb 2a		 jmp	 SHORT $LN11@mmap_ass_i
$LN1@mmap_ass_i:

; 865  :     buf = PyBytes_AsString(v);

  000f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000fb	e8 00 00 00 00	 call	 PyBytes_AsString
  00100	48 89 44 24 20	 mov	 QWORD PTR buf$[rsp], rax

; 866  :     self->data[i] = buf[0];

  00105	48 8b 44 24 40	 mov	 rax, QWORD PTR self$[rsp]
  0010a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0010e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  00113	48 8b 54 24 20	 mov	 rdx, QWORD PTR buf$[rsp]
  00118	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  0011b	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 867  :     return 0;

  0011e	33 c0		 xor	 eax, eax
$LN11@mmap_ass_i:

; 868  : }

  00120	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00124	c3		 ret	 0
mmap_ass_item ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BN@KMJDFLHJ@mmap?5indices?5must?5be?5integer?$AA@ ; `string'
PUBLIC	??_C@_0CE@OJOLNMIH@mmap?5slice?5assignment?5is?5wrong?5s@ ; `string'
PUBLIC	??_C@_0CL@IONPCJKP@mmap?5object?5doesn?8t?5support?5slic@ ; `string'
PUBLIC	??_C@_0CJ@IDJECKPJ@mmap?5item?5value?5must?5be?5in?5range@ ; `string'
PUBLIC	??_C@_0BP@OFGMNLFP@mmap?5item?5value?5must?5be?5an?5int?$AA@ ; `string'
PUBLIC	??_C@_0CD@CHMIGJCN@mmap?5doesn?8t?5support?5item?5deleti@ ; `string'
EXTRN	PyBuffer_Release:PROC
EXTRN	PyObject_GetBuffer:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$mmap_ass_subscript DD imagerel mmap_ass_subscript
	DD	imagerel mmap_ass_subscript+1064
	DD	imagerel $unwind$mmap_ass_subscript
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mmap_ass_subscript DD 021601H
	DD	0190116H
xdata	ENDS
;	COMDAT ??_C@_0BN@KMJDFLHJ@mmap?5indices?5must?5be?5integer?$AA@
CONST	SEGMENT
??_C@_0BN@KMJDFLHJ@mmap?5indices?5must?5be?5integer?$AA@ DB 'mmap indices'
	DB	' must be integer', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OJOLNMIH@mmap?5slice?5assignment?5is?5wrong?5s@
CONST	SEGMENT
??_C@_0CE@OJOLNMIH@mmap?5slice?5assignment?5is?5wrong?5s@ DB 'mmap slice '
	DB	'assignment is wrong size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@IONPCJKP@mmap?5object?5doesn?8t?5support?5slic@
CONST	SEGMENT
??_C@_0CL@IONPCJKP@mmap?5object?5doesn?8t?5support?5slic@ DB 'mmap object'
	DB	' doesn''t support slice deletion', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IDJECKPJ@mmap?5item?5value?5must?5be?5in?5range@
CONST	SEGMENT
??_C@_0CJ@IDJECKPJ@mmap?5item?5value?5must?5be?5in?5range@ DB 'mmap item '
	DB	'value must be in range(0, 256)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OFGMNLFP@mmap?5item?5value?5must?5be?5an?5int?$AA@
CONST	SEGMENT
??_C@_0BP@OFGMNLFP@mmap?5item?5value?5must?5be?5an?5int?$AA@ DB 'mmap ite'
	DB	'm value must be an int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@CHMIGJCN@mmap?5doesn?8t?5support?5item?5deleti@
CONST	SEGMENT
??_C@_0CD@CHMIGJCN@mmap?5doesn?8t?5support?5item?5deleti@ DB 'mmap doesn'''
	DB	't support item deletion', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT mmap_ass_subscript
_TEXT	SEGMENT
v$121064 = 48
i$121063 = 56
vbuf$121090 = 64
step$121088 = 144
stop$121087 = 152
start$121086 = 160
slicelen$121089 = 168
i$121103 = 176
cur$121102 = 184
self$ = 208
item$ = 216
value$ = 224
mmap_ass_subscript PROC					; COMDAT

; 872  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
$LN30@mmap_ass_s:

; 873  :     CHECK_VALID(-1);

  00016	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0001e	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00026	75 1d		 jne	 SHORT $LN27@mmap_ass_s
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@MIHFAFBK@mmap?5closed?5or?5invalid?$AA@
  0002f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00036	e8 00 00 00 00	 call	 PyErr_SetString
  0003b	b8 ff ff ff ff	 mov	 eax, -1
  00040	e9 db 03 00 00	 jmp	 $LN31@mmap_ass_s
$LN27@mmap_ass_s:
  00045	33 c0		 xor	 eax, eax
  00047	85 c0		 test	 eax, eax
  00049	75 cb		 jne	 SHORT $LN30@mmap_ass_s

; 874  : 
; 875  :     if (!is_writable(self))

  0004b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00053	e8 00 00 00 00	 call	 is_writable
  00058	85 c0		 test	 eax, eax
  0005a	75 0a		 jne	 SHORT $LN26@mmap_ass_s

; 876  :         return -1;

  0005c	b8 ff ff ff ff	 mov	 eax, -1
  00061	e9 ba 03 00 00	 jmp	 $LN31@mmap_ass_s
$LN26@mmap_ass_s:

; 877  : 
; 878  :     if (PyIndex_Check(item)) {

  00066	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  0006e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00072	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  0007a	0f 84 b4 01 00
	00		 je	 $LN25@mmap_ass_s
  00080	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR item$[rsp]
  00088	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008c	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00093	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  0009b	0f 84 93 01 00
	00		 je	 $LN25@mmap_ass_s

; 879  :         Py_ssize_t i = PyNumber_AsSsize_t(item, PyExc_IndexError);

  000a1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  000a8	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  000b0	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  000b5	48 89 44 24 38	 mov	 QWORD PTR i$121063[rsp], rax

; 880  :         Py_ssize_t v;
; 881  : 
; 882  :         if (i == -1 && PyErr_Occurred())

  000ba	48 83 7c 24 38
	ff		 cmp	 QWORD PTR i$121063[rsp], -1
  000c0	75 14		 jne	 SHORT $LN24@mmap_ass_s
  000c2	e8 00 00 00 00	 call	 PyErr_Occurred
  000c7	48 85 c0	 test	 rax, rax
  000ca	74 0a		 je	 SHORT $LN24@mmap_ass_s

; 883  :             return -1;

  000cc	b8 ff ff ff ff	 mov	 eax, -1
  000d1	e9 4a 03 00 00	 jmp	 $LN31@mmap_ass_s
$LN24@mmap_ass_s:

; 884  :         if (i < 0)

  000d6	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$121063[rsp], 0
  000dc	7d 1c		 jge	 SHORT $LN23@mmap_ass_s

; 885  :             i += self->size;

  000de	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000e6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$121063[rsp]
  000ef	48 03 c8	 add	 rcx, rax
  000f2	48 8b c1	 mov	 rax, rcx
  000f5	48 89 44 24 38	 mov	 QWORD PTR i$121063[rsp], rax
$LN23@mmap_ass_s:

; 886  :         if (i < 0 || (size_t)i >= self->size) {

  000fa	48 83 7c 24 38
	00		 cmp	 QWORD PTR i$121063[rsp], 0
  00100	7c 13		 jl	 SHORT $LN21@mmap_ass_s
  00102	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0010a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010e	48 39 44 24 38	 cmp	 QWORD PTR i$121063[rsp], rax
  00113	72 1d		 jb	 SHORT $LN22@mmap_ass_s
$LN21@mmap_ass_s:

; 887  :             PyErr_SetString(PyExc_IndexError,
; 888  :                             "mmap index out of range");

  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@OLHKLCDF@mmap?5index?5out?5of?5range?$AA@
  0011c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00123	e8 00 00 00 00	 call	 PyErr_SetString

; 889  :             return -1;

  00128	b8 ff ff ff ff	 mov	 eax, -1
  0012d	e9 ee 02 00 00	 jmp	 $LN31@mmap_ass_s
$LN22@mmap_ass_s:

; 890  :         }
; 891  :         if (value == NULL) {

  00132	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR value$[rsp], 0
  0013b	75 1d		 jne	 SHORT $LN20@mmap_ass_s

; 892  :             PyErr_SetString(PyExc_TypeError,
; 893  :                             "mmap doesn't support item deletion");

  0013d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@CHMIGJCN@mmap?5doesn?8t?5support?5item?5deleti@
  00144	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0014b	e8 00 00 00 00	 call	 PyErr_SetString

; 894  :             return -1;

  00150	b8 ff ff ff ff	 mov	 eax, -1
  00155	e9 c6 02 00 00	 jmp	 $LN31@mmap_ass_s
$LN20@mmap_ass_s:

; 895  :         }
; 896  :         if (!PyIndex_Check(value)) {

  0015a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR value$[rsp]
  00162	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00166	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  0016e	74 1d		 je	 SHORT $LN18@mmap_ass_s
  00170	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR value$[rsp]
  00178	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0017c	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00183	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  0018b	75 1d		 jne	 SHORT $LN19@mmap_ass_s
$LN18@mmap_ass_s:

; 897  :             PyErr_SetString(PyExc_TypeError,
; 898  :                             "mmap item value must be an int");

  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@OFGMNLFP@mmap?5item?5value?5must?5be?5an?5int?$AA@
  00194	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0019b	e8 00 00 00 00	 call	 PyErr_SetString

; 899  :             return -1;

  001a0	b8 ff ff ff ff	 mov	 eax, -1
  001a5	e9 76 02 00 00	 jmp	 $LN31@mmap_ass_s
$LN19@mmap_ass_s:

; 900  :         }
; 901  :         v = PyNumber_AsSsize_t(value, PyExc_TypeError);

  001aa	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_TypeError
  001b1	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  001b9	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  001be	48 89 44 24 30	 mov	 QWORD PTR v$121064[rsp], rax

; 902  :         if (v == -1 && PyErr_Occurred())

  001c3	48 83 7c 24 30
	ff		 cmp	 QWORD PTR v$121064[rsp], -1
  001c9	75 14		 jne	 SHORT $LN17@mmap_ass_s
  001cb	e8 00 00 00 00	 call	 PyErr_Occurred
  001d0	48 85 c0	 test	 rax, rax
  001d3	74 0a		 je	 SHORT $LN17@mmap_ass_s

; 903  :             return -1;

  001d5	b8 ff ff ff ff	 mov	 eax, -1
  001da	e9 41 02 00 00	 jmp	 $LN31@mmap_ass_s
$LN17@mmap_ass_s:

; 904  :         if (v < 0 || v > 255) {

  001df	48 83 7c 24 30
	00		 cmp	 QWORD PTR v$121064[rsp], 0
  001e5	7c 0b		 jl	 SHORT $LN15@mmap_ass_s
  001e7	48 81 7c 24 30
	ff 00 00 00	 cmp	 QWORD PTR v$121064[rsp], 255 ; 000000ffH
  001f0	7e 1d		 jle	 SHORT $LN16@mmap_ass_s
$LN15@mmap_ass_s:

; 905  :             PyErr_SetString(PyExc_ValueError,
; 906  :                             "mmap item value must be "
; 907  :                             "in range(0, 256)");

  001f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@IDJECKPJ@mmap?5item?5value?5must?5be?5in?5range@
  001f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00200	e8 00 00 00 00	 call	 PyErr_SetString

; 908  :             return -1;

  00205	b8 ff ff ff ff	 mov	 eax, -1
  0020a	e9 11 02 00 00	 jmp	 $LN31@mmap_ass_s
$LN16@mmap_ass_s:

; 909  :         }
; 910  :         self->data[i] = (char) v;

  0020f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00217	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0021b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$121063[rsp]
  00220	0f b6 54 24 30	 movzx	 edx, BYTE PTR v$121064[rsp]
  00225	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 911  :         return 0;

  00228	33 c0		 xor	 eax, eax
  0022a	e9 f1 01 00 00	 jmp	 $LN31@mmap_ass_s
  0022f	e9 ec 01 00 00	 jmp	 $LN14@mmap_ass_s
$LN25@mmap_ass_s:

; 912  :     }
; 913  :     else if (PySlice_Check(item)) {

  00234	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PySlice_Type
  0023b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  00243	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00247	0f 85 bb 01 00
	00		 jne	 $LN13@mmap_ass_s

; 914  :         Py_ssize_t start, stop, step, slicelen;
; 915  :         Py_buffer vbuf;
; 916  : 
; 917  :         if (PySlice_GetIndicesEx(item,
; 918  :                                  self->size, &start, &stop,
; 919  :                                  &step, &slicelen) < 0) {

  0024d	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR slicelen$121089[rsp]
  00255	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025a	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR step$121088[rsp]
  00262	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00267	4c 8d 8c 24 98
	00 00 00	 lea	 r9, QWORD PTR stop$121087[rsp]
  0026f	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR start$121086[rsp]
  00277	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  0027f	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  00283	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR item$[rsp]
  0028b	e8 00 00 00 00	 call	 PySlice_GetIndicesEx
  00290	85 c0		 test	 eax, eax
  00292	7d 0a		 jge	 SHORT $LN12@mmap_ass_s

; 920  :             return -1;

  00294	b8 ff ff ff ff	 mov	 eax, -1
  00299	e9 82 01 00 00	 jmp	 $LN31@mmap_ass_s
$LN12@mmap_ass_s:

; 921  :         }
; 922  :         if (value == NULL) {

  0029e	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR value$[rsp], 0
  002a7	75 1d		 jne	 SHORT $LN11@mmap_ass_s

; 923  :             PyErr_SetString(PyExc_TypeError,
; 924  :                 "mmap object doesn't support slice deletion");

  002a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@IONPCJKP@mmap?5object?5doesn?8t?5support?5slic@
  002b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002b7	e8 00 00 00 00	 call	 PyErr_SetString

; 925  :             return -1;

  002bc	b8 ff ff ff ff	 mov	 eax, -1
  002c1	e9 5a 01 00 00	 jmp	 $LN31@mmap_ass_s
$LN11@mmap_ass_s:

; 926  :         }
; 927  :         if (PyObject_GetBuffer(value, &vbuf, PyBUF_SIMPLE) < 0)

  002c6	45 33 c0	 xor	 r8d, r8d
  002c9	48 8d 54 24 40	 lea	 rdx, QWORD PTR vbuf$121090[rsp]
  002ce	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  002d6	e8 00 00 00 00	 call	 PyObject_GetBuffer
  002db	85 c0		 test	 eax, eax
  002dd	7d 0a		 jge	 SHORT $LN10@mmap_ass_s

; 928  :             return -1;

  002df	b8 ff ff ff ff	 mov	 eax, -1
  002e4	e9 37 01 00 00	 jmp	 $LN31@mmap_ass_s
$LN10@mmap_ass_s:

; 929  :         if (vbuf.len != slicelen) {

  002e9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR slicelen$121089[rsp]
  002f1	48 39 44 24 50	 cmp	 QWORD PTR vbuf$121090[rsp+16], rax
  002f6	74 27		 je	 SHORT $LN9@mmap_ass_s

; 930  :             PyErr_SetString(PyExc_IndexError,
; 931  :                 "mmap slice assignment is wrong size");

  002f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@OJOLNMIH@mmap?5slice?5assignment?5is?5wrong?5s@
  002ff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00306	e8 00 00 00 00	 call	 PyErr_SetString

; 932  :             PyBuffer_Release(&vbuf);

  0030b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR vbuf$121090[rsp]
  00310	e8 00 00 00 00	 call	 PyBuffer_Release

; 933  :             return -1;

  00315	b8 ff ff ff ff	 mov	 eax, -1
  0031a	e9 01 01 00 00	 jmp	 $LN31@mmap_ass_s
$LN9@mmap_ass_s:

; 934  :         }
; 935  : 
; 936  :         if (slicelen == 0) {

  0031f	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR slicelen$121089[rsp], 0
  00328	75 05		 jne	 SHORT $LN8@mmap_ass_s
  0032a	e9 c9 00 00 00	 jmp	 $LN7@mmap_ass_s
$LN8@mmap_ass_s:

; 937  :         }
; 938  :         else if (step == 1) {

  0032f	48 83 bc 24 90
	00 00 00 01	 cmp	 QWORD PTR step$121088[rsp], 1
  00338	75 2e		 jne	 SHORT $LN6@mmap_ass_s

; 939  :             memcpy(self->data + start, vbuf.buf, slicelen);

  0033a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  00342	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00346	48 03 84 24 a0
	00 00 00	 add	 rax, QWORD PTR start$121086[rsp]
  0034e	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR slicelen$121089[rsp]
  00356	48 8b 54 24 40	 mov	 rdx, QWORD PTR vbuf$121090[rsp]
  0035b	48 8b c8	 mov	 rcx, rax
  0035e	e8 00 00 00 00	 call	 memcpy

; 940  :         }
; 941  :         else {

  00363	e9 90 00 00 00	 jmp	 $LN5@mmap_ass_s
$LN6@mmap_ass_s:

; 942  :             Py_ssize_t cur, i;
; 943  : 
; 944  :             for (cur = start, i = 0;
; 945  :                  i < slicelen;
; 946  :                  cur += step, i++)

  00368	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR start$121086[rsp]
  00370	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR cur$121102[rsp], rax
  00378	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR i$121103[rsp], 0
  00384	eb 31		 jmp	 SHORT $LN4@mmap_ass_s
$LN3@mmap_ass_s:
  00386	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR step$121088[rsp]
  0038e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR cur$121102[rsp]
  00396	48 03 c8	 add	 rcx, rax
  00399	48 8b c1	 mov	 rax, rcx
  0039c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR cur$121102[rsp], rax
  003a4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR i$121103[rsp]
  003ac	48 ff c0	 inc	 rax
  003af	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR i$121103[rsp], rax
$LN4@mmap_ass_s:
  003b7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR slicelen$121089[rsp]
  003bf	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR i$121103[rsp], rax
  003c7	7d 2f		 jge	 SHORT $LN2@mmap_ass_s

; 947  :             {
; 948  :                 self->data[cur] = ((char *)vbuf.buf)[i];

  003c9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  003d1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  003d5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR i$121103[rsp]
  003dd	48 8b 54 24 40	 mov	 rdx, QWORD PTR vbuf$121090[rsp]
  003e2	48 03 d1	 add	 rdx, rcx
  003e5	48 8b ca	 mov	 rcx, rdx
  003e8	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR cur$121102[rsp]
  003f0	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  003f3	88 0c 10	 mov	 BYTE PTR [rax+rdx], cl

; 949  :             }

  003f6	eb 8e		 jmp	 SHORT $LN3@mmap_ass_s
$LN2@mmap_ass_s:
$LN5@mmap_ass_s:
$LN7@mmap_ass_s:

; 950  :         }
; 951  :         PyBuffer_Release(&vbuf);

  003f8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR vbuf$121090[rsp]
  003fd	e8 00 00 00 00	 call	 PyBuffer_Release

; 952  :         return 0;

  00402	33 c0		 xor	 eax, eax
  00404	eb 1a		 jmp	 SHORT $LN31@mmap_ass_s

; 953  :     }
; 954  :     else {

  00406	eb 18		 jmp	 SHORT $LN1@mmap_ass_s
$LN13@mmap_ass_s:

; 955  :         PyErr_SetString(PyExc_TypeError,
; 956  :                         "mmap indices must be integer");

  00408	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMJDFLHJ@mmap?5indices?5must?5be?5integer?$AA@
  0040f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00416	e8 00 00 00 00	 call	 PyErr_SetString

; 957  :         return -1;

  0041b	b8 ff ff ff ff	 mov	 eax, -1
$LN1@mmap_ass_s:
$LN14@mmap_ass_s:
$LN31@mmap_ass_s:

; 958  :     }
; 959  : }

  00420	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00427	c3		 ret	 0
mmap_ass_subscript ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BJ@ILNJPNME@mmap?5length?5is?5too?5large?$AA@ ; `string'
PUBLIC	??_C@_0CG@JJJMKNMA@mmap?5offset?5is?5greater?5than?5file@ ; `string'
PUBLIC	??_C@_0BK@BFJDGGFK@cannot?5mmap?5an?5empty?5file?$AA@ ; `string'
PUBLIC	_Py_DecRef
PUBLIC	??_C@_0CG@ODNCCLGL@memory?5mapped?5offset?5must?5be?5pos@ ; `string'
PUBLIC	??_C@_0BP@MEHKOKFA@mmap?5invalid?5access?5parameter?4?$AA@ ; `string'
PUBLIC	??_C@_06KBNJCMJO@iO?$HMziL?$AA@			; `string'
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	__imp_DuplicateHandle:PROC
EXTRN	__imp_GetCurrentProcess:PROC
EXTRN	__imp_lseek:PROC
EXTRN	__imp__get_osfhandle:PROC
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_OSError:QWORD
EXTRN	_PyVerify_fd:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_mmap_object DD imagerel new_mmap_object
	DD	imagerel new_mmap_object+1862
	DD	imagerel $unwind$new_mmap_object
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_mmap_object DD 021601H
	DD	01d0116H
xdata	ENDS
;	COMDAT ??_C@_0BJ@ILNJPNME@mmap?5length?5is?5too?5large?$AA@
CONST	SEGMENT
??_C@_0BJ@ILNJPNME@mmap?5length?5is?5too?5large?$AA@ DB 'mmap length is t'
	DB	'oo large', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JJJMKNMA@mmap?5offset?5is?5greater?5than?5file@
CONST	SEGMENT
??_C@_0CG@JJJMKNMA@mmap?5offset?5is?5greater?5than?5file@ DB 'mmap offset'
	DB	' is greater than file size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BFJDGGFK@cannot?5mmap?5an?5empty?5file?$AA@
CONST	SEGMENT
??_C@_0BK@BFJDGGFK@cannot?5mmap?5an?5empty?5file?$AA@ DB 'cannot mmap an '
	DB	'empty file', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@ODNCCLGL@memory?5mapped?5offset?5must?5be?5pos@
CONST	SEGMENT
??_C@_0CG@ODNCCLGL@memory?5mapped?5offset?5must?5be?5pos@ DB 'memory mapp'
	DB	'ed offset must be positive', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@MEHKOKFA@mmap?5invalid?5access?5parameter?4?$AA@
CONST	SEGMENT
??_C@_0BP@MEHKOKFA@mmap?5invalid?5access?5parameter?4?$AA@ DB 'mmap inval'
	DB	'id access parameter.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06KBNJCMJO@iO?$HMziL?$AA@
CONST	SEGMENT
??_C@_06KBNJCMJO@iO?$HMziL?$AA@ DB 'iO|ziL', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT new_mmap_object
_TEXT	SEGMENT
fileno$ = 80
map_size_obj$ = 88
off_hi$ = 96
map_size$ = 104
size_hi$ = 112
off_lo$ = 116
access$ = 120
size_lo$ = 124
size$ = 128
offset$ = 136
m_obj$ = 144
dwDesiredAccess$ = 152
fh$ = 160
tagname$ = 168
dwErr$ = 176
flProtect$ = 180
high$121238 = 184
low$121237 = 188
tv75 = 192
tv150 = 200
tv152 = 208
type$ = 240
args$ = 248
kwdict$ = 256
new_mmap_object PROC					; COMDAT

; 1250 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 1251 :     mmap_object *m_obj;
; 1252 :     PyObject *map_size_obj = NULL;

  00016	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR map_size_obj$[rsp], 0

; 1253 :     Py_ssize_t map_size;
; 1254 :     PY_LONG_LONG offset = 0, size;

  0001f	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR offset$[rsp], 0

; 1255 :     DWORD off_hi;       /* upper 32 bits of offset */
; 1256 :     DWORD off_lo;       /* lower 32 bits of offset */
; 1257 :     DWORD size_hi;      /* upper 32 bits of size */
; 1258 :     DWORD size_lo;      /* lower 32 bits of size */
; 1259 :     char *tagname = "";

  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00032	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tagname$[rsp], rax

; 1260 :     DWORD dwErr = 0;

  0003a	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR dwErr$[rsp], 0

; 1261 :     int fileno;
; 1262 :     HANDLE fh = 0;

  00045	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR fh$[rsp], 0

; 1263 :     int access = (access_mode)ACCESS_DEFAULT;

  00051	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR access$[rsp], 0

; 1264 :     DWORD flProtect, dwDesiredAccess;
; 1265 :     static char *keywords[] = { "fileno", "length",
; 1266 :                                 "tagname",
; 1267 :                                 "access", "offset", NULL };
; 1268 : 
; 1269 :     if (!PyArg_ParseTupleAndKeywords(args, kwdict, "iO|ziL", keywords,
; 1270 :                                      &fileno, &map_size_obj,
; 1271 :                                      &tagname, &access, &offset)) {

  00059	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR offset$[rsp]
  00061	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00066	48 8d 44 24 78	 lea	 rax, QWORD PTR access$[rsp]
  0006b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00070	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR tagname$[rsp]
  00078	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0007d	48 8d 44 24 58	 lea	 rax, QWORD PTR map_size_obj$[rsp]
  00082	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00087	48 8d 44 24 50	 lea	 rax, QWORD PTR fileno$[rsp]
  0008c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00091	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?keywords@?1??new_mmap_object@@9@9
  00098	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06KBNJCMJO@iO?$HMziL?$AA@
  0009f	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR kwdict$[rsp]
  000a7	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000af	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  000b4	85 c0		 test	 eax, eax
  000b6	75 07		 jne	 SHORT $LN29@new_mmap_o

; 1272 :         return NULL;

  000b8	33 c0		 xor	 eax, eax
  000ba	e9 7f 06 00 00	 jmp	 $LN30@new_mmap_o
$LN29@new_mmap_o:

; 1273 :     }
; 1274 : 
; 1275 :     switch((access_mode)access) {

  000bf	8b 44 24 78	 mov	 eax, DWORD PTR access$[rsp]
  000c3	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv75[rsp], eax
  000ca	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR tv75[rsp], 0
  000d2	74 38		 je	 SHORT $LN25@new_mmap_o
  000d4	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR tv75[rsp], 1
  000dc	74 16		 je	 SHORT $LN26@new_mmap_o
  000de	83 bc 24 c0 00
	00 00 02	 cmp	 DWORD PTR tv75[rsp], 2
  000e6	74 24		 je	 SHORT $LN25@new_mmap_o
  000e8	83 bc 24 c0 00
	00 00 03	 cmp	 DWORD PTR tv75[rsp], 3
  000f0	74 32		 je	 SHORT $LN24@new_mmap_o
  000f2	eb 48		 jmp	 SHORT $LN23@new_mmap_o
$LN26@new_mmap_o:

; 1276 :     case ACCESS_READ:
; 1277 :         flProtect = PAGE_READONLY;

  000f4	c7 84 24 b4 00
	00 00 02 00 00
	00		 mov	 DWORD PTR flProtect$[rsp], 2

; 1278 :         dwDesiredAccess = FILE_MAP_READ;

  000ff	c7 84 24 98 00
	00 00 04 00 00
	00		 mov	 DWORD PTR dwDesiredAccess$[rsp], 4

; 1279 :         break;

  0010a	eb 48		 jmp	 SHORT $LN27@new_mmap_o
$LN25@new_mmap_o:

; 1280 :     case ACCESS_DEFAULT:  case ACCESS_WRITE:
; 1281 :         flProtect = PAGE_READWRITE;

  0010c	c7 84 24 b4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR flProtect$[rsp], 4

; 1282 :         dwDesiredAccess = FILE_MAP_WRITE;

  00117	c7 84 24 98 00
	00 00 02 00 00
	00		 mov	 DWORD PTR dwDesiredAccess$[rsp], 2

; 1283 :         break;

  00122	eb 30		 jmp	 SHORT $LN27@new_mmap_o
$LN24@new_mmap_o:

; 1284 :     case ACCESS_COPY:
; 1285 :         flProtect = PAGE_WRITECOPY;

  00124	c7 84 24 b4 00
	00 00 08 00 00
	00		 mov	 DWORD PTR flProtect$[rsp], 8

; 1286 :         dwDesiredAccess = FILE_MAP_COPY;

  0012f	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR dwDesiredAccess$[rsp], 1

; 1287 :         break;

  0013a	eb 18		 jmp	 SHORT $LN27@new_mmap_o
$LN23@new_mmap_o:

; 1288 :     default:
; 1289 :         return PyErr_Format(PyExc_ValueError,
; 1290 :                             "mmap invalid access parameter.");

  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@MEHKOKFA@mmap?5invalid?5access?5parameter?4?$AA@
  00143	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0014a	e8 00 00 00 00	 call	 PyErr_Format
  0014f	e9 ea 05 00 00	 jmp	 $LN30@new_mmap_o
$LN27@new_mmap_o:

; 1291 :     }
; 1292 : 
; 1293 :     map_size = _GetMapSize(map_size_obj, "size");

  00154	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04IAGNFIBA@size?$AA@
  0015b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR map_size_obj$[rsp]
  00160	e8 00 00 00 00	 call	 _GetMapSize
  00165	48 89 44 24 68	 mov	 QWORD PTR map_size$[rsp], rax

; 1294 :     if (map_size < 0)

  0016a	48 83 7c 24 68
	00		 cmp	 QWORD PTR map_size$[rsp], 0
  00170	7d 07		 jge	 SHORT $LN22@new_mmap_o

; 1295 :         return NULL;

  00172	33 c0		 xor	 eax, eax
  00174	e9 c5 05 00 00	 jmp	 $LN30@new_mmap_o
$LN22@new_mmap_o:

; 1296 :     if (offset < 0) {

  00179	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR offset$[rsp], 0
  00182	7d 1a		 jge	 SHORT $LN21@new_mmap_o

; 1297 :         PyErr_SetString(PyExc_OverflowError,
; 1298 :             "memory mapped offset must be positive");

  00184	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@ODNCCLGL@memory?5mapped?5offset?5must?5be?5pos@
  0018b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00192	e8 00 00 00 00	 call	 PyErr_SetString

; 1299 :         return NULL;

  00197	33 c0		 xor	 eax, eax
  00199	e9 a0 05 00 00	 jmp	 $LN30@new_mmap_o
$LN21@new_mmap_o:

; 1300 :     }
; 1301 : 
; 1302 :     /* assume -1 and 0 both mean invalid filedescriptor
; 1303 :        to 'anonymously' map memory.
; 1304 :        XXX: fileno == 0 is a valid fd, but was accepted prior to 2.5.
; 1305 :        XXX: Should this code be added?
; 1306 :        if (fileno == 0)
; 1307 :         PyErr_WarnEx(PyExc_DeprecationWarning,
; 1308 :                      "don't use 0 for anonymous memory",
; 1309 :                      1);
; 1310 :      */
; 1311 :     if (fileno != -1 && fileno != 0) {

  0019e	83 7c 24 50 ff	 cmp	 DWORD PTR fileno$[rsp], -1
  001a3	74 66		 je	 SHORT $LN20@new_mmap_o
  001a5	83 7c 24 50 00	 cmp	 DWORD PTR fileno$[rsp], 0
  001aa	74 5f		 je	 SHORT $LN20@new_mmap_o

; 1312 :         /* Ensure that fileno is within the CRT's valid range */
; 1313 :         if (_PyVerify_fd(fileno) == 0) {

  001ac	8b 4c 24 50	 mov	 ecx, DWORD PTR fileno$[rsp]
  001b0	e8 00 00 00 00	 call	 _PyVerify_fd
  001b5	85 c0		 test	 eax, eax
  001b7	75 13		 jne	 SHORT $LN19@new_mmap_o

; 1314 :             PyErr_SetFromErrno(PyExc_OSError);

  001b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  001c0	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 1315 :             return NULL;

  001c5	33 c0		 xor	 eax, eax
  001c7	e9 72 05 00 00	 jmp	 $LN30@new_mmap_o
$LN19@new_mmap_o:

; 1316 :         }
; 1317 :         fh = (HANDLE)_get_osfhandle(fileno);

  001cc	8b 4c 24 50	 mov	 ecx, DWORD PTR fileno$[rsp]
  001d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  001d6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR fh$[rsp], rax

; 1318 :         if (fh==(HANDLE)-1) {

  001de	48 83 bc 24 a0
	00 00 00 ff	 cmp	 QWORD PTR fh$[rsp], -1
  001e7	75 13		 jne	 SHORT $LN18@new_mmap_o

; 1319 :             PyErr_SetFromErrno(PyExc_OSError);

  001e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OSError
  001f0	e8 00 00 00 00	 call	 PyErr_SetFromErrno

; 1320 :             return NULL;

  001f5	33 c0		 xor	 eax, eax
  001f7	e9 42 05 00 00	 jmp	 $LN30@new_mmap_o
$LN18@new_mmap_o:

; 1321 :         }
; 1322 :         /* Win9x appears to need us seeked to zero */
; 1323 :         lseek(fileno, 0, SEEK_SET);

  001fc	45 33 c0	 xor	 r8d, r8d
  001ff	33 d2		 xor	 edx, edx
  00201	8b 4c 24 50	 mov	 ecx, DWORD PTR fileno$[rsp]
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_lseek
$LN20@new_mmap_o:

; 1324 :     }
; 1325 : 
; 1326 :     m_obj = (mmap_object *)type->tp_alloc(type, 0);

  0020b	33 d2		 xor	 edx, edx
  0020d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  00215	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  0021d	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00223	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR m_obj$[rsp], rax

; 1327 :     if (m_obj == NULL)

  0022b	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR m_obj$[rsp], 0
  00234	75 07		 jne	 SHORT $LN17@new_mmap_o

; 1328 :         return NULL;

  00236	33 c0		 xor	 eax, eax
  00238	e9 01 05 00 00	 jmp	 $LN30@new_mmap_o
$LN17@new_mmap_o:

; 1329 :     /* Set every field to an invalid marker, so we can safely
; 1330 :        destruct the object in the face of failure */
; 1331 :     m_obj->data = NULL;

  0023d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  00245	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 1332 :     m_obj->file_handle = INVALID_HANDLE_VALUE;

  0024d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  00255	48 c7 80 90 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+144], -1

; 1333 :     m_obj->map_handle = NULL;

  00260	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  00268	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 1334 :     m_obj->tagname = NULL;

  00273	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  0027b	48 c7 80 98 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+152], 0

; 1335 :     m_obj->offset = offset;

  00286	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  0028e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  00296	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 1336 : 
; 1337 :     if (fh) {

  0029a	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR fh$[rsp], 0
  002a3	0f 84 28 02 00
	00		 je	 $LN16@new_mmap_o

; 1338 :         /* It is necessary to duplicate the handle, so the
; 1339 :            Python code can close it on us */
; 1340 :         if (!DuplicateHandle(
; 1341 :             GetCurrentProcess(), /* source process handle */
; 1342 :             fh, /* handle to be duplicated */
; 1343 :             GetCurrentProcess(), /* target proc handle */
; 1344 :             (LPHANDLE)&m_obj->file_handle, /* result */
; 1345 :             0, /* access - ignored due to options value */
; 1346 :             FALSE, /* inherited by child processes? */
; 1347 :             DUPLICATE_SAME_ACCESS)) { /* options */

  002a9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  002b1	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  002b7	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  002bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcess
  002c5	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv152[rsp], rax
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcess
  002d3	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR [rsp+48], 2
  002db	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  002e3	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  002eb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv150[rsp]
  002f3	4c 8b c9	 mov	 r9, rcx
  002f6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv152[rsp]
  002fe	4c 8b c1	 mov	 r8, rcx
  00301	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR fh$[rsp]
  00309	48 8b c8	 mov	 rcx, rax
  0030c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DuplicateHandle
  00312	85 c0		 test	 eax, eax
  00314	75 2d		 jne	 SHORT $LN15@new_mmap_o

; 1348 :             dwErr = GetLastError();

  00316	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0031c	89 84 24 b0 00
	00 00		 mov	 DWORD PTR dwErr$[rsp], eax

; 1349 :             Py_DECREF(m_obj);

  00323	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR m_obj$[rsp]
  0032b	e8 00 00 00 00	 call	 _Py_DecRef

; 1350 :             PyErr_SetFromWindowsErr(dwErr);

  00330	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR dwErr$[rsp]
  00337	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 1351 :             return NULL;

  0033c	33 c0		 xor	 eax, eax
  0033e	e9 fb 03 00 00	 jmp	 $LN30@new_mmap_o
$LN15@new_mmap_o:

; 1352 :         }
; 1353 :         if (!map_size) {

  00343	48 83 7c 24 68
	00		 cmp	 QWORD PTR map_size$[rsp], 0
  00349	0f 85 54 01 00
	00		 jne	 $LN14@new_mmap_o

; 1354 :             DWORD low,high;
; 1355 :             low = GetFileSize(fh, &high);

  0034f	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR high$121238[rsp]
  00357	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fh$[rsp]
  0035f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetFileSize
  00365	89 84 24 bc 00
	00 00		 mov	 DWORD PTR low$121237[rsp], eax

; 1356 :             /* low might just happen to have the value INVALID_FILE_SIZE;
; 1357 :                so we need to check the last error also. */
; 1358 :             if (low == INVALID_FILE_SIZE &&
; 1359 :                 (dwErr = GetLastError()) != NO_ERROR) {

  0036c	83 bc 24 bc 00
	00 00 ff	 cmp	 DWORD PTR low$121237[rsp], -1 ; ffffffffH
  00374	75 35		 jne	 SHORT $LN13@new_mmap_o
  00376	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0037c	89 84 24 b0 00
	00 00		 mov	 DWORD PTR dwErr$[rsp], eax
  00383	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR dwErr$[rsp], 0
  0038b	74 1e		 je	 SHORT $LN13@new_mmap_o

; 1360 :                 Py_DECREF(m_obj);

  0038d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR m_obj$[rsp]
  00395	e8 00 00 00 00	 call	 _Py_DecRef

; 1361 :                 return PyErr_SetFromWindowsErr(dwErr);

  0039a	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR dwErr$[rsp]
  003a1	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr
  003a6	e9 93 03 00 00	 jmp	 $LN30@new_mmap_o
$LN13@new_mmap_o:

; 1362 :             }
; 1363 : 
; 1364 :             size = (((PY_LONG_LONG) high) << 32) + low;

  003ab	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR high$121238[rsp]
  003b2	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  003b6	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR low$121237[rsp]
  003bd	48 03 c1	 add	 rax, rcx
  003c0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR size$[rsp], rax

; 1365 :             if (size == 0) {

  003c8	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  003d1	75 27		 jne	 SHORT $LN12@new_mmap_o

; 1366 :                 PyErr_SetString(PyExc_ValueError,
; 1367 :                                 "cannot mmap an empty file");

  003d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@BFJDGGFK@cannot?5mmap?5an?5empty?5file?$AA@
  003da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  003e1	e8 00 00 00 00	 call	 PyErr_SetString

; 1368 :                 Py_DECREF(m_obj);

  003e6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR m_obj$[rsp]
  003ee	e8 00 00 00 00	 call	 _Py_DecRef

; 1369 :                 return NULL;

  003f3	33 c0		 xor	 eax, eax
  003f5	e9 44 03 00 00	 jmp	 $LN30@new_mmap_o
$LN12@new_mmap_o:

; 1370 :             }
; 1371 :             if (offset >= size) {

  003fa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  00402	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR offset$[rsp], rax
  0040a	7c 27		 jl	 SHORT $LN11@new_mmap_o

; 1372 :                 PyErr_SetString(PyExc_ValueError,
; 1373 :                                 "mmap offset is greater than file size");

  0040c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@JJJMKNMA@mmap?5offset?5is?5greater?5than?5file@
  00413	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0041a	e8 00 00 00 00	 call	 PyErr_SetString

; 1374 :                 Py_DECREF(m_obj);

  0041f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR m_obj$[rsp]
  00427	e8 00 00 00 00	 call	 _Py_DecRef

; 1375 :                 return NULL;

  0042c	33 c0		 xor	 eax, eax
  0042e	e9 0b 03 00 00	 jmp	 $LN30@new_mmap_o
$LN11@new_mmap_o:

; 1376 :             }
; 1377 :             if (size - offset > PY_SSIZE_T_MAX) {

  00433	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  0043b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  00443	48 2b c8	 sub	 rcx, rax
  00446	48 8b c1	 mov	 rax, rcx
  00449	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00453	48 3b c1	 cmp	 rax, rcx
  00456	7e 27		 jle	 SHORT $LN10@new_mmap_o

; 1378 :                 PyErr_SetString(PyExc_ValueError,
; 1379 :                                 "mmap length is too large");

  00458	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@ILNJPNME@mmap?5length?5is?5too?5large?$AA@
  0045f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00466	e8 00 00 00 00	 call	 PyErr_SetString

; 1380 :                 Py_DECREF(m_obj);

  0046b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR m_obj$[rsp]
  00473	e8 00 00 00 00	 call	 _Py_DecRef

; 1381 :                 return NULL;

  00478	33 c0		 xor	 eax, eax
  0047a	e9 bf 02 00 00	 jmp	 $LN30@new_mmap_o
$LN10@new_mmap_o:

; 1382 :             }
; 1383 :             m_obj->size = (Py_ssize_t) (size - offset);

  0047f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  00487	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  0048f	48 2b c8	 sub	 rcx, rax
  00492	48 8b c1	 mov	 rax, rcx
  00495	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR m_obj$[rsp]
  0049d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 1384 :         } else {

  004a1	eb 2c		 jmp	 SHORT $LN9@new_mmap_o
$LN14@new_mmap_o:

; 1385 :             m_obj->size = map_size;

  004a3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  004ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR map_size$[rsp]
  004b0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1386 :             size = offset + map_size;

  004b4	48 8b 44 24 68	 mov	 rax, QWORD PTR map_size$[rsp]
  004b9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  004c1	48 03 c8	 add	 rcx, rax
  004c4	48 8b c1	 mov	 rax, rcx
  004c7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR size$[rsp], rax
$LN9@new_mmap_o:

; 1387 :         }
; 1388 :     }
; 1389 :     else {

  004cf	eb 2c		 jmp	 SHORT $LN8@new_mmap_o
$LN16@new_mmap_o:

; 1390 :         m_obj->size = map_size;

  004d1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  004d9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR map_size$[rsp]
  004de	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1391 :         size = offset + map_size;

  004e2	48 8b 44 24 68	 mov	 rax, QWORD PTR map_size$[rsp]
  004e7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  004ef	48 03 c8	 add	 rcx, rax
  004f2	48 8b c1	 mov	 rax, rcx
  004f5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR size$[rsp], rax
$LN8@new_mmap_o:

; 1392 :     }
; 1393 : 
; 1394 :     /* set the initial position */
; 1395 :     m_obj->pos = (size_t) 0;

  004fd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  00505	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 1396 : 
; 1397 :     m_obj->exports = 0;

  0050d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  00515	c7 80 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+128], 0

; 1398 :     /* set the tag name */
; 1399 :     if (tagname != NULL && *tagname != '\0') {

  0051f	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR tagname$[rsp], 0
  00528	74 7f		 je	 SHORT $LN7@new_mmap_o
  0052a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tagname$[rsp]
  00532	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00535	85 c0		 test	 eax, eax
  00537	74 70		 je	 SHORT $LN7@new_mmap_o

; 1400 :         m_obj->tagname = PyMem_Malloc(strlen(tagname)+1);

  00539	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tagname$[rsp]
  00541	e8 00 00 00 00	 call	 strlen
  00546	48 ff c0	 inc	 rax
  00549	48 8b c8	 mov	 rcx, rax
  0054c	e8 00 00 00 00	 call	 PyMem_Malloc
  00551	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR m_obj$[rsp]
  00559	48 89 81 98 00
	00 00		 mov	 QWORD PTR [rcx+152], rax

; 1401 :         if (m_obj->tagname == NULL) {

  00560	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  00568	48 83 b8 98 00
	00 00 00	 cmp	 QWORD PTR [rax+152], 0
  00570	75 19		 jne	 SHORT $LN6@new_mmap_o

; 1402 :             PyErr_NoMemory();

  00572	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1403 :             Py_DECREF(m_obj);

  00577	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR m_obj$[rsp]
  0057f	e8 00 00 00 00	 call	 _Py_DecRef

; 1404 :             return NULL;

  00584	33 c0		 xor	 eax, eax
  00586	e9 b3 01 00 00	 jmp	 $LN30@new_mmap_o
$LN6@new_mmap_o:

; 1405 :         }
; 1406 :         strcpy(m_obj->tagname, tagname);

  0058b	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tagname$[rsp]
  00593	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  0059b	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  005a2	e8 00 00 00 00	 call	 strcpy

; 1407 :     }
; 1408 :     else

  005a7	eb 13		 jmp	 SHORT $LN5@new_mmap_o
$LN7@new_mmap_o:

; 1409 :         m_obj->tagname = NULL;

  005a9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  005b1	48 c7 80 98 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+152], 0
$LN5@new_mmap_o:

; 1410 : 
; 1411 :     m_obj->access = (access_mode)access;

  005bc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  005c4	8b 4c 24 78	 mov	 ecx, DWORD PTR access$[rsp]
  005c8	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 1412 :     size_hi = (DWORD)(size >> 32);

  005ce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  005d6	48 c1 f8 20	 sar	 rax, 32			; 00000020H
  005da	89 44 24 70	 mov	 DWORD PTR size_hi$[rsp], eax

; 1413 :     size_lo = (DWORD)(size & 0xFFFFFFFF);

  005de	b8 ff ff ff ff	 mov	 eax, -1
  005e3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  005eb	48 23 c8	 and	 rcx, rax
  005ee	48 8b c1	 mov	 rax, rcx
  005f1	89 44 24 7c	 mov	 DWORD PTR size_lo$[rsp], eax

; 1414 :     off_hi = (DWORD)(offset >> 32);

  005f5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR offset$[rsp]
  005fd	48 c1 f8 20	 sar	 rax, 32			; 00000020H
  00601	89 44 24 60	 mov	 DWORD PTR off_hi$[rsp], eax

; 1415 :     off_lo = (DWORD)(offset & 0xFFFFFFFF);

  00605	b8 ff ff ff ff	 mov	 eax, -1
  0060a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  00612	48 23 c8	 and	 rcx, rax
  00615	48 8b c1	 mov	 rax, rcx
  00618	89 44 24 74	 mov	 DWORD PTR off_lo$[rsp], eax

; 1416 :     /* For files, it would be sufficient to pass 0 as size.
; 1417 :        For anonymous maps, we have to pass the size explicitly. */
; 1418 :     m_obj->map_handle = CreateFileMapping(m_obj->file_handle,
; 1419 :                                           NULL,
; 1420 :                                           flProtect,
; 1421 :                                           size_hi,
; 1422 :                                           size_lo,
; 1423 :                                           m_obj->tagname);

  0061c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  00624	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0062b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00630	8b 44 24 7c	 mov	 eax, DWORD PTR size_lo$[rsp]
  00634	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00638	44 8b 4c 24 70	 mov	 r9d, DWORD PTR size_hi$[rsp]
  0063d	44 8b 84 24 b4
	00 00 00	 mov	 r8d, DWORD PTR flProtect$[rsp]
  00645	33 d2		 xor	 edx, edx
  00647	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  0064f	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  00656	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileMappingA
  0065c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR m_obj$[rsp]
  00664	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 1424 :     if (m_obj->map_handle != NULL) {

  0066b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  00673	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0067b	0f 84 95 00 00
	00		 je	 $LN4@new_mmap_o

; 1425 :         m_obj->data = (char *) MapViewOfFile(m_obj->map_handle,
; 1426 :                                              dwDesiredAccess,
; 1427 :                                              off_hi,
; 1428 :                                              off_lo,
; 1429 :                                              m_obj->size);

  00681	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  00689	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0068d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00692	44 8b 4c 24 74	 mov	 r9d, DWORD PTR off_lo$[rsp]
  00697	44 8b 44 24 60	 mov	 r8d, DWORD PTR off_hi$[rsp]
  0069c	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR dwDesiredAccess$[rsp]
  006a3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  006ab	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  006b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MapViewOfFile
  006b8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR m_obj$[rsp]
  006c0	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 1430 :         if (m_obj->data != NULL)

  006c4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  006cc	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  006d1	74 0c		 je	 SHORT $LN3@new_mmap_o

; 1431 :             return (PyObject *)m_obj;

  006d3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  006db	eb 61		 jmp	 SHORT $LN30@new_mmap_o

; 1432 :         else {

  006dd	eb 35		 jmp	 SHORT $LN2@new_mmap_o
$LN3@new_mmap_o:

; 1433 :             dwErr = GetLastError();

  006df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  006e5	89 84 24 b0 00
	00 00		 mov	 DWORD PTR dwErr$[rsp], eax

; 1434 :             CloseHandle(m_obj->map_handle);

  006ec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  006f4	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  006fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 1435 :             m_obj->map_handle = NULL;

  00701	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR m_obj$[rsp]
  00709	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0
$LN2@new_mmap_o:

; 1436 :         }
; 1437 :     } else

  00714	eb 0d		 jmp	 SHORT $LN1@new_mmap_o
$LN4@new_mmap_o:

; 1438 :         dwErr = GetLastError();

  00716	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0071c	89 84 24 b0 00
	00 00		 mov	 DWORD PTR dwErr$[rsp], eax
$LN1@new_mmap_o:

; 1439 :     Py_DECREF(m_obj);

  00723	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR m_obj$[rsp]
  0072b	e8 00 00 00 00	 call	 _Py_DecRef

; 1440 :     PyErr_SetFromWindowsErr(dwErr);

  00730	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR dwErr$[rsp]
  00737	e8 00 00 00 00	 call	 PyErr_SetFromWindowsErr

; 1441 :     return NULL;

  0073c	33 c0		 xor	 eax, eax
$LN30@new_mmap_o:

; 1442 : }

  0073e	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00745	c3		 ret	 0
new_mmap_object ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@FBABAJKH@map?5size?5must?5be?5an?5integral?5val@ ; `string'
PUBLIC	??_C@_0CC@DACBLODL@memory?5mapped?5?$CFs?5must?5be?5positiv@ ; `string'
;	COMDAT pdata
; File c:\src\pyparallel\modules\mmapmodule.c
pdata	SEGMENT
$pdata$_GetMapSize DD imagerel _GetMapSize
	DD	imagerel _GetMapSize+202
	DD	imagerel $unwind$_GetMapSize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_GetMapSize DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CD@FBABAJKH@map?5size?5must?5be?5an?5integral?5val@
CONST	SEGMENT
??_C@_0CD@FBABAJKH@map?5size?5must?5be?5an?5integral?5val@ DB 'map size m'
	DB	'ust be an integral value', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DACBLODL@memory?5mapped?5?$CFs?5must?5be?5positiv@
CONST	SEGMENT
??_C@_0CC@DACBLODL@memory?5mapped?5?$CFs?5must?5be?5positiv@ DB 'memory m'
	DB	'apped %s must be positive', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _GetMapSize
_TEXT	SEGMENT
i$121159 = 32
o$ = 64
param$ = 72
_GetMapSize PROC					; COMDAT

; 1059 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1060 :     if (o == NULL)

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  00014	75 07		 jne	 SHORT $LN4@GetMapSize

; 1061 :         return 0;

  00016	33 c0		 xor	 eax, eax
  00018	e9 a8 00 00 00	 jmp	 $LN5@GetMapSize
$LN4@GetMapSize:

; 1062 :     if (PyIndex_Check(o)) {

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00022	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00026	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  0002e	74 7b		 je	 SHORT $LN3@GetMapSize
  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00035	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00039	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00040	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  00048	74 61		 je	 SHORT $LN3@GetMapSize

; 1063 :         Py_ssize_t i = PyNumber_AsSsize_t(o, PyExc_OverflowError);

  0004a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00056	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  0005b	48 89 44 24 20	 mov	 QWORD PTR i$121159[rsp], rax

; 1064 :         if (i==-1 && PyErr_Occurred())

  00060	48 83 7c 24 20
	ff		 cmp	 QWORD PTR i$121159[rsp], -1
  00066	75 13		 jne	 SHORT $LN2@GetMapSize
  00068	e8 00 00 00 00	 call	 PyErr_Occurred
  0006d	48 85 c0	 test	 rax, rax
  00070	74 09		 je	 SHORT $LN2@GetMapSize

; 1065 :             return -1;

  00072	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00079	eb 4a		 jmp	 SHORT $LN5@GetMapSize
$LN2@GetMapSize:

; 1066 :         if (i < 0) {

  0007b	48 83 7c 24 20
	00		 cmp	 QWORD PTR i$121159[rsp], 0
  00081	7d 21		 jge	 SHORT $LN1@GetMapSize

; 1067 :             PyErr_Format(PyExc_OverflowError,
; 1068 :                             "memory mapped %s must be positive",
; 1069 :                             param);

  00083	4c 8b 44 24 48	 mov	 r8, QWORD PTR param$[rsp]
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@DACBLODL@memory?5mapped?5?$CFs?5must?5be?5positiv@
  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  00096	e8 00 00 00 00	 call	 PyErr_Format

; 1070 :             return -1;

  0009b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000a2	eb 21		 jmp	 SHORT $LN5@GetMapSize
$LN1@GetMapSize:

; 1071 :         }
; 1072 :         return i;

  000a4	48 8b 44 24 20	 mov	 rax, QWORD PTR i$121159[rsp]
  000a9	eb 1a		 jmp	 SHORT $LN5@GetMapSize
$LN3@GetMapSize:

; 1073 :     }
; 1074 : 
; 1075 :     PyErr_SetString(PyExc_TypeError, "map size must be an integral value");

  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@FBABAJKH@map?5size?5must?5be?5an?5integral?5val@
  000b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b9	e8 00 00 00 00	 call	 PyErr_SetString

; 1076 :     return -1;

  000be	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN5@GetMapSize:

; 1077 : }

  000c5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c9	c3		 ret	 0
_GetMapSize ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@GOGDFIHI@ACCESS_COPY?$AA@		; `string'
PUBLIC	??_C@_0N@PGEALJOO@ACCESS_WRITE?$AA@		; `string'
PUBLIC	??_C@_0M@LONGKDHF@ACCESS_READ?$AA@		; `string'
PUBLIC	??_C@_0BG@CGCEMFPN@ALLOCATIONGRANULARITY?$AA@	; `string'
PUBLIC	??_C@_08CFCAAKPG@PAGESIZE?$AA@			; `string'
PUBLIC	??_C@_05KKCIMGE@error?$AA@			; `string'
PUBLIC	PyInit_mmap
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_mmap DD imagerel $LN6
	DD	imagerel $LN6+271
	DD	imagerel $unwind$PyInit_mmap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_mmap DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT ??_C@_0M@GOGDFIHI@ACCESS_COPY?$AA@
CONST	SEGMENT
??_C@_0M@GOGDFIHI@ACCESS_COPY?$AA@ DB 'ACCESS_COPY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PGEALJOO@ACCESS_WRITE?$AA@
CONST	SEGMENT
??_C@_0N@PGEALJOO@ACCESS_WRITE?$AA@ DB 'ACCESS_WRITE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LONGKDHF@ACCESS_READ?$AA@
CONST	SEGMENT
??_C@_0M@LONGKDHF@ACCESS_READ?$AA@ DB 'ACCESS_READ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CGCEMFPN@ALLOCATIONGRANULARITY?$AA@
CONST	SEGMENT
??_C@_0BG@CGCEMFPN@ALLOCATIONGRANULARITY?$AA@ DB 'ALLOCATIONGRANULARITY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08CFCAAKPG@PAGESIZE?$AA@
CONST	SEGMENT
??_C@_08CFCAAKPG@PAGESIZE?$AA@ DB 'PAGESIZE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05KKCIMGE@error?$AA@
CONST	SEGMENT
??_C@_05KKCIMGE@error?$AA@ DB 'error', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit_mmap
_TEXT	SEGMENT
dict$ = 32
module$ = 40
PyInit_mmap PROC					; COMDAT

; 1469 : {

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1470 :     PyObject *dict, *module;
; 1471 : 
; 1472 :     if (PyType_Ready(&mmap_object_type) < 0)

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mmap_object_type
  0000b	e8 00 00 00 00	 call	 PyType_Ready
  00010	85 c0		 test	 eax, eax
  00012	7d 07		 jge	 SHORT $LN3@PyInit_mma

; 1473 :         return NULL;

  00014	33 c0		 xor	 eax, eax
  00016	e9 ef 00 00 00	 jmp	 $LN4@PyInit_mma
$LN3@PyInit_mma:

; 1474 : 
; 1475 :     module = PyModule_Create(&mmapmodule);

  0001b	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:mmapmodule
  00027	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  0002c	48 89 44 24 28	 mov	 QWORD PTR module$[rsp], rax

; 1476 :     if (module == NULL)

  00031	48 83 7c 24 28
	00		 cmp	 QWORD PTR module$[rsp], 0
  00037	75 07		 jne	 SHORT $LN2@PyInit_mma

; 1477 :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 ca 00 00 00	 jmp	 $LN4@PyInit_mma
$LN2@PyInit_mma:

; 1478 :     dict = PyModule_GetDict(module);

  00040	48 8b 4c 24 28	 mov	 rcx, QWORD PTR module$[rsp]
  00045	e8 00 00 00 00	 call	 PyModule_GetDict
  0004a	48 89 44 24 20	 mov	 QWORD PTR dict$[rsp], rax

; 1479 :     if (!dict)

  0004f	48 83 7c 24 20
	00		 cmp	 QWORD PTR dict$[rsp], 0
  00055	75 07		 jne	 SHORT $LN1@PyInit_mma

; 1480 :         return NULL;

  00057	33 c0		 xor	 eax, eax
  00059	e9 ac 00 00 00	 jmp	 $LN4@PyInit_mma
$LN1@PyInit_mma:

; 1481 :     PyDict_SetItemString(dict, "error", PyExc_OSError);

  0005e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR PyExc_OSError
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KKCIMGE@error?$AA@
  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dict$[rsp]
  00071	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1482 :     PyDict_SetItemString(dict, "mmap", (PyObject*) &mmap_object_type);

  00076	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:mmap_object_type
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04PHBJEMCB@mmap?$AA@
  00084	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dict$[rsp]
  00089	e8 00 00 00 00	 call	 PyDict_SetItemString

; 1483 : #ifdef PROT_EXEC
; 1484 :     setint(dict, "PROT_EXEC", PROT_EXEC);
; 1485 : #endif
; 1486 : #ifdef PROT_READ
; 1487 :     setint(dict, "PROT_READ", PROT_READ);
; 1488 : #endif
; 1489 : #ifdef PROT_WRITE
; 1490 :     setint(dict, "PROT_WRITE", PROT_WRITE);
; 1491 : #endif
; 1492 : 
; 1493 : #ifdef MAP_SHARED
; 1494 :     setint(dict, "MAP_SHARED", MAP_SHARED);
; 1495 : #endif
; 1496 : #ifdef MAP_PRIVATE
; 1497 :     setint(dict, "MAP_PRIVATE", MAP_PRIVATE);
; 1498 : #endif
; 1499 : #ifdef MAP_DENYWRITE
; 1500 :     setint(dict, "MAP_DENYWRITE", MAP_DENYWRITE);
; 1501 : #endif
; 1502 : #ifdef MAP_EXECUTABLE
; 1503 :     setint(dict, "MAP_EXECUTABLE", MAP_EXECUTABLE);
; 1504 : #endif
; 1505 : #ifdef MAP_ANONYMOUS
; 1506 :     setint(dict, "MAP_ANON", MAP_ANONYMOUS);
; 1507 :     setint(dict, "MAP_ANONYMOUS", MAP_ANONYMOUS);
; 1508 : #endif
; 1509 : 
; 1510 :     setint(dict, "PAGESIZE", (long)my_getpagesize());

  0008e	e8 00 00 00 00	 call	 my_getpagesize
  00093	44 8b c0	 mov	 r8d, eax
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08CFCAAKPG@PAGESIZE?$AA@
  0009d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dict$[rsp]
  000a2	e8 00 00 00 00	 call	 setint

; 1511 : 
; 1512 :     setint(dict, "ALLOCATIONGRANULARITY", (long)my_getallocationgranularity());

  000a7	e8 00 00 00 00	 call	 my_getallocationgranularity
  000ac	44 8b c0	 mov	 r8d, eax
  000af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CGCEMFPN@ALLOCATIONGRANULARITY?$AA@
  000b6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dict$[rsp]
  000bb	e8 00 00 00 00	 call	 setint

; 1513 : 
; 1514 :     setint(dict, "ACCESS_READ", ACCESS_READ);

  000c0	41 b8 01 00 00
	00		 mov	 r8d, 1
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@LONGKDHF@ACCESS_READ?$AA@
  000cd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dict$[rsp]
  000d2	e8 00 00 00 00	 call	 setint

; 1515 :     setint(dict, "ACCESS_WRITE", ACCESS_WRITE);

  000d7	41 b8 02 00 00
	00		 mov	 r8d, 2
  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@PGEALJOO@ACCESS_WRITE?$AA@
  000e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dict$[rsp]
  000e9	e8 00 00 00 00	 call	 setint

; 1516 :     setint(dict, "ACCESS_COPY", ACCESS_COPY);

  000ee	41 b8 03 00 00
	00		 mov	 r8d, 3
  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GOGDFIHI@ACCESS_COPY?$AA@
  000fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dict$[rsp]
  00100	e8 00 00 00 00	 call	 setint

; 1517 :     return module;

  00105	48 8b 44 24 28	 mov	 rax, QWORD PTR module$[rsp]
$LN4@PyInit_mma:

; 1518 : }

  0010a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0010e	c3		 ret	 0
PyInit_mmap ENDP
_TEXT	ENDS
EXTRN	__imp_GetSystemInfo:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$my_getpagesize DD imagerel my_getpagesize
	DD	imagerel my_getpagesize+24
	DD	imagerel $unwind$my_getpagesize
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$my_getpagesize DD 010401H
	DD	0a204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT my_getpagesize
_TEXT	SEGMENT
si$ = 32
my_getpagesize PROC					; COMDAT

; 35   : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 36   :     SYSTEM_INFO si;
; 37   :     GetSystemInfo(&si);

  00004	48 8d 4c 24 20	 lea	 rcx, QWORD PTR si$[rsp]
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemInfo

; 38   :     return si.dwPageSize;

  0000f	8b 44 24 24	 mov	 eax, DWORD PTR si$[rsp+4]

; 39   : }

  00013	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00017	c3		 ret	 0
my_getpagesize ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$my_getallocationgranularity DD imagerel my_getallocationgranularity
	DD	imagerel my_getallocationgranularity+24
	DD	imagerel $unwind$my_getallocationgranularity
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$my_getallocationgranularity DD 010401H
	DD	0a204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT my_getallocationgranularity
_TEXT	SEGMENT
si$ = 32
my_getallocationgranularity PROC			; COMDAT

; 43   : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 44   : 
; 45   :     SYSTEM_INFO si;
; 46   :     GetSystemInfo(&si);

  00004	48 8d 4c 24 20	 lea	 rcx, QWORD PTR si$[rsp]
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemInfo

; 47   :     return si.dwAllocationGranularity;

  0000f	8b 44 24 48	 mov	 eax, DWORD PTR si$[rsp+40]

; 48   : }

  00013	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00017	c3		 ret	 0
my_getallocationgranularity ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setint DD imagerel setint
	DD	imagerel setint+80
	DD	imagerel $unwind$setint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setint DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT setint
_TEXT	SEGMENT
o$ = 32
d$ = 64
name$ = 72
value$ = 80
setint	PROC						; COMDAT

; 1447 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1448 :     PyObject *o = PyLong_FromLong(value);

  00013	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  00017	e8 00 00 00 00	 call	 PyLong_FromLong
  0001c	48 89 44 24 20	 mov	 QWORD PTR o$[rsp], rax

; 1449 :     if (o && PyDict_SetItemString(d, name, o) == 0) {

  00021	48 83 7c 24 20
	00		 cmp	 QWORD PTR o$[rsp], 0
  00027	74 22		 je	 SHORT $LN1@setint
  00029	4c 8b 44 24 20	 mov	 r8, QWORD PTR o$[rsp]
  0002e	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  00038	e8 00 00 00 00	 call	 PyDict_SetItemString
  0003d	85 c0		 test	 eax, eax
  0003f	75 0a		 jne	 SHORT $LN1@setint

; 1450 :         Py_DECREF(o);

  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR o$[rsp]
  00046	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@setint:

; 1451 :     }
; 1452 : }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
setint	ENDP
_TEXT	ENDS
END
