; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_05HMENAHCI@_sha1?$AA@			; `string'
PUBLIC	??_C@_04PGHFOLLE@sha1?$AA@			; `string'
PUBLIC	??_C@_06ICGJLFIM@string?$AA@			; `string'
PUBLIC	??_C@_0L@GFKAPDAF@_sha1?4sha1?$AA@		; `string'
PUBLIC	??_C@_0M@NPLIJFCD@digest_size?$AA@		; `string'
PUBLIC	??_C@_04MEMAJGDJ@name?$AA@			; `string'
PUBLIC	??_C@_0L@EHHMJOPG@block_size?$AA@		; `string'
PUBLIC	??_C@_06HDLLMMEJ@update?$AA@			; `string'
PUBLIC	??_C@_09NNAIGNDA@hexdigest?$AA@			; `string'
PUBLIC	??_C@_06IJPNAHC@digest?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
;	COMDAT ??_C@_05HMENAHCI@_sha1?$AA@
CONST	SEGMENT
??_C@_05HMENAHCI@_sha1?$AA@ DB '_sha1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGHFOLLE@sha1?$AA@
CONST	SEGMENT
??_C@_04PGHFOLLE@sha1?$AA@ DB 'sha1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string?$AA@
CONST	SEGMENT
??_C@_06ICGJLFIM@string?$AA@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GFKAPDAF@_sha1?4sha1?$AA@
CONST	SEGMENT
??_C@_0L@GFKAPDAF@_sha1?4sha1?$AA@ DB '_sha1.sha1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NPLIJFCD@digest_size?$AA@
CONST	SEGMENT
??_C@_0M@NPLIJFCD@digest_size?$AA@ DB 'digest_size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MEMAJGDJ@name?$AA@
CONST	SEGMENT
??_C@_04MEMAJGDJ@name?$AA@ DB 'name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EHHMJOPG@block_size?$AA@
CONST	SEGMENT
??_C@_0L@EHHMJOPG@block_size?$AA@ DB 'block_size', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HDLLMMEJ@update?$AA@
CONST	SEGMENT
??_C@_06HDLLMMEJ@update?$AA@ DB 'update', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09NNAIGNDA@hexdigest?$AA@
CONST	SEGMENT
??_C@_09NNAIGNDA@hexdigest?$AA@ DB 'hexdigest', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06IJPNAHC@digest?$AA@
CONST	SEGMENT
??_C@_06IJPNAHC@digest?$AA@ DB 'digest', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
SHA1_copy__doc__ DB 'Return a copy of the hash object.', 00H
	ORG $+6
SHA1_digest__doc__ DB 'Return the digest value as a string of binary data'
	DB	'.', 00H
	ORG $+4
SHA1_hexdigest__doc__ DB 'Return the digest value as a string of hexadeci'
	DB	'mal digits.', 00H
	ORG $+5
SHA1_update__doc__ DB 'Update this hash object''s state with the provided'
	DB	' string.', 00H
	ORG $+6
SHA1_methods DQ	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DQ	FLAT:SHA1_copy
	DD	04H
	ORG $+4
	DQ	FLAT:SHA1_copy__doc__
	DQ	FLAT:??_C@_06IJPNAHC@digest?$AA@
	DQ	FLAT:SHA1_digest
	DD	04H
	ORG $+4
	DQ	FLAT:SHA1_digest__doc__
	DQ	FLAT:??_C@_09NNAIGNDA@hexdigest?$AA@
	DQ	FLAT:SHA1_hexdigest
	DD	04H
	ORG $+4
	DQ	FLAT:SHA1_hexdigest__doc__
	DQ	FLAT:??_C@_06HDLLMMEJ@update?$AA@
	DQ	FLAT:SHA1_update
	DD	01H
	ORG $+4
	DQ	FLAT:SHA1_update__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
SHA1_getseters DQ FLAT:??_C@_0L@EHHMJOPG@block_size?$AA@
	DQ	FLAT:SHA1_get_block_size
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_04MEMAJGDJ@name?$AA@
	DQ	FLAT:SHA1_get_name
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:??_C@_0M@NPLIJFCD@digest_size?$AA@
	DQ	FLAT:sha1_get_digest_size
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+32
SHA1type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0L@GFKAPDAF@_sha1?4sha1?$AA@
	DQ	00000000000000c0H
	DQ	0000000000000000H
	DQ	FLAT:SHA1_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:SHA1_methods
	DQ	0000000000000000H
	DQ	FLAT:SHA1_getseters
	ORG $+136
SHA1_new__doc__ DB 'Return a new SHA1 hash object; optionally initialized'
	DB	' with a string.', 00H
	ORG $+3
?kwlist@?1??SHA1_new@@9@9 DQ FLAT:??_C@_06ICGJLFIM@string?$AA@ ; `SHA1_new'::`2'::kwlist
	DQ	0000000000000000H
	ORG $+8
SHA1_functions DQ FLAT:??_C@_04PGHFOLLE@sha1?$AA@
	DQ	FLAT:SHA1_new
	DD	03H
	ORG $+4
	DQ	FLAT:SHA1_new__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
_sha1module DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_05HMENAHCI@_sha1?$AA@
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	FLAT:SHA1_functions
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	_PyObject_DebugFree:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\sha1module.c
pdata	SEGMENT
$pdata$SHA1_dealloc DD imagerel SHA1_dealloc
	DD	imagerel SHA1_dealloc+24
	DD	imagerel $unwind$SHA1_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SHA1_dealloc
_TEXT	SEGMENT
ptr$ = 48
SHA1_dealloc PROC					; COMDAT

; 309  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 310  :     PyObject_Del(ptr);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  0000e	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 311  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
SHA1_dealloc ENDP
_TEXT	ENDS
PUBLIC	$T20964
;	COMDAT pdata
pdata	SEGMENT
$pdata$SHA1_copy DD imagerel SHA1_copy
	DD	imagerel SHA1_copy+107
	DD	imagerel $unwind$SHA1_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_copy DD 041301H
	DD	0130113H
	DD	0600b700cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SHA1_copy
_TEXT	SEGMENT
newobj$ = 32
$T20964 = 40
self$ = 176
unused$ = 184
SHA1_copy PROC						; COMDAT

; 320  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 321  :     SHA1object *newobj;
; 322  : 
; 323  :     if ((newobj = newSHA1object()) == NULL)

  00013	e8 00 00 00 00	 call	 newSHA1object
  00018	48 89 44 24 20	 mov	 QWORD PTR newobj$[rsp], rax
  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR newobj$[rsp], 0
  00023	75 04		 jne	 SHORT $LN1@SHA1_copy

; 324  :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 38		 jmp	 SHORT $LN2@SHA1_copy
$LN1@SHA1_copy:

; 325  : 
; 326  :     newobj->hash_state = self->hash_state;

  00029	48 8d 44 24 28	 lea	 rax, QWORD PTR $T20964[rsp]
  0002e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	48 8d 71 60	 lea	 rsi, QWORD PTR [rcx+96]
  0003d	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00042	f3 a4		 rep movsb
  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
  00049	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T20964[rsp]
  0004e	48 8d 78 60	 lea	 rdi, QWORD PTR [rax+96]
  00052	48 8b f1	 mov	 rsi, rcx
  00055	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  0005a	f3 a4		 rep movsb

; 327  :     return (PyObject *)newobj;

  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR newobj$[rsp]
$LN2@SHA1_copy:

; 328  : }

  00061	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00068	5f		 pop	 rdi
  00069	5e		 pop	 rsi
  0006a	c3		 ret	 0
SHA1_copy ENDP
_TEXT	ENDS
EXTRN	_PyObject_New:PROC
EXTRN	_PxObject_New:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$newSHA1object DD imagerel newSHA1object
	DD	imagerel newSHA1object+59
	DD	imagerel $unwind$newSHA1object
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newSHA1object DD 010401H
	DD	06204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT newSHA1object
_TEXT	SEGMENT
tv70 = 32
newSHA1object PROC					; COMDAT

; 300  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 301  :     return (SHA1object *)PyObject_New(SHA1object, &SHA1type);

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 13		 je	 SHORT $LN3@newSHA1obj
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SHA1type
  00014	e8 00 00 00 00	 call	 _PxObject_New
  00019	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
  0001e	eb 11		 jmp	 SHORT $LN4@newSHA1obj
$LN3@newSHA1obj:
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SHA1type
  00027	e8 00 00 00 00	 call	 _PyObject_New
  0002c	48 89 44 24 20	 mov	 QWORD PTR tv70[rsp], rax
$LN4@newSHA1obj:
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR tv70[rsp]

; 302  : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
newSHA1object ENDP
_TEXT	ENDS
PUBLIC	$T20979
EXTRN	PyBytes_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$SHA1_digest DD imagerel SHA1_digest
	DD	imagerel SHA1_digest+121
	DD	imagerel $unwind$SHA1_digest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_digest DD 041301H
	DD	0210113H
	DD	0600b700cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SHA1_digest
_TEXT	SEGMENT
temp$ = 32
digest$ = 128
$T20979 = 152
self$ = 288
unused$ = 296
SHA1_digest PROC					; COMDAT

; 335  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 336  :     unsigned char digest[SHA1_DIGESTSIZE];
; 337  :     struct sha1_state temp;
; 338  : 
; 339  :     temp = self->hash_state;

  00013	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR $T20979[rsp]
  0001b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00023	48 8b f8	 mov	 rdi, rax
  00026	48 8d 71 60	 lea	 rsi, QWORD PTR [rcx+96]
  0002a	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  0002f	f3 a4		 rep movsb
  00031	48 8d 44 24 20	 lea	 rax, QWORD PTR temp$[rsp]
  00036	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR $T20979[rsp]
  0003e	48 8b f8	 mov	 rdi, rax
  00041	48 8b f1	 mov	 rsi, rcx
  00044	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00049	f3 a4		 rep movsb

; 340  :     sha1_done(&temp, digest);

  0004b	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR digest$[rsp]
  00053	48 8d 4c 24 20	 lea	 rcx, QWORD PTR temp$[rsp]
  00058	e8 00 00 00 00	 call	 sha1_done

; 341  :     return PyBytes_FromStringAndSize((const char *)digest, SHA1_DIGESTSIZE);

  0005d	ba 14 00 00 00	 mov	 edx, 20
  00062	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR digest$[rsp]
  0006a	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize

; 342  : }

  0006f	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00076	5f		 pop	 rdi
  00077	5e		 pop	 rsi
  00078	c3		 ret	 0
SHA1_digest ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EC@HPAPAJNA@?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?$CJ@ ; `string'
PUBLIC	??_C@_1BI@JCEANMNF@?$AAo?$AAu?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BK@FHFLFHOK@?$AAs?$AAh?$AAa?$AA1?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$sha1_done DD imagerel sha1_done
	DD	imagerel sha1_done+763
	DD	imagerel $unwind$sha1_done
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sha1_done DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1EC@HPAPAJNA@?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?$CJ@
CONST	SEGMENT
??_C@_1EC@HPAPAJNA@?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?$CJ@ DB 's'
	DB	00H, 'h', 00H, 'a', 00H, '1', 00H, '-', 00H, '>', 00H, 'c', 00H
	DB	'u', 00H, 'r', 00H, 'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H, '<'
	DB	00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 'o', 00H
	DB	'f', 00H, '(', 00H, 's', 00H, 'h', 00H, 'a', 00H, '1', 00H, '-'
	DB	00H, '>', 00H, 'b', 00H, 'u', 00H, 'f', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BI@JCEANMNF@?$AAo?$AAu?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@JCEANMNF@?$AAo?$AAu?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'o'
	DB	00H, 'u', 00H, 't', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@FHFLFHOK@?$AAs?$AAh?$AAa?$AA1?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@FHFLFHOK@?$AAs?$AAh?$AAa?$AA1?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 'h', 00H, 'a', 00H, '1', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 's', 00H, 'h', 00H, 'a'
	DB	00H, '1', 00H, 'm', 00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H
	DB	'e', 00H, '.', 00H, 'c', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT sha1_done
_TEXT	SEGMENT
i$ = 32
sha1$ = 64
out$ = 72
sha1_done PROC						; COMDAT

; 244  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 245  :     int i;
; 246  : 
; 247  :     assert(sha1 != NULL);

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR sha1$[rsp], 0
  00014	75 1c		 jne	 SHORT $LN11@sha1_done
  00016	41 b8 f7 00 00
	00		 mov	 r8d, 247		; 000000f7H
  0001c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@FHFLFHOK@?$AAs?$AAh?$AAa?$AA1?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00030	33 c0		 xor	 eax, eax
$LN11@sha1_done:

; 248  :     assert(out != NULL);

  00032	48 83 7c 24 48
	00		 cmp	 QWORD PTR out$[rsp], 0
  00038	75 1c		 jne	 SHORT $LN12@sha1_done
  0003a	41 b8 f8 00 00
	00		 mov	 r8d, 248		; 000000f8H
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@JCEANMNF@?$AAo?$AAu?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00054	33 c0		 xor	 eax, eax
$LN12@sha1_done:

; 249  :     assert(sha1->curlen < sizeof(sha1->buf));

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  0005b	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0005e	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00062	72 1c		 jb	 SHORT $LN13@sha1_done
  00064	41 b8 f9 00 00
	00		 mov	 r8d, 249		; 000000f9H
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@HPAPAJNA@?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?$CJ@
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007e	33 c0		 xor	 eax, eax
$LN13@sha1_done:

; 250  : 
; 251  :     /* increase the length of the message */
; 252  :     sha1->length += sha1->curlen * 8;

  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00085	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00088	c1 e0 03	 shl	 eax, 3
  0008b	8b c0		 mov	 eax, eax
  0008d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  00092	48 03 01	 add	 rax, QWORD PTR [rcx]
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  0009a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 253  : 
; 254  :     /* append the '1' bit */
; 255  :     sha1->buf[sha1->curlen++] = (unsigned char)0x80;

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  000a2	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  000aa	c6 44 01 20 80	 mov	 BYTE PTR [rcx+rax+32], 128 ; 00000080H
  000af	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  000b4	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000b7	ff c0		 inc	 eax
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  000be	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 256  : 
; 257  :     /* if the length is currently above 56 bytes we append zeros
; 258  :      * then compress.  Then we can fall back to padding zeros and length
; 259  :      * encoding like normal.
; 260  :      */
; 261  :     if (sha1->curlen > 56) {

  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  000c6	83 78 1c 38	 cmp	 DWORD PTR [rax+28], 56	; 00000038H
  000ca	76 53		 jbe	 SHORT $LN8@sha1_done
$LN7@sha1_done:

; 262  :         while (sha1->curlen < 64) {

  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  000d1	83 78 1c 40	 cmp	 DWORD PTR [rax+28], 64	; 00000040H
  000d5	73 26		 jae	 SHORT $LN6@sha1_done

; 263  :             sha1->buf[sha1->curlen++] = (unsigned char)0;

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  000dc	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000df	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  000e4	c6 44 01 20 00	 mov	 BYTE PTR [rcx+rax+32], 0
  000e9	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  000ee	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  000f1	ff c0		 inc	 eax
  000f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  000f8	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 264  :         }

  000fb	eb cf		 jmp	 SHORT $LN7@sha1_done
$LN6@sha1_done:

; 265  :         sha1_compress(sha1, sha1->buf);

  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00102	48 83 c0 20	 add	 rax, 32			; 00000020H
  00106	48 8b d0	 mov	 rdx, rax
  00109	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  0010e	e8 00 00 00 00	 call	 sha1_compress

; 266  :         sha1->curlen = 0;

  00113	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00118	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
$LN8@sha1_done:
$LN5@sha1_done:

; 267  :     }
; 268  : 
; 269  :     /* pad upto 56 bytes of zeroes */
; 270  :     while (sha1->curlen < 56) {

  0011f	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00124	83 78 1c 38	 cmp	 DWORD PTR [rax+28], 56	; 00000038H
  00128	73 26		 jae	 SHORT $LN4@sha1_done

; 271  :         sha1->buf[sha1->curlen++] = (unsigned char)0;

  0012a	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  0012f	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00132	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  00137	c6 44 01 20 00	 mov	 BYTE PTR [rcx+rax+32], 0
  0013c	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00141	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00144	ff c0		 inc	 eax
  00146	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  0014b	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 272  :     }

  0014e	eb cf		 jmp	 SHORT $LN5@sha1_done
$LN4@sha1_done:

; 273  : 
; 274  :     /* store length */
; 275  :     STORE64H(sha1->length, sha1->buf+56);

  00150	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00155	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00158	48 c1 f8 38	 sar	 rax, 56			; 00000038H
  0015c	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00162	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  00167	88 41 58	 mov	 BYTE PTR [rcx+88], al
  0016a	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  0016f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00172	48 c1 f8 30	 sar	 rax, 48			; 00000030H
  00176	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0017c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  00181	88 41 59	 mov	 BYTE PTR [rcx+89], al
  00184	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00189	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0018c	48 c1 f8 28	 sar	 rax, 40			; 00000028H
  00190	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00196	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  0019b	88 41 5a	 mov	 BYTE PTR [rcx+90], al
  0019e	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  001a3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a6	48 c1 f8 20	 sar	 rax, 32			; 00000020H
  001aa	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  001b5	88 41 5b	 mov	 BYTE PTR [rcx+91], al
  001b8	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  001bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c0	48 c1 f8 18	 sar	 rax, 24
  001c4	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001ca	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  001cf	88 41 5c	 mov	 BYTE PTR [rcx+92], al
  001d2	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  001d7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001da	48 c1 f8 10	 sar	 rax, 16
  001de	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001e4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  001e9	88 41 5d	 mov	 BYTE PTR [rcx+93], al
  001ec	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  001f1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f4	48 c1 f8 08	 sar	 rax, 8
  001f8	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  00203	88 41 5e	 mov	 BYTE PTR [rcx+94], al
  00206	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  0020b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0020e	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00214	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  00219	88 41 5f	 mov	 BYTE PTR [rcx+95], al

; 276  :     sha1_compress(sha1, sha1->buf);

  0021c	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00221	48 83 c0 20	 add	 rax, 32			; 00000020H
  00225	48 8b d0	 mov	 rdx, rax
  00228	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  0022d	e8 00 00 00 00	 call	 sha1_compress

; 277  : 
; 278  :     /* copy output */
; 279  :     for (i = 0; i < 5; i++) {

  00232	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0023a	eb 0a		 jmp	 SHORT $LN3@sha1_done
$LN2@sha1_done:
  0023c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00240	ff c0		 inc	 eax
  00242	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN3@sha1_done:
  00246	83 7c 24 20 05	 cmp	 DWORD PTR i$[rsp], 5
  0024b	0f 8d a5 00 00
	00		 jge	 $LN1@sha1_done

; 280  :         STORE32H(sha1->state[i], out+(4*i));

  00251	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00256	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  0025b	8b 44 81 08	 mov	 eax, DWORD PTR [rcx+rax*4+8]
  0025f	c1 e8 18	 shr	 eax, 24
  00262	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00267	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0026b	c1 e1 02	 shl	 ecx, 2
  0026e	48 63 c9	 movsxd	 rcx, ecx
  00271	48 8b 54 24 48	 mov	 rdx, QWORD PTR out$[rsp]
  00276	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00279	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0027e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  00283	8b 44 81 08	 mov	 eax, DWORD PTR [rcx+rax*4+8]
  00287	c1 e8 10	 shr	 eax, 16
  0028a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0028f	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00293	c1 e1 02	 shl	 ecx, 2
  00296	48 63 c9	 movsxd	 rcx, ecx
  00299	48 8b 54 24 48	 mov	 rdx, QWORD PTR out$[rsp]
  0029e	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al
  002a2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  002ac	8b 44 81 08	 mov	 eax, DWORD PTR [rcx+rax*4+8]
  002b0	c1 e8 08	 shr	 eax, 8
  002b3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002b8	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  002bc	c1 e1 02	 shl	 ecx, 2
  002bf	48 63 c9	 movsxd	 rcx, ecx
  002c2	48 8b 54 24 48	 mov	 rdx, QWORD PTR out$[rsp]
  002c7	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al
  002cb	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  002d5	8b 44 81 08	 mov	 eax, DWORD PTR [rcx+rax*4+8]
  002d9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002de	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  002e2	c1 e1 02	 shl	 ecx, 2
  002e5	48 63 c9	 movsxd	 rcx, ecx
  002e8	48 8b 54 24 48	 mov	 rdx, QWORD PTR out$[rsp]
  002ed	88 44 0a 03	 mov	 BYTE PTR [rdx+rcx+3], al

; 281  :     }

  002f1	e9 46 ff ff ff	 jmp	 $LN2@sha1_done
$LN1@sha1_done:

; 282  : }

  002f6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002fa	c3		 ret	 0
sha1_done ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sha1_compress DD imagerel sha1_compress
	DD	imagerel sha1_compress+3626
	DD	imagerel $unwind$sha1_compress
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sha1_compress DD 021101H
	DD	02d0111H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT sha1_compress
_TEXT	SEGMENT
W$ = 0
a$ = 320
i$ = 324
b$ = 328
d$ = 332
c$ = 336
e$ = 340
sha1$ = 368
buf$ = 376
sha1_compress PROC					; COMDAT

; 108  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H

; 109  :     SHA1_INT32 a,b,c,d,e,W[80],i;
; 110  : 
; 111  :     /* copy the state into 512-bits into W[0..15] */
; 112  :     for (i = 0; i < 16; i++) {

  00011	c7 84 24 44 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0001c	eb 10		 jmp	 SHORT $LN14@sha1_compr
$LN13@sha1_compr:
  0001e	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00025	ff c0		 inc	 eax
  00027	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN14@sha1_compr:
  0002e	83 bc 24 44 01
	00 00 10	 cmp	 DWORD PTR i$[rsp], 16
  00036	0f 83 98 00 00
	00		 jae	 $LN12@sha1_compr

; 113  :         LOAD32H(W[i], buf + (4*i));

  0003c	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00043	c1 e0 02	 shl	 eax, 2
  00046	8b c0		 mov	 eax, eax
  00048	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00050	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00054	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00059	c1 e0 18	 shl	 eax, 24
  0005c	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00063	c1 e1 02	 shl	 ecx, 2
  00066	8b c9		 mov	 ecx, ecx
  00068	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00070	0f b6 4c 0a 01	 movzx	 ecx, BYTE PTR [rdx+rcx+1]
  00075	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0007b	c1 e1 10	 shl	 ecx, 16
  0007e	0b c1		 or	 eax, ecx
  00080	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00087	c1 e1 02	 shl	 ecx, 2
  0008a	8b c9		 mov	 ecx, ecx
  0008c	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00094	0f b6 4c 0a 02	 movzx	 ecx, BYTE PTR [rdx+rcx+2]
  00099	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0009f	c1 e1 08	 shl	 ecx, 8
  000a2	0b c1		 or	 eax, ecx
  000a4	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  000ab	c1 e1 02	 shl	 ecx, 2
  000ae	8b c9		 mov	 ecx, ecx
  000b0	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000b8	0f b6 4c 0a 03	 movzx	 ecx, BYTE PTR [rdx+rcx+3]
  000bd	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000c3	0b c1		 or	 eax, ecx
  000c5	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  000cc	89 04 8c	 mov	 DWORD PTR W$[rsp+rcx*4], eax

; 114  :     }

  000cf	e9 4a ff ff ff	 jmp	 $LN13@sha1_compr
$LN12@sha1_compr:

; 115  : 
; 116  :     /* copy state */
; 117  :     a = sha1->state[0];

  000d4	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sha1$[rsp]
  000dc	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000df	89 84 24 40 01
	00 00		 mov	 DWORD PTR a$[rsp], eax

; 118  :     b = sha1->state[1];

  000e6	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sha1$[rsp]
  000ee	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  000f1	89 84 24 48 01
	00 00		 mov	 DWORD PTR b$[rsp], eax

; 119  :     c = sha1->state[2];

  000f8	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sha1$[rsp]
  00100	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00103	89 84 24 50 01
	00 00		 mov	 DWORD PTR c$[rsp], eax

; 120  :     d = sha1->state[3];

  0010a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sha1$[rsp]
  00112	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00115	89 84 24 4c 01
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 121  :     e = sha1->state[4];

  0011c	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sha1$[rsp]
  00124	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00127	89 84 24 54 01
	00 00		 mov	 DWORD PTR e$[rsp], eax

; 122  : 
; 123  :     /* expand it */
; 124  :     for (i = 16; i < 80; i++) {

  0012e	c7 84 24 44 01
	00 00 10 00 00
	00		 mov	 DWORD PTR i$[rsp], 16
  00139	eb 10		 jmp	 SHORT $LN11@sha1_compr
$LN10@sha1_compr:
  0013b	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00142	ff c0		 inc	 eax
  00144	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN11@sha1_compr:
  0014b	83 bc 24 44 01
	00 00 50	 cmp	 DWORD PTR i$[rsp], 80	; 00000050H
  00153	0f 83 92 00 00
	00		 jae	 $LN9@sha1_compr

; 125  :         W[i] = ROL(W[i-3] ^ W[i-8] ^ W[i-14] ^ W[i-16], 1);

  00159	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00160	83 e8 03	 sub	 eax, 3
  00163	8b c0		 mov	 eax, eax
  00165	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0016c	83 e9 08	 sub	 ecx, 8
  0016f	8b c9		 mov	 ecx, ecx
  00171	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  00174	8b 04 84	 mov	 eax, DWORD PTR W$[rsp+rax*4]
  00177	33 c1		 xor	 eax, ecx
  00179	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00180	83 e9 0e	 sub	 ecx, 14
  00183	8b c9		 mov	 ecx, ecx
  00185	33 04 8c	 xor	 eax, DWORD PTR W$[rsp+rcx*4]
  00188	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0018f	83 e9 10	 sub	 ecx, 16
  00192	8b c9		 mov	 ecx, ecx
  00194	33 04 8c	 xor	 eax, DWORD PTR W$[rsp+rcx*4]
  00197	d1 e0		 shl	 eax, 1
  00199	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  001a0	83 e9 03	 sub	 ecx, 3
  001a3	8b c9		 mov	 ecx, ecx
  001a5	8b 94 24 44 01
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  001ac	83 ea 08	 sub	 edx, 8
  001af	8b d2		 mov	 edx, edx
  001b1	8b 14 94	 mov	 edx, DWORD PTR W$[rsp+rdx*4]
  001b4	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  001b7	33 ca		 xor	 ecx, edx
  001b9	8b 94 24 44 01
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  001c0	83 ea 0e	 sub	 edx, 14
  001c3	8b d2		 mov	 edx, edx
  001c5	33 0c 94	 xor	 ecx, DWORD PTR W$[rsp+rdx*4]
  001c8	8b 94 24 44 01
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  001cf	83 ea 10	 sub	 edx, 16
  001d2	8b d2		 mov	 edx, edx
  001d4	33 0c 94	 xor	 ecx, DWORD PTR W$[rsp+rdx*4]
  001d7	c1 e9 1f	 shr	 ecx, 31
  001da	0b c1		 or	 eax, ecx
  001dc	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  001e3	89 04 8c	 mov	 DWORD PTR W$[rsp+rcx*4], eax

; 126  :     }

  001e6	e9 50 ff ff ff	 jmp	 $LN10@sha1_compr
$LN9@sha1_compr:

; 127  : 
; 128  :     /* compress */
; 129  :     /* round one */
; 130  :     #define FF_0(a,b,c,d,e,i) e = (ROLc(a, 5) + F0(b,c,d) + e + W[i] + 0x5a827999UL); b = ROLc(b, 30);
; 131  :     #define FF_1(a,b,c,d,e,i) e = (ROLc(a, 5) + F1(b,c,d) + e + W[i] + 0x6ed9eba1UL); b = ROLc(b, 30);
; 132  :     #define FF_2(a,b,c,d,e,i) e = (ROLc(a, 5) + F2(b,c,d) + e + W[i] + 0x8f1bbcdcUL); b = ROLc(b, 30);
; 133  :     #define FF_3(a,b,c,d,e,i) e = (ROLc(a, 5) + F3(b,c,d) + e + W[i] + 0xca62c1d6UL); b = ROLc(b, 30);
; 134  : 
; 135  :     for (i = 0; i < 20; ) {

  001eb	c7 84 24 44 01
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
$LN8@sha1_compr:
  001f6	83 bc 24 44 01
	00 00 14	 cmp	 DWORD PTR i$[rsp], 20
  001fe	0f 83 df 02 00
	00		 jae	 $LN7@sha1_compr

; 136  :        FF_0(a,b,c,d,e,i++);

  00204	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR a$[rsp]
  0020b	c1 e0 05	 shl	 eax, 5
  0020e	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  00215	c1 e9 1b	 shr	 ecx, 27
  00218	0b c1		 or	 eax, ecx
  0021a	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  00221	8b 94 24 50 01
	00 00		 mov	 edx, DWORD PTR c$[rsp]
  00228	33 d1		 xor	 edx, ecx
  0022a	8b ca		 mov	 ecx, edx
  0022c	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR b$[rsp]
  00233	23 d1		 and	 edx, ecx
  00235	8b ca		 mov	 ecx, edx
  00237	8b 94 24 4c 01
	00 00		 mov	 edx, DWORD PTR d$[rsp]
  0023e	33 d1		 xor	 edx, ecx
  00240	8b ca		 mov	 ecx, edx
  00242	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR e$[rsp]
  00249	03 d0		 add	 edx, eax
  0024b	8b c2		 mov	 eax, edx
  0024d	03 c8		 add	 ecx, eax
  0024f	8b c1		 mov	 eax, ecx
  00251	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00258	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  0025b	8d 84 08 99 79
	82 5a		 lea	 eax, DWORD PTR [rax+rcx+1518500249]
  00262	89 84 24 54 01
	00 00		 mov	 DWORD PTR e$[rsp], eax
  00269	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00270	ff c0		 inc	 eax
  00272	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00279	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  00280	c1 e0 1e	 shl	 eax, 30
  00283	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  0028a	c1 e9 02	 shr	 ecx, 2
  0028d	0b c1		 or	 eax, ecx
  0028f	89 84 24 48 01
	00 00		 mov	 DWORD PTR b$[rsp], eax

; 137  :        FF_0(e,a,b,c,d,i++);

  00296	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  0029d	c1 e0 05	 shl	 eax, 5
  002a0	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  002a7	c1 e9 1b	 shr	 ecx, 27
  002aa	0b c1		 or	 eax, ecx
  002ac	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  002b3	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR b$[rsp]
  002ba	33 d1		 xor	 edx, ecx
  002bc	8b ca		 mov	 ecx, edx
  002be	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR a$[rsp]
  002c5	23 d1		 and	 edx, ecx
  002c7	8b ca		 mov	 ecx, edx
  002c9	8b 94 24 50 01
	00 00		 mov	 edx, DWORD PTR c$[rsp]
  002d0	33 d1		 xor	 edx, ecx
  002d2	8b ca		 mov	 ecx, edx
  002d4	8b 94 24 4c 01
	00 00		 mov	 edx, DWORD PTR d$[rsp]
  002db	03 d0		 add	 edx, eax
  002dd	8b c2		 mov	 eax, edx
  002df	03 c8		 add	 ecx, eax
  002e1	8b c1		 mov	 eax, ecx
  002e3	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  002ea	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  002ed	8d 84 08 99 79
	82 5a		 lea	 eax, DWORD PTR [rax+rcx+1518500249]
  002f4	89 84 24 4c 01
	00 00		 mov	 DWORD PTR d$[rsp], eax
  002fb	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00302	ff c0		 inc	 eax
  00304	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  0030b	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR a$[rsp]
  00312	c1 e0 1e	 shl	 eax, 30
  00315	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  0031c	c1 e9 02	 shr	 ecx, 2
  0031f	0b c1		 or	 eax, ecx
  00321	89 84 24 40 01
	00 00		 mov	 DWORD PTR a$[rsp], eax

; 138  :        FF_0(d,e,a,b,c,i++);

  00328	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR d$[rsp]
  0032f	c1 e0 05	 shl	 eax, 5
  00332	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  00339	c1 e9 1b	 shr	 ecx, 27
  0033c	0b c1		 or	 eax, ecx
  0033e	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  00345	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR a$[rsp]
  0034c	33 d1		 xor	 edx, ecx
  0034e	8b ca		 mov	 ecx, edx
  00350	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR e$[rsp]
  00357	23 d1		 and	 edx, ecx
  00359	8b ca		 mov	 ecx, edx
  0035b	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR b$[rsp]
  00362	33 d1		 xor	 edx, ecx
  00364	8b ca		 mov	 ecx, edx
  00366	8b 94 24 50 01
	00 00		 mov	 edx, DWORD PTR c$[rsp]
  0036d	03 d0		 add	 edx, eax
  0036f	8b c2		 mov	 eax, edx
  00371	03 c8		 add	 ecx, eax
  00373	8b c1		 mov	 eax, ecx
  00375	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0037c	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  0037f	8d 84 08 99 79
	82 5a		 lea	 eax, DWORD PTR [rax+rcx+1518500249]
  00386	89 84 24 50 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
  0038d	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00394	ff c0		 inc	 eax
  00396	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  0039d	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  003a4	c1 e0 1e	 shl	 eax, 30
  003a7	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  003ae	c1 e9 02	 shr	 ecx, 2
  003b1	0b c1		 or	 eax, ecx
  003b3	89 84 24 54 01
	00 00		 mov	 DWORD PTR e$[rsp], eax

; 139  :        FF_0(c,d,e,a,b,i++);

  003ba	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  003c1	c1 e0 05	 shl	 eax, 5
  003c4	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  003cb	c1 e9 1b	 shr	 ecx, 27
  003ce	0b c1		 or	 eax, ecx
  003d0	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  003d7	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR e$[rsp]
  003de	33 d1		 xor	 edx, ecx
  003e0	8b ca		 mov	 ecx, edx
  003e2	8b 94 24 4c 01
	00 00		 mov	 edx, DWORD PTR d$[rsp]
  003e9	23 d1		 and	 edx, ecx
  003eb	8b ca		 mov	 ecx, edx
  003ed	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR a$[rsp]
  003f4	33 d1		 xor	 edx, ecx
  003f6	8b ca		 mov	 ecx, edx
  003f8	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR b$[rsp]
  003ff	03 d0		 add	 edx, eax
  00401	8b c2		 mov	 eax, edx
  00403	03 c8		 add	 ecx, eax
  00405	8b c1		 mov	 eax, ecx
  00407	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0040e	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  00411	8d 84 08 99 79
	82 5a		 lea	 eax, DWORD PTR [rax+rcx+1518500249]
  00418	89 84 24 48 01
	00 00		 mov	 DWORD PTR b$[rsp], eax
  0041f	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00426	ff c0		 inc	 eax
  00428	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  0042f	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR d$[rsp]
  00436	c1 e0 1e	 shl	 eax, 30
  00439	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  00440	c1 e9 02	 shr	 ecx, 2
  00443	0b c1		 or	 eax, ecx
  00445	89 84 24 4c 01
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 140  :        FF_0(b,c,d,e,a,i++);

  0044c	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  00453	c1 e0 05	 shl	 eax, 5
  00456	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  0045d	c1 e9 1b	 shr	 ecx, 27
  00460	0b c1		 or	 eax, ecx
  00462	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  00469	8b 94 24 4c 01
	00 00		 mov	 edx, DWORD PTR d$[rsp]
  00470	33 d1		 xor	 edx, ecx
  00472	8b ca		 mov	 ecx, edx
  00474	8b 94 24 50 01
	00 00		 mov	 edx, DWORD PTR c$[rsp]
  0047b	23 d1		 and	 edx, ecx
  0047d	8b ca		 mov	 ecx, edx
  0047f	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR e$[rsp]
  00486	33 d1		 xor	 edx, ecx
  00488	8b ca		 mov	 ecx, edx
  0048a	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR a$[rsp]
  00491	03 d0		 add	 edx, eax
  00493	8b c2		 mov	 eax, edx
  00495	03 c8		 add	 ecx, eax
  00497	8b c1		 mov	 eax, ecx
  00499	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  004a0	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  004a3	8d 84 08 99 79
	82 5a		 lea	 eax, DWORD PTR [rax+rcx+1518500249]
  004aa	89 84 24 40 01
	00 00		 mov	 DWORD PTR a$[rsp], eax
  004b1	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  004b8	ff c0		 inc	 eax
  004ba	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  004c1	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  004c8	c1 e0 1e	 shl	 eax, 30
  004cb	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  004d2	c1 e9 02	 shr	 ecx, 2
  004d5	0b c1		 or	 eax, ecx
  004d7	89 84 24 50 01
	00 00		 mov	 DWORD PTR c$[rsp], eax

; 141  :     }

  004de	e9 13 fd ff ff	 jmp	 $LN8@sha1_compr
$LN7@sha1_compr:
$LN6@sha1_compr:

; 142  : 
; 143  :     /* round two */
; 144  :     for (; i < 40; )  {

  004e3	83 bc 24 44 01
	00 00 28	 cmp	 DWORD PTR i$[rsp], 40	; 00000028H
  004eb	0f 83 94 02 00
	00		 jae	 $LN5@sha1_compr

; 145  :        FF_1(a,b,c,d,e,i++);

  004f1	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR a$[rsp]
  004f8	c1 e0 05	 shl	 eax, 5
  004fb	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  00502	c1 e9 1b	 shr	 ecx, 27
  00505	0b c1		 or	 eax, ecx
  00507	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  0050e	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR b$[rsp]
  00515	33 d1		 xor	 edx, ecx
  00517	8b ca		 mov	 ecx, edx
  00519	33 8c 24 4c 01
	00 00		 xor	 ecx, DWORD PTR d$[rsp]
  00520	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR e$[rsp]
  00527	03 d0		 add	 edx, eax
  00529	8b c2		 mov	 eax, edx
  0052b	03 c8		 add	 ecx, eax
  0052d	8b c1		 mov	 eax, ecx
  0052f	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00536	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  00539	8d 84 08 a1 eb
	d9 6e		 lea	 eax, DWORD PTR [rax+rcx+1859775393]
  00540	89 84 24 54 01
	00 00		 mov	 DWORD PTR e$[rsp], eax
  00547	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0054e	ff c0		 inc	 eax
  00550	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00557	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  0055e	c1 e0 1e	 shl	 eax, 30
  00561	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  00568	c1 e9 02	 shr	 ecx, 2
  0056b	0b c1		 or	 eax, ecx
  0056d	89 84 24 48 01
	00 00		 mov	 DWORD PTR b$[rsp], eax

; 146  :        FF_1(e,a,b,c,d,i++);

  00574	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  0057b	c1 e0 05	 shl	 eax, 5
  0057e	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  00585	c1 e9 1b	 shr	 ecx, 27
  00588	0b c1		 or	 eax, ecx
  0058a	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  00591	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR a$[rsp]
  00598	33 d1		 xor	 edx, ecx
  0059a	8b ca		 mov	 ecx, edx
  0059c	33 8c 24 50 01
	00 00		 xor	 ecx, DWORD PTR c$[rsp]
  005a3	8b 94 24 4c 01
	00 00		 mov	 edx, DWORD PTR d$[rsp]
  005aa	03 d0		 add	 edx, eax
  005ac	8b c2		 mov	 eax, edx
  005ae	03 c8		 add	 ecx, eax
  005b0	8b c1		 mov	 eax, ecx
  005b2	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  005b9	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  005bc	8d 84 08 a1 eb
	d9 6e		 lea	 eax, DWORD PTR [rax+rcx+1859775393]
  005c3	89 84 24 4c 01
	00 00		 mov	 DWORD PTR d$[rsp], eax
  005ca	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  005d1	ff c0		 inc	 eax
  005d3	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  005da	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR a$[rsp]
  005e1	c1 e0 1e	 shl	 eax, 30
  005e4	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  005eb	c1 e9 02	 shr	 ecx, 2
  005ee	0b c1		 or	 eax, ecx
  005f0	89 84 24 40 01
	00 00		 mov	 DWORD PTR a$[rsp], eax

; 147  :        FF_1(d,e,a,b,c,i++);

  005f7	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR d$[rsp]
  005fe	c1 e0 05	 shl	 eax, 5
  00601	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  00608	c1 e9 1b	 shr	 ecx, 27
  0060b	0b c1		 or	 eax, ecx
  0060d	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  00614	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR e$[rsp]
  0061b	33 d1		 xor	 edx, ecx
  0061d	8b ca		 mov	 ecx, edx
  0061f	33 8c 24 48 01
	00 00		 xor	 ecx, DWORD PTR b$[rsp]
  00626	8b 94 24 50 01
	00 00		 mov	 edx, DWORD PTR c$[rsp]
  0062d	03 d0		 add	 edx, eax
  0062f	8b c2		 mov	 eax, edx
  00631	03 c8		 add	 ecx, eax
  00633	8b c1		 mov	 eax, ecx
  00635	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0063c	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  0063f	8d 84 08 a1 eb
	d9 6e		 lea	 eax, DWORD PTR [rax+rcx+1859775393]
  00646	89 84 24 50 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
  0064d	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00654	ff c0		 inc	 eax
  00656	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  0065d	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  00664	c1 e0 1e	 shl	 eax, 30
  00667	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  0066e	c1 e9 02	 shr	 ecx, 2
  00671	0b c1		 or	 eax, ecx
  00673	89 84 24 54 01
	00 00		 mov	 DWORD PTR e$[rsp], eax

; 148  :        FF_1(c,d,e,a,b,i++);

  0067a	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  00681	c1 e0 05	 shl	 eax, 5
  00684	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  0068b	c1 e9 1b	 shr	 ecx, 27
  0068e	0b c1		 or	 eax, ecx
  00690	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  00697	8b 94 24 4c 01
	00 00		 mov	 edx, DWORD PTR d$[rsp]
  0069e	33 d1		 xor	 edx, ecx
  006a0	8b ca		 mov	 ecx, edx
  006a2	33 8c 24 40 01
	00 00		 xor	 ecx, DWORD PTR a$[rsp]
  006a9	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR b$[rsp]
  006b0	03 d0		 add	 edx, eax
  006b2	8b c2		 mov	 eax, edx
  006b4	03 c8		 add	 ecx, eax
  006b6	8b c1		 mov	 eax, ecx
  006b8	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  006bf	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  006c2	8d 84 08 a1 eb
	d9 6e		 lea	 eax, DWORD PTR [rax+rcx+1859775393]
  006c9	89 84 24 48 01
	00 00		 mov	 DWORD PTR b$[rsp], eax
  006d0	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  006d7	ff c0		 inc	 eax
  006d9	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  006e0	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR d$[rsp]
  006e7	c1 e0 1e	 shl	 eax, 30
  006ea	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  006f1	c1 e9 02	 shr	 ecx, 2
  006f4	0b c1		 or	 eax, ecx
  006f6	89 84 24 4c 01
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 149  :        FF_1(b,c,d,e,a,i++);

  006fd	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  00704	c1 e0 05	 shl	 eax, 5
  00707	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  0070e	c1 e9 1b	 shr	 ecx, 27
  00711	0b c1		 or	 eax, ecx
  00713	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  0071a	8b 94 24 50 01
	00 00		 mov	 edx, DWORD PTR c$[rsp]
  00721	33 d1		 xor	 edx, ecx
  00723	8b ca		 mov	 ecx, edx
  00725	33 8c 24 54 01
	00 00		 xor	 ecx, DWORD PTR e$[rsp]
  0072c	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR a$[rsp]
  00733	03 d0		 add	 edx, eax
  00735	8b c2		 mov	 eax, edx
  00737	03 c8		 add	 ecx, eax
  00739	8b c1		 mov	 eax, ecx
  0073b	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00742	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  00745	8d 84 08 a1 eb
	d9 6e		 lea	 eax, DWORD PTR [rax+rcx+1859775393]
  0074c	89 84 24 40 01
	00 00		 mov	 DWORD PTR a$[rsp], eax
  00753	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0075a	ff c0		 inc	 eax
  0075c	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00763	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  0076a	c1 e0 1e	 shl	 eax, 30
  0076d	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  00774	c1 e9 02	 shr	 ecx, 2
  00777	0b c1		 or	 eax, ecx
  00779	89 84 24 50 01
	00 00		 mov	 DWORD PTR c$[rsp], eax

; 150  :     }

  00780	e9 5e fd ff ff	 jmp	 $LN6@sha1_compr
$LN5@sha1_compr:
$LN4@sha1_compr:

; 151  : 
; 152  :     /* round three */
; 153  :     for (; i < 60; )  {

  00785	83 bc 24 44 01
	00 00 3c	 cmp	 DWORD PTR i$[rsp], 60	; 0000003cH
  0078d	0f 83 43 03 00
	00		 jae	 $LN3@sha1_compr

; 154  :        FF_2(a,b,c,d,e,i++);

  00793	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR a$[rsp]
  0079a	c1 e0 05	 shl	 eax, 5
  0079d	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  007a4	c1 e9 1b	 shr	 ecx, 27
  007a7	0b c1		 or	 eax, ecx
  007a9	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  007b0	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR b$[rsp]
  007b7	23 d1		 and	 edx, ecx
  007b9	8b ca		 mov	 ecx, edx
  007bb	8b 94 24 50 01
	00 00		 mov	 edx, DWORD PTR c$[rsp]
  007c2	44 8b 84 24 48
	01 00 00	 mov	 r8d, DWORD PTR b$[rsp]
  007ca	44 0b c2	 or	 r8d, edx
  007cd	41 8b d0	 mov	 edx, r8d
  007d0	44 8b 84 24 4c
	01 00 00	 mov	 r8d, DWORD PTR d$[rsp]
  007d8	44 23 c2	 and	 r8d, edx
  007db	41 8b d0	 mov	 edx, r8d
  007de	0b ca		 or	 ecx, edx
  007e0	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR e$[rsp]
  007e7	03 d0		 add	 edx, eax
  007e9	8b c2		 mov	 eax, edx
  007eb	03 c8		 add	 ecx, eax
  007ed	8b c1		 mov	 eax, ecx
  007ef	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  007f6	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  007f9	ba dc bc 1b 8f	 mov	 edx, -1894007588	; ffffffff8f1bbcdcH
  007fe	48 8d 04 10	 lea	 rax, QWORD PTR [rax+rdx]
  00802	8d 04 08	 lea	 eax, DWORD PTR [rax+rcx]
  00805	89 84 24 54 01
	00 00		 mov	 DWORD PTR e$[rsp], eax
  0080c	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00813	ff c0		 inc	 eax
  00815	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  0081c	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  00823	c1 e0 1e	 shl	 eax, 30
  00826	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  0082d	c1 e9 02	 shr	 ecx, 2
  00830	0b c1		 or	 eax, ecx
  00832	89 84 24 48 01
	00 00		 mov	 DWORD PTR b$[rsp], eax

; 155  :        FF_2(e,a,b,c,d,i++);

  00839	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  00840	c1 e0 05	 shl	 eax, 5
  00843	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  0084a	c1 e9 1b	 shr	 ecx, 27
  0084d	0b c1		 or	 eax, ecx
  0084f	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  00856	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR a$[rsp]
  0085d	23 d1		 and	 edx, ecx
  0085f	8b ca		 mov	 ecx, edx
  00861	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR b$[rsp]
  00868	44 8b 84 24 40
	01 00 00	 mov	 r8d, DWORD PTR a$[rsp]
  00870	44 0b c2	 or	 r8d, edx
  00873	41 8b d0	 mov	 edx, r8d
  00876	44 8b 84 24 50
	01 00 00	 mov	 r8d, DWORD PTR c$[rsp]
  0087e	44 23 c2	 and	 r8d, edx
  00881	41 8b d0	 mov	 edx, r8d
  00884	0b ca		 or	 ecx, edx
  00886	8b 94 24 4c 01
	00 00		 mov	 edx, DWORD PTR d$[rsp]
  0088d	03 d0		 add	 edx, eax
  0088f	8b c2		 mov	 eax, edx
  00891	03 c8		 add	 ecx, eax
  00893	8b c1		 mov	 eax, ecx
  00895	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0089c	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  0089f	ba dc bc 1b 8f	 mov	 edx, -1894007588	; ffffffff8f1bbcdcH
  008a4	48 8d 04 10	 lea	 rax, QWORD PTR [rax+rdx]
  008a8	8d 04 08	 lea	 eax, DWORD PTR [rax+rcx]
  008ab	89 84 24 4c 01
	00 00		 mov	 DWORD PTR d$[rsp], eax
  008b2	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  008b9	ff c0		 inc	 eax
  008bb	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  008c2	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR a$[rsp]
  008c9	c1 e0 1e	 shl	 eax, 30
  008cc	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  008d3	c1 e9 02	 shr	 ecx, 2
  008d6	0b c1		 or	 eax, ecx
  008d8	89 84 24 40 01
	00 00		 mov	 DWORD PTR a$[rsp], eax

; 156  :        FF_2(d,e,a,b,c,i++);

  008df	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR d$[rsp]
  008e6	c1 e0 05	 shl	 eax, 5
  008e9	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  008f0	c1 e9 1b	 shr	 ecx, 27
  008f3	0b c1		 or	 eax, ecx
  008f5	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  008fc	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR e$[rsp]
  00903	23 d1		 and	 edx, ecx
  00905	8b ca		 mov	 ecx, edx
  00907	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR a$[rsp]
  0090e	44 8b 84 24 54
	01 00 00	 mov	 r8d, DWORD PTR e$[rsp]
  00916	44 0b c2	 or	 r8d, edx
  00919	41 8b d0	 mov	 edx, r8d
  0091c	44 8b 84 24 48
	01 00 00	 mov	 r8d, DWORD PTR b$[rsp]
  00924	44 23 c2	 and	 r8d, edx
  00927	41 8b d0	 mov	 edx, r8d
  0092a	0b ca		 or	 ecx, edx
  0092c	8b 94 24 50 01
	00 00		 mov	 edx, DWORD PTR c$[rsp]
  00933	03 d0		 add	 edx, eax
  00935	8b c2		 mov	 eax, edx
  00937	03 c8		 add	 ecx, eax
  00939	8b c1		 mov	 eax, ecx
  0093b	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00942	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  00945	ba dc bc 1b 8f	 mov	 edx, -1894007588	; ffffffff8f1bbcdcH
  0094a	48 8d 04 10	 lea	 rax, QWORD PTR [rax+rdx]
  0094e	8d 04 08	 lea	 eax, DWORD PTR [rax+rcx]
  00951	89 84 24 50 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
  00958	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0095f	ff c0		 inc	 eax
  00961	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00968	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  0096f	c1 e0 1e	 shl	 eax, 30
  00972	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  00979	c1 e9 02	 shr	 ecx, 2
  0097c	0b c1		 or	 eax, ecx
  0097e	89 84 24 54 01
	00 00		 mov	 DWORD PTR e$[rsp], eax

; 157  :        FF_2(c,d,e,a,b,i++);

  00985	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  0098c	c1 e0 05	 shl	 eax, 5
  0098f	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  00996	c1 e9 1b	 shr	 ecx, 27
  00999	0b c1		 or	 eax, ecx
  0099b	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  009a2	8b 94 24 4c 01
	00 00		 mov	 edx, DWORD PTR d$[rsp]
  009a9	23 d1		 and	 edx, ecx
  009ab	8b ca		 mov	 ecx, edx
  009ad	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR e$[rsp]
  009b4	44 8b 84 24 4c
	01 00 00	 mov	 r8d, DWORD PTR d$[rsp]
  009bc	44 0b c2	 or	 r8d, edx
  009bf	41 8b d0	 mov	 edx, r8d
  009c2	44 8b 84 24 40
	01 00 00	 mov	 r8d, DWORD PTR a$[rsp]
  009ca	44 23 c2	 and	 r8d, edx
  009cd	41 8b d0	 mov	 edx, r8d
  009d0	0b ca		 or	 ecx, edx
  009d2	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR b$[rsp]
  009d9	03 d0		 add	 edx, eax
  009db	8b c2		 mov	 eax, edx
  009dd	03 c8		 add	 ecx, eax
  009df	8b c1		 mov	 eax, ecx
  009e1	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  009e8	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  009eb	ba dc bc 1b 8f	 mov	 edx, -1894007588	; ffffffff8f1bbcdcH
  009f0	48 8d 04 10	 lea	 rax, QWORD PTR [rax+rdx]
  009f4	8d 04 08	 lea	 eax, DWORD PTR [rax+rcx]
  009f7	89 84 24 48 01
	00 00		 mov	 DWORD PTR b$[rsp], eax
  009fe	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00a05	ff c0		 inc	 eax
  00a07	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00a0e	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR d$[rsp]
  00a15	c1 e0 1e	 shl	 eax, 30
  00a18	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  00a1f	c1 e9 02	 shr	 ecx, 2
  00a22	0b c1		 or	 eax, ecx
  00a24	89 84 24 4c 01
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 158  :        FF_2(b,c,d,e,a,i++);

  00a2b	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  00a32	c1 e0 05	 shl	 eax, 5
  00a35	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  00a3c	c1 e9 1b	 shr	 ecx, 27
  00a3f	0b c1		 or	 eax, ecx
  00a41	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  00a48	8b 94 24 50 01
	00 00		 mov	 edx, DWORD PTR c$[rsp]
  00a4f	23 d1		 and	 edx, ecx
  00a51	8b ca		 mov	 ecx, edx
  00a53	8b 94 24 4c 01
	00 00		 mov	 edx, DWORD PTR d$[rsp]
  00a5a	44 8b 84 24 50
	01 00 00	 mov	 r8d, DWORD PTR c$[rsp]
  00a62	44 0b c2	 or	 r8d, edx
  00a65	41 8b d0	 mov	 edx, r8d
  00a68	44 8b 84 24 54
	01 00 00	 mov	 r8d, DWORD PTR e$[rsp]
  00a70	44 23 c2	 and	 r8d, edx
  00a73	41 8b d0	 mov	 edx, r8d
  00a76	0b ca		 or	 ecx, edx
  00a78	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR a$[rsp]
  00a7f	03 d0		 add	 edx, eax
  00a81	8b c2		 mov	 eax, edx
  00a83	03 c8		 add	 ecx, eax
  00a85	8b c1		 mov	 eax, ecx
  00a87	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00a8e	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  00a91	ba dc bc 1b 8f	 mov	 edx, -1894007588	; ffffffff8f1bbcdcH
  00a96	48 8d 04 10	 lea	 rax, QWORD PTR [rax+rdx]
  00a9a	8d 04 08	 lea	 eax, DWORD PTR [rax+rcx]
  00a9d	89 84 24 40 01
	00 00		 mov	 DWORD PTR a$[rsp], eax
  00aa4	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00aab	ff c0		 inc	 eax
  00aad	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00ab4	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  00abb	c1 e0 1e	 shl	 eax, 30
  00abe	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  00ac5	c1 e9 02	 shr	 ecx, 2
  00ac8	0b c1		 or	 eax, ecx
  00aca	89 84 24 50 01
	00 00		 mov	 DWORD PTR c$[rsp], eax

; 159  :     }

  00ad1	e9 af fc ff ff	 jmp	 $LN4@sha1_compr
$LN3@sha1_compr:
$LN2@sha1_compr:

; 160  : 
; 161  :     /* round four */
; 162  :     for (; i < 80; )  {

  00ad6	83 bc 24 44 01
	00 00 50	 cmp	 DWORD PTR i$[rsp], 80	; 00000050H
  00ade	0f 83 ad 02 00
	00		 jae	 $LN1@sha1_compr

; 163  :        FF_3(a,b,c,d,e,i++);

  00ae4	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR a$[rsp]
  00aeb	c1 e0 05	 shl	 eax, 5
  00aee	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  00af5	c1 e9 1b	 shr	 ecx, 27
  00af8	0b c1		 or	 eax, ecx
  00afa	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  00b01	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR b$[rsp]
  00b08	33 d1		 xor	 edx, ecx
  00b0a	8b ca		 mov	 ecx, edx
  00b0c	33 8c 24 4c 01
	00 00		 xor	 ecx, DWORD PTR d$[rsp]
  00b13	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR e$[rsp]
  00b1a	03 d0		 add	 edx, eax
  00b1c	8b c2		 mov	 eax, edx
  00b1e	03 c8		 add	 ecx, eax
  00b20	8b c1		 mov	 eax, ecx
  00b22	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00b29	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  00b2c	ba d6 c1 62 ca	 mov	 edx, -899497514		; ffffffffca62c1d6H
  00b31	48 8d 04 10	 lea	 rax, QWORD PTR [rax+rdx]
  00b35	8d 04 08	 lea	 eax, DWORD PTR [rax+rcx]
  00b38	89 84 24 54 01
	00 00		 mov	 DWORD PTR e$[rsp], eax
  00b3f	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00b46	ff c0		 inc	 eax
  00b48	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00b4f	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  00b56	c1 e0 1e	 shl	 eax, 30
  00b59	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  00b60	c1 e9 02	 shr	 ecx, 2
  00b63	0b c1		 or	 eax, ecx
  00b65	89 84 24 48 01
	00 00		 mov	 DWORD PTR b$[rsp], eax

; 164  :        FF_3(e,a,b,c,d,i++);

  00b6c	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  00b73	c1 e0 05	 shl	 eax, 5
  00b76	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  00b7d	c1 e9 1b	 shr	 ecx, 27
  00b80	0b c1		 or	 eax, ecx
  00b82	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  00b89	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR a$[rsp]
  00b90	33 d1		 xor	 edx, ecx
  00b92	8b ca		 mov	 ecx, edx
  00b94	33 8c 24 50 01
	00 00		 xor	 ecx, DWORD PTR c$[rsp]
  00b9b	8b 94 24 4c 01
	00 00		 mov	 edx, DWORD PTR d$[rsp]
  00ba2	03 d0		 add	 edx, eax
  00ba4	8b c2		 mov	 eax, edx
  00ba6	03 c8		 add	 ecx, eax
  00ba8	8b c1		 mov	 eax, ecx
  00baa	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00bb1	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  00bb4	ba d6 c1 62 ca	 mov	 edx, -899497514		; ffffffffca62c1d6H
  00bb9	48 8d 04 10	 lea	 rax, QWORD PTR [rax+rdx]
  00bbd	8d 04 08	 lea	 eax, DWORD PTR [rax+rcx]
  00bc0	89 84 24 4c 01
	00 00		 mov	 DWORD PTR d$[rsp], eax
  00bc7	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00bce	ff c0		 inc	 eax
  00bd0	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00bd7	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR a$[rsp]
  00bde	c1 e0 1e	 shl	 eax, 30
  00be1	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  00be8	c1 e9 02	 shr	 ecx, 2
  00beb	0b c1		 or	 eax, ecx
  00bed	89 84 24 40 01
	00 00		 mov	 DWORD PTR a$[rsp], eax

; 165  :        FF_3(d,e,a,b,c,i++);

  00bf4	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR d$[rsp]
  00bfb	c1 e0 05	 shl	 eax, 5
  00bfe	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  00c05	c1 e9 1b	 shr	 ecx, 27
  00c08	0b c1		 or	 eax, ecx
  00c0a	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  00c11	8b 94 24 54 01
	00 00		 mov	 edx, DWORD PTR e$[rsp]
  00c18	33 d1		 xor	 edx, ecx
  00c1a	8b ca		 mov	 ecx, edx
  00c1c	33 8c 24 48 01
	00 00		 xor	 ecx, DWORD PTR b$[rsp]
  00c23	8b 94 24 50 01
	00 00		 mov	 edx, DWORD PTR c$[rsp]
  00c2a	03 d0		 add	 edx, eax
  00c2c	8b c2		 mov	 eax, edx
  00c2e	03 c8		 add	 ecx, eax
  00c30	8b c1		 mov	 eax, ecx
  00c32	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00c39	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  00c3c	ba d6 c1 62 ca	 mov	 edx, -899497514		; ffffffffca62c1d6H
  00c41	48 8d 04 10	 lea	 rax, QWORD PTR [rax+rdx]
  00c45	8d 04 08	 lea	 eax, DWORD PTR [rax+rcx]
  00c48	89 84 24 50 01
	00 00		 mov	 DWORD PTR c$[rsp], eax
  00c4f	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00c56	ff c0		 inc	 eax
  00c58	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00c5f	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR e$[rsp]
  00c66	c1 e0 1e	 shl	 eax, 30
  00c69	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  00c70	c1 e9 02	 shr	 ecx, 2
  00c73	0b c1		 or	 eax, ecx
  00c75	89 84 24 54 01
	00 00		 mov	 DWORD PTR e$[rsp], eax

; 166  :        FF_3(c,d,e,a,b,i++);

  00c7c	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  00c83	c1 e0 05	 shl	 eax, 5
  00c86	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  00c8d	c1 e9 1b	 shr	 ecx, 27
  00c90	0b c1		 or	 eax, ecx
  00c92	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR e$[rsp]
  00c99	8b 94 24 4c 01
	00 00		 mov	 edx, DWORD PTR d$[rsp]
  00ca0	33 d1		 xor	 edx, ecx
  00ca2	8b ca		 mov	 ecx, edx
  00ca4	33 8c 24 40 01
	00 00		 xor	 ecx, DWORD PTR a$[rsp]
  00cab	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR b$[rsp]
  00cb2	03 d0		 add	 edx, eax
  00cb4	8b c2		 mov	 eax, edx
  00cb6	03 c8		 add	 ecx, eax
  00cb8	8b c1		 mov	 eax, ecx
  00cba	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00cc1	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  00cc4	ba d6 c1 62 ca	 mov	 edx, -899497514		; ffffffffca62c1d6H
  00cc9	48 8d 04 10	 lea	 rax, QWORD PTR [rax+rdx]
  00ccd	8d 04 08	 lea	 eax, DWORD PTR [rax+rcx]
  00cd0	89 84 24 48 01
	00 00		 mov	 DWORD PTR b$[rsp], eax
  00cd7	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00cde	ff c0		 inc	 eax
  00ce0	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00ce7	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR d$[rsp]
  00cee	c1 e0 1e	 shl	 eax, 30
  00cf1	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  00cf8	c1 e9 02	 shr	 ecx, 2
  00cfb	0b c1		 or	 eax, ecx
  00cfd	89 84 24 4c 01
	00 00		 mov	 DWORD PTR d$[rsp], eax

; 167  :        FF_3(b,c,d,e,a,i++);

  00d04	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR b$[rsp]
  00d0b	c1 e0 05	 shl	 eax, 5
  00d0e	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR b$[rsp]
  00d15	c1 e9 1b	 shr	 ecx, 27
  00d18	0b c1		 or	 eax, ecx
  00d1a	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR d$[rsp]
  00d21	8b 94 24 50 01
	00 00		 mov	 edx, DWORD PTR c$[rsp]
  00d28	33 d1		 xor	 edx, ecx
  00d2a	8b ca		 mov	 ecx, edx
  00d2c	33 8c 24 54 01
	00 00		 xor	 ecx, DWORD PTR e$[rsp]
  00d33	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR a$[rsp]
  00d3a	03 d0		 add	 edx, eax
  00d3c	8b c2		 mov	 eax, edx
  00d3e	03 c8		 add	 ecx, eax
  00d40	8b c1		 mov	 eax, ecx
  00d42	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00d49	8b 0c 8c	 mov	 ecx, DWORD PTR W$[rsp+rcx*4]
  00d4c	ba d6 c1 62 ca	 mov	 edx, -899497514		; ffffffffca62c1d6H
  00d51	48 8d 04 10	 lea	 rax, QWORD PTR [rax+rdx]
  00d55	8d 04 08	 lea	 eax, DWORD PTR [rax+rcx]
  00d58	89 84 24 40 01
	00 00		 mov	 DWORD PTR a$[rsp], eax
  00d5f	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00d66	ff c0		 inc	 eax
  00d68	89 84 24 44 01
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00d6f	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR c$[rsp]
  00d76	c1 e0 1e	 shl	 eax, 30
  00d79	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR c$[rsp]
  00d80	c1 e9 02	 shr	 ecx, 2
  00d83	0b c1		 or	 eax, ecx
  00d85	89 84 24 50 01
	00 00		 mov	 DWORD PTR c$[rsp], eax

; 168  :     }

  00d8c	e9 45 fd ff ff	 jmp	 $LN2@sha1_compr
$LN1@sha1_compr:

; 169  : 
; 170  :     #undef FF_0
; 171  :     #undef FF_1
; 172  :     #undef FF_2
; 173  :     #undef FF_3
; 174  : 
; 175  :     /* store */
; 176  :     sha1->state[0] = sha1->state[0] + a;

  00d91	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sha1$[rsp]
  00d99	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00d9c	03 84 24 40 01
	00 00		 add	 eax, DWORD PTR a$[rsp]
  00da3	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR sha1$[rsp]
  00dab	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 177  :     sha1->state[1] = sha1->state[1] + b;

  00dae	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sha1$[rsp]
  00db6	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00db9	03 84 24 48 01
	00 00		 add	 eax, DWORD PTR b$[rsp]
  00dc0	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR sha1$[rsp]
  00dc8	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 178  :     sha1->state[2] = sha1->state[2] + c;

  00dcb	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sha1$[rsp]
  00dd3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00dd6	03 84 24 50 01
	00 00		 add	 eax, DWORD PTR c$[rsp]
  00ddd	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR sha1$[rsp]
  00de5	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 179  :     sha1->state[3] = sha1->state[3] + d;

  00de8	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sha1$[rsp]
  00df0	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00df3	03 84 24 4c 01
	00 00		 add	 eax, DWORD PTR d$[rsp]
  00dfa	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR sha1$[rsp]
  00e02	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 180  :     sha1->state[4] = sha1->state[4] + e;

  00e05	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR sha1$[rsp]
  00e0d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00e10	03 84 24 54 01
	00 00		 add	 eax, DWORD PTR e$[rsp]
  00e17	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR sha1$[rsp]
  00e1f	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 181  : }

  00e22	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  00e29	c3		 ret	 0
sha1_compress ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EO@BJKIFCAJ@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAr?$AAe?$AAt?$AAv@ ; `string'
PUBLIC	??_C@_1EO@LALHLELK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ ; `string'
PUBLIC	??_C@_1DG@MMKMIIBJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@FHOAPDMD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	$T21010
EXTRN	_PyUnicode_CheckConsistency:PROC
EXTRN	Py_hexdigits:QWORD
EXTRN	PyUnicode_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$SHA1_hexdigest DD imagerel SHA1_hexdigest
	DD	imagerel SHA1_hexdigest+724
	DD	imagerel $unwind$SHA1_hexdigest
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_hexdigest DD 041301H
	DD	0270113H
	DD	0600b700cH
xdata	ENDS
;	COMDAT ??_C@_1EO@BJKIFCAJ@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAr?$AAe?$AAt?$AAv@
CONST	SEGMENT
??_C@_1EO@BJKIFCAJ@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAr?$AAe?$AAt?$AAv@ DB '_'
	DB	00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H
	DB	'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e'
	DB	00H, 'c', 00H, 'k', 00H, 'C', 00H, 'o', 00H, 'n', 00H, 's', 00H
	DB	'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'y'
	DB	00H, '(', 00H, 'r', 00H, 'e', 00H, 't', 00H, 'v', 00H, 'a', 00H
	DB	'l', 00H, ',', 00H, ' ', 00H, '1', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@LALHLELK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
CONST	SEGMENT
??_C@_1EO@LALHLELK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'r', 00H, 'e', 00H, 't', 00H, 'v', 00H, 'a', 00H, 'l', 00H, ')'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@MMKMIIBJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@MMKMIIBJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'r', 00H
	DB	'e', 00H, 't', 00H, 'v', 00H, 'a', 00H, 'l', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@FHOAPDMD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@FHOAPDMD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'r', 00H, 'e', 00H, 't', 00H, 'v', 00H
	DB	'a', 00H, 'l', 00H, ')', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT SHA1_hexdigest
_TEXT	SEGMENT
i$ = 32
retval$ = 40
temp$ = 48
digest$ = 144
hex_digest$ = 168
j$ = 176
c$20658 = 180
$T21010 = 184
tv137 = 280
tv146 = 288
self$ = 336
unused$ = 344
SHA1_hexdigest PROC					; COMDAT

; 349  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 350  :     unsigned char digest[SHA1_DIGESTSIZE];
; 351  :     struct sha1_state temp;
; 352  :     PyObject *retval;
; 353  :     Py_UCS1 *hex_digest;
; 354  :     int i, j;
; 355  : 
; 356  :     /* Get the raw (binary) digest value */
; 357  :     temp = self->hash_state;

  00013	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR $T21010[rsp]
  0001b	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR self$[rsp]
  00023	48 8b f8	 mov	 rdi, rax
  00026	48 8d 71 60	 lea	 rsi, QWORD PTR [rcx+96]
  0002a	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  0002f	f3 a4		 rep movsb
  00031	48 8d 44 24 30	 lea	 rax, QWORD PTR temp$[rsp]
  00036	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR $T21010[rsp]
  0003e	48 8b f8	 mov	 rdi, rax
  00041	48 8b f1	 mov	 rsi, rcx
  00044	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00049	f3 a4		 rep movsb

; 358  :     sha1_done(&temp, digest);

  0004b	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR digest$[rsp]
  00053	48 8d 4c 24 30	 lea	 rcx, QWORD PTR temp$[rsp]
  00058	e8 00 00 00 00	 call	 sha1_done

; 359  : 
; 360  :     /* Create a new string */
; 361  :     retval = PyUnicode_New(SHA1_DIGESTSIZE * 2, 127);

  0005d	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00062	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00067	e8 00 00 00 00	 call	 PyUnicode_New
  0006c	48 89 44 24 28	 mov	 QWORD PTR retval$[rsp], rax

; 362  :     if (!retval)

  00071	48 83 7c 24 28
	00		 cmp	 QWORD PTR retval$[rsp], 0
  00077	75 07		 jne	 SHORT $LN4@SHA1_hexdi

; 363  :             return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 4a 02 00 00	 jmp	 $LN5@SHA1_hexdi
$LN4@SHA1_hexdi:

; 364  :     hex_digest = PyUnicode_1BYTE_DATA(retval);

  00080	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  00085	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00089	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0008f	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00094	85 c0		 test	 eax, eax
  00096	75 1c		 jne	 SHORT $LN7@SHA1_hexdi
  00098	41 b8 6c 01 00
	00		 mov	 r8d, 364		; 0000016cH
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FHOAPDMD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b2	33 c0		 xor	 eax, eax
$LN7@SHA1_hexdi:
  000b4	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  000b9	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000bc	c1 e8 05	 shr	 eax, 5
  000bf	83 e0 01	 and	 eax, 1
  000c2	85 c0		 test	 eax, eax
  000c4	0f 84 ae 00 00
	00		 je	 $LN13@SHA1_hexdi
  000ca	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  000cf	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d9	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000de	85 c0		 test	 eax, eax
  000e0	75 1c		 jne	 SHORT $LN8@SHA1_hexdi
  000e2	41 b8 6c 01 00
	00		 mov	 r8d, 364		; 0000016cH
  000e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@FHOAPDMD@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000fc	33 c0		 xor	 eax, eax
$LN8@SHA1_hexdi:
  000fe	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  00103	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00106	c1 e8 07	 shr	 eax, 7
  00109	83 e0 01	 and	 eax, 1
  0010c	85 c0		 test	 eax, eax
  0010e	75 1c		 jne	 SHORT $LN9@SHA1_hexdi
  00110	41 b8 6c 01 00
	00		 mov	 r8d, 364		; 0000016cH
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@MMKMIIBJ@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$AA@
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0012a	33 c0		 xor	 eax, eax
$LN9@SHA1_hexdi:
  0012c	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  00131	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00134	c1 e8 06	 shr	 eax, 6
  00137	83 e0 01	 and	 eax, 1
  0013a	85 c0		 test	 eax, eax
  0013c	74 15		 je	 SHORT $LN10@SHA1_hexdi
  0013e	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  00143	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00149	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv137[rsp], rax
  00151	eb 13		 jmp	 SHORT $LN11@SHA1_hexdi
$LN10@SHA1_hexdi:
  00153	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  00158	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  0015e	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv137[rsp], rax
$LN11@SHA1_hexdi:
  00166	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tv137[rsp]
  0016e	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv146[rsp], rax
  00176	eb 3f		 jmp	 SHORT $LN14@SHA1_hexdi
$LN13@SHA1_hexdi:
  00178	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  0017d	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00185	75 1c		 jne	 SHORT $LN12@SHA1_hexdi
  00187	41 b8 6c 01 00
	00		 mov	 r8d, 364		; 0000016cH
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@LALHLELK@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAt?$AAv?$AAa?$AAl?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001a1	33 c0		 xor	 eax, eax
$LN12@SHA1_hexdi:
  001a3	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
  001a8	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  001af	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv146[rsp], rax
$LN14@SHA1_hexdi:
  001b7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR tv146[rsp]
  001bf	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR hex_digest$[rsp], rax

; 365  : 
; 366  :     /* Make hex version of the digest */
; 367  :     for(i=j=0; i<SHA1_DIGESTSIZE; i++) {

  001c7	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  001d2	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  001d9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001dd	eb 0a		 jmp	 SHORT $LN3@SHA1_hexdi
$LN2@SHA1_hexdi:
  001df	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001e3	ff c0		 inc	 eax
  001e5	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN3@SHA1_hexdi:
  001e9	83 7c 24 20 14	 cmp	 DWORD PTR i$[rsp], 20
  001ee	0f 8d a2 00 00
	00		 jge	 $LN1@SHA1_hexdi

; 368  :         unsigned char c;
; 369  :         c = (digest[i] >> 4) & 0xf;

  001f4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001f9	0f b6 84 04 90
	00 00 00	 movzx	 eax, BYTE PTR digest$[rsp+rax]
  00201	c1 f8 04	 sar	 eax, 4
  00204	83 e0 0f	 and	 eax, 15
  00207	88 84 24 b4 00
	00 00		 mov	 BYTE PTR c$20658[rsp], al

; 370  :         hex_digest[j++] = Py_hexdigits[c];

  0020e	0f b6 84 24 b4
	00 00 00	 movzx	 eax, BYTE PTR c$20658[rsp]
  00216	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR j$[rsp]
  0021e	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR hex_digest$[rsp]
  00226	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR Py_hexdigits
  0022d	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  00231	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00234	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  0023b	ff c0		 inc	 eax
  0023d	89 84 24 b0 00
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 371  :         c = (digest[i] & 0xf);

  00244	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00249	0f b6 84 04 90
	00 00 00	 movzx	 eax, BYTE PTR digest$[rsp+rax]
  00251	83 e0 0f	 and	 eax, 15
  00254	88 84 24 b4 00
	00 00		 mov	 BYTE PTR c$20658[rsp], al

; 372  :         hex_digest[j++] = Py_hexdigits[c];

  0025b	0f b6 84 24 b4
	00 00 00	 movzx	 eax, BYTE PTR c$20658[rsp]
  00263	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR j$[rsp]
  0026b	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR hex_digest$[rsp]
  00273	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR Py_hexdigits
  0027a	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  0027e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00281	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00288	ff c0		 inc	 eax
  0028a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 373  :     }

  00291	e9 49 ff ff ff	 jmp	 $LN2@SHA1_hexdi
$LN1@SHA1_hexdi:

; 374  : #ifdef Py_DEBUG
; 375  :     assert(_PyUnicode_CheckConsistency(retval, 1));

  00296	ba 01 00 00 00	 mov	 edx, 1
  0029b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR retval$[rsp]
  002a0	e8 00 00 00 00	 call	 _PyUnicode_CheckConsistency
  002a5	85 c0		 test	 eax, eax
  002a7	75 1c		 jne	 SHORT $LN15@SHA1_hexdi
  002a9	41 b8 77 01 00
	00		 mov	 r8d, 375		; 00000177H
  002af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@BJKIFCAJ@?$AA_?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAC?$AAo?$AAn?$AAs?$AAi?$AAs?$AAt?$AAe?$AAn?$AAc?$AAy?$AA?$CI?$AAr?$AAe?$AAt?$AAv@
  002bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002c3	33 c0		 xor	 eax, eax
$LN15@SHA1_hexdi:

; 376  : #endif
; 377  :     return retval;

  002c5	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]
$LN5@SHA1_hexdi:

; 378  : }

  002ca	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  002d1	5f		 pop	 rdi
  002d2	5e		 pop	 rsi
  002d3	c3		 ret	 0
SHA1_hexdigest ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@ ; `string'
PUBLIC	??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@ ; `string'
PUBLIC	??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@ ; `string'
PUBLIC	??_C@_08BNPIIEPK@O?3update?$AA@			; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyBuffer_Release:PROC
EXTRN	PyExc_BufferError:QWORD
EXTRN	PyObject_GetBuffer:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$SHA1_update DD imagerel SHA1_update
	DD	imagerel SHA1_update+314
	DD	imagerel $unwind$SHA1_update
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_update DD 021101H
	DD	0110111H
xdata	ENDS
;	COMDAT ??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@
CONST	SEGMENT
??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@ DB 'Buffer mus'
	DB	't be single dimension', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@
CONST	SEGMENT
??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@ DB 'object suppo'
	DB	'rting the buffer API required', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@
CONST	SEGMENT
??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@ DB 'Unicode-obj'
	DB	'ects must be encoded before hashing', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BNPIIEPK@O?3update?$AA@
CONST	SEGMENT
??_C@_08BNPIIEPK@O?3update?$AA@ DB 'O:update', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT SHA1_update
_TEXT	SEGMENT
buf$ = 32
obj$ = 112
self$ = 144
args$ = 152
SHA1_update PROC					; COMDAT

; 385  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 386  :     PyObject *obj;
; 387  :     Py_buffer buf;
; 388  : 
; 389  :     if (!PyArg_ParseTuple(args, "O:update", &obj))

  00011	4c 8d 44 24 70	 lea	 r8, QWORD PTR obj$[rsp]
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08BNPIIEPK@O?3update?$AA@
  0001d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00025	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0002a	85 c0		 test	 eax, eax
  0002c	75 07		 jne	 SHORT $LN9@SHA1_updat

; 390  :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 fd 00 00 00	 jmp	 $LN10@SHA1_updat
$LN9@SHA1_updat:
$LN8@SHA1_updat:

; 391  : 
; 392  :     GET_BUFFER_VIEW_OR_ERROUT(obj, &buf);

  00035	48 8b 44 24 70	 mov	 rax, QWORD PTR obj$[rsp]
  0003a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00044	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00049	85 c0		 test	 eax, eax
  0004b	74 1a		 je	 SHORT $LN5@SHA1_updat
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@
  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0005b	e8 00 00 00 00	 call	 PyErr_SetString
  00060	33 c0		 xor	 eax, eax
  00062	e9 cb 00 00 00	 jmp	 $LN10@SHA1_updat
$LN5@SHA1_updat:
  00067	48 8b 44 24 70	 mov	 rax, QWORD PTR obj$[rsp]
  0006c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00070	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  00078	74 16		 je	 SHORT $LN3@SHA1_updat
  0007a	48 8b 44 24 70	 mov	 rax, QWORD PTR obj$[rsp]
  0007f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00083	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  0008a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008e	75 1a		 jne	 SHORT $LN4@SHA1_updat
$LN3@SHA1_updat:
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@
  00097	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009e	e8 00 00 00 00	 call	 PyErr_SetString
  000a3	33 c0		 xor	 eax, eax
  000a5	e9 88 00 00 00	 jmp	 $LN10@SHA1_updat
$LN4@SHA1_updat:
  000aa	45 33 c0	 xor	 r8d, r8d
  000ad	48 8d 54 24 20	 lea	 rdx, QWORD PTR buf$[rsp]
  000b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR obj$[rsp]
  000b7	e8 00 00 00 00	 call	 PyObject_GetBuffer
  000bc	83 f8 ff	 cmp	 eax, -1
  000bf	75 04		 jne	 SHORT $LN2@SHA1_updat
  000c1	33 c0		 xor	 eax, eax
  000c3	eb 6d		 jmp	 SHORT $LN10@SHA1_updat
$LN2@SHA1_updat:
  000c5	83 7c 24 44 01	 cmp	 DWORD PTR buf$[rsp+36], 1
  000ca	7e 21		 jle	 SHORT $LN1@SHA1_updat
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@
  000d3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  000da	e8 00 00 00 00	 call	 PyErr_SetString
  000df	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  000e4	e8 00 00 00 00	 call	 PyBuffer_Release
  000e9	33 c0		 xor	 eax, eax
  000eb	eb 45		 jmp	 SHORT $LN10@SHA1_updat
$LN1@SHA1_updat:
  000ed	33 c0		 xor	 eax, eax
  000ef	85 c0		 test	 eax, eax
  000f1	0f 85 3e ff ff
	ff		 jne	 $LN8@SHA1_updat

; 393  : 
; 394  :     sha1_process(&self->hash_state, buf.buf, buf.len);

  000f7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR self$[rsp]
  000ff	48 83 c0 60	 add	 rax, 96			; 00000060H
  00103	4c 8b 44 24 30	 mov	 r8, QWORD PTR buf$[rsp+16]
  00108	48 8b 54 24 20	 mov	 rdx, QWORD PTR buf$[rsp]
  0010d	48 8b c8	 mov	 rcx, rax
  00110	e8 00 00 00 00	 call	 sha1_process

; 395  : 
; 396  :     PyBuffer_Release(&buf);

  00115	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0011a	e8 00 00 00 00	 call	 PyBuffer_Release

; 397  :     Py_INCREF(Py_None);

  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00126	e8 00 00 00 00	 call	 _Py_IncRef

; 398  :     return Py_None;

  0012b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN10@SHA1_updat:

; 399  : }

  00132	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00139	c3		 ret	 0
SHA1_update ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EE@CGIBOGPJ@?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAb?$AAu?$AAf@ ; `string'
PUBLIC	??_C@_1BG@FJHBFMEJ@?$AAi?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	memcpy:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\sha1module.c
pdata	SEGMENT
$pdata$sha1_process DD imagerel sha1_process
	DD	imagerel sha1_process+478
	DD	imagerel $unwind$sha1_process
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sha1_process DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_1EE@CGIBOGPJ@?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAb?$AAu?$AAf@
CONST	SEGMENT
??_C@_1EE@CGIBOGPJ@?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAb?$AAu?$AAf@ DB 's'
	DB	00H, 'h', 00H, 'a', 00H, '1', 00H, '-', 00H, '>', 00H, 'c', 00H
	DB	'u', 00H, 'r', 00H, 'l', 00H, 'e', 00H, 'n', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	'o', 00H, 'f', 00H, '(', 00H, 's', 00H, 'h', 00H, 'a', 00H, '1'
	DB	00H, '-', 00H, '>', 00H, 'b', 00H, 'u', 00H, 'f', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@FJHBFMEJ@?$AAi?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@FJHBFMEJ@?$AAi?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT sha1_process
_TEXT	SEGMENT
n$ = 32
tv129 = 40
sha1$ = 64
in$ = 72
inlen$ = 80
sha1_process PROC					; COMDAT

; 209  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 210  :     Py_ssize_t n;
; 211  : 
; 212  :     assert(sha1 != NULL);

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR sha1$[rsp], 0
  00019	75 1c		 jne	 SHORT $LN8@sha1_proce
  0001b	41 b8 d4 00 00
	00		 mov	 r8d, 212		; 000000d4H
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@FHFLFHOK@?$AAs?$AAh?$AAa?$AA1?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00035	33 c0		 xor	 eax, eax
$LN8@sha1_proce:

; 213  :     assert(in != NULL);

  00037	48 83 7c 24 48
	00		 cmp	 QWORD PTR in$[rsp], 0
  0003d	75 1c		 jne	 SHORT $LN9@sha1_proce
  0003f	41 b8 d5 00 00
	00		 mov	 r8d, 213		; 000000d5H
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@FJHBFMEJ@?$AAi?$AAn?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00059	33 c0		 xor	 eax, eax
$LN9@sha1_proce:

; 214  :     assert(sha1->curlen <= sizeof(sha1->buf));

  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00060	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00063	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00067	76 1c		 jbe	 SHORT $LN10@sha1_proce
  00069	41 b8 d6 00 00
	00		 mov	 r8d, 214		; 000000d6H
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@CGIBOGPJ@?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAl?$AAe?$AAn?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAs?$AAh?$AAa?$AA1?$AA?9?$AA?$DO?$AAb?$AAu?$AAf@
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00083	33 c0		 xor	 eax, eax
$LN10@sha1_proce:
$LN5@sha1_proce:

; 215  : 
; 216  :     while (inlen > 0) {

  00085	48 83 7c 24 50
	00		 cmp	 QWORD PTR inlen$[rsp], 0
  0008b	0f 8e 48 01 00
	00		 jle	 $LN4@sha1_proce

; 217  :         if (sha1->curlen == 0 && inlen >= SHA1_BLOCKSIZE) {

  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00096	83 78 1c 00	 cmp	 DWORD PTR [rax+28], 0
  0009a	75 4e		 jne	 SHORT $LN3@sha1_proce
  0009c	48 83 7c 24 50
	40		 cmp	 QWORD PTR inlen$[rsp], 64 ; 00000040H
  000a2	7c 46		 jl	 SHORT $LN3@sha1_proce

; 218  :            sha1_compress(sha1, (unsigned char *)in);

  000a4	48 8b 54 24 48	 mov	 rdx, QWORD PTR in$[rsp]
  000a9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  000ae	e8 00 00 00 00	 call	 sha1_compress

; 219  :            sha1->length   += SHA1_BLOCKSIZE * 8;

  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  000b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bb	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  000c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  000c6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 220  :            in             += SHA1_BLOCKSIZE;

  000c9	48 8b 44 24 48	 mov	 rax, QWORD PTR in$[rsp]
  000ce	48 83 c0 40	 add	 rax, 64			; 00000040H
  000d2	48 89 44 24 48	 mov	 QWORD PTR in$[rsp], rax

; 221  :            inlen          -= SHA1_BLOCKSIZE;

  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR inlen$[rsp]
  000dc	48 83 e8 40	 sub	 rax, 64			; 00000040H
  000e0	48 89 44 24 50	 mov	 QWORD PTR inlen$[rsp], rax

; 222  :         } else {

  000e5	e9 ea 00 00 00	 jmp	 $LN2@sha1_proce
$LN3@sha1_proce:

; 223  :            n = MIN(inlen, (Py_ssize_t)(SHA1_BLOCKSIZE - sha1->curlen));

  000ea	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  000ef	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f4	2b 48 1c	 sub	 ecx, DWORD PTR [rax+28]
  000f7	8b c1		 mov	 eax, ecx
  000f9	8b c0		 mov	 eax, eax
  000fb	48 39 44 24 50	 cmp	 QWORD PTR inlen$[rsp], rax
  00100	7d 0c		 jge	 SHORT $LN11@sha1_proce
  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR inlen$[rsp]
  00107	48 89 44 24 28	 mov	 QWORD PTR tv129[rsp], rax
  0010c	eb 16		 jmp	 SHORT $LN12@sha1_proce
$LN11@sha1_proce:
  0010e	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00113	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00118	2b 48 1c	 sub	 ecx, DWORD PTR [rax+28]
  0011b	8b c1		 mov	 eax, ecx
  0011d	8b c0		 mov	 eax, eax
  0011f	48 89 44 24 28	 mov	 QWORD PTR tv129[rsp], rax
$LN12@sha1_proce:
  00124	48 8b 44 24 28	 mov	 rax, QWORD PTR tv129[rsp]
  00129	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 224  :            memcpy(sha1->buf + sha1->curlen, in, (size_t)n);

  0012e	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00133	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  0013b	48 8d 44 01 20	 lea	 rax, QWORD PTR [rcx+rax+32]
  00140	4c 8b 44 24 20	 mov	 r8, QWORD PTR n$[rsp]
  00145	48 8b 54 24 48	 mov	 rdx, QWORD PTR in$[rsp]
  0014a	48 8b c8	 mov	 rcx, rax
  0014d	e8 00 00 00 00	 call	 memcpy

; 225  :            sha1->curlen   += n;

  00152	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00157	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0015a	48 03 44 24 20	 add	 rax, QWORD PTR n$[rsp]
  0015f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  00164	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 226  :            in             += n;

  00167	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  0016c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR in$[rsp]
  00171	48 03 c8	 add	 rcx, rax
  00174	48 8b c1	 mov	 rax, rcx
  00177	48 89 44 24 48	 mov	 QWORD PTR in$[rsp], rax

; 227  :            inlen          -= n;

  0017c	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  00181	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inlen$[rsp]
  00186	48 2b c8	 sub	 rcx, rax
  00189	48 8b c1	 mov	 rax, rcx
  0018c	48 89 44 24 50	 mov	 QWORD PTR inlen$[rsp], rax

; 228  :            if (sha1->curlen == SHA1_BLOCKSIZE) {

  00191	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  00196	83 78 1c 40	 cmp	 DWORD PTR [rax+28], 64	; 00000040H
  0019a	75 38		 jne	 SHORT $LN1@sha1_proce

; 229  :               sha1_compress(sha1, sha1->buf);

  0019c	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  001a1	48 83 c0 20	 add	 rax, 32			; 00000020H
  001a5	48 8b d0	 mov	 rdx, rax
  001a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  001ad	e8 00 00 00 00	 call	 sha1_compress

; 230  :               sha1->length += 8*SHA1_BLOCKSIZE;

  001b2	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  001b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ba	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  001c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sha1$[rsp]
  001c5	48 89 01	 mov	 QWORD PTR [rcx], rax

; 231  :               sha1->curlen = 0;

  001c8	48 8b 44 24 40	 mov	 rax, QWORD PTR sha1$[rsp]
  001cd	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
$LN1@sha1_proce:
$LN2@sha1_proce:

; 232  :            }
; 233  :        }
; 234  :     }

  001d4	e9 ac fe ff ff	 jmp	 $LN5@sha1_proce
$LN4@sha1_proce:

; 235  : }

  001d9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001dd	c3		 ret	 0
sha1_process ENDP
_TEXT	ENDS
EXTRN	PyLong_FromLong:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$SHA1_get_block_size DD imagerel SHA1_get_block_size
	DD	imagerel SHA1_get_block_size+29
	DD	imagerel $unwind$SHA1_get_block_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_get_block_size DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT SHA1_get_block_size
_TEXT	SEGMENT
self$ = 48
closure$ = 56
SHA1_get_block_size PROC				; COMDAT

; 411  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 412  :     return PyLong_FromLong(SHA1_BLOCKSIZE);

  0000e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00013	e8 00 00 00 00	 call	 PyLong_FromLong

; 413  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
SHA1_get_block_size ENDP
_TEXT	ENDS
PUBLIC	??_C@_04KPMLCNGO@SHA1?$AA@			; `string'
EXTRN	PyUnicode_FromStringAndSize:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$SHA1_get_name DD imagerel SHA1_get_name
	DD	imagerel SHA1_get_name+36
	DD	imagerel $unwind$SHA1_get_name
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_get_name DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_04KPMLCNGO@SHA1?$AA@
CONST	SEGMENT
??_C@_04KPMLCNGO@SHA1?$AA@ DB 'SHA1', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT SHA1_get_name
_TEXT	SEGMENT
self$ = 48
closure$ = 56
SHA1_get_name PROC					; COMDAT

; 417  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 418  :     return PyUnicode_FromStringAndSize("SHA1", 4);

  0000e	ba 04 00 00 00	 mov	 edx, 4
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04KPMLCNGO@SHA1?$AA@
  0001a	e8 00 00 00 00	 call	 PyUnicode_FromStringAndSize

; 419  : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
SHA1_get_name ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sha1_get_digest_size DD imagerel sha1_get_digest_size
	DD	imagerel sha1_get_digest_size+29
	DD	imagerel $unwind$sha1_get_digest_size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sha1_get_digest_size DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT sha1_get_digest_size
_TEXT	SEGMENT
self$ = 48
closure$ = 56
sha1_get_digest_size PROC				; COMDAT

; 423  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 424  :     return PyLong_FromLong(SHA1_DIGESTSIZE);

  0000e	b9 14 00 00 00	 mov	 ecx, 20
  00013	e8 00 00 00 00	 call	 PyLong_FromLong

; 425  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
sha1_get_digest_size ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_06KJFPOEIK@?$HMO?3new?$AA@		; `string'
EXTRN	PyErr_Occurred:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$SHA1_new DD imagerel SHA1_new
	DD	imagerel SHA1_new+474
	DD	imagerel $unwind$SHA1_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SHA1_new DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT ??_C@_06KJFPOEIK@?$HMO?3new?$AA@
CONST	SEGMENT
??_C@_06KJFPOEIK@?$HMO?3new?$AA@ DB '|O:new', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT SHA1_new
_TEXT	SEGMENT
data_obj$ = 48
buf$ = 64
new$ = 144
self$ = 176
args$ = 184
kwdict$ = 192
SHA1_new PROC						; COMDAT

; 486  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 487  :     static char *kwlist[] = {"string", NULL};
; 488  :     SHA1object *new;
; 489  :     PyObject *data_obj = NULL;

  00016	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR data_obj$[rsp], 0

; 490  :     Py_buffer buf;
; 491  : 
; 492  :     if (!PyArg_ParseTupleAndKeywords(args, kwdict, "|O:new", kwlist,
; 493  :                                      &data_obj)) {

  0001f	48 8d 44 24 30	 lea	 rax, QWORD PTR data_obj$[rsp]
  00024	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00029	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??SHA1_new@@9@9
  00030	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06KJFPOEIK@?$HMO?3new?$AA@
  00037	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR kwdict$[rsp]
  0003f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00047	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0004c	85 c0		 test	 eax, eax
  0004e	75 07		 jne	 SHORT $LN15@SHA1_new

; 494  :         return NULL;

  00050	33 c0		 xor	 eax, eax
  00052	e9 7b 01 00 00	 jmp	 $LN16@SHA1_new
$LN15@SHA1_new:

; 495  :     }
; 496  : 
; 497  :     if (data_obj)

  00057	48 83 7c 24 30
	00		 cmp	 QWORD PTR data_obj$[rsp], 0
  0005d	0f 84 c8 00 00
	00		 je	 $LN14@SHA1_new
$LN13@SHA1_new:

; 498  :         GET_BUFFER_VIEW_OR_ERROUT(data_obj, &buf);

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR data_obj$[rsp]
  00068	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00072	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00077	85 c0		 test	 eax, eax
  00079	74 1a		 je	 SHORT $LN10@SHA1_new
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@IBHDLOCD@Unicode?9objects?5must?5be?5encoded?5@
  00082	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00089	e8 00 00 00 00	 call	 PyErr_SetString
  0008e	33 c0		 xor	 eax, eax
  00090	e9 3d 01 00 00	 jmp	 $LN16@SHA1_new
$LN10@SHA1_new:
  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR data_obj$[rsp]
  0009a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009e	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  000a6	74 16		 je	 SHORT $LN8@SHA1_new
  000a8	48 8b 44 24 30	 mov	 rax, QWORD PTR data_obj$[rsp]
  000ad	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000b1	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  000b8	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000bc	75 1a		 jne	 SHORT $LN9@SHA1_new
$LN8@SHA1_new:
  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@NHOOCGGK@object?5supporting?5the?5buffer?5API@
  000c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000cc	e8 00 00 00 00	 call	 PyErr_SetString
  000d1	33 c0		 xor	 eax, eax
  000d3	e9 fa 00 00 00	 jmp	 $LN16@SHA1_new
$LN9@SHA1_new:
  000d8	45 33 c0	 xor	 r8d, r8d
  000db	48 8d 54 24 40	 lea	 rdx, QWORD PTR buf$[rsp]
  000e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data_obj$[rsp]
  000e5	e8 00 00 00 00	 call	 PyObject_GetBuffer
  000ea	83 f8 ff	 cmp	 eax, -1
  000ed	75 07		 jne	 SHORT $LN7@SHA1_new
  000ef	33 c0		 xor	 eax, eax
  000f1	e9 dc 00 00 00	 jmp	 $LN16@SHA1_new
$LN7@SHA1_new:
  000f6	83 7c 24 64 01	 cmp	 DWORD PTR buf$[rsp+36], 1
  000fb	7e 24		 jle	 SHORT $LN6@SHA1_new
  000fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@DGKHNIN@Buffer?5must?5be?5single?5dimension?$AA@
  00104	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  0010b	e8 00 00 00 00	 call	 PyErr_SetString
  00110	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  00115	e8 00 00 00 00	 call	 PyBuffer_Release
  0011a	33 c0		 xor	 eax, eax
  0011c	e9 b1 00 00 00	 jmp	 $LN16@SHA1_new
$LN6@SHA1_new:
  00121	33 c0		 xor	 eax, eax
  00123	85 c0		 test	 eax, eax
  00125	0f 85 38 ff ff
	ff		 jne	 $LN13@SHA1_new
$LN14@SHA1_new:

; 499  : 
; 500  :     if ((new = newSHA1object()) == NULL) {

  0012b	e8 00 00 00 00	 call	 newSHA1object
  00130	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR new$[rsp], rax
  00138	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR new$[rsp], 0
  00141	75 16		 jne	 SHORT $LN5@SHA1_new

; 501  :         if (data_obj)

  00143	48 83 7c 24 30
	00		 cmp	 QWORD PTR data_obj$[rsp], 0
  00149	74 0a		 je	 SHORT $LN4@SHA1_new

; 502  :             PyBuffer_Release(&buf);

  0014b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  00150	e8 00 00 00 00	 call	 PyBuffer_Release
$LN4@SHA1_new:

; 503  :         return NULL;

  00155	33 c0		 xor	 eax, eax
  00157	eb 79		 jmp	 SHORT $LN16@SHA1_new
$LN5@SHA1_new:

; 504  :     }
; 505  : 
; 506  :     sha1_init(&new->hash_state);

  00159	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR new$[rsp]
  00161	48 83 c0 60	 add	 rax, 96			; 00000060H
  00165	48 8b c8	 mov	 rcx, rax
  00168	e8 00 00 00 00	 call	 sha1_init

; 507  : 
; 508  :     if (PyErr_Occurred()) {

  0016d	e8 00 00 00 00	 call	 PyErr_Occurred
  00172	48 85 c0	 test	 rax, rax
  00175	74 23		 je	 SHORT $LN3@SHA1_new

; 509  :         Py_DECREF(new);

  00177	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR new$[rsp]
  0017f	e8 00 00 00 00	 call	 _Py_DecRef

; 510  :         if (data_obj)

  00184	48 83 7c 24 30
	00		 cmp	 QWORD PTR data_obj$[rsp], 0
  0018a	74 0a		 je	 SHORT $LN2@SHA1_new

; 511  :             PyBuffer_Release(&buf);

  0018c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  00191	e8 00 00 00 00	 call	 PyBuffer_Release
$LN2@SHA1_new:

; 512  :         return NULL;

  00196	33 c0		 xor	 eax, eax
  00198	eb 38		 jmp	 SHORT $LN16@SHA1_new
$LN3@SHA1_new:

; 513  :     }
; 514  :     if (data_obj) {

  0019a	48 83 7c 24 30
	00		 cmp	 QWORD PTR data_obj$[rsp], 0
  001a0	74 28		 je	 SHORT $LN1@SHA1_new

; 515  :         sha1_process(&new->hash_state, buf.buf, buf.len);

  001a2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR new$[rsp]
  001aa	48 83 c0 60	 add	 rax, 96			; 00000060H
  001ae	4c 8b 44 24 50	 mov	 r8, QWORD PTR buf$[rsp+16]
  001b3	48 8b 54 24 40	 mov	 rdx, QWORD PTR buf$[rsp]
  001b8	48 8b c8	 mov	 rcx, rax
  001bb	e8 00 00 00 00	 call	 sha1_process

; 516  :         PyBuffer_Release(&buf);

  001c0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  001c5	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@SHA1_new:

; 517  :     }
; 518  : 
; 519  :     return (PyObject *)new;

  001ca	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR new$[rsp]
$LN16@SHA1_new:

; 520  : }

  001d2	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001d9	c3		 ret	 0
SHA1_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\sha1module.c
pdata	SEGMENT
$pdata$sha1_init DD imagerel sha1_init
	DD	imagerel sha1_init+134
	DD	imagerel $unwind$sha1_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sha1_init DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT sha1_init
_TEXT	SEGMENT
sha1$ = 48
sha1_init PROC						; COMDAT

; 189  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 190  :    assert(sha1 != NULL);

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR sha1$[rsp], 0
  0000f	75 1c		 jne	 SHORT $LN3@sha1_init
  00011	41 b8 be 00 00
	00		 mov	 r8d, 190		; 000000beH
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DA@FNBGEOHH@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAs?$AAh?$AAa?$AA1?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@FHFLFHOK@?$AAs?$AAh?$AAa?$AA1?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002b	33 c0		 xor	 eax, eax
$LN3@sha1_init:

; 191  :    sha1->state[0] = 0x67452301UL;

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR sha1$[rsp]
  00032	c7 40 08 01 23
	45 67		 mov	 DWORD PTR [rax+8], 1732584193 ; 67452301H

; 192  :    sha1->state[1] = 0xefcdab89UL;

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR sha1$[rsp]
  0003e	c7 40 0c 89 ab
	cd ef		 mov	 DWORD PTR [rax+12], -271733879 ; efcdab89H

; 193  :    sha1->state[2] = 0x98badcfeUL;

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR sha1$[rsp]
  0004a	c7 40 10 fe dc
	ba 98		 mov	 DWORD PTR [rax+16], -1732584194 ; 98badcfeH

; 194  :    sha1->state[3] = 0x10325476UL;

  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR sha1$[rsp]
  00056	c7 40 14 76 54
	32 10		 mov	 DWORD PTR [rax+20], 271733878 ; 10325476H

; 195  :    sha1->state[4] = 0xc3d2e1f0UL;

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR sha1$[rsp]
  00062	c7 40 18 f0 e1
	d2 c3		 mov	 DWORD PTR [rax+24], -1009589776 ; c3d2e1f0H

; 196  :    sha1->curlen = 0;

  00069	48 8b 44 24 30	 mov	 rax, QWORD PTR sha1$[rsp]
  0006e	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 197  :    sha1->length = 0;

  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR sha1$[rsp]
  0007a	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 198  : }

  00081	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00085	c3		 ret	 0
sha1_init ENDP
_TEXT	ENDS
PUBLIC	PyInit__sha1
EXTRN	PyModule_Create2TraceRefs:PROC
EXTRN	PyType_Ready:PROC
EXTRN	PyType_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit__sha1 DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$PyInit__sha1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__sha1 DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyInit__sha1
_TEXT	SEGMENT
PyInit__sha1 PROC					; COMDAT

; 550  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 551  :     Py_TYPE(&SHA1type) = &PyType_Type;

  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type
  0000b	48 89 05 58 00
	00 00		 mov	 QWORD PTR SHA1type+88, rax

; 552  :     if (PyType_Ready(&SHA1type) < 0)

  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:SHA1type
  00019	e8 00 00 00 00	 call	 PyType_Ready
  0001e	85 c0		 test	 eax, eax
  00020	7d 04		 jge	 SHORT $LN1@PyInit__sh

; 553  :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	eb 11		 jmp	 SHORT $LN2@PyInit__sh
$LN1@PyInit__sh:

; 554  :     return PyModule_Create(&_sha1module);

  00026	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_sha1module
  00032	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
$LN2@PyInit__sh:

; 555  : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
PyInit__sha1 ENDP
_TEXT	ENDS
END
