; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04LFOLHMFG@_sre?$AA@			; `string'
PUBLIC	??_C@_08GAHBPIPM@getlower?$AA@			; `string'
PUBLIC	??_C@_0M@PEJEAKBE@getcodesize?$AA@		; `string'
PUBLIC	??_C@_07OLJGFCKG@compile?$AA@			; `string'
PUBLIC	??_C@_0BB@BBOJIAJC@_sre?4SRE_Scanner?$AA@	; `string'
PUBLIC	??_C@_0P@HEJLNOBB@_sre?4SRE_Match?$AA@		; `string'
PUBLIC	??_C@_02EPEBAFDB@re?$AA@			; `string'
PUBLIC	??_C@_04PPLNELOM@regs?$AA@			; `string'
PUBLIC	??_C@_09COONDMIO@lastgroup?$AA@			; `string'
PUBLIC	??_C@_09LCAJIJAE@lastindex?$AA@			; `string'
PUBLIC	??_C@_06GFPMPEEP@expand?$AA@			; `string'
PUBLIC	??_C@_09GGPMIDAG@groupdict?$AA@			; `string'
PUBLIC	??_C@_04FOPLNFFP@span?$AA@			; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_05FAGFPHJG@start?$AA@			; `string'
PUBLIC	??_C@_05MGJOOGAJ@group?$AA@			; `string'
PUBLIC	??_C@_07DLHCIBDH@default?$AA@			; `string'
PUBLIC	??_C@_0BB@FJKNOFPK@_sre?4SRE_Pattern?$AA@	; `string'
PUBLIC	??_C@_0L@IAGOJEHI@groupindex?$AA@		; `string'
PUBLIC	??_C@_06HNAIAMHH@groups?$AA@			; `string'
PUBLIC	??_C@_05GECEPKB@flags?$AA@			; `string'
PUBLIC	??_C@_0N@LCDCNIJ@__deepcopy__?$AA@		; `string'
PUBLIC	??_C@_08MOMBEIKE@__copy__?$AA@			; `string'
PUBLIC	??_C@_07GPBKGHMB@scanner?$AA@			; `string'
PUBLIC	??_C@_08JCKNOCFD@finditer?$AA@			; `string'
PUBLIC	??_C@_07MHCELJLC@findall?$AA@			; `string'
PUBLIC	??_C@_05EHPMMFBK@split?$AA@			; `string'
PUBLIC	??_C@_04GLGDJLDE@subn?$AA@			; `string'
PUBLIC	??_C@_03KCMAIMAP@sub?$AA@			; `string'
PUBLIC	??_C@_06GFPLNGOC@search?$AA@			; `string'
PUBLIC	??_C@_05FNONLPDI@match?$AA@			; `string'
PUBLIC	??_C@_05IOMEMJEC@count?$AA@			; `string'
PUBLIC	??_C@_06ICGJLFIM@string?$AA@			; `string'
PUBLIC	??_C@_04CLIOPAIH@repl?$AA@			; `string'
PUBLIC	??_C@_08HONNCIIN@maxsplit?$AA@			; `string'
PUBLIC	??_C@_06OEKOLKIL@source?$AA@			; `string'
PUBLIC	??_C@_06MJPHPKNA@endpos?$AA@			; `string'
PUBLIC	??_C@_03PCBNCGFH@pos?$AA@			; `string'
PUBLIC	??_C@_07CHFOACKJ@pattern?$AA@			; `string'
;	COMDAT ??_C@_04LFOLHMFG@_sre?$AA@
CONST	SEGMENT
??_C@_04LFOLHMFG@_sre?$AA@ DB '_sre', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GAHBPIPM@getlower?$AA@
CONST	SEGMENT
??_C@_08GAHBPIPM@getlower?$AA@ DB 'getlower', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PEJEAKBE@getcodesize?$AA@
CONST	SEGMENT
??_C@_0M@PEJEAKBE@getcodesize?$AA@ DB 'getcodesize', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OLJGFCKG@compile?$AA@
CONST	SEGMENT
??_C@_07OLJGFCKG@compile?$AA@ DB 'compile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BBOJIAJC@_sre?4SRE_Scanner?$AA@
CONST	SEGMENT
??_C@_0BB@BBOJIAJC@_sre?4SRE_Scanner?$AA@ DB '_sre.SRE_Scanner', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HEJLNOBB@_sre?4SRE_Match?$AA@
CONST	SEGMENT
??_C@_0P@HEJLNOBB@_sre?4SRE_Match?$AA@ DB '_sre.SRE_Match', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02EPEBAFDB@re?$AA@
CONST	SEGMENT
??_C@_02EPEBAFDB@re?$AA@ DB 're', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PPLNELOM@regs?$AA@
CONST	SEGMENT
??_C@_04PPLNELOM@regs?$AA@ DB 'regs', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09COONDMIO@lastgroup?$AA@
CONST	SEGMENT
??_C@_09COONDMIO@lastgroup?$AA@ DB 'lastgroup', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LCAJIJAE@lastindex?$AA@
CONST	SEGMENT
??_C@_09LCAJIJAE@lastindex?$AA@ DB 'lastindex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GFPMPEEP@expand?$AA@
CONST	SEGMENT
??_C@_06GFPMPEEP@expand?$AA@ DB 'expand', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GGPMIDAG@groupdict?$AA@
CONST	SEGMENT
??_C@_09GGPMIDAG@groupdict?$AA@ DB 'groupdict', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04FOPLNFFP@span?$AA@
CONST	SEGMENT
??_C@_04FOPLNFFP@span?$AA@ DB 'span', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FAGFPHJG@start?$AA@
CONST	SEGMENT
??_C@_05FAGFPHJG@start?$AA@ DB 'start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MGJOOGAJ@group?$AA@
CONST	SEGMENT
??_C@_05MGJOOGAJ@group?$AA@ DB 'group', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DLHCIBDH@default?$AA@
CONST	SEGMENT
??_C@_07DLHCIBDH@default?$AA@ DB 'default', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FJKNOFPK@_sre?4SRE_Pattern?$AA@
CONST	SEGMENT
??_C@_0BB@FJKNOFPK@_sre?4SRE_Pattern?$AA@ DB '_sre.SRE_Pattern', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IAGOJEHI@groupindex?$AA@
CONST	SEGMENT
??_C@_0L@IAGOJEHI@groupindex?$AA@ DB 'groupindex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06HNAIAMHH@groups?$AA@
CONST	SEGMENT
??_C@_06HNAIAMHH@groups?$AA@ DB 'groups', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GECEPKB@flags?$AA@
CONST	SEGMENT
??_C@_05GECEPKB@flags?$AA@ DB 'flags', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LCDCNIJ@__deepcopy__?$AA@
CONST	SEGMENT
??_C@_0N@LCDCNIJ@__deepcopy__?$AA@ DB '__deepcopy__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MOMBEIKE@__copy__?$AA@
CONST	SEGMENT
??_C@_08MOMBEIKE@__copy__?$AA@ DB '__copy__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GPBKGHMB@scanner?$AA@
CONST	SEGMENT
??_C@_07GPBKGHMB@scanner?$AA@ DB 'scanner', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08JCKNOCFD@finditer?$AA@
CONST	SEGMENT
??_C@_08JCKNOCFD@finditer?$AA@ DB 'finditer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MHCELJLC@findall?$AA@
CONST	SEGMENT
??_C@_07MHCELJLC@findall?$AA@ DB 'findall', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05EHPMMFBK@split?$AA@
CONST	SEGMENT
??_C@_05EHPMMFBK@split?$AA@ DB 'split', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GLGDJLDE@subn?$AA@
CONST	SEGMENT
??_C@_04GLGDJLDE@subn?$AA@ DB 'subn', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KCMAIMAP@sub?$AA@
CONST	SEGMENT
??_C@_03KCMAIMAP@sub?$AA@ DB 'sub', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06GFPLNGOC@search?$AA@
CONST	SEGMENT
??_C@_06GFPLNGOC@search?$AA@ DB 'search', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FNONLPDI@match?$AA@
CONST	SEGMENT
??_C@_05FNONLPDI@match?$AA@ DB 'match', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05IOMEMJEC@count?$AA@
CONST	SEGMENT
??_C@_05IOMEMJEC@count?$AA@ DB 'count', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06ICGJLFIM@string?$AA@
CONST	SEGMENT
??_C@_06ICGJLFIM@string?$AA@ DB 'string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CLIOPAIH@repl?$AA@
CONST	SEGMENT
??_C@_04CLIOPAIH@repl?$AA@ DB 'repl', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08HONNCIIN@maxsplit?$AA@
CONST	SEGMENT
??_C@_08HONNCIIN@maxsplit?$AA@ DB 'maxsplit', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06OEKOLKIL@source?$AA@
CONST	SEGMENT
??_C@_06OEKOLKIL@source?$AA@ DB 'source', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MJPHPKNA@endpos?$AA@
CONST	SEGMENT
??_C@_06MJPHPKNA@endpos?$AA@ DB 'endpos', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PCBNCGFH@pos?$AA@
CONST	SEGMENT
??_C@_03PCBNCGFH@pos?$AA@ DB 'pos', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07CHFOACKJ@pattern?$AA@
CONST	SEGMENT
??_C@_07CHFOACKJ@pattern?$AA@ DB 'pattern', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
copyright DB	' SRE 2.2.2 Copyright (c) 1997-2002 by Secret Labs AB ', 00H
	ORG $+10
sre_char_info DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	06H
	DB	02H
	DB	02H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	010H
	DB	00H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
sre_char_lower DB 00H
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	011H
	DB	012H
	DB	013H
	DB	014H
	DB	015H
	DB	016H
	DB	017H
	DB	018H
	DB	019H
	DB	01aH
	DB	01bH
	DB	01cH
	DB	01dH
	DB	01eH
	DB	01fH
	DB	020H
	DB	021H
	DB	022H
	DB	023H
	DB	024H
	DB	025H
	DB	026H
	DB	027H
	DB	028H
	DB	029H
	DB	02aH
	DB	02bH
	DB	02cH
	DB	02dH
	DB	02eH
	DB	02fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	03aH
	DB	03bH
	DB	03cH
	DB	03dH
	DB	03eH
	DB	03fH
	DB	040H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	05bH
	DB	05cH
	DB	05dH
	DB	05eH
	DB	05fH
	DB	060H
	DB	061H
	DB	062H
	DB	063H
	DB	064H
	DB	065H
	DB	066H
	DB	067H
	DB	068H
	DB	069H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	06dH
	DB	06eH
	DB	06fH
	DB	070H
	DB	071H
	DB	072H
	DB	073H
	DB	074H
	DB	075H
	DB	076H
	DB	077H
	DB	078H
	DB	079H
	DB	07aH
	DB	07bH
	DB	07cH
	DB	07dH
	DB	07eH
	DB	07fH
?kwlist@?1??pattern_match@@9@9 DQ FLAT:??_C@_07CHFOACKJ@pattern?$AA@ ; `pattern_match'::`2'::kwlist
	DQ	FLAT:??_C@_03PCBNCGFH@pos?$AA@
	DQ	FLAT:??_C@_06MJPHPKNA@endpos?$AA@
	DQ	0000000000000000H
?kwlist@?1??pattern_search@@9@9 DQ FLAT:??_C@_07CHFOACKJ@pattern?$AA@ ; `pattern_search'::`2'::kwlist
	DQ	FLAT:??_C@_03PCBNCGFH@pos?$AA@
	DQ	FLAT:??_C@_06MJPHPKNA@endpos?$AA@
	DQ	0000000000000000H
?kwlist@?1??pattern_findall@@9@9 DQ FLAT:??_C@_06OEKOLKIL@source?$AA@ ; `pattern_findall'::`2'::kwlist
	DQ	FLAT:??_C@_03PCBNCGFH@pos?$AA@
	DQ	FLAT:??_C@_06MJPHPKNA@endpos?$AA@
	DQ	0000000000000000H
?kwlist@?1??pattern_split@@9@9 DQ FLAT:??_C@_06OEKOLKIL@source?$AA@ ; `pattern_split'::`2'::kwlist
	DQ	FLAT:??_C@_08HONNCIIN@maxsplit?$AA@
	DQ	0000000000000000H
?kwlist@?1??pattern_sub@@9@9 DQ FLAT:??_C@_04CLIOPAIH@repl?$AA@ ; `pattern_sub'::`2'::kwlist
	DQ	FLAT:??_C@_06ICGJLFIM@string?$AA@
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	0000000000000000H
?kwlist@?1??pattern_subn@@9@9 DQ FLAT:??_C@_04CLIOPAIH@repl?$AA@ ; `pattern_subn'::`2'::kwlist
	DQ	FLAT:??_C@_06ICGJLFIM@string?$AA@
	DQ	FLAT:??_C@_05IOMEMJEC@count?$AA@
	DQ	0000000000000000H
	ORG $+8
pattern_match_doc DB 'match(string[, pos[, endpos]]) -> match object or N'
	DB	'one.', 0aH, '    Matches zero or more characters at the begin'
	DB	'ning of the string', 00H
	ORG $+5
pattern_search_doc DB 'search(string[, pos[, endpos]]) -> match object or'
	DB	' None.', 0aH, '    Scan through string looking for a match, a'
	DB	'nd return a corresponding', 0aH, '    match object instance. '
	DB	'Return None if no position in the string matches.', 00H
	ORG $+2
pattern_split_doc DB 'split(string[, maxsplit = 0])  -> list.', 0aH, '   '
	DB	' Split string by the occurrences of pattern.', 00H
	ORG $+8
pattern_findall_doc DB 'findall(string[, pos[, endpos]]) -> list.', 0aH, ' '
	DB	'  Return a list of all non-overlapping matches of pattern in '
	DB	'string.', 00H
pattern_finditer_doc DB 'finditer(string[, pos[, endpos]]) -> iterator.', 0aH
	DB	'    Return an iterator over all non-overlapping matches for t'
	DB	'he ', 0aH, '    RE pattern in string. For each match, the ite'
	DB	'rator returns a', 0aH, '    match object.', 00H
	ORG $+13
pattern_sub_doc DB 'sub(repl, string[, count = 0]) -> newstring.', 0aH, ' '
	DB	'   Return the string obtained by replacing the leftmost non-o'
	DB	'verlapping', 0aH, '    occurrences of pattern in string by th'
	DB	'e replacement repl.', 00H
	ORG $+12
pattern_subn_doc DB 'subn(repl, string[, count = 0]) -> (newstring, numbe'
	DB	'r of subs)', 0aH, '    Return the tuple (new_string, number_o'
	DB	'f_subs_made) found by replacing', 0aH, '    the leftmost non-'
	DB	'overlapping occurrences of pattern with the', 0aH, '    repla'
	DB	'cement repl.', 00H
pattern_doc DB	'Compiled regular expression objects', 00H
	ORG $+12
pattern_methods DQ FLAT:??_C@_05FNONLPDI@match?$AA@
	DQ	FLAT:pattern_match
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_match_doc
	DQ	FLAT:??_C@_06GFPLNGOC@search?$AA@
	DQ	FLAT:pattern_search
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_search_doc
	DQ	FLAT:??_C@_03KCMAIMAP@sub?$AA@
	DQ	FLAT:pattern_sub
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_sub_doc
	DQ	FLAT:??_C@_04GLGDJLDE@subn?$AA@
	DQ	FLAT:pattern_subn
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_subn_doc
	DQ	FLAT:??_C@_05EHPMMFBK@split?$AA@
	DQ	FLAT:pattern_split
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_split_doc
	DQ	FLAT:??_C@_07MHCELJLC@findall?$AA@
	DQ	FLAT:pattern_findall
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_findall_doc
	DQ	FLAT:??_C@_08JCKNOCFD@finditer?$AA@
	DQ	FLAT:pattern_finditer
	DD	03H
	ORG $+4
	DQ	FLAT:pattern_finditer_doc
	DQ	FLAT:??_C@_07GPBKGHMB@scanner?$AA@
	DQ	FLAT:pattern_scanner
	DD	03H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08MOMBEIKE@__copy__?$AA@
	DQ	FLAT:pattern_copy
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0N@LCDCNIJ@__deepcopy__?$AA@
	DQ	FLAT:pattern_deepcopy
	DD	08H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
pattern_members DQ FLAT:??_C@_07CHFOACKJ@pattern?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000088H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_05GECEPKB@flags?$AA@
	DD	01H
	ORG $+4
	DQ	0000000000000090H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06HNAIAMHH@groups?$AA@
	DD	013H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0L@IAGOJEHI@groupindex?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000078H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
Pattern_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BB@FJKNOFPK@_sre?4SRE_Pattern?$AA@
	DQ	0000000000000110H
	DQ	0000000000000004H
	DQ	FLAT:pattern_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	FLAT:pattern_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000098H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:pattern_methods
	DQ	FLAT:pattern_members
	ORG $+144
?kwlist@?1??match_groups@@9@9 DQ FLAT:??_C@_07DLHCIBDH@default?$AA@ ; `match_groups'::`2'::kwlist
	DQ	0000000000000000H
?kwlist@?1??match_groupdict@@9@9 DQ FLAT:??_C@_07DLHCIBDH@default?$AA@ ; `match_groupdict'::`2'::kwlist
	DQ	0000000000000000H
match_doc DB	'The result of re.match() and re.search().', 0aH, 'Match '
	DB	'objects always have a boolean value of True.', 00H
	ORG $+3
match_group_doc DB 'group([group1, ...]) -> str or tuple.', 0aH, '    Ret'
	DB	'urn subgroup(s) of the match by indices or names.', 0aH, '   '
	DB	' For 0 returns the entire match.', 00H
	ORG $+13
match_start_doc DB 'start([group=0]) -> int.', 0aH, '    Return index of '
	DB	'the start of the substring matched by group.', 00H
	ORG $+6
match_end_doc DB 'end([group=0]) -> int.', 0aH, '    Return index of the '
	DB	'end of the substring matched by group.', 00H
	ORG $+10
match_span_doc DB 'span([group]) -> tuple.', 0aH, '    For MatchObject m,'
	DB	' return the 2-tuple (m.start(group), m.end(group)).', 00H
	ORG $+14
match_groups_doc DB 'groups([default=None]) -> tuple.', 0aH, '    Return '
	DB	'a tuple containing all the subgroups of the match, from 1.', 0aH
	DB	'    The default argument is used for groups', 0aH, '    that '
	DB	'did not participate in the match', 00H
	ORG $+3
match_groupdict_doc DB 'groupdict([default=None]) -> dict.', 0aH, '    Re'
	DB	'turn a dictionary containing all the named subgroups of the m'
	DB	'atch,', 0aH, '    keyed by the subgroup name. The default arg'
	DB	'ument is used for groups', 0aH, '    that did not participate'
	DB	' in the match', 00H
	ORG $+2
match_expand_doc DB 'expand(template) -> str.', 0aH, '    Return the stri'
	DB	'ng obtained by doing backslash substitution', 0aH, '    on th'
	DB	'e string template, as done by the sub() method.', 00H
	ORG $+15
match_methods DQ FLAT:??_C@_05MGJOOGAJ@group?$AA@
	DQ	FLAT:match_group
	DD	01H
	ORG $+4
	DQ	FLAT:match_group_doc
	DQ	FLAT:??_C@_05FAGFPHJG@start?$AA@
	DQ	FLAT:match_start
	DD	01H
	ORG $+4
	DQ	FLAT:match_start_doc
	DQ	FLAT:??_C@_03JBJLGPFL@end?$AA@
	DQ	FLAT:match_end
	DD	01H
	ORG $+4
	DQ	FLAT:match_end_doc
	DQ	FLAT:??_C@_04FOPLNFFP@span?$AA@
	DQ	FLAT:match_span
	DD	01H
	ORG $+4
	DQ	FLAT:match_span_doc
	DQ	FLAT:??_C@_06HNAIAMHH@groups?$AA@
	DQ	FLAT:match_groups
	DD	03H
	ORG $+4
	DQ	FLAT:match_groups_doc
	DQ	FLAT:??_C@_09GGPMIDAG@groupdict?$AA@
	DQ	FLAT:match_groupdict
	DD	03H
	ORG $+4
	DQ	FLAT:match_groupdict_doc
	DQ	FLAT:??_C@_06GFPMPEEP@expand?$AA@
	DQ	FLAT:match_expand
	DD	08H
	ORG $+4
	DQ	FLAT:match_expand_doc
	DQ	FLAT:??_C@_08MOMBEIKE@__copy__?$AA@
	DQ	FLAT:match_copy
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0N@LCDCNIJ@__deepcopy__?$AA@
	DQ	FLAT:match_deepcopy
	DD	08H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
match_getset DQ	FLAT:??_C@_09LCAJIJAE@lastindex?$AA@
	DQ	FLAT:match_lastindex_get
	DQ	0000000000000000H
	ORG $+16
	DQ	FLAT:??_C@_09COONDMIO@lastgroup?$AA@
	DQ	FLAT:match_lastgroup_get
	DQ	0000000000000000H
	ORG $+16
	DQ	FLAT:??_C@_04PPLNELOM@regs?$AA@
	DQ	FLAT:match_regs_get
	DQ	0000000000000000H
	ORG $+16
	DQ	0000000000000000H
	ORG $+32
match_members DQ FLAT:??_C@_06ICGJLFIM@string?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000070H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_02EPEBAFDB@re?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000080H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_03PCBNCGFH@pos?$AA@
	DD	013H
	ORG $+4
	DQ	0000000000000088H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06MJPHPKNA@endpos?$AA@
	DD	013H
	ORG $+4
	DQ	0000000000000090H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
	ORG $+8
Match_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0P@HEJLNOBB@_sre?4SRE_Match?$AA@
	DQ	00000000000000b0H
	DQ	0000000000000008H
	DQ	FLAT:match_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	FLAT:match_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:match_methods
	DQ	FLAT:match_members
	DQ	FLAT:match_getset
	ORG $+136
scanner_methods DQ FLAT:??_C@_05FNONLPDI@match?$AA@
	DQ	FLAT:scanner_match
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06GFPLNGOC@search?$AA@
	DQ	FLAT:scanner_search
	DD	04H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
scanner_members DQ FLAT:??_C@_07CHFOACKJ@pattern?$AA@
	DD	06H
	ORG $+4
	DQ	0000000000000060H
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	ORG $+32
Scanner_Type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BB@BBOJIAJC@_sre?4SRE_Scanner?$AA@
	DQ	0000000000000770H
	DQ	0000000000000000H
	DQ	FLAT:scanner_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	040000H
	ORG $+4
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:scanner_methods
	DQ	FLAT:scanner_members
	DQ	0000000000000000H
	ORG $+136
?kwlist@?1??pattern_scanner@@9@9 DQ FLAT:??_C@_06OEKOLKIL@source?$AA@ ; `pattern_scanner'::`2'::kwlist
	DQ	FLAT:??_C@_03PCBNCGFH@pos?$AA@
	DQ	FLAT:??_C@_06MJPHPKNA@endpos?$AA@
	DQ	0000000000000000H
_functions DQ	FLAT:??_C@_07OLJGFCKG@compile?$AA@
	DQ	FLAT:_compile
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0M@PEJEAKBE@getcodesize?$AA@
	DQ	FLAT:sre_codesize
	DD	04H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_08GAHBPIPM@getlower?$AA@
	DQ	FLAT:sre_getlower
	DD	01H
	ORG $+4
	ORG $+8
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
sremodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_04LFOLHMFG@_sre?$AA@
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	FLAT:_functions
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
EXTRN	PyLong_FromSize_t:PROC
; Function compile flags: /Ogtp
; File c:\src\pyparallel\modules\_sre.c
;	COMDAT sre_codesize
_TEXT	SEGMENT
self$ = 8
unused$ = 16
sre_codesize PROC					; COMDAT

; 1636 :     return PyLong_FromSize_t(sizeof(SRE_CODE));

  00000	b9 04 00 00 00	 mov	 ecx, 4

; 1637 : }

  00005	e9 00 00 00 00	 jmp	 PyLong_FromSize_t
sre_codesize ENDP
_TEXT	ENDS
PUBLIC	??_C@_01KBJDNOO@i?$AA@				; `string'
PUBLIC	??_C@_02PDIHAGKM@ii?$AA@			; `string'
EXTRN	_Py_BuildValue_SizeT:PROC
EXTRN	_PyArg_ParseTuple_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_getlower DD imagerel sre_getlower
	DD	imagerel sre_getlower+128
	DD	imagerel $unwind$sre_getlower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_getlower DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_01KBJDNOO@i?$AA@
CONST	SEGMENT
??_C@_01KBJDNOO@i?$AA@ DB 'i', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDIHAGKM@ii?$AA@
CONST	SEGMENT
??_C@_02PDIHAGKM@ii?$AA@ DB 'ii', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT sre_getlower
_TEXT	SEGMENT
self$ = 48
args$ = 56
character$ = 64
flags$ = 72
sre_getlower PROC					; COMDAT

; 1641 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1642 :     int character, flags;
; 1643 :     if (!PyArg_ParseTuple(args, "ii", &character, &flags))

  00004	48 8b ca	 mov	 rcx, rdx
  00007	4c 8d 4c 24 48	 lea	 r9, QWORD PTR flags$[rsp]
  0000c	4c 8d 44 24 40	 lea	 r8, QWORD PTR character$[rsp]
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PDIHAGKM@ii?$AA@
  00018	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN3@sre_getlow

; 1644 :         return NULL;

  00021	33 c0		 xor	 eax, eax

; 1650 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
$LN3@sre_getlow:

; 1645 :     if (flags & SRE_FLAG_LOCALE)

  00028	8b 44 24 48	 mov	 eax, DWORD PTR flags$[rsp]

; 1646 :         return Py_BuildValue("i", sre_lower_locale(character));

  0002c	8b 4c 24 40	 mov	 ecx, DWORD PTR character$[rsp]
  00030	a8 04		 test	 al, 4
  00032	74 18		 je	 SHORT $LN2@sre_getlow
  00034	e8 00 00 00 00	 call	 sre_lower_locale

; 1649 :     return Py_BuildValue("i", sre_lower(character));

  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01KBJDNOO@i?$AA@
  00040	8b d0		 mov	 edx, eax
  00042	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 1650 : }

  00047	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004b	c3		 ret	 0
$LN2@sre_getlow:

; 1647 :     if (flags & SRE_FLAG_UNICODE)

  0004c	a8 20		 test	 al, 32			; 00000020H
  0004e	74 18		 je	 SHORT $LN1@sre_getlow

; 1648 :         return Py_BuildValue("i", sre_lower_unicode(character));

  00050	e8 00 00 00 00	 call	 sre_lower_unicode

; 1649 :     return Py_BuildValue("i", sre_lower(character));

  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01KBJDNOO@i?$AA@
  0005c	8b d0		 mov	 edx, eax
  0005e	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 1650 : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
$LN1@sre_getlow:

; 1649 :     return Py_BuildValue("i", sre_lower(character));

  00068	e8 00 00 00 00	 call	 sre_lower
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01KBJDNOO@i?$AA@
  00074	8b d0		 mov	 edx, eax
  00076	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT

; 1650 : }

  0007b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007f	c3		 ret	 0
sre_getlower ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT sre_lower
_TEXT	SEGMENT
ch$ = 8
sre_lower PROC						; COMDAT

; 147  :     return ((ch) < 128 ? (unsigned int)sre_char_lower[ch] : ch);

  00000	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00006	73 0e		 jae	 SHORT $LN3@sre_lower
  00008	8b c1		 mov	 eax, ecx
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sre_char_lower
  00011	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]

; 148  : }

  00015	c3		 ret	 0
$LN3@sre_lower:

; 147  :     return ((ch) < 128 ? (unsigned int)sre_char_lower[ch] : ch);

  00016	8b c1		 mov	 eax, ecx

; 148  : }

  00018	c3		 ret	 0
sre_lower ENDP
_TEXT	ENDS
EXTRN	__imp_tolower:PROC
; Function compile flags: /Ogtp
;	COMDAT sre_lower_locale
_TEXT	SEGMENT
ch$ = 8
sre_lower_locale PROC					; COMDAT

; 161  :     return ((ch) < 256 ? (unsigned int)tolower((ch)) : ch);

  00000	81 f9 00 01 00
	00		 cmp	 ecx, 256		; 00000100H
  00006	73 07		 jae	 SHORT $LN3@sre_lower_

; 162  : }

  00008	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_tolower
$LN3@sre_lower_:

; 161  :     return ((ch) < 256 ? (unsigned int)tolower((ch)) : ch);

  0000f	8b c1		 mov	 eax, ecx

; 162  : }

  00011	c3		 ret	 0
sre_lower_locale ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_ToLowercase:PROC
; Function compile flags: /Ogtp
;	COMDAT sre_lower_unicode
_TEXT	SEGMENT
ch$ = 8
sre_lower_unicode PROC					; COMDAT

; 174  :     return (unsigned int) Py_UNICODE_TOLOWER(ch);
; 175  : }

  00000	e9 00 00 00 00	 jmp	 _PyUnicode_ToLowercase
sre_lower_unicode ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
EXTRN	_PyObject_DebugFree:PROC
EXTRN	PyBuffer_Release:PROC
EXTRN	PyObject_ClearWeakRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_dealloc DD imagerel pattern_dealloc
	DD	imagerel pattern_dealloc+103
	DD	imagerel $unwind$pattern_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_dealloc DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT pattern_dealloc
_TEXT	SEGMENT
self$ = 48
pattern_dealloc PROC					; COMDAT

; 1868 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1869 :     if (self->weakreflist != NULL)

  00006	48 83 b9 98 00
	00 00 00	 cmp	 QWORD PTR [rcx+152], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 05		 je	 SHORT $LN14@pattern_de

; 1870 :         PyObject_ClearWeakRefs((PyObject *) self);

  00013	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN14@pattern_de:

; 1871 :     if (self->view.buf)

  00018	48 8d 8b a8 00
	00 00		 lea	 rcx, QWORD PTR [rbx+168]
  0001f	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00023	74 05		 je	 SHORT $LN12@pattern_de

; 1872 :         PyBuffer_Release(&self->view);

  00025	e8 00 00 00 00	 call	 PyBuffer_Release
$LN12@pattern_de:

; 1873 :     Py_XDECREF(self->pattern);

  0002a	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
  00031	48 85 c9	 test	 rcx, rcx
  00034	74 05		 je	 SHORT $LN11@pattern_de
  00036	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@pattern_de:

; 1874 :     Py_XDECREF(self->groupindex);

  0003b	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  0003f	48 85 c9	 test	 rcx, rcx
  00042	74 05		 je	 SHORT $LN7@pattern_de
  00044	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@pattern_de:

; 1875 :     Py_XDECREF(self->indexgroup);

  00049	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00050	48 85 c9	 test	 rcx, rcx
  00053	74 05		 je	 SHORT $LN3@pattern_de
  00055	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@pattern_de:

; 1876 :     PyObject_DEL(self);

  0005a	48 8b cb	 mov	 rcx, rbx

; 1877 : }

  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5b		 pop	 rbx
  00062	e9 00 00 00 00	 jmp	 _PyObject_DebugFree
pattern_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_RefTotal:QWORD
EXTRN	Px_DecRef:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@HDLODFOL@O?$HMnn?3match?$AA@		; `string'
EXTRN	PyErr_Occurred:PROC
EXTRN	_PyArg_ParseTupleAndKeywords_SizeT:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_sre.c
pdata	SEGMENT
$pdata$pattern_match DD imagerel pattern_match
	DD	imagerel pattern_match+171
	DD	imagerel $unwind$pattern_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_match DD imagerel pattern_match+171
	DD	imagerel pattern_match+244
	DD	imagerel $chain$0$pattern_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pattern_match DD imagerel pattern_match+244
	DD	imagerel pattern_match+287
	DD	imagerel $chain$2$pattern_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pattern_match DD 020021H
	DD	0ee7400H
	DD	imagerel pattern_match
	DD	imagerel pattern_match+171
	DD	imagerel $unwind$pattern_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_match DD 020821H
	DD	0ee7408H
	DD	imagerel pattern_match
	DD	imagerel pattern_match+171
	DD	imagerel $unwind$pattern_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_match DD 030b01H
	DD	0ec010bH
	DD	03004H
xdata	ENDS
;	COMDAT ??_C@_0L@HDLODFOL@O?$HMnn?3match?$AA@
CONST	SEGMENT
??_C@_0L@HDLODFOL@O?$HMnn?3match?$AA@ DB 'O|nn:match', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT pattern_match
_TEXT	SEGMENT
string$ = 64
start$ = 72
state$ = 80
self$ = 1904
args$ = 1912
kw$ = 1920
end$ = 1928
pattern_match PROC					; COMDAT

; 1881 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 81 ec 60 07
	00 00		 sub	 rsp, 1888		; 00000760H
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	49 8b c0	 mov	 rax, r8
  00011	4c 8b d2	 mov	 r10, rdx

; 1882 :     SRE_STATE state;
; 1883 :     int status;
; 1884 : 
; 1885 :     PyObject* string;
; 1886 :     Py_ssize_t start = 0;
; 1887 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  00014	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH

; 1888 :     static char* kwlist[] = { "pattern", "pos", "endpos", NULL };
; 1889 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "O|nn:match", kwlist,
; 1890 :                                      &string, &start, &end))

  0001e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_match@@9@9
  00025	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@HDLODFOL@O?$HMnn?3match?$AA@
  0002c	49 89 4b 20	 mov	 QWORD PTR [r11+32], rcx
  00030	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00034	48 8b d0	 mov	 rdx, rax
  00037	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003c	48 8d 4c 24 48	 lea	 rcx, QWORD PTR start$[rsp]
  00041	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
  0004a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR string$[rsp]
  00054	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00059	49 8b ca	 mov	 rcx, r10
  0005c	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00061	85 c0		 test	 eax, eax
  00063	75 0b		 jne	 SHORT $LN5@pattern_ma
$LN9@pattern_ma:

; 1891 :         return NULL;

  00065	33 c0		 xor	 eax, eax

; 1914 : }

  00067	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  0006e	5b		 pop	 rbx
  0006f	c3		 ret	 0
$LN5@pattern_ma:

; 1892 : 
; 1893 :     string = state_init(&state, self, string, start, end);

  00070	48 8b 84 24 88
	07 00 00	 mov	 rax, QWORD PTR end$[rsp]
  00078	4c 8b 4c 24 48	 mov	 r9, QWORD PTR start$[rsp]
  0007d	4c 8b 44 24 40	 mov	 r8, QWORD PTR string$[rsp]
  00082	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  00087	48 8b d3	 mov	 rdx, rbx
  0008a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008f	e8 00 00 00 00	 call	 state_init
  00094	48 89 44 24 40	 mov	 QWORD PTR string$[rsp], rax

; 1894 :     if (!string)

  00099	48 85 c0	 test	 rax, rax

; 1895 :         return NULL;

  0009c	74 c7		 je	 SHORT $LN9@pattern_ma

; 1896 : 
; 1897 :     state.ptr = state.start;
; 1898 : 
; 1899 :     TRACE(("|%p|%p|MATCH\n", PatternObject_GetCode(self), state.ptr));
; 1900 : 
; 1901 :     if (state.logical_charsize == 1) {

  0009e	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR state$[rsp+56], 1
  000a6	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp+16]
  000ab	48 89 bc 24 70
	07 00 00	 mov	 QWORD PTR [rsp+1904], rdi
  000b3	48 89 44 24 50	 mov	 QWORD PTR state$[rsp], rax

; 1902 :         status = sre_match(&state, PatternObject_GetCode(self));

  000b8	48 8d 93 00 01
	00 00		 lea	 rdx, QWORD PTR [rbx+256]
  000bf	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  000c4	75 0a		 jne	 SHORT $LN3@pattern_ma
  000c6	e8 00 00 00 00	 call	 sre_match
  000cb	48 8b f8	 mov	 rdi, rax

; 1903 :     } else {

  000ce	eb 07		 jmp	 SHORT $LN2@pattern_ma
$LN3@pattern_ma:

; 1904 :         status = sre_umatch(&state, PatternObject_GetCode(self));

  000d0	e8 00 00 00 00	 call	 sre_umatch
  000d5	8b f8		 mov	 edi, eax
$LN2@pattern_ma:

; 1905 :     }
; 1906 : 
; 1907 :     TRACE(("|%p|%p|END\n", PatternObject_GetCode(self), state.ptr));
; 1908 :     if (PyErr_Occurred())

  000d7	e8 00 00 00 00	 call	 PyErr_Occurred
  000dc	48 85 c0	 test	 rax, rax
  000df	74 13		 je	 SHORT $LN1@pattern_ma

; 1909 :         return NULL;

  000e1	33 c0		 xor	 eax, eax
  000e3	48 8b bc 24 70
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1904]

; 1914 : }

  000eb	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  000f2	5b		 pop	 rbx
  000f3	c3		 ret	 0
$LN1@pattern_ma:

; 1910 : 
; 1911 :     state_fini(&state);

  000f4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  000f9	e8 00 00 00 00	 call	 state_fini

; 1912 : 
; 1913 :     return pattern_new_match(self, &state, status);

  000fe	48 8d 54 24 50	 lea	 rdx, QWORD PTR state$[rsp]
  00103	44 8b c7	 mov	 r8d, edi
  00106	48 8b cb	 mov	 rcx, rbx
  00109	e8 00 00 00 00	 call	 pattern_new_match
  0010e	48 8b bc 24 70
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1904]

; 1914 : }

  00116	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  0011d	5b		 pop	 rbx
  0011e	c3		 ret	 0
pattern_match ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BC@DAEMKNJI@?$AAr?$AAe?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@ ; `string'
EXTRN	__imp__wassert:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyObject_DebugMalloc:PROC
EXTRN	memcpy:PROC
EXTRN	PyErr_CheckSignals:PROC
EXTRN	__ImageBase:BYTE
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_match DD imagerel sre_match
	DD	imagerel sre_match+96
	DD	imagerel $unwind$sre_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$sre_match DD imagerel sre_match+96
	DD	imagerel sre_match+5156
	DD	imagerel $chain$2$sre_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$sre_match DD imagerel sre_match+5156
	DD	imagerel sre_match+5336
	DD	imagerel $chain$4$sre_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$sre_match DD 060021H
	DD	0c7400H
	DD	0b6400H
	DD	0a5400H
	DD	imagerel sre_match
	DD	imagerel sre_match+96
	DD	imagerel $unwind$sre_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$sre_match DD 060f21H
	DD	0c740fH
	DD	0b640aH
	DD	0a5405H
	DD	imagerel sre_match
	DD	imagerel sre_match+96
	DD	imagerel $unwind$sre_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_match DD 060e01H
	DD	0f00a320eH
	DD	0d006e008H
	DD	03002c004H
xdata	ENDS
;	COMDAT ??_C@_1BC@DAEMKNJI@?$AAr?$AAe?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@DAEMKNJI@?$AAr?$AAe?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'1', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@
CONST	SEGMENT
??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H
	DB	'p', 00H, 'y', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'l'
	DB	00H, 'l', 00H, 'e', 00H, 'l', 00H, '\', 00H, 'm', 00H, 'o', 00H
	DB	'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, 's', 00H, '\', 00H, '_'
	DB	00H, 's', 00H, 'r', 00H, 'e', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT sre_match
_TEXT	SEGMENT
state$ = 80
pattern$ = 88
sre_match PROC						; COMDAT

; 782  : {

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 783  :     char* end = (char*)state->end;
; 784  :     Py_ssize_t alloc_pos, ctx_pos = -1;
; 785  :     Py_ssize_t i, ret = 0;
; 786  :     Py_ssize_t jump;
; 787  :     unsigned int sigcount=0;
; 788  : 
; 789  :     SRE_MATCH_CONTEXT* ctx;
; 790  :     SRE_MATCH_CONTEXT* nextctx;
; 791  : 
; 792  :     TRACE(("|%p|%p|ENTER\n", pattern, state->ptr));
; 793  : 
; 794  :     DATA_ALLOC(SRE_MATCH_CONTEXT, ctx);

  0000e	4c 8b a9 a0 06
	00 00		 mov	 r13, QWORD PTR [rcx+1696]
  00015	48 8b 81 98 06
	00 00		 mov	 rax, QWORD PTR [rcx+1688]
  0001c	4c 8b 71 18	 mov	 r14, QWORD PTR [rcx+24]
  00020	49 2b c5	 sub	 rax, r13
  00023	45 33 ff	 xor	 r15d, r15d
  00026	48 8b da	 mov	 rbx, rdx
  00029	4c 8b e1	 mov	 r12, rcx
  0002c	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00030	73 1d		 jae	 SHORT $LN709@sre_match
  00032	41 8d 57 40	 lea	 edx, QWORD PTR [r15+64]
  00036	e8 00 00 00 00	 call	 data_stack_grow
  0003b	85 c0		 test	 eax, eax
  0003d	79 10		 jns	 SHORT $LN709@sre_match
  0003f	48 98		 cdqe

; 1427 :         case JUMP_MAX_UNTIL_2:
; 1428 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1429 :             goto jump_max_until_2;
; 1430 :         case JUMP_MAX_UNTIL_3:
; 1431 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1432 :             goto jump_max_until_3;
; 1433 :         case JUMP_MIN_UNTIL_2:
; 1434 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1435 :             goto jump_min_until_2;
; 1436 :         case JUMP_MIN_UNTIL_3:
; 1437 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1438 :             goto jump_min_until_3;
; 1439 :         case JUMP_BRANCH:
; 1440 :             TRACE(("|%p|%p|JUMP_BRANCH\n", ctx->pattern, ctx->ptr));
; 1441 :             goto jump_branch;
; 1442 :         case JUMP_MAX_UNTIL_1:
; 1443 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1444 :             goto jump_max_until_1;
; 1445 :         case JUMP_MIN_UNTIL_1:
; 1446 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1447 :             goto jump_min_until_1;
; 1448 :         case JUMP_REPEAT:
; 1449 :             TRACE(("|%p|%p|JUMP_REPEAT\n", ctx->pattern, ctx->ptr));
; 1450 :             goto jump_repeat;
; 1451 :         case JUMP_REPEAT_ONE_1:
; 1452 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_1\n", ctx->pattern, ctx->ptr));
; 1453 :             goto jump_repeat_one_1;
; 1454 :         case JUMP_REPEAT_ONE_2:
; 1455 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_2\n", ctx->pattern, ctx->ptr));
; 1456 :             goto jump_repeat_one_2;
; 1457 :         case JUMP_MIN_REPEAT_ONE:
; 1458 :             TRACE(("|%p|%p|JUMP_MIN_REPEAT_ONE\n", ctx->pattern, ctx->ptr));
; 1459 :             goto jump_min_repeat_one;
; 1460 :         case JUMP_ASSERT:
; 1461 :             TRACE(("|%p|%p|JUMP_ASSERT\n", ctx->pattern, ctx->ptr));
; 1462 :             goto jump_assert;
; 1463 :         case JUMP_ASSERT_NOT:
; 1464 :             TRACE(("|%p|%p|JUMP_ASSERT_NOT\n", ctx->pattern, ctx->ptr));
; 1465 :             goto jump_assert_not;
; 1466 :         case JUMP_NONE:
; 1467 :             TRACE(("|%p|%p|RETURN %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1468 :                    ctx->ptr, ret));
; 1469 :             break;
; 1470 :     }
; 1471 : 
; 1472 :     return ret; /* should never get here */
; 1473 : }

  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	41 5f		 pop	 r15
  00047	41 5e		 pop	 r14
  00049	41 5d		 pop	 r13
  0004b	41 5c		 pop	 r12
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
$LN709@sre_match:

; 783  :     char* end = (char*)state->end;
; 784  :     Py_ssize_t alloc_pos, ctx_pos = -1;
; 785  :     Py_ssize_t i, ret = 0;
; 786  :     Py_ssize_t jump;
; 787  :     unsigned int sigcount=0;
; 788  : 
; 789  :     SRE_MATCH_CONTEXT* ctx;
; 790  :     SRE_MATCH_CONTEXT* nextctx;
; 791  : 
; 792  :     TRACE(("|%p|%p|ENTER\n", pattern, state->ptr));
; 793  : 
; 794  :     DATA_ALLOC(SRE_MATCH_CONTEXT, ctx);

  0004f	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00057	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  00060	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00065	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  0006a	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  0006f	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]

; 795  :     ctx->last_ctx_pos = -1;

  00074	48 c7 07 ff ff
	ff ff		 mov	 QWORD PTR [rdi], -1

; 796  :     ctx->jump = JUMP_NONE;

  0007b	4c 89 7f 08	 mov	 QWORD PTR [rdi+8], r15

; 797  :     ctx->pattern = pattern;

  0007f	48 89 5f 18	 mov	 QWORD PTR [rdi+24], rbx
$LN818@sre_match:

; 798  :     ctx_pos = alloc_pos;

  00083	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  0008a	66 0f 1f 44 00
	00		 npad	 6
$entrance$20908:

; 799  : 
; 800  : entrance:
; 801  : 
; 802  :     ctx->ptr = (char *)state->ptr;

  00090	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]

; 803  : 
; 804  :     if (ctx->pattern[0] == SRE_OP_INFO) {

  00094	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  00098	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx
  0009c	41 83 38 11	 cmp	 DWORD PTR [r8], 17
  000a0	75 30		 jne	 SHORT $LN703@sre_match

; 805  :         /* optimization info block */
; 806  :         /* <INFO> <1=skip> <2=flags> <3=min> ... */
; 807  :         if (ctx->pattern[3] && (end - ctx->ptr)/state->charsize < ctx->pattern[3]) {

  000a2	45 8b 48 0c	 mov	 r9d, DWORD PTR [r8+12]
  000a6	45 85 c9	 test	 r9d, r9d
  000a9	74 19		 je	 SHORT $LN704@sre_match
  000ab	49 8b c6	 mov	 rax, r14
  000ae	48 2b c1	 sub	 rax, rcx
  000b1	49 63 4c 24 3c	 movsxd	 rcx, DWORD PTR [r12+60]
  000b6	48 99		 cdq
  000b8	48 f7 f9	 idiv	 rcx
  000bb	49 3b c1	 cmp	 rax, r9

; 808  :             TRACE(("reject (got %" PY_FORMAT_SIZE_T "d chars, "
; 809  :                    "need %" PY_FORMAT_SIZE_T "d)\n",
; 810  :                    (end - ctx->ptr)/state->charsize,
; 811  :                    (Py_ssize_t) ctx->pattern[3]));
; 812  :             RETURN_FAILURE;

  000be	0f 8c e7 06 00
	00		 jl	 $LN30@sre_match
$LN704@sre_match:

; 813  :         }
; 814  :         ctx->pattern += ctx->pattern[1] + 1;

  000c4	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  000c8	ff c0		 inc	 eax
  000ca	49 8d 0c 80	 lea	 rcx, QWORD PTR [r8+rax*4]
$LN816@sre_match:
  000ce	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx
$LN703@sre_match:

; 815  :     }
; 816  : 
; 817  :     for (;;) {
; 818  :         ++sigcount;

  000d2	41 ff c7	 inc	 r15d

; 819  :         if ((0 == (sigcount & 0xfff)) && PyErr_CheckSignals())

  000d5	41 f7 c7 ff 0f
	00 00		 test	 r15d, 4095		; 00000fffH
  000dc	75 0d		 jne	 SHORT $LN698@sre_match
  000de	e8 00 00 00 00	 call	 PyErr_CheckSignals
  000e3	85 c0		 test	 eax, eax
  000e5	0f 85 01 13 00
	00		 jne	 $LN777@sre_match
$LN698@sre_match:

; 821  : 
; 822  :         switch (*ctx->pattern++) {

  000eb	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  000ef	8b 08		 mov	 ecx, DWORD PTR [rax]
  000f1	4c 8d 48 04	 lea	 r9, QWORD PTR [rax+4]
  000f5	4c 89 4f 18	 mov	 QWORD PTR [rdi+24], r9
  000f9	83 f9 1f	 cmp	 ecx, 31
  000fc	0f 87 00 13 00
	00		 ja	 $LN28@sre_match
  00102	8b c1		 mov	 eax, ecx
  00104	8b 8c 8e 00 00
	00 00		 mov	 ecx, DWORD PTR $LN807@sre_match[rsi+rcx*4]
  0010b	48 03 ce	 add	 rcx, rsi
  0010e	ff e1		 jmp	 rcx
$LN695@sre_match:

; 823  : 
; 824  :         case SRE_OP_MARK:
; 825  :             /* set mark */
; 826  :             /* <MARK> <gid> */
; 827  :             TRACE(("|%p|%p|MARK %d\n", ctx->pattern,
; 828  :                    ctx->ptr, ctx->pattern[0]));
; 829  :             i = ctx->pattern[0];

  00110	41 8b 19	 mov	 ebx, DWORD PTR [r9]

; 830  :             if (i & 1)

  00113	f6 c3 01	 test	 bl, 1
  00116	74 12		 je	 SHORT $LN694@sre_match

; 831  :                 state->lastindex = i/2 + 1;

  00118	8b c3		 mov	 eax, ebx
  0011a	48 99		 cdq
  0011c	48 2b c2	 sub	 rax, rdx
  0011f	48 d1 f8	 sar	 rax, 1
  00122	48 ff c0	 inc	 rax
  00125	49 89 44 24 40	 mov	 QWORD PTR [r12+64], rax
$LN694@sre_match:

; 832  :             if (i > state->lastmark) {

  0012a	49 8b 44 24 48	 mov	 rax, QWORD PTR [r12+72]
  0012f	48 3b d8	 cmp	 rbx, rax
  00132	7e 23		 jle	 SHORT $LN693@sre_match

; 833  :                 /* state->lastmark is the highest valid index in the
; 834  :                    state->mark array.  If it is increased by more than 1,
; 835  :                    the intervening marks must be set to NULL to signal
; 836  :                    that these marks have not been encountered. */
; 837  :                 Py_ssize_t j = state->lastmark + 1;

  00134	48 ff c0	 inc	 rax

; 838  :                 while (j < i)

  00137	48 3b c3	 cmp	 rax, rbx
  0013a	7d 16		 jge	 SHORT $LN692@sre_match

; 833  :                 /* state->lastmark is the highest valid index in the
; 834  :                    state->mark array.  If it is increased by more than 1,
; 835  :                    the intervening marks must be set to NULL to signal
; 836  :                    that these marks have not been encountered. */
; 837  :                 Py_ssize_t j = state->lastmark + 1;

  0013c	4c 8b c3	 mov	 r8, rbx
  0013f	49 8d 4c c4 50	 lea	 rcx, QWORD PTR [r12+rax*8+80]
  00144	33 d2		 xor	 edx, edx
  00146	4c 2b c0	 sub	 r8, rax
  00149	49 c1 e0 03	 shl	 r8, 3
  0014d	e8 00 00 00 00	 call	 memset
$LN692@sre_match:

; 839  :                     state->mark[j++] = NULL;
; 840  :                 state->lastmark = i;

  00152	49 89 5c 24 48	 mov	 QWORD PTR [r12+72], rbx
$LN693@sre_match:

; 841  :             }
; 842  :             state->mark[i] = ctx->ptr;

  00157	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0015b	49 89 44 dc 50	 mov	 QWORD PTR [r12+rbx*8+80], rax
$LN670@sre_match:

; 843  :             ctx->pattern++;

  00160	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 844  :             break;

  00165	e9 68 ff ff ff	 jmp	 $LN703@sre_match
$LN690@sre_match:

; 845  : 
; 846  :         case SRE_OP_LITERAL:
; 847  :             /* match literal string */
; 848  :             /* <LITERAL> <code> */
; 849  :             TRACE(("|%p|%p|LITERAL %d\n", ctx->pattern,
; 850  :                    ctx->ptr, *ctx->pattern));
; 851  :             if (ctx->ptr >= end || (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) != ctx->pattern[0])

  0016a	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  0016e	49 3b ce	 cmp	 rcx, r14
  00171	0f 83 34 06 00
	00		 jae	 $LN30@sre_match
  00177	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0017a	41 3b 01	 cmp	 eax, DWORD PTR [r9]
  0017d	0f 85 28 06 00
	00		 jne	 $LN30@sre_match

; 852  :                 RETURN_FAILURE;
; 853  :             ctx->pattern++;

  00183	49 8d 41 04	 lea	 rax, QWORD PTR [r9+4]
  00187	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax
$LN653@sre_match:

; 854  :             ctx->ptr += state->charsize;

  0018b	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  00190	48 03 c1	 add	 rax, rcx
  00193	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 855  :             break;

  00197	e9 36 ff ff ff	 jmp	 $LN703@sre_match
$LN684@sre_match:

; 856  : 
; 857  :         case SRE_OP_NOT_LITERAL:
; 858  :             /* match anything that is not literal character */
; 859  :             /* <NOT_LITERAL> <code> */
; 860  :             TRACE(("|%p|%p|NOT_LITERAL %d\n", ctx->pattern,
; 861  :                    ctx->ptr, *ctx->pattern));
; 862  :             if (ctx->ptr >= end || (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) == ctx->pattern[0])

  0019c	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  001a0	49 3b ce	 cmp	 rcx, r14
  001a3	0f 83 02 06 00
	00		 jae	 $LN30@sre_match
  001a9	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001ac	41 3b 01	 cmp	 eax, DWORD PTR [r9]
  001af	0f 84 f6 05 00
	00		 je	 $LN30@sre_match

; 863  :                 RETURN_FAILURE;
; 864  :             ctx->pattern++;

  001b5	49 8d 41 04	 lea	 rax, QWORD PTR [r9+4]
  001b9	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 865  :             ctx->ptr += state->charsize;

  001bd	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  001c2	48 03 c1	 add	 rax, rcx
  001c5	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 866  :             break;

  001c9	e9 04 ff ff ff	 jmp	 $LN703@sre_match
$LN675@sre_match:

; 867  : 
; 868  :         case SRE_OP_SUCCESS:
; 869  :             /* end of pattern */
; 870  :             TRACE(("|%p|%p|SUCCESS\n", ctx->pattern, ctx->ptr));
; 871  :             state->ptr = ctx->ptr;
; 872  :             RETURN_SUCCESS;
; 873  : 
; 874  :         case SRE_OP_AT:
; 875  :             /* match at given position */
; 876  :             /* <AT> <code> */
; 877  :             TRACE(("|%p|%p|AT %d\n", ctx->pattern, ctx->ptr, *ctx->pattern));
; 878  :             if (!SRE_AT(state, ctx->ptr, *ctx->pattern))

  001ce	45 8b 01	 mov	 r8d, DWORD PTR [r9]
  001d1	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  001d5	49 8b cc	 mov	 rcx, r12
  001d8	e8 00 00 00 00	 call	 sre_at
  001dd	85 c0		 test	 eax, eax
  001df	0f 85 7b ff ff
	ff		 jne	 $LN670@sre_match

; 879  :                 RETURN_FAILURE;

  001e5	e9 c1 05 00 00	 jmp	 $LN30@sre_match
$LN669@sre_match:

; 880  :             ctx->pattern++;
; 881  :             break;
; 882  : 
; 883  :         case SRE_OP_CATEGORY:
; 884  :             /* match at given category */
; 885  :             /* <CATEGORY> <code> */
; 886  :             TRACE(("|%p|%p|CATEGORY %d\n", ctx->pattern,
; 887  :                    ctx->ptr, *ctx->pattern));
; 888  :             if (ctx->ptr >= end || !sre_category(ctx->pattern[0], SRE_CHARGET(state, ctx->ptr, 0)))

  001ea	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  001ee	49 3b c6	 cmp	 rax, r14
  001f1	0f 83 b4 05 00
	00		 jae	 $LN30@sre_match
  001f7	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  001fa	41 8b 09	 mov	 ecx, DWORD PTR [r9]
  001fd	e8 00 00 00 00	 call	 sre_category
  00202	85 c0		 test	 eax, eax
  00204	0f 84 a1 05 00
	00		 je	 $LN30@sre_match

; 889  :                 RETURN_FAILURE;
; 890  :             ctx->pattern++;

  0020a	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 891  :             ctx->ptr += state->charsize;

  0020f	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  00214	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 892  :             break;

  00218	e9 b5 fe ff ff	 jmp	 $LN703@sre_match
$LN663@sre_match:

; 893  : 
; 894  :         case SRE_OP_ANY:
; 895  :             /* match anything (except a newline) */
; 896  :             /* <ANY> */
; 897  :             TRACE(("|%p|%p|ANY\n", ctx->pattern, ctx->ptr));
; 898  :                 if (ctx->ptr >= end || SRE_IS_LINEBREAK(SRE_CHARGET(state, ctx->ptr, 0)))

  0021d	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00221	49 3b d6	 cmp	 rdx, r14
  00224	0f 83 81 05 00
	00		 jae	 $LN30@sre_match
  0022a	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0022d	3c 80		 cmp	 al, 128			; 00000080H
  0022f	73 14		 jae	 SHORT $LN805@sre_match
  00231	0f b6 c0	 movzx	 eax, al
  00234	0f be 8c 30 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+rsi]
  0023c	83 e1 04	 and	 ecx, 4
  0023f	0f 85 66 05 00
	00		 jne	 $LN30@sre_match
$LN805@sre_match:

; 899  :                     RETURN_FAILURE;
; 900  :             ctx->ptr += state->charsize;

  00245	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  0024a	48 03 c2	 add	 rax, rdx
  0024d	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 901  :             break;

  00251	e9 7c fe ff ff	 jmp	 $LN703@sre_match
$LN657@sre_match:

; 902  : 
; 903  :         case SRE_OP_ANY_ALL:
; 904  :             /* match anything */
; 905  :             /* <ANY_ALL> */
; 906  :             TRACE(("|%p|%p|ANY_ALL\n", ctx->pattern, ctx->ptr));
; 907  :             if (ctx->ptr >= end)

  00256	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  0025a	49 3b ce	 cmp	 rcx, r14
  0025d	0f 82 28 ff ff
	ff		 jb	 $LN653@sre_match

; 908  :                 RETURN_FAILURE;

  00263	e9 43 05 00 00	 jmp	 $LN30@sre_match
$LN652@sre_match:

; 909  :             ctx->ptr += state->charsize;
; 910  :             break;
; 911  : 
; 912  :         case SRE_OP_IN:
; 913  :             /* match set member (or non_member) */
; 914  :             /* <IN> <skip> <set> */
; 915  :             TRACE(("|%p|%p|IN\n", ctx->pattern, ctx->ptr));
; 916  :                 if (ctx->ptr >= end || !SRE_CHARSET(ctx->pattern + 1, SRE_CHARGET(state, ctx->ptr, 0)))

  00268	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0026c	49 3b c6	 cmp	 rax, r14
  0026f	0f 83 36 05 00
	00		 jae	 $LN30@sre_match
  00275	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00278	49 8d 49 04	 lea	 rcx, QWORD PTR [r9+4]
  0027c	e8 00 00 00 00	 call	 sre_charset
  00281	85 c0		 test	 eax, eax
  00283	0f 84 22 05 00
	00		 je	 $LN30@sre_match

; 917  :                     RETURN_FAILURE;
; 918  :             ctx->pattern += ctx->pattern[0];

  00289	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0028d	8b 01		 mov	 eax, DWORD PTR [rcx]
  0028f	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00293	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx

; 919  :             ctx->ptr += state->charsize;

  00297	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  0029c	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 920  :             break;

  002a0	e9 2d fe ff ff	 jmp	 $LN703@sre_match
$LN646@sre_match:

; 921  : 
; 922  :         case SRE_OP_LITERAL_IGNORE:
; 923  :             TRACE(("|%p|%p|LITERAL_IGNORE %d\n",
; 924  :                    ctx->pattern, ctx->ptr, ctx->pattern[0]));
; 925  :             if (ctx->ptr >= end ||
; 926  :                 state->lower(SRE_CHARGET(state, ctx->ptr, 0)) != state->lower(*ctx->pattern))

  002a5	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  002a9	49 3b c6	 cmp	 rax, r14
  002ac	0f 83 f9 04 00
	00		 jae	 $LN30@sre_match
  002b2	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  002b5	41 ff 94 24 00
	07 00 00	 call	 QWORD PTR [r12+1792]
  002bd	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  002c1	8b 09		 mov	 ecx, DWORD PTR [rcx]
  002c3	8b d8		 mov	 ebx, eax
  002c5	41 ff 94 24 00
	07 00 00	 call	 QWORD PTR [r12+1792]
  002cd	3b d8		 cmp	 ebx, eax
  002cf	0f 85 d6 04 00
	00		 jne	 $LN30@sre_match

; 927  :                 RETURN_FAILURE;
; 928  :             ctx->pattern++;

  002d5	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 929  :             ctx->ptr += state->charsize;

  002da	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  002df	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 930  :             break;

  002e3	e9 ea fd ff ff	 jmp	 $LN703@sre_match
$LN640@sre_match:

; 931  : 
; 932  :         case SRE_OP_NOT_LITERAL_IGNORE:
; 933  :             TRACE(("|%p|%p|NOT_LITERAL_IGNORE %d\n",
; 934  :                    ctx->pattern, ctx->ptr, *ctx->pattern));
; 935  :             if (ctx->ptr >= end ||
; 936  :                 state->lower(SRE_CHARGET(state, ctx->ptr, 0)) == state->lower(*ctx->pattern))

  002e8	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  002ec	49 3b c6	 cmp	 rax, r14
  002ef	0f 83 b6 04 00
	00		 jae	 $LN30@sre_match
  002f5	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  002f8	41 ff 94 24 00
	07 00 00	 call	 QWORD PTR [r12+1792]
  00300	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00304	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00306	8b d8		 mov	 ebx, eax
  00308	41 ff 94 24 00
	07 00 00	 call	 QWORD PTR [r12+1792]
  00310	3b d8		 cmp	 ebx, eax
  00312	0f 84 93 04 00
	00		 je	 $LN30@sre_match

; 937  :                 RETURN_FAILURE;
; 938  :             ctx->pattern++;

  00318	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 939  :             ctx->ptr += state->charsize;

  0031d	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  00322	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 940  :             break;

  00326	e9 a7 fd ff ff	 jmp	 $LN703@sre_match
$LN634@sre_match:

; 941  : 
; 942  :         case SRE_OP_IN_IGNORE:
; 943  :             TRACE(("|%p|%p|IN_IGNORE\n", ctx->pattern, ctx->ptr));
; 944  :             if (ctx->ptr >= end
; 945  :                 || !SRE_CHARSET(ctx->pattern+1,
; 946  :                                 (SRE_CODE)state->lower(SRE_CHARGET(state, ctx->ptr, 0))))

  0032b	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0032f	49 3b c6	 cmp	 rax, r14
  00332	0f 83 73 04 00
	00		 jae	 $LN30@sre_match
  00338	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0033b	41 ff 94 24 00
	07 00 00	 call	 QWORD PTR [r12+1792]
  00343	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00347	48 83 c1 04	 add	 rcx, 4
  0034b	8b d0		 mov	 edx, eax
  0034d	e8 00 00 00 00	 call	 sre_charset
  00352	85 c0		 test	 eax, eax
  00354	0f 84 51 04 00
	00		 je	 $LN30@sre_match

; 947  :                 RETURN_FAILURE;
; 948  :             ctx->pattern += ctx->pattern[0];

  0035a	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0035e	8b 01		 mov	 eax, DWORD PTR [rcx]
  00360	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00364	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx

; 949  :             ctx->ptr += state->charsize;

  00368	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  0036d	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 950  :             break;

  00371	e9 5c fd ff ff	 jmp	 $LN703@sre_match
$LN628@sre_match:

; 951  : 
; 952  :         case SRE_OP_JUMP:
; 953  :         case SRE_OP_INFO:
; 954  :             /* jump forward */
; 955  :             /* <JUMP> <offset> */
; 956  :             TRACE(("|%p|%p|JUMP %d\n", ctx->pattern,
; 957  :                    ctx->ptr, ctx->pattern[0]));
; 958  :             ctx->pattern += ctx->pattern[0];

  00376	41 8b 01	 mov	 eax, DWORD PTR [r9]
  00379	49 8d 0c 81	 lea	 rcx, QWORD PTR [r9+rax*4]

; 959  :             break;

  0037d	e9 4c fd ff ff	 jmp	 $LN816@sre_match
$LN626@sre_match:

; 960  : 
; 961  :         case SRE_OP_BRANCH:
; 962  :             /* alternation */
; 963  :             /* <BRANCH> <0=skip> code <JUMP> ... <NULL> */
; 964  :             TRACE(("|%p|%p|BRANCH\n", ctx->pattern, ctx->ptr));
; 965  :             LASTMARK_SAVE();

  00382	49 8b 5c 24 48	 mov	 rbx, QWORD PTR [r12+72]
  00387	48 89 5f 28	 mov	 QWORD PTR [rdi+40], rbx
  0038b	49 8b 44 24 40	 mov	 rax, QWORD PTR [r12+64]
  00390	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 966  :             ctx->u.rep = state->repeat;

  00394	49 8b 84 24 f8
	06 00 00	 mov	 rax, QWORD PTR [r12+1784]
  0039c	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 967  :             if (ctx->u.rep)

  003a0	48 85 c0	 test	 rax, rax
  003a3	0f 84 96 07 00
	00		 je	 $LN609@sre_match

; 968  :                 MARK_PUSH(ctx->lastmark);

  003a9	48 85 db	 test	 rbx, rbx
  003ac	0f 8e 8d 07 00
	00		 jle	 $LN609@sre_match
  003b2	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  003ba	48 8d 34 dd 08
	00 00 00	 lea	 rsi, QWORD PTR [rbx*8+8]
  003c2	49 2b 84 24 a0
	06 00 00	 sub	 rax, QWORD PTR [r12+1696]
  003ca	48 3b f0	 cmp	 rsi, rax
  003cd	76 26		 jbe	 SHORT $LN610@sre_match
  003cf	48 8b d6	 mov	 rdx, rsi
  003d2	49 8b cc	 mov	 rcx, r12
  003d5	e8 00 00 00 00	 call	 data_stack_grow
  003da	85 c0		 test	 eax, eax
  003dc	0f 88 13 10 00
	00		 js	 $LN791@sre_match
  003e2	49 83 fd ff	 cmp	 r13, -1
  003e6	74 0d		 je	 SHORT $LN610@sre_match
  003e8	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  003f0	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN610@sre_match:
  003f5	49 8b 8c 24 90
	06 00 00	 mov	 rcx, QWORD PTR [r12+1680]
  003fd	49 8d 54 24 50	 lea	 rdx, QWORD PTR [r12+80]
  00402	4c 8b c6	 mov	 r8, rsi
  00405	49 03 8c 24 a0
	06 00 00	 add	 rcx, QWORD PTR [r12+1696]
  0040d	e8 00 00 00 00	 call	 memcpy
  00412	4c 8d 1c dd 08
	00 00 00	 lea	 r11, QWORD PTR [rbx*8+8]
  0041a	4d 01 9c 24 a0
	06 00 00	 add	 QWORD PTR [r12+1696], r11

; 969  :             for (; ctx->pattern[0]; ctx->pattern += ctx->pattern[0]) {

  00422	e9 18 07 00 00	 jmp	 $LN609@sre_match
$LN550@sre_match:

; 993  : 
; 994  :         case SRE_OP_REPEAT_ONE:
; 995  :             /* match repeated sequence (maximizing regexp) */
; 996  : 
; 997  :             /* this operator only works if the repeated item is
; 998  :                exactly one character wide, and we're not already
; 999  :                collecting backtracking points.  for other cases,
; 1000 :                use the MAX_REPEAT operator */
; 1001 : 
; 1002 :             /* <REPEAT_ONE> <skip> <1=min> <2=max> item <SUCCESS> tail */
; 1003 : 
; 1004 :             TRACE(("|%p|%p|REPEAT_ONE %d %d\n", ctx->pattern, ctx->ptr,
; 1005 :                    ctx->pattern[1], ctx->pattern[2]));
; 1006 : 
; 1007 :             if ((Py_ssize_t) ctx->pattern[1] > (end - ctx->ptr) / state->charsize)

  00427	49 63 4c 24 3c	 movsxd	 rcx, DWORD PTR [r12+60]
  0042c	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00430	49 8b c6	 mov	 rax, r14
  00433	49 2b c0	 sub	 rax, r8
  00436	48 99		 cdq
  00438	48 f7 f9	 idiv	 rcx
  0043b	41 8b 49 04	 mov	 ecx, DWORD PTR [r9+4]
  0043f	48 3b c8	 cmp	 rcx, rax

; 1008 :                 RETURN_FAILURE; /* cannot match */

  00442	0f 8f 63 03 00
	00		 jg	 $LN30@sre_match

; 1009 : 
; 1010 :             state->ptr = ctx->ptr;

  00448	4d 89 04 24	 mov	 QWORD PTR [r12], r8

; 1011 : 
; 1012 :             ret = SRE_COUNT(state, ctx->pattern+3, ctx->pattern[2]);

  0044c	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00450	49 8b cc	 mov	 rcx, r12
  00453	44 8b 42 08	 mov	 r8d, DWORD PTR [rdx+8]
  00457	48 83 c2 0c	 add	 rdx, 12
  0045b	e8 00 00 00 00	 call	 sre_count

; 1013 :             RETURN_ON_ERROR(ret);

  00460	48 85 c0	 test	 rax, rax
  00463	0f 88 9d 0f 00
	00		 js	 $LN811@sre_match

; 1014 :             DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  00469	49 8b 8c 24 90
	06 00 00	 mov	 rcx, QWORD PTR [r12+1680]

; 1015 :             ctx->count = ret;

  00471	49 89 44 0d 20	 mov	 QWORD PTR [r13+rcx+32], rax

; 1016 :             ctx->ptr += state->charsize * ctx->count;
; 1017 : 
; 1018 :             /* when we arrive here, count contains the number of
; 1019 :                matches, and ctx->ptr points to the tail of the target
; 1020 :                string.  check if the rest of the pattern matches,
; 1021 :                and backtrack if not. */
; 1022 : 
; 1023 :             if (ctx->count < (Py_ssize_t) ctx->pattern[1])

  00476	49 8b 54 0d 18	 mov	 rdx, QWORD PTR [r13+rcx+24]
  0047b	49 8d 7c 0d 00	 lea	 rdi, QWORD PTR [r13+rcx]
  00480	49 63 4c 24 3c	 movsxd	 rcx, DWORD PTR [r12+60]
  00485	48 0f af c8	 imul	 rcx, rax
  00489	48 01 4f 10	 add	 QWORD PTR [rdi+16], rcx
  0048d	8b 4a 04	 mov	 ecx, DWORD PTR [rdx+4]
  00490	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00494	48 3b c1	 cmp	 rax, rcx

; 1024 :                 RETURN_FAILURE;

  00497	0f 8c 0e 03 00
	00		 jl	 $LN30@sre_match

; 1025 : 
; 1026 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_SUCCESS) {

  0049d	8b 02		 mov	 eax, DWORD PTR [rdx]
  0049f	83 3c 82 01	 cmp	 DWORD PTR [rdx+rax*4], 1
  004a3	75 0e		 jne	 SHORT $LN527@sre_match

; 1027 :                 /* tail is empty.  we're finished */
; 1028 :                 state->ptr = ctx->ptr;

  004a5	4d 89 04 24	 mov	 QWORD PTR [r12], r8

; 1029 :                 RETURN_SUCCESS;

  004a9	bb 01 00 00 00	 mov	 ebx, 1
  004ae	e9 fa 02 00 00	 jmp	 $exit$20915
$LN527@sre_match:

; 1030 :             }
; 1031 : 
; 1032 :             LASTMARK_SAVE();

  004b3	49 8b 44 24 48	 mov	 rax, QWORD PTR [r12+72]
  004b8	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  004bc	49 8b 44 24 40	 mov	 rax, QWORD PTR [r12+64]
  004c1	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1033 : 
; 1034 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_LITERAL) {

  004c5	8b 02		 mov	 eax, DWORD PTR [rdx]
  004c7	83 3c 82 13	 cmp	 DWORD PTR [rdx+rax*4], 19
  004cb	0f 85 b1 08 00
	00		 jne	 $LN490@sre_match

; 1035 :                 /* tail starts with a literal. skip positions where
; 1036 :                    the rest of the pattern cannot possibly match */
; 1037 :                 ctx->u.chr = ctx->pattern[ctx->pattern[0]+1];

  004d1	ff c0		 inc	 eax
  004d3	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  004d6	89 47 38	 mov	 DWORD PTR [rdi+56], eax
  004d9	e9 b5 07 00 00	 jmp	 $LN522@sre_match
$LN461@sre_match:

; 1074 :                 }
; 1075 :             }
; 1076 :             RETURN_FAILURE;
; 1077 : 
; 1078 :         case SRE_OP_MIN_REPEAT_ONE:
; 1079 :             /* match repeated sequence (minimizing regexp) */
; 1080 : 
; 1081 :             /* this operator only works if the repeated item is
; 1082 :                exactly one character wide, and we're not already
; 1083 :                collecting backtracking points.  for other cases,
; 1084 :                use the MIN_REPEAT operator */
; 1085 : 
; 1086 :             /* <MIN_REPEAT_ONE> <skip> <1=min> <2=max> item <SUCCESS> tail */
; 1087 : 
; 1088 :             TRACE(("|%p|%p|MIN_REPEAT_ONE %d %d\n", ctx->pattern, ctx->ptr,
; 1089 :                    ctx->pattern[1], ctx->pattern[2]));
; 1090 : 
; 1091 :             if ((Py_ssize_t) ctx->pattern[1] > (end - ctx->ptr) / state->charsize)

  004de	49 63 4c 24 3c	 movsxd	 rcx, DWORD PTR [r12+60]
  004e3	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  004e7	49 8b c6	 mov	 rax, r14
  004ea	49 2b c0	 sub	 rax, r8
  004ed	48 99		 cdq
  004ef	48 f7 f9	 idiv	 rcx
  004f2	41 8b 49 04	 mov	 ecx, DWORD PTR [r9+4]
  004f6	48 3b c8	 cmp	 rcx, rax

; 1092 :                 RETURN_FAILURE; /* cannot match */

  004f9	0f 8f ac 02 00
	00		 jg	 $LN30@sre_match

; 1093 : 
; 1094 :             state->ptr = ctx->ptr;

  004ff	4d 89 04 24	 mov	 QWORD PTR [r12], r8

; 1095 : 
; 1096 :             if (ctx->pattern[1] == 0)

  00503	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00507	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  0050a	85 c0		 test	 eax, eax
  0050c	75 0a		 jne	 SHORT $LN455@sre_match

; 1097 :                 ctx->count = 0;

  0050e	48 c7 47 20 00
	00 00 00	 mov	 QWORD PTR [rdi+32], 0

; 1098 :             else {

  00516	eb 4a		 jmp	 SHORT $LN454@sre_match
$LN455@sre_match:

; 1099 :                 /* count using pattern min as the maximum */
; 1100 :                 ret = SRE_COUNT(state, ctx->pattern+3, ctx->pattern[1]);

  00518	4c 8b c0	 mov	 r8, rax
  0051b	48 83 c2 0c	 add	 rdx, 12
  0051f	49 8b cc	 mov	 rcx, r12
  00522	e8 00 00 00 00	 call	 sre_count
  00527	4c 8b d8	 mov	 r11, rax

; 1101 :                 RETURN_ON_ERROR(ret);

  0052a	48 85 c0	 test	 rax, rax
  0052d	0f 88 d3 0e 00
	00		 js	 $LN811@sre_match

; 1102 :                 DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  00533	49 8b 8c 24 90
	06 00 00	 mov	 rcx, QWORD PTR [r12+1680]
  0053b	49 8d 7c 0d 00	 lea	 rdi, QWORD PTR [r13+rcx]

; 1103 :                 if (ret < (Py_ssize_t) ctx->pattern[1])

  00540	49 8b 4c 0d 18	 mov	 rcx, QWORD PTR [r13+rcx+24]
  00545	8b 51 04	 mov	 edx, DWORD PTR [rcx+4]
  00548	48 3b c2	 cmp	 rax, rdx

; 1104 :                     /* didn't match minimum number of times */
; 1105 :                     RETURN_FAILURE;

  0054b	0f 8c 5a 02 00
	00		 jl	 $LN30@sre_match

; 1106 :                 /* advance past minimum matches of repeat */
; 1107 :                 ctx->count = ret;

  00551	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 1108 :                 ctx->ptr += state->charsize * ctx->count;

  00555	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  0055a	49 0f af c3	 imul	 rax, r11
  0055e	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
$LN454@sre_match:

; 1109 :             }
; 1110 : 
; 1111 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_SUCCESS) {

  00562	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00566	8b 01		 mov	 eax, DWORD PTR [rcx]
  00568	83 3c 81 01	 cmp	 DWORD PTR [rcx+rax*4], 1
  0056c	75 12		 jne	 SHORT $LN434@sre_match
$LN678@sre_match:

; 1112 :                 /* tail is empty.  we're finished */
; 1113 :                 state->ptr = ctx->ptr;

  0056e	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1114 :                 RETURN_SUCCESS;

  00572	bb 01 00 00 00	 mov	 ebx, 1
  00577	49 89 04 24	 mov	 QWORD PTR [r12], rax
  0057b	e9 2d 02 00 00	 jmp	 $exit$20915
$LN434@sre_match:

; 1115 : 
; 1116 :             } else {
; 1117 :                 /* general case */
; 1118 :                 LASTMARK_SAVE();

  00580	49 8b 44 24 48	 mov	 rax, QWORD PTR [r12+72]
  00585	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  00589	49 8b 44 24 40	 mov	 rax, QWORD PTR [r12+64]
  0058e	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
  00592	e9 ff 08 00 00	 jmp	 $LN431@sre_match
$LN390@sre_match:

; 1138 :                 }
; 1139 :             }
; 1140 :             RETURN_FAILURE;
; 1141 : 
; 1142 :         case SRE_OP_REPEAT:
; 1143 :             /* create repeat context.  all the hard work is done
; 1144 :                by the UNTIL operator (MAX_UNTIL, MIN_UNTIL) */
; 1145 :             /* <REPEAT> <skip> <1=min> <2=max> item <UNTIL> tail */
; 1146 :             TRACE(("|%p|%p|REPEAT %d %d\n", ctx->pattern, ctx->ptr,
; 1147 :                    ctx->pattern[1], ctx->pattern[2]));
; 1148 : 
; 1149 :             /* install new repeat context */
; 1150 :             ctx->u.rep = (SRE_REPEAT*) PyObject_MALLOC(sizeof(*ctx->u.rep));

  00597	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0059c	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  005a1	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1151 :             if (!ctx->u.rep) {

  005a5	48 85 c0	 test	 rax, rax
  005a8	0f 85 a8 09 00
	00		 jne	 $LN385@sre_match

; 1152 :                 PyErr_NoMemory();

  005ae	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1153 :                 RETURN_FAILURE;

  005b3	e9 f3 01 00 00	 jmp	 $LN30@sre_match
$LN127@sre_match:

; 1301 : 
; 1302 :         case SRE_OP_GROUPREF:
; 1303 :             /* match backreference */
; 1304 :             TRACE(("|%p|%p|GROUPREF %d\n", ctx->pattern,
; 1305 :                    ctx->ptr, ctx->pattern[0]));
; 1306 :             i = ctx->pattern[0];
; 1307 :             {
; 1308 :                 Py_ssize_t groupref = i+i;

  005b8	41 8b 01	 mov	 eax, DWORD PTR [r9]
  005bb	48 03 c0	 add	 rax, rax

; 1309 :                 if (groupref >= state->lastmark) {

  005be	49 3b 44 24 48	 cmp	 rax, QWORD PTR [r12+72]

; 1310 :                     RETURN_FAILURE;

  005c3	0f 8d e2 01 00
	00		 jge	 $LN30@sre_match

; 1311 :                 } else {
; 1312 :                     char* p = (char*) state->mark[groupref];

  005c9	49 8b 54 c4 50	 mov	 rdx, QWORD PTR [r12+rax*8+80]

; 1313 :                     char* e = (char*) state->mark[groupref+1];

  005ce	4d 8b 44 c4 58	 mov	 r8, QWORD PTR [r12+rax*8+88]

; 1314 :                     if (!p || !e || e < p)

  005d3	48 85 d2	 test	 rdx, rdx
  005d6	0f 84 cf 01 00
	00		 je	 $LN30@sre_match
  005dc	4d 85 c0	 test	 r8, r8
  005df	0f 84 c6 01 00
	00		 je	 $LN30@sre_match
  005e5	49 3b d0	 cmp	 rdx, r8
  005e8	0f 87 bd 01 00
	00		 ja	 $LN30@sre_match

; 1315 :                         RETURN_FAILURE;
; 1316 :                     while (p < e) {

  005ee	73 2c		 jae	 SHORT $LN114@sre_match
$LL115@sre_match:

; 1317 :                         if (ctx->ptr >= end ||
; 1318 :                             SRE_CHARGET(state, ctx->ptr, 0) != SRE_CHARGET(state, p, 0))

  005f0	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  005f4	49 3b ce	 cmp	 rcx, r14
  005f7	0f 83 ae 01 00
	00		 jae	 $LN30@sre_match
  005fd	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00600	38 01		 cmp	 BYTE PTR [rcx], al
  00602	0f 85 a3 01 00
	00		 jne	 $LN30@sre_match

; 1319 :                             RETURN_FAILURE;
; 1320 :                         p += state->charsize;

  00608	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  0060d	48 03 d0	 add	 rdx, rax

; 1321 :                         ctx->ptr += state->charsize;

  00610	48 03 c1	 add	 rax, rcx
  00613	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  00617	49 3b d0	 cmp	 rdx, r8
  0061a	72 d4		 jb	 SHORT $LL115@sre_match
$LN114@sre_match:

; 1322 :                     }
; 1323 :                 }
; 1324 :             }
; 1325 :             ctx->pattern++;

  0061c	49 8d 41 04	 lea	 rax, QWORD PTR [r9+4]
  00620	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 1326 :             break;

  00624	e9 a9 fa ff ff	 jmp	 $LN703@sre_match
$LN108@sre_match:

; 1327 : 
; 1328 :         case SRE_OP_GROUPREF_IGNORE:
; 1329 :             /* match backreference */
; 1330 :             TRACE(("|%p|%p|GROUPREF_IGNORE %d\n", ctx->pattern,
; 1331 :                    ctx->ptr, ctx->pattern[0]));
; 1332 :             i = ctx->pattern[0];
; 1333 :             {
; 1334 :                 Py_ssize_t groupref = i+i;

  00629	41 8b 01	 mov	 eax, DWORD PTR [r9]
  0062c	48 03 c0	 add	 rax, rax

; 1335 :                 if (groupref >= state->lastmark) {

  0062f	49 3b 44 24 48	 cmp	 rax, QWORD PTR [r12+72]

; 1336 :                     RETURN_FAILURE;

  00634	0f 8d 71 01 00
	00		 jge	 $LN30@sre_match

; 1337 :                 } else {
; 1338 :                     char* p = (char*) state->mark[groupref];

  0063a	49 8b 74 c4 50	 mov	 rsi, QWORD PTR [r12+rax*8+80]

; 1339 :                     char* e = (char*) state->mark[groupref+1];

  0063f	49 8b 6c c4 58	 mov	 rbp, QWORD PTR [r12+rax*8+88]

; 1340 :                     if (!p || !e || e < p)

  00644	48 85 f6	 test	 rsi, rsi
  00647	0f 84 dd 05 00
	00		 je	 $LN557@sre_match
  0064d	48 85 ed	 test	 rbp, rbp
  00650	0f 84 d4 05 00
	00		 je	 $LN557@sre_match
  00656	48 3b f5	 cmp	 rsi, rbp
  00659	0f 87 cb 05 00
	00		 ja	 $LN557@sre_match

; 1341 :                         RETURN_FAILURE;
; 1342 :                     while (p < e) {

  0065f	73 3e		 jae	 SHORT $LN96@sre_match
$LL97@sre_match:

; 1343 :                         if (ctx->ptr >= end ||
; 1344 :                             state->lower(SRE_CHARGET(state, ctx->ptr, 0)) !=
; 1345 :                             state->lower(SRE_CHARGET(state, p, 0)))

  00661	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00665	49 3b c6	 cmp	 rax, r14
  00668	0f 83 bc 05 00
	00		 jae	 $LN557@sre_match
  0066e	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00671	41 ff 94 24 00
	07 00 00	 call	 QWORD PTR [r12+1792]
  00679	0f b6 0e	 movzx	 ecx, BYTE PTR [rsi]
  0067c	8b d8		 mov	 ebx, eax
  0067e	41 ff 94 24 00
	07 00 00	 call	 QWORD PTR [r12+1792]
  00686	3b d8		 cmp	 ebx, eax
  00688	0f 85 9c 05 00
	00		 jne	 $LN557@sre_match

; 1346 :                             RETURN_FAILURE;
; 1347 :                         p += state->charsize;

  0068e	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]

; 1348 :                         ctx->ptr += state->charsize;

  00693	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  00697	48 03 f0	 add	 rsi, rax
  0069a	48 3b f5	 cmp	 rsi, rbp
  0069d	72 c2		 jb	 SHORT $LL97@sre_match
$LN96@sre_match:

; 1349 :                     }
; 1350 :                 }
; 1351 :             }
; 1352 :             ctx->pattern++;

  0069f	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 1353 :             break;

  006a4	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  006ab	e9 22 fa ff ff	 jmp	 $LN703@sre_match
$LN90@sre_match:

; 1354 : 
; 1355 :         case SRE_OP_GROUPREF_EXISTS:
; 1356 :             TRACE(("|%p|%p|GROUPREF_EXISTS %d\n", ctx->pattern,
; 1357 :                    ctx->ptr, ctx->pattern[0]));
; 1358 :             /* <GROUPREF_EXISTS> <group> <skip> codeyes <JUMP> codeno ... */
; 1359 :             i = ctx->pattern[0];
; 1360 :             {
; 1361 :                 Py_ssize_t groupref = i+i;

  006b0	41 8b 01	 mov	 eax, DWORD PTR [r9]
  006b3	48 03 c0	 add	 rax, rax

; 1362 :                 if (groupref >= state->lastmark) {

  006b6	49 3b 44 24 48	 cmp	 rax, QWORD PTR [r12+72]
  006bb	7c 0d		 jl	 SHORT $LN89@sre_match
$LN86@sre_match:

; 1363 :                     ctx->pattern += ctx->pattern[1];

  006bd	41 8b 41 04	 mov	 eax, DWORD PTR [r9+4]
  006c1	49 8d 0c 81	 lea	 rcx, QWORD PTR [r9+rax*4]

; 1364 :                     break;

  006c5	e9 04 fa ff ff	 jmp	 $LN816@sre_match
$LN89@sre_match:

; 1365 :                 } else {
; 1366 :                     SRE_CHAR* p = (SRE_CHAR*) state->mark[groupref];

  006ca	49 8b 54 c4 50	 mov	 rdx, QWORD PTR [r12+rax*8+80]

; 1367 :                     SRE_CHAR* e = (SRE_CHAR*) state->mark[groupref+1];

  006cf	49 8b 4c c4 58	 mov	 rcx, QWORD PTR [r12+rax*8+88]

; 1368 :                     if (!p || !e || e < p) {

  006d4	48 85 d2	 test	 rdx, rdx
  006d7	74 e4		 je	 SHORT $LN86@sre_match
  006d9	48 85 c9	 test	 rcx, rcx
  006dc	74 df		 je	 SHORT $LN86@sre_match
  006de	48 3b ca	 cmp	 rcx, rdx
  006e1	72 da		 jb	 SHORT $LN86@sre_match

; 1369 :                         ctx->pattern += ctx->pattern[1];
; 1370 :                         break;
; 1371 :                     }
; 1372 :                 }
; 1373 :             }
; 1374 :             ctx->pattern += 2;

  006e3	49 8d 41 08	 lea	 rax, QWORD PTR [r9+8]
  006e7	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 1375 :             break;

  006eb	e9 e2 f9 ff ff	 jmp	 $LN703@sre_match
$LN85@sre_match:

; 1376 : 
; 1377 :         case SRE_OP_ASSERT:
; 1378 :             /* assert subpattern */
; 1379 :             /* <ASSERT> <skip> <back> <pattern> */
; 1380 :             TRACE(("|%p|%p|ASSERT %d\n", ctx->pattern,
; 1381 :                    ctx->ptr, ctx->pattern[1]));
; 1382 :             state->ptr = ctx->ptr - state->charsize * ctx->pattern[1];

  006f0	41 8b 49 04	 mov	 ecx, DWORD PTR [r9+4]
  006f4	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  006f8	41 0f af 4c 24
	3c		 imul	 ecx, DWORD PTR [r12+60]
  006fe	48 2b c1	 sub	 rax, rcx
  00701	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 1383 :             if (state->ptr < state->beginning)

  00705	49 3b 44 24 08	 cmp	 rax, QWORD PTR [r12+8]
  0070a	0f 82 9b 00 00
	00		 jb	 $LN30@sre_match

; 1384 :                 RETURN_FAILURE;
; 1385 :             DO_JUMP(JUMP_ASSERT, jump_assert, ctx->pattern+2);

  00710	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  00718	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  00720	48 2b c3	 sub	 rax, rbx
  00723	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00727	73 28		 jae	 SHORT $LN72@sre_match
  00729	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0072e	49 8b cc	 mov	 rcx, r12
  00731	e8 00 00 00 00	 call	 data_stack_grow
  00736	85 c0		 test	 eax, eax
  00738	0f 88 b7 0c 00
	00		 js	 $LN791@sre_match
  0073e	49 83 fd ff	 cmp	 r13, -1
  00742	74 0d		 je	 SHORT $LN72@sre_match
  00744	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  0074c	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN72@sre_match:
  00751	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00759	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  00762	48 c7 44 03 08
	0c 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 12
  0076b	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  0076f	e9 ff 08 00 00	 jmp	 $LN817@sre_match
$LN55@sre_match:

; 1387 :             ctx->pattern += ctx->pattern[0];
; 1388 :             break;
; 1389 : 
; 1390 :         case SRE_OP_ASSERT_NOT:
; 1391 :             /* assert not subpattern */
; 1392 :             /* <ASSERT_NOT> <skip> <back> <pattern> */
; 1393 :             TRACE(("|%p|%p|ASSERT_NOT %d\n", ctx->pattern,
; 1394 :                    ctx->ptr, ctx->pattern[1]));
; 1395 :             state->ptr = ctx->ptr - state->charsize * ctx->pattern[1];

  00774	41 8b 49 04	 mov	 ecx, DWORD PTR [r9+4]
  00778	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0077c	41 0f af 4c 24
	3c		 imul	 ecx, DWORD PTR [r12+60]
  00782	48 2b c1	 sub	 rax, rcx
  00785	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 1396 :             if (state->ptr >= state->beginning) {

  00789	49 3b 44 24 08	 cmp	 rax, QWORD PTR [r12+8]
  0078e	0f 83 80 08 00
	00		 jae	 $LN781@sre_match
$LN32@sre_match:

; 1400 :                     RETURN_FAILURE;
; 1401 :                 }
; 1402 :             }
; 1403 :             ctx->pattern += ctx->pattern[0];

  00794	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00798	8b 01		 mov	 eax, DWORD PTR [rcx]
  0079a	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]

; 1415 :         }
; 1416 :     }

  0079e	e9 2b f9 ff ff	 jmp	 $LN816@sre_match
$LN820@sre_match:

; 1299 :             state->ptr = ctx->ptr;

  007a3	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  007a7	49 89 04 24	 mov	 QWORD PTR [r12], rax
$LN30@sre_match:

; 1404 :             break;
; 1405 : 
; 1406 :         case SRE_OP_FAILURE:
; 1407 :             /* immediate failure */
; 1408 :             TRACE(("|%p|%p|FAILURE\n", ctx->pattern, ctx->ptr));
; 1409 :             RETURN_FAILURE;

  007ab	33 db		 xor	 ebx, ebx
$exit$20915:

; 1417 : 
; 1418 : exit:
; 1419 :     ctx_pos = ctx->last_ctx_pos;

  007ad	4c 8b 2f	 mov	 r13, QWORD PTR [rdi]

; 1420 :     jump = ctx->jump;

  007b0	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]

; 1421 :     DATA_POP_DISCARD(ctx);

  007b4	49 83 84 24 a0
	06 00 00 c0	 add	 QWORD PTR [r12+1696], -64 ; ffffffffffffffc0H
  007bd	49 8b 94 24 a0
	06 00 00	 mov	 rdx, QWORD PTR [r12+1696]

; 1422 :     if (ctx_pos == -1)

  007c5	49 83 fd ff	 cmp	 r13, -1
  007c9	0f 84 7f 07 00
	00		 je	 $LN761@sre_match

; 1424 :     DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  007cf	49 8b 8c 24 90
	06 00 00	 mov	 rcx, QWORD PTR [r12+1680]

; 1425 : 
; 1426 :     switch (jump) {

  007d7	48 ff c8	 dec	 rax
  007da	4a 8d 3c 29	 lea	 rdi, QWORD PTR [rcx+r13]
  007de	48 83 f8 0c	 cmp	 rax, 12
  007e2	0f 87 66 07 00
	00		 ja	 $LN761@sre_match
  007e8	8b 84 86 00 00
	00 00		 mov	 eax, DWORD PTR $LN806@sre_match[rsi+rax*4]
  007ef	48 03 c6	 add	 rax, rsi
  007f2	ff e0		 jmp	 rax
$jump_max_until_2$21448:

; 1217 :                 DATA_POP(&ctx->u.rep->last_ptr);

  007f4	48 8d 54 11 f8	 lea	 rdx, QWORD PTR [rcx+rdx-8]
  007f9	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  007fd	41 b8 08 00 00
	00		 mov	 r8d, 8
  00803	48 83 c1 10	 add	 rcx, 16
  00807	e8 00 00 00 00	 call	 memcpy
  0080c	49 83 84 24 a0
	06 00 00 f8	 add	 QWORD PTR [r12+1696], -8
  00815	49 8b 94 24 a0
	06 00 00	 mov	 rdx, QWORD PTR [r12+1696]

; 1218 :                 if (ret) {

  0081d	48 85 db	 test	 rbx, rbx
  00820	0f 85 a0 02 00
	00		 jne	 $LN825@sre_match

; 1219 :                     MARK_POP_DISCARD(ctx->lastmark);
; 1220 :                     RETURN_ON_ERROR(ret);
; 1221 :                     RETURN_SUCCESS;
; 1222 :                 }
; 1223 :                 MARK_POP(ctx->lastmark);

  00826	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0082a	48 85 c9	 test	 rcx, rcx
  0082d	7e 3c		 jle	 SHORT $LN262@sre_match
  0082f	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00837	48 c1 e1 03	 shl	 rcx, 3
  0083b	48 2b c1	 sub	 rax, rcx
  0083e	4c 8d 41 08	 lea	 r8, QWORD PTR [rcx+8]
  00842	49 8d 4c 24 50	 lea	 rcx, QWORD PTR [r12+80]
  00847	48 8d 54 10 f8	 lea	 rdx, QWORD PTR [rax+rdx-8]
  0084c	e8 00 00 00 00	 call	 memcpy
  00851	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00855	48 c7 c0 f8 ff
	ff ff		 mov	 rax, -8
  0085c	48 c1 e1 03	 shl	 rcx, 3
  00860	48 2b c1	 sub	 rax, rcx
  00863	49 01 84 24 a0
	06 00 00	 add	 QWORD PTR [r12+1696], rax
$LN262@sre_match:

; 1224 :                 LASTMARK_RESTORE();

  0086b	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  0086f	49 89 44 24 48	 mov	 QWORD PTR [r12+72], rax
  00874	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00878	49 89 44 24 40	 mov	 QWORD PTR [r12+64], rax

; 1225 :                 ctx->u.rep->count = ctx->count-1;

  0087d	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00881	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00885	48 ff c9	 dec	 rcx
  00888	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1226 :                 state->ptr = ctx->ptr;

  0088b	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0088f	49 89 04 24	 mov	 QWORD PTR [r12], rax
$LN328@sre_match:

; 1227 :             }
; 1228 : 
; 1229 :             /* cannot match more repeated items here.  make sure the
; 1230 :                tail matches */
; 1231 :             state->repeat = ctx->u.rep->prev;

  00893	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1232 :             DO_JUMP(JUMP_MAX_UNTIL_3, jump_max_until_3, ctx->pattern);

  00897	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  0089f	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  008a3	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  008ab	48 2b c3	 sub	 rax, rbx
  008ae	49 89 8c 24 f8
	06 00 00	 mov	 QWORD PTR [r12+1784], rcx
  008b6	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  008ba	73 28		 jae	 SHORT $LN249@sre_match
  008bc	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  008c1	49 8b cc	 mov	 rcx, r12
  008c4	e8 00 00 00 00	 call	 data_stack_grow
  008c9	85 c0		 test	 eax, eax
  008cb	0f 88 24 0b 00
	00		 js	 $LN791@sre_match
  008d1	49 83 fd ff	 cmp	 r13, -1
  008d5	74 0d		 je	 SHORT $LN249@sre_match
  008d7	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  008df	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN249@sre_match:
  008e4	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  008ec	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  008f5	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  008f9	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  008fd	4c 8b eb	 mov	 r13, rbx
  00900	48 c7 41 08 03
	00 00 00	 mov	 QWORD PTR [rcx+8], 3
  00908	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  0090c	48 8b f9	 mov	 rdi, rcx
  0090f	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  00913	e9 78 f7 ff ff	 jmp	 $entrance$20908
$jump_max_until_3$21504:

; 1233 :             RETURN_ON_SUCCESS(ret);

  00918	48 85 db	 test	 rbx, rbx
  0091b	0f 88 2d 06 00
	00		 js	 $LN761@sre_match
  00921	0f 8f c4 01 00
	00		 jg	 $LN822@sre_match

; 1234 :             state->repeat = ctx->u.rep;

  00927	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  0092b	49 89 84 24 f8
	06 00 00	 mov	 QWORD PTR [r12+1784], rax

; 1235 :             state->ptr = ctx->ptr;
; 1236 :             RETURN_FAILURE;

  00933	e9 6b fe ff ff	 jmp	 $LN820@sre_match
$jump_min_until_2$21583:

; 1272 :             if (ret) {

  00938	48 85 db	 test	 rbx, rbx

; 1273 :                 RETURN_ON_ERROR(ret);
; 1274 :                 RETURN_SUCCESS;

  0093b	0f 85 a4 01 00
	00		 jne	 $LN821@sre_match

; 1275 :             }
; 1276 : 
; 1277 :             state->repeat = ctx->u.rep;

  00941	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00945	49 89 84 24 f8
	06 00 00	 mov	 QWORD PTR [r12+1784], rax

; 1278 :             state->ptr = ctx->ptr;

  0094d	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00951	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 1279 : 
; 1280 :             LASTMARK_RESTORE();

  00955	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00959	49 89 44 24 48	 mov	 QWORD PTR [r12+72], rax
  0095e	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00962	49 89 44 24 40	 mov	 QWORD PTR [r12+64], rax

; 1281 : 
; 1282 :             if ((ctx->count >= (Py_ssize_t) ctx->u.rep->pattern[2]
; 1283 :                 && ctx->u.rep->pattern[2] != SRE_MAXREPEAT) ||
; 1284 :                 state->ptr == ctx->u.rep->last_ptr)

  00967	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  0096b	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0096f	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00972	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00976	7c 09		 jl	 SHORT $LN168@sre_match
  00978	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  0097b	0f 85 2a fe ff
	ff		 jne	 $LN30@sre_match
$LN168@sre_match:
  00981	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  00985	49 39 04 24	 cmp	 QWORD PTR [r12], rax
  00989	0f 84 1c fe ff
	ff		 je	 $LN30@sre_match

; 1285 :                 RETURN_FAILURE;
; 1286 : 
; 1287 :             ctx->u.rep->count = ctx->count;

  0098f	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00993	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00997	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1288 :             /* zero-width match protection */
; 1289 :             DATA_PUSH(&ctx->u.rep->last_ptr);

  0099a	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  009a2	49 2b 84 24 a0
	06 00 00	 sub	 rax, QWORD PTR [r12+1696]
  009aa	48 83 f8 08	 cmp	 rax, 8
  009ae	73 22		 jae	 SHORT $LN156@sre_match
  009b0	ba 08 00 00 00	 mov	 edx, 8
  009b5	49 8b cc	 mov	 rcx, r12
  009b8	e8 00 00 00 00	 call	 data_stack_grow
  009bd	85 c0		 test	 eax, eax
  009bf	0f 88 30 0a 00
	00		 js	 $LN791@sre_match
  009c5	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  009cd	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN156@sre_match:
  009d2	49 8b 8c 24 a0
	06 00 00	 mov	 rcx, QWORD PTR [r12+1696]
  009da	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  009de	41 b8 08 00 00
	00		 mov	 r8d, 8
  009e4	49 03 8c 24 90
	06 00 00	 add	 rcx, QWORD PTR [r12+1680]
  009ec	48 83 c2 10	 add	 rdx, 16
  009f0	e8 00 00 00 00	 call	 memcpy
  009f5	49 83 84 24 a0
	06 00 00 08	 add	 QWORD PTR [r12+1696], 8

; 1290 :             ctx->u.rep->last_ptr = state->ptr;

  009fe	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  00a02	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00a06	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  00a0a	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  00a12	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  00a1a	48 2b c3	 sub	 rax, rbx
  00a1d	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00a21	73 22		 jae	 SHORT $LN147@sre_match
  00a23	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00a28	49 8b cc	 mov	 rcx, r12
  00a2b	e8 00 00 00 00	 call	 data_stack_grow
  00a30	85 c0		 test	 eax, eax
  00a32	0f 88 bd 09 00
	00		 js	 $LN791@sre_match
  00a38	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00a40	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN147@sre_match:
  00a45	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00a4d	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  00a56	48 c7 44 03 08
	06 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 6
  00a5f	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
$LN819@sre_match:
  00a63	4c 89 2a	 mov	 QWORD PTR [rdx], r13
  00a66	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00a6a	4c 8b eb	 mov	 r13, rbx
  00a6d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00a71	48 8b fa	 mov	 rdi, rdx
  00a74	48 83 c1 0c	 add	 rcx, 12
  00a78	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00a7c	e9 0f f6 ff ff	 jmp	 $entrance$20908
$jump_min_until_3$21635:

; 1293 :             DATA_POP(&ctx->u.rep->last_ptr);

  00a81	48 8d 54 11 f8	 lea	 rdx, QWORD PTR [rcx+rdx-8]
  00a86	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00a8a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00a90	48 83 c1 10	 add	 rcx, 16
  00a94	e8 00 00 00 00	 call	 memcpy
  00a99	49 83 84 24 a0
	06 00 00 f8	 add	 QWORD PTR [r12+1696], -8

; 1294 :             if (ret) {

  00aa2	48 85 db	 test	 rbx, rbx

; 1295 :                 RETURN_ON_ERROR(ret);
; 1296 :                 RETURN_SUCCESS;

  00aa5	75 3e		 jne	 SHORT $LN821@sre_match
$LN130@sre_match:

; 1297 :             }
; 1298 :             ctx->u.rep->count = ctx->count-1;

  00aa7	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00aab	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00aaf	48 ff c9	 dec	 rcx
  00ab2	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1300 :             RETURN_FAILURE;

  00ab5	e9 e9 fc ff ff	 jmp	 $LN820@sre_match
$jump_branch$21060:

; 980  :                 if (ret) {

  00aba	48 85 db	 test	 rbx, rbx
  00abd	74 36		 je	 SHORT $LN573@sre_match

; 981  :                     if (ctx->u.rep)

  00abf	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  00ac4	74 1c		 je	 SHORT $LN587@sre_match
$LN825@sre_match:

; 982  :                         MARK_POP_DISCARD(ctx->lastmark);

  00ac6	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00aca	48 85 c0	 test	 rax, rax
  00acd	7e 13		 jle	 SHORT $LN587@sre_match
  00acf	48 c1 e0 03	 shl	 rax, 3
  00ad3	48 2b d0	 sub	 rdx, rax
  00ad6	48 83 ea 08	 sub	 rdx, 8
  00ada	49 89 94 24 a0
	06 00 00	 mov	 QWORD PTR [r12+1696], rdx
$LN587@sre_match:

; 983  :                     RETURN_ON_ERROR(ret);

  00ae2	48 85 db	 test	 rbx, rbx
$LN821@sre_match:
  00ae5	0f 88 63 04 00
	00		 js	 $LN761@sre_match
$LN822@sre_match:

; 984  :                     RETURN_SUCCESS;

  00aeb	bb 01 00 00 00	 mov	 ebx, 1
  00af0	e9 b8 fc ff ff	 jmp	 $exit$20915
$LN573@sre_match:

; 985  :                 }
; 986  :                 if (ctx->u.rep)

  00af5	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  00afa	74 23		 je	 SHORT $LN569@sre_match

; 987  :                     MARK_POP_KEEP(ctx->lastmark);

  00afc	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00b00	48 85 c0	 test	 rax, rax
  00b03	7e 1a		 jle	 SHORT $LN569@sre_match
  00b05	48 c1 e0 03	 shl	 rax, 3
  00b09	48 2b c8	 sub	 rcx, rax
  00b0c	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  00b10	48 8d 54 11 f8	 lea	 rdx, QWORD PTR [rcx+rdx-8]
  00b15	49 8d 4c 24 50	 lea	 rcx, QWORD PTR [r12+80]
  00b1a	e8 00 00 00 00	 call	 memcpy
$LN569@sre_match:

; 988  :                 LASTMARK_RESTORE();

  00b1f	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00b23	49 89 44 24 48	 mov	 QWORD PTR [r12+72], rax
  00b28	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00b2c	49 89 44 24 40	 mov	 QWORD PTR [r12+64], rax
$LN608@sre_match:

; 969  :             for (; ctx->pattern[0]; ctx->pattern += ctx->pattern[0]) {

  00b31	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00b35	8b 01		 mov	 eax, DWORD PTR [rcx]
  00b37	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00b3b	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx
$LN609@sre_match:
  00b3f	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00b43	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00b46	0f 84 b8 00 00
	00		 je	 $LN607@sre_match

; 970  :                 if (ctx->pattern[1] == SRE_OP_LITERAL &&
; 971  :                     (ctx->ptr >= end ||
; 972  :                      (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) != ctx->pattern[2]))

  00b4c	8b 51 04	 mov	 edx, DWORD PTR [rcx+4]
  00b4f	83 fa 13	 cmp	 edx, 19
  00b52	75 11		 jne	 SHORT $LN606@sre_match
  00b54	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00b58	49 3b c6	 cmp	 rax, r14
  00b5b	73 d4		 jae	 SHORT $LN608@sre_match
  00b5d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b60	3b 41 08	 cmp	 eax, DWORD PTR [rcx+8]

; 973  :                     continue;

  00b63	75 cc		 jne	 SHORT $LN608@sre_match
$LN606@sre_match:

; 974  :                 if (ctx->pattern[1] == SRE_OP_IN &&
; 975  :                     (ctx->ptr >= end ||
; 976  :                      !SRE_CHARSET(ctx->pattern + 3, (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0))))

  00b65	83 fa 0f	 cmp	 edx, 15
  00b68	75 19		 jne	 SHORT $LN604@sre_match
  00b6a	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00b6e	49 3b c6	 cmp	 rax, r14
  00b71	73 be		 jae	 SHORT $LN608@sre_match
  00b73	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00b76	48 83 c1 0c	 add	 rcx, 12
  00b7a	e8 00 00 00 00	 call	 sre_charset
  00b7f	85 c0		 test	 eax, eax
  00b81	74 ae		 je	 SHORT $LN608@sre_match
$LN604@sre_match:

; 977  :                     continue;
; 978  :                 state->ptr = ctx->ptr;

  00b83	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 979  :                 DO_JUMP(JUMP_BRANCH, jump_branch, ctx->pattern+1);

  00b87	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  00b8f	49 89 04 24	 mov	 QWORD PTR [r12], rax
  00b93	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  00b9b	48 2b c3	 sub	 rax, rbx
  00b9e	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00ba2	73 28		 jae	 SHORT $LN594@sre_match
  00ba4	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00ba9	49 8b cc	 mov	 rcx, r12
  00bac	e8 00 00 00 00	 call	 data_stack_grow
  00bb1	85 c0		 test	 eax, eax
  00bb3	0f 88 3c 08 00
	00		 js	 $LN791@sre_match
  00bb9	49 83 fd ff	 cmp	 r13, -1
  00bbd	74 0d		 je	 SHORT $LN594@sre_match
  00bbf	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00bc7	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN594@sre_match:
  00bcc	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00bd4	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  00bdd	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  00be1	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  00be5	4c 8b eb	 mov	 r13, rbx
  00be8	48 c7 41 08 0b
	00 00 00	 mov	 QWORD PTR [rcx+8], 11
  00bf0	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00bf4	48 8b f9	 mov	 rdi, rcx
  00bf7	48 83 c0 04	 add	 rax, 4
  00bfb	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  00bff	e9 7f f4 ff ff	 jmp	 $LN818@sre_match
$LN607@sre_match:

; 989  :             }
; 990  :             if (ctx->u.rep)

  00c04	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  00c09	74 1f		 je	 SHORT $LN557@sre_match

; 991  :                 MARK_POP_DISCARD(ctx->lastmark);

  00c0b	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00c0f	48 85 c0	 test	 rax, rax
  00c12	7e 16		 jle	 SHORT $LN557@sre_match
  00c14	48 c1 e0 03	 shl	 rax, 3
  00c18	48 c7 c1 f8 ff
	ff ff		 mov	 rcx, -8
  00c1f	48 2b c8	 sub	 rcx, rax
  00c22	49 01 8c 24 a0
	06 00 00	 add	 QWORD PTR [r12+1696], rcx
$LN557@sre_match:

; 992  :             RETURN_FAILURE;

  00c2a	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  00c31	e9 75 fb ff ff	 jmp	 $LN30@sre_match
$jump_min_until_1$21547:
$jump_max_until_1$21378:

; 1258 :                 if (ret) {

  00c36	48 85 db	 test	 rbx, rbx
  00c39	0f 84 68 fe ff
	ff		 je	 $LN130@sre_match

; 1259 :                     RETURN_ON_ERROR(ret);
; 1260 :                     RETURN_SUCCESS;

  00c3f	e9 a1 fe ff ff	 jmp	 $LN821@sre_match
$jump_repeat$21338:

; 1163 :             state->repeat = ctx->u.rep->prev;

  00c44	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00c48	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00c4c	49 89 8c 24 f8
	06 00 00	 mov	 QWORD PTR [r12+1784], rcx

; 1164 :             PyObject_FREE(ctx->u.rep);

  00c54	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00c58	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 1165 : 
; 1166 :             if (ret) {

  00c5d	48 85 db	 test	 rbx, rbx
  00c60	0f 84 45 fb ff
	ff		 je	 $LN30@sre_match

; 1167 :                 RETURN_ON_ERROR(ret);
; 1168 :                 RETURN_SUCCESS;

  00c66	e9 7a fe ff ff	 jmp	 $LN821@sre_match
$jump_repeat_one_1$21167:

; 1050 :                     if (ret) {

  00c6b	48 85 db	 test	 rbx, rbx

; 1051 :                         RETURN_ON_ERROR(ret);
; 1052 :                         RETURN_SUCCESS;

  00c6e	0f 85 71 fe ff
	ff		 jne	 $LN821@sre_match

; 1053 :                     }
; 1054 : 
; 1055 :                     LASTMARK_RESTORE();

  00c74	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00c78	49 89 44 24 48	 mov	 QWORD PTR [r12+72], rax
  00c7d	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00c81	49 89 44 24 40	 mov	 QWORD PTR [r12+64], rax

; 1056 : 
; 1057 :                     ctx->ptr -= state->charsize;

  00c86	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  00c8b	48 29 47 10	 sub	 QWORD PTR [rdi+16], rax

; 1058 :                     ctx->count--;

  00c8f	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
$LN522@sre_match:

; 1038 :                 for (;;) {
; 1039 :                     while (ctx->count >= (Py_ssize_t) ctx->pattern[1] &&
; 1040 :                            (ctx->ptr >= end ||
; 1041 :                             SRE_CHARGET(state, ctx->ptr, 0) != ctx->u.chr)) {

  00c93	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00c97	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00c9a	48 39 47 20	 cmp	 QWORD PTR [rdi+32], rax
  00c9e	7c 2a		 jl	 SHORT $LN808@sre_match
$LL520@sre_match:
  00ca0	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00ca4	49 3b ce	 cmp	 rcx, r14
  00ca7	73 08		 jae	 SHORT $LN518@sre_match
  00ca9	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00cac	3b 47 38	 cmp	 eax, DWORD PTR [rdi+56]
  00caf	74 19		 je	 SHORT $LN808@sre_match
$LN518@sre_match:

; 1042 :                         ctx->ptr -= state->charsize;

  00cb1	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]

; 1043 :                         ctx->count--;

  00cb6	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
  00cba	48 2b c8	 sub	 rcx, rax
  00cbd	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx
  00cc1	8b 4a 04	 mov	 ecx, DWORD PTR [rdx+4]
  00cc4	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00cc8	7d d6		 jge	 SHORT $LL520@sre_match
$LN808@sre_match:

; 1044 :                     }
; 1045 :                     if (ctx->count < (Py_ssize_t) ctx->pattern[1])

  00cca	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00ccd	48 39 47 20	 cmp	 QWORD PTR [rdi+32], rax
  00cd1	0f 8c d4 fa ff
	ff		 jl	 $LN30@sre_match

; 1046 :                         break;
; 1047 :                     state->ptr = ctx->ptr;

  00cd7	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1048 :                     DO_JUMP(JUMP_REPEAT_ONE_1, jump_repeat_one_1,
; 1049 :                             ctx->pattern+ctx->pattern[0]);

  00cdb	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  00ce3	49 89 04 24	 mov	 QWORD PTR [r12], rax
  00ce7	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  00cef	48 2b c3	 sub	 rax, rbx
  00cf2	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00cf6	73 28		 jae	 SHORT $LN508@sre_match
  00cf8	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00cfd	49 8b cc	 mov	 rcx, r12
  00d00	e8 00 00 00 00	 call	 data_stack_grow
  00d05	85 c0		 test	 eax, eax
  00d07	0f 88 e8 06 00
	00		 js	 $LN791@sre_match
  00d0d	49 83 fd ff	 cmp	 r13, -1
  00d11	74 0d		 je	 SHORT $LN508@sre_match
  00d13	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00d1b	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN508@sre_match:
  00d20	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00d28	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  00d31	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  00d35	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  00d39	4c 8b eb	 mov	 r13, rbx
  00d3c	48 c7 42 08 08
	00 00 00	 mov	 QWORD PTR [rdx+8], 8
  00d44	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00d48	48 8b fa	 mov	 rdi, rdx
  00d4b	8b 01		 mov	 eax, DWORD PTR [rcx]
  00d4d	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00d51	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00d55	e9 36 f3 ff ff	 jmp	 $entrance$20908
$jump_repeat_one_2$21205:

; 1067 :                     if (ret) {

  00d5a	48 85 db	 test	 rbx, rbx

; 1068 :                         RETURN_ON_ERROR(ret);
; 1069 :                         RETURN_SUCCESS;

  00d5d	0f 85 82 fd ff
	ff		 jne	 $LN821@sre_match

; 1070 :                     }
; 1071 :                     ctx->ptr -= state->charsize;

  00d63	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  00d68	48 29 47 10	 sub	 QWORD PTR [rdi+16], rax

; 1072 :                     ctx->count--;
; 1073 :                     LASTMARK_RESTORE();

  00d6c	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00d70	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
  00d74	49 89 44 24 48	 mov	 QWORD PTR [r12+72], rax
  00d79	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00d7d	49 89 44 24 40	 mov	 QWORD PTR [r12+64], rax
$LN490@sre_match:

; 1059 :                 }
; 1060 : 
; 1061 :             } else {
; 1062 :                 /* general case */
; 1063 :                 while (ctx->count >= (Py_ssize_t) ctx->pattern[1]) {

  00d82	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00d86	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00d89	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00d8d	0f 8c 18 fa ff
	ff		 jl	 $LN30@sre_match

; 1064 :                     state->ptr = ctx->ptr;

  00d93	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1065 :                     DO_JUMP(JUMP_REPEAT_ONE_2, jump_repeat_one_2,
; 1066 :                             ctx->pattern+ctx->pattern[0]);

  00d97	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  00d9f	49 89 04 24	 mov	 QWORD PTR [r12], rax
  00da3	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  00dab	48 2b c3	 sub	 rax, rbx
  00dae	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00db2	73 28		 jae	 SHORT $LN480@sre_match
  00db4	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00db9	49 8b cc	 mov	 rcx, r12
  00dbc	e8 00 00 00 00	 call	 data_stack_grow
  00dc1	85 c0		 test	 eax, eax
  00dc3	0f 88 2c 06 00
	00		 js	 $LN791@sre_match
  00dc9	49 83 fd ff	 cmp	 r13, -1
  00dcd	74 0d		 je	 SHORT $LN480@sre_match
  00dcf	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00dd7	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN480@sre_match:
  00ddc	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00de4	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  00ded	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  00df1	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  00df5	4c 8b eb	 mov	 r13, rbx
  00df8	48 c7 42 08 09
	00 00 00	 mov	 QWORD PTR [rdx+8], 9
  00e00	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00e04	48 8b fa	 mov	 rdi, rdx
  00e07	8b 01		 mov	 eax, DWORD PTR [rcx]
  00e09	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00e0d	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00e11	e9 7a f2 ff ff	 jmp	 $entrance$20908
$jump_min_repeat_one$21280:

; 1124 :                     if (ret) {

  00e16	48 85 db	 test	 rbx, rbx

; 1125 :                         RETURN_ON_ERROR(ret);
; 1126 :                         RETURN_SUCCESS;

  00e19	0f 85 c6 fc ff
	ff		 jne	 $LN821@sre_match

; 1127 :                     }
; 1128 :                     state->ptr = ctx->ptr;

  00e1f	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1129 :                     ret = SRE_COUNT(state, ctx->pattern+3, 1);

  00e23	44 8d 43 01	 lea	 r8d, QWORD PTR [rbx+1]
  00e27	49 8b cc	 mov	 rcx, r12
  00e2a	49 89 04 24	 mov	 QWORD PTR [r12], rax
  00e2e	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00e32	48 83 c2 0c	 add	 rdx, 12
  00e36	e8 00 00 00 00	 call	 sre_count

; 1130 :                     RETURN_ON_ERROR(ret);

  00e3b	48 85 c0	 test	 rax, rax
  00e3e	0f 88 c2 05 00
	00		 js	 $LN811@sre_match

; 1131 :                     DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  00e44	49 8b 8c 24 90
	06 00 00	 mov	 rcx, QWORD PTR [r12+1680]
  00e4c	49 8d 7c 0d 00	 lea	 rdi, QWORD PTR [r13+rcx]

; 1132 :                     if (ret == 0)

  00e51	0f 84 54 f9 ff
	ff		 je	 $LN30@sre_match

; 1133 :                         break;
; 1134 :                     assert(ret == 1);

  00e57	48 83 f8 01	 cmp	 rax, 1
  00e5b	74 1a		 je	 SHORT $LN722@sre_match
  00e5d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@
  00e64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@DAEMKNJI@?$AAr?$AAe?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00e6b	41 b8 6e 04 00
	00		 mov	 r8d, 1134		; 0000046eH
  00e71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN722@sre_match:

; 1135 :                     ctx->ptr += state->charsize;

  00e77	49 63 44 24 3c	 movsxd	 rax, DWORD PTR [r12+60]
  00e7c	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 1136 :                     ctx->count++;
; 1137 :                     LASTMARK_RESTORE();

  00e80	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00e84	48 ff 47 20	 inc	 QWORD PTR [rdi+32]
  00e88	49 89 44 24 48	 mov	 QWORD PTR [r12+72], rax
  00e8d	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00e91	49 89 44 24 40	 mov	 QWORD PTR [r12+64], rax
$LN431@sre_match:

; 1119 :                 while ((Py_ssize_t)ctx->pattern[2] == SRE_MAXREPEAT
; 1120 :                        || ctx->count <= (Py_ssize_t)ctx->pattern[2]) {

  00e96	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00e9a	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00e9d	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  00ea0	74 0a		 je	 SHORT $LN775@sre_match
  00ea2	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00ea6	0f 8f ff f8 ff
	ff		 jg	 $LN30@sre_match
$LN775@sre_match:

; 1121 :                     state->ptr = ctx->ptr;

  00eac	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1122 :                     DO_JUMP(JUMP_MIN_REPEAT_ONE,jump_min_repeat_one,
; 1123 :                             ctx->pattern+ctx->pattern[0]);

  00eb0	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  00eb8	49 89 04 24	 mov	 QWORD PTR [r12], rax
  00ebc	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  00ec4	48 2b c3	 sub	 rax, rbx
  00ec7	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00ecb	73 28		 jae	 SHORT $LN420@sre_match
  00ecd	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00ed2	49 8b cc	 mov	 rcx, r12
  00ed5	e8 00 00 00 00	 call	 data_stack_grow
  00eda	85 c0		 test	 eax, eax
  00edc	0f 88 13 05 00
	00		 js	 $LN791@sre_match
  00ee2	49 83 fd ff	 cmp	 r13, -1
  00ee6	74 0d		 je	 SHORT $LN420@sre_match
  00ee8	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00ef0	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN420@sre_match:
  00ef5	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00efd	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  00f06	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  00f0a	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  00f0e	4c 8b eb	 mov	 r13, rbx
  00f11	48 c7 42 08 0a
	00 00 00	 mov	 QWORD PTR [rdx+8], 10
  00f19	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00f1d	48 8b fa	 mov	 rdi, rdx
  00f20	8b 01		 mov	 eax, DWORD PTR [rcx]
  00f22	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00f26	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00f2a	e9 61 f1 ff ff	 jmp	 $entrance$20908
$jump_assert$21739:

; 1386 :             RETURN_ON_FAILURE(ret);

  00f2f	48 85 db	 test	 rbx, rbx
  00f32	78 1a		 js	 SHORT $LN761@sre_match
  00f34	0f 85 5a f8 ff
	ff		 jne	 $LN32@sre_match
  00f3a	e9 6c f8 ff ff	 jmp	 $LN30@sre_match
$jump_assert_not$21774:

; 1398 :                 if (ret) {

  00f3f	48 85 db	 test	 rbx, rbx
  00f42	0f 84 4c f8 ff
	ff		 je	 $LN32@sre_match

; 1399 :                     RETURN_ON_ERROR(ret);

  00f48	0f 89 5d f8 ff
	ff		 jns	 $LN30@sre_match
$LN761@sre_match:

; 1423 :         return ret;

  00f4e	48 8b c3	 mov	 rax, rbx
  00f51	e9 b0 04 00 00	 jmp	 $LN811@sre_match
$LN385@sre_match:

; 1154 :             }
; 1155 :             ctx->u.rep->count = -1;

  00f56	48 c7 00 ff ff
	ff ff		 mov	 QWORD PTR [rax], -1

; 1156 :             ctx->u.rep->pattern = ctx->pattern;

  00f5d	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00f61	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00f65	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1157 :             ctx->u.rep->prev = state->repeat;

  00f69	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00f6d	49 8b 84 24 f8
	06 00 00	 mov	 rax, QWORD PTR [r12+1784]
  00f75	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1158 :             ctx->u.rep->last_ptr = NULL;

  00f79	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00f7d	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1159 :             state->repeat = ctx->u.rep;

  00f85	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1160 : 
; 1161 :             state->ptr = ctx->ptr;
; 1162 :             DO_JUMP(JUMP_REPEAT, jump_repeat, ctx->pattern+ctx->pattern[0]);

  00f89	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  00f91	49 89 84 24 f8
	06 00 00	 mov	 QWORD PTR [r12+1784], rax
  00f99	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00f9d	49 89 04 24	 mov	 QWORD PTR [r12], rax
  00fa1	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  00fa9	48 2b c3	 sub	 rax, rbx
  00fac	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00fb0	73 28		 jae	 SHORT $LN376@sre_match
  00fb2	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00fb7	49 8b cc	 mov	 rcx, r12
  00fba	e8 00 00 00 00	 call	 data_stack_grow
  00fbf	85 c0		 test	 eax, eax
  00fc1	0f 88 2e 04 00
	00		 js	 $LN791@sre_match
  00fc7	49 83 fd ff	 cmp	 r13, -1
  00fcb	74 0d		 je	 SHORT $LN376@sre_match
  00fcd	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00fd5	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN376@sre_match:
  00fda	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  00fe2	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  00feb	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  00fef	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  00ff3	4c 8b eb	 mov	 r13, rbx
  00ff6	48 c7 42 08 07
	00 00 00	 mov	 QWORD PTR [rdx+8], 7
  00ffe	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  01002	48 8b fa	 mov	 rdi, rdx
  01005	8b 01		 mov	 eax, DWORD PTR [rcx]
  01007	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  0100b	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  0100f	e9 7c f0 ff ff	 jmp	 $entrance$20908
$LN781@sre_match:

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  01014	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  0101c	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  01024	48 2b c3	 sub	 rax, rbx
  01027	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  0102b	73 28		 jae	 SHORT $LN45@sre_match
  0102d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01032	49 8b cc	 mov	 rcx, r12
  01035	e8 00 00 00 00	 call	 data_stack_grow
  0103a	85 c0		 test	 eax, eax
  0103c	0f 88 b3 03 00
	00		 js	 $LN791@sre_match
  01042	49 83 fd ff	 cmp	 r13, -1
  01046	74 0d		 je	 SHORT $LN45@sre_match
  01048	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  01050	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN45@sre_match:
  01055	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  0105d	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  01066	48 c7 44 03 08
	0d 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 13
  0106f	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
$LN817@sre_match:
  01073	4c 89 29	 mov	 QWORD PTR [rcx], r13
  01076	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  0107a	4c 8b eb	 mov	 r13, rbx
  0107d	48 83 c0 08	 add	 rax, 8
  01081	48 8b f9	 mov	 rdi, rcx
  01084	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  01088	e9 03 f0 ff ff	 jmp	 $entrance$20908
$LN360@sre_match:

; 1169 :             }
; 1170 :             RETURN_FAILURE;
; 1171 : 
; 1172 :         case SRE_OP_MAX_UNTIL:
; 1173 :             /* maximizing repeat */
; 1174 :             /* <REPEAT> <skip> <1=min> <2=max> item <MAX_UNTIL> tail */
; 1175 : 
; 1176 :             /* FIXME: we probably need to deal with zero-width
; 1177 :                matches in here... */
; 1178 : 
; 1179 :             ctx->u.rep = state->repeat;

  0108d	49 8b 84 24 f8
	06 00 00	 mov	 rax, QWORD PTR [r12+1784]
  01095	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1180 :             if (!ctx->u.rep)

  01099	48 85 c0	 test	 rax, rax
  0109c	0f 84 57 03 00
	00		 je	 $LN789@sre_match

; 1181 :                 RETURN_ERROR(SRE_ERROR_STATE);
; 1182 : 
; 1183 :             state->ptr = ctx->ptr;

  010a2	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  010a6	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 1184 : 
; 1185 :             ctx->count = ctx->u.rep->count+1;

  010aa	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  010ae	4c 8b 00	 mov	 r8, QWORD PTR [rax]

; 1186 : 
; 1187 :             TRACE(("|%p|%p|MAX_UNTIL %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1188 :                    ctx->ptr, ctx->count));
; 1189 : 
; 1190 :             if (ctx->count < (Py_ssize_t) ctx->u.rep->pattern[1]) {

  010b1	48 8b d0	 mov	 rdx, rax
  010b4	49 ff c0	 inc	 r8
  010b7	4c 89 47 20	 mov	 QWORD PTR [rdi+32], r8
  010bb	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  010bf	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  010c2	4c 3b c1	 cmp	 r8, rcx
  010c5	7d 67		 jge	 SHORT $LN329@sre_match

; 1191 :                 /* not enough matches */
; 1192 :                 ctx->u.rep->count = ctx->count;

  010c7	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1193 :                 DO_JUMP(JUMP_MAX_UNTIL_1, jump_max_until_1,
; 1194 :                         ctx->u.rep->pattern+3);

  010ca	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  010d2	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  010da	48 2b c3	 sub	 rax, rbx
  010dd	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  010e1	73 28		 jae	 SHORT $LN345@sre_match
  010e3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  010e8	49 8b cc	 mov	 rcx, r12
  010eb	e8 00 00 00 00	 call	 data_stack_grow
  010f0	85 c0		 test	 eax, eax
  010f2	0f 88 fd 02 00
	00		 js	 $LN791@sre_match
  010f8	49 83 fd ff	 cmp	 r13, -1
  010fc	74 0d		 je	 SHORT $LN345@sre_match
  010fe	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  01106	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN345@sre_match:
  0110b	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  01113	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  0111c	48 c7 44 03 08
	01 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 1
  01125	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  01129	e9 35 f9 ff ff	 jmp	 $LN819@sre_match
$LN329@sre_match:

; 1195 :                 if (ret) {
; 1196 :                     RETURN_ON_ERROR(ret);
; 1197 :                     RETURN_SUCCESS;
; 1198 :                 }
; 1199 :                 ctx->u.rep->count = ctx->count-1;
; 1200 :                 state->ptr = ctx->ptr;
; 1201 :                 RETURN_FAILURE;
; 1202 :             }
; 1203 : 
; 1204 :             if ((ctx->count < (Py_ssize_t) ctx->u.rep->pattern[2] ||
; 1205 :                 ctx->u.rep->pattern[2] == SRE_MAXREPEAT) &&
; 1206 :                 state->ptr != ctx->u.rep->last_ptr) {

  0112e	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  01131	4c 3b c1	 cmp	 r8, rcx
  01134	7c 09		 jl	 SHORT $LN327@sre_match
  01136	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  01139	0f 85 54 f7 ff
	ff		 jne	 $LN328@sre_match
$LN327@sre_match:
  0113f	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  01143	49 39 04 24	 cmp	 QWORD PTR [r12], rax
  01147	0f 84 46 f7 ff
	ff		 je	 $LN328@sre_match

; 1207 :                 /* we may have enough matches, but if we can
; 1208 :                    match another item, do so */
; 1209 :                 ctx->u.rep->count = ctx->count;

  0114d	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1210 :                 LASTMARK_SAVE();

  01150	49 8b 5c 24 48	 mov	 rbx, QWORD PTR [r12+72]
  01155	48 89 5f 28	 mov	 QWORD PTR [rdi+40], rbx
  01159	49 8b 44 24 40	 mov	 rax, QWORD PTR [r12+64]
  0115e	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1211 :                 MARK_PUSH(ctx->lastmark);

  01162	48 85 db	 test	 rbx, rbx
  01165	7e 77		 jle	 SHORT $LN317@sre_match
  01167	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  0116f	48 8d 34 dd 08
	00 00 00	 lea	 rsi, QWORD PTR [rbx*8+8]
  01177	49 2b 84 24 a0
	06 00 00	 sub	 rax, QWORD PTR [r12+1696]
  0117f	48 3b f0	 cmp	 rsi, rax
  01182	76 26		 jbe	 SHORT $LN311@sre_match
  01184	48 8b d6	 mov	 rdx, rsi
  01187	49 8b cc	 mov	 rcx, r12
  0118a	e8 00 00 00 00	 call	 data_stack_grow
  0118f	85 c0		 test	 eax, eax
  01191	0f 88 5e 02 00
	00		 js	 $LN791@sre_match
  01197	49 83 fd ff	 cmp	 r13, -1
  0119b	74 0d		 je	 SHORT $LN311@sre_match
  0119d	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  011a5	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN311@sre_match:
  011aa	49 8b 8c 24 90
	06 00 00	 mov	 rcx, QWORD PTR [r12+1680]
  011b2	49 8d 54 24 50	 lea	 rdx, QWORD PTR [r12+80]
  011b7	4c 8b c6	 mov	 r8, rsi
  011ba	49 03 8c 24 a0
	06 00 00	 add	 rcx, QWORD PTR [r12+1696]
  011c2	e8 00 00 00 00	 call	 memcpy
  011c7	4c 8d 1c dd 08
	00 00 00	 lea	 r11, QWORD PTR [rbx*8+8]
  011cf	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  011d6	4d 01 9c 24 a0
	06 00 00	 add	 QWORD PTR [r12+1696], r11
$LN317@sre_match:

; 1212 :                 /* zero-width match protection */
; 1213 :                 DATA_PUSH(&ctx->u.rep->last_ptr);

  011de	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  011e6	49 2b 84 24 a0
	06 00 00	 sub	 rax, QWORD PTR [r12+1696]
  011ee	48 83 f8 08	 cmp	 rax, 8
  011f2	73 28		 jae	 SHORT $LN302@sre_match
  011f4	ba 08 00 00 00	 mov	 edx, 8
  011f9	49 8b cc	 mov	 rcx, r12
  011fc	e8 00 00 00 00	 call	 data_stack_grow
  01201	85 c0		 test	 eax, eax
  01203	0f 88 ec 01 00
	00		 js	 $LN791@sre_match
  01209	49 83 fd ff	 cmp	 r13, -1
  0120d	74 0d		 je	 SHORT $LN302@sre_match
  0120f	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  01217	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN302@sre_match:
  0121c	49 8b 8c 24 a0
	06 00 00	 mov	 rcx, QWORD PTR [r12+1696]
  01224	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  01228	41 b8 08 00 00
	00		 mov	 r8d, 8
  0122e	49 03 8c 24 90
	06 00 00	 add	 rcx, QWORD PTR [r12+1680]
  01236	48 83 c2 10	 add	 rdx, 16
  0123a	e8 00 00 00 00	 call	 memcpy
  0123f	49 83 84 24 a0
	06 00 00 08	 add	 QWORD PTR [r12+1696], 8

; 1214 :                 ctx->u.rep->last_ptr = state->ptr;

  01248	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  0124c	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  01250	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1215 :                 DO_JUMP(JUMP_MAX_UNTIL_2, jump_max_until_2,
; 1216 :                         ctx->u.rep->pattern+3);

  01254	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  0125c	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  01264	48 2b c3	 sub	 rax, rbx
  01267	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  0126b	73 28		 jae	 SHORT $LN293@sre_match
  0126d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01272	49 8b cc	 mov	 rcx, r12
  01275	e8 00 00 00 00	 call	 data_stack_grow
  0127a	85 c0		 test	 eax, eax
  0127c	0f 88 73 01 00
	00		 js	 $LN791@sre_match
  01282	49 83 fd ff	 cmp	 r13, -1
  01286	74 0d		 je	 SHORT $LN293@sre_match
  01288	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  01290	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN293@sre_match:
  01295	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  0129d	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  012a6	48 c7 44 03 08
	02 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 2
  012af	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  012b3	e9 ab f7 ff ff	 jmp	 $LN819@sre_match
$LN230@sre_match:

; 1237 : 
; 1238 :         case SRE_OP_MIN_UNTIL:
; 1239 :             /* minimizing repeat */
; 1240 :             /* <REPEAT> <skip> <1=min> <2=max> item <MIN_UNTIL> tail */
; 1241 : 
; 1242 :             ctx->u.rep = state->repeat;

  012b8	49 8b 84 24 f8
	06 00 00	 mov	 rax, QWORD PTR [r12+1784]
  012c0	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1243 :             if (!ctx->u.rep)

  012c4	48 85 c0	 test	 rax, rax
  012c7	0f 84 2c 01 00
	00		 je	 $LN789@sre_match

; 1245 : 
; 1246 :             state->ptr = ctx->ptr;

  012cd	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  012d1	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 1247 : 
; 1248 :             ctx->count = ctx->u.rep->count+1;

  012d5	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  012d9	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 1249 : 
; 1250 :             TRACE(("|%p|%p|MIN_UNTIL %" PY_FORMAT_SIZE_T "d %p\n", ctx->pattern,
; 1251 :                    ctx->ptr, ctx->count, ctx->u.rep->pattern));
; 1252 : 
; 1253 :             if (ctx->count < (Py_ssize_t) ctx->u.rep->pattern[1]) {

  012dc	4c 8b c0	 mov	 r8, rax
  012df	48 ff c2	 inc	 rdx
  012e2	48 89 57 20	 mov	 QWORD PTR [rdi+32], rdx
  012e6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  012ea	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  012ed	48 3b d1	 cmp	 rdx, rcx
  012f0	7d 67		 jge	 SHORT $LN199@sre_match

; 1254 :                 /* not enough matches */
; 1255 :                 ctx->u.rep->count = ctx->count;

  012f2	49 89 10	 mov	 QWORD PTR [r8], rdx

; 1256 :                 DO_JUMP(JUMP_MIN_UNTIL_1, jump_min_until_1,
; 1257 :                         ctx->u.rep->pattern+3);

  012f5	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  012fd	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  01305	48 2b c3	 sub	 rax, rbx
  01308	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  0130c	73 28		 jae	 SHORT $LN215@sre_match
  0130e	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01313	49 8b cc	 mov	 rcx, r12
  01316	e8 00 00 00 00	 call	 data_stack_grow
  0131b	85 c0		 test	 eax, eax
  0131d	0f 88 d2 00 00
	00		 js	 $LN791@sre_match
  01323	49 83 fd ff	 cmp	 r13, -1
  01327	74 0d		 je	 SHORT $LN215@sre_match
  01329	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  01331	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN215@sre_match:
  01336	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  0133e	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  01347	48 c7 44 03 08
	04 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 4
  01350	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  01354	e9 0a f7 ff ff	 jmp	 $LN819@sre_match
$LN199@sre_match:

; 1261 :                 }
; 1262 :                 ctx->u.rep->count = ctx->count-1;
; 1263 :                 state->ptr = ctx->ptr;
; 1264 :                 RETURN_FAILURE;
; 1265 :             }
; 1266 : 
; 1267 :             LASTMARK_SAVE();

  01359	49 8b 44 24 48	 mov	 rax, QWORD PTR [r12+72]
  0135e	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  01362	49 8b 44 24 40	 mov	 rax, QWORD PTR [r12+64]
  01367	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1268 : 
; 1269 :             /* see if the tail matches */
; 1270 :             state->repeat = ctx->u.rep->prev;

  0136b	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1271 :             DO_JUMP(JUMP_MIN_UNTIL_2, jump_min_until_2, ctx->pattern);

  0136f	49 8b 9c 24 a0
	06 00 00	 mov	 rbx, QWORD PTR [r12+1696]
  01377	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0137b	49 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR [r12+1688]
  01383	48 2b c3	 sub	 rax, rbx
  01386	49 89 8c 24 f8
	06 00 00	 mov	 QWORD PTR [r12+1784], rcx
  0138e	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  01392	73 24		 jae	 SHORT $LN187@sre_match
  01394	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01399	49 8b cc	 mov	 rcx, r12
  0139c	e8 00 00 00 00	 call	 data_stack_grow
  013a1	85 c0		 test	 eax, eax
  013a3	78 50		 js	 SHORT $LN791@sre_match
  013a5	49 83 fd ff	 cmp	 r13, -1
  013a9	74 0d		 je	 SHORT $LN187@sre_match
  013ab	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  013b3	49 8d 7c 05 00	 lea	 rdi, QWORD PTR [r13+rax]
$LN187@sre_match:
  013b8	49 8b 84 24 90
	06 00 00	 mov	 rax, QWORD PTR [r12+1680]
  013c0	49 83 84 24 a0
	06 00 00 40	 add	 QWORD PTR [r12+1696], 64 ; 00000040H
  013c9	4c 89 2c 03	 mov	 QWORD PTR [rbx+rax], r13
  013cd	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  013d1	4c 8b eb	 mov	 r13, rbx
  013d4	48 c7 41 08 05
	00 00 00	 mov	 QWORD PTR [rcx+8], 5
  013dc	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  013e0	48 8b f9	 mov	 rdi, rcx
  013e3	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  013e7	e9 a4 ec ff ff	 jmp	 $entrance$20908
$LN777@sre_match:

; 820  :             RETURN_ERROR(SRE_ERROR_INTERRUPTED);

  013ec	48 c7 c0 f6 ff
	ff ff		 mov	 rax, -10
  013f3	eb 11		 jmp	 SHORT $LN811@sre_match
$LN791@sre_match:

; 1271 :             DO_JUMP(JUMP_MIN_UNTIL_2, jump_min_until_2, ctx->pattern);

  013f5	48 98		 cdqe
  013f7	eb 0d		 jmp	 SHORT $LN811@sre_match
$LN789@sre_match:

; 1244 :                 RETURN_ERROR(SRE_ERROR_STATE);

  013f9	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  01400	eb 04		 jmp	 SHORT $LN811@sre_match
$LN28@sre_match:

; 1410 : 
; 1411 :         default:
; 1412 :             TRACE(("|%p|%p|UNKNOWN %d\n", ctx->pattern, ctx->ptr,
; 1413 :                    ctx->pattern[-1]));
; 1414 :             RETURN_ERROR(SRE_ERROR_ILLEGAL);

  01402	48 83 c8 ff	 or	 rax, -1
$LN811@sre_match:
  01406	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0140b	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  01410	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]

; 1427 :         case JUMP_MAX_UNTIL_2:
; 1428 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1429 :             goto jump_max_until_2;
; 1430 :         case JUMP_MAX_UNTIL_3:
; 1431 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1432 :             goto jump_max_until_3;
; 1433 :         case JUMP_MIN_UNTIL_2:
; 1434 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1435 :             goto jump_min_until_2;
; 1436 :         case JUMP_MIN_UNTIL_3:
; 1437 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1438 :             goto jump_min_until_3;
; 1439 :         case JUMP_BRANCH:
; 1440 :             TRACE(("|%p|%p|JUMP_BRANCH\n", ctx->pattern, ctx->ptr));
; 1441 :             goto jump_branch;
; 1442 :         case JUMP_MAX_UNTIL_1:
; 1443 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1444 :             goto jump_max_until_1;
; 1445 :         case JUMP_MIN_UNTIL_1:
; 1446 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1447 :             goto jump_min_until_1;
; 1448 :         case JUMP_REPEAT:
; 1449 :             TRACE(("|%p|%p|JUMP_REPEAT\n", ctx->pattern, ctx->ptr));
; 1450 :             goto jump_repeat;
; 1451 :         case JUMP_REPEAT_ONE_1:
; 1452 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_1\n", ctx->pattern, ctx->ptr));
; 1453 :             goto jump_repeat_one_1;
; 1454 :         case JUMP_REPEAT_ONE_2:
; 1455 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_2\n", ctx->pattern, ctx->ptr));
; 1456 :             goto jump_repeat_one_2;
; 1457 :         case JUMP_MIN_REPEAT_ONE:
; 1458 :             TRACE(("|%p|%p|JUMP_MIN_REPEAT_ONE\n", ctx->pattern, ctx->ptr));
; 1459 :             goto jump_min_repeat_one;
; 1460 :         case JUMP_ASSERT:
; 1461 :             TRACE(("|%p|%p|JUMP_ASSERT\n", ctx->pattern, ctx->ptr));
; 1462 :             goto jump_assert;
; 1463 :         case JUMP_ASSERT_NOT:
; 1464 :             TRACE(("|%p|%p|JUMP_ASSERT_NOT\n", ctx->pattern, ctx->ptr));
; 1465 :             goto jump_assert_not;
; 1466 :         case JUMP_NONE:
; 1467 :             TRACE(("|%p|%p|RETURN %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1468 :                    ctx->ptr, ret));
; 1469 :             break;
; 1470 :     }
; 1471 : 
; 1472 :     return ret; /* should never get here */
; 1473 : }

  01415	48 83 c4 20	 add	 rsp, 32			; 00000020H
  01419	41 5f		 pop	 r15
  0141b	41 5e		 pop	 r14
  0141d	41 5d		 pop	 r13
  0141f	41 5c		 pop	 r12
  01421	5b		 pop	 rbx
  01422	c3		 ret	 0
  01423	90		 npad	 1
$LN807@sre_match:
  01424	00 00 00 00	 DD	 $LN30@sre_match
  01428	00 00 00 00	 DD	 $LN678@sre_match
  0142c	00 00 00 00	 DD	 $LN663@sre_match
  01430	00 00 00 00	 DD	 $LN657@sre_match
  01434	00 00 00 00	 DD	 $LN85@sre_match
  01438	00 00 00 00	 DD	 $LN55@sre_match
  0143c	00 00 00 00	 DD	 $LN675@sre_match
  01440	00 00 00 00	 DD	 $LN626@sre_match
  01444	00 00 00 00	 DD	 $LN28@sre_match
  01448	00 00 00 00	 DD	 $LN669@sre_match
  0144c	00 00 00 00	 DD	 $LN28@sre_match
  01450	00 00 00 00	 DD	 $LN28@sre_match
  01454	00 00 00 00	 DD	 $LN127@sre_match
  01458	00 00 00 00	 DD	 $LN90@sre_match
  0145c	00 00 00 00	 DD	 $LN108@sre_match
  01460	00 00 00 00	 DD	 $LN652@sre_match
  01464	00 00 00 00	 DD	 $LN634@sre_match
  01468	00 00 00 00	 DD	 $LN628@sre_match
  0146c	00 00 00 00	 DD	 $LN628@sre_match
  01470	00 00 00 00	 DD	 $LN690@sre_match
  01474	00 00 00 00	 DD	 $LN646@sre_match
  01478	00 00 00 00	 DD	 $LN695@sre_match
  0147c	00 00 00 00	 DD	 $LN360@sre_match
  01480	00 00 00 00	 DD	 $LN230@sre_match
  01484	00 00 00 00	 DD	 $LN684@sre_match
  01488	00 00 00 00	 DD	 $LN640@sre_match
  0148c	00 00 00 00	 DD	 $LN28@sre_match
  01490	00 00 00 00	 DD	 $LN28@sre_match
  01494	00 00 00 00	 DD	 $LN390@sre_match
  01498	00 00 00 00	 DD	 $LN550@sre_match
  0149c	00 00 00 00	 DD	 $LN28@sre_match
  014a0	00 00 00 00	 DD	 $LN461@sre_match
$LN806@sre_match:
  014a4	00 00 00 00	 DD	 $jump_min_until_1$21547
  014a8	00 00 00 00	 DD	 $jump_max_until_2$21448
  014ac	00 00 00 00	 DD	 $jump_max_until_3$21504
  014b0	00 00 00 00	 DD	 $jump_min_until_1$21547
  014b4	00 00 00 00	 DD	 $jump_min_until_2$21583
  014b8	00 00 00 00	 DD	 $jump_min_until_3$21635
  014bc	00 00 00 00	 DD	 $jump_repeat$21338
  014c0	00 00 00 00	 DD	 $jump_repeat_one_1$21167
  014c4	00 00 00 00	 DD	 $jump_repeat_one_2$21205
  014c8	00 00 00 00	 DD	 $jump_min_repeat_one$21280
  014cc	00 00 00 00	 DD	 $jump_branch$21060
  014d0	00 00 00 00	 DD	 $jump_assert$21739
  014d4	00 00 00 00	 DD	 $jump_assert_not$21774
sre_match ENDP
_TEXT	ENDS
EXTRN	_PyUnicode_IsLinebreak:PROC
EXTRN	_PyUnicode_IsNumeric:PROC
EXTRN	_PyUnicode_IsDigit:PROC
EXTRN	_PyUnicode_IsAlpha:PROC
EXTRN	_PyUnicode_IsWhitespace:PROC
EXTRN	_Py_ascii_whitespace:BYTE
EXTRN	_PyUnicode_IsDecimalDigit:PROC
EXTRN	__imp_isalnum:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_category DD imagerel sre_category
	DD	imagerel sre_category+760
	DD	imagerel $unwind$sre_category
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_category DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT sre_category
_TEXT	SEGMENT
category$ = 48
ch$ = 56
sre_category PROC					; COMDAT

; 179  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b da		 mov	 ebx, edx

; 180  :     switch (category) {

  00008	83 f9 11	 cmp	 ecx, 17
  0000b	0f 87 95 02 00
	00		 ja	 $LN19@sre_catego
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00018	8b c1		 mov	 eax, ecx
  0001a	8b 84 82 00 00
	00 00		 mov	 eax, DWORD PTR $LN57@sre_catego[rdx+rax*4]
  00021	48 03 c2	 add	 rax, rdx
  00024	ff e0		 jmp	 rax
$LN18@sre_catego:

; 181  : 
; 182  :     case SRE_CATEGORY_DIGIT:
; 183  :         return SRE_IS_DIGIT(ch);

  00026	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  0002c	73 13		 jae	 SHORT $LN23@sre_catego
  0002e	0f be 8c 13 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rbx+rdx]
  00036	83 e1 01	 and	 ecx, 1
  00039	8b c1		 mov	 eax, ecx

; 222  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
$LN23@sre_catego:

; 181  : 
; 182  :     case SRE_CATEGORY_DIGIT:
; 183  :         return SRE_IS_DIGIT(ch);

  00041	33 c9		 xor	 ecx, ecx
  00043	8b c1		 mov	 eax, ecx

; 222  : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN17@sre_catego:

; 184  :     case SRE_CATEGORY_NOT_DIGIT:
; 185  :         return !SRE_IS_DIGIT(ch);

  0004b	33 c9		 xor	 ecx, ecx
  0004d	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  00053	73 18		 jae	 SHORT $LN25@sre_catego
  00055	0f be 94 13 00
	00 00 00	 movsx	 edx, BYTE PTR sre_char_info[rbx+rdx]
  0005d	83 e2 01	 and	 edx, 1
  00060	85 d2		 test	 edx, edx
  00062	0f 94 c1	 sete	 cl
  00065	8b c1		 mov	 eax, ecx

; 222  : }

  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5b		 pop	 rbx
  0006c	c3		 ret	 0
$LN25@sre_catego:

; 184  :     case SRE_CATEGORY_NOT_DIGIT:
; 185  :         return !SRE_IS_DIGIT(ch);

  0006d	85 c9		 test	 ecx, ecx
  0006f	8b d1		 mov	 edx, ecx
  00071	0f 94 c1	 sete	 cl
  00074	8b c1		 mov	 eax, ecx

; 222  : }

  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5b		 pop	 rbx
  0007b	c3		 ret	 0
$LN16@sre_catego:

; 186  :     case SRE_CATEGORY_SPACE:
; 187  :         return SRE_IS_SPACE(ch);

  0007c	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  00082	73 bd		 jae	 SHORT $LN23@sre_catego
  00084	0f be 8c 13 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rbx+rdx]
  0008c	83 e1 02	 and	 ecx, 2
  0008f	8b c1		 mov	 eax, ecx

; 222  : }

  00091	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00095	5b		 pop	 rbx
  00096	c3		 ret	 0
$LN15@sre_catego:

; 188  :     case SRE_CATEGORY_NOT_SPACE:
; 189  :         return !SRE_IS_SPACE(ch);

  00097	33 c9		 xor	 ecx, ecx
  00099	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  0009f	73 cc		 jae	 SHORT $LN25@sre_catego
  000a1	0f be 94 13 00
	00 00 00	 movsx	 edx, BYTE PTR sre_char_info[rbx+rdx]
  000a9	83 e2 02	 and	 edx, 2
  000ac	85 d2		 test	 edx, edx
  000ae	0f 94 c1	 sete	 cl
  000b1	8b c1		 mov	 eax, ecx

; 222  : }

  000b3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b7	5b		 pop	 rbx
  000b8	c3		 ret	 0
$LN14@sre_catego:

; 190  :     case SRE_CATEGORY_WORD:
; 191  :         return SRE_IS_WORD(ch);

  000b9	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  000bf	73 80		 jae	 SHORT $LN23@sre_catego
  000c1	0f be 8c 13 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rbx+rdx]
  000c9	83 e1 10	 and	 ecx, 16
  000cc	8b c1		 mov	 eax, ecx

; 222  : }

  000ce	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d2	5b		 pop	 rbx
  000d3	c3		 ret	 0
$LN13@sre_catego:

; 192  :     case SRE_CATEGORY_NOT_WORD:
; 193  :         return !SRE_IS_WORD(ch);

  000d4	33 c9		 xor	 ecx, ecx
  000d6	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  000dc	73 8f		 jae	 SHORT $LN25@sre_catego
  000de	0f be 94 13 00
	00 00 00	 movsx	 edx, BYTE PTR sre_char_info[rbx+rdx]
  000e6	83 e2 10	 and	 edx, 16
  000e9	85 d2		 test	 edx, edx
  000eb	0f 94 c1	 sete	 cl
  000ee	8b c1		 mov	 eax, ecx

; 222  : }

  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	5b		 pop	 rbx
  000f5	c3		 ret	 0
$LN12@sre_catego:

; 194  :     case SRE_CATEGORY_LINEBREAK:
; 195  :         return SRE_IS_LINEBREAK(ch);

  000f6	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  000fc	0f 83 3f ff ff
	ff		 jae	 $LN23@sre_catego
  00102	0f be 8c 13 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rbx+rdx]
  0010a	83 e1 04	 and	 ecx, 4
  0010d	8b c1		 mov	 eax, ecx

; 222  : }

  0010f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00113	5b		 pop	 rbx
  00114	c3		 ret	 0
$LN11@sre_catego:

; 196  :     case SRE_CATEGORY_NOT_LINEBREAK:
; 197  :         return !SRE_IS_LINEBREAK(ch);

  00115	33 c9		 xor	 ecx, ecx
  00117	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  0011d	0f 83 4a ff ff
	ff		 jae	 $LN25@sre_catego
  00123	0f be 94 13 00
	00 00 00	 movsx	 edx, BYTE PTR sre_char_info[rbx+rdx]
  0012b	83 e2 04	 and	 edx, 4
  0012e	85 d2		 test	 edx, edx
  00130	0f 94 c1	 sete	 cl
  00133	8b c1		 mov	 eax, ecx

; 222  : }

  00135	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00139	5b		 pop	 rbx
  0013a	c3		 ret	 0
$LN10@sre_catego:

; 198  : 
; 199  :     case SRE_CATEGORY_LOC_WORD:
; 200  :         return SRE_LOC_IS_WORD(ch);

  0013b	f7 c3 00 ff ff
	ff		 test	 ebx, -256		; ffffff00H
  00141	75 0c		 jne	 SHORT $LN55@sre_catego
  00143	8b cb		 mov	 ecx, ebx
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
$LN59@sre_catego:
  0014b	85 c0		 test	 eax, eax
  0014d	75 0f		 jne	 SHORT $LN41@sre_catego
$LN55@sre_catego:
  0014f	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  00152	74 0a		 je	 SHORT $LN41@sre_catego
  00154	33 c9		 xor	 ecx, ecx
  00156	8b c1		 mov	 eax, ecx

; 222  : }

  00158	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0015c	5b		 pop	 rbx
  0015d	c3		 ret	 0
$LN41@sre_catego:

; 198  : 
; 199  :     case SRE_CATEGORY_LOC_WORD:
; 200  :         return SRE_LOC_IS_WORD(ch);

  0015e	b9 01 00 00 00	 mov	 ecx, 1
  00163	8b c1		 mov	 eax, ecx

; 222  : }

  00165	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00169	5b		 pop	 rbx
  0016a	c3		 ret	 0
$LN9@sre_catego:

; 201  :     case SRE_CATEGORY_LOC_NOT_WORD:
; 202  :         return !SRE_LOC_IS_WORD(ch);

  0016b	f7 c3 00 ff ff
	ff		 test	 ebx, -256		; ffffff00H
  00171	75 10		 jne	 SHORT $LN56@sre_catego
  00173	8b cb		 mov	 ecx, ebx
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
$LN58@sre_catego:
  0017b	85 c0		 test	 eax, eax
  0017d	0f 85 be fe ff
	ff		 jne	 $LN23@sre_catego
$LN56@sre_catego:
  00183	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  00186	0f 84 b5 fe ff
	ff		 je	 $LN23@sre_catego
  0018c	b9 01 00 00 00	 mov	 ecx, 1

; 181  : 
; 182  :     case SRE_CATEGORY_DIGIT:
; 183  :         return SRE_IS_DIGIT(ch);

  00191	8b c1		 mov	 eax, ecx

; 222  : }

  00193	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00197	5b		 pop	 rbx
  00198	c3		 ret	 0
$LN8@sre_catego:

; 203  : 
; 204  :     case SRE_CATEGORY_UNI_DIGIT:
; 205  :         return SRE_UNI_IS_DIGIT(ch);

  00199	8b cb		 mov	 ecx, ebx

; 222  : }

  0019b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0019f	5b		 pop	 rbx
  001a0	e9 00 00 00 00	 jmp	 _PyUnicode_IsDecimalDigit
$LN7@sre_catego:

; 206  :     case SRE_CATEGORY_UNI_NOT_DIGIT:
; 207  :         return !SRE_UNI_IS_DIGIT(ch);

  001a5	8b cb		 mov	 ecx, ebx
  001a7	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  001ac	33 c9		 xor	 ecx, ecx
  001ae	85 c0		 test	 eax, eax
  001b0	0f 94 c1	 sete	 cl
  001b3	8b c1		 mov	 eax, ecx

; 222  : }

  001b5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001b9	5b		 pop	 rbx
  001ba	c3		 ret	 0
$LN6@sre_catego:

; 208  :     case SRE_CATEGORY_UNI_SPACE:
; 209  :         return SRE_UNI_IS_SPACE(ch);

  001bb	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  001c1	73 0e		 jae	 SHORT $LN47@sre_catego
  001c3	0f b6 84 13 00
	00 00 00	 movzx	 eax, BYTE PTR _Py_ascii_whitespace[rbx+rdx]

; 222  : }

  001cb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001cf	5b		 pop	 rbx
  001d0	c3		 ret	 0
$LN47@sre_catego:

; 208  :     case SRE_CATEGORY_UNI_SPACE:
; 209  :         return SRE_UNI_IS_SPACE(ch);

  001d1	8b cb		 mov	 ecx, ebx

; 222  : }

  001d3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d7	5b		 pop	 rbx
  001d8	e9 00 00 00 00	 jmp	 _PyUnicode_IsWhitespace
$LN5@sre_catego:

; 210  :     case SRE_CATEGORY_UNI_NOT_SPACE:
; 211  :         return !SRE_UNI_IS_SPACE(ch);

  001dd	81 fb 80 00 00
	00		 cmp	 ebx, 128		; 00000080H
  001e3	73 17		 jae	 SHORT $LN49@sre_catego
  001e5	0f b6 84 13 00
	00 00 00	 movzx	 eax, BYTE PTR _Py_ascii_whitespace[rbx+rdx]
  001ed	33 c9		 xor	 ecx, ecx
  001ef	85 c0		 test	 eax, eax
  001f1	0f 94 c1	 sete	 cl
  001f4	8b c1		 mov	 eax, ecx

; 222  : }

  001f6	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001fa	5b		 pop	 rbx
  001fb	c3		 ret	 0
$LN49@sre_catego:

; 210  :     case SRE_CATEGORY_UNI_NOT_SPACE:
; 211  :         return !SRE_UNI_IS_SPACE(ch);

  001fc	8b cb		 mov	 ecx, ebx
  001fe	e8 00 00 00 00	 call	 _PyUnicode_IsWhitespace
  00203	33 c9		 xor	 ecx, ecx
  00205	85 c0		 test	 eax, eax
  00207	0f 94 c1	 sete	 cl
  0020a	8b c1		 mov	 eax, ecx

; 222  : }

  0020c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00210	5b		 pop	 rbx
  00211	c3		 ret	 0
$LN4@sre_catego:

; 212  :     case SRE_CATEGORY_UNI_WORD:
; 213  :         return SRE_UNI_IS_WORD(ch);

  00212	8b cb		 mov	 ecx, ebx
  00214	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00219	85 c0		 test	 eax, eax
  0021b	0f 85 3d ff ff
	ff		 jne	 $LN41@sre_catego
  00221	8b cb		 mov	 ecx, ebx
  00223	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00228	85 c0		 test	 eax, eax
  0022a	0f 85 2e ff ff
	ff		 jne	 $LN41@sre_catego
  00230	8b cb		 mov	 ecx, ebx
  00232	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00237	85 c0		 test	 eax, eax
  00239	0f 85 1f ff ff
	ff		 jne	 $LN41@sre_catego
  0023f	8b cb		 mov	 ecx, ebx
  00241	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  00246	e9 00 ff ff ff	 jmp	 $LN59@sre_catego
$LN3@sre_catego:

; 214  :     case SRE_CATEGORY_UNI_NOT_WORD:
; 215  :         return !SRE_UNI_IS_WORD(ch);

  0024b	8b cb		 mov	 ecx, ebx
  0024d	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00252	85 c0		 test	 eax, eax
  00254	0f 85 e7 fd ff
	ff		 jne	 $LN23@sre_catego
  0025a	8b cb		 mov	 ecx, ebx
  0025c	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00261	85 c0		 test	 eax, eax
  00263	0f 85 d8 fd ff
	ff		 jne	 $LN23@sre_catego
  00269	8b cb		 mov	 ecx, ebx
  0026b	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00270	85 c0		 test	 eax, eax
  00272	0f 85 c9 fd ff
	ff		 jne	 $LN23@sre_catego
  00278	8b cb		 mov	 ecx, ebx
  0027a	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  0027f	e9 f7 fe ff ff	 jmp	 $LN58@sre_catego
$LN2@sre_catego:

; 216  :     case SRE_CATEGORY_UNI_LINEBREAK:
; 217  :         return SRE_UNI_IS_LINEBREAK(ch);

  00284	8b cb		 mov	 ecx, ebx

; 222  : }

  00286	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0028a	5b		 pop	 rbx
  0028b	e9 00 00 00 00	 jmp	 _PyUnicode_IsLinebreak
$LN1@sre_catego:

; 218  :     case SRE_CATEGORY_UNI_NOT_LINEBREAK:
; 219  :         return !SRE_UNI_IS_LINEBREAK(ch);

  00290	8b cb		 mov	 ecx, ebx
  00292	e8 00 00 00 00	 call	 _PyUnicode_IsLinebreak
  00297	33 c9		 xor	 ecx, ecx
  00299	85 c0		 test	 eax, eax
  0029b	0f 94 c1	 sete	 cl
  0029e	8b c1		 mov	 eax, ecx

; 222  : }

  002a0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002a4	5b		 pop	 rbx
  002a5	c3		 ret	 0
$LN19@sre_catego:

; 220  :     }
; 221  :     return 0;

  002a6	33 c0		 xor	 eax, eax

; 222  : }

  002a8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002ac	5b		 pop	 rbx
  002ad	c3		 ret	 0
  002ae	66 90		 npad	 2
$LN57@sre_catego:
  002b0	00 00 00 00	 DD	 $LN18@sre_catego
  002b4	00 00 00 00	 DD	 $LN17@sre_catego
  002b8	00 00 00 00	 DD	 $LN16@sre_catego
  002bc	00 00 00 00	 DD	 $LN15@sre_catego
  002c0	00 00 00 00	 DD	 $LN14@sre_catego
  002c4	00 00 00 00	 DD	 $LN13@sre_catego
  002c8	00 00 00 00	 DD	 $LN12@sre_catego
  002cc	00 00 00 00	 DD	 $LN11@sre_catego
  002d0	00 00 00 00	 DD	 $LN10@sre_catego
  002d4	00 00 00 00	 DD	 $LN9@sre_catego
  002d8	00 00 00 00	 DD	 $LN8@sre_catego
  002dc	00 00 00 00	 DD	 $LN7@sre_catego
  002e0	00 00 00 00	 DD	 $LN6@sre_catego
  002e4	00 00 00 00	 DD	 $LN5@sre_catego
  002e8	00 00 00 00	 DD	 $LN4@sre_catego
  002ec	00 00 00 00	 DD	 $LN3@sre_catego
  002f0	00 00 00 00	 DD	 $LN2@sre_catego
  002f4	00 00 00 00	 DD	 $LN1@sre_catego
sre_category ENDP
_TEXT	ENDS
EXTRN	_PyMem_DebugRealloc:PROC
EXTRN	_PxMem_Realloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$data_stack_grow DD imagerel data_stack_grow
	DD	imagerel data_stack_grow+143
	DD	imagerel $unwind$data_stack_grow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$data_stack_grow DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT data_stack_grow
_TEXT	SEGMENT
state$ = 48
size$ = 56
data_stack_grow PROC					; COMDAT

; 238  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 239  :     Py_ssize_t minsize, cursize;
; 240  :     minsize = state->data_stack_base+size;

  0000a	48 8b 81 a0 06
	00 00		 mov	 rax, QWORD PTR [rcx+1696]
  00011	48 8b d9	 mov	 rbx, rcx
  00014	48 8d 0c 02	 lea	 rcx, QWORD PTR [rdx+rax]

; 241  :     cursize = state->data_stack_size;
; 242  :     if (cursize < minsize) {

  00018	48 39 8b 98 06
	00 00		 cmp	 QWORD PTR [rbx+1688], rcx
  0001f	7d 61		 jge	 SHORT $LN2@data_stack

; 243  :         void* stack;
; 244  :         cursize = minsize+minsize/4+1024;

  00021	48 8b c1	 mov	 rax, rcx
  00024	48 99		 cdq
  00026	83 e2 03	 and	 edx, 3
  00029	48 03 c2	 add	 rax, rdx
  0002c	48 c1 f8 02	 sar	 rax, 2
  00030	48 8d bc 08 00
	04 00 00	 lea	 rdi, QWORD PTR [rax+rcx+1024]

; 245  :         TRACE(("allocate/grow stack %" PY_FORMAT_SIZE_T "d\n", cursize));
; 246  :         stack = PyMem_REALLOC(state->data_stack, cursize);

  00038	e8 00 00 00 00	 call	 _Py_PXCTX
  0003d	48 8b 8b 90 06
	00 00		 mov	 rcx, QWORD PTR [rbx+1680]
  00044	48 8b d7	 mov	 rdx, rdi
  00047	85 c0		 test	 eax, eax
  00049	74 07		 je	 SHORT $LN5@data_stack
  0004b	e8 00 00 00 00	 call	 _PxMem_Realloc
  00050	eb 05		 jmp	 SHORT $LN6@data_stack
$LN5@data_stack:
  00052	e8 00 00 00 00	 call	 _PyMem_DebugRealloc
$LN6@data_stack:

; 247  :         if (!stack) {

  00057	48 85 c0	 test	 rax, rax
  0005a	75 18		 jne	 SHORT $LN1@data_stack

; 248  :             data_stack_dealloc(state);

  0005c	48 8b cb	 mov	 rcx, rbx
  0005f	e8 00 00 00 00	 call	 data_stack_dealloc

; 249  :             return SRE_ERROR_MEMORY;

  00064	b8 f7 ff ff ff	 mov	 eax, -9

; 255  : }

  00069	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
$LN1@data_stack:

; 250  :         }
; 251  :         state->data_stack = (char *)stack;

  00074	48 89 83 90 06
	00 00		 mov	 QWORD PTR [rbx+1680], rax

; 252  :         state->data_stack_size = cursize;

  0007b	48 89 bb 98 06
	00 00		 mov	 QWORD PTR [rbx+1688], rdi
$LN2@data_stack:

; 253  :     }
; 254  :     return 0;

  00082	33 c0		 xor	 eax, eax

; 255  : }

  00084	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
data_stack_grow ENDP
_TEXT	ENDS
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$data_stack_dealloc DD imagerel data_stack_dealloc
	DD	imagerel data_stack_dealloc+98
	DD	imagerel $unwind$data_stack_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$data_stack_dealloc DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT data_stack_dealloc
_TEXT	SEGMENT
state$ = 48
data_stack_dealloc PROC					; COMDAT

; 228  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 229  :     if (state->data_stack) {

  00006	48 83 b9 90 06
	00 00 00	 cmp	 QWORD PTR [rcx+1680], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 39		 je	 SHORT $LN6@data_stack@2

; 230  :         PyMem_FREE(state->data_stack);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	48 8b 8b 90 06
	00 00		 mov	 rcx, QWORD PTR [rbx+1680]
  0001f	85 c0		 test	 eax, eax
  00021	74 07		 je	 SHORT $LN4@data_stack@2
  00023	e8 00 00 00 00	 call	 _PxMem_Free
  00028	eb 05		 jmp	 SHORT $LN5@data_stack@2
$LN4@data_stack@2:
  0002a	e8 00 00 00 00	 call	 _PyMem_DebugFree
$LN5@data_stack@2:

; 231  :         state->data_stack = NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	48 89 83 90 06
	00 00		 mov	 QWORD PTR [rbx+1680], rax

; 232  :     }
; 233  :     state->data_stack_size = state->data_stack_base = 0;

  00038	48 89 83 a0 06
	00 00		 mov	 QWORD PTR [rbx+1696], rax
  0003f	48 89 83 98 06
	00 00		 mov	 QWORD PTR [rbx+1688], rax

; 234  : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5b		 pop	 rbx
  0004b	c3		 ret	 0
$LN6@data_stack@2:

; 232  :     }
; 233  :     state->data_stack_size = state->data_stack_base = 0;

  0004c	33 c0		 xor	 eax, eax
  0004e	48 89 81 a0 06
	00 00		 mov	 QWORD PTR [rcx+1696], rax
  00055	48 89 81 98 06
	00 00		 mov	 QWORD PTR [rcx+1688], rax

; 234  : }

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
data_stack_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_at DD imagerel sre_at
	DD	imagerel sre_at+1096
	DD	imagerel $unwind$sre_at
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_at DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT sre_at
_TEXT	SEGMENT
state$ = 48
ptr$ = 56
at$ = 64
sre_at	PROC						; COMDAT

; 308  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	48 8b fa	 mov	 rdi, rdx
  0001d	48 8b e9	 mov	 rbp, rcx

; 309  :     /* check if pointer is at given position */
; 310  : 
; 311  :     Py_ssize_t thisp, thatp;
; 312  : 
; 313  :     switch (at) {

  00020	41 83 f8 0b	 cmp	 r8d, 11
  00024	0f 87 d0 03 00
	00		 ja	 $LN18@sre_at
  0002a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  00031	41 8b c0	 mov	 eax, r8d
  00034	41 8b 84 81 00
	00 00 00	 mov	 eax, DWORD PTR $LN97@sre_at[r9+rax*4]
  0003c	49 03 c1	 add	 rax, r9
  0003f	ff e0		 jmp	 rax
$LN17@sre_at:

; 314  : 
; 315  :     case SRE_AT_BEGINNING:
; 316  :     case SRE_AT_BEGINNING_STRING:
; 317  :         return ((void*) ptr == state->beginning);

  00041	33 db		 xor	 ebx, ebx
  00043	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00047	0f 94 c3	 sete	 bl
  0004a	8b c3		 mov	 eax, ebx
  0004c	e9 ab 03 00 00	 jmp	 $LN20@sre_at
$LN16@sre_at:

; 318  : 
; 319  :     case SRE_AT_BEGINNING_LINE:
; 320  :         return ((void*) ptr == state->beginning ||
; 321  :                 SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, -1)));

  00051	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00055	74 19		 je	 SHORT $LN24@sre_at
  00057	0f b6 42 ff	 movzx	 eax, BYTE PTR [rdx-1]
  0005b	3c 80		 cmp	 al, 128			; 00000080H
  0005d	73 4a		 jae	 SHORT $LN91@sre_at
  0005f	0f b6 c0	 movzx	 eax, al
  00062	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0006b	83 e1 04	 and	 ecx, 4
  0006e	74 39		 je	 SHORT $LN91@sre_at
$LN24@sre_at:
  00070	bb 01 00 00 00	 mov	 ebx, 1
  00075	8b c3		 mov	 eax, ebx
  00077	e9 80 03 00 00	 jmp	 $LN20@sre_at
$LN15@sre_at:

; 322  : 
; 323  :     case SRE_AT_END:
; 324  :         return (((void*) (ptr+state->charsize) == state->end &&
; 325  :                  SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, 0))) ||
; 326  :                 ((void*) ptr == state->end));

  0007c	48 63 41 3c	 movsxd	 rax, DWORD PTR [rcx+60]
  00080	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  00084	48 03 c7	 add	 rax, rdi
  00087	48 3b c2	 cmp	 rax, rdx
  0008a	75 18		 jne	 SHORT $LN28@sre_at
  0008c	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  0008f	3c 80		 cmp	 al, 128			; 00000080H
  00091	73 11		 jae	 SHORT $LN28@sre_at
  00093	0f b6 c0	 movzx	 eax, al
  00096	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0009f	83 e1 04	 and	 ecx, 4
  000a2	75 cc		 jne	 SHORT $LN24@sre_at
$LN28@sre_at:
  000a4	48 3b fa	 cmp	 rdi, rdx
  000a7	74 c7		 je	 SHORT $LN24@sre_at
$LN91@sre_at:
  000a9	33 db		 xor	 ebx, ebx
  000ab	8b c3		 mov	 eax, ebx
  000ad	e9 4a 03 00 00	 jmp	 $LN20@sre_at
$LN14@sre_at:

; 327  : 
; 328  :     case SRE_AT_END_LINE:
; 329  :         return ((void*) ptr == state->end ||
; 330  :                 SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, 0)));

  000b2	48 3b 51 18	 cmp	 rdx, QWORD PTR [rcx+24]
  000b6	74 b8		 je	 SHORT $LN24@sre_at
  000b8	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  000bb	3c 80		 cmp	 al, 128			; 00000080H
  000bd	73 11		 jae	 SHORT $LN92@sre_at
  000bf	0f b6 c0	 movzx	 eax, al
  000c2	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  000cb	83 e1 04	 and	 ecx, 4
  000ce	75 a0		 jne	 SHORT $LN24@sre_at
$LN92@sre_at:
  000d0	33 db		 xor	 ebx, ebx
  000d2	8b c3		 mov	 eax, ebx
  000d4	e9 23 03 00 00	 jmp	 $LN20@sre_at
$LN13@sre_at:

; 331  : 
; 332  :     case SRE_AT_END_STRING:
; 333  :         return ((void*) ptr == state->end);

  000d9	33 db		 xor	 ebx, ebx
  000db	48 3b 51 18	 cmp	 rdx, QWORD PTR [rcx+24]
  000df	0f 94 c3	 sete	 bl
  000e2	8b c3		 mov	 eax, ebx
  000e4	e9 13 03 00 00	 jmp	 $LN20@sre_at
$LN12@sre_at:

; 334  : 
; 335  :     case SRE_AT_BOUNDARY:
; 336  :         if (state->beginning == state->end)

  000e9	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  000ed	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  000f1	48 3b c2	 cmp	 rax, rdx

; 337  :             return 0;

  000f4	0f 84 00 03 00
	00		 je	 $LN18@sre_at

; 338  :         thatp = ((void*) ptr > state->beginning) ?
; 339  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  000fa	33 db		 xor	 ebx, ebx
  000fc	48 3b f8	 cmp	 rdi, rax
  000ff	76 19		 jbe	 SHORT $LN37@sre_at
  00101	0f b6 47 ff	 movzx	 eax, BYTE PTR [rdi-1]
  00105	3c 80		 cmp	 al, 128			; 00000080H
  00107	73 11		 jae	 SHORT $LN37@sre_at
  00109	0f b6 c0	 movzx	 eax, al
  0010c	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00115	83 e1 10	 and	 ecx, 16
  00118	eb 02		 jmp	 SHORT $LN38@sre_at
$LN37@sre_at:
  0011a	8b cb		 mov	 ecx, ebx
$LN38@sre_at:
  0011c	4c 63 c1	 movsxd	 r8, ecx

; 340  :         thisp = ((void*) ptr < state->end) ?
; 341  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0011f	48 3b fa	 cmp	 rdi, rdx
  00122	73 26		 jae	 SHORT $LN41@sre_at
  00124	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  00127	3c 80		 cmp	 al, 128			; 00000080H
  00129	73 1f		 jae	 SHORT $LN41@sre_at
  0012b	0f b6 c0	 movzx	 eax, al
  0012e	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00137	83 e1 10	 and	 ecx, 16

; 342  :         return thisp != thatp;

  0013a	48 63 c1	 movsxd	 rax, ecx
  0013d	49 3b c0	 cmp	 rax, r8
  00140	0f 95 c3	 setne	 bl
  00143	8b c3		 mov	 eax, ebx
  00145	e9 b2 02 00 00	 jmp	 $LN20@sre_at
$LN41@sre_at:
  0014a	48 63 c3	 movsxd	 rax, ebx
  0014d	8b cb		 mov	 ecx, ebx
  0014f	49 3b c0	 cmp	 rax, r8
  00152	0f 95 c3	 setne	 bl
  00155	8b c3		 mov	 eax, ebx
  00157	e9 a0 02 00 00	 jmp	 $LN20@sre_at
$LN10@sre_at:

; 343  : 
; 344  :     case SRE_AT_NON_BOUNDARY:
; 345  :         if (state->beginning == state->end)

  0015c	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00160	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  00164	48 3b c2	 cmp	 rax, rdx

; 346  :             return 0;

  00167	0f 84 8d 02 00
	00		 je	 $LN18@sre_at

; 347  :         thatp = ((void*) ptr > state->beginning) ?
; 348  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  0016d	33 db		 xor	 ebx, ebx
  0016f	48 3b f8	 cmp	 rdi, rax
  00172	76 19		 jbe	 SHORT $LN45@sre_at
  00174	0f b6 47 ff	 movzx	 eax, BYTE PTR [rdi-1]
  00178	3c 80		 cmp	 al, 128			; 00000080H
  0017a	73 11		 jae	 SHORT $LN45@sre_at
  0017c	0f b6 c0	 movzx	 eax, al
  0017f	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00188	83 e1 10	 and	 ecx, 16
  0018b	eb 02		 jmp	 SHORT $LN46@sre_at
$LN45@sre_at:
  0018d	8b cb		 mov	 ecx, ebx
$LN46@sre_at:
  0018f	4c 63 c1	 movsxd	 r8, ecx

; 349  :         thisp = ((void*) ptr < state->end) ?
; 350  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00192	48 3b fa	 cmp	 rdi, rdx
  00195	73 26		 jae	 SHORT $LN49@sre_at
  00197	0f b6 07	 movzx	 eax, BYTE PTR [rdi]
  0019a	3c 80		 cmp	 al, 128			; 00000080H
  0019c	73 1f		 jae	 SHORT $LN49@sre_at
  0019e	0f b6 c0	 movzx	 eax, al
  001a1	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  001aa	83 e1 10	 and	 ecx, 16

; 351  :         return thisp == thatp;

  001ad	48 63 c1	 movsxd	 rax, ecx
  001b0	49 3b c0	 cmp	 rax, r8
  001b3	0f 94 c3	 sete	 bl
  001b6	8b c3		 mov	 eax, ebx
  001b8	e9 3f 02 00 00	 jmp	 $LN20@sre_at
$LN49@sre_at:
  001bd	48 63 c3	 movsxd	 rax, ebx
  001c0	8b cb		 mov	 ecx, ebx
  001c2	49 3b c0	 cmp	 rax, r8
  001c5	0f 94 c3	 sete	 bl
  001c8	8b c3		 mov	 eax, ebx
  001ca	e9 2d 02 00 00	 jmp	 $LN20@sre_at
$LN8@sre_at:

; 352  : 
; 353  :     case SRE_AT_LOC_BOUNDARY:
; 354  :         if (state->beginning == state->end)

  001cf	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  001d3	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 355  :             return 0;

  001d7	0f 84 1d 02 00
	00		 je	 $LN18@sre_at

; 356  :         thatp = ((void*) ptr > state->beginning) ?
; 357  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  001dd	33 db		 xor	 ebx, ebx
  001df	8d 73 01	 lea	 esi, QWORD PTR [rbx+1]
  001e2	48 3b d0	 cmp	 rdx, rax
  001e5	76 20		 jbe	 SHORT $LN55@sre_at
  001e7	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  001eb	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  001f1	75 0a		 jne	 SHORT $LN93@sre_at
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  001f9	85 c0		 test	 eax, eax
  001fb	75 06		 jne	 SHORT $LN53@sre_at
$LN93@sre_at:
  001fd	80 7f ff 5f	 cmp	 BYTE PTR [rdi-1], 95	; 0000005fH
  00201	75 04		 jne	 SHORT $LN55@sre_at
$LN53@sre_at:
  00203	8b c6		 mov	 eax, esi
  00205	eb 02		 jmp	 SHORT $LN56@sre_at
$LN55@sre_at:
  00207	8b c3		 mov	 eax, ebx
$LN56@sre_at:
  00209	4c 63 e0	 movsxd	 r12, eax

; 358  :         thisp = ((void*) ptr < state->end) ?
; 359  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0020c	48 3b 7d 18	 cmp	 rdi, QWORD PTR [rbp+24]
  00210	73 1a		 jae	 SHORT $LN61@sre_at
  00212	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00215	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  0021b	75 0a		 jne	 SHORT $LN94@sre_at
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  00223	85 c0		 test	 eax, eax
  00225	75 07		 jne	 SHORT $LN62@sre_at
$LN94@sre_at:
  00227	80 3f 5f	 cmp	 BYTE PTR [rdi], 95	; 0000005fH
  0022a	74 02		 je	 SHORT $LN62@sre_at
$LN61@sre_at:
  0022c	8b f3		 mov	 esi, ebx
$LN62@sre_at:

; 360  :         return thisp != thatp;

  0022e	48 63 c6	 movsxd	 rax, esi
  00231	49 3b c4	 cmp	 rax, r12
  00234	0f 95 c3	 setne	 bl
  00237	8b c3		 mov	 eax, ebx
  00239	e9 be 01 00 00	 jmp	 $LN20@sre_at
$LN6@sre_at:

; 361  : 
; 362  :     case SRE_AT_LOC_NON_BOUNDARY:
; 363  :         if (state->beginning == state->end)

  0023e	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00242	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 364  :             return 0;

  00246	0f 84 ae 01 00
	00		 je	 $LN18@sre_at

; 365  :         thatp = ((void*) ptr > state->beginning) ?
; 366  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  0024c	33 db		 xor	 ebx, ebx
  0024e	8d 73 01	 lea	 esi, QWORD PTR [rbx+1]
  00251	48 3b d0	 cmp	 rdx, rax
  00254	76 20		 jbe	 SHORT $LN67@sre_at
  00256	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  0025a	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  00260	75 0a		 jne	 SHORT $LN95@sre_at
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  00268	85 c0		 test	 eax, eax
  0026a	75 06		 jne	 SHORT $LN65@sre_at
$LN95@sre_at:
  0026c	80 7f ff 5f	 cmp	 BYTE PTR [rdi-1], 95	; 0000005fH
  00270	75 04		 jne	 SHORT $LN67@sre_at
$LN65@sre_at:
  00272	8b c6		 mov	 eax, esi
  00274	eb 02		 jmp	 SHORT $LN68@sre_at
$LN67@sre_at:
  00276	8b c3		 mov	 eax, ebx
$LN68@sre_at:
  00278	4c 63 e0	 movsxd	 r12, eax

; 367  :         thisp = ((void*) ptr < state->end) ?
; 368  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0027b	48 3b 7d 18	 cmp	 rdi, QWORD PTR [rbp+24]
  0027f	73 1a		 jae	 SHORT $LN73@sre_at
  00281	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00284	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  0028a	75 0a		 jne	 SHORT $LN96@sre_at
  0028c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  00292	85 c0		 test	 eax, eax
  00294	75 07		 jne	 SHORT $LN74@sre_at
$LN96@sre_at:
  00296	80 3f 5f	 cmp	 BYTE PTR [rdi], 95	; 0000005fH
  00299	74 02		 je	 SHORT $LN74@sre_at
$LN73@sre_at:
  0029b	8b f3		 mov	 esi, ebx
$LN74@sre_at:

; 369  :         return thisp == thatp;

  0029d	48 63 c6	 movsxd	 rax, esi
  002a0	49 3b c4	 cmp	 rax, r12
  002a3	0f 94 c3	 sete	 bl
  002a6	8b c3		 mov	 eax, ebx
  002a8	e9 4f 01 00 00	 jmp	 $LN20@sre_at
$LN4@sre_at:

; 370  : 
; 371  :     case SRE_AT_UNI_BOUNDARY:
; 372  :         if (state->beginning == state->end)

  002ad	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  002b1	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 373  :             return 0;

  002b5	0f 84 3f 01 00
	00		 je	 $LN18@sre_at

; 374  :         thatp = ((void*) ptr > state->beginning) ?
; 375  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  002bb	33 db		 xor	 ebx, ebx
  002bd	8d 73 01	 lea	 esi, QWORD PTR [rbx+1]
  002c0	48 3b d0	 cmp	 rdx, rax
  002c3	76 3e		 jbe	 SHORT $LN77@sre_at
  002c5	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  002c9	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  002ce	85 c0		 test	 eax, eax
  002d0	75 2d		 jne	 SHORT $LN75@sre_at
  002d2	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  002d6	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  002db	85 c0		 test	 eax, eax
  002dd	75 20		 jne	 SHORT $LN75@sre_at
  002df	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  002e3	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  002e8	85 c0		 test	 eax, eax
  002ea	75 13		 jne	 SHORT $LN75@sre_at
  002ec	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  002f0	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  002f5	85 c0		 test	 eax, eax
  002f7	75 06		 jne	 SHORT $LN75@sre_at
  002f9	80 7f ff 5f	 cmp	 BYTE PTR [rdi-1], 95	; 0000005fH
  002fd	75 04		 jne	 SHORT $LN77@sre_at
$LN75@sre_at:
  002ff	8b c6		 mov	 eax, esi
  00301	eb 02		 jmp	 SHORT $LN78@sre_at
$LN77@sre_at:
  00303	8b c3		 mov	 eax, ebx
$LN78@sre_at:
  00305	4c 63 e0	 movsxd	 r12, eax

; 376  :         thisp = ((void*) ptr < state->end) ?
; 377  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00308	48 3b 7d 18	 cmp	 rdi, QWORD PTR [rbp+24]
  0030c	73 35		 jae	 SHORT $LN81@sre_at
  0030e	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00311	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00316	85 c0		 test	 eax, eax
  00318	75 2b		 jne	 SHORT $LN82@sre_at
  0031a	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  0031d	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00322	85 c0		 test	 eax, eax
  00324	75 1f		 jne	 SHORT $LN82@sre_at
  00326	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00329	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  0032e	85 c0		 test	 eax, eax
  00330	75 13		 jne	 SHORT $LN82@sre_at
  00332	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  00335	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  0033a	85 c0		 test	 eax, eax
  0033c	75 07		 jne	 SHORT $LN82@sre_at
  0033e	80 3f 5f	 cmp	 BYTE PTR [rdi], 95	; 0000005fH
  00341	74 02		 je	 SHORT $LN82@sre_at
$LN81@sre_at:
  00343	8b f3		 mov	 esi, ebx
$LN82@sre_at:

; 378  :         return thisp != thatp;

  00345	48 63 c6	 movsxd	 rax, esi
  00348	49 3b c4	 cmp	 rax, r12
  0034b	0f 95 c3	 setne	 bl
  0034e	8b c3		 mov	 eax, ebx
  00350	e9 a7 00 00 00	 jmp	 $LN20@sre_at
$LN2@sre_at:

; 379  : 
; 380  :     case SRE_AT_UNI_NON_BOUNDARY:
; 381  :         if (state->beginning == state->end)

  00355	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00359	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 382  :             return 0;

  0035d	0f 84 97 00 00
	00		 je	 $LN18@sre_at

; 383  :         thatp = ((void*) ptr > state->beginning) ?
; 384  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  00363	33 db		 xor	 ebx, ebx
  00365	8d 73 01	 lea	 esi, QWORD PTR [rbx+1]
  00368	48 3b d0	 cmp	 rdx, rax
  0036b	76 3e		 jbe	 SHORT $LN85@sre_at
  0036d	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00371	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00376	85 c0		 test	 eax, eax
  00378	75 2d		 jne	 SHORT $LN83@sre_at
  0037a	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  0037e	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00383	85 c0		 test	 eax, eax
  00385	75 20		 jne	 SHORT $LN83@sre_at
  00387	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  0038b	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00390	85 c0		 test	 eax, eax
  00392	75 13		 jne	 SHORT $LN83@sre_at
  00394	0f b6 4f ff	 movzx	 ecx, BYTE PTR [rdi-1]
  00398	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  0039d	85 c0		 test	 eax, eax
  0039f	75 06		 jne	 SHORT $LN83@sre_at
  003a1	80 7f ff 5f	 cmp	 BYTE PTR [rdi-1], 95	; 0000005fH
  003a5	75 04		 jne	 SHORT $LN85@sre_at
$LN83@sre_at:
  003a7	8b c6		 mov	 eax, esi
  003a9	eb 02		 jmp	 SHORT $LN86@sre_at
$LN85@sre_at:
  003ab	8b c3		 mov	 eax, ebx
$LN86@sre_at:
  003ad	4c 63 e0	 movsxd	 r12, eax

; 385  :         thisp = ((void*) ptr < state->end) ?
; 386  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  003b0	48 3b 7d 18	 cmp	 rdi, QWORD PTR [rbp+24]
  003b4	73 35		 jae	 SHORT $LN89@sre_at
  003b6	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  003b9	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  003be	85 c0		 test	 eax, eax
  003c0	75 2b		 jne	 SHORT $LN90@sre_at
  003c2	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  003c5	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  003ca	85 c0		 test	 eax, eax
  003cc	75 1f		 jne	 SHORT $LN90@sre_at
  003ce	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  003d1	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  003d6	85 c0		 test	 eax, eax
  003d8	75 13		 jne	 SHORT $LN90@sre_at
  003da	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  003dd	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  003e2	85 c0		 test	 eax, eax
  003e4	75 07		 jne	 SHORT $LN90@sre_at
  003e6	80 3f 5f	 cmp	 BYTE PTR [rdi], 95	; 0000005fH
  003e9	74 02		 je	 SHORT $LN90@sre_at
$LN89@sre_at:
  003eb	8b f3		 mov	 esi, ebx
$LN90@sre_at:

; 387  :         return thisp == thatp;

  003ed	48 63 ce	 movsxd	 rcx, esi
  003f0	49 3b cc	 cmp	 rcx, r12
  003f3	0f 94 c3	 sete	 bl
  003f6	8b c3		 mov	 eax, ebx
  003f8	eb 02		 jmp	 SHORT $LN20@sre_at
$LN18@sre_at:

; 388  : 
; 389  :     }
; 390  : 
; 391  :     return 0;

  003fa	33 c0		 xor	 eax, eax
$LN20@sre_at:

; 392  : }

  003fc	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00401	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00406	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0040b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00410	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00414	41 5c		 pop	 r12
  00416	c3		 ret	 0
  00417	90		 npad	 1
$LN97@sre_at:
  00418	00 00 00 00	 DD	 $LN17@sre_at
  0041c	00 00 00 00	 DD	 $LN16@sre_at
  00420	00 00 00 00	 DD	 $LN17@sre_at
  00424	00 00 00 00	 DD	 $LN12@sre_at
  00428	00 00 00 00	 DD	 $LN10@sre_at
  0042c	00 00 00 00	 DD	 $LN15@sre_at
  00430	00 00 00 00	 DD	 $LN14@sre_at
  00434	00 00 00 00	 DD	 $LN13@sre_at
  00438	00 00 00 00	 DD	 $LN8@sre_at
  0043c	00 00 00 00	 DD	 $LN6@sre_at
  00440	00 00 00 00	 DD	 $LN4@sre_at
  00444	00 00 00 00	 DD	 $LN2@sre_at
sre_at	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_charset DD imagerel sre_charset
	DD	imagerel sre_charset+392
	DD	imagerel $unwind$sre_charset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_charset DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT sre_charset
_TEXT	SEGMENT
set$ = 48
ch$ = 56
sre_charset PROC					; COMDAT

; 396  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 397  :     /* check if character is a member of the given set */
; 398  : 
; 399  :     int ok = 1;
; 400  : 
; 401  :     for (;;) {
; 402  :         switch (*set++) {

  0001a	8b 01		 mov	 eax, DWORD PTR [rcx]
  0001c	8b f2		 mov	 esi, edx
  0001e	bf 01 00 00 00	 mov	 edi, 1
  00023	48 8d 59 04	 lea	 rbx, QWORD PTR [rcx+4]
  00027	83 f8 1b	 cmp	 eax, 27
  0002a	0f 87 ee 00 00
	00		 ja	 $LN1@sre_charse
  00030	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:__ImageBase
  00037	33 ed		 xor	 ebp, ebp
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL25@sre_charse:
  00040	41 0f b6 84 04
	00 00 00 00	 movzx	 eax, BYTE PTR $LN34@sre_charse[r12+rax]
  00049	41 8b 8c 84 00
	00 00 00	 mov	 ecx, DWORD PTR $LN35@sre_charse[r12+rax*4]
  00051	49 03 cc	 add	 rcx, r12
  00054	ff e1		 jmp	 rcx
$LN20@sre_charse:

; 406  : 
; 407  :         case SRE_OP_LITERAL:
; 408  :             /* <LITERAL> <code> */
; 409  :             if (ch == set[0])

  00056	3b 33		 cmp	 esi, DWORD PTR [rbx]
  00058	0f 84 dd 00 00
	00		 je	 $LN29@sre_charse

; 411  :             set++;

  0005e	48 83 c3 04	 add	 rbx, 4

; 412  :             break;

  00062	e9 a8 00 00 00	 jmp	 $LN5@sre_charse
$LN18@sre_charse:

; 413  : 
; 414  :         case SRE_OP_CATEGORY:
; 415  :             /* <CATEGORY> <code> */
; 416  :             if (sre_category(set[0], (int) ch))

  00067	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00069	8b d6		 mov	 edx, esi
  0006b	e8 00 00 00 00	 call	 sre_category
  00070	85 c0		 test	 eax, eax
  00072	0f 85 c3 00 00
	00		 jne	 $LN29@sre_charse

; 417  :                 return ok;
; 418  :             set += 1;

  00078	48 83 c3 04	 add	 rbx, 4

; 419  :             break;

  0007c	e9 8e 00 00 00	 jmp	 $LN5@sre_charse
$LN16@sre_charse:

; 420  : 
; 421  :         case SRE_OP_CHARSET:
; 422  :             if (sizeof(SRE_CODE) == 2) {
; 423  :                 /* <CHARSET> <bitmap> (16 bits per code word) */
; 424  :                 if (ch < 256 && (set[ch >> 4] & (1 << (ch & 15))))
; 425  :                     return ok;
; 426  :                 set += 16;
; 427  :             }
; 428  :             else {
; 429  :                 /* <CHARSET> <bitmap> (32 bits per code word) */
; 430  :                 if (ch < 256 && (set[ch >> 5] & (1u << (ch & 31))))

  00081	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H
  00087	73 18		 jae	 SHORT $LN12@sre_charse
  00089	48 8b c6	 mov	 rax, rsi
  0008c	8b ce		 mov	 ecx, esi
  0008e	48 c1 e8 05	 shr	 rax, 5
  00092	83 e1 1f	 and	 ecx, 31
  00095	8b 04 83	 mov	 eax, DWORD PTR [rbx+rax*4]
  00098	0f a3 c8	 bt	 eax, ecx
  0009b	0f 82 9a 00 00
	00		 jb	 $LN29@sre_charse
$LN12@sre_charse:

; 431  :                     return ok;
; 432  :                 set += 8;

  000a1	48 83 c3 20	 add	 rbx, 32			; 00000020H

; 433  :             }
; 434  :             break;

  000a5	eb 68		 jmp	 SHORT $LN5@sre_charse
$LN11@sre_charse:

; 435  : 
; 436  :         case SRE_OP_RANGE:
; 437  :             /* <RANGE> <lower> <upper> */
; 438  :             if (set[0] <= ch && ch <= set[1])

  000a7	39 33		 cmp	 DWORD PTR [rbx], esi
  000a9	77 09		 ja	 SHORT $LN10@sre_charse
  000ab	3b 73 04	 cmp	 esi, DWORD PTR [rbx+4]
  000ae	0f 86 87 00 00
	00		 jbe	 $LN29@sre_charse
$LN10@sre_charse:

; 439  :                 return ok;
; 440  :             set += 2;

  000b4	48 83 c3 08	 add	 rbx, 8

; 441  :             break;

  000b8	eb 55		 jmp	 SHORT $LN5@sre_charse
$LN9@sre_charse:

; 442  : 
; 443  :         case SRE_OP_NEGATE:
; 444  :             ok = !ok;

  000ba	85 ff		 test	 edi, edi
  000bc	8b c5		 mov	 eax, ebp
  000be	0f 94 c0	 sete	 al
  000c1	8b f8		 mov	 edi, eax

; 445  :             break;

  000c3	eb 4a		 jmp	 SHORT $LN5@sre_charse
$LN8@sre_charse:

; 446  : 
; 447  :         case SRE_OP_BIGCHARSET:
; 448  :             /* <BIGCHARSET> <blockcount> <256 blockindices> <blocks> */
; 449  :         {
; 450  :             Py_ssize_t count, block;
; 451  :             count = *(set++);

  000c5	44 8b 03	 mov	 r8d, DWORD PTR [rbx]

; 452  : 
; 453  :             if (sizeof(SRE_CODE) == 2) {
; 454  :                 block = ((unsigned char*)set)[ch >> 8];
; 455  :                 set += 128;
; 456  :                 if (set[block*16 + ((ch & 255)>>4)] & (1 << (ch & 15)))
; 457  :                     return ok;
; 458  :                 set += count*16;
; 459  :             }
; 460  :             else {
; 461  :                 /* !(c & ~N) == (c < N+1) for any unsigned c, this avoids
; 462  :                  * warnings when c's type supports only numbers < N+1 */
; 463  :                 if (!(ch & ~65535))

  000c8	f7 c6 00 00 ff
	ff		 test	 esi, -65536		; ffff0000H
  000ce	75 0e		 jne	 SHORT $LN4@sre_charse

; 464  :                     block = ((unsigned char*)set)[ch >> 8];

  000d0	48 8b c6	 mov	 rax, rsi
  000d3	48 c1 e8 08	 shr	 rax, 8
  000d7	0f b6 4c 18 04	 movzx	 ecx, BYTE PTR [rax+rbx+4]

; 465  :                 else

  000dc	eb 04		 jmp	 SHORT $LN3@sre_charse
$LN4@sre_charse:

; 466  :                     block = -1;

  000de	48 83 c9 ff	 or	 rcx, -1
$LN3@sre_charse:

; 467  :                 set += 64;

  000e2	48 81 c3 04 01
	00 00		 add	 rbx, 260		; 00000104H

; 468  :                 if (block >=0 &&
; 469  :                     (set[block*8 + ((ch & 255)>>5)] & (1u << (ch & 31))))

  000e9	48 85 c9	 test	 rcx, rcx
  000ec	78 1a		 js	 SHORT $LN2@sre_charse
  000ee	8b c6		 mov	 eax, esi
  000f0	48 c1 e8 05	 shr	 rax, 5
  000f4	83 e0 07	 and	 eax, 7
  000f7	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  000fb	8b ce		 mov	 ecx, esi
  000fd	8b 04 93	 mov	 eax, DWORD PTR [rbx+rdx*4]
  00100	83 e1 1f	 and	 ecx, 31
  00103	0f a3 c8	 bt	 eax, ecx
  00106	72 33		 jb	 SHORT $LN29@sre_charse
$LN2@sre_charse:

; 470  :                     return ok;
; 471  :                 set += count*8;

  00108	49 c1 e0 05	 shl	 r8, 5
  0010c	49 03 d8	 add	 rbx, r8
$LN5@sre_charse:

; 397  :     /* check if character is a member of the given set */
; 398  : 
; 399  :     int ok = 1;
; 400  : 
; 401  :     for (;;) {
; 402  :         switch (*set++) {

  0010f	8b 03		 mov	 eax, DWORD PTR [rbx]
  00111	48 83 c3 04	 add	 rbx, 4
  00115	83 f8 1b	 cmp	 eax, 27
  00118	0f 86 22 ff ff
	ff		 jbe	 $LL25@sre_charse
$LN1@sre_charse:

; 472  :             }
; 473  :             break;
; 474  :         }
; 475  : 
; 476  :         default:
; 477  :             /* internal error -- there's not much we can do about it
; 478  :                here, so let's just pretend it didn't match... */
; 479  :             return 0;

  0011e	33 c0		 xor	 eax, eax
$LN24@sre_charse:

; 480  :         }
; 481  :     }
; 482  : }

  00120	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00125	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0012a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0012f	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00134	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00138	41 5c		 pop	 r12
  0013a	c3		 ret	 0
$LN29@sre_charse:

; 410  :                 return ok;

  0013b	8b c7		 mov	 eax, edi
  0013d	eb e1		 jmp	 SHORT $LN24@sre_charse
$LN21@sre_charse:

; 403  : 
; 404  :         case SRE_OP_FAILURE:
; 405  :             return !ok;

  0013f	85 ff		 test	 edi, edi
  00141	40 0f 94 c5	 sete	 bpl
  00145	8b c5		 mov	 eax, ebp
  00147	eb d7		 jmp	 SHORT $LN24@sre_charse
  00149	0f 1f 00	 npad	 3
$LN35@sre_charse:

; 480  :         }
; 481  :     }
; 482  : }

  0014c	00 00 00 00	 DD	 $LN21@sre_charse
  00150	00 00 00 00	 DD	 $LN18@sre_charse
  00154	00 00 00 00	 DD	 $LN16@sre_charse
  00158	00 00 00 00	 DD	 $LN8@sre_charse
  0015c	00 00 00 00	 DD	 $LN20@sre_charse
  00160	00 00 00 00	 DD	 $LN9@sre_charse
  00164	00 00 00 00	 DD	 $LN11@sre_charse
  00168	00 00 00 00	 DD	 $LN1@sre_charse
$LN34@sre_charse:
  0016c	00		 DB	 0
  0016d	07		 DB	 7
  0016e	07		 DB	 7
  0016f	07		 DB	 7
  00170	07		 DB	 7
  00171	07		 DB	 7
  00172	07		 DB	 7
  00173	07		 DB	 7
  00174	07		 DB	 7
  00175	01		 DB	 1
  00176	02		 DB	 2
  00177	03		 DB	 3
  00178	07		 DB	 7
  00179	07		 DB	 7
  0017a	07		 DB	 7
  0017b	07		 DB	 7
  0017c	07		 DB	 7
  0017d	07		 DB	 7
  0017e	07		 DB	 7
  0017f	04		 DB	 4
  00180	07		 DB	 7
  00181	07		 DB	 7
  00182	07		 DB	 7
  00183	07		 DB	 7
  00184	07		 DB	 7
  00185	07		 DB	 7
  00186	05		 DB	 5
  00187	06		 DB	 6
sre_charset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_count DD imagerel sre_count
	DD	imagerel sre_count+532
	DD	imagerel $unwind$sre_count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_count DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT sre_count
_TEXT	SEGMENT
state$ = 48
pattern$ = 56
maxcount$ = 64
sre_count PROC						; COMDAT

; 488  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 489  :     SRE_CODE chr;
; 490  :     char* ptr = (char *)state->ptr;
; 491  :     char* end = (char *)state->end;

  00014	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  00018	48 8b 19	 mov	 rbx, QWORD PTR [rcx]

; 492  :     Py_ssize_t i;
; 493  : 
; 494  :     /* adjust end */
; 495  :     if (maxcount < (end - ptr) / state->charsize && maxcount != SRE_MAXREPEAT)

  0001b	4c 63 49 3c	 movsxd	 r9, DWORD PTR [rcx+60]
  0001f	48 8b ea	 mov	 rbp, rdx
  00022	48 8b c7	 mov	 rax, rdi
  00025	48 8b f1	 mov	 rsi, rcx
  00028	48 2b c3	 sub	 rax, rbx
  0002b	48 99		 cdq
  0002d	49 f7 f9	 idiv	 r9
  00030	4c 3b c0	 cmp	 r8, rax
  00033	7d 14		 jge	 SHORT $LN27@sre_count
  00035	b8 ff ff ff ff	 mov	 eax, -1
  0003a	4c 3b c0	 cmp	 r8, rax
  0003d	74 0a		 je	 SHORT $LN27@sre_count

; 496  :         end = ptr + maxcount*state->charsize;

  0003f	49 8b f9	 mov	 rdi, r9
  00042	49 0f af f8	 imul	 rdi, r8
  00046	48 03 fb	 add	 rdi, rbx
$LN27@sre_count:

; 497  : 
; 498  :     switch (pattern[0]) {

  00049	8b 45 00	 mov	 eax, DWORD PTR [rbp]
  0004c	83 c0 fe	 add	 eax, -2			; fffffffeH
  0004f	83 f8 17	 cmp	 eax, 23
  00052	0f 87 39 01 00
	00		 ja	 $LN38@sre_count
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0005f	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN48@sre_count[rdx+rax]
  00067	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN49@sre_count[rdx+rax*4]
  0006e	48 03 ca	 add	 rcx, rdx
  00071	ff e1		 jmp	 rcx
$LN32@sre_count:

; 499  : 
; 500  :     case SRE_OP_IN:
; 501  :         /* repeated set */
; 502  :         TRACE(("|%p|%p|COUNT IN\n", pattern, ptr));
; 503  :         while (ptr < end &&
; 504  :                SRE_CHARSET(pattern + 2, SRE_CHARGET(state, ptr, 0)))

  00073	48 3b df	 cmp	 rbx, rdi
  00076	0f 83 0d 01 00
	00		 jae	 $LN50@sre_count
  0007c	0f 1f 40 00	 npad	 4
$LL23@sre_count:
  00080	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  00083	48 8d 4d 08	 lea	 rcx, QWORD PTR [rbp+8]
  00087	e8 00 00 00 00	 call	 sre_charset
  0008c	85 c0		 test	 eax, eax
  0008e	0f 84 f5 00 00
	00		 je	 $LN50@sre_count

; 505  :             ptr += state->charsize;

  00094	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  00098	48 03 d8	 add	 rbx, rax
  0009b	48 3b df	 cmp	 rbx, rdi
  0009e	72 e0		 jb	 SHORT $LL23@sre_count

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  000a0	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  000a3	48 8b c3	 mov	 rax, rbx
  000a6	e9 12 01 00 00	 jmp	 $LN51@sre_count
$LN33@sre_count:

; 506  :         break;
; 507  : 
; 508  :     case SRE_OP_ANY:
; 509  :         /* repeated dot wildcard. */
; 510  :         TRACE(("|%p|%p|COUNT ANY\n", pattern, ptr));
; 511  :         while (ptr < end && !SRE_IS_LINEBREAK(SRE_CHARGET(state, ptr, 0)))

  000ab	48 3b df	 cmp	 rbx, rdi
  000ae	0f 83 d5 00 00
	00		 jae	 $LN50@sre_count
$LL20@sre_count:
  000b4	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000b7	3c 80		 cmp	 al, 128			; 00000080H
  000b9	73 14		 jae	 SHORT $LN47@sre_count
  000bb	0f b6 c0	 movzx	 eax, al
  000be	0f be 8c 10 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+rdx]
  000c6	83 e1 04	 and	 ecx, 4
  000c9	0f 85 ba 00 00
	00		 jne	 $LN50@sre_count
$LN47@sre_count:

; 512  :             ptr += state->charsize;

  000cf	49 03 d9	 add	 rbx, r9
  000d2	48 3b df	 cmp	 rbx, rdi
  000d5	72 dd		 jb	 SHORT $LL20@sre_count

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  000d7	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  000da	48 8b c3	 mov	 rax, rbx
  000dd	e9 db 00 00 00	 jmp	 $LN51@sre_count
$LN18@sre_count:

; 513  :         break;
; 514  : 
; 515  :     case SRE_OP_ANY_ALL:
; 516  :         /* repeated dot wildcard.  skip to the end of the target
; 517  :            string, and backtrack from there */
; 518  :         TRACE(("|%p|%p|COUNT ANY_ALL\n", pattern, ptr));
; 519  :         ptr = end;

  000e2	48 8b df	 mov	 rbx, rdi

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  000e5	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  000e8	48 8b c3	 mov	 rax, rbx
  000eb	e9 cd 00 00 00	 jmp	 $LN51@sre_count
$LN17@sre_count:

; 520  :         break;
; 521  : 
; 522  :     case SRE_OP_LITERAL:
; 523  :         /* repeated literal */
; 524  :         chr = pattern[1];

  000f0	8b 4d 04	 mov	 ecx, DWORD PTR [rbp+4]

; 525  :         TRACE(("|%p|%p|COUNT LITERAL %d\n", pattern, ptr, chr));
; 526  :         while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) == chr)

  000f3	48 3b df	 cmp	 rbx, rdi
  000f6	0f 83 8d 00 00
	00		 jae	 $LN50@sre_count
  000fc	0f 1f 40 00	 npad	 4
$LL16@sre_count:
  00100	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00103	3b c1		 cmp	 eax, ecx
  00105	0f 85 7e 00 00
	00		 jne	 $LN50@sre_count

; 527  :             ptr += state->charsize;

  0010b	49 03 d9	 add	 rbx, r9
  0010e	48 3b df	 cmp	 rbx, rdi
  00111	72 ed		 jb	 SHORT $LL16@sre_count

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  00113	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00116	48 8b c3	 mov	 rax, rbx
  00119	e9 9f 00 00 00	 jmp	 $LN51@sre_count
$LN14@sre_count:

; 528  :         break;
; 529  : 
; 530  :     case SRE_OP_LITERAL_IGNORE:
; 531  :         /* repeated literal */
; 532  :         chr = pattern[1];

  0011e	8b 6d 04	 mov	 ebp, DWORD PTR [rbp+4]

; 533  :         TRACE(("|%p|%p|COUNT LITERAL_IGNORE %d\n", pattern, ptr, chr));
; 534  :         while (ptr < end && (SRE_CODE) state->lower(SRE_CHARGET(state, ptr, 0)) == chr)

  00121	48 3b df	 cmp	 rbx, rdi
  00124	73 63		 jae	 SHORT $LN50@sre_count
$LL13@sre_count:
  00126	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00129	ff 96 00 07 00
	00		 call	 QWORD PTR [rsi+1792]
  0012f	3b c5		 cmp	 eax, ebp
  00131	75 56		 jne	 SHORT $LN50@sre_count

; 535  :             ptr += state->charsize;

  00133	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  00137	48 03 d8	 add	 rbx, rax
  0013a	48 3b df	 cmp	 rbx, rdi
  0013d	72 e7		 jb	 SHORT $LL13@sre_count

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  0013f	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00142	48 8b c3	 mov	 rax, rbx
  00145	eb 76		 jmp	 SHORT $LN51@sre_count
$LN11@sre_count:

; 536  :         break;
; 537  : 
; 538  :     case SRE_OP_NOT_LITERAL:
; 539  :         /* repeated non-literal */
; 540  :         chr = pattern[1];

  00147	8b 4d 04	 mov	 ecx, DWORD PTR [rbp+4]

; 541  :         TRACE(("|%p|%p|COUNT NOT_LITERAL %d\n", pattern, ptr, chr));
; 542  :         while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) != chr)

  0014a	48 3b df	 cmp	 rbx, rdi
  0014d	73 3a		 jae	 SHORT $LN50@sre_count
  0014f	90		 npad	 1
$LL10@sre_count:
  00150	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00153	3b c1		 cmp	 eax, ecx
  00155	74 32		 je	 SHORT $LN50@sre_count

; 543  :             ptr += state->charsize;

  00157	49 03 d9	 add	 rbx, r9
  0015a	48 3b df	 cmp	 rbx, rdi
  0015d	72 f1		 jb	 SHORT $LL10@sre_count

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  0015f	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00162	48 8b c3	 mov	 rax, rbx
  00165	eb 56		 jmp	 SHORT $LN51@sre_count
$LN8@sre_count:

; 544  :         break;
; 545  : 
; 546  :     case SRE_OP_NOT_LITERAL_IGNORE:
; 547  :         /* repeated non-literal */
; 548  :         chr = pattern[1];

  00167	8b 6d 04	 mov	 ebp, DWORD PTR [rbp+4]

; 549  :         TRACE(("|%p|%p|COUNT NOT_LITERAL_IGNORE %d\n", pattern, ptr, chr));
; 550  :         while (ptr < end && (SRE_CODE) state->lower(SRE_CHARGET(state, ptr, 0)) != chr)

  0016a	48 3b df	 cmp	 rbx, rdi
  0016d	73 1a		 jae	 SHORT $LN50@sre_count
  0016f	90		 npad	 1
$LL7@sre_count:
  00170	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00173	ff 96 00 07 00
	00		 call	 QWORD PTR [rsi+1792]
  00179	3b c5		 cmp	 eax, ebp
  0017b	74 0c		 je	 SHORT $LN50@sre_count

; 551  :             ptr += state->charsize;

  0017d	48 63 4e 3c	 movsxd	 rcx, DWORD PTR [rsi+60]
  00181	48 03 d9	 add	 rbx, rcx
  00184	48 3b df	 cmp	 rbx, rdi
  00187	72 e7		 jb	 SHORT $LL7@sre_count
$LN50@sre_count:

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  00189	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  0018c	48 8b c3	 mov	 rax, rbx
  0018f	eb 2c		 jmp	 SHORT $LN51@sre_count
$LN38@sre_count:

; 552  :         break;
; 553  : 
; 554  :     default:
; 555  :         /* repeated single character pattern */
; 556  :         TRACE(("|%p|%p|COUNT SUBPATTERN\n", pattern, ptr));
; 557  :         while ((char*) state->ptr < end) {

  00191	48 3b df	 cmp	 rbx, rdi
  00194	73 21		 jae	 SHORT $LN40@sre_count
  00196	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@sre_count:

; 558  :             i = SRE_MATCH(state, pattern);

  001a0	48 8b d5	 mov	 rdx, rbp
  001a3	48 8b ce	 mov	 rcx, rsi
  001a6	e8 00 00 00 00	 call	 sre_match

; 559  :             if (i < 0)

  001ab	48 85 c0	 test	 rax, rax
  001ae	78 16		 js	 SHORT $LN28@sre_count

; 560  :                 return i;
; 561  :             if (!i)

  001b0	74 05		 je	 SHORT $LN40@sre_count

; 552  :         break;
; 553  : 
; 554  :     default:
; 555  :         /* repeated single character pattern */
; 556  :         TRACE(("|%p|%p|COUNT SUBPATTERN\n", pattern, ptr));
; 557  :         while ((char*) state->ptr < end) {

  001b2	48 39 3e	 cmp	 QWORD PTR [rsi], rdi
  001b5	72 e9		 jb	 SHORT $LL4@sre_count
$LN40@sre_count:

; 562  :                 break;
; 563  :         }
; 564  :         TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 565  :                ((char*)state->ptr - ptr)/state->charsize));
; 566  :         return ((char*)state->ptr - ptr)/state->charsize;

  001b7	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  001ba	48 2b c3	 sub	 rax, rbx
$LN51@sre_count:
  001bd	48 63 4e 3c	 movsxd	 rcx, DWORD PTR [rsi+60]
  001c1	48 99		 cdq
  001c3	48 f7 f9	 idiv	 rcx
$LN28@sre_count:

; 572  : }

  001c6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  001cb	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  001d0	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001d9	5f		 pop	 rdi
  001da	c3		 ret	 0
  001db	90		 npad	 1
$LN49@sre_count:
  001dc	00 00 00 00	 DD	 $LN33@sre_count
  001e0	00 00 00 00	 DD	 $LN18@sre_count
  001e4	00 00 00 00	 DD	 $LN32@sre_count
  001e8	00 00 00 00	 DD	 $LN17@sre_count
  001ec	00 00 00 00	 DD	 $LN14@sre_count
  001f0	00 00 00 00	 DD	 $LN11@sre_count
  001f4	00 00 00 00	 DD	 $LN8@sre_count
  001f8	00 00 00 00	 DD	 $LN38@sre_count
$LN48@sre_count:
  001fc	00		 DB	 0
  001fd	01		 DB	 1
  001fe	07		 DB	 7
  001ff	07		 DB	 7
  00200	07		 DB	 7
  00201	07		 DB	 7
  00202	07		 DB	 7
  00203	07		 DB	 7
  00204	07		 DB	 7
  00205	07		 DB	 7
  00206	07		 DB	 7
  00207	07		 DB	 7
  00208	07		 DB	 7
  00209	02		 DB	 2
  0020a	07		 DB	 7
  0020b	07		 DB	 7
  0020c	07		 DB	 7
  0020d	03		 DB	 3
  0020e	04		 DB	 4
  0020f	07		 DB	 7
  00210	07		 DB	 7
  00211	07		 DB	 7
  00212	05		 DB	 5
  00213	06		 DB	 6
sre_count ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_umatch DD imagerel sre_umatch
	DD	imagerel sre_umatch+100
	DD	imagerel $unwind$sre_umatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$sre_umatch DD imagerel sre_umatch+100
	DD	imagerel sre_umatch+5452
	DD	imagerel $chain$3$sre_umatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$sre_umatch DD imagerel sre_umatch+5452
	DD	imagerel sre_umatch+5632
	DD	imagerel $chain$5$sre_umatch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$sre_umatch DD 080021H
	DD	04c400H
	DD	0d7400H
	DD	0c6400H
	DD	0b5400H
	DD	imagerel sre_umatch
	DD	imagerel sre_umatch+100
	DD	imagerel $unwind$sre_umatch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$sre_umatch DD 082b21H
	DD	04c42bH
	DD	0d740fH
	DD	0c640aH
	DD	0b5405H
	DD	imagerel sre_umatch
	DD	imagerel sre_umatch+100
	DD	imagerel $unwind$sre_umatch
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_umatch DD 050c01H
	DD	0f008420cH
	DD	0d004e006H
	DD	03002H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT sre_umatch
_TEXT	SEGMENT
sigcount$1$ = 80
state$ = 80
pattern$ = 88
sre_umatch PROC						; COMDAT

; 782  : {

  00000	40 53		 push	 rbx
  00002	41 55		 push	 r13
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 783  :     char* end = (char*)state->end;
; 784  :     Py_ssize_t alloc_pos, ctx_pos = -1;
; 785  :     Py_ssize_t i, ret = 0;
; 786  :     Py_ssize_t jump;
; 787  :     unsigned int sigcount=0;
; 788  : 
; 789  :     SRE_MATCH_CONTEXT* ctx;
; 790  :     SRE_MATCH_CONTEXT* nextctx;
; 791  : 
; 792  :     TRACE(("|%p|%p|ENTER\n", pattern, state->ptr));
; 793  : 
; 794  :     DATA_ALLOC(SRE_MATCH_CONTEXT, ctx);

  0000c	4c 8b b1 a0 06
	00 00		 mov	 r14, QWORD PTR [rcx+1696]
  00013	48 8b 81 98 06
	00 00		 mov	 rax, QWORD PTR [rcx+1688]
  0001a	4c 8b 79 18	 mov	 r15, QWORD PTR [rcx+24]
  0001e	45 33 d2	 xor	 r10d, r10d
  00021	49 2b c6	 sub	 rax, r14
  00024	48 8b da	 mov	 rbx, rdx
  00027	4c 8b e9	 mov	 r13, rcx
  0002a	44 89 54 24 50	 mov	 DWORD PTR sigcount$1$[rsp], r10d
  0002f	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00033	73 20		 jae	 SHORT $LN709@sre_umatch
  00035	41 8d 52 40	 lea	 edx, QWORD PTR [r10+64]
  00039	e8 00 00 00 00	 call	 data_stack_grow
  0003e	85 c0		 test	 eax, eax
  00040	79 0e		 jns	 SHORT $LN873@sre_umatch
  00042	48 98		 cdqe

; 1427 :         case JUMP_MAX_UNTIL_2:
; 1428 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1429 :             goto jump_max_until_2;
; 1430 :         case JUMP_MAX_UNTIL_3:
; 1431 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1432 :             goto jump_max_until_3;
; 1433 :         case JUMP_MIN_UNTIL_2:
; 1434 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1435 :             goto jump_min_until_2;
; 1436 :         case JUMP_MIN_UNTIL_3:
; 1437 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1438 :             goto jump_min_until_3;
; 1439 :         case JUMP_BRANCH:
; 1440 :             TRACE(("|%p|%p|JUMP_BRANCH\n", ctx->pattern, ctx->ptr));
; 1441 :             goto jump_branch;
; 1442 :         case JUMP_MAX_UNTIL_1:
; 1443 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1444 :             goto jump_max_until_1;
; 1445 :         case JUMP_MIN_UNTIL_1:
; 1446 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1447 :             goto jump_min_until_1;
; 1448 :         case JUMP_REPEAT:
; 1449 :             TRACE(("|%p|%p|JUMP_REPEAT\n", ctx->pattern, ctx->ptr));
; 1450 :             goto jump_repeat;
; 1451 :         case JUMP_REPEAT_ONE_1:
; 1452 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_1\n", ctx->pattern, ctx->ptr));
; 1453 :             goto jump_repeat_one_1;
; 1454 :         case JUMP_REPEAT_ONE_2:
; 1455 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_2\n", ctx->pattern, ctx->ptr));
; 1456 :             goto jump_repeat_one_2;
; 1457 :         case JUMP_MIN_REPEAT_ONE:
; 1458 :             TRACE(("|%p|%p|JUMP_MIN_REPEAT_ONE\n", ctx->pattern, ctx->ptr));
; 1459 :             goto jump_min_repeat_one;
; 1460 :         case JUMP_ASSERT:
; 1461 :             TRACE(("|%p|%p|JUMP_ASSERT\n", ctx->pattern, ctx->ptr));
; 1462 :             goto jump_assert;
; 1463 :         case JUMP_ASSERT_NOT:
; 1464 :             TRACE(("|%p|%p|JUMP_ASSERT_NOT\n", ctx->pattern, ctx->ptr));
; 1465 :             goto jump_assert_not;
; 1466 :         case JUMP_NONE:
; 1467 :             TRACE(("|%p|%p|RETURN %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1468 :                    ctx->ptr, ret));
; 1469 :             break;
; 1470 :     }
; 1471 : 
; 1472 :     return ret; /* should never get here */
; 1473 : }

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	41 5f		 pop	 r15
  0004a	41 5e		 pop	 r14
  0004c	41 5d		 pop	 r13
  0004e	5b		 pop	 rbx
  0004f	c3		 ret	 0
$LN873@sre_umatch:

; 979  :                 DO_JUMP(JUMP_BRANCH, jump_branch, ctx->pattern+1);

  00050	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
$LN709@sre_umatch:

; 783  :     char* end = (char*)state->end;
; 784  :     Py_ssize_t alloc_pos, ctx_pos = -1;
; 785  :     Py_ssize_t i, ret = 0;
; 786  :     Py_ssize_t jump;
; 787  :     unsigned int sigcount=0;
; 788  : 
; 789  :     SRE_MATCH_CONTEXT* ctx;
; 790  :     SRE_MATCH_CONTEXT* nextctx;
; 791  : 
; 792  :     TRACE(("|%p|%p|ENTER\n", pattern, state->ptr));
; 793  : 
; 794  :     DATA_ALLOC(SRE_MATCH_CONTEXT, ctx);

  00055	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0005c	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  00064	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  00069	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  0006e	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00073	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]

; 795  :     ctx->last_ctx_pos = -1;

  00077	48 c7 07 ff ff
	ff ff		 mov	 QWORD PTR [rdi], -1

; 796  :     ctx->jump = JUMP_NONE;

  0007e	48 c7 47 08 00
	00 00 00	 mov	 QWORD PTR [rdi+8], 0

; 797  :     ctx->pattern = pattern;

  00086	48 89 5f 18	 mov	 QWORD PTR [rdi+24], rbx
  0008a	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
$LN893@sre_umatch:

; 798  :     ctx_pos = alloc_pos;

  0008f	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  00096	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$entrance$22309:

; 799  : 
; 800  : entrance:
; 801  : 
; 802  :     ctx->ptr = (char *)state->ptr;

  000a0	49 8b 4d 00	 mov	 rcx, QWORD PTR [r13]

; 803  : 
; 804  :     if (ctx->pattern[0] == SRE_OP_INFO) {

  000a4	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  000a8	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx
  000ac	41 83 38 11	 cmp	 DWORD PTR [r8], 17
  000b0	75 2f		 jne	 SHORT $LN703@sre_umatch

; 805  :         /* optimization info block */
; 806  :         /* <INFO> <1=skip> <2=flags> <3=min> ... */
; 807  :         if (ctx->pattern[3] && (end - ctx->ptr)/state->charsize < ctx->pattern[3]) {

  000b2	45 8b 48 0c	 mov	 r9d, DWORD PTR [r8+12]
  000b6	45 85 c9	 test	 r9d, r9d
  000b9	74 18		 je	 SHORT $LN704@sre_umatch
  000bb	49 8b c7	 mov	 rax, r15
  000be	48 2b c1	 sub	 rax, rcx
  000c1	49 63 4d 3c	 movsxd	 rcx, DWORD PTR [r13+60]
  000c5	48 99		 cdq
  000c7	48 f7 f9	 idiv	 rcx
  000ca	49 3b c1	 cmp	 rax, r9

; 808  :             TRACE(("reject (got %" PY_FORMAT_SIZE_T "d chars, "
; 809  :                    "need %" PY_FORMAT_SIZE_T "d)\n",
; 810  :                    (end - ctx->ptr)/state->charsize,
; 811  :                    (Py_ssize_t) ctx->pattern[3]));
; 812  :             RETURN_FAILURE;

  000cd	0f 8c 04 03 00
	00		 jl	 $LN30@sre_umatch
$LN704@sre_umatch:

; 813  :         }
; 814  :         ctx->pattern += ctx->pattern[1] + 1;

  000d3	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  000d7	ff c0		 inc	 eax
  000d9	49 8d 0c 80	 lea	 rcx, QWORD PTR [r8+rax*4]
$LN888@sre_umatch:
  000dd	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx
$LN703@sre_umatch:

; 815  :     }
; 816  : 
; 817  :     for (;;) {
; 818  :         ++sigcount;

  000e1	41 ff c2	 inc	 r10d
  000e4	44 89 54 24 50	 mov	 DWORD PTR sigcount$1$[rsp], r10d

; 819  :         if ((0 == (sigcount & 0xfff)) && PyErr_CheckSignals())

  000e9	41 f7 c2 ff 0f
	00 00		 test	 r10d, 4095		; 00000fffH
  000f0	75 12		 jne	 SHORT $LN698@sre_umatch
  000f2	e8 00 00 00 00	 call	 PyErr_CheckSignals
  000f7	85 c0		 test	 eax, eax
  000f9	0f 85 10 14 00
	00		 jne	 $LN841@sre_umatch
  000ff	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
$LN698@sre_umatch:

; 821  : 
; 822  :         switch (*ctx->pattern++) {

  00104	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00108	8b 08		 mov	 ecx, DWORD PTR [rax]
  0010a	4c 8d 58 04	 lea	 r11, QWORD PTR [rax+4]
  0010e	4c 89 5f 18	 mov	 QWORD PTR [rdi+24], r11
  00112	83 f9 1f	 cmp	 ecx, 31
  00115	0f 87 0a 14 00
	00		 ja	 $LN28@sre_umatch
  0011b	8b 8c 8e 00 00
	00 00		 mov	 ecx, DWORD PTR $LN871@sre_umatch[rsi+rcx*4]
  00122	48 03 ce	 add	 rcx, rsi
  00125	ff e1		 jmp	 rcx
$LN695@sre_umatch:

; 823  : 
; 824  :         case SRE_OP_MARK:
; 825  :             /* set mark */
; 826  :             /* <MARK> <gid> */
; 827  :             TRACE(("|%p|%p|MARK %d\n", ctx->pattern,
; 828  :                    ctx->ptr, ctx->pattern[0]));
; 829  :             i = ctx->pattern[0];

  00127	41 8b 1b	 mov	 ebx, DWORD PTR [r11]

; 830  :             if (i & 1)

  0012a	f6 c3 01	 test	 bl, 1
  0012d	74 11		 je	 SHORT $LN694@sre_umatch

; 831  :                 state->lastindex = i/2 + 1;

  0012f	8b c3		 mov	 eax, ebx
  00131	48 99		 cdq
  00133	48 2b c2	 sub	 rax, rdx
  00136	48 d1 f8	 sar	 rax, 1
  00139	48 ff c0	 inc	 rax
  0013c	49 89 45 40	 mov	 QWORD PTR [r13+64], rax
$LN694@sre_umatch:

; 832  :             if (i > state->lastmark) {

  00140	49 8b 45 48	 mov	 rax, QWORD PTR [r13+72]
  00144	48 3b d8	 cmp	 rbx, rax
  00147	7e 22		 jle	 SHORT $LN693@sre_umatch

; 833  :                 /* state->lastmark is the highest valid index in the
; 834  :                    state->mark array.  If it is increased by more than 1,
; 835  :                    the intervening marks must be set to NULL to signal
; 836  :                    that these marks have not been encountered. */
; 837  :                 Py_ssize_t j = state->lastmark + 1;

  00149	48 ff c0	 inc	 rax

; 838  :                 while (j < i)

  0014c	48 3b c3	 cmp	 rax, rbx
  0014f	7d 16		 jge	 SHORT $LN692@sre_umatch

; 833  :                 /* state->lastmark is the highest valid index in the
; 834  :                    state->mark array.  If it is increased by more than 1,
; 835  :                    the intervening marks must be set to NULL to signal
; 836  :                    that these marks have not been encountered. */
; 837  :                 Py_ssize_t j = state->lastmark + 1;

  00151	4c 8b c3	 mov	 r8, rbx
  00154	49 8d 4c c5 50	 lea	 rcx, QWORD PTR [r13+rax*8+80]
  00159	33 d2		 xor	 edx, edx
  0015b	4c 2b c0	 sub	 r8, rax
  0015e	49 c1 e0 03	 shl	 r8, 3
  00162	e8 00 00 00 00	 call	 memset
$LN692@sre_umatch:

; 839  :                     state->mark[j++] = NULL;
; 840  :                 state->lastmark = i;

  00167	49 89 5d 48	 mov	 QWORD PTR [r13+72], rbx
$LN693@sre_umatch:

; 841  :             }
; 842  :             state->mark[i] = ctx->ptr;

  0016b	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0016f	49 89 44 dd 50	 mov	 QWORD PTR [r13+rbx*8+80], rax
$LN670@sre_umatch:

; 843  :             ctx->pattern++;

  00174	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 844  :             break;

  00179	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  0017e	e9 5e ff ff ff	 jmp	 $LN703@sre_umatch
$LN690@sre_umatch:

; 845  : 
; 846  :         case SRE_OP_LITERAL:
; 847  :             /* match literal string */
; 848  :             /* <LITERAL> <code> */
; 849  :             TRACE(("|%p|%p|LITERAL %d\n", ctx->pattern,
; 850  :                    ctx->ptr, *ctx->pattern));
; 851  :             if (ctx->ptr >= end || (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) != ctx->pattern[0])

  00183	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00187	49 3b cf	 cmp	 rcx, r15
  0018a	0f 83 47 02 00
	00		 jae	 $LN30@sre_umatch
  00190	41 8b 45 3c	 mov	 eax, DWORD PTR [r13+60]
  00194	83 f8 01	 cmp	 eax, 1
  00197	75 05		 jne	 SHORT $LN722@sre_umatch
  00199	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0019c	eb 0c		 jmp	 SHORT $LN721@sre_umatch
$LN722@sre_umatch:
  0019e	83 f8 02	 cmp	 eax, 2
  001a1	75 05		 jne	 SHORT $LN720@sre_umatch
  001a3	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  001a6	eb 02		 jmp	 SHORT $LN721@sre_umatch
$LN720@sre_umatch:
  001a8	8b 01		 mov	 eax, DWORD PTR [rcx]
$LN721@sre_umatch:
  001aa	41 3b 03	 cmp	 eax, DWORD PTR [r11]
  001ad	0f 85 24 02 00
	00		 jne	 $LN30@sre_umatch
$LN883@sre_umatch:

; 852  :                 RETURN_FAILURE;
; 853  :             ctx->pattern++;

  001b3	49 8d 43 04	 lea	 rax, QWORD PTR [r11+4]
  001b7	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax
$LN653@sre_umatch:

; 854  :             ctx->ptr += state->charsize;

  001bb	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  001bf	48 03 c1	 add	 rax, rcx
  001c2	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 855  :             break;

  001c6	e9 16 ff ff ff	 jmp	 $LN703@sre_umatch
$LN684@sre_umatch:

; 856  : 
; 857  :         case SRE_OP_NOT_LITERAL:
; 858  :             /* match anything that is not literal character */
; 859  :             /* <NOT_LITERAL> <code> */
; 860  :             TRACE(("|%p|%p|NOT_LITERAL %d\n", ctx->pattern,
; 861  :                    ctx->ptr, *ctx->pattern));
; 862  :             if (ctx->ptr >= end || (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) == ctx->pattern[0])

  001cb	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  001cf	49 3b cf	 cmp	 rcx, r15
  001d2	0f 83 ff 01 00
	00		 jae	 $LN30@sre_umatch
  001d8	41 8b 45 3c	 mov	 eax, DWORD PTR [r13+60]
  001dc	83 f8 01	 cmp	 eax, 1
  001df	75 05		 jne	 SHORT $LN726@sre_umatch
  001e1	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  001e4	eb 0c		 jmp	 SHORT $LN725@sre_umatch
$LN726@sre_umatch:
  001e6	83 f8 02	 cmp	 eax, 2
  001e9	75 05		 jne	 SHORT $LN724@sre_umatch
  001eb	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  001ee	eb 02		 jmp	 SHORT $LN725@sre_umatch
$LN724@sre_umatch:
  001f0	8b 01		 mov	 eax, DWORD PTR [rcx]
$LN725@sre_umatch:
  001f2	41 3b 03	 cmp	 eax, DWORD PTR [r11]

; 864  :             ctx->pattern++;
; 865  :             ctx->ptr += state->charsize;
; 866  :             break;

  001f5	75 bc		 jne	 SHORT $LN883@sre_umatch

; 863  :                 RETURN_FAILURE;

  001f7	e9 db 01 00 00	 jmp	 $LN30@sre_umatch
$LN675@sre_umatch:

; 867  : 
; 868  :         case SRE_OP_SUCCESS:
; 869  :             /* end of pattern */
; 870  :             TRACE(("|%p|%p|SUCCESS\n", ctx->pattern, ctx->ptr));
; 871  :             state->ptr = ctx->ptr;
; 872  :             RETURN_SUCCESS;
; 873  : 
; 874  :         case SRE_OP_AT:
; 875  :             /* match at given position */
; 876  :             /* <AT> <code> */
; 877  :             TRACE(("|%p|%p|AT %d\n", ctx->pattern, ctx->ptr, *ctx->pattern));
; 878  :             if (!SRE_AT(state, ctx->ptr, *ctx->pattern))

  001fc	45 8b 03	 mov	 r8d, DWORD PTR [r11]
  001ff	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00203	49 8b cd	 mov	 rcx, r13
  00206	e8 00 00 00 00	 call	 sre_uat
  0020b	85 c0		 test	 eax, eax
  0020d	0f 85 61 ff ff
	ff		 jne	 $LN670@sre_umatch

; 879  :                 RETURN_FAILURE;

  00213	e9 bf 01 00 00	 jmp	 $LN30@sre_umatch
$LN669@sre_umatch:

; 880  :             ctx->pattern++;
; 881  :             break;
; 882  : 
; 883  :         case SRE_OP_CATEGORY:
; 884  :             /* match at given category */
; 885  :             /* <CATEGORY> <code> */
; 886  :             TRACE(("|%p|%p|CATEGORY %d\n", ctx->pattern,
; 887  :                    ctx->ptr, *ctx->pattern));
; 888  :             if (ctx->ptr >= end || !sre_category(ctx->pattern[0], SRE_CHARGET(state, ctx->ptr, 0)))

  00218	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0021c	49 3b c7	 cmp	 rax, r15
  0021f	0f 83 b2 01 00
	00		 jae	 $LN30@sre_umatch
  00225	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  00229	83 f9 01	 cmp	 ecx, 1
  0022c	75 05		 jne	 SHORT $LN730@sre_umatch
  0022e	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00231	eb 0c		 jmp	 SHORT $LN729@sre_umatch
$LN730@sre_umatch:
  00233	83 f9 02	 cmp	 ecx, 2
  00236	75 05		 jne	 SHORT $LN728@sre_umatch
  00238	0f b7 10	 movzx	 edx, WORD PTR [rax]
  0023b	eb 02		 jmp	 SHORT $LN729@sre_umatch
$LN728@sre_umatch:
  0023d	8b 10		 mov	 edx, DWORD PTR [rax]
$LN729@sre_umatch:
  0023f	41 8b 0b	 mov	 ecx, DWORD PTR [r11]
  00242	e8 00 00 00 00	 call	 sre_category
  00247	85 c0		 test	 eax, eax
  00249	0f 84 88 01 00
	00		 je	 $LN30@sre_umatch

; 889  :                 RETURN_FAILURE;
; 890  :             ctx->pattern++;

  0024f	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 891  :             ctx->ptr += state->charsize;

  00254	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]

; 892  :             break;

  00258	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  0025d	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  00261	e9 7b fe ff ff	 jmp	 $LN703@sre_umatch
$LN663@sre_umatch:

; 893  : 
; 894  :         case SRE_OP_ANY:
; 895  :             /* match anything (except a newline) */
; 896  :             /* <ANY> */
; 897  :             TRACE(("|%p|%p|ANY\n", ctx->pattern, ctx->ptr));
; 898  :                 if (ctx->ptr >= end || SRE_IS_LINEBREAK(SRE_CHARGET(state, ctx->ptr, 0)))

  00266	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0026a	49 3b d7	 cmp	 rdx, r15
  0026d	0f 83 64 01 00
	00		 jae	 $LN30@sre_umatch
  00273	4d 63 45 3c	 movsxd	 r8, DWORD PTR [r13+60]
  00277	41 83 f8 01	 cmp	 r8d, 1
  0027b	75 05		 jne	 SHORT $LN734@sre_umatch
  0027d	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00280	eb 0d		 jmp	 SHORT $LN733@sre_umatch
$LN734@sre_umatch:
  00282	41 83 f8 02	 cmp	 r8d, 2
  00286	75 05		 jne	 SHORT $LN732@sre_umatch
  00288	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  0028b	eb 02		 jmp	 SHORT $LN733@sre_umatch
$LN732@sre_umatch:
  0028d	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN733@sre_umatch:
  0028f	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00294	73 29		 jae	 SHORT $LN869@sre_umatch
  00296	41 83 f8 01	 cmp	 r8d, 1
  0029a	75 05		 jne	 SHORT $LN738@sre_umatch
  0029c	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0029f	eb 0d		 jmp	 SHORT $LN737@sre_umatch
$LN738@sre_umatch:
  002a1	41 83 f8 02	 cmp	 r8d, 2
  002a5	75 05		 jne	 SHORT $LN736@sre_umatch
  002a7	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  002aa	eb 02		 jmp	 SHORT $LN737@sre_umatch
$LN736@sre_umatch:
  002ac	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN737@sre_umatch:
  002ae	0f be 8c 30 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+rsi]
  002b6	83 e1 04	 and	 ecx, 4
  002b9	0f 85 18 01 00
	00		 jne	 $LN30@sre_umatch
$LN869@sre_umatch:

; 899  :                     RETURN_FAILURE;
; 900  :             ctx->ptr += state->charsize;

  002bf	4a 8d 04 02	 lea	 rax, QWORD PTR [rdx+r8]
  002c3	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  002c7	e9 15 fe ff ff	 jmp	 $LN703@sre_umatch
$LN657@sre_umatch:

; 901  :             break;
; 902  : 
; 903  :         case SRE_OP_ANY_ALL:
; 904  :             /* match anything */
; 905  :             /* <ANY_ALL> */
; 906  :             TRACE(("|%p|%p|ANY_ALL\n", ctx->pattern, ctx->ptr));
; 907  :             if (ctx->ptr >= end)

  002cc	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  002d0	49 3b cf	 cmp	 rcx, r15
  002d3	0f 82 e2 fe ff
	ff		 jb	 $LN653@sre_umatch

; 908  :                 RETURN_FAILURE;

  002d9	e9 f9 00 00 00	 jmp	 $LN30@sre_umatch
$LN652@sre_umatch:

; 909  :             ctx->ptr += state->charsize;
; 910  :             break;
; 911  : 
; 912  :         case SRE_OP_IN:
; 913  :             /* match set member (or non_member) */
; 914  :             /* <IN> <skip> <set> */
; 915  :             TRACE(("|%p|%p|IN\n", ctx->pattern, ctx->ptr));
; 916  :                 if (ctx->ptr >= end || !SRE_CHARSET(ctx->pattern + 1, SRE_CHARGET(state, ctx->ptr, 0)))

  002de	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  002e2	49 3b c7	 cmp	 rax, r15
  002e5	0f 83 ec 00 00
	00		 jae	 $LN30@sre_umatch
  002eb	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  002ef	83 f9 01	 cmp	 ecx, 1
  002f2	75 05		 jne	 SHORT $LN744@sre_umatch
  002f4	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  002f7	eb 0c		 jmp	 SHORT $LN743@sre_umatch
$LN744@sre_umatch:
  002f9	83 f9 02	 cmp	 ecx, 2
  002fc	75 05		 jne	 SHORT $LN742@sre_umatch
  002fe	0f b7 10	 movzx	 edx, WORD PTR [rax]
  00301	eb 02		 jmp	 SHORT $LN743@sre_umatch
$LN742@sre_umatch:
  00303	8b 10		 mov	 edx, DWORD PTR [rax]
$LN743@sre_umatch:
  00305	49 8d 4b 04	 lea	 rcx, QWORD PTR [r11+4]
  00309	e8 00 00 00 00	 call	 sre_ucharset
  0030e	85 c0		 test	 eax, eax
  00310	0f 84 c1 00 00
	00		 je	 $LN30@sre_umatch
$LN885@sre_umatch:

; 917  :                     RETURN_FAILURE;
; 918  :             ctx->pattern += ctx->pattern[0];

  00316	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]

; 919  :             ctx->ptr += state->charsize;
; 920  :             break;

  0031a	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  0031f	8b 01		 mov	 eax, DWORD PTR [rcx]
  00321	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00325	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx
  00329	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  0032d	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  00331	e9 ab fd ff ff	 jmp	 $LN703@sre_umatch
$LN646@sre_umatch:

; 921  : 
; 922  :         case SRE_OP_LITERAL_IGNORE:
; 923  :             TRACE(("|%p|%p|LITERAL_IGNORE %d\n",
; 924  :                    ctx->pattern, ctx->ptr, ctx->pattern[0]));
; 925  :             if (ctx->ptr >= end ||
; 926  :                 state->lower(SRE_CHARGET(state, ctx->ptr, 0)) != state->lower(*ctx->pattern))

  00336	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  0033a	49 3b c7	 cmp	 rax, r15
  0033d	0f 83 94 00 00
	00		 jae	 $LN30@sre_umatch
  00343	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  00347	83 f9 01	 cmp	 ecx, 1
  0034a	75 05		 jne	 SHORT $LN748@sre_umatch
  0034c	0f b6 30	 movzx	 esi, BYTE PTR [rax]
  0034f	eb 0c		 jmp	 SHORT $LN747@sre_umatch
$LN748@sre_umatch:
  00351	83 f9 02	 cmp	 ecx, 2
  00354	75 05		 jne	 SHORT $LN746@sre_umatch
  00356	0f b7 30	 movzx	 esi, WORD PTR [rax]
  00359	eb 02		 jmp	 SHORT $LN747@sre_umatch
$LN746@sre_umatch:
  0035b	8b 30		 mov	 esi, DWORD PTR [rax]
$LN747@sre_umatch:
  0035d	41 8b 0b	 mov	 ecx, DWORD PTR [r11]
  00360	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  00367	8b ce		 mov	 ecx, esi
  00369	8b d8		 mov	 ebx, eax
  0036b	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  00372	3b c3		 cmp	 eax, ebx
  00374	75 5a		 jne	 SHORT $LN557@sre_umatch
$LN887@sre_umatch:

; 927  :                 RETURN_FAILURE;
; 928  :             ctx->pattern++;

  00376	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4

; 929  :             ctx->ptr += state->charsize;

  0037b	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]

; 930  :             break;

  0037f	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00384	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  00388	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  0038f	e9 4d fd ff ff	 jmp	 $LN703@sre_umatch
$LN640@sre_umatch:

; 931  : 
; 932  :         case SRE_OP_NOT_LITERAL_IGNORE:
; 933  :             TRACE(("|%p|%p|NOT_LITERAL_IGNORE %d\n",
; 934  :                    ctx->pattern, ctx->ptr, *ctx->pattern));
; 935  :             if (ctx->ptr >= end ||
; 936  :                 state->lower(SRE_CHARGET(state, ctx->ptr, 0)) == state->lower(*ctx->pattern))

  00394	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00398	49 3b c7	 cmp	 rax, r15
  0039b	73 3a		 jae	 SHORT $LN30@sre_umatch
  0039d	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  003a1	83 f9 01	 cmp	 ecx, 1
  003a4	75 05		 jne	 SHORT $LN752@sre_umatch
  003a6	0f b6 30	 movzx	 esi, BYTE PTR [rax]
  003a9	eb 0c		 jmp	 SHORT $LN751@sre_umatch
$LN752@sre_umatch:
  003ab	83 f9 02	 cmp	 ecx, 2
  003ae	75 05		 jne	 SHORT $LN750@sre_umatch
  003b0	0f b7 30	 movzx	 esi, WORD PTR [rax]
  003b3	eb 02		 jmp	 SHORT $LN751@sre_umatch
$LN750@sre_umatch:
  003b5	8b 30		 mov	 esi, DWORD PTR [rax]
$LN751@sre_umatch:
  003b7	41 8b 0b	 mov	 ecx, DWORD PTR [r11]
  003ba	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  003c1	8b ce		 mov	 ecx, esi
  003c3	8b d8		 mov	 ebx, eax
  003c5	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  003cc	3b c3		 cmp	 eax, ebx

; 937  :                 RETURN_FAILURE;
; 938  :             ctx->pattern++;
; 939  :             ctx->ptr += state->charsize;
; 940  :             break;

  003ce	75 a6		 jne	 SHORT $LN887@sre_umatch
$LN557@sre_umatch:

; 992  :             RETURN_FAILURE;

  003d0	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
$LN30@sre_umatch:

; 1404 :             break;
; 1405 : 
; 1406 :         case SRE_OP_FAILURE:
; 1407 :             /* immediate failure */
; 1408 :             TRACE(("|%p|%p|FAILURE\n", ctx->pattern, ctx->ptr));
; 1409 :             RETURN_FAILURE;

  003d7	33 db		 xor	 ebx, ebx
$exit$22316:

; 1417 : 
; 1418 : exit:
; 1419 :     ctx_pos = ctx->last_ctx_pos;

  003d9	4c 8b 37	 mov	 r14, QWORD PTR [rdi]

; 1420 :     jump = ctx->jump;

  003dc	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]

; 1421 :     DATA_POP_DISCARD(ctx);

  003e0	49 83 85 a0 06
	00 00 c0	 add	 QWORD PTR [r13+1696], -64 ; ffffffffffffffc0H
  003e8	49 8b 8d a0 06
	00 00		 mov	 rcx, QWORD PTR [r13+1696]

; 1422 :     if (ctx_pos == -1)

  003ef	49 83 fe ff	 cmp	 r14, -1
  003f3	0f 84 bd 0b 00
	00		 je	 $LN825@sre_umatch

; 1424 :     DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  003f9	49 8b 95 90 06
	00 00		 mov	 rdx, QWORD PTR [r13+1680]

; 1425 : 
; 1426 :     switch (jump) {

  00400	48 ff c8	 dec	 rax
  00403	4a 8d 3c 32	 lea	 rdi, QWORD PTR [rdx+r14]
  00407	48 83 f8 0c	 cmp	 rax, 12
  0040b	0f 87 a5 0b 00
	00		 ja	 $LN825@sre_umatch
  00411	8b 84 86 00 00
	00 00		 mov	 eax, DWORD PTR $LN870@sre_umatch[rsi+rax*4]
  00418	48 03 c6	 add	 rax, rsi
  0041b	ff e0		 jmp	 rax
$LN634@sre_umatch:

; 941  : 
; 942  :         case SRE_OP_IN_IGNORE:
; 943  :             TRACE(("|%p|%p|IN_IGNORE\n", ctx->pattern, ctx->ptr));
; 944  :             if (ctx->ptr >= end
; 945  :                 || !SRE_CHARSET(ctx->pattern+1,
; 946  :                                 (SRE_CODE)state->lower(SRE_CHARGET(state, ctx->ptr, 0))))

  0041d	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00421	49 3b c7	 cmp	 rax, r15
  00424	73 b1		 jae	 SHORT $LN30@sre_umatch
  00426	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  0042a	83 f9 01	 cmp	 ecx, 1
  0042d	75 05		 jne	 SHORT $LN756@sre_umatch
  0042f	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00432	eb 0c		 jmp	 SHORT $LN755@sre_umatch
$LN756@sre_umatch:
  00434	83 f9 02	 cmp	 ecx, 2
  00437	75 05		 jne	 SHORT $LN754@sre_umatch
  00439	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  0043c	eb 02		 jmp	 SHORT $LN755@sre_umatch
$LN754@sre_umatch:
  0043e	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN755@sre_umatch:
  00440	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  00447	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0044b	48 83 c1 04	 add	 rcx, 4
  0044f	8b d0		 mov	 edx, eax
  00451	e8 00 00 00 00	 call	 sre_ucharset
  00456	85 c0		 test	 eax, eax

; 948  :             ctx->pattern += ctx->pattern[0];
; 949  :             ctx->ptr += state->charsize;
; 950  :             break;

  00458	0f 85 b8 fe ff
	ff		 jne	 $LN885@sre_umatch

; 947  :                 RETURN_FAILURE;

  0045e	e9 74 ff ff ff	 jmp	 $LN30@sre_umatch
$LN628@sre_umatch:

; 951  : 
; 952  :         case SRE_OP_JUMP:
; 953  :         case SRE_OP_INFO:
; 954  :             /* jump forward */
; 955  :             /* <JUMP> <offset> */
; 956  :             TRACE(("|%p|%p|JUMP %d\n", ctx->pattern,
; 957  :                    ctx->ptr, ctx->pattern[0]));
; 958  :             ctx->pattern += ctx->pattern[0];

  00463	41 8b 03	 mov	 eax, DWORD PTR [r11]
  00466	49 8d 0c 83	 lea	 rcx, QWORD PTR [r11+rax*4]

; 959  :             break;

  0046a	e9 6e fc ff ff	 jmp	 $LN888@sre_umatch
$LN626@sre_umatch:

; 960  : 
; 961  :         case SRE_OP_BRANCH:
; 962  :             /* alternation */
; 963  :             /* <BRANCH> <0=skip> code <JUMP> ... <NULL> */
; 964  :             TRACE(("|%p|%p|BRANCH\n", ctx->pattern, ctx->ptr));
; 965  :             LASTMARK_SAVE();

  0046f	49 8b 5d 48	 mov	 rbx, QWORD PTR [r13+72]
  00473	48 89 5f 28	 mov	 QWORD PTR [rdi+40], rbx
  00477	49 8b 45 40	 mov	 rax, QWORD PTR [r13+64]
  0047b	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 966  :             ctx->u.rep = state->repeat;

  0047f	49 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [r13+1784]
  00486	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 967  :             if (ctx->u.rep)

  0048a	48 85 c0	 test	 rax, rax
  0048d	0f 84 d6 06 00
	00		 je	 $LN609@sre_umatch

; 968  :                 MARK_PUSH(ctx->lastmark);

  00493	48 85 db	 test	 rbx, rbx
  00496	0f 8e cd 06 00
	00		 jle	 $LN609@sre_umatch
  0049c	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  004a3	48 8d 34 dd 08
	00 00 00	 lea	 rsi, QWORD PTR [rbx*8+8]
  004ab	49 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [r13+1696]
  004b2	48 3b f0	 cmp	 rsi, rax
  004b5	76 24		 jbe	 SHORT $LN610@sre_umatch
  004b7	48 8b d6	 mov	 rdx, rsi
  004ba	49 8b cd	 mov	 rcx, r13
  004bd	e8 00 00 00 00	 call	 data_stack_grow
  004c2	85 c0		 test	 eax, eax
  004c4	0f 88 4e 10 00
	00		 js	 $LN855@sre_umatch
  004ca	49 83 fe ff	 cmp	 r14, -1
  004ce	74 0b		 je	 SHORT $LN610@sre_umatch
  004d0	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  004d7	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN610@sre_umatch:
  004db	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]
  004e2	49 8d 55 50	 lea	 rdx, QWORD PTR [r13+80]
  004e6	4c 8b c6	 mov	 r8, rsi
  004e9	49 03 8d a0 06
	00 00		 add	 rcx, QWORD PTR [r13+1696]
  004f0	e8 00 00 00 00	 call	 memcpy
  004f5	4c 8d 1c dd 08
	00 00 00	 lea	 r11, QWORD PTR [rbx*8+8]
  004fd	4d 01 9d a0 06
	00 00		 add	 QWORD PTR [r13+1696], r11

; 969  :             for (; ctx->pattern[0]; ctx->pattern += ctx->pattern[0]) {

  00504	e9 60 06 00 00	 jmp	 $LN609@sre_umatch
$LN550@sre_umatch:

; 993  : 
; 994  :         case SRE_OP_REPEAT_ONE:
; 995  :             /* match repeated sequence (maximizing regexp) */
; 996  : 
; 997  :             /* this operator only works if the repeated item is
; 998  :                exactly one character wide, and we're not already
; 999  :                collecting backtracking points.  for other cases,
; 1000 :                use the MAX_REPEAT operator */
; 1001 : 
; 1002 :             /* <REPEAT_ONE> <skip> <1=min> <2=max> item <SUCCESS> tail */
; 1003 : 
; 1004 :             TRACE(("|%p|%p|REPEAT_ONE %d %d\n", ctx->pattern, ctx->ptr,
; 1005 :                    ctx->pattern[1], ctx->pattern[2]));
; 1006 : 
; 1007 :             if ((Py_ssize_t) ctx->pattern[1] > (end - ctx->ptr) / state->charsize)

  00509	49 63 4d 3c	 movsxd	 rcx, DWORD PTR [r13+60]
  0050d	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00511	49 8b c7	 mov	 rax, r15
  00514	49 2b c0	 sub	 rax, r8
  00517	48 99		 cdq
  00519	48 f7 f9	 idiv	 rcx
  0051c	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  00520	48 3b c8	 cmp	 rcx, rax

; 1008 :                 RETURN_FAILURE; /* cannot match */

  00523	0f 8f ae fe ff
	ff		 jg	 $LN30@sre_umatch

; 1009 : 
; 1010 :             state->ptr = ctx->ptr;

  00529	4d 89 45 00	 mov	 QWORD PTR [r13], r8

; 1011 : 
; 1012 :             ret = SRE_COUNT(state, ctx->pattern+3, ctx->pattern[2]);

  0052d	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00531	49 8b cd	 mov	 rcx, r13
  00534	44 8b 42 08	 mov	 r8d, DWORD PTR [rdx+8]
  00538	48 83 c2 0c	 add	 rdx, 12
  0053c	e8 00 00 00 00	 call	 sre_ucount

; 1013 :             RETURN_ON_ERROR(ret);

  00541	48 85 c0	 test	 rax, rax
  00544	0f 88 df 0f 00
	00		 js	 $LN879@sre_umatch

; 1014 :             DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  0054a	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]

; 1015 :             ctx->count = ret;

  00551	49 89 44 0e 20	 mov	 QWORD PTR [r14+rcx+32], rax

; 1016 :             ctx->ptr += state->charsize * ctx->count;
; 1017 : 
; 1018 :             /* when we arrive here, count contains the number of
; 1019 :                matches, and ctx->ptr points to the tail of the target
; 1020 :                string.  check if the rest of the pattern matches,
; 1021 :                and backtrack if not. */
; 1022 : 
; 1023 :             if (ctx->count < (Py_ssize_t) ctx->pattern[1])

  00556	49 8b 54 0e 18	 mov	 rdx, QWORD PTR [r14+rcx+24]
  0055b	49 8d 3c 0e	 lea	 rdi, QWORD PTR [r14+rcx]
  0055f	49 63 4d 3c	 movsxd	 rcx, DWORD PTR [r13+60]
  00563	48 0f af c8	 imul	 rcx, rax
  00567	48 01 4f 10	 add	 QWORD PTR [rdi+16], rcx
  0056b	8b 4a 04	 mov	 ecx, DWORD PTR [rdx+4]
  0056e	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00572	48 3b c1	 cmp	 rax, rcx

; 1024 :                 RETURN_FAILURE;

  00575	0f 8c 5c fe ff
	ff		 jl	 $LN30@sre_umatch

; 1025 : 
; 1026 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_SUCCESS) {

  0057b	8b 02		 mov	 eax, DWORD PTR [rdx]
  0057d	83 3c 82 01	 cmp	 DWORD PTR [rdx+rax*4], 1
  00581	75 0e		 jne	 SHORT $LN527@sre_umatch

; 1027 :                 /* tail is empty.  we're finished */
; 1028 :                 state->ptr = ctx->ptr;

  00583	4d 89 45 00	 mov	 QWORD PTR [r13], r8

; 1029 :                 RETURN_SUCCESS;

  00587	bb 01 00 00 00	 mov	 ebx, 1
  0058c	e9 48 fe ff ff	 jmp	 $exit$22316
$LN527@sre_umatch:

; 1030 :             }
; 1031 : 
; 1032 :             LASTMARK_SAVE();

  00591	49 8b 45 48	 mov	 rax, QWORD PTR [r13+72]
  00595	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  00599	49 8b 45 40	 mov	 rax, QWORD PTR [r13+64]
  0059d	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1033 : 
; 1034 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_LITERAL) {

  005a1	8b 02		 mov	 eax, DWORD PTR [rdx]
  005a3	83 3c 82 13	 cmp	 DWORD PTR [rdx+rax*4], 19
  005a7	0f 85 46 08 00
	00		 jne	 $LN490@sre_umatch

; 1035 :                 /* tail starts with a literal. skip positions where
; 1036 :                    the rest of the pattern cannot possibly match */
; 1037 :                 ctx->u.chr = ctx->pattern[ctx->pattern[0]+1];

  005ad	ff c0		 inc	 eax
  005af	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  005b2	89 47 38	 mov	 DWORD PTR [rdi+56], eax
  005b5	e9 32 07 00 00	 jmp	 $LN522@sre_umatch
$LN461@sre_umatch:

; 1074 :                 }
; 1075 :             }
; 1076 :             RETURN_FAILURE;
; 1077 : 
; 1078 :         case SRE_OP_MIN_REPEAT_ONE:
; 1079 :             /* match repeated sequence (minimizing regexp) */
; 1080 : 
; 1081 :             /* this operator only works if the repeated item is
; 1082 :                exactly one character wide, and we're not already
; 1083 :                collecting backtracking points.  for other cases,
; 1084 :                use the MIN_REPEAT operator */
; 1085 : 
; 1086 :             /* <MIN_REPEAT_ONE> <skip> <1=min> <2=max> item <SUCCESS> tail */
; 1087 : 
; 1088 :             TRACE(("|%p|%p|MIN_REPEAT_ONE %d %d\n", ctx->pattern, ctx->ptr,
; 1089 :                    ctx->pattern[1], ctx->pattern[2]));
; 1090 : 
; 1091 :             if ((Py_ssize_t) ctx->pattern[1] > (end - ctx->ptr) / state->charsize)

  005ba	49 63 4d 3c	 movsxd	 rcx, DWORD PTR [r13+60]
  005be	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  005c2	49 8b c7	 mov	 rax, r15
  005c5	49 2b c0	 sub	 rax, r8
  005c8	48 99		 cdq
  005ca	48 f7 f9	 idiv	 rcx
  005cd	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  005d1	48 3b c8	 cmp	 rcx, rax

; 1092 :                 RETURN_FAILURE; /* cannot match */

  005d4	0f 8f fd fd ff
	ff		 jg	 $LN30@sre_umatch

; 1093 : 
; 1094 :             state->ptr = ctx->ptr;

  005da	4d 89 45 00	 mov	 QWORD PTR [r13], r8

; 1095 : 
; 1096 :             if (ctx->pattern[1] == 0)

  005de	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  005e2	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  005e5	85 c0		 test	 eax, eax
  005e7	75 0a		 jne	 SHORT $LN455@sre_umatch

; 1097 :                 ctx->count = 0;

  005e9	48 c7 47 20 00
	00 00 00	 mov	 QWORD PTR [rdi+32], 0

; 1098 :             else {

  005f1	eb 47		 jmp	 SHORT $LN454@sre_umatch
$LN455@sre_umatch:

; 1099 :                 /* count using pattern min as the maximum */
; 1100 :                 ret = SRE_COUNT(state, ctx->pattern+3, ctx->pattern[1]);

  005f3	4c 8b c0	 mov	 r8, rax
  005f6	48 83 c2 0c	 add	 rdx, 12
  005fa	49 8b cd	 mov	 rcx, r13
  005fd	e8 00 00 00 00	 call	 sre_ucount
  00602	4c 8b d8	 mov	 r11, rax

; 1101 :                 RETURN_ON_ERROR(ret);

  00605	48 85 c0	 test	 rax, rax
  00608	0f 88 1b 0f 00
	00		 js	 $LN879@sre_umatch

; 1102 :                 DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  0060e	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]
  00615	49 8d 3c 0e	 lea	 rdi, QWORD PTR [r14+rcx]

; 1103 :                 if (ret < (Py_ssize_t) ctx->pattern[1])

  00619	49 8b 4c 0e 18	 mov	 rcx, QWORD PTR [r14+rcx+24]
  0061e	8b 51 04	 mov	 edx, DWORD PTR [rcx+4]
  00621	48 3b c2	 cmp	 rax, rdx

; 1104 :                     /* didn't match minimum number of times */
; 1105 :                     RETURN_FAILURE;

  00624	0f 8c ad fd ff
	ff		 jl	 $LN30@sre_umatch

; 1106 :                 /* advance past minimum matches of repeat */
; 1107 :                 ctx->count = ret;

  0062a	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 1108 :                 ctx->ptr += state->charsize * ctx->count;

  0062e	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  00632	49 0f af c3	 imul	 rax, r11
  00636	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
$LN454@sre_umatch:

; 1109 :             }
; 1110 : 
; 1111 :             if (ctx->pattern[ctx->pattern[0]] == SRE_OP_SUCCESS) {

  0063a	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  0063e	8b 01		 mov	 eax, DWORD PTR [rcx]
  00640	83 3c 81 01	 cmp	 DWORD PTR [rcx+rax*4], 1
  00644	75 12		 jne	 SHORT $LN434@sre_umatch
$LN678@sre_umatch:

; 1112 :                 /* tail is empty.  we're finished */
; 1113 :                 state->ptr = ctx->ptr;

  00646	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1114 :                 RETURN_SUCCESS;

  0064a	bb 01 00 00 00	 mov	 ebx, 1
  0064f	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00653	e9 81 fd ff ff	 jmp	 $exit$22316
$LN434@sre_umatch:

; 1115 : 
; 1116 :             } else {
; 1117 :                 /* general case */
; 1118 :                 LASTMARK_SAVE();

  00658	49 8b 45 48	 mov	 rax, QWORD PTR [r13+72]
  0065c	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  00660	49 8b 45 40	 mov	 rax, QWORD PTR [r13+64]
  00664	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
  00668	e9 93 08 00 00	 jmp	 $LN431@sre_umatch
$LN390@sre_umatch:

; 1138 :                 }
; 1139 :             }
; 1140 :             RETURN_FAILURE;
; 1141 : 
; 1142 :         case SRE_OP_REPEAT:
; 1143 :             /* create repeat context.  all the hard work is done
; 1144 :                by the UNTIL operator (MAX_UNTIL, MIN_UNTIL) */
; 1145 :             /* <REPEAT> <skip> <1=min> <2=max> item <UNTIL> tail */
; 1146 :             TRACE(("|%p|%p|REPEAT %d %d\n", ctx->pattern, ctx->ptr,
; 1147 :                    ctx->pattern[1], ctx->pattern[2]));
; 1148 : 
; 1149 :             /* install new repeat context */
; 1150 :             ctx->u.rep = (SRE_REPEAT*) PyObject_MALLOC(sizeof(*ctx->u.rep));

  0066d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00672	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00677	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1151 :             if (!ctx->u.rep) {

  0067b	48 85 c0	 test	 rax, rax
  0067e	0f 85 3a 09 00
	00		 jne	 $LN385@sre_umatch

; 1152 :                 PyErr_NoMemory();

  00684	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1153 :                 RETURN_FAILURE;

  00689	e9 49 fd ff ff	 jmp	 $LN30@sre_umatch
$LN127@sre_umatch:

; 1301 : 
; 1302 :         case SRE_OP_GROUPREF:
; 1303 :             /* match backreference */
; 1304 :             TRACE(("|%p|%p|GROUPREF %d\n", ctx->pattern,
; 1305 :                    ctx->ptr, ctx->pattern[0]));
; 1306 :             i = ctx->pattern[0];
; 1307 :             {
; 1308 :                 Py_ssize_t groupref = i+i;

  0068e	41 8b 03	 mov	 eax, DWORD PTR [r11]
  00691	48 03 c0	 add	 rax, rax

; 1309 :                 if (groupref >= state->lastmark) {

  00694	49 3b 45 48	 cmp	 rax, QWORD PTR [r13+72]

; 1310 :                     RETURN_FAILURE;

  00698	0f 8d 39 fd ff
	ff		 jge	 $LN30@sre_umatch

; 1311 :                 } else {
; 1312 :                     char* p = (char*) state->mark[groupref];

  0069e	4d 8b 4c c5 50	 mov	 r9, QWORD PTR [r13+rax*8+80]

; 1313 :                     char* e = (char*) state->mark[groupref+1];

  006a3	4d 8b 54 c5 58	 mov	 r10, QWORD PTR [r13+rax*8+88]

; 1314 :                     if (!p || !e || e < p)

  006a8	4d 85 c9	 test	 r9, r9
  006ab	0f 84 26 fd ff
	ff		 je	 $LN30@sre_umatch
  006b1	4d 85 d2	 test	 r10, r10
  006b4	0f 84 1d fd ff
	ff		 je	 $LN30@sre_umatch
  006ba	4d 3b ca	 cmp	 r9, r10
  006bd	0f 87 14 fd ff
	ff		 ja	 $LN30@sre_umatch

; 1315 :                         RETURN_FAILURE;
; 1316 :                     while (p < e) {

  006c3	73 67		 jae	 SHORT $LN114@sre_umatch
  006c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL115@sre_umatch:

; 1317 :                         if (ctx->ptr >= end ||
; 1318 :                             SRE_CHARGET(state, ctx->ptr, 0) != SRE_CHARGET(state, p, 0))

  006d0	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  006d4	49 3b d7	 cmp	 rdx, r15
  006d7	0f 83 fa fc ff
	ff		 jae	 $LN30@sre_umatch
  006dd	49 63 4d 3c	 movsxd	 rcx, DWORD PTR [r13+60]
  006e1	83 f9 01	 cmp	 ecx, 1
  006e4	75 06		 jne	 SHORT $LN773@sre_umatch
  006e6	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  006ea	eb 0e		 jmp	 SHORT $LN772@sre_umatch
$LN773@sre_umatch:
  006ec	83 f9 02	 cmp	 ecx, 2
  006ef	75 06		 jne	 SHORT $LN771@sre_umatch
  006f1	44 0f b7 02	 movzx	 r8d, WORD PTR [rdx]
  006f5	eb 03		 jmp	 SHORT $LN772@sre_umatch
$LN771@sre_umatch:
  006f7	44 8b 02	 mov	 r8d, DWORD PTR [rdx]
$LN772@sre_umatch:
  006fa	83 f9 01	 cmp	 ecx, 1
  006fd	75 06		 jne	 SHORT $LN777@sre_umatch
  006ff	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00703	eb 0e		 jmp	 SHORT $LN776@sre_umatch
$LN777@sre_umatch:
  00705	83 f9 02	 cmp	 ecx, 2
  00708	75 06		 jne	 SHORT $LN775@sre_umatch
  0070a	41 0f b7 01	 movzx	 eax, WORD PTR [r9]
  0070e	eb 03		 jmp	 SHORT $LN776@sre_umatch
$LN775@sre_umatch:
  00710	41 8b 01	 mov	 eax, DWORD PTR [r9]
$LN776@sre_umatch:
  00713	44 3b c0	 cmp	 r8d, eax
  00716	0f 85 bb fc ff
	ff		 jne	 $LN30@sre_umatch

; 1319 :                             RETURN_FAILURE;
; 1320 :                         p += state->charsize;
; 1321 :                         ctx->ptr += state->charsize;

  0071c	48 8d 04 0a	 lea	 rax, QWORD PTR [rdx+rcx]
  00720	4c 03 c9	 add	 r9, rcx
  00723	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  00727	4d 3b ca	 cmp	 r9, r10
  0072a	72 a4		 jb	 SHORT $LL115@sre_umatch
$LN114@sre_umatch:

; 919  :             ctx->ptr += state->charsize;
; 920  :             break;

  0072c	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]

; 1322 :                     }
; 1323 :                 }
; 1324 :             }
; 1325 :             ctx->pattern++;

  00731	49 8d 43 04	 lea	 rax, QWORD PTR [r11+4]
  00735	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax
  00739	e9 a3 f9 ff ff	 jmp	 $LN703@sre_umatch
$LN108@sre_umatch:

; 1326 :             break;
; 1327 : 
; 1328 :         case SRE_OP_GROUPREF_IGNORE:
; 1329 :             /* match backreference */
; 1330 :             TRACE(("|%p|%p|GROUPREF_IGNORE %d\n", ctx->pattern,
; 1331 :                    ctx->ptr, ctx->pattern[0]));
; 1332 :             i = ctx->pattern[0];
; 1333 :             {
; 1334 :                 Py_ssize_t groupref = i+i;

  0073e	41 8b 03	 mov	 eax, DWORD PTR [r11]
  00741	48 03 c0	 add	 rax, rax

; 1335 :                 if (groupref >= state->lastmark) {

  00744	49 3b 45 48	 cmp	 rax, QWORD PTR [r13+72]

; 1336 :                     RETURN_FAILURE;

  00748	0f 8d 89 fc ff
	ff		 jge	 $LN30@sre_umatch

; 1337 :                 } else {
; 1338 :                     char* p = (char*) state->mark[groupref];

  0074e	49 8b 6c c5 50	 mov	 rbp, QWORD PTR [r13+rax*8+80]

; 1339 :                     char* e = (char*) state->mark[groupref+1];

  00753	4d 8b 64 c5 58	 mov	 r12, QWORD PTR [r13+rax*8+88]

; 1340 :                     if (!p || !e || e < p)

  00758	48 85 ed	 test	 rbp, rbp
  0075b	0f 84 76 fc ff
	ff		 je	 $LN30@sre_umatch
  00761	4d 85 e4	 test	 r12, r12
  00764	0f 84 6d fc ff
	ff		 je	 $LN30@sre_umatch
  0076a	49 3b ec	 cmp	 rbp, r12
  0076d	0f 87 64 fc ff
	ff		 ja	 $LN30@sre_umatch

; 1341 :                         RETURN_FAILURE;
; 1342 :                     while (p < e) {

  00773	0f 83 fb f9 ff
	ff		 jae	 $LN670@sre_umatch
  00779	0f 1f 80 00 00
	00 00		 npad	 7
$LL97@sre_umatch:

; 1343 :                         if (ctx->ptr >= end ||
; 1344 :                             state->lower(SRE_CHARGET(state, ctx->ptr, 0)) !=
; 1345 :                             state->lower(SRE_CHARGET(state, p, 0)))

  00780	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00784	49 3b c7	 cmp	 rax, r15
  00787	0f 83 43 fc ff
	ff		 jae	 $LN557@sre_umatch
  0078d	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  00791	83 f9 01	 cmp	 ecx, 1
  00794	75 05		 jne	 SHORT $LN781@sre_umatch
  00796	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00799	eb 0c		 jmp	 SHORT $LN780@sre_umatch
$LN781@sre_umatch:
  0079b	83 f9 02	 cmp	 ecx, 2
  0079e	75 05		 jne	 SHORT $LN779@sre_umatch
  007a0	0f b7 10	 movzx	 edx, WORD PTR [rax]
  007a3	eb 02		 jmp	 SHORT $LN780@sre_umatch
$LN779@sre_umatch:
  007a5	8b 10		 mov	 edx, DWORD PTR [rax]
$LN780@sre_umatch:
  007a7	83 f9 01	 cmp	 ecx, 1
  007aa	75 06		 jne	 SHORT $LN785@sre_umatch
  007ac	0f b6 75 00	 movzx	 esi, BYTE PTR [rbp]
  007b0	eb 0e		 jmp	 SHORT $LN784@sre_umatch
$LN785@sre_umatch:
  007b2	83 f9 02	 cmp	 ecx, 2
  007b5	75 06		 jne	 SHORT $LN783@sre_umatch
  007b7	0f b7 75 00	 movzx	 esi, WORD PTR [rbp]
  007bb	eb 03		 jmp	 SHORT $LN784@sre_umatch
$LN783@sre_umatch:
  007bd	8b 75 00	 mov	 esi, DWORD PTR [rbp]
$LN784@sre_umatch:
  007c0	8b ca		 mov	 ecx, edx
  007c2	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  007c9	8b ce		 mov	 ecx, esi
  007cb	8b d8		 mov	 ebx, eax
  007cd	41 ff 95 00 07
	00 00		 call	 QWORD PTR [r13+1792]
  007d4	3b d8		 cmp	 ebx, eax
  007d6	0f 85 f4 fb ff
	ff		 jne	 $LN557@sre_umatch

; 1346 :                             RETURN_FAILURE;
; 1347 :                         p += state->charsize;

  007dc	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]

; 1348 :                         ctx->ptr += state->charsize;

  007e0	48 01 47 10	 add	 QWORD PTR [rdi+16], rax
  007e4	48 03 e8	 add	 rbp, rax
  007e7	49 3b ec	 cmp	 rbp, r12
  007ea	72 94		 jb	 SHORT $LL97@sre_umatch

; 844  :             break;

  007ec	48 83 47 18 04	 add	 QWORD PTR [rdi+24], 4
  007f1	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]

; 1122 :                     DO_JUMP(JUMP_MIN_REPEAT_ONE,jump_min_repeat_one,
; 1123 :                             ctx->pattern+ctx->pattern[0]);

  007f6	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  007fd	e9 df f8 ff ff	 jmp	 $LN703@sre_umatch
$LN90@sre_umatch:

; 1349 :                     }
; 1350 :                 }
; 1351 :             }
; 1352 :             ctx->pattern++;
; 1353 :             break;
; 1354 : 
; 1355 :         case SRE_OP_GROUPREF_EXISTS:
; 1356 :             TRACE(("|%p|%p|GROUPREF_EXISTS %d\n", ctx->pattern,
; 1357 :                    ctx->ptr, ctx->pattern[0]));
; 1358 :             /* <GROUPREF_EXISTS> <group> <skip> codeyes <JUMP> codeno ... */
; 1359 :             i = ctx->pattern[0];
; 1360 :             {
; 1361 :                 Py_ssize_t groupref = i+i;

  00802	41 8b 03	 mov	 eax, DWORD PTR [r11]
  00805	48 03 c0	 add	 rax, rax

; 1362 :                 if (groupref >= state->lastmark) {

  00808	49 3b 45 48	 cmp	 rax, QWORD PTR [r13+72]
  0080c	7c 0d		 jl	 SHORT $LN89@sre_umatch
$LN86@sre_umatch:

; 1363 :                     ctx->pattern += ctx->pattern[1];

  0080e	41 8b 43 04	 mov	 eax, DWORD PTR [r11+4]
  00812	49 8d 0c 83	 lea	 rcx, QWORD PTR [r11+rax*4]

; 1364 :                     break;

  00816	e9 c2 f8 ff ff	 jmp	 $LN888@sre_umatch
$LN89@sre_umatch:

; 1365 :                 } else {
; 1366 :                     SRE_CHAR* p = (SRE_CHAR*) state->mark[groupref];

  0081b	49 8b 54 c5 50	 mov	 rdx, QWORD PTR [r13+rax*8+80]

; 1367 :                     SRE_CHAR* e = (SRE_CHAR*) state->mark[groupref+1];

  00820	49 8b 4c c5 58	 mov	 rcx, QWORD PTR [r13+rax*8+88]

; 1368 :                     if (!p || !e || e < p) {

  00825	48 85 d2	 test	 rdx, rdx
  00828	74 e4		 je	 SHORT $LN86@sre_umatch
  0082a	48 85 c9	 test	 rcx, rcx
  0082d	74 df		 je	 SHORT $LN86@sre_umatch
  0082f	48 3b ca	 cmp	 rcx, rdx
  00832	72 da		 jb	 SHORT $LN86@sre_umatch

; 1369 :                         ctx->pattern += ctx->pattern[1];
; 1370 :                         break;
; 1371 :                     }
; 1372 :                 }
; 1373 :             }
; 1374 :             ctx->pattern += 2;

  00834	49 8d 43 08	 lea	 rax, QWORD PTR [r11+8]
  00838	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 1375 :             break;

  0083c	e9 a0 f8 ff ff	 jmp	 $LN703@sre_umatch
$LN85@sre_umatch:

; 1376 : 
; 1377 :         case SRE_OP_ASSERT:
; 1378 :             /* assert subpattern */
; 1379 :             /* <ASSERT> <skip> <back> <pattern> */
; 1380 :             TRACE(("|%p|%p|ASSERT %d\n", ctx->pattern,
; 1381 :                    ctx->ptr, ctx->pattern[1]));
; 1382 :             state->ptr = ctx->ptr - state->charsize * ctx->pattern[1];

  00841	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  00845	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00849	41 0f af 4d 3c	 imul	 ecx, DWORD PTR [r13+60]
  0084e	48 2b c1	 sub	 rax, rcx
  00851	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1383 :             if (state->ptr < state->beginning)

  00855	49 3b 45 08	 cmp	 rax, QWORD PTR [r13+8]
  00859	0f 82 78 fb ff
	ff		 jb	 $LN30@sre_umatch

; 1384 :                 RETURN_FAILURE;
; 1385 :             DO_JUMP(JUMP_ASSERT, jump_assert, ctx->pattern+2);

  0085f	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00866	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  0086d	48 2b c3	 sub	 rax, rbx
  00870	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00874	73 26		 jae	 SHORT $LN72@sre_umatch
  00876	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0087b	49 8b cd	 mov	 rcx, r13
  0087e	e8 00 00 00 00	 call	 data_stack_grow
  00883	85 c0		 test	 eax, eax
  00885	0f 88 8d 0c 00
	00		 js	 $LN855@sre_umatch
  0088b	49 83 fe ff	 cmp	 r14, -1
  0088f	74 0b		 je	 SHORT $LN72@sre_umatch
  00891	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00898	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN72@sre_umatch:
  0089c	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  008a3	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  008ab	48 c7 44 03 08
	0c 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 12
  008b4	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  008b8	e9 14 08 00 00	 jmp	 $LN890@sre_umatch
$LN55@sre_umatch:

; 1387 :             ctx->pattern += ctx->pattern[0];
; 1388 :             break;
; 1389 : 
; 1390 :         case SRE_OP_ASSERT_NOT:
; 1391 :             /* assert not subpattern */
; 1392 :             /* <ASSERT_NOT> <skip> <back> <pattern> */
; 1393 :             TRACE(("|%p|%p|ASSERT_NOT %d\n", ctx->pattern,
; 1394 :                    ctx->ptr, ctx->pattern[1]));
; 1395 :             state->ptr = ctx->ptr - state->charsize * ctx->pattern[1];

  008bd	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  008c1	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  008c5	41 0f af 4d 3c	 imul	 ecx, DWORD PTR [r13+60]
  008ca	48 2b c1	 sub	 rax, rcx
  008cd	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1396 :             if (state->ptr >= state->beginning) {

  008d1	49 3b 45 08	 cmp	 rax, QWORD PTR [r13+8]
  008d5	0f 83 9d 07 00
	00		 jae	 $LN845@sre_umatch
$LN32@sre_umatch:

; 1400 :                     RETURN_FAILURE;
; 1401 :                 }
; 1402 :             }
; 1403 :             ctx->pattern += ctx->pattern[0];

  008db	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]

; 1415 :         }
; 1416 :     }

  008df	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  008e4	8b 01		 mov	 eax, DWORD PTR [rcx]
  008e6	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  008ea	e9 ee f7 ff ff	 jmp	 $LN888@sre_umatch
$jump_max_until_2$22871:

; 1217 :                 DATA_POP(&ctx->u.rep->last_ptr);

  008ef	48 8d 54 11 f8	 lea	 rdx, QWORD PTR [rcx+rdx-8]
  008f4	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  008f8	41 b8 08 00 00
	00		 mov	 r8d, 8
  008fe	48 83 c1 10	 add	 rcx, 16
  00902	e8 00 00 00 00	 call	 memcpy
  00907	49 83 85 a0 06
	00 00 f8	 add	 QWORD PTR [r13+1696], -8
  0090f	49 8b 95 a0 06
	00 00		 mov	 rdx, QWORD PTR [r13+1696]

; 1218 :                 if (ret) {

  00916	48 85 db	 test	 rbx, rbx
  00919	0f 84 d1 07 00
	00		 je	 $LN269@sre_umatch

; 1219 :                     MARK_POP_DISCARD(ctx->lastmark);

  0091f	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00923	48 85 c0	 test	 rax, rax
  00926	0f 8e e3 01 00
	00		 jle	 $LN587@sre_umatch
  0092c	48 c1 e0 03	 shl	 rax, 3
  00930	48 2b d0	 sub	 rdx, rax
  00933	48 83 ea 08	 sub	 rdx, 8
  00937	49 89 95 a0 06
	00 00		 mov	 QWORD PTR [r13+1696], rdx

; 1220 :                     RETURN_ON_ERROR(ret);
; 1221 :                     RETURN_SUCCESS;

  0093e	e9 cc 01 00 00	 jmp	 $LN587@sre_umatch
$jump_max_until_3$22927:

; 1233 :             RETURN_ON_SUCCESS(ret);

  00943	48 85 db	 test	 rbx, rbx
  00946	0f 88 6a 06 00
	00		 js	 $LN825@sre_umatch
  0094c	0f 8f c6 01 00
	00		 jg	 $LN896@sre_umatch

; 1234 :             state->repeat = ctx->u.rep;

  00952	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00956	49 89 85 f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rax

; 1235 :             state->ptr = ctx->ptr;

  0095d	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00961	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1236 :             RETURN_FAILURE;

  00965	e9 6d fa ff ff	 jmp	 $LN30@sre_umatch
$jump_min_until_2$23006:

; 1272 :             if (ret) {

  0096a	48 85 db	 test	 rbx, rbx

; 1273 :                 RETURN_ON_ERROR(ret);
; 1274 :                 RETURN_SUCCESS;

  0096d	0f 85 9f 01 00
	00		 jne	 $LN895@sre_umatch

; 1275 :             }
; 1276 : 
; 1277 :             state->repeat = ctx->u.rep;

  00973	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00977	49 89 85 f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rax

; 1278 :             state->ptr = ctx->ptr;

  0097e	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00982	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1279 : 
; 1280 :             LASTMARK_RESTORE();

  00986	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  0098a	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  0098e	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00992	49 89 45 40	 mov	 QWORD PTR [r13+64], rax

; 1281 : 
; 1282 :             if ((ctx->count >= (Py_ssize_t) ctx->u.rep->pattern[2]
; 1283 :                 && ctx->u.rep->pattern[2] != SRE_MAXREPEAT) ||
; 1284 :                 state->ptr == ctx->u.rep->last_ptr)

  00996	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  0099a	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0099e	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  009a1	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  009a5	7c 09		 jl	 SHORT $LN168@sre_umatch
  009a7	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  009aa	0f 85 27 fa ff
	ff		 jne	 $LN30@sre_umatch
$LN168@sre_umatch:
  009b0	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  009b4	49 39 45 00	 cmp	 QWORD PTR [r13], rax
  009b8	0f 84 19 fa ff
	ff		 je	 $LN30@sre_umatch

; 1285 :                 RETURN_FAILURE;
; 1286 : 
; 1287 :             ctx->u.rep->count = ctx->count;

  009be	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  009c2	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  009c6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1288 :             /* zero-width match protection */
; 1289 :             DATA_PUSH(&ctx->u.rep->last_ptr);

  009c9	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  009d0	49 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [r13+1696]
  009d7	48 83 f8 08	 cmp	 rax, 8
  009db	73 20		 jae	 SHORT $LN156@sre_umatch
  009dd	ba 08 00 00 00	 mov	 edx, 8
  009e2	49 8b cd	 mov	 rcx, r13
  009e5	e8 00 00 00 00	 call	 data_stack_grow
  009ea	85 c0		 test	 eax, eax
  009ec	0f 88 26 0b 00
	00		 js	 $LN855@sre_umatch
  009f2	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  009f9	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN156@sre_umatch:
  009fd	49 8b 8d a0 06
	00 00		 mov	 rcx, QWORD PTR [r13+1696]
  00a04	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  00a08	41 b8 08 00 00
	00		 mov	 r8d, 8
  00a0e	49 03 8d 90 06
	00 00		 add	 rcx, QWORD PTR [r13+1680]
  00a15	48 83 c2 10	 add	 rdx, 16
  00a19	e8 00 00 00 00	 call	 memcpy
  00a1e	49 83 85 a0 06
	00 00 08	 add	 QWORD PTR [r13+1696], 8

; 1290 :             ctx->u.rep->last_ptr = state->ptr;

  00a26	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  00a2a	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00a2e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1291 :             DO_JUMP(JUMP_MIN_UNTIL_3,jump_min_until_3,
; 1292 :                     ctx->u.rep->pattern+3);

  00a32	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00a39	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00a40	48 2b c3	 sub	 rax, rbx
  00a43	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00a47	73 20		 jae	 SHORT $LN147@sre_umatch
  00a49	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00a4e	49 8b cd	 mov	 rcx, r13
  00a51	e8 00 00 00 00	 call	 data_stack_grow
  00a56	85 c0		 test	 eax, eax
  00a58	0f 88 ba 0a 00
	00		 js	 $LN855@sre_umatch
  00a5e	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00a65	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN147@sre_umatch:
  00a69	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00a70	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  00a78	48 c7 44 03 08
	06 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 6
  00a81	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
$LN894@sre_umatch:

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  00a85	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00a8a	4c 89 32	 mov	 QWORD PTR [rdx], r14
  00a8d	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00a91	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00a95	48 8b fa	 mov	 rdi, rdx
  00a98	4c 8b f3	 mov	 r14, rbx
  00a9b	48 83 c1 0c	 add	 rcx, 12
  00a9f	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00aa3	e9 f8 f5 ff ff	 jmp	 $entrance$22309
$jump_min_until_3$23058:

; 1293 :             DATA_POP(&ctx->u.rep->last_ptr);

  00aa8	48 8d 54 11 f8	 lea	 rdx, QWORD PTR [rcx+rdx-8]
  00aad	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00ab1	41 b8 08 00 00
	00		 mov	 r8d, 8
  00ab7	48 83 c1 10	 add	 rcx, 16
  00abb	e8 00 00 00 00	 call	 memcpy
  00ac0	49 83 85 a0 06
	00 00 f8	 add	 QWORD PTR [r13+1696], -8

; 1294 :             if (ret) {

  00ac8	48 85 db	 test	 rbx, rbx

; 1295 :                 RETURN_ON_ERROR(ret);
; 1296 :                 RETURN_SUCCESS;

  00acb	75 45		 jne	 SHORT $LN895@sre_umatch
$LN130@sre_umatch:

; 1297 :             }
; 1298 :             ctx->u.rep->count = ctx->count-1;

  00acd	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00ad1	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00ad5	48 ff c9	 dec	 rcx
  00ad8	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1299 :             state->ptr = ctx->ptr;

  00adb	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00adf	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1300 :             RETURN_FAILURE;

  00ae3	e9 ef f8 ff ff	 jmp	 $LN30@sre_umatch
$jump_branch$22483:

; 980  :                 if (ret) {

  00ae8	48 85 db	 test	 rbx, rbx
  00aeb	74 35		 je	 SHORT $LN573@sre_umatch

; 981  :                     if (ctx->u.rep)

  00aed	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  00af2	74 1b		 je	 SHORT $LN587@sre_umatch

; 982  :                         MARK_POP_DISCARD(ctx->lastmark);

  00af4	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00af8	48 85 c0	 test	 rax, rax
  00afb	7e 12		 jle	 SHORT $LN587@sre_umatch
  00afd	48 c1 e0 03	 shl	 rax, 3
  00b01	48 2b c8	 sub	 rcx, rax
  00b04	48 83 e9 08	 sub	 rcx, 8
  00b08	49 89 8d a0 06
	00 00		 mov	 QWORD PTR [r13+1696], rcx
$LN587@sre_umatch:

; 983  :                     RETURN_ON_ERROR(ret);

  00b0f	48 85 db	 test	 rbx, rbx
$LN895@sre_umatch:
  00b12	0f 88 9e 04 00
	00		 js	 $LN825@sre_umatch
$LN896@sre_umatch:

; 984  :                     RETURN_SUCCESS;

  00b18	bb 01 00 00 00	 mov	 ebx, 1
  00b1d	e9 b7 f8 ff ff	 jmp	 $exit$22316
$LN573@sre_umatch:

; 985  :                 }
; 986  :                 if (ctx->u.rep)

  00b22	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  00b27	74 22		 je	 SHORT $LN569@sre_umatch

; 987  :                     MARK_POP_KEEP(ctx->lastmark);

  00b29	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00b2d	48 85 c0	 test	 rax, rax
  00b30	7e 19		 jle	 SHORT $LN569@sre_umatch
  00b32	48 c1 e0 03	 shl	 rax, 3
  00b36	48 2b c8	 sub	 rcx, rax
  00b39	4c 8d 40 08	 lea	 r8, QWORD PTR [rax+8]
  00b3d	48 8d 54 11 f8	 lea	 rdx, QWORD PTR [rcx+rdx-8]
  00b42	49 8d 4d 50	 lea	 rcx, QWORD PTR [r13+80]
  00b46	e8 00 00 00 00	 call	 memcpy
$LN569@sre_umatch:

; 988  :                 LASTMARK_RESTORE();

  00b4b	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00b4f	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  00b53	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00b57	49 89 45 40	 mov	 QWORD PTR [r13+64], rax
$LN608@sre_umatch:

; 969  :             for (; ctx->pattern[0]; ctx->pattern += ctx->pattern[0]) {

  00b5b	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00b5f	8b 01		 mov	 eax, DWORD PTR [rcx]
  00b61	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00b65	48 89 4f 18	 mov	 QWORD PTR [rdi+24], rcx
$LN609@sre_umatch:
  00b69	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  00b6d	41 83 38 00	 cmp	 DWORD PTR [r8], 0
  00b71	0f 84 ea 00 00
	00		 je	 $LN607@sre_umatch

; 970  :                 if (ctx->pattern[1] == SRE_OP_LITERAL &&
; 971  :                     (ctx->ptr >= end ||
; 972  :                      (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0) != ctx->pattern[2]))

  00b77	41 8b 50 04	 mov	 edx, DWORD PTR [r8+4]
  00b7b	83 fa 13	 cmp	 edx, 19
  00b7e	75 29		 jne	 SHORT $LN606@sre_umatch
  00b80	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00b84	49 3b c7	 cmp	 rax, r15
  00b87	73 d2		 jae	 SHORT $LN608@sre_umatch
  00b89	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  00b8d	83 f9 01	 cmp	 ecx, 1
  00b90	75 05		 jne	 SHORT $LN760@sre_umatch
  00b92	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00b95	eb 0c		 jmp	 SHORT $LN759@sre_umatch
$LN760@sre_umatch:
  00b97	83 f9 02	 cmp	 ecx, 2
  00b9a	75 05		 jne	 SHORT $LN758@sre_umatch
  00b9c	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00b9f	eb 02		 jmp	 SHORT $LN759@sre_umatch
$LN758@sre_umatch:
  00ba1	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN759@sre_umatch:
  00ba3	41 3b 48 08	 cmp	 ecx, DWORD PTR [r8+8]

; 973  :                     continue;

  00ba7	75 b2		 jne	 SHORT $LN608@sre_umatch
$LN606@sre_umatch:

; 974  :                 if (ctx->pattern[1] == SRE_OP_IN &&
; 975  :                     (ctx->ptr >= end ||
; 976  :                      !SRE_CHARSET(ctx->pattern + 3, (SRE_CODE) SRE_CHARGET(state, ctx->ptr, 0))))

  00ba9	83 fa 0f	 cmp	 edx, 15
  00bac	75 34		 jne	 SHORT $LN604@sre_umatch
  00bae	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  00bb2	49 3b c7	 cmp	 rax, r15
  00bb5	73 a4		 jae	 SHORT $LN608@sre_umatch
  00bb7	41 8b 4d 3c	 mov	 ecx, DWORD PTR [r13+60]
  00bbb	83 f9 01	 cmp	 ecx, 1
  00bbe	75 05		 jne	 SHORT $LN764@sre_umatch
  00bc0	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00bc3	eb 0c		 jmp	 SHORT $LN763@sre_umatch
$LN764@sre_umatch:
  00bc5	83 f9 02	 cmp	 ecx, 2
  00bc8	75 05		 jne	 SHORT $LN762@sre_umatch
  00bca	0f b7 10	 movzx	 edx, WORD PTR [rax]
  00bcd	eb 02		 jmp	 SHORT $LN763@sre_umatch
$LN762@sre_umatch:
  00bcf	8b 10		 mov	 edx, DWORD PTR [rax]
$LN763@sre_umatch:
  00bd1	49 8d 48 0c	 lea	 rcx, QWORD PTR [r8+12]
  00bd5	e8 00 00 00 00	 call	 sre_ucharset
  00bda	85 c0		 test	 eax, eax
  00bdc	0f 84 79 ff ff
	ff		 je	 $LN608@sre_umatch
$LN604@sre_umatch:

; 977  :                     continue;
; 978  :                 state->ptr = ctx->ptr;

  00be2	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 979  :                 DO_JUMP(JUMP_BRANCH, jump_branch, ctx->pattern+1);

  00be6	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00bed	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00bf1	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00bf8	48 2b c3	 sub	 rax, rbx
  00bfb	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00bff	73 26		 jae	 SHORT $LN594@sre_umatch
  00c01	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00c06	49 8b cd	 mov	 rcx, r13
  00c09	e8 00 00 00 00	 call	 data_stack_grow
  00c0e	85 c0		 test	 eax, eax
  00c10	0f 88 02 09 00
	00		 js	 $LN855@sre_umatch
  00c16	49 83 fe ff	 cmp	 r14, -1
  00c1a	74 0b		 je	 SHORT $LN594@sre_umatch
  00c1c	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00c23	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN594@sre_umatch:
  00c27	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00c2e	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  00c36	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00c3b	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  00c3f	4c 89 31	 mov	 QWORD PTR [rcx], r14
  00c42	48 c7 41 08 0b
	00 00 00	 mov	 QWORD PTR [rcx+8], 11
  00c4a	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00c4e	48 83 c0 04	 add	 rax, 4
  00c52	4c 8b f3	 mov	 r14, rbx
  00c55	48 8b f9	 mov	 rdi, rcx
  00c58	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  00c5c	e9 2e f4 ff ff	 jmp	 $LN893@sre_umatch
$LN607@sre_umatch:

; 989  :             }
; 990  :             if (ctx->u.rep)

  00c61	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
  00c66	0f 84 64 f7 ff
	ff		 je	 $LN557@sre_umatch

; 991  :                 MARK_POP_DISCARD(ctx->lastmark);

  00c6c	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00c70	48 85 c0	 test	 rax, rax
  00c73	0f 8e 57 f7 ff
	ff		 jle	 $LN557@sre_umatch
  00c79	48 c1 e0 03	 shl	 rax, 3
  00c7d	48 c7 c1 f8 ff
	ff ff		 mov	 rcx, -8
  00c84	48 2b c8	 sub	 rcx, rax
  00c87	49 01 8d a0 06
	00 00		 add	 QWORD PTR [r13+1696], rcx

; 992  :             RETURN_FAILURE;

  00c8e	e9 3d f7 ff ff	 jmp	 $LN557@sre_umatch
$jump_min_until_1$22970:
$jump_max_until_1$22801:

; 1258 :                 if (ret) {

  00c93	48 85 db	 test	 rbx, rbx
  00c96	0f 84 31 fe ff
	ff		 je	 $LN130@sre_umatch

; 1259 :                     RETURN_ON_ERROR(ret);
; 1260 :                     RETURN_SUCCESS;

  00c9c	e9 71 fe ff ff	 jmp	 $LN895@sre_umatch
$jump_repeat$22761:

; 1163 :             state->repeat = ctx->u.rep->prev;

  00ca1	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00ca5	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00ca9	49 89 8d f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rcx

; 1164 :             PyObject_FREE(ctx->u.rep);

  00cb0	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00cb4	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 1165 : 
; 1166 :             if (ret) {

  00cb9	48 85 db	 test	 rbx, rbx
  00cbc	0f 84 15 f7 ff
	ff		 je	 $LN30@sre_umatch

; 1167 :                 RETURN_ON_ERROR(ret);
; 1168 :                 RETURN_SUCCESS;

  00cc2	e9 4b fe ff ff	 jmp	 $LN895@sre_umatch
$jump_repeat_one_1$22592:

; 1050 :                     if (ret) {

  00cc7	48 85 db	 test	 rbx, rbx

; 1051 :                         RETURN_ON_ERROR(ret);
; 1052 :                         RETURN_SUCCESS;

  00cca	0f 85 42 fe ff
	ff		 jne	 $LN895@sre_umatch

; 1053 :                     }
; 1054 : 
; 1055 :                     LASTMARK_RESTORE();

  00cd0	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00cd4	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  00cd8	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00cdc	49 89 45 40	 mov	 QWORD PTR [r13+64], rax

; 1056 : 
; 1057 :                     ctx->ptr -= state->charsize;

  00ce0	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  00ce4	48 29 47 10	 sub	 QWORD PTR [rdi+16], rax

; 1058 :                     ctx->count--;

  00ce8	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
$LN522@sre_umatch:

; 1038 :                 for (;;) {
; 1039 :                     while (ctx->count >= (Py_ssize_t) ctx->pattern[1] &&
; 1040 :                            (ctx->ptr >= end ||
; 1041 :                             SRE_CHARGET(state, ctx->ptr, 0) != ctx->u.chr)) {

  00cec	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00cf0	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00cf3	48 39 47 20	 cmp	 QWORD PTR [rdi+32], rax
  00cf7	7c 47		 jl	 SHORT $LN872@sre_umatch
  00cf9	0f 1f 80 00 00
	00 00		 npad	 7
$LL520@sre_umatch:
  00d00	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00d04	49 3b cf	 cmp	 rcx, r15
  00d07	73 1f		 jae	 SHORT $LN518@sre_umatch
  00d09	41 8b 45 3c	 mov	 eax, DWORD PTR [r13+60]
  00d0d	83 f8 01	 cmp	 eax, 1
  00d10	75 05		 jne	 SHORT $LN768@sre_umatch
  00d12	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00d15	eb 0c		 jmp	 SHORT $LN767@sre_umatch
$LN768@sre_umatch:
  00d17	83 f8 02	 cmp	 eax, 2
  00d1a	75 05		 jne	 SHORT $LN766@sre_umatch
  00d1c	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00d1f	eb 02		 jmp	 SHORT $LN767@sre_umatch
$LN766@sre_umatch:
  00d21	8b 01		 mov	 eax, DWORD PTR [rcx]
$LN767@sre_umatch:
  00d23	3b 47 38	 cmp	 eax, DWORD PTR [rdi+56]
  00d26	74 18		 je	 SHORT $LN872@sre_umatch
$LN518@sre_umatch:

; 1042 :                         ctx->ptr -= state->charsize;

  00d28	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]

; 1043 :                         ctx->count--;

  00d2c	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
  00d30	48 2b c8	 sub	 rcx, rax
  00d33	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx
  00d37	8b 4a 04	 mov	 ecx, DWORD PTR [rdx+4]
  00d3a	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00d3e	7d c0		 jge	 SHORT $LL520@sre_umatch
$LN872@sre_umatch:

; 1044 :                     }
; 1045 :                     if (ctx->count < (Py_ssize_t) ctx->pattern[1])

  00d40	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00d43	48 39 47 20	 cmp	 QWORD PTR [rdi+32], rax
  00d47	0f 8c 8a f6 ff
	ff		 jl	 $LN30@sre_umatch

; 1046 :                         break;
; 1047 :                     state->ptr = ctx->ptr;

  00d4d	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1048 :                     DO_JUMP(JUMP_REPEAT_ONE_1, jump_repeat_one_1,
; 1049 :                             ctx->pattern+ctx->pattern[0]);

  00d51	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00d58	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00d5c	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00d63	48 2b c3	 sub	 rax, rbx
  00d66	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00d6a	73 26		 jae	 SHORT $LN508@sre_umatch
  00d6c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00d71	49 8b cd	 mov	 rcx, r13
  00d74	e8 00 00 00 00	 call	 data_stack_grow
  00d79	85 c0		 test	 eax, eax
  00d7b	0f 88 97 07 00
	00		 js	 $LN855@sre_umatch
  00d81	49 83 fe ff	 cmp	 r14, -1
  00d85	74 0b		 je	 SHORT $LN508@sre_umatch
  00d87	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00d8e	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN508@sre_umatch:
  00d92	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00d99	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  00da1	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00da6	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  00daa	4c 89 32	 mov	 QWORD PTR [rdx], r14
  00dad	48 c7 42 08 08
	00 00 00	 mov	 QWORD PTR [rdx+8], 8
  00db5	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00db9	8b 01		 mov	 eax, DWORD PTR [rcx]
  00dbb	48 8b fa	 mov	 rdi, rdx
  00dbe	4c 8b f3	 mov	 r14, rbx
  00dc1	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00dc5	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00dc9	e9 d2 f2 ff ff	 jmp	 $entrance$22309
$jump_repeat_one_2$22630:

; 1067 :                     if (ret) {

  00dce	48 85 db	 test	 rbx, rbx

; 1068 :                         RETURN_ON_ERROR(ret);
; 1069 :                         RETURN_SUCCESS;

  00dd1	0f 85 3b fd ff
	ff		 jne	 $LN895@sre_umatch

; 1070 :                     }
; 1071 :                     ctx->ptr -= state->charsize;

  00dd7	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  00ddb	48 29 47 10	 sub	 QWORD PTR [rdi+16], rax

; 1072 :                     ctx->count--;
; 1073 :                     LASTMARK_RESTORE();

  00ddf	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00de3	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
  00de7	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  00deb	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00def	49 89 45 40	 mov	 QWORD PTR [r13+64], rax
$LN490@sre_umatch:

; 1059 :                 }
; 1060 : 
; 1061 :             } else {
; 1062 :                 /* general case */
; 1063 :                 while (ctx->count >= (Py_ssize_t) ctx->pattern[1]) {

  00df3	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00df7	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00dfa	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00dfe	0f 8c d3 f5 ff
	ff		 jl	 $LN30@sre_umatch

; 1064 :                     state->ptr = ctx->ptr;

  00e04	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1065 :                     DO_JUMP(JUMP_REPEAT_ONE_2, jump_repeat_one_2,
; 1066 :                             ctx->pattern+ctx->pattern[0]);

  00e08	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00e0f	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00e13	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00e1a	48 2b c3	 sub	 rax, rbx
  00e1d	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00e21	73 26		 jae	 SHORT $LN480@sre_umatch
  00e23	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00e28	49 8b cd	 mov	 rcx, r13
  00e2b	e8 00 00 00 00	 call	 data_stack_grow
  00e30	85 c0		 test	 eax, eax
  00e32	0f 88 e0 06 00
	00		 js	 $LN855@sre_umatch
  00e38	49 83 fe ff	 cmp	 r14, -1
  00e3c	74 0b		 je	 SHORT $LN480@sre_umatch
  00e3e	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00e45	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN480@sre_umatch:
  00e49	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00e50	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  00e58	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00e5d	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  00e61	4c 89 32	 mov	 QWORD PTR [rdx], r14
  00e64	48 c7 42 08 09
	00 00 00	 mov	 QWORD PTR [rdx+8], 9
  00e6c	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00e70	8b 01		 mov	 eax, DWORD PTR [rcx]
  00e72	48 8b fa	 mov	 rdi, rdx
  00e75	4c 8b f3	 mov	 r14, rbx
  00e78	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00e7c	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00e80	e9 1b f2 ff ff	 jmp	 $entrance$22309
$jump_min_repeat_one$22705:

; 1124 :                     if (ret) {

  00e85	48 85 db	 test	 rbx, rbx

; 1125 :                         RETURN_ON_ERROR(ret);
; 1126 :                         RETURN_SUCCESS;

  00e88	0f 85 84 fc ff
	ff		 jne	 $LN895@sre_umatch

; 1127 :                     }
; 1128 :                     state->ptr = ctx->ptr;

  00e8e	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1129 :                     ret = SRE_COUNT(state, ctx->pattern+3, 1);

  00e92	44 8d 43 01	 lea	 r8d, QWORD PTR [rbx+1]
  00e96	49 8b cd	 mov	 rcx, r13
  00e99	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00e9d	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00ea1	48 83 c2 0c	 add	 rdx, 12
  00ea5	e8 00 00 00 00	 call	 sre_ucount

; 1130 :                     RETURN_ON_ERROR(ret);

  00eaa	48 85 c0	 test	 rax, rax
  00ead	0f 88 76 06 00
	00		 js	 $LN879@sre_umatch

; 1131 :                     DATA_LOOKUP_AT(SRE_MATCH_CONTEXT, ctx, ctx_pos);

  00eb3	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]
  00eba	49 8d 3c 0e	 lea	 rdi, QWORD PTR [r14+rcx]

; 1132 :                     if (ret == 0)

  00ebe	0f 84 13 f5 ff
	ff		 je	 $LN30@sre_umatch

; 1133 :                         break;
; 1134 :                     assert(ret == 1);

  00ec4	48 83 f8 01	 cmp	 rax, 1
  00ec8	74 1a		 je	 SHORT $LN770@sre_umatch
  00eca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@
  00ed1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@DAEMKNJI@?$AAr?$AAe?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00ed8	41 b8 6e 04 00
	00		 mov	 r8d, 1134		; 0000046eH
  00ede	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN770@sre_umatch:

; 1135 :                     ctx->ptr += state->charsize;

  00ee4	49 63 45 3c	 movsxd	 rax, DWORD PTR [r13+60]
  00ee8	48 01 47 10	 add	 QWORD PTR [rdi+16], rax

; 1136 :                     ctx->count++;
; 1137 :                     LASTMARK_RESTORE();

  00eec	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00ef0	48 ff 47 20	 inc	 QWORD PTR [rdi+32]
  00ef4	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  00ef8	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  00efc	49 89 45 40	 mov	 QWORD PTR [r13+64], rax
$LN431@sre_umatch:

; 1119 :                 while ((Py_ssize_t)ctx->pattern[2] == SRE_MAXREPEAT
; 1120 :                        || ctx->count <= (Py_ssize_t)ctx->pattern[2]) {

  00f00	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00f04	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00f07	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  00f0a	74 0a		 je	 SHORT $LN839@sre_umatch
  00f0c	48 39 4f 20	 cmp	 QWORD PTR [rdi+32], rcx
  00f10	0f 8f c1 f4 ff
	ff		 jg	 $LN30@sre_umatch
$LN839@sre_umatch:

; 1121 :                     state->ptr = ctx->ptr;

  00f16	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1122 :                     DO_JUMP(JUMP_MIN_REPEAT_ONE,jump_min_repeat_one,
; 1123 :                             ctx->pattern+ctx->pattern[0]);

  00f1a	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00f21	49 89 45 00	 mov	 QWORD PTR [r13], rax
  00f25	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  00f2c	48 2b c3	 sub	 rax, rbx
  00f2f	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  00f33	73 26		 jae	 SHORT $LN420@sre_umatch
  00f35	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00f3a	49 8b cd	 mov	 rcx, r13
  00f3d	e8 00 00 00 00	 call	 data_stack_grow
  00f42	85 c0		 test	 eax, eax
  00f44	0f 88 ce 05 00
	00		 js	 $LN855@sre_umatch
  00f4a	49 83 fe ff	 cmp	 r14, -1
  00f4e	74 0b		 je	 SHORT $LN420@sre_umatch
  00f50	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00f57	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN420@sre_umatch:
  00f5b	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  00f62	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  00f6a	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  00f6f	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  00f73	4c 89 32	 mov	 QWORD PTR [rdx], r14
  00f76	48 c7 42 08 0a
	00 00 00	 mov	 QWORD PTR [rdx+8], 10
  00f7e	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00f82	8b 01		 mov	 eax, DWORD PTR [rcx]
  00f84	48 8b fa	 mov	 rdi, rdx
  00f87	4c 8b f3	 mov	 r14, rbx
  00f8a	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  00f8e	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  00f92	e9 09 f1 ff ff	 jmp	 $entrance$22309
$jump_assert$23170:

; 1386 :             RETURN_ON_FAILURE(ret);

  00f97	48 85 db	 test	 rbx, rbx
  00f9a	78 1a		 js	 SHORT $LN825@sre_umatch
  00f9c	0f 85 39 f9 ff
	ff		 jne	 $LN32@sre_umatch
  00fa2	e9 30 f4 ff ff	 jmp	 $LN30@sre_umatch
$jump_assert_not$23205:

; 1398 :                 if (ret) {

  00fa7	48 85 db	 test	 rbx, rbx
  00faa	0f 84 2b f9 ff
	ff		 je	 $LN32@sre_umatch

; 1399 :                     RETURN_ON_ERROR(ret);

  00fb0	0f 89 21 f4 ff
	ff		 jns	 $LN30@sre_umatch
$LN825@sre_umatch:

; 1423 :         return ret;

  00fb6	48 8b c3	 mov	 rax, rbx
  00fb9	e9 6b 05 00 00	 jmp	 $LN879@sre_umatch
$LN385@sre_umatch:

; 1154 :             }
; 1155 :             ctx->u.rep->count = -1;

  00fbe	48 c7 00 ff ff
	ff ff		 mov	 QWORD PTR [rax], -1

; 1156 :             ctx->u.rep->pattern = ctx->pattern;

  00fc5	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00fc9	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00fcd	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1157 :             ctx->u.rep->prev = state->repeat;

  00fd1	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00fd5	49 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [r13+1784]
  00fdc	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1158 :             ctx->u.rep->last_ptr = NULL;

  00fe0	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  00fe4	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1159 :             state->repeat = ctx->u.rep;

  00fec	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1160 : 
; 1161 :             state->ptr = ctx->ptr;
; 1162 :             DO_JUMP(JUMP_REPEAT, jump_repeat, ctx->pattern+ctx->pattern[0]);

  00ff0	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  00ff7	49 89 85 f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rax
  00ffe	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  01002	49 89 45 00	 mov	 QWORD PTR [r13], rax
  01006	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  0100d	48 2b c3	 sub	 rax, rbx
  01010	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  01014	73 26		 jae	 SHORT $LN376@sre_umatch
  01016	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0101b	49 8b cd	 mov	 rcx, r13
  0101e	e8 00 00 00 00	 call	 data_stack_grow
  01023	85 c0		 test	 eax, eax
  01025	0f 88 ed 04 00
	00		 js	 $LN855@sre_umatch
  0102b	49 83 fe ff	 cmp	 r14, -1
  0102f	74 0b		 je	 SHORT $LN376@sre_umatch
  01031	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01038	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN376@sre_umatch:
  0103c	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01043	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  0104b	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  01050	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  01054	4c 89 32	 mov	 QWORD PTR [rdx], r14
  01057	48 c7 42 08 07
	00 00 00	 mov	 QWORD PTR [rdx+8], 7
  0105f	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  01063	8b 01		 mov	 eax, DWORD PTR [rcx]
  01065	48 8b fa	 mov	 rdi, rdx
  01068	4c 8b f3	 mov	 r14, rbx
  0106b	48 8d 0c 81	 lea	 rcx, QWORD PTR [rcx+rax*4]
  0106f	48 89 4a 18	 mov	 QWORD PTR [rdx+24], rcx
  01073	e9 28 f0 ff ff	 jmp	 $entrance$22309
$LN845@sre_umatch:
  01078	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  0107f	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  01086	48 2b c3	 sub	 rax, rbx
  01089	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  0108d	73 26		 jae	 SHORT $LN45@sre_umatch
  0108f	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01094	49 8b cd	 mov	 rcx, r13
  01097	e8 00 00 00 00	 call	 data_stack_grow
  0109c	85 c0		 test	 eax, eax
  0109e	0f 88 74 04 00
	00		 js	 $LN855@sre_umatch
  010a4	49 83 fe ff	 cmp	 r14, -1
  010a8	74 0b		 je	 SHORT $LN45@sre_umatch
  010aa	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  010b1	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN45@sre_umatch:
  010b5	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  010bc	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  010c4	48 c7 44 03 08
	0d 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 13
  010cd	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
$LN890@sre_umatch:
  010d1	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  010d6	4c 89 31	 mov	 QWORD PTR [rcx], r14
  010d9	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  010dd	48 83 c0 08	 add	 rax, 8
  010e1	48 8b f9	 mov	 rdi, rcx
  010e4	4c 8b f3	 mov	 r14, rbx
  010e7	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  010eb	e9 b0 ef ff ff	 jmp	 $entrance$22309
$LN269@sre_umatch:

; 1222 :                 }
; 1223 :                 MARK_POP(ctx->lastmark);

  010f0	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  010f4	48 85 c9	 test	 rcx, rcx
  010f7	7e 39		 jle	 SHORT $LN262@sre_umatch
  010f9	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01100	48 c1 e1 03	 shl	 rcx, 3
  01104	48 2b c1	 sub	 rax, rcx
  01107	4c 8d 41 08	 lea	 r8, QWORD PTR [rcx+8]
  0110b	49 8d 4d 50	 lea	 rcx, QWORD PTR [r13+80]
  0110f	48 8d 54 10 f8	 lea	 rdx, QWORD PTR [rax+rdx-8]
  01114	e8 00 00 00 00	 call	 memcpy
  01119	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0111d	48 c7 c0 f8 ff
	ff ff		 mov	 rax, -8
  01124	48 c1 e1 03	 shl	 rcx, 3
  01128	48 2b c1	 sub	 rax, rcx
  0112b	49 01 85 a0 06
	00 00		 add	 QWORD PTR [r13+1696], rax
$LN262@sre_umatch:

; 1224 :                 LASTMARK_RESTORE();

  01132	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  01136	49 89 45 48	 mov	 QWORD PTR [r13+72], rax
  0113a	48 8b 47 30	 mov	 rax, QWORD PTR [rdi+48]
  0113e	49 89 45 40	 mov	 QWORD PTR [r13+64], rax

; 1225 :                 ctx->u.rep->count = ctx->count-1;

  01142	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  01146	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  0114a	48 ff c9	 dec	 rcx
  0114d	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1226 :                 state->ptr = ctx->ptr;

  01150	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  01154	49 89 45 00	 mov	 QWORD PTR [r13], rax
$LN328@sre_umatch:

; 1227 :             }
; 1228 : 
; 1229 :             /* cannot match more repeated items here.  make sure the
; 1230 :                tail matches */
; 1231 :             state->repeat = ctx->u.rep->prev;

  01158	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1232 :             DO_JUMP(JUMP_MAX_UNTIL_3, jump_max_until_3, ctx->pattern);

  0115c	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  01163	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  01167	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  0116e	48 2b c3	 sub	 rax, rbx
  01171	49 89 8d f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rcx
  01178	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  0117c	73 26		 jae	 SHORT $LN249@sre_umatch
  0117e	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01183	49 8b cd	 mov	 rcx, r13
  01186	e8 00 00 00 00	 call	 data_stack_grow
  0118b	85 c0		 test	 eax, eax
  0118d	0f 88 85 03 00
	00		 js	 $LN855@sre_umatch
  01193	49 83 fe ff	 cmp	 r14, -1
  01197	74 0b		 je	 SHORT $LN249@sre_umatch
  01199	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  011a0	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN249@sre_umatch:
  011a4	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  011ab	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  011b3	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  011b8	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  011bc	4c 89 31	 mov	 QWORD PTR [rcx], r14
  011bf	48 c7 41 08 03
	00 00 00	 mov	 QWORD PTR [rcx+8], 3
  011c7	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  011cb	48 8b f9	 mov	 rdi, rcx
  011ce	4c 8b f3	 mov	 r14, rbx
  011d1	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  011d5	e9 c6 ee ff ff	 jmp	 $entrance$22309
$LN360@sre_umatch:

; 1169 :             }
; 1170 :             RETURN_FAILURE;
; 1171 : 
; 1172 :         case SRE_OP_MAX_UNTIL:
; 1173 :             /* maximizing repeat */
; 1174 :             /* <REPEAT> <skip> <1=min> <2=max> item <MAX_UNTIL> tail */
; 1175 : 
; 1176 :             /* FIXME: we probably need to deal with zero-width
; 1177 :                matches in here... */
; 1178 : 
; 1179 :             ctx->u.rep = state->repeat;

  011da	49 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [r13+1784]
  011e1	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1180 :             if (!ctx->u.rep)

  011e5	48 85 c0	 test	 rax, rax
  011e8	0f 84 2e 03 00
	00		 je	 $LN853@sre_umatch

; 1181 :                 RETURN_ERROR(SRE_ERROR_STATE);
; 1182 : 
; 1183 :             state->ptr = ctx->ptr;

  011ee	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  011f2	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1184 : 
; 1185 :             ctx->count = ctx->u.rep->count+1;

  011f6	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  011fa	4c 8b 00	 mov	 r8, QWORD PTR [rax]

; 1186 : 
; 1187 :             TRACE(("|%p|%p|MAX_UNTIL %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1188 :                    ctx->ptr, ctx->count));
; 1189 : 
; 1190 :             if (ctx->count < (Py_ssize_t) ctx->u.rep->pattern[1]) {

  011fd	48 8b d0	 mov	 rdx, rax
  01200	49 ff c0	 inc	 r8
  01203	4c 89 47 20	 mov	 QWORD PTR [rdi+32], r8
  01207	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0120b	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  0120e	4c 3b c1	 cmp	 r8, rcx
  01211	7d 61		 jge	 SHORT $LN329@sre_umatch

; 1191 :                 /* not enough matches */
; 1192 :                 ctx->u.rep->count = ctx->count;

  01213	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1193 :                 DO_JUMP(JUMP_MAX_UNTIL_1, jump_max_until_1,
; 1194 :                         ctx->u.rep->pattern+3);

  01216	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  0121d	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  01224	48 2b c3	 sub	 rax, rbx
  01227	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  0122b	73 26		 jae	 SHORT $LN345@sre_umatch
  0122d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01232	49 8b cd	 mov	 rcx, r13
  01235	e8 00 00 00 00	 call	 data_stack_grow
  0123a	85 c0		 test	 eax, eax
  0123c	0f 88 d6 02 00
	00		 js	 $LN855@sre_umatch
  01242	49 83 fe ff	 cmp	 r14, -1
  01246	74 0b		 je	 SHORT $LN345@sre_umatch
  01248	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0124f	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN345@sre_umatch:
  01253	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0125a	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  01262	48 c7 44 03 08
	01 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 1
  0126b	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  0126f	e9 11 f8 ff ff	 jmp	 $LN894@sre_umatch
$LN329@sre_umatch:

; 1195 :                 if (ret) {
; 1196 :                     RETURN_ON_ERROR(ret);
; 1197 :                     RETURN_SUCCESS;
; 1198 :                 }
; 1199 :                 ctx->u.rep->count = ctx->count-1;
; 1200 :                 state->ptr = ctx->ptr;
; 1201 :                 RETURN_FAILURE;
; 1202 :             }
; 1203 : 
; 1204 :             if ((ctx->count < (Py_ssize_t) ctx->u.rep->pattern[2] ||
; 1205 :                 ctx->u.rep->pattern[2] == SRE_MAXREPEAT) &&
; 1206 :                 state->ptr != ctx->u.rep->last_ptr) {

  01274	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  01277	4c 3b c1	 cmp	 r8, rcx
  0127a	7c 09		 jl	 SHORT $LN327@sre_umatch
  0127c	83 f9 ff	 cmp	 ecx, -1			; ffffffffH
  0127f	0f 85 d3 fe ff
	ff		 jne	 $LN328@sre_umatch
$LN327@sre_umatch:
  01285	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  01289	49 39 45 00	 cmp	 QWORD PTR [r13], rax
  0128d	0f 84 c5 fe ff
	ff		 je	 $LN328@sre_umatch

; 1207 :                 /* we may have enough matches, but if we can
; 1208 :                    match another item, do so */
; 1209 :                 ctx->u.rep->count = ctx->count;

  01293	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1210 :                 LASTMARK_SAVE();

  01296	49 8b 5d 48	 mov	 rbx, QWORD PTR [r13+72]
  0129a	48 89 5f 28	 mov	 QWORD PTR [rdi+40], rbx
  0129e	49 8b 45 40	 mov	 rax, QWORD PTR [r13+64]
  012a2	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1211 :                 MARK_PUSH(ctx->lastmark);

  012a6	48 85 db	 test	 rbx, rbx
  012a9	7e 6f		 jle	 SHORT $LN317@sre_umatch
  012ab	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  012b2	48 8d 34 dd 08
	00 00 00	 lea	 rsi, QWORD PTR [rbx*8+8]
  012ba	49 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [r13+1696]
  012c1	48 3b f0	 cmp	 rsi, rax
  012c4	76 24		 jbe	 SHORT $LN311@sre_umatch
  012c6	48 8b d6	 mov	 rdx, rsi
  012c9	49 8b cd	 mov	 rcx, r13
  012cc	e8 00 00 00 00	 call	 data_stack_grow
  012d1	85 c0		 test	 eax, eax
  012d3	0f 88 3f 02 00
	00		 js	 $LN855@sre_umatch
  012d9	49 83 fe ff	 cmp	 r14, -1
  012dd	74 0b		 je	 SHORT $LN311@sre_umatch
  012df	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  012e6	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN311@sre_umatch:
  012ea	49 8b 8d 90 06
	00 00		 mov	 rcx, QWORD PTR [r13+1680]
  012f1	49 8d 55 50	 lea	 rdx, QWORD PTR [r13+80]
  012f5	4c 8b c6	 mov	 r8, rsi
  012f8	49 03 8d a0 06
	00 00		 add	 rcx, QWORD PTR [r13+1696]
  012ff	e8 00 00 00 00	 call	 memcpy
  01304	4c 8d 1c dd 08
	00 00 00	 lea	 r11, QWORD PTR [rbx*8+8]
  0130c	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:__ImageBase
  01313	4d 01 9d a0 06
	00 00		 add	 QWORD PTR [r13+1696], r11
$LN317@sre_umatch:

; 1212 :                 /* zero-width match protection */
; 1213 :                 DATA_PUSH(&ctx->u.rep->last_ptr);

  0131a	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  01321	49 2b 85 a0 06
	00 00		 sub	 rax, QWORD PTR [r13+1696]
  01328	48 83 f8 08	 cmp	 rax, 8
  0132c	73 26		 jae	 SHORT $LN302@sre_umatch
  0132e	ba 08 00 00 00	 mov	 edx, 8
  01333	49 8b cd	 mov	 rcx, r13
  01336	e8 00 00 00 00	 call	 data_stack_grow
  0133b	85 c0		 test	 eax, eax
  0133d	0f 88 d5 01 00
	00		 js	 $LN855@sre_umatch
  01343	49 83 fe ff	 cmp	 r14, -1
  01347	74 0b		 je	 SHORT $LN302@sre_umatch
  01349	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01350	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN302@sre_umatch:
  01354	49 8b 8d a0 06
	00 00		 mov	 rcx, QWORD PTR [r13+1696]
  0135b	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  0135f	41 b8 08 00 00
	00		 mov	 r8d, 8
  01365	49 03 8d 90 06
	00 00		 add	 rcx, QWORD PTR [r13+1680]
  0136c	48 83 c2 10	 add	 rdx, 16
  01370	e8 00 00 00 00	 call	 memcpy
  01375	49 83 85 a0 06
	00 00 08	 add	 QWORD PTR [r13+1696], 8

; 1214 :                 ctx->u.rep->last_ptr = state->ptr;

  0137d	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  01381	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  01385	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1215 :                 DO_JUMP(JUMP_MAX_UNTIL_2, jump_max_until_2,
; 1216 :                         ctx->u.rep->pattern+3);

  01389	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  01390	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  01397	48 2b c3	 sub	 rax, rbx
  0139a	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  0139e	73 26		 jae	 SHORT $LN293@sre_umatch
  013a0	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  013a5	49 8b cd	 mov	 rcx, r13
  013a8	e8 00 00 00 00	 call	 data_stack_grow
  013ad	85 c0		 test	 eax, eax
  013af	0f 88 63 01 00
	00		 js	 $LN855@sre_umatch
  013b5	49 83 fe ff	 cmp	 r14, -1
  013b9	74 0b		 je	 SHORT $LN293@sre_umatch
  013bb	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  013c2	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN293@sre_umatch:
  013c6	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  013cd	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  013d5	48 c7 44 03 08
	02 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 2
  013de	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  013e2	e9 9e f6 ff ff	 jmp	 $LN894@sre_umatch
$LN230@sre_umatch:

; 1237 : 
; 1238 :         case SRE_OP_MIN_UNTIL:
; 1239 :             /* minimizing repeat */
; 1240 :             /* <REPEAT> <skip> <1=min> <2=max> item <MIN_UNTIL> tail */
; 1241 : 
; 1242 :             ctx->u.rep = state->repeat;

  013e7	49 8b 85 f8 06
	00 00		 mov	 rax, QWORD PTR [r13+1784]
  013ee	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax

; 1243 :             if (!ctx->u.rep)

  013f2	48 85 c0	 test	 rax, rax
  013f5	0f 84 21 01 00
	00		 je	 $LN853@sre_umatch

; 1245 : 
; 1246 :             state->ptr = ctx->ptr;

  013fb	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]
  013ff	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 1247 : 
; 1248 :             ctx->count = ctx->u.rep->count+1;

  01403	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  01407	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 1249 : 
; 1250 :             TRACE(("|%p|%p|MIN_UNTIL %" PY_FORMAT_SIZE_T "d %p\n", ctx->pattern,
; 1251 :                    ctx->ptr, ctx->count, ctx->u.rep->pattern));
; 1252 : 
; 1253 :             if (ctx->count < (Py_ssize_t) ctx->u.rep->pattern[1]) {

  0140a	4c 8b c0	 mov	 r8, rax
  0140d	48 ff c2	 inc	 rdx
  01410	48 89 57 20	 mov	 QWORD PTR [rdi+32], rdx
  01414	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01418	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  0141b	48 3b d1	 cmp	 rdx, rcx
  0141e	7d 61		 jge	 SHORT $LN199@sre_umatch

; 1254 :                 /* not enough matches */
; 1255 :                 ctx->u.rep->count = ctx->count;

  01420	49 89 10	 mov	 QWORD PTR [r8], rdx

; 1256 :                 DO_JUMP(JUMP_MIN_UNTIL_1, jump_min_until_1,
; 1257 :                         ctx->u.rep->pattern+3);

  01423	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  0142a	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  01431	48 2b c3	 sub	 rax, rbx
  01434	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  01438	73 26		 jae	 SHORT $LN215@sre_umatch
  0143a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0143f	49 8b cd	 mov	 rcx, r13
  01442	e8 00 00 00 00	 call	 data_stack_grow
  01447	85 c0		 test	 eax, eax
  01449	0f 88 c9 00 00
	00		 js	 $LN855@sre_umatch
  0144f	49 83 fe ff	 cmp	 r14, -1
  01453	74 0b		 je	 SHORT $LN215@sre_umatch
  01455	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  0145c	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN215@sre_umatch:
  01460	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  01467	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H
  0146f	48 c7 44 03 08
	04 00 00 00	 mov	 QWORD PTR [rbx+rax+8], 4
  01478	48 8d 14 03	 lea	 rdx, QWORD PTR [rbx+rax]
  0147c	e9 04 f6 ff ff	 jmp	 $LN894@sre_umatch
$LN199@sre_umatch:

; 1261 :                 }
; 1262 :                 ctx->u.rep->count = ctx->count-1;
; 1263 :                 state->ptr = ctx->ptr;
; 1264 :                 RETURN_FAILURE;
; 1265 :             }
; 1266 : 
; 1267 :             LASTMARK_SAVE();

  01481	49 8b 45 48	 mov	 rax, QWORD PTR [r13+72]
  01485	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
  01489	49 8b 45 40	 mov	 rax, QWORD PTR [r13+64]
  0148d	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 1268 : 
; 1269 :             /* see if the tail matches */
; 1270 :             state->repeat = ctx->u.rep->prev;

  01491	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]

; 1271 :             DO_JUMP(JUMP_MIN_UNTIL_2, jump_min_until_2, ctx->pattern);

  01495	49 8b 9d a0 06
	00 00		 mov	 rbx, QWORD PTR [r13+1696]
  0149c	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  014a0	49 8b 85 98 06
	00 00		 mov	 rax, QWORD PTR [r13+1688]
  014a7	48 2b c3	 sub	 rax, rbx
  014aa	49 89 8d f8 06
	00 00		 mov	 QWORD PTR [r13+1784], rcx
  014b1	48 83 f8 40	 cmp	 rax, 64			; 00000040H
  014b5	73 22		 jae	 SHORT $LN187@sre_umatch
  014b7	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  014bc	49 8b cd	 mov	 rcx, r13
  014bf	e8 00 00 00 00	 call	 data_stack_grow
  014c4	85 c0		 test	 eax, eax
  014c6	78 50		 js	 SHORT $LN855@sre_umatch
  014c8	49 83 fe ff	 cmp	 r14, -1
  014cc	74 0b		 je	 SHORT $LN187@sre_umatch
  014ce	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  014d5	49 8d 3c 06	 lea	 rdi, QWORD PTR [r14+rax]
$LN187@sre_umatch:
  014d9	49 8b 85 90 06
	00 00		 mov	 rax, QWORD PTR [r13+1680]
  014e0	49 83 85 a0 06
	00 00 40	 add	 QWORD PTR [r13+1696], 64 ; 00000040H

; 1397 :                 DO_JUMP(JUMP_ASSERT_NOT, jump_assert_not, ctx->pattern+2);

  014e8	44 8b 54 24 50	 mov	 r10d, DWORD PTR sigcount$1$[rsp]
  014ed	48 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+rax]
  014f1	4c 89 31	 mov	 QWORD PTR [rcx], r14
  014f4	48 c7 41 08 05
	00 00 00	 mov	 QWORD PTR [rcx+8], 5
  014fc	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  01500	48 8b f9	 mov	 rdi, rcx
  01503	4c 8b f3	 mov	 r14, rbx
  01506	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  0150a	e9 91 eb ff ff	 jmp	 $entrance$22309
$LN841@sre_umatch:

; 820  :             RETURN_ERROR(SRE_ERROR_INTERRUPTED);

  0150f	48 c7 c0 f6 ff
	ff ff		 mov	 rax, -10
  01516	eb 11		 jmp	 SHORT $LN879@sre_umatch
$LN855@sre_umatch:

; 1271 :             DO_JUMP(JUMP_MIN_UNTIL_2, jump_min_until_2, ctx->pattern);

  01518	48 98		 cdqe
  0151a	eb 0d		 jmp	 SHORT $LN879@sre_umatch
$LN853@sre_umatch:

; 1244 :                 RETURN_ERROR(SRE_ERROR_STATE);

  0151c	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2
  01523	eb 04		 jmp	 SHORT $LN879@sre_umatch
$LN28@sre_umatch:

; 1410 : 
; 1411 :         default:
; 1412 :             TRACE(("|%p|%p|UNKNOWN %d\n", ctx->pattern, ctx->ptr,
; 1413 :                    ctx->pattern[-1]));
; 1414 :             RETURN_ERROR(SRE_ERROR_ILLEGAL);

  01525	48 83 c8 ff	 or	 rax, -1
$LN879@sre_umatch:
  01529	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  0152e	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  01533	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  01538	4c 8b 64 24 20	 mov	 r12, QWORD PTR [rsp+32]

; 1427 :         case JUMP_MAX_UNTIL_2:
; 1428 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1429 :             goto jump_max_until_2;
; 1430 :         case JUMP_MAX_UNTIL_3:
; 1431 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1432 :             goto jump_max_until_3;
; 1433 :         case JUMP_MIN_UNTIL_2:
; 1434 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_2\n", ctx->pattern, ctx->ptr));
; 1435 :             goto jump_min_until_2;
; 1436 :         case JUMP_MIN_UNTIL_3:
; 1437 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_3\n", ctx->pattern, ctx->ptr));
; 1438 :             goto jump_min_until_3;
; 1439 :         case JUMP_BRANCH:
; 1440 :             TRACE(("|%p|%p|JUMP_BRANCH\n", ctx->pattern, ctx->ptr));
; 1441 :             goto jump_branch;
; 1442 :         case JUMP_MAX_UNTIL_1:
; 1443 :             TRACE(("|%p|%p|JUMP_MAX_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1444 :             goto jump_max_until_1;
; 1445 :         case JUMP_MIN_UNTIL_1:
; 1446 :             TRACE(("|%p|%p|JUMP_MIN_UNTIL_1\n", ctx->pattern, ctx->ptr));
; 1447 :             goto jump_min_until_1;
; 1448 :         case JUMP_REPEAT:
; 1449 :             TRACE(("|%p|%p|JUMP_REPEAT\n", ctx->pattern, ctx->ptr));
; 1450 :             goto jump_repeat;
; 1451 :         case JUMP_REPEAT_ONE_1:
; 1452 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_1\n", ctx->pattern, ctx->ptr));
; 1453 :             goto jump_repeat_one_1;
; 1454 :         case JUMP_REPEAT_ONE_2:
; 1455 :             TRACE(("|%p|%p|JUMP_REPEAT_ONE_2\n", ctx->pattern, ctx->ptr));
; 1456 :             goto jump_repeat_one_2;
; 1457 :         case JUMP_MIN_REPEAT_ONE:
; 1458 :             TRACE(("|%p|%p|JUMP_MIN_REPEAT_ONE\n", ctx->pattern, ctx->ptr));
; 1459 :             goto jump_min_repeat_one;
; 1460 :         case JUMP_ASSERT:
; 1461 :             TRACE(("|%p|%p|JUMP_ASSERT\n", ctx->pattern, ctx->ptr));
; 1462 :             goto jump_assert;
; 1463 :         case JUMP_ASSERT_NOT:
; 1464 :             TRACE(("|%p|%p|JUMP_ASSERT_NOT\n", ctx->pattern, ctx->ptr));
; 1465 :             goto jump_assert_not;
; 1466 :         case JUMP_NONE:
; 1467 :             TRACE(("|%p|%p|RETURN %" PY_FORMAT_SIZE_T "d\n", ctx->pattern,
; 1468 :                    ctx->ptr, ret));
; 1469 :             break;
; 1470 :     }
; 1471 : 
; 1472 :     return ret; /* should never get here */
; 1473 : }

  0153d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  01541	41 5f		 pop	 r15
  01543	41 5e		 pop	 r14
  01545	41 5d		 pop	 r13
  01547	5b		 pop	 rbx
  01548	c3		 ret	 0
  01549	0f 1f 00	 npad	 3
$LN871@sre_umatch:
  0154c	00 00 00 00	 DD	 $LN30@sre_umatch
  01550	00 00 00 00	 DD	 $LN678@sre_umatch
  01554	00 00 00 00	 DD	 $LN663@sre_umatch
  01558	00 00 00 00	 DD	 $LN657@sre_umatch
  0155c	00 00 00 00	 DD	 $LN85@sre_umatch
  01560	00 00 00 00	 DD	 $LN55@sre_umatch
  01564	00 00 00 00	 DD	 $LN675@sre_umatch
  01568	00 00 00 00	 DD	 $LN626@sre_umatch
  0156c	00 00 00 00	 DD	 $LN28@sre_umatch
  01570	00 00 00 00	 DD	 $LN669@sre_umatch
  01574	00 00 00 00	 DD	 $LN28@sre_umatch
  01578	00 00 00 00	 DD	 $LN28@sre_umatch
  0157c	00 00 00 00	 DD	 $LN127@sre_umatch
  01580	00 00 00 00	 DD	 $LN90@sre_umatch
  01584	00 00 00 00	 DD	 $LN108@sre_umatch
  01588	00 00 00 00	 DD	 $LN652@sre_umatch
  0158c	00 00 00 00	 DD	 $LN634@sre_umatch
  01590	00 00 00 00	 DD	 $LN628@sre_umatch
  01594	00 00 00 00	 DD	 $LN628@sre_umatch
  01598	00 00 00 00	 DD	 $LN690@sre_umatch
  0159c	00 00 00 00	 DD	 $LN646@sre_umatch
  015a0	00 00 00 00	 DD	 $LN695@sre_umatch
  015a4	00 00 00 00	 DD	 $LN360@sre_umatch
  015a8	00 00 00 00	 DD	 $LN230@sre_umatch
  015ac	00 00 00 00	 DD	 $LN684@sre_umatch
  015b0	00 00 00 00	 DD	 $LN640@sre_umatch
  015b4	00 00 00 00	 DD	 $LN28@sre_umatch
  015b8	00 00 00 00	 DD	 $LN28@sre_umatch
  015bc	00 00 00 00	 DD	 $LN390@sre_umatch
  015c0	00 00 00 00	 DD	 $LN550@sre_umatch
  015c4	00 00 00 00	 DD	 $LN28@sre_umatch
  015c8	00 00 00 00	 DD	 $LN461@sre_umatch
$LN870@sre_umatch:
  015cc	00 00 00 00	 DD	 $jump_min_until_1$22970
  015d0	00 00 00 00	 DD	 $jump_max_until_2$22871
  015d4	00 00 00 00	 DD	 $jump_max_until_3$22927
  015d8	00 00 00 00	 DD	 $jump_min_until_1$22970
  015dc	00 00 00 00	 DD	 $jump_min_until_2$23006
  015e0	00 00 00 00	 DD	 $jump_min_until_3$23058
  015e4	00 00 00 00	 DD	 $jump_repeat$22761
  015e8	00 00 00 00	 DD	 $jump_repeat_one_1$22592
  015ec	00 00 00 00	 DD	 $jump_repeat_one_2$22630
  015f0	00 00 00 00	 DD	 $jump_min_repeat_one$22705
  015f4	00 00 00 00	 DD	 $jump_branch$22483
  015f8	00 00 00 00	 DD	 $jump_assert$23170
  015fc	00 00 00 00	 DD	 $jump_assert_not$23205
sre_umatch ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_uat DD imagerel sre_uat
	DD	imagerel sre_uat+2396
	DD	imagerel $unwind$sre_uat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_uat DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT sre_uat
_TEXT	SEGMENT
state$ = 48
ptr$ = 56
at$ = 64
sre_uat	PROC						; COMDAT

; 308  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	48 8b da	 mov	 rbx, rdx
  0001d	48 8b f1	 mov	 rsi, rcx

; 309  :     /* check if pointer is at given position */
; 310  : 
; 311  :     Py_ssize_t thisp, thatp;
; 312  : 
; 313  :     switch (at) {

  00020	41 83 f8 0b	 cmp	 r8d, 11
  00024	0f 87 e5 08 00
	00		 ja	 $LN18@sre_uat
  0002a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:__ImageBase
  00031	41 8b c0	 mov	 eax, r8d
  00034	41 8b 84 81 00
	00 00 00	 mov	 eax, DWORD PTR $LN281@sre_uat[r9+rax*4]
  0003c	49 03 c1	 add	 rax, r9
  0003f	ff e0		 jmp	 rax
$LN17@sre_uat:

; 314  : 
; 315  :     case SRE_AT_BEGINNING:
; 316  :     case SRE_AT_BEGINNING_STRING:
; 317  :         return ((void*) ptr == state->beginning);

  00041	33 ff		 xor	 edi, edi
  00043	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00047	40 0f 94 c7	 sete	 dil
  0004b	8b c7		 mov	 eax, edi
  0004d	e9 bf 08 00 00	 jmp	 $LN20@sre_uat
$LN16@sre_uat:

; 318  : 
; 319  :     case SRE_AT_BEGINNING_LINE:
; 320  :         return ((void*) ptr == state->beginning ||
; 321  :                 SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, -1)));

  00052	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00056	74 51		 je	 SHORT $LN32@sre_uat
  00058	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  0005b	83 f8 01	 cmp	 eax, 1
  0005e	75 06		 jne	 SHORT $LN24@sre_uat
  00060	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00064	eb 0e		 jmp	 SHORT $LN23@sre_uat
$LN24@sre_uat:
  00066	83 f8 02	 cmp	 eax, 2
  00069	75 06		 jne	 SHORT $LN22@sre_uat
  0006b	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  0006f	eb 03		 jmp	 SHORT $LN23@sre_uat
$LN22@sre_uat:
  00071	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN23@sre_uat:
  00074	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0007a	0f 8d 8e 00 00
	00		 jge	 $LN275@sre_uat
  00080	83 f8 01	 cmp	 eax, 1
  00083	75 06		 jne	 SHORT $LN28@sre_uat
  00085	0f b6 42 ff	 movzx	 eax, BYTE PTR [rdx-1]
  00089	eb 0e		 jmp	 SHORT $LN27@sre_uat
$LN28@sre_uat:
  0008b	83 f8 02	 cmp	 eax, 2
  0008e	75 06		 jne	 SHORT $LN26@sre_uat
  00090	0f b7 42 fe	 movzx	 eax, WORD PTR [rdx-2]
  00094	eb 03		 jmp	 SHORT $LN27@sre_uat
$LN26@sre_uat:
  00096	8b 42 fc	 mov	 eax, DWORD PTR [rdx-4]
$LN27@sre_uat:
  00099	48 98		 cdqe
  0009b	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  000a4	83 e1 04	 and	 ecx, 4
  000a7	74 65		 je	 SHORT $LN275@sre_uat
$LN32@sre_uat:
  000a9	bf 01 00 00 00	 mov	 edi, 1
  000ae	8b c7		 mov	 eax, edi
  000b0	e9 5c 08 00 00	 jmp	 $LN20@sre_uat
$LN15@sre_uat:

; 322  : 
; 323  :     case SRE_AT_END:
; 324  :         return (((void*) (ptr+state->charsize) == state->end &&
; 325  :                  SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, 0))) ||
; 326  :                 ((void*) ptr == state->end));

  000b5	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  000b9	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]
  000bd	48 8d 04 0b	 lea	 rax, QWORD PTR [rbx+rcx]
  000c1	48 3b c2	 cmp	 rax, rdx
  000c4	75 43		 jne	 SHORT $LN44@sre_uat
  000c6	83 f9 01	 cmp	 ecx, 1
  000c9	75 05		 jne	 SHORT $LN36@sre_uat
  000cb	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000ce	eb 0c		 jmp	 SHORT $LN35@sre_uat
$LN36@sre_uat:
  000d0	83 f9 02	 cmp	 ecx, 2
  000d3	75 05		 jne	 SHORT $LN34@sre_uat
  000d5	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  000d8	eb 02		 jmp	 SHORT $LN35@sre_uat
$LN34@sre_uat:
  000da	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN35@sre_uat:
  000dc	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000e1	7d 26		 jge	 SHORT $LN44@sre_uat
  000e3	83 f9 01	 cmp	 ecx, 1
  000e6	75 05		 jne	 SHORT $LN40@sre_uat
  000e8	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000eb	eb 0c		 jmp	 SHORT $LN39@sre_uat
$LN40@sre_uat:
  000ed	83 f9 02	 cmp	 ecx, 2
  000f0	75 05		 jne	 SHORT $LN38@sre_uat
  000f2	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  000f5	eb 02		 jmp	 SHORT $LN39@sre_uat
$LN38@sre_uat:
  000f7	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN39@sre_uat:
  000f9	48 98		 cdqe
  000fb	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00104	83 e1 04	 and	 ecx, 4
  00107	75 a0		 jne	 SHORT $LN32@sre_uat
$LN44@sre_uat:
  00109	48 3b da	 cmp	 rbx, rdx
  0010c	74 9b		 je	 SHORT $LN32@sre_uat
$LN275@sre_uat:
  0010e	33 ff		 xor	 edi, edi
  00110	8b c7		 mov	 eax, edi
  00112	e9 fa 07 00 00	 jmp	 $LN20@sre_uat
$LN14@sre_uat:

; 327  : 
; 328  :     case SRE_AT_END_LINE:
; 329  :         return ((void*) ptr == state->end ||
; 330  :                 SRE_IS_LINEBREAK((int) SRE_CHARGET(state, ptr, 0)));

  00117	48 3b 51 18	 cmp	 rdx, QWORD PTR [rcx+24]
  0011b	74 8c		 je	 SHORT $LN32@sre_uat
  0011d	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  00120	83 f8 01	 cmp	 eax, 1
  00123	75 05		 jne	 SHORT $LN49@sre_uat
  00125	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  00128	eb 0c		 jmp	 SHORT $LN48@sre_uat
$LN49@sre_uat:
  0012a	83 f8 02	 cmp	 eax, 2
  0012d	75 05		 jne	 SHORT $LN47@sre_uat
  0012f	0f b7 0a	 movzx	 ecx, WORD PTR [rdx]
  00132	eb 02		 jmp	 SHORT $LN48@sre_uat
$LN47@sre_uat:
  00134	8b 0a		 mov	 ecx, DWORD PTR [rdx]
$LN48@sre_uat:
  00136	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  0013c	7d 2a		 jge	 SHORT $LN276@sre_uat
  0013e	83 f8 01	 cmp	 eax, 1
  00141	75 05		 jne	 SHORT $LN53@sre_uat
  00143	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00146	eb 0c		 jmp	 SHORT $LN52@sre_uat
$LN53@sre_uat:
  00148	83 f8 02	 cmp	 eax, 2
  0014b	75 05		 jne	 SHORT $LN51@sre_uat
  0014d	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00150	eb 02		 jmp	 SHORT $LN52@sre_uat
$LN51@sre_uat:
  00152	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN52@sre_uat:
  00154	48 98		 cdqe
  00156	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0015f	83 e1 04	 and	 ecx, 4
  00162	0f 85 41 ff ff
	ff		 jne	 $LN32@sre_uat
$LN276@sre_uat:
  00168	33 ff		 xor	 edi, edi
  0016a	8b c7		 mov	 eax, edi
  0016c	e9 a0 07 00 00	 jmp	 $LN20@sre_uat
$LN13@sre_uat:

; 331  : 
; 332  :     case SRE_AT_END_STRING:
; 333  :         return ((void*) ptr == state->end);

  00171	33 ff		 xor	 edi, edi
  00173	48 3b 51 18	 cmp	 rdx, QWORD PTR [rcx+24]
  00177	40 0f 94 c7	 sete	 dil
  0017b	8b c7		 mov	 eax, edi
  0017d	e9 8f 07 00 00	 jmp	 $LN20@sre_uat
$LN12@sre_uat:

; 334  : 
; 335  :     case SRE_AT_BOUNDARY:
; 336  :         if (state->beginning == state->end)

  00182	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00186	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  0018a	48 3b c2	 cmp	 rax, rdx

; 337  :             return 0;

  0018d	0f 84 7c 07 00
	00		 je	 $LN18@sre_uat

; 338  :         thatp = ((void*) ptr > state->beginning) ?
; 339  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  00193	33 ff		 xor	 edi, edi
  00195	48 3b d8	 cmp	 rbx, rax
  00198	76 69		 jbe	 SHORT $LN69@sre_uat
  0019a	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  0019d	83 f8 01	 cmp	 eax, 1
  001a0	75 06		 jne	 SHORT $LN61@sre_uat
  001a2	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  001a6	eb 0e		 jmp	 SHORT $LN60@sre_uat
$LN61@sre_uat:
  001a8	83 f8 02	 cmp	 eax, 2
  001ab	75 06		 jne	 SHORT $LN59@sre_uat
  001ad	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  001b1	eb 03		 jmp	 SHORT $LN60@sre_uat
$LN59@sre_uat:
  001b3	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN60@sre_uat:
  001b6	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  001bc	7d 45		 jge	 SHORT $LN69@sre_uat
  001be	83 f8 01	 cmp	 eax, 1
  001c1	75 14		 jne	 SHORT $LN65@sre_uat
  001c3	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  001c7	48 98		 cdqe
  001c9	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  001d2	83 e1 10	 and	 ecx, 16
  001d5	eb 2e		 jmp	 SHORT $LN70@sre_uat
$LN65@sre_uat:
  001d7	83 f8 02	 cmp	 eax, 2
  001da	75 14		 jne	 SHORT $LN63@sre_uat
  001dc	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  001e0	48 98		 cdqe
  001e2	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  001eb	83 e1 10	 and	 ecx, 16
  001ee	eb 15		 jmp	 SHORT $LN70@sre_uat
$LN63@sre_uat:
  001f0	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
  001f3	48 98		 cdqe
  001f5	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  001fe	83 e1 10	 and	 ecx, 16
  00201	eb 02		 jmp	 SHORT $LN70@sre_uat
$LN69@sre_uat:
  00203	8b cf		 mov	 ecx, edi
$LN70@sre_uat:
  00205	4c 63 c1	 movsxd	 r8, ecx

; 340  :         thisp = ((void*) ptr < state->end) ?
; 341  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00208	48 3b da	 cmp	 rbx, rdx
  0020b	0f 83 90 00 00
	00		 jae	 $LN81@sre_uat
  00211	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00214	83 f8 01	 cmp	 eax, 1
  00217	75 05		 jne	 SHORT $LN73@sre_uat
  00219	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0021c	eb 0c		 jmp	 SHORT $LN72@sre_uat
$LN73@sre_uat:
  0021e	83 f8 02	 cmp	 eax, 2
  00221	75 05		 jne	 SHORT $LN71@sre_uat
  00223	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00226	eb 02		 jmp	 SHORT $LN72@sre_uat
$LN71@sre_uat:
  00228	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN72@sre_uat:
  0022a	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00230	7d 6f		 jge	 SHORT $LN81@sre_uat
  00232	83 f8 01	 cmp	 eax, 1
  00235	75 22		 jne	 SHORT $LN77@sre_uat
  00237	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0023a	48 98		 cdqe
  0023c	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00245	83 e1 10	 and	 ecx, 16

; 342  :         return thisp != thatp;

  00248	48 63 c1	 movsxd	 rax, ecx
  0024b	49 3b c0	 cmp	 rax, r8
  0024e	40 0f 95 c7	 setne	 dil
  00252	8b c7		 mov	 eax, edi
  00254	e9 b8 06 00 00	 jmp	 $LN20@sre_uat
$LN77@sre_uat:

; 340  :         thisp = ((void*) ptr < state->end) ?
; 341  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00259	83 f8 02	 cmp	 eax, 2
  0025c	75 22		 jne	 SHORT $LN75@sre_uat
  0025e	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00261	48 98		 cdqe
  00263	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0026c	83 e1 10	 and	 ecx, 16

; 342  :         return thisp != thatp;

  0026f	48 63 c1	 movsxd	 rax, ecx
  00272	49 3b c0	 cmp	 rax, r8
  00275	40 0f 95 c7	 setne	 dil
  00279	8b c7		 mov	 eax, edi
  0027b	e9 91 06 00 00	 jmp	 $LN20@sre_uat
$LN75@sre_uat:

; 340  :         thisp = ((void*) ptr < state->end) ?
; 341  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00280	8b 03		 mov	 eax, DWORD PTR [rbx]
  00282	48 98		 cdqe
  00284	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0028d	83 e1 10	 and	 ecx, 16

; 342  :         return thisp != thatp;

  00290	48 63 c1	 movsxd	 rax, ecx
  00293	49 3b c0	 cmp	 rax, r8
  00296	40 0f 95 c7	 setne	 dil
  0029a	8b c7		 mov	 eax, edi
  0029c	e9 70 06 00 00	 jmp	 $LN20@sre_uat
$LN81@sre_uat:

; 340  :         thisp = ((void*) ptr < state->end) ?
; 341  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  002a1	8b cf		 mov	 ecx, edi

; 342  :         return thisp != thatp;

  002a3	48 63 c1	 movsxd	 rax, ecx
  002a6	49 3b c0	 cmp	 rax, r8
  002a9	40 0f 95 c7	 setne	 dil
  002ad	8b c7		 mov	 eax, edi
  002af	e9 5d 06 00 00	 jmp	 $LN20@sre_uat
$LN10@sre_uat:

; 343  : 
; 344  :     case SRE_AT_NON_BOUNDARY:
; 345  :         if (state->beginning == state->end)

  002b4	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  002b8	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  002bc	48 3b c2	 cmp	 rax, rdx

; 346  :             return 0;

  002bf	0f 84 4a 06 00
	00		 je	 $LN18@sre_uat

; 347  :         thatp = ((void*) ptr > state->beginning) ?
; 348  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  002c5	33 ff		 xor	 edi, edi
  002c7	48 3b d8	 cmp	 rbx, rax
  002ca	76 69		 jbe	 SHORT $LN93@sre_uat
  002cc	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  002cf	83 f8 01	 cmp	 eax, 1
  002d2	75 06		 jne	 SHORT $LN85@sre_uat
  002d4	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  002d8	eb 0e		 jmp	 SHORT $LN84@sre_uat
$LN85@sre_uat:
  002da	83 f8 02	 cmp	 eax, 2
  002dd	75 06		 jne	 SHORT $LN83@sre_uat
  002df	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  002e3	eb 03		 jmp	 SHORT $LN84@sre_uat
$LN83@sre_uat:
  002e5	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN84@sre_uat:
  002e8	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  002ee	7d 45		 jge	 SHORT $LN93@sre_uat
  002f0	83 f8 01	 cmp	 eax, 1
  002f3	75 14		 jne	 SHORT $LN89@sre_uat
  002f5	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  002f9	48 98		 cdqe
  002fb	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00304	83 e1 10	 and	 ecx, 16
  00307	eb 2e		 jmp	 SHORT $LN94@sre_uat
$LN89@sre_uat:
  00309	83 f8 02	 cmp	 eax, 2
  0030c	75 14		 jne	 SHORT $LN87@sre_uat
  0030e	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  00312	48 98		 cdqe
  00314	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0031d	83 e1 10	 and	 ecx, 16
  00320	eb 15		 jmp	 SHORT $LN94@sre_uat
$LN87@sre_uat:
  00322	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
  00325	48 98		 cdqe
  00327	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00330	83 e1 10	 and	 ecx, 16
  00333	eb 02		 jmp	 SHORT $LN94@sre_uat
$LN93@sre_uat:
  00335	8b cf		 mov	 ecx, edi
$LN94@sre_uat:
  00337	4c 63 c1	 movsxd	 r8, ecx

; 349  :         thisp = ((void*) ptr < state->end) ?
; 350  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0033a	48 3b da	 cmp	 rbx, rdx
  0033d	0f 83 90 00 00
	00		 jae	 $LN105@sre_uat
  00343	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00346	83 f8 01	 cmp	 eax, 1
  00349	75 05		 jne	 SHORT $LN97@sre_uat
  0034b	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0034e	eb 0c		 jmp	 SHORT $LN96@sre_uat
$LN97@sre_uat:
  00350	83 f8 02	 cmp	 eax, 2
  00353	75 05		 jne	 SHORT $LN95@sre_uat
  00355	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00358	eb 02		 jmp	 SHORT $LN96@sre_uat
$LN95@sre_uat:
  0035a	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN96@sre_uat:
  0035c	81 f9 80 00 00
	00		 cmp	 ecx, 128		; 00000080H
  00362	7d 6f		 jge	 SHORT $LN105@sre_uat
  00364	83 f8 01	 cmp	 eax, 1
  00367	75 22		 jne	 SHORT $LN101@sre_uat
  00369	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0036c	48 98		 cdqe
  0036e	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  00377	83 e1 10	 and	 ecx, 16

; 351  :         return thisp == thatp;

  0037a	48 63 c1	 movsxd	 rax, ecx
  0037d	49 3b c0	 cmp	 rax, r8
  00380	40 0f 94 c7	 sete	 dil
  00384	8b c7		 mov	 eax, edi
  00386	e9 86 05 00 00	 jmp	 $LN20@sre_uat
$LN101@sre_uat:

; 349  :         thisp = ((void*) ptr < state->end) ?
; 350  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0038b	83 f8 02	 cmp	 eax, 2
  0038e	75 22		 jne	 SHORT $LN99@sre_uat
  00390	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00393	48 98		 cdqe
  00395	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  0039e	83 e1 10	 and	 ecx, 16

; 351  :         return thisp == thatp;

  003a1	48 63 c1	 movsxd	 rax, ecx
  003a4	49 3b c0	 cmp	 rax, r8
  003a7	40 0f 94 c7	 sete	 dil
  003ab	8b c7		 mov	 eax, edi
  003ad	e9 5f 05 00 00	 jmp	 $LN20@sre_uat
$LN99@sre_uat:

; 349  :         thisp = ((void*) ptr < state->end) ?
; 350  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  003b2	8b 03		 mov	 eax, DWORD PTR [rbx]
  003b4	48 98		 cdqe
  003b6	42 0f be 8c 08
	00 00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+r9]
  003bf	83 e1 10	 and	 ecx, 16

; 351  :         return thisp == thatp;

  003c2	48 63 c1	 movsxd	 rax, ecx
  003c5	49 3b c0	 cmp	 rax, r8
  003c8	40 0f 94 c7	 sete	 dil
  003cc	8b c7		 mov	 eax, edi
  003ce	e9 3e 05 00 00	 jmp	 $LN20@sre_uat
$LN105@sre_uat:

; 349  :         thisp = ((void*) ptr < state->end) ?
; 350  :             SRE_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  003d3	8b cf		 mov	 ecx, edi

; 351  :         return thisp == thatp;

  003d5	48 63 c1	 movsxd	 rax, ecx
  003d8	49 3b c0	 cmp	 rax, r8
  003db	40 0f 94 c7	 sete	 dil
  003df	8b c7		 mov	 eax, edi
  003e1	e9 2b 05 00 00	 jmp	 $LN20@sre_uat
$LN8@sre_uat:

; 352  : 
; 353  :     case SRE_AT_LOC_BOUNDARY:
; 354  :         if (state->beginning == state->end)

  003e6	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  003ea	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 355  :             return 0;

  003ee	0f 84 1b 05 00
	00		 je	 $LN18@sre_uat

; 356  :         thatp = ((void*) ptr > state->beginning) ?
; 357  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  003f4	33 ff		 xor	 edi, edi
  003f6	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  003f9	48 3b d0	 cmp	 rdx, rax
  003fc	76 69		 jbe	 SHORT $LN123@sre_uat
  003fe	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  00401	3b c5		 cmp	 eax, ebp
  00403	75 06		 jne	 SHORT $LN109@sre_uat
  00405	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00409	eb 0e		 jmp	 SHORT $LN108@sre_uat
$LN109@sre_uat:
  0040b	83 f8 02	 cmp	 eax, 2
  0040e	75 06		 jne	 SHORT $LN107@sre_uat
  00410	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  00414	eb 03		 jmp	 SHORT $LN108@sre_uat
$LN107@sre_uat:
  00416	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN108@sre_uat:
  00419	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  0041f	75 22		 jne	 SHORT $LN277@sre_uat
  00421	3b c5		 cmp	 eax, ebp
  00423	75 06		 jne	 SHORT $LN113@sre_uat
  00425	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00429	eb 0e		 jmp	 SHORT $LN112@sre_uat
$LN113@sre_uat:
  0042b	83 f8 02	 cmp	 eax, 2
  0042e	75 06		 jne	 SHORT $LN111@sre_uat
  00430	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  00434	eb 03		 jmp	 SHORT $LN112@sre_uat
$LN111@sre_uat:
  00436	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN112@sre_uat:
  00439	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  0043f	85 c0		 test	 eax, eax
  00441	75 20		 jne	 SHORT $LN121@sre_uat
$LN277@sre_uat:
  00443	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00446	3b c5		 cmp	 eax, ebp
  00448	75 06		 jne	 SHORT $LN119@sre_uat
  0044a	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  0044e	eb 0e		 jmp	 SHORT $LN118@sre_uat
$LN119@sre_uat:
  00450	83 f8 02	 cmp	 eax, 2
  00453	75 06		 jne	 SHORT $LN117@sre_uat
  00455	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  00459	eb 03		 jmp	 SHORT $LN118@sre_uat
$LN117@sre_uat:
  0045b	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
$LN118@sre_uat:
  0045e	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00461	75 04		 jne	 SHORT $LN123@sre_uat
$LN121@sre_uat:
  00463	8b c5		 mov	 eax, ebp
  00465	eb 02		 jmp	 SHORT $LN124@sre_uat
$LN123@sre_uat:
  00467	8b c7		 mov	 eax, edi
$LN124@sre_uat:
  00469	4c 63 e0	 movsxd	 r12, eax

; 358  :         thisp = ((void*) ptr < state->end) ?
; 359  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  0046c	48 3b 5e 18	 cmp	 rbx, QWORD PTR [rsi+24]
  00470	73 5c		 jae	 SHORT $LN141@sre_uat
  00472	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00475	3b c5		 cmp	 eax, ebp
  00477	75 05		 jne	 SHORT $LN127@sre_uat
  00479	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0047c	eb 0c		 jmp	 SHORT $LN126@sre_uat
$LN127@sre_uat:
  0047e	83 f8 02	 cmp	 eax, 2
  00481	75 05		 jne	 SHORT $LN125@sre_uat
  00483	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00486	eb 02		 jmp	 SHORT $LN126@sre_uat
$LN125@sre_uat:
  00488	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN126@sre_uat:
  0048a	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  00490	75 1f		 jne	 SHORT $LN278@sre_uat
  00492	3b c5		 cmp	 eax, ebp
  00494	75 05		 jne	 SHORT $LN131@sre_uat
  00496	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00499	eb 0c		 jmp	 SHORT $LN130@sre_uat
$LN131@sre_uat:
  0049b	83 f8 02	 cmp	 eax, 2
  0049e	75 05		 jne	 SHORT $LN129@sre_uat
  004a0	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  004a3	eb 02		 jmp	 SHORT $LN130@sre_uat
$LN129@sre_uat:
  004a5	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN130@sre_uat:
  004a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  004ad	85 c0		 test	 eax, eax
  004af	75 1f		 jne	 SHORT $LN142@sre_uat
$LN278@sre_uat:
  004b1	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  004b4	3b c5		 cmp	 eax, ebp
  004b6	75 05		 jne	 SHORT $LN137@sre_uat
  004b8	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  004bb	eb 0c		 jmp	 SHORT $LN136@sre_uat
$LN137@sre_uat:
  004bd	83 f8 02	 cmp	 eax, 2
  004c0	75 05		 jne	 SHORT $LN135@sre_uat
  004c2	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  004c5	eb 02		 jmp	 SHORT $LN136@sre_uat
$LN135@sre_uat:
  004c7	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN136@sre_uat:
  004c9	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  004cc	74 02		 je	 SHORT $LN142@sre_uat
$LN141@sre_uat:
  004ce	8b ef		 mov	 ebp, edi
$LN142@sre_uat:

; 360  :         return thisp != thatp;

  004d0	48 63 c5	 movsxd	 rax, ebp
  004d3	49 3b c4	 cmp	 rax, r12
  004d6	40 0f 95 c7	 setne	 dil
  004da	8b c7		 mov	 eax, edi
  004dc	e9 30 04 00 00	 jmp	 $LN20@sre_uat
$LN6@sre_uat:

; 361  : 
; 362  :     case SRE_AT_LOC_NON_BOUNDARY:
; 363  :         if (state->beginning == state->end)

  004e1	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  004e5	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 364  :             return 0;

  004e9	0f 84 20 04 00
	00		 je	 $LN18@sre_uat

; 365  :         thatp = ((void*) ptr > state->beginning) ?
; 366  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  004ef	33 ff		 xor	 edi, edi
  004f1	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  004f4	48 3b d0	 cmp	 rdx, rax
  004f7	76 69		 jbe	 SHORT $LN159@sre_uat
  004f9	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  004fc	3b c5		 cmp	 eax, ebp
  004fe	75 06		 jne	 SHORT $LN145@sre_uat
  00500	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00504	eb 0e		 jmp	 SHORT $LN144@sre_uat
$LN145@sre_uat:
  00506	83 f8 02	 cmp	 eax, 2
  00509	75 06		 jne	 SHORT $LN143@sre_uat
  0050b	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  0050f	eb 03		 jmp	 SHORT $LN144@sre_uat
$LN143@sre_uat:
  00511	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN144@sre_uat:
  00514	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  0051a	75 22		 jne	 SHORT $LN279@sre_uat
  0051c	3b c5		 cmp	 eax, ebp
  0051e	75 06		 jne	 SHORT $LN149@sre_uat
  00520	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00524	eb 0e		 jmp	 SHORT $LN148@sre_uat
$LN149@sre_uat:
  00526	83 f8 02	 cmp	 eax, 2
  00529	75 06		 jne	 SHORT $LN147@sre_uat
  0052b	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  0052f	eb 03		 jmp	 SHORT $LN148@sre_uat
$LN147@sre_uat:
  00531	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN148@sre_uat:
  00534	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  0053a	85 c0		 test	 eax, eax
  0053c	75 20		 jne	 SHORT $LN157@sre_uat
$LN279@sre_uat:
  0053e	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00541	3b c5		 cmp	 eax, ebp
  00543	75 06		 jne	 SHORT $LN155@sre_uat
  00545	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  00549	eb 0e		 jmp	 SHORT $LN154@sre_uat
$LN155@sre_uat:
  0054b	83 f8 02	 cmp	 eax, 2
  0054e	75 06		 jne	 SHORT $LN153@sre_uat
  00550	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  00554	eb 03		 jmp	 SHORT $LN154@sre_uat
$LN153@sre_uat:
  00556	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
$LN154@sre_uat:
  00559	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  0055c	75 04		 jne	 SHORT $LN159@sre_uat
$LN157@sre_uat:
  0055e	8b c5		 mov	 eax, ebp
  00560	eb 02		 jmp	 SHORT $LN160@sre_uat
$LN159@sre_uat:
  00562	8b c7		 mov	 eax, edi
$LN160@sre_uat:
  00564	4c 63 e0	 movsxd	 r12, eax

; 367  :         thisp = ((void*) ptr < state->end) ?
; 368  :             SRE_LOC_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00567	48 3b 5e 18	 cmp	 rbx, QWORD PTR [rsi+24]
  0056b	73 5c		 jae	 SHORT $LN177@sre_uat
  0056d	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00570	3b c5		 cmp	 eax, ebp
  00572	75 05		 jne	 SHORT $LN163@sre_uat
  00574	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00577	eb 0c		 jmp	 SHORT $LN162@sre_uat
$LN163@sre_uat:
  00579	83 f8 02	 cmp	 eax, 2
  0057c	75 05		 jne	 SHORT $LN161@sre_uat
  0057e	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00581	eb 02		 jmp	 SHORT $LN162@sre_uat
$LN161@sre_uat:
  00583	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN162@sre_uat:
  00585	f7 c1 00 ff ff
	ff		 test	 ecx, -256		; ffffffffffffff00H
  0058b	75 1f		 jne	 SHORT $LN280@sre_uat
  0058d	3b c5		 cmp	 eax, ebp
  0058f	75 05		 jne	 SHORT $LN167@sre_uat
  00591	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00594	eb 0c		 jmp	 SHORT $LN166@sre_uat
$LN167@sre_uat:
  00596	83 f8 02	 cmp	 eax, 2
  00599	75 05		 jne	 SHORT $LN165@sre_uat
  0059b	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  0059e	eb 02		 jmp	 SHORT $LN166@sre_uat
$LN165@sre_uat:
  005a0	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN166@sre_uat:
  005a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  005a8	85 c0		 test	 eax, eax
  005aa	75 1f		 jne	 SHORT $LN178@sre_uat
$LN280@sre_uat:
  005ac	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  005af	3b c5		 cmp	 eax, ebp
  005b1	75 05		 jne	 SHORT $LN173@sre_uat
  005b3	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  005b6	eb 0c		 jmp	 SHORT $LN172@sre_uat
$LN173@sre_uat:
  005b8	83 f8 02	 cmp	 eax, 2
  005bb	75 05		 jne	 SHORT $LN171@sre_uat
  005bd	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  005c0	eb 02		 jmp	 SHORT $LN172@sre_uat
$LN171@sre_uat:
  005c2	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN172@sre_uat:
  005c4	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  005c7	74 02		 je	 SHORT $LN178@sre_uat
$LN177@sre_uat:
  005c9	8b ef		 mov	 ebp, edi
$LN178@sre_uat:

; 369  :         return thisp == thatp;

  005cb	48 63 c5	 movsxd	 rax, ebp
  005ce	49 3b c4	 cmp	 rax, r12
  005d1	40 0f 94 c7	 sete	 dil
  005d5	8b c7		 mov	 eax, edi
  005d7	e9 35 03 00 00	 jmp	 $LN20@sre_uat
$LN4@sre_uat:

; 370  : 
; 371  :     case SRE_AT_UNI_BOUNDARY:
; 372  :         if (state->beginning == state->end)

  005dc	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  005e0	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 373  :             return 0;

  005e4	0f 84 25 03 00
	00		 je	 $LN18@sre_uat

; 374  :         thatp = ((void*) ptr > state->beginning) ?
; 375  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  005ea	33 ff		 xor	 edi, edi
  005ec	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  005ef	48 3b d0	 cmp	 rdx, rax
  005f2	0f 86 b8 00 00
	00		 jbe	 $LN201@sre_uat
  005f8	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  005fb	3b c5		 cmp	 eax, ebp
  005fd	75 06		 jne	 SHORT $LN181@sre_uat
  005ff	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  00603	eb 0e		 jmp	 SHORT $LN180@sre_uat
$LN181@sre_uat:
  00605	83 f8 02	 cmp	 eax, 2
  00608	75 06		 jne	 SHORT $LN179@sre_uat
  0060a	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  0060e	eb 03		 jmp	 SHORT $LN180@sre_uat
$LN179@sre_uat:
  00610	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN180@sre_uat:
  00613	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00618	85 c0		 test	 eax, eax
  0061a	0f 85 8c 00 00
	00		 jne	 $LN187@sre_uat
  00620	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00623	3b c5		 cmp	 eax, ebp
  00625	75 06		 jne	 SHORT $LN185@sre_uat
  00627	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  0062b	eb 0e		 jmp	 SHORT $LN184@sre_uat
$LN185@sre_uat:
  0062d	83 f8 02	 cmp	 eax, 2
  00630	75 06		 jne	 SHORT $LN183@sre_uat
  00632	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  00636	eb 03		 jmp	 SHORT $LN184@sre_uat
$LN183@sre_uat:
  00638	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN184@sre_uat:
  0063b	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00640	85 c0		 test	 eax, eax
  00642	75 68		 jne	 SHORT $LN187@sre_uat
  00644	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00647	3b c5		 cmp	 eax, ebp
  00649	75 06		 jne	 SHORT $LN190@sre_uat
  0064b	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  0064f	eb 0e		 jmp	 SHORT $LN189@sre_uat
$LN190@sre_uat:
  00651	83 f8 02	 cmp	 eax, 2
  00654	75 06		 jne	 SHORT $LN188@sre_uat
  00656	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  0065a	eb 03		 jmp	 SHORT $LN189@sre_uat
$LN188@sre_uat:
  0065c	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN189@sre_uat:
  0065f	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00664	85 c0		 test	 eax, eax
  00666	75 44		 jne	 SHORT $LN187@sre_uat
  00668	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  0066b	3b c5		 cmp	 eax, ebp
  0066d	75 06		 jne	 SHORT $LN194@sre_uat
  0066f	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  00673	eb 0e		 jmp	 SHORT $LN193@sre_uat
$LN194@sre_uat:
  00675	83 f8 02	 cmp	 eax, 2
  00678	75 06		 jne	 SHORT $LN192@sre_uat
  0067a	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  0067e	eb 03		 jmp	 SHORT $LN193@sre_uat
$LN192@sre_uat:
  00680	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN193@sre_uat:
  00683	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  00688	85 c0		 test	 eax, eax
  0068a	75 20		 jne	 SHORT $LN187@sre_uat
  0068c	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  0068f	3b c5		 cmp	 eax, ebp
  00691	75 06		 jne	 SHORT $LN198@sre_uat
  00693	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  00697	eb 0e		 jmp	 SHORT $LN197@sre_uat
$LN198@sre_uat:
  00699	83 f8 02	 cmp	 eax, 2
  0069c	75 06		 jne	 SHORT $LN196@sre_uat
  0069e	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  006a2	eb 03		 jmp	 SHORT $LN197@sre_uat
$LN196@sre_uat:
  006a4	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
$LN197@sre_uat:
  006a7	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  006aa	75 04		 jne	 SHORT $LN201@sre_uat
$LN187@sre_uat:
  006ac	8b c5		 mov	 eax, ebp
  006ae	eb 02		 jmp	 SHORT $LN202@sre_uat
$LN201@sre_uat:
  006b0	8b c7		 mov	 eax, edi
$LN202@sre_uat:
  006b2	4c 63 e0	 movsxd	 r12, eax

; 376  :         thisp = ((void*) ptr < state->end) ?
; 377  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  006b5	48 3b 5e 18	 cmp	 rbx, QWORD PTR [rsi+24]
  006b9	0f 83 a5 00 00
	00		 jae	 $LN225@sre_uat
  006bf	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  006c2	3b c5		 cmp	 eax, ebp
  006c4	75 05		 jne	 SHORT $LN205@sre_uat
  006c6	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  006c9	eb 0c		 jmp	 SHORT $LN204@sre_uat
$LN205@sre_uat:
  006cb	83 f8 02	 cmp	 eax, 2
  006ce	75 05		 jne	 SHORT $LN203@sre_uat
  006d0	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  006d3	eb 02		 jmp	 SHORT $LN204@sre_uat
$LN203@sre_uat:
  006d5	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN204@sre_uat:
  006d7	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  006dc	85 c0		 test	 eax, eax
  006de	0f 85 82 00 00
	00		 jne	 $LN226@sre_uat
  006e4	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  006e7	3b c5		 cmp	 eax, ebp
  006e9	75 05		 jne	 SHORT $LN209@sre_uat
  006eb	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  006ee	eb 0c		 jmp	 SHORT $LN208@sre_uat
$LN209@sre_uat:
  006f0	83 f8 02	 cmp	 eax, 2
  006f3	75 05		 jne	 SHORT $LN207@sre_uat
  006f5	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  006f8	eb 02		 jmp	 SHORT $LN208@sre_uat
$LN207@sre_uat:
  006fa	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN208@sre_uat:
  006fc	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  00701	85 c0		 test	 eax, eax
  00703	75 61		 jne	 SHORT $LN226@sre_uat
  00705	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00708	3b c5		 cmp	 eax, ebp
  0070a	75 05		 jne	 SHORT $LN214@sre_uat
  0070c	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0070f	eb 0c		 jmp	 SHORT $LN213@sre_uat
$LN214@sre_uat:
  00711	83 f8 02	 cmp	 eax, 2
  00714	75 05		 jne	 SHORT $LN212@sre_uat
  00716	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00719	eb 02		 jmp	 SHORT $LN213@sre_uat
$LN212@sre_uat:
  0071b	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN213@sre_uat:
  0071d	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  00722	85 c0		 test	 eax, eax
  00724	75 40		 jne	 SHORT $LN226@sre_uat
  00726	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00729	3b c5		 cmp	 eax, ebp
  0072b	75 05		 jne	 SHORT $LN218@sre_uat
  0072d	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00730	eb 0c		 jmp	 SHORT $LN217@sre_uat
$LN218@sre_uat:
  00732	83 f8 02	 cmp	 eax, 2
  00735	75 05		 jne	 SHORT $LN216@sre_uat
  00737	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  0073a	eb 02		 jmp	 SHORT $LN217@sre_uat
$LN216@sre_uat:
  0073c	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN217@sre_uat:
  0073e	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  00743	85 c0		 test	 eax, eax
  00745	75 1f		 jne	 SHORT $LN226@sre_uat
  00747	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  0074a	3b c5		 cmp	 eax, ebp
  0074c	75 05		 jne	 SHORT $LN222@sre_uat
  0074e	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00751	eb 0c		 jmp	 SHORT $LN221@sre_uat
$LN222@sre_uat:
  00753	83 f8 02	 cmp	 eax, 2
  00756	75 05		 jne	 SHORT $LN220@sre_uat
  00758	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  0075b	eb 02		 jmp	 SHORT $LN221@sre_uat
$LN220@sre_uat:
  0075d	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN221@sre_uat:
  0075f	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00762	74 02		 je	 SHORT $LN226@sre_uat
$LN225@sre_uat:
  00764	8b ef		 mov	 ebp, edi
$LN226@sre_uat:

; 378  :         return thisp != thatp;

  00766	48 63 c5	 movsxd	 rax, ebp
  00769	49 3b c4	 cmp	 rax, r12
  0076c	40 0f 95 c7	 setne	 dil
  00770	8b c7		 mov	 eax, edi
  00772	e9 9a 01 00 00	 jmp	 $LN20@sre_uat
$LN2@sre_uat:

; 379  : 
; 380  :     case SRE_AT_UNI_NON_BOUNDARY:
; 381  :         if (state->beginning == state->end)

  00777	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0077b	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]

; 382  :             return 0;

  0077f	0f 84 8a 01 00
	00		 je	 $LN18@sre_uat

; 383  :         thatp = ((void*) ptr > state->beginning) ?
; 384  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, -1)) : 0;

  00785	33 ff		 xor	 edi, edi
  00787	8d 6f 01	 lea	 ebp, QWORD PTR [rdi+1]
  0078a	48 3b d0	 cmp	 rdx, rax
  0078d	0f 86 b8 00 00
	00		 jbe	 $LN249@sre_uat
  00793	8b 41 3c	 mov	 eax, DWORD PTR [rcx+60]
  00796	3b c5		 cmp	 eax, ebp
  00798	75 06		 jne	 SHORT $LN229@sre_uat
  0079a	0f b6 4a ff	 movzx	 ecx, BYTE PTR [rdx-1]
  0079e	eb 0e		 jmp	 SHORT $LN228@sre_uat
$LN229@sre_uat:
  007a0	83 f8 02	 cmp	 eax, 2
  007a3	75 06		 jne	 SHORT $LN227@sre_uat
  007a5	0f b7 4a fe	 movzx	 ecx, WORD PTR [rdx-2]
  007a9	eb 03		 jmp	 SHORT $LN228@sre_uat
$LN227@sre_uat:
  007ab	8b 4a fc	 mov	 ecx, DWORD PTR [rdx-4]
$LN228@sre_uat:
  007ae	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  007b3	85 c0		 test	 eax, eax
  007b5	0f 85 8c 00 00
	00		 jne	 $LN235@sre_uat
  007bb	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  007be	3b c5		 cmp	 eax, ebp
  007c0	75 06		 jne	 SHORT $LN233@sre_uat
  007c2	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  007c6	eb 0e		 jmp	 SHORT $LN232@sre_uat
$LN233@sre_uat:
  007c8	83 f8 02	 cmp	 eax, 2
  007cb	75 06		 jne	 SHORT $LN231@sre_uat
  007cd	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  007d1	eb 03		 jmp	 SHORT $LN232@sre_uat
$LN231@sre_uat:
  007d3	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN232@sre_uat:
  007d6	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  007db	85 c0		 test	 eax, eax
  007dd	75 68		 jne	 SHORT $LN235@sre_uat
  007df	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  007e2	3b c5		 cmp	 eax, ebp
  007e4	75 06		 jne	 SHORT $LN238@sre_uat
  007e6	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  007ea	eb 0e		 jmp	 SHORT $LN237@sre_uat
$LN238@sre_uat:
  007ec	83 f8 02	 cmp	 eax, 2
  007ef	75 06		 jne	 SHORT $LN236@sre_uat
  007f1	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  007f5	eb 03		 jmp	 SHORT $LN237@sre_uat
$LN236@sre_uat:
  007f7	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN237@sre_uat:
  007fa	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  007ff	85 c0		 test	 eax, eax
  00801	75 44		 jne	 SHORT $LN235@sre_uat
  00803	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00806	3b c5		 cmp	 eax, ebp
  00808	75 06		 jne	 SHORT $LN242@sre_uat
  0080a	0f b6 4b ff	 movzx	 ecx, BYTE PTR [rbx-1]
  0080e	eb 0e		 jmp	 SHORT $LN241@sre_uat
$LN242@sre_uat:
  00810	83 f8 02	 cmp	 eax, 2
  00813	75 06		 jne	 SHORT $LN240@sre_uat
  00815	0f b7 4b fe	 movzx	 ecx, WORD PTR [rbx-2]
  00819	eb 03		 jmp	 SHORT $LN241@sre_uat
$LN240@sre_uat:
  0081b	8b 4b fc	 mov	 ecx, DWORD PTR [rbx-4]
$LN241@sre_uat:
  0081e	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  00823	85 c0		 test	 eax, eax
  00825	75 20		 jne	 SHORT $LN235@sre_uat
  00827	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  0082a	3b c5		 cmp	 eax, ebp
  0082c	75 06		 jne	 SHORT $LN246@sre_uat
  0082e	0f b6 43 ff	 movzx	 eax, BYTE PTR [rbx-1]
  00832	eb 0e		 jmp	 SHORT $LN245@sre_uat
$LN246@sre_uat:
  00834	83 f8 02	 cmp	 eax, 2
  00837	75 06		 jne	 SHORT $LN244@sre_uat
  00839	0f b7 43 fe	 movzx	 eax, WORD PTR [rbx-2]
  0083d	eb 03		 jmp	 SHORT $LN245@sre_uat
$LN244@sre_uat:
  0083f	8b 43 fc	 mov	 eax, DWORD PTR [rbx-4]
$LN245@sre_uat:
  00842	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00845	75 04		 jne	 SHORT $LN249@sre_uat
$LN235@sre_uat:
  00847	8b c5		 mov	 eax, ebp
  00849	eb 02		 jmp	 SHORT $LN250@sre_uat
$LN249@sre_uat:
  0084b	8b c7		 mov	 eax, edi
$LN250@sre_uat:
  0084d	4c 63 e0	 movsxd	 r12, eax

; 385  :         thisp = ((void*) ptr < state->end) ?
; 386  :             SRE_UNI_IS_WORD((int) SRE_CHARGET(state, ptr, 0)) : 0;

  00850	48 3b 5e 18	 cmp	 rbx, QWORD PTR [rsi+24]
  00854	0f 83 a5 00 00
	00		 jae	 $LN273@sre_uat
  0085a	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  0085d	3b c5		 cmp	 eax, ebp
  0085f	75 05		 jne	 SHORT $LN253@sre_uat
  00861	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00864	eb 0c		 jmp	 SHORT $LN252@sre_uat
$LN253@sre_uat:
  00866	83 f8 02	 cmp	 eax, 2
  00869	75 05		 jne	 SHORT $LN251@sre_uat
  0086b	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  0086e	eb 02		 jmp	 SHORT $LN252@sre_uat
$LN251@sre_uat:
  00870	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN252@sre_uat:
  00872	e8 00 00 00 00	 call	 _PyUnicode_IsAlpha
  00877	85 c0		 test	 eax, eax
  00879	0f 85 82 00 00
	00		 jne	 $LN274@sre_uat
  0087f	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00882	3b c5		 cmp	 eax, ebp
  00884	75 05		 jne	 SHORT $LN257@sre_uat
  00886	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  00889	eb 0c		 jmp	 SHORT $LN256@sre_uat
$LN257@sre_uat:
  0088b	83 f8 02	 cmp	 eax, 2
  0088e	75 05		 jne	 SHORT $LN255@sre_uat
  00890	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00893	eb 02		 jmp	 SHORT $LN256@sre_uat
$LN255@sre_uat:
  00895	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN256@sre_uat:
  00897	e8 00 00 00 00	 call	 _PyUnicode_IsDecimalDigit
  0089c	85 c0		 test	 eax, eax
  0089e	75 61		 jne	 SHORT $LN274@sre_uat
  008a0	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  008a3	3b c5		 cmp	 eax, ebp
  008a5	75 05		 jne	 SHORT $LN262@sre_uat
  008a7	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  008aa	eb 0c		 jmp	 SHORT $LN261@sre_uat
$LN262@sre_uat:
  008ac	83 f8 02	 cmp	 eax, 2
  008af	75 05		 jne	 SHORT $LN260@sre_uat
  008b1	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  008b4	eb 02		 jmp	 SHORT $LN261@sre_uat
$LN260@sre_uat:
  008b6	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN261@sre_uat:
  008b8	e8 00 00 00 00	 call	 _PyUnicode_IsDigit
  008bd	85 c0		 test	 eax, eax
  008bf	75 40		 jne	 SHORT $LN274@sre_uat
  008c1	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  008c4	3b c5		 cmp	 eax, ebp
  008c6	75 05		 jne	 SHORT $LN266@sre_uat
  008c8	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  008cb	eb 0c		 jmp	 SHORT $LN265@sre_uat
$LN266@sre_uat:
  008cd	83 f8 02	 cmp	 eax, 2
  008d0	75 05		 jne	 SHORT $LN264@sre_uat
  008d2	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  008d5	eb 02		 jmp	 SHORT $LN265@sre_uat
$LN264@sre_uat:
  008d7	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN265@sre_uat:
  008d9	e8 00 00 00 00	 call	 _PyUnicode_IsNumeric
  008de	85 c0		 test	 eax, eax
  008e0	75 1f		 jne	 SHORT $LN274@sre_uat
  008e2	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  008e5	3b c5		 cmp	 eax, ebp
  008e7	75 05		 jne	 SHORT $LN270@sre_uat
  008e9	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  008ec	eb 0c		 jmp	 SHORT $LN269@sre_uat
$LN270@sre_uat:
  008ee	83 f8 02	 cmp	 eax, 2
  008f1	75 05		 jne	 SHORT $LN268@sre_uat
  008f3	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  008f6	eb 02		 jmp	 SHORT $LN269@sre_uat
$LN268@sre_uat:
  008f8	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN269@sre_uat:
  008fa	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  008fd	74 02		 je	 SHORT $LN274@sre_uat
$LN273@sre_uat:
  008ff	8b ef		 mov	 ebp, edi
$LN274@sre_uat:

; 387  :         return thisp == thatp;

  00901	48 63 cd	 movsxd	 rcx, ebp
  00904	49 3b cc	 cmp	 rcx, r12
  00907	40 0f 94 c7	 sete	 dil
  0090b	8b c7		 mov	 eax, edi
  0090d	eb 02		 jmp	 SHORT $LN20@sre_uat
$LN18@sre_uat:

; 388  : 
; 389  :     }
; 390  : 
; 391  :     return 0;

  0090f	33 c0		 xor	 eax, eax
$LN20@sre_uat:

; 392  : }

  00911	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00916	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0091b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00920	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00925	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00929	41 5c		 pop	 r12
  0092b	c3		 ret	 0
$LN281@sre_uat:
  0092c	00 00 00 00	 DD	 $LN17@sre_uat
  00930	00 00 00 00	 DD	 $LN16@sre_uat
  00934	00 00 00 00	 DD	 $LN17@sre_uat
  00938	00 00 00 00	 DD	 $LN12@sre_uat
  0093c	00 00 00 00	 DD	 $LN10@sre_uat
  00940	00 00 00 00	 DD	 $LN15@sre_uat
  00944	00 00 00 00	 DD	 $LN14@sre_uat
  00948	00 00 00 00	 DD	 $LN13@sre_uat
  0094c	00 00 00 00	 DD	 $LN8@sre_uat
  00950	00 00 00 00	 DD	 $LN6@sre_uat
  00954	00 00 00 00	 DD	 $LN4@sre_uat
  00958	00 00 00 00	 DD	 $LN2@sre_uat
sre_uat	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_ucharset DD imagerel sre_ucharset
	DD	imagerel sre_ucharset+392
	DD	imagerel $unwind$sre_ucharset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_ucharset DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT sre_ucharset
_TEXT	SEGMENT
set$ = 48
ch$ = 56
sre_ucharset PROC					; COMDAT

; 396  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 397  :     /* check if character is a member of the given set */
; 398  : 
; 399  :     int ok = 1;
; 400  : 
; 401  :     for (;;) {
; 402  :         switch (*set++) {

  0001a	8b 01		 mov	 eax, DWORD PTR [rcx]
  0001c	8b f2		 mov	 esi, edx
  0001e	bf 01 00 00 00	 mov	 edi, 1
  00023	48 8d 59 04	 lea	 rbx, QWORD PTR [rcx+4]
  00027	83 f8 1b	 cmp	 eax, 27
  0002a	0f 87 ee 00 00
	00		 ja	 $LN1@sre_uchars
  00030	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:__ImageBase
  00037	33 ed		 xor	 ebp, ebp
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL25@sre_uchars:
  00040	41 0f b6 84 04
	00 00 00 00	 movzx	 eax, BYTE PTR $LN34@sre_uchars[r12+rax]
  00049	41 8b 8c 84 00
	00 00 00	 mov	 ecx, DWORD PTR $LN35@sre_uchars[r12+rax*4]
  00051	49 03 cc	 add	 rcx, r12
  00054	ff e1		 jmp	 rcx
$LN20@sre_uchars:

; 406  : 
; 407  :         case SRE_OP_LITERAL:
; 408  :             /* <LITERAL> <code> */
; 409  :             if (ch == set[0])

  00056	3b 33		 cmp	 esi, DWORD PTR [rbx]
  00058	0f 84 dd 00 00
	00		 je	 $LN29@sre_uchars

; 411  :             set++;

  0005e	48 83 c3 04	 add	 rbx, 4

; 412  :             break;

  00062	e9 a8 00 00 00	 jmp	 $LN5@sre_uchars
$LN18@sre_uchars:

; 413  : 
; 414  :         case SRE_OP_CATEGORY:
; 415  :             /* <CATEGORY> <code> */
; 416  :             if (sre_category(set[0], (int) ch))

  00067	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00069	8b d6		 mov	 edx, esi
  0006b	e8 00 00 00 00	 call	 sre_category
  00070	85 c0		 test	 eax, eax
  00072	0f 85 c3 00 00
	00		 jne	 $LN29@sre_uchars

; 417  :                 return ok;
; 418  :             set += 1;

  00078	48 83 c3 04	 add	 rbx, 4

; 419  :             break;

  0007c	e9 8e 00 00 00	 jmp	 $LN5@sre_uchars
$LN16@sre_uchars:

; 420  : 
; 421  :         case SRE_OP_CHARSET:
; 422  :             if (sizeof(SRE_CODE) == 2) {
; 423  :                 /* <CHARSET> <bitmap> (16 bits per code word) */
; 424  :                 if (ch < 256 && (set[ch >> 4] & (1 << (ch & 15))))
; 425  :                     return ok;
; 426  :                 set += 16;
; 427  :             }
; 428  :             else {
; 429  :                 /* <CHARSET> <bitmap> (32 bits per code word) */
; 430  :                 if (ch < 256 && (set[ch >> 5] & (1u << (ch & 31))))

  00081	81 fe 00 01 00
	00		 cmp	 esi, 256		; 00000100H
  00087	73 18		 jae	 SHORT $LN12@sre_uchars
  00089	48 8b c6	 mov	 rax, rsi
  0008c	8b ce		 mov	 ecx, esi
  0008e	48 c1 e8 05	 shr	 rax, 5
  00092	83 e1 1f	 and	 ecx, 31
  00095	8b 04 83	 mov	 eax, DWORD PTR [rbx+rax*4]
  00098	0f a3 c8	 bt	 eax, ecx
  0009b	0f 82 9a 00 00
	00		 jb	 $LN29@sre_uchars
$LN12@sre_uchars:

; 431  :                     return ok;
; 432  :                 set += 8;

  000a1	48 83 c3 20	 add	 rbx, 32			; 00000020H

; 433  :             }
; 434  :             break;

  000a5	eb 68		 jmp	 SHORT $LN5@sre_uchars
$LN11@sre_uchars:

; 435  : 
; 436  :         case SRE_OP_RANGE:
; 437  :             /* <RANGE> <lower> <upper> */
; 438  :             if (set[0] <= ch && ch <= set[1])

  000a7	39 33		 cmp	 DWORD PTR [rbx], esi
  000a9	77 09		 ja	 SHORT $LN10@sre_uchars
  000ab	3b 73 04	 cmp	 esi, DWORD PTR [rbx+4]
  000ae	0f 86 87 00 00
	00		 jbe	 $LN29@sre_uchars
$LN10@sre_uchars:

; 439  :                 return ok;
; 440  :             set += 2;

  000b4	48 83 c3 08	 add	 rbx, 8

; 441  :             break;

  000b8	eb 55		 jmp	 SHORT $LN5@sre_uchars
$LN9@sre_uchars:

; 442  : 
; 443  :         case SRE_OP_NEGATE:
; 444  :             ok = !ok;

  000ba	85 ff		 test	 edi, edi
  000bc	8b c5		 mov	 eax, ebp
  000be	0f 94 c0	 sete	 al
  000c1	8b f8		 mov	 edi, eax

; 445  :             break;

  000c3	eb 4a		 jmp	 SHORT $LN5@sre_uchars
$LN8@sre_uchars:

; 446  : 
; 447  :         case SRE_OP_BIGCHARSET:
; 448  :             /* <BIGCHARSET> <blockcount> <256 blockindices> <blocks> */
; 449  :         {
; 450  :             Py_ssize_t count, block;
; 451  :             count = *(set++);

  000c5	44 8b 03	 mov	 r8d, DWORD PTR [rbx]

; 452  : 
; 453  :             if (sizeof(SRE_CODE) == 2) {
; 454  :                 block = ((unsigned char*)set)[ch >> 8];
; 455  :                 set += 128;
; 456  :                 if (set[block*16 + ((ch & 255)>>4)] & (1 << (ch & 15)))
; 457  :                     return ok;
; 458  :                 set += count*16;
; 459  :             }
; 460  :             else {
; 461  :                 /* !(c & ~N) == (c < N+1) for any unsigned c, this avoids
; 462  :                  * warnings when c's type supports only numbers < N+1 */
; 463  :                 if (!(ch & ~65535))

  000c8	f7 c6 00 00 ff
	ff		 test	 esi, -65536		; ffff0000H
  000ce	75 0e		 jne	 SHORT $LN4@sre_uchars

; 464  :                     block = ((unsigned char*)set)[ch >> 8];

  000d0	48 8b c6	 mov	 rax, rsi
  000d3	48 c1 e8 08	 shr	 rax, 8
  000d7	0f b6 4c 18 04	 movzx	 ecx, BYTE PTR [rax+rbx+4]

; 465  :                 else

  000dc	eb 04		 jmp	 SHORT $LN3@sre_uchars
$LN4@sre_uchars:

; 466  :                     block = -1;

  000de	48 83 c9 ff	 or	 rcx, -1
$LN3@sre_uchars:

; 467  :                 set += 64;

  000e2	48 81 c3 04 01
	00 00		 add	 rbx, 260		; 00000104H

; 468  :                 if (block >=0 &&
; 469  :                     (set[block*8 + ((ch & 255)>>5)] & (1u << (ch & 31))))

  000e9	48 85 c9	 test	 rcx, rcx
  000ec	78 1a		 js	 SHORT $LN2@sre_uchars
  000ee	8b c6		 mov	 eax, esi
  000f0	48 c1 e8 05	 shr	 rax, 5
  000f4	83 e0 07	 and	 eax, 7
  000f7	48 8d 14 c8	 lea	 rdx, QWORD PTR [rax+rcx*8]
  000fb	8b ce		 mov	 ecx, esi
  000fd	8b 04 93	 mov	 eax, DWORD PTR [rbx+rdx*4]
  00100	83 e1 1f	 and	 ecx, 31
  00103	0f a3 c8	 bt	 eax, ecx
  00106	72 33		 jb	 SHORT $LN29@sre_uchars
$LN2@sre_uchars:

; 470  :                     return ok;
; 471  :                 set += count*8;

  00108	49 c1 e0 05	 shl	 r8, 5
  0010c	49 03 d8	 add	 rbx, r8
$LN5@sre_uchars:

; 397  :     /* check if character is a member of the given set */
; 398  : 
; 399  :     int ok = 1;
; 400  : 
; 401  :     for (;;) {
; 402  :         switch (*set++) {

  0010f	8b 03		 mov	 eax, DWORD PTR [rbx]
  00111	48 83 c3 04	 add	 rbx, 4
  00115	83 f8 1b	 cmp	 eax, 27
  00118	0f 86 22 ff ff
	ff		 jbe	 $LL25@sre_uchars
$LN1@sre_uchars:

; 472  :             }
; 473  :             break;
; 474  :         }
; 475  : 
; 476  :         default:
; 477  :             /* internal error -- there's not much we can do about it
; 478  :                here, so let's just pretend it didn't match... */
; 479  :             return 0;

  0011e	33 c0		 xor	 eax, eax
$LN24@sre_uchars:

; 480  :         }
; 481  :     }
; 482  : }

  00120	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00125	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0012a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0012f	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00134	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00138	41 5c		 pop	 r12
  0013a	c3		 ret	 0
$LN29@sre_uchars:

; 410  :                 return ok;

  0013b	8b c7		 mov	 eax, edi
  0013d	eb e1		 jmp	 SHORT $LN24@sre_uchars
$LN21@sre_uchars:

; 403  : 
; 404  :         case SRE_OP_FAILURE:
; 405  :             return !ok;

  0013f	85 ff		 test	 edi, edi
  00141	40 0f 94 c5	 sete	 bpl
  00145	8b c5		 mov	 eax, ebp
  00147	eb d7		 jmp	 SHORT $LN24@sre_uchars
  00149	0f 1f 00	 npad	 3
$LN35@sre_uchars:

; 480  :         }
; 481  :     }
; 482  : }

  0014c	00 00 00 00	 DD	 $LN21@sre_uchars
  00150	00 00 00 00	 DD	 $LN18@sre_uchars
  00154	00 00 00 00	 DD	 $LN16@sre_uchars
  00158	00 00 00 00	 DD	 $LN8@sre_uchars
  0015c	00 00 00 00	 DD	 $LN20@sre_uchars
  00160	00 00 00 00	 DD	 $LN9@sre_uchars
  00164	00 00 00 00	 DD	 $LN11@sre_uchars
  00168	00 00 00 00	 DD	 $LN1@sre_uchars
$LN34@sre_uchars:
  0016c	00		 DB	 0
  0016d	07		 DB	 7
  0016e	07		 DB	 7
  0016f	07		 DB	 7
  00170	07		 DB	 7
  00171	07		 DB	 7
  00172	07		 DB	 7
  00173	07		 DB	 7
  00174	07		 DB	 7
  00175	01		 DB	 1
  00176	02		 DB	 2
  00177	03		 DB	 3
  00178	07		 DB	 7
  00179	07		 DB	 7
  0017a	07		 DB	 7
  0017b	07		 DB	 7
  0017c	07		 DB	 7
  0017d	07		 DB	 7
  0017e	07		 DB	 7
  0017f	04		 DB	 4
  00180	07		 DB	 7
  00181	07		 DB	 7
  00182	07		 DB	 7
  00183	07		 DB	 7
  00184	07		 DB	 7
  00185	07		 DB	 7
  00186	05		 DB	 5
  00187	06		 DB	 6
sre_ucharset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_ucount DD imagerel sre_ucount
	DD	imagerel sre_ucount+692
	DD	imagerel $unwind$sre_ucount
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_ucount DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT sre_ucount
_TEXT	SEGMENT
state$ = 48
pattern$ = 56
maxcount$ = 64
sre_ucount PROC						; COMDAT

; 488  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 489  :     SRE_CODE chr;
; 490  :     char* ptr = (char *)state->ptr;
; 491  :     char* end = (char *)state->end;

  00014	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  00018	48 8b 19	 mov	 rbx, QWORD PTR [rcx]

; 492  :     Py_ssize_t i;
; 493  : 
; 494  :     /* adjust end */
; 495  :     if (maxcount < (end - ptr) / state->charsize && maxcount != SRE_MAXREPEAT)

  0001b	4c 63 49 3c	 movsxd	 r9, DWORD PTR [rcx+60]
  0001f	48 8b ea	 mov	 rbp, rdx
  00022	48 8b c7	 mov	 rax, rdi
  00025	48 8b f1	 mov	 rsi, rcx
  00028	48 2b c3	 sub	 rax, rbx
  0002b	48 99		 cdq
  0002d	49 f7 f9	 idiv	 r9
  00030	4c 3b c0	 cmp	 r8, rax
  00033	7d 14		 jge	 SHORT $LN27@sre_ucount
  00035	b8 ff ff ff ff	 mov	 eax, -1
  0003a	4c 3b c0	 cmp	 r8, rax
  0003d	74 0a		 je	 SHORT $LN27@sre_ucount

; 496  :         end = ptr + maxcount*state->charsize;

  0003f	49 8b f9	 mov	 rdi, r9
  00042	49 0f af f8	 imul	 rdi, r8
  00046	48 03 fb	 add	 rdi, rbx
$LN27@sre_ucount:

; 497  : 
; 498  :     switch (pattern[0]) {

  00049	8b 45 00	 mov	 eax, DWORD PTR [rbp]
  0004c	83 c0 fe	 add	 eax, -2			; fffffffeH
  0004f	83 f8 17	 cmp	 eax, 23
  00052	0f 87 e2 01 00
	00		 ja	 $LN66@sre_ucount
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0005f	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN76@sre_ucount[rdx+rax]
  00067	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN77@sre_ucount[rdx+rax*4]
  0006e	48 03 ca	 add	 rcx, rdx
  00071	ff e1		 jmp	 rcx
$LN60@sre_ucount:

; 499  : 
; 500  :     case SRE_OP_IN:
; 501  :         /* repeated set */
; 502  :         TRACE(("|%p|%p|COUNT IN\n", pattern, ptr));
; 503  :         while (ptr < end &&
; 504  :                SRE_CHARSET(pattern + 2, SRE_CHARGET(state, ptr, 0)))

  00073	48 3b df	 cmp	 rbx, rdi
  00076	0f 83 b6 01 00
	00		 jae	 $LN78@sre_ucount
  0007c	0f 1f 40 00	 npad	 4
$LL23@sre_ucount:
  00080	41 83 f9 01	 cmp	 r9d, 1
  00084	75 05		 jne	 SHORT $LN32@sre_ucount
  00086	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  00089	eb 0d		 jmp	 SHORT $LN31@sre_ucount
$LN32@sre_ucount:
  0008b	41 83 f9 02	 cmp	 r9d, 2
  0008f	75 05		 jne	 SHORT $LN30@sre_ucount
  00091	0f b7 13	 movzx	 edx, WORD PTR [rbx]
  00094	eb 02		 jmp	 SHORT $LN31@sre_ucount
$LN30@sre_ucount:
  00096	8b 13		 mov	 edx, DWORD PTR [rbx]
$LN31@sre_ucount:
  00098	48 8d 4d 08	 lea	 rcx, QWORD PTR [rbp+8]
  0009c	e8 00 00 00 00	 call	 sre_ucharset
  000a1	85 c0		 test	 eax, eax
  000a3	0f 84 89 01 00
	00		 je	 $LN78@sre_ucount

; 505  :             ptr += state->charsize;

  000a9	4c 63 4e 3c	 movsxd	 r9, DWORD PTR [rsi+60]
  000ad	49 03 d9	 add	 rbx, r9
  000b0	48 3b df	 cmp	 rbx, rdi
  000b3	72 cb		 jb	 SHORT $LL23@sre_ucount

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  000b5	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  000b8	48 8b c3	 mov	 rax, rbx
  000bb	e9 9d 01 00 00	 jmp	 $LN79@sre_ucount
$LN61@sre_ucount:

; 506  :         break;
; 507  : 
; 508  :     case SRE_OP_ANY:
; 509  :         /* repeated dot wildcard. */
; 510  :         TRACE(("|%p|%p|COUNT ANY\n", pattern, ptr));
; 511  :         while (ptr < end && !SRE_IS_LINEBREAK(SRE_CHARGET(state, ptr, 0)))

  000c0	48 3b df	 cmp	 rbx, rdi
  000c3	0f 83 69 01 00
	00		 jae	 $LN78@sre_ucount
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL20@sre_ucount:
  000d0	41 83 f9 01	 cmp	 r9d, 1
  000d4	75 05		 jne	 SHORT $LN36@sre_ucount
  000d6	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000d9	eb 0d		 jmp	 SHORT $LN35@sre_ucount
$LN36@sre_ucount:
  000db	41 83 f9 02	 cmp	 r9d, 2
  000df	75 05		 jne	 SHORT $LN34@sre_ucount
  000e1	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  000e4	eb 02		 jmp	 SHORT $LN35@sre_ucount
$LN34@sre_ucount:
  000e6	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN35@sre_ucount:
  000e8	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000ed	73 29		 jae	 SHORT $LN75@sre_ucount
  000ef	41 83 f9 01	 cmp	 r9d, 1
  000f3	75 05		 jne	 SHORT $LN40@sre_ucount
  000f5	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000f8	eb 0d		 jmp	 SHORT $LN39@sre_ucount
$LN40@sre_ucount:
  000fa	41 83 f9 02	 cmp	 r9d, 2
  000fe	75 05		 jne	 SHORT $LN38@sre_ucount
  00100	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00103	eb 02		 jmp	 SHORT $LN39@sre_ucount
$LN38@sre_ucount:
  00105	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN39@sre_ucount:
  00107	0f be 8c 10 00
	00 00 00	 movsx	 ecx, BYTE PTR sre_char_info[rax+rdx]
  0010f	83 e1 04	 and	 ecx, 4
  00112	0f 85 1a 01 00
	00		 jne	 $LN78@sre_ucount
$LN75@sre_ucount:

; 512  :             ptr += state->charsize;

  00118	49 03 d9	 add	 rbx, r9
  0011b	48 3b df	 cmp	 rbx, rdi
  0011e	72 b0		 jb	 SHORT $LL20@sre_ucount

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  00120	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00123	48 8b c3	 mov	 rax, rbx
  00126	e9 32 01 00 00	 jmp	 $LN79@sre_ucount
$LN18@sre_ucount:

; 513  :         break;
; 514  : 
; 515  :     case SRE_OP_ANY_ALL:
; 516  :         /* repeated dot wildcard.  skip to the end of the target
; 517  :            string, and backtrack from there */
; 518  :         TRACE(("|%p|%p|COUNT ANY_ALL\n", pattern, ptr));
; 519  :         ptr = end;

  0012b	48 8b df	 mov	 rbx, rdi

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  0012e	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00131	48 8b c3	 mov	 rax, rbx
  00134	e9 24 01 00 00	 jmp	 $LN79@sre_ucount
$LN17@sre_ucount:

; 520  :         break;
; 521  : 
; 522  :     case SRE_OP_LITERAL:
; 523  :         /* repeated literal */
; 524  :         chr = pattern[1];

  00139	8b 4d 04	 mov	 ecx, DWORD PTR [rbp+4]

; 525  :         TRACE(("|%p|%p|COUNT LITERAL %d\n", pattern, ptr, chr));
; 526  :         while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) == chr)

  0013c	48 3b df	 cmp	 rbx, rdi
  0013f	0f 83 ed 00 00
	00		 jae	 $LN78@sre_ucount
$LL16@sre_ucount:
  00145	41 83 f9 01	 cmp	 r9d, 1
  00149	75 05		 jne	 SHORT $LN46@sre_ucount
  0014b	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  0014e	eb 0d		 jmp	 SHORT $LN45@sre_ucount
$LN46@sre_ucount:
  00150	41 83 f9 02	 cmp	 r9d, 2
  00154	75 05		 jne	 SHORT $LN44@sre_ucount
  00156	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  00159	eb 02		 jmp	 SHORT $LN45@sre_ucount
$LN44@sre_ucount:
  0015b	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN45@sre_ucount:
  0015d	3b c1		 cmp	 eax, ecx
  0015f	0f 85 cd 00 00
	00		 jne	 $LN78@sre_ucount

; 527  :             ptr += state->charsize;

  00165	49 03 d9	 add	 rbx, r9
  00168	48 3b df	 cmp	 rbx, rdi
  0016b	72 d8		 jb	 SHORT $LL16@sre_ucount

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  0016d	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00170	48 8b c3	 mov	 rax, rbx
  00173	e9 e5 00 00 00	 jmp	 $LN79@sre_ucount
$LN14@sre_ucount:

; 528  :         break;
; 529  : 
; 530  :     case SRE_OP_LITERAL_IGNORE:
; 531  :         /* repeated literal */
; 532  :         chr = pattern[1];

  00178	8b 6d 04	 mov	 ebp, DWORD PTR [rbp+4]

; 533  :         TRACE(("|%p|%p|COUNT LITERAL_IGNORE %d\n", pattern, ptr, chr));
; 534  :         while (ptr < end && (SRE_CODE) state->lower(SRE_CHARGET(state, ptr, 0)) == chr)

  0017b	48 3b df	 cmp	 rbx, rdi
  0017e	0f 83 ae 00 00
	00		 jae	 $LN78@sre_ucount
$LL13@sre_ucount:
  00184	41 83 f9 01	 cmp	 r9d, 1
  00188	75 05		 jne	 SHORT $LN50@sre_ucount
  0018a	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0018d	eb 0d		 jmp	 SHORT $LN49@sre_ucount
$LN50@sre_ucount:
  0018f	41 83 f9 02	 cmp	 r9d, 2
  00193	75 05		 jne	 SHORT $LN48@sre_ucount
  00195	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00198	eb 02		 jmp	 SHORT $LN49@sre_ucount
$LN48@sre_ucount:
  0019a	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN49@sre_ucount:
  0019c	ff 96 00 07 00
	00		 call	 QWORD PTR [rsi+1792]
  001a2	3b c5		 cmp	 eax, ebp
  001a4	0f 85 88 00 00
	00		 jne	 $LN78@sre_ucount

; 535  :             ptr += state->charsize;

  001aa	4c 63 4e 3c	 movsxd	 r9, DWORD PTR [rsi+60]
  001ae	49 03 d9	 add	 rbx, r9
  001b1	48 3b df	 cmp	 rbx, rdi
  001b4	72 ce		 jb	 SHORT $LL13@sre_ucount

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  001b6	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  001b9	48 8b c3	 mov	 rax, rbx
  001bc	e9 9c 00 00 00	 jmp	 $LN79@sre_ucount
$LN11@sre_ucount:

; 536  :         break;
; 537  : 
; 538  :     case SRE_OP_NOT_LITERAL:
; 539  :         /* repeated non-literal */
; 540  :         chr = pattern[1];

  001c1	8b 4d 04	 mov	 ecx, DWORD PTR [rbp+4]

; 541  :         TRACE(("|%p|%p|COUNT NOT_LITERAL %d\n", pattern, ptr, chr));
; 542  :         while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) != chr)

  001c4	48 3b df	 cmp	 rbx, rdi
  001c7	73 69		 jae	 SHORT $LN78@sre_ucount
  001c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@sre_ucount:
  001d0	41 83 f9 01	 cmp	 r9d, 1
  001d4	75 05		 jne	 SHORT $LN54@sre_ucount
  001d6	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  001d9	eb 0d		 jmp	 SHORT $LN53@sre_ucount
$LN54@sre_ucount:
  001db	41 83 f9 02	 cmp	 r9d, 2
  001df	75 05		 jne	 SHORT $LN52@sre_ucount
  001e1	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  001e4	eb 02		 jmp	 SHORT $LN53@sre_ucount
$LN52@sre_ucount:
  001e6	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN53@sre_ucount:
  001e8	3b c1		 cmp	 eax, ecx
  001ea	74 46		 je	 SHORT $LN78@sre_ucount

; 543  :             ptr += state->charsize;

  001ec	49 03 d9	 add	 rbx, r9
  001ef	48 3b df	 cmp	 rbx, rdi
  001f2	72 dc		 jb	 SHORT $LL10@sre_ucount

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  001f4	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  001f7	48 8b c3	 mov	 rax, rbx
  001fa	eb 61		 jmp	 SHORT $LN79@sre_ucount
$LN8@sre_ucount:

; 544  :         break;
; 545  : 
; 546  :     case SRE_OP_NOT_LITERAL_IGNORE:
; 547  :         /* repeated non-literal */
; 548  :         chr = pattern[1];

  001fc	8b 6d 04	 mov	 ebp, DWORD PTR [rbp+4]

; 549  :         TRACE(("|%p|%p|COUNT NOT_LITERAL_IGNORE %d\n", pattern, ptr, chr));
; 550  :         while (ptr < end && (SRE_CODE) state->lower(SRE_CHARGET(state, ptr, 0)) != chr)

  001ff	48 3b df	 cmp	 rbx, rdi
  00202	73 2e		 jae	 SHORT $LN78@sre_ucount
$LL7@sre_ucount:
  00204	41 83 f9 01	 cmp	 r9d, 1
  00208	75 05		 jne	 SHORT $LN58@sre_ucount
  0020a	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  0020d	eb 0d		 jmp	 SHORT $LN57@sre_ucount
$LN58@sre_ucount:
  0020f	41 83 f9 02	 cmp	 r9d, 2
  00213	75 05		 jne	 SHORT $LN56@sre_ucount
  00215	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00218	eb 02		 jmp	 SHORT $LN57@sre_ucount
$LN56@sre_ucount:
  0021a	8b 0b		 mov	 ecx, DWORD PTR [rbx]
$LN57@sre_ucount:
  0021c	ff 96 00 07 00
	00		 call	 QWORD PTR [rsi+1792]
  00222	3b c5		 cmp	 eax, ebp
  00224	74 0c		 je	 SHORT $LN78@sre_ucount

; 551  :             ptr += state->charsize;

  00226	4c 63 4e 3c	 movsxd	 r9, DWORD PTR [rsi+60]
  0022a	49 03 d9	 add	 rbx, r9
  0022d	48 3b df	 cmp	 rbx, rdi
  00230	72 d2		 jb	 SHORT $LL7@sre_ucount
$LN78@sre_ucount:

; 567  :     }
; 568  : 
; 569  :     TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 570  :            (ptr - (char*) state->ptr)/state->charsize));
; 571  :     return (ptr - (char*) state->ptr)/state->charsize;

  00232	48 2b 1e	 sub	 rbx, QWORD PTR [rsi]
  00235	48 8b c3	 mov	 rax, rbx
  00238	eb 23		 jmp	 SHORT $LN79@sre_ucount
$LN66@sre_ucount:

; 552  :         break;
; 553  : 
; 554  :     default:
; 555  :         /* repeated single character pattern */
; 556  :         TRACE(("|%p|%p|COUNT SUBPATTERN\n", pattern, ptr));
; 557  :         while ((char*) state->ptr < end) {

  0023a	48 3b df	 cmp	 rbx, rdi
  0023d	73 18		 jae	 SHORT $LN68@sre_ucount
  0023f	90		 npad	 1
$LL4@sre_ucount:

; 558  :             i = SRE_MATCH(state, pattern);

  00240	48 8b d5	 mov	 rdx, rbp
  00243	48 8b ce	 mov	 rcx, rsi
  00246	e8 00 00 00 00	 call	 sre_umatch

; 559  :             if (i < 0)

  0024b	48 85 c0	 test	 rax, rax
  0024e	78 16		 js	 SHORT $LN28@sre_ucount

; 560  :                 return i;
; 561  :             if (!i)

  00250	74 05		 je	 SHORT $LN68@sre_ucount

; 552  :         break;
; 553  : 
; 554  :     default:
; 555  :         /* repeated single character pattern */
; 556  :         TRACE(("|%p|%p|COUNT SUBPATTERN\n", pattern, ptr));
; 557  :         while ((char*) state->ptr < end) {

  00252	48 39 3e	 cmp	 QWORD PTR [rsi], rdi
  00255	72 e9		 jb	 SHORT $LL4@sre_ucount
$LN68@sre_ucount:

; 562  :                 break;
; 563  :         }
; 564  :         TRACE(("|%p|%p|COUNT %" PY_FORMAT_SIZE_T "d\n", pattern, ptr,
; 565  :                ((char*)state->ptr - ptr)/state->charsize));
; 566  :         return ((char*)state->ptr - ptr)/state->charsize;

  00257	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0025a	48 2b c3	 sub	 rax, rbx
$LN79@sre_ucount:
  0025d	48 63 4e 3c	 movsxd	 rcx, DWORD PTR [rsi+60]
  00261	48 99		 cdq
  00263	48 f7 f9	 idiv	 rcx
$LN28@sre_ucount:

; 572  : }

  00266	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0026b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00270	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00275	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00279	5f		 pop	 rdi
  0027a	c3		 ret	 0
  0027b	90		 npad	 1
$LN77@sre_ucount:
  0027c	00 00 00 00	 DD	 $LN61@sre_ucount
  00280	00 00 00 00	 DD	 $LN18@sre_ucount
  00284	00 00 00 00	 DD	 $LN60@sre_ucount
  00288	00 00 00 00	 DD	 $LN17@sre_ucount
  0028c	00 00 00 00	 DD	 $LN14@sre_ucount
  00290	00 00 00 00	 DD	 $LN11@sre_ucount
  00294	00 00 00 00	 DD	 $LN8@sre_ucount
  00298	00 00 00 00	 DD	 $LN66@sre_ucount
$LN76@sre_ucount:
  0029c	00		 DB	 0
  0029d	01		 DB	 1
  0029e	07		 DB	 7
  0029f	07		 DB	 7
  002a0	07		 DB	 7
  002a1	07		 DB	 7
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	02		 DB	 2
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	03		 DB	 3
  002ae	04		 DB	 4
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	05		 DB	 5
  002b3	06		 DB	 6
sre_ucount ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0DC@DNNGCEHM@can?8t?5use?5a?5bytes?5pattern?5on?5a?5s@ ; `string'
PUBLIC	??_C@_0DC@EJGEMLIB@can?8t?5use?5a?5string?5pattern?5on?5a?5@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$state_init DD imagerel state_init
	DD	imagerel state_init+389
	DD	imagerel $unwind$state_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$state_init DD 0a1801H
	DD	0f6418H
	DD	0e5418H
	DD	0d3418H
	DD	0d0147218H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_0DC@DNNGCEHM@can?8t?5use?5a?5bytes?5pattern?5on?5a?5s@
CONST	SEGMENT
??_C@_0DC@DNNGCEHM@can?8t?5use?5a?5bytes?5pattern?5on?5a?5s@ DB 'can''t u'
	DB	'se a bytes pattern on a string-like object', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EJGEMLIB@can?8t?5use?5a?5string?5pattern?5on?5a?5@
CONST	SEGMENT
??_C@_0DC@EJGEMLIB@can?8t?5use?5a?5string?5pattern?5on?5a?5@ DB 'can''t u'
	DB	'se a string pattern on a bytes-like object', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT state_init
_TEXT	SEGMENT
charsize$ = 48
length$ = 56
logical_charsize$ = 96
state$ = 96
pattern$ = 104
string$ = 112
start$ = 120
end$ = 128
state_init PROC						; COMDAT

; 1739 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00018	4d 8b e8	 mov	 r13, r8
  0001b	4c 8b e2	 mov	 r12, rdx

; 1740 :     /* prepare state object */
; 1741 : 
; 1742 :     Py_ssize_t length;
; 1743 :     int logical_charsize, charsize;
; 1744 :     void* ptr;
; 1745 : 
; 1746 :     memset(state, 0, sizeof(SRE_STATE));

  0001e	33 d2		 xor	 edx, edx
  00020	41 b8 08 07 00
	00		 mov	 r8d, 1800		; 00000708H
  00026	49 8b f9	 mov	 rdi, r9
  00029	48 8b d9	 mov	 rbx, rcx
  0002c	e8 00 00 00 00	 call	 memset

; 1747 : 
; 1748 :     state->lastmark = -1;
; 1749 :     state->lastindex = -1;
; 1750 : 
; 1751 :     state->buffer.buf = NULL;

  00031	48 8d ab a8 06
	00 00		 lea	 rbp, QWORD PTR [rbx+1704]

; 1752 :     ptr = getstring(string, &length, &logical_charsize, &charsize, &state->buffer);

  00038	4c 8d 4c 24 30	 lea	 r9, QWORD PTR charsize$[rsp]
  0003d	4c 8d 44 24 60	 lea	 r8, QWORD PTR logical_charsize$[rsp]
  00042	48 8d 54 24 38	 lea	 rdx, QWORD PTR length$[rsp]
  00047	33 f6		 xor	 esi, esi
  00049	49 8b cd	 mov	 rcx, r13
  0004c	48 c7 43 48 ff
	ff ff ff	 mov	 QWORD PTR [rbx+72], -1
  00054	48 c7 43 40 ff
	ff ff ff	 mov	 QWORD PTR [rbx+64], -1
  0005c	48 89 75 00	 mov	 QWORD PTR [rbp], rsi
  00060	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00065	e8 00 00 00 00	 call	 getstring
  0006a	4c 8b d8	 mov	 r11, rax

; 1753 :     if (!ptr)

  0006d	48 85 c0	 test	 rax, rax
  00070	74 26		 je	 SHORT $err$23478

; 1754 :         goto err;
; 1755 : 
; 1756 :     if (logical_charsize == 1 && pattern->logical_charsize > 1) {

  00072	8b 54 24 60	 mov	 edx, DWORD PTR logical_charsize$[rsp]
  00076	83 fa 01	 cmp	 edx, 1
  00079	75 46		 jne	 SHORT $LN17@state_init
  0007b	41 39 94 24 a0
	00 00 00	 cmp	 DWORD PTR [r12+160], edx
  00083	7e 52		 jle	 SHORT $LN12@state_init

; 1757 :         PyErr_SetString(PyExc_TypeError,
; 1758 :                         "can't use a string pattern on a bytes-like object");

  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@EJGEMLIB@can?8t?5use?5a?5string?5pattern?5on?5a?5@
$LN19@state_init:

; 1762 :         PyErr_SetString(PyExc_TypeError,
; 1763 :                         "can't use a bytes pattern on a string-like object");

  0008c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00093	e8 00 00 00 00	 call	 PyErr_SetString
$err$23478:

; 1799 :   err:
; 1800 :     if (state->buffer.buf)

  00098	48 39 75 00	 cmp	 QWORD PTR [rbp], rsi
  0009c	74 08		 je	 SHORT $LN1@state_init

; 1801 :         PyBuffer_Release(&state->buffer);

  0009e	48 8b cd	 mov	 rcx, rbp
  000a1	e8 00 00 00 00	 call	 PyBuffer_Release
$LN1@state_init:

; 1802 :     return NULL;

  000a6	33 c0		 xor	 eax, eax
$LN15@state_init:

; 1803 : }

  000a8	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000ad	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  000b2	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  000b7	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000bb	41 5d		 pop	 r13
  000bd	41 5c		 pop	 r12
  000bf	5f		 pop	 rdi
  000c0	c3		 ret	 0
$LN17@state_init:

; 1759 :         goto err;
; 1760 :     }
; 1761 :     if (logical_charsize > 1 && pattern->logical_charsize == 1) {

  000c1	7e 14		 jle	 SHORT $LN12@state_init
  000c3	41 83 bc 24 a0
	00 00 00 01	 cmp	 DWORD PTR [r12+160], 1
  000cc	75 09		 jne	 SHORT $LN12@state_init

; 1762 :         PyErr_SetString(PyExc_TypeError,
; 1763 :                         "can't use a bytes pattern on a string-like object");

  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DNNGCEHM@can?8t?5use?5a?5bytes?5pattern?5on?5a?5s@
  000d5	eb b5		 jmp	 SHORT $LN19@state_init
$LN12@state_init:

; 1764 :         goto err;
; 1765 :     }
; 1766 : 
; 1767 :     /* adjust boundaries */
; 1768 :     if (start < 0)

  000d7	48 8b 44 24 38	 mov	 rax, QWORD PTR length$[rsp]
  000dc	48 85 ff	 test	 rdi, rdi
  000df	79 05		 jns	 SHORT $LN11@state_init

; 1769 :         start = 0;

  000e1	48 8b fe	 mov	 rdi, rsi
  000e4	eb 07		 jmp	 SHORT $LN9@state_init
$LN11@state_init:

; 1770 :     else if (start > length)

  000e6	48 3b f8	 cmp	 rdi, rax
  000e9	48 0f 4f f8	 cmovg	 rdi, rax
$LN9@state_init:

; 1771 :         start = length;
; 1772 : 
; 1773 :     if (end < 0)

  000ed	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR end$[rsp]
  000f5	48 85 c9	 test	 rcx, rcx
  000f8	78 0a		 js	 SHORT $LN6@state_init

; 1774 :         end = 0;
; 1775 :     else if (end > length)

  000fa	48 8b f1	 mov	 rsi, rcx
  000fd	48 3b c8	 cmp	 rcx, rax
  00100	48 0f 4f f0	 cmovg	 rsi, rax
$LN6@state_init:

; 1776 :         end = length;
; 1777 : 
; 1778 :     state->logical_charsize = logical_charsize;
; 1779 :     state->charsize = charsize;

  00104	48 63 44 24 30	 movsxd	 rax, DWORD PTR charsize$[rsp]
  00109	89 53 38	 mov	 DWORD PTR [rbx+56], edx

; 1780 : 
; 1781 :     state->beginning = ptr;

  0010c	4c 89 5b 08	 mov	 QWORD PTR [rbx+8], r11

; 1782 : 
; 1783 :     state->start = (void*) ((char*) ptr + start * state->charsize);

  00110	48 8b c8	 mov	 rcx, rax
  00113	89 43 3c	 mov	 DWORD PTR [rbx+60], eax
  00116	48 0f af c7	 imul	 rax, rdi
  0011a	49 03 c3	 add	 rax, r11
  0011d	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1784 :     state->end = (void*) ((char*) ptr + end * state->charsize);

  00121	48 0f af ce	 imul	 rcx, rsi
  00125	49 03 cb	 add	 rcx, r11
  00128	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 1785 : 
; 1786 :     Py_INCREF(string);

  0012c	49 8b cd	 mov	 rcx, r13
  0012f	e8 00 00 00 00	 call	 _Py_IncRef

; 1787 :     state->string = string;

  00134	4c 89 6b 20	 mov	 QWORD PTR [rbx+32], r13

; 1788 :     state->pos = start;

  00138	48 89 7b 28	 mov	 QWORD PTR [rbx+40], rdi

; 1789 :     state->endpos = end;

  0013c	48 89 73 30	 mov	 QWORD PTR [rbx+48], rsi

; 1790 : 
; 1791 :     if (pattern->flags & SRE_FLAG_LOCALE)

  00140	41 8b 84 24 90
	00 00 00	 mov	 eax, DWORD PTR [r12+144]
  00148	a8 04		 test	 al, 4
  0014a	74 16		 je	 SHORT $LN5@state_init

; 1792 :         state->lower = sre_lower_locale;

  0014c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:sre_lower_locale

; 1793 :     else if (pattern->flags & SRE_FLAG_UNICODE)

  00153	48 89 83 00 07
	00 00		 mov	 QWORD PTR [rbx+1792], rax

; 1794 :         state->lower = sre_lower_unicode;
; 1795 :     else
; 1796 :         state->lower = sre_lower;
; 1797 : 
; 1798 :     return string;

  0015a	49 8b c5	 mov	 rax, r13
  0015d	e9 46 ff ff ff	 jmp	 $LN15@state_init
$LN5@state_init:

; 1793 :     else if (pattern->flags & SRE_FLAG_UNICODE)

  00162	a8 20		 test	 al, 32			; 00000020H
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sre_lower_unicode
  0016b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:sre_lower
  00172	48 0f 45 c1	 cmovne	 rax, rcx
  00176	48 89 83 00 07
	00 00		 mov	 QWORD PTR [rbx+1792], rax

; 1794 :         state->lower = sre_lower_unicode;
; 1795 :     else
; 1796 :         state->lower = sre_lower;
; 1797 : 
; 1798 :     return string;

  0017d	49 8b c5	 mov	 rax, r13
  00180	e9 23 ff ff ff	 jmp	 $LN15@state_init
state_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@INBCANGJ@expected?5string?5or?5buffer?$AA@ ; `string'
PUBLIC	??_C@_0P@DHPONDMO@Buffer?5is?5NULL?$AA@		; `string'
PUBLIC	??_C@_0BF@IGOCMODN@buffer?5size?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BJ@DECHLKAL@buffer?5has?5negative?5size?$AA@ ; `string'
PUBLIC	??_C@_1EO@FGPOAJPL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ ; `string'
PUBLIC	??_C@_1DG@BDAGFJHI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@IIEKCCKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyObject_Size:PROC
EXTRN	_PyUnicode_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_sre.c
pdata	SEGMENT
$pdata$getstring DD imagerel getstring
	DD	imagerel getstring+509
	DD	imagerel $unwind$getstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$getstring DD imagerel getstring+509
	DD	imagerel getstring+662
	DD	imagerel $chain$1$getstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$getstring DD imagerel getstring+662
	DD	imagerel getstring+683
	DD	imagerel $chain$2$getstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$getstring DD imagerel getstring+683
	DD	imagerel getstring+688
	DD	imagerel $chain$3$getstring
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$getstring DD imagerel getstring+688
	DD	imagerel getstring+711
	DD	imagerel $chain$4$getstring
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$getstring DD 021H
	DD	imagerel getstring
	DD	imagerel getstring+509
	DD	imagerel $unwind$getstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$getstring DD 040021H
	DD	096400H
	DD	085400H
	DD	imagerel getstring
	DD	imagerel getstring+509
	DD	imagerel $unwind$getstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$getstring DD 021H
	DD	imagerel getstring
	DD	imagerel getstring+509
	DD	imagerel $unwind$getstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$getstring DD 040e21H
	DD	09640eH
	DD	085405H
	DD	imagerel getstring
	DD	imagerel getstring+509
	DD	imagerel $unwind$getstring
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getstring DD 081401H
	DD	0b7414H
	DD	0a3414H
	DD	0e0103214H
	DD	0c00cd00eH
xdata	ENDS
;	COMDAT ??_C@_0BK@INBCANGJ@expected?5string?5or?5buffer?$AA@
CONST	SEGMENT
??_C@_0BK@INBCANGJ@expected?5string?5or?5buffer?$AA@ DB 'expected string '
	DB	'or buffer', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DHPONDMO@Buffer?5is?5NULL?$AA@
CONST	SEGMENT
??_C@_0P@DHPONDMO@Buffer?5is?5NULL?$AA@ DB 'Buffer is NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IGOCMODN@buffer?5size?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BF@IGOCMODN@buffer?5size?5mismatch?$AA@ DB 'buffer size mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DECHLKAL@buffer?5has?5negative?5size?$AA@
CONST	SEGMENT
??_C@_0BJ@DECHLKAL@buffer?5has?5negative?5size?$AA@ DB 'buffer has negati'
	DB	've size', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@FGPOAJPL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
CONST	SEGMENT
??_C@_1EO@FGPOAJPL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	's', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ')'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@BDAGFJHI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@BDAGFJHI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@IIEKCCKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@IIEKCCKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 's', 00H, 't', 00H, 'r', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ')', 00H, 00H, 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT getstring
_TEXT	SEGMENT
string$ = 64
p_length$ = 72
p_logical_charsize$ = 80
p_charsize$ = 88
view$ = 96
getstring PROC						; COMDAT

; 1670 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1671 :     /* given a python object, return a data pointer, a length (in
; 1672 :        characters), and a character size.  return NULL if the object
; 1673 :        is not a string (or not compatible) */
; 1674 : 
; 1675 :     PyBufferProcs *buffer;
; 1676 :     Py_ssize_t size, bytes;
; 1677 :     int charsize;
; 1678 :     void* ptr;
; 1679 : 
; 1680 :     /* Unicode objects do not support the buffer API. So, get the data
; 1681 :        directly instead. */
; 1682 :     if (PyUnicode_Check(string)) {

  00014	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00018	4d 8b e1	 mov	 r12, r9
  0001b	4d 8b e8	 mov	 r13, r8
  0001e	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00028	4c 8b f2	 mov	 r14, rdx
  0002b	48 8b d9	 mov	 rbx, rcx
  0002e	0f 84 89 01 00
	00		 je	 $LN9@getstring

; 1683 :         if (PyUnicode_READY(string) == -1)

  00034	f6 41 70 80	 test	 BYTE PTR [rcx+112], 128	; 00000080H
  00038	75 0e		 jne	 SHORT $LN8@getstring
  0003a	e8 00 00 00 00	 call	 _PyUnicode_Ready
  0003f	83 f8 ff	 cmp	 eax, -1

; 1684 :             return NULL;

  00042	0f 84 7b 02 00
	00		 je	 $LN30@getstring
$LN8@getstring:

; 1685 :         ptr = PyUnicode_DATA(string);

  00048	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0004c	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00056	75 1a		 jne	 SHORT $LN15@getstring
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IIEKCCKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
  00066	41 b8 95 06 00
	00		 mov	 r8d, 1685		; 00000695H
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN15@getstring:
  00072	f6 43 70 20	 test	 BYTE PTR [rbx+112], 32	; 00000020H
  00076	74 62		 je	 SHORT $LN21@getstring
  00078	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0007c	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00086	75 1a		 jne	 SHORT $LN16@getstring
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IIEKCCKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
  00096	41 b8 95 06 00
	00		 mov	 r8d, 1685		; 00000695H
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN16@getstring:
  000a2	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  000a6	75 1a		 jne	 SHORT $LN17@getstring
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@BDAGFJHI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
  000b6	41 b8 95 06 00
	00		 mov	 r8d, 1685		; 00000695H
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN17@getstring:
  000c2	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H
  000c6	74 09		 je	 SHORT $LN18@getstring
  000c8	48 8d bb 80 00
	00 00		 lea	 rdi, QWORD PTR [rbx+128]
  000cf	eb 34		 jmp	 SHORT $LN22@getstring
$LN18@getstring:
  000d1	48 8d bb a0 00
	00 00		 lea	 rdi, QWORD PTR [rbx+160]
  000d8	eb 2b		 jmp	 SHORT $LN22@getstring
$LN21@getstring:
  000da	48 83 bb a0 00
	00 00 00	 cmp	 QWORD PTR [rbx+160], 0
  000e2	75 1a		 jne	 SHORT $LN20@getstring
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@FGPOAJPL@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  000f2	41 b8 95 06 00
	00		 mov	 r8d, 1685		; 00000695H
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN20@getstring:
  000fe	48 8b bb a0 00
	00 00		 mov	 rdi, QWORD PTR [rbx+160]
$LN22@getstring:

; 1686 :         *p_length = PyUnicode_GET_LENGTH(string);

  00105	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00109	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00113	75 1a		 jne	 SHORT $LN23@getstring
  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@
  0011c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IIEKCCKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
  00123	41 b8 96 06 00
	00		 mov	 r8d, 1686		; 00000696H
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN23@getstring:
  0012f	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00133	75 1a		 jne	 SHORT $LN24@getstring
  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@BDAGFJHI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
  00143	41 b8 96 06 00
	00		 mov	 r8d, 1686		; 00000696H
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN24@getstring:
  0014f	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00153	49 89 06	 mov	 QWORD PTR [r14], rax

; 1687 :         *p_charsize = PyUnicode_KIND(string);

  00156	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0015a	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00164	75 1a		 jne	 SHORT $LN25@getstring
  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@IIEKCCKC@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
  00174	41 b8 97 06 00
	00		 mov	 r8d, 1687		; 00000697H
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN25@getstring:
  00180	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00184	75 1a		 jne	 SHORT $LN26@getstring
  00186	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1EC@FLAHCDBH@?$AAc?$AA?3?$AA?2?$AAs?$AAr?$AAc?$AA?2?$AAp?$AAy?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA?2?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AA_?$AAs?$AAr?$AAe?$AA?4?$AAc@
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@BDAGFJHI@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?$CJ?$AA?$AA@
  00194	41 b8 97 06 00
	00		 mov	 r8d, 1687		; 00000697H
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN26@getstring:
  001a0	8b 4b 70	 mov	 ecx, DWORD PTR [rbx+112]

; 1688 :         *p_logical_charsize = 4;
; 1689 :         return ptr;

  001a3	48 8b c7	 mov	 rax, rdi
  001a6	c1 e9 02	 shr	 ecx, 2
  001a9	83 e1 07	 and	 ecx, 7
  001ac	41 89 0c 24	 mov	 DWORD PTR [r12], ecx
  001b0	41 c7 45 00 04
	00 00 00	 mov	 DWORD PTR [r13], 4
  001b8	e9 d9 00 00 00	 jmp	 $LN10@getstring
$LN9@getstring:

; 1690 :     }
; 1691 : 
; 1692 :     /* get pointer to byte string buffer */
; 1693 :     view->len = -1;

  001bd	48 8b 7c 24 60	 mov	 rdi, QWORD PTR view$[rsp]
  001c2	48 c7 47 10 ff
	ff ff ff	 mov	 QWORD PTR [rdi+16], -1

; 1694 :     buffer = Py_TYPE(string)->tp_as_buffer;

  001ca	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  001ce	48 8b 88 f8 00
	00 00		 mov	 rcx, QWORD PTR [rax+248]

; 1695 :     if (!buffer || !buffer->bf_getbuffer ||
; 1696 :         (*buffer->bf_getbuffer)(string, view, PyBUF_SIMPLE) < 0) {

  001d5	48 85 c9	 test	 rcx, rcx
  001d8	0f 84 d2 00 00
	00		 je	 $LN6@getstring
  001de	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001e1	48 85 c0	 test	 rax, rax
  001e4	0f 84 c6 00 00
	00		 je	 $LN6@getstring
  001ea	45 33 c0	 xor	 r8d, r8d
  001ed	48 8b d7	 mov	 rdx, rdi
  001f0	48 8b cb	 mov	 rcx, rbx
  001f3	ff d0		 call	 rax
  001f5	85 c0		 test	 eax, eax
  001f7	0f 88 b3 00 00
	00		 js	 $LN6@getstring

; 1699 :     }
; 1700 : 
; 1701 :     /* determine buffer size */
; 1702 :     bytes = view->len;

  001fd	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00202	48 8b 6f 10	 mov	 rbp, QWORD PTR [rdi+16]
  00206	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 1703 :     ptr = view->buf;

  0020b	48 8b 37	 mov	 rsi, QWORD PTR [rdi]

; 1704 : 
; 1705 :     if (bytes < 0) {

  0020e	48 85 ed	 test	 rbp, rbp
  00211	79 10		 jns	 SHORT $LN5@getstring

; 1706 :         PyErr_SetString(PyExc_TypeError, "buffer has negative size");

  00213	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0021a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@DECHLKAL@buffer?5has?5negative?5size?$AA@

; 1707 :         goto err;

  00221	eb 53		 jmp	 SHORT $LN29@getstring
$LN5@getstring:

; 1708 :     }
; 1709 : 
; 1710 :     /* determine character size */
; 1711 :     size = PyObject_Size(string);

  00223	48 8b cb	 mov	 rcx, rbx
  00226	e8 00 00 00 00	 call	 PyObject_Size

; 1712 : 
; 1713 :     if (PyBytes_Check(string) || bytes == size)

  0022b	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0022f	f7 81 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rcx+256], 134217728 ; 08000000H
  00239	75 15		 jne	 SHORT $LN3@getstring
  0023b	48 3b e8	 cmp	 rbp, rax
  0023e	74 10		 je	 SHORT $LN3@getstring

; 1714 :         charsize = 1;
; 1715 :     else {
; 1716 :         PyErr_SetString(PyExc_TypeError, "buffer size mismatch");

  00240	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00247	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@IGOCMODN@buffer?5size?5mismatch?$AA@

; 1717 :         goto err;

  0024e	eb 26		 jmp	 SHORT $LN29@getstring
$LN3@getstring:

; 1718 :     }
; 1719 : 
; 1720 :     *p_length = size;

  00250	49 89 06	 mov	 QWORD PTR [r14], rax

; 1721 :     *p_charsize = charsize;

  00253	41 c7 04 24 01
	00 00 00	 mov	 DWORD PTR [r12], 1

; 1722 :     *p_logical_charsize = charsize;

  0025b	41 c7 45 00 01
	00 00 00	 mov	 DWORD PTR [r13], 1

; 1723 : 
; 1724 :     if (ptr == NULL) {

  00263	48 85 f6	 test	 rsi, rsi
  00266	75 43		 jne	 SHORT $LN1@getstring

; 1725 :             PyErr_SetString(PyExc_ValueError,
; 1726 :                             "Buffer is NULL");

  00268	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0026f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@DHPONDMO@Buffer?5is?5NULL?$AA@
$LN29@getstring:
  00276	e8 00 00 00 00	 call	 PyErr_SetString

; 1730 :   err:
; 1731 :     PyBuffer_Release(view);

  0027b	48 8b cf	 mov	 rcx, rdi
$err$23448:
  0027e	e8 00 00 00 00	 call	 PyBuffer_Release

; 1732 :     view->buf = NULL;

  00283	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0

; 1733 :     return NULL;

  0028a	33 c0		 xor	 eax, eax
$LN28@getstring:
  0028c	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00291	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
$LN10@getstring:

; 1734 : }

  00296	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0029b	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  002a0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002a4	41 5e		 pop	 r14
  002a6	41 5d		 pop	 r13
  002a8	41 5c		 pop	 r12
  002aa	c3		 ret	 0
$LN1@getstring:

; 1727 :             goto err;
; 1728 :     }
; 1729 :     return ptr;

  002ab	48 8b c6	 mov	 rax, rsi
  002ae	eb dc		 jmp	 SHORT $LN28@getstring
$LN6@getstring:

; 1697 :             PyErr_SetString(PyExc_TypeError, "expected string or buffer");

  002b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@INBCANGJ@expected?5string?5or?5buffer?$AA@
  002be	e8 00 00 00 00	 call	 PyErr_SetString
$LN30@getstring:

; 1698 :             return NULL;

  002c3	33 c0		 xor	 eax, eax
  002c5	eb cf		 jmp	 SHORT $LN10@getstring
getstring ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$state_fini DD imagerel state_fini
	DD	imagerel state_fini+54
	DD	imagerel $unwind$state_fini
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$state_fini DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT state_fini
_TEXT	SEGMENT
state$ = 48
state_fini PROC						; COMDAT

; 1807 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1808 :     if (state->buffer.buf)

  00009	48 81 c1 a8 06
	00 00		 add	 rcx, 1704		; 000006a8H
  00010	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00014	74 05		 je	 SHORT $LN4@state_fini

; 1809 :         PyBuffer_Release(&state->buffer);

  00016	e8 00 00 00 00	 call	 PyBuffer_Release
$LN4@state_fini:

; 1810 :     Py_XDECREF(state->string);

  0001b	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  0001f	48 85 c9	 test	 rcx, rcx
  00022	74 05		 je	 SHORT $LN3@state_fini
  00024	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@state_fini:

; 1811 :     data_stack_dealloc(state);

  00029	48 8b cb	 mov	 rcx, rbx

; 1812 : }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	e9 00 00 00 00	 jmp	 data_stack_dealloc
state_fini ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@HKAPAGAG@O?$HMnn?3search?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_search DD imagerel pattern_search
	DD	imagerel pattern_search+166
	DD	imagerel $unwind$pattern_search
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_search DD imagerel pattern_search+166
	DD	imagerel pattern_search+244
	DD	imagerel $chain$0$pattern_search
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pattern_search DD imagerel pattern_search+244
	DD	imagerel pattern_search+277
	DD	imagerel $chain$2$pattern_search
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pattern_search DD 020021H
	DD	0ee7400H
	DD	imagerel pattern_search
	DD	imagerel pattern_search+166
	DD	imagerel $unwind$pattern_search
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_search DD 020821H
	DD	0ee7408H
	DD	imagerel pattern_search
	DD	imagerel pattern_search+166
	DD	imagerel $unwind$pattern_search
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_search DD 030b01H
	DD	0ec010bH
	DD	03004H
xdata	ENDS
;	COMDAT ??_C@_0M@HKAPAGAG@O?$HMnn?3search?$AA@
CONST	SEGMENT
??_C@_0M@HKAPAGAG@O?$HMnn?3search?$AA@ DB 'O|nn:search', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT pattern_search
_TEXT	SEGMENT
string$ = 64
start$ = 72
state$ = 80
self$ = 1904
args$ = 1912
kw$ = 1920
end$ = 1928
pattern_search PROC					; COMDAT

; 1918 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 81 ec 60 07
	00 00		 sub	 rsp, 1888		; 00000760H
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	49 8b c0	 mov	 rax, r8
  00011	4c 8b d2	 mov	 r10, rdx

; 1919 :     SRE_STATE state;
; 1920 :     int status;
; 1921 : 
; 1922 :     PyObject* string;
; 1923 :     Py_ssize_t start = 0;
; 1924 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  00014	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH

; 1925 :     static char* kwlist[] = { "pattern", "pos", "endpos", NULL };
; 1926 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "O|nn:search", kwlist,
; 1927 :                                      &string, &start, &end))

  0001e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_search@@9@9
  00025	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@HKAPAGAG@O?$HMnn?3search?$AA@
  0002c	49 89 4b 20	 mov	 QWORD PTR [r11+32], rcx
  00030	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00034	48 8b d0	 mov	 rdx, rax
  00037	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003c	48 8d 4c 24 48	 lea	 rcx, QWORD PTR start$[rsp]
  00041	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
  0004a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR string$[rsp]
  00054	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00059	49 8b ca	 mov	 rcx, r10
  0005c	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00061	85 c0		 test	 eax, eax
  00063	75 0b		 jne	 SHORT $LN5@pattern_se
$LN9@pattern_se:

; 1928 :         return NULL;

  00065	33 c0		 xor	 eax, eax

; 1950 : }

  00067	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  0006e	5b		 pop	 rbx
  0006f	c3		 ret	 0
$LN5@pattern_se:

; 1929 : 
; 1930 :     string = state_init(&state, self, string, start, end);

  00070	48 8b 84 24 88
	07 00 00	 mov	 rax, QWORD PTR end$[rsp]
  00078	4c 8b 4c 24 48	 mov	 r9, QWORD PTR start$[rsp]
  0007d	4c 8b 44 24 40	 mov	 r8, QWORD PTR string$[rsp]
  00082	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  00087	48 8b d3	 mov	 rdx, rbx
  0008a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008f	e8 00 00 00 00	 call	 state_init
  00094	48 89 44 24 40	 mov	 QWORD PTR string$[rsp], rax

; 1931 :     if (!string)

  00099	48 85 c0	 test	 rax, rax

; 1932 :         return NULL;

  0009c	74 c7		 je	 SHORT $LN9@pattern_se

; 1933 : 
; 1934 :     TRACE(("|%p|%p|SEARCH\n", PatternObject_GetCode(self), state.ptr));
; 1935 : 
; 1936 :     if (state.logical_charsize == 1) {

  0009e	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR state$[rsp+56], 1
  000a6	48 89 bc 24 70
	07 00 00	 mov	 QWORD PTR [rsp+1904], rdi

; 1937 :         status = sre_search(&state, PatternObject_GetCode(self));

  000ae	48 8d 93 00 01
	00 00		 lea	 rdx, QWORD PTR [rbx+256]
  000b5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  000ba	75 0a		 jne	 SHORT $LN3@pattern_se
  000bc	e8 00 00 00 00	 call	 sre_search
  000c1	48 8b f8	 mov	 rdi, rax

; 1938 :     } else {

  000c4	eb 07		 jmp	 SHORT $LN2@pattern_se
$LN3@pattern_se:

; 1939 :         status = sre_usearch(&state, PatternObject_GetCode(self));

  000c6	e8 00 00 00 00	 call	 sre_usearch
  000cb	8b f8		 mov	 edi, eax
$LN2@pattern_se:

; 1940 :     }
; 1941 : 
; 1942 :     TRACE(("|%p|%p|END\n", PatternObject_GetCode(self), state.ptr));
; 1943 : 
; 1944 :     state_fini(&state);

  000cd	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  000d2	e8 00 00 00 00	 call	 state_fini

; 1945 : 
; 1946 :     if (PyErr_Occurred())

  000d7	e8 00 00 00 00	 call	 PyErr_Occurred
  000dc	48 85 c0	 test	 rax, rax
  000df	74 13		 je	 SHORT $LN1@pattern_se

; 1947 :         return NULL;

  000e1	33 c0		 xor	 eax, eax
  000e3	48 8b bc 24 70
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1904]

; 1950 : }

  000eb	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  000f2	5b		 pop	 rbx
  000f3	c3		 ret	 0
$LN1@pattern_se:

; 1948 : 
; 1949 :     return pattern_new_match(self, &state, status);

  000f4	48 8d 54 24 50	 lea	 rdx, QWORD PTR state$[rsp]
  000f9	44 8b c7	 mov	 r8d, edi
  000fc	48 8b cb	 mov	 rcx, rbx
  000ff	e8 00 00 00 00	 call	 pattern_new_match
  00104	48 8b bc 24 70
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1904]

; 1950 : }

  0010c	48 81 c4 60 07
	00 00		 add	 rsp, 1888		; 00000760H
  00113	5b		 pop	 rbx
  00114	c3		 ret	 0
pattern_search ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_search DD imagerel sre_search
	DD	imagerel sre_search+655
	DD	imagerel $unwind$sre_search
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_search DD 091501H
	DD	0f0114215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT sre_search
_TEXT	SEGMENT
flags$1$ = 112
state$ = 112
pattern$ = 120
prefix_len$1$ = 128
prefix_skip$1$ = 136
sre_search PROC						; COMDAT

; 1477 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1478 :     char* ptr = (char*)state->start;
; 1479 :     char* end = (char*)state->end;

  00015	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  00019	48 8b 59 10	 mov	 rbx, QWORD PTR [rcx+16]

; 1480 :     Py_ssize_t status = 0;

  0001d	33 f6		 xor	 esi, esi

; 1481 :     Py_ssize_t prefix_len = 0;
; 1482 :     Py_ssize_t prefix_skip = 0;
; 1483 :     SRE_CODE* prefix = NULL;
; 1484 :     SRE_CODE* charset = NULL;
; 1485 :     SRE_CODE* overlap = NULL;
; 1486 :     int flags = 0;
; 1487 : 
; 1488 :     if (pattern[0] == SRE_OP_INFO) {

  0001f	83 3a 11	 cmp	 DWORD PTR [rdx], 17
  00022	4c 8b c2	 mov	 r8, rdx
  00025	48 8b f9	 mov	 rdi, rcx
  00028	4c 8b ed	 mov	 r13, rbp
  0002b	44 8b ce	 mov	 r9d, esi
  0002e	48 89 b4 24 80
	00 00 00	 mov	 QWORD PTR prefix_len$1$[rsp], rsi
  00036	44 8b d6	 mov	 r10d, esi
  00039	48 89 b4 24 88
	00 00 00	 mov	 QWORD PTR prefix_skip$1$[rsp], rsi
  00041	44 8b f6	 mov	 r14d, esi
  00044	44 8b e6	 mov	 r12d, esi
  00047	44 8b fe	 mov	 r15d, esi
  0004a	44 8b de	 mov	 r11d, esi
  0004d	89 74 24 70	 mov	 DWORD PTR flags$1$[rsp], esi
  00051	0f 85 2a 01 00
	00		 jne	 $LN32@sre_search

; 1489 :         /* optimization info block */
; 1490 :         /* <INFO> <1=skip> <2=flags> <3=min> <4=max> <5=prefix info>  */
; 1491 : 
; 1492 :         flags = pattern[2];
; 1493 : 
; 1494 :         if (pattern[3] > 1) {

  00057	8b 42 0c	 mov	 eax, DWORD PTR [rdx+12]
  0005a	44 8b 5a 08	 mov	 r11d, DWORD PTR [rdx+8]
  0005e	44 89 5c 24 70	 mov	 DWORD PTR flags$1$[rsp], r11d
  00063	83 f8 01	 cmp	 eax, 1
  00066	76 15		 jbe	 SHORT $LN36@sre_search

; 1495 :             /* adjust end point (but make sure we leave at least one
; 1496 :                character in there, so literal search will work) */
; 1497 :             end -= (pattern[3]-1) * state->charsize;

  00068	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  0006c	ff c8		 dec	 eax
  0006e	0f af c1	 imul	 eax, ecx
  00071	4c 2b e8	 sub	 r13, rax

; 1498 :             if (end <= ptr)

  00074	4c 3b eb	 cmp	 r13, rbx
  00077	77 04		 ja	 SHORT $LN36@sre_search

; 1499 :                 end = ptr + state->charsize;

  00079	4c 8d 2c 0b	 lea	 r13, QWORD PTR [rbx+rcx]
$LN36@sre_search:

; 1500 :         }
; 1501 : 
; 1502 :         if (flags & SRE_INFO_PREFIX) {

  0007d	41 f6 c3 01	 test	 r11b, 1
  00081	74 23		 je	 SHORT $LN35@sre_search

; 1503 :             /* pattern starts with a known prefix */
; 1504 :             /* <length> <skip> <prefix data> <overlap data> */
; 1505 :             prefix_len = pattern[5];

  00083	44 8b 4a 14	 mov	 r9d, DWORD PTR [rdx+20]

; 1506 :             prefix_skip = pattern[6];

  00087	44 8b 52 18	 mov	 r10d, DWORD PTR [rdx+24]

; 1507 :             prefix = pattern + 7;

  0008b	4c 8d 72 1c	 lea	 r14, QWORD PTR [rdx+28]
  0008f	4c 89 8c 24 80
	00 00 00	 mov	 QWORD PTR prefix_len$1$[rsp], r9
  00097	4c 89 94 24 88
	00 00 00	 mov	 QWORD PTR prefix_skip$1$[rsp], r10

; 1508 :             overlap = prefix + prefix_len - 1;

  0009f	4f 8d 7c 8e fc	 lea	 r15, QWORD PTR [r14+r9*4-4]
  000a4	eb 0a		 jmp	 SHORT $LN33@sre_search
$LN35@sre_search:

; 1509 :         } else if (flags & SRE_INFO_CHARSET)

  000a6	41 f6 c3 04	 test	 r11b, 4
  000aa	74 04		 je	 SHORT $LN33@sre_search

; 1510 :             /* pattern starts with a character from a known set */
; 1511 :             /* <charset> */
; 1512 :             charset = pattern + 5;

  000ac	4c 8d 62 14	 lea	 r12, QWORD PTR [rdx+20]
$LN33@sre_search:

; 1513 : 
; 1514 :         pattern += 1 + pattern[1];

  000b0	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  000b3	ff c0		 inc	 eax
  000b5	4c 8d 04 82	 lea	 r8, QWORD PTR [rdx+rax*4]
  000b9	4c 89 44 24 78	 mov	 QWORD PTR pattern$[rsp], r8

; 1515 :     }
; 1516 : 
; 1517 :     TRACE(("prefix = %p %" PY_FORMAT_SIZE_T "d %" PY_FORMAT_SIZE_T "d\n",
; 1518 :            prefix, prefix_len, prefix_skip));
; 1519 :     TRACE(("charset = %p\n", charset));
; 1520 : 
; 1521 : #if defined(USE_FAST_SEARCH)
; 1522 :     if (prefix_len > 1) {

  000be	49 83 f9 01	 cmp	 r9, 1
  000c2	0f 8e b9 00 00
	00		 jle	 $LN32@sre_search

; 1523 :         /* pattern starts with a known prefix.  use the overlap
; 1524 :            table to skip forward as fast as we possibly can */
; 1525 :         Py_ssize_t i = 0;
; 1526 :         end = (char *)state->end;
; 1527 :         while (ptr < end) {

  000c8	48 3b dd	 cmp	 rbx, rbp
  000cb	0f 83 d8 00 00
	00		 jae	 $LN62@sre_search
$LL31@sre_search:

; 1528 :             for (;;) {
; 1529 :                 if ((SRE_CODE) SRE_CHARGET(state, ptr, 0) != prefix[i]) {

  000d1	0f b6 0b	 movzx	 ecx, BYTE PTR [rbx]
  000d4	48 8d 04 b5 00
	00 00 00	 lea	 rax, QWORD PTR [rsi*4]
  000dc	42 3b 0c 30	 cmp	 ecx, DWORD PTR [rax+r14]
  000e0	74 17		 je	 SHORT $LN27@sre_search
$LL29@sre_search:

; 1530 :                     if (!i)

  000e2	48 85 f6	 test	 rsi, rsi
  000e5	74 77		 je	 SHORT $LN23@sre_search

; 1531 :                         break;
; 1532 :                     else
; 1533 :                         i = overlap[i];

  000e7	42 8b 34 38	 mov	 esi, DWORD PTR [rax+r15]
  000eb	48 8d 04 b5 00
	00 00 00	 lea	 rax, QWORD PTR [rsi*4]
  000f3	42 3b 0c 30	 cmp	 ecx, DWORD PTR [rax+r14]
  000f7	75 e9		 jne	 SHORT $LL29@sre_search
$LN27@sre_search:

; 1534 :                 } else {
; 1535 :                     if (++i == prefix_len) {

  000f9	48 ff c6	 inc	 rsi
  000fc	49 3b f1	 cmp	 rsi, r9
  000ff	75 5d		 jne	 SHORT $LN23@sre_search

; 1536 :                         /* found a potential match */
; 1537 :                         TRACE(("|%p|%p|SEARCH SCAN\n", pattern, ptr));
; 1538 :                         state->start = ptr - (prefix_len - 1) * state->charsize;

  00101	48 63 57 3c	 movsxd	 rdx, DWORD PTR [rdi+60]
  00105	49 8d 49 ff	 lea	 rcx, QWORD PTR [r9-1]
  00109	48 8b c3	 mov	 rax, rbx
  0010c	48 0f af ca	 imul	 rcx, rdx
  00110	48 2b c1	 sub	 rax, rcx

; 1539 :                         state->ptr = ptr - (prefix_len - prefix_skip - 1) * state->charsize;

  00113	49 8b c9	 mov	 rcx, r9
  00116	49 2b ca	 sub	 rcx, r10
  00119	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  0011d	48 8b c3	 mov	 rax, rbx
  00120	48 ff c9	 dec	 rcx
  00123	48 0f af ca	 imul	 rcx, rdx
  00127	48 2b c1	 sub	 rax, rcx
  0012a	48 89 07	 mov	 QWORD PTR [rdi], rax

; 1540 :                         if (flags & SRE_INFO_LITERAL)

  0012d	41 f6 c3 02	 test	 r11b, 2
  00131	75 44		 jne	 SHORT $LN49@sre_search

; 1542 :                         status = SRE_MATCH(state, pattern + 2*prefix_skip);

  00133	4b 8d 14 d0	 lea	 rdx, QWORD PTR [r8+r10*8]
  00137	48 8b cf	 mov	 rcx, rdi
  0013a	e8 00 00 00 00	 call	 sre_match

; 1543 :                         if (status != 0)

  0013f	48 85 c0	 test	 rax, rax
  00142	0f 85 36 01 00
	00		 jne	 $LN39@sre_search

; 1544 :                             return status;
; 1545 :                         /* close but no cigar -- try again */
; 1546 :                         i = overlap[i];

  00148	41 8b 34 b7	 mov	 esi, DWORD PTR [r15+rsi*4]
  0014c	4c 8b 44 24 78	 mov	 r8, QWORD PTR pattern$[rsp]
  00151	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR prefix_len$1$[rsp]
  00159	44 8b 5c 24 70	 mov	 r11d, DWORD PTR flags$1$[rsp]
$LN23@sre_search:

; 1547 :                     }
; 1548 :                     break;
; 1549 :                 }
; 1550 :             }
; 1551 :             ptr += state->charsize;

  0015e	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  00162	48 03 d8	 add	 rbx, rax
  00165	48 3b dd	 cmp	 rbx, rbp
  00168	73 3f		 jae	 SHORT $LN62@sre_search

; 1523 :         /* pattern starts with a known prefix.  use the overlap
; 1524 :            table to skip forward as fast as we possibly can */
; 1525 :         Py_ssize_t i = 0;
; 1526 :         end = (char *)state->end;
; 1527 :         while (ptr < end) {

  0016a	4c 8b 94 24 88
	00 00 00	 mov	 r10, QWORD PTR prefix_skip$1$[rsp]
  00172	e9 5a ff ff ff	 jmp	 $LL31@sre_search
$LN49@sre_search:

; 1541 :                             return 1; /* we got all of it */

  00177	b8 01 00 00 00	 mov	 eax, 1
  0017c	e9 fd 00 00 00	 jmp	 $LN39@sre_search
$LN32@sre_search:

; 1554 :     }
; 1555 : #endif
; 1556 : 
; 1557 :     if (pattern[0] == SRE_OP_LITERAL) {

  00181	41 83 38 13	 cmp	 DWORD PTR [r8], 19
  00185	75 66		 jne	 SHORT $LN20@sre_search

; 1558 :         /* pattern starts with a literal character.  this is used
; 1559 :            for short prefixes, and if fast search is disabled */
; 1560 :         SRE_CODE chr = pattern[1];

  00187	45 8b 60 04	 mov	 r12d, DWORD PTR [r8+4]
  0018b	0f 1f 44 00 00	 npad	 5
$LL19@sre_search:

; 1561 :         end = (char*)state->end;
; 1562 :         for (;;) {
; 1563 :             while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) != chr)

  00190	48 3b dd	 cmp	 rbx, rbp
  00193	73 14		 jae	 SHORT $LN62@sre_search
$LL17@sre_search:
  00195	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  00198	41 3b c4	 cmp	 eax, r12d
  0019b	74 13		 je	 SHORT $LN16@sre_search

; 1564 :                 ptr += state->charsize;

  0019d	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  001a1	48 03 d8	 add	 rbx, rax
  001a4	48 3b dd	 cmp	 rbx, rbp
  001a7	72 ec		 jb	 SHORT $LL17@sre_search
$LN62@sre_search:

; 1552 :         }
; 1553 :         return 0;

  001a9	33 c0		 xor	 eax, eax
  001ab	e9 ce 00 00 00	 jmp	 $LN39@sre_search
$LN16@sre_search:

; 1565 :             if (ptr >= end)

  001b0	48 3b dd	 cmp	 rbx, rbp
  001b3	73 f4		 jae	 SHORT $LN62@sre_search

; 1566 :                 return 0;
; 1567 :             TRACE(("|%p|%p|SEARCH LITERAL\n", pattern, ptr));
; 1568 :             state->start = ptr;
; 1569 :             ptr += state->charsize;

  001b5	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  001b9	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx
  001bd	48 03 d8	 add	 rbx, rax

; 1570 :             state->ptr = ptr;

  001c0	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 1571 :             if (flags & SRE_INFO_LITERAL)

  001c3	41 f6 c3 02	 test	 r11b, 2
  001c7	75 ae		 jne	 SHORT $LN49@sre_search

; 1572 :                 return 1; /* we got all of it */
; 1573 :             status = SRE_MATCH(state, pattern + 2);

  001c9	49 8d 50 08	 lea	 rdx, QWORD PTR [r8+8]
  001cd	48 8b cf	 mov	 rcx, rdi
  001d0	e8 00 00 00 00	 call	 sre_match
  001d5	48 8b f0	 mov	 rsi, rax

; 1574 :             if (status != 0)

  001d8	48 85 c0	 test	 rax, rax
  001db	0f 85 9a 00 00
	00		 jne	 $LN63@sre_search

; 1575 :                 break;
; 1576 :         }

  001e1	4c 8b 44 24 78	 mov	 r8, QWORD PTR pattern$[rsp]
  001e6	44 8b 5c 24 70	 mov	 r11d, DWORD PTR flags$1$[rsp]
  001eb	eb a3		 jmp	 SHORT $LL19@sre_search
$LN20@sre_search:

; 1577 :     } else if (charset) {

  001ed	4d 85 e4	 test	 r12, r12
  001f0	74 55		 je	 SHORT $LN47@sre_search
  001f2	4c 8b 6c 24 78	 mov	 r13, QWORD PTR pattern$[rsp]
$LL10@sre_search:

; 1578 :         /* pattern starts with a character from a known set */
; 1579 :         end = (char*)state->end;
; 1580 :         for (;;) {
; 1581 :             while (ptr < end && !SRE_CHARSET(charset, SRE_CHARGET(state, ptr, 0)))

  001f7	48 3b dd	 cmp	 rbx, rbp
  001fa	73 ad		 jae	 SHORT $LN62@sre_search
  001fc	0f 1f 40 00	 npad	 4
$LL8@sre_search:
  00200	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  00203	49 8b cc	 mov	 rcx, r12
  00206	e8 00 00 00 00	 call	 sre_charset
  0020b	85 c0		 test	 eax, eax
  0020d	75 10		 jne	 SHORT $LN7@sre_search

; 1582 :                 ptr += state->charsize;

  0020f	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  00213	48 03 d8	 add	 rbx, rax
  00216	48 3b dd	 cmp	 rbx, rbp
  00219	72 e5		 jb	 SHORT $LL8@sre_search

; 1552 :         }
; 1553 :         return 0;

  0021b	33 c0		 xor	 eax, eax
  0021d	eb 5f		 jmp	 SHORT $LN39@sre_search
$LN7@sre_search:

; 1583 :             if (ptr >= end)

  0021f	48 3b dd	 cmp	 rbx, rbp
  00222	73 85		 jae	 SHORT $LN62@sre_search

; 1584 :                 return 0;
; 1585 :             TRACE(("|%p|%p|SEARCH CHARSET\n", pattern, ptr));
; 1586 :             state->start = ptr;
; 1587 :             state->ptr = ptr;
; 1588 :             status = SRE_MATCH(state, pattern);

  00224	49 8b d5	 mov	 rdx, r13
  00227	48 8b cf	 mov	 rcx, rdi
  0022a	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx
  0022e	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00231	e8 00 00 00 00	 call	 sre_match
  00236	48 8b f0	 mov	 rsi, rax

; 1589 :             if (status != 0)

  00239	48 85 c0	 test	 rax, rax
  0023c	75 3d		 jne	 SHORT $LN63@sre_search

; 1590 :                 break;
; 1591 :             ptr += state->charsize;

  0023e	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  00242	48 03 d8	 add	 rbx, rax

; 1592 :         }

  00245	eb b0		 jmp	 SHORT $LL10@sre_search
$LN47@sre_search:

; 1593 :     } else
; 1594 :         /* general case */
; 1595 :         while (ptr <= end) {

  00247	49 3b dd	 cmp	 rbx, r13
  0024a	77 2f		 ja	 SHORT $LN63@sre_search
  0024c	0f 1f 40 00	 npad	 4
$LL3@sre_search:

; 1596 :             TRACE(("|%p|%p|SEARCH\n", pattern, ptr));
; 1597 :             state->start = state->ptr = ptr;
; 1598 :             ptr += state->charsize;

  00250	48 63 47 3c	 movsxd	 rax, DWORD PTR [rdi+60]
  00254	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00257	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx

; 1599 :             status = SRE_MATCH(state, pattern);

  0025b	49 8b d0	 mov	 rdx, r8
  0025e	48 8b cf	 mov	 rcx, rdi
  00261	48 03 d8	 add	 rbx, rax
  00264	e8 00 00 00 00	 call	 sre_match
  00269	48 8b f0	 mov	 rsi, rax

; 1600 :             if (status != 0)

  0026c	48 85 c0	 test	 rax, rax
  0026f	75 0a		 jne	 SHORT $LN63@sre_search

; 1593 :     } else
; 1594 :         /* general case */
; 1595 :         while (ptr <= end) {

  00271	4c 8b 44 24 78	 mov	 r8, QWORD PTR pattern$[rsp]
  00276	49 3b dd	 cmp	 rbx, r13
  00279	76 d5		 jbe	 SHORT $LL3@sre_search
$LN63@sre_search:

; 1601 :                 break;
; 1602 :         }
; 1603 : 
; 1604 :     return status;

  0027b	48 8b c6	 mov	 rax, rsi
$LN39@sre_search:

; 1605 : }

  0027e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00282	41 5f		 pop	 r15
  00284	41 5e		 pop	 r14
  00286	41 5d		 pop	 r13
  00288	41 5c		 pop	 r12
  0028a	5f		 pop	 rdi
  0028b	5e		 pop	 rsi
  0028c	5d		 pop	 rbp
  0028d	5b		 pop	 rbx
  0028e	c3		 ret	 0
sre_search ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sre_usearch DD imagerel sre_usearch
	DD	imagerel sre_usearch+703
	DD	imagerel $unwind$sre_usearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sre_usearch DD 091501H
	DD	0f0114215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT sre_usearch
_TEXT	SEGMENT
flags$1$ = 112
state$ = 112
pattern$ = 120
prefix_len$1$ = 128
prefix_skip$1$ = 136
sre_usearch PROC					; COMDAT

; 1477 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1478 :     char* ptr = (char*)state->start;
; 1479 :     char* end = (char*)state->end;

  00015	48 8b 69 18	 mov	 rbp, QWORD PTR [rcx+24]
  00019	48 8b 59 10	 mov	 rbx, QWORD PTR [rcx+16]

; 1480 :     Py_ssize_t status = 0;

  0001d	33 ff		 xor	 edi, edi

; 1481 :     Py_ssize_t prefix_len = 0;
; 1482 :     Py_ssize_t prefix_skip = 0;
; 1483 :     SRE_CODE* prefix = NULL;
; 1484 :     SRE_CODE* charset = NULL;
; 1485 :     SRE_CODE* overlap = NULL;
; 1486 :     int flags = 0;
; 1487 : 
; 1488 :     if (pattern[0] == SRE_OP_INFO) {

  0001f	83 3a 11	 cmp	 DWORD PTR [rdx], 17
  00022	4c 8b d2	 mov	 r10, rdx
  00025	48 8b f1	 mov	 rsi, rcx
  00028	4c 8b e5	 mov	 r12, rbp
  0002b	44 8b c7	 mov	 r8d, edi
  0002e	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR prefix_len$1$[rsp], rdi
  00036	44 8b cf	 mov	 r9d, edi
  00039	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR prefix_skip$1$[rsp], rdi
  00041	44 8b ff	 mov	 r15d, edi
  00044	44 8b ef	 mov	 r13d, edi
  00047	44 8b f7	 mov	 r14d, edi
  0004a	44 8b df	 mov	 r11d, edi
  0004d	89 7c 24 70	 mov	 DWORD PTR flags$1$[rsp], edi
  00051	0f 85 31 01 00
	00		 jne	 $LN32@sre_usearc

; 1489 :         /* optimization info block */
; 1490 :         /* <INFO> <1=skip> <2=flags> <3=min> <4=max> <5=prefix info>  */
; 1491 : 
; 1492 :         flags = pattern[2];
; 1493 : 
; 1494 :         if (pattern[3] > 1) {

  00057	8b 42 0c	 mov	 eax, DWORD PTR [rdx+12]
  0005a	44 8b 5a 08	 mov	 r11d, DWORD PTR [rdx+8]
  0005e	44 89 5c 24 70	 mov	 DWORD PTR flags$1$[rsp], r11d
  00063	83 f8 01	 cmp	 eax, 1
  00066	76 15		 jbe	 SHORT $LN36@sre_usearc

; 1495 :             /* adjust end point (but make sure we leave at least one
; 1496 :                character in there, so literal search will work) */
; 1497 :             end -= (pattern[3]-1) * state->charsize;

  00068	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  0006c	ff c8		 dec	 eax
  0006e	0f af c1	 imul	 eax, ecx
  00071	4c 2b e0	 sub	 r12, rax

; 1498 :             if (end <= ptr)

  00074	4c 3b e3	 cmp	 r12, rbx
  00077	77 04		 ja	 SHORT $LN36@sre_usearc

; 1499 :                 end = ptr + state->charsize;

  00079	4c 8d 24 0b	 lea	 r12, QWORD PTR [rbx+rcx]
$LN36@sre_usearc:

; 1500 :         }
; 1501 : 
; 1502 :         if (flags & SRE_INFO_PREFIX) {

  0007d	41 f6 c3 01	 test	 r11b, 1
  00081	74 23		 je	 SHORT $LN35@sre_usearc

; 1503 :             /* pattern starts with a known prefix */
; 1504 :             /* <length> <skip> <prefix data> <overlap data> */
; 1505 :             prefix_len = pattern[5];

  00083	44 8b 42 14	 mov	 r8d, DWORD PTR [rdx+20]

; 1506 :             prefix_skip = pattern[6];

  00087	44 8b 4a 18	 mov	 r9d, DWORD PTR [rdx+24]

; 1507 :             prefix = pattern + 7;

  0008b	4c 8d 7a 1c	 lea	 r15, QWORD PTR [rdx+28]
  0008f	4c 89 84 24 80
	00 00 00	 mov	 QWORD PTR prefix_len$1$[rsp], r8
  00097	4c 89 8c 24 88
	00 00 00	 mov	 QWORD PTR prefix_skip$1$[rsp], r9

; 1508 :             overlap = prefix + prefix_len - 1;

  0009f	4f 8d 74 87 fc	 lea	 r14, QWORD PTR [r15+r8*4-4]
  000a4	eb 0a		 jmp	 SHORT $LN33@sre_usearc
$LN35@sre_usearc:

; 1509 :         } else if (flags & SRE_INFO_CHARSET)

  000a6	41 f6 c3 04	 test	 r11b, 4
  000aa	74 04		 je	 SHORT $LN33@sre_usearc

; 1510 :             /* pattern starts with a character from a known set */
; 1511 :             /* <charset> */
; 1512 :             charset = pattern + 5;

  000ac	4c 8d 6a 14	 lea	 r13, QWORD PTR [rdx+20]
$LN33@sre_usearc:

; 1513 : 
; 1514 :         pattern += 1 + pattern[1];

  000b0	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  000b3	ff c0		 inc	 eax
  000b5	4c 8d 14 82	 lea	 r10, QWORD PTR [rdx+rax*4]
  000b9	4c 89 54 24 78	 mov	 QWORD PTR pattern$[rsp], r10

; 1515 :     }
; 1516 : 
; 1517 :     TRACE(("prefix = %p %" PY_FORMAT_SIZE_T "d %" PY_FORMAT_SIZE_T "d\n",
; 1518 :            prefix, prefix_len, prefix_skip));
; 1519 :     TRACE(("charset = %p\n", charset));
; 1520 : 
; 1521 : #if defined(USE_FAST_SEARCH)
; 1522 :     if (prefix_len > 1) {

  000be	49 83 f8 01	 cmp	 r8, 1
  000c2	0f 8e c0 00 00
	00		 jle	 $LN32@sre_usearc

; 1523 :         /* pattern starts with a known prefix.  use the overlap
; 1524 :            table to skip forward as fast as we possibly can */
; 1525 :         Py_ssize_t i = 0;
; 1526 :         end = (char *)state->end;
; 1527 :         while (ptr < end) {

  000c8	48 3b dd	 cmp	 rbx, rbp
  000cb	0f 83 f2 00 00
	00		 jae	 $LN74@sre_usearc
$LL31@sre_usearc:
  000d1	48 63 56 3c	 movsxd	 rdx, DWORD PTR [rsi+60]
$LL29@sre_usearc:

; 1528 :             for (;;) {
; 1529 :                 if ((SRE_CODE) SRE_CHARGET(state, ptr, 0) != prefix[i]) {

  000d5	83 fa 01	 cmp	 edx, 1
  000d8	75 05		 jne	 SHORT $LN43@sre_usearc
  000da	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000dd	eb 0c		 jmp	 SHORT $LN42@sre_usearc
$LN43@sre_usearc:
  000df	83 fa 02	 cmp	 edx, 2
  000e2	75 05		 jne	 SHORT $LN41@sre_usearc
  000e4	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  000e7	eb 02		 jmp	 SHORT $LN42@sre_usearc
$LN41@sre_usearc:
  000e9	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN42@sre_usearc:
  000eb	48 8d 0c bd 00
	00 00 00	 lea	 rcx, QWORD PTR [rdi*4]
  000f3	42 3b 04 39	 cmp	 eax, DWORD PTR [rcx+r15]
  000f7	74 0b		 je	 SHORT $LN27@sre_usearc

; 1530 :                     if (!i)

  000f9	48 85 ff	 test	 rdi, rdi
  000fc	74 67		 je	 SHORT $LN23@sre_usearc

; 1531 :                         break;
; 1532 :                     else
; 1533 :                         i = overlap[i];

  000fe	42 8b 3c 31	 mov	 edi, DWORD PTR [rcx+r14]

; 1547 :                     }
; 1548 :                     break;
; 1549 :                 }
; 1550 :             }

  00102	eb d1		 jmp	 SHORT $LL29@sre_usearc
$LN27@sre_usearc:

; 1534 :                 } else {
; 1535 :                     if (++i == prefix_len) {

  00104	48 ff c7	 inc	 rdi
  00107	49 3b f8	 cmp	 rdi, r8
  0010a	75 59		 jne	 SHORT $LN23@sre_usearc

; 1536 :                         /* found a potential match */
; 1537 :                         TRACE(("|%p|%p|SEARCH SCAN\n", pattern, ptr));
; 1538 :                         state->start = ptr - (prefix_len - 1) * state->charsize;

  0010c	49 8d 48 ff	 lea	 rcx, QWORD PTR [r8-1]
  00110	48 8b c3	 mov	 rax, rbx
  00113	48 0f af ca	 imul	 rcx, rdx
  00117	48 2b c1	 sub	 rax, rcx

; 1539 :                         state->ptr = ptr - (prefix_len - prefix_skip - 1) * state->charsize;

  0011a	49 8b c8	 mov	 rcx, r8
  0011d	49 2b c9	 sub	 rcx, r9
  00120	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
  00124	48 8b c3	 mov	 rax, rbx
  00127	48 ff c9	 dec	 rcx
  0012a	48 0f af ca	 imul	 rcx, rdx
  0012e	48 2b c1	 sub	 rax, rcx
  00131	48 89 06	 mov	 QWORD PTR [rsi], rax

; 1540 :                         if (flags & SRE_INFO_LITERAL)

  00134	41 f6 c3 02	 test	 r11b, 2
  00138	75 44		 jne	 SHORT $LN61@sre_usearc

; 1542 :                         status = SRE_MATCH(state, pattern + 2*prefix_skip);

  0013a	4b 8d 14 ca	 lea	 rdx, QWORD PTR [r10+r9*8]
  0013e	48 8b ce	 mov	 rcx, rsi
  00141	e8 00 00 00 00	 call	 sre_umatch

; 1543 :                         if (status != 0)

  00146	48 85 c0	 test	 rax, rax
  00149	0f 85 5f 01 00
	00		 jne	 $LN39@sre_usearc

; 1544 :                             return status;
; 1545 :                         /* close but no cigar -- try again */
; 1546 :                         i = overlap[i];

  0014f	41 8b 3c be	 mov	 edi, DWORD PTR [r14+rdi*4]
  00153	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR prefix_len$1$[rsp]
  0015b	4c 8b 54 24 78	 mov	 r10, QWORD PTR pattern$[rsp]
  00160	44 8b 5c 24 70	 mov	 r11d, DWORD PTR flags$1$[rsp]
$LN23@sre_usearc:

; 1551 :             ptr += state->charsize;

  00165	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  00169	48 03 d8	 add	 rbx, rax
  0016c	48 3b dd	 cmp	 rbx, rbp
  0016f	73 52		 jae	 SHORT $LN74@sre_usearc

; 1523 :         /* pattern starts with a known prefix.  use the overlap
; 1524 :            table to skip forward as fast as we possibly can */
; 1525 :         Py_ssize_t i = 0;
; 1526 :         end = (char *)state->end;
; 1527 :         while (ptr < end) {

  00171	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR prefix_skip$1$[rsp]
  00179	e9 53 ff ff ff	 jmp	 $LL31@sre_usearc
$LN61@sre_usearc:

; 1541 :                             return 1; /* we got all of it */

  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	e9 26 01 00 00	 jmp	 $LN39@sre_usearc
$LN32@sre_usearc:

; 1554 :     }
; 1555 : #endif
; 1556 : 
; 1557 :     if (pattern[0] == SRE_OP_LITERAL) {

  00188	41 83 3a 13	 cmp	 DWORD PTR [r10], 19
  0018c	75 75		 jne	 SHORT $LN20@sre_usearc

; 1558 :         /* pattern starts with a literal character.  this is used
; 1559 :            for short prefixes, and if fast search is disabled */
; 1560 :         SRE_CODE chr = pattern[1];

  0018e	45 8b 62 04	 mov	 r12d, DWORD PTR [r10+4]
$LL19@sre_usearc:

; 1561 :         end = (char*)state->end;
; 1562 :         for (;;) {
; 1563 :             while (ptr < end && (SRE_CODE) SRE_CHARGET(state, ptr, 0) != chr)

  00192	48 3b dd	 cmp	 rbx, rbp
  00195	73 2c		 jae	 SHORT $LN74@sre_usearc
  00197	48 63 4e 3c	 movsxd	 rcx, DWORD PTR [rsi+60]
  0019b	0f 1f 44 00 00	 npad	 5
$LL17@sre_usearc:
  001a0	83 f9 01	 cmp	 ecx, 1
  001a3	75 05		 jne	 SHORT $LN47@sre_usearc
  001a5	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  001a8	eb 0c		 jmp	 SHORT $LN46@sre_usearc
$LN47@sre_usearc:
  001aa	83 f9 02	 cmp	 ecx, 2
  001ad	75 05		 jne	 SHORT $LN45@sre_usearc
  001af	0f b7 03	 movzx	 eax, WORD PTR [rbx]
  001b2	eb 02		 jmp	 SHORT $LN46@sre_usearc
$LN45@sre_usearc:
  001b4	8b 03		 mov	 eax, DWORD PTR [rbx]
$LN46@sre_usearc:
  001b6	41 3b c4	 cmp	 eax, r12d
  001b9	74 0f		 je	 SHORT $LN16@sre_usearc

; 1564 :                 ptr += state->charsize;

  001bb	48 03 d9	 add	 rbx, rcx
  001be	48 3b dd	 cmp	 rbx, rbp
  001c1	72 dd		 jb	 SHORT $LL17@sre_usearc
$LN74@sre_usearc:

; 1552 :         }
; 1553 :         return 0;

  001c3	33 c0		 xor	 eax, eax
  001c5	e9 e4 00 00 00	 jmp	 $LN39@sre_usearc
$LN16@sre_usearc:

; 1565 :             if (ptr >= end)

  001ca	48 3b dd	 cmp	 rbx, rbp
  001cd	73 f4		 jae	 SHORT $LN74@sre_usearc

; 1566 :                 return 0;
; 1567 :             TRACE(("|%p|%p|SEARCH LITERAL\n", pattern, ptr));
; 1568 :             state->start = ptr;

  001cf	48 89 5e 10	 mov	 QWORD PTR [rsi+16], rbx

; 1569 :             ptr += state->charsize;

  001d3	48 03 d9	 add	 rbx, rcx

; 1570 :             state->ptr = ptr;

  001d6	48 89 1e	 mov	 QWORD PTR [rsi], rbx

; 1571 :             if (flags & SRE_INFO_LITERAL)

  001d9	41 f6 c3 02	 test	 r11b, 2
  001dd	75 9f		 jne	 SHORT $LN61@sre_usearc

; 1572 :                 return 1; /* we got all of it */
; 1573 :             status = SRE_MATCH(state, pattern + 2);

  001df	49 8d 52 08	 lea	 rdx, QWORD PTR [r10+8]
  001e3	48 8b ce	 mov	 rcx, rsi
  001e6	e8 00 00 00 00	 call	 sre_umatch
  001eb	48 8b f8	 mov	 rdi, rax

; 1574 :             if (status != 0)

  001ee	48 85 c0	 test	 rax, rax
  001f1	0f 85 b4 00 00
	00		 jne	 $LN75@sre_usearc

; 1575 :                 break;
; 1576 :         }

  001f7	4c 8b 54 24 78	 mov	 r10, QWORD PTR pattern$[rsp]
  001fc	44 8b 5c 24 70	 mov	 r11d, DWORD PTR flags$1$[rsp]
  00201	eb 8f		 jmp	 SHORT $LL19@sre_usearc
$LN20@sre_usearc:

; 1577 :     } else if (charset) {

  00203	4d 85 ed	 test	 r13, r13
  00206	74 6e		 je	 SHORT $LN59@sre_usearc
  00208	4c 8b 64 24 78	 mov	 r12, QWORD PTR pattern$[rsp]
  0020d	0f 1f 00	 npad	 3
$LL10@sre_usearc:

; 1578 :         /* pattern starts with a character from a known set */
; 1579 :         end = (char*)state->end;
; 1580 :         for (;;) {
; 1581 :             while (ptr < end && !SRE_CHARSET(charset, SRE_CHARGET(state, ptr, 0)))

  00210	48 3b dd	 cmp	 rbx, rbp
  00213	73 ae		 jae	 SHORT $LN74@sre_usearc
$LL8@sre_usearc:
  00215	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]
  00218	83 f8 01	 cmp	 eax, 1
  0021b	75 05		 jne	 SHORT $LN51@sre_usearc
  0021d	0f b6 13	 movzx	 edx, BYTE PTR [rbx]
  00220	eb 0c		 jmp	 SHORT $LN50@sre_usearc
$LN51@sre_usearc:
  00222	83 f8 02	 cmp	 eax, 2
  00225	75 05		 jne	 SHORT $LN49@sre_usearc
  00227	0f b7 13	 movzx	 edx, WORD PTR [rbx]
  0022a	eb 02		 jmp	 SHORT $LN50@sre_usearc
$LN49@sre_usearc:
  0022c	8b 13		 mov	 edx, DWORD PTR [rbx]
$LN50@sre_usearc:
  0022e	49 8b cd	 mov	 rcx, r13
  00231	e8 00 00 00 00	 call	 sre_ucharset
  00236	85 c0		 test	 eax, eax
  00238	75 10		 jne	 SHORT $LN7@sre_usearc

; 1582 :                 ptr += state->charsize;

  0023a	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  0023e	48 03 d8	 add	 rbx, rax
  00241	48 3b dd	 cmp	 rbx, rbp
  00244	72 cf		 jb	 SHORT $LL8@sre_usearc

; 1552 :         }
; 1553 :         return 0;

  00246	33 c0		 xor	 eax, eax
  00248	eb 64		 jmp	 SHORT $LN39@sre_usearc
$LN7@sre_usearc:

; 1583 :             if (ptr >= end)

  0024a	48 3b dd	 cmp	 rbx, rbp
  0024d	0f 83 70 ff ff
	ff		 jae	 $LN74@sre_usearc

; 1584 :                 return 0;
; 1585 :             TRACE(("|%p|%p|SEARCH CHARSET\n", pattern, ptr));
; 1586 :             state->start = ptr;
; 1587 :             state->ptr = ptr;
; 1588 :             status = SRE_MATCH(state, pattern);

  00253	49 8b d4	 mov	 rdx, r12
  00256	48 8b ce	 mov	 rcx, rsi
  00259	48 89 5e 10	 mov	 QWORD PTR [rsi+16], rbx
  0025d	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00260	e8 00 00 00 00	 call	 sre_umatch
  00265	48 8b f8	 mov	 rdi, rax

; 1589 :             if (status != 0)

  00268	48 85 c0	 test	 rax, rax
  0026b	75 3e		 jne	 SHORT $LN75@sre_usearc

; 1590 :                 break;
; 1591 :             ptr += state->charsize;

  0026d	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  00271	48 03 d8	 add	 rbx, rax

; 1592 :         }

  00274	eb 9a		 jmp	 SHORT $LL10@sre_usearc
$LN59@sre_usearc:

; 1593 :     } else
; 1594 :         /* general case */
; 1595 :         while (ptr <= end) {

  00276	49 3b dc	 cmp	 rbx, r12
  00279	77 30		 ja	 SHORT $LN75@sre_usearc
  0027b	0f 1f 44 00 00	 npad	 5
$LL3@sre_usearc:

; 1596 :             TRACE(("|%p|%p|SEARCH\n", pattern, ptr));
; 1597 :             state->start = state->ptr = ptr;
; 1598 :             ptr += state->charsize;

  00280	48 63 46 3c	 movsxd	 rax, DWORD PTR [rsi+60]
  00284	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00287	48 89 5e 10	 mov	 QWORD PTR [rsi+16], rbx

; 1599 :             status = SRE_MATCH(state, pattern);

  0028b	49 8b d2	 mov	 rdx, r10
  0028e	48 8b ce	 mov	 rcx, rsi
  00291	48 03 d8	 add	 rbx, rax
  00294	e8 00 00 00 00	 call	 sre_umatch
  00299	48 8b f8	 mov	 rdi, rax

; 1600 :             if (status != 0)

  0029c	48 85 c0	 test	 rax, rax
  0029f	75 0a		 jne	 SHORT $LN75@sre_usearc

; 1593 :     } else
; 1594 :         /* general case */
; 1595 :         while (ptr <= end) {

  002a1	4c 8b 54 24 78	 mov	 r10, QWORD PTR pattern$[rsp]
  002a6	49 3b dc	 cmp	 rbx, r12
  002a9	76 d5		 jbe	 SHORT $LL3@sre_usearc
$LN75@sre_usearc:

; 1601 :                 break;
; 1602 :         }
; 1603 : 
; 1604 :     return status;

  002ab	48 8b c7	 mov	 rax, rdi
$LN39@sre_usearc:

; 1605 : }

  002ae	48 83 c4 28	 add	 rsp, 40			; 00000028H
  002b2	41 5f		 pop	 r15
  002b4	41 5e		 pop	 r14
  002b6	41 5d		 pop	 r13
  002b8	41 5c		 pop	 r12
  002ba	5f		 pop	 rdi
  002bb	5e		 pop	 rsi
  002bc	5d		 pop	 rbp
  002bd	5b		 pop	 rbx
  002be	c3		 ret	 0
sre_usearch ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@GAFMGLAD@O?$HMnn?3findall?$AA@		; `string'
EXTRN	PyList_Append:PROC
EXTRN	PySequence_GetSlice:PROC
EXTRN	PyTuple_New:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_findall DD imagerel pattern_findall
	DD	imagerel pattern_findall+173
	DD	imagerel $unwind$pattern_findall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_findall DD imagerel pattern_findall+173
	DD	imagerel pattern_findall+224
	DD	imagerel $chain$0$pattern_findall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$pattern_findall DD imagerel pattern_findall+224
	DD	imagerel pattern_findall+674
	DD	imagerel $chain$5$pattern_findall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$pattern_findall DD imagerel pattern_findall+674
	DD	imagerel pattern_findall+715
	DD	imagerel $chain$7$pattern_findall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$pattern_findall DD 080021H
	DD	0ecd400H
	DD	0f2c400H
	DD	0f17400H
	DD	0f03400H
	DD	imagerel pattern_findall
	DD	imagerel pattern_findall+173
	DD	imagerel $unwind$pattern_findall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$pattern_findall DD 081d21H
	DD	0f2c41dH
	DD	0f17415H
	DD	0f0340dH
	DD	0ecd400H
	DD	imagerel pattern_findall
	DD	imagerel pattern_findall+173
	DD	imagerel $unwind$pattern_findall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_findall DD 020821H
	DD	0ecd408H
	DD	imagerel pattern_findall
	DD	imagerel pattern_findall+173
	DD	imagerel $unwind$pattern_findall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_findall DD 041201H
	DD	0ed0112H
	DD	050026003H
xdata	ENDS
;	COMDAT ??_C@_0N@GAFMGLAD@O?$HMnn?3findall?$AA@
CONST	SEGMENT
??_C@_0N@GAFMGLAD@O?$HMnn?3findall?$AA@ DB 'O|nn:findall', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT pattern_findall
_TEXT	SEGMENT
start$ = 64
end$ = 72
state$ = 80
self$ = 1920
args$ = 1928
kw$ = 1936
string$ = 1944
pattern_findall PROC					; COMDAT

; 2049 : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	48 8d ac 24 98
	f9 ff ff	 lea	 rbp, QWORD PTR [rsp-1640]
  0000b	48 81 ec 68 07
	00 00		 sub	 rsp, 1896		; 00000768H
  00012	48 8b f1	 mov	 rsi, rcx
  00015	49 8b c0	 mov	 rax, r8
  00018	4c 8b d2	 mov	 r10, rdx

; 2050 :     SRE_STATE state;
; 2051 :     PyObject* list;
; 2052 :     int status;
; 2053 :     Py_ssize_t i, b, e;
; 2054 : 
; 2055 :     PyObject* string;
; 2056 :     Py_ssize_t start = 0;
; 2057 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  0001b	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH

; 2058 :     static char* kwlist[] = { "source", "pos", "endpos", NULL };
; 2059 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "O|nn:findall", kwlist,
; 2060 :                                      &string, &start, &end))

  00025	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_findall@@9@9
  0002c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@GAFMGLAD@O?$HMnn?3findall?$AA@
  00033	48 89 4c 24 48	 mov	 QWORD PTR end$[rsp], rcx
  00038	48 8d 4c 24 48	 lea	 rcx, QWORD PTR end$[rsp]
  0003d	48 8b d0	 mov	 rdx, rax
  00040	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00045	48 8d 4c 24 40	 lea	 rcx, QWORD PTR start$[rsp]
  0004a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
  00053	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00058	48 8d 8d 98 06
	00 00		 lea	 rcx, QWORD PTR string$[rbp-256]
  0005f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00064	49 8b ca	 mov	 rcx, r10
  00067	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0006c	85 c0		 test	 eax, eax
  0006e	75 0c		 jne	 SHORT $LN25@pattern_fi
$LN46@pattern_fi:

; 2061 :         return NULL;

  00070	33 c0		 xor	 eax, eax

; 2145 : 
; 2146 : }

  00072	48 81 c4 68 07
	00 00		 add	 rsp, 1896		; 00000768H
  00079	5e		 pop	 rsi
  0007a	5d		 pop	 rbp
  0007b	c3		 ret	 0
$LN25@pattern_fi:

; 2062 : 
; 2063 :     string = state_init(&state, self, string, start, end);

  0007c	48 8b 44 24 48	 mov	 rax, QWORD PTR end$[rsp]
  00081	4c 8b 4c 24 40	 mov	 r9, QWORD PTR start$[rsp]
  00086	4c 8b 85 98 06
	00 00		 mov	 r8, QWORD PTR string$[rbp-256]
  0008d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  00092	48 8b d6	 mov	 rdx, rsi
  00095	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009a	e8 00 00 00 00	 call	 state_init
  0009f	48 89 85 98 06
	00 00		 mov	 QWORD PTR string$[rbp-256], rax

; 2064 :     if (!string)

  000a6	48 85 c0	 test	 rax, rax

; 2065 :         return NULL;

  000a9	74 c5		 je	 SHORT $LN46@pattern_fi

; 2066 : 
; 2067 :     list = PyList_New(0);

  000ab	33 c9		 xor	 ecx, ecx
  000ad	4c 89 ac 24 60
	07 00 00	 mov	 QWORD PTR [rsp+1888], r13
  000b5	e8 00 00 00 00	 call	 PyList_New
  000ba	4c 8b e8	 mov	 r13, rax

; 2068 :     if (!list) {

  000bd	48 85 c0	 test	 rax, rax
  000c0	75 1e		 jne	 SHORT $LN28@pattern_fi

; 2069 :         state_fini(&state);

  000c2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  000c7	e8 00 00 00 00	 call	 state_fini
  000cc	4c 8b ac 24 60
	07 00 00	 mov	 r13, QWORD PTR [rsp+1888]

; 2070 :         return NULL;

  000d4	33 c0		 xor	 eax, eax

; 2145 : 
; 2146 : }

  000d6	48 81 c4 68 07
	00 00		 add	 rsp, 1896		; 00000768H
  000dd	5e		 pop	 rsi
  000de	5d		 pop	 rbp
  000df	c3		 ret	 0
$LN28@pattern_fi:

; 2071 :     }
; 2072 : 
; 2073 :     while (state.start <= state.end) {

  000e0	48 8b 44 24 68	 mov	 rax, QWORD PTR state$[rsp+24]
  000e5	48 89 9c 24 80
	07 00 00	 mov	 QWORD PTR [rsp+1920], rbx
  000ed	48 89 bc 24 88
	07 00 00	 mov	 QWORD PTR [rsp+1928], rdi
  000f5	4c 89 a4 24 90
	07 00 00	 mov	 QWORD PTR [rsp+1936], r12
  000fd	48 39 44 24 60	 cmp	 QWORD PTR state$[rsp+16], rax
  00102	0f 87 63 01 00
	00		 ja	 $LN21@pattern_fi
  00108	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL22@pattern_fi:

; 2074 : 
; 2075 :         PyObject* item;
; 2076 : 
; 2077 :         state_reset(&state);

  00110	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  00115	e8 00 00 00 00	 call	 state_reset

; 2078 : 
; 2079 :         state.ptr = state.start;
; 2080 : 
; 2081 :         if (state.logical_charsize == 1) {

  0011a	83 7d 88 01	 cmp	 DWORD PTR state$[rbp-200], 1
  0011e	4c 8b 5c 24 60	 mov	 r11, QWORD PTR state$[rsp+16]
  00123	4c 89 5c 24 50	 mov	 QWORD PTR state$[rsp], r11

; 2082 :             status = sre_search(&state, PatternObject_GetCode(self));

  00128	48 8d 96 00 01
	00 00		 lea	 rdx, QWORD PTR [rsi+256]
  0012f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  00134	75 0a		 jne	 SHORT $LN20@pattern_fi
  00136	e8 00 00 00 00	 call	 sre_search
  0013b	48 8b d8	 mov	 rbx, rax

; 2083 :         } else {

  0013e	eb 07		 jmp	 SHORT $LN19@pattern_fi
$LN20@pattern_fi:

; 2084 :             status = sre_usearch(&state, PatternObject_GetCode(self));

  00140	e8 00 00 00 00	 call	 sre_usearch
  00145	8b d8		 mov	 ebx, eax
$LN19@pattern_fi:

; 2085 :         }
; 2086 : 
; 2087 :         if (PyErr_Occurred())

  00147	e8 00 00 00 00	 call	 PyErr_Occurred
  0014c	48 85 c0	 test	 rax, rax
  0014f	0f 85 60 01 00
	00		 jne	 $error$23721

; 2088 :             goto error;
; 2089 : 
; 2090 :         if (status <= 0) {

  00155	85 db		 test	 ebx, ebx
  00157	0f 8e 4f 01 00
	00		 jle	 $LN43@pattern_fi

; 2094 :             goto error;
; 2095 :         }
; 2096 : 
; 2097 :         /* don't bother to build a match object */
; 2098 :         switch (self->groups) {

  0015d	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  00161	48 8b c1	 mov	 rax, rcx
  00164	48 85 c9	 test	 rcx, rcx
  00167	74 78		 je	 SHORT $LN13@pattern_fi
  00169	48 ff c8	 dec	 rax
  0016c	74 57		 je	 SHORT $LN11@pattern_fi

; 2111 :         default:
; 2112 :             item = PyTuple_New(self->groups);

  0016e	e8 00 00 00 00	 call	 PyTuple_New
  00173	4c 8b e0	 mov	 r12, rax

; 2113 :             if (!item)

  00176	48 85 c0	 test	 rax, rax
  00179	0f 84 36 01 00
	00		 je	 $error$23721

; 2114 :                 goto error;
; 2115 :             for (i = 0; i < self->groups; i++) {

  0017f	33 db		 xor	 ebx, ebx
  00181	48 39 5e 70	 cmp	 QWORD PTR [rsi+112], rbx
  00185	0f 8e 9a 00 00
	00		 jle	 $LN12@pattern_fi
  0018b	48 8d 78 70	 lea	 rdi, QWORD PTR [rax+112]
  0018f	90		 npad	 1
$LL7@pattern_fi:

; 2116 :                 PyObject* o = state_getslice(&state, i+1, string, 1);

  00190	4c 8b 85 98 06
	00 00		 mov	 r8, QWORD PTR string$[rbp-256]
  00197	48 ff c3	 inc	 rbx
  0019a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  0019f	48 8b d3	 mov	 rdx, rbx
  001a2	41 b9 01 00 00
	00		 mov	 r9d, 1
  001a8	e8 00 00 00 00	 call	 state_getslice

; 2117 :                 if (!o) {

  001ad	48 85 c0	 test	 rax, rax
  001b0	0f 84 ec 00 00
	00		 je	 $LN30@pattern_fi

; 2119 :                     goto error;
; 2120 :                 }
; 2121 :                 PyTuple_SET_ITEM(item, i, o);

  001b6	48 89 07	 mov	 QWORD PTR [rdi], rax
  001b9	48 83 c7 08	 add	 rdi, 8
  001bd	48 3b 5e 70	 cmp	 rbx, QWORD PTR [rsi+112]
  001c1	7c cd		 jl	 SHORT $LL7@pattern_fi

; 2122 :             }
; 2123 :             break;

  001c3	eb 60		 jmp	 SHORT $LN12@pattern_fi
$LN11@pattern_fi:

; 2104 :                 goto error;
; 2105 :             break;
; 2106 :         case 1:
; 2107 :             item = state_getslice(&state, 1, string, 1);

  001c5	4c 8b 85 98 06
	00 00		 mov	 r8, QWORD PTR string$[rbp-256]
  001cc	41 b9 01 00 00
	00		 mov	 r9d, 1
  001d2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  001d7	41 8b d1	 mov	 edx, r9d
  001da	e8 00 00 00 00	 call	 state_getslice

; 2108 :             if (!item)
; 2109 :                 goto error;
; 2110 :             break;

  001df	eb 38		 jmp	 SHORT $LN45@pattern_fi
$LN13@pattern_fi:

; 2099 :         case 0:
; 2100 :             b = STATE_OFFSET(&state, state.start);

  001e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR state$[rsp+8]
  001e6	4c 63 45 8c	 movsxd	 r8, DWORD PTR state$[rbp-196]
  001ea	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp+16]
  001ef	48 2b c1	 sub	 rax, rcx
  001f2	48 99		 cdq
  001f4	49 f7 f8	 idiv	 r8
  001f7	4c 8b c8	 mov	 r9, rax

; 2101 :             e = STATE_OFFSET(&state, state.ptr);

  001fa	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp]
  001ff	48 2b c1	 sub	 rax, rcx

; 2102 :             item = PySequence_GetSlice(string, b, e);

  00202	48 8b 8d 98 06
	00 00		 mov	 rcx, QWORD PTR string$[rbp-256]
  00209	48 99		 cdq
  0020b	49 f7 f8	 idiv	 r8
  0020e	49 8b d1	 mov	 rdx, r9
  00211	4c 8b c0	 mov	 r8, rax
  00214	e8 00 00 00 00	 call	 PySequence_GetSlice
$LN45@pattern_fi:
  00219	4c 8b e0	 mov	 r12, rax

; 2103 :             if (!item)

  0021c	48 85 c0	 test	 rax, rax
  0021f	0f 84 90 00 00
	00		 je	 $error$23721
$LN12@pattern_fi:

; 2124 :         }
; 2125 : 
; 2126 :         status = PyList_Append(list, item);

  00225	49 8b d4	 mov	 rdx, r12
  00228	49 8b cd	 mov	 rcx, r13
  0022b	e8 00 00 00 00	 call	 PyList_Append

; 2127 :         Py_DECREF(item);

  00230	49 8b cc	 mov	 rcx, r12
  00233	8b d8		 mov	 ebx, eax
  00235	e8 00 00 00 00	 call	 _Py_DecRef

; 2128 :         if (status < 0)

  0023a	85 db		 test	 ebx, ebx
  0023c	78 77		 js	 SHORT $error$23721

; 2129 :             goto error;
; 2130 : 
; 2131 :         if (state.ptr == state.start)

  0023e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR state$[rsp]
  00243	48 3b 4c 24 60	 cmp	 rcx, QWORD PTR state$[rsp+16]
  00248	75 0e		 jne	 SHORT $LN2@pattern_fi

; 2132 :             state.start = (void*) ((char*) state.ptr + state.charsize);

  0024a	48 63 45 8c	 movsxd	 rax, DWORD PTR state$[rbp-196]
  0024e	48 03 c1	 add	 rax, rcx
  00251	48 89 44 24 60	 mov	 QWORD PTR state$[rsp+16], rax

; 2133 :         else

  00256	eb 08		 jmp	 SHORT $LN1@pattern_fi
$LN2@pattern_fi:

; 2134 :             state.start = state.ptr;

  00258	48 8b c1	 mov	 rax, rcx
  0025b	48 89 4c 24 60	 mov	 QWORD PTR state$[rsp+16], rcx
$LN1@pattern_fi:

; 2071 :     }
; 2072 : 
; 2073 :     while (state.start <= state.end) {

  00260	48 3b 44 24 68	 cmp	 rax, QWORD PTR state$[rsp+24]
  00265	0f 86 a5 fe ff
	ff		 jbe	 $LL22@pattern_fi
$LN21@pattern_fi:

; 2135 : 
; 2136 :     }
; 2137 : 
; 2138 :     state_fini(&state);

  0026b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  00270	e8 00 00 00 00	 call	 state_fini

; 2139 :     return list;

  00275	49 8b c5	 mov	 rax, r13
$LN42@pattern_fi:
  00278	4c 8b a4 24 90
	07 00 00	 mov	 r12, QWORD PTR [rsp+1936]
  00280	48 8b bc 24 88
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1928]
  00288	48 8b 9c 24 80
	07 00 00	 mov	 rbx, QWORD PTR [rsp+1920]
  00290	4c 8b ac 24 60
	07 00 00	 mov	 r13, QWORD PTR [rsp+1888]

; 2145 : 
; 2146 : }

  00298	48 81 c4 68 07
	00 00		 add	 rsp, 1896		; 00000768H
  0029f	5e		 pop	 rsi
  002a0	5d		 pop	 rbp
  002a1	c3		 ret	 0
$LN30@pattern_fi:

; 2118 :                     Py_DECREF(item);

  002a2	49 8b cc	 mov	 rcx, r12
  002a5	e8 00 00 00 00	 call	 _Py_DecRef
  002aa	eb 09		 jmp	 SHORT $error$23721
$LN43@pattern_fi:

; 2091 :             if (status == 0)

  002ac	74 bd		 je	 SHORT $LN21@pattern_fi

; 2092 :                 break;
; 2093 :             pattern_error(status);

  002ae	8b cb		 mov	 ecx, ebx
  002b0	e8 00 00 00 00	 call	 pattern_error
$error$23721:

; 2140 : 
; 2141 : error:
; 2142 :     Py_DECREF(list);

  002b5	49 8b cd	 mov	 rcx, r13
  002b8	e8 00 00 00 00	 call	 _Py_DecRef

; 2143 :     state_fini(&state);

  002bd	48 8d 4c 24 50	 lea	 rcx, QWORD PTR state$[rsp]
  002c2	e8 00 00 00 00	 call	 state_fini

; 2144 :     return NULL;

  002c7	33 c0		 xor	 eax, eax
  002c9	eb ad		 jmp	 SHORT $LN42@pattern_fi
pattern_findall ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT state_reset
_TEXT	SEGMENT
state$ = 8
state_reset PROC					; COMDAT

; 1655 :     /* FIXME: dynamic! */
; 1656 :     /*memset(state->mark, 0, sizeof(*state->mark) * SRE_MARK_SIZE);*/
; 1657 : 
; 1658 :     state->lastmark = -1;

  00000	48 c7 41 48 ff
	ff ff ff	 mov	 QWORD PTR [rcx+72], -1

; 1659 :     state->lastindex = -1;

  00008	48 c7 41 40 ff
	ff ff ff	 mov	 QWORD PTR [rcx+64], -1

; 1660 : 
; 1661 :     state->repeat = NULL;

  00010	48 c7 81 f8 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rcx+1784], 0

; 1662 : 
; 1663 :     data_stack_dealloc(state);
; 1664 : }

  0001b	e9 00 00 00 00	 jmp	 data_stack_dealloc
state_reset ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$state_getslice DD imagerel state_getslice
	DD	imagerel state_getslice+170
	DD	imagerel $unwind$state_getslice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$state_getslice DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT state_getslice
_TEXT	SEGMENT
state$ = 48
index$ = 56
string$ = 64
empty$ = 72
state_getslice PROC					; COMDAT

; 1820 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1821 :     Py_ssize_t i, j;
; 1822 : 
; 1823 :     index = (index - 1) * 2;
; 1824 : 
; 1825 :     if (string == Py_None || index >= state->lastmark || !state->mark[index] || !state->mark[index+1]) {

  0000a	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  00011	49 8b d8	 mov	 rbx, r8
  00014	4c 8b d1	 mov	 r10, rcx
  00017	48 8d 54 12 fe	 lea	 rdx, QWORD PTR [rdx+rdx-2]
  0001c	4c 3b c7	 cmp	 r8, rdi
  0001f	74 50		 je	 SHORT $LN4@state_gets
  00021	48 3b 51 48	 cmp	 rdx, QWORD PTR [rcx+72]
  00025	7d 4a		 jge	 SHORT $LN4@state_gets
  00027	48 8b 44 d1 50	 mov	 rax, QWORD PTR [rcx+rdx*8+80]
  0002c	48 85 c0	 test	 rax, rax
  0002f	74 40		 je	 SHORT $LN4@state_gets
  00031	4c 8b 5c d1 58	 mov	 r11, QWORD PTR [rcx+rdx*8+88]
  00036	4d 85 db	 test	 r11, r11
  00039	74 36		 je	 SHORT $LN4@state_gets

; 1831 :             return Py_None;
; 1832 :         }
; 1833 :     } else {
; 1834 :         i = STATE_OFFSET(state, state->mark[index]);

  0003b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003f	4d 63 42 3c	 movsxd	 r8, DWORD PTR [r10+60]
  00043	48 2b c1	 sub	 rax, rcx

; 1835 :         j = STATE_OFFSET(state, state->mark[index+1]);

  00046	4c 2b d9	 sub	 r11, rcx

; 1836 :     }
; 1837 : 
; 1838 :     return PySequence_GetSlice(string, i, j);

  00049	48 8b cb	 mov	 rcx, rbx
  0004c	48 99		 cdq
  0004e	49 f7 f8	 idiv	 r8
  00051	4c 8b c8	 mov	 r9, rax
  00054	49 8b c3	 mov	 rax, r11
  00057	48 99		 cdq
  00059	49 f7 f8	 idiv	 r8
  0005c	49 8b d1	 mov	 rdx, r9
  0005f	4c 8b c0	 mov	 r8, rax

; 1839 : }

  00062	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00067	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006b	5f		 pop	 rdi
  0006c	e9 00 00 00 00	 jmp	 PySequence_GetSlice
$LN4@state_gets:

; 1826 :         if (empty)

  00071	45 85 c9	 test	 r9d, r9d
  00074	74 1e		 je	 SHORT $LN3@state_gets

; 1827 :             /* want empty string */
; 1828 :             i = j = 0;

  00076	45 33 c9	 xor	 r9d, r9d

; 1836 :     }
; 1837 : 
; 1838 :     return PySequence_GetSlice(string, i, j);

  00079	48 8b cb	 mov	 rcx, rbx
  0007c	41 8b c1	 mov	 eax, r9d
  0007f	41 8b d1	 mov	 edx, r9d
  00082	44 8b c0	 mov	 r8d, eax

; 1839 : }

  00085	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	e9 00 00 00 00	 jmp	 PySequence_GetSlice
$LN3@state_gets:

; 1829 :         else {
; 1830 :             Py_INCREF(Py_None);

  00094	48 8b cf	 mov	 rcx, rdi
  00097	e8 00 00 00 00	 call	 _Py_IncRef

; 1839 : }

  0009c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a1	48 8b c7	 mov	 rax, rdi
  000a4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a8	5f		 pop	 rdi
  000a9	c3		 ret	 0
state_getslice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@LIEPNCKF@maximum?5recursion?5limit?5exceeded@ ; `string'
PUBLIC	??_C@_0CM@MJLOECCJ@internal?5error?5in?5regular?5expres@ ; `string'
EXTRN	PyExc_RuntimeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_error DD imagerel pattern_error
	DD	imagerel pattern_error+68
	DD	imagerel $unwind$pattern_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_error DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CB@LIEPNCKF@maximum?5recursion?5limit?5exceeded@
CONST	SEGMENT
??_C@_0CB@LIEPNCKF@maximum?5recursion?5limit?5exceeded@ DB 'maximum recur'
	DB	'sion limit exceeded', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@MJLOECCJ@internal?5error?5in?5regular?5expres@
CONST	SEGMENT
??_C@_0CM@MJLOECCJ@internal?5error?5in?5regular?5expres@ DB 'internal err'
	DB	'or in regular expression engine', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT pattern_error
_TEXT	SEGMENT
status$ = 48
pattern_error PROC					; COMDAT

; 1843 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1844 :     switch (status) {

  00004	83 f9 f6	 cmp	 ecx, -10
  00007	74 36		 je	 SHORT $LN2@pattern_er
  00009	83 f9 f7	 cmp	 ecx, -9
  0000c	74 2c		 je	 SHORT $LN3@pattern_er
  0000e	83 f9 fd	 cmp	 ecx, -3

; 1853 :         break;
; 1854 :     case SRE_ERROR_INTERRUPTED:
; 1855 :     /* An exception has already been raised, so let it fly */
; 1856 :         break;
; 1857 :     default:
; 1858 :         /* other error codes indicate compiler/engine bugs */
; 1859 :         PyErr_SetString(
; 1860 :             PyExc_RuntimeError,
; 1861 :             "internal error in regular expression engine"
; 1862 :             );

  00011	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  00018	74 10		 je	 SHORT $LN4@pattern_er
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@MJLOECCJ@internal?5error?5in?5regular?5expres@

; 1863 :     }
; 1864 : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	e9 00 00 00 00	 jmp	 PyErr_SetString
$LN4@pattern_er:

; 1845 :     case SRE_ERROR_RECURSION_LIMIT:
; 1846 :         PyErr_SetString(
; 1847 :             PyExc_RuntimeError,
; 1848 :             "maximum recursion limit exceeded"
; 1849 :             );

  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@LIEPNCKF@maximum?5recursion?5limit?5exceeded@

; 1863 :     }
; 1864 : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	e9 00 00 00 00	 jmp	 PyErr_SetString
$LN3@pattern_er:

; 1850 :         break;
; 1851 :     case SRE_ERROR_MEMORY:
; 1852 :         PyErr_NoMemory();

  0003a	e8 00 00 00 00	 call	 PyErr_NoMemory
$LN2@pattern_er:

; 1863 :     }
; 1864 : }

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
pattern_error ENDP
_TEXT	ENDS
EXTRN	PyCallIter_New:PROC
EXTRN	PyObject_GetAttrString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_finditer DD imagerel pattern_finditer
	DD	imagerel pattern_finditer+35
	DD	imagerel $unwind$pattern_finditer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_finditer DD imagerel pattern_finditer+35
	DD	imagerel pattern_finditer+74
	DD	imagerel $chain$0$pattern_finditer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pattern_finditer DD imagerel pattern_finditer+74
	DD	imagerel pattern_finditer+114
	DD	imagerel $chain$2$pattern_finditer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pattern_finditer DD 020021H
	DD	067400H
	DD	imagerel pattern_finditer
	DD	imagerel pattern_finditer+35
	DD	imagerel $unwind$pattern_finditer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_finditer DD 020521H
	DD	067405H
	DD	imagerel pattern_finditer
	DD	imagerel pattern_finditer+35
	DD	imagerel $unwind$pattern_finditer
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_finditer DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT pattern_finditer
_TEXT	SEGMENT
pattern$ = 48
args$ = 56
kw$ = 64
pattern_finditer PROC					; COMDAT

; 2151 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2152 :     PyObject* scanner;
; 2153 :     PyObject* search;
; 2154 :     PyObject* iterator;
; 2155 : 
; 2156 :     scanner = pattern_scanner(pattern, args, kw);

  00006	e8 00 00 00 00	 call	 pattern_scanner
  0000b	48 8b d8	 mov	 rbx, rax

; 2157 :     if (!scanner)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN2@pattern_fi@2

; 2169 : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5b		 pop	 rbx
  00018	c3		 ret	 0
$LN2@pattern_fi@2:

; 2158 :         return NULL;
; 2159 : 
; 2160 :     search = PyObject_GetAttrString(scanner, "search");

  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06GFPLNGOC@search?$AA@
  00020	48 8b c8	 mov	 rcx, rax
  00023	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00028	e8 00 00 00 00	 call	 PyObject_GetAttrString

; 2161 :     Py_DECREF(scanner);

  0002d	48 8b cb	 mov	 rcx, rbx
  00030	48 8b f8	 mov	 rdi, rax
  00033	e8 00 00 00 00	 call	 _Py_DecRef

; 2162 :     if (!search)

  00038	48 85 ff	 test	 rdi, rdi
  0003b	75 0d		 jne	 SHORT $LN1@pattern_fi@2

; 2163 :         return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 2169 : }

  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
$LN1@pattern_fi@2:

; 2164 : 
; 2165 :     iterator = PyCallIter_New(search, Py_None);

  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  00051	48 8b cf	 mov	 rcx, rdi
  00054	e8 00 00 00 00	 call	 PyCallIter_New

; 2166 :     Py_DECREF(search);

  00059	48 8b cf	 mov	 rcx, rdi
  0005c	48 8b d8	 mov	 rbx, rax
  0005f	e8 00 00 00 00	 call	 _Py_DecRef
  00064	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 2167 : 
; 2168 :     return iterator;

  00069	48 8b c3	 mov	 rax, rbx

; 2169 : }

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5b		 pop	 rbx
  00071	c3		 ret	 0
pattern_finditer ENDP
_TEXT	ENDS
PUBLIC	??_C@_09KFOACILG@O?$HMn?3split?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_split DD imagerel pattern_split
	DD	imagerel pattern_split+153
	DD	imagerel $unwind$pattern_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_split DD imagerel pattern_split+153
	DD	imagerel pattern_split+205
	DD	imagerel $chain$0$pattern_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$pattern_split DD imagerel pattern_split+205
	DD	imagerel pattern_split+644
	DD	imagerel $chain$6$pattern_split
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$pattern_split DD imagerel pattern_split+644
	DD	imagerel pattern_split+737
	DD	imagerel $chain$8$pattern_split
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$pattern_split DD 0a0021H
	DD	0eae400H
	DD	0ebd400H
	DD	0ec7400H
	DD	0f16400H
	DD	0f03400H
	DD	imagerel pattern_split
	DD	imagerel pattern_split+153
	DD	imagerel $unwind$pattern_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$pattern_split DD 0a2521H
	DD	0eae425H
	DD	0ec741dH
	DD	0f16415H
	DD	0f03408H
	DD	0ebd400H
	DD	imagerel pattern_split
	DD	imagerel pattern_split+153
	DD	imagerel $unwind$pattern_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_split DD 020821H
	DD	0ebd408H
	DD	imagerel pattern_split
	DD	imagerel pattern_split+153
	DD	imagerel $unwind$pattern_split
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_split DD 041301H
	DD	0ed0113H
	DD	05002c004H
xdata	ENDS
;	COMDAT ??_C@_09KFOACILG@O?$HMn?3split?$AA@
CONST	SEGMENT
??_C@_09KFOACILG@O?$HMn?3split?$AA@ DB 'O|n:split', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT pattern_split
_TEXT	SEGMENT
maxsplit$ = 48
state$ = 64
self$ = 1920
args$ = 1928
kw$ = 1936
string$ = 1944
pattern_split PROC					; COMDAT

; 2174 : {

  00000	40 55		 push	 rbp
  00002	41 54		 push	 r12
  00004	48 8d ac 24 98
	f9 ff ff	 lea	 rbp, QWORD PTR [rsp-1640]
  0000c	48 81 ec 68 07
	00 00		 sub	 rsp, 1896		; 00000768H
  00013	4c 8b e1	 mov	 r12, rcx
  00016	49 8b c0	 mov	 rax, r8
  00019	4c 8b d2	 mov	 r10, rdx

; 2175 :     SRE_STATE state;
; 2176 :     PyObject* list;
; 2177 :     PyObject* item;
; 2178 :     int status;
; 2179 :     Py_ssize_t n;
; 2180 :     Py_ssize_t i;
; 2181 :     void* last;
; 2182 : 
; 2183 :     PyObject* string;
; 2184 :     Py_ssize_t maxsplit = 0;
; 2185 :     static char* kwlist[] = { "source", "maxsplit", NULL };
; 2186 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "O|n:split", kwlist,
; 2187 :                                      &string, &maxsplit))

  0001c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR maxsplit$[rsp]
  00021	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_split@@9@9
  00028	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09KFOACILG@O?$HMn?3split?$AA@
  0002f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00034	48 8d 8d 98 06
	00 00		 lea	 rcx, QWORD PTR string$[rbp-256]
  0003b	48 8b d0	 mov	 rdx, rax
  0003e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00043	49 8b ca	 mov	 rcx, r10
  00046	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR maxsplit$[rsp], 0
  0004f	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00054	85 c0		 test	 eax, eax
  00056	75 0d		 jne	 SHORT $LN22@pattern_sp
$LN44@pattern_sp:

; 2188 :         return NULL;

  00058	33 c0		 xor	 eax, eax

; 2280 : 
; 2281 : }

  0005a	48 81 c4 68 07
	00 00		 add	 rsp, 1896		; 00000768H
  00061	41 5c		 pop	 r12
  00063	5d		 pop	 rbp
  00064	c3		 ret	 0
$LN22@pattern_sp:

; 2189 : 
; 2190 :     string = state_init(&state, self, string, 0, PY_SSIZE_T_MAX);

  00065	4c 8b 85 98 06
	00 00		 mov	 r8, QWORD PTR string$[rbp-256]
  0006c	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00076	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  0007b	45 33 c9	 xor	 r9d, r9d
  0007e	49 8b d4	 mov	 rdx, r12
  00081	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00086	e8 00 00 00 00	 call	 state_init
  0008b	48 89 85 98 06
	00 00		 mov	 QWORD PTR string$[rbp-256], rax

; 2191 :     if (!string)

  00092	48 85 c0	 test	 rax, rax

; 2192 :         return NULL;

  00095	74 c1		 je	 SHORT $LN44@pattern_sp

; 2193 : 
; 2194 :     list = PyList_New(0);

  00097	33 c9		 xor	 ecx, ecx
  00099	4c 89 ac 24 58
	07 00 00	 mov	 QWORD PTR [rsp+1880], r13
  000a1	e8 00 00 00 00	 call	 PyList_New
  000a6	4c 8b e8	 mov	 r13, rax

; 2195 :     if (!list) {

  000a9	48 85 c0	 test	 rax, rax
  000ac	75 1f		 jne	 SHORT $LN20@pattern_sp

; 2196 :         state_fini(&state);

  000ae	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  000b3	e8 00 00 00 00	 call	 state_fini
  000b8	4c 8b ac 24 58
	07 00 00	 mov	 r13, QWORD PTR [rsp+1880]

; 2197 :         return NULL;

  000c0	33 c0		 xor	 eax, eax

; 2280 : 
; 2281 : }

  000c2	48 81 c4 68 07
	00 00		 add	 rsp, 1896		; 00000768H
  000c9	41 5c		 pop	 r12
  000cb	5d		 pop	 rbp
  000cc	c3		 ret	 0
$LN20@pattern_sp:
  000cd	48 89 9c 24 80
	07 00 00	 mov	 QWORD PTR [rsp+1920], rbx

; 2198 :     }
; 2199 : 
; 2200 :     n = 0;
; 2201 :     last = state.start;

  000d5	48 8b 5c 24 50	 mov	 rbx, QWORD PTR state$[rsp+16]
  000da	48 89 b4 24 88
	07 00 00	 mov	 QWORD PTR [rsp+1928], rsi
  000e2	48 89 bc 24 60
	07 00 00	 mov	 QWORD PTR [rsp+1888], rdi
  000ea	4c 89 b4 24 50
	07 00 00	 mov	 QWORD PTR [rsp+1872], r14
  000f2	45 33 f6	 xor	 r14d, r14d
$LL19@pattern_sp:

; 2202 : 
; 2203 :     while (!maxsplit || n < maxsplit) {

  000f5	48 8b 44 24 30	 mov	 rax, QWORD PTR maxsplit$[rsp]
  000fa	48 85 c0	 test	 rax, rax
  000fd	74 09		 je	 SHORT $LN17@pattern_sp
  000ff	4c 3b f0	 cmp	 r14, rax
  00102	0f 8d 7c 01 00
	00		 jge	 $LN37@pattern_sp
$LN17@pattern_sp:

; 2204 : 
; 2205 :         state_reset(&state);

  00108	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  0010d	e8 00 00 00 00	 call	 state_reset

; 2206 : 
; 2207 :         state.ptr = state.start;
; 2208 : 
; 2209 :         if (state.logical_charsize == 1) {

  00112	83 7c 24 78 01	 cmp	 DWORD PTR state$[rsp+56], 1
  00117	4c 8b 5c 24 50	 mov	 r11, QWORD PTR state$[rsp+16]
  0011c	4c 89 5c 24 40	 mov	 QWORD PTR state$[rsp], r11

; 2210 :             status = sre_search(&state, PatternObject_GetCode(self));

  00121	49 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR [r12+256]
  00129	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  0012e	75 0a		 jne	 SHORT $LN16@pattern_sp
  00130	e8 00 00 00 00	 call	 sre_search
  00135	48 8b f8	 mov	 rdi, rax

; 2211 :         } else {

  00138	eb 07		 jmp	 SHORT $LN15@pattern_sp
$LN16@pattern_sp:

; 2212 :             status = sre_usearch(&state, PatternObject_GetCode(self));

  0013a	e8 00 00 00 00	 call	 sre_usearch
  0013f	8b f8		 mov	 edi, eax
$LN15@pattern_sp:

; 2213 :         }
; 2214 : 
; 2215 :         if (PyErr_Occurred())

  00141	e8 00 00 00 00	 call	 PyErr_Occurred
  00146	48 85 c0	 test	 rax, rax
  00149	0f 85 ee 00 00
	00		 jne	 $error$23810

; 2216 :             goto error;
; 2217 : 
; 2218 :         if (status <= 0) {

  0014f	85 ff		 test	 edi, edi
  00151	0f 8e dd 00 00
	00		 jle	 $LN43@pattern_sp

; 2222 :             goto error;
; 2223 :         }
; 2224 : 
; 2225 :         if (state.start == state.ptr) {

  00157	48 8b 44 24 50	 mov	 rax, QWORD PTR state$[rsp+16]
  0015c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR state$[rsp]
  00161	48 3b c1	 cmp	 rax, rcx
  00164	75 1d		 jne	 SHORT $LN11@pattern_sp

; 2226 :             if (last == state.end)

  00166	48 3b 5c 24 58	 cmp	 rbx, QWORD PTR state$[rsp+24]
  0016b	0f 84 13 01 00
	00		 je	 $LN37@pattern_sp

; 2227 :                 break;
; 2228 :             /* skip one character */
; 2229 :             state.start = (void*) ((char*) state.ptr + state.charsize);

  00171	48 63 44 24 7c	 movsxd	 rax, DWORD PTR state$[rsp+60]
  00176	48 03 c1	 add	 rax, rcx
  00179	48 89 44 24 50	 mov	 QWORD PTR state$[rsp+16], rax

; 2230 :             continue;

  0017e	e9 72 ff ff ff	 jmp	 $LL19@pattern_sp
$LN11@pattern_sp:

; 2231 :         }
; 2232 : 
; 2233 :         /* get segment before this match */
; 2234 :         item = PySequence_GetSlice(
; 2235 :             string, STATE_OFFSET(&state, last),
; 2236 :             STATE_OFFSET(&state, state.start)
; 2237 :             );

  00183	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp+8]
  00188	4c 63 4c 24 7c	 movsxd	 r9, DWORD PTR state$[rsp+60]
  0018d	48 2b c1	 sub	 rax, rcx
  00190	48 2b d9	 sub	 rbx, rcx
  00193	48 8b 8d 98 06
	00 00		 mov	 rcx, QWORD PTR string$[rbp-256]
  0019a	48 99		 cdq
  0019c	49 f7 f9	 idiv	 r9
  0019f	4c 8b c0	 mov	 r8, rax
  001a2	48 8b c3	 mov	 rax, rbx
  001a5	48 99		 cdq
  001a7	49 f7 f9	 idiv	 r9
  001aa	48 8b d0	 mov	 rdx, rax
  001ad	e8 00 00 00 00	 call	 PySequence_GetSlice
  001b2	48 8b f8	 mov	 rdi, rax

; 2238 :         if (!item)

  001b5	48 85 c0	 test	 rax, rax
  001b8	0f 84 7f 00 00
	00		 je	 $error$23810

; 2239 :             goto error;
; 2240 :         status = PyList_Append(list, item);

  001be	48 8b d0	 mov	 rdx, rax
  001c1	49 8b cd	 mov	 rcx, r13
  001c4	e8 00 00 00 00	 call	 PyList_Append

; 2241 :         Py_DECREF(item);

  001c9	48 8b cf	 mov	 rcx, rdi
  001cc	8b d8		 mov	 ebx, eax
  001ce	e8 00 00 00 00	 call	 _Py_DecRef

; 2242 :         if (status < 0)

  001d3	85 db		 test	 ebx, ebx
  001d5	78 66		 js	 SHORT $error$23810

; 2243 :             goto error;
; 2244 : 
; 2245 :         /* add groups (if any) */
; 2246 :         for (i = 0; i < self->groups; i++) {

  001d7	33 ff		 xor	 edi, edi
  001d9	49 39 7c 24 70	 cmp	 QWORD PTR [r12+112], rdi
  001de	7e 42		 jle	 SHORT $LN5@pattern_sp
$LL7@pattern_sp:

; 2247 :             item = state_getslice(&state, i+1, string, 0);

  001e0	4c 8b 85 98 06
	00 00		 mov	 r8, QWORD PTR string$[rbp-256]
  001e7	48 ff c7	 inc	 rdi
  001ea	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  001ef	48 8b d7	 mov	 rdx, rdi
  001f2	45 33 c9	 xor	 r9d, r9d
  001f5	e8 00 00 00 00	 call	 state_getslice
  001fa	48 8b f0	 mov	 rsi, rax

; 2248 :             if (!item)

  001fd	48 85 c0	 test	 rax, rax
  00200	74 3b		 je	 SHORT $error$23810

; 2249 :                 goto error;
; 2250 :             status = PyList_Append(list, item);

  00202	48 8b d0	 mov	 rdx, rax
  00205	49 8b cd	 mov	 rcx, r13
  00208	e8 00 00 00 00	 call	 PyList_Append

; 2251 :             Py_DECREF(item);

  0020d	48 8b ce	 mov	 rcx, rsi
  00210	8b d8		 mov	 ebx, eax
  00212	e8 00 00 00 00	 call	 _Py_DecRef

; 2252 :             if (status < 0)

  00217	85 db		 test	 ebx, ebx
  00219	78 22		 js	 SHORT $error$23810

; 2243 :             goto error;
; 2244 : 
; 2245 :         /* add groups (if any) */
; 2246 :         for (i = 0; i < self->groups; i++) {

  0021b	49 3b 7c 24 70	 cmp	 rdi, QWORD PTR [r12+112]
  00220	7c be		 jl	 SHORT $LL7@pattern_sp
$LN5@pattern_sp:

; 2253 :                 goto error;
; 2254 :         }
; 2255 : 
; 2256 :         n = n + 1;
; 2257 : 
; 2258 :         last = state.start = state.ptr;

  00222	48 8b 5c 24 40	 mov	 rbx, QWORD PTR state$[rsp]
  00227	49 ff c6	 inc	 r14
  0022a	48 89 5c 24 50	 mov	 QWORD PTR state$[rsp+16], rbx

; 2259 : 
; 2260 :     }

  0022f	e9 c1 fe ff ff	 jmp	 $LL19@pattern_sp
$LN43@pattern_sp:

; 2219 :             if (status == 0)

  00234	74 4e		 je	 SHORT $LN37@pattern_sp

; 2220 :                 break;
; 2221 :             pattern_error(status);

  00236	8b cf		 mov	 ecx, edi
  00238	e8 00 00 00 00	 call	 pattern_error
$error$23810:

; 2275 : 
; 2276 : error:
; 2277 :     Py_DECREF(list);

  0023d	49 8b cd	 mov	 rcx, r13
  00240	e8 00 00 00 00	 call	 _Py_DecRef

; 2278 :     state_fini(&state);

  00245	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  0024a	e8 00 00 00 00	 call	 state_fini

; 2279 :     return NULL;

  0024f	33 c0		 xor	 eax, eax
$LN42@pattern_sp:
  00251	48 8b 9c 24 80
	07 00 00	 mov	 rbx, QWORD PTR [rsp+1920]
  00259	48 8b bc 24 60
	07 00 00	 mov	 rdi, QWORD PTR [rsp+1888]
  00261	48 8b b4 24 88
	07 00 00	 mov	 rsi, QWORD PTR [rsp+1928]
  00269	4c 8b b4 24 50
	07 00 00	 mov	 r14, QWORD PTR [rsp+1872]
  00271	4c 8b ac 24 58
	07 00 00	 mov	 r13, QWORD PTR [rsp+1880]

; 2280 : 
; 2281 : }

  00279	48 81 c4 68 07
	00 00		 add	 rsp, 1896		; 00000768H
  00280	41 5c		 pop	 r12
  00282	5d		 pop	 rbp
  00283	c3		 ret	 0
$LN37@pattern_sp:

; 2261 : 
; 2262 :     /* get segment following last match (even if empty) */
; 2263 :     item = PySequence_GetSlice(
; 2264 :         string, STATE_OFFSET(&state, last), state.endpos
; 2265 :         );

  00284	48 63 4c 24 7c	 movsxd	 rcx, DWORD PTR state$[rsp+60]
  00289	48 2b 5c 24 48	 sub	 rbx, QWORD PTR state$[rsp+8]
  0028e	4c 8b 44 24 70	 mov	 r8, QWORD PTR state$[rsp+48]
  00293	48 8b c3	 mov	 rax, rbx
  00296	48 99		 cdq
  00298	48 f7 f9	 idiv	 rcx
  0029b	48 8b 8d 98 06
	00 00		 mov	 rcx, QWORD PTR string$[rbp-256]
  002a2	48 8b d0	 mov	 rdx, rax
  002a5	e8 00 00 00 00	 call	 PySequence_GetSlice
  002aa	48 8b f8	 mov	 rdi, rax

; 2266 :     if (!item)

  002ad	48 85 c0	 test	 rax, rax
  002b0	74 8b		 je	 SHORT $error$23810

; 2267 :         goto error;
; 2268 :     status = PyList_Append(list, item);

  002b2	48 8b d0	 mov	 rdx, rax
  002b5	49 8b cd	 mov	 rcx, r13
  002b8	e8 00 00 00 00	 call	 PyList_Append

; 2269 :     Py_DECREF(item);

  002bd	48 8b cf	 mov	 rcx, rdi
  002c0	8b d8		 mov	 ebx, eax
  002c2	e8 00 00 00 00	 call	 _Py_DecRef

; 2270 :     if (status < 0)

  002c7	85 db		 test	 ebx, ebx
  002c9	0f 88 6e ff ff
	ff		 js	 $error$23810

; 2271 :         goto error;
; 2272 : 
; 2273 :     state_fini(&state);

  002cf	48 8d 4c 24 40	 lea	 rcx, QWORD PTR state$[rsp]
  002d4	e8 00 00 00 00	 call	 state_fini

; 2274 :     return list;

  002d9	49 8b c5	 mov	 rax, r13
  002dc	e9 70 ff ff ff	 jmp	 $LN42@pattern_sp
pattern_split ENDP
_TEXT	ENDS
PUBLIC	??_C@_08GGLMCPHI@OO?$HMn?3sub?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_sub DD imagerel pattern_sub
	DD	imagerel pattern_sub+124
	DD	imagerel $unwind$pattern_sub
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_sub DD 020801H
	DD	030049208H
xdata	ENDS
;	COMDAT ??_C@_08GGLMCPHI@OO?$HMn?3sub?$AA@
CONST	SEGMENT
??_C@_08GGLMCPHI@OO?$HMn?3sub?$AA@ DB 'OO|n:sub', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT pattern_sub
_TEXT	SEGMENT
string$ = 64
ptemplate$ = 72
self$ = 96
args$ = 104
kw$ = 112
count$ = 120
pattern_sub PROC					; COMDAT

; 2467 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00008	48 8b d9	 mov	 rbx, rcx

; 2468 :     PyObject* ptemplate;
; 2469 :     PyObject* string;
; 2470 :     Py_ssize_t count = 0;
; 2471 :     static char* kwlist[] = { "repl", "string", "count", NULL };
; 2472 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|n:sub", kwlist,
; 2473 :                                      &ptemplate, &string, &count))

  0000b	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000f	49 8b c0	 mov	 rax, r8
  00012	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00016	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  0001a	4c 8b d2	 mov	 r10, rdx
  0001d	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  00021	49 8d 4b f0	 lea	 rcx, QWORD PTR [r11-16]
  00025	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_sub@@9@9
  0002c	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00030	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08GGLMCPHI@OO?$HMn?3sub?$AA@
  00037	48 8b d0	 mov	 rdx, rax
  0003a	49 8b ca	 mov	 rcx, r10
  0003d	49 c7 43 20 00
	00 00 00	 mov	 QWORD PTR [r11+32], 0
  00045	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0004a	85 c0		 test	 eax, eax
  0004c	75 08		 jne	 SHORT $LN1@pattern_su

; 2474 :         return NULL;

  0004e	33 c0		 xor	 eax, eax

; 2477 : }

  00050	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
$LN1@pattern_su:

; 2475 : 
; 2476 :     return pattern_subx(self, ptemplate, string, count, 0);

  00056	4c 8b 4c 24 78	 mov	 r9, QWORD PTR count$[rsp]
  0005b	4c 8b 44 24 40	 mov	 r8, QWORD PTR string$[rsp]
  00060	48 8b 54 24 48	 mov	 rdx, QWORD PTR ptemplate$[rsp]
  00065	48 8b cb	 mov	 rcx, rbx
  00068	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00071	e8 00 00 00 00	 call	 pattern_subx

; 2477 : }

  00076	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0007a	5b		 pop	 rbx
  0007b	c3		 ret	 0
pattern_sub ENDP
_TEXT	ENDS
PUBLIC	??_C@_02IBMEMAAO@Nn?$AA@			; `string'
PUBLIC	??_C@_05PNMDMCHP@_subx?$AA@			; `string'
EXTRN	PyObject_CallObject:PROC
EXTRN	PyTuple_Pack:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyCallable_Check:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_subx DD imagerel pattern_subx
	DD	imagerel pattern_subx+311
	DD	imagerel $unwind$pattern_subx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_subx DD imagerel pattern_subx+311
	DD	imagerel pattern_subx+989
	DD	imagerel $chain$0$pattern_subx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$pattern_subx DD imagerel pattern_subx+989
	DD	imagerel pattern_subx+1017
	DD	imagerel $chain$1$pattern_subx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$pattern_subx DD 021H
	DD	imagerel pattern_subx
	DD	imagerel pattern_subx+311
	DD	imagerel $unwind$pattern_subx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_subx DD 020821H
	DD	0fef408H
	DD	imagerel pattern_subx
	DD	imagerel pattern_subx+311
	DD	imagerel $unwind$pattern_subx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_subx DD 0b2601H
	DD	01006426H
	DD	0ff3426H
	DD	0f80126H
	DD	0d015e017H
	DD	07011c013H
	DD	05010H
xdata	ENDS
;	COMDAT ??_C@_02IBMEMAAO@Nn?$AA@
CONST	SEGMENT
??_C@_02IBMEMAAO@Nn?$AA@ DB 'Nn', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05PNMDMCHP@_subx?$AA@
CONST	SEGMENT
??_C@_05PNMDMCHP@_subx?$AA@ DB '_subx', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT pattern_subx
_TEXT	SEGMENT
n$ = 48
string$1$ = 56
charsize$ = 64
$T27627 = 72
logical_charsize$ = 80
view$ = 96
state$ = 176
self$ = 2032
ptemplate$ = 2040
string$ = 2048
count$ = 2056
subn$ = 2064
pattern_subx PROC					; COMDAT

; 2286 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	55		 push	 rbp
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 55		 push	 r13
  00015	41 56		 push	 r14
  00017	48 8d ac 24 40
	f9 ff ff	 lea	 rbp, QWORD PTR [rsp-1728]
  0001f	48 81 ec c0 07
	00 00		 sub	 rsp, 1984		; 000007c0H
  00026	4c 8b e9	 mov	 r13, rcx

; 2287 :     SRE_STATE state;
; 2288 :     PyObject* list;
; 2289 :     PyObject* item;
; 2290 :     PyObject* filter;
; 2291 :     PyObject* args;
; 2292 :     PyObject* match;
; 2293 :     void* ptr;
; 2294 :     int status;
; 2295 :     Py_ssize_t n;
; 2296 :     Py_ssize_t i, b, e;
; 2297 :     int logical_charsize, charsize;
; 2298 :     int filter_is_callable;
; 2299 :     Py_buffer view;
; 2300 : 
; 2301 :     if (PyCallable_Check(ptemplate)) {

  00029	48 8b ca	 mov	 rcx, rdx
  0002c	49 8b f1	 mov	 rsi, r9
  0002f	4d 8b f0	 mov	 r14, r8
  00032	48 8b fa	 mov	 rdi, rdx
  00035	e8 00 00 00 00	 call	 PyCallable_Check
  0003a	33 db		 xor	 ebx, ebx

; 2302 :         /* sub/subn takes either a function or a template */
; 2303 :         filter = ptemplate;
; 2304 :         Py_INCREF(filter);

  0003c	48 8b cf	 mov	 rcx, rdi
  0003f	85 c0		 test	 eax, eax
  00041	74 10		 je	 SHORT $LN37@pattern_su@2
  00043	4c 8b e7	 mov	 r12, rdi
  00046	e8 00 00 00 00	 call	 _Py_IncRef

; 2305 :         filter_is_callable = 1;

  0004b	8d 7b 01	 lea	 edi, QWORD PTR [rbx+1]

; 2306 :     } else {

  0004e	e9 a8 00 00 00	 jmp	 $LN31@pattern_su@2
$LN37@pattern_su@2:

; 2307 :         /* if not callable, check if it's a literal string */
; 2308 :         int literal;
; 2309 :         view.buf = NULL;
; 2310 :         ptr = getstring(ptemplate, &n, &logical_charsize, &charsize, &view);

  00053	48 8d 44 24 60	 lea	 rax, QWORD PTR view$[rsp]
  00058	4c 8d 4c 24 40	 lea	 r9, QWORD PTR charsize$[rsp]
  0005d	4c 8d 44 24 50	 lea	 r8, QWORD PTR logical_charsize$[rsp]
  00062	48 8d 54 24 30	 lea	 rdx, QWORD PTR n$[rsp]
  00067	48 89 5c 24 60	 mov	 QWORD PTR view$[rsp], rbx
  0006c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00071	e8 00 00 00 00	 call	 getstring

; 2311 :         b = charsize;

  00076	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR charsize$[rsp]

; 2312 :         if (ptr) {

  0007b	48 85 c0	 test	 rax, rax
  0007e	74 11		 je	 SHORT $LN35@pattern_su@2

; 2313 :             literal = sre_literal_template(b, ptr, n);

  00080	4c 8b 44 24 30	 mov	 r8, QWORD PTR n$[rsp]
  00085	48 8b d0	 mov	 rdx, rax
  00088	e8 00 00 00 00	 call	 sre_literal_template
  0008d	8b f0		 mov	 esi, eax

; 2314 :         } else {

  0008f	eb 07		 jmp	 SHORT $LN34@pattern_su@2
$LN35@pattern_su@2:

; 2315 :             PyErr_Clear();

  00091	e8 00 00 00 00	 call	 PyErr_Clear

; 2316 :             literal = 0;

  00096	8b f3		 mov	 esi, ebx
$LN34@pattern_su@2:

; 2317 :         }
; 2318 :         if (view.buf)

  00098	48 39 5c 24 60	 cmp	 QWORD PTR view$[rsp], rbx
  0009d	74 0a		 je	 SHORT $LN33@pattern_su@2

; 2319 :             PyBuffer_Release(&view);

  0009f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR view$[rsp]
  000a4	e8 00 00 00 00	 call	 PyBuffer_Release
$LN33@pattern_su@2:

; 2320 :         if (literal) {

  000a9	85 f6		 test	 esi, esi
  000ab	74 0f		 je	 SHORT $LN32@pattern_su@2

; 2321 :             filter = ptemplate;
; 2322 :             Py_INCREF(filter);

  000ad	48 8b cf	 mov	 rcx, rdi
  000b0	4c 8b e7	 mov	 r12, rdi
  000b3	e8 00 00 00 00	 call	 _Py_IncRef

; 2323 :             filter_is_callable = 0;

  000b8	8b fb		 mov	 edi, ebx

; 2324 :         } else {

  000ba	eb 38		 jmp	 SHORT $LN52@pattern_su@2
$LN32@pattern_su@2:

; 2325 :             /* not a literal; hand it over to the template compiler */
; 2326 :             filter = call(
; 2327 :                 SRE_PY_MODULE, "_subx",
; 2328 :                 PyTuple_Pack(2, self, ptemplate)
; 2329 :                 );

  000bc	4c 8b c7	 mov	 r8, rdi
  000bf	49 8b d5	 mov	 rdx, r13
  000c2	b9 02 00 00 00	 mov	 ecx, 2
  000c7	e8 00 00 00 00	 call	 PyTuple_Pack
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNMDMCHP@_subx?$AA@
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02EPEBAFDB@re?$AA@
  000da	4c 8b c0	 mov	 r8, rax
  000dd	e8 00 00 00 00	 call	 call
  000e2	4c 8b e0	 mov	 r12, rax

; 2330 :             if (!filter)

  000e5	48 85 c0	 test	 rax, rax

; 2331 :                 return NULL;

  000e8	74 44		 je	 SHORT $LN56@pattern_su@2

; 2332 :             filter_is_callable = PyCallable_Check(filter);

  000ea	48 8b c8	 mov	 rcx, rax
  000ed	e8 00 00 00 00	 call	 PyCallable_Check
  000f2	8b f8		 mov	 edi, eax
$LN52@pattern_su@2:
  000f4	48 8b b5 08 07
	00 00		 mov	 rsi, QWORD PTR count$[rbp-256]
$LN31@pattern_su@2:

; 2333 :         }
; 2334 :     }
; 2335 : 
; 2336 :     string = state_init(&state, self, string, 0, PY_SSIZE_T_MAX);

  000fb	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00105	48 8d 4d b0	 lea	 rcx, QWORD PTR state$[rbp-256]
  00109	45 33 c9	 xor	 r9d, r9d
  0010c	4d 8b c6	 mov	 r8, r14
  0010f	49 8b d5	 mov	 rdx, r13
  00112	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00117	e8 00 00 00 00	 call	 state_init
  0011c	48 89 44 24 38	 mov	 QWORD PTR string$1$[rsp], rax

; 2337 :     if (!string) {

  00121	48 85 c0	 test	 rax, rax
  00124	75 0f		 jne	 SHORT $LN29@pattern_su@2

; 2338 :         Py_DECREF(filter);

  00126	49 8b cc	 mov	 rcx, r12
  00129	e8 00 00 00 00	 call	 _Py_DecRef
$LN56@pattern_su@2:

; 2339 :         return NULL;

  0012e	33 c0		 xor	 eax, eax
  00130	e9 a8 02 00 00	 jmp	 $LN38@pattern_su@2
$LN29@pattern_su@2:

; 2340 :     }
; 2341 : 
; 2342 :     list = PyList_New(0);

  00135	33 c9		 xor	 ecx, ecx
  00137	4c 89 bc 24 f0
	07 00 00	 mov	 QWORD PTR [rsp+2032], r15
  0013f	e8 00 00 00 00	 call	 PyList_New
  00144	4c 8b f8	 mov	 r15, rax

; 2343 :     if (!list) {

  00147	48 85 c0	 test	 rax, rax
  0014a	75 16		 jne	 SHORT $LN28@pattern_su@2

; 2344 :         Py_DECREF(filter);

  0014c	49 8b cc	 mov	 rcx, r12
  0014f	e8 00 00 00 00	 call	 _Py_DecRef

; 2345 :         state_fini(&state);

  00154	48 8d 4d b0	 lea	 rcx, QWORD PTR state$[rbp-256]
  00158	e8 00 00 00 00	 call	 state_fini

; 2346 :         return NULL;

  0015d	e9 71 02 00 00	 jmp	 $LN53@pattern_su@2
$LN28@pattern_su@2:

; 2387 :             /* ignore empty match on latest position */
; 2388 :             goto next;
; 2389 : 
; 2390 :         if (filter_is_callable) {

  00162	48 63 c7	 movsxd	 rax, edi
  00165	48 8b cb	 mov	 rcx, rbx
  00168	48 89 5c 24 30	 mov	 QWORD PTR n$[rsp], rbx
  0016d	48 89 44 24 48	 mov	 QWORD PTR $T27627[rsp], rax
$LL27@pattern_su@2:

; 2347 :     }
; 2348 : 
; 2349 :     n = i = 0;
; 2350 : 
; 2351 :     while (!count || n < count) {

  00172	48 85 f6	 test	 rsi, rsi
  00175	74 09		 je	 SHORT $LN25@pattern_su@2
  00177	48 3b ce	 cmp	 rcx, rsi
  0017a	0f 8d b8 01 00
	00		 jge	 $LN26@pattern_su@2
$LN25@pattern_su@2:

; 2352 : 
; 2353 :         state_reset(&state);

  00180	48 8d 4d b0	 lea	 rcx, QWORD PTR state$[rbp-256]
  00184	e8 00 00 00 00	 call	 state_reset

; 2354 : 
; 2355 :         state.ptr = state.start;
; 2356 : 
; 2357 :         if (state.logical_charsize == 1) {

  00189	83 7d e8 01	 cmp	 DWORD PTR state$[rbp-200], 1
  0018d	4c 8b 5d c0	 mov	 r11, QWORD PTR state$[rbp-240]
  00191	4c 89 5d b0	 mov	 QWORD PTR state$[rbp-256], r11

; 2358 :             status = sre_search(&state, PatternObject_GetCode(self));

  00195	49 8d 95 00 01
	00 00		 lea	 rdx, QWORD PTR [r13+256]
  0019c	48 8d 4d b0	 lea	 rcx, QWORD PTR state$[rbp-256]
  001a0	75 0a		 jne	 SHORT $LN24@pattern_su@2
  001a2	e8 00 00 00 00	 call	 sre_search
  001a7	48 8b f8	 mov	 rdi, rax

; 2359 :         } else {

  001aa	eb 07		 jmp	 SHORT $LN23@pattern_su@2
$LN24@pattern_su@2:

; 2360 :             status = sre_usearch(&state, PatternObject_GetCode(self));

  001ac	e8 00 00 00 00	 call	 sre_usearch
  001b1	8b f8		 mov	 edi, eax
$LN23@pattern_su@2:

; 2361 :         }
; 2362 : 
; 2363 :         if (PyErr_Occurred())

  001b3	e8 00 00 00 00	 call	 PyErr_Occurred
  001b8	48 85 c0	 test	 rax, rax
  001bb	0f 85 f9 01 00
	00		 jne	 $error$23897

; 2364 :             goto error;
; 2365 : 
; 2366 :         if (status <= 0) {

  001c1	85 ff		 test	 edi, edi
  001c3	0f 8e 69 01 00
	00		 jle	 $LN54@pattern_su@2

; 2370 :             goto error;
; 2371 :         }
; 2372 : 
; 2373 :         b = STATE_OFFSET(&state, state.start);

  001c9	48 8b 4d b8	 mov	 rcx, QWORD PTR state$[rbp-248]
  001cd	48 63 7d ec	 movsxd	 rdi, DWORD PTR state$[rbp-196]
  001d1	4c 8b 5d c0	 mov	 r11, QWORD PTR state$[rbp-240]

; 2374 :         e = STATE_OFFSET(&state, state.ptr);

  001d5	4c 8b 4d b0	 mov	 r9, QWORD PTR state$[rbp-256]
  001d9	49 8b c3	 mov	 rax, r11
  001dc	48 2b c1	 sub	 rax, rcx
  001df	48 99		 cdq
  001e1	48 f7 ff	 idiv	 rdi
  001e4	4c 8b d0	 mov	 r10, rax
  001e7	49 8b c1	 mov	 rax, r9
  001ea	48 2b c1	 sub	 rax, rcx
  001ed	48 99		 cdq
  001ef	48 f7 ff	 idiv	 rdi
  001f2	4c 8b f0	 mov	 r14, rax

; 2375 : 
; 2376 :         if (i < b) {

  001f5	49 3b da	 cmp	 rbx, r10
  001f8	7d 3b		 jge	 SHORT $LN55@pattern_su@2

; 2377 :             /* get segment before this match */
; 2378 :             item = PySequence_GetSlice(string, i, b);

  001fa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR string$1$[rsp]
  001ff	4d 8b c2	 mov	 r8, r10
  00202	48 8b d3	 mov	 rdx, rbx
  00205	e8 00 00 00 00	 call	 PySequence_GetSlice
  0020a	48 8b f8	 mov	 rdi, rax

; 2379 :             if (!item)

  0020d	48 85 c0	 test	 rax, rax
  00210	0f 84 a4 01 00
	00		 je	 $error$23897

; 2380 :                 goto error;
; 2381 :             status = PyList_Append(list, item);

  00216	48 8b d0	 mov	 rdx, rax
  00219	49 8b cf	 mov	 rcx, r15
  0021c	e8 00 00 00 00	 call	 PyList_Append

; 2382 :             Py_DECREF(item);

  00221	48 8b cf	 mov	 rcx, rdi
  00224	8b d8		 mov	 ebx, eax
  00226	e8 00 00 00 00	 call	 _Py_DecRef

; 2383 :             if (status < 0)

  0022b	85 db		 test	 ebx, ebx
  0022d	0f 88 87 01 00
	00		 js	 $error$23897

; 2384 :                 goto error;
; 2385 : 
; 2386 :         } else if (i == b && i == e && n > 0)

  00233	eb 15		 jmp	 SHORT $LN15@pattern_su@2
$LN55@pattern_su@2:
  00235	75 13		 jne	 SHORT $LN15@pattern_su@2
  00237	48 3b d8	 cmp	 rbx, rax
  0023a	75 0e		 jne	 SHORT $LN15@pattern_su@2
  0023c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  00241	48 85 c9	 test	 rcx, rcx
  00244	0f 8f be 00 00
	00		 jg	 $next$23910
$LN15@pattern_su@2:

; 2387 :             /* ignore empty match on latest position */
; 2388 :             goto next;
; 2389 : 
; 2390 :         if (filter_is_callable) {

  0024a	48 83 7c 24 48
	00		 cmp	 QWORD PTR $T27627[rsp], 0
  00250	74 67		 je	 SHORT $LN14@pattern_su@2

; 2391 :             /* pass match object through filter */
; 2392 :             match = pattern_new_match(self, &state, 1);

  00252	48 8d 55 b0	 lea	 rdx, QWORD PTR state$[rbp-256]
  00256	41 b8 01 00 00
	00		 mov	 r8d, 1
  0025c	49 8b cd	 mov	 rcx, r13
  0025f	e8 00 00 00 00	 call	 pattern_new_match
  00264	48 8b d8	 mov	 rbx, rax

; 2393 :             if (!match)

  00267	48 85 c0	 test	 rax, rax
  0026a	0f 84 4a 01 00
	00		 je	 $error$23897

; 2394 :                 goto error;
; 2395 :             args = PyTuple_Pack(1, match);

  00270	48 8b d0	 mov	 rdx, rax
  00273	b9 01 00 00 00	 mov	 ecx, 1
  00278	e8 00 00 00 00	 call	 PyTuple_Pack
  0027d	48 8b f0	 mov	 rsi, rax

; 2396 :             if (!args) {

  00280	48 85 c0	 test	 rax, rax
  00283	0f 84 9c 00 00
	00		 je	 $LN47@pattern_su@2

; 2398 :                 goto error;
; 2399 :             }
; 2400 :             item = PyObject_CallObject(filter, args);

  00289	48 8b d0	 mov	 rdx, rax
  0028c	49 8b cc	 mov	 rcx, r12
  0028f	e8 00 00 00 00	 call	 PyObject_CallObject

; 2401 :             Py_DECREF(args);

  00294	48 8b ce	 mov	 rcx, rsi
  00297	48 8b f8	 mov	 rdi, rax
  0029a	e8 00 00 00 00	 call	 _Py_DecRef

; 2402 :             Py_DECREF(match);

  0029f	48 8b cb	 mov	 rcx, rbx
  002a2	e8 00 00 00 00	 call	 _Py_DecRef

; 2403 :             if (!item)

  002a7	48 85 ff	 test	 rdi, rdi
  002aa	0f 84 0a 01 00
	00		 je	 $error$23897

; 2404 :                 goto error;
; 2405 :         } else {

  002b0	48 8b b5 08 07
	00 00		 mov	 rsi, QWORD PTR count$[rbp-256]
  002b7	eb 0b		 jmp	 SHORT $LN10@pattern_su@2
$LN14@pattern_su@2:

; 2406 :             /* filter is literal string */
; 2407 :             item = filter;
; 2408 :             Py_INCREF(item);

  002b9	49 8b cc	 mov	 rcx, r12
  002bc	49 8b fc	 mov	 rdi, r12
  002bf	e8 00 00 00 00	 call	 _Py_IncRef
$LN10@pattern_su@2:

; 2409 :         }
; 2410 : 
; 2411 :         /* add to list */
; 2412 :         if (item != Py_None) {

  002c4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  002cb	48 3b f8	 cmp	 rdi, rax
  002ce	74 1d		 je	 SHORT $LN8@pattern_su@2

; 2413 :             status = PyList_Append(list, item);

  002d0	48 8b d7	 mov	 rdx, rdi
  002d3	49 8b cf	 mov	 rcx, r15
  002d6	e8 00 00 00 00	 call	 PyList_Append

; 2414 :             Py_DECREF(item);

  002db	48 8b cf	 mov	 rcx, rdi
  002de	8b d8		 mov	 ebx, eax
  002e0	e8 00 00 00 00	 call	 _Py_DecRef

; 2415 :             if (status < 0)

  002e5	85 db		 test	 ebx, ebx
  002e7	0f 88 cd 00 00
	00		 js	 $error$23897
$LN8@pattern_su@2:

; 2416 :                 goto error;
; 2417 :         }
; 2418 : 
; 2419 :         i = e;
; 2420 :         n = n + 1;

  002ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  002f2	8b 7d ec	 mov	 edi, DWORD PTR state$[rbp-196]
  002f5	4c 8b 5d c0	 mov	 r11, QWORD PTR state$[rbp-240]
  002f9	4c 8b 4d b0	 mov	 r9, QWORD PTR state$[rbp-256]
  002fd	48 ff c1	 inc	 rcx
  00300	49 8b de	 mov	 rbx, r14
  00303	48 89 4c 24 30	 mov	 QWORD PTR n$[rsp], rcx
$next$23910:

; 2421 : 
; 2422 : next:
; 2423 :         /* move on */
; 2424 :         if (state.ptr == state.start)

  00308	4d 3b cb	 cmp	 r9, r11
  0030b	75 0f		 jne	 SHORT $LN7@pattern_su@2

; 2425 :             state.start = (void*) ((char*) state.ptr + state.charsize);

  0030d	48 63 c7	 movsxd	 rax, edi
  00310	49 03 c1	 add	 rax, r9
  00313	48 89 45 c0	 mov	 QWORD PTR state$[rbp-240], rax

; 2426 :         else

  00317	e9 56 fe ff ff	 jmp	 $LL27@pattern_su@2
$LN7@pattern_su@2:

; 2427 :             state.start = state.ptr;

  0031c	4c 89 4d c0	 mov	 QWORD PTR state$[rbp-240], r9

; 2428 : 
; 2429 :     }

  00320	e9 4d fe ff ff	 jmp	 $LL27@pattern_su@2
$LN47@pattern_su@2:

; 2397 :                 Py_DECREF(match);

  00325	48 8b cb	 mov	 rcx, rbx
  00328	e8 00 00 00 00	 call	 _Py_DecRef
  0032d	e9 88 00 00 00	 jmp	 $error$23897
$LN54@pattern_su@2:

; 2367 :             if (status == 0)

  00332	0f 85 7b 00 00
	00		 jne	 $LN20@pattern_su@2
$LN26@pattern_su@2:

; 2430 : 
; 2431 :     /* get segment following last match */
; 2432 :     if (i < state.endpos) {

  00338	4c 8b 45 e0	 mov	 r8, QWORD PTR state$[rbp-208]

; 2433 :         item = PySequence_GetSlice(string, i, state.endpos);

  0033c	4c 8b 74 24 38	 mov	 r14, QWORD PTR string$1$[rsp]
  00341	49 3b d8	 cmp	 rbx, r8
  00344	7d 2c		 jge	 SHORT $LN3@pattern_su@2
  00346	48 8b d3	 mov	 rdx, rbx
  00349	49 8b ce	 mov	 rcx, r14
  0034c	e8 00 00 00 00	 call	 PySequence_GetSlice
  00351	48 8b f8	 mov	 rdi, rax

; 2434 :         if (!item)

  00354	48 85 c0	 test	 rax, rax
  00357	74 61		 je	 SHORT $error$23897

; 2435 :             goto error;
; 2436 :         status = PyList_Append(list, item);

  00359	48 8b d0	 mov	 rdx, rax
  0035c	49 8b cf	 mov	 rcx, r15
  0035f	e8 00 00 00 00	 call	 PyList_Append

; 2437 :         Py_DECREF(item);

  00364	48 8b cf	 mov	 rcx, rdi
  00367	8b d8		 mov	 ebx, eax
  00369	e8 00 00 00 00	 call	 _Py_DecRef

; 2438 :         if (status < 0)

  0036e	85 db		 test	 ebx, ebx
  00370	78 48		 js	 SHORT $error$23897
$LN3@pattern_su@2:

; 2439 :             goto error;
; 2440 :     }
; 2441 : 
; 2442 :     state_fini(&state);

  00372	48 8d 4d b0	 lea	 rcx, QWORD PTR state$[rbp-256]
  00376	e8 00 00 00 00	 call	 state_fini

; 2443 : 
; 2444 :     Py_DECREF(filter);

  0037b	49 8b cc	 mov	 rcx, r12
  0037e	e8 00 00 00 00	 call	 _Py_DecRef

; 2445 : 
; 2446 :     /* convert list to single string (also removes list) */
; 2447 :     item = join_list(list, string);

  00383	49 8b d6	 mov	 rdx, r14
  00386	49 8b cf	 mov	 rcx, r15
  00389	e8 00 00 00 00	 call	 join_list

; 2448 : 
; 2449 :     if (!item)

  0038e	48 85 c0	 test	 rax, rax

; 2450 :         return NULL;

  00391	74 40		 je	 SHORT $LN53@pattern_su@2

; 2451 : 
; 2452 :     if (subn)

  00393	48 83 bd 10 07
	00 00 00	 cmp	 QWORD PTR subn$[rbp-256], 0
  0039b	74 38		 je	 SHORT $LN51@pattern_su@2

; 2453 :         return Py_BuildValue("Nn", item, n);

  0039d	4c 8b 44 24 30	 mov	 r8, QWORD PTR n$[rsp]
  003a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02IBMEMAAO@Nn?$AA@
  003a9	48 8b d0	 mov	 rdx, rax
  003ac	e8 00 00 00 00	 call	 _Py_BuildValue_SizeT
  003b1	eb 22		 jmp	 SHORT $LN51@pattern_su@2
$LN20@pattern_su@2:

; 2368 :                 break;
; 2369 :             pattern_error(status);

  003b3	8b cf		 mov	 ecx, edi
  003b5	e8 00 00 00 00	 call	 pattern_error
$error$23897:

; 2454 : 
; 2455 :     return item;
; 2456 : 
; 2457 : error:
; 2458 :     Py_DECREF(list);

  003ba	49 8b cf	 mov	 rcx, r15
  003bd	e8 00 00 00 00	 call	 _Py_DecRef

; 2459 :     state_fini(&state);

  003c2	48 8d 4d b0	 lea	 rcx, QWORD PTR state$[rbp-256]
  003c6	e8 00 00 00 00	 call	 state_fini

; 2460 :     Py_DECREF(filter);

  003cb	49 8b cc	 mov	 rcx, r12
  003ce	e8 00 00 00 00	 call	 _Py_DecRef
$LN53@pattern_su@2:

; 2461 :     return NULL;

  003d3	33 c0		 xor	 eax, eax
$LN51@pattern_su@2:
  003d5	4c 8b bc 24 f0
	07 00 00	 mov	 r15, QWORD PTR [rsp+2032]
$LN38@pattern_su@2:

; 2462 : 
; 2463 : }

  003dd	4c 8d 9c 24 c0
	07 00 00	 lea	 r11, QWORD PTR [rsp+1984]
  003e5	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  003e9	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  003ed	49 8b e3	 mov	 rsp, r11
  003f0	41 5e		 pop	 r14
  003f2	41 5d		 pop	 r13
  003f4	41 5c		 pop	 r12
  003f6	5f		 pop	 rdi
  003f7	5d		 pop	 rbp
  003f8	c3		 ret	 0
pattern_subx ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT sre_literal_template
_TEXT	SEGMENT
charsize$ = 8
ptr$ = 16
len$ = 24
sre_literal_template PROC				; COMDAT

; 1619 :     /* check if given string is a literal template (i.e. no escapes) */
; 1620 :     struct {
; 1621 :         int charsize;
; 1622 :     } state = {
; 1623 :         charsize
; 1624 :     };
; 1625 :     while (len-- > 0) {

  00000	4d 85 c0	 test	 r8, r8
  00003	7e 29		 jle	 SHORT $LN12@sre_litera
$LL3@sre_litera:
  00005	49 ff c8	 dec	 r8

; 1626 :         if (SRE_CHARGET((&state), ptr, 0) == '\\')

  00008	83 f9 01	 cmp	 ecx, 1
  0000b	75 05		 jne	 SHORT $LN8@sre_litera
  0000d	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00010	eb 0c		 jmp	 SHORT $LN7@sre_litera
$LN8@sre_litera:
  00012	83 f9 02	 cmp	 ecx, 2
  00015	75 05		 jne	 SHORT $LN6@sre_litera
  00017	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  0001a	eb 02		 jmp	 SHORT $LN7@sre_litera
$LN6@sre_litera:
  0001c	8b 02		 mov	 eax, DWORD PTR [rdx]
$LN7@sre_litera:
  0001e	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00021	74 11		 je	 SHORT $LN11@sre_litera

; 1628 :         ptr += charsize;

  00023	48 63 c1	 movsxd	 rax, ecx
  00026	48 03 d0	 add	 rdx, rax
  00029	4d 85 c0	 test	 r8, r8
  0002c	7f d7		 jg	 SHORT $LL3@sre_litera
$LN12@sre_litera:

; 1629 :     }
; 1630 :     return 1;

  0002e	b8 01 00 00 00	 mov	 eax, 1

; 1631 : }

  00033	c3		 ret	 0
$LN11@sre_litera:

; 1627 :             return 0;

  00034	33 c0		 xor	 eax, eax

; 1631 : }

  00036	c3		 ret	 0
sre_literal_template ENDP
_TEXT	ENDS
EXTRN	PyImport_Import:PROC
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$call DD	imagerel call
	DD	imagerel call+34
	DD	imagerel $unwind$call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$call DD imagerel call+34
	DD	imagerel call+68
	DD	imagerel $chain$0$call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$call DD imagerel call+68
	DD	imagerel call+182
	DD	imagerel $chain$3$call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$call DD 040821H
	DD	077408H
	DD	063400H
	DD	imagerel call
	DD	imagerel call+34
	DD	imagerel $unwind$call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$call DD 020521H
	DD	063405H
	DD	imagerel call
	DD	imagerel call+34
	DD	imagerel $unwind$call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call DD	040a01H
	DD	08540aH
	DD	06006320aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT call
_TEXT	SEGMENT
module$ = 48
function$ = 56
args$ = 64
call	PROC						; COMDAT

; 1954 : {

  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f0	 mov	 rsi, r8
  0000d	48 8b ea	 mov	 rbp, rdx

; 1955 :     PyObject* name;
; 1956 :     PyObject* mod;
; 1957 :     PyObject* func;
; 1958 :     PyObject* result;
; 1959 : 
; 1960 :     if (!args)

  00010	4d 85 c0	 test	 r8, r8
  00013	75 0d		 jne	 SHORT $LN4@call

; 1961 :         return NULL;

  00015	33 c0		 xor	 eax, eax

; 1977 : }

  00017	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5e		 pop	 rsi
  00021	c3		 ret	 0
$LN4@call:
  00022	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 1962 :     name = PyUnicode_FromString(module);

  00027	e8 00 00 00 00	 call	 PyUnicode_FromString
  0002c	48 8b d8	 mov	 rbx, rax

; 1963 :     if (!name)

  0002f	48 85 c0	 test	 rax, rax
  00032	75 10		 jne	 SHORT $LN3@call
  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 1977 : }

  00039	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5e		 pop	 rsi
  00043	c3		 ret	 0
$LN3@call:

; 1964 :         return NULL;
; 1965 :     mod = PyImport_Import(name);

  00044	48 8b c8	 mov	 rcx, rax
  00047	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004c	e8 00 00 00 00	 call	 PyImport_Import

; 1966 :     Py_DECREF(name);

  00051	48 8b cb	 mov	 rcx, rbx
  00054	48 8b f8	 mov	 rdi, rax
  00057	e8 00 00 00 00	 call	 _Py_DecRef

; 1967 :     if (!mod)

  0005c	48 85 ff	 test	 rdi, rdi

; 1968 :         return NULL;

  0005f	74 1b		 je	 SHORT $LN9@call

; 1969 :     func = PyObject_GetAttrString(mod, function);

  00061	48 8b d5	 mov	 rdx, rbp
  00064	48 8b cf	 mov	 rcx, rdi
  00067	e8 00 00 00 00	 call	 PyObject_GetAttrString

; 1970 :     Py_DECREF(mod);

  0006c	48 8b cf	 mov	 rcx, rdi
  0006f	48 8b e8	 mov	 rbp, rax
  00072	e8 00 00 00 00	 call	 _Py_DecRef

; 1971 :     if (!func)

  00077	48 85 ed	 test	 rbp, rbp
  0007a	75 04		 jne	 SHORT $LN1@call
$LN9@call:

; 1972 :         return NULL;

  0007c	33 c0		 xor	 eax, eax
  0007e	eb 21		 jmp	 SHORT $LN8@call
$LN1@call:

; 1973 :     result = PyObject_CallObject(func, args);

  00080	48 8b d6	 mov	 rdx, rsi
  00083	48 8b cd	 mov	 rcx, rbp
  00086	e8 00 00 00 00	 call	 PyObject_CallObject

; 1974 :     Py_DECREF(func);

  0008b	48 8b cd	 mov	 rcx, rbp
  0008e	48 8b d8	 mov	 rbx, rax
  00091	e8 00 00 00 00	 call	 _Py_DecRef

; 1975 :     Py_DECREF(args);

  00096	48 8b ce	 mov	 rcx, rsi
  00099	e8 00 00 00 00	 call	 _Py_DecRef

; 1976 :     return result;

  0009e	48 8b c3	 mov	 rax, rbx
$LN8@call:

; 1977 : }

  000a1	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  000a6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ab	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000b0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b4	5e		 pop	 rsi
  000b5	c3		 ret	 0
call	ENDP
_TEXT	ENDS
PUBLIC	??_C@_04DFGCDGNN@join?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$join_list DD imagerel join_list
	DD	imagerel join_list+87
	DD	imagerel $unwind$join_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$join_list DD imagerel join_list+87
	DD	imagerel join_list+131
	DD	imagerel $chain$0$join_list
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$join_list DD imagerel join_list+131
	DD	imagerel join_list+237
	DD	imagerel $chain$3$join_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$join_list DD 040a21H
	DD	06540aH
	DD	076400H
	DD	imagerel join_list
	DD	imagerel join_list+87
	DD	imagerel $unwind$join_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$join_list DD 020521H
	DD	076405H
	DD	imagerel join_list
	DD	imagerel join_list+87
	DD	imagerel $unwind$join_list
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$join_list DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_04DFGCDGNN@join?$AA@
CONST	SEGMENT
??_C@_04DFGCDGNN@join?$AA@ DB 'join', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT join_list
_TEXT	SEGMENT
list$ = 48
string$ = 56
join_list PROC						; COMDAT

; 2001 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b c2	 mov	 rax, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 2002 :     /* join list elements */
; 2003 : 
; 2004 :     PyObject* joiner;
; 2005 : #if PY_VERSION_HEX >= 0x01060000
; 2006 :     PyObject* function;
; 2007 :     PyObject* args;
; 2008 : #endif
; 2009 :     PyObject* result;
; 2010 : 
; 2011 :     joiner = PySequence_GetSlice(string, 0, 0);

  00010	45 33 c0	 xor	 r8d, r8d
  00013	48 8b c8	 mov	 rcx, rax
  00016	33 d2		 xor	 edx, edx
  00018	e8 00 00 00 00	 call	 PySequence_GetSlice
  0001d	48 8b f8	 mov	 rdi, rax

; 2012 :     if (!joiner)

  00020	48 85 c0	 test	 rax, rax
  00023	75 0b		 jne	 SHORT $LN4@join_list

; 2045 : }

  00025	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
$LN4@join_list:

; 2013 :         return NULL;
; 2014 : 
; 2015 :     if (PyList_GET_SIZE(list) == 0) {

  00030	48 83 7b 60 00	 cmp	 QWORD PTR [rbx+96], 0
  00035	75 16		 jne	 SHORT $LN3@join_list

; 2016 :         Py_DECREF(list);

  00037	48 8b cb	 mov	 rcx, rbx
  0003a	e8 00 00 00 00	 call	 _Py_DecRef

; 2017 :         return joiner;

  0003f	48 8b c7	 mov	 rax, rdi

; 2045 : }

  00042	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5f		 pop	 rdi
  0004c	c3		 ret	 0
$LN3@join_list:

; 2018 :     }
; 2019 : 
; 2020 : #if PY_VERSION_HEX >= 0x01060000
; 2021 :     function = PyObject_GetAttrString(joiner, "join");

  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04DFGCDGNN@join?$AA@
  00054	48 8b c8	 mov	 rcx, rax
  00057	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0005c	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00061	48 8b f0	 mov	 rsi, rax

; 2022 :     if (!function) {

  00064	48 85 c0	 test	 rax, rax
  00067	75 1a		 jne	 SHORT $LN2@join_list

; 2023 :         Py_DECREF(joiner);

  00069	48 8b cf	 mov	 rcx, rdi
  0006c	e8 00 00 00 00	 call	 _Py_DecRef
  00071	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 2024 :         return NULL;

  00076	33 c0		 xor	 eax, eax

; 2045 : }

  00078	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
$LN2@join_list:

; 2025 :     }
; 2026 :     args = PyTuple_New(1);

  00083	b9 01 00 00 00	 mov	 ecx, 1
  00088	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0008d	e8 00 00 00 00	 call	 PyTuple_New

; 2027 :     if (!args) {
; 2028 :         Py_DECREF(function);

  00092	48 8b ce	 mov	 rcx, rsi
  00095	48 8b e8	 mov	 rbp, rax
  00098	48 85 c0	 test	 rax, rax
  0009b	75 11		 jne	 SHORT $LN1@join_list
  0009d	e8 00 00 00 00	 call	 _Py_DecRef

; 2029 :         Py_DECREF(joiner);

  000a2	48 8b cf	 mov	 rcx, rdi
  000a5	e8 00 00 00 00	 call	 _Py_DecRef

; 2030 :         return NULL;

  000aa	33 c0		 xor	 eax, eax
  000ac	eb 2a		 jmp	 SHORT $LN8@join_list
$LN1@join_list:

; 2031 :     }
; 2032 :     PyTuple_SET_ITEM(args, 0, list);
; 2033 :     result = PyObject_CallObject(function, args);

  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 89 58 70	 mov	 QWORD PTR [rax+112], rbx
  000b5	e8 00 00 00 00	 call	 PyObject_CallObject

; 2034 :     Py_DECREF(args); /* also removes list */

  000ba	48 8b cd	 mov	 rcx, rbp
  000bd	48 8b d8	 mov	 rbx, rax
  000c0	e8 00 00 00 00	 call	 _Py_DecRef

; 2035 :     Py_DECREF(function);

  000c5	48 8b ce	 mov	 rcx, rsi
  000c8	e8 00 00 00 00	 call	 _Py_DecRef

; 2036 : #else
; 2037 :     result = call(
; 2038 :         "string", "join",
; 2039 :         PyTuple_Pack(2, list, joiner)
; 2040 :         );
; 2041 : #endif
; 2042 :     Py_DECREF(joiner);

  000cd	48 8b cf	 mov	 rcx, rdi
  000d0	e8 00 00 00 00	 call	 _Py_DecRef

; 2043 : 
; 2044 :     return result;

  000d5	48 8b c3	 mov	 rax, rbx
$LN8@join_list:

; 2045 : }

  000d8	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  000dd	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000e2	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000e7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000eb	5f		 pop	 rdi
  000ec	c3		 ret	 0
join_list ENDP
_TEXT	ENDS
PUBLIC	??_C@_09KFMGADAI@OO?$HMn?3subn?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_subn DD imagerel pattern_subn
	DD	imagerel pattern_subn+124
	DD	imagerel $unwind$pattern_subn
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_subn DD 020801H
	DD	030049208H
xdata	ENDS
;	COMDAT ??_C@_09KFMGADAI@OO?$HMn?3subn?$AA@
CONST	SEGMENT
??_C@_09KFMGADAI@OO?$HMn?3subn?$AA@ DB 'OO|n:subn', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT pattern_subn
_TEXT	SEGMENT
string$ = 64
ptemplate$ = 72
self$ = 96
args$ = 104
kw$ = 112
count$ = 120
pattern_subn PROC					; COMDAT

; 2481 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00008	48 8b d9	 mov	 rbx, rcx

; 2482 :     PyObject* ptemplate;
; 2483 :     PyObject* string;
; 2484 :     Py_ssize_t count = 0;
; 2485 :     static char* kwlist[] = { "repl", "string", "count", NULL };
; 2486 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|n:subn", kwlist,
; 2487 :                                      &ptemplate, &string, &count))

  0000b	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  0000f	49 8b c0	 mov	 rax, r8
  00012	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00016	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  0001a	4c 8b d2	 mov	 r10, rdx
  0001d	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  00021	49 8d 4b f0	 lea	 rcx, QWORD PTR [r11-16]
  00025	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_subn@@9@9
  0002c	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00030	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09KFMGADAI@OO?$HMn?3subn?$AA@
  00037	48 8b d0	 mov	 rdx, rax
  0003a	49 8b ca	 mov	 rcx, r10
  0003d	49 c7 43 20 00
	00 00 00	 mov	 QWORD PTR [r11+32], 0
  00045	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0004a	85 c0		 test	 eax, eax
  0004c	75 08		 jne	 SHORT $LN1@pattern_su@3

; 2488 :         return NULL;

  0004e	33 c0		 xor	 eax, eax

; 2491 : }

  00050	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
$LN1@pattern_su@3:

; 2489 : 
; 2490 :     return pattern_subx(self, ptemplate, string, count, 1);

  00056	4c 8b 4c 24 78	 mov	 r9, QWORD PTR count$[rsp]
  0005b	4c 8b 44 24 40	 mov	 r8, QWORD PTR string$[rsp]
  00060	48 8b 54 24 48	 mov	 rdx, QWORD PTR ptemplate$[rsp]
  00065	48 8b cb	 mov	 rcx, rbx
  00068	48 c7 44 24 20
	01 00 00 00	 mov	 QWORD PTR [rsp+32], 1
  00071	e8 00 00 00 00	 call	 pattern_subx

; 2491 : }

  00076	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0007a	5b		 pop	 rbx
  0007b	c3		 ret	 0
pattern_subn ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@FCKMIBIP@cannot?5copy?5this?5pattern?5object?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_copy DD imagerel pattern_copy
	DD	imagerel pattern_copy+30
	DD	imagerel $unwind$pattern_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_copy DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CA@FCKMIBIP@cannot?5copy?5this?5pattern?5object?$AA@
CONST	SEGMENT
??_C@_0CA@FCKMIBIP@cannot?5copy?5this?5pattern?5object?$AA@ DB 'cannot co'
	DB	'py this pattern object', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT pattern_copy
_TEXT	SEGMENT
self$ = 48
unused$ = 56
pattern_copy PROC					; COMDAT

; 2495 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2496 : #ifdef USE_BUILTIN_COPY
; 2497 :     PatternObject* copy;
; 2498 :     int offset;
; 2499 : 
; 2500 :     copy = PyObject_NEW_VAR(PatternObject, &Pattern_Type, self->codesize);
; 2501 :     if (!copy)
; 2502 :         return NULL;
; 2503 : 
; 2504 :     offset = offsetof(PatternObject, groups);
; 2505 : 
; 2506 :     Py_XINCREF(self->groupindex);
; 2507 :     Py_XINCREF(self->indexgroup);
; 2508 :     Py_XINCREF(self->pattern);
; 2509 : 
; 2510 :     memcpy((char*) copy + offset, (char*) self + offset,
; 2511 :            sizeof(PatternObject) + self->codesize * sizeof(SRE_CODE) - offset);
; 2512 :     copy->weakreflist = NULL;
; 2513 : 
; 2514 :     return (PyObject*) copy;
; 2515 : #else
; 2516 :     PyErr_SetString(PyExc_TypeError, "cannot copy this pattern object");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@FCKMIBIP@cannot?5copy?5this?5pattern?5object?$AA@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 2517 :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 2518 : #endif
; 2519 : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
pattern_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@JJCFKNNG@cannot?5deepcopy?5this?5pattern?5obj@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_deepcopy DD imagerel pattern_deepcopy
	DD	imagerel pattern_deepcopy+30
	DD	imagerel $unwind$pattern_deepcopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_deepcopy DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CE@JJCFKNNG@cannot?5deepcopy?5this?5pattern?5obj@
CONST	SEGMENT
??_C@_0CE@JJCFKNNG@cannot?5deepcopy?5this?5pattern?5obj@ DB 'cannot deepc'
	DB	'opy this pattern object', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT pattern_deepcopy
_TEXT	SEGMENT
self$ = 48
memo$ = 56
pattern_deepcopy PROC					; COMDAT

; 2523 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2524 : #ifdef USE_BUILTIN_COPY
; 2525 :     PatternObject* copy;
; 2526 : 
; 2527 :     copy = (PatternObject*) pattern_copy(self);
; 2528 :     if (!copy)
; 2529 :         return NULL;
; 2530 : 
; 2531 :     if (!deepcopy(&copy->groupindex, memo) ||
; 2532 :         !deepcopy(&copy->indexgroup, memo) ||
; 2533 :         !deepcopy(&copy->pattern, memo)) {
; 2534 :         Py_DECREF(copy);
; 2535 :         return NULL;
; 2536 :     }
; 2537 : 
; 2538 : #else
; 2539 :     PyErr_SetString(PyExc_TypeError, "cannot deepcopy this pattern object");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@JJCFKNNG@cannot?5deepcopy?5this?5pattern?5obj@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 2540 :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 2541 : #endif
; 2542 : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
pattern_deepcopy ENDP
_TEXT	ENDS
PUBLIC	??_C@_08ECDGFLNN@OiO?$CB?$HMnOO?$AA@		; `string'
EXTRN	PyLong_AsUnsignedLong:PROC
EXTRN	PyList_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$_compile DD imagerel _compile
	DD	imagerel _compile+169
	DD	imagerel $unwind$_compile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_compile DD imagerel _compile+169
	DD	imagerel _compile+236
	DD	imagerel $chain$3$_compile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$_compile DD imagerel _compile+236
	DD	imagerel _compile+297
	DD	imagerel $chain$4$_compile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$_compile DD imagerel _compile+297
	DD	imagerel _compile+319
	DD	imagerel $chain$5$_compile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$_compile DD imagerel _compile+319
	DD	imagerel _compile+535
	DD	imagerel $chain$6$_compile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$_compile DD imagerel _compile+535
	DD	imagerel _compile+561
	DD	imagerel $chain$7$_compile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$_compile DD 021H
	DD	imagerel _compile
	DD	imagerel _compile+169
	DD	imagerel $unwind$_compile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$_compile DD 020021H
	DD	010c400H
	DD	imagerel _compile
	DD	imagerel _compile+169
	DD	imagerel $unwind$_compile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$_compile DD 021H
	DD	imagerel _compile+169
	DD	imagerel _compile+236
	DD	imagerel $chain$3$_compile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$_compile DD 020821H
	DD	0135408H
	DD	imagerel _compile+169
	DD	imagerel _compile+236
	DD	imagerel $chain$3$_compile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_compile DD 041021H
	DD	010c410H
	DD	0126408H
	DD	imagerel _compile
	DD	imagerel _compile+169
	DD	imagerel $unwind$_compile
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_compile DD 078a01H
	DD	011748aH
	DD	0163482H
	DD	014010cH
	DD	0d005H
xdata	ENDS
;	COMDAT ??_C@_08ECDGFLNN@OiO?$CB?$HMnOO?$AA@
CONST	SEGMENT
??_C@_08ECDGFLNN@OiO?$CB?$HMnOO?$AA@ DB 'OiO!|nOO', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _compile
_TEXT	SEGMENT
groupindex$ = 80
indexgroup$ = 88
code$ = 96
groups$ = 104
p_length$24108 = 112
self_$ = 176
args$ = 184
flags$ = 192
pattern$ = 200
_compile PROC						; COMDAT

; 2647 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	41 55		 push	 r13
  00005	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 2648 :     /* "compile" pattern descriptor to pattern object */
; 2649 : 
; 2650 :     PatternObject* self;
; 2651 :     Py_ssize_t i, n;
; 2652 : 
; 2653 :     PyObject* pattern;
; 2654 :     int flags = 0;

  0000c	45 33 ed	 xor	 r13d, r13d

; 2655 :     PyObject* code;
; 2656 :     Py_ssize_t groups = 0;
; 2657 :     PyObject* groupindex = NULL;
; 2658 :     PyObject* indexgroup = NULL;
; 2659 : 
; 2660 :     if (!PyArg_ParseTuple(args, "OiO!|nOO", &pattern, &flags,
; 2661 :                           &PyList_Type, &code, &groups,
; 2662 :                           &groupindex, &indexgroup))

  0000f	49 8d 4b b0	 lea	 rcx, QWORD PTR [r11-80]
  00013	48 8b c2	 mov	 rax, rdx
  00016	49 89 4b 98	 mov	 QWORD PTR [r11-104], rcx
  0001a	49 8d 4b a8	 lea	 rcx, QWORD PTR [r11-88]
  0001e	4d 8d 4b 18	 lea	 r9, QWORD PTR [r11+24]
  00022	49 89 4b 90	 mov	 QWORD PTR [r11-112], rcx
  00026	49 8d 4b c0	 lea	 rcx, QWORD PTR [r11-64]
  0002a	4d 8d 43 20	 lea	 r8, QWORD PTR [r11+32]
  0002e	49 89 4b 88	 mov	 QWORD PTR [r11-120], rcx
  00032	49 8d 4b b8	 lea	 rcx, QWORD PTR [r11-72]
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08ECDGFLNN@OiO?$CB?$HMnOO?$AA@
  0003d	49 89 4b 80	 mov	 QWORD PTR [r11-128], rcx
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyList_Type
  00048	45 89 6b 18	 mov	 DWORD PTR [r11+24], r13d
  0004c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00051	48 8b c8	 mov	 rcx, rax
  00054	4d 89 6b c0	 mov	 QWORD PTR [r11-64], r13
  00058	4d 89 6b a8	 mov	 QWORD PTR [r11-88], r13
  0005c	4d 89 6b b0	 mov	 QWORD PTR [r11-80], r13
  00060	e8 00 00 00 00	 call	 _PyArg_ParseTuple_SizeT
  00065	85 c0		 test	 eax, eax
  00067	75 0c		 jne	 SHORT $LN19@compile

; 2663 :         return NULL;

  00069	33 c0		 xor	 eax, eax

; 2728 : }

  0006b	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00072	41 5d		 pop	 r13
  00074	c3		 ret	 0
$LN19@compile:

; 2664 : 
; 2665 :     n = PyList_GET_SIZE(code);

  00075	48 8b 44 24 60	 mov	 rax, QWORD PTR code$[rsp]
  0007a	48 89 9c 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rbx
  00082	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rdi
  0008a	48 8b 78 60	 mov	 rdi, QWORD PTR [rax+96]

; 2666 :     /* coverity[ampersand_in_size] */
; 2667 :     self = PyObject_NEW_VAR(PatternObject, &Pattern_Type, n);

  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pattern_Type
  00095	48 8b d7	 mov	 rdx, rdi
  00098	e8 00 00 00 00	 call	 _PyObject_NEW_VAR
  0009d	48 8b d8	 mov	 rbx, rax

; 2668 :     if (!self)

  000a0	48 85 c0	 test	 rax, rax
  000a3	0f 84 6e 01 00
	00		 je	 $LN26@compile
$LN18@compile:
  000a9	48 89 b4 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rsi
  000b1	4c 89 a4 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], r12

; 2671 :     self->pattern = NULL;
; 2672 :     self->groupindex = NULL;
; 2673 :     self->indexgroup = NULL;
; 2674 :     self->view.buf = NULL;

  000b9	4c 8d a0 a8 00
	00 00		 lea	 r12, QWORD PTR [rax+168]
  000c0	4c 89 a8 98 00
	00 00		 mov	 QWORD PTR [rax+152], r13
  000c7	4c 89 a8 88 00
	00 00		 mov	 QWORD PTR [rax+136], r13
  000ce	4c 89 68 78	 mov	 QWORD PTR [rax+120], r13
  000d2	4d 89 2c 24	 mov	 QWORD PTR [r12], r13
  000d6	4c 89 a8 80 00
	00 00		 mov	 QWORD PTR [rax+128], r13

; 2675 : 
; 2676 :     self->codesize = n;

  000dd	48 89 b8 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rdi

; 2677 : 
; 2678 :     for (i = 0; i < n; i++) {

  000e4	49 8b f5	 mov	 rsi, r13
  000e7	48 85 ff	 test	 rdi, rdi
  000ea	7e 3d		 jle	 SHORT $LN15@compile

; 2669 :         return NULL;
; 2670 :     self->weakreflist = NULL;

  000ec	48 89 ac 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rbp
  000f4	48 8d a8 00 01
	00 00		 lea	 rbp, QWORD PTR [rax+256]
  000fb	0f 1f 44 00 00	 npad	 5
$LL17@compile:

; 2679 :         PyObject *o = PyList_GET_ITEM(code, i);

  00100	48 8b 44 24 60	 mov	 rax, QWORD PTR code$[rsp]
  00105	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]

; 2680 :         unsigned long value = PyLong_AsUnsignedLong(o);

  00109	48 8b 0c f1	 mov	 rcx, QWORD PTR [rcx+rsi*8]
  0010d	e8 00 00 00 00	 call	 PyLong_AsUnsignedLong
  00112	48 ff c6	 inc	 rsi
  00115	48 83 c5 04	 add	 rbp, 4
  00119	89 45 fc	 mov	 DWORD PTR [rbp-4], eax
  0011c	48 3b f7	 cmp	 rsi, rdi
  0011f	7c df		 jl	 SHORT $LL17@compile
  00121	48 8b ac 24 98
	00 00 00	 mov	 rbp, QWORD PTR [rsp+152]
$LN15@compile:

; 2681 :         self->code[i] = (SRE_CODE) value;
; 2682 :         if ((unsigned long) self->code[i] != value) {
; 2683 :             PyErr_SetString(PyExc_OverflowError,
; 2684 :                             "regular expression code size limit exceeded");
; 2685 :             break;
; 2686 :         }
; 2687 :     }
; 2688 : 
; 2689 :     if (PyErr_Occurred()) {

  00129	e8 00 00 00 00	 call	 PyErr_Occurred
  0012e	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR [rsp+144]
  00136	48 85 c0	 test	 rax, rax

; 2690 :         Py_DECREF(self);
; 2691 :         return NULL;

  00139	0f 85 c1 00 00
	00		 jne	 $LN28@compile

; 2692 :     }
; 2693 : 
; 2694 :     if (pattern == Py_None) {

  0013f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pattern$[rsp]
  00147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0014e	48 3b c8	 cmp	 rcx, rax
  00151	75 0d		 jne	 SHORT $LN12@compile

; 2695 :         self->logical_charsize = -1;

  00153	48 c7 83 a0 00
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rbx+160], -1

; 2696 :         self->charsize = -1;
; 2697 :     }
; 2698 :     else {

  0015e	eb 22		 jmp	 SHORT $LN10@compile
$LN12@compile:

; 2699 :         Py_ssize_t p_length;
; 2700 :         if (!getstring(pattern, &p_length, &self->logical_charsize,
; 2701 :                        &self->charsize, &self->view)) {

  00160	4c 8d 8b a4 00
	00 00		 lea	 r9, QWORD PTR [rbx+164]
  00167	4c 8d 83 a0 00
	00 00		 lea	 r8, QWORD PTR [rbx+160]
  0016e	48 8d 54 24 70	 lea	 rdx, QWORD PTR p_length$24108[rsp]
  00173	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00178	e8 00 00 00 00	 call	 getstring
  0017d	48 85 c0	 test	 rax, rax

; 2702 :             Py_DECREF(self);
; 2703 :             return NULL;

  00180	74 7e		 je	 SHORT $LN28@compile
$LN10@compile:

; 2704 :         }
; 2705 :     }
; 2706 : 
; 2707 :     Py_INCREF(pattern);

  00182	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pattern$[rsp]
  0018a	e8 00 00 00 00	 call	 _Py_IncRef

; 2708 :     self->pattern = pattern;

  0018f	4c 8b 9c 24 c8
	00 00 00	 mov	 r11, QWORD PTR pattern$[rsp]
  00197	4c 89 9b 88 00
	00 00		 mov	 QWORD PTR [rbx+136], r11

; 2709 : 
; 2710 :     self->flags = flags;

  0019e	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  001a5	89 83 90 00 00
	00		 mov	 DWORD PTR [rbx+144], eax

; 2711 : 
; 2712 :     self->groups = groups;

  001ab	48 8b 44 24 68	 mov	 rax, QWORD PTR groups$[rsp]
  001b0	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 2713 : 
; 2714 :     Py_XINCREF(groupindex);

  001b4	48 8b 44 24 50	 mov	 rax, QWORD PTR groupindex$[rsp]
  001b9	48 85 c0	 test	 rax, rax
  001bc	74 0d		 je	 SHORT $LN8@compile
  001be	48 8b c8	 mov	 rcx, rax
  001c1	e8 00 00 00 00	 call	 _Py_IncRef
  001c6	48 8b 44 24 50	 mov	 rax, QWORD PTR groupindex$[rsp]
$LN8@compile:

; 2715 :     self->groupindex = groupindex;

  001cb	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 2716 : 
; 2717 :     Py_XINCREF(indexgroup);

  001cf	48 8b 44 24 58	 mov	 rax, QWORD PTR indexgroup$[rsp]
  001d4	48 85 c0	 test	 rax, rax
  001d7	74 0d		 je	 SHORT $LN4@compile
  001d9	48 8b c8	 mov	 rcx, rax
  001dc	e8 00 00 00 00	 call	 _Py_IncRef
  001e1	48 8b 44 24 58	 mov	 rax, QWORD PTR indexgroup$[rsp]
$LN4@compile:

; 2718 :     self->indexgroup = indexgroup;
; 2719 : 
; 2720 :     self->weakreflist = NULL;
; 2721 : 
; 2722 :     if (!_validate(self)) {

  001e6	48 8b cb	 mov	 rcx, rbx
  001e9	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax
  001f0	4c 89 ab 98 00
	00 00		 mov	 QWORD PTR [rbx+152], r13
  001f7	e8 00 00 00 00	 call	 _validate
  001fc	85 c0		 test	 eax, eax
  001fe	75 0c		 jne	 SHORT $LN1@compile
$LN28@compile:

; 2723 :         Py_DECREF(self);

  00200	48 8b cb	 mov	 rcx, rbx
  00203	e8 00 00 00 00	 call	 _Py_DecRef

; 2724 :         return NULL;

  00208	33 c0		 xor	 eax, eax
  0020a	eb 03		 jmp	 SHORT $LN27@compile
$LN1@compile:

; 2725 :     }
; 2726 : 
; 2727 :     return (PyObject*) self;

  0020c	48 8b c3	 mov	 rax, rbx
$LN27@compile:
  0020f	4c 8b a4 24 80
	00 00 00	 mov	 r12, QWORD PTR [rsp+128]
$LN26@compile:
  00217	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+176]
  0021f	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR [rsp+136]

; 2728 : }

  00227	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0022e	41 5d		 pop	 r13
  00230	c3		 ret	 0
_compile ENDP
_TEXT	ENDS
EXTRN	PyObject_InitVar:PROC
EXTRN	_PxObject_NewVar:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$_PyObject_NEW_VAR DD imagerel _PyObject_NEW_VAR
	DD	imagerel _PyObject_NEW_VAR+117
	DD	imagerel $unwind$_PyObject_NEW_VAR
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_NEW_VAR DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_NEW_VAR
_TEXT	SEGMENT
op$ = 32
tp$ = 64
n$ = 72
_PyObject_NEW_VAR PROC					; COMDAT

; 301  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 302  :     register PyObject *op;
; 303  :     Px_RETURN(_PxObject_NewVar(tp, n))

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 11		 je	 SHORT $LN1@PyObject_N
  00017	48 8b 54 24 48	 mov	 rdx, QWORD PTR n$[rsp]
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tp$[rsp]
  00021	e8 00 00 00 00	 call	 _PxObject_NewVar
  00026	eb 48		 jmp	 SHORT $LN2@PyObject_N
$LN1@PyObject_N:

; 304  :     op = (PyObject *)PyObject_MALLOC(_PyObject_VAR_SIZE(tp, n));

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR tp$[rsp]
  0002d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR n$[rsp]
  00032	48 0f af 88 80
	00 00 00	 imul	 rcx, QWORD PTR [rax+128]
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tp$[rsp]
  00042	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00046	48 8d 44 01 07	 lea	 rax, QWORD PTR [rcx+rax+7]
  0004b	48 83 e0 f8	 and	 rax, -8
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00057	48 89 44 24 20	 mov	 QWORD PTR op$[rsp], rax

; 305  :     return (PyVarObject *)PyObject_InitVar((PyVarObject*)op, tp, n);

  0005c	4c 8b 44 24 48	 mov	 r8, QWORD PTR n$[rsp]
  00061	48 8b 54 24 40	 mov	 rdx, QWORD PTR tp$[rsp]
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op$[rsp]
  0006b	e8 00 00 00 00	 call	 PyObject_InitVar
$LN2@PyObject_N:

; 306  : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
_PyObject_NEW_VAR ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@CBNGNFNM@invalid?5SRE?5code?$AA@	; `string'
;	COMDAT pdata
; File c:\src\pyparallel\modules\_sre.c
pdata	SEGMENT
$pdata$_validate DD imagerel _validate
	DD	imagerel _validate+75
	DD	imagerel $unwind$_validate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_validate DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BB@CBNGNFNM@invalid?5SRE?5code?$AA@
CONST	SEGMENT
??_C@_0BB@CBNGNFNM@invalid?5SRE?5code?$AA@ DB 'invalid SRE code', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _validate
_TEXT	SEGMENT
self$ = 48
_validate PROC						; COMDAT

; 3182 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3183 :     if (!_validate_outer(self->code, self->code+self->codesize, self->groups))

  00004	48 8b 81 f8 00
	00 00		 mov	 rax, QWORD PTR [rcx+248]
  0000b	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  0000f	48 8d 94 81 00
	01 00 00	 lea	 rdx, QWORD PTR [rcx+rax*4+256]
  00017	48 81 c1 00 01
	00 00		 add	 rcx, 256		; 00000100H
  0001e	e8 00 00 00 00	 call	 _validate_outer
  00023	85 c0		 test	 eax, eax
  00025	75 1a		 jne	 SHORT $LN3@validate

; 3184 :     {
; 3185 :         PyErr_SetString(PyExc_RuntimeError, "invalid SRE code");

  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@CBNGNFNM@invalid?5SRE?5code?$AA@
  00035	e8 00 00 00 00	 call	 PyErr_SetString

; 3186 :         return 0;

  0003a	33 c0		 xor	 eax, eax

; 3191 : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
$LN3@validate:

; 3187 :     }
; 3188 :     else
; 3189 :         VTRACE(("Success!\n"));
; 3190 :     return 1;

  00041	b8 01 00 00 00	 mov	 eax, 1

; 3191 : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
_validate ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _validate_outer
_TEXT	SEGMENT
code$ = 8
end$ = 16
groups$ = 24
_validate_outer PROC					; COMDAT

; 3173 :     if (groups < 0 || groups > 100 || code >= end || end[-1] != SRE_OP_SUCCESS)

  00000	49 83 f8 64	 cmp	 r8, 100			; 00000064H
  00004	77 1f		 ja	 SHORT $LN7@validate_o
  00006	48 3b ca	 cmp	 rcx, rdx
  00009	73 1a		 jae	 SHORT $LN7@validate_o
  0000b	48 83 c2 fc	 add	 rdx, -4
  0000f	83 3a 01	 cmp	 DWORD PTR [rdx], 1
  00012	75 11		 jne	 SHORT $LN7@validate_o

; 3175 :     if (groups == 0)  /* fix for simplejson */

  00014	b8 64 00 00 00	 mov	 eax, 100		; 00000064H
  00019	4d 85 c0	 test	 r8, r8
  0001c	4c 0f 44 c0	 cmove	 r8, rax

; 3176 :         groups = 100; /* 100 groups should always be safe */
; 3177 :     return _validate_inner(code, end-1, groups);
; 3178 : }

  00020	e9 00 00 00 00	 jmp	 _validate_inner
$LN7@validate_o:

; 3174 :         FAIL;

  00025	33 c0		 xor	 eax, eax

; 3176 :         groups = 100; /* 100 groups should always be safe */
; 3177 :     return _validate_inner(code, end-1, groups);
; 3178 : }

  00027	c3		 ret	 0
_validate_outer ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_validate_inner DD imagerel _validate_inner
	DD	imagerel _validate_inner+39
	DD	imagerel $unwind$_validate_inner
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$_validate_inner DD imagerel _validate_inner+39
	DD	imagerel _validate_inner+1360
	DD	imagerel $chain$1$_validate_inner
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$_validate_inner DD imagerel _validate_inner+1360
	DD	imagerel _validate_inner+1444
	DD	imagerel $chain$3$_validate_inner
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$_validate_inner DD 040021H
	DD	076400H
	DD	065400H
	DD	imagerel _validate_inner
	DD	imagerel _validate_inner+39
	DD	imagerel $unwind$_validate_inner
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$_validate_inner DD 040d21H
	DD	07640dH
	DD	065405H
	DD	imagerel _validate_inner
	DD	imagerel _validate_inner+39
	DD	imagerel $unwind$_validate_inner
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_validate_inner DD 040f01H
	DD	09340fH
	DD	0700b320fH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT _validate_inner
_TEXT	SEGMENT
code$ = 48
end$ = 56
groups$ = 64
_validate_inner PROC					; COMDAT

; 2883 : {

  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b d9	 mov	 rbx, rcx

; 2884 :     /* Some variables are manipulated by the macros above */
; 2885 :     SRE_CODE op;
; 2886 :     SRE_CODE arg;
; 2887 :     SRE_CODE skip;
; 2888 : 
; 2889 :     VTRACE(("code=%p, end=%p\n", code, end));
; 2890 : 
; 2891 :     if (code > end)

  00015	48 3b ca	 cmp	 rcx, rdx
  00018	76 0d		 jbe	 SHORT $LN810@validate_i

; 2892 :         FAIL;

  0001a	33 c0		 xor	 eax, eax

; 3168 : }

  0001c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
$LN810@validate_i:
  00027	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 2893 : 
; 2894 :     while (code < end) {

  0002c	48 3b ca	 cmp	 rcx, rdx
  0002f	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
$LN901@validate_i:
  00034	0f 83 fb 04 00
	00		 jae	 $LN3@validate_i
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase

; 2895 :         GET_OP;

  00041	48 3b df	 cmp	 rbx, rdi
  00044	73 38		 jae	 SHORT $LN832@validate_i
  00046	8b 03		 mov	 eax, DWORD PTR [rbx]
  00048	48 83 c3 04	 add	 rbx, 4

; 2896 :         switch (op) {

  0004c	83 f8 1f	 cmp	 eax, 31
  0004f	77 2d		 ja	 SHORT $LN832@validate_i
  00051	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN894@validate_i[rdx+rax]
  00059	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN895@validate_i[rdx+rax*4]
  00060	48 03 ca	 add	 rcx, rdx
  00063	ff e1		 jmp	 rcx
$LN785@validate_i:

; 2897 : 
; 2898 :         case SRE_OP_MARK:
; 2899 :             /* We don't check whether marks are properly nested; the
; 2900 :                sre_match() code is robust even if they don't, and the worst
; 2901 :                you can get is nonsensical match results. */
; 2902 :             GET_ARG;

  00065	48 3b df	 cmp	 rbx, rdi
  00068	73 14		 jae	 SHORT $LN832@validate_i
  0006a	8b 03		 mov	 eax, DWORD PTR [rbx]

; 2903 :             if (arg > 2*groups+1) {

  0006c	4b 8d 4c 00 01	 lea	 rcx, QWORD PTR [r8+r8+1]
  00071	48 83 c3 04	 add	 rbx, 4
  00075	48 3b c1	 cmp	 rax, rcx
  00078	0f 8e af 04 00
	00		 jle	 $LN7@validate_i
$LN832@validate_i:

; 2895 :         GET_OP;

  0007e	33 c0		 xor	 eax, eax
  00080	e9 b5 04 00 00	 jmp	 $LN900@validate_i
$LN758@validate_i:

; 2904 :                 VTRACE(("arg=%d, groups=%d\n", (int)arg, (int)groups));
; 2905 :                 FAIL;
; 2906 :             }
; 2907 :             break;
; 2908 : 
; 2909 :         case SRE_OP_LITERAL:
; 2910 :         case SRE_OP_NOT_LITERAL:
; 2911 :         case SRE_OP_LITERAL_IGNORE:
; 2912 :         case SRE_OP_NOT_LITERAL_IGNORE:
; 2913 :             GET_ARG;

  00085	48 3b df	 cmp	 rbx, rdi
  00088	73 f4		 jae	 SHORT $LN832@validate_i
  0008a	48 83 c3 04	 add	 rbx, 4
  0008e	48 3b df	 cmp	 rbx, rdi
  00091	eb a1		 jmp	 SHORT $LN901@validate_i
$LN740@validate_i:

; 2914 :             /* The arg is just a character, nothing to check */
; 2915 :             break;
; 2916 : 
; 2917 :         case SRE_OP_SUCCESS:
; 2918 :         case SRE_OP_FAILURE:
; 2919 :             /* Nothing to check; these normally end the matching process */
; 2920 :             break;
; 2921 : 
; 2922 :         case SRE_OP_AT:
; 2923 :             GET_ARG;

  00093	48 3b df	 cmp	 rbx, rdi
  00096	73 e6		 jae	 SHORT $LN832@validate_i
  00098	8b 03		 mov	 eax, DWORD PTR [rbx]
  0009a	48 83 c3 04	 add	 rbx, 4

; 2924 :             switch (arg) {

  0009e	83 f8 0b	 cmp	 eax, 11
  000a1	77 db		 ja	 SHORT $LN832@validate_i

; 2893 : 
; 2894 :     while (code < end) {

  000a3	48 3b df	 cmp	 rbx, rdi
  000a6	eb 8c		 jmp	 SHORT $LN901@validate_i
$LN712@validate_i:

; 2925 :             case SRE_AT_BEGINNING:
; 2926 :             case SRE_AT_BEGINNING_STRING:
; 2927 :             case SRE_AT_BEGINNING_LINE:
; 2928 :             case SRE_AT_END:
; 2929 :             case SRE_AT_END_LINE:
; 2930 :             case SRE_AT_END_STRING:
; 2931 :             case SRE_AT_BOUNDARY:
; 2932 :             case SRE_AT_NON_BOUNDARY:
; 2933 :             case SRE_AT_LOC_BOUNDARY:
; 2934 :             case SRE_AT_LOC_NON_BOUNDARY:
; 2935 :             case SRE_AT_UNI_BOUNDARY:
; 2936 :             case SRE_AT_UNI_NON_BOUNDARY:
; 2937 :                 break;
; 2938 :             default:
; 2939 :                 FAIL;
; 2940 :             }
; 2941 :             break;
; 2942 : 
; 2943 :         case SRE_OP_ANY:
; 2944 :         case SRE_OP_ANY_ALL:
; 2945 :             /* These have no operands */
; 2946 :             break;
; 2947 : 
; 2948 :         case SRE_OP_IN:
; 2949 :         case SRE_OP_IN_IGNORE:
; 2950 :             GET_SKIP;

  000a8	48 3b df	 cmp	 rbx, rdi
  000ab	73 d1		 jae	 SHORT $LN832@validate_i
  000ad	8b 33		 mov	 esi, DWORD PTR [rbx]
  000af	48 8b c7	 mov	 rax, rdi
  000b2	48 2b c3	 sub	 rax, rbx
  000b5	48 c1 f8 02	 sar	 rax, 2
  000b9	48 3b f0	 cmp	 rsi, rax
  000bc	7f c0		 jg	 SHORT $LN832@validate_i

; 2951 :             /* Stop 1 before the end; we check the FAILURE below */
; 2952 :             if (!_validate_charset(code, code+skip-2))

  000be	48 8d 54 b3 fc	 lea	 rdx, QWORD PTR [rbx+rsi*4-4]
  000c3	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  000c7	e8 00 00 00 00	 call	 _validate_charset
  000cc	85 c0		 test	 eax, eax
  000ce	74 ae		 je	 SHORT $LN832@validate_i

; 2953 :                 FAIL;
; 2954 :             if (code[skip-2] != SRE_OP_FAILURE)

  000d0	8d 46 fe	 lea	 eax, DWORD PTR [rsi-2]
  000d3	83 7c 83 04 00	 cmp	 DWORD PTR [rbx+rax*4+4], 0
  000d8	75 a4		 jne	 SHORT $LN832@validate_i

; 2955 :                 FAIL;
; 2956 :             code += skip-1;
; 2957 :             break;

  000da	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  000df	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  000e2	48 8d 5c 83 04	 lea	 rbx, QWORD PTR [rbx+rax*4+4]
  000e7	48 3b df	 cmp	 rbx, rdi
  000ea	e9 45 ff ff ff	 jmp	 $LN901@validate_i
$LN674@validate_i:

; 2958 : 
; 2959 :         case SRE_OP_INFO:
; 2960 :             {
; 2961 :                 /* A minimal info field is
; 2962 :                    <INFO> <1=skip> <2=flags> <3=min> <4=max>;
; 2963 :                    If SRE_INFO_PREFIX or SRE_INFO_CHARSET is in the flags,
; 2964 :                    more follows. */
; 2965 :                 SRE_CODE flags, i;
; 2966 :                 SRE_CODE *newcode;
; 2967 :                 GET_SKIP;

  000ef	48 3b df	 cmp	 rbx, rdi
  000f2	73 8a		 jae	 SHORT $LN832@validate_i
  000f4	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  000f6	48 8b c7	 mov	 rax, rdi
  000f9	48 2b c3	 sub	 rax, rbx
  000fc	48 c1 f8 02	 sar	 rax, 2
  00100	48 3b c8	 cmp	 rcx, rax
  00103	0f 8f 75 ff ff
	ff		 jg	 $LN832@validate_i
  00109	48 83 c3 04	 add	 rbx, 4

; 2968 :                 newcode = code+skip-1;

  0010d	48 8d 6c 8b fc	 lea	 rbp, QWORD PTR [rbx+rcx*4-4]

; 2969 :                 GET_ARG; flags = arg;

  00112	48 3b df	 cmp	 rbx, rdi
  00115	0f 83 63 ff ff
	ff		 jae	 $LN832@validate_i
  0011b	44 8b 03	 mov	 r8d, DWORD PTR [rbx]
  0011e	48 83 c3 04	 add	 rbx, 4

; 2970 :                 GET_ARG;

  00122	48 3b df	 cmp	 rbx, rdi
  00125	0f 83 53 ff ff
	ff		 jae	 $LN832@validate_i
  0012b	48 83 c3 04	 add	 rbx, 4

; 2971 :                 GET_ARG;

  0012f	48 3b df	 cmp	 rbx, rdi
  00132	0f 83 46 ff ff
	ff		 jae	 $LN832@validate_i
  00138	48 83 c3 04	 add	 rbx, 4

; 2972 :                 /* Check that only valid flags are present */
; 2973 :                 if ((flags & ~(SRE_INFO_PREFIX |
; 2974 :                                SRE_INFO_LITERAL |
; 2975 :                                SRE_INFO_CHARSET)) != 0)

  0013c	41 f7 c0 f8 ff
	ff ff		 test	 r8d, -8			; fffffff8H
  00143	0f 85 35 ff ff
	ff		 jne	 $LN832@validate_i

; 2976 :                     FAIL;
; 2977 :                 /* PREFIX and CHARSET are mutually exclusive */
; 2978 :                 if ((flags & SRE_INFO_PREFIX) &&
; 2979 :                     (flags & SRE_INFO_CHARSET))

  00149	41 8b c0	 mov	 eax, r8d
  0014c	83 e0 01	 and	 eax, 1
  0014f	74 0a		 je	 SHORT $LN593@validate_i
  00151	41 f6 c0 04	 test	 r8b, 4
  00155	0f 85 23 ff ff
	ff		 jne	 $LN832@validate_i
$LN593@validate_i:

; 2980 :                     FAIL;
; 2981 :                 /* LITERAL implies PREFIX */
; 2982 :                 if ((flags & SRE_INFO_LITERAL) &&
; 2983 :                     !(flags & SRE_INFO_PREFIX))

  0015b	41 f6 c0 02	 test	 r8b, 2
  0015f	74 08		 je	 SHORT $LN586@validate_i
  00161	85 c0		 test	 eax, eax
  00163	0f 84 15 ff ff
	ff		 je	 $LN832@validate_i
$LN586@validate_i:

; 2984 :                     FAIL;
; 2985 :                 /* Validate the prefix */
; 2986 :                 if (flags & SRE_INFO_PREFIX) {

  00169	85 c0		 test	 eax, eax
  0016b	74 6b		 je	 SHORT $LN582@validate_i

; 2987 :                     SRE_CODE prefix_len;
; 2988 :                     GET_ARG; prefix_len = arg;

  0016d	48 3b df	 cmp	 rbx, rdi
  00170	0f 83 08 ff ff
	ff		 jae	 $LN832@validate_i
  00176	8b 13		 mov	 edx, DWORD PTR [rbx]
  00178	48 83 c3 04	 add	 rbx, 4

; 2989 :                     GET_ARG;

  0017c	48 3b df	 cmp	 rbx, rdi
  0017f	0f 83 f9 fe ff
	ff		 jae	 $LN832@validate_i
  00185	48 83 c3 04	 add	 rbx, 4

; 2990 :                     /* Here comes the prefix string */
; 2991 :                     if (prefix_len > newcode-code)

  00189	48 8b c5	 mov	 rax, rbp
  0018c	48 2b c3	 sub	 rax, rbx
  0018f	48 c1 f8 02	 sar	 rax, 2
  00193	48 3b d0	 cmp	 rdx, rax
  00196	0f 8f e2 fe ff
	ff		 jg	 $LN832@validate_i

; 2992 :                         FAIL;
; 2993 :                     code += prefix_len;

  0019c	4c 8d 0c 95 00
	00 00 00	 lea	 r9, QWORD PTR [rdx*4]

; 2994 :                     /* And here comes the overlap table */
; 2995 :                     if (prefix_len > newcode-code)

  001a4	48 8b c5	 mov	 rax, rbp
  001a7	49 03 d9	 add	 rbx, r9
  001aa	48 2b c3	 sub	 rax, rbx
  001ad	48 c1 f8 02	 sar	 rax, 2
  001b1	48 3b d0	 cmp	 rdx, rax
  001b4	0f 8f c4 fe ff
	ff		 jg	 $LN832@validate_i

; 2996 :                         FAIL;
; 2997 :                     /* Each overlap value should be < prefix_len */
; 2998 :                     for (i = 0; i < prefix_len; i++) {

  001ba	33 c9		 xor	 ecx, ecx
  001bc	85 d2		 test	 edx, edx
  001be	74 15		 je	 SHORT $LN533@validate_i
  001c0	48 8b c3	 mov	 rax, rbx
$LL535@validate_i:

; 2999 :                         if (code[i] >= prefix_len)

  001c3	39 10		 cmp	 DWORD PTR [rax], edx
  001c5	0f 83 b3 fe ff
	ff		 jae	 $LN832@validate_i

; 2996 :                         FAIL;
; 2997 :                     /* Each overlap value should be < prefix_len */
; 2998 :                     for (i = 0; i < prefix_len; i++) {

  001cb	ff c1		 inc	 ecx
  001cd	48 83 c0 04	 add	 rax, 4
  001d1	3b ca		 cmp	 ecx, edx
  001d3	72 ee		 jb	 SHORT $LL535@validate_i
$LN533@validate_i:

; 3000 :                             FAIL;
; 3001 :                     }
; 3002 :                     code += prefix_len;

  001d5	49 03 d9	 add	 rbx, r9
$LN582@validate_i:

; 3003 :                 }
; 3004 :                 /* Validate the charset */
; 3005 :                 if (flags & SRE_INFO_CHARSET) {

  001d8	41 f6 c0 04	 test	 r8b, 4
  001dc	74 2e		 je	 SHORT $LN525@validate_i

; 3006 :                     if (!_validate_charset(code, newcode-1))

  001de	48 8d 55 fc	 lea	 rdx, QWORD PTR [rbp-4]
  001e2	48 8b cb	 mov	 rcx, rbx
  001e5	e8 00 00 00 00	 call	 _validate_charset
  001ea	85 c0		 test	 eax, eax
  001ec	0f 84 8c fe ff
	ff		 je	 $LN832@validate_i

; 3007 :                         FAIL;
; 3008 :                     if (newcode[-1] != SRE_OP_FAILURE)

  001f2	83 7d fc 00	 cmp	 DWORD PTR [rbp-4], 0
  001f6	0f 85 82 fe ff
	ff		 jne	 $LN832@validate_i

; 3009 :                         FAIL;
; 3010 :                     code = newcode;

  001fc	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  00201	48 8b dd	 mov	 rbx, rbp
  00204	48 3b df	 cmp	 rbx, rdi
  00207	e9 28 fe ff ff	 jmp	 $LN901@validate_i
$LN525@validate_i:

; 3011 :                 }
; 3012 :                 else if (code != newcode) {

  0020c	48 3b dd	 cmp	 rbx, rbp

; 3013 :                   VTRACE(("code=%p, newcode=%p\n", code, newcode));
; 3014 :                     FAIL;
; 3015 :                 }
; 3016 :             }
; 3017 :             break;

  0020f	e9 0e 03 00 00	 jmp	 $LN902@validate_i
$LN499@validate_i:

; 3018 : 
; 3019 :         case SRE_OP_BRANCH:
; 3020 :             {
; 3021 :                 SRE_CODE *target = NULL;

  00214	33 ed		 xor	 ebp, ebp
$LL498@validate_i:

; 3022 :                 for (;;) {
; 3023 :                     GET_SKIP;

  00216	48 3b df	 cmp	 rbx, rdi
  00219	0f 83 5f fe ff
	ff		 jae	 $LN832@validate_i
  0021f	8b 33		 mov	 esi, DWORD PTR [rbx]
  00221	48 8b c7	 mov	 rax, rdi
  00224	48 2b c3	 sub	 rax, rbx
  00227	48 c1 f8 02	 sar	 rax, 2
  0022b	48 3b f0	 cmp	 rsi, rax
  0022e	0f 8f 4a fe ff
	ff		 jg	 $LN832@validate_i
  00234	48 83 c3 04	 add	 rbx, 4

; 3024 :                     if (skip == 0)

  00238	85 f6		 test	 esi, esi
  0023a	0f 84 ed 02 00
	00		 je	 $LN7@validate_i

; 3025 :                         break;
; 3026 :                     /* Stop 2 before the end; we check the JUMP below */
; 3027 :                     if (!_validate_inner(code, code+skip-3, groups))

  00240	48 8d 54 b3 f4	 lea	 rdx, QWORD PTR [rbx+rsi*4-12]
  00245	48 8b cb	 mov	 rcx, rbx
  00248	e8 00 00 00 00	 call	 _validate_inner
  0024d	85 c0		 test	 eax, eax
  0024f	0f 84 29 fe ff
	ff		 je	 $LN832@validate_i

; 3028 :                         FAIL;
; 3029 :                     code += skip-3;

  00255	8d 46 fd	 lea	 eax, DWORD PTR [rsi-3]
  00258	48 8d 1c 83	 lea	 rbx, QWORD PTR [rbx+rax*4]

; 3030 :                     /* Check that it ends with a JUMP, and that each JUMP
; 3031 :                        has the same target */
; 3032 :                     GET_OP;

  0025c	48 3b df	 cmp	 rbx, rdi
  0025f	0f 83 19 fe ff
	ff		 jae	 $LN832@validate_i
  00265	8b 03		 mov	 eax, DWORD PTR [rbx]
  00267	48 83 c3 04	 add	 rbx, 4

; 3033 :                     if (op != SRE_OP_JUMP)

  0026b	83 f8 12	 cmp	 eax, 18
  0026e	0f 85 0a fe ff
	ff		 jne	 $LN832@validate_i

; 3034 :                         FAIL;
; 3035 :                     GET_SKIP;

  00274	48 3b df	 cmp	 rbx, rdi
  00277	0f 83 01 fe ff
	ff		 jae	 $LN832@validate_i
  0027d	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0027f	48 8b c7	 mov	 rax, rdi
  00282	48 2b c3	 sub	 rax, rbx
  00285	48 c1 f8 02	 sar	 rax, 2
  00289	48 3b c8	 cmp	 rcx, rax
  0028c	0f 8f ec fd ff
	ff		 jg	 $LN832@validate_i
  00292	48 83 c3 04	 add	 rbx, 4

; 3036 :                     if (target == NULL)

  00296	48 85 ed	 test	 rbp, rbp
  00299	75 0f		 jne	 SHORT $LN419@validate_i

; 3037 :                         target = code+skip-1;

  0029b	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  002a0	48 8d 6c 8b fc	 lea	 rbp, QWORD PTR [rbx+rcx*4-4]
  002a5	e9 6c ff ff ff	 jmp	 $LL498@validate_i
$LN419@validate_i:

; 3038 :                     else if (code+skip-1 != target)

  002aa	48 8d 44 8b fc	 lea	 rax, QWORD PTR [rbx+rcx*4-4]
  002af	48 3b c5	 cmp	 rax, rbp
  002b2	0f 85 c6 fd ff
	ff		 jne	 $LN832@validate_i

; 3039 :                         FAIL;
; 3040 :                 }

  002b8	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  002bd	e9 54 ff ff ff	 jmp	 $LL498@validate_i
$LN409@validate_i:

; 3041 :             }
; 3042 :             break;
; 3043 : 
; 3044 :         case SRE_OP_REPEAT_ONE:
; 3045 :         case SRE_OP_MIN_REPEAT_ONE:
; 3046 :             {
; 3047 :                 SRE_CODE min, max;
; 3048 :                 GET_SKIP;

  002c2	48 3b df	 cmp	 rbx, rdi
  002c5	0f 83 b3 fd ff
	ff		 jae	 $LN832@validate_i
  002cb	8b 33		 mov	 esi, DWORD PTR [rbx]
  002cd	48 8b c7	 mov	 rax, rdi
  002d0	48 2b c3	 sub	 rax, rbx
  002d3	48 c1 f8 02	 sar	 rax, 2
  002d7	48 3b f0	 cmp	 rsi, rax
  002da	0f 8f 9e fd ff
	ff		 jg	 $LN832@validate_i
  002e0	48 83 c3 04	 add	 rbx, 4

; 3049 :                 GET_ARG; min = arg;

  002e4	48 3b df	 cmp	 rbx, rdi
  002e7	0f 83 91 fd ff
	ff		 jae	 $LN832@validate_i
  002ed	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  002ef	48 83 c3 04	 add	 rbx, 4

; 3050 :                 GET_ARG; max = arg;

  002f3	48 3b df	 cmp	 rbx, rdi
  002f6	0f 83 82 fd ff
	ff		 jae	 $LN832@validate_i
  002fc	8b 03		 mov	 eax, DWORD PTR [rbx]

; 3051 :                 if (min > max)

  002fe	3b c8		 cmp	 ecx, eax
  00300	0f 87 78 fd ff
	ff		 ja	 $LN832@validate_i

; 3052 :                     FAIL;
; 3053 :                 if (max > SRE_MAXREPEAT)

  00306	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00309	0f 87 6f fd ff
	ff		 ja	 $LN832@validate_i

; 3054 :                     FAIL;
; 3055 :                 if (!_validate_inner(code, code+skip-4, groups))

  0030f	48 8d 54 b3 f4	 lea	 rdx, QWORD PTR [rbx+rsi*4-12]
  00314	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  00318	e8 00 00 00 00	 call	 _validate_inner
  0031d	85 c0		 test	 eax, eax
  0031f	0f 84 59 fd ff
	ff		 je	 $LN832@validate_i

; 3056 :                     FAIL;
; 3057 :                 code += skip-4;

  00325	8d 46 fc	 lea	 eax, DWORD PTR [rsi-4]
  00328	48 8d 5c 83 04	 lea	 rbx, QWORD PTR [rbx+rax*4+4]

; 3058 :                 GET_OP;
; 3059 :                 if (op != SRE_OP_SUCCESS)
; 3060 :                     FAIL;
; 3061 :             }
; 3062 :             break;

  0032d	e9 de 01 00 00	 jmp	 $LN904@validate_i
$LN309@validate_i:

; 3063 : 
; 3064 :         case SRE_OP_REPEAT:
; 3065 :             {
; 3066 :                 SRE_CODE min, max;
; 3067 :                 GET_SKIP;

  00332	48 3b df	 cmp	 rbx, rdi
  00335	0f 83 43 fd ff
	ff		 jae	 $LN832@validate_i
  0033b	8b 33		 mov	 esi, DWORD PTR [rbx]
  0033d	48 8b c7	 mov	 rax, rdi
  00340	48 2b c3	 sub	 rax, rbx
  00343	48 c1 f8 02	 sar	 rax, 2
  00347	48 3b f0	 cmp	 rsi, rax
  0034a	0f 8f 2e fd ff
	ff		 jg	 $LN832@validate_i
  00350	48 83 c3 04	 add	 rbx, 4

; 3068 :                 GET_ARG; min = arg;

  00354	48 3b df	 cmp	 rbx, rdi
  00357	0f 83 21 fd ff
	ff		 jae	 $LN832@validate_i
  0035d	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0035f	48 83 c3 04	 add	 rbx, 4

; 3069 :                 GET_ARG; max = arg;

  00363	48 3b df	 cmp	 rbx, rdi
  00366	0f 83 12 fd ff
	ff		 jae	 $LN832@validate_i
  0036c	8b 03		 mov	 eax, DWORD PTR [rbx]

; 3070 :                 if (min > max)

  0036e	3b c8		 cmp	 ecx, eax
  00370	0f 87 08 fd ff
	ff		 ja	 $LN832@validate_i

; 3071 :                     FAIL;
; 3072 :                 if (max > SRE_MAXREPEAT)

  00376	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00379	0f 87 ff fc ff
	ff		 ja	 $LN832@validate_i

; 3073 :                     FAIL;
; 3074 :                 if (!_validate_inner(code, code+skip-3, groups))

  0037f	48 8d 54 b3 f8	 lea	 rdx, QWORD PTR [rbx+rsi*4-8]
  00384	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  00388	e8 00 00 00 00	 call	 _validate_inner
  0038d	85 c0		 test	 eax, eax
  0038f	0f 84 e9 fc ff
	ff		 je	 $LN832@validate_i

; 3075 :                     FAIL;
; 3076 :                 code += skip-3;

  00395	8d 46 fd	 lea	 eax, DWORD PTR [rsi-3]
  00398	48 8d 5c 83 04	 lea	 rbx, QWORD PTR [rbx+rax*4+4]

; 3077 :                 GET_OP;

  0039d	48 3b df	 cmp	 rbx, rdi
  003a0	0f 83 d8 fc ff
	ff		 jae	 $LN832@validate_i
  003a6	8b 03		 mov	 eax, DWORD PTR [rbx]
  003a8	48 83 c3 04	 add	 rbx, 4

; 3078 :                 if (op != SRE_OP_MAX_UNTIL && op != SRE_OP_MIN_UNTIL)

  003ac	83 f8 16	 cmp	 eax, 22
  003af	0f 84 73 01 00
	00		 je	 $LN898@validate_i
  003b5	83 f8 17	 cmp	 eax, 23

; 3079 :                     FAIL;
; 3080 :             }
; 3081 :             break;

  003b8	e9 65 01 00 00	 jmp	 $LN902@validate_i
$LN209@validate_i:

; 3082 : 
; 3083 :         case SRE_OP_GROUPREF:
; 3084 :         case SRE_OP_GROUPREF_IGNORE:
; 3085 :             GET_ARG;

  003bd	48 3b df	 cmp	 rbx, rdi
  003c0	0f 83 b8 fc ff
	ff		 jae	 $LN832@validate_i
  003c6	8b 03		 mov	 eax, DWORD PTR [rbx]
  003c8	48 83 c3 04	 add	 rbx, 4

; 3086 :             if (arg >= groups)

  003cc	49 3b c0	 cmp	 rax, r8
  003cf	0f 8d a9 fc ff
	ff		 jge	 $LN832@validate_i

; 2893 : 
; 2894 :     while (code < end) {

  003d5	48 3b df	 cmp	 rbx, rdi
  003d8	e9 57 fc ff ff	 jmp	 $LN901@validate_i
$LN185@validate_i:

; 3087 :                 FAIL;
; 3088 :             break;
; 3089 : 
; 3090 :         case SRE_OP_GROUPREF_EXISTS:
; 3091 :             /* The regex syntax for this is: '(?(group)then|else)', where
; 3092 :                'group' is either an integer group number or a group name,
; 3093 :                'then' and 'else' are sub-regexes, and 'else' is optional. */
; 3094 :             GET_ARG;

  003dd	48 3b df	 cmp	 rbx, rdi
  003e0	0f 83 98 fc ff
	ff		 jae	 $LN832@validate_i
  003e6	8b 03		 mov	 eax, DWORD PTR [rbx]
  003e8	48 83 c3 04	 add	 rbx, 4

; 3095 :             if (arg >= groups)

  003ec	49 3b c0	 cmp	 rax, r8
  003ef	0f 8d 89 fc ff
	ff		 jge	 $LN832@validate_i

; 3096 :                 FAIL;
; 3097 :             GET_SKIP_ADJ(1);

  003f5	48 3b df	 cmp	 rbx, rdi
  003f8	0f 83 80 fc ff
	ff		 jae	 $LN832@validate_i
  003fe	8b 33		 mov	 esi, DWORD PTR [rbx]
  00400	48 8b cf	 mov	 rcx, rdi
  00403	48 2b cb	 sub	 rcx, rbx
  00406	8d 6e ff	 lea	 ebp, DWORD PTR [rsi-1]
  00409	48 c1 f9 02	 sar	 rcx, 2
  0040d	48 3b e9	 cmp	 rbp, rcx
  00410	0f 8f 68 fc ff
	ff		 jg	 $LN832@validate_i

; 3098 :             code--; /* The skip is relative to the first arg! */
; 3099 :             /* There are two possibilities here: if there is both a 'then'
; 3100 :                part and an 'else' part, the generated code looks like:
; 3101 : 
; 3102 :                GROUPREF_EXISTS
; 3103 :                <group>
; 3104 :                <skipyes>
; 3105 :                ...then part...
; 3106 :                JUMP
; 3107 :                <skipno>
; 3108 :                (<skipyes> jumps here)
; 3109 :                ...else part...
; 3110 :                (<skipno> jumps here)
; 3111 : 
; 3112 :                If there is only a 'then' part, it looks like:
; 3113 : 
; 3114 :                GROUPREF_EXISTS
; 3115 :                <group>
; 3116 :                <skip>
; 3117 :                ...then part...
; 3118 :                (<skip> jumps here)
; 3119 : 
; 3120 :                There is no direct way to decide which it is, and we don't want
; 3121 :                to allow arbitrary jumps anywhere in the code; so we just look
; 3122 :                for a JUMP opcode preceding our skip target.
; 3123 :             */
; 3124 :             if (skip >= 3 && skip-3 < end-code &&
; 3125 :                 code[skip-3] == SRE_OP_JUMP)

  00416	83 fe 03	 cmp	 esi, 3
  00419	72 7a		 jb	 SHORT $LN97@validate_i
  0041b	8d 46 fd	 lea	 eax, DWORD PTR [rsi-3]
  0041e	8b d0		 mov	 edx, eax
  00420	48 3b d1	 cmp	 rdx, rcx
  00423	7d 70		 jge	 SHORT $LN97@validate_i
  00425	83 3c 83 12	 cmp	 DWORD PTR [rbx+rax*4], 18
  00429	75 6a		 jne	 SHORT $LN97@validate_i

; 3126 :             {
; 3127 :                 VTRACE(("both then and else parts present\n"));
; 3128 :                 if (!_validate_inner(code+1, code+skip-3, groups))

  0042b	48 8d 54 b3 f4	 lea	 rdx, QWORD PTR [rbx+rsi*4-12]
  00430	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  00434	e8 00 00 00 00	 call	 _validate_inner
  00439	85 c0		 test	 eax, eax
  0043b	0f 84 3d fc ff
	ff		 je	 $LN832@validate_i

; 3129 :                     FAIL;
; 3130 :                 code += skip-2; /* Position after JUMP, at <skipno> */

  00441	8d 46 fe	 lea	 eax, DWORD PTR [rsi-2]
  00444	48 8d 1c 83	 lea	 rbx, QWORD PTR [rbx+rax*4]

; 3131 :                 GET_SKIP;

  00448	48 3b df	 cmp	 rbx, rdi
  0044b	0f 83 2d fc ff
	ff		 jae	 $LN832@validate_i
  00451	8b 33		 mov	 esi, DWORD PTR [rbx]
  00453	48 8b c7	 mov	 rax, rdi
  00456	48 2b c3	 sub	 rax, rbx
  00459	48 c1 f8 02	 sar	 rax, 2
  0045d	48 3b f0	 cmp	 rsi, rax
  00460	0f 8f 18 fc ff
	ff		 jg	 $LN832@validate_i

; 3132 :                 if (!_validate_inner(code, code+skip-1, groups))

  00466	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  0046b	48 8d 14 b3	 lea	 rdx, QWORD PTR [rbx+rsi*4]
  0046f	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  00473	e8 00 00 00 00	 call	 _validate_inner
  00478	85 c0		 test	 eax, eax
  0047a	0f 84 fe fb ff
	ff		 je	 $LN832@validate_i

; 3133 :                     FAIL;
; 3134 :                 code += skip-1;

  00480	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  00485	8d 46 ff	 lea	 eax, DWORD PTR [rsi-1]
  00488	48 8d 5c 83 04	 lea	 rbx, QWORD PTR [rbx+rax*4+4]
  0048d	48 3b df	 cmp	 rbx, rdi
  00490	e9 9f fb ff ff	 jmp	 $LN901@validate_i
$LN97@validate_i:

; 3135 :             }
; 3136 :             else {
; 3137 :                 VTRACE(("only a then part present\n"));
; 3138 :                 if (!_validate_inner(code+1, code+skip-1, groups))

  00495	48 8d 54 b3 fc	 lea	 rdx, QWORD PTR [rbx+rsi*4-4]
  0049a	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  0049e	e8 00 00 00 00	 call	 _validate_inner
  004a3	85 c0		 test	 eax, eax
  004a5	0f 84 d3 fb ff
	ff		 je	 $LN832@validate_i

; 3139 :                     FAIL;
; 3140 :                 code += skip-1;

  004ab	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
  004b0	48 8d 1c ab	 lea	 rbx, QWORD PTR [rbx+rbp*4]
  004b4	48 3b df	 cmp	 rbx, rdi
  004b7	e9 78 fb ff ff	 jmp	 $LN901@validate_i
$LN86@validate_i:

; 3141 :             }
; 3142 :             break;
; 3143 : 
; 3144 :         case SRE_OP_ASSERT:
; 3145 :         case SRE_OP_ASSERT_NOT:
; 3146 :             GET_SKIP;

  004bc	48 3b df	 cmp	 rbx, rdi
  004bf	0f 83 b9 fb ff
	ff		 jae	 $LN832@validate_i
  004c5	8b 33		 mov	 esi, DWORD PTR [rbx]
  004c7	48 8b c7	 mov	 rax, rdi
  004ca	48 2b c3	 sub	 rax, rbx
  004cd	48 c1 f8 02	 sar	 rax, 2
  004d1	48 3b f0	 cmp	 rsi, rax
  004d4	0f 8f a4 fb ff
	ff		 jg	 $LN832@validate_i
  004da	48 83 c3 04	 add	 rbx, 4

; 3147 :             GET_ARG; /* 0 for lookahead, width for lookbehind */

  004de	48 3b df	 cmp	 rbx, rdi
  004e1	0f 83 97 fb ff
	ff		 jae	 $LN832@validate_i

; 3148 :             code--; /* Back up over arg to simplify math below */
; 3149 :             if (arg & 0x80000000)

  004e7	f7 03 00 00 00
	80		 test	 DWORD PTR [rbx], -2147483648 ; 80000000H
  004ed	0f 85 8b fb ff
	ff		 jne	 $LN832@validate_i

; 3150 :                 FAIL; /* Width too large */
; 3151 :             /* Stop 1 before the end; we check the SUCCESS below */
; 3152 :             if (!_validate_inner(code+1, code+skip-2, groups))

  004f3	48 8d 54 b3 f8	 lea	 rdx, QWORD PTR [rbx+rsi*4-8]
  004f8	48 8d 4b 04	 lea	 rcx, QWORD PTR [rbx+4]
  004fc	e8 00 00 00 00	 call	 _validate_inner
  00501	85 c0		 test	 eax, eax
  00503	0f 84 75 fb ff
	ff		 je	 $LN832@validate_i

; 3153 :                 FAIL;
; 3154 :             code += skip-2;

  00509	8d 46 fe	 lea	 eax, DWORD PTR [rsi-2]
  0050c	48 8d 1c 83	 lea	 rbx, QWORD PTR [rbx+rax*4]
$LN904@validate_i:

; 3155 :             GET_OP;

  00510	48 3b df	 cmp	 rbx, rdi
  00513	0f 83 65 fb ff
	ff		 jae	 $LN832@validate_i
  00519	8b 03		 mov	 eax, DWORD PTR [rbx]
  0051b	48 83 c3 04	 add	 rbx, 4

; 3156 :             if (op != SRE_OP_SUCCESS)

  0051f	83 f8 01	 cmp	 eax, 1
$LN902@validate_i:
  00522	0f 85 56 fb ff
	ff		 jne	 $LN832@validate_i
$LN898@validate_i:

; 2955 :                 FAIL;
; 2956 :             code += skip-1;
; 2957 :             break;

  00528	4c 8b 44 24 40	 mov	 r8, QWORD PTR groups$[rsp]
$LN7@validate_i:

; 2893 : 
; 2894 :     while (code < end) {

  0052d	48 3b df	 cmp	 rbx, rdi
  00530	e9 ff fa ff ff	 jmp	 $LN901@validate_i
$LN3@validate_i:

; 3157 :                 FAIL;
; 3158 :             break;
; 3159 : 
; 3160 :         default:
; 3161 :             FAIL;
; 3162 : 
; 3163 :         }
; 3164 :     }
; 3165 : 
; 3166 :     VTRACE(("okay\n"));
; 3167 :     return 1;

  00535	b8 01 00 00 00	 mov	 eax, 1
$LN900@validate_i:
  0053a	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0053f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 3168 : }

  00544	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00549	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0054d	5f		 pop	 rdi
  0054e	c3		 ret	 0
  0054f	90		 npad	 1
$LN895@validate_i:
  00550	00 00 00 00	 DD	 $LN7@validate_i
  00554	00 00 00 00	 DD	 $LN86@validate_i
  00558	00 00 00 00	 DD	 $LN740@validate_i
  0055c	00 00 00 00	 DD	 $LN499@validate_i
  00560	00 00 00 00	 DD	 $LN209@validate_i
  00564	00 00 00 00	 DD	 $LN185@validate_i
  00568	00 00 00 00	 DD	 $LN712@validate_i
  0056c	00 00 00 00	 DD	 $LN674@validate_i
  00570	00 00 00 00	 DD	 $LN758@validate_i
  00574	00 00 00 00	 DD	 $LN785@validate_i
  00578	00 00 00 00	 DD	 $LN309@validate_i
  0057c	00 00 00 00	 DD	 $LN409@validate_i
  00580	00 00 00 00	 DD	 $LN832@validate_i
$LN894@validate_i:
  00584	00		 DB	 0
  00585	00		 DB	 0
  00586	00		 DB	 0
  00587	00		 DB	 0
  00588	01		 DB	 1
  00589	01		 DB	 1
  0058a	02		 DB	 2
  0058b	03		 DB	 3
  0058c	0c		 DB	 12
  0058d	0c		 DB	 12
  0058e	0c		 DB	 12
  0058f	0c		 DB	 12
  00590	04		 DB	 4
  00591	05		 DB	 5
  00592	04		 DB	 4
  00593	06		 DB	 6
  00594	06		 DB	 6
  00595	07		 DB	 7
  00596	0c		 DB	 12
  00597	08		 DB	 8
  00598	08		 DB	 8
  00599	09		 DB	 9
  0059a	0c		 DB	 12
  0059b	0c		 DB	 12
  0059c	08		 DB	 8
  0059d	08		 DB	 8
  0059e	0c		 DB	 12
  0059f	0c		 DB	 12
  005a0	0a		 DB	 10
  005a1	0b		 DB	 11
  005a2	0c		 DB	 12
  005a3	0b		 DB	 11
_validate_inner ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT _validate_charset
_TEXT	SEGMENT
code$ = 8
end$ = 16
_validate_charset PROC					; COMDAT

; 2798 : {

  00000	4c 8b ca	 mov	 r9, rdx
  00003	4c 8b c1	 mov	 r8, rcx

; 2799 :     /* Some variables are manipulated by the macros above */
; 2800 :     SRE_CODE op;
; 2801 :     SRE_CODE arg;
; 2802 :     SRE_CODE offset;
; 2803 :     int i;
; 2804 : 
; 2805 :     while (code < end) {

  00006	48 3b ca	 cmp	 rcx, rdx
  00009	0f 83 f4 00 00
	00		 jae	 $LN153@validate_c
  0000f	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:__ImageBase
$LL154@validate_c:

; 2806 :         GET_OP;

  00016	4d 3b c1	 cmp	 r8, r9
  00019	0f 83 ea 00 00
	00		 jae	 $LN160@validate_c
  0001f	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00022	49 83 c0 04	 add	 r8, 4

; 2807 :         switch (op) {

  00026	83 c0 f7	 add	 eax, -9			; fffffff7H
  00029	83 f8 12	 cmp	 eax, 18
  0002c	0f 87 d7 00 00
	00		 ja	 $LN160@validate_c
  00032	41 8b 8c 82 00
	00 00 00	 mov	 ecx, DWORD PTR $LN171@validate_c[r10+rax*4]
  0003a	49 03 ca	 add	 rcx, r10
  0003d	ff e1		 jmp	 rcx
$LN132@validate_c:

; 2808 : 
; 2809 :         case SRE_OP_NEGATE:
; 2810 :             break;
; 2811 : 
; 2812 :         case SRE_OP_LITERAL:
; 2813 :             GET_ARG;

  0003f	4d 3b c1	 cmp	 r8, r9
  00042	0f 83 c1 00 00
	00		 jae	 $LN160@validate_c
  00048	49 83 c0 04	 add	 r8, 4

; 2814 :             break;

  0004c	e9 a9 00 00 00	 jmp	 $LN4@validate_c
$LN115@validate_c:

; 2815 : 
; 2816 :         case SRE_OP_RANGE:
; 2817 :             GET_ARG;

  00051	4d 3b c1	 cmp	 r8, r9
  00054	0f 83 af 00 00
	00		 jae	 $LN160@validate_c
  0005a	49 83 c0 04	 add	 r8, 4

; 2818 :             GET_ARG;

  0005e	4d 3b c1	 cmp	 r8, r9
  00061	0f 83 a2 00 00
	00		 jae	 $LN160@validate_c
  00067	49 83 c0 04	 add	 r8, 4

; 2819 :             break;

  0006b	e9 8a 00 00 00	 jmp	 $LN4@validate_c
$LN83@validate_c:

; 2820 : 
; 2821 :         case SRE_OP_CHARSET:
; 2822 :             offset = 32/sizeof(SRE_CODE); /* 32-byte bitmap */
; 2823 :             if (offset > end-code)

  00070	49 8b c1	 mov	 rax, r9
  00073	49 2b c0	 sub	 rax, r8
  00076	48 83 e0 fc	 and	 rax, -4
  0007a	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  0007e	0f 8c 85 00 00
	00		 jl	 $LN160@validate_c

; 2824 :                 FAIL;
; 2825 :             code += offset;

  00084	49 83 c0 20	 add	 r8, 32			; 00000020H

; 2826 :             break;

  00088	eb 70		 jmp	 SHORT $LN4@validate_c
$LN74@validate_c:

; 2827 : 
; 2828 :         case SRE_OP_BIGCHARSET:
; 2829 :             GET_ARG; /* Number of blocks */

  0008a	4d 3b c1	 cmp	 r8, r9
  0008d	73 7a		 jae	 SHORT $LN160@validate_c
  0008f	41 8b 10	 mov	 edx, DWORD PTR [r8]
  00092	49 83 c0 04	 add	 r8, 4

; 2830 :             offset = 256/sizeof(SRE_CODE); /* 256-byte table */
; 2831 :             if (offset > end-code)

  00096	49 8b c1	 mov	 rax, r9
  00099	49 2b c0	 sub	 rax, r8
  0009c	48 83 e0 fc	 and	 rax, -4
  000a0	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  000a6	7c 61		 jl	 SHORT $LN160@validate_c

; 2832 :                 FAIL;
; 2833 :             /* Make sure that each byte points to a valid block */
; 2834 :             for (i = 0; i < 256; i++) {

  000a8	33 c9		 xor	 ecx, ecx
  000aa	66 0f 1f 44 00
	00		 npad	 6
$LL51@validate_c:

; 2835 :                 if (((unsigned char *)code)[i] >= arg)

  000b0	42 0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+r8]
  000b5	3b c2		 cmp	 eax, edx
  000b7	73 50		 jae	 SHORT $LN160@validate_c

; 2832 :                 FAIL;
; 2833 :             /* Make sure that each byte points to a valid block */
; 2834 :             for (i = 0; i < 256; i++) {

  000b9	48 ff c1	 inc	 rcx
  000bc	48 81 f9 00 01
	00 00		 cmp	 rcx, 256		; 00000100H
  000c3	7c eb		 jl	 SHORT $LL51@validate_c

; 2836 :                     FAIL;
; 2837 :             }
; 2838 :             code += offset;

  000c5	49 81 c0 00 01
	00 00		 add	 r8, 256			; 00000100H

; 2839 :             offset = arg * 32/sizeof(SRE_CODE); /* 32-byte bitmap times arg */

  000cc	c1 e2 05	 shl	 edx, 5

; 2840 :             if (offset > end-code)

  000cf	49 8b c1	 mov	 rax, r9
  000d2	c1 ea 02	 shr	 edx, 2
  000d5	49 2b c0	 sub	 rax, r8
  000d8	8b ca		 mov	 ecx, edx
  000da	48 c1 f8 02	 sar	 rax, 2
  000de	48 3b c8	 cmp	 rcx, rax
  000e1	7f 26		 jg	 SHORT $LN160@validate_c

; 2841 :                 FAIL;
; 2842 :             code += offset;

  000e3	4d 8d 04 90	 lea	 r8, QWORD PTR [r8+rdx*4]

; 2843 :             break;

  000e7	eb 11		 jmp	 SHORT $LN4@validate_c
$LN33@validate_c:

; 2844 : 
; 2845 :         case SRE_OP_CATEGORY:
; 2846 :             GET_ARG;

  000e9	4d 3b c1	 cmp	 r8, r9
  000ec	73 1b		 jae	 SHORT $LN160@validate_c
  000ee	41 8b 00	 mov	 eax, DWORD PTR [r8]
  000f1	49 83 c0 04	 add	 r8, 4

; 2847 :             switch (arg) {

  000f5	83 f8 11	 cmp	 eax, 17
  000f8	77 0f		 ja	 SHORT $LN160@validate_c
$LN4@validate_c:

; 2799 :     /* Some variables are manipulated by the macros above */
; 2800 :     SRE_CODE op;
; 2801 :     SRE_CODE arg;
; 2802 :     SRE_CODE offset;
; 2803 :     int i;
; 2804 : 
; 2805 :     while (code < end) {

  000fa	4d 3b c1	 cmp	 r8, r9
  000fd	0f 82 13 ff ff
	ff		 jb	 $LL154@validate_c
$LN153@validate_c:

; 2848 :             case SRE_CATEGORY_DIGIT:
; 2849 :             case SRE_CATEGORY_NOT_DIGIT:
; 2850 :             case SRE_CATEGORY_SPACE:
; 2851 :             case SRE_CATEGORY_NOT_SPACE:
; 2852 :             case SRE_CATEGORY_WORD:
; 2853 :             case SRE_CATEGORY_NOT_WORD:
; 2854 :             case SRE_CATEGORY_LINEBREAK:
; 2855 :             case SRE_CATEGORY_NOT_LINEBREAK:
; 2856 :             case SRE_CATEGORY_LOC_WORD:
; 2857 :             case SRE_CATEGORY_LOC_NOT_WORD:
; 2858 :             case SRE_CATEGORY_UNI_DIGIT:
; 2859 :             case SRE_CATEGORY_UNI_NOT_DIGIT:
; 2860 :             case SRE_CATEGORY_UNI_SPACE:
; 2861 :             case SRE_CATEGORY_UNI_NOT_SPACE:
; 2862 :             case SRE_CATEGORY_UNI_WORD:
; 2863 :             case SRE_CATEGORY_UNI_NOT_WORD:
; 2864 :             case SRE_CATEGORY_UNI_LINEBREAK:
; 2865 :             case SRE_CATEGORY_UNI_NOT_LINEBREAK:
; 2866 :                 break;
; 2867 :             default:
; 2868 :                 FAIL;
; 2869 :             }
; 2870 :             break;
; 2871 : 
; 2872 :         default:
; 2873 :             FAIL;
; 2874 : 
; 2875 :         }
; 2876 :     }
; 2877 : 
; 2878 :     return 1;

  00103	b8 01 00 00 00	 mov	 eax, 1

; 2879 : }

  00108	c3		 ret	 0
$LN160@validate_c:

; 2806 :         GET_OP;

  00109	33 c0		 xor	 eax, eax

; 2879 : }

  0010b	c3		 ret	 0
$LN171@validate_c:
  0010c	00 00 00 00	 DD	 $LN33@validate_c
  00110	00 00 00 00	 DD	 $LN83@validate_c
  00114	00 00 00 00	 DD	 $LN74@validate_c
  00118	00 00 00 00	 DD	 $LN160@validate_c
  0011c	00 00 00 00	 DD	 $LN160@validate_c
  00120	00 00 00 00	 DD	 $LN160@validate_c
  00124	00 00 00 00	 DD	 $LN160@validate_c
  00128	00 00 00 00	 DD	 $LN160@validate_c
  0012c	00 00 00 00	 DD	 $LN160@validate_c
  00130	00 00 00 00	 DD	 $LN160@validate_c
  00134	00 00 00 00	 DD	 $LN132@validate_c
  00138	00 00 00 00	 DD	 $LN160@validate_c
  0013c	00 00 00 00	 DD	 $LN160@validate_c
  00140	00 00 00 00	 DD	 $LN160@validate_c
  00144	00 00 00 00	 DD	 $LN160@validate_c
  00148	00 00 00 00	 DD	 $LN160@validate_c
  0014c	00 00 00 00	 DD	 $LN160@validate_c
  00150	00 00 00 00	 DD	 $LN4@validate_c
  00154	00 00 00 00	 DD	 $LN115@validate_c
_validate_charset ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_dealloc DD imagerel match_dealloc
	DD	imagerel match_dealloc+62
	DD	imagerel $unwind$match_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_dealloc DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT match_dealloc
_TEXT	SEGMENT
self$ = 48
match_dealloc PROC					; COMDAT

; 3198 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 3199 :     Py_XDECREF(self->regs);

  00009	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 05		 je	 SHORT $LN7@match_deal
  00012	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@match_deal:

; 3200 :     Py_XDECREF(self->string);

  00017	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  0001b	48 85 c9	 test	 rcx, rcx
  0001e	74 05		 je	 SHORT $LN3@match_deal
  00020	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@match_deal:

; 3201 :     Py_DECREF(self->pattern);

  00025	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0002c	e8 00 00 00 00	 call	 _Py_DecRef

; 3202 :     PyObject_DEL(self);

  00031	48 8b cb	 mov	 rcx, rbx

; 3203 : }

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5b		 pop	 rbx
  00039	e9 00 00 00 00	 jmp	 _PyObject_DebugFree
match_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_07BBLEBFDC@_expand?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_expand DD imagerel match_expand
	DD	imagerel match_expand+53
	DD	imagerel $unwind$match_expand
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_expand DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_07BBLEBFDC@_expand?$AA@
CONST	SEGMENT
??_C@_07BBLEBFDC@_expand?$AA@ DB '_expand', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT match_expand
_TEXT	SEGMENT
self$ = 48
ptemplate$ = 56
match_expand PROC					; COMDAT

; 3265 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3266 :     /* delegate to Python code */
; 3267 :     return call(
; 3268 :         SRE_PY_MODULE, "_expand",
; 3269 :         PyTuple_Pack(3, self->pattern, self, ptemplate)
; 3270 :         );

  00004	4c 8b ca	 mov	 r9, rdx
  00007	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]
  0000e	4c 8b c1	 mov	 r8, rcx
  00011	b9 03 00 00 00	 mov	 ecx, 3
  00016	e8 00 00 00 00	 call	 PyTuple_Pack
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07BBLEBFDC@_expand?$AA@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02EPEBAFDB@re?$AA@
  00029	4c 8b c0	 mov	 r8, rax

; 3271 : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	e9 00 00 00 00	 jmp	 call
match_expand ENDP
_TEXT	ENDS
EXTRN	_Py_FalseStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_group DD imagerel match_group
	DD	imagerel match_group+189
	DD	imagerel $unwind$match_group
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_group DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0d0143218H
	DD	07010c012H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT match_group
_TEXT	SEGMENT
self$ = 64
args$ = 72
match_group PROC					; COMDAT

; 3275 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3276 :     PyObject* result;
; 3277 :     Py_ssize_t i, size;
; 3278 : 
; 3279 :     size = PyTuple_GET_SIZE(args);

  00018	48 8b 6a 60	 mov	 rbp, QWORD PTR [rdx+96]
  0001c	4c 8b e2	 mov	 r12, rdx
  0001f	4c 8b e9	 mov	 r13, rcx

; 3280 : 
; 3281 :     switch (size) {

  00022	48 8b c5	 mov	 rax, rbp
  00025	48 85 ed	 test	 rbp, rbp
  00028	74 61		 je	 SHORT $LN8@match_grou
  0002a	48 ff c8	 dec	 rax
  0002d	74 56		 je	 SHORT $LN7@match_grou

; 3288 :     default:
; 3289 :         /* fetch multiple items */
; 3290 :         result = PyTuple_New(size);

  0002f	48 8b cd	 mov	 rcx, rbp
  00032	e8 00 00 00 00	 call	 PyTuple_New
  00037	48 8b f0	 mov	 rsi, rax

; 3291 :         if (!result)

  0003a	48 85 c0	 test	 rax, rax

; 3292 :             return NULL;

  0003d	74 42		 je	 SHORT $LN17@match_grou

; 3293 :         for (i = 0; i < size; i++) {

  0003f	33 ff		 xor	 edi, edi
  00041	48 85 ed	 test	 rbp, rbp
  00044	7e 5b		 jle	 SHORT $LN9@match_grou
  00046	48 8d 58 70	 lea	 rbx, QWORD PTR [rax+112]
  0004a	4c 2b e0	 sub	 r12, rax
  0004d	0f 1f 00	 npad	 3
$LL4@match_grou:

; 3294 :             PyObject* item = match_getslice(
; 3295 :                 self, PyTuple_GET_ITEM(args, i), Py_None
; 3296 :                 );

  00050	49 8b 14 1c	 mov	 rdx, QWORD PTR [r12+rbx]
  00054	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  0005b	49 8b cd	 mov	 rcx, r13
  0005e	e8 00 00 00 00	 call	 match_getslice

; 3297 :             if (!item) {

  00063	48 85 c0	 test	 rax, rax
  00066	74 11		 je	 SHORT $LN14@match_grou

; 3300 :             }
; 3301 :             PyTuple_SET_ITEM(result, i, item);

  00068	48 ff c7	 inc	 rdi
  0006b	48 89 03	 mov	 QWORD PTR [rbx], rax
  0006e	48 83 c3 08	 add	 rbx, 8
  00072	48 3b fd	 cmp	 rdi, rbp
  00075	7c d9		 jl	 SHORT $LL4@match_grou

; 3297 :             if (!item) {

  00077	eb 28		 jmp	 SHORT $LN9@match_grou
$LN14@match_grou:

; 3298 :                 Py_DECREF(result);

  00079	48 8b ce	 mov	 rcx, rsi
  0007c	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@match_grou:

; 3299 :                 return NULL;

  00081	33 c0		 xor	 eax, eax
  00083	eb 1f		 jmp	 SHORT $LN11@match_grou
$LN7@match_grou:

; 3284 :         break;
; 3285 :     case 1:
; 3286 :         result = match_getslice(self, PyTuple_GET_ITEM(args, 0), Py_None);

  00085	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]

; 3287 :         break;

  00089	eb 07		 jmp	 SHORT $LN16@match_grou
$LN8@match_grou:

; 3282 :     case 0:
; 3283 :         result = match_getslice(self, Py_False, Py_None);

  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_FalseStruct
$LN16@match_grou:
  00092	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  00099	e8 00 00 00 00	 call	 match_getslice
  0009e	48 8b f0	 mov	 rsi, rax
$LN9@match_grou:

; 3302 :         }
; 3303 :         break;
; 3304 :     }
; 3305 :     return result;

  000a1	48 8b c6	 mov	 rax, rsi
$LN11@match_grou:

; 3306 : }

  000a4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a9	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ae	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000b3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b7	41 5d		 pop	 r13
  000b9	41 5c		 pop	 r12
  000bb	5f		 pop	 rdi
  000bc	c3		 ret	 0
match_group ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_getslice DD imagerel match_getslice
	DD	imagerel match_getslice+45
	DD	imagerel $unwind$match_getslice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_getslice DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT match_getslice
_TEXT	SEGMENT
self$ = 48
index$ = 56
def$ = 64
match_getslice PROC					; COMDAT

; 3259 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b d9	 mov	 rbx, rcx

; 3260 :     return match_getslice_by_index(self, match_getindex(self, index), def);

  00010	e8 00 00 00 00	 call	 match_getindex
  00015	4c 8b c7	 mov	 r8, rdi
  00018	48 8b cb	 mov	 rcx, rbx
  0001b	48 8b d0	 mov	 rdx, rax

; 3261 : }

  0001e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	e9 00 00 00 00	 jmp	 match_getslice_by_index
match_getslice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@OOOHFIK@no?5such?5group?$AA@		; `string'
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_getslice_by_index DD imagerel match_getslice_by_index
	DD	imagerel match_getslice_by_index+121
	DD	imagerel $unwind$match_getslice_by_index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_getslice_by_index DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0O@OOOHFIK@no?5such?5group?$AA@
CONST	SEGMENT
??_C@_0O@OOOHFIK@no?5such?5group?$AA@ DB 'no such group', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT match_getslice_by_index
_TEXT	SEGMENT
self$ = 48
index$ = 56
def$ = 64
match_getslice_by_index PROC				; COMDAT

; 3207 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b d8	 mov	 rbx, r8

; 3208 :     if (index < 0 || index >= self->groups) {

  00009	48 85 d2	 test	 rdx, rdx
  0000c	78 50		 js	 SHORT $LN3@match_gets
  0000e	48 3b 91 a0 00
	00 00		 cmp	 rdx, QWORD PTR [rcx+160]
  00015	7d 47		 jge	 SHORT $LN3@match_gets

; 3215 :     }
; 3216 : 
; 3217 :     index *= 2;
; 3218 : 
; 3219 :     if (self->string == Py_None || self->mark[index] < 0) {

  00017	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  0001b	4c 8d 04 12	 lea	 r8, QWORD PTR [rdx+rdx]
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  00026	48 3b c2	 cmp	 rax, rdx
  00029	74 22		 je	 SHORT $LN1@match_gets
  0002b	4a 8b 94 c1 a8
	00 00 00	 mov	 rdx, QWORD PTR [rcx+r8*8+168]
  00033	48 85 d2	 test	 rdx, rdx
  00036	78 15		 js	 SHORT $LN1@match_gets

; 3223 :     }
; 3224 : 
; 3225 :     return PySequence_GetSlice(
; 3226 :         self->string, self->mark[index], self->mark[index+1]
; 3227 :         );

  00038	4e 8b 84 c1 b0
	00 00 00	 mov	 r8, QWORD PTR [rcx+r8*8+176]
  00040	48 8b c8	 mov	 rcx, rax

; 3228 : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	e9 00 00 00 00	 jmp	 PySequence_GetSlice
$LN1@match_gets:

; 3220 :         /* return default value if the string or group is undefined */
; 3221 :         Py_INCREF(def);

  0004d	48 8b cb	 mov	 rcx, rbx
  00050	e8 00 00 00 00	 call	 _Py_IncRef

; 3222 :         return def;

  00055	48 8b c3	 mov	 rax, rbx

; 3228 : }

  00058	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005c	5b		 pop	 rbx
  0005d	c3		 ret	 0
$LN3@match_gets:

; 3209 :         /* raise IndexError if we were given a bad group number */
; 3210 :         PyErr_SetString(
; 3211 :             PyExc_IndexError,
; 3212 :             "no such group"
; 3213 :             );

  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@OOOHFIK@no?5such?5group?$AA@
  0006c	e8 00 00 00 00	 call	 PyErr_SetString

; 3214 :         return NULL;

  00071	33 c0		 xor	 eax, eax

; 3228 : }

  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5b		 pop	 rbx
  00078	c3		 ret	 0
match_getslice_by_index ENDP
_TEXT	ENDS
EXTRN	PyObject_GetItem:PROC
EXTRN	PyLong_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_getindex DD imagerel match_getindex
	DD	imagerel match_getindex+51
	DD	imagerel $unwind$match_getindex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$match_getindex DD imagerel match_getindex+51
	DD	imagerel match_getindex+140
	DD	imagerel $chain$1$match_getindex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$match_getindex DD imagerel match_getindex+140
	DD	imagerel match_getindex+150
	DD	imagerel $chain$3$match_getindex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$match_getindex DD imagerel match_getindex+150
	DD	imagerel match_getindex+163
	DD	imagerel $chain$4$match_getindex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$match_getindex DD 020021H
	DD	047400H
	DD	imagerel match_getindex
	DD	imagerel match_getindex+51
	DD	imagerel $unwind$match_getindex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$match_getindex DD 040021H
	DD	047400H
	DD	063400H
	DD	imagerel match_getindex
	DD	imagerel match_getindex+51
	DD	imagerel $unwind$match_getindex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$match_getindex DD 041721H
	DD	063417H
	DD	047405H
	DD	imagerel match_getindex
	DD	imagerel match_getindex+51
	DD	imagerel $unwind$match_getindex
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_getindex DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT match_getindex
_TEXT	SEGMENT
self$ = 48
index$ = 56
match_getindex PROC					; COMDAT

; 3232 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3233 :     Py_ssize_t i;
; 3234 : 
; 3235 :     if (index == NULL)

  00004	48 85 d2	 test	 rdx, rdx
  00007	75 07		 jne	 SHORT $LN6@match_geti

; 3236 :         /* Default value */
; 3237 :         return 0;

  00009	33 c0		 xor	 eax, eax

; 3255 : }

  0000b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000f	c3		 ret	 0
$LN6@match_geti:

; 3238 : 
; 3239 :     if (PyLong_Check(index))

  00010	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00014	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  0001e	74 0c		 je	 SHORT $LN5@match_geti

; 3240 :         return PyLong_AsSsize_t(index);

  00020	48 8b ca	 mov	 rcx, rdx

; 3255 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	e9 00 00 00 00	 jmp	 PyLong_AsSsize_t
$LN5@match_geti:

; 3241 : 
; 3242 :     i = -1;
; 3243 : 
; 3244 :     if (self->pattern->groupindex) {

  0002c	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  00033	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00038	48 83 cf ff	 or	 rdi, -1
  0003c	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00040	48 85 c9	 test	 rcx, rcx
  00043	74 51		 je	 SHORT $LN1@match_geti

; 3245 :         index = PyObject_GetItem(self->pattern->groupindex, index);

  00045	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0004a	e8 00 00 00 00	 call	 PyObject_GetItem
  0004f	48 8b d8	 mov	 rbx, rax

; 3246 :         if (index) {

  00052	48 85 c0	 test	 rax, rax
  00055	74 35		 je	 SHORT $LN3@match_geti

; 3247 :             if (PyLong_Check(index))

  00057	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0005b	f7 81 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rcx+256], 16777216 ; 01000000H
  00065	74 0b		 je	 SHORT $LN2@match_geti

; 3248 :                 i = PyLong_AsSsize_t(index);

  00067	48 8b c8	 mov	 rcx, rax
  0006a	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0006f	48 8b f8	 mov	 rdi, rax
$LN2@match_geti:

; 3249 :             Py_DECREF(index);

  00072	48 8b cb	 mov	 rcx, rbx
  00075	e8 00 00 00 00	 call	 _Py_DecRef
  0007a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3252 :     }
; 3253 : 
; 3254 :     return i;

  0007f	48 8b c7	 mov	 rax, rdi
  00082	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 3255 : }

  00087	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008b	c3		 ret	 0
$LN3@match_geti:

; 3250 :         } else
; 3251 :             PyErr_Clear();

  0008c	e8 00 00 00 00	 call	 PyErr_Clear
  00091	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN1@match_geti:

; 3252 :     }
; 3253 : 
; 3254 :     return i;

  00096	48 8b c7	 mov	 rax, rdi
  00099	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 3255 : }

  0009e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a2	c3		 ret	 0
match_getindex ENDP
_TEXT	ENDS
PUBLIC	??_C@_09PKLNFNAK@?$HMO?3groups?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_groups DD imagerel match_groups
	DD	imagerel match_groups+81
	DD	imagerel $unwind$match_groups
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$match_groups DD imagerel match_groups+81
	DD	imagerel match_groups+113
	DD	imagerel $chain$0$match_groups
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$match_groups DD imagerel match_groups+113
	DD	imagerel match_groups+208
	DD	imagerel $chain$4$match_groups
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$match_groups DD imagerel match_groups+208
	DD	imagerel match_groups+220
	DD	imagerel $chain$6$match_groups
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$match_groups DD 060021H
	DD	0a7400H
	DD	095400H
	DD	083400H
	DD	imagerel match_groups
	DD	imagerel match_groups+81
	DD	imagerel $unwind$match_groups
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$match_groups DD 060f21H
	DD	0a740fH
	DD	083405H
	DD	095400H
	DD	imagerel match_groups
	DD	imagerel match_groups+81
	DD	imagerel $unwind$match_groups
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$match_groups DD 020521H
	DD	095405H
	DD	imagerel match_groups
	DD	imagerel match_groups+81
	DD	imagerel $unwind$match_groups
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_groups DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT ??_C@_09PKLNFNAK@?$HMO?3groups?$AA@
CONST	SEGMENT
??_C@_09PKLNFNAK@?$HMO?3groups?$AA@ DB '|O:groups', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT match_groups
_TEXT	SEGMENT
self$ = 64
args$ = 72
kw$ = 80
def$ = 88
match_groups PROC					; COMDAT

; 3310 : {

  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b f1	 mov	 rsi, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 3311 :     PyObject* result;
; 3312 :     Py_ssize_t index;
; 3313 : 
; 3314 :     PyObject* def = Py_None;

  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct

; 3315 :     static char* kwlist[] = { "default", NULL };
; 3316 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:groups", kwlist, &def))

  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??match_groups@@9@9
  0001d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09PKLNFNAK@?$HMO?3groups?$AA@
  00024	48 89 4c 24 58	 mov	 QWORD PTR def$[rsp], rcx
  00029	48 8d 4c 24 58	 lea	 rcx, QWORD PTR def$[rsp]
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00036	49 8b ca	 mov	 rcx, r10
  00039	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0003e	85 c0		 test	 eax, eax
  00040	75 08		 jne	 SHORT $LN6@match_grou@2

; 3317 :         return NULL;

  00042	33 c0		 xor	 eax, eax

; 3334 : }

  00044	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00048	5e		 pop	 rsi
  00049	c3		 ret	 0
$LN6@match_grou@2:

; 3318 : 
; 3319 :     result = PyTuple_New(self->groups-1);

  0004a	48 8b 8e a0 00
	00 00		 mov	 rcx, QWORD PTR [rsi+160]
  00051	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00056	48 ff c9	 dec	 rcx
  00059	e8 00 00 00 00	 call	 PyTuple_New
  0005e	48 8b e8	 mov	 rbp, rax

; 3320 :     if (!result)

  00061	48 85 c0	 test	 rax, rax
  00064	75 0b		 jne	 SHORT $LN5@match_grou@2
  00066	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 3334 : }

  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	5e		 pop	 rsi
  00070	c3		 ret	 0
$LN5@match_grou@2:
  00071	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 3321 :         return NULL;
; 3322 : 
; 3323 :     for (index = 1; index < self->groups; index++) {

  00076	bb 01 00 00 00	 mov	 ebx, 1
  0007b	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00080	48 3b 9e a0 00
	00 00		 cmp	 rbx, QWORD PTR [rsi+160]
  00087	7d 2f		 jge	 SHORT $LN2@match_grou@2
  00089	48 8d 78 70	 lea	 rdi, QWORD PTR [rax+112]
  0008d	0f 1f 00	 npad	 3
$LL4@match_grou@2:

; 3324 :         PyObject* item;
; 3325 :         item = match_getslice_by_index(self, index, def);

  00090	4c 8b 44 24 58	 mov	 r8, QWORD PTR def$[rsp]
  00095	48 8b d3	 mov	 rdx, rbx
  00098	48 8b ce	 mov	 rcx, rsi
  0009b	e8 00 00 00 00	 call	 match_getslice_by_index

; 3326 :         if (!item) {

  000a0	48 85 c0	 test	 rax, rax
  000a3	74 2b		 je	 SHORT $LN10@match_grou@2

; 3329 :         }
; 3330 :         PyTuple_SET_ITEM(result, index-1, item);

  000a5	48 89 07	 mov	 QWORD PTR [rdi], rax
  000a8	48 ff c3	 inc	 rbx
  000ab	48 83 c7 08	 add	 rdi, 8
  000af	48 3b 9e a0 00
	00 00		 cmp	 rbx, QWORD PTR [rsi+160]
  000b6	7c d8		 jl	 SHORT $LL4@match_grou@2
$LN2@match_grou@2:

; 3331 :     }
; 3332 : 
; 3333 :     return result;

  000b8	48 8b c5	 mov	 rax, rbp
$LN14@match_grou@2:
  000bb	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c0	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000c5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]

; 3334 : }

  000ca	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ce	5e		 pop	 rsi
  000cf	c3		 ret	 0
$LN10@match_grou@2:

; 3327 :             Py_DECREF(result);

  000d0	48 8b cd	 mov	 rcx, rbp
  000d3	e8 00 00 00 00	 call	 _Py_DecRef

; 3328 :             return NULL;

  000d8	33 c0		 xor	 eax, eax
  000da	eb df		 jmp	 SHORT $LN14@match_grou@2
match_groups ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@CCHOFDJE@?$HMO?3groupdict?$AA@		; `string'
EXTRN	PyDict_SetItem:PROC
EXTRN	PyMapping_Keys:PROC
EXTRN	PyDict_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_groupdict DD imagerel match_groupdict
	DD	imagerel match_groupdict+117
	DD	imagerel $unwind$match_groupdict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$match_groupdict DD imagerel match_groupdict+117
	DD	imagerel match_groupdict+293
	DD	imagerel $chain$4$match_groupdict
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$match_groupdict DD imagerel match_groupdict+293
	DD	imagerel match_groupdict+305
	DD	imagerel $chain$5$match_groupdict
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$match_groupdict DD 021H
	DD	imagerel match_groupdict
	DD	imagerel match_groupdict+117
	DD	imagerel $unwind$match_groupdict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$match_groupdict DD 081421H
	DD	06c414H
	DD	07740fH
	DD	0c640aH
	DD	0a3405H
	DD	imagerel match_groupdict
	DD	imagerel match_groupdict+117
	DD	imagerel $unwind$match_groupdict
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_groupdict DD 045001H
	DD	0b5450H
	DD	0d0027206H
xdata	ENDS
;	COMDAT ??_C@_0N@CCHOFDJE@?$HMO?3groupdict?$AA@
CONST	SEGMENT
??_C@_0N@CCHOFDJE@?$HMO?3groupdict?$AA@ DB '|O:groupdict', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT match_groupdict
_TEXT	SEGMENT
self$ = 80
args$ = 88
kw$ = 96
def$ = 104
match_groupdict PROC					; COMDAT

; 3338 : {

  00000	41 55		 push	 r13
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	4c 8b e9	 mov	 r13, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	4c 8b d2	 mov	 r10, rdx

; 3339 :     PyObject* result;
; 3340 :     PyObject* keys;
; 3341 :     Py_ssize_t index;
; 3342 : 
; 3343 :     PyObject* def = Py_None;

  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct

; 3344 :     static char* kwlist[] = { "default", NULL };
; 3345 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:groupdict", kwlist, &def))

  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??match_groupdict@@9@9
  0001d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@CCHOFDJE@?$HMO?3groupdict?$AA@
  00024	48 89 4c 24 68	 mov	 QWORD PTR def$[rsp], rcx
  00029	48 8d 4c 24 68	 lea	 rcx, QWORD PTR def$[rsp]
  0002e	48 8b d0	 mov	 rdx, rax
  00031	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00036	49 8b ca	 mov	 rcx, r10
  00039	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  0003e	85 c0		 test	 eax, eax
  00040	75 09		 jne	 SHORT $LN14@match_grou@3

; 3346 :         return NULL;

  00042	33 c0		 xor	 eax, eax

; 3382 : }

  00044	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00048	41 5d		 pop	 r13
  0004a	c3		 ret	 0
$LN14@match_grou@3:
  0004b	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp

; 3347 : 
; 3348 :     result = PyDict_New();

  00050	e8 00 00 00 00	 call	 PyDict_New
  00055	48 8b e8	 mov	 rbp, rax

; 3349 :     if (!result || !self->pattern->groupindex)

  00058	48 85 c0	 test	 rax, rax
  0005b	0f 84 c4 00 00
	00		 je	 $LN22@match_grou@3
  00061	49 8b 8d 80 00
	00 00		 mov	 rcx, QWORD PTR [r13+128]
  00068	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0006c	48 85 c9	 test	 rcx, rcx
  0006f	0f 84 b0 00 00
	00		 je	 $LN22@match_grou@3

; 3350 :         return result;
; 3351 : 
; 3352 :     keys = PyMapping_Keys(self->pattern->groupindex);

  00075	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0007a	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  0007f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00084	4c 89 64 24 30	 mov	 QWORD PTR [rsp+48], r12
  00089	e8 00 00 00 00	 call	 PyMapping_Keys
  0008e	48 8b f0	 mov	 rsi, rax

; 3353 :     if (!keys)

  00091	48 85 c0	 test	 rax, rax
  00094	74 71		 je	 SHORT $LN3@match_grou@3

; 3354 :         goto failed;
; 3355 : 
; 3356 :     for (index = 0; index < PyList_GET_SIZE(keys); index++) {

  00096	33 ff		 xor	 edi, edi
  00098	48 39 78 60	 cmp	 QWORD PTR [rax+96], rdi
  0009c	7e 4c		 jle	 SHORT $LN8@match_grou@3
  0009e	66 90		 npad	 2
$LL10@match_grou@3:

; 3357 :         int status;
; 3358 :         PyObject* key;
; 3359 :         PyObject* value;
; 3360 :         key = PyList_GET_ITEM(keys, index);

  000a0	48 8b 4e 70	 mov	 rcx, QWORD PTR [rsi+112]
  000a4	48 8b 1c f9	 mov	 rbx, QWORD PTR [rcx+rdi*8]

; 3361 :         if (!key)

  000a8	48 85 db	 test	 rbx, rbx
  000ab	74 52		 je	 SHORT $failed$25320

; 3362 :             goto failed;
; 3363 :         value = match_getslice(self, key, def);

  000ad	4c 8b 44 24 68	 mov	 r8, QWORD PTR def$[rsp]
  000b2	48 8b d3	 mov	 rdx, rbx
  000b5	49 8b cd	 mov	 rcx, r13
  000b8	e8 00 00 00 00	 call	 match_getslice
  000bd	4c 8b e0	 mov	 r12, rax

; 3364 :         if (!value) {

  000c0	48 85 c0	 test	 rax, rax
  000c3	74 32		 je	 SHORT $LN19@match_grou@3

; 3366 :             goto failed;
; 3367 :         }
; 3368 :         status = PyDict_SetItem(result, key, value);

  000c5	4c 8b c0	 mov	 r8, rax
  000c8	48 8b d3	 mov	 rdx, rbx
  000cb	48 8b cd	 mov	 rcx, rbp
  000ce	e8 00 00 00 00	 call	 PyDict_SetItem

; 3369 :         Py_DECREF(value);

  000d3	49 8b cc	 mov	 rcx, r12
  000d6	8b d8		 mov	 ebx, eax
  000d8	e8 00 00 00 00	 call	 _Py_DecRef

; 3370 :         if (status < 0)

  000dd	85 db		 test	 ebx, ebx
  000df	78 1e		 js	 SHORT $failed$25320

; 3354 :         goto failed;
; 3355 : 
; 3356 :     for (index = 0; index < PyList_GET_SIZE(keys); index++) {

  000e1	48 ff c7	 inc	 rdi
  000e4	48 3b 7e 60	 cmp	 rdi, QWORD PTR [rsi+96]
  000e8	7c b6		 jl	 SHORT $LL10@match_grou@3
$LN8@match_grou@3:

; 3371 :             goto failed;
; 3372 :     }
; 3373 : 
; 3374 :     Py_DECREF(keys);

  000ea	48 8b ce	 mov	 rcx, rsi
  000ed	e8 00 00 00 00	 call	 _Py_DecRef

; 3375 : 
; 3376 :     return result;

  000f2	48 8b c5	 mov	 rax, rbp
  000f5	eb 1a		 jmp	 SHORT $LN26@match_grou@3
$LN19@match_grou@3:

; 3365 :             Py_DECREF(key);

  000f7	48 8b cb	 mov	 rcx, rbx
  000fa	e8 00 00 00 00	 call	 _Py_DecRef
$failed$25320:

; 3377 : 
; 3378 : failed:
; 3379 :     Py_XDECREF(keys);

  000ff	48 8b ce	 mov	 rcx, rsi
  00102	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@match_grou@3:

; 3380 :     Py_DECREF(result);

  00107	48 8b cd	 mov	 rcx, rbp
  0010a	e8 00 00 00 00	 call	 _Py_DecRef

; 3381 :     return NULL;

  0010f	33 c0		 xor	 eax, eax
$LN26@match_grou@3:
  00111	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00116	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  0011b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  00120	4c 8b 64 24 30	 mov	 r12, QWORD PTR [rsp+48]
$LN22@match_grou@3:
  00125	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]

; 3382 : }

  0012a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0012e	41 5d		 pop	 r13
  00130	c3		 ret	 0
match_groupdict ENDP
_TEXT	ENDS
EXTRN	PyLong_FromSsize_t:PROC
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_start DD imagerel match_start
	DD	imagerel match_start+135
	DD	imagerel $unwind$match_start
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_start DD 020601H
	DD	030025206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT match_start
_TEXT	SEGMENT
self$ = 64
args$ = 72
index_$ = 80
match_start PROC					; COMDAT

; 3386 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 3387 :     Py_ssize_t index;
; 3388 : 
; 3389 :     PyObject* index_ = NULL;
; 3390 :     if (!PyArg_UnpackTuple(args, "start", 0, 1, &index_))

  0000c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR index_$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FAGFPHJG@start?$AA@
  0001d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00023	48 8b c8	 mov	 rcx, rax
  00026	45 33 c0	 xor	 r8d, r8d
  00029	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR index_$[rsp], 0
  00032	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00037	85 c0		 test	 eax, eax

; 3391 :         return NULL;

  00039	74 44		 je	 SHORT $LN6@match_star

; 3392 : 
; 3393 :     index = match_getindex(self, index_);

  0003b	48 8b 54 24 50	 mov	 rdx, QWORD PTR index_$[rsp]
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 match_getindex

; 3394 : 
; 3395 :     if (index < 0 || index >= self->groups) {

  00048	48 85 c0	 test	 rax, rax
  0004b	78 1f		 js	 SHORT $LN1@match_star
  0004d	48 3b 83 a0 00
	00 00		 cmp	 rax, QWORD PTR [rbx+160]
  00054	7d 16		 jge	 SHORT $LN1@match_star

; 3401 :     }
; 3402 : 
; 3403 :     /* mark is -1 if group is undefined */
; 3404 :     return PyLong_FromSsize_t(self->mark[index*2]);

  00056	48 03 c0	 add	 rax, rax
  00059	48 8b 8c c3 a8
	00 00 00	 mov	 rcx, QWORD PTR [rbx+rax*8+168]
  00061	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 3405 : }

  00066	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006a	5b		 pop	 rbx
  0006b	c3		 ret	 0
$LN1@match_star:

; 3396 :         PyErr_SetString(
; 3397 :             PyExc_IndexError,
; 3398 :             "no such group"
; 3399 :             );

  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@OOOHFIK@no?5such?5group?$AA@
  0007a	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@match_star:

; 3400 :         return NULL;

  0007f	33 c0		 xor	 eax, eax

; 3405 : }

  00081	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00085	5b		 pop	 rbx
  00086	c3		 ret	 0
match_start ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_end DD imagerel match_end
	DD	imagerel match_end+135
	DD	imagerel $unwind$match_end
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_end DD 020601H
	DD	030025206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT match_end
_TEXT	SEGMENT
self$ = 64
args$ = 72
index_$ = 80
match_end PROC						; COMDAT

; 3409 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 3410 :     Py_ssize_t index;
; 3411 : 
; 3412 :     PyObject* index_ = NULL;
; 3413 :     if (!PyArg_UnpackTuple(args, "end", 0, 1, &index_))

  0000c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR index_$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JBJLGPFL@end?$AA@
  0001d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00023	48 8b c8	 mov	 rcx, rax
  00026	45 33 c0	 xor	 r8d, r8d
  00029	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR index_$[rsp], 0
  00032	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00037	85 c0		 test	 eax, eax

; 3414 :         return NULL;

  00039	74 44		 je	 SHORT $LN6@match_end

; 3415 : 
; 3416 :     index = match_getindex(self, index_);

  0003b	48 8b 54 24 50	 mov	 rdx, QWORD PTR index_$[rsp]
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 match_getindex

; 3417 : 
; 3418 :     if (index < 0 || index >= self->groups) {

  00048	48 85 c0	 test	 rax, rax
  0004b	78 1f		 js	 SHORT $LN1@match_end
  0004d	48 3b 83 a0 00
	00 00		 cmp	 rax, QWORD PTR [rbx+160]
  00054	7d 16		 jge	 SHORT $LN1@match_end

; 3424 :     }
; 3425 : 
; 3426 :     /* mark is -1 if group is undefined */
; 3427 :     return PyLong_FromSsize_t(self->mark[index*2+1]);

  00056	48 8d 48 0b	 lea	 rcx, QWORD PTR [rax+11]
  0005a	48 03 c9	 add	 rcx, rcx
  0005d	48 8b 0c cb	 mov	 rcx, QWORD PTR [rbx+rcx*8]
  00061	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 3428 : }

  00066	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006a	5b		 pop	 rbx
  0006b	c3		 ret	 0
$LN1@match_end:

; 3419 :         PyErr_SetString(
; 3420 :             PyExc_IndexError,
; 3421 :             "no such group"
; 3422 :             );

  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@OOOHFIK@no?5such?5group?$AA@
  0007a	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@match_end:

; 3423 :         return NULL;

  0007f	33 c0		 xor	 eax, eax

; 3428 : }

  00081	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00085	5b		 pop	 rbx
  00086	c3		 ret	 0
match_end ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_span DD imagerel match_span
	DD	imagerel match_span+146
	DD	imagerel $unwind$match_span
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_span DD 020601H
	DD	030025206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT match_span
_TEXT	SEGMENT
self$ = 64
args$ = 72
index_$ = 80
match_span PROC						; COMDAT

; 3459 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 3460 :     Py_ssize_t index;
; 3461 : 
; 3462 :     PyObject* index_ = NULL;
; 3463 :     if (!PyArg_UnpackTuple(args, "span", 0, 1, &index_))

  0000c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR index_$[rsp]
  00011	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04FOPLNFFP@span?$AA@
  0001d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00023	48 8b c8	 mov	 rcx, rax
  00026	45 33 c0	 xor	 r8d, r8d
  00029	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR index_$[rsp], 0
  00032	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00037	85 c0		 test	 eax, eax

; 3464 :         return NULL;

  00039	74 4f		 je	 SHORT $LN6@match_span

; 3465 : 
; 3466 :     index = match_getindex(self, index_);

  0003b	48 8b 54 24 50	 mov	 rdx, QWORD PTR index_$[rsp]
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 match_getindex

; 3467 : 
; 3468 :     if (index < 0 || index >= self->groups) {

  00048	48 85 c0	 test	 rax, rax
  0004b	78 2a		 js	 SHORT $LN1@match_span
  0004d	48 3b 83 a0 00
	00 00		 cmp	 rax, QWORD PTR [rbx+160]
  00054	7d 21		 jge	 SHORT $LN1@match_span

; 3474 :     }
; 3475 : 
; 3476 :     /* marks are -1 if group is undefined */
; 3477 :     return _pair(self->mark[index*2], self->mark[index*2+1]);

  00056	48 8d 50 0b	 lea	 rdx, QWORD PTR [rax+11]
  0005a	48 03 c0	 add	 rax, rax
  0005d	48 8b 8c c3 a8
	00 00 00	 mov	 rcx, QWORD PTR [rbx+rax*8+168]
  00065	48 03 d2	 add	 rdx, rdx
  00068	48 8b 14 d3	 mov	 rdx, QWORD PTR [rbx+rdx*8]
  0006c	e8 00 00 00 00	 call	 _pair

; 3478 : }

  00071	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00075	5b		 pop	 rbx
  00076	c3		 ret	 0
$LN1@match_span:

; 3469 :         PyErr_SetString(
; 3470 :             PyExc_IndexError,
; 3471 :             "no such group"
; 3472 :             );

  00077	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@OOOHFIK@no?5such?5group?$AA@
  00085	e8 00 00 00 00	 call	 PyErr_SetString
$LN6@match_span:

; 3473 :         return NULL;

  0008a	33 c0		 xor	 eax, eax

; 3478 : }

  0008c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00090	5b		 pop	 rbx
  00091	c3		 ret	 0
match_span ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_pair DD	imagerel _pair
	DD	imagerel _pair+118
	DD	imagerel $unwind$_pair
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_pair DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT _pair
_TEXT	SEGMENT
i1$ = 48
i2$ = 56
_pair	PROC						; COMDAT

; 3432 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 3433 :     PyObject* pair;
; 3434 :     PyObject* item;
; 3435 : 
; 3436 :     pair = PyTuple_New(2);

  00012	b9 02 00 00 00	 mov	 ecx, 2
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	e8 00 00 00 00	 call	 PyTuple_New
  0001f	48 8b d8	 mov	 rbx, rax

; 3437 :     if (!pair)

  00022	48 85 c0	 test	 rax, rax

; 3438 :         return NULL;

  00025	74 3d		 je	 SHORT $LN6@pair

; 3439 : 
; 3440 :     item = PyLong_FromSsize_t(i1);

  00027	48 8b cf	 mov	 rcx, rdi
  0002a	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 3441 :     if (!item)

  0002f	48 85 c0	 test	 rax, rax
  00032	74 28		 je	 SHORT $error$25383

; 3442 :         goto error;
; 3443 :     PyTuple_SET_ITEM(pair, 0, item);
; 3444 : 
; 3445 :     item = PyLong_FromSsize_t(i2);

  00034	48 8b ce	 mov	 rcx, rsi
  00037	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
  0003b	e8 00 00 00 00	 call	 PyLong_FromSsize_t

; 3446 :     if (!item)

  00040	48 85 c0	 test	 rax, rax
  00043	74 17		 je	 SHORT $error$25383

; 3447 :         goto error;
; 3448 :     PyTuple_SET_ITEM(pair, 1, item);

  00045	48 89 43 78	 mov	 QWORD PTR [rbx+120], rax

; 3449 : 
; 3450 :     return pair;

  00049	48 8b c3	 mov	 rax, rbx

; 3454 :     return NULL;
; 3455 : }

  0004c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00051	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
$error$25383:

; 3451 : 
; 3452 :   error:
; 3453 :     Py_DECREF(pair);

  0005c	48 8b cb	 mov	 rcx, rbx
  0005f	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@pair:

; 3454 :     return NULL;
; 3455 : }

  00064	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00069	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006e	33 c0		 xor	 eax, eax
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5f		 pop	 rdi
  00075	c3		 ret	 0
_pair	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BO@OLIFHLDD@cannot?5copy?5this?5match?5object?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_copy DD imagerel match_copy
	DD	imagerel match_copy+30
	DD	imagerel $unwind$match_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_copy DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BO@OLIFHLDD@cannot?5copy?5this?5match?5object?$AA@
CONST	SEGMENT
??_C@_0BO@OLIFHLDD@cannot?5copy?5this?5match?5object?$AA@ DB 'cannot copy'
	DB	' this match object', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT match_copy
_TEXT	SEGMENT
self$ = 48
unused$ = 56
match_copy PROC						; COMDAT

; 3508 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3509 : #ifdef USE_BUILTIN_COPY
; 3510 :     MatchObject* copy;
; 3511 :     Py_ssize_t slots, offset;
; 3512 : 
; 3513 :     slots = 2 * (self->pattern->groups+1);
; 3514 : 
; 3515 :     copy = PyObject_NEW_VAR(MatchObject, &Match_Type, slots);
; 3516 :     if (!copy)
; 3517 :         return NULL;
; 3518 : 
; 3519 :     /* this value a constant, but any compiler should be able to
; 3520 :        figure that out all by itself */
; 3521 :     offset = offsetof(MatchObject, string);
; 3522 : 
; 3523 :     Py_XINCREF(self->pattern);
; 3524 :     Py_XINCREF(self->string);
; 3525 :     Py_XINCREF(self->regs);
; 3526 : 
; 3527 :     memcpy((char*) copy + offset, (char*) self + offset,
; 3528 :            sizeof(MatchObject) + slots * sizeof(Py_ssize_t) - offset);
; 3529 : 
; 3530 :     return (PyObject*) copy;
; 3531 : #else
; 3532 :     PyErr_SetString(PyExc_TypeError, "cannot copy this match object");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@OLIFHLDD@cannot?5copy?5this?5match?5object?$AA@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 3533 :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 3534 : #endif
; 3535 : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
match_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@MMIEPIHE@cannot?5deepcopy?5this?5match?5objec@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_deepcopy DD imagerel match_deepcopy
	DD	imagerel match_deepcopy+30
	DD	imagerel $unwind$match_deepcopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_deepcopy DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CC@MMIEPIHE@cannot?5deepcopy?5this?5match?5objec@
CONST	SEGMENT
??_C@_0CC@MMIEPIHE@cannot?5deepcopy?5this?5match?5objec@ DB 'cannot deepc'
	DB	'opy this match object', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT match_deepcopy
_TEXT	SEGMENT
self$ = 48
memo$ = 56
match_deepcopy PROC					; COMDAT

; 3539 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3540 : #ifdef USE_BUILTIN_COPY
; 3541 :     MatchObject* copy;
; 3542 : 
; 3543 :     copy = (MatchObject*) match_copy(self);
; 3544 :     if (!copy)
; 3545 :         return NULL;
; 3546 : 
; 3547 :     if (!deepcopy((PyObject**) &copy->pattern, memo) ||
; 3548 :         !deepcopy(&copy->string, memo) ||
; 3549 :         !deepcopy(&copy->regs, memo)) {
; 3550 :         Py_DECREF(copy);
; 3551 :         return NULL;
; 3552 :     }
; 3553 : 
; 3554 : #else
; 3555 :     PyErr_SetString(PyExc_TypeError, "cannot deepcopy this match object");

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@MMIEPIHE@cannot?5deepcopy?5this?5match?5objec@
  00012	e8 00 00 00 00	 call	 PyErr_SetString

; 3556 :     return NULL;

  00017	33 c0		 xor	 eax, eax

; 3557 : #endif
; 3558 : }

  00019	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001d	c3		 ret	 0
match_deepcopy ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_lastindex_get DD imagerel match_lastindex_get
	DD	imagerel match_lastindex_get+49
	DD	imagerel $unwind$match_lastindex_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_lastindex_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT match_lastindex_get
_TEXT	SEGMENT
self$ = 48
match_lastindex_get PROC				; COMDAT

; 3615 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3616 :     if (self->lastindex >= 0)

  00004	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  0000b	48 85 c9	 test	 rcx, rcx
  0000e	78 09		 js	 SHORT $LN1@match_last

; 3620 : }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	e9 00 00 00 00	 jmp	 PyLong_FromSsize_t
$LN1@match_last:

; 3617 :         return PyLong_FromSsize_t(self->lastindex);
; 3618 :     Py_INCREF(Py_None);

  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00020	e8 00 00 00 00	 call	 _Py_IncRef

; 3619 :     return Py_None;

  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 3620 : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
match_lastindex_get ENDP
_TEXT	ENDS
EXTRN	PySequence_GetItem:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_lastgroup_get DD imagerel match_lastgroup_get
	DD	imagerel match_lastgroup_get+77
	DD	imagerel $unwind$match_lastgroup_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_lastgroup_get DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT match_lastgroup_get
_TEXT	SEGMENT
self$ = 48
match_lastgroup_get PROC				; COMDAT

; 3624 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3625 :     if (self->pattern->indexgroup && self->lastindex >= 0) {

  00004	48 8b 81 80 00
	00 00		 mov	 rax, QWORD PTR [rcx+128]
  0000b	4c 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [rax+128]
  00012	4d 85 c0	 test	 r8, r8
  00015	74 1e		 je	 SHORT $LN2@match_last@2
  00017	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  0001e	48 85 d2	 test	 rdx, rdx
  00021	78 12		 js	 SHORT $LN2@match_last@2

; 3626 :         PyObject* result = PySequence_GetItem(
; 3627 :             self->pattern->indexgroup, self->lastindex
; 3628 :             );

  00023	49 8b c8	 mov	 rcx, r8
  00026	e8 00 00 00 00	 call	 PySequence_GetItem

; 3629 :         if (result)

  0002b	48 85 c0	 test	 rax, rax

; 3630 :             return result;

  0002e	75 18		 jne	 SHORT $LN3@match_last@2

; 3631 :         PyErr_Clear();

  00030	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@match_last@2:

; 3632 :     }
; 3633 :     Py_INCREF(Py_None);

  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0003c	e8 00 00 00 00	 call	 _Py_IncRef

; 3634 :     return Py_None;

  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@match_last@2:

; 3635 : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
match_lastgroup_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_regs_get DD imagerel match_regs_get
	DD	imagerel match_regs_get+46
	DD	imagerel $unwind$match_regs_get
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_regs_get DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT match_regs_get
_TEXT	SEGMENT
self$ = 48
match_regs_get PROC					; COMDAT

; 3639 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 3640 :     if (self->regs) {

  00009	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 0f		 je	 SHORT $LN2@match_regs

; 3641 :         Py_INCREF(self->regs);

  00012	e8 00 00 00 00	 call	 _Py_IncRef

; 3642 :         return self->regs;

  00017	48 8b 43 78	 mov	 rax, QWORD PTR [rbx+120]

; 3645 : }

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
$LN2@match_regs:

; 3643 :     } else
; 3644 :         return match_regs(self);

  00021	48 8b cb	 mov	 rcx, rbx

; 3645 : }

  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	e9 00 00 00 00	 jmp	 match_regs
match_regs_get ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$match_regs DD imagerel match_regs
	DD	imagerel match_regs+46
	DD	imagerel $unwind$match_regs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$match_regs DD imagerel match_regs+46
	DD	imagerel match_regs+165
	DD	imagerel $chain$2$match_regs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$match_regs DD imagerel match_regs+165
	DD	imagerel match_regs+177
	DD	imagerel $chain$4$match_regs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$match_regs DD 060021H
	DD	087400H
	DD	076400H
	DD	063400H
	DD	imagerel match_regs
	DD	imagerel match_regs+46
	DD	imagerel $unwind$match_regs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$match_regs DD 061121H
	DD	087411H
	DD	07640cH
	DD	063405H
	DD	imagerel match_regs
	DD	imagerel match_regs+46
	DD	imagerel $unwind$match_regs
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$match_regs DD 040b01H
	DD	09540bH
	DD	0c007320bH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT match_regs
_TEXT	SEGMENT
self$ = 48
match_regs PROC						; COMDAT

; 3482 : {

  00000	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00005	41 54		 push	 r12
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	48 8b e9	 mov	 rbp, rcx

; 3483 :     PyObject* regs;
; 3484 :     PyObject* item;
; 3485 :     Py_ssize_t index;
; 3486 : 
; 3487 :     regs = PyTuple_New(self->groups);

  0000e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00015	e8 00 00 00 00	 call	 PyTuple_New
  0001a	4c 8b e0	 mov	 r12, rax

; 3488 :     if (!regs)

  0001d	48 85 c0	 test	 rax, rax
  00020	75 0c		 jne	 SHORT $LN5@match_regs@2

; 3504 : }

  00022	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	41 5c		 pop	 r12
  0002d	c3		 ret	 0
$LN5@match_regs@2:
  0002e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 3489 :         return NULL;
; 3490 : 
; 3491 :     for (index = 0; index < self->groups; index++) {

  00033	33 db		 xor	 ebx, ebx
  00035	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0003a	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0003f	48 39 9d a0 00
	00 00		 cmp	 QWORD PTR [rbp+160], rbx
  00046	7e 33		 jle	 SHORT $LN2@match_regs@2
  00048	48 8d 78 70	 lea	 rdi, QWORD PTR [rax+112]
  0004c	48 8d b5 a8 00
	00 00		 lea	 rsi, QWORD PTR [rbp+168]
$LL4@match_regs@2:

; 3492 :         item = _pair(self->mark[index*2], self->mark[index*2+1]);

  00053	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  00057	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0005a	e8 00 00 00 00	 call	 _pair

; 3493 :         if (!item) {

  0005f	48 85 c0	 test	 rax, rax
  00062	74 41		 je	 SHORT $LN9@match_regs@2

; 3496 :         }
; 3497 :         PyTuple_SET_ITEM(regs, index, item);

  00064	48 89 07	 mov	 QWORD PTR [rdi], rax
  00067	48 ff c3	 inc	 rbx
  0006a	48 83 c7 08	 add	 rdi, 8
  0006e	48 83 c6 10	 add	 rsi, 16
  00072	48 3b 9d a0 00
	00 00		 cmp	 rbx, QWORD PTR [rbp+160]
  00079	7c d8		 jl	 SHORT $LL4@match_regs@2
$LN2@match_regs@2:

; 3498 :     }
; 3499 : 
; 3500 :     Py_INCREF(regs);

  0007b	49 8b cc	 mov	 rcx, r12
  0007e	e8 00 00 00 00	 call	 _Py_IncRef

; 3501 :     self->regs = regs;

  00083	4c 89 65 78	 mov	 QWORD PTR [rbp+120], r12

; 3502 : 
; 3503 :     return regs;

  00087	49 8b c4	 mov	 rax, r12
$LN13@match_regs@2:

; 3504 : }

  0008a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0008f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00094	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00099	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	41 5c		 pop	 r12
  000a4	c3		 ret	 0
$LN9@match_regs@2:

; 3494 :             Py_DECREF(regs);

  000a5	49 8b cc	 mov	 rcx, r12
  000a8	e8 00 00 00 00	 call	 _Py_DecRef

; 3495 :             return NULL;

  000ad	33 c0		 xor	 eax, eax
  000af	eb d9		 jmp	 SHORT $LN13@match_regs@2
match_regs ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_new_match DD imagerel pattern_new_match
	DD	imagerel pattern_new_match+36
	DD	imagerel $unwind$pattern_new_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_new_match DD imagerel pattern_new_match+36
	DD	imagerel pattern_new_match+75
	DD	imagerel $chain$0$pattern_new_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$pattern_new_match DD imagerel pattern_new_match+75
	DD	imagerel pattern_new_match+344
	DD	imagerel $chain$3$pattern_new_match
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$pattern_new_match DD imagerel pattern_new_match+344
	DD	imagerel pattern_new_match+397
	DD	imagerel $chain$4$pattern_new_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$pattern_new_match DD 021H
	DD	imagerel pattern_new_match
	DD	imagerel pattern_new_match+36
	DD	imagerel $unwind$pattern_new_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$pattern_new_match DD 040821H
	DD	065408H
	DD	077400H
	DD	imagerel pattern_new_match
	DD	imagerel pattern_new_match+36
	DD	imagerel $unwind$pattern_new_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_new_match DD 020521H
	DD	077405H
	DD	imagerel pattern_new_match
	DD	imagerel pattern_new_match+36
	DD	imagerel $unwind$pattern_new_match
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_new_match DD 040a01H
	DD	08340aH
	DD	06006320aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT pattern_new_match
_TEXT	SEGMENT
pattern$ = 48
state$ = 56
status$ = 64
pattern_new_match PROC					; COMDAT

; 3700 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	48 8b f1	 mov	 rsi, rcx

; 3701 :     /* create match object (from state object) */
; 3702 : 
; 3703 :     MatchObject* match;
; 3704 :     Py_ssize_t i, j;
; 3705 :     char* base;
; 3706 :     int n;
; 3707 : 
; 3708 :     if (status > 0) {

  00010	45 85 c0	 test	 r8d, r8d
  00013	0f 8e 3f 01 00
	00		 jle	 $LN15@pattern_ne

; 3709 : 
; 3710 :         /* create match object (with room for extra group marks) */
; 3711 :         /* coverity[ampersand_in_size] */
; 3712 :         match = PyObject_NEW_VAR(MatchObject, &Match_Type,
; 3713 :                                  2*(pattern->groups+1));

  00019	48 8b 51 70	 mov	 rdx, QWORD PTR [rcx+112]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Match_Type
  00024	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00029	48 8d 54 12 02	 lea	 rdx, QWORD PTR [rdx+rdx+2]
  0002e	e8 00 00 00 00	 call	 _PyObject_NEW_VAR
  00033	48 8b f8	 mov	 rdi, rax

; 3714 :         if (!match)

  00036	48 85 c0	 test	 rax, rax
  00039	75 10		 jne	 SHORT $LN8@pattern_ne
  0003b	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 3758 :     return NULL;
; 3759 : }

  00040	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5e		 pop	 rsi
  0004a	c3		 ret	 0
$LN8@pattern_ne:

; 3715 :             return NULL;
; 3716 : 
; 3717 :         Py_INCREF(pattern);

  0004b	48 8b ce	 mov	 rcx, rsi
  0004e	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00053	e8 00 00 00 00	 call	 _Py_IncRef

; 3718 :         match->pattern = pattern;

  00058	48 89 b7 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rsi

; 3719 : 
; 3720 :         Py_INCREF(state->string);

  0005f	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00063	e8 00 00 00 00	 call	 _Py_IncRef

; 3721 :         match->string = state->string;

  00068	4c 8b 5b 20	 mov	 r11, QWORD PTR [rbx+32]

; 3722 : 
; 3723 :         match->regs = NULL;

  0006c	45 33 d2	 xor	 r10d, r10d
  0006f	4c 89 5f 70	 mov	 QWORD PTR [rdi+112], r11
  00073	4c 89 57 78	 mov	 QWORD PTR [rdi+120], r10

; 3724 :         match->groups = pattern->groups+1;

  00077	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  0007b	48 ff c0	 inc	 rax
  0007e	48 89 87 a0 00
	00 00		 mov	 QWORD PTR [rdi+160], rax

; 3725 : 
; 3726 :         /* fill in group slices */
; 3727 : 
; 3728 :         base = (char*) state->beginning;

  00085	4c 8b 5b 08	 mov	 r11, QWORD PTR [rbx+8]

; 3729 :         n = state->charsize;
; 3730 : 
; 3731 :         match->mark[0] = ((char*) state->start - base) / n;

  00089	48 63 6b 3c	 movsxd	 rbp, DWORD PTR [rbx+60]
  0008d	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00091	49 2b c3	 sub	 rax, r11
  00094	48 99		 cdq
  00096	48 f7 fd	 idiv	 rbp
  00099	48 89 87 a8 00
	00 00		 mov	 QWORD PTR [rdi+168], rax

; 3732 :         match->mark[1] = ((char*) state->ptr - base) / n;

  000a0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000a3	49 2b c3	 sub	 rax, r11
  000a6	48 99		 cdq
  000a8	48 f7 fd	 idiv	 rbp
  000ab	48 89 87 b0 00
	00 00		 mov	 QWORD PTR [rdi+176], rax

; 3733 : 
; 3734 :         for (i = j = 0; i < pattern->groups; i++, j+=2)

  000b2	4c 39 56 70	 cmp	 QWORD PTR [rsi+112], r10
  000b6	7e 67		 jle	 SHORT $LN5@pattern_ne
  000b8	4c 8b cf	 mov	 r9, rdi
  000bb	41 b8 01 00 00
	00		 mov	 r8d, 1
  000c1	48 8d 4b 58	 lea	 rcx, QWORD PTR [rbx+88]
  000c5	4c 2b cb	 sub	 r9, rbx
$LL7@pattern_ne:

; 3735 :             if (j+1 <= state->lastmark && state->mark[j] && state->mark[j+1]) {

  000c8	4c 3b 43 48	 cmp	 r8, QWORD PTR [rbx+72]
  000cc	7f 2e		 jg	 SHORT $LN4@pattern_ne
  000ce	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]
  000d2	48 85 c0	 test	 rax, rax
  000d5	74 25		 je	 SHORT $LN4@pattern_ne
  000d7	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  000db	74 1f		 je	 SHORT $LN4@pattern_ne

; 3736 :                 match->mark[j+2] = ((char*) state->mark[j] - base) / n;

  000dd	49 2b c3	 sub	 rax, r11
  000e0	48 99		 cdq
  000e2	48 f7 fd	 idiv	 rbp
  000e5	49 89 44 09 60	 mov	 QWORD PTR [r9+rcx+96], rax

; 3737 :                 match->mark[j+3] = ((char*) state->mark[j+1] - base) / n;

  000ea	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  000ed	49 2b c3	 sub	 rax, r11
  000f0	48 99		 cdq
  000f2	48 f7 fd	 idiv	 rbp
  000f5	49 89 44 09 68	 mov	 QWORD PTR [r9+rcx+104], rax

; 3738 :             } else

  000fa	eb 12		 jmp	 SHORT $LN6@pattern_ne
$LN4@pattern_ne:

; 3739 :                 match->mark[j+2] = match->mark[j+3] = -1; /* undefined */

  000fc	49 c7 44 09 68
	ff ff ff ff	 mov	 QWORD PTR [r9+rcx+104], -1
  00105	49 c7 44 09 60
	ff ff ff ff	 mov	 QWORD PTR [r9+rcx+96], -1
$LN6@pattern_ne:

; 3733 : 
; 3734 :         for (i = j = 0; i < pattern->groups; i++, j+=2)

  0010e	49 ff c2	 inc	 r10
  00111	48 83 c1 10	 add	 rcx, 16
  00115	49 83 c0 02	 add	 r8, 2
  00119	4c 3b 56 70	 cmp	 r10, QWORD PTR [rsi+112]
  0011d	7c a9		 jl	 SHORT $LL7@pattern_ne
$LN5@pattern_ne:

; 3740 : 
; 3741 :         match->pos = state->pos;

  0011f	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00123	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00128	48 89 87 88 00
	00 00		 mov	 QWORD PTR [rdi+136], rax

; 3742 :         match->endpos = state->endpos;

  0012f	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  00133	48 89 87 90 00
	00 00		 mov	 QWORD PTR [rdi+144], rax

; 3743 : 
; 3744 :         match->lastindex = state->lastindex;

  0013a	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  0013e	48 89 87 98 00
	00 00		 mov	 QWORD PTR [rdi+152], rax

; 3745 : 
; 3746 :         return (PyObject*) match;

  00145	48 8b c7	 mov	 rax, rdi
  00148	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 3758 :     return NULL;
; 3759 : }

  0014d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00152	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00156	5e		 pop	 rsi
  00157	c3		 ret	 0
$LN15@pattern_ne:

; 3747 : 
; 3748 :     } else if (status == 0) {

  00158	75 1e		 jne	 SHORT $LN1@pattern_ne

; 3749 : 
; 3750 :         /* no match */
; 3751 :         Py_INCREF(Py_None);

  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00161	e8 00 00 00 00	 call	 _Py_IncRef

; 3752 :         return Py_None;

  00166	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 3758 :     return NULL;
; 3759 : }

  0016d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00172	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00176	5e		 pop	 rsi
  00177	c3		 ret	 0
$LN1@pattern_ne:

; 3753 : 
; 3754 :     }
; 3755 : 
; 3756 :     /* internal error */
; 3757 :     pattern_error(status);

  00178	41 8b c8	 mov	 ecx, r8d
  0017b	e8 00 00 00 00	 call	 pattern_error

; 3758 :     return NULL;
; 3759 : }

  00180	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00185	33 c0		 xor	 eax, eax
  00187	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0018b	5e		 pop	 rsi
  0018c	c3		 ret	 0
pattern_new_match ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scanner_dealloc DD imagerel scanner_dealloc
	DD	imagerel scanner_dealloc+45
	DD	imagerel $unwind$scanner_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_dealloc DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT scanner_dealloc
_TEXT	SEGMENT
self$ = 48
scanner_dealloc PROC					; COMDAT

; 3767 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 3768 :     state_fini(&self->state);

  00009	48 83 c1 68	 add	 rcx, 104		; 00000068H
  0000d	e8 00 00 00 00	 call	 state_fini

; 3769 :     Py_XDECREF(self->pattern);

  00012	48 8b 4b 60	 mov	 rcx, QWORD PTR [rbx+96]
  00016	48 85 c9	 test	 rcx, rcx
  00019	74 05		 je	 SHORT $LN3@scanner_de
  0001b	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@scanner_de:

; 3770 :     PyObject_DEL(self);

  00020	48 8b cb	 mov	 rcx, rbx

; 3771 : }

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	e9 00 00 00 00	 jmp	 _PyObject_DebugFree
scanner_dealloc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scanner_match DD imagerel scanner_match
	DD	imagerel scanner_match+191
	DD	imagerel $unwind$scanner_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_match DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT scanner_match
_TEXT	SEGMENT
self$ = 48
unused$ = 56
scanner_match PROC					; COMDAT

; 3775 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 3776 :     SRE_STATE* state = &self->state;
; 3777 :     PyObject* match;
; 3778 :     int status;
; 3779 : 
; 3780 :     state_reset(state);

  00012	48 83 c1 68	 add	 rcx, 104		; 00000068H
  00016	e8 00 00 00 00	 call	 state_reset

; 3781 : 
; 3782 :     state->ptr = state->start;

  0001b	48 8b 47 78	 mov	 rax, QWORD PTR [rdi+120]

; 3783 : 
; 3784 :     if (state->logical_charsize == 1) {
; 3785 :         status = sre_match(state, PatternObject_GetCode(self->pattern));

  0001f	48 8d 4f 68	 lea	 rcx, QWORD PTR [rdi+104]
  00023	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  00027	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  0002b	48 81 c2 00 01
	00 00		 add	 rdx, 256		; 00000100H
  00032	83 bf a0 00 00
	00 01		 cmp	 DWORD PTR [rdi+160], 1
  00039	75 0a		 jne	 SHORT $LN6@scanner_ma
  0003b	e8 00 00 00 00	 call	 sre_match
  00040	48 8b f0	 mov	 rsi, rax

; 3786 :     } else {

  00043	eb 07		 jmp	 SHORT $LN5@scanner_ma
$LN6@scanner_ma:

; 3787 :         status = sre_umatch(state, PatternObject_GetCode(self->pattern));

  00045	e8 00 00 00 00	 call	 sre_umatch
  0004a	8b f0		 mov	 esi, eax
$LN5@scanner_ma:

; 3788 :     }
; 3789 :     if (PyErr_Occurred())

  0004c	e8 00 00 00 00	 call	 PyErr_Occurred
  00051	48 85 c0	 test	 rax, rax
  00054	74 12		 je	 SHORT $LN4@scanner_ma

; 3790 :         return NULL;

  00056	33 c0		 xor	 eax, eax

; 3799 : 
; 3800 :     return match;
; 3801 : }

  00058	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
$LN4@scanner_ma:

; 3791 : 
; 3792 :     match = pattern_new_match((PatternObject*) self->pattern,
; 3793 :                                state, status);

  00068	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  0006c	48 8d 57 68	 lea	 rdx, QWORD PTR [rdi+104]
  00070	44 8b c6	 mov	 r8d, esi
  00073	e8 00 00 00 00	 call	 pattern_new_match
  00078	4c 8b d8	 mov	 r11, rax

; 3794 : 
; 3795 :     if (status == 0 || state->ptr == state->start)

  0007b	85 f6		 test	 esi, esi
  0007d	74 1e		 je	 SHORT $LN2@scanner_ma
  0007f	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  00083	48 3b 4f 78	 cmp	 rcx, QWORD PTR [rdi+120]
  00087	74 14		 je	 SHORT $LN2@scanner_ma

; 3797 :     else
; 3798 :         state->start = state->ptr;

  00089	48 89 4f 78	 mov	 QWORD PTR [rdi+120], rcx

; 3799 : 
; 3800 :     return match;
; 3801 : }

  0008d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00092	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00097	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
$LN2@scanner_ma:

; 3796 :         state->start = (void*) ((char*) state->ptr + state->charsize);

  0009d	48 63 87 a4 00
	00 00		 movsxd	 rax, DWORD PTR [rdi+164]

; 3799 : 
; 3800 :     return match;
; 3801 : }

  000a4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a9	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ae	48 03 47 68	 add	 rax, QWORD PTR [rdi+104]
  000b2	48 89 47 78	 mov	 QWORD PTR [rdi+120], rax
  000b6	49 8b c3	 mov	 rax, r11
  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
scanner_match ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$scanner_search DD imagerel scanner_search
	DD	imagerel scanner_search+191
	DD	imagerel $unwind$scanner_search
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$scanner_search DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT scanner_search
_TEXT	SEGMENT
self$ = 48
unused$ = 56
scanner_search PROC					; COMDAT

; 3806 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 3807 :     SRE_STATE* state = &self->state;
; 3808 :     PyObject* match;
; 3809 :     int status;
; 3810 : 
; 3811 :     state_reset(state);

  00012	48 83 c1 68	 add	 rcx, 104		; 00000068H
  00016	e8 00 00 00 00	 call	 state_reset

; 3812 : 
; 3813 :     state->ptr = state->start;

  0001b	48 8b 47 78	 mov	 rax, QWORD PTR [rdi+120]

; 3814 : 
; 3815 :     if (state->logical_charsize == 1) {
; 3816 :         status = sre_search(state, PatternObject_GetCode(self->pattern));

  0001f	48 8d 4f 68	 lea	 rcx, QWORD PTR [rdi+104]
  00023	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  00027	48 8b 57 60	 mov	 rdx, QWORD PTR [rdi+96]
  0002b	48 81 c2 00 01
	00 00		 add	 rdx, 256		; 00000100H
  00032	83 bf a0 00 00
	00 01		 cmp	 DWORD PTR [rdi+160], 1
  00039	75 0a		 jne	 SHORT $LN6@scanner_se
  0003b	e8 00 00 00 00	 call	 sre_search
  00040	48 8b f0	 mov	 rsi, rax

; 3817 :     } else {

  00043	eb 07		 jmp	 SHORT $LN5@scanner_se
$LN6@scanner_se:

; 3818 :         status = sre_usearch(state, PatternObject_GetCode(self->pattern));

  00045	e8 00 00 00 00	 call	 sre_usearch
  0004a	8b f0		 mov	 esi, eax
$LN5@scanner_se:

; 3819 :     }
; 3820 :     if (PyErr_Occurred())

  0004c	e8 00 00 00 00	 call	 PyErr_Occurred
  00051	48 85 c0	 test	 rax, rax
  00054	74 12		 je	 SHORT $LN4@scanner_se

; 3821 :         return NULL;

  00056	33 c0		 xor	 eax, eax

; 3830 : 
; 3831 :     return match;
; 3832 : }

  00058	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5f		 pop	 rdi
  00067	c3		 ret	 0
$LN4@scanner_se:

; 3822 : 
; 3823 :     match = pattern_new_match((PatternObject*) self->pattern,
; 3824 :                                state, status);

  00068	48 8b 4f 60	 mov	 rcx, QWORD PTR [rdi+96]
  0006c	48 8d 57 68	 lea	 rdx, QWORD PTR [rdi+104]
  00070	44 8b c6	 mov	 r8d, esi
  00073	e8 00 00 00 00	 call	 pattern_new_match
  00078	4c 8b d8	 mov	 r11, rax

; 3825 : 
; 3826 :     if (status == 0 || state->ptr == state->start)

  0007b	85 f6		 test	 esi, esi
  0007d	74 1e		 je	 SHORT $LN2@scanner_se
  0007f	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  00083	48 3b 4f 78	 cmp	 rcx, QWORD PTR [rdi+120]
  00087	74 14		 je	 SHORT $LN2@scanner_se

; 3828 :     else
; 3829 :         state->start = state->ptr;

  00089	48 89 4f 78	 mov	 QWORD PTR [rdi+120], rcx

; 3830 : 
; 3831 :     return match;
; 3832 : }

  0008d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00092	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00097	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
$LN2@scanner_se:

; 3827 :         state->start = (void*) ((char*) state->ptr + state->charsize);

  0009d	48 63 87 a4 00
	00 00		 movsxd	 rax, DWORD PTR [rdi+164]

; 3830 : 
; 3831 :     return match;
; 3832 : }

  000a4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a9	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ae	48 03 47 68	 add	 rax, QWORD PTR [rdi+104]
  000b2	48 89 47 78	 mov	 QWORD PTR [rdi+120], rax
  000b6	49 8b c3	 mov	 rax, r11
  000b9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
scanner_search ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@MIGCLFHA@O?$HMnn?3scanner?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pattern_scanner DD imagerel pattern_scanner
	DD	imagerel pattern_scanner+107
	DD	imagerel $unwind$pattern_scanner
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$pattern_scanner DD imagerel pattern_scanner+107
	DD	imagerel pattern_scanner+196
	DD	imagerel $chain$0$pattern_scanner
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$pattern_scanner DD imagerel pattern_scanner+196
	DD	imagerel pattern_scanner+222
	DD	imagerel $chain$2$pattern_scanner
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$pattern_scanner DD 020021H
	DD	0c3400H
	DD	imagerel pattern_scanner
	DD	imagerel pattern_scanner+107
	DD	imagerel $unwind$pattern_scanner
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$pattern_scanner DD 020521H
	DD	0c3405H
	DD	imagerel pattern_scanner
	DD	imagerel pattern_scanner+107
	DD	imagerel $unwind$pattern_scanner
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pattern_scanner DD 020801H
	DD	070049208H
xdata	ENDS
;	COMDAT ??_C@_0N@MIGCLFHA@O?$HMnn?3scanner?$AA@
CONST	SEGMENT
??_C@_0N@MIGCLFHA@O?$HMnn?3scanner?$AA@ DB 'O|nn:scanner', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT pattern_scanner
_TEXT	SEGMENT
start$ = 64
string$ = 72
pattern$ = 96
args$ = 104
kw$ = 112
end$ = 120
pattern_scanner PROC					; COMDAT

; 3880 : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	57		 push	 rdi
  00004	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00008	48 8b f9	 mov	 rdi, rcx
  0000b	49 8b c0	 mov	 rax, r8
  0000e	4c 8b d2	 mov	 r10, rdx

; 3881 :     /* create search state object */
; 3882 : 
; 3883 :     ScannerObject* self;
; 3884 : 
; 3885 :     PyObject* string;
; 3886 :     Py_ssize_t start = 0;
; 3887 :     Py_ssize_t end = PY_SSIZE_T_MAX;

  00011	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH

; 3888 :     static char* kwlist[] = { "source", "pos", "endpos", NULL };
; 3889 :     if (!PyArg_ParseTupleAndKeywords(args, kw, "O|nn:scanner", kwlist,
; 3890 :                                      &string, &start, &end))

  0001b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??pattern_scanner@@9@9
  00022	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0N@MIGCLFHA@O?$HMnn?3scanner?$AA@
  00029	49 89 4b 20	 mov	 QWORD PTR [r11+32], rcx
  0002d	49 8d 4b 20	 lea	 rcx, QWORD PTR [r11+32]
  00031	48 8b d0	 mov	 rdx, rax
  00034	49 89 4b d8	 mov	 QWORD PTR [r11-40], rcx
  00038	49 8d 4b e8	 lea	 rcx, QWORD PTR [r11-24]
  0003c	49 c7 43 e8 00
	00 00 00	 mov	 QWORD PTR [r11-24], 0
  00044	49 89 4b d0	 mov	 QWORD PTR [r11-48], rcx
  00048	49 8d 4b f0	 lea	 rcx, QWORD PTR [r11-16]
  0004c	49 89 4b c8	 mov	 QWORD PTR [r11-56], rcx
  00050	49 8b ca	 mov	 rcx, r10
  00053	e8 00 00 00 00	 call	 _PyArg_ParseTupleAndKeywords_SizeT
  00058	85 c0		 test	 eax, eax
  0005a	75 08		 jne	 SHORT $LN3@pattern_sc

; 3891 :         return NULL;

  0005c	33 c0		 xor	 eax, eax

; 3909 : }

  0005e	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
$LN3@pattern_sc:

; 3892 : 
; 3893 :     /* create scanner object */
; 3894 :     self = PyObject_NEW(ScannerObject, &Scanner_Type);

  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Scanner_Type
  0006b	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00070	e8 00 00 00 00	 call	 _PyObject_NEW
  00075	48 8b d8	 mov	 rbx, rax

; 3895 :     if (!self)

  00078	48 85 c0	 test	 rax, rax

; 3896 :         return NULL;

  0007b	74 3a		 je	 SHORT $LN7@pattern_sc

; 3897 :     self->pattern = NULL;

  0007d	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 3898 : 
; 3899 :     string = state_init(&self->state, pattern, string, start, end);

  00085	4c 8b 4c 24 40	 mov	 r9, QWORD PTR start$[rsp]
  0008a	4c 8b 44 24 48	 mov	 r8, QWORD PTR string$[rsp]
  0008f	48 8d 48 68	 lea	 rcx, QWORD PTR [rax+104]
  00093	48 8b 44 24 78	 mov	 rax, QWORD PTR end$[rsp]
  00098	48 8b d7	 mov	 rdx, rdi
  0009b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a0	e8 00 00 00 00	 call	 state_init
  000a5	48 89 44 24 48	 mov	 QWORD PTR string$[rsp], rax

; 3900 :     if (!string) {

  000aa	48 85 c0	 test	 rax, rax
  000ad	75 15		 jne	 SHORT $LN1@pattern_sc

; 3901 :         Py_DECREF(self);

  000af	48 8b cb	 mov	 rcx, rbx
  000b2	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@pattern_sc:

; 3902 :         return NULL;

  000b7	33 c0		 xor	 eax, eax
  000b9	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 3909 : }

  000be	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
$LN1@pattern_sc:

; 3903 :     }
; 3904 : 
; 3905 :     Py_INCREF(pattern);

  000c4	48 8b cf	 mov	 rcx, rdi
  000c7	e8 00 00 00 00	 call	 _Py_IncRef

; 3906 :     self->pattern = (PyObject*) pattern;

  000cc	48 89 7b 60	 mov	 QWORD PTR [rbx+96], rdi

; 3907 : 
; 3908 :     return (PyObject*) self;

  000d0	48 8b c3	 mov	 rax, rbx
  000d3	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 3909 : }

  000d8	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000dc	5f		 pop	 rdi
  000dd	c3		 ret	 0
pattern_scanner ENDP
_TEXT	ENDS
EXTRN	PyObject_Init:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\objimpl.h
pdata	SEGMENT
$pdata$_PyObject_NEW DD imagerel _PyObject_NEW
	DD	imagerel _PyObject_NEW+62
	DD	imagerel $unwind$_PyObject_NEW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_NEW DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_NEW
_TEXT	SEGMENT
tp$ = 48
_PyObject_NEW PROC					; COMDAT

; 293  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 294  :     Px_RETURN(_PxObject_New(tp))

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0c		 je	 SHORT $LN1@PyObject_N@2
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tp$[rsp]
  00017	e8 00 00 00 00	 call	 _PxObject_New
  0001c	eb 1b		 jmp	 SHORT $LN2@PyObject_N@2
$LN1@PyObject_N@2:

; 295  :     return PyObject_Init((PyObject *)PyObject_MALLOC(_PyObject_SIZE(tp)), tp);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR tp$[rsp]
  00023	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00027	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  0002c	48 8b 54 24 30	 mov	 rdx, QWORD PTR tp$[rsp]
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 PyObject_Init
$LN2@PyObject_N@2:

; 296  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
_PyObject_NEW ENDP
_TEXT	ENDS
PUBLIC	??_C@_09JHBDCMB@copyright?$AA@			; `string'
PUBLIC	??_C@_09OIJCJPIM@MAXREPEAT?$AA@			; `string'
PUBLIC	??_C@_08JEAPHMON@CODESIZE?$AA@			; `string'
PUBLIC	??_C@_05DKLEPMBK@MAGIC?$AA@			; `string'
PUBLIC	PyInit__sre
EXTRN	PyLong_FromUnsignedLong:PROC
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
EXTRN	PyType_Ready:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\_sre.c
pdata	SEGMENT
$pdata$PyInit__sre DD imagerel $LN11
	DD	imagerel $LN11+76
	DD	imagerel $unwind$PyInit__sre
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyInit__sre DD imagerel $LN11+76
	DD	imagerel $LN11+104
	DD	imagerel $chain$0$PyInit__sre
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyInit__sre DD imagerel $LN11+104
	DD	imagerel $LN11+324
	DD	imagerel $chain$4$PyInit__sre
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$PyInit__sre DD imagerel $LN11+324
	DD	imagerel $LN11+331
	DD	imagerel $chain$5$PyInit__sre
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$PyInit__sre DD 021H
	DD	imagerel $LN11
	DD	imagerel $LN11+76
	DD	imagerel $unwind$PyInit__sre
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyInit__sre DD 060d21H
	DD	04740dH
	DD	076408H
	DD	063400H
	DD	imagerel $LN11
	DD	imagerel $LN11+76
	DD	imagerel $unwind$PyInit__sre
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyInit__sre DD 020521H
	DD	063405H
	DD	imagerel $LN11
	DD	imagerel $LN11+76
	DD	imagerel $unwind$PyInit__sre
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit__sre DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_09JHBDCMB@copyright?$AA@
CONST	SEGMENT
??_C@_09JHBDCMB@copyright?$AA@ DB 'copyright', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OIJCJPIM@MAXREPEAT?$AA@
CONST	SEGMENT
??_C@_09OIJCJPIM@MAXREPEAT?$AA@ DB 'MAXREPEAT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08JEAPHMON@CODESIZE?$AA@
CONST	SEGMENT
??_C@_08JEAPHMON@CODESIZE?$AA@ DB 'CODESIZE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DKLEPMBK@MAGIC?$AA@
CONST	SEGMENT
??_C@_05DKLEPMBK@MAGIC?$AA@ DB 'MAGIC', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyInit__sre
_TEXT	SEGMENT
PyInit__sre PROC					; COMDAT

; 3931 : {

$LN11:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3932 :     PyObject* m;
; 3933 :     PyObject* d;
; 3934 :     PyObject* x;
; 3935 : 
; 3936 :     /* Patch object types */
; 3937 :     if (PyType_Ready(&Pattern_Type) || PyType_Ready(&Match_Type) ||
; 3938 :         PyType_Ready(&Scanner_Type))

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Pattern_Type
  0000b	e8 00 00 00 00	 call	 PyType_Ready
  00010	85 c0		 test	 eax, eax
  00012	0f 85 2c 01 00
	00		 jne	 $LN6@PyInit__sr
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Match_Type
  0001f	e8 00 00 00 00	 call	 PyType_Ready
  00024	85 c0		 test	 eax, eax
  00026	0f 85 18 01 00
	00		 jne	 $LN6@PyInit__sr
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Scanner_Type
  00033	e8 00 00 00 00	 call	 PyType_Ready
  00038	85 c0		 test	 eax, eax
  0003a	0f 85 04 01 00
	00		 jne	 $LN6@PyInit__sr

; 3940 : 
; 3941 :     m = PyModule_Create(&sremodule);

  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sremodule
  00047	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  0004c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00051	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00056	48 8b d8	 mov	 rbx, rax

; 3942 :     if (m == NULL)

  00059	48 85 c0	 test	 rax, rax
  0005c	75 0a		 jne	 SHORT $LN5@PyInit__sr
  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3970 : }

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
$LN5@PyInit__sr:

; 3943 :         return NULL;
; 3944 :     d = PyModule_GetDict(m);

  00068	48 8b c8	 mov	 rcx, rax
  0006b	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00070	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00075	e8 00 00 00 00	 call	 PyModule_GetDict

; 3945 : 
; 3946 :     x = PyLong_FromLong(SRE_MAGIC);

  0007a	b9 29 a6 31 01	 mov	 ecx, 20031017		; 0131a629H
  0007f	48 8b f0	 mov	 rsi, rax
  00082	e8 00 00 00 00	 call	 PyLong_FromLong
  00087	48 8b f8	 mov	 rdi, rax

; 3947 :     if (x) {

  0008a	48 85 c0	 test	 rax, rax
  0008d	74 1a		 je	 SHORT $LN4@PyInit__sr

; 3948 :         PyDict_SetItemString(d, "MAGIC", x);

  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05DKLEPMBK@MAGIC?$AA@
  00096	4c 8b c0	 mov	 r8, rax
  00099	48 8b ce	 mov	 rcx, rsi
  0009c	e8 00 00 00 00	 call	 PyDict_SetItemString

; 3949 :         Py_DECREF(x);

  000a1	48 8b cf	 mov	 rcx, rdi
  000a4	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@PyInit__sr:

; 3950 :     }
; 3951 : 
; 3952 :     x = PyLong_FromLong(sizeof(SRE_CODE));

  000a9	b9 04 00 00 00	 mov	 ecx, 4
  000ae	e8 00 00 00 00	 call	 PyLong_FromLong
  000b3	48 8b f8	 mov	 rdi, rax

; 3953 :     if (x) {

  000b6	48 85 c0	 test	 rax, rax
  000b9	74 1a		 je	 SHORT $LN3@PyInit__sr

; 3954 :         PyDict_SetItemString(d, "CODESIZE", x);

  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08JEAPHMON@CODESIZE?$AA@
  000c2	4c 8b c0	 mov	 r8, rax
  000c5	48 8b ce	 mov	 rcx, rsi
  000c8	e8 00 00 00 00	 call	 PyDict_SetItemString

; 3955 :         Py_DECREF(x);

  000cd	48 8b cf	 mov	 rcx, rdi
  000d0	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyInit__sr:

; 3956 :     }
; 3957 : 
; 3958 :     x = PyLong_FromUnsignedLong(SRE_MAXREPEAT);

  000d5	83 c9 ff	 or	 ecx, -1			; ffffffffH
  000d8	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
  000dd	48 8b f8	 mov	 rdi, rax

; 3959 :     if (x) {

  000e0	48 85 c0	 test	 rax, rax
  000e3	74 1a		 je	 SHORT $LN2@PyInit__sr

; 3960 :         PyDict_SetItemString(d, "MAXREPEAT", x);

  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09OIJCJPIM@MAXREPEAT?$AA@
  000ec	4c 8b c0	 mov	 r8, rax
  000ef	48 8b ce	 mov	 rcx, rsi
  000f2	e8 00 00 00 00	 call	 PyDict_SetItemString

; 3961 :         Py_DECREF(x);

  000f7	48 8b cf	 mov	 rcx, rdi
  000fa	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PyInit__sr:

; 3962 :     }
; 3963 : 
; 3964 :     x = PyUnicode_FromString(copyright);

  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:copyright
  00106	e8 00 00 00 00	 call	 PyUnicode_FromString
  0010b	48 8b f8	 mov	 rdi, rax

; 3965 :     if (x) {

  0010e	48 85 c0	 test	 rax, rax
  00111	74 1a		 je	 SHORT $LN1@PyInit__sr

; 3966 :         PyDict_SetItemString(d, "copyright", x);

  00113	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09JHBDCMB@copyright?$AA@
  0011a	4c 8b c0	 mov	 r8, rax
  0011d	48 8b ce	 mov	 rcx, rsi
  00120	e8 00 00 00 00	 call	 PyDict_SetItemString

; 3967 :         Py_DECREF(x);

  00125	48 8b cf	 mov	 rcx, rdi
  00128	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyInit__sr:

; 3968 :     }
; 3969 :     return m;

  0012d	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  00132	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00137	48 8b c3	 mov	 rax, rbx
  0013a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 3970 : }

  0013f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00143	c3		 ret	 0
$LN6@PyInit__sr:

; 3939 :         return NULL;

  00144	33 c0		 xor	 eax, eax

; 3970 : }

  00146	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0014a	c3		 ret	 0
PyInit__sre ENDP
_TEXT	ENDS
END
