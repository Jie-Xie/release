; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06CMONBEBE@atexit?$AA@			; `string'
PUBLIC	??_C@_0P@KFBBEIOJ@_run_exitfuncs?$AA@		; `string'
PUBLIC	??_C@_0L@PKKNFCHP@unregister?$AA@		; `string'
PUBLIC	??_C@_06DNEIODDF@_clear?$AA@			; `string'
PUBLIC	??_C@_08DHHIDNEP@register?$AA@			; `string'
;	COMDAT ??_C@_06CMONBEBE@atexit?$AA@
CONST	SEGMENT
??_C@_06CMONBEBE@atexit?$AA@ DB 'atexit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KFBBEIOJ@_run_exitfuncs?$AA@
CONST	SEGMENT
??_C@_0P@KFBBEIOJ@_run_exitfuncs?$AA@ DB '_run_exitfuncs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PKKNFCHP@unregister?$AA@
CONST	SEGMENT
??_C@_0L@PKKNFCHP@unregister?$AA@ DB 'unregister', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DNEIODDF@_clear?$AA@
CONST	SEGMENT
??_C@_06DNEIODDF@_clear?$AA@ DB '_clear', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DHHIDNEP@register?$AA@
CONST	SEGMENT
??_C@_08DHHIDNEP@register?$AA@ DB 'register', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
atexit_register__doc__ DB 'register(func, *args, **kwargs) -> func', 0aH, 0aH
	DB	'Register a function to be executed upon normal program termin'
	DB	'ation', 0aH, 0aH, '    func - function to be called at exit', 0aH
	DB	'    args - optional arguments to pass to func', 0aH, '    kwa'
	DB	'rgs - optional keyword arguments to pass to func', 0aH, 0aH, ' '
	DB	'   func is returned to facilitate usage as a decorator.', 00H
	ORG $+2
atexit_run_exitfuncs__doc__ DB '_run_exitfuncs() -> None', 0aH, 0aH, 'Run'
	DB	' all registered exit functions.', 00H
	ORG $+11
atexit_clear__doc__ DB '_clear() -> None', 0aH, 0aH, 'Clear the list of p'
	DB	'reviously registered exit functions.', 00H
	ORG $+6
atexit_unregister__doc__ DB 'unregister(func) -> None', 0aH, 0aH, 'Unregi'
	DB	'ster a exit function which was previously registered using', 0aH
	DB	'atexit.register', 0aH, 0aH, '    func - function to be unregi'
	DB	'stered', 00H
	ORG $+13
atexit_methods DQ FLAT:??_C@_08DHHIDNEP@register?$AA@
	DQ	FLAT:atexit_register
	DD	03H
	ORG $+4
	DQ	FLAT:atexit_register__doc__
	DQ	FLAT:??_C@_06DNEIODDF@_clear?$AA@
	DQ	FLAT:atexit_clear
	DD	04H
	ORG $+4
	DQ	FLAT:atexit_clear__doc__
	DQ	FLAT:??_C@_0L@PKKNFCHP@unregister?$AA@
	DQ	FLAT:atexit_unregister
	DD	08H
	ORG $+4
	DQ	FLAT:atexit_unregister__doc__
	DQ	FLAT:??_C@_0P@KFBBEIOJ@_run_exitfuncs?$AA@
	DQ	FLAT:atexit_run_exitfuncs
	DD	04H
	ORG $+4
	DQ	FLAT:atexit_run_exitfuncs__doc__
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
atexit__doc__ DB 'allow programmer to define multiple exit functions to b'
	DB	'e executedupon normal program termination.', 0aH, 0aH, 'Two p'
	DB	'ublic functions, register and unregister, are defined.', 0aH, 00H
atexitmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06CMONBEBE@atexit?$AA@
	DQ	FLAT:atexit__doc__
	DQ	0000000000000010H
	DQ	FLAT:atexit_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:atexit_free
_DATA	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0CE@ILJKFDML@the?5first?5argument?5must?5be?5calla@ ; `string'
PUBLIC	??_C@_0CP@NKAFPPKC@register?$CI?$CJ?5takes?5at?5least?51?5argu@ ; `string'
EXTRN	PyMem_Free:PROC
EXTRN	PyTuple_GetSlice:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	PyCallable_Check:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Realloc:PROC
EXTRN	PyModule_GetState:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\atexitmodule.c
pdata	SEGMENT
$pdata$atexit_register DD imagerel atexit_register
	DD	imagerel atexit_register+454
	DD	imagerel $unwind$atexit_register
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$atexit_register DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0CE@ILJKFDML@the?5first?5argument?5must?5be?5calla@
CONST	SEGMENT
??_C@_0CE@ILJKFDML@the?5first?5argument?5must?5be?5calla@ DB 'the first a'
	DB	'rgument must be callable', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NKAFPPKC@register?$CI?$CJ?5takes?5at?5least?51?5argu@
CONST	SEGMENT
??_C@_0CP@NKAFPPKC@register?$CI?$CJ?5takes?5at?5least?51?5argu@ DB 'regis'
	DB	'ter() takes at least 1 argument (0 given)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT atexit_register
_TEXT	SEGMENT
modstate$ = 32
func$ = 40
new_callback$ = 48
r$20385 = 56
self$ = 80
args$ = 88
kwargs$ = 96
atexit_register PROC					; COMDAT

; 125  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 126  :     atexitmodule_state *modstate;
; 127  :     atexit_callback *new_callback;
; 128  :     PyObject *func = NULL;

  00013	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR func$[rsp], 0

; 129  : 
; 130  :     modstate = GET_ATEXIT_STATE(self);

  0001c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00021	e8 00 00 00 00	 call	 PyModule_GetState
  00026	48 89 44 24 20	 mov	 QWORD PTR modstate$[rsp], rax

; 131  : 
; 132  :     if (modstate->ncallbacks >= modstate->callback_len) {

  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR modstate$[rsp]
  00035	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00038	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  0003b	7c 54		 jl	 SHORT $LN10@atexit_reg

; 133  :         atexit_callback **r;
; 134  :         modstate->callback_len += 16;

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  00042	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00045	83 c0 10	 add	 eax, 16
  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR modstate$[rsp]
  0004d	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 135  :         r = (atexit_callback**)PyMem_Realloc(modstate->atexit_callbacks,
; 136  :                                       sizeof(atexit_callback*) * modstate->callback_len);

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  00055	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00059	48 c1 e0 03	 shl	 rax, 3
  0005d	48 8b d0	 mov	 rdx, rax
  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  00065	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00068	e8 00 00 00 00	 call	 PyMem_Realloc
  0006d	48 89 44 24 38	 mov	 QWORD PTR r$20385[rsp], rax

; 137  :         if (r == NULL)

  00072	48 83 7c 24 38
	00		 cmp	 QWORD PTR r$20385[rsp], 0
  00078	75 0a		 jne	 SHORT $LN9@atexit_reg

; 138  :             return PyErr_NoMemory();

  0007a	e8 00 00 00 00	 call	 PyErr_NoMemory
  0007f	e9 3d 01 00 00	 jmp	 $LN11@atexit_reg
$LN9@atexit_reg:

; 139  :         modstate->atexit_callbacks = r;

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  00089	48 8b 4c 24 38	 mov	 rcx, QWORD PTR r$20385[rsp]
  0008e	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN10@atexit_reg:

; 140  :     }
; 141  : 
; 142  :     if (PyTuple_GET_SIZE(args) == 0) {

  00091	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00096	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0009b	75 1a		 jne	 SHORT $LN8@atexit_reg

; 143  :         PyErr_SetString(PyExc_TypeError,
; 144  :                 "register() takes at least 1 argument (0 given)");

  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@NKAFPPKC@register?$CI?$CJ?5takes?5at?5least?51?5argu@
  000a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ab	e8 00 00 00 00	 call	 PyErr_SetString

; 145  :         return NULL; 

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 0a 01 00 00	 jmp	 $LN11@atexit_reg
$LN8@atexit_reg:

; 146  :     }
; 147  : 
; 148  :     func = PyTuple_GET_ITEM(args, 0);

  000b7	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  000bc	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000c0	48 89 44 24 28	 mov	 QWORD PTR func$[rsp], rax

; 149  :     if (!PyCallable_Check(func)) {

  000c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR func$[rsp]
  000ca	e8 00 00 00 00	 call	 PyCallable_Check
  000cf	85 c0		 test	 eax, eax
  000d1	75 1a		 jne	 SHORT $LN7@atexit_reg

; 150  :         PyErr_SetString(PyExc_TypeError,
; 151  :                 "the first argument must be callable");

  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@ILJKFDML@the?5first?5argument?5must?5be?5calla@
  000da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000e1	e8 00 00 00 00	 call	 PyErr_SetString

; 152  :         return NULL;

  000e6	33 c0		 xor	 eax, eax
  000e8	e9 d4 00 00 00	 jmp	 $LN11@atexit_reg
$LN7@atexit_reg:

; 153  :     }
; 154  : 
; 155  :     new_callback = PyMem_Malloc(sizeof(atexit_callback));

  000ed	b9 18 00 00 00	 mov	 ecx, 24
  000f2	e8 00 00 00 00	 call	 PyMem_Malloc
  000f7	48 89 44 24 30	 mov	 QWORD PTR new_callback$[rsp], rax

; 156  :     if (new_callback == NULL)

  000fc	48 83 7c 24 30
	00		 cmp	 QWORD PTR new_callback$[rsp], 0
  00102	75 0a		 jne	 SHORT $LN6@atexit_reg

; 157  :         return PyErr_NoMemory();   

  00104	e8 00 00 00 00	 call	 PyErr_NoMemory
  00109	e9 b3 00 00 00	 jmp	 $LN11@atexit_reg
$LN6@atexit_reg:

; 158  : 
; 159  :     new_callback->args = PyTuple_GetSlice(args, 1, PyTuple_GET_SIZE(args));

  0010e	48 8b 44 24 58	 mov	 rax, QWORD PTR args$[rsp]
  00113	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00117	ba 01 00 00 00	 mov	 edx, 1
  0011c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00121	e8 00 00 00 00	 call	 PyTuple_GetSlice
  00126	48 8b 4c 24 30	 mov	 rcx, QWORD PTR new_callback$[rsp]
  0012b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 160  :     if (new_callback->args == NULL) {

  0012f	48 8b 44 24 30	 mov	 rax, QWORD PTR new_callback$[rsp]
  00134	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00139	75 0e		 jne	 SHORT $LN5@atexit_reg

; 161  :         PyMem_Free(new_callback);

  0013b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR new_callback$[rsp]
  00140	e8 00 00 00 00	 call	 PyMem_Free

; 162  :         return NULL;

  00145	33 c0		 xor	 eax, eax
  00147	eb 78		 jmp	 SHORT $LN11@atexit_reg
$LN5@atexit_reg:

; 163  :     }
; 164  :     new_callback->func = func;

  00149	48 8b 44 24 30	 mov	 rax, QWORD PTR new_callback$[rsp]
  0014e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR func$[rsp]
  00153	48 89 08	 mov	 QWORD PTR [rax], rcx

; 165  :     new_callback->kwargs = kwargs;

  00156	48 8b 44 24 30	 mov	 rax, QWORD PTR new_callback$[rsp]
  0015b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR kwargs$[rsp]
  00160	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 166  :     Py_INCREF(func);

  00164	48 8b 4c 24 28	 mov	 rcx, QWORD PTR func$[rsp]
  00169	e8 00 00 00 00	 call	 _Py_IncRef
$LN4@atexit_reg:

; 167  :     Py_XINCREF(kwargs);

  0016e	48 83 7c 24 60
	00		 cmp	 QWORD PTR kwargs$[rsp], 0
  00174	74 0a		 je	 SHORT $LN1@atexit_reg
  00176	48 8b 4c 24 60	 mov	 rcx, QWORD PTR kwargs$[rsp]
  0017b	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@atexit_reg:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 e8		 jne	 SHORT $LN4@atexit_reg

; 168  : 
; 169  :     modstate->atexit_callbacks[modstate->ncallbacks++] = new_callback;

  00186	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  0018b	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  0018f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR modstate$[rsp]
  00194	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00197	48 8b 54 24 30	 mov	 rdx, QWORD PTR new_callback$[rsp]
  0019c	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
  001a0	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  001a5	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001a8	ff c0		 inc	 eax
  001aa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR modstate$[rsp]
  001af	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 170  : 
; 171  :     Py_INCREF(func);

  001b2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR func$[rsp]
  001b7	e8 00 00 00 00	 call	 _Py_IncRef

; 172  :     return func;

  001bc	48 8b 44 24 28	 mov	 rax, QWORD PTR func$[rsp]
$LN11@atexit_reg:

; 173  : }

  001c1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c5	c3		 ret	 0
atexit_register ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyErr_Occurred:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\atexitmodule.c
pdata	SEGMENT
$pdata$atexit_run_exitfuncs DD imagerel atexit_run_exitfuncs
	DD	imagerel atexit_run_exitfuncs+57
	DD	imagerel $unwind$atexit_run_exitfuncs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$atexit_run_exitfuncs DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT atexit_run_exitfuncs
_TEXT	SEGMENT
self$ = 48
unused$ = 56
atexit_run_exitfuncs PROC				; COMDAT

; 182  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 183  :     atexit_callfuncs();

  0000e	e8 00 00 00 00	 call	 atexit_callfuncs

; 184  :     if (PyErr_Occurred())

  00013	e8 00 00 00 00	 call	 PyErr_Occurred
  00018	48 85 c0	 test	 rax, rax
  0001b	74 04		 je	 SHORT $LN1@atexit_run

; 185  :         return NULL;

  0001d	33 c0		 xor	 eax, eax
  0001f	eb 13		 jmp	 SHORT $LN2@atexit_run
$LN1@atexit_run:

; 186  :     Py_RETURN_NONE;

  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00028	e8 00 00 00 00	 call	 _Py_IncRef
  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@atexit_run:

; 187  : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
atexit_run_exitfuncs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@OCGJGIFK@Error?5in?5atexit?4_run_exitfuncs?3?6@ ; `string'
PUBLIC	_Py_DecRef
EXTRN	PyErr_Restore:PROC
EXTRN	PyErr_Display:PROC
EXTRN	PyErr_NormalizeException:PROC
EXTRN	PySys_WriteStderr:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_SystemExit:QWORD
EXTRN	PyErr_Fetch:PROC
EXTRN	PyObject_Call:PROC
EXTRN	PyState_FindModule:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$atexit_callfuncs DD imagerel atexit_callfuncs
	DD	imagerel atexit_callfuncs+417
	DD	imagerel $unwind$atexit_callfuncs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$atexit_callfuncs DD 010401H
	DD	0c204H
xdata	ENDS
;	COMDAT ??_C@_0CB@OCGJGIFK@Error?5in?5atexit?4_run_exitfuncs?3?6@
CONST	SEGMENT
??_C@_0CB@OCGJGIFK@Error?5in?5atexit?4_run_exitfuncs?3?6@ DB 'Error in at'
	DB	'exit._run_exitfuncs:', 0aH, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT atexit_callfuncs
_TEXT	SEGMENT
i$ = 32
exc_tb$ = 40
module$ = 48
exc_type$ = 56
modstate$ = 64
r$ = 72
cb$ = 80
exc_value$ = 88
atexit_callfuncs PROC					; COMDAT

; 40   : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 41   :     PyObject *exc_type = NULL, *exc_value, *exc_tb, *r;

  00004	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR exc_type$[rsp], 0

; 42   :     atexit_callback *cb;
; 43   :     PyObject *module;
; 44   :     atexitmodule_state *modstate;
; 45   :     int i;
; 46   : 
; 47   :     module = PyState_FindModule(&atexitmodule);

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:atexitmodule
  00014	e8 00 00 00 00	 call	 PyState_FindModule
  00019	48 89 44 24 30	 mov	 QWORD PTR module$[rsp], rax

; 48   :     if (module == NULL)

  0001e	48 83 7c 24 30
	00		 cmp	 QWORD PTR module$[rsp], 0
  00024	75 05		 jne	 SHORT $LN22@atexit_cal

; 49   :         return;

  00026	e9 71 01 00 00	 jmp	 $LN23@atexit_cal
$LN22@atexit_cal:

; 50   :     modstate = GET_ATEXIT_STATE(module);

  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR module$[rsp]
  00030	e8 00 00 00 00	 call	 PyModule_GetState
  00035	48 89 44 24 40	 mov	 QWORD PTR modstate$[rsp], rax

; 51   : 
; 52   :     if (modstate->ncallbacks == 0)

  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR modstate$[rsp]
  0003f	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00043	75 05		 jne	 SHORT $LN21@atexit_cal

; 53   :         return;

  00045	e9 52 01 00 00	 jmp	 $LN23@atexit_cal
$LN21@atexit_cal:

; 54   : 
; 55   : 
; 56   :     for (i = modstate->ncallbacks - 1; i >= 0; i--)

  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR modstate$[rsp]
  0004f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00052	ff c8		 dec	 eax
  00054	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00058	eb 0a		 jmp	 SHORT $LN20@atexit_cal
$LN19@atexit_cal:
  0005a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0005e	ff c8		 dec	 eax
  00060	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN20@atexit_cal:
  00064	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00069	0f 8c 07 01 00
	00		 jl	 $LN18@atexit_cal

; 57   :     {
; 58   :         cb = modstate->atexit_callbacks[i];

  0006f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR modstate$[rsp]
  00079	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0007c	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00080	48 89 44 24 50	 mov	 QWORD PTR cb$[rsp], rax

; 59   :         if (cb == NULL)

  00085	48 83 7c 24 50
	00		 cmp	 QWORD PTR cb$[rsp], 0
  0008b	75 02		 jne	 SHORT $LN17@atexit_cal

; 60   :             continue;

  0008d	eb cb		 jmp	 SHORT $LN19@atexit_cal
$LN17@atexit_cal:

; 61   : 
; 62   :         r = PyObject_Call(cb->func, cb->args, cb->kwargs);

  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR cb$[rsp]
  00094	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  00098	48 8b 44 24 50	 mov	 rax, QWORD PTR cb$[rsp]
  0009d	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000a1	48 8b 44 24 50	 mov	 rax, QWORD PTR cb$[rsp]
  000a6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a9	e8 00 00 00 00	 call	 PyObject_Call
  000ae	48 89 44 24 48	 mov	 QWORD PTR r$[rsp], rax
$LN16@atexit_cal:

; 63   :         Py_XDECREF(r);

  000b3	48 83 7c 24 48
	00		 cmp	 QWORD PTR r$[rsp], 0
  000b9	74 0a		 je	 SHORT $LN13@atexit_cal
  000bb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR r$[rsp]
  000c0	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@atexit_cal:
  000c5	33 c0		 xor	 eax, eax
  000c7	85 c0		 test	 eax, eax
  000c9	75 e8		 jne	 SHORT $LN16@atexit_cal

; 64   :         if (r == NULL) {

  000cb	48 83 7c 24 48
	00		 cmp	 QWORD PTR r$[rsp], 0
  000d1	0f 85 9a 00 00
	00		 jne	 $LN12@atexit_cal

; 65   :             /* Maintain the last exception, but don't leak if there are
; 66   :                multiple exceptions. */
; 67   :             if (exc_type) {

  000d7	48 83 7c 24 38
	00		 cmp	 QWORD PTR exc_type$[rsp], 0
  000dd	74 3a		 je	 SHORT $LN11@atexit_cal

; 68   :                 Py_DECREF(exc_type);

  000df	48 8b 4c 24 38	 mov	 rcx, QWORD PTR exc_type$[rsp]
  000e4	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@atexit_cal:

; 69   :                 Py_XDECREF(exc_value);

  000e9	48 83 7c 24 58
	00		 cmp	 QWORD PTR exc_value$[rsp], 0
  000ef	74 0a		 je	 SHORT $LN7@atexit_cal
  000f1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR exc_value$[rsp]
  000f6	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@atexit_cal:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 e8		 jne	 SHORT $LN10@atexit_cal
$LN6@atexit_cal:

; 70   :                 Py_XDECREF(exc_tb);    

  00101	48 83 7c 24 28
	00		 cmp	 QWORD PTR exc_tb$[rsp], 0
  00107	74 0a		 je	 SHORT $LN3@atexit_cal
  00109	48 8b 4c 24 28	 mov	 rcx, QWORD PTR exc_tb$[rsp]
  0010e	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@atexit_cal:
  00113	33 c0		 xor	 eax, eax
  00115	85 c0		 test	 eax, eax
  00117	75 e8		 jne	 SHORT $LN6@atexit_cal
$LN11@atexit_cal:

; 71   :             }
; 72   :             PyErr_Fetch(&exc_type, &exc_value, &exc_tb);

  00119	4c 8d 44 24 28	 lea	 r8, QWORD PTR exc_tb$[rsp]
  0011e	48 8d 54 24 58	 lea	 rdx, QWORD PTR exc_value$[rsp]
  00123	48 8d 4c 24 38	 lea	 rcx, QWORD PTR exc_type$[rsp]
  00128	e8 00 00 00 00	 call	 PyErr_Fetch

; 73   :             if (!PyErr_ExceptionMatches(PyExc_SystemExit)) {

  0012d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemExit
  00134	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00139	85 c0		 test	 eax, eax
  0013b	75 34		 jne	 SHORT $LN2@atexit_cal

; 74   :                 PySys_WriteStderr("Error in atexit._run_exitfuncs:\n");

  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@OCGJGIFK@Error?5in?5atexit?4_run_exitfuncs?3?6@
  00144	e8 00 00 00 00	 call	 PySys_WriteStderr

; 75   :                 PyErr_NormalizeException(&exc_type, &exc_value, &exc_tb);

  00149	4c 8d 44 24 28	 lea	 r8, QWORD PTR exc_tb$[rsp]
  0014e	48 8d 54 24 58	 lea	 rdx, QWORD PTR exc_value$[rsp]
  00153	48 8d 4c 24 38	 lea	 rcx, QWORD PTR exc_type$[rsp]
  00158	e8 00 00 00 00	 call	 PyErr_NormalizeException

; 76   :                 PyErr_Display(exc_type, exc_value, exc_tb);

  0015d	4c 8b 44 24 28	 mov	 r8, QWORD PTR exc_tb$[rsp]
  00162	48 8b 54 24 58	 mov	 rdx, QWORD PTR exc_value$[rsp]
  00167	48 8b 4c 24 38	 mov	 rcx, QWORD PTR exc_type$[rsp]
  0016c	e8 00 00 00 00	 call	 PyErr_Display
$LN2@atexit_cal:
$LN12@atexit_cal:

; 77   :             }
; 78   :         }
; 79   :     }

  00171	e9 e4 fe ff ff	 jmp	 $LN19@atexit_cal
$LN18@atexit_cal:

; 80   : 
; 81   :     atexit_cleanup(module);

  00176	48 8b 4c 24 30	 mov	 rcx, QWORD PTR module$[rsp]
  0017b	e8 00 00 00 00	 call	 atexit_cleanup

; 82   : 
; 83   :     if (exc_type)

  00180	48 83 7c 24 38
	00		 cmp	 QWORD PTR exc_type$[rsp], 0
  00186	74 14		 je	 SHORT $LN1@atexit_cal

; 84   :         PyErr_Restore(exc_type, exc_value, exc_tb);

  00188	4c 8b 44 24 28	 mov	 r8, QWORD PTR exc_tb$[rsp]
  0018d	48 8b 54 24 58	 mov	 rdx, QWORD PTR exc_value$[rsp]
  00192	48 8b 4c 24 38	 mov	 rcx, QWORD PTR exc_type$[rsp]
  00197	e8 00 00 00 00	 call	 PyErr_Restore
$LN1@atexit_cal:
$LN23@atexit_cal:

; 85   : }

  0019c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001a0	c3		 ret	 0
atexit_callfuncs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\modules\atexitmodule.c
pdata	SEGMENT
$pdata$atexit_cleanup DD imagerel atexit_cleanup
	DD	imagerel atexit_cleanup+41
	DD	imagerel $unwind$atexit_cleanup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$atexit_cleanup DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT atexit_cleanup
_TEXT	SEGMENT
r$ = 32
self$ = 64
atexit_cleanup PROC					; COMDAT

; 104  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 105  :     PyObject *r = atexit_clear(self, NULL);

  00009	33 d2		 xor	 edx, edx
  0000b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00010	e8 00 00 00 00	 call	 atexit_clear
  00015	48 89 44 24 20	 mov	 QWORD PTR r$[rsp], rax

; 106  :     Py_DECREF(r);

  0001a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR r$[rsp]
  0001f	e8 00 00 00 00	 call	 _Py_DecRef

; 107  : }

  00024	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00028	c3		 ret	 0
atexit_cleanup ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$atexit_clear DD imagerel atexit_clear
	DD	imagerel atexit_clear+147
	DD	imagerel $unwind$atexit_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$atexit_clear DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT atexit_clear
_TEXT	SEGMENT
i$ = 32
modstate$ = 40
cb$ = 48
self$ = 80
unused$ = 88
atexit_clear PROC					; COMDAT

; 196  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 197  :     atexitmodule_state *modstate;
; 198  :     atexit_callback *cb;
; 199  :     int i;
; 200  : 
; 201  :     modstate = GET_ATEXIT_STATE(self);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 PyModule_GetState
  00018	48 89 44 24 28	 mov	 QWORD PTR modstate$[rsp], rax

; 202  : 
; 203  :     for (i = 0; i < modstate->ncallbacks; i++) {

  0001d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00025	eb 0a		 jmp	 SHORT $LN4@atexit_cle
$LN3@atexit_cle:
  00027	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0002b	ff c0		 inc	 eax
  0002d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@atexit_cle:
  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR modstate$[rsp]
  00036	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00039	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0003d	7d 30		 jge	 SHORT $LN2@atexit_cle

; 204  :         cb = modstate->atexit_callbacks[i];

  0003f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00044	48 8b 4c 24 28	 mov	 rcx, QWORD PTR modstate$[rsp]
  00049	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004c	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00050	48 89 44 24 30	 mov	 QWORD PTR cb$[rsp], rax

; 205  :         if (cb == NULL)

  00055	48 83 7c 24 30
	00		 cmp	 QWORD PTR cb$[rsp], 0
  0005b	75 02		 jne	 SHORT $LN1@atexit_cle

; 206  :             continue;

  0005d	eb c8		 jmp	 SHORT $LN3@atexit_cle
$LN1@atexit_cle:

; 207  : 
; 208  :         atexit_delete_cb(self, i);

  0005f	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00063	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00068	e8 00 00 00 00	 call	 atexit_delete_cb

; 209  :     }

  0006d	eb b8		 jmp	 SHORT $LN3@atexit_cle
$LN2@atexit_cle:

; 210  :     modstate->ncallbacks = 0;

  0006f	48 8b 44 24 28	 mov	 rax, QWORD PTR modstate$[rsp]
  00074	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 211  :     Py_RETURN_NONE;

  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00082	e8 00 00 00 00	 call	 _Py_IncRef
  00087	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 212  : }

  0008e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00092	c3		 ret	 0
atexit_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$atexit_delete_cb DD imagerel atexit_delete_cb
	DD	imagerel atexit_delete_cb+145
	DD	imagerel $unwind$atexit_delete_cb
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$atexit_delete_cb DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT atexit_delete_cb
_TEXT	SEGMENT
modstate$ = 32
cb$ = 40
self$ = 64
i$ = 72
atexit_delete_cb PROC					; COMDAT

; 89   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 90   :     atexitmodule_state *modstate;
; 91   :     atexit_callback *cb;
; 92   : 
; 93   :     modstate = GET_ATEXIT_STATE(self);

  0000d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR self$[rsp]
  00012	e8 00 00 00 00	 call	 PyModule_GetState
  00017	48 89 44 24 20	 mov	 QWORD PTR modstate$[rsp], rax

; 94   :     cb = modstate->atexit_callbacks[i];

  0001c	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  00021	48 8b 4c 24 20	 mov	 rcx, QWORD PTR modstate$[rsp]
  00026	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00029	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0002d	48 89 44 24 28	 mov	 QWORD PTR cb$[rsp], rax

; 95   :     modstate->atexit_callbacks[i] = NULL;

  00032	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR modstate$[rsp]
  0003c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003f	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 96   :     Py_DECREF(cb->func);

  00047	48 8b 44 24 28	 mov	 rax, QWORD PTR cb$[rsp]
  0004c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004f	e8 00 00 00 00	 call	 _Py_DecRef

; 97   :     Py_DECREF(cb->args);

  00054	48 8b 44 24 28	 mov	 rax, QWORD PTR cb$[rsp]
  00059	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0005d	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@atexit_del:

; 98   :     Py_XDECREF(cb->kwargs);

  00062	48 8b 44 24 28	 mov	 rax, QWORD PTR cb$[rsp]
  00067	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0006c	74 0e		 je	 SHORT $LN1@atexit_del
  0006e	48 8b 44 24 28	 mov	 rax, QWORD PTR cb$[rsp]
  00073	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00077	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@atexit_del:
  0007c	33 c0		 xor	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	75 e0		 jne	 SHORT $LN4@atexit_del

; 99   :     PyMem_Free(cb);

  00082	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cb$[rsp]
  00087	e8 00 00 00 00	 call	 PyMem_Free

; 100  : }

  0008c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00090	c3		 ret	 0
atexit_delete_cb ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$atexit_free DD imagerel atexit_free
	DD	imagerel atexit_free+42
	DD	imagerel $unwind$atexit_free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$atexit_free DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT atexit_free
_TEXT	SEGMENT
modstate$ = 32
m$ = 64
atexit_free PROC					; COMDAT

; 216  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 217  :     atexitmodule_state *modstate;
; 218  :     modstate = GET_ATEXIT_STATE(m);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR m$[rsp]
  0000e	e8 00 00 00 00	 call	 PyModule_GetState
  00013	48 89 44 24 20	 mov	 QWORD PTR modstate$[rsp], rax

; 219  :     PyMem_Free(modstate->atexit_callbacks);

  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  0001d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00020	e8 00 00 00 00	 call	 PyMem_Free

; 220  : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
atexit_free ENDP
_TEXT	ENDS
EXTRN	PyObject_RichCompareBool:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$atexit_unregister DD imagerel atexit_unregister
	DD	imagerel atexit_unregister+181
	DD	imagerel $unwind$atexit_unregister
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$atexit_unregister DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT atexit_unregister
_TEXT	SEGMENT
i$ = 32
eq$ = 36
modstate$ = 40
cb$ = 48
self$ = 80
func$ = 88
atexit_unregister PROC					; COMDAT

; 232  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 233  :     atexitmodule_state *modstate;
; 234  :     atexit_callback *cb;
; 235  :     int i, eq;
; 236  : 
; 237  :     modstate = GET_ATEXIT_STATE(self);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00013	e8 00 00 00 00	 call	 PyModule_GetState
  00018	48 89 44 24 28	 mov	 QWORD PTR modstate$[rsp], rax

; 238  : 
; 239  :     for (i = 0; i < modstate->ncallbacks; i++)

  0001d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00025	eb 0a		 jmp	 SHORT $LN6@atexit_unr
$LN5@atexit_unr:
  00027	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0002b	ff c0		 inc	 eax
  0002d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN6@atexit_unr:
  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR modstate$[rsp]
  00036	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00039	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0003d	7d 5e		 jge	 SHORT $LN4@atexit_unr

; 240  :     {
; 241  :         cb = modstate->atexit_callbacks[i];

  0003f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00044	48 8b 4c 24 28	 mov	 rcx, QWORD PTR modstate$[rsp]
  00049	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0004c	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00050	48 89 44 24 30	 mov	 QWORD PTR cb$[rsp], rax

; 242  :         if (cb == NULL)

  00055	48 83 7c 24 30
	00		 cmp	 QWORD PTR cb$[rsp], 0
  0005b	75 02		 jne	 SHORT $LN3@atexit_unr

; 243  :             continue;

  0005d	eb c8		 jmp	 SHORT $LN5@atexit_unr
$LN3@atexit_unr:

; 244  : 
; 245  :         eq = PyObject_RichCompareBool(cb->func, func, Py_EQ);

  0005f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00065	48 8b 54 24 58	 mov	 rdx, QWORD PTR func$[rsp]
  0006a	48 8b 44 24 30	 mov	 rax, QWORD PTR cb$[rsp]
  0006f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00072	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00077	89 44 24 24	 mov	 DWORD PTR eq$[rsp], eax

; 246  :         if (eq < 0)

  0007b	83 7c 24 24 00	 cmp	 DWORD PTR eq$[rsp], 0
  00080	7d 04		 jge	 SHORT $LN2@atexit_unr

; 247  :             return NULL;

  00082	33 c0		 xor	 eax, eax
  00084	eb 2a		 jmp	 SHORT $LN7@atexit_unr
$LN2@atexit_unr:

; 248  :         if (eq)

  00086	83 7c 24 24 00	 cmp	 DWORD PTR eq$[rsp], 0
  0008b	74 0e		 je	 SHORT $LN1@atexit_unr

; 249  :             atexit_delete_cb(self, i);

  0008d	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00091	48 8b 4c 24 50	 mov	 rcx, QWORD PTR self$[rsp]
  00096	e8 00 00 00 00	 call	 atexit_delete_cb
$LN1@atexit_unr:

; 250  :     }

  0009b	eb 8a		 jmp	 SHORT $LN5@atexit_unr
$LN4@atexit_unr:

; 251  :     Py_RETURN_NONE;

  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000a4	e8 00 00 00 00	 call	 _Py_IncRef
  000a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN7@atexit_unr:

; 252  : }

  000b0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b4	c3		 ret	 0
atexit_unregister ENDP
_TEXT	ENDS
PUBLIC	PyInit_atexit
EXTRN	_Py_PyAtExit:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_atexit DD imagerel $LN7
	DD	imagerel $LN7+191
	DD	imagerel $unwind$PyInit_atexit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_atexit DD 010401H
	DD	08204H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyInit_atexit
_TEXT	SEGMENT
modstate$ = 32
m$ = 40
tv80 = 48
PyInit_atexit PROC					; COMDAT

; 291  : {

$LN7:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 292  :     PyObject *m;
; 293  :     atexitmodule_state *modstate;
; 294  : 
; 295  :     m = PyModule_Create(&atexitmodule);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:atexitmodule
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00015	48 89 44 24 28	 mov	 QWORD PTR m$[rsp], rax

; 296  :     if (m == NULL)

  0001a	48 83 7c 24 28
	00		 cmp	 QWORD PTR m$[rsp], 0
  00020	75 07		 jne	 SHORT $LN2@PyInit_ate

; 297  :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 91 00 00 00	 jmp	 $LN3@PyInit_ate
$LN2@PyInit_ate:

; 298  : 
; 299  :     modstate = GET_ATEXIT_STATE(m);

  00029	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  0002e	e8 00 00 00 00	 call	 PyModule_GetState
  00033	48 89 44 24 20	 mov	 QWORD PTR modstate$[rsp], rax

; 300  :     modstate->callback_len = 32;

  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  0003d	c7 40 0c 20 00
	00 00		 mov	 DWORD PTR [rax+12], 32	; 00000020H

; 301  :     modstate->ncallbacks = 0;

  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  00049	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 302  :     modstate->atexit_callbacks = PyMem_New(atexit_callback*, 
; 303  :                                            modstate->callback_len);

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  00055	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00059	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  00063	48 3b c1	 cmp	 rax, rcx
  00066	76 0b		 jbe	 SHORT $LN5@PyInit_ate
  00068	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv80[rsp], 0
  00071	eb 1a		 jmp	 SHORT $LN6@PyInit_ate
$LN5@PyInit_ate:
  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  00078	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  0007c	48 c1 e0 03	 shl	 rax, 3
  00080	48 8b c8	 mov	 rcx, rax
  00083	e8 00 00 00 00	 call	 PyMem_Malloc
  00088	48 89 44 24 30	 mov	 QWORD PTR tv80[rsp], rax
$LN6@PyInit_ate:
  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv80[rsp]
  00097	48 89 08	 mov	 QWORD PTR [rax], rcx

; 304  :     if (modstate->atexit_callbacks == NULL)

  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR modstate$[rsp]
  0009f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000a3	75 04		 jne	 SHORT $LN1@PyInit_ate

; 305  :         return NULL;

  000a5	33 c0		 xor	 eax, eax
  000a7	eb 11		 jmp	 SHORT $LN3@PyInit_ate
$LN1@PyInit_ate:

; 306  : 
; 307  :     _Py_PyAtExit(atexit_callfuncs);

  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:atexit_callfuncs
  000b0	e8 00 00 00 00	 call	 _Py_PyAtExit

; 308  :     return m;

  000b5	48 8b 44 24 28	 mov	 rax, QWORD PTR m$[rsp]
$LN3@PyInit_ate:

; 309  : }

  000ba	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000be	c3		 ret	 0
PyInit_atexit ENDP
_TEXT	ENDS
END
