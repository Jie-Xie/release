; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	PyParser_New
EXTRN	PyGrammar_FindDFA:PROC
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	PyNode_New:PROC
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_Py_PXCTX:PROC
EXTRN	PyGrammar_AddAccelerators:PROC
;	COMDAT pdata
; File c:\src\pyparallel\parser\parser.c
pdata	SEGMENT
$pdata$PyParser_New DD imagerel $LN10
	DD	imagerel $LN10+278
	DD	imagerel $unwind$PyParser_New
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_New DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyParser_New
_TEXT	SEGMENT
ps$ = 32
tv73 = 40
tv86 = 48
g$ = 80
start$ = 88
PyParser_New PROC					; COMDAT

; 73   : {

$LN10:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 74   :     parser_state *ps;
; 75   : 
; 76   :     if (!g->g_accel)

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00012	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00016	75 0a		 jne	 SHORT $LN3@PyParser_N

; 77   :         PyGrammar_AddAccelerators(g);

  00018	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0001d	e8 00 00 00 00	 call	 PyGrammar_AddAccelerators
$LN3@PyParser_N:

; 78   :     ps = (parser_state *)PyMem_MALLOC(sizeof(parser_state));

  00022	e8 00 00 00 00	 call	 _Py_PXCTX
  00027	85 c0		 test	 eax, eax
  00029	74 11		 je	 SHORT $LN6@PyParser_N
  0002b	b9 c0 8c 00 00	 mov	 ecx, 36032		; 00008cc0H
  00030	e8 00 00 00 00	 call	 _PxMem_Malloc
  00035	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
  0003a	eb 0f		 jmp	 SHORT $LN7@PyParser_N
$LN6@PyParser_N:
  0003c	b9 c0 8c 00 00	 mov	 ecx, 36032		; 00008cc0H
  00041	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00046	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
$LN7@PyParser_N:
  0004b	48 8b 44 24 28	 mov	 rax, QWORD PTR tv73[rsp]
  00050	48 89 44 24 20	 mov	 QWORD PTR ps$[rsp], rax

; 79   :     if (ps == NULL)

  00055	48 83 7c 24 20
	00		 cmp	 QWORD PTR ps$[rsp], 0
  0005b	75 07		 jne	 SHORT $LN2@PyParser_N

; 80   :         return NULL;

  0005d	33 c0		 xor	 eax, eax
  0005f	e9 ad 00 00 00	 jmp	 $LN4@PyParser_N
$LN2@PyParser_N:

; 81   :     ps->p_grammar = g;

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR ps$[rsp]
  00069	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0006e	48 89 88 a8 8c
	00 00		 mov	 QWORD PTR [rax+36008], rcx

; 82   : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 83   :     ps->p_flags = 0;

  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR ps$[rsp]
  0007a	c7 80 b8 8c 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+36024], 0

; 84   : #endif
; 85   :     ps->p_tree = PyNode_New(start);

  00084	8b 4c 24 58	 mov	 ecx, DWORD PTR start$[rsp]
  00088	e8 00 00 00 00	 call	 PyNode_New
  0008d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ps$[rsp]
  00092	48 89 81 b0 8c
	00 00		 mov	 QWORD PTR [rcx+36016], rax

; 86   :     if (ps->p_tree == NULL) {

  00099	48 8b 44 24 20	 mov	 rax, QWORD PTR ps$[rsp]
  0009e	48 83 b8 b0 8c
	00 00 00	 cmp	 QWORD PTR [rax+36016], 0
  000a6	75 33		 jne	 SHORT $LN1@PyParser_N

; 87   :         PyMem_FREE(ps);

  000a8	e8 00 00 00 00	 call	 _Py_PXCTX
  000ad	85 c0		 test	 eax, eax
  000af	74 14		 je	 SHORT $LN8@PyParser_N
  000b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ps$[rsp]
  000b6	e8 00 00 00 00	 call	 _PxMem_Free
  000bb	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
  000c3	eb 12		 jmp	 SHORT $LN9@PyParser_N
$LN8@PyParser_N:
  000c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ps$[rsp]
  000ca	e8 00 00 00 00	 call	 _PyMem_DebugFree
  000cf	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN9@PyParser_N:

; 88   :         return NULL;

  000d7	33 c0		 xor	 eax, eax
  000d9	eb 36		 jmp	 SHORT $LN4@PyParser_N
$LN1@PyParser_N:

; 89   :     }
; 90   :     s_reset(&ps->p_stack);

  000db	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ps$[rsp]
  000e0	e8 00 00 00 00	 call	 s_reset

; 91   :     (void) s_push(&ps->p_stack, PyGrammar_FindDFA(g, start), ps->p_tree);

  000e5	8b 54 24 58	 mov	 edx, DWORD PTR start$[rsp]
  000e9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  000ee	e8 00 00 00 00	 call	 PyGrammar_FindDFA
  000f3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ps$[rsp]
  000f8	4c 8b 81 b0 8c
	00 00		 mov	 r8, QWORD PTR [rcx+36016]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ps$[rsp]
  00107	e8 00 00 00 00	 call	 s_push

; 92   :     return ps;

  0010c	48 8b 44 24 20	 mov	 rax, QWORD PTR ps$[rsp]
$LN4@PyParser_N:

; 93   : }

  00111	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00115	c3		 ret	 0
PyParser_New ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT s_reset
_TEXT	SEGMENT
s$ = 8
s_reset	PROC						; COMDAT

; 31   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 32   :     s->s_top = &s->s_base[MAXSTACK];

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  0000a	48 05 a8 8c 00
	00		 add	 rax, 36008		; 00008ca8H
  00010	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s$[rsp]
  00015	48 89 01	 mov	 QWORD PTR [rcx], rax

; 33   : }

  00018	c3		 ret	 0
s_reset	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@OFBDNFIB@s_push?3?5parser?5stack?5overflow?6?$AA@ ; `string'
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_push DD imagerel s_push
	DD	imagerel s_push+150
	DD	imagerel $unwind$s_push
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_push DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BP@OFBDNFIB@s_push?3?5parser?5stack?5overflow?6?$AA@
CONST	SEGMENT
??_C@_0BP@OFBDNFIB@s_push?3?5parser?5stack?5overflow?6?$AA@ DB 's_push: p'
	DB	'arser stack overflow', 0aH, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT s_push
_TEXT	SEGMENT
top$ = 32
s$ = 64
d$ = 72
parent$ = 80
s_push	PROC						; COMDAT

; 39   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 40   :     register stackentry *top;
; 41   :     if (s->s_top == s->s_base) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00018	48 83 c0 08	 add	 rax, 8
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00021	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00024	75 21		 jne	 SHORT $LN1@s_push

; 42   :         fprintf(stderr, "s_push: parser stack overflow\n");

  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0002c	48 83 c0 60	 add	 rax, 96			; 00000060H
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@OFBDNFIB@s_push?3?5parser?5stack?5overflow?6?$AA@
  00037	48 8b c8	 mov	 rcx, rax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 43   :         return E_NOMEM;

  00040	b8 0f 00 00 00	 mov	 eax, 15
  00045	eb 4a		 jmp	 SHORT $LN2@s_push
$LN1@s_push:

; 44   :     }
; 45   :     top = --s->s_top;

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0004c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004f	48 83 e8 18	 sub	 rax, 24
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00058	48 89 01	 mov	 QWORD PTR [rcx], rax
  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00060	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00063	48 89 44 24 20	 mov	 QWORD PTR top$[rsp], rax

; 46   :     top->s_dfa = d;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR top$[rsp]
  0006d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR d$[rsp]
  00072	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 47   :     top->s_parent = parent;

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR top$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR parent$[rsp]
  00080	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 48   :     top->s_state = 0;

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR top$[rsp]
  00089	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 49   :     return 0;

  0008f	33 c0		 xor	 eax, eax
$LN2@s_push:

; 50   : }

  00091	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00095	c3		 ret	 0
s_push	ENDP
_TEXT	ENDS
PUBLIC	PyParser_Delete
EXTRN	PyNode_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_Delete DD imagerel $LN5
	DD	imagerel $LN5+78
	DD	imagerel $unwind$PyParser_Delete
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_Delete DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyParser_Delete
_TEXT	SEGMENT
tv70 = 32
ps$ = 64
PyParser_Delete PROC					; COMDAT

; 97   : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 98   :     /* NB If you want to save the parse tree,
; 99   :        you must set p_tree to NULL before calling delparser! */
; 100  :     PyNode_Free(ps->p_tree);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ps$[rsp]
  0000e	48 8b 88 b0 8c
	00 00		 mov	 rcx, QWORD PTR [rax+36016]
  00015	e8 00 00 00 00	 call	 PyNode_Free

; 101  :     PyMem_FREE(ps);

  0001a	e8 00 00 00 00	 call	 _Py_PXCTX
  0001f	85 c0		 test	 eax, eax
  00021	74 14		 je	 SHORT $LN3@PyParser_D
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ps$[rsp]
  00028	e8 00 00 00 00	 call	 _PxMem_Free
  0002d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00035	eb 12		 jmp	 SHORT $LN4@PyParser_D
$LN3@PyParser_D:
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ps$[rsp]
  0003c	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00041	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN4@PyParser_D:

; 102  : }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
PyParser_Delete ENDP
_TEXT	ENDS
PUBLIC	??_C@_08NFAPMDFI@?5Error?4?6?$AA@		; `string'
PUBLIC	??_C@_0BK@LDPALBAH@?5Error?3?5bottom?5of?5stack?4?6?$AA@ ; `string'
PUBLIC	??_C@_09DFFFHICN@?5Pop?5?4?4?4?6?$AA@		; `string'
PUBLIC	??_C@_0L@KNHEDADL@?5?5ACCEPT?4?6?$AA@		; `string'
PUBLIC	??_C@_0CD@FHGIOBHI@?5?5DFA?5?8?$CFs?8?0?5state?5?$CFd?3?5Direct?5pop@ ; `string'
PUBLIC	??_C@_08ONBPPHIB@?5Shift?4?6?$AA@		; `string'
PUBLIC	??_C@_0BD@FLAGIELO@?5MemError?3?5shift?4?6?$AA@	; `string'
PUBLIC	??_C@_0L@HKMOJKNJ@?5Push?5?4?4?4?6?$AA@		; `string'
PUBLIC	??_C@_0BB@GBDMIHHJ@?5MemError?3?5push?6?$AA@	; `string'
PUBLIC	??_C@_0BF@LLJKCNBI@?5DFA?5?8?$CFs?8?0?5state?5?$CFd?3?$AA@ ; `string'
PUBLIC	??_C@_0BD@FPBLCLGC@Token?5?$CFs?1?8?$CFs?8?5?4?4?4?5?$AA@ ; `string'
PUBLIC	PyParser_AddToken
EXTRN	__imp_printf:PROC
EXTRN	_PyParser_TokenNames:BYTE
EXTRN	Py_DebugFlag:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_AddToken DD imagerel $LN44
	DD	imagerel $LN44+1106
	DD	imagerel $unwind$PyParser_AddToken
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_AddToken DD 011701H
	DD	0e217H
xdata	ENDS
;	COMDAT ??_C@_08NFAPMDFI@?5Error?4?6?$AA@
CONST	SEGMENT
??_C@_08NFAPMDFI@?5Error?4?6?$AA@ DB ' Error.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@LDPALBAH@?5Error?3?5bottom?5of?5stack?4?6?$AA@
CONST	SEGMENT
??_C@_0BK@LDPALBAH@?5Error?3?5bottom?5of?5stack?4?6?$AA@ DB ' Error: bott'
	DB	'om of stack.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09DFFFHICN@?5Pop?5?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_09DFFFHICN@?5Pop?5?4?4?4?6?$AA@ DB ' Pop ...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KNHEDADL@?5?5ACCEPT?4?6?$AA@
CONST	SEGMENT
??_C@_0L@KNHEDADL@?5?5ACCEPT?4?6?$AA@ DB '  ACCEPT.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FHGIOBHI@?5?5DFA?5?8?$CFs?8?0?5state?5?$CFd?3?5Direct?5pop@
CONST	SEGMENT
??_C@_0CD@FHGIOBHI@?5?5DFA?5?8?$CFs?8?0?5state?5?$CFd?3?5Direct?5pop@ DB ' '
	DB	' DFA ''%s'', state %d: Direct pop.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08ONBPPHIB@?5Shift?4?6?$AA@
CONST	SEGMENT
??_C@_08ONBPPHIB@?5Shift?4?6?$AA@ DB ' Shift.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FLAGIELO@?5MemError?3?5shift?4?6?$AA@
CONST	SEGMENT
??_C@_0BD@FLAGIELO@?5MemError?3?5shift?4?6?$AA@ DB ' MemError: shift.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HKMOJKNJ@?5Push?5?4?4?4?6?$AA@
CONST	SEGMENT
??_C@_0L@HKMOJKNJ@?5Push?5?4?4?4?6?$AA@ DB ' Push ...', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GBDMIHHJ@?5MemError?3?5push?6?$AA@
CONST	SEGMENT
??_C@_0BB@GBDMIHHJ@?5MemError?3?5push?6?$AA@ DB ' MemError: push', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LLJKCNBI@?5DFA?5?8?$CFs?8?0?5state?5?$CFd?3?$AA@
CONST	SEGMENT
??_C@_0BF@LLJKCNBI@?5DFA?5?8?$CFs?8?0?5state?5?$CFd?3?$AA@ DB ' DFA ''%s'''
	DB	', state %d:', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FPBLCLGC@Token?5?$CFs?1?8?$CFs?8?5?4?4?4?5?$AA@
CONST	SEGMENT
??_C@_0BD@FPBLCLGC@Token?5?$CFs?1?8?$CFs?8?5?4?4?4?5?$AA@ DB 'Token %s/'''
	DB	'%s'' ... ', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyParser_AddToken
_TEXT	SEGMENT
ilabel$ = 48
err$ = 52
s$20767 = 56
d$20766 = 64
x$20772 = 72
nt$20775 = 76
arrow$20776 = 80
d1$20777 = 88
tv172 = 96
ps$ = 128
type$ = 136
str$ = 144
lineno$ = 152
col_offset$ = 160
expected_ret$ = 168
PyParser_AddToken PROC					; COMDAT

; 230  : {

$LN44:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 231  :     register int ilabel;
; 232  :     int err;
; 233  : 
; 234  :     D(printf("Token %s/'%s' ... ", _PyParser_TokenNames[type], str));

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  0001e	75 02		 jne	 SHORT $LN38@PyParser_A
  00020	eb 28		 jmp	 SHORT $LN37@PyParser_A
$LN38@PyParser_A:
  00022	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR type$[rsp]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyParser_TokenNames
  00031	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR str$[rsp]
  00039	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@FPBLCLGC@Token?5?$CFs?1?8?$CFs?8?5?4?4?4?5?$AA@
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN37@PyParser_A:

; 235  : 
; 236  :     /* Find out which label this token is */
; 237  :     ilabel = classify(ps, type, str);

  0004a	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR str$[rsp]
  00052	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR type$[rsp]
  00059	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ps$[rsp]
  00061	e8 00 00 00 00	 call	 classify
  00066	89 44 24 30	 mov	 DWORD PTR ilabel$[rsp], eax

; 238  :     if (ilabel < 0)

  0006a	83 7c 24 30 00	 cmp	 DWORD PTR ilabel$[rsp], 0
  0006f	7d 0a		 jge	 SHORT $LN36@PyParser_A

; 239  :         return E_SYNTAX;

  00071	b8 0e 00 00 00	 mov	 eax, 14
  00076	e9 d2 03 00 00	 jmp	 $LN39@PyParser_A
$LN36@PyParser_A:
$LN43@PyParser_A:
$LN35@PyParser_A:

; 240  : 
; 241  :     /* Loop until the token is shifted or an error occurred */
; 242  :     for (;;) {
; 243  :         /* Fetch the current dfa and state */
; 244  :         register dfa *d = ps->p_stack.s_top->s_dfa;

  0007b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008a	48 89 44 24 40	 mov	 QWORD PTR d$20766[rsp], rax

; 245  :         register state *s = &d->d_state[ps->p_stack.s_top->s_state];

  0008f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps$[rsp]
  00097	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009a	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0009d	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$20766[rsp]
  000a6	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  000aa	48 89 44 24 38	 mov	 QWORD PTR s$20767[rsp], rax

; 246  : 
; 247  :         D(printf(" DFA '%s', state %d:",
; 248  :             d->d_name, ps->p_stack.s_top->s_state));

  000af	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  000b6	75 02		 jne	 SHORT $LN33@PyParser_A
  000b8	eb 24		 jmp	 SHORT $LN32@PyParser_A
$LN33@PyParser_A:
  000ba	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps$[rsp]
  000c2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c5	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR d$20766[rsp]
  000cd	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@LLJKCNBI@?5DFA?5?8?$CFs?8?0?5state?5?$CFd?3?$AA@
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN32@PyParser_A:

; 249  : 
; 250  :         /* Check accelerator */
; 251  :         if (s->s_lower <= ilabel && ilabel < s->s_upper) {

  000de	48 8b 44 24 38	 mov	 rax, QWORD PTR s$20767[rsp]
  000e3	8b 4c 24 30	 mov	 ecx, DWORD PTR ilabel$[rsp]
  000e7	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  000ea	0f 8f 6b 02 00
	00		 jg	 $LN31@PyParser_A
  000f0	48 8b 44 24 38	 mov	 rax, QWORD PTR s$20767[rsp]
  000f5	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000f8	39 44 24 30	 cmp	 DWORD PTR ilabel$[rsp], eax
  000fc	0f 8d 59 02 00
	00		 jge	 $LN31@PyParser_A

; 252  :             register int x = s->s_accel[ilabel - s->s_lower];

  00102	48 8b 44 24 38	 mov	 rax, QWORD PTR s$20767[rsp]
  00107	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0010a	8b 4c 24 30	 mov	 ecx, DWORD PTR ilabel$[rsp]
  0010e	2b c8		 sub	 ecx, eax
  00110	8b c1		 mov	 eax, ecx
  00112	48 98		 cdqe
  00114	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$20767[rsp]
  00119	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0011d	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00120	89 44 24 48	 mov	 DWORD PTR x$20772[rsp], eax

; 253  :             if (x != -1) {

  00124	83 7c 24 48 ff	 cmp	 DWORD PTR x$20772[rsp], -1
  00129	0f 84 2c 02 00
	00		 je	 $LN30@PyParser_A

; 254  :                 if (x & (1<<7)) {

  0012f	8b 44 24 48	 mov	 eax, DWORD PTR x$20772[rsp]
  00133	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00138	85 c0		 test	 eax, eax
  0013a	0f 84 b2 00 00
	00		 je	 $LN29@PyParser_A

; 255  :                     /* Push non-terminal */
; 256  :                     int nt = (x >> 8) + NT_OFFSET;

  00140	8b 44 24 48	 mov	 eax, DWORD PTR x$20772[rsp]
  00144	c1 f8 08	 sar	 eax, 8
  00147	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0014c	89 44 24 4c	 mov	 DWORD PTR nt$20775[rsp], eax

; 257  :                     int arrow = x & ((1<<7)-1);

  00150	8b 44 24 48	 mov	 eax, DWORD PTR x$20772[rsp]
  00154	83 e0 7f	 and	 eax, 127		; 0000007fH
  00157	89 44 24 50	 mov	 DWORD PTR arrow$20776[rsp], eax

; 258  :                     dfa *d1 = PyGrammar_FindDFA(
; 259  :                         ps->p_grammar, nt);

  0015b	8b 54 24 4c	 mov	 edx, DWORD PTR nt$20775[rsp]
  0015f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps$[rsp]
  00167	48 8b 88 a8 8c
	00 00		 mov	 rcx, QWORD PTR [rax+36008]
  0016e	e8 00 00 00 00	 call	 PyGrammar_FindDFA
  00173	48 89 44 24 58	 mov	 QWORD PTR d1$20777[rsp], rax

; 260  :                     if ((err = push(&ps->p_stack, nt, d1,
; 261  :                         arrow, lineno, col_offset)) > 0) {

  00178	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR col_offset$[rsp]
  0017f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00183	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR lineno$[rsp]
  0018a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0018e	44 8b 4c 24 50	 mov	 r9d, DWORD PTR arrow$20776[rsp]
  00193	4c 8b 44 24 58	 mov	 r8, QWORD PTR d1$20777[rsp]
  00198	8b 54 24 4c	 mov	 edx, DWORD PTR nt$20775[rsp]
  0019c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ps$[rsp]
  001a4	e8 00 00 00 00	 call	 push
  001a9	89 44 24 34	 mov	 DWORD PTR err$[rsp], eax
  001ad	83 7c 24 34 00	 cmp	 DWORD PTR err$[rsp], 0
  001b2	7e 21		 jle	 SHORT $LN28@PyParser_A

; 262  :                         D(printf(" MemError: push\n"));

  001b4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  001bb	75 02		 jne	 SHORT $LN27@PyParser_A
  001bd	eb 0d		 jmp	 SHORT $LN26@PyParser_A
$LN27@PyParser_A:
  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GBDMIHHJ@?5MemError?3?5push?6?$AA@
  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN26@PyParser_A:

; 263  :                         return err;

  001cc	8b 44 24 34	 mov	 eax, DWORD PTR err$[rsp]
  001d0	e9 78 02 00 00	 jmp	 $LN39@PyParser_A
$LN28@PyParser_A:

; 264  :                     }
; 265  :                     D(printf(" Push ...\n"));

  001d5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  001dc	75 02		 jne	 SHORT $LN25@PyParser_A
  001de	eb 0d		 jmp	 SHORT $LN24@PyParser_A
$LN25@PyParser_A:
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@HKMOJKNJ@?5Push?5?4?4?4?6?$AA@
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN24@PyParser_A:

; 266  :                     continue;

  001ed	e9 89 fe ff ff	 jmp	 $LN35@PyParser_A
$LN29@PyParser_A:

; 267  :                 }
; 268  : 
; 269  :                 /* Shift the token */
; 270  :                 if ((err = shift(&ps->p_stack, type, str,
; 271  :                                 x, lineno, col_offset)) > 0) {

  001f2	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR col_offset$[rsp]
  001f9	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001fd	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR lineno$[rsp]
  00204	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00208	44 8b 4c 24 48	 mov	 r9d, DWORD PTR x$20772[rsp]
  0020d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR str$[rsp]
  00215	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR type$[rsp]
  0021c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ps$[rsp]
  00224	e8 00 00 00 00	 call	 shift
  00229	89 44 24 34	 mov	 DWORD PTR err$[rsp], eax
  0022d	83 7c 24 34 00	 cmp	 DWORD PTR err$[rsp], 0
  00232	7e 21		 jle	 SHORT $LN23@PyParser_A

; 272  :                     D(printf(" MemError: shift.\n"));

  00234	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  0023b	75 02		 jne	 SHORT $LN22@PyParser_A
  0023d	eb 0d		 jmp	 SHORT $LN21@PyParser_A
$LN22@PyParser_A:
  0023f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@FLAGIELO@?5MemError?3?5shift?4?6?$AA@
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN21@PyParser_A:

; 273  :                     return err;

  0024c	8b 44 24 34	 mov	 eax, DWORD PTR err$[rsp]
  00250	e9 f8 01 00 00	 jmp	 $LN39@PyParser_A
$LN23@PyParser_A:

; 274  :                 }
; 275  :                 D(printf(" Shift.\n"));

  00255	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  0025c	75 02		 jne	 SHORT $LN20@PyParser_A
  0025e	eb 0d		 jmp	 SHORT $LN19@PyParser_A
$LN20@PyParser_A:
  00260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08ONBPPHIB@?5Shift?4?6?$AA@
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN19@PyParser_A:
$LN18@PyParser_A:

; 276  :                 /* Pop while we are in an accept-only state */
; 277  :                 while (s = &d->d_state
; 278  :                                 [ps->p_stack.s_top->s_state],
; 279  :                     s->s_accept && s->s_narcs == 1) {

  0026d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps$[rsp]
  00275	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00278	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0027b	48 6b c0 28	 imul	 rax, 40			; 00000028H
  0027f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$20766[rsp]
  00284	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00288	48 89 44 24 38	 mov	 QWORD PTR s$20767[rsp], rax
  0028d	48 8b 44 24 38	 mov	 rax, QWORD PTR s$20767[rsp]
  00292	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00296	74 14		 je	 SHORT $LN41@PyParser_A
  00298	48 8b 44 24 38	 mov	 rax, QWORD PTR s$20767[rsp]
  0029d	83 38 01	 cmp	 DWORD PTR [rax], 1
  002a0	75 0a		 jne	 SHORT $LN41@PyParser_A
  002a2	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  002aa	eb 08		 jmp	 SHORT $LN42@PyParser_A
$LN41@PyParser_A:
  002ac	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN42@PyParser_A:
  002b4	83 7c 24 60 00	 cmp	 DWORD PTR tv172[rsp], 0
  002b9	0f 84 92 00 00
	00		 je	 $LN17@PyParser_A

; 280  :                     D(printf("  DFA '%s', state %d: "
; 281  :                              "Direct pop.\n",
; 282  :                              d->d_name,
; 283  :                              ps->p_stack.s_top->s_state));

  002bf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  002c6	75 02		 jne	 SHORT $LN16@PyParser_A
  002c8	eb 24		 jmp	 SHORT $LN15@PyParser_A
$LN16@PyParser_A:
  002ca	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps$[rsp]
  002d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d5	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  002d8	48 8b 44 24 40	 mov	 rax, QWORD PTR d$20766[rsp]
  002dd	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  002e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@FHGIOBHI@?5?5DFA?5?8?$CFs?8?0?5state?5?$CFd?3?5Direct?5pop@
  002e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN15@PyParser_A:

; 284  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 285  : #if 0
; 286  :                     if (d->d_name[0] == 'i' &&
; 287  :                         strcmp(d->d_name,
; 288  :                            "import_stmt") == 0)
; 289  :                         future_hack(ps);
; 290  : #endif
; 291  : #endif
; 292  :                     s_pop(&ps->p_stack);

  002ee	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ps$[rsp]
  002f6	e8 00 00 00 00	 call	 s_pop

; 293  :                     if (s_empty(&ps->p_stack)) {

  002fb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps$[rsp]
  00303	48 05 a8 8c 00
	00		 add	 rax, 36008		; 00008ca8H
  00309	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ps$[rsp]
  00311	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00314	75 22		 jne	 SHORT $LN14@PyParser_A

; 294  :                         D(printf("  ACCEPT.\n"));

  00316	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  0031d	75 02		 jne	 SHORT $LN13@PyParser_A
  0031f	eb 0d		 jmp	 SHORT $LN12@PyParser_A
$LN13@PyParser_A:
  00321	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@KNHEDADL@?5?5ACCEPT?4?6?$AA@
  00328	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN12@PyParser_A:

; 295  :                         return E_DONE;

  0032e	b8 10 00 00 00	 mov	 eax, 16
  00333	e9 15 01 00 00	 jmp	 $LN39@PyParser_A
$LN14@PyParser_A:

; 296  :                     }
; 297  :                     d = ps->p_stack.s_top->s_dfa;

  00338	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps$[rsp]
  00340	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00343	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00347	48 89 44 24 40	 mov	 QWORD PTR d$20766[rsp], rax

; 298  :                 }

  0034c	e9 1c ff ff ff	 jmp	 $LN18@PyParser_A
$LN17@PyParser_A:

; 299  :                 return E_OK;

  00351	b8 0a 00 00 00	 mov	 eax, 10
  00356	e9 f2 00 00 00	 jmp	 $LN39@PyParser_A
$LN30@PyParser_A:
$LN31@PyParser_A:

; 300  :             }
; 301  :         }
; 302  : 
; 303  :         if (s->s_accept) {

  0035b	48 8b 44 24 38	 mov	 rax, QWORD PTR s$20767[rsp]
  00360	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00364	74 67		 je	 SHORT $LN11@PyParser_A

; 304  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 305  : #if 0
; 306  :             if (d->d_name[0] == 'i' &&
; 307  :                 strcmp(d->d_name, "import_stmt") == 0)
; 308  :                 future_hack(ps);
; 309  : #endif
; 310  : #endif
; 311  :             /* Pop this dfa and try again */
; 312  :             s_pop(&ps->p_stack);

  00366	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ps$[rsp]
  0036e	e8 00 00 00 00	 call	 s_pop

; 313  :             D(printf(" Pop ...\n"));

  00373	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  0037a	75 02		 jne	 SHORT $LN10@PyParser_A
  0037c	eb 0d		 jmp	 SHORT $LN9@PyParser_A
$LN10@PyParser_A:
  0037e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09DFFFHICN@?5Pop?5?4?4?4?6?$AA@
  00385	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN9@PyParser_A:

; 314  :             if (s_empty(&ps->p_stack)) {

  0038b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps$[rsp]
  00393	48 05 a8 8c 00
	00		 add	 rax, 36008		; 00008ca8H
  00399	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ps$[rsp]
  003a1	48 39 01	 cmp	 QWORD PTR [rcx], rax
  003a4	75 22		 jne	 SHORT $LN8@PyParser_A

; 315  :                 D(printf(" Error: bottom of stack.\n"));

  003a6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  003ad	75 02		 jne	 SHORT $LN7@PyParser_A
  003af	eb 0d		 jmp	 SHORT $LN6@PyParser_A
$LN7@PyParser_A:
  003b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@LDPALBAH@?5Error?3?5bottom?5of?5stack?4?6?$AA@
  003b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN6@PyParser_A:

; 316  :                 return E_SYNTAX;

  003be	b8 0e 00 00 00	 mov	 eax, 14
  003c3	e9 85 00 00 00	 jmp	 $LN39@PyParser_A
$LN8@PyParser_A:

; 317  :             }
; 318  :             continue;

  003c8	e9 ae fc ff ff	 jmp	 $LN43@PyParser_A
$LN11@PyParser_A:

; 319  :         }
; 320  : 
; 321  :         /* Stuck, report syntax error */
; 322  :         D(printf(" Error.\n"));

  003cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  003d4	75 02		 jne	 SHORT $LN5@PyParser_A
  003d6	eb 0d		 jmp	 SHORT $LN4@PyParser_A
$LN5@PyParser_A:
  003d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08NFAPMDFI@?5Error?4?6?$AA@
  003df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN4@PyParser_A:

; 323  :         if (expected_ret) {

  003e5	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR expected_ret$[rsp], 0
  003ee	74 51		 je	 SHORT $LN3@PyParser_A

; 324  :             if (s->s_lower == s->s_upper - 1) {

  003f0	48 8b 44 24 38	 mov	 rax, QWORD PTR s$20767[rsp]
  003f5	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  003f8	ff c8		 dec	 eax
  003fa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$20767[rsp]
  003ff	39 41 10	 cmp	 DWORD PTR [rcx+16], eax
  00402	75 2f		 jne	 SHORT $LN2@PyParser_A

; 325  :                 /* Only one possible expected token */
; 326  :                 *expected_ret = ps->p_grammar->
; 327  :                     g_ll.ll_label[s->s_lower].lb_type;

  00404	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps$[rsp]
  0040c	48 8b 80 a8 8c
	00 00		 mov	 rax, QWORD PTR [rax+36008]
  00413	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$20767[rsp]
  00418	48 63 49 10	 movsxd	 rcx, DWORD PTR [rcx+16]
  0041c	48 6b c9 10	 imul	 rcx, 16
  00420	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00424	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR expected_ret$[rsp]
  0042c	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0042f	89 02		 mov	 DWORD PTR [rdx], eax

; 328  :             }
; 329  :             else

  00431	eb 0e		 jmp	 SHORT $LN1@PyParser_A
$LN2@PyParser_A:

; 330  :                 *expected_ret = -1;

  00433	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR expected_ret$[rsp]
  0043b	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1
$LN1@PyParser_A:
$LN3@PyParser_A:

; 331  :         }
; 332  :         return E_SYNTAX;

  00441	b8 0e 00 00 00	 mov	 eax, 14
  00446	eb 05		 jmp	 SHORT $LN39@PyParser_A

; 333  :     }

  00448	e9 2e fc ff ff	 jmp	 $LN35@PyParser_A
$LN39@PyParser_A:

; 334  : }

  0044d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00451	c3		 ret	 0
PyParser_AddToken ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@JCFDCJKP@s_pop?3?5parser?5stack?5underflow?5?9?9@ ; `string'
EXTRN	Py_FatalError:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$s_pop DD	imagerel s_pop
	DD	imagerel s_pop+67
	DD	imagerel $unwind$s_pop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s_pop DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0CH@JCFDCJKP@s_pop?3?5parser?5stack?5underflow?5?9?9@
CONST	SEGMENT
??_C@_0CH@JCFDCJKP@s_pop?3?5parser?5stack?5underflow?5?9?9@ DB 's_pop: pa'
	DB	'rser stack underflow -- FATAL', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT s_pop
_TEXT	SEGMENT
s$ = 48
s_pop	PROC						; COMDAT

; 56   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 57   :     if (s_empty(s))

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 05 a8 8c 00
	00		 add	 rax, 36008		; 00008ca8H
  00014	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00019	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0001c	75 0c		 jne	 SHORT $LN1@s_pop

; 58   :         Py_FatalError("s_pop: parser stack underflow -- FATAL");

  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@JCFDCJKP@s_pop?3?5parser?5stack?5underflow?5?9?9@
  00025	e8 00 00 00 00	 call	 Py_FatalError
$LN1@s_pop:

; 59   :     s->s_top++;

  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0002f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00032	48 83 c0 18	 add	 rax, 24
  00036	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 60   : }

  0003e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00042	c3		 ret	 0
s_pop	ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BI@NGGIKEFI@?$AA?$CB?$AAs?$AA_?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@EAMCGKNI@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAp?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	PyNode_AddChild:PROC
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$shift DD	imagerel shift
	DD	imagerel shift+149
	DD	imagerel $unwind$shift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$shift DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT ??_C@_1BI@NGGIKEFI@?$AA?$CB?$AAs?$AA_?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BI@NGGIKEFI@?$AA?$CB?$AAs?$AA_?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@ DB '!'
	DB	00H, 's', 00H, '_', 00H, 'e', 00H, 'm', 00H, 'p', 00H, 't', 00H
	DB	'y', 00H, '(', 00H, 's', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@EAMCGKNI@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAp?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@EAMCGKNI@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAp?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'a', 00H, 'r', 00H, 's', 00H
	DB	'e', 00H, 'r', 00H, '\', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 's'
	DB	00H, 'e', 00H, 'r', 00H, '.', 00H, 'c', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT shift
_TEXT	SEGMENT
err$ = 48
s$ = 80
type$ = 88
str$ = 96
newstate$ = 104
lineno$ = 112
col_offset$ = 120
shift	PROC						; COMDAT

; 109  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 110  :     int err;
; 111  :     assert(!s_empty(s));

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0001c	48 05 a8 8c 00
	00		 add	 rax, 36008		; 00008ca8H
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00027	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0002a	75 1c		 jne	 SHORT $LN4@shift
  0002c	41 b8 6f 00 00
	00		 mov	 r8d, 111		; 0000006fH
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CG@EAMCGKNI@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAp?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@NGGIKEFI@?$AA?$CB?$AAs?$AA_?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00046	33 c0		 xor	 eax, eax
$LN4@shift:

; 112  :     err = PyNode_AddChild(s->s_top->s_parent, type, str, lineno, col_offset);

  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0004d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00050	8b 4c 24 78	 mov	 ecx, DWORD PTR col_offset$[rsp]
  00054	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00058	44 8b 4c 24 70	 mov	 r9d, DWORD PTR lineno$[rsp]
  0005d	4c 8b 44 24 60	 mov	 r8, QWORD PTR str$[rsp]
  00062	8b 54 24 58	 mov	 edx, DWORD PTR type$[rsp]
  00066	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0006a	e8 00 00 00 00	 call	 PyNode_AddChild
  0006f	89 44 24 30	 mov	 DWORD PTR err$[rsp], eax

; 113  :     if (err)

  00073	83 7c 24 30 00	 cmp	 DWORD PTR err$[rsp], 0
  00078	74 06		 je	 SHORT $LN1@shift

; 114  :         return err;

  0007a	8b 44 24 30	 mov	 eax, DWORD PTR err$[rsp]
  0007e	eb 10		 jmp	 SHORT $LN2@shift
$LN1@shift:

; 115  :     s->s_top->s_state = newstate;

  00080	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00085	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00088	8b 4c 24 68	 mov	 ecx, DWORD PTR newstate$[rsp]
  0008c	89 08		 mov	 DWORD PTR [rax], ecx

; 116  :     return 0;

  0008e	33 c0		 xor	 eax, eax
$LN2@shift:

; 117  : }

  00090	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00094	c3		 ret	 0
shift	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$push DD	imagerel push
	DD	imagerel push+198
	DD	imagerel $unwind$push
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$push DD	011701H
	DD	08217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT push
_TEXT	SEGMENT
n$ = 48
err$ = 56
s$ = 80
type$ = 88
d$ = 96
newstate$ = 104
lineno$ = 112
col_offset$ = 120
push	PROC						; COMDAT

; 121  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 122  :     int err;
; 123  :     register node *n;
; 124  :     n = s->s_top->s_parent;

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0001c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00023	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 125  :     assert(!s_empty(s));

  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0002d	48 05 a8 8c 00
	00		 add	 rax, 36008		; 00008ca8H
  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00038	48 39 01	 cmp	 QWORD PTR [rcx], rax
  0003b	75 1c		 jne	 SHORT $LN4@push
  0003d	41 b8 7d 00 00
	00		 mov	 r8d, 125		; 0000007dH
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CG@EAMCGKNI@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAp?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?4?$AAc?$AA?$AA@
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BI@NGGIKEFI@?$AA?$CB?$AAs?$AA_?$AAe?$AAm?$AAp?$AAt?$AAy?$AA?$CI?$AAs?$AA?$CJ?$AA?$AA@
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00057	33 c0		 xor	 eax, eax
$LN4@push:

; 126  :     err = PyNode_AddChild(n, type, (char *)NULL, lineno, col_offset);

  00059	8b 44 24 78	 mov	 eax, DWORD PTR col_offset$[rsp]
  0005d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00061	44 8b 4c 24 70	 mov	 r9d, DWORD PTR lineno$[rsp]
  00066	45 33 c0	 xor	 r8d, r8d
  00069	8b 54 24 58	 mov	 edx, DWORD PTR type$[rsp]
  0006d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  00072	e8 00 00 00 00	 call	 PyNode_AddChild
  00077	89 44 24 38	 mov	 DWORD PTR err$[rsp], eax

; 127  :     if (err)

  0007b	83 7c 24 38 00	 cmp	 DWORD PTR err$[rsp], 0
  00080	74 06		 je	 SHORT $LN1@push

; 128  :         return err;

  00082	8b 44 24 38	 mov	 eax, DWORD PTR err$[rsp]
  00086	eb 39		 jmp	 SHORT $LN2@push
$LN1@push:

; 129  :     s->s_top->s_state = newstate;

  00088	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0008d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00090	8b 4c 24 68	 mov	 ecx, DWORD PTR newstate$[rsp]
  00094	89 08		 mov	 DWORD PTR [rax], ecx

; 130  :     return s_push(s, d, CHILD(n, NCH(n)-1));

  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  0009b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0009e	ff c8		 dec	 eax
  000a0	48 98		 cdqe
  000a2	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000a6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  000ab	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000af	4c 8b c0	 mov	 r8, rax
  000b2	48 8b 54 24 60	 mov	 rdx, QWORD PTR d$[rsp]
  000b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000bc	e8 00 00 00 00	 call	 s_push
$LN2@push:

; 131  : }

  000c1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c5	c3		 ret	 0
push	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@KJOHAMNK@Illegal?5token?6?$AA@		; `string'
PUBLIC	??_C@_0BG@JKNBOFJK@It?8s?5a?5token?5we?5know?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@EDEPLKBJ@It?8s?5a?5keyword?6?$AA@	; `string'
EXTRN	strcmp:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$classify DD imagerel classify
	DD	imagerel classify+397
	DD	imagerel $unwind$classify
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$classify DD 011201H
	DD	0c212H
xdata	ENDS
;	COMDAT ??_C@_0P@KJOHAMNK@Illegal?5token?6?$AA@
CONST	SEGMENT
??_C@_0P@KJOHAMNK@Illegal?5token?6?$AA@ DB 'Illegal token', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JKNBOFJK@It?8s?5a?5token?5we?5know?6?$AA@
CONST	SEGMENT
??_C@_0BG@JKNBOFJK@It?8s?5a?5token?5we?5know?6?$AA@ DB 'It''s a token we '
	DB	'know', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@EDEPLKBJ@It?8s?5a?5keyword?6?$AA@
CONST	SEGMENT
??_C@_0BA@EDEPLKBJ@It?8s?5a?5keyword?6?$AA@ DB 'It''s a keyword', 0aH, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT classify
_TEXT	SEGMENT
n$ = 32
g$ = 40
i$20721 = 48
s$20719 = 56
l$20720 = 64
i$20732 = 72
l$20731 = 80
ps$ = 112
type$ = 120
str$ = 128
classify PROC						; COMDAT

; 138  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 139  :     grammar *g = ps->p_grammar;

  00012	48 8b 44 24 70	 mov	 rax, QWORD PTR ps$[rsp]
  00017	48 8b 80 a8 8c
	00 00		 mov	 rax, QWORD PTR [rax+36008]
  0001e	48 89 44 24 28	 mov	 QWORD PTR g$[rsp], rax

; 140  :     register int n = g->g_ll.ll_nlabels;

  00023	48 8b 44 24 28	 mov	 rax, QWORD PTR g$[rsp]
  00028	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002b	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 141  : 
; 142  :     if (type == NAME) {

  0002f	83 7c 24 78 01	 cmp	 DWORD PTR type$[rsp], 1
  00034	0f 85 b9 00 00
	00		 jne	 $LN16@classify

; 143  :         register char *s = str;

  0003a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$[rsp]
  00042	48 89 44 24 38	 mov	 QWORD PTR s$20719[rsp], rax

; 144  :         register label *l = g->g_ll.ll_label;

  00047	48 8b 44 24 28	 mov	 rax, QWORD PTR g$[rsp]
  0004c	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00050	48 89 44 24 40	 mov	 QWORD PTR l$20720[rsp], rax

; 145  :         register int i;
; 146  :         for (i = n; i > 0; i--, l++) {

  00055	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00059	89 44 24 30	 mov	 DWORD PTR i$20721[rsp], eax
  0005d	eb 18		 jmp	 SHORT $LN15@classify
$LN14@classify:
  0005f	8b 44 24 30	 mov	 eax, DWORD PTR i$20721[rsp]
  00063	ff c8		 dec	 eax
  00065	89 44 24 30	 mov	 DWORD PTR i$20721[rsp], eax
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR l$20720[rsp]
  0006e	48 83 c0 10	 add	 rax, 16
  00072	48 89 44 24 40	 mov	 QWORD PTR l$20720[rsp], rax
$LN15@classify:
  00077	83 7c 24 30 00	 cmp	 DWORD PTR i$20721[rsp], 0
  0007c	7e 75		 jle	 SHORT $LN13@classify

; 147  :             if (l->lb_type != NAME || l->lb_str == NULL ||
; 148  :                 l->lb_str[0] != s[0] ||
; 149  :                 strcmp(l->lb_str, s) != 0)

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR l$20720[rsp]
  00083	83 38 01	 cmp	 DWORD PTR [rax], 1
  00086	75 3b		 jne	 SHORT $LN11@classify
  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR l$20720[rsp]
  0008d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00092	74 2f		 je	 SHORT $LN11@classify
  00094	48 8b 44 24 40	 mov	 rax, QWORD PTR l$20720[rsp]
  00099	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0009d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$20719[rsp]
  000a5	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  000a8	3b c1		 cmp	 eax, ecx
  000aa	75 17		 jne	 SHORT $LN11@classify
  000ac	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$20719[rsp]
  000b1	48 8b 44 24 40	 mov	 rax, QWORD PTR l$20720[rsp]
  000b6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000ba	e8 00 00 00 00	 call	 strcmp
  000bf	85 c0		 test	 eax, eax
  000c1	74 02		 je	 SHORT $LN12@classify
$LN11@classify:

; 150  :                 continue;

  000c3	eb 9a		 jmp	 SHORT $LN14@classify
$LN12@classify:

; 151  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 152  : #if 0
; 153  :             /* Leaving this in as an example */
; 154  :             if (!(ps->p_flags & CO_FUTURE_WITH_STATEMENT)) {
; 155  :                 if (s[0] == 'w' && strcmp(s, "with") == 0)
; 156  :                     break; /* not a keyword yet */
; 157  :                 else if (s[0] == 'a' && strcmp(s, "as") == 0)
; 158  :                     break; /* not a keyword yet */
; 159  :             }
; 160  : #endif
; 161  : #endif
; 162  :             D(printf("It's a keyword\n"));

  000c5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  000cc	75 02		 jne	 SHORT $LN10@classify
  000ce	eb 0d		 jmp	 SHORT $LN9@classify
$LN10@classify:
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@EDEPLKBJ@It?8s?5a?5keyword?6?$AA@
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN9@classify:

; 163  :             return n - i;

  000dd	8b 44 24 30	 mov	 eax, DWORD PTR i$20721[rsp]
  000e1	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  000e5	2b c8		 sub	 ecx, eax
  000e7	8b c1		 mov	 eax, ecx
  000e9	e9 9a 00 00 00	 jmp	 $LN17@classify

; 164  :         }

  000ee	e9 6c ff ff ff	 jmp	 $LN14@classify
$LN13@classify:
$LN16@classify:

; 165  :     }
; 166  : 
; 167  :     {
; 168  :         register label *l = g->g_ll.ll_label;

  000f3	48 8b 44 24 28	 mov	 rax, QWORD PTR g$[rsp]
  000f8	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000fc	48 89 44 24 50	 mov	 QWORD PTR l$20731[rsp], rax

; 169  :         register int i;
; 170  :         for (i = n; i > 0; i--, l++) {

  00101	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00105	89 44 24 48	 mov	 DWORD PTR i$20732[rsp], eax
  00109	eb 18		 jmp	 SHORT $LN8@classify
$LN7@classify:
  0010b	8b 44 24 48	 mov	 eax, DWORD PTR i$20732[rsp]
  0010f	ff c8		 dec	 eax
  00111	89 44 24 48	 mov	 DWORD PTR i$20732[rsp], eax
  00115	48 8b 44 24 50	 mov	 rax, QWORD PTR l$20731[rsp]
  0011a	48 83 c0 10	 add	 rax, 16
  0011e	48 89 44 24 50	 mov	 QWORD PTR l$20731[rsp], rax
$LN8@classify:
  00123	83 7c 24 48 00	 cmp	 DWORD PTR i$20732[rsp], 0
  00128	7e 41		 jle	 SHORT $LN6@classify

; 171  :             if (l->lb_type == type && l->lb_str == NULL) {

  0012a	48 8b 44 24 50	 mov	 rax, QWORD PTR l$20731[rsp]
  0012f	8b 4c 24 78	 mov	 ecx, DWORD PTR type$[rsp]
  00133	39 08		 cmp	 DWORD PTR [rax], ecx
  00135	75 32		 jne	 SHORT $LN5@classify
  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR l$20731[rsp]
  0013c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00141	75 26		 jne	 SHORT $LN5@classify

; 172  :                 D(printf("It's a token we know\n"));

  00143	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  0014a	75 02		 jne	 SHORT $LN4@classify
  0014c	eb 0d		 jmp	 SHORT $LN3@classify
$LN4@classify:
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@JKNBOFJK@It?8s?5a?5token?5we?5know?6?$AA@
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN3@classify:

; 173  :                 return n - i;

  0015b	8b 44 24 48	 mov	 eax, DWORD PTR i$20732[rsp]
  0015f	8b 4c 24 20	 mov	 ecx, DWORD PTR n$[rsp]
  00163	2b c8		 sub	 ecx, eax
  00165	8b c1		 mov	 eax, ecx
  00167	eb 1f		 jmp	 SHORT $LN17@classify
$LN5@classify:

; 174  :             }
; 175  :         }

  00169	eb a0		 jmp	 SHORT $LN7@classify
$LN6@classify:

; 176  :     }
; 177  : 
; 178  :     D(printf("Illegal token\n"));

  0016b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  00172	75 02		 jne	 SHORT $LN2@classify
  00174	eb 0d		 jmp	 SHORT $LN1@classify
$LN2@classify:
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@KJOHAMNK@Illegal?5token?6?$AA@
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN1@classify:

; 179  :     return -1;

  00183	b8 ff ff ff ff	 mov	 eax, -1
$LN17@classify:

; 180  : }

  00188	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018c	c3		 ret	 0
classify ENDP
_TEXT	ENDS
PUBLIC	??_C@_01PKGAHCOL@?$CJ?$AA@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_01ODHLEDKK@?$CI?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_03IGPHLJKL@NIL?$AA@			; `string'
PUBLIC	_Py_dumptree
EXTRN	PyGrammar_LabelRepr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_dumptree DD imagerel $LN10
	DD	imagerel $LN10+225
	DD	imagerel $unwind$_Py_dumptree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_dumptree DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_01PKGAHCOL@?$CJ?$AA@
CONST	SEGMENT
??_C@_01PKGAHCOL@?$CJ?$AA@ DB ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01ODHLEDKK@?$CI?$AA@
CONST	SEGMENT
??_C@_01ODHLEDKK@?$CI?$AA@ DB '(', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03IGPHLJKL@NIL?$AA@
CONST	SEGMENT
??_C@_03IGPHLJKL@NIL?$AA@ DB 'NIL', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_dumptree
_TEXT	SEGMENT
i$ = 32
l$20827 = 40
g$ = 80
n$ = 88
_Py_dumptree PROC					; COMDAT

; 343  : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 344  :     int i;
; 345  : 
; 346  :     if (n == NULL)

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR n$[rsp], 0
  00014	75 12		 jne	 SHORT $LN7@Py_dumptre

; 347  :         printf("NIL");

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IGPHLJKL@NIL?$AA@
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 348  :     else {

  00023	e9 b4 00 00 00	 jmp	 $LN6@Py_dumptre
$LN7@Py_dumptre:

; 349  :         label l;
; 350  :         l.lb_type = TYPE(n);

  00028	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  0002d	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00030	89 44 24 28	 mov	 DWORD PTR l$20827[rsp], eax

; 351  :         l.lb_str = STR(n);

  00034	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00039	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003d	48 89 44 24 30	 mov	 QWORD PTR l$20827[rsp+8], rax

; 352  :         printf("%s", PyGrammar_LabelRepr(&l));

  00042	48 8d 4c 24 28	 lea	 rcx, QWORD PTR l$20827[rsp]
  00047	e8 00 00 00 00	 call	 PyGrammar_LabelRepr
  0004c	48 8b d0	 mov	 rdx, rax
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 353  :         if (ISNONTERMINAL(TYPE(n))) {

  0005c	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00061	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00064	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00069	7c 71		 jl	 SHORT $LN5@Py_dumptre

; 354  :             printf("(");

  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01ODHLEDKK@?$CI?$AA@
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 355  :             for (i = 0; i < NCH(n); i++) {

  00078	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00080	eb 0a		 jmp	 SHORT $LN4@Py_dumptre
$LN3@Py_dumptre:
  00082	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00086	ff c0		 inc	 eax
  00088	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@Py_dumptre:
  0008c	48 8b 44 24 58	 mov	 rax, QWORD PTR n$[rsp]
  00091	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00094	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00098	7d 35		 jge	 SHORT $LN2@Py_dumptre

; 356  :                 if (i > 0)

  0009a	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0009f	7e 0d		 jle	 SHORT $LN1@Py_dumptre

; 357  :                     printf(",");

  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01IHBHIGKO@?0?$AA@
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN1@Py_dumptre:

; 358  :                 dumptree(g, CHILD(n, i));

  000ae	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b3	48 6b c0 28	 imul	 rax, 40			; 00000028H
  000b7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR n$[rsp]
  000bc	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  000c0	48 8b d0	 mov	 rdx, rax
  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  000c8	e8 00 00 00 00	 call	 _Py_dumptree

; 359  :             }

  000cd	eb b3		 jmp	 SHORT $LN3@Py_dumptre
$LN2@Py_dumptre:

; 360  :             printf(")");

  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01PKGAHCOL@?$CJ?$AA@
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN5@Py_dumptre:
$LN6@Py_dumptre:

; 361  :         }
; 362  :     }
; 363  : }

  000dc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e0	c3		 ret	 0
_Py_dumptree ENDP
_TEXT	ENDS
PUBLIC	??_C@_02LKANKAOC@?$DP?5?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_04ENHBHKMJ@?$CI?$CFs?$CJ?$AA@		; `string'
PUBLIC	_Py_showtree
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_showtree DD imagerel $LN13
	DD	imagerel $LN13+240
	DD	imagerel $unwind$_Py_showtree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_showtree DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_02LKANKAOC@?$DP?5?$AA@
CONST	SEGMENT
??_C@_02LKANKAOC@?$DP?5?$AA@ DB '? ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04ENHBHKMJ@?$CI?$CFs?$CJ?$AA@
CONST	SEGMENT
??_C@_04ENHBHKMJ@?$CI?$CFs?$CJ?$AA@ DB '(%s)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_showtree
_TEXT	SEGMENT
i$ = 32
g$ = 64
n$ = 72
_Py_showtree PROC					; COMDAT

; 367  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 368  :     int i;
; 369  : 
; 370  :     if (n == NULL)

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR n$[rsp], 0
  00014	75 05		 jne	 SHORT $LN10@Py_showtre

; 371  :         return;

  00016	e9 d0 00 00 00	 jmp	 $LN11@Py_showtre
$LN10@Py_showtre:

; 372  :     if (ISNONTERMINAL(TYPE(n))) {

  0001b	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00020	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00023	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00028	7c 45		 jl	 SHORT $LN9@Py_showtre

; 373  :         for (i = 0; i < NCH(n); i++)

  0002a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00032	eb 0a		 jmp	 SHORT $LN8@Py_showtre
$LN7@Py_showtre:
  00034	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00038	ff c0		 inc	 eax
  0003a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN8@Py_showtre:
  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00043	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00046	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0004a	7d 21		 jge	 SHORT $LN6@Py_showtre

; 374  :             showtree(g, CHILD(n, i));

  0004c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00051	48 6b c0 28	 imul	 rax, 40			; 00000028H
  00055	48 8b 4c 24 48	 mov	 rcx, QWORD PTR n$[rsp]
  0005a	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  0005e	48 8b d0	 mov	 rdx, rax
  00061	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$[rsp]
  00066	e8 00 00 00 00	 call	 _Py_showtree
  0006b	eb c7		 jmp	 SHORT $LN7@Py_showtre
$LN6@Py_showtre:

; 375  :     }
; 376  :     else if (ISTERMINAL(TYPE(n))) {

  0006d	eb 7c		 jmp	 SHORT $LN5@Py_showtre
$LN9@Py_showtre:
  0006f	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00074	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00077	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0007c	7d 60		 jge	 SHORT $LN4@Py_showtre

; 377  :         printf("%s", _PyParser_TokenNames[TYPE(n)]);

  0007e	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  00083	48 0f bf 00	 movsx	 rax, WORD PTR [rax]
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyParser_TokenNames
  0008e	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 378  :         if (TYPE(n) == NUMBER || TYPE(n) == NAME)

  0009f	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000a4	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000a7	83 f8 02	 cmp	 eax, 2
  000aa	74 0d		 je	 SHORT $LN2@Py_showtre
  000ac	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000b1	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000b4	83 f8 01	 cmp	 eax, 1
  000b7	75 16		 jne	 SHORT $LN3@Py_showtre
$LN2@Py_showtre:

; 379  :             printf("(%s)", STR(n));

  000b9	48 8b 44 24 48	 mov	 rax, QWORD PTR n$[rsp]
  000be	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04ENHBHKMJ@?$CI?$CFs?$CJ?$AA@
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN3@Py_showtre:

; 380  :         printf(" ");

  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 381  :     }
; 382  :     else

  000dc	eb 0d		 jmp	 SHORT $LN1@Py_showtre
$LN4@Py_showtre:

; 383  :         printf("? ");

  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02LKANKAOC@?$DP?5?$AA@
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN1@Py_showtre:
$LN5@Py_showtre:
$LN11@Py_showtre:

; 384  : }

  000eb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ef	c3		 ret	 0
_Py_showtree ENDP
_TEXT	ENDS
PUBLIC	??_C@_09CONAPFNL@Listing?3?6?$AA@		; `string'
PUBLIC	??_C@_08GCJAIBFI@Tokens?3?6?$AA@		; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0N@MOLAPCEN@Parse?5tree?3?6?$AA@		; `string'
PUBLIC	_Py_printtree
EXTRN	PyNode_ListTree:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_printtree DD imagerel $LN4
	DD	imagerel $LN4+176
	DD	imagerel $unwind$_Py_printtree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_printtree DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_09CONAPFNL@Listing?3?6?$AA@
CONST	SEGMENT
??_C@_09CONAPFNL@Listing?3?6?$AA@ DB 'Listing:', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GCJAIBFI@Tokens?3?6?$AA@
CONST	SEGMENT
??_C@_08GCJAIBFI@Tokens?3?6?$AA@ DB 'Tokens:', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOLAPCEN@Parse?5tree?3?6?$AA@
CONST	SEGMENT
??_C@_0N@MOLAPCEN@Parse?5tree?3?6?$AA@ DB 'Parse tree:', 0aH, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_printtree
_TEXT	SEGMENT
ps$ = 48
_Py_printtree PROC					; COMDAT

; 388  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 389  :     if (Py_DebugFlag) {

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_DebugFlag, 0
  00010	74 6e		 je	 SHORT $LN1@Py_printtr

; 390  :         printf("Parse tree:\n");

  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@MOLAPCEN@Parse?5tree?3?6?$AA@
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 391  :         dumptree(ps->p_grammar, ps->p_tree);

  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR ps$[rsp]
  00024	48 8b 90 b0 8c
	00 00		 mov	 rdx, QWORD PTR [rax+36016]
  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR ps$[rsp]
  00030	48 8b 88 a8 8c
	00 00		 mov	 rcx, QWORD PTR [rax+36008]
  00037	e8 00 00 00 00	 call	 _Py_dumptree

; 392  :         printf("\n");

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 393  :         printf("Tokens:\n");

  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08GCJAIBFI@Tokens?3?6?$AA@
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 394  :         showtree(ps->p_grammar, ps->p_tree);

  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR ps$[rsp]
  0005b	48 8b 90 b0 8c
	00 00		 mov	 rdx, QWORD PTR [rax+36016]
  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR ps$[rsp]
  00067	48 8b 88 a8 8c
	00 00		 mov	 rcx, QWORD PTR [rax+36008]
  0006e	e8 00 00 00 00	 call	 _Py_showtree

; 395  :         printf("\n");

  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN1@Py_printtr:

; 396  :     }
; 397  :     printf("Listing:\n");

  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09CONAPFNL@Listing?3?6?$AA@
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 398  :     PyNode_ListTree(ps->p_tree);

  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR ps$[rsp]
  00092	48 8b 88 b0 8c
	00 00		 mov	 rcx, QWORD PTR [rax+36016]
  00099	e8 00 00 00 00	 call	 PyNode_ListTree

; 399  :     printf("\n");

  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 400  : }

  000ab	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000af	c3		 ret	 0
_Py_printtree ENDP
_TEXT	ENDS
END
