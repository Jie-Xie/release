; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
arenas	DQ	01H DUP (?)
maxarenas DD	01H DUP (?)
	ALIGN	8

unused_arena_objects DQ 01H DUP (?)
usable_arenas DQ 01H DUP (?)
narenas_currently_allocated DQ 01H DUP (?)
ntimes_arena_allocated DQ 01H DUP (?)
narenas_highwater DQ 01H DUP (?)
_Py_AllocatedBlocks DQ 01H DUP (?)
serialno DQ	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
usedpools DQ	FLAT:usedpools-16
	DQ	FLAT:usedpools-16
	DQ	FLAT:usedpools
	DQ	FLAT:usedpools
	DQ	FLAT:usedpools+16
	DQ	FLAT:usedpools+16
	DQ	FLAT:usedpools+32
	DQ	FLAT:usedpools+32
	DQ	FLAT:usedpools+48
	DQ	FLAT:usedpools+48
	DQ	FLAT:usedpools+64
	DQ	FLAT:usedpools+64
	DQ	FLAT:usedpools+80
	DQ	FLAT:usedpools+80
	DQ	FLAT:usedpools+96
	DQ	FLAT:usedpools+96
	DQ	FLAT:usedpools+112
	DQ	FLAT:usedpools+112
	DQ	FLAT:usedpools+128
	DQ	FLAT:usedpools+128
	DQ	FLAT:usedpools+144
	DQ	FLAT:usedpools+144
	DQ	FLAT:usedpools+160
	DQ	FLAT:usedpools+160
	DQ	FLAT:usedpools+176
	DQ	FLAT:usedpools+176
	DQ	FLAT:usedpools+192
	DQ	FLAT:usedpools+192
	DQ	FLAT:usedpools+208
	DQ	FLAT:usedpools+208
	DQ	FLAT:usedpools+224
	DQ	FLAT:usedpools+224
	DQ	FLAT:usedpools+240
	DQ	FLAT:usedpools+240
	DQ	FLAT:usedpools+256
	DQ	FLAT:usedpools+256
	DQ	FLAT:usedpools+272
	DQ	FLAT:usedpools+272
	DQ	FLAT:usedpools+288
	DQ	FLAT:usedpools+288
	DQ	FLAT:usedpools+304
	DQ	FLAT:usedpools+304
	DQ	FLAT:usedpools+320
	DQ	FLAT:usedpools+320
	DQ	FLAT:usedpools+336
	DQ	FLAT:usedpools+336
	DQ	FLAT:usedpools+352
	DQ	FLAT:usedpools+352
	DQ	FLAT:usedpools+368
	DQ	FLAT:usedpools+368
	DQ	FLAT:usedpools+384
	DQ	FLAT:usedpools+384
	DQ	FLAT:usedpools+400
	DQ	FLAT:usedpools+400
	DQ	FLAT:usedpools+416
	DQ	FLAT:usedpools+416
	DQ	FLAT:usedpools+432
	DQ	FLAT:usedpools+432
	DQ	FLAT:usedpools+448
	DQ	FLAT:usedpools+448
	DQ	FLAT:usedpools+464
	DQ	FLAT:usedpools+464
	DQ	FLAT:usedpools+480
	DQ	FLAT:usedpools+480
	DQ	FLAT:usedpools+496
	DQ	FLAT:usedpools+496
	DQ	FLAT:usedpools+512
	DQ	FLAT:usedpools+512
	DQ	FLAT:usedpools+528
	DQ	FLAT:usedpools+528
	DQ	FLAT:usedpools+544
	DQ	FLAT:usedpools+544
	DQ	FLAT:usedpools+560
	DQ	FLAT:usedpools+560
	DQ	FLAT:usedpools+576
	DQ	FLAT:usedpools+576
	DQ	FLAT:usedpools+592
	DQ	FLAT:usedpools+592
	DQ	FLAT:usedpools+608
	DQ	FLAT:usedpools+608
	DQ	FLAT:usedpools+624
	DQ	FLAT:usedpools+624
	DQ	FLAT:usedpools+640
	DQ	FLAT:usedpools+640
	DQ	FLAT:usedpools+656
	DQ	FLAT:usedpools+656
	DQ	FLAT:usedpools+672
	DQ	FLAT:usedpools+672
	DQ	FLAT:usedpools+688
	DQ	FLAT:usedpools+688
	DQ	FLAT:usedpools+704
	DQ	FLAT:usedpools+704
	DQ	FLAT:usedpools+720
	DQ	FLAT:usedpools+720
	DQ	FLAT:usedpools+736
	DQ	FLAT:usedpools+736
	DQ	FLAT:usedpools+752
	DQ	FLAT:usedpools+752
	DQ	FLAT:usedpools+768
	DQ	FLAT:usedpools+768
	DQ	FLAT:usedpools+784
	DQ	FLAT:usedpools+784
	DQ	FLAT:usedpools+800
	DQ	FLAT:usedpools+800
	DQ	FLAT:usedpools+816
	DQ	FLAT:usedpools+816
	DQ	FLAT:usedpools+832
	DQ	FLAT:usedpools+832
	DQ	FLAT:usedpools+848
	DQ	FLAT:usedpools+848
	DQ	FLAT:usedpools+864
	DQ	FLAT:usedpools+864
	DQ	FLAT:usedpools+880
	DQ	FLAT:usedpools+880
	DQ	FLAT:usedpools+896
	DQ	FLAT:usedpools+896
	DQ	FLAT:usedpools+912
	DQ	FLAT:usedpools+912
	DQ	FLAT:usedpools+928
	DQ	FLAT:usedpools+928
	DQ	FLAT:usedpools+944
	DQ	FLAT:usedpools+944
	DQ	FLAT:usedpools+960
	DQ	FLAT:usedpools+960
	DQ	FLAT:usedpools+976
	DQ	FLAT:usedpools+976
	DQ	FLAT:usedpools+992
	DQ	FLAT:usedpools+992
_DATA	ENDS
PUBLIC	_Py_GetAllocatedBlocks
; Function compile flags: /Odtp
; File c:\src\pyparallel\objects\obmalloc.c
;	COMDAT _Py_GetAllocatedBlocks
_TEXT	SEGMENT
_Py_GetAllocatedBlocks PROC				; COMDAT

; 558  :     READ_LOCK();
; 559  :     return _Py_AllocatedBlocks;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_AllocatedBlocks

; 560  :     READ_UNLOCK();
; 561  : }

  00007	c3		 ret	 0
_Py_GetAllocatedBlocks ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FG@LBHCAJED@?$AA?$CG?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAp?$AAo?$AAo?$AAl?$AA?9?$AA?$DO?$AAa?$AAr?$AAe?$AAn?$AAa?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAu?$AAs?$AAa@ ; `string'
PUBLIC	??_C@_1JA@OJBNAKMD@?$AA?$CI?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$CK?$AA?$CJ?$AAp?$AAo?$AAo?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$CK?$AA?$CJ?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa@ ; `string'
PUBLIC	??_C@_1DM@GIELJHEK@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1PG@EABAAMHH@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@ ; `string'
PUBLIC	??_C@_1LC@NOICJOPH@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@ ; `string'
PUBLIC	??_C@_1EC@IKPJGJIF@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@ ; `string'
PUBLIC	??_C@_1DI@IPKFDBGJ@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BG@CAHEDHEL@?$AAb?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	PyObject_Malloc
EXTRN	__imp_malloc:PROC
EXTRN	__imp__wassert:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Malloc DD imagerel $LN33
	DD	imagerel $LN33+1754
	DD	imagerel $unwind$PyObject_Malloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Malloc DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_1FG@LBHCAJED@?$AA?$CG?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAp?$AAo?$AAo?$AAl?$AA?9?$AA?$DO?$AAa?$AAr?$AAe?$AAn?$AAa?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAu?$AAs?$AAa@
CONST	SEGMENT
??_C@_1FG@LBHCAJED@?$AA?$CG?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAp?$AAo?$AAo?$AAl?$AA?9?$AA?$DO?$AAa?$AAr?$AAe?$AAn?$AAa?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAu?$AAs?$AAa@ DB '&'
	DB	00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H
	DB	'[', 00H, 'p', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '-', 00H, '>'
	DB	00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ']', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, 'u', 00H, 's', 00H, 'a', 00H, 'b', 00H
	DB	'l', 00H, 'e', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n'
	DB	00H, 'a', 00H, 's', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@OJBNAKMD@?$AA?$CI?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$CK?$AA?$CJ?$AAp?$AAo?$AAo?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$CK?$AA?$CJ?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa@
CONST	SEGMENT
??_C@_1JA@OJBNAKMD@?$AA?$CI?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$CK?$AA?$CJ?$AAp?$AAo?$AAo?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$CK?$AA?$CJ?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa@ DB '('
	DB	00H, 'b', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '*', 00H
	DB	')', 00H, 'p', 00H, 'o', 00H, 'o', 00H, 'l', 00H, ' ', 00H, '<'
	DB	00H, '=', 00H, ' ', 00H, '(', 00H, 'b', 00H, 'l', 00H, 'o', 00H
	DB	'c', 00H, 'k', 00H, '*', 00H, ')', 00H, 'u', 00H, 's', 00H, 'a'
	DB	00H, 'b', 00H, 'l', 00H, 'e', 00H, '_', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H, 'a'
	DB	00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, '+', 00H, ' ', 00H, 'A', 00H, 'R', 00H, 'E', 00H, 'N'
	DB	00H, 'A', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	' ', 00H, '-', 00H, ' ', 00H, 'P', 00H, 'O', 00H, 'O', 00H, 'L'
	DB	00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@GIELJHEK@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@GIELJHEK@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'u'
	DB	00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, '-'
	DB	00H, '>', 00H, 'n', 00H, 'f', 00H, 'r', 00H, 'e', 00H, 'e', 00H
	DB	'p', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1PG@EABAAMHH@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
CONST	SEGMENT
??_C@_1PG@EABAAMHH@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@ DB 'u'
	DB	00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, '-'
	DB	00H, '>', 00H, 'f', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'p', 00H
	DB	'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, ' ', 00H, '!', 00H, '='
	DB	00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, 'u', 00H, 's', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'e', 00H
	DB	'n', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H, 'p', 00H, 'o'
	DB	00H, 'o', 00H, 'l', 00H, '_', 00H, 'a', 00H, 'd', 00H, 'd', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 's', 00H, ' ', 00H, '<', 00H, '='
	DB	00H, ' ', 00H, '(', 00H, 'b', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'k', 00H, '*', 00H, ')', 00H, 'u', 00H, 's', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'e', 00H
	DB	'n', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H, 'a', 00H, 'd'
	DB	00H, 'd', 00H, 'r', 00H, 'e', 00H, 's', 00H, 's', 00H, ' ', 00H
	DB	'+', 00H, ' ', 00H, 'A', 00H, 'R', 00H, 'E', 00H, 'N', 00H, 'A'
	DB	00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, 'P', 00H, 'O', 00H, 'O', 00H, 'L', 00H, '_'
	DB	00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1LC@NOICJOPH@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
CONST	SEGMENT
??_C@_1LC@NOICJOPH@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@ DB 'u'
	DB	00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, '-'
	DB	00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, 'u', 00H, 's', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'e', 00H
	DB	'n', 00H, 'a', 00H, 's', 00H, '-', 00H, '>', 00H, 'n', 00H, 'e'
	DB	00H, 'x', 00H, 't', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H
	DB	'a', 00H, '-', 00H, '>', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 'v'
	DB	00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'u', 00H, 's', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, '_', 00H, 'a', 00H, 'r', 00H, 'e', 00H
	DB	'n', 00H, 'a', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@IKPJGJIF@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
CONST	SEGMENT
??_C@_1EC@IKPJGJIF@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@ DB 'u'
	DB	00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, '-'
	DB	00H, '>', 00H, 'f', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'p', 00H
	DB	'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@IPKFDBGJ@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@IPKFDBGJ@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'u'
	DB	00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, '-'
	DB	00H, '>', 00H, 'a', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BG@CAHEDHEL@?$AAb?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BG@CAHEDHEL@?$AAb?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'b'
	DB	00H, 'p', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H
	DB	'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'o', 00H, 'b', 00H, 'm'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, '.', 00H
	DB	'c', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_Malloc
_TEXT	SEGMENT
bp$ = 32
size$ = 40
next$ = 48
pool$ = 56
result$20896 = 64
nbytes$ = 96
PyObject_Malloc PROC					; COMDAT

; 803  : {

$LN33:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 804  :     block *bp;
; 805  :     poolp pool;
; 806  :     poolp next;
; 807  :     uint size;
; 808  :     Px_RETURN(_PxMem_Malloc(nbytes))

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0f		 je	 SHORT $LN17@PyObject_M
  00012	48 8b 4c 24 60	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00017	e8 00 00 00 00	 call	 _PxMem_Malloc
  0001c	e9 b4 06 00 00	 jmp	 $LN18@PyObject_M
$LN17@PyObject_M:

; 809  : 
; 810  : #ifdef WITH_VALGRIND
; 811  :     if (UNLIKELY(running_on_valgrind == -1))
; 812  :         running_on_valgrind = RUNNING_ON_VALGRIND;
; 813  :     if (UNLIKELY(running_on_valgrind))
; 814  :         goto redirect;
; 815  : #endif
; 816  : 
; 817  :     /*
; 818  :      * Limit ourselves to PY_SSIZE_T_MAX bytes to prevent security holes.
; 819  :      * Most python internals blindly use a signed Py_ssize_t to track
; 820  :      * things without checking for overflows or negatives.
; 821  :      * As size_t is unsigned, checking for nbytes < 0 is not required.
; 822  :      */
; 823  :     if (nbytes > PY_SSIZE_T_MAX)

  00021	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0002b	48 39 44 24 60	 cmp	 QWORD PTR nbytes$[rsp], rax
  00030	76 07		 jbe	 SHORT $LN16@PyObject_M

; 824  :         return NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 9c 06 00 00	 jmp	 $LN18@PyObject_M
$LN16@PyObject_M:

; 825  : 
; 826  :     _Py_AllocatedBlocks++;

  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_AllocatedBlocks
  00040	48 ff c0	 inc	 rax
  00043	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_AllocatedBlocks, rax

; 827  : 
; 828  :     /*
; 829  :      * This implicitly redirects malloc(0).
; 830  :      */
; 831  :     if ((nbytes - 1) < SMALL_REQUEST_THRESHOLD) {

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR nbytes$[rsp]
  0004f	48 ff c8	 dec	 rax
  00052	48 3d 00 02 00
	00		 cmp	 rax, 512		; 00000200H
  00058	0f 83 38 06 00
	00		 jae	 $LN15@PyObject_M

; 832  :         LOCK();
; 833  :         /*
; 834  :          * Most frequent paths first
; 835  :          */
; 836  :         size = (uint)(nbytes - 1) >> ALIGNMENT_SHIFT;

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR nbytes$[rsp]
  00063	48 ff c8	 dec	 rax
  00066	c1 e8 03	 shr	 eax, 3
  00069	89 44 24 28	 mov	 DWORD PTR size$[rsp], eax

; 837  :         pool = usedpools[size + size];

  0006d	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  00071	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  00075	03 c8		 add	 ecx, eax
  00077	8b c1		 mov	 eax, ecx
  00079	8b c0		 mov	 eax, eax
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:usedpools
  00082	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00086	48 89 44 24 38	 mov	 QWORD PTR pool$[rsp], rax

; 838  :         if (pool != pool->nextpool) {

  0008b	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  00090	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00094	48 39 44 24 38	 cmp	 QWORD PTR pool$[rsp], rax
  00099	0f 84 0b 01 00
	00		 je	 $LN14@PyObject_M

; 839  :             /*
; 840  :              * There is a used pool for this size class.
; 841  :              * Pick up the head block of its free list.
; 842  :              */
; 843  :             ++pool->ref.count;

  0009f	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  000a4	8b 00		 mov	 eax, DWORD PTR [rax]
  000a6	ff c0		 inc	 eax
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  000ad	89 01		 mov	 DWORD PTR [rcx], eax

; 844  :             bp = pool->freeblock;

  000af	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  000b4	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b8	48 89 44 24 20	 mov	 QWORD PTR bp$[rsp], rax

; 845  :             assert(bp != NULL);

  000bd	48 83 7c 24 20
	00		 cmp	 QWORD PTR bp$[rsp], 0
  000c3	75 1c		 jne	 SHORT $LN20@PyObject_M
  000c5	41 b8 4d 03 00
	00		 mov	 r8d, 845		; 0000034dH
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@CAHEDHEL@?$AAb?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000df	33 c0		 xor	 eax, eax
$LN20@PyObject_M:

; 846  :             if ((pool->freeblock = *(block **)bp) != NULL) {

  000e1	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  000e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bp$[rsp]
  000eb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ee	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  000f2	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  000f7	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000fc	74 0a		 je	 SHORT $LN13@PyObject_M

; 847  :                 UNLOCK();
; 848  :                 return (void *)bp;

  000fe	48 8b 44 24 20	 mov	 rax, QWORD PTR bp$[rsp]
  00103	e9 cd 05 00 00	 jmp	 $LN18@PyObject_M
$LN13@PyObject_M:

; 849  :             }
; 850  :             /*
; 851  :              * Reached the end of the free list, try to extend it.
; 852  :              */
; 853  :             if (pool->nextoffset <= pool->maxnextoffset) {

  00108	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  0010d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  00112	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  00115	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00118	77 4e		 ja	 SHORT $LN12@PyObject_M

; 854  :                 /* There is room for another block. */
; 855  :                 pool->freeblock = (block*)pool +
; 856  :                                   pool->nextoffset;

  0011a	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  0011f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00122	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  00127	48 03 c8	 add	 rcx, rax
  0012a	48 8b c1	 mov	 rax, rcx
  0012d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  00132	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 857  :                 pool->nextoffset += INDEX2SIZE(size);

  00136	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  0013b	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0013e	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  00142	8d 44 c8 08	 lea	 eax, DWORD PTR [rax+rcx*8+8]
  00146	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  0014b	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 858  :                 *(block **)(pool->freeblock) = NULL;

  0014e	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  00153	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00157	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 859  :                 UNLOCK();
; 860  :                 return (void *)bp;

  0015e	48 8b 44 24 20	 mov	 rax, QWORD PTR bp$[rsp]
  00163	e9 6d 05 00 00	 jmp	 $LN18@PyObject_M
$LN12@PyObject_M:

; 861  :             }
; 862  :             /* Pool is full, unlink from used pools. */
; 863  :             next = pool->nextpool;

  00168	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  0016d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00171	48 89 44 24 30	 mov	 QWORD PTR next$[rsp], rax

; 864  :             pool = pool->prevpool;

  00176	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  0017b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0017f	48 89 44 24 38	 mov	 QWORD PTR pool$[rsp], rax

; 865  :             next->prevpool = pool;

  00184	48 8b 44 24 30	 mov	 rax, QWORD PTR next$[rsp]
  00189	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  0018e	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 866  :             pool->nextpool = next;

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  00197	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  0019c	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 867  :             UNLOCK();
; 868  :             return (void *)bp;

  001a0	48 8b 44 24 20	 mov	 rax, QWORD PTR bp$[rsp]
  001a5	e9 2b 05 00 00	 jmp	 $LN18@PyObject_M
$LN14@PyObject_M:

; 869  :         }
; 870  : 
; 871  :         /* There isn't a pool of the right size class immediately
; 872  :          * available:  use a free pool.
; 873  :          */
; 874  :         if (usable_arenas == NULL) {

  001aa	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR usable_arenas, 0
  001b2	75 39		 jne	 SHORT $LN11@PyObject_M

; 875  :             /* No arena has a free pool:  allocate a new arena. */
; 876  : #ifdef WITH_MEMORY_LIMITS
; 877  :             if (narenas_currently_allocated >= MAX_ARENAS) {
; 878  :                 UNLOCK();
; 879  :                 goto redirect;
; 880  :             }
; 881  : #endif
; 882  :             usable_arenas = new_arena();

  001b4	e8 00 00 00 00	 call	 new_arena
  001b9	48 89 05 00 00
	00 00		 mov	 QWORD PTR usable_arenas, rax

; 883  :             if (usable_arenas == NULL) {

  001c0	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR usable_arenas, 0
  001c8	75 05		 jne	 SHORT $LN10@PyObject_M

; 884  :                 UNLOCK();
; 885  :                 goto redirect;

  001ca	e9 c7 04 00 00	 jmp	 $redirect$20836
$LN10@PyObject_M:

; 886  :             }
; 887  :             usable_arenas->nextarena =
; 888  :                 usable_arenas->prevarena = NULL;

  001cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  001d6	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0
  001de	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  001e5	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN11@PyObject_M:

; 889  :         }
; 890  :         assert(usable_arenas->address != 0);

  001ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  001f4	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001f8	75 1c		 jne	 SHORT $LN21@PyObject_M
  001fa	41 b8 7a 03 00
	00		 mov	 r8d, 890		; 0000037aH
  00200	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@IPKFDBGJ@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00214	33 c0		 xor	 eax, eax
$LN21@PyObject_M:

; 891  : 
; 892  :         /* Try to get a cached free pool. */
; 893  :         pool = usable_arenas->freepools;

  00216	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  0021d	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00221	48 89 44 24 38	 mov	 QWORD PTR pool$[rsp], rax

; 894  :         if (pool != NULL) {

  00226	48 83 7c 24 38
	00		 cmp	 QWORD PTR pool$[rsp], 0
  0022c	0f 84 80 02 00
	00		 je	 $LN9@PyObject_M

; 895  :             /* Unlink from cached pools. */
; 896  :             usable_arenas->freepools = pool->nextpool;

  00232	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  00239	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  0023e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00242	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 897  : 
; 898  :             /* This arena already had the smallest nfreepools
; 899  :              * value, so decreasing nfreepools doesn't change
; 900  :              * that, and we don't need to rearrange the
; 901  :              * usable_arenas list.  However, if the arena has
; 902  :              * become wholly allocated, we need to remove its
; 903  :              * arena_object from usable_arenas.
; 904  :              */
; 905  :             --usable_arenas->nfreepools;

  00246	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  0024d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00250	ff c8		 dec	 eax
  00252	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usable_arenas
  00259	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 906  :             if (usable_arenas->nfreepools == 0) {

  0025c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  00263	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00267	0f 85 c2 00 00
	00		 jne	 $LN8@PyObject_M

; 907  :                 /* Wholly allocated:  remove. */
; 908  :                 assert(usable_arenas->freepools == NULL);

  0026d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  00274	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00279	74 1c		 je	 SHORT $LN22@PyObject_M
  0027b	41 b8 8c 03 00
	00		 mov	 r8d, 908		; 0000038cH
  00281	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00288	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@IKPJGJIF@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
  0028f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00295	33 c0		 xor	 eax, eax
$LN22@PyObject_M:

; 909  :                 assert(usable_arenas->nextarena == NULL ||
; 910  :                        usable_arenas->nextarena->prevarena ==
; 911  :                        usable_arenas);

  00297	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  0029e	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  002a3	74 34		 je	 SHORT $LN23@PyObject_M
  002a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  002ac	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usable_arenas
  002b7	48 39 48 28	 cmp	 QWORD PTR [rax+40], rcx
  002bb	74 1c		 je	 SHORT $LN23@PyObject_M
  002bd	41 b8 8f 03 00
	00		 mov	 r8d, 911		; 0000038fH
  002c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  002ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LC@NOICJOPH@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002d7	33 c0		 xor	 eax, eax
$LN23@PyObject_M:

; 912  : 
; 913  :                 usable_arenas = usable_arenas->nextarena;

  002d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  002e0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002e4	48 89 05 00 00
	00 00		 mov	 QWORD PTR usable_arenas, rax

; 914  :                 if (usable_arenas != NULL) {

  002eb	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR usable_arenas, 0
  002f3	74 38		 je	 SHORT $LN7@PyObject_M

; 915  :                     usable_arenas->prevarena = NULL;

  002f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  002fc	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 916  :                     assert(usable_arenas->address != 0);

  00304	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  0030b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0030f	75 1c		 jne	 SHORT $LN24@PyObject_M
  00311	41 b8 94 03 00
	00		 mov	 r8d, 916		; 00000394H
  00317	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  0031e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@IPKFDBGJ@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0032b	33 c0		 xor	 eax, eax
$LN24@PyObject_M:
$LN7@PyObject_M:

; 917  :                 }
; 918  :             }
; 919  :             else {

  0032d	eb 47		 jmp	 SHORT $LN6@PyObject_M
$LN8@PyObject_M:

; 920  :                 /* nfreepools > 0:  it must be that freepools
; 921  :                  * isn't NULL, or that we haven't yet carved
; 922  :                  * off all the arena's pools for the first
; 923  :                  * time.
; 924  :                  */
; 925  :                 assert(usable_arenas->freepools != NULL ||
; 926  :                        usable_arenas->pool_address <=
; 927  :                        (block*)usable_arenas->address +
; 928  :                            ARENA_SIZE - POOL_SIZE);

  0032f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  00336	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0033b	75 39		 jne	 SHORT $LN25@PyObject_M
  0033d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  00344	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00347	48 05 00 f0 03
	00		 add	 rax, 258048		; 0003f000H
  0034d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usable_arenas
  00354	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax
  00358	76 1c		 jbe	 SHORT $LN25@PyObject_M
  0035a	41 b8 a0 03 00
	00		 mov	 r8d, 928		; 000003a0H
  00360	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00367	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1PG@EABAAMHH@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
  0036e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00374	33 c0		 xor	 eax, eax
$LN25@PyObject_M:
$LN6@PyObject_M:
$init_pool$20858:

; 929  :             }
; 930  :         init_pool:
; 931  :             /* Frontlink to used pools. */
; 932  :             next = usedpools[size + size]; /* == prev */

  00376	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  0037a	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  0037e	03 c8		 add	 ecx, eax
  00380	8b c1		 mov	 eax, ecx
  00382	8b c0		 mov	 eax, eax
  00384	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:usedpools
  0038b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0038f	48 89 44 24 30	 mov	 QWORD PTR next$[rsp], rax

; 933  :             pool->nextpool = next;

  00394	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  00399	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  0039e	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 934  :             pool->prevpool = next;

  003a2	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  003a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  003ac	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 935  :             next->nextpool = pool;

  003b0	48 8b 44 24 30	 mov	 rax, QWORD PTR next$[rsp]
  003b5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  003ba	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 936  :             next->prevpool = pool;

  003be	48 8b 44 24 30	 mov	 rax, QWORD PTR next$[rsp]
  003c3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  003c8	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 937  :             pool->ref.count = 1;

  003cc	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  003d1	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 938  :             if (pool->szidx == size) {

  003d7	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  003dc	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  003e0	39 48 24	 cmp	 DWORD PTR [rax+36], ecx
  003e3	75 4d		 jne	 SHORT $LN5@PyObject_M

; 939  :                 /* Luckily, this pool last contained blocks
; 940  :                  * of the same size class, so its header
; 941  :                  * and free list are already initialized.
; 942  :                  */
; 943  :                 bp = pool->freeblock;

  003e5	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  003ea	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003ee	48 89 44 24 20	 mov	 QWORD PTR bp$[rsp], rax

; 944  :                 assert(bp != NULL);

  003f3	48 83 7c 24 20
	00		 cmp	 QWORD PTR bp$[rsp], 0
  003f9	75 1c		 jne	 SHORT $LN26@PyObject_M
  003fb	41 b8 b0 03 00
	00		 mov	 r8d, 944		; 000003b0H
  00401	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00408	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BG@CAHEDHEL@?$AAb?$AAp?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0040f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00415	33 c0		 xor	 eax, eax
$LN26@PyObject_M:

; 945  :                 pool->freeblock = *(block **)bp;

  00417	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  0041c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bp$[rsp]
  00421	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00424	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 946  :                 UNLOCK();
; 947  :                 return (void *)bp;

  00428	48 8b 44 24 20	 mov	 rax, QWORD PTR bp$[rsp]
  0042d	e9 a3 02 00 00	 jmp	 $LN18@PyObject_M
$LN5@PyObject_M:

; 948  :             }
; 949  :             /*
; 950  :              * Initialize the pool header, set up the free list to
; 951  :              * contain just the second block, and return the first
; 952  :              * block.
; 953  :              */
; 954  :             pool->szidx = size;

  00432	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  00437	8b 4c 24 28	 mov	 ecx, DWORD PTR size$[rsp]
  0043b	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 955  :             size = INDEX2SIZE(size);

  0043e	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  00442	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [rax*8+8]
  00449	89 44 24 28	 mov	 DWORD PTR size$[rsp], eax

; 956  :             bp = (block *)pool + POOL_OVERHEAD;

  0044d	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  00452	48 83 c0 30	 add	 rax, 48			; 00000030H
  00456	48 89 44 24 20	 mov	 QWORD PTR bp$[rsp], rax

; 957  :             pool->nextoffset = POOL_OVERHEAD + (size << 1);

  0045b	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  0045f	d1 e0		 shl	 eax, 1
  00461	8b c0		 mov	 eax, eax
  00463	48 83 c0 30	 add	 rax, 48			; 00000030H
  00467	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  0046c	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 958  :             pool->maxnextoffset = POOL_SIZE - size;

  0046f	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00474	2b 44 24 28	 sub	 eax, DWORD PTR size$[rsp]
  00478	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  0047d	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 959  :             pool->freeblock = bp + size;

  00480	8b 44 24 28	 mov	 eax, DWORD PTR size$[rsp]
  00484	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bp$[rsp]
  00489	48 03 c8	 add	 rcx, rax
  0048c	48 8b c1	 mov	 rax, rcx
  0048f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  00494	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 960  :             *(block **)(pool->freeblock) = NULL;

  00498	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  0049d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  004a1	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 961  :             UNLOCK();
; 962  :             return (void *)bp;

  004a8	48 8b 44 24 20	 mov	 rax, QWORD PTR bp$[rsp]
  004ad	e9 23 02 00 00	 jmp	 $LN18@PyObject_M
$LN9@PyObject_M:

; 963  :         }
; 964  : 
; 965  :         /* Carve off a new pool. */
; 966  :         assert(usable_arenas->nfreepools > 0);

  004b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  004b9	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  004bd	77 1c		 ja	 SHORT $LN27@PyObject_M
  004bf	41 b8 c6 03 00
	00		 mov	 r8d, 966		; 000003c6H
  004c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  004cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@GIELJHEK@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  004d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004d9	33 c0		 xor	 eax, eax
$LN27@PyObject_M:

; 967  :         assert(usable_arenas->freepools == NULL);

  004db	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  004e2	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  004e7	74 1c		 je	 SHORT $LN28@PyObject_M
  004e9	41 b8 c7 03 00
	00		 mov	 r8d, 967		; 000003c7H
  004ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  004f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@IKPJGJIF@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
  004fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00503	33 c0		 xor	 eax, eax
$LN28@PyObject_M:

; 968  :         pool = (poolp)usable_arenas->pool_address;

  00505	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  0050c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00510	48 89 44 24 38	 mov	 QWORD PTR pool$[rsp], rax

; 969  :         assert((block*)pool <= (block*)usable_arenas->address +
; 970  :                                ARENA_SIZE - POOL_SIZE);

  00515	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  0051c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0051f	48 05 00 f0 03
	00		 add	 rax, 258048		; 0003f000H
  00525	48 39 44 24 38	 cmp	 QWORD PTR pool$[rsp], rax
  0052a	76 1c		 jbe	 SHORT $LN29@PyObject_M
  0052c	41 b8 ca 03 00
	00		 mov	 r8d, 970		; 000003caH
  00532	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00539	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JA@OJBNAKMD@?$AA?$CI?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$CK?$AA?$CJ?$AAp?$AAo?$AAo?$AAl?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?$CK?$AA?$CJ?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa@
  00540	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00546	33 c0		 xor	 eax, eax
$LN29@PyObject_M:

; 971  :         pool->arenaindex = usable_arenas - arenas;

  00548	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR arenas
  0054f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usable_arenas
  00556	48 2b c8	 sub	 rcx, rax
  00559	48 8b c1	 mov	 rax, rcx
  0055c	48 99		 cdq
  0055e	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00563	48 f7 f9	 idiv	 rcx
  00566	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pool$[rsp]
  0056b	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 972  :         assert(&arenas[pool->arenaindex] == usable_arenas);

  0056e	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  00573	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00576	48 6b c0 30	 imul	 rax, 48			; 00000030H
  0057a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  00581	48 03 c8	 add	 rcx, rax
  00584	48 8b c1	 mov	 rax, rcx
  00587	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR usable_arenas
  0058e	74 1c		 je	 SHORT $LN30@PyObject_M
  00590	41 b8 cc 03 00
	00		 mov	 r8d, 972		; 000003ccH
  00596	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  0059d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FG@LBHCAJED@?$AA?$CG?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAp?$AAo?$AAo?$AAl?$AA?9?$AA?$DO?$AAa?$AAr?$AAe?$AAn?$AAa?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAu?$AAs?$AAa@
  005a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005aa	33 c0		 xor	 eax, eax
$LN30@PyObject_M:

; 973  :         pool->szidx = DUMMY_SIZE_IDX;

  005ac	48 8b 44 24 38	 mov	 rax, QWORD PTR pool$[rsp]
  005b1	c7 40 24 ff ff
	00 00		 mov	 DWORD PTR [rax+36], 65535 ; 0000ffffH

; 974  :         usable_arenas->pool_address += POOL_SIZE;

  005b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  005bf	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  005c3	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  005c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usable_arenas
  005d0	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 975  :         --usable_arenas->nfreepools;

  005d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  005db	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  005de	ff c8		 dec	 eax
  005e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usable_arenas
  005e7	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 976  : 
; 977  :         if (usable_arenas->nfreepools == 0) {

  005ea	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  005f1	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  005f5	0f 85 96 00 00
	00		 jne	 $LN4@PyObject_M

; 978  :             assert(usable_arenas->nextarena == NULL ||
; 979  :                    usable_arenas->nextarena->prevarena ==
; 980  :                    usable_arenas);

  005fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  00602	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00607	74 34		 je	 SHORT $LN31@PyObject_M
  00609	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  00610	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00614	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usable_arenas
  0061b	48 39 48 28	 cmp	 QWORD PTR [rax+40], rcx
  0061f	74 1c		 je	 SHORT $LN31@PyObject_M
  00621	41 b8 d4 03 00
	00		 mov	 r8d, 980		; 000003d4H
  00627	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  0062e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1LC@NOICJOPH@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL@
  00635	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0063b	33 c0		 xor	 eax, eax
$LN31@PyObject_M:

; 981  :             /* Unlink the arena:  it is completely allocated. */
; 982  :             usable_arenas = usable_arenas->nextarena;

  0063d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  00644	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00648	48 89 05 00 00
	00 00		 mov	 QWORD PTR usable_arenas, rax

; 983  :             if (usable_arenas != NULL) {

  0064f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR usable_arenas, 0
  00657	74 38		 je	 SHORT $LN3@PyObject_M

; 984  :                 usable_arenas->prevarena = NULL;

  00659	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  00660	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 985  :                 assert(usable_arenas->address != 0);

  00668	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  0066f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00673	75 1c		 jne	 SHORT $LN32@PyObject_M
  00675	41 b8 d9 03 00
	00		 mov	 r8d, 985		; 000003d9H
  0067b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00682	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@IPKFDBGJ@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00689	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0068f	33 c0		 xor	 eax, eax
$LN32@PyObject_M:
$LN3@PyObject_M:
$LN4@PyObject_M:

; 986  :             }
; 987  :         }
; 988  : 
; 989  :         goto init_pool;

  00691	e9 e0 fc ff ff	 jmp	 $init_pool$20858
$LN15@PyObject_M:
$redirect$20836:

; 990  :     }
; 991  : 
; 992  :     /* The small block allocator ends here. */
; 993  : 
; 994  : redirect:
; 995  :     /* Redirect the original request to the underlying (libc) allocator.
; 996  :      * We jump here on bigger requests, on error in the code above (as a
; 997  :      * last chance to serve the request) or when the max memory limit
; 998  :      * has been reached.
; 999  :      */
; 1000 :     if (nbytes == 0)

  00696	48 83 7c 24 60
	00		 cmp	 QWORD PTR nbytes$[rsp], 0
  0069c	75 09		 jne	 SHORT $LN2@PyObject_M

; 1001 :         nbytes = 1;

  0069e	48 c7 44 24 60
	01 00 00 00	 mov	 QWORD PTR nbytes$[rsp], 1
$LN2@PyObject_M:

; 1002 :     {
; 1003 :         void *result = malloc(nbytes);

  006a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR nbytes$[rsp]
  006ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  006b2	48 89 44 24 40	 mov	 QWORD PTR result$20896[rsp], rax

; 1004 :         if (!result) {

  006b7	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$20896[rsp], 0
  006bd	75 11		 jne	 SHORT $LN1@PyObject_M

; 1005 :             LOCK();
; 1006 :             _Py_AllocatedBlocks--;

  006bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_AllocatedBlocks
  006c6	48 ff c8	 dec	 rax
  006c9	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_AllocatedBlocks, rax
$LN1@PyObject_M:

; 1007 :             UNLOCK();
; 1008 :         }
; 1009 :         return result;

  006d0	48 8b 44 24 40	 mov	 rax, QWORD PTR result$20896[rsp]
$LN18@PyObject_M:

; 1010 :     }
; 1011 : }

  006d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  006d9	c3		 ret	 0
PyObject_Malloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FO@GBFDKEBI@?$AAP?$AAO?$AAO?$AAL?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?5?$AA?$CK?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAo?$AAb?$AAj?$AA?9?$AA?$DO?$AAn?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs@ ; `string'
PUBLIC	??_C@_1CO@OEKMPLEO@?$AAa?$AAr?$AAe?$AAn?$AAa?$AAo?$AAb?$AAj?$AA?9?$AA?$DO?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@FGLCAEIO@?$AAu?$AAn?$AAu?$AAs?$AAe?$AAd?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AA_?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@BHLHOJNI@?$AAu?$AAn?$AAu?$AAs?$AAe?$AAd?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AA_?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@KMIDHFNE@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	_PyObject_DebugMallocStats
PUBLIC	??_C@_0BC@HAEBPFMD@PYTHONMALLOCSTATS?$AA@	; `string'
PUBLIC	??_C@_09MEEKLCNL@new_arena?$AA@			; `string'
PUBLIC	??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@ ; `string'
EXTRN	__imp_realloc:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	__imp_getenv:PROC
EXTRN	Py_IgnoreEnvironmentFlag:DWORD
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$new_arena DD imagerel new_arena
	DD	imagerel new_arena+957
	DD	imagerel $unwind$new_arena
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$new_arena DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT ??_C@_1FO@GBFDKEBI@?$AAP?$AAO?$AAO?$AAL?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?5?$AA?$CK?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAo?$AAb?$AAj?$AA?9?$AA?$DO?$AAn?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs@
CONST	SEGMENT
??_C@_1FO@GBFDKEBI@?$AAP?$AAO?$AAO?$AAL?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?5?$AA?$CK?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAo?$AAb?$AAj?$AA?9?$AA?$DO?$AAn?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs@ DB 'P'
	DB	00H, 'O', 00H, 'O', 00H, 'L', 00H, '_', 00H, 'S', 00H, 'I', 00H
	DB	'Z', 00H, 'E', 00H, ' ', 00H, '*', 00H, ' ', 00H, 'a', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'a', 00H, 'o', 00H, 'b', 00H, 'j', 00H
	DB	'-', 00H, '>', 00H, 'n', 00H, 'f', 00H, 'r', 00H, 'e', 00H, 'e'
	DB	00H, 'p', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'A', 00H, 'R', 00H, 'E', 00H, 'N'
	DB	00H, 'A', 00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CO@OEKMPLEO@?$AAa?$AAr?$AAe?$AAn?$AAa?$AAo?$AAb?$AAj?$AA?9?$AA?$DO?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@OEKMPLEO@?$AAa?$AAr?$AAe?$AAn?$AAa?$AAo?$AAb?$AAj?$AA?9?$AA?$DO?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'a'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 'o', 00H, 'b', 00H
	DB	'j', 00H, '-', 00H, '>', 00H, 'a', 00H, 'd', 00H, 'd', 00H, 'r'
	DB	00H, 'e', 00H, 's', 00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@FGLCAEIO@?$AAu?$AAn?$AAu?$AAs?$AAe?$AAd?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AA_?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@FGLCAEIO@?$AAu?$AAn?$AAu?$AAs?$AAe?$AAd?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AA_?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'u'
	DB	00H, 'n', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'd', 00H, '_', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, '_', 00H, 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H
	DB	' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L'
	DB	00H, 'L', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@BHLHOJNI@?$AAu?$AAn?$AAu?$AAs?$AAe?$AAd?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AA_?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@BHLHOJNI@?$AAu?$AAn?$AAu?$AAs?$AAe?$AAd?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AA_?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'u'
	DB	00H, 'n', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'd', 00H, '_', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, '_', 00H, 'o'
	DB	00H, 'b', 00H, 'j', 00H, 'e', 00H, 'c', 00H, 't', 00H, 's', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L'
	DB	00H, 'L', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@KMIDHFNE@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@KMIDHFNE@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'u'
	DB	00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HAEBPFMD@PYTHONMALLOCSTATS?$AA@
CONST	SEGMENT
??_C@_0BC@HAEBPFMD@PYTHONMALLOCSTATS?$AA@ DB 'PYTHONMALLOCSTATS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MEEKLCNL@new_arena?$AA@
CONST	SEGMENT
??_C@_09MEEKLCNL@new_arena?$AA@ DB 'new_arena', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
CONST	SEGMENT
??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@ DB '..\Objects\obmallo'
	DB	'c.c', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT new_arena
_TEXT	SEGMENT
err$ = 32
address$ = 40
excess$ = 48
arenaobj$ = 56
numarenas$20764 = 64
i$20763 = 68
nbytes$20765 = 72
tv73 = 80
tv81 = 88
tv146 = 96
tv164 = 104
new_arena PROC						; COMDAT

; 571  : {

  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 572  :     struct arena_object* arenaobj = NULL;

  00004	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR arenaobj$[rsp], 0

; 573  :     uint excess;        /* number of bytes above pool alignment */
; 574  :     void *address;
; 575  :     int err;
; 576  :     Py_GUARD

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	85 c0		 test	 eax, eax
  00014	74 1c		 je	 SHORT $LN11@new_arena
  00016	45 33 c9	 xor	 r9d, r9d
  00019	41 b8 40 02 00
	00		 mov	 r8d, 576		; 00000240H
  0001f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MEEKLCNL@new_arena?$AA@
  0002d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN11@new_arena:

; 577  : 
; 578  : #ifdef PYMALLOC_DEBUG
; 579  :     if (Py_GETENV("PYTHONMALLOCSTATS"))

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR Py_IgnoreEnvironmentFlag, 0
  00039	74 0b		 je	 SHORT $LN14@new_arena
  0003b	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
  00044	eb 12		 jmp	 SHORT $LN15@new_arena
$LN14@new_arena:
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@HAEBPFMD@PYTHONMALLOCSTATS?$AA@
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getenv
  00053	48 89 44 24 50	 mov	 QWORD PTR tv73[rsp], rax
$LN15@new_arena:
  00058	48 83 7c 24 50
	00		 cmp	 QWORD PTR tv73[rsp], 0
  0005e	74 12		 je	 SHORT $LN10@new_arena

; 580  :         _PyObject_DebugMallocStats(stderr);

  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00066	48 83 c0 60	 add	 rax, 96			; 00000060H
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	e8 00 00 00 00	 call	 _PyObject_DebugMallocStats
$LN10@new_arena:

; 581  : #endif
; 582  :     if (unused_arena_objects == NULL) {

  00072	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR unused_arena_objects, 0
  0007a	0f 85 70 01 00
	00		 jne	 $LN9@new_arena

; 583  :         uint i;
; 584  :         uint numarenas;
; 585  :         size_t nbytes;
; 586  : 
; 587  :         /* Double the number of arena objects on each allocation.
; 588  :          * Note that it's possible for `numarenas` to overflow.
; 589  :          */
; 590  :         numarenas = maxarenas ? maxarenas << 1 : INITIAL_ARENA_OBJECTS;

  00080	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR maxarenas, 0
  00087	74 0e		 je	 SHORT $LN16@new_arena
  00089	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR maxarenas
  0008f	d1 e0		 shl	 eax, 1
  00091	89 44 24 58	 mov	 DWORD PTR tv81[rsp], eax
  00095	eb 08		 jmp	 SHORT $LN17@new_arena
$LN16@new_arena:
  00097	c7 44 24 58 10
	00 00 00	 mov	 DWORD PTR tv81[rsp], 16
$LN17@new_arena:
  0009f	8b 44 24 58	 mov	 eax, DWORD PTR tv81[rsp]
  000a3	89 44 24 40	 mov	 DWORD PTR numarenas$20764[rsp], eax

; 591  :         if (numarenas <= maxarenas)

  000a7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR maxarenas
  000ad	39 44 24 40	 cmp	 DWORD PTR numarenas$20764[rsp], eax
  000b1	77 05		 ja	 SHORT $LN8@new_arena

; 592  :             goto end;                   /* overflow */

  000b3	e9 fb 02 00 00	 jmp	 $end$20767
$LN8@new_arena:

; 593  : #if SIZEOF_SIZE_T <= SIZEOF_INT
; 594  :         if (numarenas > PY_SIZE_MAX / sizeof(*arenas))
; 595  :             goto end;                   /* overflow */
; 596  : #endif
; 597  :         nbytes = numarenas * sizeof(*arenas);

  000b8	8b 44 24 40	 mov	 eax, DWORD PTR numarenas$20764[rsp]
  000bc	48 6b c0 30	 imul	 rax, 48			; 00000030H
  000c0	48 89 44 24 48	 mov	 QWORD PTR nbytes$20765[rsp], rax

; 598  :         arenaobj = (struct arena_object *)realloc(arenas, nbytes);

  000c5	48 8b 54 24 48	 mov	 rdx, QWORD PTR nbytes$20765[rsp]
  000ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000d7	48 89 44 24 38	 mov	 QWORD PTR arenaobj$[rsp], rax

; 599  :         if (arenaobj == NULL)

  000dc	48 83 7c 24 38
	00		 cmp	 QWORD PTR arenaobj$[rsp], 0
  000e2	75 05		 jne	 SHORT $LN7@new_arena

; 600  :             goto end;

  000e4	e9 ca 02 00 00	 jmp	 $end$20767
$LN7@new_arena:

; 601  :         arenas = arenaobj;

  000e9	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  000ee	48 89 05 00 00
	00 00		 mov	 QWORD PTR arenas, rax

; 602  : 
; 603  :         /* We might need to fix pointers that were copied.  However,
; 604  :          * new_arena only gets called when all the pages in the
; 605  :          * previous arenas are full.  Thus, there are *no* pointers
; 606  :          * into the old array. Thus, we don't have to worry about
; 607  :          * invalid pointers.  Just to be sure, some asserts:
; 608  :          */
; 609  :         assert(usable_arenas == NULL);

  000f5	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR usable_arenas, 0
  000fd	74 1c		 je	 SHORT $LN18@new_arena
  000ff	41 b8 61 02 00
	00		 mov	 r8d, 609		; 00000261H
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@KMIDHFNE@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00119	33 c0		 xor	 eax, eax
$LN18@new_arena:

; 610  :         assert(unused_arena_objects == NULL);

  0011b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR unused_arena_objects, 0
  00123	74 1c		 je	 SHORT $LN19@new_arena
  00125	41 b8 62 02 00
	00		 mov	 r8d, 610		; 00000262H
  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@BHLHOJNI@?$AAu?$AAn?$AAu?$AAs?$AAe?$AAd?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AA_?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0013f	33 c0		 xor	 eax, eax
$LN19@new_arena:

; 611  : 
; 612  :         /* Put the new arenas on the unused_arena_objects list. */
; 613  :         for (i = maxarenas; i < numarenas; ++i) {

  00141	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR maxarenas
  00147	89 44 24 44	 mov	 DWORD PTR i$20763[rsp], eax
  0014b	eb 0a		 jmp	 SHORT $LN6@new_arena
$LN5@new_arena:
  0014d	8b 44 24 44	 mov	 eax, DWORD PTR i$20763[rsp]
  00151	ff c0		 inc	 eax
  00153	89 44 24 44	 mov	 DWORD PTR i$20763[rsp], eax
$LN6@new_arena:
  00157	8b 44 24 40	 mov	 eax, DWORD PTR numarenas$20764[rsp]
  0015b	39 44 24 44	 cmp	 DWORD PTR i$20763[rsp], eax
  0015f	73 67		 jae	 SHORT $LN4@new_arena

; 614  :             arenas[i].address = 0;              /* mark as unassociated */

  00161	8b 44 24 44	 mov	 eax, DWORD PTR i$20763[rsp]
  00165	48 6b c0 30	 imul	 rax, 48			; 00000030H
  00169	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  00170	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 615  :             arenas[i].nextarena = i < numarenas - 1 ?
; 616  :                                    &arenas[i+1] : NULL;

  00178	8b 44 24 40	 mov	 eax, DWORD PTR numarenas$20764[rsp]
  0017c	ff c8		 dec	 eax
  0017e	39 44 24 44	 cmp	 DWORD PTR i$20763[rsp], eax
  00182	73 20		 jae	 SHORT $LN20@new_arena
  00184	8b 44 24 44	 mov	 eax, DWORD PTR i$20763[rsp]
  00188	ff c0		 inc	 eax
  0018a	8b c0		 mov	 eax, eax
  0018c	48 6b c0 30	 imul	 rax, 48			; 00000030H
  00190	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  00197	48 03 c8	 add	 rcx, rax
  0019a	48 8b c1	 mov	 rax, rcx
  0019d	48 89 44 24 60	 mov	 QWORD PTR tv146[rsp], rax
  001a2	eb 09		 jmp	 SHORT $LN21@new_arena
$LN20@new_arena:
  001a4	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv146[rsp], 0
$LN21@new_arena:
  001ad	8b 44 24 44	 mov	 eax, DWORD PTR i$20763[rsp]
  001b1	48 6b c0 30	 imul	 rax, 48			; 00000030H
  001b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  001bc	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv146[rsp]
  001c1	48 89 54 01 20	 mov	 QWORD PTR [rcx+rax+32], rdx

; 617  :         }

  001c6	eb 85		 jmp	 SHORT $LN5@new_arena
$LN4@new_arena:

; 618  : 
; 619  :         /* Update globals. */
; 620  :         unused_arena_objects = &arenas[maxarenas];

  001c8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR maxarenas
  001ce	48 6b c0 30	 imul	 rax, 48			; 00000030H
  001d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  001d9	48 03 c8	 add	 rcx, rax
  001dc	48 8b c1	 mov	 rax, rcx
  001df	48 89 05 00 00
	00 00		 mov	 QWORD PTR unused_arena_objects, rax

; 621  :         maxarenas = numarenas;

  001e6	8b 44 24 40	 mov	 eax, DWORD PTR numarenas$20764[rsp]
  001ea	89 05 00 00 00
	00		 mov	 DWORD PTR maxarenas, eax
$LN9@new_arena:

; 622  :     }
; 623  : 
; 624  :     /* Take the next available arena object off the head of the list. */
; 625  :     assert(unused_arena_objects != NULL);

  001f0	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR unused_arena_objects, 0
  001f8	75 1c		 jne	 SHORT $LN22@new_arena
  001fa	41 b8 71 02 00
	00		 mov	 r8d, 625		; 00000271H
  00200	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@FGLCAEIO@?$AAu?$AAn?$AAu?$AAs?$AAe?$AAd?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AA_?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00214	33 c0		 xor	 eax, eax
$LN22@new_arena:

; 626  :     arenaobj = unused_arena_objects;

  00216	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR unused_arena_objects
  0021d	48 89 44 24 38	 mov	 QWORD PTR arenaobj$[rsp], rax

; 627  :     unused_arena_objects = arenaobj->nextarena;

  00222	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  00227	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0022b	48 89 05 00 00
	00 00		 mov	 QWORD PTR unused_arena_objects, rax

; 628  :     assert(arenaobj->address == 0);

  00232	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  00237	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0023b	74 1c		 je	 SHORT $LN23@new_arena
  0023d	41 b8 74 02 00
	00		 mov	 r8d, 628		; 00000274H
  00243	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  0024a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CO@OEKMPLEO@?$AAa?$AAr?$AAe?$AAn?$AAa?$AAo?$AAb?$AAj?$AA?9?$AA?$DO?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00251	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00257	33 c0		 xor	 eax, eax
$LN23@new_arena:

; 629  : #ifdef ARENAS_USE_MMAP
; 630  :     address = mmap(NULL, ARENA_SIZE, PROT_READ|PROT_WRITE,
; 631  :                                    MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
; 632  :     err = (address == MAP_FAILED);
; 633  : #else
; 634  :     address = malloc(ARENA_SIZE);

  00259	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00264	48 89 44 24 28	 mov	 QWORD PTR address$[rsp], rax

; 635  :     err = (address == 0);

  00269	48 83 7c 24 28
	00		 cmp	 QWORD PTR address$[rsp], 0
  0026f	75 0a		 jne	 SHORT $LN24@new_arena
  00271	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv164[rsp], 1
  00279	eb 08		 jmp	 SHORT $LN25@new_arena
$LN24@new_arena:
  0027b	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
$LN25@new_arena:
  00283	8b 44 24 68	 mov	 eax, DWORD PTR tv164[rsp]
  00287	89 44 24 20	 mov	 DWORD PTR err$[rsp], eax

; 636  : #endif
; 637  :     if (err) {

  0028b	83 7c 24 20 00	 cmp	 DWORD PTR err$[rsp], 0
  00290	74 21		 je	 SHORT $LN3@new_arena

; 638  :         /* The allocation failed: return NULL after putting the
; 639  :          * arenaobj back.
; 640  :          */
; 641  :         arenaobj->nextarena = unused_arena_objects;

  00292	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  00297	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unused_arena_objects
  0029e	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 642  :         unused_arena_objects = arenaobj;

  002a2	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  002a7	48 89 05 00 00
	00 00		 mov	 QWORD PTR unused_arena_objects, rax

; 643  :         goto end;

  002ae	e9 00 01 00 00	 jmp	 $end$20767
$LN3@new_arena:

; 644  :     }
; 645  :     arenaobj->address = (uptr)address;

  002b3	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  002b8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR address$[rsp]
  002bd	48 89 08	 mov	 QWORD PTR [rax], rcx

; 646  : 
; 647  :     ++narenas_currently_allocated;

  002c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR narenas_currently_allocated
  002c7	48 ff c0	 inc	 rax
  002ca	48 89 05 00 00
	00 00		 mov	 QWORD PTR narenas_currently_allocated, rax

; 648  :     ++ntimes_arena_allocated;

  002d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ntimes_arena_allocated
  002d8	48 ff c0	 inc	 rax
  002db	48 89 05 00 00
	00 00		 mov	 QWORD PTR ntimes_arena_allocated, rax

; 649  :     if (narenas_currently_allocated > narenas_highwater)

  002e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR narenas_highwater
  002e9	48 39 05 00 00
	00 00		 cmp	 QWORD PTR narenas_currently_allocated, rax
  002f0	76 0e		 jbe	 SHORT $LN2@new_arena

; 650  :         narenas_highwater = narenas_currently_allocated;

  002f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR narenas_currently_allocated
  002f9	48 89 05 00 00
	00 00		 mov	 QWORD PTR narenas_highwater, rax
$LN2@new_arena:

; 651  :     arenaobj->freepools = NULL;

  00300	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  00305	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 652  :     /* pool_address <- first pool-aligned address in the arena
; 653  :        nfreepools <- number of whole pools that fit after alignment */
; 654  :     arenaobj->pool_address = (block*)arenaobj->address;

  0030d	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  00312	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arenaobj$[rsp]
  00317	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0031a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 655  :     arenaobj->nfreepools = ARENA_SIZE / POOL_SIZE;

  0031e	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  00323	c7 40 10 40 00
	00 00		 mov	 DWORD PTR [rax+16], 64	; 00000040H

; 656  :     assert(POOL_SIZE * arenaobj->nfreepools == ARENA_SIZE);

  0032a	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  0032f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00332	69 c0 00 10 00
	00		 imul	 eax, 4096		; 00001000H
  00338	3d 00 00 04 00	 cmp	 eax, 262144		; 00040000H
  0033d	74 1c		 je	 SHORT $LN26@new_arena
  0033f	41 b8 90 02 00
	00		 mov	 r8d, 656		; 00000290H
  00345	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  0034c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FO@GBFDKEBI@?$AAP?$AAO?$AAO?$AAL?$AA_?$AAS?$AAI?$AAZ?$AAE?$AA?5?$AA?$CK?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAo?$AAb?$AAj?$AA?9?$AA?$DO?$AAn?$AAf?$AAr?$AAe?$AAe?$AAp?$AAo?$AAo?$AAl?$AAs@
  00353	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00359	33 c0		 xor	 eax, eax
$LN26@new_arena:

; 657  :     excess = (uint)(arenaobj->address & POOL_SIZE_MASK);

  0035b	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  00360	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00363	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00369	89 44 24 30	 mov	 DWORD PTR excess$[rsp], eax

; 658  :     if (excess != 0) {

  0036d	83 7c 24 30 00	 cmp	 DWORD PTR excess$[rsp], 0
  00372	74 2f		 je	 SHORT $LN1@new_arena

; 659  :         --arenaobj->nfreepools;

  00374	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  00379	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0037c	ff c8		 dec	 eax
  0037e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arenaobj$[rsp]
  00383	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 660  :         arenaobj->pool_address += POOL_SIZE - excess;

  00386	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  0038b	2b 44 24 30	 sub	 eax, DWORD PTR excess$[rsp]
  0038f	8b c0		 mov	 eax, eax
  00391	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arenaobj$[rsp]
  00396	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  0039a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arenaobj$[rsp]
  0039f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN1@new_arena:

; 661  :     }
; 662  :     arenaobj->ntotalpools = arenaobj->nfreepools;

  003a3	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]
  003a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR arenaobj$[rsp]
  003ad	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  003b0	89 48 14	 mov	 DWORD PTR [rax+20], ecx
$end$20767:

; 663  : 
; 664  : end:
; 665  :     return arenaobj;

  003b3	48 8b 44 24 38	 mov	 rax, QWORD PTR arenaobj$[rsp]

; 666  : }

  003b8	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003bc	c3		 ret	 0
new_arena ENDP
_TEXT	ENDS
PUBLIC	??_C@_1KC@NBJOBBIJ@?$AA?$CI?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv@ ; `string'
PUBLIC	??_C@_1HA@LGLIEEDD@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx@ ; `string'
PUBLIC	??_C@_1HA@GLHNJBIA@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAf?$AA?5?$AA?$DO?$AA?5?$AAa?$AAo@ ; `string'
PUBLIC	??_C@_1HC@LPCILHKJ@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAa@ ; `string'
PUBLIC	??_C@_1FE@MDHFACC@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO@ ; `string'
PUBLIC	??_C@_1IG@GJKIJKLB@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1CI@BEKINLCN@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DO@EOHAPIIG@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DO@JACEJAIO@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@ ; `string'
PUBLIC	??_C@_1GK@PJGKOKMF@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_@ ; `string'
PUBLIC	??_C@_1GM@HPPIECFK@?$AAa?$AAo?$AA?5?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe@ ; `string'
PUBLIC	??_C@_1GK@PLJGLHGG@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1CI@ECLFLOHI@?$AAp?$AAo?$AAo?$AAl?$AA?9?$AA?$DO?$AAr?$AAe?$AAf?$AA?4?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	Py_ADDRESS_IN_RANGE
PUBLIC	PyObject_Free
EXTRN	__imp_free:PROC
EXTRN	_PxMem_Free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Free DD imagerel $LN38
	DD	imagerel $LN38+1807
	DD	imagerel $unwind$PyObject_Free
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Free DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_1KC@NBJOBBIJ@?$AA?$CI?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv@
CONST	SEGMENT
??_C@_1KC@NBJOBBIJ@?$AA?$CI?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv@ DB '('
	DB	00H, 'u', 00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	'_', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'a', 00H, 'o', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'a', 00H, 'o', 00H, '-'
	DB	00H, '>', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ')', 00H
	DB	' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'a', 00H, 'o', 00H, '-'
	DB	00H, '>', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, '-', 00H, '>', 00H, 'n'
	DB	00H, 'e', 00H, 'x', 00H, 't', 00H, 'a', 00H, 'r', 00H, 'e', 00H
	DB	'n', 00H, 'a', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'a'
	DB	00H, 'o', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@LGLIEEDD@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx@
CONST	SEGMENT
??_C@_1HA@LGLIEEDD@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx@ DB 'a'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'a', 00H, 'o'
	DB	00H, '-', 00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H, 't', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, '-', 00H, '>'
	DB	00H, 'p', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'a', 00H, 'r', 00H
	DB	'e', 00H, 'n', 00H, 'a', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'a', 00H, 'o', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@GLHNJBIA@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAf?$AA?5?$AA?$DO?$AA?5?$AAa?$AAo@
CONST	SEGMENT
??_C@_1HA@GLHNJBIA@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAf?$AA?5?$AA?$DO?$AA?5?$AAa?$AAo@ DB 'a'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'p', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'n', 00H, 'f'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, 'a', 00H, 'o', 00H, '-', 00H
	DB	'>', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'a', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'a', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'f', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'p', 00H, 'o', 00H, 'o'
	DB	00H, 'l', 00H, 's', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1HC@LPCILHKJ@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAa@
CONST	SEGMENT
??_C@_1HC@LPCILHKJ@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAa@ DB 'a'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'n', 00H, 'f'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, 'a', 00H, 'o', 00H
	DB	'-', 00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'a'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, '-', 00H, '>', 00H
	DB	'n', 00H, 'f', 00H, 'r', 00H, 'e', 00H, 'e', 00H, 'p', 00H, 'o'
	DB	00H, 'o', 00H, 'l', 00H, 's', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FE@MDHFACC@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO@
CONST	SEGMENT
??_C@_1FE@MDHFACC@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO@ DB 'a'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'p', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, '-'
	DB	00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'a', 00H, 'o', 00H, '-', 00H, '>', 00H, 'n', 00H
	DB	'e', 00H, 'x', 00H, 't', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n'
	DB	00H, 'a', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1IG@GJKIJKLB@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe@
CONST	SEGMENT
??_C@_1IG@GJKIJKLB@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe@ DB 'a'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'a', 00H, 'o'
	DB	00H, '-', 00H, '>', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 'v', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, 'a', 00H, 'o', 00H, '-', 00H, '>', 00H
	DB	'n', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'a', 00H, 'r', 00H, 'e'
	DB	00H, 'n', 00H, 'a', 00H, '-', 00H, '>', 00H, 'p', 00H, 'r', 00H
	DB	'e', 00H, 'v', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@BEKINLCN@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@BEKINLCN@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@ DB 'u'
	DB	00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'a', 00H, 'o', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@EOHAPIIG@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@EOHAPIIG@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@ DB 'a'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, '-'
	DB	00H, '>', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 'v', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'a', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DO@JACEJAIO@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@
CONST	SEGMENT
??_C@_1DO@JACEJAIO@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@ DB 'a'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'p', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, '-'
	DB	00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H, 't', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, 'a', 00H, 'o', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1GK@PJGKOKMF@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_@
CONST	SEGMENT
??_C@_1GK@PJGKOKMF@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_@ DB 'u'
	DB	00H, 's', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '_', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'u', 00H, 's'
	DB	00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H, '_', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, '-', 00H, '>'
	DB	00H, 'a', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1GM@HPPIECFK@?$AAa?$AAo?$AA?5?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe@
CONST	SEGMENT
??_C@_1GM@HPPIECFK@?$AAa?$AAo?$AA?5?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe@ DB 'a'
	DB	00H, 'o', 00H, ' ', 00H, '-', 00H, '>', 00H, 'n', 00H, 'e', 00H
	DB	'x', 00H, 't', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H
	DB	'L', 00H, 'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'a'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'n', 00H, 'e', 00H, 'x', 00H
	DB	't', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, '-'
	DB	00H, '>', 00H, 'a', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1GK@PLJGLHGG@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe@
CONST	SEGMENT
??_C@_1GK@PLJGLHGG@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe@ DB 'a'
	DB	00H, 'o', 00H, '-', 00H, '>', 00H, 'p', 00H, 'r', 00H, 'e', 00H
	DB	'v', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'a', 00H, 'o'
	DB	00H, '-', 00H, '>', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 'v', 00H
	DB	'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, '-', 00H, '>'
	DB	00H, 'a', 00H, 'd', 00H, 'd', 00H, 'r', 00H, 'e', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@ECLFLOHI@?$AAp?$AAo?$AAo?$AAl?$AA?9?$AA?$DO?$AAr?$AAe?$AAf?$AA?4?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@ECLFLOHI@?$AAp?$AAo?$AAo?$AAl?$AA?9?$AA?$DO?$AAr?$AAe?$AAf?$AA?4?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@ DB 'p'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, '-', 00H, '>', 00H, 'r', 00H
	DB	'e', 00H, 'f', 00H, '.', 00H, 'c', 00H, 'o', 00H, 'u', 00H, 'n'
	DB	00H, 't', 00H, ' ', 00H, '>', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_Free
_TEXT	SEGMENT
prev$ = 32
lastfree$ = 40
size$ = 48
next$ = 56
pool$ = 64
ao$20919 = 72
nf$20920 = 80
tv129 = 84
p$ = 112
PyObject_Free PROC					; COMDAT

; 1018 : {

$LN38:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1019 :     poolp pool;
; 1020 :     block *lastfree;
; 1021 :     poolp next, prev;
; 1022 :     uint size;
; 1023 : #ifndef Py_USING_MEMORY_DEBUGGER
; 1024 :     uint arenaindex_temp;
; 1025 : #endif
; 1026 :     Px_RETURN_VOID(_PxMem_Free(p))

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0f		 je	 SHORT $LN18@PyObject_F
  00012	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  00017	e8 00 00 00 00	 call	 _PxMem_Free
  0001c	e9 e9 06 00 00	 jmp	 $LN19@PyObject_F
$LN18@PyObject_F:

; 1027 : 
; 1028 :     if (p == NULL)      /* free(NULL) has no effect */

  00021	48 83 7c 24 70
	00		 cmp	 QWORD PTR p$[rsp], 0
  00027	75 05		 jne	 SHORT $LN17@PyObject_F

; 1029 :         return;

  00029	e9 dc 06 00 00	 jmp	 $LN19@PyObject_F
$LN17@PyObject_F:

; 1030 : 
; 1031 :     _Py_AllocatedBlocks--;

  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_AllocatedBlocks
  00035	48 ff c8	 dec	 rax
  00038	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_AllocatedBlocks, rax

; 1032 : 
; 1033 : #ifdef WITH_VALGRIND
; 1034 :     if (UNLIKELY(running_on_valgrind > 0))
; 1035 :         goto redirect;
; 1036 : #endif
; 1037 : 
; 1038 :     pool = POOL_ADDR(p);

  0003f	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  00044	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0004a	48 89 44 24 40	 mov	 QWORD PTR pool$[rsp], rax

; 1039 :     if (Py_ADDRESS_IN_RANGE(p, pool)) {

  0004f	48 8b 54 24 40	 mov	 rdx, QWORD PTR pool$[rsp]
  00054	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  00059	e8 00 00 00 00	 call	 Py_ADDRESS_IN_RANGE
  0005e	85 c0		 test	 eax, eax
  00060	0f 84 99 06 00
	00		 je	 $LN16@PyObject_F

; 1040 :         /* We allocated this address. */
; 1041 :         LOCK();
; 1042 :         /* Link p to the start of the pool's freeblock list.  Since
; 1043 :          * the pool had at least the p block outstanding, the pool
; 1044 :          * wasn't empty (so it's already in a usedpools[] list, or
; 1045 :          * was full and is in no list -- it's not in the freeblocks
; 1046 :          * list in any case).
; 1047 :          */
; 1048 :         assert(pool->ref.count > 0);            /* else it was empty */

  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  0006b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0006e	77 1c		 ja	 SHORT $LN21@PyObject_F
  00070	41 b8 18 04 00
	00		 mov	 r8d, 1048		; 00000418H
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@ECLFLOHI@?$AAp?$AAo?$AAo?$AAl?$AA?9?$AA?$DO?$AAr?$AAe?$AAf?$AA?4?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008a	33 c0		 xor	 eax, eax
$LN21@PyObject_F:

; 1049 :         *(block **)p = lastfree = pool->freeblock;

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  00091	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00095	48 89 44 24 28	 mov	 QWORD PTR lastfree$[rsp], rax
  0009a	48 8b 44 24 70	 mov	 rax, QWORD PTR p$[rsp]
  0009f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lastfree$[rsp]
  000a4	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1050 :         pool->freeblock = (block *)p;

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  000ac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  000b1	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1051 :         if (lastfree) {

  000b5	48 83 7c 24 28
	00		 cmp	 QWORD PTR lastfree$[rsp], 0
  000bb	0f 84 96 05 00
	00		 je	 $LN15@PyObject_F

; 1052 :             struct arena_object* ao;
; 1053 :             uint nf;  /* ao->nfreepools */
; 1054 : 
; 1055 :             /* freeblock wasn't NULL, so the pool wasn't full,
; 1056 :              * and the pool is in a usedpools[] list.
; 1057 :              */
; 1058 :             if (--pool->ref.count != 0) {

  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  000c6	8b 00		 mov	 eax, DWORD PTR [rax]
  000c8	ff c8		 dec	 eax
  000ca	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pool$[rsp]
  000cf	89 01		 mov	 DWORD PTR [rcx], eax
  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  000d6	83 38 00	 cmp	 DWORD PTR [rax], 0
  000d9	74 05		 je	 SHORT $LN14@PyObject_F

; 1059 :                 /* pool isn't empty:  leave it in usedpools */
; 1060 :                 UNLOCK();
; 1061 :                 return;

  000db	e9 2a 06 00 00	 jmp	 $LN19@PyObject_F
$LN14@PyObject_F:

; 1062 :             }
; 1063 :             /* Pool is now empty:  unlink from usedpools, and
; 1064 :              * link to the front of freepools.  This ensures that
; 1065 :              * previously freed pools will be allocated later
; 1066 :              * (being not referenced, they are perhaps paged out).
; 1067 :              */
; 1068 :             next = pool->nextpool;

  000e0	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  000e5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000e9	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 1069 :             prev = pool->prevpool;

  000ee	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  000f3	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000f7	48 89 44 24 20	 mov	 QWORD PTR prev$[rsp], rax

; 1070 :             next->prevpool = prev;

  000fc	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  00101	48 8b 4c 24 20	 mov	 rcx, QWORD PTR prev$[rsp]
  00106	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1071 :             prev->nextpool = next;

  0010a	48 8b 44 24 20	 mov	 rax, QWORD PTR prev$[rsp]
  0010f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  00114	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1072 : 
; 1073 :             /* Link the pool to freepools.  This is a singly-linked
; 1074 :              * list, and pool->prevpool isn't used there.
; 1075 :              */
; 1076 :             ao = &arenas[pool->arenaindex];

  00118	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  0011d	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00120	48 6b c0 30	 imul	 rax, 48			; 00000030H
  00124	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  0012b	48 03 c8	 add	 rcx, rax
  0012e	48 8b c1	 mov	 rax, rcx
  00131	48 89 44 24 48	 mov	 QWORD PTR ao$20919[rsp], rax

; 1077 :             pool->nextpool = ao->freepools;

  00136	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  0013b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  00140	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00144	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1078 :             ao->freepools = pool;

  00148	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0014d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pool$[rsp]
  00152	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1079 :             nf = ++ao->nfreepools;

  00156	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0015b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0015e	ff c0		 inc	 eax
  00160	89 44 24 54	 mov	 DWORD PTR tv129[rsp], eax
  00164	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00169	8b 4c 24 54	 mov	 ecx, DWORD PTR tv129[rsp]
  0016d	89 48 10	 mov	 DWORD PTR [rax+16], ecx
  00170	8b 44 24 54	 mov	 eax, DWORD PTR tv129[rsp]
  00174	89 44 24 50	 mov	 DWORD PTR nf$20920[rsp], eax

; 1080 : 
; 1081 :             /* All the rest is arena management.  We just freed
; 1082 :              * a pool, and there are 4 cases for arena mgmt:
; 1083 :              * 1. If all the pools are free, return the arena to
; 1084 :              *    the system free().
; 1085 :              * 2. If this is the only free pool in the arena,
; 1086 :              *    add the arena back to the `usable_arenas` list.
; 1087 :              * 3. If the "next" arena has a smaller count of free
; 1088 :              *    pools, we have to "slide this arena right" to
; 1089 :              *    restore that usable_arenas is sorted in order of
; 1090 :              *    nfreepools.
; 1091 :              * 4. Else there's nothing more to do.
; 1092 :              */
; 1093 :             if (nf == ao->ntotalpools) {

  00178	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0017d	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00180	39 44 24 50	 cmp	 DWORD PTR nf$20920[rsp], eax
  00184	0f 85 a3 01 00
	00		 jne	 $LN13@PyObject_F

; 1094 :                 /* Case 1.  First unlink ao from usable_arenas.
; 1095 :                  */
; 1096 :                 assert(ao->prevarena == NULL ||
; 1097 :                        ao->prevarena->address != 0);

  0018a	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0018f	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00194	74 2b		 je	 SHORT $LN22@PyObject_F
  00196	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0019b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0019f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001a3	75 1c		 jne	 SHORT $LN22@PyObject_F
  001a5	41 b8 49 04 00
	00		 mov	 r8d, 1097		; 00000449H
  001ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GK@PLJGLHGG@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe@
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001bf	33 c0		 xor	 eax, eax
$LN22@PyObject_F:

; 1098 :                 assert(ao ->nextarena == NULL ||
; 1099 :                        ao->nextarena->address != 0);

  001c1	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  001c6	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  001cb	74 2b		 je	 SHORT $LN23@PyObject_F
  001cd	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  001d2	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  001d6	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001da	75 1c		 jne	 SHORT $LN23@PyObject_F
  001dc	41 b8 4b 04 00
	00		 mov	 r8d, 1099		; 0000044bH
  001e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GM@HPPIECFK@?$AAa?$AAo?$AA?5?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe@
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001f6	33 c0		 xor	 eax, eax
$LN23@PyObject_F:

; 1100 : 
; 1101 :                 /* Fix the pointer in the prevarena, or the
; 1102 :                  * usable_arenas pointer.
; 1103 :                  */
; 1104 :                 if (ao->prevarena == NULL) {

  001f8	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  001fd	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00202	75 45		 jne	 SHORT $LN12@PyObject_F

; 1105 :                     usable_arenas = ao->nextarena;

  00204	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00209	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0020d	48 89 05 00 00
	00 00		 mov	 QWORD PTR usable_arenas, rax

; 1106 :                     assert(usable_arenas == NULL ||
; 1107 :                            usable_arenas->address != 0);

  00214	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR usable_arenas, 0
  0021c	74 29		 je	 SHORT $LN24@PyObject_F
  0021e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  00225	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00229	75 1c		 jne	 SHORT $LN24@PyObject_F
  0022b	41 b8 53 04 00
	00		 mov	 r8d, 1107		; 00000453H
  00231	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00238	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1GK@PJGKOKMF@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_@
  0023f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00245	33 c0		 xor	 eax, eax
$LN24@PyObject_F:

; 1108 :                 }
; 1109 :                 else {

  00247	eb 46		 jmp	 SHORT $LN11@PyObject_F
$LN12@PyObject_F:

; 1110 :                     assert(ao->prevarena->nextarena == ao);

  00249	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0024e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00252	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  00257	48 39 48 20	 cmp	 QWORD PTR [rax+32], rcx
  0025b	74 1c		 je	 SHORT $LN25@PyObject_F
  0025d	41 b8 56 04 00
	00		 mov	 r8d, 1110		; 00000456H
  00263	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  0026a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@JACEJAIO@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@
  00271	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00277	33 c0		 xor	 eax, eax
$LN25@PyObject_F:

; 1111 :                     ao->prevarena->nextarena =
; 1112 :                         ao->nextarena;

  00279	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0027e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00282	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  00287	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0028b	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
$LN11@PyObject_F:

; 1113 :                 }
; 1114 :                 /* Fix the pointer in the nextarena. */
; 1115 :                 if (ao->nextarena != NULL) {

  0028f	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00294	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00299	74 46		 je	 SHORT $LN10@PyObject_F

; 1116 :                     assert(ao->nextarena->prevarena == ao);

  0029b	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  002a0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002a4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  002a9	48 39 48 28	 cmp	 QWORD PTR [rax+40], rcx
  002ad	74 1c		 je	 SHORT $LN26@PyObject_F
  002af	41 b8 5c 04 00
	00		 mov	 r8d, 1116		; 0000045cH
  002b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  002bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@EOHAPIIG@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@
  002c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002c9	33 c0		 xor	 eax, eax
$LN26@PyObject_F:

; 1117 :                     ao->nextarena->prevarena =
; 1118 :                         ao->prevarena;

  002cb	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  002d0	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  002d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  002d9	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  002dd	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
$LN10@PyObject_F:

; 1119 :                 }
; 1120 :                 /* Record that this arena_object slot is
; 1121 :                  * available to be reused.
; 1122 :                  */
; 1123 :                 ao->nextarena = unused_arena_objects;

  002e1	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  002e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR unused_arena_objects
  002ed	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1124 :                 unused_arena_objects = ao;

  002f1	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  002f6	48 89 05 00 00
	00 00		 mov	 QWORD PTR unused_arena_objects, rax

; 1125 : 
; 1126 :                 /* Free the entire arena. */
; 1127 : #ifdef ARENAS_USE_MMAP
; 1128 :                 munmap((void *)ao->address, ARENA_SIZE);
; 1129 : #else
; 1130 :                 free((void *)ao->address);

  002fd	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00302	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1131 : #endif
; 1132 :                 ao->address = 0;                        /* mark unassociated */

  0030b	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00310	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1133 :                 --narenas_currently_allocated;

  00317	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR narenas_currently_allocated
  0031e	48 ff c8	 dec	 rax
  00321	48 89 05 00 00
	00 00		 mov	 QWORD PTR narenas_currently_allocated, rax

; 1134 : 
; 1135 :                 UNLOCK();
; 1136 :                 return;

  00328	e9 dd 03 00 00	 jmp	 $LN19@PyObject_F
$LN13@PyObject_F:

; 1137 :             }
; 1138 :             if (nf == 1) {

  0032d	83 7c 24 50 01	 cmp	 DWORD PTR nf$20920[rsp], 1
  00332	75 71		 jne	 SHORT $LN9@PyObject_F

; 1139 :                 /* Case 2.  Put ao at the head of
; 1140 :                  * usable_arenas.  Note that because
; 1141 :                  * ao->nfreepools was 0 before, ao isn't
; 1142 :                  * currently on the usable_arenas list.
; 1143 :                  */
; 1144 :                 ao->nextarena = usable_arenas;

  00334	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00339	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR usable_arenas
  00340	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1145 :                 ao->prevarena = NULL;

  00344	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00349	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 1146 :                 if (usable_arenas)

  00351	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR usable_arenas, 0
  00359	74 10		 je	 SHORT $LN8@PyObject_F

; 1147 :                     usable_arenas->prevarena = ao;

  0035b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  00362	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  00367	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
$LN8@PyObject_F:

; 1148 :                 usable_arenas = ao;

  0036b	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00370	48 89 05 00 00
	00 00		 mov	 QWORD PTR usable_arenas, rax

; 1149 :                 assert(usable_arenas->address != 0);

  00377	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR usable_arenas
  0037e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00382	75 1c		 jne	 SHORT $LN27@PyObject_F
  00384	41 b8 7d 04 00
	00		 mov	 r8d, 1149		; 0000047dH
  0038a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00391	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@IPKFDBGJ@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?9?$AA?$DO?$AAa?$AAd?$AAd?$AAr?$AAe?$AAs?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0039e	33 c0		 xor	 eax, eax
$LN27@PyObject_F:

; 1150 : 
; 1151 :                 UNLOCK();
; 1152 :                 return;

  003a0	e9 65 03 00 00	 jmp	 $LN19@PyObject_F
$LN9@PyObject_F:

; 1153 :             }
; 1154 :             /* If this arena is now out of order, we need to keep
; 1155 :              * the list sorted.  The list is kept sorted so that
; 1156 :              * the "most full" arenas are used first, which allows
; 1157 :              * the nearly empty arenas to be completely freed.  In
; 1158 :              * a few un-scientific tests, it seems like this
; 1159 :              * approach allowed a lot more memory to be freed.
; 1160 :              */
; 1161 :             if (ao->nextarena == NULL ||
; 1162 :                          nf <= ao->nextarena->nfreepools) {

  003a5	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  003aa	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  003af	74 12		 je	 SHORT $LN6@PyObject_F
  003b1	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  003b6	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  003ba	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  003bd	39 44 24 50	 cmp	 DWORD PTR nf$20920[rsp], eax
  003c1	77 05		 ja	 SHORT $LN7@PyObject_F
$LN6@PyObject_F:

; 1163 :                 /* Case 4.  Nothing to do. */
; 1164 :                 UNLOCK();
; 1165 :                 return;

  003c3	e9 42 03 00 00	 jmp	 $LN19@PyObject_F
$LN7@PyObject_F:

; 1166 :             }
; 1167 :             /* Case 3:  We have to move the arena towards the end
; 1168 :              * of the list, because it has more free pools than
; 1169 :              * the arena to its right.
; 1170 :              * First unlink ao from usable_arenas.
; 1171 :              */
; 1172 :             if (ao->prevarena != NULL) {

  003c8	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  003cd	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  003d2	74 48		 je	 SHORT $LN5@PyObject_F

; 1173 :                 /* ao isn't at the head of the list */
; 1174 :                 assert(ao->prevarena->nextarena == ao);

  003d4	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  003d9	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  003dd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  003e2	48 39 48 20	 cmp	 QWORD PTR [rax+32], rcx
  003e6	74 1c		 je	 SHORT $LN28@PyObject_F
  003e8	41 b8 96 04 00
	00		 mov	 r8d, 1174		; 00000496H
  003ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  003f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DO@JACEJAIO@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@
  003fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00402	33 c0		 xor	 eax, eax
$LN28@PyObject_F:

; 1175 :                 ao->prevarena->nextarena = ao->nextarena;

  00404	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00409	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0040d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  00412	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00416	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1176 :             }
; 1177 :             else {

  0041a	eb 3a		 jmp	 SHORT $LN4@PyObject_F
$LN5@PyObject_F:

; 1178 :                 /* ao is at the head of the list */
; 1179 :                 assert(usable_arenas == ao);

  0041c	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00421	48 39 05 00 00
	00 00		 cmp	 QWORD PTR usable_arenas, rax
  00428	74 1c		 je	 SHORT $LN29@PyObject_F
  0042a	41 b8 9b 04 00
	00		 mov	 r8d, 1179		; 0000049bH
  00430	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00437	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@BEKINLCN@?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?$AA@
  0043e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00444	33 c0		 xor	 eax, eax
$LN29@PyObject_F:

; 1180 :                 usable_arenas = ao->nextarena;

  00446	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0044b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0044f	48 89 05 00 00
	00 00		 mov	 QWORD PTR usable_arenas, rax
$LN4@PyObject_F:

; 1181 :             }
; 1182 :             ao->nextarena->prevarena = ao->prevarena;

  00456	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0045b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0045f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  00464	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00468	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
$LN3@PyObject_F:

; 1183 : 
; 1184 :             /* Locate the new insertion point by iterating over
; 1185 :              * the list, using our nextarena pointer.
; 1186 :              */
; 1187 :             while (ao->nextarena != NULL &&
; 1188 :                             nf > ao->nextarena->nfreepools) {

  0046c	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00471	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00476	74 3c		 je	 SHORT $LN2@PyObject_F
  00478	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0047d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00481	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00484	39 44 24 50	 cmp	 DWORD PTR nf$20920[rsp], eax
  00488	76 2a		 jbe	 SHORT $LN2@PyObject_F

; 1189 :                 ao->prevarena = ao->nextarena;

  0048a	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0048f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  00494	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00498	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1190 :                 ao->nextarena = ao->nextarena->nextarena;

  0049c	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  004a1	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  004a5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  004aa	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  004ae	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1191 :             }

  004b2	eb b8		 jmp	 SHORT $LN3@PyObject_F
$LN2@PyObject_F:

; 1192 : 
; 1193 :             /* Insert ao at this point. */
; 1194 :             assert(ao->nextarena == NULL ||
; 1195 :                 ao->prevarena == ao->nextarena->prevarena);

  004b4	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  004b9	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  004be	74 34		 je	 SHORT $LN30@PyObject_F
  004c0	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  004c5	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  004c9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  004ce	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  004d2	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  004d6	74 1c		 je	 SHORT $LN30@PyObject_F
  004d8	41 b8 ab 04 00
	00		 mov	 r8d, 1195		; 000004abH
  004de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  004e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1IG@GJKIJKLB@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe@
  004ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004f2	33 c0		 xor	 eax, eax
$LN30@PyObject_F:

; 1196 :             assert(ao->prevarena->nextarena == ao->nextarena);

  004f4	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  004f9	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  004fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  00502	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00506	48 39 48 20	 cmp	 QWORD PTR [rax+32], rcx
  0050a	74 1c		 je	 SHORT $LN31@PyObject_F
  0050c	41 b8 ac 04 00
	00		 mov	 r8d, 1196		; 000004acH
  00512	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00519	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FE@MDHFACC@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO@
  00520	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00526	33 c0		 xor	 eax, eax
$LN31@PyObject_F:

; 1197 : 
; 1198 :             ao->prevarena->nextarena = ao;

  00528	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0052d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00531	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  00536	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1199 :             if (ao->nextarena != NULL)

  0053a	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0053f	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00544	74 12		 je	 SHORT $LN1@PyObject_F

; 1200 :                 ao->nextarena->prevarena = ao;

  00546	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0054b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0054f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  00554	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
$LN1@PyObject_F:

; 1201 : 
; 1202 :             /* Verify that the swaps worked. */
; 1203 :             assert(ao->nextarena == NULL ||
; 1204 :                       nf <= ao->nextarena->nfreepools);

  00558	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0055d	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00562	74 2e		 je	 SHORT $LN32@PyObject_F
  00564	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00569	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0056d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00570	39 44 24 50	 cmp	 DWORD PTR nf$20920[rsp], eax
  00574	76 1c		 jbe	 SHORT $LN32@PyObject_F
  00576	41 b8 b4 04 00
	00		 mov	 r8d, 1204		; 000004b4H
  0057c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00583	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HC@LPCILHKJ@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAf?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAa@
  0058a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00590	33 c0		 xor	 eax, eax
$LN32@PyObject_F:

; 1205 :             assert(ao->prevarena == NULL ||
; 1206 :                       nf > ao->prevarena->nfreepools);

  00592	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00597	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0059c	74 2e		 je	 SHORT $LN33@PyObject_F
  0059e	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  005a3	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  005a7	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  005aa	39 44 24 50	 cmp	 DWORD PTR nf$20920[rsp], eax
  005ae	77 1c		 ja	 SHORT $LN33@PyObject_F
  005b0	41 b8 b6 04 00
	00		 mov	 r8d, 1206		; 000004b6H
  005b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  005bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@GLHNJBIA@?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAn?$AAf?$AA?5?$AA?$DO?$AA?5?$AAa?$AAo@
  005c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  005ca	33 c0		 xor	 eax, eax
$LN33@PyObject_F:

; 1207 :             assert(ao->nextarena == NULL ||
; 1208 :                 ao->nextarena->prevarena == ao);

  005cc	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  005d1	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  005d6	74 30		 je	 SHORT $LN34@PyObject_F
  005d8	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  005dd	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  005e1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  005e6	48 39 48 28	 cmp	 QWORD PTR [rax+40], rcx
  005ea	74 1c		 je	 SHORT $LN34@PyObject_F
  005ec	41 b8 b8 04 00
	00		 mov	 r8d, 1208		; 000004b8H
  005f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  005f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1HA@LGLIEEDD@?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAa?$AAr?$AAe?$AAn?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx@
  00600	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00606	33 c0		 xor	 eax, eax
$LN34@PyObject_F:

; 1209 :             assert((usable_arenas == ao &&
; 1210 :                 ao->prevarena == NULL) ||
; 1211 :                 ao->prevarena->nextarena == ao);

  00608	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0060d	48 39 05 00 00
	00 00		 cmp	 QWORD PTR usable_arenas, rax
  00614	75 0c		 jne	 SHORT $LN35@PyObject_F
  00616	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  0061b	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00620	74 30		 je	 SHORT $LN36@PyObject_F
$LN35@PyObject_F:
  00622	48 8b 44 24 48	 mov	 rax, QWORD PTR ao$20919[rsp]
  00627	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0062b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ao$20919[rsp]
  00630	48 39 48 20	 cmp	 QWORD PTR [rax+32], rcx
  00634	74 1c		 je	 SHORT $LN36@PyObject_F
  00636	41 b8 bb 04 00
	00		 mov	 r8d, 1211		; 000004bbH
  0063c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00643	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1KC@NBJOBBIJ@?$AA?$CI?$AAu?$AAs?$AAa?$AAb?$AAl?$AAe?$AA_?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAa?$AAo?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAa?$AAo?$AA?9?$AA?$DO?$AAp?$AAr?$AAe?$AAv@
  0064a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00650	33 c0		 xor	 eax, eax
$LN36@PyObject_F:

; 1212 : 
; 1213 :             UNLOCK();
; 1214 :             return;

  00652	e9 b3 00 00 00	 jmp	 $LN19@PyObject_F
$LN15@PyObject_F:

; 1215 :         }
; 1216 :         /* Pool was full, so doesn't currently live in any list:
; 1217 :          * link it to the front of the appropriate usedpools[] list.
; 1218 :          * This mimics LRU pool usage for new allocations and
; 1219 :          * targets optimal filling when several pools contain
; 1220 :          * blocks of the same size class.
; 1221 :          */
; 1222 :         --pool->ref.count;

  00657	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  0065c	8b 00		 mov	 eax, DWORD PTR [rax]
  0065e	ff c8		 dec	 eax
  00660	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pool$[rsp]
  00665	89 01		 mov	 DWORD PTR [rcx], eax

; 1223 :         assert(pool->ref.count > 0);            /* else the pool is empty */

  00667	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  0066c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0066f	77 1c		 ja	 SHORT $LN37@PyObject_F
  00671	41 b8 c7 04 00
	00		 mov	 r8d, 1223		; 000004c7H
  00677	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  0067e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@ECLFLOHI@?$AAp?$AAo?$AAo?$AAl?$AA?9?$AA?$DO?$AAr?$AAe?$AAf?$AA?4?$AAc?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DO?$AA?5?$AA0?$AA?$AA@
  00685	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0068b	33 c0		 xor	 eax, eax
$LN37@PyObject_F:

; 1224 :         size = pool->szidx;

  0068d	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  00692	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00695	89 44 24 30	 mov	 DWORD PTR size$[rsp], eax

; 1225 :         next = usedpools[size + size];

  00699	8b 44 24 30	 mov	 eax, DWORD PTR size$[rsp]
  0069d	8b 4c 24 30	 mov	 ecx, DWORD PTR size$[rsp]
  006a1	03 c8		 add	 ecx, eax
  006a3	8b c1		 mov	 eax, ecx
  006a5	8b c0		 mov	 eax, eax
  006a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:usedpools
  006ae	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  006b2	48 89 44 24 38	 mov	 QWORD PTR next$[rsp], rax

; 1226 :         prev = next->prevpool;

  006b7	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  006bc	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  006c0	48 89 44 24 20	 mov	 QWORD PTR prev$[rsp], rax

; 1227 :         /* insert pool before next:   prev <-> pool <-> next */
; 1228 :         pool->nextpool = next;

  006c5	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  006ca	48 8b 4c 24 38	 mov	 rcx, QWORD PTR next$[rsp]
  006cf	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1229 :         pool->prevpool = prev;

  006d3	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  006d8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR prev$[rsp]
  006dd	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1230 :         next->prevpool = pool;

  006e1	48 8b 44 24 38	 mov	 rax, QWORD PTR next$[rsp]
  006e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pool$[rsp]
  006eb	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1231 :         prev->nextpool = pool;

  006ef	48 8b 44 24 20	 mov	 rax, QWORD PTR prev$[rsp]
  006f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pool$[rsp]
  006f9	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1232 :         UNLOCK();
; 1233 :         return;

  006fd	eb 0b		 jmp	 SHORT $LN19@PyObject_F
$LN16@PyObject_F:

; 1234 :     }
; 1235 : 
; 1236 : #ifdef WITH_VALGRIND
; 1237 : redirect:
; 1238 : #endif
; 1239 :     /* We didn't allocate this address. */
; 1240 :     free(p);

  006ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p$[rsp]
  00704	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN19@PyObject_F:

; 1241 : }

  0070a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0070e	c3		 ret	 0
PyObject_Free ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@LPLEGNPM@PyObject_Realloc?$AA@	; `string'
PUBLIC	PyObject_Realloc
EXTRN	memcpy:PROC
EXTRN	_PxMem_Realloc:PROC
EXTRN	_PyParallel_Guard:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Realloc DD imagerel $LN18
	DD	imagerel $LN18+446
	DD	imagerel $unwind$PyObject_Realloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Realloc DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0BB@LPLEGNPM@PyObject_Realloc?$AA@
CONST	SEGMENT
??_C@_0BB@LPLEGNPM@PyObject_Realloc?$AA@ DB 'PyObject_Realloc', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_Realloc
_TEXT	SEGMENT
bp$ = 48
size$ = 56
pool$ = 64
tv146 = 72
p$ = 96
nbytes$ = 104
PyObject_Realloc PROC					; COMDAT

; 1251 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1252 :     void *bp;
; 1253 :     poolp pool;
; 1254 :     size_t size;
; 1255 : #ifndef Py_USING_MEMORY_DEBUGGER
; 1256 :     uint arenaindex_temp;
; 1257 : #endif
; 1258 :     if (p == NULL)

  0000e	48 83 7c 24 60
	00		 cmp	 QWORD PTR p$[rsp], 0
  00014	75 0f		 jne	 SHORT $LN13@PyObject_R

; 1259 :         return PyObject_Malloc(nbytes);

  00016	48 8b 4c 24 68	 mov	 rcx, QWORD PTR nbytes$[rsp]
  0001b	e8 00 00 00 00	 call	 PyObject_Malloc
  00020	e9 94 01 00 00	 jmp	 $LN14@PyObject_R
$LN13@PyObject_R:
$LN12@PyObject_R:

; 1260 : 
; 1261 :     PyPx_GUARD_MEM(p);

  00025	e8 00 00 00 00	 call	 _Py_PXCTX
  0002a	85 c0		 test	 eax, eax
  0002c	74 28		 je	 SHORT $LN9@PyObject_R
  0002e	c7 44 24 20 00
	04 00 00	 mov	 DWORD PTR [rsp+32], 1024 ; 00000400H
  00036	4c 8b 4c 24 60	 mov	 r9, QWORD PTR p$[rsp]
  0003b	41 b8 ed 04 00
	00		 mov	 r8d, 1261		; 000004edH
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@LPLEGNPM@PyObject_Realloc?$AA@
  0004f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00054	eb 26		 jmp	 SHORT $LN8@PyObject_R
$LN9@PyObject_R:
  00056	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  0005e	4c 8b 4c 24 60	 mov	 r9, QWORD PTR p$[rsp]
  00063	41 b8 ed 04 00
	00		 mov	 r8d, 1261		; 000004edH
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@LPLEGNPM@PyObject_Realloc?$AA@
  00077	e8 00 00 00 00	 call	 _PyParallel_Guard
$LN8@PyObject_R:
  0007c	33 c0		 xor	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	75 a3		 jne	 SHORT $LN12@PyObject_R

; 1262 :     Px_RETURN(_PxMem_Realloc(p, nbytes))

  00082	e8 00 00 00 00	 call	 _Py_PXCTX
  00087	85 c0		 test	 eax, eax
  00089	74 14		 je	 SHORT $LN7@PyObject_R
  0008b	48 8b 54 24 68	 mov	 rdx, QWORD PTR nbytes$[rsp]
  00090	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  00095	e8 00 00 00 00	 call	 _PxMem_Realloc
  0009a	e9 1a 01 00 00	 jmp	 $LN14@PyObject_R
$LN7@PyObject_R:

; 1263 : 
; 1264 :     /*
; 1265 :      * Limit ourselves to PY_SSIZE_T_MAX bytes to prevent security holes.
; 1266 :      * Most python internals blindly use a signed Py_ssize_t to track
; 1267 :      * things without checking for overflows or negatives.
; 1268 :      * As size_t is unsigned, checking for nbytes < 0 is not required.
; 1269 :      */
; 1270 :     if (nbytes > PY_SSIZE_T_MAX)

  0009f	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000a9	48 39 44 24 68	 cmp	 QWORD PTR nbytes$[rsp], rax
  000ae	76 07		 jbe	 SHORT $LN6@PyObject_R

; 1271 :         return NULL;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 02 01 00 00	 jmp	 $LN14@PyObject_R
$LN6@PyObject_R:

; 1272 : 
; 1273 : #ifdef WITH_VALGRIND
; 1274 :     /* Treat running_on_valgrind == -1 the same as 0 */
; 1275 :     if (UNLIKELY(running_on_valgrind > 0))
; 1276 :         goto redirect;
; 1277 : #endif
; 1278 : 
; 1279 :     pool = POOL_ADDR(p);

  000b7	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  000bc	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000c2	48 89 44 24 40	 mov	 QWORD PTR pool$[rsp], rax

; 1280 :     if (Py_ADDRESS_IN_RANGE(p, pool)) {

  000c7	48 8b 54 24 40	 mov	 rdx, QWORD PTR pool$[rsp]
  000cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  000d1	e8 00 00 00 00	 call	 Py_ADDRESS_IN_RANGE
  000d6	85 c0		 test	 eax, eax
  000d8	0f 84 89 00 00
	00		 je	 $LN5@PyObject_R

; 1281 :         /* We're in charge of this block */
; 1282 :         size = INDEX2SIZE(pool->szidx);

  000de	48 8b 44 24 40	 mov	 rax, QWORD PTR pool$[rsp]
  000e3	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000e6	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [rax*8+8]
  000ed	8b c0		 mov	 eax, eax
  000ef	48 89 44 24 38	 mov	 QWORD PTR size$[rsp], rax

; 1283 :         if (nbytes <= size) {

  000f4	48 8b 44 24 38	 mov	 rax, QWORD PTR size$[rsp]
  000f9	48 39 44 24 68	 cmp	 QWORD PTR nbytes$[rsp], rax
  000fe	77 2b		 ja	 SHORT $LN4@PyObject_R

; 1284 :             /* The block is staying the same or shrinking.  If
; 1285 :              * it's shrinking, there's a tradeoff:  it costs
; 1286 :              * cycles to copy the block to a smaller size class,
; 1287 :              * but it wastes memory not to copy it.  The
; 1288 :              * compromise here is to copy on shrink only if at
; 1289 :              * least 25% of size can be shaved off.
; 1290 :              */
; 1291 :             if (4 * nbytes > 3 * size) {

  00100	48 8b 44 24 68	 mov	 rax, QWORD PTR nbytes$[rsp]
  00105	48 c1 e0 02	 shl	 rax, 2
  00109	48 8b 4c 24 38	 mov	 rcx, QWORD PTR size$[rsp]
  0010e	48 6b c9 03	 imul	 rcx, 3
  00112	48 3b c1	 cmp	 rax, rcx
  00115	76 0a		 jbe	 SHORT $LN3@PyObject_R

; 1292 :                 /* It's the same,
; 1293 :                  * or shrinking and new/old > 3/4.
; 1294 :                  */
; 1295 :                 return p;

  00117	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0011c	e9 98 00 00 00	 jmp	 $LN14@PyObject_R
$LN3@PyObject_R:

; 1296 :             }
; 1297 :             size = nbytes;

  00121	48 8b 44 24 68	 mov	 rax, QWORD PTR nbytes$[rsp]
  00126	48 89 44 24 38	 mov	 QWORD PTR size$[rsp], rax
$LN4@PyObject_R:

; 1298 :         }
; 1299 :         bp = PyObject_Malloc(nbytes);

  0012b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00130	e8 00 00 00 00	 call	 PyObject_Malloc
  00135	48 89 44 24 30	 mov	 QWORD PTR bp$[rsp], rax

; 1300 :         if (bp != NULL) {

  0013a	48 83 7c 24 30
	00		 cmp	 QWORD PTR bp$[rsp], 0
  00140	74 1e		 je	 SHORT $LN2@PyObject_R

; 1301 :             memcpy(bp, p, size);

  00142	4c 8b 44 24 38	 mov	 r8, QWORD PTR size$[rsp]
  00147	48 8b 54 24 60	 mov	 rdx, QWORD PTR p$[rsp]
  0014c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bp$[rsp]
  00151	e8 00 00 00 00	 call	 memcpy

; 1302 :             PyObject_Free(p);

  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  0015b	e8 00 00 00 00	 call	 PyObject_Free
$LN2@PyObject_R:

; 1303 :         }
; 1304 :         return bp;

  00160	48 8b 44 24 30	 mov	 rax, QWORD PTR bp$[rsp]
  00165	eb 52		 jmp	 SHORT $LN14@PyObject_R
$LN5@PyObject_R:

; 1305 :     }
; 1306 : #ifdef WITH_VALGRIND
; 1307 :  redirect:
; 1308 : #endif
; 1309 :     /* We're not managing this block.  If nbytes <=
; 1310 :      * SMALL_REQUEST_THRESHOLD, it's tempting to try to take over this
; 1311 :      * block.  However, if we do, we need to copy the valid data from
; 1312 :      * the C-managed block to one of our blocks, and there's no portable
; 1313 :      * way to know how much of the memory space starting at p is valid.
; 1314 :      * As bug 1185883 pointed out the hard way, it's possible that the
; 1315 :      * C-managed block is "at the end" of allocated VM space, so that
; 1316 :      * a memory fault can occur if we try to copy nbytes bytes starting
; 1317 :      * at p.  Instead we punt:  let C continue to manage this block.
; 1318 :      */
; 1319 :     if (nbytes)

  00167	48 83 7c 24 68
	00		 cmp	 QWORD PTR nbytes$[rsp], 0
  0016d	74 12		 je	 SHORT $LN1@PyObject_R

; 1320 :         return realloc(p, nbytes);

  0016f	48 8b 54 24 68	 mov	 rdx, QWORD PTR nbytes$[rsp]
  00174	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0017f	eb 38		 jmp	 SHORT $LN14@PyObject_R
$LN1@PyObject_R:

; 1321 :     /* C doesn't define the result of realloc(p, 0) (it may or may not
; 1322 :      * return NULL then), but Python's docs promise that nbytes==0 never
; 1323 :      * returns NULL.  We don't pass 0 to realloc(), to avoid that endcase
; 1324 :      * to begin with.  Even then, we can't be sure that realloc() won't
; 1325 :      * return NULL.
; 1326 :      */
; 1327 :     bp = realloc(p, 1);

  00181	ba 01 00 00 00	 mov	 edx, 1
  00186	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00191	48 89 44 24 30	 mov	 QWORD PTR bp$[rsp], rax

; 1328 :     return bp ? bp : p;

  00196	48 83 7c 24 30
	00		 cmp	 QWORD PTR bp$[rsp], 0
  0019c	74 0c		 je	 SHORT $LN16@PyObject_R
  0019e	48 8b 44 24 30	 mov	 rax, QWORD PTR bp$[rsp]
  001a3	48 89 44 24 48	 mov	 QWORD PTR tv146[rsp], rax
  001a8	eb 0a		 jmp	 SHORT $LN17@PyObject_R
$LN16@PyObject_R:
  001aa	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  001af	48 89 44 24 48	 mov	 QWORD PTR tv146[rsp], rax
$LN17@PyObject_R:
  001b4	48 8b 44 24 48	 mov	 rax, QWORD PTR tv146[rsp]
$LN14@PyObject_R:

; 1329 : }

  001b9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001bd	c3		 ret	 0
PyObject_Realloc ENDP
_TEXT	ENDS
PUBLIC	_PyObject_DebugMallocApi
PUBLIC	_PyMem_DebugMalloc
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyMem_DebugMalloc DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$_PyMem_DebugMalloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyMem_DebugMalloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyMem_DebugMalloc
_TEXT	SEGMENT
nbytes$ = 48
_PyMem_DebugMalloc PROC					; COMDAT

; 1485 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1486 :     Px_RETURN(_PxMem_Malloc(nbytes))

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0c		 je	 SHORT $LN1@PyMem_Debu
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00017	e8 00 00 00 00	 call	 _PxMem_Malloc
  0001c	eb 0c		 jmp	 SHORT $LN2@PyMem_Debu
$LN1@PyMem_Debu:

; 1487 :     return _PyObject_DebugMallocApi(_PYMALLOC_MEM_ID, nbytes);

  0001e	48 8b 54 24 30	 mov	 rdx, QWORD PTR nbytes$[rsp]
  00023	b1 6d		 mov	 cl, 109			; 0000006dH
  00025	e8 00 00 00 00	 call	 _PyObject_DebugMallocApi
$LN2@PyMem_Debu:

; 1488 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
_PyMem_DebugMalloc ENDP
_TEXT	ENDS
PUBLIC	_PyObject_DebugReallocApi
PUBLIC	_PyMem_DebugRealloc
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyMem_DebugRealloc DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$_PyMem_DebugRealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyMem_DebugRealloc DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyMem_DebugRealloc
_TEXT	SEGMENT
p$ = 48
nbytes$ = 56
_PyMem_DebugRealloc PROC				; COMDAT

; 1491 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1492 :     Px_RETURN(_PxMem_Realloc(p, nbytes))

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 11		 je	 SHORT $LN1@PyMem_Debu@2
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR nbytes$[rsp]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00021	e8 00 00 00 00	 call	 _PxMem_Realloc
  00026	eb 11		 jmp	 SHORT $LN2@PyMem_Debu@2
$LN1@PyMem_Debu@2:

; 1493 :     return _PyObject_DebugReallocApi(_PYMALLOC_MEM_ID, p, nbytes);

  00028	4c 8b 44 24 38	 mov	 r8, QWORD PTR nbytes$[rsp]
  0002d	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00032	b1 6d		 mov	 cl, 109			; 0000006dH
  00034	e8 00 00 00 00	 call	 _PyObject_DebugReallocApi
$LN2@PyMem_Debu@2:

; 1494 : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
_PyMem_DebugRealloc ENDP
_TEXT	ENDS
PUBLIC	_PyObject_DebugFreeApi
PUBLIC	_PyMem_DebugFree
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyMem_DebugFree DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$_PyMem_DebugFree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyMem_DebugFree DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyMem_DebugFree
_TEXT	SEGMENT
p$ = 48
_PyMem_DebugFree PROC					; COMDAT

; 1497 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1498 :     Px_RETURN_VOID(_PxMem_Free(p))

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0c		 je	 SHORT $LN1@PyMem_Debu@3
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00017	e8 00 00 00 00	 call	 _PxMem_Free
  0001c	eb 0c		 jmp	 SHORT $LN2@PyMem_Debu@3
$LN1@PyMem_Debu@3:

; 1499 :     _PyObject_DebugFreeApi(_PYMALLOC_MEM_ID, p);

  0001e	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00023	b1 6d		 mov	 cl, 109			; 0000006dH
  00025	e8 00 00 00 00	 call	 _PyObject_DebugFreeApi
$LN2@PyMem_Debu@3:

; 1500 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
_PyMem_DebugFree ENDP
_TEXT	ENDS
PUBLIC	_PyObject_DebugMalloc
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_DebugMalloc DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$_PyObject_DebugMalloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_DebugMalloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_DebugMalloc
_TEXT	SEGMENT
nbytes$ = 48
_PyObject_DebugMalloc PROC				; COMDAT

; 1505 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1506 :     Px_RETURN(_PxMem_Malloc(nbytes))

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0c		 je	 SHORT $LN1@PyObject_D
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00017	e8 00 00 00 00	 call	 _PxMem_Malloc
  0001c	eb 0c		 jmp	 SHORT $LN2@PyObject_D
$LN1@PyObject_D:

; 1507 :     return _PyObject_DebugMallocApi(_PYMALLOC_OBJ_ID, nbytes);

  0001e	48 8b 54 24 30	 mov	 rdx, QWORD PTR nbytes$[rsp]
  00023	b1 6f		 mov	 cl, 111			; 0000006fH
  00025	e8 00 00 00 00	 call	 _PyObject_DebugMallocApi
$LN2@PyObject_D:

; 1508 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
_PyObject_DebugMalloc ENDP
_TEXT	ENDS
PUBLIC	_PyObject_DebugRealloc
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_DebugRealloc DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$_PyObject_DebugRealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_DebugRealloc DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_DebugRealloc
_TEXT	SEGMENT
p$ = 48
nbytes$ = 56
_PyObject_DebugRealloc PROC				; COMDAT

; 1511 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1512 :     Px_RETURN(_PxMem_Realloc(p, nbytes))

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 11		 je	 SHORT $LN1@PyObject_D@2
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR nbytes$[rsp]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00021	e8 00 00 00 00	 call	 _PxMem_Realloc
  00026	eb 11		 jmp	 SHORT $LN2@PyObject_D@2
$LN1@PyObject_D@2:

; 1513 :     return _PyObject_DebugReallocApi(_PYMALLOC_OBJ_ID, p, nbytes);

  00028	4c 8b 44 24 38	 mov	 r8, QWORD PTR nbytes$[rsp]
  0002d	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00032	b1 6f		 mov	 cl, 111			; 0000006fH
  00034	e8 00 00 00 00	 call	 _PyObject_DebugReallocApi
$LN2@PyObject_D@2:

; 1514 : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
_PyObject_DebugRealloc ENDP
_TEXT	ENDS
PUBLIC	_PyObject_DebugFree
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_DebugFree DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$_PyObject_DebugFree
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_DebugFree DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_DebugFree
_TEXT	SEGMENT
p$ = 48
_PyObject_DebugFree PROC				; COMDAT

; 1517 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1518 :     Px_RETURN_VOID(_PxMem_Free(p))

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 0c		 je	 SHORT $LN1@PyObject_D@3
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00017	e8 00 00 00 00	 call	 _PxMem_Free
  0001c	eb 0c		 jmp	 SHORT $LN2@PyObject_D@3
$LN1@PyObject_D@3:

; 1519 :     _PyObject_DebugFreeApi(_PYMALLOC_OBJ_ID, p);

  0001e	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00023	b1 6f		 mov	 cl, 111			; 0000006fH
  00025	e8 00 00 00 00	 call	 _PyObject_DebugFreeApi
$LN2@PyObject_D@3:

; 1520 : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
_PyObject_DebugFree ENDP
_TEXT	ENDS
PUBLIC	_PyObject_DebugCheckAddressApi
PUBLIC	??_C@_0BM@PLLJMBDI@_PyObject_DebugCheckAddress?$AA@ ; `string'
PUBLIC	_PyObject_DebugCheckAddress
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_DebugCheckAddress DD imagerel $LN4
	DD	imagerel $LN4+63
	DD	imagerel $unwind$_PyObject_DebugCheckAddress
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_DebugCheckAddress DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BM@PLLJMBDI@_PyObject_DebugCheckAddress?$AA@
CONST	SEGMENT
??_C@_0BM@PLLJMBDI@_PyObject_DebugCheckAddress?$AA@ DB '_PyObject_DebugCh'
	DB	'eckAddress', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyObject_DebugCheckAddress
_TEXT	SEGMENT
p$ = 48
_PyObject_DebugCheckAddress PROC			; COMDAT

; 1523 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1524 :     Py_GUARD

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 1c		 je	 SHORT $LN1@PyObject_D@4
  00012	45 33 c9	 xor	 r9d, r9d
  00015	41 b8 f4 05 00
	00		 mov	 r8d, 1524		; 000005f4H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@PLLJMBDI@_PyObject_DebugCheckAddress?$AA@
  00029	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN1@PyObject_D@4:

; 1525 :     _PyObject_DebugCheckAddressApi(_PYMALLOC_OBJ_ID, p);

  0002e	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00033	b1 6f		 mov	 cl, 111			; 0000006fH
  00035	e8 00 00 00 00	 call	 _PyObject_DebugCheckAddressApi

; 1526 : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
_PyObject_DebugCheckAddress ENDP
_TEXT	ENDS
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_DebugMallocApi DD imagerel $LN7
	DD	imagerel $LN7+275
	DD	imagerel $unwind$_PyObject_DebugMallocApi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_DebugMallocApi DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_DebugMallocApi
_TEXT	SEGMENT
p$ = 32
tail$ = 40
total$ = 48
id$ = 80
nbytes$ = 88
_PyObject_DebugMallocApi PROC				; COMDAT

; 1532 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1533 :     uchar *p;           /* base address of malloc'ed block */
; 1534 :     uchar *tail;        /* p + 2*SST + nbytes == pointer to tail pad bytes */
; 1535 :     size_t total;       /* nbytes + 4*SST */
; 1536 :     Px_RETURN(_PxMem_Malloc(nbytes))

  0000d	e8 00 00 00 00	 call	 _Py_PXCTX
  00012	85 c0		 test	 eax, eax
  00014	74 0f		 je	 SHORT $LN4@PyObject_D@5
  00016	48 8b 4c 24 58	 mov	 rcx, QWORD PTR nbytes$[rsp]
  0001b	e8 00 00 00 00	 call	 _PxMem_Malloc
  00020	e9 e9 00 00 00	 jmp	 $LN5@PyObject_D@5
$LN4@PyObject_D@5:

; 1537 : 
; 1538 :     bumpserialno();

  00025	e8 00 00 00 00	 call	 bumpserialno

; 1539 :     total = nbytes + 4*SST;

  0002a	48 8b 44 24 58	 mov	 rax, QWORD PTR nbytes$[rsp]
  0002f	48 83 c0 20	 add	 rax, 32			; 00000020H
  00033	48 89 44 24 30	 mov	 QWORD PTR total$[rsp], rax

; 1540 :     if (total < nbytes)

  00038	48 8b 44 24 58	 mov	 rax, QWORD PTR nbytes$[rsp]
  0003d	48 39 44 24 30	 cmp	 QWORD PTR total$[rsp], rax
  00042	73 07		 jae	 SHORT $LN3@PyObject_D@5

; 1541 :         /* overflow:  can't represent total as a size_t */
; 1542 :         return NULL;

  00044	33 c0		 xor	 eax, eax
  00046	e9 c3 00 00 00	 jmp	 $LN5@PyObject_D@5
$LN3@PyObject_D@5:

; 1543 : 
; 1544 :     p = (uchar *)PyObject_Malloc(total);

  0004b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR total$[rsp]
  00050	e8 00 00 00 00	 call	 PyObject_Malloc
  00055	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 1545 :     if (p == NULL)

  0005a	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$[rsp], 0
  00060	75 07		 jne	 SHORT $LN2@PyObject_D@5

; 1546 :         return NULL;

  00062	33 c0		 xor	 eax, eax
  00064	e9 a5 00 00 00	 jmp	 $LN5@PyObject_D@5
$LN2@PyObject_D@5:

; 1547 : 
; 1548 :     /* at p, write size (SST bytes), id (1 byte), pad (SST-1 bytes) */
; 1549 :     write_size_t(p, nbytes);

  00069	48 8b 54 24 58	 mov	 rdx, QWORD PTR nbytes$[rsp]
  0006e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00073	e8 00 00 00 00	 call	 write_size_t

; 1550 :     p[SST] = (uchar)id;

  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0007d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR id$[rsp]
  00082	88 48 08	 mov	 BYTE PTR [rax+8], cl

; 1551 :     memset(p + SST + 1 , FORBIDDENBYTE, SST-1);

  00085	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0008a	48 83 c0 09	 add	 rax, 9
  0008e	41 b8 07 00 00
	00		 mov	 r8d, 7
  00094	ba fb 00 00 00	 mov	 edx, 251		; 000000fbH
  00099	48 8b c8	 mov	 rcx, rax
  0009c	e8 00 00 00 00	 call	 memset

; 1552 : 
; 1553 :     if (nbytes > 0)

  000a1	48 83 7c 24 58
	00		 cmp	 QWORD PTR nbytes$[rsp], 0
  000a7	76 1b		 jbe	 SHORT $LN1@PyObject_D@5

; 1554 :         memset(p + 2*SST, CLEANBYTE, nbytes);

  000a9	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000ae	48 83 c0 10	 add	 rax, 16
  000b2	4c 8b 44 24 58	 mov	 r8, QWORD PTR nbytes$[rsp]
  000b7	ba cb 00 00 00	 mov	 edx, 203		; 000000cbH
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	e8 00 00 00 00	 call	 memset
$LN1@PyObject_D@5:

; 1555 : 
; 1556 :     /* at tail, write pad (SST bytes) and serialno (SST bytes) */
; 1557 :     tail = p + 2*SST + nbytes;

  000c4	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  000c9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR nbytes$[rsp]
  000ce	48 8d 44 08 10	 lea	 rax, QWORD PTR [rax+rcx+16]
  000d3	48 89 44 24 28	 mov	 QWORD PTR tail$[rsp], rax

; 1558 :     memset(tail, FORBIDDENBYTE, SST);

  000d8	41 b8 08 00 00
	00		 mov	 r8d, 8
  000de	ba fb 00 00 00	 mov	 edx, 251		; 000000fbH
  000e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tail$[rsp]
  000e8	e8 00 00 00 00	 call	 memset

; 1559 :     write_size_t(tail + SST, serialno);

  000ed	48 8b 44 24 28	 mov	 rax, QWORD PTR tail$[rsp]
  000f2	48 83 c0 08	 add	 rax, 8
  000f6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR serialno
  000fd	48 8b c8	 mov	 rcx, rax
  00100	e8 00 00 00 00	 call	 write_size_t

; 1560 : 
; 1561 :     return p + 2*SST;

  00105	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0010a	48 83 c0 10	 add	 rax, 16
$LN5@PyObject_D@5:

; 1562 : }

  0010e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00112	c3		 ret	 0
_PyObject_DebugMallocApi ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@DPGDDHHA@bumpserialno?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$bumpserialno DD imagerel bumpserialno
	DD	imagerel bumpserialno+63
	DD	imagerel $unwind$bumpserialno
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bumpserialno DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0N@DPGDDHHA@bumpserialno?$AA@
CONST	SEGMENT
??_C@_0N@DPGDDHHA@bumpserialno?$AA@ DB 'bumpserialno', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT bumpserialno
_TEXT	SEGMENT
bumpserialno PROC					; COMDAT

; 1397 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1398 :     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN1@bumpserial
  0000d	45 33 c9	 xor	 r9d, r9d
  00010	41 b8 76 05 00
	00		 mov	 r8d, 1398		; 00000576H
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DPGDDHHA@bumpserialno?$AA@
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN1@bumpserial:

; 1399 :     ++serialno;

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR serialno
  00030	48 ff c0	 inc	 rax
  00033	48 89 05 00 00
	00 00		 mov	 QWORD PTR serialno, rax

; 1400 : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
bumpserialno ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$write_size_t DD imagerel write_size_t
	DD	imagerel write_size_t+103
	DD	imagerel $unwind$write_size_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$write_size_t DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT write_size_t
_TEXT	SEGMENT
i$ = 0
q$ = 8
p$ = 32
n$ = 40
write_size_t PROC					; COMDAT

; 1422 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1423 :     uchar *q = (uchar *)p + SST - 1;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00013	48 83 c0 07	 add	 rax, 7
  00017	48 89 44 24 08	 mov	 QWORD PTR q$[rsp], rax

; 1424 :     int i;
; 1425 : 
; 1426 :     for (i = SST; --i >= 0; --q) {

  0001c	c7 04 24 08 00
	00 00		 mov	 DWORD PTR i$[rsp], 8
  00023	eb 0d		 jmp	 SHORT $LN3@write_size
$LN2@write_size:
  00025	48 8b 44 24 08	 mov	 rax, QWORD PTR q$[rsp]
  0002a	48 ff c8	 dec	 rax
  0002d	48 89 44 24 08	 mov	 QWORD PTR q$[rsp], rax
$LN3@write_size:
  00032	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00035	ff c8		 dec	 eax
  00037	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0003a	83 3c 24 00	 cmp	 DWORD PTR i$[rsp], 0
  0003e	7c 22		 jl	 SHORT $LN1@write_size

; 1427 :         *q = (uchar)(n & 0xff);

  00040	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00045	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0004b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR q$[rsp]
  00050	88 01		 mov	 BYTE PTR [rcx], al

; 1428 :         n >>= 8;

  00052	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00057	48 c1 e8 08	 shr	 rax, 8
  0005b	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 1429 :     }

  00060	eb c3		 jmp	 SHORT $LN2@write_size
$LN1@write_size:

; 1430 : }

  00062	48 83 c4 18	 add	 rsp, 24
  00066	c3		 ret	 0
write_size_t ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_DebugFreeApi DD imagerel $LN6
	DD	imagerel $LN6+145
	DD	imagerel $unwind$_PyObject_DebugFreeApi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_DebugFreeApi DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_DebugFreeApi
_TEXT	SEGMENT
q$ = 32
nbytes$ = 40
api$ = 64
p$ = 72
_PyObject_DebugFreeApi PROC				; COMDAT

; 1571 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1572 :     uchar *q = (uchar *)p - 2*SST;  /* address returned from malloc */

  0000d	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  00012	48 83 e8 10	 sub	 rax, 16
  00016	48 89 44 24 20	 mov	 QWORD PTR q$[rsp], rax

; 1573 :     size_t nbytes;
; 1574 : 
; 1575 :     if (p == NULL)

  0001b	48 83 7c 24 48
	00		 cmp	 QWORD PTR p$[rsp], 0
  00021	75 02		 jne	 SHORT $LN3@PyObject_D@6

; 1576 :         return;

  00023	eb 67		 jmp	 SHORT $LN4@PyObject_D@6
$LN3@PyObject_D@6:

; 1577 : 
; 1578 :     Px_RETURN_VOID(_PxMem_Free(p))

  00025	e8 00 00 00 00	 call	 _Py_PXCTX
  0002a	85 c0		 test	 eax, eax
  0002c	74 0c		 je	 SHORT $LN2@PyObject_D@6
  0002e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$[rsp]
  00033	e8 00 00 00 00	 call	 _PxMem_Free
  00038	eb 52		 jmp	 SHORT $LN4@PyObject_D@6
$LN2@PyObject_D@6:

; 1579 : 
; 1580 :     _PyObject_DebugCheckAddressApi(api, p);

  0003a	48 8b 54 24 48	 mov	 rdx, QWORD PTR p$[rsp]
  0003f	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR api$[rsp]
  00044	e8 00 00 00 00	 call	 _PyObject_DebugCheckAddressApi

; 1581 :     nbytes = read_size_t(q);

  00049	48 8b 4c 24 20	 mov	 rcx, QWORD PTR q$[rsp]
  0004e	e8 00 00 00 00	 call	 read_size_t
  00053	48 89 44 24 28	 mov	 QWORD PTR nbytes$[rsp], rax

; 1582 :     nbytes += 4*SST;

  00058	48 8b 44 24 28	 mov	 rax, QWORD PTR nbytes$[rsp]
  0005d	48 83 c0 20	 add	 rax, 32			; 00000020H
  00061	48 89 44 24 28	 mov	 QWORD PTR nbytes$[rsp], rax

; 1583 :     if (nbytes > 0)

  00066	48 83 7c 24 28
	00		 cmp	 QWORD PTR nbytes$[rsp], 0
  0006c	76 14		 jbe	 SHORT $LN1@PyObject_D@6

; 1584 :         memset(q, DEADBYTE, nbytes);

  0006e	4c 8b 44 24 28	 mov	 r8, QWORD PTR nbytes$[rsp]
  00073	ba db 00 00 00	 mov	 edx, 219		; 000000dbH
  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR q$[rsp]
  0007d	e8 00 00 00 00	 call	 memset
$LN1@PyObject_D@6:

; 1585 :     PyObject_Free(q);

  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR q$[rsp]
  00087	e8 00 00 00 00	 call	 PyObject_Free
$LN4@PyObject_D@6:

; 1586 : }

  0008c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00090	c3		 ret	 0
_PyObject_DebugFreeApi ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_size_t DD imagerel read_size_t
	DD	imagerel read_size_t+118
	DD	imagerel $unwind$read_size_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_size_t DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT read_size_t
_TEXT	SEGMENT
i$ = 0
q$ = 8
result$ = 16
p$ = 48
read_size_t PROC					; COMDAT

; 1407 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1408 :     const uchar *q = (const uchar *)p;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  0000e	48 89 44 24 08	 mov	 QWORD PTR q$[rsp], rax

; 1409 :     size_t result = *q++;

  00013	48 8b 44 24 08	 mov	 rax, QWORD PTR q$[rsp]
  00018	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001b	48 89 44 24 10	 mov	 QWORD PTR result$[rsp], rax
  00020	48 8b 44 24 08	 mov	 rax, QWORD PTR q$[rsp]
  00025	48 ff c0	 inc	 rax
  00028	48 89 44 24 08	 mov	 QWORD PTR q$[rsp], rax

; 1410 :     int i;
; 1411 : 
; 1412 :     for (i = SST; --i > 0; ++q)

  0002d	c7 04 24 08 00
	00 00		 mov	 DWORD PTR i$[rsp], 8
  00034	eb 0d		 jmp	 SHORT $LN3@read_size_
$LN2@read_size_:
  00036	48 8b 44 24 08	 mov	 rax, QWORD PTR q$[rsp]
  0003b	48 ff c0	 inc	 rax
  0003e	48 89 44 24 08	 mov	 QWORD PTR q$[rsp], rax
$LN3@read_size_:
  00043	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00046	ff c8		 dec	 eax
  00048	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0004b	83 3c 24 00	 cmp	 DWORD PTR i$[rsp], 0
  0004f	7e 1b		 jle	 SHORT $LN1@read_size_

; 1413 :         result = (result << 8) | *q;

  00051	48 8b 44 24 10	 mov	 rax, QWORD PTR result$[rsp]
  00056	48 c1 e0 08	 shl	 rax, 8
  0005a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR q$[rsp]
  0005f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00062	48 0b c1	 or	 rax, rcx
  00065	48 89 44 24 10	 mov	 QWORD PTR result$[rsp], rax
  0006a	eb ca		 jmp	 SHORT $LN2@read_size_
$LN1@read_size_:

; 1414 :     return result;

  0006c	48 8b 44 24 10	 mov	 rax, QWORD PTR result$[rsp]

; 1415 : }

  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	c3		 ret	 0
read_size_t ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DI@GAMJMKPP@?$AAq?$AA?$FL?$AAS?$AAS?$AAT?$AA?5?$AA?$CL?$AA?5?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAR?$AAB?$AAI?$AAD?$AAD?$AAE?$AAN?$AAB?$AAY?$AAT?$AAE?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@PBAOIGLO@?$AAq?$AA?$FL?$AAS?$AAS?$AAT?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAu?$AAc?$AAh?$AAa?$AAr?$AA?$CJ?$AAa?$AAp?$AAi?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BK@PFADAFEN@_PyObject_DebugReallocApi?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_DebugReallocApi DD imagerel $LN19
	DD	imagerel $LN19+679
	DD	imagerel $unwind$_PyObject_DebugReallocApi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_DebugReallocApi DD 011201H
	DD	0c212H
xdata	ENDS
;	COMDAT ??_C@_1DI@GAMJMKPP@?$AAq?$AA?$FL?$AAS?$AAS?$AAT?$AA?5?$AA?$CL?$AA?5?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAR?$AAB?$AAI?$AAD?$AAD?$AAE?$AAN?$AAB?$AAY?$AAT?$AAE?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@GAMJMKPP@?$AAq?$AA?$FL?$AAS?$AAS?$AAT?$AA?5?$AA?$CL?$AA?5?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAR?$AAB?$AAI?$AAD?$AAD?$AAE?$AAN?$AAB?$AAY?$AAT?$AAE?$AA?$AA@ DB 'q'
	DB	00H, '[', 00H, 'S', 00H, 'S', 00H, 'T', 00H, ' ', 00H, '+', 00H
	DB	' ', 00H, 'i', 00H, ']', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, 'F', 00H, 'O', 00H, 'R', 00H, 'B', 00H, 'I', 00H, 'D', 00H
	DB	'D', 00H, 'E', 00H, 'N', 00H, 'B', 00H, 'Y', 00H, 'T', 00H, 'E'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@PBAOIGLO@?$AAq?$AA?$FL?$AAS?$AAS?$AAT?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAu?$AAc?$AAh?$AAa?$AAr?$AA?$CJ?$AAa?$AAp?$AAi?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@PBAOIGLO@?$AAq?$AA?$FL?$AAS?$AAS?$AAT?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAu?$AAc?$AAh?$AAa?$AAr?$AA?$CJ?$AAa?$AAp?$AAi?$AA?$AA@ DB 'q'
	DB	00H, '[', 00H, 'S', 00H, 'S', 00H, 'T', 00H, ']', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '(', 00H, 'u', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, ')', 00H, 'a', 00H, 'p', 00H, 'i', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PFADAFEN@_PyObject_DebugReallocApi?$AA@
CONST	SEGMENT
??_C@_0BK@PFADAFEN@_PyObject_DebugReallocApi?$AA@ DB '_PyObject_DebugReal'
	DB	'locApi', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyObject_DebugReallocApi
_TEXT	SEGMENT
i$ = 48
tail$ = 56
original_nbytes$ = 64
q$ = 72
total$ = 80
api$ = 112
p$ = 120
nbytes$ = 128
_PyObject_DebugReallocApi PROC				; COMDAT

; 1590 : {

$LN19:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1591 :     uchar *q = (uchar *)p;

  00012	48 8b 44 24 78	 mov	 rax, QWORD PTR p$[rsp]
  00017	48 89 44 24 48	 mov	 QWORD PTR q$[rsp], rax

; 1592 :     uchar *tail;
; 1593 :     size_t total;       /* nbytes + 4*SST */
; 1594 :     size_t original_nbytes;
; 1595 :     int i;
; 1596 : 
; 1597 :     if (p == NULL)

  0001c	48 83 7c 24 78
	00		 cmp	 QWORD PTR p$[rsp], 0
  00022	75 17		 jne	 SHORT $LN14@PyObject_D@7

; 1598 :         return _PyObject_DebugMallocApi(api, nbytes);

  00024	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR nbytes$[rsp]
  0002c	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR api$[rsp]
  00031	e8 00 00 00 00	 call	 _PyObject_DebugMallocApi
  00036	e9 67 02 00 00	 jmp	 $LN15@PyObject_D@7
$LN14@PyObject_D@7:
$LN13@PyObject_D@7:

; 1599 : 
; 1600 :     PyPx_GUARD_MEM(p);

  0003b	e8 00 00 00 00	 call	 _Py_PXCTX
  00040	85 c0		 test	 eax, eax
  00042	74 28		 je	 SHORT $LN10@PyObject_D@7
  00044	c7 44 24 20 00
	04 00 00	 mov	 DWORD PTR [rsp+32], 1024 ; 00000400H
  0004c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR p$[rsp]
  00051	41 b8 40 06 00
	00		 mov	 r8d, 1600		; 00000640H
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@PFADAFEN@_PyObject_DebugReallocApi?$AA@
  00065	e8 00 00 00 00	 call	 _PyParallel_Guard
  0006a	eb 26		 jmp	 SHORT $LN9@PyObject_D@7
$LN10@PyObject_D@7:
  0006c	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  00074	4c 8b 4c 24 78	 mov	 r9, QWORD PTR p$[rsp]
  00079	41 b8 40 06 00
	00		 mov	 r8d, 1600		; 00000640H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@PFADAFEN@_PyObject_DebugReallocApi?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_Guard
$LN9@PyObject_D@7:
  00092	33 c0		 xor	 eax, eax
  00094	85 c0		 test	 eax, eax
  00096	75 a3		 jne	 SHORT $LN13@PyObject_D@7

; 1601 :     Px_RETURN(_PxMem_Realloc(p, nbytes))

  00098	e8 00 00 00 00	 call	 _Py_PXCTX
  0009d	85 c0		 test	 eax, eax
  0009f	74 17		 je	 SHORT $LN8@PyObject_D@7
  000a1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR nbytes$[rsp]
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  000ae	e8 00 00 00 00	 call	 _PxMem_Realloc
  000b3	e9 ea 01 00 00	 jmp	 $LN15@PyObject_D@7
$LN8@PyObject_D@7:

; 1602 : 
; 1603 :     _PyObject_DebugCheckAddressApi(api, p);

  000b8	48 8b 54 24 78	 mov	 rdx, QWORD PTR p$[rsp]
  000bd	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR api$[rsp]
  000c2	e8 00 00 00 00	 call	 _PyObject_DebugCheckAddressApi

; 1604 :     bumpserialno();

  000c7	e8 00 00 00 00	 call	 bumpserialno

; 1605 :     original_nbytes = read_size_t(q - 2*SST);

  000cc	48 8b 44 24 48	 mov	 rax, QWORD PTR q$[rsp]
  000d1	48 83 e8 10	 sub	 rax, 16
  000d5	48 8b c8	 mov	 rcx, rax
  000d8	e8 00 00 00 00	 call	 read_size_t
  000dd	48 89 44 24 40	 mov	 QWORD PTR original_nbytes$[rsp], rax

; 1606 :     total = nbytes + 4*SST;

  000e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR nbytes$[rsp]
  000ea	48 83 c0 20	 add	 rax, 32			; 00000020H
  000ee	48 89 44 24 50	 mov	 QWORD PTR total$[rsp], rax

; 1607 :     if (total < nbytes)

  000f3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR nbytes$[rsp]
  000fb	48 39 44 24 50	 cmp	 QWORD PTR total$[rsp], rax
  00100	73 07		 jae	 SHORT $LN7@PyObject_D@7

; 1608 :         /* overflow:  can't represent total as a size_t */
; 1609 :         return NULL;

  00102	33 c0		 xor	 eax, eax
  00104	e9 99 01 00 00	 jmp	 $LN15@PyObject_D@7
$LN7@PyObject_D@7:

; 1610 : 
; 1611 :     if (nbytes < original_nbytes) {

  00109	48 8b 44 24 40	 mov	 rax, QWORD PTR original_nbytes$[rsp]
  0010e	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR nbytes$[rsp], rax
  00116	73 37		 jae	 SHORT $LN6@PyObject_D@7

; 1612 :         /* shrinking:  mark old extra memory dead */
; 1613 :         memset(q + nbytes, DEADBYTE, original_nbytes - nbytes + 2*SST);

  00118	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR nbytes$[rsp]
  00120	48 8b 4c 24 40	 mov	 rcx, QWORD PTR original_nbytes$[rsp]
  00125	48 2b c8	 sub	 rcx, rax
  00128	48 8b c1	 mov	 rax, rcx
  0012b	48 83 c0 10	 add	 rax, 16
  0012f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR nbytes$[rsp]
  00137	48 8b 54 24 48	 mov	 rdx, QWORD PTR q$[rsp]
  0013c	48 03 d1	 add	 rdx, rcx
  0013f	48 8b ca	 mov	 rcx, rdx
  00142	4c 8b c0	 mov	 r8, rax
  00145	ba db 00 00 00	 mov	 edx, 219		; 000000dbH
  0014a	e8 00 00 00 00	 call	 memset
$LN6@PyObject_D@7:

; 1614 :     }
; 1615 : 
; 1616 :     /* Resize and add decorations. We may get a new pointer here, in which
; 1617 :      * case we didn't get the chance to mark the old memory with DEADBYTE,
; 1618 :      * but we live with that.
; 1619 :      */
; 1620 :     q = (uchar *)PyObject_Realloc(q - 2*SST, total);

  0014f	48 8b 44 24 48	 mov	 rax, QWORD PTR q$[rsp]
  00154	48 83 e8 10	 sub	 rax, 16
  00158	48 8b 54 24 50	 mov	 rdx, QWORD PTR total$[rsp]
  0015d	48 8b c8	 mov	 rcx, rax
  00160	e8 00 00 00 00	 call	 PyObject_Realloc
  00165	48 89 44 24 48	 mov	 QWORD PTR q$[rsp], rax

; 1621 :     if (q == NULL)

  0016a	48 83 7c 24 48
	00		 cmp	 QWORD PTR q$[rsp], 0
  00170	75 07		 jne	 SHORT $LN5@PyObject_D@7

; 1622 :         return NULL;

  00172	33 c0		 xor	 eax, eax
  00174	e9 29 01 00 00	 jmp	 $LN15@PyObject_D@7
$LN5@PyObject_D@7:

; 1623 : 
; 1624 :     write_size_t(q, nbytes);

  00179	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR nbytes$[rsp]
  00181	48 8b 4c 24 48	 mov	 rcx, QWORD PTR q$[rsp]
  00186	e8 00 00 00 00	 call	 write_size_t

; 1625 :     assert(q[SST] == (uchar)api);

  0018b	48 8b 44 24 48	 mov	 rax, QWORD PTR q$[rsp]
  00190	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00194	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR api$[rsp]
  00199	3b c1		 cmp	 eax, ecx
  0019b	74 1c		 je	 SHORT $LN17@PyObject_D@7
  0019d	41 b8 59 06 00
	00		 mov	 r8d, 1625		; 00000659H
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@PBAOIGLO@?$AAq?$AA?$FL?$AAS?$AAS?$AAT?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAu?$AAc?$AAh?$AAa?$AAr?$AA?$CJ?$AAa?$AAp?$AAi?$AA?$AA@
  001b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001b7	33 c0		 xor	 eax, eax
$LN17@PyObject_D@7:

; 1626 :     for (i = 1; i < SST; ++i)

  001b9	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  001c1	eb 0a		 jmp	 SHORT $LN4@PyObject_D@7
$LN3@PyObject_D@7:
  001c3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  001c7	ff c0		 inc	 eax
  001c9	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@PyObject_D@7:
  001cd	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  001d2	7d 37		 jge	 SHORT $LN2@PyObject_D@7

; 1627 :         assert(q[SST + i] == FORBIDDENBYTE);

  001d4	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  001d8	83 c0 08	 add	 eax, 8
  001db	48 98		 cdqe
  001dd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR q$[rsp]
  001e2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e6	3d fb 00 00 00	 cmp	 eax, 251		; 000000fbH
  001eb	74 1c		 je	 SHORT $LN18@PyObject_D@7
  001ed	41 b8 5b 06 00
	00		 mov	 r8d, 1627		; 0000065bH
  001f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  001fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@GAMJMKPP@?$AAq?$AA?$FL?$AAS?$AAS?$AAT?$AA?5?$AA?$CL?$AA?5?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAF?$AAO?$AAR?$AAB?$AAI?$AAD?$AAD?$AAE?$AAN?$AAB?$AAY?$AAT?$AAE?$AA?$AA@
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00207	33 c0		 xor	 eax, eax
$LN18@PyObject_D@7:
  00209	eb b8		 jmp	 SHORT $LN3@PyObject_D@7
$LN2@PyObject_D@7:

; 1628 :     q += 2*SST;

  0020b	48 8b 44 24 48	 mov	 rax, QWORD PTR q$[rsp]
  00210	48 83 c0 10	 add	 rax, 16
  00214	48 89 44 24 48	 mov	 QWORD PTR q$[rsp], rax

; 1629 :     tail = q + nbytes;

  00219	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR nbytes$[rsp]
  00221	48 8b 4c 24 48	 mov	 rcx, QWORD PTR q$[rsp]
  00226	48 03 c8	 add	 rcx, rax
  00229	48 8b c1	 mov	 rax, rcx
  0022c	48 89 44 24 38	 mov	 QWORD PTR tail$[rsp], rax

; 1630 :     memset(tail, FORBIDDENBYTE, SST);

  00231	41 b8 08 00 00
	00		 mov	 r8d, 8
  00237	ba fb 00 00 00	 mov	 edx, 251		; 000000fbH
  0023c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tail$[rsp]
  00241	e8 00 00 00 00	 call	 memset

; 1631 :     write_size_t(tail + SST, serialno);

  00246	48 8b 44 24 38	 mov	 rax, QWORD PTR tail$[rsp]
  0024b	48 83 c0 08	 add	 rax, 8
  0024f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR serialno
  00256	48 8b c8	 mov	 rcx, rax
  00259	e8 00 00 00 00	 call	 write_size_t

; 1632 : 
; 1633 :     if (nbytes > original_nbytes) {

  0025e	48 8b 44 24 40	 mov	 rax, QWORD PTR original_nbytes$[rsp]
  00263	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR nbytes$[rsp], rax
  0026b	76 30		 jbe	 SHORT $LN1@PyObject_D@7

; 1634 :         /* growing:  mark new extra memory clean */
; 1635 :         memset(q + original_nbytes, CLEANBYTE,
; 1636 :                nbytes - original_nbytes);

  0026d	48 8b 44 24 40	 mov	 rax, QWORD PTR original_nbytes$[rsp]
  00272	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR nbytes$[rsp]
  0027a	48 2b c8	 sub	 rcx, rax
  0027d	48 8b c1	 mov	 rax, rcx
  00280	48 8b 4c 24 40	 mov	 rcx, QWORD PTR original_nbytes$[rsp]
  00285	48 8b 54 24 48	 mov	 rdx, QWORD PTR q$[rsp]
  0028a	48 03 d1	 add	 rdx, rcx
  0028d	48 8b ca	 mov	 rcx, rdx
  00290	4c 8b c0	 mov	 r8, rax
  00293	ba cb 00 00 00	 mov	 edx, 203		; 000000cbH
  00298	e8 00 00 00 00	 call	 memset
$LN1@PyObject_D@7:

; 1637 :     }
; 1638 : 
; 1639 :     return q;

  0029d	48 8b 44 24 48	 mov	 rax, QWORD PTR q$[rsp]
$LN15@PyObject_D@7:

; 1640 : }

  002a2	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002a6	c3		 ret	 0
_PyObject_DebugReallocApi ENDP
_TEXT	ENDS
PUBLIC	_PyObject_DebugDumpAddress
PUBLIC	??_C@_0BG@KDHLIILG@bad?5trailing?5pad?5byte?$AA@ ; `string'
PUBLIC	??_C@_0BF@DDDBDDMM@bad?5leading?5pad?5byte?$AA@	; `string'
PUBLIC	??_C@_0DK@JBKCAFFP@bad?5ID?3?5Allocated?5using?5API?5?8?$CFc?8@ ; `string'
PUBLIC	??_C@_0BN@ELAEDILI@didn?8t?5expect?5a?5NULL?5pointer?$AA@ ; `string'
EXTRN	Py_FatalError:PROC
EXTRN	__imp__snprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_DebugCheckAddressApi DD imagerel $LN14
	DD	imagerel $LN14+376
	DD	imagerel $unwind$_PyObject_DebugCheckAddressApi
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_DebugCheckAddressApi DD 021001H
	DD	0150110H
xdata	ENDS
;	COMDAT ??_C@_0BG@KDHLIILG@bad?5trailing?5pad?5byte?$AA@
CONST	SEGMENT
??_C@_0BG@KDHLIILG@bad?5trailing?5pad?5byte?$AA@ DB 'bad trailing pad byt'
	DB	'e', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DDDBDDMM@bad?5leading?5pad?5byte?$AA@
CONST	SEGMENT
??_C@_0BF@DDDBDDMM@bad?5leading?5pad?5byte?$AA@ DB 'bad leading pad byte', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@JBKCAFFP@bad?5ID?3?5Allocated?5using?5API?5?8?$CFc?8@
CONST	SEGMENT
??_C@_0DK@JBKCAFFP@bad?5ID?3?5Allocated?5using?5API?5?8?$CFc?8@ DB 'bad I'
	DB	'D: Allocated using API ''%c'', verified using API ''%c''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ELAEDILI@didn?8t?5expect?5a?5NULL?5pointer?$AA@
CONST	SEGMENT
??_C@_0BN@ELAEDILI@didn?8t?5expect?5a?5NULL?5pointer?$AA@ DB 'didn''t exp'
	DB	'ect a NULL pointer', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyObject_DebugCheckAddressApi
_TEXT	SEGMENT
id$ = 48
i$ = 52
tail$ = 56
msg$ = 64
q$ = 72
nbytes$ = 80
msgbuf$ = 96
api$ = 176
p$ = 184
_PyObject_DebugCheckAddressApi PROC			; COMDAT

; 1649 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1650 :     const uchar *q = (const uchar *)p;

  00010	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00018	48 89 44 24 48	 mov	 QWORD PTR q$[rsp], rax

; 1651 :     char msgbuf[64];
; 1652 :     char *msg;
; 1653 :     size_t nbytes;
; 1654 :     const uchar *tail;
; 1655 :     int i;
; 1656 :     char id;
; 1657 :     Px_VOID

  0001d	e8 00 00 00 00	 call	 _Py_PXCTX
  00022	85 c0		 test	 eax, eax
  00024	74 05		 je	 SHORT $LN11@PyObject_D@8
  00026	e9 45 01 00 00	 jmp	 $LN12@PyObject_D@8
$LN11@PyObject_D@8:

; 1658 : 
; 1659 :     if (p == NULL) {

  0002b	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  00034	75 11		 jne	 SHORT $LN10@PyObject_D@8

; 1660 :         msg = "didn't expect a NULL pointer";

  00036	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@ELAEDILI@didn?8t?5expect?5a?5NULL?5pointer?$AA@
  0003d	48 89 44 24 40	 mov	 QWORD PTR msg$[rsp], rax

; 1661 :         goto error;

  00042	e9 12 01 00 00	 jmp	 $error$21184
$LN10@PyObject_D@8:

; 1662 :     }
; 1663 : 
; 1664 :     /* Check the API id */
; 1665 :     id = (char)q[-SST];

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR q$[rsp]
  0004c	0f b6 40 f8	 movzx	 eax, BYTE PTR [rax-8]
  00050	88 44 24 30	 mov	 BYTE PTR id$[rsp], al

; 1666 :     if (id != api) {

  00054	0f be 44 24 30	 movsx	 eax, BYTE PTR id$[rsp]
  00059	0f be 8c 24 b0
	00 00 00	 movsx	 ecx, BYTE PTR api$[rsp]
  00061	3b c1		 cmp	 eax, ecx
  00063	74 42		 je	 SHORT $LN9@PyObject_D@8

; 1667 :         msg = msgbuf;

  00065	48 8d 44 24 60	 lea	 rax, QWORD PTR msgbuf$[rsp]
  0006a	48 89 44 24 40	 mov	 QWORD PTR msg$[rsp], rax

; 1668 :         snprintf(msg, sizeof(msgbuf), "bad ID: Allocated using API '%c', verified using API '%c'", id, api);

  0006f	0f be 84 24 b0
	00 00 00	 movsx	 eax, BYTE PTR api$[rsp]
  00077	0f be 4c 24 30	 movsx	 ecx, BYTE PTR id$[rsp]
  0007c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00080	44 8b c9	 mov	 r9d, ecx
  00083	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0DK@JBKCAFFP@bad?5ID?3?5Allocated?5using?5API?5?8?$CFc?8@
  0008a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR msg$[rsp]
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__snprintf

; 1669 :         msgbuf[sizeof(msgbuf)-1] = 0;

  0009a	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR msgbuf$[rsp+63], 0

; 1670 :         goto error;

  000a2	e9 b2 00 00 00	 jmp	 $error$21184
$LN9@PyObject_D@8:

; 1671 :     }
; 1672 : 
; 1673 :     /* Check the stuff at the start of p first:  if there's underwrite
; 1674 :      * corruption, the number-of-bytes field may be nuts, and checking
; 1675 :      * the tail could lead to a segfault then.
; 1676 :      */
; 1677 :     for (i = SST-1; i >= 1; --i) {

  000a7	c7 44 24 34 07
	00 00 00	 mov	 DWORD PTR i$[rsp], 7
  000af	eb 0a		 jmp	 SHORT $LN8@PyObject_D@8
$LN7@PyObject_D@8:
  000b1	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  000b5	ff c8		 dec	 eax
  000b7	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN8@PyObject_D@8:
  000bb	83 7c 24 34 01	 cmp	 DWORD PTR i$[rsp], 1
  000c0	7c 2a		 jl	 SHORT $LN6@PyObject_D@8

; 1678 :         if (*(q-i) != FORBIDDENBYTE) {

  000c2	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  000c7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR q$[rsp]
  000cc	48 2b c8	 sub	 rcx, rax
  000cf	48 8b c1	 mov	 rax, rcx
  000d2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d5	3d fb 00 00 00	 cmp	 eax, 251		; 000000fbH
  000da	74 0e		 je	 SHORT $LN5@PyObject_D@8

; 1679 :             msg = "bad leading pad byte";

  000dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@DDDBDDMM@bad?5leading?5pad?5byte?$AA@
  000e3	48 89 44 24 40	 mov	 QWORD PTR msg$[rsp], rax

; 1680 :             goto error;

  000e8	eb 6f		 jmp	 SHORT $error$21184
$LN5@PyObject_D@8:

; 1681 :         }
; 1682 :     }

  000ea	eb c5		 jmp	 SHORT $LN7@PyObject_D@8
$LN6@PyObject_D@8:

; 1683 : 
; 1684 :     nbytes = read_size_t(q - 2*SST);

  000ec	48 8b 44 24 48	 mov	 rax, QWORD PTR q$[rsp]
  000f1	48 83 e8 10	 sub	 rax, 16
  000f5	48 8b c8	 mov	 rcx, rax
  000f8	e8 00 00 00 00	 call	 read_size_t
  000fd	48 89 44 24 50	 mov	 QWORD PTR nbytes$[rsp], rax

; 1685 :     tail = q + nbytes;

  00102	48 8b 44 24 50	 mov	 rax, QWORD PTR nbytes$[rsp]
  00107	48 8b 4c 24 48	 mov	 rcx, QWORD PTR q$[rsp]
  0010c	48 03 c8	 add	 rcx, rax
  0010f	48 8b c1	 mov	 rax, rcx
  00112	48 89 44 24 38	 mov	 QWORD PTR tail$[rsp], rax

; 1686 :     for (i = 0; i < SST; ++i) {

  00117	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0011f	eb 0a		 jmp	 SHORT $LN4@PyObject_D@8
$LN3@PyObject_D@8:
  00121	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00125	ff c0		 inc	 eax
  00127	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN4@PyObject_D@8:
  0012b	83 7c 24 34 08	 cmp	 DWORD PTR i$[rsp], 8
  00130	7d 25		 jge	 SHORT $LN2@PyObject_D@8

; 1687 :         if (tail[i] != FORBIDDENBYTE) {

  00132	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  00137	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tail$[rsp]
  0013c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00140	3d fb 00 00 00	 cmp	 eax, 251		; 000000fbH
  00145	74 0e		 je	 SHORT $LN1@PyObject_D@8

; 1688 :             msg = "bad trailing pad byte";

  00147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@KDHLIILG@bad?5trailing?5pad?5byte?$AA@
  0014e	48 89 44 24 40	 mov	 QWORD PTR msg$[rsp], rax

; 1689 :             goto error;

  00153	eb 04		 jmp	 SHORT $error$21184
$LN1@PyObject_D@8:

; 1690 :         }
; 1691 :     }

  00155	eb ca		 jmp	 SHORT $LN3@PyObject_D@8
$LN2@PyObject_D@8:

; 1692 : 
; 1693 :     return;

  00157	eb 17		 jmp	 SHORT $LN12@PyObject_D@8
$error$21184:

; 1694 : 
; 1695 : error:
; 1696 :     _PyObject_DebugDumpAddress(p);

  00159	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00161	e8 00 00 00 00	 call	 _PyObject_DebugDumpAddress

; 1697 :     Py_FatalError(msg);

  00166	48 8b 4c 24 40	 mov	 rcx, QWORD PTR msg$[rsp]
  0016b	e8 00 00 00 00	 call	 Py_FatalError
$LN12@PyObject_D@8:

; 1698 : }

  00170	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00177	c3		 ret	 0
_PyObject_DebugCheckAddressApi ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IBCFJNCN@?5?4?4?4?$AA@			; `string'
PUBLIC	??_C@_05HAJCMBLP@?5?$CF02x?$AA@			; `string'
PUBLIC	??_C@_0P@POFFKHPH@?5?5?5?5Data?5at?5p?3?$AA@	; `string'
PUBLIC	??_C@_0DO@FNLLEMPI@?5?5?5?5The?5block?5was?5made?5by?5call?5?$CD@ ; `string'
PUBLIC	??_C@_0BL@PLEOGJKI@?5?5?5?5?5?5?5?5at?5tail?$CL?$CFd?3?50x?$CF02x?$AA@ ; `string'
PUBLIC	??_C@_0CF@GNALIJCF@?5?5?5?5The?5?$CFd?5pad?5bytes?5at?5tail?$DN?$CFp?5@ ; `string'
PUBLIC	??_C@_0JD@GKMCIKON@?5?5?5?5Because?5memory?5is?5corrupted?5@ ; `string'
PUBLIC	??_C@_09CMCMEHIC@?5?$CK?$CK?$CK?5OUCH?$AA@	; `string'
PUBLIC	??_C@_0BI@BHPLOMO@?5?5?5?5?5?5?5?5at?5p?9?$CFd?3?50x?$CF02x?$AA@ ; `string'
PUBLIC	??_C@_0CB@PLJFBJPC@not?5all?5FORBIDDENBYTE?5?$CI0x?$CF02x?$CJ?3?6@ ; `string'
PUBLIC	??_C@_0BN@INFDAOLC@FORBIDDENBYTE?0?5as?5expected?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@IDCAEMEE@?5?5?5?5The?5?$CFd?5pad?5bytes?5at?5p?9?$CFd?5are@ ; `string'
PUBLIC	??_C@_0CE@FAHMLGFJ@?5?5?5?5?$CFIu?5bytes?5originally?5request@ ; `string'
PUBLIC	??_C@_0L@BFFHHJIO@?5API?5?8?$CFc?8?6?$AA@	; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CE@KABDNIPI@Debug?5memory?5block?5at?5address?5p?$DN@ ; `string'
PUBLIC	??_C@_0BL@PMBHJJLJ@_PyObject_DebugDumpAddress?$AA@ ; `string'
EXTRN	__imp_fputc:PROC
EXTRN	__imp_fputs:PROC
EXTRN	__imp_fprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_DebugDumpAddress DD imagerel $LN32
	DD	imagerel $LN32+1344
	DD	imagerel $unwind$_PyObject_DebugDumpAddress
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_DebugDumpAddress DD 010901H
	DD	0e209H
xdata	ENDS
;	COMDAT ??_C@_04IBCFJNCN@?5?4?4?4?$AA@
CONST	SEGMENT
??_C@_04IBCFJNCN@?5?4?4?4?$AA@ DB ' ...', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HAJCMBLP@?5?$CF02x?$AA@
CONST	SEGMENT
??_C@_05HAJCMBLP@?5?$CF02x?$AA@ DB ' %02x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@POFFKHPH@?5?5?5?5Data?5at?5p?3?$AA@
CONST	SEGMENT
??_C@_0P@POFFKHPH@?5?5?5?5Data?5at?5p?3?$AA@ DB '    Data at p:', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@FNLLEMPI@?5?5?5?5The?5block?5was?5made?5by?5call?5?$CD@
CONST	SEGMENT
??_C@_0DO@FNLLEMPI@?5?5?5?5The?5block?5was?5made?5by?5call?5?$CD@ DB '   '
	DB	' The block was made by call #%Iu to debug malloc/realloc.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PLEOGJKI@?5?5?5?5?5?5?5?5at?5tail?$CL?$CFd?3?50x?$CF02x?$AA@
CONST	SEGMENT
??_C@_0BL@PLEOGJKI@?5?5?5?5?5?5?5?5at?5tail?$CL?$CFd?3?50x?$CF02x?$AA@ DB ' '
	DB	'       at tail+%d: 0x%02x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GNALIJCF@?5?5?5?5The?5?$CFd?5pad?5bytes?5at?5tail?$DN?$CFp?5@
CONST	SEGMENT
??_C@_0CF@GNALIJCF@?5?5?5?5The?5?$CFd?5pad?5bytes?5at?5tail?$DN?$CFp?5@ DB ' '
	DB	'   The %d pad bytes at tail=%p are ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0JD@GKMCIKON@?5?5?5?5Because?5memory?5is?5corrupted?5@
CONST	SEGMENT
??_C@_0JD@GKMCIKON@?5?5?5?5Because?5memory?5is?5corrupted?5@ DB '    Beca'
	DB	'use memory is corrupted at the start, the count of bytes requ'
	DB	'ested', 0aH, '       may be bogus, and checking the trailing '
	DB	'pad bytes may segfault.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09CMCMEHIC@?5?$CK?$CK?$CK?5OUCH?$AA@
CONST	SEGMENT
??_C@_09CMCMEHIC@?5?$CK?$CK?$CK?5OUCH?$AA@ DB ' *** OUCH', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@BHPLOMO@?5?5?5?5?5?5?5?5at?5p?9?$CFd?3?50x?$CF02x?$AA@
CONST	SEGMENT
??_C@_0BI@BHPLOMO@?5?5?5?5?5?5?5?5at?5p?9?$CFd?3?50x?$CF02x?$AA@ DB '    '
	DB	'    at p-%d: 0x%02x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PLJFBJPC@not?5all?5FORBIDDENBYTE?5?$CI0x?$CF02x?$CJ?3?6@
CONST	SEGMENT
??_C@_0CB@PLJFBJPC@not?5all?5FORBIDDENBYTE?5?$CI0x?$CF02x?$CJ?3?6@ DB 'no'
	DB	't all FORBIDDENBYTE (0x%02x):', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@INFDAOLC@FORBIDDENBYTE?0?5as?5expected?4?6?$AA@
CONST	SEGMENT
??_C@_0BN@INFDAOLC@FORBIDDENBYTE?0?5as?5expected?4?6?$AA@ DB 'FORBIDDENBY'
	DB	'TE, as expected.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@IDCAEMEE@?5?5?5?5The?5?$CFd?5pad?5bytes?5at?5p?9?$CFd?5are@
CONST	SEGMENT
??_C@_0CC@IDCAEMEE@?5?5?5?5The?5?$CFd?5pad?5bytes?5at?5p?9?$CFd?5are@ DB ' '
	DB	'   The %d pad bytes at p-%d are ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FAHMLGFJ@?5?5?5?5?$CFIu?5bytes?5originally?5request@
CONST	SEGMENT
??_C@_0CE@FAHMLGFJ@?5?5?5?5?$CFIu?5bytes?5originally?5request@ DB '    %I'
	DB	'u bytes originally requested', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BFFHHJIO@?5API?5?8?$CFc?8?6?$AA@
CONST	SEGMENT
??_C@_0L@BFFHHJIO@?5API?5?8?$CFc?8?6?$AA@ DB ' API ''%c''', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KABDNIPI@Debug?5memory?5block?5at?5address?5p?$DN@
CONST	SEGMENT
??_C@_0CE@KABDNIPI@Debug?5memory?5block?5at?5address?5p?$DN@ DB 'Debug me'
	DB	'mory block at address p=%p:', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PMBHJJLJ@_PyObject_DebugDumpAddress?$AA@
CONST	SEGMENT
??_C@_0BL@PMBHJJLJ@_PyObject_DebugDumpAddress?$AA@ DB '_PyObject_DebugDum'
	DB	'pAddress', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyObject_DebugDumpAddress
_TEXT	SEGMENT
id$ = 32
ok$ = 36
i$ = 40
serial$ = 48
tail$ = 56
q$ = 64
nbytes$ = 72
byte$21230 = 80
byte$21245 = 81
tv82 = 84
tv154 = 88
tv202 = 92
tv234 = 96
tv251 = 100
p$ = 128
_PyObject_DebugDumpAddress PROC				; COMDAT

; 1703 : {

$LN32:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1704 :     const uchar *q = (const uchar *)p;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00011	48 89 44 24 40	 mov	 QWORD PTR q$[rsp], rax

; 1705 :     const uchar *tail;
; 1706 :     size_t nbytes, serial;
; 1707 :     int i;
; 1708 :     int ok;
; 1709 :     char id;
; 1710 :     Py_GUARD

  00016	e8 00 00 00 00	 call	 _Py_PXCTX
  0001b	85 c0		 test	 eax, eax
  0001d	74 1c		 je	 SHORT $LN29@PyObject_D@9
  0001f	45 33 c9	 xor	 r9d, r9d
  00022	41 b8 ae 06 00
	00		 mov	 r8d, 1710		; 000006aeH
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@PMBHJJLJ@_PyObject_DebugDumpAddress?$AA@
  00036	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN29@PyObject_D@9:

; 1711 : 
; 1712 :     fprintf(stderr, "Debug memory block at address p=%p:", p);

  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00041	48 83 c0 60	 add	 rax, 96			; 00000060H
  00045	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR p$[rsp]
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@KABDNIPI@Debug?5memory?5block?5at?5address?5p?$DN@
  00054	48 8b c8	 mov	 rcx, rax
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1713 :     if (p == NULL) {

  0005d	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  00066	75 1f		 jne	 SHORT $LN28@PyObject_D@9

; 1714 :         fprintf(stderr, "\n");

  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0006e	48 83 c0 60	 add	 rax, 96			; 00000060H
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  00079	48 8b c8	 mov	 rcx, rax
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1715 :         return;

  00082	e9 b4 04 00 00	 jmp	 $LN30@PyObject_D@9
$LN28@PyObject_D@9:

; 1716 :     }
; 1717 :     id = (char)q[-SST];

  00087	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  0008c	0f b6 40 f8	 movzx	 eax, BYTE PTR [rax-8]
  00090	88 44 24 20	 mov	 BYTE PTR id$[rsp], al

; 1718 :     fprintf(stderr, " API '%c'\n", id);

  00094	0f be 44 24 20	 movsx	 eax, BYTE PTR id$[rsp]
  00099	89 44 24 54	 mov	 DWORD PTR tv82[rsp], eax
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  000a3	48 83 c0 60	 add	 rax, 96			; 00000060H
  000a7	8b 4c 24 54	 mov	 ecx, DWORD PTR tv82[rsp]
  000ab	44 8b c1	 mov	 r8d, ecx
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@BFFHHJIO@?5API?5?8?$CFc?8?6?$AA@
  000b5	48 8b c8	 mov	 rcx, rax
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1719 : 
; 1720 :     nbytes = read_size_t(q - 2*SST);

  000be	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  000c3	48 83 e8 10	 sub	 rax, 16
  000c7	48 8b c8	 mov	 rcx, rax
  000ca	e8 00 00 00 00	 call	 read_size_t
  000cf	48 89 44 24 48	 mov	 QWORD PTR nbytes$[rsp], rax

; 1721 :     fprintf(stderr, "    %" PY_FORMAT_SIZE_T "u bytes originally "
; 1722 :                     "requested\n", nbytes);

  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  000da	48 83 c0 60	 add	 rax, 96			; 00000060H
  000de	4c 8b 44 24 48	 mov	 r8, QWORD PTR nbytes$[rsp]
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@FAHMLGFJ@?5?5?5?5?$CFIu?5bytes?5originally?5request@
  000ea	48 8b c8	 mov	 rcx, rax
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1723 : 
; 1724 :     /* In case this is nuts, check the leading pad bytes first. */
; 1725 :     fprintf(stderr, "    The %d pad bytes at p-%d are ", SST-1, SST-1);

  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  000f9	48 83 c0 60	 add	 rax, 96			; 00000060H
  000fd	41 b9 07 00 00
	00		 mov	 r9d, 7
  00103	41 b8 07 00 00
	00		 mov	 r8d, 7
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@IDCAEMEE@?5?5?5?5The?5?$CFd?5pad?5bytes?5at?5p?9?$CFd?5are@
  00110	48 8b c8	 mov	 rcx, rax
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1726 :     ok = 1;

  00119	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR ok$[rsp], 1

; 1727 :     for (i = 1; i <= SST-1; ++i) {

  00121	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00129	eb 0a		 jmp	 SHORT $LN27@PyObject_D@9
$LN26@PyObject_D@9:
  0012b	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0012f	ff c0		 inc	 eax
  00131	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN27@PyObject_D@9:
  00135	83 7c 24 28 07	 cmp	 DWORD PTR i$[rsp], 7
  0013a	7f 26		 jg	 SHORT $LN25@PyObject_D@9

; 1728 :         if (*(q-i) != FORBIDDENBYTE) {

  0013c	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR q$[rsp]
  00146	48 2b c8	 sub	 rcx, rax
  00149	48 8b c1	 mov	 rax, rcx
  0014c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0014f	3d fb 00 00 00	 cmp	 eax, 251		; 000000fbH
  00154	74 0a		 je	 SHORT $LN24@PyObject_D@9

; 1729 :             ok = 0;

  00156	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ok$[rsp], 0

; 1730 :             break;

  0015e	eb 02		 jmp	 SHORT $LN25@PyObject_D@9
$LN24@PyObject_D@9:

; 1731 :         }
; 1732 :     }

  00160	eb c9		 jmp	 SHORT $LN26@PyObject_D@9
$LN25@PyObject_D@9:

; 1733 :     if (ok)

  00162	83 7c 24 24 00	 cmp	 DWORD PTR ok$[rsp], 0
  00167	74 1f		 je	 SHORT $LN23@PyObject_D@9

; 1734 :         fputs("FORBIDDENBYTE, as expected.\n", stderr);

  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0016f	48 83 c0 60	 add	 rax, 96			; 00000060H
  00173	48 8b d0	 mov	 rdx, rax
  00176	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@INFDAOLC@FORBIDDENBYTE?0?5as?5expected?4?6?$AA@
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 1735 :     else {

  00183	e9 e2 00 00 00	 jmp	 $LN22@PyObject_D@9
$LN23@PyObject_D@9:

; 1736 :         fprintf(stderr, "not all FORBIDDENBYTE (0x%02x):\n",
; 1737 :             FORBIDDENBYTE);

  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0018e	48 83 c0 60	 add	 rax, 96			; 00000060H
  00192	41 b8 fb 00 00
	00		 mov	 r8d, 251		; 000000fbH
  00198	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@PLJFBJPC@not?5all?5FORBIDDENBYTE?5?$CI0x?$CF02x?$CJ?3?6@
  0019f	48 8b c8	 mov	 rcx, rax
  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1738 :         for (i = SST-1; i >= 1; --i) {

  001a8	c7 44 24 28 07
	00 00 00	 mov	 DWORD PTR i$[rsp], 7
  001b0	eb 0a		 jmp	 SHORT $LN21@PyObject_D@9
$LN20@PyObject_D@9:
  001b2	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001b6	ff c8		 dec	 eax
  001b8	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN21@PyObject_D@9:
  001bc	83 7c 24 28 01	 cmp	 DWORD PTR i$[rsp], 1
  001c1	0f 8c 89 00 00
	00		 jl	 $LN19@PyObject_D@9

; 1739 :             const uchar byte = *(q-i);

  001c7	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  001cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR q$[rsp]
  001d1	48 2b c8	 sub	 rcx, rax
  001d4	48 8b c1	 mov	 rax, rcx
  001d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001da	88 44 24 50	 mov	 BYTE PTR byte$21230[rsp], al

; 1740 :             fprintf(stderr, "        at p-%d: 0x%02x", i, byte);

  001de	0f b6 44 24 50	 movzx	 eax, BYTE PTR byte$21230[rsp]
  001e3	89 44 24 58	 mov	 DWORD PTR tv154[rsp], eax
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  001ed	48 83 c0 60	 add	 rax, 96			; 00000060H
  001f1	8b 4c 24 58	 mov	 ecx, DWORD PTR tv154[rsp]
  001f5	44 8b c9	 mov	 r9d, ecx
  001f8	44 8b 44 24 28	 mov	 r8d, DWORD PTR i$[rsp]
  001fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@BHPLOMO@?5?5?5?5?5?5?5?5at?5p?9?$CFd?3?50x?$CF02x?$AA@
  00204	48 8b c8	 mov	 rcx, rax
  00207	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1741 :             if (byte != FORBIDDENBYTE)

  0020d	0f b6 44 24 50	 movzx	 eax, BYTE PTR byte$21230[rsp]
  00212	3d fb 00 00 00	 cmp	 eax, 251		; 000000fbH
  00217	74 1a		 je	 SHORT $LN18@PyObject_D@9

; 1742 :                 fputs(" *** OUCH", stderr);

  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0021f	48 83 c0 60	 add	 rax, 96			; 00000060H
  00223	48 8b d0	 mov	 rdx, rax
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09CMCMEHIC@?5?$CK?$CK?$CK?5OUCH?$AA@
  0022d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs
$LN18@PyObject_D@9:

; 1743 :             fputc('\n', stderr);

  00233	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00239	48 83 c0 60	 add	 rax, 96			; 00000060H
  0023d	48 8b d0	 mov	 rdx, rax
  00240	b9 0a 00 00 00	 mov	 ecx, 10
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 1744 :         }

  0024b	e9 62 ff ff ff	 jmp	 $LN20@PyObject_D@9
$LN19@PyObject_D@9:

; 1745 : 
; 1746 :         fputs("    Because memory is corrupted at the start, the "
; 1747 :               "count of bytes requested\n"
; 1748 :               "       may be bogus, and checking the trailing pad "
; 1749 :               "bytes may segfault.\n", stderr);

  00250	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00256	48 83 c0 60	 add	 rax, 96			; 00000060H
  0025a	48 8b d0	 mov	 rdx, rax
  0025d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0JD@GKMCIKON@?5?5?5?5Because?5memory?5is?5corrupted?5@
  00264	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs
$LN22@PyObject_D@9:

; 1750 :     }
; 1751 : 
; 1752 :     tail = q + nbytes;

  0026a	48 8b 44 24 48	 mov	 rax, QWORD PTR nbytes$[rsp]
  0026f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR q$[rsp]
  00274	48 03 c8	 add	 rcx, rax
  00277	48 8b c1	 mov	 rax, rcx
  0027a	48 89 44 24 38	 mov	 QWORD PTR tail$[rsp], rax

; 1753 :     fprintf(stderr, "    The %d pad bytes at tail=%p are ", SST, tail);

  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00285	48 83 c0 60	 add	 rax, 96			; 00000060H
  00289	4c 8b 4c 24 38	 mov	 r9, QWORD PTR tail$[rsp]
  0028e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00294	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@GNALIJCF@?5?5?5?5The?5?$CFd?5pad?5bytes?5at?5tail?$DN?$CFp?5@
  0029b	48 8b c8	 mov	 rcx, rax
  0029e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1754 :     ok = 1;

  002a4	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR ok$[rsp], 1

; 1755 :     for (i = 0; i < SST; ++i) {

  002ac	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002b4	eb 0a		 jmp	 SHORT $LN17@PyObject_D@9
$LN16@PyObject_D@9:
  002b6	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  002ba	ff c0		 inc	 eax
  002bc	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN17@PyObject_D@9:
  002c0	83 7c 24 28 08	 cmp	 DWORD PTR i$[rsp], 8
  002c5	7d 21		 jge	 SHORT $LN15@PyObject_D@9

; 1756 :         if (tail[i] != FORBIDDENBYTE) {

  002c7	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  002cc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tail$[rsp]
  002d1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d5	3d fb 00 00 00	 cmp	 eax, 251		; 000000fbH
  002da	74 0a		 je	 SHORT $LN14@PyObject_D@9

; 1757 :             ok = 0;

  002dc	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ok$[rsp], 0

; 1758 :             break;

  002e4	eb 02		 jmp	 SHORT $LN15@PyObject_D@9
$LN14@PyObject_D@9:

; 1759 :         }
; 1760 :     }

  002e6	eb ce		 jmp	 SHORT $LN16@PyObject_D@9
$LN15@PyObject_D@9:

; 1761 :     if (ok)

  002e8	83 7c 24 24 00	 cmp	 DWORD PTR ok$[rsp], 0
  002ed	74 1f		 je	 SHORT $LN13@PyObject_D@9

; 1762 :         fputs("FORBIDDENBYTE, as expected.\n", stderr);

  002ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  002f5	48 83 c0 60	 add	 rax, 96			; 00000060H
  002f9	48 8b d0	 mov	 rdx, rax
  002fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@INFDAOLC@FORBIDDENBYTE?0?5as?5expected?4?6?$AA@
  00303	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 1763 :     else {

  00309	e9 c3 00 00 00	 jmp	 $LN12@PyObject_D@9
$LN13@PyObject_D@9:

; 1764 :         fprintf(stderr, "not all FORBIDDENBYTE (0x%02x):\n",
; 1765 :                 FORBIDDENBYTE);

  0030e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00314	48 83 c0 60	 add	 rax, 96			; 00000060H
  00318	41 b8 fb 00 00
	00		 mov	 r8d, 251		; 000000fbH
  0031e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@PLJFBJPC@not?5all?5FORBIDDENBYTE?5?$CI0x?$CF02x?$CJ?3?6@
  00325	48 8b c8	 mov	 rcx, rax
  00328	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1766 :         for (i = 0; i < SST; ++i) {

  0032e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00336	eb 0a		 jmp	 SHORT $LN11@PyObject_D@9
$LN10@PyObject_D@9:
  00338	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0033c	ff c0		 inc	 eax
  0033e	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN11@PyObject_D@9:
  00342	83 7c 24 28 08	 cmp	 DWORD PTR i$[rsp], 8
  00347	0f 8d 84 00 00
	00		 jge	 $LN9@PyObject_D@9

; 1767 :             const uchar byte = tail[i];

  0034d	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00352	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tail$[rsp]
  00357	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0035b	88 44 24 51	 mov	 BYTE PTR byte$21245[rsp], al

; 1768 :             fprintf(stderr, "        at tail+%d: 0x%02x",
; 1769 :                     i, byte);

  0035f	0f b6 44 24 51	 movzx	 eax, BYTE PTR byte$21245[rsp]
  00364	89 44 24 5c	 mov	 DWORD PTR tv202[rsp], eax
  00368	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0036e	48 83 c0 60	 add	 rax, 96			; 00000060H
  00372	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv202[rsp]
  00376	44 8b c9	 mov	 r9d, ecx
  00379	44 8b 44 24 28	 mov	 r8d, DWORD PTR i$[rsp]
  0037e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@PLEOGJKI@?5?5?5?5?5?5?5?5at?5tail?$CL?$CFd?3?50x?$CF02x?$AA@
  00385	48 8b c8	 mov	 rcx, rax
  00388	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1770 :             if (byte != FORBIDDENBYTE)

  0038e	0f b6 44 24 51	 movzx	 eax, BYTE PTR byte$21245[rsp]
  00393	3d fb 00 00 00	 cmp	 eax, 251		; 000000fbH
  00398	74 1a		 je	 SHORT $LN8@PyObject_D@9

; 1771 :                 fputs(" *** OUCH", stderr);

  0039a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  003a0	48 83 c0 60	 add	 rax, 96			; 00000060H
  003a4	48 8b d0	 mov	 rdx, rax
  003a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09CMCMEHIC@?5?$CK?$CK?$CK?5OUCH?$AA@
  003ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs
$LN8@PyObject_D@9:

; 1772 :             fputc('\n', stderr);

  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  003ba	48 83 c0 60	 add	 rax, 96			; 00000060H
  003be	48 8b d0	 mov	 rdx, rax
  003c1	b9 0a 00 00 00	 mov	 ecx, 10
  003c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 1773 :         }

  003cc	e9 67 ff ff ff	 jmp	 $LN10@PyObject_D@9
$LN9@PyObject_D@9:
$LN12@PyObject_D@9:

; 1774 :     }
; 1775 : 
; 1776 :     serial = read_size_t(tail + SST);

  003d1	48 8b 44 24 38	 mov	 rax, QWORD PTR tail$[rsp]
  003d6	48 83 c0 08	 add	 rax, 8
  003da	48 8b c8	 mov	 rcx, rax
  003dd	e8 00 00 00 00	 call	 read_size_t
  003e2	48 89 44 24 30	 mov	 QWORD PTR serial$[rsp], rax

; 1777 :     fprintf(stderr, "    The block was made by call #%" PY_FORMAT_SIZE_T
; 1778 :                     "u to debug malloc/realloc.\n", serial);

  003e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  003ed	48 83 c0 60	 add	 rax, 96			; 00000060H
  003f1	4c 8b 44 24 30	 mov	 r8, QWORD PTR serial$[rsp]
  003f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DO@FNLLEMPI@?5?5?5?5The?5block?5was?5made?5by?5call?5?$CD@
  003fd	48 8b c8	 mov	 rcx, rax
  00400	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1779 : 
; 1780 :     if (nbytes > 0) {

  00406	48 83 7c 24 48
	00		 cmp	 QWORD PTR nbytes$[rsp], 0
  0040c	0f 86 29 01 00
	00		 jbe	 $LN7@PyObject_D@9

; 1781 :         i = 0;

  00412	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 1782 :         fputs("    Data at p:", stderr);

  0041a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00420	48 83 c0 60	 add	 rax, 96			; 00000060H
  00424	48 8b d0	 mov	 rdx, rax
  00427	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@POFFKHPH@?5?5?5?5Data?5at?5p?3?$AA@
  0042e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs
$LN6@PyObject_D@9:

; 1783 :         /* print up to 8 bytes at the start */
; 1784 :         while (q < tail && i < 8) {

  00434	48 8b 44 24 38	 mov	 rax, QWORD PTR tail$[rsp]
  00439	48 39 44 24 40	 cmp	 QWORD PTR q$[rsp], rax
  0043e	73 4d		 jae	 SHORT $LN5@PyObject_D@9
  00440	83 7c 24 28 08	 cmp	 DWORD PTR i$[rsp], 8
  00445	7d 46		 jge	 SHORT $LN5@PyObject_D@9

; 1785 :             fprintf(stderr, " %02x", *q);

  00447	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  0044c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0044f	89 44 24 60	 mov	 DWORD PTR tv234[rsp], eax
  00453	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00459	48 83 c0 60	 add	 rax, 96			; 00000060H
  0045d	8b 4c 24 60	 mov	 ecx, DWORD PTR tv234[rsp]
  00461	44 8b c1	 mov	 r8d, ecx
  00464	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05HAJCMBLP@?5?$CF02x?$AA@
  0046b	48 8b c8	 mov	 rcx, rax
  0046e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1786 :             ++i;

  00474	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00478	ff c0		 inc	 eax
  0047a	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax

; 1787 :             ++q;

  0047e	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  00483	48 ff c0	 inc	 rax
  00486	48 89 44 24 40	 mov	 QWORD PTR q$[rsp], rax

; 1788 :         }

  0048b	eb a7		 jmp	 SHORT $LN6@PyObject_D@9
$LN5@PyObject_D@9:

; 1789 :         /* and up to 8 at the end */
; 1790 :         if (q < tail) {

  0048d	48 8b 44 24 38	 mov	 rax, QWORD PTR tail$[rsp]
  00492	48 39 44 24 40	 cmp	 QWORD PTR q$[rsp], rax
  00497	0f 83 86 00 00
	00		 jae	 $LN4@PyObject_D@9

; 1791 :             if (tail - q > 8) {

  0049d	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  004a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tail$[rsp]
  004a7	48 2b c8	 sub	 rcx, rax
  004aa	48 8b c1	 mov	 rax, rcx
  004ad	48 83 f8 08	 cmp	 rax, 8
  004b1	7e 28		 jle	 SHORT $LN3@PyObject_D@9

; 1792 :                 fputs(" ...", stderr);

  004b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  004b9	48 83 c0 60	 add	 rax, 96			; 00000060H
  004bd	48 8b d0	 mov	 rdx, rax
  004c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IBCFJNCN@?5?4?4?4?$AA@
  004c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 1793 :                 q = tail - 8;

  004cd	48 8b 44 24 38	 mov	 rax, QWORD PTR tail$[rsp]
  004d2	48 83 e8 08	 sub	 rax, 8
  004d6	48 89 44 24 40	 mov	 QWORD PTR q$[rsp], rax
$LN3@PyObject_D@9:
$LN2@PyObject_D@9:

; 1794 :             }
; 1795 :             while (q < tail) {

  004db	48 8b 44 24 38	 mov	 rax, QWORD PTR tail$[rsp]
  004e0	48 39 44 24 40	 cmp	 QWORD PTR q$[rsp], rax
  004e5	73 3c		 jae	 SHORT $LN1@PyObject_D@9

; 1796 :                 fprintf(stderr, " %02x", *q);

  004e7	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  004ec	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004ef	89 44 24 64	 mov	 DWORD PTR tv251[rsp], eax
  004f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  004f9	48 83 c0 60	 add	 rax, 96			; 00000060H
  004fd	8b 4c 24 64	 mov	 ecx, DWORD PTR tv251[rsp]
  00501	44 8b c1	 mov	 r8d, ecx
  00504	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05HAJCMBLP@?5?$CF02x?$AA@
  0050b	48 8b c8	 mov	 rcx, rax
  0050e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1797 :                 ++q;

  00514	48 8b 44 24 40	 mov	 rax, QWORD PTR q$[rsp]
  00519	48 ff c0	 inc	 rax
  0051c	48 89 44 24 40	 mov	 QWORD PTR q$[rsp], rax

; 1798 :             }

  00521	eb b8		 jmp	 SHORT $LN2@PyObject_D@9
$LN1@PyObject_D@9:
$LN4@PyObject_D@9:

; 1799 :         }
; 1800 :         fputc('\n', stderr);

  00523	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00529	48 83 c0 60	 add	 rax, 96			; 00000060H
  0052d	48 8b d0	 mov	 rdx, rax
  00530	b9 0a 00 00 00	 mov	 ecx, 10
  00535	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc
$LN7@PyObject_D@9:
$LN30@PyObject_D@9:

; 1801 :     }
; 1802 : }

  0053b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0053f	c3		 ret	 0
_PyObject_DebugDumpAddress ENDP
_TEXT	ENDS
PUBLIC	??_C@_05LLFBPGHK@?$CF48s?5?$AA@			; `string'
PUBLIC	??_C@_0BI@LPNJKHAA@?$CFd?5?$CFss?5?$CK?5?$CFzd?5bytes?5each?$AA@ ; `string'
PUBLIC	??_C@_0BH@PHOKLIIM@_PyDebugAllocatorStats?$AA@	; `string'
PUBLIC	_PyDebugAllocatorStats
EXTRN	PyOS_snprintf:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyDebugAllocatorStats DD imagerel $LN4
	DD	imagerel $LN4+199
	DD	imagerel $unwind$_PyDebugAllocatorStats
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyDebugAllocatorStats DD 021b01H
	DD	027011bH
xdata	ENDS
;	COMDAT ??_C@_05LLFBPGHK@?$CF48s?5?$AA@
CONST	SEGMENT
??_C@_05LLFBPGHK@?$CF48s?5?$AA@ DB '%48s ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LPNJKHAA@?$CFd?5?$CFss?5?$CK?5?$CFzd?5bytes?5each?$AA@
CONST	SEGMENT
??_C@_0BI@LPNJKHAA@?$CFd?5?$CFss?5?$CK?5?$CFzd?5bytes?5each?$AA@ DB '%d %'
	DB	'ss * %zd bytes each', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PHOKLIIM@_PyDebugAllocatorStats?$AA@
CONST	SEGMENT
??_C@_0BH@PHOKLIIM@_PyDebugAllocatorStats?$AA@ DB '_PyDebugAllocatorStats'
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyDebugAllocatorStats
_TEXT	SEGMENT
buf2$ = 48
buf1$ = 176
out$ = 320
block_name$ = 328
num_blocks$ = 336
sizeof_block$ = 344
_PyDebugAllocatorStats PROC				; COMDAT

; 1845 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 1846 :     char buf1[128];
; 1847 :     char buf2[128];
; 1848 :     Py_GUARD

  0001b	e8 00 00 00 00	 call	 _Py_PXCTX
  00020	85 c0		 test	 eax, eax
  00022	74 1c		 je	 SHORT $LN1@PyDebugAll
  00024	45 33 c9	 xor	 r9d, r9d
  00027	41 b8 38 07 00
	00		 mov	 r8d, 1848		; 00000738H
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@PHOKLIIM@_PyDebugAllocatorStats?$AA@
  0003b	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN1@PyDebugAll:

; 1849 :     PyOS_snprintf(buf1, sizeof(buf1),
; 1850 :                   "%d %ss * %zd bytes each",
; 1851 :                   num_blocks, block_name, sizeof_block);

  00040	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR sizeof_block$[rsp]
  00048	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR block_name$[rsp]
  00055	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005a	44 8b 8c 24 50
	01 00 00	 mov	 r9d, DWORD PTR num_blocks$[rsp]
  00062	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BI@LPNJKHAA@?$CFd?5?$CFss?5?$CK?5?$CFzd?5bytes?5each?$AA@
  00069	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0006e	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf1$[rsp]
  00076	e8 00 00 00 00	 call	 PyOS_snprintf

; 1852 :     PyOS_snprintf(buf2, sizeof(buf2),
; 1853 :                   "%48s ", buf1);

  0007b	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR buf1$[rsp]
  00083	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05LLFBPGHK@?$CF48s?5?$AA@
  0008a	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0008f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf2$[rsp]
  00094	e8 00 00 00 00	 call	 PyOS_snprintf

; 1854 :     (void)printone(out, buf2, num_blocks * sizeof_block);

  00099	48 63 84 24 50
	01 00 00	 movsxd	 rax, DWORD PTR num_blocks$[rsp]
  000a1	48 0f af 84 24
	58 01 00 00	 imul	 rax, QWORD PTR sizeof_block$[rsp]
  000aa	4c 8b c0	 mov	 r8, rax
  000ad	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf2$[rsp]
  000b2	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  000ba	e8 00 00 00 00	 call	 printone

; 1855 : }

  000bf	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  000c6	c3		 ret	 0
_PyDebugAllocatorStats ENDP
_TEXT	ENDS
EXTRN	strlen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$printone DD imagerel printone
	DD	imagerel printone+454
	DD	imagerel $unwind$printone
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printone DD 021601H
	DD	0170116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT printone
_TEXT	SEGMENT
i$ = 32
origvalue$ = 40
buf$ = 48
k$ = 160
digit$21281 = 164
nextvalue$21280 = 168
out$ = 192
msg$ = 200
value$ = 208
printone PROC						; COMDAT

; 1808 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1809 :     int i, k;
; 1810 :     char buf[100];
; 1811 :     size_t origvalue = value;

  00016	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR value$[rsp]
  0001e	48 89 44 24 28	 mov	 QWORD PTR origvalue$[rsp], rax

; 1812 : 
; 1813 :     fputs(msg, out);

  00023	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  0002b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR msg$[rsp]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 1814 :     for (i = (int)strlen(msg); i < 35; ++i)

  00039	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR msg$[rsp]
  00041	e8 00 00 00 00	 call	 strlen
  00046	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0004a	eb 0a		 jmp	 SHORT $LN10@printone
$LN9@printone:
  0004c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00050	ff c0		 inc	 eax
  00052	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@printone:
  00056	83 7c 24 20 23	 cmp	 DWORD PTR i$[rsp], 35	; 00000023H
  0005b	7d 15		 jge	 SHORT $LN8@printone

; 1815 :         fputc(' ', out);

  0005d	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00065	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc
  00070	eb da		 jmp	 SHORT $LN9@printone
$LN8@printone:

; 1816 :     fputc('=', out);

  00072	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  0007a	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 1817 : 
; 1818 :     /* Write the value with commas. */
; 1819 :     i = 22;

  00085	c7 44 24 20 16
	00 00 00	 mov	 DWORD PTR i$[rsp], 22

; 1820 :     buf[i--] = '\0';

  0008d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00092	c6 44 04 30 00	 mov	 BYTE PTR buf$[rsp+rax], 0
  00097	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0009b	ff c8		 dec	 eax
  0009d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 1821 :     buf[i--] = '\n';

  000a1	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a6	c6 44 04 30 0a	 mov	 BYTE PTR buf$[rsp+rax], 10
  000ab	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000af	ff c8		 dec	 eax
  000b1	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 1822 :     k = 3;

  000b5	c7 84 24 a0 00
	00 00 03 00 00
	00		 mov	 DWORD PTR k$[rsp], 3
$LN7@printone:

; 1823 :     do {
; 1824 :         size_t nextvalue = value / 10;

  000c0	33 d2		 xor	 edx, edx
  000c2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR value$[rsp]
  000ca	b9 0a 00 00 00	 mov	 ecx, 10
  000cf	48 f7 f1	 div	 rcx
  000d2	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR nextvalue$21280[rsp], rax

; 1825 :         PY_UINT32_T digit = (PY_UINT32_T)(value - nextvalue * 10);

  000da	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR nextvalue$21280[rsp]
  000e2	48 6b c0 0a	 imul	 rax, 10
  000e6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  000ee	48 2b c8	 sub	 rcx, rax
  000f1	48 8b c1	 mov	 rax, rcx
  000f4	89 84 24 a4 00
	00 00		 mov	 DWORD PTR digit$21281[rsp], eax

; 1826 :         value = nextvalue;

  000fb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR nextvalue$21280[rsp]
  00103	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR value$[rsp], rax

; 1827 :         buf[i--] = (char)(digit + '0');

  0010b	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR digit$21281[rsp]
  00112	83 c0 30	 add	 eax, 48			; 00000030H
  00115	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0011a	88 44 0c 30	 mov	 BYTE PTR buf$[rsp+rcx], al
  0011e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00122	ff c8		 dec	 eax
  00124	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax

; 1828 :         --k;

  00128	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  0012f	ff c8		 dec	 eax
  00131	89 84 24 a0 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 1829 :         if (k == 0 && value && i >= 0) {

  00138	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR k$[rsp], 0
  00140	75 31		 jne	 SHORT $LN4@printone
  00142	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR value$[rsp], 0
  0014b	74 26		 je	 SHORT $LN4@printone
  0014d	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00152	7c 1f		 jl	 SHORT $LN4@printone

; 1830 :             k = 3;

  00154	c7 84 24 a0 00
	00 00 03 00 00
	00		 mov	 DWORD PTR k$[rsp], 3

; 1831 :             buf[i--] = ',';

  0015f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00164	c6 44 04 30 2c	 mov	 BYTE PTR buf$[rsp+rax], 44 ; 0000002cH
  00169	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0016d	ff c8		 dec	 eax
  0016f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@printone:

; 1832 :         }
; 1833 :     } while (value && i >= 0);

  00173	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR value$[rsp], 0
  0017c	74 0b		 je	 SHORT $LN3@printone
  0017e	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00183	0f 8d 37 ff ff
	ff		 jge	 $LN7@printone
$LN3@printone:
$LN2@printone:

; 1834 : 
; 1835 :     while (i >= 0)

  00189	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0018e	7c 16		 jl	 SHORT $LN1@printone

; 1836 :         buf[i--] = ' ';

  00190	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00195	c6 44 04 30 20	 mov	 BYTE PTR buf$[rsp+rax], 32 ; 00000020H
  0019a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0019e	ff c8		 dec	 eax
  001a0	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001a4	eb e3		 jmp	 SHORT $LN2@printone
$LN1@printone:

; 1837 :     fputs(buf, out);

  001a6	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  001ae	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 1838 : 
; 1839 :     return origvalue;

  001b9	48 8b 44 24 28	 mov	 rax, QWORD PTR origvalue$[rsp]

; 1840 : }

  001be	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  001c5	c3		 ret	 0
printone ENDP
_TEXT	ENDS
PUBLIC	??_C@_05KGEAEGFG@Total?$AA@			; `string'
PUBLIC	??_C@_0CA@GBCGKCEO@?$CD?5bytes?5lost?5to?5arena?5alignment?$AA@ ; `string'
PUBLIC	??_C@_0BN@DPIKIPML@?$CD?5bytes?5lost?5to?5quantization?$AA@ ; `string'
PUBLIC	??_C@_0BN@OBJGCACO@?$CD?5bytes?5lost?5to?5pool?5headers?$AA@ ; `string'
PUBLIC	??_C@_0BL@FMCCONMC@?$CFu?5unused?5pools?5?$CK?5?$CFd?5bytes?$AA@ ; `string'
PUBLIC	??_C@_0BM@KKPDFEBK@?$CD?5bytes?5in?5available?5blocks?$AA@ ; `string'
PUBLIC	??_C@_0BM@DGPGANCG@?$CD?5bytes?5in?5allocated?5blocks?$AA@ ; `string'
PUBLIC	??_C@_0BM@EMIIMIHN@?$CFIu?5arenas?5?$CK?5?$CFd?5bytes?1arena?$AA@ ; `string'
PUBLIC	??_C@_0BL@CDPEAAIO@?$CD?5arenas?5allocated?5current?$AA@ ; `string'
PUBLIC	??_C@_0BI@NDJBDOMD@?$CD?5arenas?5highwater?5mark?$AA@ ; `string'
PUBLIC	??_C@_0BD@EGEFNLBB@?$CD?5arenas?5reclaimed?$AA@	; `string'
PUBLIC	??_C@_0BJ@BBJOHCGI@?$CD?5arenas?5allocated?5total?$AA@ ; `string'
PUBLIC	??_C@_0BN@JMNCPGGM@?$CD?5times?5object?5malloc?5called?$AA@ ; `string'
PUBLIC	??_C@_0BL@KKKLDLHO@?$CF5u?5?$CF6u?5?$CF11Iu?5?$CF15Iu?5?$CF13Iu?6?$AA@ ; `string'
PUBLIC	??_C@_1CC@BHEBKDII@?$AAb?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_0GP@CMHKANCA@class?5?5?5size?5?5?5num?5pools?5?5?5block@ ; `string'
PUBLIC	??_C@_1EO@ELBBAFGH@?$AAn?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA_?$AAc?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAl?$AAy?$AA_?$AAa?$AAl?$AAl@ ; `string'
PUBLIC	??_C@_1EO@NDDCLEGG@?$AAp?$AAo?$AAo?$AAl?$AA_?$AAi?$AAs?$AA_?$AAi?$AAn?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?$CI?$AAp?$AA?0?$AA?5?$AAu?$AAs?$AAe?$AAd?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?$FL?$AAs?$AAz?$AA?5@ ; `string'
PUBLIC	??_C@_1FA@JBCCFOIF@?$AAp?$AAo?$AAo?$AAl?$AA_?$AAi?$AAs?$AA_?$AAi?$AAn?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?$CI?$AAp?$AA?0?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAf?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1EM@PKOFODDM@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAu?$AAp?$AAt?$AAr?$AA?$CJ?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAp?$AAo?$AAo?$AAl?$AA_?$AAa?$AAd@ ; `string'
PUBLIC	??_C@_0DB@PNOPCKMC@Small?5block?5threshold?5?$DN?5?$CFd?0?5in?5?$CF@ ; `string'
PUBLIC	??_C@_0BL@OPOOMDLH@_PyObject_DebugMallocStats?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_DebugMallocStats DD imagerel $LN27
	DD	imagerel $LN27+2147
	DD	imagerel $unwind$_PyObject_DebugMallocStats
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_DebugMallocStats DD 020c01H
	DD	0f1010cH
xdata	ENDS
;	COMDAT ??_C@_05KGEAEGFG@Total?$AA@
CONST	SEGMENT
??_C@_05KGEAEGFG@Total?$AA@ DB 'Total', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GBCGKCEO@?$CD?5bytes?5lost?5to?5arena?5alignment?$AA@
CONST	SEGMENT
??_C@_0CA@GBCGKCEO@?$CD?5bytes?5lost?5to?5arena?5alignment?$AA@ DB '# byt'
	DB	'es lost to arena alignment', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DPIKIPML@?$CD?5bytes?5lost?5to?5quantization?$AA@
CONST	SEGMENT
??_C@_0BN@DPIKIPML@?$CD?5bytes?5lost?5to?5quantization?$AA@ DB '# bytes l'
	DB	'ost to quantization', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@OBJGCACO@?$CD?5bytes?5lost?5to?5pool?5headers?$AA@
CONST	SEGMENT
??_C@_0BN@OBJGCACO@?$CD?5bytes?5lost?5to?5pool?5headers?$AA@ DB '# bytes '
	DB	'lost to pool headers', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@FMCCONMC@?$CFu?5unused?5pools?5?$CK?5?$CFd?5bytes?$AA@
CONST	SEGMENT
??_C@_0BL@FMCCONMC@?$CFu?5unused?5pools?5?$CK?5?$CFd?5bytes?$AA@ DB '%u u'
	DB	'nused pools * %d bytes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KKPDFEBK@?$CD?5bytes?5in?5available?5blocks?$AA@
CONST	SEGMENT
??_C@_0BM@KKPDFEBK@?$CD?5bytes?5in?5available?5blocks?$AA@ DB '# bytes in'
	DB	' available blocks', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DGPGANCG@?$CD?5bytes?5in?5allocated?5blocks?$AA@
CONST	SEGMENT
??_C@_0BM@DGPGANCG@?$CD?5bytes?5in?5allocated?5blocks?$AA@ DB '# bytes in'
	DB	' allocated blocks', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EMIIMIHN@?$CFIu?5arenas?5?$CK?5?$CFd?5bytes?1arena?$AA@
CONST	SEGMENT
??_C@_0BM@EMIIMIHN@?$CFIu?5arenas?5?$CK?5?$CFd?5bytes?1arena?$AA@ DB '%Iu'
	DB	' arenas * %d bytes/arena', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@CDPEAAIO@?$CD?5arenas?5allocated?5current?$AA@
CONST	SEGMENT
??_C@_0BL@CDPEAAIO@?$CD?5arenas?5allocated?5current?$AA@ DB '# arenas all'
	DB	'ocated current', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NDJBDOMD@?$CD?5arenas?5highwater?5mark?$AA@
CONST	SEGMENT
??_C@_0BI@NDJBDOMD@?$CD?5arenas?5highwater?5mark?$AA@ DB '# arenas highwa'
	DB	'ter mark', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EGEFNLBB@?$CD?5arenas?5reclaimed?$AA@
CONST	SEGMENT
??_C@_0BD@EGEFNLBB@?$CD?5arenas?5reclaimed?$AA@ DB '# arenas reclaimed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BBJOHCGI@?$CD?5arenas?5allocated?5total?$AA@
CONST	SEGMENT
??_C@_0BJ@BBJOHCGI@?$CD?5arenas?5allocated?5total?$AA@ DB '# arenas alloc'
	DB	'ated total', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JMNCPGGM@?$CD?5times?5object?5malloc?5called?$AA@
CONST	SEGMENT
??_C@_0BN@JMNCPGGM@?$CD?5times?5object?5malloc?5called?$AA@ DB '# times o'
	DB	'bject malloc called', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KKKLDLHO@?$CF5u?5?$CF6u?5?$CF11Iu?5?$CF15Iu?5?$CF13Iu?6?$AA@
CONST	SEGMENT
??_C@_0BL@KKKLDLHO@?$CF5u?5?$CF6u?5?$CF11Iu?5?$CF15Iu?5?$CF13Iu?6?$AA@ DB '%'
	DB	'5u %6u %11Iu %15Iu %13Iu', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@BHEBKDII@?$AAb?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@BHEBKDII@?$AAb?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'b'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'&', 00H, '&', 00H, ' ', 00H, 'f', 00H, ' ', 00H, '=', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GP@CMHKANCA@class?5?5?5size?5?5?5num?5pools?5?5?5block@
CONST	SEGMENT
??_C@_0GP@CMHKANCA@class?5?5?5size?5?5?5num?5pools?5?5?5block@ DB 'class '
	DB	'  size   num pools   blocks in use  avail blocks', 0aH, '----'
	DB	'-   ----   ---------   -------------  ------------', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@ELBBAFGH@?$AAn?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA_?$AAc?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAl?$AAy?$AA_?$AAa?$AAl?$AAl@
CONST	SEGMENT
??_C@_1EO@ELBBAFGH@?$AAn?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA_?$AAc?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAl?$AAy?$AA_?$AAa?$AAl?$AAl@ DB 'n'
	DB	00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'n', 00H, 'a', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, '_', 00H, 'c', 00H
	DB	'u', 00H, 'r', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'l'
	DB	00H, 'y', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H
	DB	'c', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@NDDCLEGG@?$AAp?$AAo?$AAo?$AAl?$AA_?$AAi?$AAs?$AA_?$AAi?$AAn?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?$CI?$AAp?$AA?0?$AA?5?$AAu?$AAs?$AAe?$AAd?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?$FL?$AAs?$AAz?$AA?5@
CONST	SEGMENT
??_C@_1EO@NDDCLEGG@?$AAp?$AAo?$AAo?$AAl?$AA_?$AAi?$AAs?$AA_?$AAi?$AAn?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?$CI?$AAp?$AA?0?$AA?5?$AAu?$AAs?$AAe?$AAd?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?$FL?$AAs?$AAz?$AA?5@ DB 'p'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, '_', 00H, 'i', 00H, 's', 00H
	DB	'_', 00H, 'i', 00H, 'n', 00H, '_', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, '(', 00H, 'p', 00H, ',', 00H, ' ', 00H, 'u', 00H
	DB	's', 00H, 'e', 00H, 'd', 00H, 'p', 00H, 'o', 00H, 'o', 00H, 'l'
	DB	00H, 's', 00H, '[', 00H, 's', 00H, 'z', 00H, ' ', 00H, '+', 00H
	DB	' ', 00H, 's', 00H, 'z', 00H, ']', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@JBCCFOIF@?$AAp?$AAo?$AAo?$AAl?$AA_?$AAi?$AAs?$AA_?$AAi?$AAn?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?$CI?$AAp?$AA?0?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAf?$AAr?$AAe@
CONST	SEGMENT
??_C@_1FA@JBCCFOIF@?$AAp?$AAo?$AAo?$AAl?$AA_?$AAi?$AAs?$AA_?$AAi?$AAn?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?$CI?$AAp?$AA?0?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAf?$AAr?$AAe@ DB 'p'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, '_', 00H, 'i', 00H, 's', 00H
	DB	'_', 00H, 'i', 00H, 'n', 00H, '_', 00H, 'l', 00H, 'i', 00H, 's'
	DB	00H, 't', 00H, '(', 00H, 'p', 00H, ',', 00H, ' ', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H, 's', 00H, '[', 00H, 'i'
	DB	00H, ']', 00H, '.', 00H, 'f', 00H, 'r', 00H, 'e', 00H, 'e', 00H
	DB	'p', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@PKOFODDM@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAu?$AAp?$AAt?$AAr?$AA?$CJ?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAp?$AAo?$AAo?$AAl?$AA_?$AAa?$AAd@
CONST	SEGMENT
??_C@_1EM@PKOFODDM@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAu?$AAp?$AAt?$AAr?$AA?$CJ?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAp?$AAo?$AAo?$AAl?$AA_?$AAa?$AAd@ DB 'b'
	DB	00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, '<', 00H, '=', 00H
	DB	' ', 00H, '(', 00H, 'u', 00H, 'p', 00H, 't', 00H, 'r', 00H, ')'
	DB	00H, ' ', 00H, 'a', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'a', 00H
	DB	's', 00H, '[', 00H, 'i', 00H, ']', 00H, '.', 00H, 'p', 00H, 'o'
	DB	00H, 'o', 00H, 'l', 00H, '_', 00H, 'a', 00H, 'd', 00H, 'd', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@PNOPCKMC@Small?5block?5threshold?5?$DN?5?$CFd?0?5in?5?$CF@
CONST	SEGMENT
??_C@_0DB@PNOPCKMC@Small?5block?5threshold?5?$DN?5?$CFd?0?5in?5?$CF@ DB 'S'
	DB	'mall block threshold = %d, in %u size classes.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OPOOMDLH@_PyObject_DebugMallocStats?$AA@
CONST	SEGMENT
??_C@_0BL@OPOOMDLH@_PyObject_DebugMallocStats?$AA@ DB '_PyObject_DebugMal'
	DB	'locStats', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyObject_DebugMallocStats
_TEXT	SEGMENT
available_bytes$ = 64
i$ = 72
numfreepools$ = 76
numclasses$ = 80
numblocks$ = 96
narenas$ = 608
numpools$ = 624
total$ = 1136
buf$ = 1152
quantization$ = 1280
numfreeblocks$ = 1296
allocated_bytes$ = 1808
pool_header_bytes$ = 1816
arena_alignment$ = 1824
base$21332 = 1832
j$21331 = 1840
p$21346 = 1848
freeblocks$21349 = 1856
sz$21348 = 1860
p$21368 = 1864
f$21370 = 1872
size$21371 = 1880
b$21369 = 1888
tv183 = 1896
tv251 = 1904
out$ = 1936
_PyObject_DebugMallocStats PROC				; COMDAT

; 1865 : {

$LN27:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 07
	00 00		 sub	 rsp, 1928		; 00000788H

; 1866 :     uint i;
; 1867 :     const uint numclasses = SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT;

  0000c	c7 44 24 50 40
	00 00 00	 mov	 DWORD PTR numclasses$[rsp], 64 ; 00000040H

; 1868 :     /* # of pools, allocated blocks, and free blocks per class index */
; 1869 :     size_t numpools[SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT];
; 1870 :     size_t numblocks[SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT];
; 1871 :     size_t numfreeblocks[SMALL_REQUEST_THRESHOLD >> ALIGNMENT_SHIFT];
; 1872 :     /* total # of allocated bytes in used and full pools */
; 1873 :     size_t allocated_bytes = 0;

  00014	48 c7 84 24 10
	07 00 00 00 00
	00 00		 mov	 QWORD PTR allocated_bytes$[rsp], 0

; 1874 :     /* total # of available bytes in used pools */
; 1875 :     size_t available_bytes = 0;

  00020	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR available_bytes$[rsp], 0

; 1876 :     /* # of free pools + pools not yet carved out of current arena */
; 1877 :     uint numfreepools = 0;

  00029	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR numfreepools$[rsp], 0

; 1878 :     /* # of bytes for arena alignment padding */
; 1879 :     size_t arena_alignment = 0;

  00031	48 c7 84 24 20
	07 00 00 00 00
	00 00		 mov	 QWORD PTR arena_alignment$[rsp], 0

; 1880 :     /* # of bytes in used and full pools used for pool_headers */
; 1881 :     size_t pool_header_bytes = 0;

  0003d	48 c7 84 24 18
	07 00 00 00 00
	00 00		 mov	 QWORD PTR pool_header_bytes$[rsp], 0

; 1882 :     /* # of bytes in used and full pools wasted due to quantization,
; 1883 :      * i.e. the necessarily leftover space at the ends of used and
; 1884 :      * full pools.
; 1885 :      */
; 1886 :     size_t quantization = 0;

  00049	48 c7 84 24 00
	05 00 00 00 00
	00 00		 mov	 QWORD PTR quantization$[rsp], 0

; 1887 :     /* # of arenas actually allocated. */
; 1888 :     size_t narenas = 0;

  00055	48 c7 84 24 60
	02 00 00 00 00
	00 00		 mov	 QWORD PTR narenas$[rsp], 0

; 1889 :     /* running total -- should equal narenas * ARENA_SIZE */
; 1890 :     size_t total;
; 1891 :     char buf[128];
; 1892 : 
; 1893 :     Py_GUARD

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 1c		 je	 SHORT $LN18@PyObject_D@10
  0006a	45 33 c9	 xor	 r9d, r9d
  0006d	41 b8 65 07 00
	00		 mov	 r8d, 1893		; 00000765H
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@OPOOMDLH@_PyObject_DebugMallocStats?$AA@
  00081	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN18@PyObject_D@10:

; 1894 : 
; 1895 :     fprintf(out, "Small block threshold = %d, in %u size classes.\n",
; 1896 :             SMALL_REQUEST_THRESHOLD, numclasses);

  00086	44 8b 4c 24 50	 mov	 r9d, DWORD PTR numclasses$[rsp]
  0008b	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@PNOPCKMC@Small?5block?5threshold?5?$DN?5?$CFd?0?5in?5?$CF@
  00098	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1897 : 
; 1898 :     for (i = 0; i < numclasses; ++i)

  000a6	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ae	eb 0a		 jmp	 SHORT $LN17@PyObject_D@10
$LN16@PyObject_D@10:
  000b0	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  000b4	ff c0		 inc	 eax
  000b6	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN17@PyObject_D@10:
  000ba	8b 44 24 50	 mov	 eax, DWORD PTR numclasses$[rsp]
  000be	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  000c2	73 2f		 jae	 SHORT $LN15@PyObject_D@10

; 1899 :         numpools[i] = numblocks[i] = numfreeblocks[i] = 0;

  000c4	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  000c8	48 c7 84 c4 10
	05 00 00 00 00
	00 00		 mov	 QWORD PTR numfreeblocks$[rsp+rax*8], 0
  000d4	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  000d8	48 c7 44 c4 60
	00 00 00 00	 mov	 QWORD PTR numblocks$[rsp+rax*8], 0
  000e1	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  000e5	48 c7 84 c4 70
	02 00 00 00 00
	00 00		 mov	 QWORD PTR numpools$[rsp+rax*8], 0
  000f1	eb bd		 jmp	 SHORT $LN16@PyObject_D@10
$LN15@PyObject_D@10:

; 1900 : 
; 1901 :     /* Because full pools aren't linked to from anything, it's easiest
; 1902 :      * to march over all the arenas.  If we're lucky, most of the memory
; 1903 :      * will be living in full pools -- would be a shame to miss them.
; 1904 :      */
; 1905 :     for (i = 0; i < maxarenas; ++i) {

  000f3	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000fb	eb 0a		 jmp	 SHORT $LN14@PyObject_D@10
$LN13@PyObject_D@10:
  000fd	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00101	ff c0		 inc	 eax
  00103	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN14@PyObject_D@10:
  00107	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR maxarenas
  0010d	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  00111	0f 83 c2 02 00
	00		 jae	 $LN12@PyObject_D@10

; 1906 :         uint j;
; 1907 :         uptr base = arenas[i].address;

  00117	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  0011b	48 6b c0 30	 imul	 rax, 48			; 00000030H
  0011f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  00126	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0012a	48 89 84 24 28
	07 00 00	 mov	 QWORD PTR base$21332[rsp], rax

; 1908 : 
; 1909 :         /* Skip arenas which are not allocated. */
; 1910 :         if (arenas[i].address == (uptr)NULL)

  00132	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00136	48 6b c0 30	 imul	 rax, 48			; 00000030H
  0013a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  00141	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00146	75 02		 jne	 SHORT $LN11@PyObject_D@10

; 1911 :             continue;

  00148	eb b3		 jmp	 SHORT $LN13@PyObject_D@10
$LN11@PyObject_D@10:

; 1912 :         narenas += 1;

  0014a	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR narenas$[rsp]
  00152	48 ff c0	 inc	 rax
  00155	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR narenas$[rsp], rax

; 1913 : 
; 1914 :         numfreepools += arenas[i].nfreepools;

  0015d	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00161	48 6b c0 30	 imul	 rax, 48			; 00000030H
  00165	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  0016c	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  00170	8b 4c 24 4c	 mov	 ecx, DWORD PTR numfreepools$[rsp]
  00174	03 c8		 add	 ecx, eax
  00176	8b c1		 mov	 eax, ecx
  00178	89 44 24 4c	 mov	 DWORD PTR numfreepools$[rsp], eax

; 1915 : 
; 1916 :         /* round up to pool alignment */
; 1917 :         if (base & (uptr)POOL_SIZE_MASK) {

  0017c	48 8b 84 24 28
	07 00 00	 mov	 rax, QWORD PTR base$21332[rsp]
  00184	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0018a	48 85 c0	 test	 rax, rax
  0018d	74 42		 je	 SHORT $LN10@PyObject_D@10

; 1918 :             arena_alignment += POOL_SIZE;

  0018f	48 8b 84 24 20
	07 00 00	 mov	 rax, QWORD PTR arena_alignment$[rsp]
  00197	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0019d	48 89 84 24 20
	07 00 00	 mov	 QWORD PTR arena_alignment$[rsp], rax

; 1919 :             base &= ~(uptr)POOL_SIZE_MASK;

  001a5	48 8b 84 24 28
	07 00 00	 mov	 rax, QWORD PTR base$21332[rsp]
  001ad	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  001b3	48 89 84 24 28
	07 00 00	 mov	 QWORD PTR base$21332[rsp], rax

; 1920 :             base += POOL_SIZE;

  001bb	48 8b 84 24 28
	07 00 00	 mov	 rax, QWORD PTR base$21332[rsp]
  001c3	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  001c9	48 89 84 24 28
	07 00 00	 mov	 QWORD PTR base$21332[rsp], rax
$LN10@PyObject_D@10:

; 1921 :         }
; 1922 : 
; 1923 :         /* visit every pool in the arena */
; 1924 :         assert(base <= (uptr) arenas[i].pool_address);

  001d1	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  001d5	48 6b c0 30	 imul	 rax, 48			; 00000030H
  001d9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  001e0	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  001e5	48 39 84 24 28
	07 00 00	 cmp	 QWORD PTR base$21332[rsp], rax
  001ed	76 1c		 jbe	 SHORT $LN21@PyObject_D@10
  001ef	41 b8 84 07 00
	00		 mov	 r8d, 1924		; 00000784H
  001f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@PKOFODDM@?$AAb?$AAa?$AAs?$AAe?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAu?$AAp?$AAt?$AAr?$AA?$CJ?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAp?$AAo?$AAo?$AAl?$AA_?$AAa?$AAd@
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00209	33 c0		 xor	 eax, eax
$LN21@PyObject_D@10:

; 1925 :         for (j = 0;
; 1926 :                     base < (uptr) arenas[i].pool_address;
; 1927 :                     ++j, base += POOL_SIZE) {

  0020b	c7 84 24 30 07
	00 00 00 00 00
	00		 mov	 DWORD PTR j$21331[rsp], 0
  00216	eb 26		 jmp	 SHORT $LN9@PyObject_D@10
$LN8@PyObject_D@10:
  00218	8b 84 24 30 07
	00 00		 mov	 eax, DWORD PTR j$21331[rsp]
  0021f	ff c0		 inc	 eax
  00221	89 84 24 30 07
	00 00		 mov	 DWORD PTR j$21331[rsp], eax
  00228	48 8b 84 24 28
	07 00 00	 mov	 rax, QWORD PTR base$21332[rsp]
  00230	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00236	48 89 84 24 28
	07 00 00	 mov	 QWORD PTR base$21332[rsp], rax
$LN9@PyObject_D@10:
  0023e	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00242	48 6b c0 30	 imul	 rax, 48			; 00000030H
  00246	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  0024d	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00252	48 39 84 24 28
	07 00 00	 cmp	 QWORD PTR base$21332[rsp], rax
  0025a	0f 83 74 01 00
	00		 jae	 $LN7@PyObject_D@10

; 1928 :             poolp p = (poolp)base;

  00260	48 8b 84 24 28
	07 00 00	 mov	 rax, QWORD PTR base$21332[rsp]
  00268	48 89 84 24 38
	07 00 00	 mov	 QWORD PTR p$21346[rsp], rax

; 1929 :             const uint sz = p->szidx;

  00270	48 8b 84 24 38
	07 00 00	 mov	 rax, QWORD PTR p$21346[rsp]
  00278	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0027b	89 84 24 44 07
	00 00		 mov	 DWORD PTR sz$21348[rsp], eax

; 1930 :             uint freeblocks;
; 1931 : 
; 1932 :             if (p->ref.count == 0) {

  00282	48 8b 84 24 38
	07 00 00	 mov	 rax, QWORD PTR p$21346[rsp]
  0028a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0028d	75 46		 jne	 SHORT $LN6@PyObject_D@10

; 1933 :                 /* currently unused */
; 1934 :                 assert(pool_is_in_list(p, arenas[i].freepools));

  0028f	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00293	48 6b c0 30	 imul	 rax, 48			; 00000030H
  00297	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  0029e	48 8b 54 01 18	 mov	 rdx, QWORD PTR [rcx+rax+24]
  002a3	48 8b 8c 24 38
	07 00 00	 mov	 rcx, QWORD PTR p$21346[rsp]
  002ab	e8 00 00 00 00	 call	 pool_is_in_list
  002b0	85 c0		 test	 eax, eax
  002b2	75 1c		 jne	 SHORT $LN22@PyObject_D@10
  002b4	41 b8 8e 07 00
	00		 mov	 r8d, 1934		; 0000078eH
  002ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  002c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FA@JBCCFOIF@?$AAp?$AAo?$AAo?$AAl?$AA_?$AAi?$AAs?$AA_?$AAi?$AAn?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?$CI?$AAp?$AA?0?$AA?5?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?4?$AAf?$AAr?$AAe@
  002c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002ce	33 c0		 xor	 eax, eax
$LN22@PyObject_D@10:

; 1935 :                 continue;

  002d0	e9 43 ff ff ff	 jmp	 $LN8@PyObject_D@10
$LN6@PyObject_D@10:

; 1936 :             }
; 1937 :             ++numpools[sz];

  002d5	8b 84 24 44 07
	00 00		 mov	 eax, DWORD PTR sz$21348[rsp]
  002dc	48 8b 84 c4 70
	02 00 00	 mov	 rax, QWORD PTR numpools$[rsp+rax*8]
  002e4	48 ff c0	 inc	 rax
  002e7	8b 8c 24 44 07
	00 00		 mov	 ecx, DWORD PTR sz$21348[rsp]
  002ee	48 89 84 cc 70
	02 00 00	 mov	 QWORD PTR numpools$[rsp+rcx*8], rax

; 1938 :             numblocks[sz] += p->ref.count;

  002f6	8b 84 24 44 07
	00 00		 mov	 eax, DWORD PTR sz$21348[rsp]
  002fd	48 8b 8c 24 38
	07 00 00	 mov	 rcx, QWORD PTR p$21346[rsp]
  00305	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00307	48 03 4c c4 60	 add	 rcx, QWORD PTR numblocks$[rsp+rax*8]
  0030c	48 8b c1	 mov	 rax, rcx
  0030f	8b 8c 24 44 07
	00 00		 mov	 ecx, DWORD PTR sz$21348[rsp]
  00316	48 89 44 cc 60	 mov	 QWORD PTR numblocks$[rsp+rcx*8], rax

; 1939 :             freeblocks = NUMBLOCKS(sz) - p->ref.count;

  0031b	8b 84 24 44 07
	00 00		 mov	 eax, DWORD PTR sz$21348[rsp]
  00322	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [rax*8+8]
  00329	89 84 24 68 07
	00 00		 mov	 DWORD PTR tv183[rsp], eax
  00330	33 d2		 xor	 edx, edx
  00332	b8 d0 0f 00 00	 mov	 eax, 4048		; 00000fd0H
  00337	8b 8c 24 68 07
	00 00		 mov	 ecx, DWORD PTR tv183[rsp]
  0033e	f7 f1		 div	 ecx
  00340	48 8b 8c 24 38
	07 00 00	 mov	 rcx, QWORD PTR p$21346[rsp]
  00348	2b 01		 sub	 eax, DWORD PTR [rcx]
  0034a	89 84 24 40 07
	00 00		 mov	 DWORD PTR freeblocks$21349[rsp], eax

; 1940 :             numfreeblocks[sz] += freeblocks;

  00351	8b 84 24 44 07
	00 00		 mov	 eax, DWORD PTR sz$21348[rsp]
  00358	8b 8c 24 40 07
	00 00		 mov	 ecx, DWORD PTR freeblocks$21349[rsp]
  0035f	48 03 8c c4 10
	05 00 00	 add	 rcx, QWORD PTR numfreeblocks$[rsp+rax*8]
  00367	48 8b c1	 mov	 rax, rcx
  0036a	8b 8c 24 44 07
	00 00		 mov	 ecx, DWORD PTR sz$21348[rsp]
  00371	48 89 84 cc 10
	05 00 00	 mov	 QWORD PTR numfreeblocks$[rsp+rcx*8], rax

; 1941 : #ifdef Py_DEBUG
; 1942 :             if (freeblocks > 0)

  00379	83 bc 24 40 07
	00 00 00	 cmp	 DWORD PTR freeblocks$21349[rsp], 0
  00381	76 4c		 jbe	 SHORT $LN5@PyObject_D@10

; 1943 :                 assert(pool_is_in_list(p, usedpools[sz + sz]));

  00383	8b 84 24 44 07
	00 00		 mov	 eax, DWORD PTR sz$21348[rsp]
  0038a	8b 8c 24 44 07
	00 00		 mov	 ecx, DWORD PTR sz$21348[rsp]
  00391	03 c8		 add	 ecx, eax
  00393	8b c1		 mov	 eax, ecx
  00395	8b c0		 mov	 eax, eax
  00397	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:usedpools
  0039e	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  003a2	48 8b 8c 24 38
	07 00 00	 mov	 rcx, QWORD PTR p$21346[rsp]
  003aa	e8 00 00 00 00	 call	 pool_is_in_list
  003af	85 c0		 test	 eax, eax
  003b1	75 1c		 jne	 SHORT $LN23@PyObject_D@10
  003b3	41 b8 97 07 00
	00		 mov	 r8d, 1943		; 00000797H
  003b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  003c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@NDDCLEGG@?$AAp?$AAo?$AAo?$AAl?$AA_?$AAi?$AAs?$AA_?$AAi?$AAn?$AA_?$AAl?$AAi?$AAs?$AAt?$AA?$CI?$AAp?$AA?0?$AA?5?$AAu?$AAs?$AAe?$AAd?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?$FL?$AAs?$AAz?$AA?5@
  003c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  003cd	33 c0		 xor	 eax, eax
$LN23@PyObject_D@10:
$LN5@PyObject_D@10:

; 1944 : #endif
; 1945 :         }

  003cf	e9 44 fe ff ff	 jmp	 $LN8@PyObject_D@10
$LN7@PyObject_D@10:

; 1946 :     }

  003d4	e9 24 fd ff ff	 jmp	 $LN13@PyObject_D@10
$LN12@PyObject_D@10:

; 1947 :     assert(narenas == narenas_currently_allocated);

  003d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR narenas_currently_allocated
  003e0	48 39 84 24 60
	02 00 00	 cmp	 QWORD PTR narenas$[rsp], rax
  003e8	74 1c		 je	 SHORT $LN24@PyObject_D@10
  003ea	41 b8 9b 07 00
	00		 mov	 r8d, 1947		; 0000079bH
  003f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  003f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@ELBBAFGH@?$AAn?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAa?$AAr?$AAe?$AAn?$AAa?$AAs?$AA_?$AAc?$AAu?$AAr?$AAr?$AAe?$AAn?$AAt?$AAl?$AAy?$AA_?$AAa?$AAl?$AAl@
  003fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00404	33 c0		 xor	 eax, eax
$LN24@PyObject_D@10:

; 1948 : 
; 1949 :     fputc('\n', out);

  00406	48 8b 94 24 90
	07 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  0040e	b9 0a 00 00 00	 mov	 ecx, 10
  00413	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 1950 :     fputs("class   size   num pools   blocks in use  avail blocks\n"
; 1951 :           "-----   ----   ---------   -------------  ------------\n",
; 1952 :           out);

  00419	48 8b 94 24 90
	07 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00421	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0GP@CMHKANCA@class?5?5?5size?5?5?5num?5pools?5?5?5block@
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputs

; 1953 : 
; 1954 :     for (i = 0; i < numclasses; ++i) {

  0042e	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00436	eb 0a		 jmp	 SHORT $LN4@PyObject_D@10
$LN3@PyObject_D@10:
  00438	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  0043c	ff c0		 inc	 eax
  0043e	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN4@PyObject_D@10:
  00442	8b 44 24 50	 mov	 eax, DWORD PTR numclasses$[rsp]
  00446	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  0044a	0f 83 98 01 00
	00		 jae	 $LN2@PyObject_D@10

; 1955 :         size_t p = numpools[i];

  00450	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00454	48 8b 84 c4 70
	02 00 00	 mov	 rax, QWORD PTR numpools$[rsp+rax*8]
  0045c	48 89 84 24 48
	07 00 00	 mov	 QWORD PTR p$21368[rsp], rax

; 1956 :         size_t b = numblocks[i];

  00464	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00468	48 8b 44 c4 60	 mov	 rax, QWORD PTR numblocks$[rsp+rax*8]
  0046d	48 89 84 24 60
	07 00 00	 mov	 QWORD PTR b$21369[rsp], rax

; 1957 :         size_t f = numfreeblocks[i];

  00475	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00479	48 8b 84 c4 10
	05 00 00	 mov	 rax, QWORD PTR numfreeblocks$[rsp+rax*8]
  00481	48 89 84 24 50
	07 00 00	 mov	 QWORD PTR f$21370[rsp], rax

; 1958 :         uint size = INDEX2SIZE(i);

  00489	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  0048d	8d 04 c5 08 00
	00 00		 lea	 eax, DWORD PTR [rax*8+8]
  00494	89 84 24 58 07
	00 00		 mov	 DWORD PTR size$21371[rsp], eax

; 1959 :         if (p == 0) {

  0049b	48 83 bc 24 48
	07 00 00 00	 cmp	 QWORD PTR p$21368[rsp], 0
  004a4	75 37		 jne	 SHORT $LN1@PyObject_D@10

; 1960 :             assert(b == 0 && f == 0);

  004a6	48 83 bc 24 60
	07 00 00 00	 cmp	 QWORD PTR b$21369[rsp], 0
  004af	75 0b		 jne	 SHORT $LN25@PyObject_D@10
  004b1	48 83 bc 24 50
	07 00 00 00	 cmp	 QWORD PTR f$21370[rsp], 0
  004ba	74 1c		 je	 SHORT $LN26@PyObject_D@10
$LN25@PyObject_D@10:
  004bc	41 b8 a8 07 00
	00		 mov	 r8d, 1960		; 000007a8H
  004c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  004c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@BHEBKDII@?$AAb?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAf?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  004d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  004d6	33 c0		 xor	 eax, eax
$LN26@PyObject_D@10:

; 1961 :             continue;

  004d8	e9 5b ff ff ff	 jmp	 $LN3@PyObject_D@10
$LN1@PyObject_D@10:

; 1962 :         }
; 1963 :         fprintf(out, "%5u %6u "
; 1964 :                         "%11" PY_FORMAT_SIZE_T "u "
; 1965 :                         "%15" PY_FORMAT_SIZE_T "u "
; 1966 :                         "%13" PY_FORMAT_SIZE_T "u\n",
; 1967 :                 i, size, p, b, f);

  004dd	48 8b 84 24 50
	07 00 00	 mov	 rax, QWORD PTR f$21370[rsp]
  004e5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  004ea	48 8b 84 24 60
	07 00 00	 mov	 rax, QWORD PTR b$21369[rsp]
  004f2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004f7	48 8b 84 24 48
	07 00 00	 mov	 rax, QWORD PTR p$21368[rsp]
  004ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00504	44 8b 8c 24 58
	07 00 00	 mov	 r9d, DWORD PTR size$21371[rsp]
  0050c	44 8b 44 24 48	 mov	 r8d, DWORD PTR i$[rsp]
  00511	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@KKKLDLHO@?$CF5u?5?$CF6u?5?$CF11Iu?5?$CF15Iu?5?$CF13Iu?6?$AA@
  00518	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00520	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1968 :         allocated_bytes += b * size;

  00526	8b 84 24 58 07
	00 00		 mov	 eax, DWORD PTR size$21371[rsp]
  0052d	48 8b 8c 24 60
	07 00 00	 mov	 rcx, QWORD PTR b$21369[rsp]
  00535	48 0f af c8	 imul	 rcx, rax
  00539	48 8b c1	 mov	 rax, rcx
  0053c	48 8b 8c 24 10
	07 00 00	 mov	 rcx, QWORD PTR allocated_bytes$[rsp]
  00544	48 03 c8	 add	 rcx, rax
  00547	48 8b c1	 mov	 rax, rcx
  0054a	48 89 84 24 10
	07 00 00	 mov	 QWORD PTR allocated_bytes$[rsp], rax

; 1969 :         available_bytes += f * size;

  00552	8b 84 24 58 07
	00 00		 mov	 eax, DWORD PTR size$21371[rsp]
  00559	48 8b 8c 24 50
	07 00 00	 mov	 rcx, QWORD PTR f$21370[rsp]
  00561	48 0f af c8	 imul	 rcx, rax
  00565	48 8b c1	 mov	 rax, rcx
  00568	48 8b 4c 24 40	 mov	 rcx, QWORD PTR available_bytes$[rsp]
  0056d	48 03 c8	 add	 rcx, rax
  00570	48 8b c1	 mov	 rax, rcx
  00573	48 89 44 24 40	 mov	 QWORD PTR available_bytes$[rsp], rax

; 1970 :         pool_header_bytes += p * POOL_OVERHEAD;

  00578	48 8b 84 24 48
	07 00 00	 mov	 rax, QWORD PTR p$21368[rsp]
  00580	48 6b c0 30	 imul	 rax, 48			; 00000030H
  00584	48 8b 8c 24 18
	07 00 00	 mov	 rcx, QWORD PTR pool_header_bytes$[rsp]
  0058c	48 03 c8	 add	 rcx, rax
  0058f	48 8b c1	 mov	 rax, rcx
  00592	48 89 84 24 18
	07 00 00	 mov	 QWORD PTR pool_header_bytes$[rsp], rax

; 1971 :         quantization += p * ((POOL_SIZE - POOL_OVERHEAD) % size);

  0059a	8b 84 24 58 07
	00 00		 mov	 eax, DWORD PTR size$21371[rsp]
  005a1	48 89 84 24 70
	07 00 00	 mov	 QWORD PTR tv251[rsp], rax
  005a9	33 d2		 xor	 edx, edx
  005ab	b8 d0 0f 00 00	 mov	 eax, 4048		; 00000fd0H
  005b0	48 8b 8c 24 70
	07 00 00	 mov	 rcx, QWORD PTR tv251[rsp]
  005b8	48 f7 f1	 div	 rcx
  005bb	48 8b c2	 mov	 rax, rdx
  005be	48 8b 8c 24 48
	07 00 00	 mov	 rcx, QWORD PTR p$21368[rsp]
  005c6	48 0f af c8	 imul	 rcx, rax
  005ca	48 8b c1	 mov	 rax, rcx
  005cd	48 8b 8c 24 00
	05 00 00	 mov	 rcx, QWORD PTR quantization$[rsp]
  005d5	48 03 c8	 add	 rcx, rax
  005d8	48 8b c1	 mov	 rax, rcx
  005db	48 89 84 24 00
	05 00 00	 mov	 QWORD PTR quantization$[rsp], rax

; 1972 :     }

  005e3	e9 50 fe ff ff	 jmp	 $LN3@PyObject_D@10
$LN2@PyObject_D@10:

; 1973 :     fputc('\n', out);

  005e8	48 8b 94 24 90
	07 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  005f0	b9 0a 00 00 00	 mov	 ecx, 10
  005f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 1974 : #ifdef PYMALLOC_DEBUG
; 1975 :     (void)printone(out, "# times object malloc called", serialno);

  005fb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR serialno
  00602	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@JMNCPGGM@?$CD?5times?5object?5malloc?5called?$AA@
  00609	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00611	e8 00 00 00 00	 call	 printone

; 1976 : #endif
; 1977 :     (void)printone(out, "# arenas allocated total", ntimes_arena_allocated);

  00616	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ntimes_arena_allocated
  0061d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@BBJOHCGI@?$CD?5arenas?5allocated?5total?$AA@
  00624	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0062c	e8 00 00 00 00	 call	 printone

; 1978 :     (void)printone(out, "# arenas reclaimed", ntimes_arena_allocated - narenas);

  00631	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR narenas$[rsp]
  00639	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ntimes_arena_allocated
  00640	48 2b c8	 sub	 rcx, rax
  00643	48 8b c1	 mov	 rax, rcx
  00646	4c 8b c0	 mov	 r8, rax
  00649	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@EGEFNLBB@?$CD?5arenas?5reclaimed?$AA@
  00650	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00658	e8 00 00 00 00	 call	 printone

; 1979 :     (void)printone(out, "# arenas highwater mark", narenas_highwater);

  0065d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR narenas_highwater
  00664	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@NDJBDOMD@?$CD?5arenas?5highwater?5mark?$AA@
  0066b	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00673	e8 00 00 00 00	 call	 printone

; 1980 :     (void)printone(out, "# arenas allocated current", narenas);

  00678	4c 8b 84 24 60
	02 00 00	 mov	 r8, QWORD PTR narenas$[rsp]
  00680	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@CDPEAAIO@?$CD?5arenas?5allocated?5current?$AA@
  00687	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0068f	e8 00 00 00 00	 call	 printone

; 1981 : 
; 1982 :     PyOS_snprintf(buf, sizeof(buf),
; 1983 :         "%" PY_FORMAT_SIZE_T "u arenas * %d bytes/arena",
; 1984 :         narenas, ARENA_SIZE);

  00694	c7 44 24 20 00
	00 04 00	 mov	 DWORD PTR [rsp+32], 262144 ; 00040000H
  0069c	4c 8b 8c 24 60
	02 00 00	 mov	 r9, QWORD PTR narenas$[rsp]
  006a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BM@EMIIMIHN@?$CFIu?5arenas?5?$CK?5?$CFd?5bytes?1arena?$AA@
  006ab	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  006b0	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  006b8	e8 00 00 00 00	 call	 PyOS_snprintf

; 1985 :     (void)printone(out, buf, narenas * ARENA_SIZE);

  006bd	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR narenas$[rsp]
  006c5	48 69 c0 00 00
	04 00		 imul	 rax, 262144		; 00040000H
  006cc	4c 8b c0	 mov	 r8, rax
  006cf	48 8d 94 24 80
	04 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  006d7	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  006df	e8 00 00 00 00	 call	 printone

; 1986 : 
; 1987 :     fputc('\n', out);

  006e4	48 8b 94 24 90
	07 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  006ec	b9 0a 00 00 00	 mov	 ecx, 10
  006f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 1988 : 
; 1989 :     total = printone(out, "# bytes in allocated blocks", allocated_bytes);

  006f7	4c 8b 84 24 10
	07 00 00	 mov	 r8, QWORD PTR allocated_bytes$[rsp]
  006ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@DGPGANCG@?$CD?5bytes?5in?5allocated?5blocks?$AA@
  00706	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0070e	e8 00 00 00 00	 call	 printone
  00713	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR total$[rsp], rax

; 1990 :     total += printone(out, "# bytes in available blocks", available_bytes);

  0071b	4c 8b 44 24 40	 mov	 r8, QWORD PTR available_bytes$[rsp]
  00720	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@KKPDFEBK@?$CD?5bytes?5in?5available?5blocks?$AA@
  00727	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0072f	e8 00 00 00 00	 call	 printone
  00734	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR total$[rsp]
  0073c	48 03 c8	 add	 rcx, rax
  0073f	48 8b c1	 mov	 rax, rcx
  00742	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR total$[rsp], rax

; 1991 : 
; 1992 :     PyOS_snprintf(buf, sizeof(buf),
; 1993 :         "%u unused pools * %d bytes", numfreepools, POOL_SIZE);

  0074a	c7 44 24 20 00
	10 00 00	 mov	 DWORD PTR [rsp+32], 4096 ; 00001000H
  00752	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR numfreepools$[rsp]
  00757	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BL@FMCCONMC@?$CFu?5unused?5pools?5?$CK?5?$CFd?5bytes?$AA@
  0075e	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00763	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0076b	e8 00 00 00 00	 call	 PyOS_snprintf

; 1994 :     total += printone(out, buf, (size_t)numfreepools * POOL_SIZE);

  00770	8b 44 24 4c	 mov	 eax, DWORD PTR numfreepools$[rsp]
  00774	48 69 c0 00 10
	00 00		 imul	 rax, 4096		; 00001000H
  0077b	4c 8b c0	 mov	 r8, rax
  0077e	48 8d 94 24 80
	04 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00786	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0078e	e8 00 00 00 00	 call	 printone
  00793	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR total$[rsp]
  0079b	48 03 c8	 add	 rcx, rax
  0079e	48 8b c1	 mov	 rax, rcx
  007a1	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR total$[rsp], rax

; 1995 : 
; 1996 :     total += printone(out, "# bytes lost to pool headers", pool_header_bytes);

  007a9	4c 8b 84 24 18
	07 00 00	 mov	 r8, QWORD PTR pool_header_bytes$[rsp]
  007b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@OBJGCACO@?$CD?5bytes?5lost?5to?5pool?5headers?$AA@
  007b8	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  007c0	e8 00 00 00 00	 call	 printone
  007c5	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR total$[rsp]
  007cd	48 03 c8	 add	 rcx, rax
  007d0	48 8b c1	 mov	 rax, rcx
  007d3	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR total$[rsp], rax

; 1997 :     total += printone(out, "# bytes lost to quantization", quantization);

  007db	4c 8b 84 24 00
	05 00 00	 mov	 r8, QWORD PTR quantization$[rsp]
  007e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DPIKIPML@?$CD?5bytes?5lost?5to?5quantization?$AA@
  007ea	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  007f2	e8 00 00 00 00	 call	 printone
  007f7	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR total$[rsp]
  007ff	48 03 c8	 add	 rcx, rax
  00802	48 8b c1	 mov	 rax, rcx
  00805	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR total$[rsp], rax

; 1998 :     total += printone(out, "# bytes lost to arena alignment", arena_alignment);

  0080d	4c 8b 84 24 20
	07 00 00	 mov	 r8, QWORD PTR arena_alignment$[rsp]
  00815	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@GBCGKCEO@?$CD?5bytes?5lost?5to?5arena?5alignment?$AA@
  0081c	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00824	e8 00 00 00 00	 call	 printone
  00829	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR total$[rsp]
  00831	48 03 c8	 add	 rcx, rax
  00834	48 8b c1	 mov	 rax, rcx
  00837	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR total$[rsp], rax

; 1999 :     (void)printone(out, "Total", total);

  0083f	4c 8b 84 24 70
	04 00 00	 mov	 r8, QWORD PTR total$[rsp]
  00847	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KGEAEGFG@Total?$AA@
  0084e	48 8b 8c 24 90
	07 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00856	e8 00 00 00 00	 call	 printone

; 2000 : }

  0085b	48 81 c4 88 07
	00 00		 add	 rsp, 1928		; 00000788H
  00862	c3		 ret	 0
_PyObject_DebugMallocStats ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BO@JMGLLOKI@?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@KPIKHKHP@pool_is_in_list?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$pool_is_in_list DD imagerel pool_is_in_list
	DD	imagerel pool_is_in_list+169
	DD	imagerel $unwind$pool_is_in_list
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$pool_is_in_list DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1BO@JMGLLOKI@?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@JMGLLOKI@?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'a', 00H, 'r', 00H, 'g', 00H, 'e', 00H, 't', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KPIKHKHP@pool_is_in_list?$AA@
CONST	SEGMENT
??_C@_0BA@KPIKHKHP@pool_is_in_list?$AA@ DB 'pool_is_in_list', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT pool_is_in_list
_TEXT	SEGMENT
origlist$ = 32
target$ = 64
list$ = 72
pool_is_in_list PROC					; COMDAT

; 1439 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1440 :     poolp origlist = list;

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR list$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR origlist$[rsp], rax

; 1441 :     Py_GUARD

  00018	e8 00 00 00 00	 call	 _Py_PXCTX
  0001d	85 c0		 test	 eax, eax
  0001f	74 1c		 je	 SHORT $LN7@pool_is_in
  00021	45 33 c9	 xor	 r9d, r9d
  00024	41 b8 a1 05 00
	00		 mov	 r8d, 1441		; 000005a1H
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KPIKHKHP@pool_is_in_list?$AA@
  00038	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN7@pool_is_in:

; 1442 :     assert(target != NULL);

  0003d	48 83 7c 24 40
	00		 cmp	 QWORD PTR target$[rsp], 0
  00043	75 1c		 jne	 SHORT $LN10@pool_is_in
  00045	41 b8 a2 05 00
	00		 mov	 r8d, 1442		; 000005a2H
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@JMGLLOKI@?$AAt?$AAa?$AAr?$AAg?$AAe?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0005f	33 c0		 xor	 eax, eax
$LN10@pool_is_in:

; 1443 :     if (list == NULL)

  00061	48 83 7c 24 48
	00		 cmp	 QWORD PTR list$[rsp], 0
  00067	75 04		 jne	 SHORT $LN6@pool_is_in

; 1444 :         return 0;

  00069	33 c0		 xor	 eax, eax
  0006b	eb 37		 jmp	 SHORT $LN8@pool_is_in
$LN6@pool_is_in:
$LN5@pool_is_in:

; 1445 :     do {
; 1446 :         if (target == list)

  0006d	48 8b 44 24 48	 mov	 rax, QWORD PTR list$[rsp]
  00072	48 39 44 24 40	 cmp	 QWORD PTR target$[rsp], rax
  00077	75 07		 jne	 SHORT $LN2@pool_is_in

; 1447 :             return 1;

  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	eb 24		 jmp	 SHORT $LN8@pool_is_in
$LN2@pool_is_in:

; 1448 :         list = list->nextpool;

  00080	48 8b 44 24 48	 mov	 rax, QWORD PTR list$[rsp]
  00085	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00089	48 89 44 24 48	 mov	 QWORD PTR list$[rsp], rax

; 1449 :     } while (list != NULL && list != origlist);

  0008e	48 83 7c 24 48
	00		 cmp	 QWORD PTR list$[rsp], 0
  00094	74 0c		 je	 SHORT $LN1@pool_is_in
  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR origlist$[rsp]
  0009b	48 39 44 24 48	 cmp	 QWORD PTR list$[rsp], rax
  000a0	75 cb		 jne	 SHORT $LN5@pool_is_in
$LN1@pool_is_in:

; 1450 :     return 0;

  000a2	33 c0		 xor	 eax, eax
$LN8@pool_is_in:

; 1451 : }

  000a4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a8	c3		 ret	 0
pool_is_in_list ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@DJPPDJCJ@Py_ADDRESS_IN_RANGE?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_ADDRESS_IN_RANGE DD imagerel $LN6
	DD	imagerel $LN6+162
	DD	imagerel $unwind$Py_ADDRESS_IN_RANGE
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_ADDRESS_IN_RANGE DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BE@DJPPDJCJ@Py_ADDRESS_IN_RANGE?$AA@
CONST	SEGMENT
??_C@_0BE@DJPPDJCJ@Py_ADDRESS_IN_RANGE?$AA@ DB 'Py_ADDRESS_IN_RANGE', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT Py_ADDRESS_IN_RANGE
_TEXT	SEGMENT
arenaindex_temp$ = 32
tv81 = 36
P$ = 64
pool$ = 72
Py_ADDRESS_IN_RANGE PROC				; COMDAT

; 2010 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2011 :     uint arenaindex_temp;
; 2012 :     Py_GUARD

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 1c		 je	 SHORT $LN1@Py_ADDRESS
  00017	45 33 c9	 xor	 r9d, r9d
  0001a	41 b8 dc 07 00
	00		 mov	 r8d, 2012		; 000007dcH
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PMODNIDG@?4?4?2Objects?2obmalloc?4c?$AA@
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@DJPPDJCJ@Py_ADDRESS_IN_RANGE?$AA@
  0002e	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN1@Py_ADDRESS:

; 2013 :     arenaindex_temp = pool->arenaindex;

  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR pool$[rsp]
  00038	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  0003b	89 44 24 20	 mov	 DWORD PTR arenaindex_temp$[rsp], eax

; 2014 : 
; 2015 :     return arenaindex_temp < maxarenas &&
; 2016 :            (uptr)P - arenas[arenaindex_temp].address < (uptr)ARENA_SIZE &&
; 2017 :            arenas[arenaindex_temp].address != 0;

  0003f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR maxarenas
  00045	39 44 24 20	 cmp	 DWORD PTR arenaindex_temp$[rsp], eax
  00049	73 46		 jae	 SHORT $LN4@Py_ADDRESS
  0004b	8b 44 24 20	 mov	 eax, DWORD PTR arenaindex_temp$[rsp]
  0004f	48 6b c0 30	 imul	 rax, 48			; 00000030H
  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  0005a	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR P$[rsp]
  00063	48 2b c8	 sub	 rcx, rax
  00066	48 8b c1	 mov	 rax, rcx
  00069	48 3d 00 00 04
	00		 cmp	 rax, 262144		; 00040000H
  0006f	73 20		 jae	 SHORT $LN4@Py_ADDRESS
  00071	8b 44 24 20	 mov	 eax, DWORD PTR arenaindex_temp$[rsp]
  00075	48 6b c0 30	 imul	 rax, 48			; 00000030H
  00079	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  00080	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00085	74 0a		 je	 SHORT $LN4@Py_ADDRESS
  00087	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  0008f	eb 08		 jmp	 SHORT $LN5@Py_ADDRESS
$LN4@Py_ADDRESS:
  00091	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN5@Py_ADDRESS:
  00099	8b 44 24 24	 mov	 eax, DWORD PTR tv81[rsp]

; 2018 : }

  0009d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a1	c3		 ret	 0
Py_ADDRESS_IN_RANGE ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@OCMFKKFJ@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA2?$AA?$AA@ ; `string'
PUBLIC	_PyMem_InRange
EXTRN	__C_specific_handler:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyMem_InRange DD imagerel $LN18
	DD	imagerel $LN18+432
	DD	imagerel $unwind$_PyMem_InRange
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyMem_InRange$filt$0 DD imagerel _PyMem_InRange$filt$0
	DD	imagerel _PyMem_InRange$filt$0+61
	DD	imagerel $unwind$_PyMem_InRange$filt$0
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyMem_InRange$filt$0 DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyMem_InRange DD 020c09H
	DD	013010cH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN18+77
	DD	imagerel $LN18+91
	DD	imagerel _PyMem_InRange$filt$0
	DD	imagerel $LN18+91
xdata	ENDS
;	COMDAT ??_C@_1CE@OCMFKKFJ@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA2?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@OCMFKKFJ@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA2?$AA?$AA@ DB 'r'
	DB	00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u'
	DB	00H, 'l', 00H, 't', 00H, '2', 00H, 00H, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PyMem_InRange
_TEXT	SEGMENT
v$ = 32
result2$ = 40
invalid$ = 44
up$ = 48
addr2$ = 56
arena$ = 64
pdiff$ = 72
arenaindex_temp$ = 80
result$ = 84
ap$ = 88
address$ = 96
pool$ = 104
$T122045 = 112
$T122046 = 120
tv68 = 124
tv93 = 128
m$ = 160
_PyMem_InRange PROC					; COMDAT

; 2026 : {

$LN18:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2027 :     struct arena_object *arena;
; 2028 :     uint arenaindex_temp;
; 2029 :     uptr address;
; 2030 :     uptr addr2;
; 2031 :     uptr up;
; 2032 :     uptr pdiff;
; 2033 :     poolp pool;
; 2034 :     int invalid = 0;

  0000c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR invalid$[rsp], 0

; 2035 :     int result = 0;

  00014	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 2036 :     int result2 = 0;

  0001c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR result2$[rsp], 0

; 2037 :     void *v;
; 2038 :     struct arena_object *ap = NULL;

  00024	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR ap$[rsp], 0

; 2039 : 
; 2040 :     up = (uptr)m;

  0002d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00035	48 89 44 24 30	 mov	 QWORD PTR up$[rsp], rax

; 2041 :     pool = POOL_ADDR(m);

  0003a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  00042	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00048	48 89 44 24 68	 mov	 QWORD PTR pool$[rsp], rax

; 2042 :     READ_LOCK();
; 2043 :     __try {
; 2044 :         arenaindex_temp = pool->arenaindex;

  0004d	48 8b 44 24 68	 mov	 rax, QWORD PTR pool$[rsp]
  00052	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00055	89 44 24 50	 mov	 DWORD PTR arenaindex_temp$[rsp], eax

; 2045 :     } __except(

  00059	eb 08		 jmp	 SHORT $LN17@PyMem_InRa
$LN15@PyMem_InRa:

; 2046 :         GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
; 2047 :             EXCEPTION_EXECUTE_HANDLER :
; 2048 :             EXCEPTION_CONTINUE_SEARCH
; 2049 :     ) {
; 2050 :         invalid = 1;

  0005b	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR invalid$[rsp], 1
$LN17@PyMem_InRa:

; 2051 :     }
; 2052 :     if (invalid)

  00063	83 7c 24 2c 00	 cmp	 DWORD PTR invalid$[rsp], 0
  00068	74 05		 je	 SHORT $LN4@PyMem_InRa

; 2053 :         goto end;

  0006a	e9 35 01 00 00	 jmp	 $end$121550
$LN4@PyMem_InRa:

; 2054 : 
; 2055 :     if (arenaindex_temp < maxarenas) {

  0006f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR maxarenas
  00075	39 44 24 50	 cmp	 DWORD PTR arenaindex_temp$[rsp], eax
  00079	0f 83 91 00 00
	00		 jae	 $LN3@PyMem_InRa

; 2056 :         v = (void *)arenas[arenaindex_temp].address;

  0007f	8b 44 24 50	 mov	 eax, DWORD PTR arenaindex_temp$[rsp]
  00083	48 6b c0 30	 imul	 rax, 48			; 00000030H
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  0008e	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00092	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2057 :         ap = (struct arena_object *)v;

  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  0009c	48 89 44 24 58	 mov	 QWORD PTR ap$[rsp], rax

; 2058 :         addr2 = arenas[arenaindex_temp].address;

  000a1	8b 44 24 50	 mov	 eax, DWORD PTR arenaindex_temp$[rsp]
  000a5	48 6b c0 30	 imul	 rax, 48			; 00000030H
  000a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  000b0	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000b4	48 89 44 24 38	 mov	 QWORD PTR addr2$[rsp], rax

; 2059 :         arena = &arenas[arenaindex_temp];

  000b9	8b 44 24 50	 mov	 eax, DWORD PTR arenaindex_temp$[rsp]
  000bd	48 6b c0 30	 imul	 rax, 48			; 00000030H
  000c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  000c8	48 03 c8	 add	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	48 89 44 24 40	 mov	 QWORD PTR arena$[rsp], rax

; 2060 :         address = arena->address;

  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR arena$[rsp]
  000d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000db	48 89 44 24 60	 mov	 QWORD PTR address$[rsp], rax

; 2061 :         pdiff = up - address;

  000e0	48 8b 44 24 60	 mov	 rax, QWORD PTR address$[rsp]
  000e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR up$[rsp]
  000ea	48 2b c8	 sub	 rcx, rax
  000ed	48 8b c1	 mov	 rax, rcx
  000f0	48 89 44 24 48	 mov	 QWORD PTR pdiff$[rsp], rax

; 2062 :         if (pdiff < (uptr)ARENA_SIZE)

  000f5	48 81 7c 24 48
	00 00 04 00	 cmp	 QWORD PTR pdiff$[rsp], 262144 ; 00040000H
  000fe	73 10		 jae	 SHORT $LN3@PyMem_InRa

; 2063 :             if (address != 0)

  00100	48 83 7c 24 60
	00		 cmp	 QWORD PTR address$[rsp], 0
  00106	74 08		 je	 SHORT $LN3@PyMem_InRa

; 2064 :                 result = 1;

  00108	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR result$[rsp], 1
$LN3@PyMem_InRa:

; 2065 :     }
; 2066 :     result2 = arenaindex_temp < maxarenas &&
; 2067 :            (uptr)m - arenas[arenaindex_temp].address < (uptr)ARENA_SIZE &&
; 2068 :            arenas[arenaindex_temp].address != 0;

  00110	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR maxarenas
  00116	39 44 24 50	 cmp	 DWORD PTR arenaindex_temp$[rsp], eax
  0011a	73 4c		 jae	 SHORT $LN10@PyMem_InRa
  0011c	8b 44 24 50	 mov	 eax, DWORD PTR arenaindex_temp$[rsp]
  00120	48 6b c0 30	 imul	 rax, 48			; 00000030H
  00124	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  0012b	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0012f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR m$[rsp]
  00137	48 2b c8	 sub	 rcx, rax
  0013a	48 8b c1	 mov	 rax, rcx
  0013d	48 3d 00 00 04
	00		 cmp	 rax, 262144		; 00040000H
  00143	73 23		 jae	 SHORT $LN10@PyMem_InRa
  00145	8b 44 24 50	 mov	 eax, DWORD PTR arenaindex_temp$[rsp]
  00149	48 6b c0 30	 imul	 rax, 48			; 00000030H
  0014d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR arenas
  00154	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00159	74 0d		 je	 SHORT $LN10@PyMem_InRa
  0015b	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv93[rsp], 1
  00166	eb 0b		 jmp	 SHORT $LN11@PyMem_InRa
$LN10@PyMem_InRa:
  00168	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv93[rsp], 0
$LN11@PyMem_InRa:
  00173	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv93[rsp]
  0017a	89 44 24 28	 mov	 DWORD PTR result2$[rsp], eax

; 2069 :     assert(result == result2);

  0017e	8b 44 24 28	 mov	 eax, DWORD PTR result2$[rsp]
  00182	39 44 24 54	 cmp	 DWORD PTR result$[rsp], eax
  00186	74 1c		 je	 SHORT $end$121550
  00188	41 b8 15 08 00
	00		 mov	 r8d, 2069		; 00000815H
  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@FNFCCKMN@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAo?$AAb?$AAm?$AAa?$AAl?$AAl?$AAo?$AAc?$AA?4?$AAc?$AA?$AA@
  00195	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@OCMFKKFJ@?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA2?$AA?$AA@
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001a2	33 c0		 xor	 eax, eax
$end$121550:

; 2070 : end:
; 2071 :     READ_UNLOCK();
; 2072 :     return result;

  001a4	8b 44 24 54	 mov	 eax, DWORD PTR result$[rsp]
$LN13@PyMem_InRa:

; 2073 : }

  001a8	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001af	c3		 ret	 0
_PyMem_InRange ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
v$ = 32
result2$ = 40
invalid$ = 44
up$ = 48
addr2$ = 56
arena$ = 64
pdiff$ = 72
arenaindex_temp$ = 80
result$ = 84
ap$ = 88
address$ = 96
pool$ = 104
$T122045 = 112
$T122046 = 120
tv68 = 124
tv93 = 128
m$ = 160
_PyMem_InRange$filt$0 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
$LN14@PyMem_InRa@2:

; 2049 :     ) {

  00009	48 89 4d 70	 mov	 QWORD PTR $T122045[rbp], rcx
  0000d	48 8b 45 70	 mov	 rax, QWORD PTR $T122045[rbp]
  00011	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00014	8b 00		 mov	 eax, DWORD PTR [rax]
  00016	89 45 78	 mov	 DWORD PTR $T122046[rbp], eax
  00019	8b 45 78	 mov	 eax, DWORD PTR $T122046[rbp]
  0001c	3d 05 00 00 c0	 cmp	 eax, -1073741819	; c0000005H
  00021	75 09		 jne	 SHORT $LN8@PyMem_InRa@2
  00023	c7 45 7c 01 00
	00 00		 mov	 DWORD PTR tv68[rbp], 1
  0002a	eb 07		 jmp	 SHORT $LN9@PyMem_InRa@2
$LN8@PyMem_InRa@2:
  0002c	c7 45 7c 00 00
	00 00		 mov	 DWORD PTR tv68[rbp], 0
$LN9@PyMem_InRa@2:
  00033	8b 45 7c	 mov	 eax, DWORD PTR tv68[rbp]
$LN16@PyMem_InRa@2:
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5d		 pop	 rbp
  0003b	c3		 ret	 0
  0003c	cc		 int	 3
_PyMem_InRange$filt$0 ENDP
text$x	ENDS
END
