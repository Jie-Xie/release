; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_09NCHPBFFI@itertools?$AA@			; `string'
PUBLIC	??_C@_03GMHAIBAB@tee?$AA@			; `string'
PUBLIC	??_C@_0BG@NNPBFPMG@itertools?4zip_longest?$AA@	; `string'
PUBLIC	??_C@_0BB@IMKAOHGA@itertools?4repeat?$AA@	; `string'
PUBLIC	??_C@_0BA@BJLPBKGK@__length_hint__?$AA@		; `string'
PUBLIC	??_C@_05MJOOAIJH@times?$AA@			; `string'
PUBLIC	??_C@_06IEOJBDIK@object?$AA@			; `string'
PUBLIC	??_C@_0BA@KKPHBGCD@itertools?4count?$AA@	; `string'
PUBLIC	??_C@_04CNBNFAL@step?$AA@			; `string'
PUBLIC	??_C@_05FAGFPHJG@start?$AA@			; `string'
PUBLIC	??_C@_0BG@LNFBHPNB@itertools?4filterfalse?$AA@	; `string'
PUBLIC	??_C@_0BD@LJLKJFJE@itertools?4compress?$AA@	; `string'
PUBLIC	??_C@_09PLCFPBOK@selectors?$AA@			; `string'
PUBLIC	??_C@_04PJOLNDGD@data?$AA@			; `string'
PUBLIC	??_C@_0BF@JGKIDDED@itertools?4accumulate?$AA@	; `string'
PUBLIC	??_C@_04HPNHAEOP@func?$AA@			; `string'
PUBLIC	??_C@_0BH@OBMBIGIH@itertools?4permutations?$AA@	; `string'
PUBLIC	??_C@_0CI@LFGIIFFE@itertools?4combinations_with_repl@ ; `string'
PUBLIC	??_C@_0BH@GJLBFDPE@itertools?4combinations?$AA@	; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0BC@OPMDDELD@itertools?4product?$AA@	; `string'
PUBLIC	??_C@_0BA@HCMOOGKF@itertools?4chain?$AA@	; `string'
PUBLIC	??_C@_0O@CCOONFCF@from_iterable?$AA@		; `string'
PUBLIC	??_C@_0BC@CFHDGLCC@itertools?4starmap?$AA@	; `string'
PUBLIC	??_C@_0BB@IDGNPMJH@itertools?4islice?$AA@	; `string'
PUBLIC	??_C@_0BE@JBOLIPHD@itertools?4takewhile?$AA@	; `string'
PUBLIC	??_C@_0BE@JCKEMNLM@itertools?4dropwhile?$AA@	; `string'
PUBLIC	??_C@_0BA@GAHIILDM@itertools?4cycle?$AA@	; `string'
PUBLIC	??_C@_0P@LGCJDGOJ@itertools?4_tee?$AA@		; `string'
PUBLIC	??_C@_08MOMBEIKE@__copy__?$AA@			; `string'
PUBLIC	??_C@_0BK@MAONMKPL@itertools?4_tee_dataobject?$AA@ ; `string'
PUBLIC	??_C@_0BD@BFBLHELA@itertools?4_grouper?$AA@	; `string'
PUBLIC	??_C@_0BC@EHIPFGPL@itertools?4groupby?$AA@	; `string'
PUBLIC	??_C@_0N@MOOGCAMH@__setstate__?$AA@		; `string'
PUBLIC	??_C@_0L@NNMACJIG@__reduce__?$AA@		; `string'
PUBLIC	??_C@_03ICHNJLJF@key?$AA@			; `string'
PUBLIC	??_C@_08DCHCEAJP@iterable?$AA@			; `string'
EXTRN	PyObject_GC_Del:PROC
EXTRN	PyObject_SelfIter:PROC
EXTRN	PyObject_GenericGetAttr:PROC
;	COMDAT ??_C@_09NCHPBFFI@itertools?$AA@
CONST	SEGMENT
??_C@_09NCHPBFFI@itertools?$AA@ DB 'itertools', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03GMHAIBAB@tee?$AA@
CONST	SEGMENT
??_C@_03GMHAIBAB@tee?$AA@ DB 'tee', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NNPBFPMG@itertools?4zip_longest?$AA@
CONST	SEGMENT
??_C@_0BG@NNPBFPMG@itertools?4zip_longest?$AA@ DB 'itertools.zip_longest', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IMKAOHGA@itertools?4repeat?$AA@
CONST	SEGMENT
??_C@_0BB@IMKAOHGA@itertools?4repeat?$AA@ DB 'itertools.repeat', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
CONST	SEGMENT
??_C@_0BA@BJLPBKGK@__length_hint__?$AA@ DB '__length_hint__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05MJOOAIJH@times?$AA@
CONST	SEGMENT
??_C@_05MJOOAIJH@times?$AA@ DB 'times', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IEOJBDIK@object?$AA@
CONST	SEGMENT
??_C@_06IEOJBDIK@object?$AA@ DB 'object', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KKPHBGCD@itertools?4count?$AA@
CONST	SEGMENT
??_C@_0BA@KKPHBGCD@itertools?4count?$AA@ DB 'itertools.count', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04CNBNFAL@step?$AA@
CONST	SEGMENT
??_C@_04CNBNFAL@step?$AA@ DB 'step', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05FAGFPHJG@start?$AA@
CONST	SEGMENT
??_C@_05FAGFPHJG@start?$AA@ DB 'start', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LNFBHPNB@itertools?4filterfalse?$AA@
CONST	SEGMENT
??_C@_0BG@LNFBHPNB@itertools?4filterfalse?$AA@ DB 'itertools.filterfalse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LJLKJFJE@itertools?4compress?$AA@
CONST	SEGMENT
??_C@_0BD@LJLKJFJE@itertools?4compress?$AA@ DB 'itertools.compress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PLCFPBOK@selectors?$AA@
CONST	SEGMENT
??_C@_09PLCFPBOK@selectors?$AA@ DB 'selectors', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04PJOLNDGD@data?$AA@
CONST	SEGMENT
??_C@_04PJOLNDGD@data?$AA@ DB 'data', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JGKIDDED@itertools?4accumulate?$AA@
CONST	SEGMENT
??_C@_0BF@JGKIDDED@itertools?4accumulate?$AA@ DB 'itertools.accumulate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04HPNHAEOP@func?$AA@
CONST	SEGMENT
??_C@_04HPNHAEOP@func?$AA@ DB 'func', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OBMBIGIH@itertools?4permutations?$AA@
CONST	SEGMENT
??_C@_0BH@OBMBIGIH@itertools?4permutations?$AA@ DB 'itertools.permutation'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LFGIIFFE@itertools?4combinations_with_repl@
CONST	SEGMENT
??_C@_0CI@LFGIIFFE@itertools?4combinations_with_repl@ DB 'itertools.combi'
	DB	'nations_with_replacement', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJLBFDPE@itertools?4combinations?$AA@
CONST	SEGMENT
??_C@_0BH@GJLBFDPE@itertools?4combinations?$AA@ DB 'itertools.combination'
	DB	's', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OPMDDELD@itertools?4product?$AA@
CONST	SEGMENT
??_C@_0BC@OPMDDELD@itertools?4product?$AA@ DB 'itertools.product', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HCMOOGKF@itertools?4chain?$AA@
CONST	SEGMENT
??_C@_0BA@HCMOOGKF@itertools?4chain?$AA@ DB 'itertools.chain', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@CCOONFCF@from_iterable?$AA@
CONST	SEGMENT
??_C@_0O@CCOONFCF@from_iterable?$AA@ DB 'from_iterable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CFHDGLCC@itertools?4starmap?$AA@
CONST	SEGMENT
??_C@_0BC@CFHDGLCC@itertools?4starmap?$AA@ DB 'itertools.starmap', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IDGNPMJH@itertools?4islice?$AA@
CONST	SEGMENT
??_C@_0BB@IDGNPMJH@itertools?4islice?$AA@ DB 'itertools.islice', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JBOLIPHD@itertools?4takewhile?$AA@
CONST	SEGMENT
??_C@_0BE@JBOLIPHD@itertools?4takewhile?$AA@ DB 'itertools.takewhile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JCKEMNLM@itertools?4dropwhile?$AA@
CONST	SEGMENT
??_C@_0BE@JCKEMNLM@itertools?4dropwhile?$AA@ DB 'itertools.dropwhile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GAHIILDM@itertools?4cycle?$AA@
CONST	SEGMENT
??_C@_0BA@GAHIILDM@itertools?4cycle?$AA@ DB 'itertools.cycle', 00H ; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___copy__@?1??tee@@9@9 DQ 0000000000000000H	; `tee'::`2'::PyId___copy__
	DQ	FLAT:??_C@_08MOMBEIKE@__copy__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_0P@LGCJDGOJ@itertools?4_tee?$AA@
CONST	SEGMENT
??_C@_0P@LGCJDGOJ@itertools?4_tee?$AA@ DB 'itertools._tee', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08MOMBEIKE@__copy__?$AA@
CONST	SEGMENT
??_C@_08MOMBEIKE@__copy__?$AA@ DB '__copy__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MAONMKPL@itertools?4_tee_dataobject?$AA@
CONST	SEGMENT
??_C@_0BK@MAONMKPL@itertools?4_tee_dataobject?$AA@ DB 'itertools._tee_dat'
	DB	'aobject', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BFBLHELA@itertools?4_grouper?$AA@
CONST	SEGMENT
??_C@_0BD@BFBLHELA@itertools?4_grouper?$AA@ DB 'itertools._grouper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EHIPFGPL@itertools?4groupby?$AA@
CONST	SEGMENT
??_C@_0BC@EHIPFGPL@itertools?4groupby?$AA@ DB 'itertools.groupby', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MOOGCAMH@__setstate__?$AA@
CONST	SEGMENT
??_C@_0N@MOOGCAMH@__setstate__?$AA@ DB '__setstate__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NNMACJIG@__reduce__?$AA@
CONST	SEGMENT
??_C@_0L@NNMACJIG@__reduce__?$AA@ DB '__reduce__', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?kwargs@?1??groupby_new@@9@9 DQ FLAT:??_C@_08DCHCEAJP@iterable?$AA@ ; `groupby_new'::`2'::kwargs
	DQ	FLAT:??_C@_03ICHNJLJF@key?$AA@
	DQ	0000000000000000H
reduce_doc DB	'Return state information for pickling.', 00H
	ORG $+1
setstate_doc DB	'Set state information for unpickling.', 00H
	ORG $+10
groupby_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:groupby_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:groupby_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
groupby_doc DB	'groupby(iterable[, keyfunc]) -> create an iterator which'
	DB	' returns', 0aH, '(key, sub-iterator) grouped by each value of'
	DB	' key(value).', 0aH, 00H
	ORG $+5
groupby_type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@EHIPFGPL@itertools?4groupby?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:groupby_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:groupby_doc
	DQ	FLAT:groupby_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:groupby_next
	DQ	FLAT:groupby_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:groupby_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
_grouper_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:_grouper_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
_grouper_type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BD@BFBLHELA@itertools?4_grouper?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:_grouper_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	0000000000000000H
	DQ	FLAT:_grouper_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:_grouper_next
	DQ	FLAT:_grouper_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:_grouper_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
teedataobject_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:teedataobject_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
teedataobject_doc DB 'Data container common to multiple tee objects.', 00H
	ORG $+1
teedataobject_type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BK@MAONMKPL@itertools?4_tee_dataobject?$AA@
	DQ	0000000000000240H
	DQ	0000000000000000H
	DQ	FLAT:teedataobject_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	FLAT:teedataobject_doc
	DQ	FLAT:teedataobject_traverse
	DQ	FLAT:teedataobject_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:teedataobject_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:teedataobject_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
teecopy_doc DB	'Returns an independent iterator.', 00H
	ORG $+7
teeobject_doc DB 'Iterator wrapped to make it copyable', 00H
	ORG $+3
tee_methods DQ	FLAT:??_C@_08MOMBEIKE@__copy__?$AA@
	DQ	FLAT:tee_copy
	DD	04H
	ORG $+4
	DQ	FLAT:teecopy_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:tee_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:tee_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
tee_type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0P@LGCJDGOJ@itertools?4_tee?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:tee_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044000H
	ORG $+4
	DQ	FLAT:teeobject_doc
	DQ	FLAT:tee_traverse
	DQ	FLAT:tee_clear
	DQ	0000000000000000H
	DQ	0000000000000070H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:tee_next
	DQ	FLAT:tee_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:tee_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
tee_doc	DB	'tee(iterable, n=2) --> tuple of n independent iterators.'
	DB	00H
	ORG $+7
cycle_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:cycle_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:cycle_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
cycle_doc DB	'cycle(iterable) --> cycle object', 0aH, 0aH, 'Return ele'
	DB	'ments from the iterable until it is exhausted.', 0aH, 'Then r'
	DB	'epeat the sequence indefinitely.', 00H
	ORG $+14
cycle_type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BA@GAHIILDM@itertools?4cycle?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:cycle_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:cycle_doc
	DQ	FLAT:cycle_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:cycle_next
	DQ	FLAT:cycle_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:cycle_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
dropwhile_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:dropwhile_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:dropwhile_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
dropwhile_doc DB 'dropwhile(predicate, iterable) --> dropwhile object', 0aH
	DB	0aH, 'Drop items from the iterable while predicate(item) is tr'
	DB	'ue.', 0aH, 'Afterwards, return every element until the iterab'
	DB	'le is exhausted.', 00H
	ORG $+13
dropwhile_type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BE@JCKEMNLM@itertools?4dropwhile?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:dropwhile_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:dropwhile_doc
	DQ	FLAT:dropwhile_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:dropwhile_next
	DQ	FLAT:dropwhile_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:dropwhile_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
takewhile_reduce_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:takewhile_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:takewhile_reduce_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
takewhile_doc DB 'takewhile(predicate, iterable) --> takewhile object', 0aH
	DB	0aH, 'Return successive entries from an iterable as long as th'
	DB	'e ', 0aH, 'predicate evaluates to true for each entry.', 00H
	ORG $+4
takewhile_type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BE@JBOLIPHD@itertools?4takewhile?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:takewhile_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:takewhile_doc
	DQ	FLAT:takewhile_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:takewhile_next
	DQ	FLAT:takewhile_reduce_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:takewhile_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
islice_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:islice_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:islice_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
islice_doc DB	'islice(iterable, stop) --> islice object', 0aH, 'islice('
	DB	'iterable, start, stop[, step]) --> islice object', 0aH, 0aH, 'R'
	DB	'eturn an iterator whose next() method returns selected values'
	DB	' from an', 0aH, 'iterable.  If start is specified, will skip '
	DB	'all preceding elements;', 0aH, 'otherwise, start defaults to '
	DB	'zero.  Step defaults to one.  If', 0aH, 'specified as another'
	DB	' value, step determines how many values are ', 0aH, 'skipped '
	DB	'between successive calls.  Works like a slice() on a list', 0aH
	DB	'but returns an iterator.', 00H
	ORG $+9
islice_type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BB@IDGNPMJH@itertools?4islice?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:islice_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:islice_doc
	DQ	FLAT:islice_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:islice_next
	DQ	FLAT:islice_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:islice_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
starmap_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:starmap_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
starmap_doc DB	'starmap(function, sequence) --> starmap object', 0aH, 0aH
	DB	'Return an iterator whose values are returned from the functio'
	DB	'n evaluated', 0aH, 'with a argument tuple taken from the give'
	DB	'n sequence.', 00H
	ORG $+2
starmap_type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@CFHDGLCC@itertools?4starmap?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:starmap_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:starmap_doc
	DQ	FLAT:starmap_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:starmap_next
	DQ	FLAT:starmap_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:starmap_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
chain_doc DB	'chain(*iterables) --> chain object', 0aH, 0aH, 'Return a'
	DB	' chain object whose .__next__() method returns elements from '
	DB	'the', 0aH, 'first iterable until it is exhausted, then elemen'
	DB	'ts from the next', 0aH, 'iterable, until all of the iterables'
	DB	' are exhausted.', 00H
	ORG $+13
chain_from_iterable_doc DB 'chain.from_iterable(iterable) --> chain objec'
	DB	't', 0aH, 0aH, 'Alternate chain() contructor taking a single i'
	DB	'terable argument', 0aH, 'that evaluates lazily.', 00H
	ORG $+10
chain_methods DQ FLAT:??_C@_0O@CCOONFCF@from_iterable?$AA@
	DQ	FLAT:chain_new_from_iterable
	DD	018H
	ORG $+4
	DQ	FLAT:chain_from_iterable_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:chain_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:chain_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
chain_type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BA@HCMOOGKF@itertools?4chain?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:chain_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:chain_doc
	DQ	FLAT:chain_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:chain_next
	DQ	FLAT:chain_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:chain_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
product_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:product_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:product_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
product_doc DB	'product(*iterables, repeat=1) --> product object', 0aH, 0aH
	DB	'Cartesian product of input iterables.  Equivalent to nested f'
	DB	'or-loops.', 0aH, 0aH, 'For example, product(A, B) returns the'
	DB	' same as:  ((x,y) for x in A for y in B).', 0aH, 'The leftmos'
	DB	't iterators are in the outermost for-loop, so the output tupl'
	DB	'es', 0aH, 'cycle in a manner similar to an odometer (with the'
	DB	' rightmost element changing', 0aH, 'on every iteration).', 0aH
	DB	0aH, 'To compute the product of an iterable with itself, speci'
	DB	'fy the number', 0aH, 'of repetitions with the optional repeat'
	DB	' keyword argument. For example,', 0aH, 'product(A, repeat=4) '
	DB	'means the same as product(A, A, A, A).', 0aH, 0aH, 'product('''
	DB	'ab'', range(3)) --> (''a'',0) (''a'',1) (''a'',2) (''b'',0) ('
	DB	'''b'',1) (''b'',2)', 0aH, 'product((0,1), (0,1), (0,1)) --> ('
	DB	'0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ...', 00H
	ORG $+4
product_type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BC@OPMDDELD@itertools?4product?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:product_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:product_doc
	DQ	FLAT:product_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:product_next
	DQ	FLAT:product_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:product_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
?kwargs@?1??combinations_new@@9@9 DQ FLAT:??_C@_08DCHCEAJP@iterable?$AA@ ; `combinations_new'::`2'::kwargs
	DQ	FLAT:??_C@_01KDCPPGHE@r?$AA@
	DQ	0000000000000000H
	ORG $+8
combinations_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:combinations_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:combinations_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
combinations_doc DB 'combinations(iterable, r) --> combinations object', 0aH
	DB	0aH, 'Return successive r-length combinations of elements in t'
	DB	'he iterable.', 0aH, 0aH, 'combinations(range(4), 3) --> (0,1,'
	DB	'2), (0,1,3), (0,2,3), (1,2,3)', 00H
	ORG $+6
combinations_type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BH@GJLBFDPE@itertools?4combinations?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:combinations_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:combinations_doc
	DQ	FLAT:combinations_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:combinations_next
	DQ	FLAT:combinations_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:combinations_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
?kwargs@?1??cwr_new@@9@9 DQ FLAT:??_C@_08DCHCEAJP@iterable?$AA@ ; `cwr_new'::`2'::kwargs
	DQ	FLAT:??_C@_01KDCPPGHE@r?$AA@
	DQ	0000000000000000H
	ORG $+8
cwr_methods DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:cwr_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:cwr_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
cwr_doc	DB	'combinations_with_replacement(iterable, r) --> combinati'
	DB	'ons_with_replacement object', 0aH, 0aH, 'Return successive r-'
	DB	'length combinations of elements in the iterable', 0aH, 'allow'
	DB	'ing individual elements to have successive repeats.', 0aH, 'c'
	DB	'ombinations_with_replacement(''ABC'', 2) --> AA AB AC BB BC C'
	DB	'C', 00H
cwr_type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0CI@LFGIIFFE@itertools?4combinations_with_repl@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:cwr_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:cwr_doc
	DQ	FLAT:cwr_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:cwr_next
	DQ	FLAT:cwr_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:cwr_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
?kwargs@?1??permutations_new@@9@9 DQ FLAT:??_C@_08DCHCEAJP@iterable?$AA@ ; `permutations_new'::`2'::kwargs
	DQ	FLAT:??_C@_01KDCPPGHE@r?$AA@
	DQ	0000000000000000H
	ORG $+8
permuations_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:permutations_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:permutations_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
permutations_doc DB 'permutations(iterable[, r]) --> permutations object', 0aH
	DB	0aH, 'Return successive r-length permutations of elements in t'
	DB	'he iterable.', 0aH, 0aH, 'permutations(range(3), 2) --> (0,1)'
	DB	', (0,2), (1,0), (1,2), (2,0), (2,1)', 00H
	ORG $+14
permutations_type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BH@OBMBIGIH@itertools?4permutations?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:permutations_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:permutations_doc
	DQ	FLAT:permutations_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:permutations_next
	DQ	FLAT:permuations_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:permutations_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
?kwargs@?1??accumulate_new@@9@9 DQ FLAT:??_C@_08DCHCEAJP@iterable?$AA@ ; `accumulate_new'::`2'::kwargs
	DQ	FLAT:??_C@_04HPNHAEOP@func?$AA@
	DQ	0000000000000000H
	ORG $+8
accumulate_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:accumulate_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:accumulate_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
accumulate_doc DB 'accumulate(iterable[, func]) --> accumulate object', 0aH
	DB	0aH, 'Return series of accumulated sums (or other binary funct'
	DB	'ion results).', 00H
	ORG $+6
accumulate_type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BF@JGKIDDED@itertools?4accumulate?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:accumulate_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:accumulate_doc
	DQ	FLAT:accumulate_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:accumulate_next
	DQ	FLAT:accumulate_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:accumulate_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
?kwargs@?1??compress_new@@9@9 DQ FLAT:??_C@_04PJOLNDGD@data?$AA@ ; `compress_new'::`2'::kwargs
	DQ	FLAT:??_C@_09PLCFPBOK@selectors?$AA@
	DQ	0000000000000000H
	ORG $+8
compress_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:compress_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
compress_doc DB	'compress(data, selectors) --> iterator over selected dat'
	DB	'a', 0aH, 0aH, 'Return data elements corresponding to true sel'
	DB	'ector elements.', 0aH, 'Forms a shorter iterator from selecte'
	DB	'd data elements using the', 0aH, 'selectors to choose the dat'
	DB	'a elements.', 00H
	ORG $+1
compress_type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BD@LJLKJFJE@itertools?4compress?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:compress_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:compress_doc
	DQ	FLAT:compress_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:compress_next
	DQ	FLAT:compress_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:compress_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
filterfalse_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:filterfalse_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
filterfalse_doc DB 'filterfalse(function or None, sequence) --> filterfal'
	DB	'se object', 0aH, 0aH, 'Return those items of sequence for whi'
	DB	'ch function(item) is false.', 0aH, 'If function is None, retu'
	DB	'rn the items that are false.', 00H
	ORG $+8
filterfalse_type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BG@LNFBHPNB@itertools?4filterfalse?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:filterfalse_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:filterfalse_doc
	DQ	FLAT:filterfalse_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:filterfalse_next
	DQ	FLAT:filterfalse_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:filterfalse_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
?kwlist@?1??count_new@@9@9 DQ FLAT:??_C@_05FAGFPHJG@start?$AA@ ; `count_new'::`2'::kwlist
	DQ	FLAT:??_C@_04CNBNFAL@step?$AA@
	DQ	0000000000000000H
	ORG $+8
count_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:count_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
count_doc DB	'count(start=0, step=1) --> count object', 0aH, 0aH, 'Ret'
	DB	'urn a count object whose .__next__() method returns consecuti'
	DB	've values.', 0aH, 'Equivalent to:', 0aH, 0aH, '    def count('
	DB	'firstval=0, step=1):', 0aH, '        x = firstval', 0aH, '   '
	DB	'     while 1:', 0aH, '            yield x', 0aH, '           '
	DB	' x += step', 0aH, 00H
	ORG $+8
count_type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BA@KKPHBGCD@itertools?4count?$AA@
	DQ	0000000000000080H
	DQ	0000000000000000H
	DQ	FLAT:count_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:count_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:count_doc
	DQ	FLAT:count_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:count_next
	DQ	FLAT:count_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:count_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
?kwargs@?1??repeat_new@@9@9 DQ FLAT:??_C@_06IEOJBDIK@object?$AA@ ; `repeat_new'::`2'::kwargs
	DQ	FLAT:??_C@_05MJOOAIJH@times?$AA@
	DQ	0000000000000000H
length_hint_doc DB 'Private method returning an estimate of len(list(it))'
	DB	'.', 00H
	ORG $+1
repeat_methods DQ FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	FLAT:repeat_len
	DD	04H
	ORG $+4
	DQ	FLAT:length_hint_doc
	DQ	FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:repeat_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
repeat_doc DB	'repeat(object [,times]) -> create an iterator which retu'
	DB	'rns the object', 0aH, 'for the specified number of times.  If'
	DB	' not specified, returns the object', 0aH, 'endlessly.', 00H
	ORG $+5
repeat_type DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BB@IMKAOHGA@itertools?4repeat?$AA@
	DQ	0000000000000070H
	DQ	0000000000000000H
	DQ	FLAT:repeat_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:repeat_repr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:repeat_doc
	DQ	FLAT:repeat_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:repeat_next
	DQ	FLAT:repeat_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:repeat_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
zip_longest_methods DQ FLAT:??_C@_0L@NNMACJIG@__reduce__?$AA@
	DQ	FLAT:zip_longest_reduce
	DD	04H
	ORG $+4
	DQ	FLAT:reduce_doc
	DQ	FLAT:??_C@_0N@MOOGCAMH@__setstate__?$AA@
	DQ	FLAT:zip_longest_setstate
	DD	08H
	ORG $+4
	DQ	FLAT:setstate_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
zip_longest_doc DB 'zip_longest(iter1 [,iter2 [...]], [fillvalue=None]) -'
	DB	'-> zip_longest object', 0aH, 0aH, 'Return an zip_longest obje'
	DB	'ct whose .__next__() method returns a tuple where', 0aH, 'the'
	DB	' i-th element comes from the i-th iterable argument.  The .__'
	DB	'next__()', 0aH, 'method continues until the longest iterable '
	DB	'in the argument sequence', 0aH, 'is exhausted and then it rai'
	DB	'ses StopIteration.  When the shorter iterables', 0aH, 'are ex'
	DB	'hausted, the fillvalue is substituted in their place.  The fi'
	DB	'llvalue', 0aH, 'defaults to None or can be specified by a key'
	DB	'word argument.', 0aH, 00H
	ORG $+7
ziplongest_type DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_0BG@NNPBFPMG@itertools?4zip_longest?$AA@
	DQ	0000000000000090H
	DQ	0000000000000000H
	DQ	FLAT:zip_longest_dealloc
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_GenericGetAttr
	DQ	0000000000000000H
	DQ	0000000000000000H
	DD	044400H
	ORG $+4
	DQ	FLAT:zip_longest_doc
	DQ	FLAT:zip_longest_traverse
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:PyObject_SelfIter
	DQ	FLAT:zip_longest_next
	DQ	FLAT:zip_longest_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:zip_longest_new
	DQ	FLAT:PyObject_GC_Del
	ORG $+64
module_doc DB	'Functional tools for creating and using iterators.', 0aH
	DB	0aH, 'Infinite iterators:', 0aH, 'count(start=0, step=1) --> s'
	DB	'tart, start+step, start+2*step, ...', 0aH, 'cycle(p) --> p0, '
	DB	'p1, ... plast, p0, p1, ...', 0aH, 'repeat(elem [,n]) --> elem'
	DB	', elem, elem, ... endlessly or up to n times', 0aH, 0aH, 'Ite'
	DB	'rators terminating on the shortest input sequence:', 0aH, 'ac'
	DB	'cumulate(p[, func]) --> p0, p0+p1, p0+p1+p2', 0aH, 'chain(p, '
	DB	'q, ...) --> p0, p1, ... plast, q0, q1, ... ', 0aH, 'chain.fro'
	DB	'm_iterable([p, q, ...]) --> p0, p1, ... plast, q0, q1, ... ', 0aH
	DB	'compress(data, selectors) --> (d[0] if s[0]), (d[1] if s[1]),'
	DB	' ...', 0aH, 'dropwhile(pred, seq) --> seq[n], seq[n+1], start'
	DB	'ing when pred fails', 0aH, 'groupby(iterable[, keyfunc]) --> '
	DB	'sub-iterators grouped by value of keyfunc(v)', 0aH, 'filterfa'
	DB	'lse(pred, seq) --> elements of seq where pred(elem) is False', 0aH
	DB	'islice(seq, [start,] stop [, step]) --> elements from', 0aH, ' '
	DB	'      seq[start:stop:step]', 0aH, 'starmap(fun, seq) --> fun('
	DB	'*seq[0]), fun(*seq[1]), ...', 0aH, 'tee(it, n=2) --> (it1, it'
	DB	'2 , ... itn) splits one iterator into n', 0aH, 'takewhile(pre'
	DB	'd, seq) --> seq[0], seq[1], until pred fails', 0aH, 'zip_long'
	DB	'est(p, q, ...) --> (p[0], q[0]), (p[1], q[1]), ... ', 0aH, 0aH
	DB	'Combinatoric generators:', 0aH, 'product(p, q, ... [repeat=1]'
	DB	') --> cartesian product', 0aH, 'permutations(p[, r])', 0aH, 'c'
	DB	'ombinations(p, r)', 0aH, 'combinations_with_replacement(p, r)'
	DB	0aH, 00H
	ORG $+3
module_methods DQ FLAT:??_C@_03GMHAIBAB@tee?$AA@
	DQ	FLAT:tee
	DD	01H
	ORG $+4
	DQ	FLAT:tee_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
itertoolsmodule DQ dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_09NCHPBFFI@itertools?$AA@
	DQ	FLAT:module_doc
	DQ	ffffffffffffffffH
	DQ	FLAT:module_methods
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
;	COMDAT ??_C@_03ICHNJLJF@key?$AA@
CONST	SEGMENT
??_C@_03ICHNJLJF@key?$AA@ DB 'key', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08DCHCEAJP@iterable?$AA@
CONST	SEGMENT
??_C@_08DCHCEAJP@iterable?$AA@ DB 'iterable', 00H	; `string'
CONST	ENDS
PUBLIC	_Py_DecRef
PUBLIC	_Py_IncRef
PUBLIC	??_C@_0M@FBJDAALJ@O?$HMO?3groupby?$AA@		; `string'
EXTRN	PyObject_GetIter:PROC
EXTRN	PyArg_ParseTupleAndKeywords:PROC
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\modules\itertoolsmodule.c
pdata	SEGMENT
$pdata$groupby_new DD imagerel groupby_new
	DD	imagerel groupby_new+247
	DD	imagerel $unwind$groupby_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$groupby_new DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0M@FBJDAALJ@O?$HMO?3groupby?$AA@
CONST	SEGMENT
??_C@_0M@FBJDAALJ@O?$HMO?3groupby?$AA@ DB 'O|O:groupby', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT groupby_new
_TEXT	SEGMENT
it$ = 48
keyfunc$ = 56
gbo$ = 64
type$ = 96
args$ = 104
kwds$ = 112
groupby_new PROC					; COMDAT

; 28   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 29   :     static char *kwargs[] = {"iterable", "key", NULL};
; 30   :     groupbyobject *gbo;
; 31   :     PyObject *it, *keyfunc = Py_None;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001a	48 89 44 24 38	 mov	 QWORD PTR keyfunc$[rsp], rax

; 32   : 
; 33   :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|O:groupby", kwargs,
; 34   :                                      &it, &keyfunc))

  0001f	48 8d 44 24 38	 lea	 rax, QWORD PTR keyfunc$[rsp]
  00024	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00029	48 8d 44 24 30	 lea	 rax, QWORD PTR it$[rsp]
  0002e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00033	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwargs@?1??groupby_new@@9@9
  0003a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@FBJDAALJ@O?$HMO?3groupby?$AA@
  00041	48 8b 54 24 70	 mov	 rdx, QWORD PTR kwds$[rsp]
  00046	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0004b	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00050	85 c0		 test	 eax, eax
  00052	75 07		 jne	 SHORT $LN3@groupby_ne

; 35   :         return NULL;

  00054	33 c0		 xor	 eax, eax
  00056	e9 97 00 00 00	 jmp	 $LN4@groupby_ne
$LN3@groupby_ne:

; 36   : 
; 37   :     gbo = (groupbyobject *)type->tp_alloc(type, 0);

  0005b	33 d2		 xor	 edx, edx
  0005d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR type$[rsp]
  00062	48 8b 44 24 60	 mov	 rax, QWORD PTR type$[rsp]
  00067	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  0006d	48 89 44 24 40	 mov	 QWORD PTR gbo$[rsp], rax

; 38   :     if (gbo == NULL)

  00072	48 83 7c 24 40
	00		 cmp	 QWORD PTR gbo$[rsp], 0
  00078	75 04		 jne	 SHORT $LN2@groupby_ne

; 39   :         return NULL;

  0007a	33 c0		 xor	 eax, eax
  0007c	eb 74		 jmp	 SHORT $LN4@groupby_ne
$LN2@groupby_ne:

; 40   :     gbo->tgtkey = NULL;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR gbo$[rsp]
  00083	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 41   :     gbo->currkey = NULL;

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR gbo$[rsp]
  00090	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 42   :     gbo->currvalue = NULL;

  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR gbo$[rsp]
  0009d	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 43   :     gbo->keyfunc = keyfunc;

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR gbo$[rsp]
  000ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR keyfunc$[rsp]
  000b2	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 44   :     Py_INCREF(keyfunc);

  000b6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR keyfunc$[rsp]
  000bb	e8 00 00 00 00	 call	 _Py_IncRef

; 45   :     gbo->it = PyObject_GetIter(it);

  000c0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000c5	e8 00 00 00 00	 call	 PyObject_GetIter
  000ca	48 8b 4c 24 40	 mov	 rcx, QWORD PTR gbo$[rsp]
  000cf	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 46   :     if (gbo->it == NULL) {

  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR gbo$[rsp]
  000d8	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000dd	75 0e		 jne	 SHORT $LN1@groupby_ne

; 47   :         Py_DECREF(gbo);

  000df	48 8b 4c 24 40	 mov	 rcx, QWORD PTR gbo$[rsp]
  000e4	e8 00 00 00 00	 call	 _Py_DecRef

; 48   :         return NULL;

  000e9	33 c0		 xor	 eax, eax
  000eb	eb 05		 jmp	 SHORT $LN4@groupby_ne
$LN1@groupby_ne:

; 49   :     }
; 50   :     return (PyObject *)gbo;

  000ed	48 8b 44 24 40	 mov	 rax, QWORD PTR gbo$[rsp]
$LN4@groupby_ne:

; 51   : }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
groupby_new ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_UnTrack:PROC
;	COMDAT pdata
; File c:\src\pyparallel\modules\itertoolsmodule.c
pdata	SEGMENT
$pdata$groupby_dealloc DD imagerel groupby_dealloc
	DD	imagerel groupby_dealloc+210
	DD	imagerel $unwind$groupby_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$groupby_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT groupby_dealloc
_TEXT	SEGMENT
gbo$ = 48
groupby_dealloc PROC					; COMDAT

; 55   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 56   :     PyObject_GC_UnTrack(gbo);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR gbo$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN20@groupby_de:

; 57   :     Py_XDECREF(gbo->it);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR gbo$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN17@groupby_de
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR gbo$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@groupby_de:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN20@groupby_de
$LN16@groupby_de:

; 58   :     Py_XDECREF(gbo->keyfunc);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR gbo$[rsp]
  00038	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0003d	74 0e		 je	 SHORT $LN13@groupby_de
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR gbo$[rsp]
  00044	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@groupby_de:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN16@groupby_de
$LN12@groupby_de:

; 59   :     Py_XDECREF(gbo->tgtkey);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR gbo$[rsp]
  00058	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0005d	74 0e		 je	 SHORT $LN9@groupby_de
  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR gbo$[rsp]
  00064	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00068	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@groupby_de:
  0006d	33 c0		 xor	 eax, eax
  0006f	85 c0		 test	 eax, eax
  00071	75 e0		 jne	 SHORT $LN12@groupby_de
$LN8@groupby_de:

; 60   :     Py_XDECREF(gbo->currkey);

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR gbo$[rsp]
  00078	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0007d	74 0e		 je	 SHORT $LN5@groupby_de
  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR gbo$[rsp]
  00084	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00088	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@groupby_de:
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	75 e0		 jne	 SHORT $LN8@groupby_de
$LN4@groupby_de:

; 61   :     Py_XDECREF(gbo->currvalue);

  00093	48 8b 44 24 30	 mov	 rax, QWORD PTR gbo$[rsp]
  00098	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000a0	74 11		 je	 SHORT $LN1@groupby_de
  000a2	48 8b 44 24 30	 mov	 rax, QWORD PTR gbo$[rsp]
  000a7	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000ae	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@groupby_de:
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 da		 jne	 SHORT $LN4@groupby_de

; 62   :     Py_TYPE(gbo)->tp_free(gbo);

  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR gbo$[rsp]
  000be	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000c2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR gbo$[rsp]
  000c7	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 63   : }

  000cd	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d1	c3		 ret	 0
groupby_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@JLGPKDPD@groupby_traverse?$AA@	; `string'
PUBLIC	??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@ ; `string'
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$groupby_traverse DD imagerel groupby_traverse
	DD	imagerel groupby_traverse+491
	DD	imagerel $unwind$groupby_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$groupby_traverse DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0BB@JLGPKDPD@groupby_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@JLGPKDPD@groupby_traverse?$AA@ DB 'groupby_traverse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
CONST	SEGMENT
??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@ DB '..\Modules\'
	DB	'itertoolsmodule.c', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT groupby_traverse
_TEXT	SEGMENT
vret$20415 = 32
vret$20423 = 36
vret$20431 = 40
vret$20439 = 44
vret$20447 = 48
gbo$ = 80
visit$ = 88
arg$ = 96
groupby_traverse PROC					; COMDAT

; 67   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN30@groupby_tr:

; 68   :     Py_VISIT(gbo->it);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN27@groupby_tr
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 44 00 00
	00		 mov	 r8d, 68			; 00000044H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@JLGPKDPD@groupby_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN27@groupby_tr:
  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR gbo$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 26		 je	 SHORT $LN26@groupby_tr
  00044	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR gbo$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$20415[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$20415[rsp], 0
  0005f	74 09		 je	 SHORT $LN25@groupby_tr
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$20415[rsp]
  00065	e9 7c 01 00 00	 jmp	 $LN31@groupby_tr
$LN25@groupby_tr:
$LN26@groupby_tr:
  0006a	33 c0		 xor	 eax, eax
  0006c	85 c0		 test	 eax, eax
  0006e	75 a3		 jne	 SHORT $LN30@groupby_tr
$LN24@groupby_tr:

; 69   :     Py_VISIT(gbo->keyfunc);

  00070	e8 00 00 00 00	 call	 _Py_PXCTX
  00075	85 c0		 test	 eax, eax
  00077	74 1c		 je	 SHORT $LN21@groupby_tr
  00079	45 33 c9	 xor	 r9d, r9d
  0007c	41 b8 45 00 00
	00		 mov	 r8d, 69			; 00000045H
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@JLGPKDPD@groupby_traverse?$AA@
  00090	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN21@groupby_tr:
  00095	48 8b 44 24 50	 mov	 rax, QWORD PTR gbo$[rsp]
  0009a	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0009f	74 26		 je	 SHORT $LN20@groupby_tr
  000a1	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  000a6	48 8b 44 24 50	 mov	 rax, QWORD PTR gbo$[rsp]
  000ab	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000af	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  000b3	89 44 24 24	 mov	 DWORD PTR vret$20423[rsp], eax
  000b7	83 7c 24 24 00	 cmp	 DWORD PTR vret$20423[rsp], 0
  000bc	74 09		 je	 SHORT $LN19@groupby_tr
  000be	8b 44 24 24	 mov	 eax, DWORD PTR vret$20423[rsp]
  000c2	e9 1f 01 00 00	 jmp	 $LN31@groupby_tr
$LN19@groupby_tr:
$LN20@groupby_tr:
  000c7	33 c0		 xor	 eax, eax
  000c9	85 c0		 test	 eax, eax
  000cb	75 a3		 jne	 SHORT $LN24@groupby_tr
$LN18@groupby_tr:

; 70   :     Py_VISIT(gbo->tgtkey);

  000cd	e8 00 00 00 00	 call	 _Py_PXCTX
  000d2	85 c0		 test	 eax, eax
  000d4	74 1c		 je	 SHORT $LN15@groupby_tr
  000d6	45 33 c9	 xor	 r9d, r9d
  000d9	41 b8 46 00 00
	00		 mov	 r8d, 70			; 00000046H
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@JLGPKDPD@groupby_traverse?$AA@
  000ed	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@groupby_tr:
  000f2	48 8b 44 24 50	 mov	 rax, QWORD PTR gbo$[rsp]
  000f7	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  000fc	74 26		 je	 SHORT $LN14@groupby_tr
  000fe	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  00103	48 8b 44 24 50	 mov	 rax, QWORD PTR gbo$[rsp]
  00108	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0010c	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  00110	89 44 24 28	 mov	 DWORD PTR vret$20431[rsp], eax
  00114	83 7c 24 28 00	 cmp	 DWORD PTR vret$20431[rsp], 0
  00119	74 09		 je	 SHORT $LN13@groupby_tr
  0011b	8b 44 24 28	 mov	 eax, DWORD PTR vret$20431[rsp]
  0011f	e9 c2 00 00 00	 jmp	 $LN31@groupby_tr
$LN13@groupby_tr:
$LN14@groupby_tr:
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 a3		 jne	 SHORT $LN18@groupby_tr
$LN12@groupby_tr:

; 71   :     Py_VISIT(gbo->currkey);

  0012a	e8 00 00 00 00	 call	 _Py_PXCTX
  0012f	85 c0		 test	 eax, eax
  00131	74 1c		 je	 SHORT $LN9@groupby_tr
  00133	45 33 c9	 xor	 r9d, r9d
  00136	41 b8 47 00 00
	00		 mov	 r8d, 71			; 00000047H
  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@JLGPKDPD@groupby_traverse?$AA@
  0014a	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@groupby_tr:
  0014f	48 8b 44 24 50	 mov	 rax, QWORD PTR gbo$[rsp]
  00154	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00159	74 23		 je	 SHORT $LN8@groupby_tr
  0015b	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  00160	48 8b 44 24 50	 mov	 rax, QWORD PTR gbo$[rsp]
  00165	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00169	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  0016d	89 44 24 2c	 mov	 DWORD PTR vret$20439[rsp], eax
  00171	83 7c 24 2c 00	 cmp	 DWORD PTR vret$20439[rsp], 0
  00176	74 06		 je	 SHORT $LN7@groupby_tr
  00178	8b 44 24 2c	 mov	 eax, DWORD PTR vret$20439[rsp]
  0017c	eb 68		 jmp	 SHORT $LN31@groupby_tr
$LN7@groupby_tr:
$LN8@groupby_tr:
  0017e	33 c0		 xor	 eax, eax
  00180	85 c0		 test	 eax, eax
  00182	75 a6		 jne	 SHORT $LN12@groupby_tr
$LN6@groupby_tr:

; 72   :     Py_VISIT(gbo->currvalue);

  00184	e8 00 00 00 00	 call	 _Py_PXCTX
  00189	85 c0		 test	 eax, eax
  0018b	74 1c		 je	 SHORT $LN3@groupby_tr
  0018d	45 33 c9	 xor	 r9d, r9d
  00190	41 b8 48 00 00
	00		 mov	 r8d, 72			; 00000048H
  00196	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0019d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@JLGPKDPD@groupby_traverse?$AA@
  001a4	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@groupby_tr:
  001a9	48 8b 44 24 50	 mov	 rax, QWORD PTR gbo$[rsp]
  001ae	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  001b6	74 26		 je	 SHORT $LN2@groupby_tr
  001b8	48 8b 54 24 60	 mov	 rdx, QWORD PTR arg$[rsp]
  001bd	48 8b 44 24 50	 mov	 rax, QWORD PTR gbo$[rsp]
  001c2	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  001c9	ff 54 24 58	 call	 QWORD PTR visit$[rsp]
  001cd	89 44 24 30	 mov	 DWORD PTR vret$20447[rsp], eax
  001d1	83 7c 24 30 00	 cmp	 DWORD PTR vret$20447[rsp], 0
  001d6	74 06		 je	 SHORT $LN1@groupby_tr
  001d8	8b 44 24 30	 mov	 eax, DWORD PTR vret$20447[rsp]
  001dc	eb 08		 jmp	 SHORT $LN31@groupby_tr
$LN1@groupby_tr:
$LN2@groupby_tr:
  001de	33 c0		 xor	 eax, eax
  001e0	85 c0		 test	 eax, eax
  001e2	75 a0		 jne	 SHORT $LN6@groupby_tr

; 73   :     return 0;

  001e4	33 c0		 xor	 eax, eax
$LN31@groupby_tr:

; 74   : }

  001e6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ea	c3		 ret	 0
groupby_traverse ENDP
_TEXT	ENDS
EXTRN	PyTuple_Pack:PROC
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyIter_Next:PROC
EXTRN	PyObject_RichCompareBool:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$groupby_next DD imagerel groupby_next
	DD	imagerel groupby_next+499
	DD	imagerel $unwind$groupby_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$groupby_next DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT groupby_next
_TEXT	SEGMENT
tmp$ = 32
newvalue$ = 40
newkey$ = 48
grouper$ = 56
r$ = 64
rcmp$20468 = 72
gbo$ = 96
groupby_next PROC					; COMDAT

; 78   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN26@groupby_ne@2:

; 79   :     PyObject *newvalue, *newkey, *r, *grouper, *tmp;
; 80   : 
; 81   :     /* skip to next iteration group */
; 82   :     for (;;) {
; 83   :         if (gbo->currkey == NULL)

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  0000e	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00013	75 02		 jne	 SHORT $LN24@groupby_ne@2
  00015	eb 50		 jmp	 SHORT $LN23@groupby_ne@2
$LN24@groupby_ne@2:

; 84   :             /* pass */;
; 85   :         else if (gbo->tgtkey == NULL)

  00017	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  0001c	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00021	75 07		 jne	 SHORT $LN22@groupby_ne@2

; 86   :             break;

  00023	e9 30 01 00 00	 jmp	 $LN25@groupby_ne@2

; 87   :         else {

  00028	eb 3d		 jmp	 SHORT $LN21@groupby_ne@2
$LN22@groupby_ne@2:

; 88   :             int rcmp;
; 89   : 
; 90   :             rcmp = PyObject_RichCompareBool(gbo->tgtkey,
; 91   :                                             gbo->currkey, Py_EQ);

  0002a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00030	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  00035	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  00039	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  0003e	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00042	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00047	89 44 24 48	 mov	 DWORD PTR rcmp$20468[rsp], eax

; 92   :             if (rcmp == -1)

  0004b	83 7c 24 48 ff	 cmp	 DWORD PTR rcmp$20468[rsp], -1
  00050	75 09		 jne	 SHORT $LN20@groupby_ne@2

; 93   :                 return NULL;

  00052	33 c0		 xor	 eax, eax
  00054	e9 95 01 00 00	 jmp	 $LN27@groupby_ne@2
  00059	eb 0c		 jmp	 SHORT $LN19@groupby_ne@2
$LN20@groupby_ne@2:

; 94   :             else if (rcmp == 0)

  0005b	83 7c 24 48 00	 cmp	 DWORD PTR rcmp$20468[rsp], 0
  00060	75 05		 jne	 SHORT $LN18@groupby_ne@2

; 95   :                 break;

  00062	e9 f1 00 00 00	 jmp	 $LN25@groupby_ne@2
$LN18@groupby_ne@2:
$LN19@groupby_ne@2:
$LN21@groupby_ne@2:
$LN23@groupby_ne@2:

; 96   :         }
; 97   : 
; 98   :         newvalue = PyIter_Next(gbo->it);

  00067	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  0006c	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00070	e8 00 00 00 00	 call	 PyIter_Next
  00075	48 89 44 24 28	 mov	 QWORD PTR newvalue$[rsp], rax

; 99   :         if (newvalue == NULL)

  0007a	48 83 7c 24 28
	00		 cmp	 QWORD PTR newvalue$[rsp], 0
  00080	75 07		 jne	 SHORT $LN17@groupby_ne@2

; 100  :             return NULL;

  00082	33 c0		 xor	 eax, eax
  00084	e9 65 01 00 00	 jmp	 $LN27@groupby_ne@2
$LN17@groupby_ne@2:

; 101  : 
; 102  :         if (gbo->keyfunc == Py_None) {

  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00090	48 8b 4c 24 60	 mov	 rcx, QWORD PTR gbo$[rsp]
  00095	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  00099	75 16		 jne	 SHORT $LN16@groupby_ne@2

; 103  :             newkey = newvalue;

  0009b	48 8b 44 24 28	 mov	 rax, QWORD PTR newvalue$[rsp]
  000a0	48 89 44 24 30	 mov	 QWORD PTR newkey$[rsp], rax

; 104  :             Py_INCREF(newvalue);

  000a5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newvalue$[rsp]
  000aa	e8 00 00 00 00	 call	 _Py_IncRef

; 105  :         } else {

  000af	eb 34		 jmp	 SHORT $LN15@groupby_ne@2
$LN16@groupby_ne@2:

; 106  :             newkey = PyObject_CallFunctionObjArgs(gbo->keyfunc,
; 107  :                                                   newvalue, NULL);

  000b1	45 33 c0	 xor	 r8d, r8d
  000b4	48 8b 54 24 28	 mov	 rdx, QWORD PTR newvalue$[rsp]
  000b9	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  000be	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000c2	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  000c7	48 89 44 24 30	 mov	 QWORD PTR newkey$[rsp], rax

; 108  :             if (newkey == NULL) {

  000cc	48 83 7c 24 30
	00		 cmp	 QWORD PTR newkey$[rsp], 0
  000d2	75 11		 jne	 SHORT $LN14@groupby_ne@2

; 109  :                 Py_DECREF(newvalue);

  000d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newvalue$[rsp]
  000d9	e8 00 00 00 00	 call	 _Py_DecRef

; 110  :                 return NULL;

  000de	33 c0		 xor	 eax, eax
  000e0	e9 09 01 00 00	 jmp	 $LN27@groupby_ne@2
$LN14@groupby_ne@2:
$LN15@groupby_ne@2:

; 111  :             }
; 112  :         }
; 113  : 
; 114  :         tmp = gbo->currkey;

  000e5	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  000ea	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000ee	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 115  :         gbo->currkey = newkey;

  000f3	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  000f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newkey$[rsp]
  000fd	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx
$LN13@groupby_ne@2:

; 116  :         Py_XDECREF(tmp);

  00101	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00107	74 0a		 je	 SHORT $LN10@groupby_ne@2
  00109	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  0010e	e8 00 00 00 00	 call	 _Py_DecRef
$LN10@groupby_ne@2:
  00113	33 c0		 xor	 eax, eax
  00115	85 c0		 test	 eax, eax
  00117	75 e8		 jne	 SHORT $LN13@groupby_ne@2

; 117  : 
; 118  :         tmp = gbo->currvalue;

  00119	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  0011e	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00125	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 119  :         gbo->currvalue = newvalue;

  0012a	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  0012f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newvalue$[rsp]
  00134	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx
$LN9@groupby_ne@2:

; 120  :         Py_XDECREF(tmp);

  0013b	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00141	74 0a		 je	 SHORT $LN6@groupby_ne@2
  00143	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  00148	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@groupby_ne@2:
  0014d	33 c0		 xor	 eax, eax
  0014f	85 c0		 test	 eax, eax
  00151	75 e8		 jne	 SHORT $LN9@groupby_ne@2

; 121  :     }

  00153	e9 b1 fe ff ff	 jmp	 $LN26@groupby_ne@2
$LN25@groupby_ne@2:

; 122  : 
; 123  :     Py_INCREF(gbo->currkey);

  00158	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  0015d	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00161	e8 00 00 00 00	 call	 _Py_IncRef

; 124  :     tmp = gbo->tgtkey;

  00166	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  0016b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0016f	48 89 44 24 20	 mov	 QWORD PTR tmp$[rsp], rax

; 125  :     gbo->tgtkey = gbo->currkey;

  00174	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  00179	48 8b 4c 24 60	 mov	 rcx, QWORD PTR gbo$[rsp]
  0017e	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00182	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
$LN5@groupby_ne@2:

; 126  :     Py_XDECREF(tmp);

  00186	48 83 7c 24 20
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0018c	74 0a		 je	 SHORT $LN2@groupby_ne@2
  0018e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tmp$[rsp]
  00193	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@groupby_ne@2:
  00198	33 c0		 xor	 eax, eax
  0019a	85 c0		 test	 eax, eax
  0019c	75 e8		 jne	 SHORT $LN5@groupby_ne@2

; 127  : 
; 128  :     grouper = _grouper_create(gbo, gbo->tgtkey);

  0019e	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  001a3	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  001a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR gbo$[rsp]
  001ac	e8 00 00 00 00	 call	 _grouper_create
  001b1	48 89 44 24 38	 mov	 QWORD PTR grouper$[rsp], rax

; 129  :     if (grouper == NULL)

  001b6	48 83 7c 24 38
	00		 cmp	 QWORD PTR grouper$[rsp], 0
  001bc	75 04		 jne	 SHORT $LN1@groupby_ne@2

; 130  :         return NULL;

  001be	33 c0		 xor	 eax, eax
  001c0	eb 2c		 jmp	 SHORT $LN27@groupby_ne@2
$LN1@groupby_ne@2:

; 131  : 
; 132  :     r = PyTuple_Pack(2, gbo->currkey, grouper);

  001c2	4c 8b 44 24 38	 mov	 r8, QWORD PTR grouper$[rsp]
  001c7	48 8b 44 24 60	 mov	 rax, QWORD PTR gbo$[rsp]
  001cc	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  001d0	b9 02 00 00 00	 mov	 ecx, 2
  001d5	e8 00 00 00 00	 call	 PyTuple_Pack
  001da	48 89 44 24 40	 mov	 QWORD PTR r$[rsp], rax

; 133  :     Py_DECREF(grouper);

  001df	48 8b 4c 24 38	 mov	 rcx, QWORD PTR grouper$[rsp]
  001e4	e8 00 00 00 00	 call	 _Py_DecRef

; 134  :     return r;

  001e9	48 8b 44 24 40	 mov	 rax, QWORD PTR r$[rsp]
$LN27@groupby_ne@2:

; 135  : }

  001ee	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001f2	c3		 ret	 0
groupby_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_05LNHFJPFN@O?$CIOO?$CJ?$AA@		; `string'
PUBLIC	??_C@_0L@OLFKNFHI@O?$CIOO?$CJ?$CIOOO?$CJ?$AA@	; `string'
EXTRN	Py_BuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$groupby_reduce DD imagerel groupby_reduce
	DD	imagerel groupby_reduce+193
	DD	imagerel $unwind$groupby_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$groupby_reduce DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_05LNHFJPFN@O?$CIOO?$CJ?$AA@
CONST	SEGMENT
??_C@_05LNHFJPFN@O?$CIOO?$CJ?$AA@ DB 'O(OO)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@OLFKNFHI@O?$CIOO?$CJ?$CIOOO?$CJ?$AA@
CONST	SEGMENT
??_C@_0L@OLFKNFHI@O?$CIOO?$CJ?$CIOOO?$CJ?$AA@ DB 'O(OO)(OOO)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT groupby_reduce
_TEXT	SEGMENT
value$ = 64
lz$ = 96
groupby_reduce PROC					; COMDAT

; 139  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 140  :     /* reduce as a 'new' call with an optional 'setstate' if groupby
; 141  :      * has started
; 142  :      */
; 143  :     PyObject *value;
; 144  :     if (lz->tgtkey && lz->currkey && lz->currvalue)

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00013	74 76		 je	 SHORT $LN2@groupby_re
  00015	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0001a	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0001f	74 6a		 je	 SHORT $LN2@groupby_re
  00021	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00026	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0002e	74 5b		 je	 SHORT $LN2@groupby_re

; 145  :         value = Py_BuildValue("O(OO)(OOO)", Py_TYPE(lz),
; 146  :             lz->it, lz->keyfunc, lz->currkey, lz->currvalue, lz->tgtkey);

  00030	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00035	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00039	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00043	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0004a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004f	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00054	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00058	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00062	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  00066	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0006b	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0006f	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00074	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@OLFKNFHI@O?$CIOO?$CJ?$CIOOO?$CJ?$AA@
  0007f	e8 00 00 00 00	 call	 Py_BuildValue
  00084	48 89 44 24 40	 mov	 QWORD PTR value$[rsp], rax

; 147  :     else

  00089	eb 2c		 jmp	 SHORT $LN1@groupby_re
$LN2@groupby_re:

; 148  :         value = Py_BuildValue("O(OO)", Py_TYPE(lz),
; 149  :             lz->it, lz->keyfunc);

  0008b	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00090	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  00094	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00099	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0009d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000a2	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LNHFJPFN@O?$CIOO?$CJ?$AA@
  000ad	e8 00 00 00 00	 call	 Py_BuildValue
  000b2	48 89 44 24 40	 mov	 QWORD PTR value$[rsp], rax
$LN1@groupby_re:

; 150  : 
; 151  :     return value;

  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR value$[rsp]

; 152  : }

  000bc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c0	c3		 ret	 0
groupby_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@PGDIIEBE@groupby_setstate?$AA@	; `string'
PUBLIC	??_C@_03BBOLPBLP@OOO?$AA@			; `string'
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$groupby_setstate DD imagerel groupby_setstate
	DD	imagerel groupby_setstate+491
	DD	imagerel $unwind$groupby_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$groupby_setstate DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT ??_C@_0BB@PGDIIEBE@groupby_setstate?$AA@
CONST	SEGMENT
??_C@_0BB@PGDIIEBE@groupby_setstate?$AA@ DB 'groupby_setstate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03BBOLPBLP@OOO?$AA@
CONST	SEGMENT
??_C@_03BBOLPBLP@OOO?$AA@ DB 'OOO', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT groupby_setstate
_TEXT	SEGMENT
tgtkey$ = 48
currvalue$ = 56
currkey$ = 64
_py_tmp$20533 = 72
_py_tmp$20542 = 80
_py_tmp$20551 = 88
lz$ = 112
state$ = 120
groupby_setstate PROC					; COMDAT

; 158  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 159  :     PyObject *currkey, *currvalue, *tgtkey;
; 160  :     if (!PyArg_ParseTuple(state, "OOO", &currkey, &currvalue, &tgtkey))

  0000e	48 8d 44 24 30	 lea	 rax, QWORD PTR tgtkey$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00018	4c 8d 4c 24 38	 lea	 r9, QWORD PTR currvalue$[rsp]
  0001d	4c 8d 44 24 40	 lea	 r8, QWORD PTR currkey$[rsp]
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03BBOLPBLP@OOO?$AA@
  00029	48 8b 4c 24 78	 mov	 rcx, QWORD PTR state$[rsp]
  0002e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00033	85 c0		 test	 eax, eax
  00035	75 07		 jne	 SHORT $LN13@groupby_se

; 161  :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	e9 a8 01 00 00	 jmp	 $LN14@groupby_se
$LN13@groupby_se:
$LN12@groupby_se:

; 162  :     Py_CLEAR(lz->currkey);

  0003e	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00043	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00048	74 53		 je	 SHORT $LN9@groupby_se
  0004a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00052	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00057	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  0005b	41 b8 a2 00 00
	00		 mov	 r8d, 162		; 000000a2H
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@PGDIIEBE@groupby_setstate?$AA@
  0006f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00074	85 c0		 test	 eax, eax
  00076	75 25		 jne	 SHORT $LN9@groupby_se
  00078	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  0007d	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00081	48 89 44 24 48	 mov	 QWORD PTR _py_tmp$20533[rsp], rax
  00086	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  0008b	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0
  00093	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _py_tmp$20533[rsp]
  00098	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@groupby_se:
  0009d	33 c0		 xor	 eax, eax
  0009f	85 c0		 test	 eax, eax
  000a1	75 9b		 jne	 SHORT $LN12@groupby_se

; 163  :     lz->currkey = currkey;

  000a3	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR currkey$[rsp]
  000ad	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 164  :     Py_INCREF(lz->currkey);

  000b1	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  000b6	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  000ba	e8 00 00 00 00	 call	 _Py_IncRef
$LN8@groupby_se:

; 165  :     Py_CLEAR(lz->currvalue);

  000bf	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  000c4	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000cc	74 5c		 je	 SHORT $LN5@groupby_se
  000ce	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d6	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  000db	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  000e2	41 b8 a5 00 00
	00		 mov	 r8d, 165		; 000000a5H
  000e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@PGDIIEBE@groupby_setstate?$AA@
  000f6	e8 00 00 00 00	 call	 _PyParallel_Guard
  000fb	85 c0		 test	 eax, eax
  000fd	75 2b		 jne	 SHORT $LN5@groupby_se
  000ff	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00104	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0010b	48 89 44 24 50	 mov	 QWORD PTR _py_tmp$20542[rsp], rax
  00110	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00115	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0
  00120	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _py_tmp$20542[rsp]
  00125	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@groupby_se:
  0012a	33 c0		 xor	 eax, eax
  0012c	85 c0		 test	 eax, eax
  0012e	75 8f		 jne	 SHORT $LN8@groupby_se

; 166  :     lz->currvalue = currvalue;

  00130	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00135	48 8b 4c 24 38	 mov	 rcx, QWORD PTR currvalue$[rsp]
  0013a	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 167  :     Py_INCREF(lz->currvalue);

  00141	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00146	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0014d	e8 00 00 00 00	 call	 _Py_IncRef
$LN4@groupby_se:

; 168  :     Py_CLEAR(lz->tgtkey);

  00152	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00157	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0015c	74 53		 je	 SHORT $LN1@groupby_se
  0015e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00166	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  0016b	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  0016f	41 b8 a8 00 00
	00		 mov	 r8d, 168		; 000000a8H
  00175	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@PGDIIEBE@groupby_setstate?$AA@
  00183	e8 00 00 00 00	 call	 _PyParallel_Guard
  00188	85 c0		 test	 eax, eax
  0018a	75 25		 jne	 SHORT $LN1@groupby_se
  0018c	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00191	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00195	48 89 44 24 58	 mov	 QWORD PTR _py_tmp$20551[rsp], rax
  0019a	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  0019f	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
  001a7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _py_tmp$20551[rsp]
  001ac	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@groupby_se:
  001b1	33 c0		 xor	 eax, eax
  001b3	85 c0		 test	 eax, eax
  001b5	75 9b		 jne	 SHORT $LN4@groupby_se

; 169  :     lz->tgtkey = tgtkey;

  001b7	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  001bc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tgtkey$[rsp]
  001c1	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 170  :     Py_INCREF(lz->tgtkey);

  001c5	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  001ca	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  001ce	e8 00 00 00 00	 call	 _Py_IncRef

; 171  :     Py_RETURN_NONE;

  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  001da	e8 00 00 00 00	 call	 _Py_IncRef
  001df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN14@groupby_se:

; 172  : }

  001e6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ea	c3		 ret	 0
groupby_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_03FDKCBHJF@O?$CBO?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_grouper_new DD imagerel _grouper_new
	DD	imagerel _grouper_new+86
	DD	imagerel $unwind$_grouper_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_grouper_new DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_03FDKCBHJF@O?$CBO?$AA@
CONST	SEGMENT
??_C@_03FDKCBHJF@O?$CBO?$AA@ DB 'O!O', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _grouper_new
_TEXT	SEGMENT
tgtkey$ = 48
parent$ = 56
type$ = 80
args$ = 88
kwds$ = 96
_grouper_new PROC					; COMDAT

; 245  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 246  :     PyObject *parent, *tgtkey;
; 247  : 
; 248  :     if (!PyArg_ParseTuple(args, "O!O", &groupby_type, &parent, &tgtkey))

  00013	48 8d 44 24 30	 lea	 rax, QWORD PTR tgtkey$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001d	4c 8d 4c 24 38	 lea	 r9, QWORD PTR parent$[rsp]
  00022	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:groupby_type
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03FDKCBHJF@O?$CBO?$AA@
  00030	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00035	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0003a	85 c0		 test	 eax, eax
  0003c	75 04		 jne	 SHORT $LN1@grouper_ne

; 249  :         return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 0f		 jmp	 SHORT $LN2@grouper_ne
$LN1@grouper_ne:

; 250  : 
; 251  :     return _grouper_create((groupbyobject*) parent, tgtkey);

  00042	48 8b 54 24 30	 mov	 rdx, QWORD PTR tgtkey$[rsp]
  00047	48 8b 4c 24 38	 mov	 rcx, QWORD PTR parent$[rsp]
  0004c	e8 00 00 00 00	 call	 _grouper_create
$LN2@grouper_ne:

; 252  : }

  00051	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00055	c3		 ret	 0
_grouper_new ENDP
_TEXT	ENDS
EXTRN	PyObject_GC_Track:PROC
EXTRN	_PyObject_GC_New:PROC
EXTRN	_PxObject_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_grouper_create DD imagerel _grouper_create
	DD	imagerel _grouper_create+149
	DD	imagerel $unwind$_grouper_create
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_grouper_create DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _grouper_create
_TEXT	SEGMENT
igo$ = 32
tv70 = 40
parent$ = 64
tgtkey$ = 72
_grouper_create PROC					; COMDAT

; 256  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 257  :     _grouperobject *igo;
; 258  : 
; 259  :     igo = PyObject_GC_New(_grouperobject, &_grouper_type);

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 13		 je	 SHORT $LN4@grouper_cr
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_grouper_type
  0001e	e8 00 00 00 00	 call	 _PxObject_New
  00023	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00028	eb 11		 jmp	 SHORT $LN5@grouper_cr
$LN4@grouper_cr:
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_grouper_type
  00031	e8 00 00 00 00	 call	 _PyObject_GC_New
  00036	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN5@grouper_cr:
  0003b	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  00040	48 89 44 24 20	 mov	 QWORD PTR igo$[rsp], rax

; 260  :     if (igo == NULL)

  00045	48 83 7c 24 20
	00		 cmp	 QWORD PTR igo$[rsp], 0
  0004b	75 04		 jne	 SHORT $LN1@grouper_cr

; 261  :         return NULL;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 3f		 jmp	 SHORT $LN2@grouper_cr
$LN1@grouper_cr:

; 262  :     igo->parent = (PyObject *)parent;

  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR igo$[rsp]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR parent$[rsp]
  0005b	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 263  :     Py_INCREF(parent);

  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR parent$[rsp]
  00064	e8 00 00 00 00	 call	 _Py_IncRef

; 264  :     igo->tgtkey = tgtkey;

  00069	48 8b 44 24 20	 mov	 rax, QWORD PTR igo$[rsp]
  0006e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tgtkey$[rsp]
  00073	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 265  :     Py_INCREF(tgtkey);

  00077	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tgtkey$[rsp]
  0007c	e8 00 00 00 00	 call	 _Py_IncRef

; 266  : 
; 267  :     PyObject_GC_Track(igo);

  00081	48 8b 4c 24 20	 mov	 rcx, QWORD PTR igo$[rsp]
  00086	e8 00 00 00 00	 call	 PyObject_GC_Track

; 268  :     return (PyObject *)igo;

  0008b	48 8b 44 24 20	 mov	 rax, QWORD PTR igo$[rsp]
$LN2@grouper_cr:

; 269  : }

  00090	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00094	c3		 ret	 0
_grouper_create ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_grouper_dealloc DD imagerel _grouper_dealloc
	DD	imagerel _grouper_dealloc+62
	DD	imagerel $unwind$_grouper_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_grouper_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _grouper_dealloc
_TEXT	SEGMENT
igo$ = 48
_grouper_dealloc PROC					; COMDAT

; 273  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 274  :     PyObject_GC_UnTrack(igo);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR igo$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 275  :     Py_DECREF(igo->parent);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR igo$[rsp]
  00018	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0001c	e8 00 00 00 00	 call	 _Py_DecRef

; 276  :     Py_DECREF(igo->tgtkey);

  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR igo$[rsp]
  00026	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  0002a	e8 00 00 00 00	 call	 _Py_DecRef

; 277  :     PyObject_GC_Del(igo);

  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR igo$[rsp]
  00034	e8 00 00 00 00	 call	 PyObject_GC_Del

; 278  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
_grouper_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@HDHLNI@_grouper_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$_grouper_traverse DD imagerel _grouper_traverse
	DD	imagerel _grouper_traverse+206
	DD	imagerel $unwind$_grouper_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_grouper_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BC@HDHLNI@_grouper_traverse?$AA@
CONST	SEGMENT
??_C@_0BC@HDHLNI@_grouper_traverse?$AA@ DB '_grouper_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _grouper_traverse
_TEXT	SEGMENT
vret$20639 = 32
vret$20647 = 36
igo$ = 64
visit$ = 72
arg$ = 80
_grouper_traverse PROC					; COMDAT

; 282  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@grouper_tr:

; 283  :     Py_VISIT(igo->parent);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@grouper_tr
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 1b 01 00
	00		 mov	 r8d, 283		; 0000011bH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@HDHLNI@_grouper_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@grouper_tr:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR igo$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN8@grouper_tr
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR igo$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$20639[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$20639[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@grouper_tr
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$20639[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@grouper_tr
$LN7@grouper_tr:
$LN8@grouper_tr:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@grouper_tr
$LN6@grouper_tr:

; 284  :     Py_VISIT(igo->tgtkey);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@grouper_tr
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@HDHLNI@_grouper_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@grouper_tr:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR igo$[rsp]
  00097	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0009c	74 23		 je	 SHORT $LN2@grouper_tr
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR igo$[rsp]
  000a8	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$20647[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$20647[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@grouper_tr
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$20647[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@grouper_tr
$LN1@grouper_tr:
$LN2@grouper_tr:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@grouper_tr

; 285  :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@grouper_tr:

; 286  : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
_grouper_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@OCKKELDB@_grouper_next?$AA@		; `string'
PUBLIC	??_C@_1CK@JLADAONL@?$AAg?$AAb?$AAo?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAr?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@NKAGODIN@?$AAg?$AAb?$AAo?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAr?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_grouper_next DD imagerel _grouper_next
	DD	imagerel _grouper_next+470
	DD	imagerel $unwind$_grouper_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_grouper_next DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_0O@OCKKELDB@_grouper_next?$AA@
CONST	SEGMENT
??_C@_0O@OCKKELDB@_grouper_next?$AA@ DB '_grouper_next', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@JLADAONL@?$AAg?$AAb?$AAo?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAr?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@JLADAONL@?$AAg?$AAb?$AAo?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAr?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'g'
	DB	00H, 'b', 00H, 'o', 00H, '-', 00H, '>', 00H, 'c', 00H, 'u', 00H
	DB	'r', 00H, 'r', 00H, 'k', 00H, 'e', 00H, 'y', 00H, ' ', 00H, '!'
	DB	00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@NKAGODIN@?$AAg?$AAb?$AAo?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAr?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@NKAGODIN@?$AAg?$AAb?$AAo?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAr?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'g'
	DB	00H, 'b', 00H, 'o', 00H, '-', 00H, '>', 00H, 'c', 00H, 'u', 00H
	DB	'r', 00H, 'r', 00H, 'k', 00H, 'e', 00H, 'y', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'M', 00H, 'o', 00H, 'd', 00H, 'u', 00H
	DB	'l', 00H, 'e', 00H, 's', 00H, '\', 00H, 'i', 00H, 't', 00H, 'e'
	DB	00H, 'r', 00H, 't', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H
	DB	'm', 00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, '.'
	DB	00H, 'c', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _grouper_next
_TEXT	SEGMENT
rcmp$ = 48
newvalue$ = 56
newkey$ = 64
gbo$ = 72
r$ = 80
_py_tmp$20688 = 88
igo$ = 112
_grouper_next PROC					; COMDAT

; 290  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 291  :     groupbyobject *gbo = (groupbyobject *)igo->parent;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR igo$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 89 44 24 48	 mov	 QWORD PTR gbo$[rsp], rax

; 292  :     PyObject *newvalue, *newkey, *r;
; 293  :     int rcmp;
; 294  : 
; 295  :     if (gbo->currvalue == NULL) {

  00017	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  0001c	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00024	0f 85 c5 00 00
	00		 jne	 $LN10@grouper_ne@2

; 296  :         newvalue = PyIter_Next(gbo->it);

  0002a	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  0002f	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00033	e8 00 00 00 00	 call	 PyIter_Next
  00038	48 89 44 24 38	 mov	 QWORD PTR newvalue$[rsp], rax

; 297  :         if (newvalue == NULL)

  0003d	48 83 7c 24 38
	00		 cmp	 QWORD PTR newvalue$[rsp], 0
  00043	75 07		 jne	 SHORT $LN9@grouper_ne@2

; 298  :             return NULL;

  00045	33 c0		 xor	 eax, eax
  00047	e9 85 01 00 00	 jmp	 $LN11@grouper_ne@2
$LN9@grouper_ne@2:

; 299  : 
; 300  :         if (gbo->keyfunc == Py_None) {

  0004c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00053	48 8b 4c 24 48	 mov	 rcx, QWORD PTR gbo$[rsp]
  00058	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  0005c	75 16		 jne	 SHORT $LN8@grouper_ne@2

; 301  :             newkey = newvalue;

  0005e	48 8b 44 24 38	 mov	 rax, QWORD PTR newvalue$[rsp]
  00063	48 89 44 24 40	 mov	 QWORD PTR newkey$[rsp], rax

; 302  :             Py_INCREF(newvalue);

  00068	48 8b 4c 24 38	 mov	 rcx, QWORD PTR newvalue$[rsp]
  0006d	e8 00 00 00 00	 call	 _Py_IncRef

; 303  :         } else {

  00072	eb 34		 jmp	 SHORT $LN7@grouper_ne@2
$LN8@grouper_ne@2:

; 304  :             newkey = PyObject_CallFunctionObjArgs(gbo->keyfunc,
; 305  :                                                   newvalue, NULL);

  00074	45 33 c0	 xor	 r8d, r8d
  00077	48 8b 54 24 38	 mov	 rdx, QWORD PTR newvalue$[rsp]
  0007c	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  00081	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00085	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  0008a	48 89 44 24 40	 mov	 QWORD PTR newkey$[rsp], rax

; 306  :             if (newkey == NULL) {

  0008f	48 83 7c 24 40
	00		 cmp	 QWORD PTR newkey$[rsp], 0
  00095	75 11		 jne	 SHORT $LN6@grouper_ne@2

; 307  :                 Py_DECREF(newvalue);

  00097	48 8b 4c 24 38	 mov	 rcx, QWORD PTR newvalue$[rsp]
  0009c	e8 00 00 00 00	 call	 _Py_DecRef

; 308  :                 return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	e9 29 01 00 00	 jmp	 $LN11@grouper_ne@2
$LN6@grouper_ne@2:
$LN7@grouper_ne@2:

; 309  :             }
; 310  :         }
; 311  : 
; 312  :         assert(gbo->currkey == NULL);

  000a8	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  000ad	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  000b2	74 1c		 je	 SHORT $LN13@grouper_ne@2
  000b4	41 b8 38 01 00
	00		 mov	 r8d, 312		; 00000138H
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@NKAGODIN@?$AAg?$AAb?$AAo?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAr?$AAk?$AAe?$AAy?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000ce	33 c0		 xor	 eax, eax
$LN13@grouper_ne@2:

; 313  :         gbo->currkey = newkey;

  000d0	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  000d5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newkey$[rsp]
  000da	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 314  :         gbo->currvalue = newvalue;

  000de	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  000e3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR newvalue$[rsp]
  000e8	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx
$LN10@grouper_ne@2:

; 315  :     }
; 316  : 
; 317  :     assert(gbo->currkey != NULL);

  000ef	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  000f4	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  000f9	75 1c		 jne	 SHORT $LN14@grouper_ne@2
  000fb	41 b8 3d 01 00
	00		 mov	 r8d, 317		; 0000013dH
  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@JLADAONL@?$AAg?$AAb?$AAo?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AAr?$AAk?$AAe?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00115	33 c0		 xor	 eax, eax
$LN14@grouper_ne@2:

; 318  :     rcmp = PyObject_RichCompareBool(igo->tgtkey, gbo->currkey, Py_EQ);

  00117	41 b8 02 00 00
	00		 mov	 r8d, 2
  0011d	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  00122	48 8b 50 78	 mov	 rdx, QWORD PTR [rax+120]
  00126	48 8b 44 24 70	 mov	 rax, QWORD PTR igo$[rsp]
  0012b	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  0012f	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  00134	89 44 24 30	 mov	 DWORD PTR rcmp$[rsp], eax

; 319  :     if (rcmp <= 0)

  00138	83 7c 24 30 00	 cmp	 DWORD PTR rcmp$[rsp], 0
  0013d	7f 07		 jg	 SHORT $LN5@grouper_ne@2

; 320  :         /* got any error or current group is end */
; 321  :         return NULL;

  0013f	33 c0		 xor	 eax, eax
  00141	e9 8b 00 00 00	 jmp	 $LN11@grouper_ne@2
$LN5@grouper_ne@2:

; 322  : 
; 323  :     r = gbo->currvalue;

  00146	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  0014b	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00152	48 89 44 24 50	 mov	 QWORD PTR r$[rsp], rax

; 324  :     gbo->currvalue = NULL;

  00157	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  0015c	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0
$LN4@grouper_ne@2:

; 325  :     Py_CLEAR(gbo->currkey);

  00167	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  0016c	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00171	74 53		 je	 SHORT $LN1@grouper_ne@2
  00173	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0017b	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  00180	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  00184	41 b8 45 01 00
	00		 mov	 r8d, 325		; 00000145H
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@OCKKELDB@_grouper_next?$AA@
  00198	e8 00 00 00 00	 call	 _PyParallel_Guard
  0019d	85 c0		 test	 eax, eax
  0019f	75 25		 jne	 SHORT $LN1@grouper_ne@2
  001a1	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  001a6	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  001aa	48 89 44 24 58	 mov	 QWORD PTR _py_tmp$20688[rsp], rax
  001af	48 8b 44 24 48	 mov	 rax, QWORD PTR gbo$[rsp]
  001b4	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0
  001bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _py_tmp$20688[rsp]
  001c1	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@grouper_ne@2:
  001c6	33 c0		 xor	 eax, eax
  001c8	85 c0		 test	 eax, eax
  001ca	75 9b		 jne	 SHORT $LN4@grouper_ne@2

; 326  : 
; 327  :     return r;

  001cc	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
$LN11@grouper_ne@2:

; 328  : }

  001d1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001d5	c3		 ret	 0
_grouper_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_grouper_reduce DD imagerel _grouper_reduce
	DD	imagerel _grouper_reduce+53
	DD	imagerel $unwind$_grouper_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_grouper_reduce DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _grouper_reduce
_TEXT	SEGMENT
lz$ = 48
_grouper_reduce PROC					; COMDAT

; 332  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 333  :     return Py_BuildValue("O(OO)", Py_TYPE(lz),
; 334  :             lz->parent, lz->tgtkey);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00017	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00020	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LNHFJPFN@O?$CIOO?$CJ?$AA@
  0002b	e8 00 00 00 00	 call	 Py_BuildValue

; 335  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
_grouper_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@KDFMIKCD@teedataobject_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$teedataobject_traverse DD imagerel teedataobject_traverse
	DD	imagerel teedataobject_traverse+347
	DD	imagerel $unwind$teedataobject_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$teedataobject_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BH@KDFMIKCD@teedataobject_traverse?$AA@
CONST	SEGMENT
??_C@_0BH@KDFMIKCD@teedataobject_traverse?$AA@ DB 'teedataobject_traverse'
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT teedataobject_traverse
_TEXT	SEGMENT
i$ = 32
vret$20790 = 36
vret$20801 = 40
vret$20809 = 44
tdo$ = 64
visit$ = 72
arg$ = 80
teedataobject_traverse PROC				; COMDAT

; 467  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN21@teedataobj:

; 468  :     int i;
; 469  :     Py_VISIT(tdo->it);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN18@teedataobj
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 d5 01 00
	00		 mov	 r8d, 469		; 000001d5H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@KDFMIKCD@teedataobject_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN18@teedataobj:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR tdo$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 26		 je	 SHORT $LN17@teedataobj
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR tdo$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 24	 mov	 DWORD PTR vret$20790[rsp], eax
  0005a	83 7c 24 24 00	 cmp	 DWORD PTR vret$20790[rsp], 0
  0005f	74 09		 je	 SHORT $LN16@teedataobj
  00061	8b 44 24 24	 mov	 eax, DWORD PTR vret$20790[rsp]
  00065	e9 ec 00 00 00	 jmp	 $LN22@teedataobj
$LN16@teedataobj:
$LN17@teedataobj:
  0006a	33 c0		 xor	 eax, eax
  0006c	85 c0		 test	 eax, eax
  0006e	75 a3		 jne	 SHORT $LN21@teedataobj

; 470  :     for (i = 0; i < tdo->numread; i++)

  00070	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00078	eb 0a		 jmp	 SHORT $LN15@teedataobj
$LN14@teedataobj:
  0007a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0007e	ff c0		 inc	 eax
  00080	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN15@teedataobj:
  00084	48 8b 44 24 40	 mov	 rax, QWORD PTR tdo$[rsp]
  00089	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0008c	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00090	7d 68		 jge	 SHORT $LN13@teedataobj
$LN12@teedataobj:

; 471  :         Py_VISIT(tdo->values[i]);

  00092	e8 00 00 00 00	 call	 _Py_PXCTX
  00097	85 c0		 test	 eax, eax
  00099	74 1c		 je	 SHORT $LN9@teedataobj
  0009b	45 33 c9	 xor	 r9d, r9d
  0009e	41 b8 d7 01 00
	00		 mov	 r8d, 471		; 000001d7H
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@KDFMIKCD@teedataobject_traverse?$AA@
  000b2	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@teedataobj:
  000b7	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tdo$[rsp]
  000c1	48 83 7c c1 78
	00		 cmp	 QWORD PTR [rcx+rax*8+120], 0
  000c7	74 29		 je	 SHORT $LN8@teedataobj
  000c9	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ce	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000d3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tdo$[rsp]
  000d8	48 8b 4c c1 78	 mov	 rcx, QWORD PTR [rcx+rax*8+120]
  000dd	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000e1	89 44 24 28	 mov	 DWORD PTR vret$20801[rsp], eax
  000e5	83 7c 24 28 00	 cmp	 DWORD PTR vret$20801[rsp], 0
  000ea	74 06		 je	 SHORT $LN7@teedataobj
  000ec	8b 44 24 28	 mov	 eax, DWORD PTR vret$20801[rsp]
  000f0	eb 64		 jmp	 SHORT $LN22@teedataobj
$LN7@teedataobj:
$LN8@teedataobj:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 9a		 jne	 SHORT $LN12@teedataobj
  000f8	eb 80		 jmp	 SHORT $LN14@teedataobj
$LN13@teedataobj:
$LN6@teedataobj:

; 472  :     Py_VISIT(tdo->nextlink);

  000fa	e8 00 00 00 00	 call	 _Py_PXCTX
  000ff	85 c0		 test	 eax, eax
  00101	74 1c		 je	 SHORT $LN3@teedataobj
  00103	45 33 c9	 xor	 r9d, r9d
  00106	41 b8 d8 01 00
	00		 mov	 r8d, 472		; 000001d8H
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@KDFMIKCD@teedataobject_traverse?$AA@
  0011a	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@teedataobj:
  0011f	48 8b 44 24 40	 mov	 rax, QWORD PTR tdo$[rsp]
  00124	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00129	74 23		 je	 SHORT $LN2@teedataobj
  0012b	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00130	48 8b 44 24 40	 mov	 rax, QWORD PTR tdo$[rsp]
  00135	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00139	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  0013d	89 44 24 2c	 mov	 DWORD PTR vret$20809[rsp], eax
  00141	83 7c 24 2c 00	 cmp	 DWORD PTR vret$20809[rsp], 0
  00146	74 06		 je	 SHORT $LN1@teedataobj
  00148	8b 44 24 2c	 mov	 eax, DWORD PTR vret$20809[rsp]
  0014c	eb 08		 jmp	 SHORT $LN22@teedataobj
$LN1@teedataobj:
$LN2@teedataobj:
  0014e	33 c0		 xor	 eax, eax
  00150	85 c0		 test	 eax, eax
  00152	75 a6		 jne	 SHORT $LN6@teedataobj

; 473  :     return 0;

  00154	33 c0		 xor	 eax, eax
$LN22@teedataobj:

; 474  : }

  00156	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0015a	c3		 ret	 0
teedataobject_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@FHHEMKKO@teedataobject_clear?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$teedataobject_clear DD imagerel teedataobject_clear
	DD	imagerel teedataobject_clear+322
	DD	imagerel $unwind$teedataobject_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$teedataobject_clear DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0BE@FHHEMKKO@teedataobject_clear?$AA@
CONST	SEGMENT
??_C@_0BE@FHHEMKKO@teedataobject_clear?$AA@ DB 'teedataobject_clear', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT teedataobject_clear
_TEXT	SEGMENT
i$ = 48
tmp$ = 56
_py_tmp$20842 = 64
_py_tmp$20853 = 72
tdo$ = 96
teedataobject_clear PROC				; COMDAT

; 491  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN11@teedataobj@2:

; 492  :     int i;
; 493  :     PyObject *tmp;
; 494  : 
; 495  :     Py_CLEAR(tdo->it);

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 53		 je	 SHORT $LN8@teedataobj@2
  00015	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  00022	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  00026	41 b8 ef 01 00
	00		 mov	 r8d, 495		; 000001efH
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@FHHEMKKO@teedataobject_clear?$AA@
  0003a	e8 00 00 00 00	 call	 _PyParallel_Guard
  0003f	85 c0		 test	 eax, eax
  00041	75 25		 jne	 SHORT $LN8@teedataobj@2
  00043	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  00048	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0004c	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$20842[rsp], rax
  00051	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  00056	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$20842[rsp]
  00063	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@teedataobj@2:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 9b		 jne	 SHORT $LN11@teedataobj@2

; 496  :     for (i=0 ; i<tdo->numread ; i++)

  0006e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00076	eb 0a		 jmp	 SHORT $LN7@teedataobj@2
$LN6@teedataobj@2:
  00078	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@teedataobj@2:
  00082	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  00087	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0008a	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0008e	0f 8d 82 00 00
	00		 jge	 $LN5@teedataobj@2
$LN4@teedataobj@2:

; 497  :         Py_CLEAR(tdo->values[i]);

  00094	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00099	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tdo$[rsp]
  0009e	48 83 7c c1 78
	00		 cmp	 QWORD PTR [rcx+rax*8+120], 0
  000a4	74 65		 je	 SHORT $LN1@teedataobj@2
  000a6	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000ab	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tdo$[rsp]
  000b8	4c 8b 4c c1 78	 mov	 r9, QWORD PTR [rcx+rax*8+120]
  000bd	41 b8 f1 01 00
	00		 mov	 r8d, 497		; 000001f1H
  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@FHHEMKKO@teedataobject_clear?$AA@
  000d1	e8 00 00 00 00	 call	 _PyParallel_Guard
  000d6	85 c0		 test	 eax, eax
  000d8	75 31		 jne	 SHORT $LN1@teedataobj@2
  000da	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000df	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tdo$[rsp]
  000e4	48 8b 44 c1 78	 mov	 rax, QWORD PTR [rcx+rax*8+120]
  000e9	48 89 44 24 48	 mov	 QWORD PTR _py_tmp$20853[rsp], rax
  000ee	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tdo$[rsp]
  000f8	48 c7 44 c1 78
	00 00 00 00	 mov	 QWORD PTR [rcx+rax*8+120], 0
  00101	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _py_tmp$20853[rsp]
  00106	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@teedataobj@2:
  0010b	33 c0		 xor	 eax, eax
  0010d	85 c0		 test	 eax, eax
  0010f	75 83		 jne	 SHORT $LN4@teedataobj@2
  00111	e9 62 ff ff ff	 jmp	 $LN6@teedataobj@2
$LN5@teedataobj@2:

; 498  :     tmp = tdo->nextlink;

  00116	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  0011b	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0011f	48 89 44 24 38	 mov	 QWORD PTR tmp$[rsp], rax

; 499  :     tdo->nextlink = NULL;

  00124	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  00129	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 500  :     teedataobject_safe_decref(tmp);

  00131	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tmp$[rsp]
  00136	e8 00 00 00 00	 call	 teedataobject_safe_decref

; 501  :     return 0;

  0013b	33 c0		 xor	 eax, eax

; 502  : }

  0013d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00141	c3		 ret	 0
teedataobject_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$teedataobject_safe_decref DD imagerel teedataobject_safe_decref
	DD	imagerel teedataobject_safe_decref+125
	DD	imagerel $unwind$teedataobject_safe_decref
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$teedataobject_safe_decref DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT teedataobject_safe_decref
_TEXT	SEGMENT
nextlink$20821 = 32
obj$ = 64
teedataobject_safe_decref PROC				; COMDAT

; 478  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@teedataobj@3:

; 479  :     while (obj && Py_TYPE(obj) == &teedataobject_type &&
; 480  :            Py_REFCNT(obj) == 1) {

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR obj$[rsp], 0
  0000f	74 4f		 je	 SHORT $LN5@teedataobj@3
  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:teedataobject_type
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  0001d	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00021	75 3d		 jne	 SHORT $LN5@teedataobj@3
  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  00028	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  0002d	75 31		 jne	 SHORT $LN5@teedataobj@3

; 481  :         PyObject *nextlink = ((teedataobject *)obj)->nextlink;

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  00034	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00038	48 89 44 24 20	 mov	 QWORD PTR nextlink$20821[rsp], rax

; 482  :         ((teedataobject *)obj)->nextlink = NULL;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  00042	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 483  :         Py_DECREF(obj);

  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  0004f	e8 00 00 00 00	 call	 _Py_DecRef

; 484  :         obj = nextlink;

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR nextlink$20821[rsp]
  00059	48 89 44 24 40	 mov	 QWORD PTR obj$[rsp], rax

; 485  :     }

  0005e	eb a9		 jmp	 SHORT $LN6@teedataobj@3
$LN5@teedataobj@3:
$LN4@teedataobj@3:

; 486  :     Py_XDECREF(obj);

  00060	48 83 7c 24 40
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00066	74 0a		 je	 SHORT $LN1@teedataobj@3
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR obj$[rsp]
  0006d	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@teedataobj@3:
  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 e8		 jne	 SHORT $LN4@teedataobj@3

; 487  : }

  00078	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007c	c3		 ret	 0
teedataobject_safe_decref ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$teedataobject_dealloc DD imagerel teedataobject_dealloc
	DD	imagerel teedataobject_dealloc+44
	DD	imagerel $unwind$teedataobject_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$teedataobject_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT teedataobject_dealloc
_TEXT	SEGMENT
tdo$ = 48
teedataobject_dealloc PROC				; COMDAT

; 506  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 507  :     PyObject_GC_UnTrack(tdo);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tdo$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 508  :     teedataobject_clear(tdo);

  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tdo$[rsp]
  00018	e8 00 00 00 00	 call	 teedataobject_clear

; 509  :     PyObject_GC_Del(tdo);

  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tdo$[rsp]
  00022	e8 00 00 00 00	 call	 PyObject_GC_Del

; 510  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
teedataobject_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_06KFMHBHMK@O?$CIONO?$CJ?$AA@		; `string'
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$teedataobject_reduce DD imagerel teedataobject_reduce
	DD	imagerel teedataobject_reduce+225
	DD	imagerel $unwind$teedataobject_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$teedataobject_reduce DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_06KFMHBHMK@O?$CIONO?$CJ?$AA@
CONST	SEGMENT
??_C@_06KFMHBHMK@O?$CIONO?$CJ?$AA@ DB 'O(ONO)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT teedataobject_reduce
_TEXT	SEGMENT
values$ = 48
i$ = 56
tv89 = 64
tdo$ = 96
teedataobject_reduce PROC				; COMDAT

; 514  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 515  :     int i;
; 516  :     /* create a temporary list of already iterated values */
; 517  :     PyObject *values = PyList_New(tdo->numread);

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  0000e	48 63 40 68	 movsxd	 rax, DWORD PTR [rax+104]
  00012	48 8b c8	 mov	 rcx, rax
  00015	e8 00 00 00 00	 call	 PyList_New
  0001a	48 89 44 24 30	 mov	 QWORD PTR values$[rsp], rax

; 518  :     if (!values)

  0001f	48 83 7c 24 30
	00		 cmp	 QWORD PTR values$[rsp], 0
  00025	75 07		 jne	 SHORT $LN4@teedataobj@4

; 519  :         return NULL;

  00027	33 c0		 xor	 eax, eax
  00029	e9 ae 00 00 00	 jmp	 $LN5@teedataobj@4
$LN4@teedataobj@4:

; 520  :     for (i=0 ; i<tdo->numread ; i++) {

  0002e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00036	eb 0a		 jmp	 SHORT $LN3@teedataobj@4
$LN2@teedataobj@4:
  00038	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0003c	ff c0		 inc	 eax
  0003e	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN3@teedataobj@4:
  00042	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  00047	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0004a	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  0004e	7d 37		 jge	 SHORT $LN1@teedataobj@4

; 521  :         Py_INCREF(tdo->values[i]);

  00050	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$[rsp]
  00055	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tdo$[rsp]
  0005a	48 8b 4c c1 78	 mov	 rcx, QWORD PTR [rcx+rax*8+120]
  0005f	e8 00 00 00 00	 call	 _Py_IncRef

; 522  :         PyList_SET_ITEM(values, i, tdo->values[i]);

  00064	48 63 44 24 38	 movsxd	 rax, DWORD PTR i$[rsp]
  00069	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR i$[rsp]
  0006e	48 8b 54 24 30	 mov	 rdx, QWORD PTR values$[rsp]
  00073	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00077	4c 8b 44 24 60	 mov	 r8, QWORD PTR tdo$[rsp]
  0007c	49 8b 44 c0 78	 mov	 rax, QWORD PTR [r8+rax*8+120]
  00081	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 523  :     }

  00085	eb b1		 jmp	 SHORT $LN2@teedataobj@4
$LN1@teedataobj@4:

; 524  :     return Py_BuildValue("O(ONO)", Py_TYPE(tdo), tdo->it,
; 525  :                          values,
; 526  :                          tdo->nextlink ? tdo->nextlink : Py_None);

  00087	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  0008c	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00091	74 10		 je	 SHORT $LN7@teedataobj@4
  00093	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  00098	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0009c	48 89 44 24 40	 mov	 QWORD PTR tv89[rsp], rax
  000a1	eb 0c		 jmp	 SHORT $LN8@teedataobj@4
$LN7@teedataobj@4:
  000a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000aa	48 89 44 24 40	 mov	 QWORD PTR tv89[rsp], rax
$LN8@teedataobj@4:
  000af	48 8b 44 24 40	 mov	 rax, QWORD PTR tv89[rsp]
  000b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b9	4c 8b 4c 24 30	 mov	 r9, QWORD PTR values$[rsp]
  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  000c3	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  000c7	48 8b 44 24 60	 mov	 rax, QWORD PTR tdo$[rsp]
  000cc	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06KFMHBHMK@O?$CIONO?$CJ?$AA@
  000d7	e8 00 00 00 00	 call	 Py_BuildValue
$LN5@teedataobj@4:

; 527  : }

  000dc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e0	c3		 ret	 0
teedataobject_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@PALKPJEA@Invalid?5arguments?$AA@	; `string'
PUBLIC	??_C@_1CM@GPLMDOCI@?$AAt?$AAd?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAl?$AAi?$AAn?$AAk?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@CENPMFEO@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_04GOGHPAAM@OO?$CBO?$AA@			; `string'
PUBLIC	??_C@_1DI@GECMMFGN@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CG?$AAt?$AAe?$AAe?$AAd?$AAa?$AAt?$AAa?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?$AA@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyList_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$teedataobject_new DD imagerel teedataobject_new
	DD	imagerel teedataobject_new+502
	DD	imagerel $unwind$teedataobject_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$teedataobject_new DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0BC@PALKPJEA@Invalid?5arguments?$AA@
CONST	SEGMENT
??_C@_0BC@PALKPJEA@Invalid?5arguments?$AA@ DB 'Invalid arguments', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@GPLMDOCI@?$AAt?$AAd?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAl?$AAi?$AAn?$AAk?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@GPLMDOCI@?$AAt?$AAd?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAl?$AAi?$AAn?$AAk?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 'd', 00H, 'o', 00H, '-', 00H, '>', 00H, 'n', 00H, 'e', 00H
	DB	'x', 00H, 't', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'k', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@CENPMFEO@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@CENPMFEO@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?$AA@ DB '('
	DB	00H, 'P', 00H, 'y', 00H, '_', 00H, 's', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, ')', 00H, '(', 00H, 'l', 00H, 'e', 00H
	DB	'n', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '('
	DB	00H, 'l', 00H, 'e', 00H, 'n', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04GOGHPAAM@OO?$CBO?$AA@
CONST	SEGMENT
??_C@_04GOGHPAAM@OO?$CBO?$AA@ DB 'OO!O', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@GECMMFGN@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CG?$AAt?$AAe?$AAe?$AAd?$AAa?$AAt?$AAa?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@GECMMFGN@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CG?$AAt?$AAe?$AAe?$AAd?$AAa?$AAt?$AAa?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?$AA@ DB 't'
	DB	00H, 'y', 00H, 'p', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '&', 00H, 't', 00H, 'e', 00H, 'e', 00H, 'd', 00H, 'a'
	DB	00H, 't', 00H, 'a', 00H, 'o', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT teedataobject_new
_TEXT	SEGMENT
it$ = 48
i$ = 56
values$ = 64
len$ = 72
next$ = 80
tdo$ = 88
type$ = 112
args$ = 120
kw$ = 128
teedataobject_new PROC					; COMDAT

; 533  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 534  :     teedataobject *tdo;
; 535  :     PyObject *it, *values, *next;
; 536  :     Py_ssize_t i, len;
; 537  : 
; 538  :     assert(type == &teedataobject_type);

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:teedataobject_type
  0001a	48 39 44 24 70	 cmp	 QWORD PTR type$[rsp], rax
  0001f	74 1c		 je	 SHORT $LN18@teedataobj@5
  00021	41 b8 1a 02 00
	00		 mov	 r8d, 538		; 0000021aH
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@GECMMFGN@?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CG?$AAt?$AAe?$AAe?$AAd?$AAa?$AAt?$AAa?$AAo?$AAb?$AAj?$AAe?$AAc?$AAt?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?$AA@
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0003b	33 c0		 xor	 eax, eax
$LN18@teedataobj@5:

; 539  :     if (!PyArg_ParseTuple(args, "OO!O", &it, &PyList_Type, &values, &next))

  0003d	48 8d 44 24 50	 lea	 rax, QWORD PTR next$[rsp]
  00042	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00047	48 8d 44 24 40	 lea	 rax, QWORD PTR values$[rsp]
  0004c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00051	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:PyList_Type
  00058	4c 8d 44 24 30	 lea	 r8, QWORD PTR it$[rsp]
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GOGHPAAM@OO?$CBO?$AA@
  00064	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00069	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0006e	85 c0		 test	 eax, eax
  00070	75 07		 jne	 SHORT $LN15@teedataobj@5

; 540  :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	e9 78 01 00 00	 jmp	 $LN16@teedataobj@5
$LN15@teedataobj@5:

; 541  : 
; 542  :     tdo = (teedataobject *)teedataobject_newinternal(it);

  00079	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  0007e	e8 00 00 00 00	 call	 teedataobject_newinternal
  00083	48 89 44 24 58	 mov	 QWORD PTR tdo$[rsp], rax

; 543  :     if (!tdo)

  00088	48 83 7c 24 58
	00		 cmp	 QWORD PTR tdo$[rsp], 0
  0008e	75 07		 jne	 SHORT $LN14@teedataobj@5

; 544  :         return NULL;

  00090	33 c0		 xor	 eax, eax
  00092	e9 5a 01 00 00	 jmp	 $LN16@teedataobj@5
$LN14@teedataobj@5:

; 545  : 
; 546  :     len = PyList_GET_SIZE(values);

  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR values$[rsp]
  0009c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a0	48 89 44 24 48	 mov	 QWORD PTR len$[rsp], rax

; 547  :     if (len > LINKCELLS)

  000a5	48 83 7c 24 48
	39		 cmp	 QWORD PTR len$[rsp], 57	; 00000039H
  000ab	7e 05		 jle	 SHORT $LN13@teedataobj@5

; 548  :         goto err;

  000ad	e9 12 01 00 00	 jmp	 $err$20901
$LN13@teedataobj@5:

; 549  :     for (i=0; i<len; i++) {

  000b2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000bb	eb 0d		 jmp	 SHORT $LN12@teedataobj@5
$LN11@teedataobj@5:
  000bd	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  000c2	48 ff c0	 inc	 rax
  000c5	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN12@teedataobj@5:
  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  000cf	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  000d4	7d 37		 jge	 SHORT $LN10@teedataobj@5

; 550  :         tdo->values[i] = PyList_GET_ITEM(values, i);

  000d6	48 8b 44 24 40	 mov	 rax, QWORD PTR values$[rsp]
  000db	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tdo$[rsp]
  000e4	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  000e9	4c 8b 44 24 38	 mov	 r8, QWORD PTR i$[rsp]
  000ee	4a 8b 04 c0	 mov	 rax, QWORD PTR [rax+r8*8]
  000f2	48 89 44 d1 78	 mov	 QWORD PTR [rcx+rdx*8+120], rax

; 551  :         Py_INCREF(tdo->values[i]);

  000f7	48 8b 44 24 58	 mov	 rax, QWORD PTR tdo$[rsp]
  000fc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00101	48 8b 4c c8 78	 mov	 rcx, QWORD PTR [rax+rcx*8+120]
  00106	e8 00 00 00 00	 call	 _Py_IncRef

; 552  :     }

  0010b	eb b0		 jmp	 SHORT $LN11@teedataobj@5
$LN10@teedataobj@5:

; 553  :     /* len <= LINKCELLS < INT_MAX */
; 554  :     tdo->numread = Py_SAFE_DOWNCAST(len, Py_ssize_t, int);

  0010d	48 63 44 24 48	 movsxd	 rax, DWORD PTR len$[rsp]
  00112	48 3b 44 24 48	 cmp	 rax, QWORD PTR len$[rsp]
  00117	74 1c		 je	 SHORT $LN19@teedataobj@5
  00119	41 b8 2a 02 00
	00		 mov	 r8d, 554		; 0000022aH
  0011f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@CENPMFEO@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAl?$AAe?$AAn?$AA?$CJ?$AA?$AA@
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00133	33 c0		 xor	 eax, eax
$LN19@teedataobj@5:
  00135	48 8b 44 24 58	 mov	 rax, QWORD PTR tdo$[rsp]
  0013a	8b 4c 24 48	 mov	 ecx, DWORD PTR len$[rsp]
  0013e	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 555  : 
; 556  :     if (len == LINKCELLS) {

  00141	48 83 7c 24 48
	39		 cmp	 QWORD PTR len$[rsp], 57	; 00000039H
  00147	75 64		 jne	 SHORT $LN9@teedataobj@5

; 557  :         if (next != Py_None) {

  00149	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00150	48 39 44 24 50	 cmp	 QWORD PTR next$[rsp], rax
  00155	74 54		 je	 SHORT $LN8@teedataobj@5

; 558  :             if (Py_TYPE(next) != &teedataobject_type)

  00157	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:teedataobject_type
  0015e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00163	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00167	74 02		 je	 SHORT $LN7@teedataobj@5

; 559  :                 goto err;

  00169	eb 59		 jmp	 SHORT $err$20901
$LN7@teedataobj@5:

; 560  :             assert(tdo->nextlink == NULL);

  0016b	48 8b 44 24 58	 mov	 rax, QWORD PTR tdo$[rsp]
  00170	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00175	74 1c		 je	 SHORT $LN20@teedataobj@5
  00177	41 b8 30 02 00
	00		 mov	 r8d, 560		; 00000230H
  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@GPLMDOCI@?$AAt?$AAd?$AAo?$AA?9?$AA?$DO?$AAn?$AAe?$AAx?$AAt?$AAl?$AAi?$AAn?$AAk?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00191	33 c0		 xor	 eax, eax
$LN20@teedataobj@5:

; 561  :             Py_INCREF(next);

  00193	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  00198	e8 00 00 00 00	 call	 _Py_IncRef

; 562  :             tdo->nextlink = next;

  0019d	48 8b 44 24 58	 mov	 rax, QWORD PTR tdo$[rsp]
  001a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR next$[rsp]
  001a7	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
$LN8@teedataobj@5:

; 563  :         }
; 564  :     } else {

  001ab	eb 10		 jmp	 SHORT $LN6@teedataobj@5
$LN9@teedataobj@5:

; 565  :         if (next != Py_None)

  001ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  001b4	48 39 44 24 50	 cmp	 QWORD PTR next$[rsp], rax
  001b9	74 02		 je	 SHORT $LN5@teedataobj@5

; 566  :             goto err; /* shouldn't have a next if we are not full */

  001bb	eb 07		 jmp	 SHORT $err$20901
$LN5@teedataobj@5:
$LN6@teedataobj@5:

; 567  :     }
; 568  :     return (PyObject*)tdo;

  001bd	48 8b 44 24 58	 mov	 rax, QWORD PTR tdo$[rsp]
  001c2	eb 2d		 jmp	 SHORT $LN16@teedataobj@5
$err$20901:
$LN4@teedataobj@5:

; 569  : 
; 570  : err:
; 571  :     Py_XDECREF(tdo);

  001c4	48 83 7c 24 58
	00		 cmp	 QWORD PTR tdo$[rsp], 0
  001ca	74 0a		 je	 SHORT $LN1@teedataobj@5
  001cc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tdo$[rsp]
  001d1	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@teedataobj@5:
  001d6	33 c0		 xor	 eax, eax
  001d8	85 c0		 test	 eax, eax
  001da	75 e8		 jne	 SHORT $LN4@teedataobj@5

; 572  :     PyErr_SetString(PyExc_ValueError, "Invalid arguments");

  001dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@PALKPJEA@Invalid?5arguments?$AA@
  001e3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001ea	e8 00 00 00 00	 call	 PyErr_SetString

; 573  :     return NULL;

  001ef	33 c0		 xor	 eax, eax
$LN16@teedataobj@5:

; 574  : }

  001f1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001f5	c3		 ret	 0
teedataobject_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$teedataobject_newinternal DD imagerel teedataobject_newinternal
	DD	imagerel teedataobject_newinternal+145
	DD	imagerel $unwind$teedataobject_newinternal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$teedataobject_newinternal DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT teedataobject_newinternal
_TEXT	SEGMENT
tdo$ = 32
tv70 = 40
it$ = 64
teedataobject_newinternal PROC				; COMDAT

; 420  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 421  :     teedataobject *tdo;
; 422  : 
; 423  :     tdo = PyObject_GC_New(teedataobject, &teedataobject_type);

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 13		 je	 SHORT $LN4@teedataobj@6
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:teedataobject_type
  00019	e8 00 00 00 00	 call	 _PxObject_New
  0001e	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00023	eb 11		 jmp	 SHORT $LN5@teedataobj@6
$LN4@teedataobj@6:
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:teedataobject_type
  0002c	e8 00 00 00 00	 call	 _PyObject_GC_New
  00031	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN5@teedataobj@6:
  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  0003b	48 89 44 24 20	 mov	 QWORD PTR tdo$[rsp], rax

; 424  :     if (tdo == NULL)

  00040	48 83 7c 24 20
	00		 cmp	 QWORD PTR tdo$[rsp], 0
  00046	75 04		 jne	 SHORT $LN1@teedataobj@6

; 425  :         return NULL;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 40		 jmp	 SHORT $LN2@teedataobj@6
$LN1@teedataobj@6:

; 426  : 
; 427  :     tdo->numread = 0;

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR tdo$[rsp]
  00051	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 428  :     tdo->nextlink = NULL;

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR tdo$[rsp]
  0005d	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 429  :     Py_INCREF(it);

  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  0006a	e8 00 00 00 00	 call	 _Py_IncRef

; 430  :     tdo->it = it;

  0006f	48 8b 44 24 20	 mov	 rax, QWORD PTR tdo$[rsp]
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  00079	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 431  :     PyObject_GC_Track(tdo);

  0007d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tdo$[rsp]
  00082	e8 00 00 00 00	 call	 PyObject_GC_Track

; 432  :     return (PyObject *)tdo;

  00087	48 8b 44 24 20	 mov	 rax, QWORD PTR tdo$[rsp]
$LN2@teedataobj@6:

; 433  : }

  0008c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00090	c3		 ret	 0
teedataobject_newinternal ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$tee_next DD imagerel tee_next
	DD	imagerel tee_next+158
	DD	imagerel $unwind$tee_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tee_next DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT tee_next
_TEXT	SEGMENT
value$ = 32
link$ = 40
to$ = 64
tee_next PROC						; COMDAT

; 632  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 633  :     PyObject *value, *link;
; 634  : 
; 635  :     if (to->index >= LINKCELLS) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR to$[rsp]
  0000e	83 78 68 39	 cmp	 DWORD PTR [rax+104], 57	; 00000039H
  00012	7c 47		 jl	 SHORT $LN3@tee_next

; 636  :         link = teedataobject_jumplink(to->dataobj);

  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR to$[rsp]
  00019	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0001d	e8 00 00 00 00	 call	 teedataobject_jumplink
  00022	48 89 44 24 28	 mov	 QWORD PTR link$[rsp], rax

; 637  :         if (link == NULL)

  00027	48 83 7c 24 28
	00		 cmp	 QWORD PTR link$[rsp], 0
  0002d	75 04		 jne	 SHORT $LN2@tee_next

; 638  :             return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 66		 jmp	 SHORT $LN4@tee_next
$LN2@tee_next:

; 639  :         Py_DECREF(to->dataobj);

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR to$[rsp]
  00038	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0003c	e8 00 00 00 00	 call	 _Py_DecRef

; 640  :         to->dataobj = (teedataobject *)link;

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR to$[rsp]
  00046	48 8b 4c 24 28	 mov	 rcx, QWORD PTR link$[rsp]
  0004b	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 641  :         to->index = 0;

  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR to$[rsp]
  00054	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0
$LN3@tee_next:

; 642  :     }
; 643  :     value = teedataobject_getitem(to->dataobj, to->index);

  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR to$[rsp]
  00060	8b 50 68	 mov	 edx, DWORD PTR [rax+104]
  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR to$[rsp]
  00068	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0006c	e8 00 00 00 00	 call	 teedataobject_getitem
  00071	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 644  :     if (value == NULL)

  00076	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  0007c	75 04		 jne	 SHORT $LN1@tee_next

; 645  :         return NULL;

  0007e	33 c0		 xor	 eax, eax
  00080	eb 17		 jmp	 SHORT $LN4@tee_next
$LN1@tee_next:

; 646  :     to->index++;

  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR to$[rsp]
  00087	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0008a	ff c0		 inc	 eax
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR to$[rsp]
  00091	89 41 68	 mov	 DWORD PTR [rcx+104], eax

; 647  :     return value;

  00094	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
$LN4@tee_next:

; 648  : }

  00099	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009d	c3		 ret	 0
tee_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$teedataobject_jumplink DD imagerel teedataobject_jumplink
	DD	imagerel teedataobject_jumplink+90
	DD	imagerel $unwind$teedataobject_jumplink
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$teedataobject_jumplink DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT teedataobject_jumplink
_TEXT	SEGMENT
tdo$ = 48
teedataobject_jumplink PROC				; COMDAT

; 437  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 438  :     if (tdo->nextlink == NULL)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR tdo$[rsp]
  0000e	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00013	75 17		 jne	 SHORT $LN5@teedataobj@7

; 439  :         tdo->nextlink = teedataobject_newinternal(tdo->it);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR tdo$[rsp]
  0001a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0001e	e8 00 00 00 00	 call	 teedataobject_newinternal
  00023	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tdo$[rsp]
  00028	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax
$LN5@teedataobj@7:
$LN4@teedataobj@7:

; 440  :     Py_XINCREF(tdo->nextlink);

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR tdo$[rsp]
  00031	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00036	74 0e		 je	 SHORT $LN1@teedataobj@7
  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR tdo$[rsp]
  0003d	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00041	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@teedataobj@7:
  00046	33 c0		 xor	 eax, eax
  00048	85 c0		 test	 eax, eax
  0004a	75 e0		 jne	 SHORT $LN4@teedataobj@7

; 441  :     return tdo->nextlink;

  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR tdo$[rsp]
  00051	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]

; 442  : }

  00055	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00059	c3		 ret	 0
teedataobject_jumplink ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CE@PJBCFHGI@?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAd?$AAo?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AAr?$AAe?$AAa?$AAd?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@FBOKFFPH@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAL?$AAI?$AAN?$AAK?$AAC?$AAE?$AAL?$AAL?$AAS?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$teedataobject_getitem DD imagerel teedataobject_getitem
	DD	imagerel teedataobject_getitem+215
	DD	imagerel $unwind$teedataobject_getitem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$teedataobject_getitem DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT ??_C@_1CE@PJBCFHGI@?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAd?$AAo?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AAr?$AAe?$AAa?$AAd?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@PJBCFHGI@?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAd?$AAo?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AAr?$AAe?$AAa?$AAd?$AA?$AA@ DB 'i'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 't', 00H, 'd', 00H
	DB	'o', 00H, '-', 00H, '>', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 'r'
	DB	00H, 'e', 00H, 'a', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@FBOKFFPH@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAL?$AAI?$AAN?$AAK?$AAC?$AAE?$AAL?$AAL?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@FBOKFFPH@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAL?$AAI?$AAN?$AAK?$AAC?$AAE?$AAL?$AAL?$AAS?$AA?$AA@ DB 'i'
	DB	00H, ' ', 00H, '<', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'N', 00H
	DB	'K', 00H, 'C', 00H, 'E', 00H, 'L', 00H, 'L', 00H, 'S', 00H, 00H
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT teedataobject_getitem
_TEXT	SEGMENT
value$ = 32
tdo$ = 64
i$ = 72
teedataobject_getitem PROC				; COMDAT

; 446  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 447  :     PyObject *value;
; 448  : 
; 449  :     assert(i < LINKCELLS);

  0000d	83 7c 24 48 39	 cmp	 DWORD PTR i$[rsp], 57	; 00000039H
  00012	7c 1c		 jl	 SHORT $LN6@teedataobj@8
  00014	41 b8 c1 01 00
	00		 mov	 r8d, 449		; 000001c1H
  0001a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@FBOKFFPH@?$AAi?$AA?5?$AA?$DM?$AA?5?$AAL?$AAI?$AAN?$AAK?$AAC?$AAE?$AAL?$AAL?$AAS?$AA?$AA@
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0002e	33 c0		 xor	 eax, eax
$LN6@teedataobj@8:

; 450  :     if (i < tdo->numread)

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR tdo$[rsp]
  00035	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  00038	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  0003c	7d 16		 jge	 SHORT $LN3@teedataobj@8

; 451  :         value = tdo->values[i];

  0003e	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tdo$[rsp]
  00048	48 8b 44 c1 78	 mov	 rax, QWORD PTR [rcx+rax*8+120]
  0004d	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 452  :     else {

  00052	eb 6f		 jmp	 SHORT $LN2@teedataobj@8
$LN3@teedataobj@8:

; 453  :         /* this is the lead iterator, so fetch more data */
; 454  :         assert(i == tdo->numread);

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR tdo$[rsp]
  00059	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0005c	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  00060	74 1c		 je	 SHORT $LN7@teedataobj@8
  00062	41 b8 c6 01 00
	00		 mov	 r8d, 454		; 000001c6H
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CE@PJBCFHGI@?$AAi?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAt?$AAd?$AAo?$AA?9?$AA?$DO?$AAn?$AAu?$AAm?$AAr?$AAe?$AAa?$AAd?$AA?$AA@
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0007c	33 c0		 xor	 eax, eax
$LN7@teedataobj@8:

; 455  :         value = PyIter_Next(tdo->it);

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR tdo$[rsp]
  00083	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00087	e8 00 00 00 00	 call	 PyIter_Next
  0008c	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 456  :         if (value == NULL)

  00091	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  00097	75 04		 jne	 SHORT $LN1@teedataobj@8

; 457  :             return NULL;

  00099	33 c0		 xor	 eax, eax
  0009b	eb 35		 jmp	 SHORT $LN4@teedataobj@8
$LN1@teedataobj@8:

; 458  :         tdo->numread++;

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR tdo$[rsp]
  000a2	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  000a5	ff c0		 inc	 eax
  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tdo$[rsp]
  000ac	89 41 68	 mov	 DWORD PTR [rcx+104], eax

; 459  :         tdo->values[i] = value;

  000af	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  000b4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tdo$[rsp]
  000b9	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  000be	48 89 54 c1 78	 mov	 QWORD PTR [rcx+rax*8+120], rdx
$LN2@teedataobj@8:

; 460  :     }
; 461  :     Py_INCREF(value);

  000c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  000c8	e8 00 00 00 00	 call	 _Py_IncRef

; 462  :     return value;

  000cd	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
$LN4@teedataobj@8:

; 463  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
teedataobject_getitem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@DOPCCHLA@tee_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$tee_traverse DD imagerel tee_traverse
	DD	imagerel tee_traverse+116
	DD	imagerel $unwind$tee_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tee_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0N@DOPCCHLA@tee_traverse?$AA@
CONST	SEGMENT
??_C@_0N@DOPCCHLA@tee_traverse?$AA@ DB 'tee_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tee_traverse
_TEXT	SEGMENT
vret$20983 = 32
to$ = 64
visit$ = 72
arg$ = 80
tee_traverse PROC					; COMDAT

; 652  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@tee_traver:

; 653  :     Py_VISIT((PyObject *)to->dataobj);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@tee_traver
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 8d 02 00
	00		 mov	 r8d, 653		; 0000028dH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@DOPCCHLA@tee_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@tee_traver:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR to$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN2@tee_traver
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR to$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$20983[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$20983[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@tee_traver
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$20983[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@tee_traver
$LN1@tee_traver:
$LN2@tee_traver:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@tee_traver

; 654  :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@tee_traver:

; 655  : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
tee_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$tee_copy DD imagerel tee_copy
	DD	imagerel tee_copy+157
	DD	imagerel $unwind$tee_copy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tee_copy DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT tee_copy
_TEXT	SEGMENT
newto$ = 32
tv70 = 40
to$ = 64
tee_copy PROC						; COMDAT

; 659  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 660  :     teeobject *newto;
; 661  : 
; 662  :     newto = PyObject_GC_New(teeobject, &tee_type);

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 13		 je	 SHORT $LN4@tee_copy
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tee_type
  00019	e8 00 00 00 00	 call	 _PxObject_New
  0001e	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
  00023	eb 11		 jmp	 SHORT $LN5@tee_copy
$LN4@tee_copy:
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tee_type
  0002c	e8 00 00 00 00	 call	 _PyObject_GC_New
  00031	48 89 44 24 28	 mov	 QWORD PTR tv70[rsp], rax
$LN5@tee_copy:
  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  0003b	48 89 44 24 20	 mov	 QWORD PTR newto$[rsp], rax

; 663  :     if (newto == NULL)

  00040	48 83 7c 24 20
	00		 cmp	 QWORD PTR newto$[rsp], 0
  00046	75 04		 jne	 SHORT $LN1@tee_copy

; 664  :         return NULL;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 4c		 jmp	 SHORT $LN2@tee_copy
$LN1@tee_copy:

; 665  :     Py_INCREF(to->dataobj);

  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR to$[rsp]
  00051	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00055	e8 00 00 00 00	 call	 _Py_IncRef

; 666  :     newto->dataobj = to->dataobj;

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR newto$[rsp]
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR to$[rsp]
  00064	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00068	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 667  :     newto->index = to->index;

  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR newto$[rsp]
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR to$[rsp]
  00076	8b 49 68	 mov	 ecx, DWORD PTR [rcx+104]
  00079	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 668  :     newto->weakreflist = NULL;

  0007c	48 8b 44 24 20	 mov	 rax, QWORD PTR newto$[rsp]
  00081	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 669  :     PyObject_GC_Track(newto);

  00089	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newto$[rsp]
  0008e	e8 00 00 00 00	 call	 PyObject_GC_Track

; 670  :     return (PyObject *)newto;

  00093	48 8b 44 24 20	 mov	 rax, QWORD PTR newto$[rsp]
$LN2@tee_copy:

; 671  : }

  00098	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009c	c3		 ret	 0
tee_copy ENDP
_TEXT	ENDS
PUBLIC	??_C@_04DBFFPBBK@_tee?$AA@			; `string'
EXTRN	PyArg_UnpackTuple:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tee_new DD imagerel tee_new
	DD	imagerel tee_new+81
	DD	imagerel $unwind$tee_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tee_new DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_04DBFFPBBK@_tee?$AA@
CONST	SEGMENT
??_C@_04DBFFPBBK@_tee?$AA@ DB '_tee', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tee_new
_TEXT	SEGMENT
iterable$ = 48
type$ = 80
args$ = 88
kw$ = 96
tee_new	PROC						; COMDAT

; 709  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 710  :     PyObject *iterable;
; 711  : 
; 712  :     if (!PyArg_UnpackTuple(args, "_tee", 1, 1, &iterable))

  00013	48 8d 44 24 30	 lea	 rax, QWORD PTR iterable$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00023	41 b8 01 00 00
	00		 mov	 r8d, 1
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04DBFFPBBK@_tee?$AA@
  00030	48 8b 4c 24 58	 mov	 rcx, QWORD PTR args$[rsp]
  00035	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0003a	85 c0		 test	 eax, eax
  0003c	75 04		 jne	 SHORT $LN1@tee_new

; 713  :         return NULL;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 0a		 jmp	 SHORT $LN2@tee_new
$LN1@tee_new:

; 714  :     return tee_fromiterable(iterable);

  00042	48 8b 4c 24 30	 mov	 rcx, QWORD PTR iterable$[rsp]
  00047	e8 00 00 00 00	 call	 tee_fromiterable
$LN2@tee_new:

; 715  : }

  0004c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00050	c3		 ret	 0
tee_new	ENDP
_TEXT	ENDS
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tee_fromiterable DD imagerel tee_fromiterable
	DD	imagerel tee_fromiterable+297
	DD	imagerel $unwind$tee_fromiterable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tee_fromiterable DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT tee_fromiterable
_TEXT	SEGMENT
it$ = 32
to$ = 40
tv82 = 48
iterable$ = 80
tee_fromiterable PROC					; COMDAT

; 677  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 678  :     teeobject *to;
; 679  :     PyObject *it = NULL;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR it$[rsp], 0

; 680  : 
; 681  :     it = PyObject_GetIter(iterable);

  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR iterable$[rsp]
  00017	e8 00 00 00 00	 call	 PyObject_GetIter
  0001c	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 682  :     if (it == NULL)

  00021	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00027	75 07		 jne	 SHORT $LN9@tee_fromit

; 683  :         return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	e9 f4 00 00 00	 jmp	 $LN10@tee_fromit
$LN9@tee_fromit:

; 684  :     if (PyObject_TypeCheck(it, &tee_type)) {

  00030	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:tee_type
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0003c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00040	74 19		 je	 SHORT $LN7@tee_fromit
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:tee_type
  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
  0004e	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00052	e8 00 00 00 00	 call	 PyType_IsSubtype
  00057	85 c0		 test	 eax, eax
  00059	74 14		 je	 SHORT $LN8@tee_fromit
$LN7@tee_fromit:

; 685  :         to = (teeobject *)tee_copy((teeobject *)it);

  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00060	e8 00 00 00 00	 call	 tee_copy
  00065	48 89 44 24 28	 mov	 QWORD PTR to$[rsp], rax

; 686  :         goto done;

  0006a	e9 98 00 00 00	 jmp	 $done$21017
$LN8@tee_fromit:

; 687  :     }
; 688  : 
; 689  :     to = PyObject_GC_New(teeobject, &tee_type);

  0006f	e8 00 00 00 00	 call	 _Py_PXCTX
  00074	85 c0		 test	 eax, eax
  00076	74 13		 je	 SHORT $LN12@tee_fromit
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tee_type
  0007f	e8 00 00 00 00	 call	 _PxObject_New
  00084	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
  00089	eb 11		 jmp	 SHORT $LN13@tee_fromit
$LN12@tee_fromit:
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tee_type
  00092	e8 00 00 00 00	 call	 _PyObject_GC_New
  00097	48 89 44 24 30	 mov	 QWORD PTR tv82[rsp], rax
$LN13@tee_fromit:
  0009c	48 8b 44 24 30	 mov	 rax, QWORD PTR tv82[rsp]
  000a1	48 89 44 24 28	 mov	 QWORD PTR to$[rsp], rax

; 690  :     if (to == NULL)

  000a6	48 83 7c 24 28
	00		 cmp	 QWORD PTR to$[rsp], 0
  000ac	75 02		 jne	 SHORT $LN6@tee_fromit

; 691  :         goto done;

  000ae	eb 57		 jmp	 SHORT $done$21017
$LN6@tee_fromit:

; 692  :     to->dataobj = (teedataobject *)teedataobject_newinternal(it);

  000b0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000b5	e8 00 00 00 00	 call	 teedataobject_newinternal
  000ba	48 8b 4c 24 28	 mov	 rcx, QWORD PTR to$[rsp]
  000bf	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 693  :     if (!to->dataobj) {

  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR to$[rsp]
  000c8	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000cd	75 15		 jne	 SHORT $LN5@tee_fromit

; 694  :         PyObject_GC_Del(to);

  000cf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR to$[rsp]
  000d4	e8 00 00 00 00	 call	 PyObject_GC_Del

; 695  :         to = NULL;

  000d9	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR to$[rsp], 0

; 696  :         goto done;

  000e2	eb 23		 jmp	 SHORT $done$21017
$LN5@tee_fromit:

; 697  :     }
; 698  : 
; 699  :     to->index = 0;

  000e4	48 8b 44 24 28	 mov	 rax, QWORD PTR to$[rsp]
  000e9	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [rax+104], 0

; 700  :     to->weakreflist = NULL;

  000f0	48 8b 44 24 28	 mov	 rax, QWORD PTR to$[rsp]
  000f5	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 701  :     PyObject_GC_Track(to);

  000fd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR to$[rsp]
  00102	e8 00 00 00 00	 call	 PyObject_GC_Track
$done$21017:
$LN4@tee_fromit:

; 702  : done:
; 703  :     Py_XDECREF(it);

  00107	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  0010d	74 0a		 je	 SHORT $LN1@tee_fromit
  0010f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@tee_fromit:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	75 e8		 jne	 SHORT $LN4@tee_fromit

; 704  :     return (PyObject *)to;

  0011f	48 8b 44 24 28	 mov	 rax, QWORD PTR to$[rsp]
$LN10@tee_fromit:

; 705  : }

  00124	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00128	c3		 ret	 0
tee_fromiterable ENDP
_TEXT	ENDS
PUBLIC	??_C@_09DCPDBLOL@tee_clear?$AA@			; `string'
EXTRN	PyObject_ClearWeakRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$tee_clear DD imagerel tee_clear
	DD	imagerel tee_clear+139
	DD	imagerel $unwind$tee_clear
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tee_clear DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_09DCPDBLOL@tee_clear?$AA@
CONST	SEGMENT
??_C@_09DCPDBLOL@tee_clear?$AA@ DB 'tee_clear', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tee_clear
_TEXT	SEGMENT
_py_tmp$21056 = 48
to$ = 80
tee_clear PROC						; COMDAT

; 719  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 720  :     if (to->weakreflist != NULL)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR to$[rsp]
  0000e	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00013	74 0a		 je	 SHORT $LN5@tee_clear

; 721  :         PyObject_ClearWeakRefs((PyObject *) to);

  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR to$[rsp]
  0001a	e8 00 00 00 00	 call	 PyObject_ClearWeakRefs
$LN5@tee_clear:
$LN4@tee_clear:

; 722  :     Py_CLEAR(to->dataobj);

  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR to$[rsp]
  00024	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00029	74 53		 je	 SHORT $LN1@tee_clear
  0002b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR to$[rsp]
  00038	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  0003c	41 b8 d2 02 00
	00		 mov	 r8d, 722		; 000002d2H
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09DCPDBLOL@tee_clear?$AA@
  00050	e8 00 00 00 00	 call	 _PyParallel_Guard
  00055	85 c0		 test	 eax, eax
  00057	75 25		 jne	 SHORT $LN1@tee_clear
  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR to$[rsp]
  0005e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00062	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$21056[rsp], rax
  00067	48 8b 44 24 50	 mov	 rax, QWORD PTR to$[rsp]
  0006c	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  00074	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$21056[rsp]
  00079	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@tee_clear:
  0007e	33 c0		 xor	 eax, eax
  00080	85 c0		 test	 eax, eax
  00082	75 9b		 jne	 SHORT $LN4@tee_clear

; 723  :     return 0;

  00084	33 c0		 xor	 eax, eax

; 724  : }

  00086	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008a	c3		 ret	 0
tee_clear ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$tee_dealloc DD imagerel tee_dealloc
	DD	imagerel tee_dealloc+44
	DD	imagerel $unwind$tee_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tee_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT tee_dealloc
_TEXT	SEGMENT
to$ = 48
tee_dealloc PROC					; COMDAT

; 728  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 729  :     PyObject_GC_UnTrack(to);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR to$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack

; 730  :     tee_clear(to);

  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR to$[rsp]
  00018	e8 00 00 00 00	 call	 tee_clear

; 731  :     PyObject_GC_Del(to);

  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR to$[rsp]
  00022	e8 00 00 00 00	 call	 PyObject_GC_Del

; 732  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
tee_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_09CLHOPJKH@O?$CI?$CI?$CJ?$CJ?$CIOi?$CJ?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$tee_reduce DD imagerel tee_reduce
	DD	imagerel tee_reduce+53
	DD	imagerel $unwind$tee_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tee_reduce DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_09CLHOPJKH@O?$CI?$CI?$CJ?$CJ?$CIOi?$CJ?$AA@
CONST	SEGMENT
??_C@_09CLHOPJKH@O?$CI?$CI?$CJ?$CJ?$CIOi?$CJ?$AA@ DB 'O(())(Oi)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tee_reduce
_TEXT	SEGMENT
to$ = 48
tee_reduce PROC						; COMDAT

; 736  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 737  :     return Py_BuildValue("O(())(Oi)", Py_TYPE(to), to->dataobj, to->index);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR to$[rsp]
  0000e	44 8b 48 68	 mov	 r9d, DWORD PTR [rax+104]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR to$[rsp]
  00017	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR to$[rsp]
  00020	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09CLHOPJKH@O?$CI?$CI?$CJ?$CJ?$CIOi?$CJ?$AA@
  0002b	e8 00 00 00 00	 call	 Py_BuildValue

; 738  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
tee_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@FDKFAAFH@tee_setstate?$AA@		; `string'
PUBLIC	??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@	; `string'
PUBLIC	??_C@_03JAHMJELB@O?$CBi?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$tee_setstate DD imagerel tee_setstate
	DD	imagerel tee_setstate+269
	DD	imagerel $unwind$tee_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tee_setstate DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0N@FDKFAAFH@tee_setstate?$AA@
CONST	SEGMENT
??_C@_0N@FDKFAAFH@tee_setstate?$AA@ DB 'tee_setstate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@
CONST	SEGMENT
??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@ DB 'Index out of range', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JAHMJELB@O?$CBi?$AA@
CONST	SEGMENT
??_C@_03JAHMJELB@O?$CBi?$AA@ DB 'O!i', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tee_setstate
_TEXT	SEGMENT
index$ = 48
tdo$ = 56
_py_tmp$21090 = 64
to$ = 96
state$ = 104
tee_setstate PROC					; COMDAT

; 742  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 743  :     teedataobject *tdo;
; 744  :     int index;
; 745  :     if (!PyArg_ParseTuple(state, "O!i", &teedataobject_type, &tdo, &index))

  0000e	48 8d 44 24 30	 lea	 rax, QWORD PTR index$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00018	4c 8d 4c 24 38	 lea	 r9, QWORD PTR tdo$[rsp]
  0001d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:teedataobject_type
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JAHMJELB@O?$CBi?$AA@
  0002b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR state$[rsp]
  00030	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00035	85 c0		 test	 eax, eax
  00037	75 07		 jne	 SHORT $LN7@tee_setsta

; 746  :         return NULL;

  00039	33 c0		 xor	 eax, eax
  0003b	e9 c8 00 00 00	 jmp	 $LN8@tee_setsta
$LN7@tee_setsta:

; 747  :     if (index < 0 || index > LINKCELLS) {

  00040	83 7c 24 30 00	 cmp	 DWORD PTR index$[rsp], 0
  00045	7c 07		 jl	 SHORT $LN5@tee_setsta
  00047	83 7c 24 30 39	 cmp	 DWORD PTR index$[rsp], 57 ; 00000039H
  0004c	7e 1a		 jle	 SHORT $LN6@tee_setsta
$LN5@tee_setsta:

; 748  :         PyErr_SetString(PyExc_ValueError, "Index out of range");

  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@KNGCOGKE@Index?5out?5of?5range?$AA@
  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0005c	e8 00 00 00 00	 call	 PyErr_SetString

; 749  :         return NULL;

  00061	33 c0		 xor	 eax, eax
  00063	e9 a0 00 00 00	 jmp	 $LN8@tee_setsta
$LN6@tee_setsta:
$LN4@tee_setsta:

; 750  :     }
; 751  :     Py_CLEAR(to->dataobj);

  00068	48 8b 44 24 60	 mov	 rax, QWORD PTR to$[rsp]
  0006d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00072	74 53		 je	 SHORT $LN1@tee_setsta
  00074	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0007c	48 8b 44 24 60	 mov	 rax, QWORD PTR to$[rsp]
  00081	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  00085	41 b8 ef 02 00
	00		 mov	 r8d, 751		; 000002efH
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@FDKFAAFH@tee_setstate?$AA@
  00099	e8 00 00 00 00	 call	 _PyParallel_Guard
  0009e	85 c0		 test	 eax, eax
  000a0	75 25		 jne	 SHORT $LN1@tee_setsta
  000a2	48 8b 44 24 60	 mov	 rax, QWORD PTR to$[rsp]
  000a7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ab	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$21090[rsp], rax
  000b0	48 8b 44 24 60	 mov	 rax, QWORD PTR to$[rsp]
  000b5	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  000bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$21090[rsp]
  000c2	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@tee_setsta:
  000c7	33 c0		 xor	 eax, eax
  000c9	85 c0		 test	 eax, eax
  000cb	75 9b		 jne	 SHORT $LN4@tee_setsta

; 752  :     to->dataobj = tdo;

  000cd	48 8b 44 24 60	 mov	 rax, QWORD PTR to$[rsp]
  000d2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tdo$[rsp]
  000d7	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 753  :     Py_INCREF(to->dataobj);

  000db	48 8b 44 24 60	 mov	 rax, QWORD PTR to$[rsp]
  000e0	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000e4	e8 00 00 00 00	 call	 _Py_IncRef

; 754  :     to->index = index;

  000e9	48 8b 44 24 60	 mov	 rax, QWORD PTR to$[rsp]
  000ee	8b 4c 24 30	 mov	 ecx, DWORD PTR index$[rsp]
  000f2	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 755  :     Py_RETURN_NONE;

  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000fc	e8 00 00 00 00	 call	 _Py_IncRef
  00101	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN8@tee_setsta:

; 756  : }

  00108	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010c	c3		 ret	 0
tee_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@BCBHJBBL@n?5must?5be?5?$DO?$DN?50?$AA@	; `string'
PUBLIC	??_C@_03LLFJLPJF@O?$HMn?$AA@			; `string'
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	_PyObject_HasAttrId:PROC
EXTRN	PyTuple_New:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$tee DD	imagerel tee
	DD	imagerel tee+439
	DD	imagerel $unwind$tee
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$tee DD	010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0P@BCBHJBBL@n?5must?5be?5?$DO?$DN?50?$AA@
CONST	SEGMENT
??_C@_0P@BCBHJBBL@n?5must?5be?5?$DO?$DN?50?$AA@ DB 'n must be >= 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LLFJLPJF@O?$HMn?$AA@
CONST	SEGMENT
??_C@_03LLFJLPJF@O?$HMn?$AA@ DB 'O|n', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT tee
_TEXT	SEGMENT
it$ = 32
n$ = 40
i$ = 48
copyable$ = 56
result$ = 64
iterable$ = 72
self$ = 96
args$ = 104
tee	PROC						; COMDAT

; 813  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 814  :     Py_ssize_t i, n=2;

  0000e	48 c7 44 24 28
	02 00 00 00	 mov	 QWORD PTR n$[rsp], 2

; 815  :     PyObject *it, *iterable, *copyable, *result;
; 816  :     _Py_IDENTIFIER(__copy__);
; 817  : 
; 818  :     if (!PyArg_ParseTuple(args, "O|n", &iterable, &n))

  00017	4c 8d 4c 24 28	 lea	 r9, QWORD PTR n$[rsp]
  0001c	4c 8d 44 24 48	 lea	 r8, QWORD PTR iterable$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03LLFJLPJF@O?$HMn?$AA@
  00028	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0002d	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN12@tee

; 819  :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 75 01 00 00	 jmp	 $LN13@tee
$LN12@tee:

; 820  :     if (n < 0) {

  0003d	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$[rsp], 0
  00043	7d 1a		 jge	 SHORT $LN11@tee

; 821  :         PyErr_SetString(PyExc_ValueError, "n must be >= 0");

  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@BCBHJBBL@n?5must?5be?5?$DO?$DN?50?$AA@
  0004c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00053	e8 00 00 00 00	 call	 PyErr_SetString

; 822  :         return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 53 01 00 00	 jmp	 $LN13@tee
$LN11@tee:

; 823  :     }
; 824  :     result = PyTuple_New(n);

  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$[rsp]
  00064	e8 00 00 00 00	 call	 PyTuple_New
  00069	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 825  :     if (result == NULL)

  0006e	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$[rsp], 0
  00074	75 07		 jne	 SHORT $LN10@tee

; 826  :         return NULL;

  00076	33 c0		 xor	 eax, eax
  00078	e9 35 01 00 00	 jmp	 $LN13@tee
$LN10@tee:

; 827  :     if (n == 0)

  0007d	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$[rsp], 0
  00083	75 0a		 jne	 SHORT $LN9@tee

; 828  :         return result;

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  0008a	e9 23 01 00 00	 jmp	 $LN13@tee
$LN9@tee:

; 829  :     it = PyObject_GetIter(iterable);

  0008f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR iterable$[rsp]
  00094	e8 00 00 00 00	 call	 PyObject_GetIter
  00099	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 830  :     if (it == NULL) {

  0009e	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  000a4	75 11		 jne	 SHORT $LN8@tee

; 831  :         Py_DECREF(result);

  000a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  000ab	e8 00 00 00 00	 call	 _Py_DecRef

; 832  :         return NULL;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 fb 00 00 00	 jmp	 $LN13@tee
$LN8@tee:

; 833  :     }
; 834  :     if (!_PyObject_HasAttrId(it, &PyId___copy__)) {

  000b7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___copy__@?1??tee@@9@9
  000bc	8b c0		 mov	 eax, eax
  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000c4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000cd	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  000d1	48 8b d0	 mov	 rdx, rax
  000d4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000d9	e8 00 00 00 00	 call	 _PyObject_HasAttrId
  000de	85 c0		 test	 eax, eax
  000e0	75 34		 jne	 SHORT $LN7@tee

; 835  :         copyable = tee_fromiterable(it);

  000e2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000e7	e8 00 00 00 00	 call	 tee_fromiterable
  000ec	48 89 44 24 38	 mov	 QWORD PTR copyable$[rsp], rax

; 836  :         Py_DECREF(it);

  000f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000f6	e8 00 00 00 00	 call	 _Py_DecRef

; 837  :         if (copyable == NULL) {

  000fb	48 83 7c 24 38
	00		 cmp	 QWORD PTR copyable$[rsp], 0
  00101	75 11		 jne	 SHORT $LN6@tee

; 838  :             Py_DECREF(result);

  00103	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  00108	e8 00 00 00 00	 call	 _Py_DecRef

; 839  :             return NULL;

  0010d	33 c0		 xor	 eax, eax
  0010f	e9 9e 00 00 00	 jmp	 $LN13@tee
$LN6@tee:

; 840  :         }
; 841  :     } else

  00114	eb 0a		 jmp	 SHORT $LN5@tee
$LN7@tee:

; 842  :         copyable = it;

  00116	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
  0011b	48 89 44 24 38	 mov	 QWORD PTR copyable$[rsp], rax
$LN5@tee:

; 843  :     PyTuple_SET_ITEM(result, 0, copyable);

  00120	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  00125	48 8b 4c 24 38	 mov	 rcx, QWORD PTR copyable$[rsp]
  0012a	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 844  :     for (i=1 ; i<n ; i++) {

  0012e	48 c7 44 24 30
	01 00 00 00	 mov	 QWORD PTR i$[rsp], 1
  00137	eb 0d		 jmp	 SHORT $LN4@tee
$LN3@tee:
  00139	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0013e	48 ff c0	 inc	 rax
  00141	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN4@tee:
  00146	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0014b	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00150	7d 5b		 jge	 SHORT $LN2@tee

; 845  : 
; 846  :         copyable = _PyObject_CallMethodId(copyable, &PyId___copy__, NULL);

  00152	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___copy__@?1??tee@@9@9
  00157	8b c0		 mov	 eax, eax
  00159	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0015f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00168	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0016c	45 33 c0	 xor	 r8d, r8d
  0016f	48 8b d0	 mov	 rdx, rax
  00172	48 8b 4c 24 38	 mov	 rcx, QWORD PTR copyable$[rsp]
  00177	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  0017c	48 89 44 24 38	 mov	 QWORD PTR copyable$[rsp], rax

; 847  :         if (copyable == NULL) {

  00181	48 83 7c 24 38
	00		 cmp	 QWORD PTR copyable$[rsp], 0
  00187	75 0e		 jne	 SHORT $LN1@tee

; 848  :             Py_DECREF(result);

  00189	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  0018e	e8 00 00 00 00	 call	 _Py_DecRef

; 849  :             return NULL;

  00193	33 c0		 xor	 eax, eax
  00195	eb 1b		 jmp	 SHORT $LN13@tee
$LN1@tee:

; 850  :         }
; 851  :         PyTuple_SET_ITEM(result, i, copyable);

  00197	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  0019c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  001a1	48 8b 54 24 38	 mov	 rdx, QWORD PTR copyable$[rsp]
  001a6	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 852  :     }

  001ab	eb 8c		 jmp	 SHORT $LN3@tee
$LN2@tee:

; 853  :     return result;

  001ad	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN13@tee:

; 854  : }

  001b2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b6	c3		 ret	 0
tee	ENDP
_TEXT	ENDS
PUBLIC	??_C@_05EEELFEFN@cycle?$AA@			; `string'
PUBLIC	??_C@_07BBALHKAM@cycle?$CI?$CJ?$AA@		; `string'
EXTRN	_PyArg_NoKeywords:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$cycle_new DD imagerel cycle_new
	DD	imagerel cycle_new+280
	DD	imagerel $unwind$cycle_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cycle_new DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_05EEELFEFN@cycle?$AA@
CONST	SEGMENT
??_C@_05EEELFEFN@cycle?$AA@ DB 'cycle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BBALHKAM@cycle?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_07BBALHKAM@cycle?$CI?$CJ?$AA@ DB 'cycle()', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cycle_new
_TEXT	SEGMENT
it$ = 48
saved$ = 56
lz$ = 64
iterable$ = 72
type$ = 96
args$ = 104
kwds$ = 112
cycle_new PROC						; COMDAT

; 873  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 874  :     PyObject *it;
; 875  :     PyObject *iterable;
; 876  :     PyObject *saved;
; 877  :     cycleobject *lz;
; 878  : 
; 879  :     if (type == &cycle_type && !_PyArg_NoKeywords("cycle()", kwds))

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cycle_type
  0001a	48 39 44 24 60	 cmp	 QWORD PTR type$[rsp], rax
  0001f	75 1c		 jne	 SHORT $LN5@cycle_new
  00021	48 8b 54 24 70	 mov	 rdx, QWORD PTR kwds$[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07BBALHKAM@cycle?$CI?$CJ?$AA@
  0002d	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN5@cycle_new

; 880  :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 d6 00 00 00	 jmp	 $LN6@cycle_new
$LN5@cycle_new:

; 881  : 
; 882  :     if (!PyArg_UnpackTuple(args, "cycle", 1, 1, &iterable))

  0003d	48 8d 44 24 48	 lea	 rax, QWORD PTR iterable$[rsp]
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	41 b9 01 00 00
	00		 mov	 r9d, 1
  0004d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05EEELFEFN@cycle?$AA@
  0005a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0005f	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  00064	85 c0		 test	 eax, eax
  00066	75 07		 jne	 SHORT $LN4@cycle_new

; 883  :         return NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 a4 00 00 00	 jmp	 $LN6@cycle_new
$LN4@cycle_new:

; 884  : 
; 885  :     /* Get iterator. */
; 886  :     it = PyObject_GetIter(iterable);

  0006f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR iterable$[rsp]
  00074	e8 00 00 00 00	 call	 PyObject_GetIter
  00079	48 89 44 24 30	 mov	 QWORD PTR it$[rsp], rax

; 887  :     if (it == NULL)

  0007e	48 83 7c 24 30
	00		 cmp	 QWORD PTR it$[rsp], 0
  00084	75 07		 jne	 SHORT $LN3@cycle_new

; 888  :         return NULL;

  00086	33 c0		 xor	 eax, eax
  00088	e9 86 00 00 00	 jmp	 $LN6@cycle_new
$LN3@cycle_new:

; 889  : 
; 890  :     saved = PyList_New(0);

  0008d	33 c9		 xor	 ecx, ecx
  0008f	e8 00 00 00 00	 call	 PyList_New
  00094	48 89 44 24 38	 mov	 QWORD PTR saved$[rsp], rax

; 891  :     if (saved == NULL) {

  00099	48 83 7c 24 38
	00		 cmp	 QWORD PTR saved$[rsp], 0
  0009f	75 0e		 jne	 SHORT $LN2@cycle_new

; 892  :         Py_DECREF(it);

  000a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000a6	e8 00 00 00 00	 call	 _Py_DecRef

; 893  :         return NULL;

  000ab	33 c0		 xor	 eax, eax
  000ad	eb 64		 jmp	 SHORT $LN6@cycle_new
$LN2@cycle_new:

; 894  :     }
; 895  : 
; 896  :     /* create cycleobject structure */
; 897  :     lz = (cycleobject *)type->tp_alloc(type, 0);

  000af	33 d2		 xor	 edx, edx
  000b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR type$[rsp]
  000b6	48 8b 44 24 60	 mov	 rax, QWORD PTR type$[rsp]
  000bb	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  000c1	48 89 44 24 40	 mov	 QWORD PTR lz$[rsp], rax

; 898  :     if (lz == NULL) {

  000c6	48 83 7c 24 40
	00		 cmp	 QWORD PTR lz$[rsp], 0
  000cc	75 18		 jne	 SHORT $LN1@cycle_new

; 899  :         Py_DECREF(it);

  000ce	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000d3	e8 00 00 00 00	 call	 _Py_DecRef

; 900  :         Py_DECREF(saved);

  000d8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR saved$[rsp]
  000dd	e8 00 00 00 00	 call	 _Py_DecRef

; 901  :         return NULL;

  000e2	33 c0		 xor	 eax, eax
  000e4	eb 2d		 jmp	 SHORT $LN6@cycle_new
$LN1@cycle_new:

; 902  :     }
; 903  :     lz->it = it;

  000e6	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000eb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000f0	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 904  :     lz->saved = saved;

  000f4	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000f9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR saved$[rsp]
  000fe	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 905  :     lz->firstpass = 0;

  00102	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00107	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 906  : 
; 907  :     return (PyObject *)lz;

  0010e	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
$LN6@cycle_new:

; 908  : }

  00113	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00117	c3		 ret	 0
cycle_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cycle_dealloc DD imagerel cycle_dealloc
	DD	imagerel cycle_dealloc+108
	DD	imagerel $unwind$cycle_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cycle_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT cycle_dealloc
_TEXT	SEGMENT
lz$ = 48
cycle_dealloc PROC					; COMDAT

; 912  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 913  :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN8@cycle_deal:

; 914  :     Py_XDECREF(lz->saved);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0001d	74 0e		 je	 SHORT $LN5@cycle_deal
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@cycle_deal:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN8@cycle_deal
$LN4@cycle_deal:

; 915  :     Py_XDECREF(lz->it);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0003d	74 0e		 je	 SHORT $LN1@cycle_deal
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@cycle_deal:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN4@cycle_deal

; 916  :     Py_TYPE(lz)->tp_free(lz);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  00061	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 917  : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
cycle_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@KFPCJLFJ@cycle_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cycle_traverse DD imagerel cycle_traverse
	DD	imagerel cycle_traverse+206
	DD	imagerel $unwind$cycle_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cycle_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0P@KFPCJLFJ@cycle_traverse?$AA@
CONST	SEGMENT
??_C@_0P@KFPCJLFJ@cycle_traverse?$AA@ DB 'cycle_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cycle_traverse
_TEXT	SEGMENT
vret$21240 = 32
vret$21248 = 36
lz$ = 64
visit$ = 72
arg$ = 80
cycle_traverse PROC					; COMDAT

; 921  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@cycle_trav:

; 922  :     Py_VISIT(lz->it);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@cycle_trav
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 9a 03 00
	00		 mov	 r8d, 922		; 0000039aH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@KFPCJLFJ@cycle_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@cycle_trav:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN8@cycle_trav
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$21240[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$21240[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@cycle_trav
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$21240[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@cycle_trav
$LN7@cycle_trav:
$LN8@cycle_trav:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@cycle_trav
$LN6@cycle_trav:

; 923  :     Py_VISIT(lz->saved);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@cycle_trav
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 9b 03 00
	00		 mov	 r8d, 923		; 0000039bH
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@KFPCJLFJ@cycle_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@cycle_trav:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00097	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0009c	74 23		 je	 SHORT $LN2@cycle_trav
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000a8	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$21248[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$21248[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@cycle_trav
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$21248[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@cycle_trav
$LN1@cycle_trav:
$LN2@cycle_trav:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@cycle_trav

; 924  :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@cycle_trav:

; 925  : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
cycle_traverse ENDP
_TEXT	ENDS
EXTRN	PyList_Size:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_StopIteration:QWORD
EXTRN	PyErr_Occurred:PROC
EXTRN	PyList_Append:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$cycle_next DD imagerel cycle_next
	DD	imagerel cycle_next+259
	DD	imagerel $unwind$cycle_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cycle_next DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT cycle_next
_TEXT	SEGMENT
it$ = 32
tmp$ = 40
item$ = 48
lz$ = 80
cycle_next PROC						; COMDAT

; 929  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN9@cycle_next:

; 930  :     PyObject *item;
; 931  :     PyObject *it;
; 932  :     PyObject *tmp;
; 933  : 
; 934  :     while (1) {

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 ea 00 00
	00		 je	 $LN8@cycle_next

; 935  :         item = PyIter_Next(lz->it);

  00014	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00019	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0001d	e8 00 00 00 00	 call	 PyIter_Next
  00022	48 89 44 24 30	 mov	 QWORD PTR item$[rsp], rax

; 936  :         if (item != NULL) {

  00027	48 83 7c 24 30
	00		 cmp	 QWORD PTR item$[rsp], 0
  0002d	74 3d		 je	 SHORT $LN7@cycle_next

; 937  :             if (!lz->firstpass && PyList_Append(lz->saved, item)) {

  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00034	83 78 70 00	 cmp	 DWORD PTR [rax+112], 0
  00038	75 28		 jne	 SHORT $LN6@cycle_next
  0003a	48 8b 54 24 30	 mov	 rdx, QWORD PTR item$[rsp]
  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00048	e8 00 00 00 00	 call	 PyList_Append
  0004d	85 c0		 test	 eax, eax
  0004f	74 11		 je	 SHORT $LN6@cycle_next

; 938  :                 Py_DECREF(item);

  00051	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$[rsp]
  00056	e8 00 00 00 00	 call	 _Py_DecRef

; 939  :                 return NULL;

  0005b	33 c0		 xor	 eax, eax
  0005d	e9 9c 00 00 00	 jmp	 $LN10@cycle_next
$LN6@cycle_next:

; 940  :             }
; 941  :             return item;

  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR item$[rsp]
  00067	e9 92 00 00 00	 jmp	 $LN10@cycle_next
$LN7@cycle_next:

; 942  :         }
; 943  :         if (PyErr_Occurred()) {

  0006c	e8 00 00 00 00	 call	 PyErr_Occurred
  00071	48 85 c0	 test	 rax, rax
  00074	74 1b		 je	 SHORT $LN5@cycle_next

; 944  :             if (PyErr_ExceptionMatches(PyExc_StopIteration))

  00076	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  0007d	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00082	85 c0		 test	 eax, eax
  00084	74 07		 je	 SHORT $LN4@cycle_next

; 945  :                 PyErr_Clear();

  00086	e8 00 00 00 00	 call	 PyErr_Clear

; 946  :             else

  0008b	eb 04		 jmp	 SHORT $LN3@cycle_next
$LN4@cycle_next:

; 947  :                 return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	eb 6d		 jmp	 SHORT $LN10@cycle_next
$LN3@cycle_next:
$LN5@cycle_next:

; 948  :         }
; 949  :         if (PyList_Size(lz->saved) == 0)

  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00096	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  0009a	e8 00 00 00 00	 call	 PyList_Size
  0009f	48 85 c0	 test	 rax, rax
  000a2	75 04		 jne	 SHORT $LN2@cycle_next

; 950  :             return NULL;

  000a4	33 c0		 xor	 eax, eax
  000a6	eb 56		 jmp	 SHORT $LN10@cycle_next
$LN2@cycle_next:

; 951  :         it = PyObject_GetIter(lz->saved);

  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  000ad	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000b1	e8 00 00 00 00	 call	 PyObject_GetIter
  000b6	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 952  :         if (it == NULL)

  000bb	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  000c1	75 04		 jne	 SHORT $LN1@cycle_next

; 953  :             return NULL;

  000c3	33 c0		 xor	 eax, eax
  000c5	eb 37		 jmp	 SHORT $LN10@cycle_next
$LN1@cycle_next:

; 954  :         tmp = lz->it;

  000c7	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  000cc	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d0	48 89 44 24 28	 mov	 QWORD PTR tmp$[rsp], rax

; 955  :         lz->it = it;

  000d5	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  000da	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000df	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 956  :         lz->firstpass = 1;

  000e3	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  000e8	c7 40 70 01 00
	00 00		 mov	 DWORD PTR [rax+112], 1

; 957  :         Py_DECREF(tmp);

  000ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmp$[rsp]
  000f4	e8 00 00 00 00	 call	 _Py_DecRef

; 958  :     }

  000f9	e9 0b ff ff ff	 jmp	 $LN9@cycle_next
$LN8@cycle_next:
$LN10@cycle_next:

; 959  : }

  000fe	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00102	c3		 ret	 0
cycle_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_08JBCIEMOA@O?$CIO?$CJ?$CIOi?$CJ?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cycle_reduce DD imagerel cycle_reduce
	DD	imagerel cycle_reduce+65
	DD	imagerel $unwind$cycle_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cycle_reduce DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_08JBCIEMOA@O?$CIO?$CJ?$CIOi?$CJ?$AA@
CONST	SEGMENT
??_C@_08JBCIEMOA@O?$CIO?$CJ?$CIOi?$CJ?$AA@ DB 'O(O)(Oi)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cycle_reduce
_TEXT	SEGMENT
lz$ = 64
cycle_reduce PROC					; COMDAT

; 963  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 964  :     /* Create a new cycle with the iterator tuple, then set
; 965  :      * the saved state on it.
; 966  :      */
; 967  :     return Py_BuildValue("O(O)(Oi)", Py_TYPE(lz),
; 968  :         lz->it, lz->saved, lz->firstpass);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00011	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0001a	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00023	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0002c	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08JBCIEMOA@O?$CIO?$CJ?$CIOi?$CJ?$AA@
  00037	e8 00 00 00 00	 call	 Py_BuildValue

; 969  :     }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
cycle_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@MIKFLMLO@cycle_setstate?$AA@		; `string'
PUBLIC	??_C@_02MPEHDMPO@Oi?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cycle_setstate DD imagerel cycle_setstate
	DD	imagerel cycle_setstate+269
	DD	imagerel $unwind$cycle_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cycle_setstate DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0P@MIKFLMLO@cycle_setstate?$AA@
CONST	SEGMENT
??_C@_0P@MIKFLMLO@cycle_setstate?$AA@ DB 'cycle_setstate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02MPEHDMPO@Oi?$AA@
CONST	SEGMENT
??_C@_02MPEHDMPO@Oi?$AA@ DB 'Oi', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cycle_setstate
_TEXT	SEGMENT
saved$ = 48
firstpass$ = 56
_py_tmp$21299 = 64
tv92 = 72
lz$ = 96
state$ = 104
cycle_setstate PROC					; COMDAT

; 973  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 974  :     PyObject *saved=NULL;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR saved$[rsp], 0

; 975  :     int firstpass;
; 976  :     if (!PyArg_ParseTuple(state, "Oi", &saved, &firstpass))

  00017	4c 8d 4c 24 38	 lea	 r9, QWORD PTR firstpass$[rsp]
  0001c	4c 8d 44 24 30	 lea	 r8, QWORD PTR saved$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MPEHDMPO@Oi?$AA@
  00028	48 8b 4c 24 68	 mov	 rcx, QWORD PTR state$[rsp]
  0002d	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN9@cycle_sets

; 977  :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 cb 00 00 00	 jmp	 $LN10@cycle_sets
$LN9@cycle_sets:
$LN8@cycle_sets:

; 978  :     Py_CLEAR(lz->saved);

  0003d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00042	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00047	74 53		 je	 SHORT $LN5@cycle_sets
  00049	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00051	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00056	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0005a	41 b8 d2 03 00
	00		 mov	 r8d, 978		; 000003d2H
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@MIKFLMLO@cycle_setstate?$AA@
  0006e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00073	85 c0		 test	 eax, eax
  00075	75 25		 jne	 SHORT $LN5@cycle_sets
  00077	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0007c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00080	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$21299[rsp], rax
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0008a	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$21299[rsp]
  00097	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@cycle_sets:
  0009c	33 c0		 xor	 eax, eax
  0009e	85 c0		 test	 eax, eax
  000a0	75 9b		 jne	 SHORT $LN8@cycle_sets

; 979  :     lz->saved = saved;

  000a2	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR saved$[rsp]
  000ac	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN4@cycle_sets:

; 980  :     Py_XINCREF(lz->saved);

  000b0	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000b5	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000ba	74 0e		 je	 SHORT $LN1@cycle_sets
  000bc	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000c1	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000c5	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@cycle_sets:
  000ca	33 c0		 xor	 eax, eax
  000cc	85 c0		 test	 eax, eax
  000ce	75 e0		 jne	 SHORT $LN4@cycle_sets

; 981  :     lz->firstpass = firstpass != 0;

  000d0	83 7c 24 38 00	 cmp	 DWORD PTR firstpass$[rsp], 0
  000d5	74 0a		 je	 SHORT $LN12@cycle_sets
  000d7	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000df	eb 08		 jmp	 SHORT $LN13@cycle_sets
$LN12@cycle_sets:
  000e1	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN13@cycle_sets:
  000e9	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000ee	8b 4c 24 48	 mov	 ecx, DWORD PTR tv92[rsp]
  000f2	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 982  :     Py_RETURN_NONE;

  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000fc	e8 00 00 00 00	 call	 _Py_IncRef
  00101	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN10@cycle_sets:

; 983  : }

  00108	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010c	c3		 ret	 0
cycle_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_09FPIDKODG@dropwhile?$AA@			; `string'
PUBLIC	??_C@_0M@MKGKMIKK@dropwhile?$CI?$CJ?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$dropwhile_new DD imagerel dropwhile_new
	DD	imagerel dropwhile_new+250
	DD	imagerel $unwind$dropwhile_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dropwhile_new DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_09FPIDKODG@dropwhile?$AA@
CONST	SEGMENT
??_C@_09FPIDKODG@dropwhile?$AA@ DB 'dropwhile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MKGKMIKK@dropwhile?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@MKGKMIKK@dropwhile?$CI?$CJ?$AA@ DB 'dropwhile()', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT dropwhile_new
_TEXT	SEGMENT
it$ = 48
lz$ = 56
seq$ = 64
func$ = 72
type$ = 96
args$ = 104
kwds$ = 112
dropwhile_new PROC					; COMDAT

; 1057 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1058 :     PyObject *func, *seq;
; 1059 :     PyObject *it;
; 1060 :     dropwhileobject *lz;
; 1061 : 
; 1062 :     if (type == &dropwhile_type && !_PyArg_NoKeywords("dropwhile()", kwds))

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dropwhile_type
  0001a	48 39 44 24 60	 cmp	 QWORD PTR type$[rsp], rax
  0001f	75 1c		 jne	 SHORT $LN4@dropwhile_
  00021	48 8b 54 24 70	 mov	 rdx, QWORD PTR kwds$[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@MKGKMIKK@dropwhile?$CI?$CJ?$AA@
  0002d	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN4@dropwhile_

; 1063 :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 b8 00 00 00	 jmp	 $LN5@dropwhile_
$LN4@dropwhile_:

; 1064 : 
; 1065 :     if (!PyArg_UnpackTuple(args, "dropwhile", 2, 2, &func, &seq))

  0003d	48 8d 44 24 40	 lea	 rax, QWORD PTR seq$[rsp]
  00042	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00047	48 8d 44 24 48	 lea	 rax, QWORD PTR func$[rsp]
  0004c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00051	41 b9 02 00 00
	00		 mov	 r9d, 2
  00057	41 b8 02 00 00
	00		 mov	 r8d, 2
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09FPIDKODG@dropwhile?$AA@
  00064	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00069	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0006e	85 c0		 test	 eax, eax
  00070	75 04		 jne	 SHORT $LN3@dropwhile_

; 1066 :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	eb 7f		 jmp	 SHORT $LN5@dropwhile_
$LN3@dropwhile_:

; 1067 : 
; 1068 :     /* Get iterator. */
; 1069 :     it = PyObject_GetIter(seq);

  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$[rsp]
  0007b	e8 00 00 00 00	 call	 PyObject_GetIter
  00080	48 89 44 24 30	 mov	 QWORD PTR it$[rsp], rax

; 1070 :     if (it == NULL)

  00085	48 83 7c 24 30
	00		 cmp	 QWORD PTR it$[rsp], 0
  0008b	75 04		 jne	 SHORT $LN2@dropwhile_

; 1071 :         return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	eb 64		 jmp	 SHORT $LN5@dropwhile_
$LN2@dropwhile_:

; 1072 : 
; 1073 :     /* create dropwhileobject structure */
; 1074 :     lz = (dropwhileobject *)type->tp_alloc(type, 0);

  00091	33 d2		 xor	 edx, edx
  00093	48 8b 4c 24 60	 mov	 rcx, QWORD PTR type$[rsp]
  00098	48 8b 44 24 60	 mov	 rax, QWORD PTR type$[rsp]
  0009d	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  000a3	48 89 44 24 38	 mov	 QWORD PTR lz$[rsp], rax

; 1075 :     if (lz == NULL) {

  000a8	48 83 7c 24 38
	00		 cmp	 QWORD PTR lz$[rsp], 0
  000ae	75 0e		 jne	 SHORT $LN1@dropwhile_

; 1076 :         Py_DECREF(it);

  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000b5	e8 00 00 00 00	 call	 _Py_DecRef

; 1077 :         return NULL;

  000ba	33 c0		 xor	 eax, eax
  000bc	eb 37		 jmp	 SHORT $LN5@dropwhile_
$LN1@dropwhile_:

; 1078 :     }
; 1079 :     Py_INCREF(func);

  000be	48 8b 4c 24 48	 mov	 rcx, QWORD PTR func$[rsp]
  000c3	e8 00 00 00 00	 call	 _Py_IncRef

; 1080 :     lz->func = func;

  000c8	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000cd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR func$[rsp]
  000d2	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1081 :     lz->it = it;

  000d6	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000e0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1082 :     lz->start = 0;

  000e4	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000e9	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 1083 : 
; 1084 :     return (PyObject *)lz;

  000f0	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
$LN5@dropwhile_:

; 1085 : }

  000f5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f9	c3		 ret	 0
dropwhile_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dropwhile_dealloc DD imagerel dropwhile_dealloc
	DD	imagerel dropwhile_dealloc+108
	DD	imagerel $unwind$dropwhile_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dropwhile_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT dropwhile_dealloc
_TEXT	SEGMENT
lz$ = 48
dropwhile_dealloc PROC					; COMDAT

; 1089 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1090 :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN8@dropwhile_@2:

; 1091 :     Py_XDECREF(lz->func);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN5@dropwhile_@2
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@dropwhile_@2:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN8@dropwhile_@2
$LN4@dropwhile_@2:

; 1092 :     Py_XDECREF(lz->it);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0003d	74 0e		 je	 SHORT $LN1@dropwhile_@2
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@dropwhile_@2:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN4@dropwhile_@2

; 1093 :     Py_TYPE(lz)->tp_free(lz);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  00061	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 1094 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
dropwhile_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@IDIMKPBG@dropwhile_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$dropwhile_traverse DD imagerel dropwhile_traverse
	DD	imagerel dropwhile_traverse+206
	DD	imagerel $unwind$dropwhile_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dropwhile_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BD@IDIMKPBG@dropwhile_traverse?$AA@
CONST	SEGMENT
??_C@_0BD@IDIMKPBG@dropwhile_traverse?$AA@ DB 'dropwhile_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT dropwhile_traverse
_TEXT	SEGMENT
vret$21397 = 32
vret$21405 = 36
lz$ = 64
visit$ = 72
arg$ = 80
dropwhile_traverse PROC					; COMDAT

; 1098 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@dropwhile_@3:

; 1099 :     Py_VISIT(lz->it);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@dropwhile_@3
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 4b 04 00
	00		 mov	 r8d, 1099		; 0000044bH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@IDIMKPBG@dropwhile_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@dropwhile_@3:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00042	74 23		 je	 SHORT $LN8@dropwhile_@3
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$21397[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$21397[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@dropwhile_@3
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$21397[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@dropwhile_@3
$LN7@dropwhile_@3:
$LN8@dropwhile_@3:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@dropwhile_@3
$LN6@dropwhile_@3:

; 1100 :     Py_VISIT(lz->func);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@dropwhile_@3
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 4c 04 00
	00		 mov	 r8d, 1100		; 0000044cH
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@IDIMKPBG@dropwhile_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@dropwhile_@3:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00097	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0009c	74 23		 je	 SHORT $LN2@dropwhile_@3
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000a8	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$21405[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$21405[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@dropwhile_@3
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$21405[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@dropwhile_@3
$LN1@dropwhile_@3:
$LN2@dropwhile_@3:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@dropwhile_@3

; 1101 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@dropwhile_@3:

; 1102 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
dropwhile_traverse ENDP
_TEXT	ENDS
EXTRN	PyObject_IsTrue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$dropwhile_next DD imagerel dropwhile_next
	DD	imagerel dropwhile_next+221
	DD	imagerel $unwind$dropwhile_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dropwhile_next DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT dropwhile_next
_TEXT	SEGMENT
it$ = 32
iternext$ = 40
ok$ = 48
good$ = 56
item$ = 64
lz$ = 96
dropwhile_next PROC					; COMDAT

; 1106 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1107 :     PyObject *item, *good;
; 1108 :     PyObject *it = lz->it;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00012	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 1109 :     long ok;
; 1110 :     PyObject *(*iternext)(PyObject *);
; 1111 : 
; 1112 :     iternext = *Py_TYPE(it)->tp_iternext;

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
  0001c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00020	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00027	48 89 44 24 28	 mov	 QWORD PTR iternext$[rsp], rax
$LN7@dropwhile_@4:

; 1113 :     for (;;) {
; 1114 :         item = iternext(it);

  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00031	ff 54 24 28	 call	 QWORD PTR iternext$[rsp]
  00035	48 89 44 24 40	 mov	 QWORD PTR item$[rsp], rax

; 1115 :         if (item == NULL)

  0003a	48 83 7c 24 40
	00		 cmp	 QWORD PTR item$[rsp], 0
  00040	75 07		 jne	 SHORT $LN5@dropwhile_@4

; 1116 :             return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	e9 8f 00 00 00	 jmp	 $LN8@dropwhile_@4
$LN5@dropwhile_@4:

; 1117 :         if (lz->start == 1)

  00049	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	83 78 70 01	 cmp	 DWORD PTR [rax+112], 1
  00052	75 07		 jne	 SHORT $LN4@dropwhile_@4

; 1118 :             return item;

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR item$[rsp]
  00059	eb 7d		 jmp	 SHORT $LN8@dropwhile_@4
$LN4@dropwhile_@4:

; 1119 : 
; 1120 :         good = PyObject_CallFunctionObjArgs(lz->func, item, NULL);

  0005b	45 33 c0	 xor	 r8d, r8d
  0005e	48 8b 54 24 40	 mov	 rdx, QWORD PTR item$[rsp]
  00063	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00068	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0006c	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  00071	48 89 44 24 38	 mov	 QWORD PTR good$[rsp], rax

; 1121 :         if (good == NULL) {

  00076	48 83 7c 24 38
	00		 cmp	 QWORD PTR good$[rsp], 0
  0007c	75 0e		 jne	 SHORT $LN3@dropwhile_@4

; 1122 :             Py_DECREF(item);

  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  00083	e8 00 00 00 00	 call	 _Py_DecRef

; 1123 :             return NULL;

  00088	33 c0		 xor	 eax, eax
  0008a	eb 4c		 jmp	 SHORT $LN8@dropwhile_@4
$LN3@dropwhile_@4:

; 1124 :         }
; 1125 :         ok = PyObject_IsTrue(good);

  0008c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR good$[rsp]
  00091	e8 00 00 00 00	 call	 PyObject_IsTrue
  00096	89 44 24 30	 mov	 DWORD PTR ok$[rsp], eax

; 1126 :         Py_DECREF(good);

  0009a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR good$[rsp]
  0009f	e8 00 00 00 00	 call	 _Py_DecRef

; 1127 :         if (ok == 0) {

  000a4	83 7c 24 30 00	 cmp	 DWORD PTR ok$[rsp], 0
  000a9	75 13		 jne	 SHORT $LN2@dropwhile_@4

; 1128 :             lz->start = 1;

  000ab	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000b0	c7 40 70 01 00
	00 00		 mov	 DWORD PTR [rax+112], 1

; 1129 :             return item;

  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR item$[rsp]
  000bc	eb 1a		 jmp	 SHORT $LN8@dropwhile_@4
$LN2@dropwhile_@4:

; 1130 :         }
; 1131 :         Py_DECREF(item);

  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  000c3	e8 00 00 00 00	 call	 _Py_DecRef

; 1132 :         if (ok < 0)

  000c8	83 7c 24 30 00	 cmp	 DWORD PTR ok$[rsp], 0
  000cd	7d 04		 jge	 SHORT $LN1@dropwhile_@4

; 1133 :             return NULL;

  000cf	33 c0		 xor	 eax, eax
  000d1	eb 05		 jmp	 SHORT $LN8@dropwhile_@4
$LN1@dropwhile_@4:

; 1134 :     }

  000d3	e9 54 ff ff ff	 jmp	 $LN7@dropwhile_@4
$LN8@dropwhile_@4:

; 1135 : }

  000d8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000dc	c3		 ret	 0
dropwhile_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_06NMCPHMHN@O?$CIOO?$CJl?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$dropwhile_reduce DD imagerel dropwhile_reduce
	DD	imagerel dropwhile_reduce+65
	DD	imagerel $unwind$dropwhile_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dropwhile_reduce DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_06NMCPHMHN@O?$CIOO?$CJl?$AA@
CONST	SEGMENT
??_C@_06NMCPHMHN@O?$CIOO?$CJl?$AA@ DB 'O(OO)l', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT dropwhile_reduce
_TEXT	SEGMENT
lz$ = 64
dropwhile_reduce PROC					; COMDAT

; 1139 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1140 :     return Py_BuildValue("O(OO)l", Py_TYPE(lz),
; 1141 :                          lz->func, lz->it, lz->start);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00011	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0001a	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00023	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0002c	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06NMCPHMHN@O?$CIOO?$CJl?$AA@
  00037	e8 00 00 00 00	 call	 Py_BuildValue

; 1142 : }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
dropwhile_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dropwhile_setstate DD imagerel dropwhile_setstate
	DD	imagerel dropwhile_setstate+75
	DD	imagerel $unwind$dropwhile_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dropwhile_setstate DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT dropwhile_setstate
_TEXT	SEGMENT
start$ = 32
lz$ = 64
state$ = 72
dropwhile_setstate PROC					; COMDAT

; 1146 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1147 :     int start = PyObject_IsTrue(state);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00013	e8 00 00 00 00	 call	 PyObject_IsTrue
  00018	89 44 24 20	 mov	 DWORD PTR start$[rsp], eax

; 1148 :     if (start < 0)

  0001c	83 7c 24 20 00	 cmp	 DWORD PTR start$[rsp], 0
  00021	7d 04		 jge	 SHORT $LN1@dropwhile_@5

; 1149 :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 1f		 jmp	 SHORT $LN2@dropwhile_@5
$LN1@dropwhile_@5:

; 1150 :     lz->start = start;

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0002c	8b 4c 24 20	 mov	 ecx, DWORD PTR start$[rsp]
  00030	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 1151 :     Py_RETURN_NONE;

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0003a	e8 00 00 00 00	 call	 _Py_IncRef
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@dropwhile_@5:

; 1152 : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
dropwhile_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_09FMMMOMPJ@takewhile?$AA@			; `string'
PUBLIC	??_C@_0M@BONKCANI@takewhile?$CI?$CJ?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$takewhile_new DD imagerel takewhile_new
	DD	imagerel takewhile_new+250
	DD	imagerel $unwind$takewhile_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$takewhile_new DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_09FMMMOMPJ@takewhile?$AA@
CONST	SEGMENT
??_C@_09FMMMOMPJ@takewhile?$AA@ DB 'takewhile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@BONKCANI@takewhile?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@BONKCANI@takewhile?$CI?$CJ?$AA@ DB 'takewhile()', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT takewhile_new
_TEXT	SEGMENT
it$ = 48
lz$ = 56
seq$ = 64
func$ = 72
type$ = 96
args$ = 104
kwds$ = 112
takewhile_new PROC					; COMDAT

; 1226 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1227 :     PyObject *func, *seq;
; 1228 :     PyObject *it;
; 1229 :     takewhileobject *lz;
; 1230 : 
; 1231 :     if (type == &takewhile_type && !_PyArg_NoKeywords("takewhile()", kwds))

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:takewhile_type
  0001a	48 39 44 24 60	 cmp	 QWORD PTR type$[rsp], rax
  0001f	75 1c		 jne	 SHORT $LN4@takewhile_
  00021	48 8b 54 24 70	 mov	 rdx, QWORD PTR kwds$[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@BONKCANI@takewhile?$CI?$CJ?$AA@
  0002d	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN4@takewhile_

; 1232 :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 b8 00 00 00	 jmp	 $LN5@takewhile_
$LN4@takewhile_:

; 1233 : 
; 1234 :     if (!PyArg_UnpackTuple(args, "takewhile", 2, 2, &func, &seq))

  0003d	48 8d 44 24 40	 lea	 rax, QWORD PTR seq$[rsp]
  00042	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00047	48 8d 44 24 48	 lea	 rax, QWORD PTR func$[rsp]
  0004c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00051	41 b9 02 00 00
	00		 mov	 r9d, 2
  00057	41 b8 02 00 00
	00		 mov	 r8d, 2
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09FMMMOMPJ@takewhile?$AA@
  00064	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00069	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0006e	85 c0		 test	 eax, eax
  00070	75 04		 jne	 SHORT $LN3@takewhile_

; 1235 :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	eb 7f		 jmp	 SHORT $LN5@takewhile_
$LN3@takewhile_:

; 1236 : 
; 1237 :     /* Get iterator. */
; 1238 :     it = PyObject_GetIter(seq);

  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$[rsp]
  0007b	e8 00 00 00 00	 call	 PyObject_GetIter
  00080	48 89 44 24 30	 mov	 QWORD PTR it$[rsp], rax

; 1239 :     if (it == NULL)

  00085	48 83 7c 24 30
	00		 cmp	 QWORD PTR it$[rsp], 0
  0008b	75 04		 jne	 SHORT $LN2@takewhile_

; 1240 :         return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	eb 64		 jmp	 SHORT $LN5@takewhile_
$LN2@takewhile_:

; 1241 : 
; 1242 :     /* create takewhileobject structure */
; 1243 :     lz = (takewhileobject *)type->tp_alloc(type, 0);

  00091	33 d2		 xor	 edx, edx
  00093	48 8b 4c 24 60	 mov	 rcx, QWORD PTR type$[rsp]
  00098	48 8b 44 24 60	 mov	 rax, QWORD PTR type$[rsp]
  0009d	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  000a3	48 89 44 24 38	 mov	 QWORD PTR lz$[rsp], rax

; 1244 :     if (lz == NULL) {

  000a8	48 83 7c 24 38
	00		 cmp	 QWORD PTR lz$[rsp], 0
  000ae	75 0e		 jne	 SHORT $LN1@takewhile_

; 1245 :         Py_DECREF(it);

  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000b5	e8 00 00 00 00	 call	 _Py_DecRef

; 1246 :         return NULL;

  000ba	33 c0		 xor	 eax, eax
  000bc	eb 37		 jmp	 SHORT $LN5@takewhile_
$LN1@takewhile_:

; 1247 :     }
; 1248 :     Py_INCREF(func);

  000be	48 8b 4c 24 48	 mov	 rcx, QWORD PTR func$[rsp]
  000c3	e8 00 00 00 00	 call	 _Py_IncRef

; 1249 :     lz->func = func;

  000c8	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000cd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR func$[rsp]
  000d2	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1250 :     lz->it = it;

  000d6	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000e0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1251 :     lz->stop = 0;

  000e4	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000e9	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 1252 : 
; 1253 :     return (PyObject *)lz;

  000f0	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
$LN5@takewhile_:

; 1254 : }

  000f5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f9	c3		 ret	 0
takewhile_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$takewhile_dealloc DD imagerel takewhile_dealloc
	DD	imagerel takewhile_dealloc+108
	DD	imagerel $unwind$takewhile_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$takewhile_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT takewhile_dealloc
_TEXT	SEGMENT
lz$ = 48
takewhile_dealloc PROC					; COMDAT

; 1258 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1259 :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN8@takewhile_@2:

; 1260 :     Py_XDECREF(lz->func);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN5@takewhile_@2
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@takewhile_@2:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN8@takewhile_@2
$LN4@takewhile_@2:

; 1261 :     Py_XDECREF(lz->it);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0003d	74 0e		 je	 SHORT $LN1@takewhile_@2
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@takewhile_@2:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN4@takewhile_@2

; 1262 :     Py_TYPE(lz)->tp_free(lz);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  00061	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 1263 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
takewhile_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@LLJNNBCB@takewhile_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$takewhile_traverse DD imagerel takewhile_traverse
	DD	imagerel takewhile_traverse+206
	DD	imagerel $unwind$takewhile_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$takewhile_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BD@LLJNNBCB@takewhile_traverse?$AA@
CONST	SEGMENT
??_C@_0BD@LLJNNBCB@takewhile_traverse?$AA@ DB 'takewhile_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT takewhile_traverse
_TEXT	SEGMENT
vret$21540 = 32
vret$21548 = 36
lz$ = 64
visit$ = 72
arg$ = 80
takewhile_traverse PROC					; COMDAT

; 1267 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@takewhile_@3:

; 1268 :     Py_VISIT(lz->it);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@takewhile_@3
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 f4 04 00
	00		 mov	 r8d, 1268		; 000004f4H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@LLJNNBCB@takewhile_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@takewhile_@3:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00042	74 23		 je	 SHORT $LN8@takewhile_@3
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$21540[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$21540[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@takewhile_@3
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$21540[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@takewhile_@3
$LN7@takewhile_@3:
$LN8@takewhile_@3:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@takewhile_@3
$LN6@takewhile_@3:

; 1269 :     Py_VISIT(lz->func);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@takewhile_@3
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 f5 04 00
	00		 mov	 r8d, 1269		; 000004f5H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@LLJNNBCB@takewhile_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@takewhile_@3:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00097	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0009c	74 23		 je	 SHORT $LN2@takewhile_@3
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000a8	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$21548[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$21548[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@takewhile_@3
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$21548[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@takewhile_@3
$LN1@takewhile_@3:
$LN2@takewhile_@3:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@takewhile_@3

; 1270 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@takewhile_@3:

; 1271 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
takewhile_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$takewhile_next DD imagerel takewhile_next
	DD	imagerel takewhile_next+201
	DD	imagerel $unwind$takewhile_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$takewhile_next DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT takewhile_next
_TEXT	SEGMENT
it$ = 32
ok$ = 40
good$ = 48
item$ = 56
lz$ = 80
takewhile_next PROC					; COMDAT

; 1275 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1276 :     PyObject *item, *good;
; 1277 :     PyObject *it = lz->it;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00012	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 1278 :     long ok;
; 1279 : 
; 1280 :     if (lz->stop == 1)

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0001c	83 78 70 01	 cmp	 DWORD PTR [rax+112], 1
  00020	75 07		 jne	 SHORT $LN5@takewhile_@4

; 1281 :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 9b 00 00 00	 jmp	 $LN6@takewhile_@4
$LN5@takewhile_@4:

; 1282 : 
; 1283 :     item = (*Py_TYPE(it)->tp_iternext)(it);

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
  0002e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00037	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]
  0003d	48 89 44 24 38	 mov	 QWORD PTR item$[rsp], rax

; 1284 :     if (item == NULL)

  00042	48 83 7c 24 38
	00		 cmp	 QWORD PTR item$[rsp], 0
  00048	75 04		 jne	 SHORT $LN4@takewhile_@4

; 1285 :         return NULL;

  0004a	33 c0		 xor	 eax, eax
  0004c	eb 76		 jmp	 SHORT $LN6@takewhile_@4
$LN4@takewhile_@4:

; 1286 : 
; 1287 :     good = PyObject_CallFunctionObjArgs(lz->func, item, NULL);

  0004e	45 33 c0	 xor	 r8d, r8d
  00051	48 8b 54 24 38	 mov	 rdx, QWORD PTR item$[rsp]
  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0005b	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0005f	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  00064	48 89 44 24 30	 mov	 QWORD PTR good$[rsp], rax

; 1288 :     if (good == NULL) {

  00069	48 83 7c 24 30
	00		 cmp	 QWORD PTR good$[rsp], 0
  0006f	75 0e		 jne	 SHORT $LN3@takewhile_@4

; 1289 :         Py_DECREF(item);

  00071	48 8b 4c 24 38	 mov	 rcx, QWORD PTR item$[rsp]
  00076	e8 00 00 00 00	 call	 _Py_DecRef

; 1290 :         return NULL;

  0007b	33 c0		 xor	 eax, eax
  0007d	eb 45		 jmp	 SHORT $LN6@takewhile_@4
$LN3@takewhile_@4:

; 1291 :     }
; 1292 :     ok = PyObject_IsTrue(good);

  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR good$[rsp]
  00084	e8 00 00 00 00	 call	 PyObject_IsTrue
  00089	89 44 24 28	 mov	 DWORD PTR ok$[rsp], eax

; 1293 :     Py_DECREF(good);

  0008d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR good$[rsp]
  00092	e8 00 00 00 00	 call	 _Py_DecRef

; 1294 :     if (ok == 1)

  00097	83 7c 24 28 01	 cmp	 DWORD PTR ok$[rsp], 1
  0009c	75 07		 jne	 SHORT $LN2@takewhile_@4

; 1295 :         return item;

  0009e	48 8b 44 24 38	 mov	 rax, QWORD PTR item$[rsp]
  000a3	eb 1f		 jmp	 SHORT $LN6@takewhile_@4
$LN2@takewhile_@4:

; 1296 :     Py_DECREF(item);

  000a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR item$[rsp]
  000aa	e8 00 00 00 00	 call	 _Py_DecRef

; 1297 :     if (ok == 0)

  000af	83 7c 24 28 00	 cmp	 DWORD PTR ok$[rsp], 0
  000b4	75 0c		 jne	 SHORT $LN1@takewhile_@4

; 1298 :         lz->stop = 1;

  000b6	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  000bb	c7 40 70 01 00
	00 00		 mov	 DWORD PTR [rax+112], 1
$LN1@takewhile_@4:

; 1299 :     return NULL;

  000c2	33 c0		 xor	 eax, eax
$LN6@takewhile_@4:

; 1300 : }

  000c4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c8	c3		 ret	 0
takewhile_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$takewhile_reduce DD imagerel takewhile_reduce
	DD	imagerel takewhile_reduce+65
	DD	imagerel $unwind$takewhile_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$takewhile_reduce DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT takewhile_reduce
_TEXT	SEGMENT
lz$ = 64
takewhile_reduce PROC					; COMDAT

; 1304 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1305 :     return Py_BuildValue("O(OO)l", Py_TYPE(lz),
; 1306 :                          lz->func, lz->it, lz->stop);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00011	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0001a	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00023	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0002c	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06NMCPHMHN@O?$CIOO?$CJl?$AA@
  00037	e8 00 00 00 00	 call	 Py_BuildValue

; 1307 : }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
takewhile_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$takewhile_reduce_setstate DD imagerel takewhile_reduce_setstate
	DD	imagerel takewhile_reduce_setstate+75
	DD	imagerel $unwind$takewhile_reduce_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$takewhile_reduce_setstate DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT takewhile_reduce_setstate
_TEXT	SEGMENT
stop$ = 32
lz$ = 64
state$ = 72
takewhile_reduce_setstate PROC				; COMDAT

; 1311 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1312 :     int stop = PyObject_IsTrue(state);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00013	e8 00 00 00 00	 call	 PyObject_IsTrue
  00018	89 44 24 20	 mov	 DWORD PTR stop$[rsp], eax

; 1313 :     if (stop < 0)

  0001c	83 7c 24 20 00	 cmp	 DWORD PTR stop$[rsp], 0
  00021	7d 04		 jge	 SHORT $LN1@takewhile_@5

; 1314 :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 1f		 jmp	 SHORT $LN2@takewhile_@5
$LN1@takewhile_@5:

; 1315 :     lz->stop = stop;

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0002c	8b 4c 24 20	 mov	 ecx, DWORD PTR stop$[rsp]
  00030	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 1316 :     Py_RETURN_NONE;

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0003a	e8 00 00 00 00	 call	 _Py_IncRef
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@takewhile_@5:

; 1317 : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
takewhile_reduce_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@DNHAKAJL@Step?5for?5islice?$CI?$CJ?5must?5be?5a?5posi@ ; `string'
PUBLIC	??_C@_0EI@DHOLOIGM@Indices?5for?5islice?$CI?$CJ?5must?5be?5Non@ ; `string'
PUBLIC	??_C@_0EO@DAIAMBKO@Stop?5argument?5for?5islice?$CI?$CJ?5must?5@ ; `string'
PUBLIC	??_C@_06LJPMJOIG@islice?$AA@			; `string'
PUBLIC	??_C@_08IHGLAMB@islice?$CI?$CJ?$AA@		; `string'
EXTRN	PyLong_AsSsize_t:PROC
EXTRN	PyTuple_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$islice_new DD imagerel islice_new
	DD	imagerel islice_new+775
	DD	imagerel $unwind$islice_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$islice_new DD 021601H
	DD	0130116H
xdata	ENDS
;	COMDAT ??_C@_0DG@DNHAKAJL@Step?5for?5islice?$CI?$CJ?5must?5be?5a?5posi@
CONST	SEGMENT
??_C@_0DG@DNHAKAJL@Step?5for?5islice?$CI?$CJ?5must?5be?5a?5posi@ DB 'Step'
	DB	' for islice() must be a positive integer or None.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@DHOLOIGM@Indices?5for?5islice?$CI?$CJ?5must?5be?5Non@
CONST	SEGMENT
??_C@_0EI@DHOLOIGM@Indices?5for?5islice?$CI?$CJ?5must?5be?5Non@ DB 'Indic'
	DB	'es for islice() must be None or an integer: 0 <= x <= sys.max'
	DB	'size.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@DAIAMBKO@Stop?5argument?5for?5islice?$CI?$CJ?5must?5@
CONST	SEGMENT
??_C@_0EO@DAIAMBKO@Stop?5argument?5for?5islice?$CI?$CJ?5must?5@ DB 'Stop '
	DB	'argument for islice() must be None or an integer: 0 <= x <= s'
	DB	'ys.maxsize.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06LJPMJOIG@islice?$AA@
CONST	SEGMENT
??_C@_06LJPMJOIG@islice?$AA@ DB 'islice', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08IHGLAMB@islice?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_08IHGLAMB@islice?$CI?$CJ?$AA@ DB 'islice()', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT islice_new
_TEXT	SEGMENT
it$ = 64
a1$ = 72
step$ = 80
stop$ = 88
lz$ = 96
numargs$ = 104
start$ = 112
seq$ = 120
a3$ = 128
a2$ = 136
type$ = 160
args$ = 168
kwds$ = 176
islice_new PROC						; COMDAT

; 1392 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1393 :     PyObject *seq;
; 1394 :     Py_ssize_t start=0, stop=-1, step=1;

  00016	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR start$[rsp], 0
  0001f	48 c7 44 24 58
	ff ff ff ff	 mov	 QWORD PTR stop$[rsp], -1
  00028	48 c7 44 24 50
	01 00 00 00	 mov	 QWORD PTR step$[rsp], 1

; 1395 :     PyObject *it, *a1=NULL, *a2=NULL, *a3=NULL;

  00031	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR a1$[rsp], 0
  0003a	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR a2$[rsp], 0
  00046	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR a3$[rsp], 0

; 1396 :     Py_ssize_t numargs;
; 1397 :     isliceobject *lz;
; 1398 : 
; 1399 :     if (type == &islice_type && !_PyArg_NoKeywords("islice()", kwds))

  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:islice_type
  00059	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR type$[rsp], rax
  00061	75 1f		 jne	 SHORT $LN20@islice_new
  00063	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08IHGLAMB@islice?$CI?$CJ?$AA@
  00072	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00077	85 c0		 test	 eax, eax
  00079	75 07		 jne	 SHORT $LN20@islice_new

; 1400 :         return NULL;

  0007b	33 c0		 xor	 eax, eax
  0007d	e9 7d 02 00 00	 jmp	 $LN21@islice_new
$LN20@islice_new:

; 1401 : 
; 1402 :     if (!PyArg_UnpackTuple(args, "islice", 2, 4, &seq, &a1, &a2, &a3))

  00082	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR a3$[rsp]
  0008a	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0008f	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR a2$[rsp]
  00097	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0009c	48 8d 44 24 48	 lea	 rax, QWORD PTR a1$[rsp]
  000a1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a6	48 8d 44 24 78	 lea	 rax, QWORD PTR seq$[rsp]
  000ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b0	41 b9 04 00 00
	00		 mov	 r9d, 4
  000b6	41 b8 02 00 00
	00		 mov	 r8d, 2
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06LJPMJOIG@islice?$AA@
  000c3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000cb	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  000d0	85 c0		 test	 eax, eax
  000d2	75 07		 jne	 SHORT $LN19@islice_new

; 1403 :         return NULL;

  000d4	33 c0		 xor	 eax, eax
  000d6	e9 24 02 00 00	 jmp	 $LN21@islice_new
$LN19@islice_new:

; 1404 : 
; 1405 :     numargs = PyTuple_Size(args);

  000db	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000e3	e8 00 00 00 00	 call	 PyTuple_Size
  000e8	48 89 44 24 68	 mov	 QWORD PTR numargs$[rsp], rax

; 1406 :     if (numargs == 2) {

  000ed	48 83 7c 24 68
	02		 cmp	 QWORD PTR numargs$[rsp], 2
  000f3	75 53		 jne	 SHORT $LN18@islice_new

; 1407 :         if (a1 != Py_None) {

  000f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000fc	48 39 44 24 48	 cmp	 QWORD PTR a1$[rsp], rax
  00101	74 40		 je	 SHORT $LN17@islice_new

; 1408 :             stop = PyLong_AsSsize_t(a1);

  00103	48 8b 4c 24 48	 mov	 rcx, QWORD PTR a1$[rsp]
  00108	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0010d	48 89 44 24 58	 mov	 QWORD PTR stop$[rsp], rax

; 1409 :             if (stop == -1) {

  00112	48 83 7c 24 58
	ff		 cmp	 QWORD PTR stop$[rsp], -1
  00118	75 29		 jne	 SHORT $LN16@islice_new

; 1410 :                 if (PyErr_Occurred())

  0011a	e8 00 00 00 00	 call	 PyErr_Occurred
  0011f	48 85 c0	 test	 rax, rax
  00122	74 05		 je	 SHORT $LN15@islice_new

; 1411 :                     PyErr_Clear();

  00124	e8 00 00 00 00	 call	 PyErr_Clear
$LN15@islice_new:

; 1412 :                 PyErr_SetString(PyExc_ValueError,
; 1413 :                    "Stop argument for islice() must be None or an integer: 0 <= x <= sys.maxsize.");

  00129	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EO@DAIAMBKO@Stop?5argument?5for?5islice?$CI?$CJ?5must?5@
  00130	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00137	e8 00 00 00 00	 call	 PyErr_SetString

; 1414 :                 return NULL;

  0013c	33 c0		 xor	 eax, eax
  0013e	e9 bc 01 00 00	 jmp	 $LN21@islice_new
$LN16@islice_new:
$LN17@islice_new:

; 1415 :             }
; 1416 :         }
; 1417 :     } else {

  00143	e9 88 00 00 00	 jmp	 $LN14@islice_new
$LN18@islice_new:

; 1418 :         if (a1 != Py_None)

  00148	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0014f	48 39 44 24 48	 cmp	 QWORD PTR a1$[rsp], rax
  00154	74 0f		 je	 SHORT $LN13@islice_new

; 1419 :             start = PyLong_AsSsize_t(a1);

  00156	48 8b 4c 24 48	 mov	 rcx, QWORD PTR a1$[rsp]
  0015b	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00160	48 89 44 24 70	 mov	 QWORD PTR start$[rsp], rax
$LN13@islice_new:

; 1420 :         if (start == -1 && PyErr_Occurred())

  00165	48 83 7c 24 70
	ff		 cmp	 QWORD PTR start$[rsp], -1
  0016b	75 0f		 jne	 SHORT $LN12@islice_new
  0016d	e8 00 00 00 00	 call	 PyErr_Occurred
  00172	48 85 c0	 test	 rax, rax
  00175	74 05		 je	 SHORT $LN12@islice_new

; 1421 :             PyErr_Clear();

  00177	e8 00 00 00 00	 call	 PyErr_Clear
$LN12@islice_new:

; 1422 :         if (a2 != Py_None) {

  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00183	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR a2$[rsp], rax
  0018b	74 43		 je	 SHORT $LN11@islice_new

; 1423 :             stop = PyLong_AsSsize_t(a2);

  0018d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR a2$[rsp]
  00195	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0019a	48 89 44 24 58	 mov	 QWORD PTR stop$[rsp], rax

; 1424 :             if (stop == -1) {

  0019f	48 83 7c 24 58
	ff		 cmp	 QWORD PTR stop$[rsp], -1
  001a5	75 29		 jne	 SHORT $LN10@islice_new

; 1425 :                 if (PyErr_Occurred())

  001a7	e8 00 00 00 00	 call	 PyErr_Occurred
  001ac	48 85 c0	 test	 rax, rax
  001af	74 05		 je	 SHORT $LN9@islice_new

; 1426 :                     PyErr_Clear();

  001b1	e8 00 00 00 00	 call	 PyErr_Clear
$LN9@islice_new:

; 1427 :                 PyErr_SetString(PyExc_ValueError,
; 1428 :                    "Stop argument for islice() must be None or an integer: 0 <= x <= sys.maxsize.");

  001b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EO@DAIAMBKO@Stop?5argument?5for?5islice?$CI?$CJ?5must?5@
  001bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001c4	e8 00 00 00 00	 call	 PyErr_SetString

; 1429 :                 return NULL;

  001c9	33 c0		 xor	 eax, eax
  001cb	e9 2f 01 00 00	 jmp	 $LN21@islice_new
$LN10@islice_new:
$LN11@islice_new:
$LN14@islice_new:

; 1430 :             }
; 1431 :         }
; 1432 :     }
; 1433 :     if (start<0 || stop<-1) {

  001d0	48 83 7c 24 70
	00		 cmp	 QWORD PTR start$[rsp], 0
  001d6	7c 08		 jl	 SHORT $LN7@islice_new
  001d8	48 83 7c 24 58
	ff		 cmp	 QWORD PTR stop$[rsp], -1
  001de	7d 1a		 jge	 SHORT $LN8@islice_new
$LN7@islice_new:

; 1434 :         PyErr_SetString(PyExc_ValueError,
; 1435 :            "Indices for islice() must be None or an integer: 0 <= x <= sys.maxsize.");

  001e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EI@DHOLOIGM@Indices?5for?5islice?$CI?$CJ?5must?5be?5Non@
  001e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001ee	e8 00 00 00 00	 call	 PyErr_SetString

; 1436 :         return NULL;

  001f3	33 c0		 xor	 eax, eax
  001f5	e9 05 01 00 00	 jmp	 $LN21@islice_new
$LN8@islice_new:

; 1437 :     }
; 1438 : 
; 1439 :     if (a3 != NULL) {

  001fa	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR a3$[rsp], 0
  00203	74 3a		 je	 SHORT $LN6@islice_new

; 1440 :         if (a3 != Py_None)

  00205	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0020c	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR a3$[rsp], rax
  00214	74 12		 je	 SHORT $LN5@islice_new

; 1441 :             step = PyLong_AsSsize_t(a3);

  00216	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR a3$[rsp]
  0021e	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00223	48 89 44 24 50	 mov	 QWORD PTR step$[rsp], rax
$LN5@islice_new:

; 1442 :         if (step == -1 && PyErr_Occurred())

  00228	48 83 7c 24 50
	ff		 cmp	 QWORD PTR step$[rsp], -1
  0022e	75 0f		 jne	 SHORT $LN4@islice_new
  00230	e8 00 00 00 00	 call	 PyErr_Occurred
  00235	48 85 c0	 test	 rax, rax
  00238	74 05		 je	 SHORT $LN4@islice_new

; 1443 :             PyErr_Clear();

  0023a	e8 00 00 00 00	 call	 PyErr_Clear
$LN4@islice_new:
$LN6@islice_new:

; 1444 :     }
; 1445 :     if (step<1) {

  0023f	48 83 7c 24 50
	01		 cmp	 QWORD PTR step$[rsp], 1
  00245	7d 1a		 jge	 SHORT $LN3@islice_new

; 1446 :         PyErr_SetString(PyExc_ValueError,
; 1447 :            "Step for islice() must be a positive integer or None.");

  00247	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@DNHAKAJL@Step?5for?5islice?$CI?$CJ?5must?5be?5a?5posi@
  0024e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00255	e8 00 00 00 00	 call	 PyErr_SetString

; 1448 :         return NULL;

  0025a	33 c0		 xor	 eax, eax
  0025c	e9 9e 00 00 00	 jmp	 $LN21@islice_new
$LN3@islice_new:

; 1449 :     }
; 1450 : 
; 1451 :     /* Get iterator. */
; 1452 :     it = PyObject_GetIter(seq);

  00261	48 8b 4c 24 78	 mov	 rcx, QWORD PTR seq$[rsp]
  00266	e8 00 00 00 00	 call	 PyObject_GetIter
  0026b	48 89 44 24 40	 mov	 QWORD PTR it$[rsp], rax

; 1453 :     if (it == NULL)

  00270	48 83 7c 24 40
	00		 cmp	 QWORD PTR it$[rsp], 0
  00276	75 07		 jne	 SHORT $LN2@islice_new

; 1454 :         return NULL;

  00278	33 c0		 xor	 eax, eax
  0027a	e9 80 00 00 00	 jmp	 $LN21@islice_new
$LN2@islice_new:

; 1455 : 
; 1456 :     /* create isliceobject structure */
; 1457 :     lz = (isliceobject *)type->tp_alloc(type, 0);

  0027f	33 d2		 xor	 edx, edx
  00281	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  00289	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  00291	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00297	48 89 44 24 60	 mov	 QWORD PTR lz$[rsp], rax

; 1458 :     if (lz == NULL) {

  0029c	48 83 7c 24 60
	00		 cmp	 QWORD PTR lz$[rsp], 0
  002a2	75 0e		 jne	 SHORT $LN1@islice_new

; 1459 :         Py_DECREF(it);

  002a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  002a9	e8 00 00 00 00	 call	 _Py_DecRef

; 1460 :         return NULL;

  002ae	33 c0		 xor	 eax, eax
  002b0	eb 4d		 jmp	 SHORT $LN21@islice_new
$LN1@islice_new:

; 1461 :     }
; 1462 :     lz->it = it;

  002b2	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  002b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR it$[rsp]
  002bc	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1463 :     lz->next = start;

  002c0	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  002c5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR start$[rsp]
  002ca	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1464 :     lz->stop = stop;

  002ce	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  002d3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR stop$[rsp]
  002d8	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 1465 :     lz->step = step;

  002dc	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  002e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR step$[rsp]
  002e6	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 1466 :     lz->cnt = 0L;

  002ea	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  002ef	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 1467 : 
; 1468 :     return (PyObject *)lz;

  002fa	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
$LN21@islice_new:

; 1469 : }

  002ff	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00306	c3		 ret	 0
islice_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$islice_dealloc DD imagerel islice_dealloc
	DD	imagerel islice_dealloc+76
	DD	imagerel $unwind$islice_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$islice_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT islice_dealloc
_TEXT	SEGMENT
lz$ = 48
islice_dealloc PROC					; COMDAT

; 1473 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1474 :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN4@islice_dea:

; 1475 :     Py_XDECREF(lz->it);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN1@islice_dea
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@islice_dea:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN4@islice_dea

; 1476 :     Py_TYPE(lz)->tp_free(lz);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  00041	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 1477 : }

  00047	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004b	c3		 ret	 0
islice_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@JEBIGEKL@islice_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$islice_traverse DD imagerel islice_traverse
	DD	imagerel islice_traverse+116
	DD	imagerel $unwind$islice_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$islice_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BA@JEBIGEKL@islice_traverse?$AA@
CONST	SEGMENT
??_C@_0BA@JEBIGEKL@islice_traverse?$AA@ DB 'islice_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT islice_traverse
_TEXT	SEGMENT
vret$21707 = 32
lz$ = 64
visit$ = 72
arg$ = 80
islice_traverse PROC					; COMDAT

; 1481 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@islice_tra:

; 1482 :     Py_VISIT(lz->it);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@islice_tra
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 ca 05 00
	00		 mov	 r8d, 1482		; 000005caH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JEBIGEKL@islice_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@islice_tra:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN2@islice_tra
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$21707[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$21707[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@islice_tra
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$21707[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@islice_tra
$LN1@islice_tra:
$LN2@islice_tra:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@islice_tra

; 1483 :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@islice_tra:

; 1484 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
islice_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$islice_next DD imagerel islice_next
	DD	imagerel islice_next+341
	DD	imagerel $unwind$islice_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$islice_next DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT islice_next
_TEXT	SEGMENT
it$ = 32
oldnext$ = 40
iternext$ = 48
stop$ = 56
item$ = 64
lz$ = 96
islice_next PROC					; COMDAT

; 1488 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1489 :     PyObject *item;
; 1490 :     PyObject *it = lz->it;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 1491 :     Py_ssize_t stop = lz->stop;

  00017	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0001c	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00020	48 89 44 24 38	 mov	 QWORD PTR stop$[rsp], rax

; 1492 :     Py_ssize_t oldnext;
; 1493 :     PyObject *(*iternext)(PyObject *);
; 1494 : 
; 1495 :     iternext = *Py_TYPE(it)->tp_iternext;

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
  0002a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002e	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00035	48 89 44 24 30	 mov	 QWORD PTR iternext$[rsp], rax
$LN7@islice_nex:

; 1496 :     while (lz->cnt < lz->next) {

  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0003f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  00044	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00048	48 39 88 80 00
	00 00		 cmp	 QWORD PTR [rax+128], rcx
  0004f	7d 44		 jge	 SHORT $LN6@islice_nex

; 1497 :         item = iternext(it);

  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00056	ff 54 24 30	 call	 QWORD PTR iternext$[rsp]
  0005a	48 89 44 24 40	 mov	 QWORD PTR item$[rsp], rax

; 1498 :         if (item == NULL)

  0005f	48 83 7c 24 40
	00		 cmp	 QWORD PTR item$[rsp], 0
  00065	75 07		 jne	 SHORT $LN5@islice_nex

; 1499 :             return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	e9 e2 00 00 00	 jmp	 $LN8@islice_nex
$LN5@islice_nex:

; 1500 :         Py_DECREF(item);

  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  00073	e8 00 00 00 00	 call	 _Py_DecRef

; 1501 :         lz->cnt++;

  00078	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0007d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00084	48 ff c0	 inc	 rax
  00087	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  0008c	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 1502 :     }

  00093	eb a5		 jmp	 SHORT $LN7@islice_nex
$LN6@islice_nex:

; 1503 :     if (stop != -1 && lz->cnt >= stop)

  00095	48 83 7c 24 38
	ff		 cmp	 QWORD PTR stop$[rsp], -1
  0009b	74 1a		 je	 SHORT $LN4@islice_nex
  0009d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stop$[rsp]
  000a7	48 39 88 80 00
	00 00		 cmp	 QWORD PTR [rax+128], rcx
  000ae	7c 07		 jl	 SHORT $LN4@islice_nex

; 1504 :         return NULL;

  000b0	33 c0		 xor	 eax, eax
  000b2	e9 99 00 00 00	 jmp	 $LN8@islice_nex
$LN4@islice_nex:

; 1505 :     item = iternext(it);

  000b7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000bc	ff 54 24 30	 call	 QWORD PTR iternext$[rsp]
  000c0	48 89 44 24 40	 mov	 QWORD PTR item$[rsp], rax

; 1506 :     if (item == NULL)

  000c5	48 83 7c 24 40
	00		 cmp	 QWORD PTR item$[rsp], 0
  000cb	75 04		 jne	 SHORT $LN3@islice_nex

; 1507 :         return NULL;

  000cd	33 c0		 xor	 eax, eax
  000cf	eb 7f		 jmp	 SHORT $LN8@islice_nex
$LN3@islice_nex:

; 1508 :     lz->cnt++;

  000d1	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000d6	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000dd	48 ff c0	 inc	 rax
  000e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  000e5	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 1509 :     oldnext = lz->next;

  000ec	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000f1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f5	48 89 44 24 28	 mov	 QWORD PTR oldnext$[rsp], rax

; 1510 :     /* The (size_t) cast below avoids the danger of undefined
; 1511 :        behaviour from signed integer overflow. */
; 1512 :     lz->next += (size_t)lz->step;

  000fa	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000ff	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00103	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  00108	48 03 41 78	 add	 rax, QWORD PTR [rcx+120]
  0010c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  00111	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 1513 :     if (lz->next < oldnext || (stop != -1 && lz->next > stop))

  00115	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0011a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR oldnext$[rsp]
  0011f	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00123	7c 18		 jl	 SHORT $LN1@islice_nex
  00125	48 83 7c 24 38
	ff		 cmp	 QWORD PTR stop$[rsp], -1
  0012b	74 1e		 je	 SHORT $LN2@islice_nex
  0012d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00132	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stop$[rsp]
  00137	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  0013b	7e 0e		 jle	 SHORT $LN2@islice_nex
$LN1@islice_nex:

; 1514 :         lz->next = stop;

  0013d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00142	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stop$[rsp]
  00147	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN2@islice_nex:

; 1515 :     return item;

  0014b	48 8b 44 24 40	 mov	 rax, QWORD PTR item$[rsp]
$LN8@islice_nex:

; 1516 : }

  00150	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00154	c3		 ret	 0
islice_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_08ECCLGIIA@O?$CIOnNn?$CJn?$AA@		; `string'
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$islice_reduce DD imagerel islice_reduce
	DD	imagerel islice_reduce+161
	DD	imagerel $unwind$islice_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$islice_reduce DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_08ECCLGIIA@O?$CIOnNn?$CJn?$AA@
CONST	SEGMENT
??_C@_08ECCLGIIA@O?$CIOnNn?$CJn?$AA@ DB 'O(OnNn)n', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT islice_reduce
_TEXT	SEGMENT
stop$ = 64
lz$ = 96
islice_reduce PROC					; COMDAT

; 1520 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1521 :     /* When unpickled, generate a new object with the same bounds,
; 1522 :      * then 'setstate' with the next and count
; 1523 :      */
; 1524 :     PyObject *stop;
; 1525 :     if (lz->stop == -1) {

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 83 78 70 ff	 cmp	 QWORD PTR [rax+112], -1
  00013	75 18		 jne	 SHORT $LN3@islice_red

; 1526 :         stop = Py_None;

  00015	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001c	48 89 44 24 40	 mov	 QWORD PTR stop$[rsp], rax

; 1527 :         Py_INCREF(stop);

  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR stop$[rsp]
  00026	e8 00 00 00 00	 call	 _Py_IncRef

; 1528 :     } else {

  0002b	eb 1f		 jmp	 SHORT $LN2@islice_red
$LN3@islice_red:

; 1529 :         stop = PyLong_FromSsize_t(lz->stop);

  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00032	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00036	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  0003b	48 89 44 24 40	 mov	 QWORD PTR stop$[rsp], rax

; 1530 :         if (stop == NULL)

  00040	48 83 7c 24 40
	00		 cmp	 QWORD PTR stop$[rsp], 0
  00046	75 04		 jne	 SHORT $LN1@islice_red

; 1531 :             return NULL;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 50		 jmp	 SHORT $LN4@islice_red
$LN1@islice_red:
$LN2@islice_red:

; 1532 :     }
; 1533 :     return Py_BuildValue("O(OnNn)n", Py_TYPE(lz),
; 1534 :         lz->it, lz->next, stop, lz->step,
; 1535 :         lz->cnt);

  0004c	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00051	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00058	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00062	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00066	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR stop$[rsp]
  00070	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00075	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0007a	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0007e	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00083	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00087	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0008c	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08ECCLGIIA@O?$CIOnNn?$CJn?$AA@
  00097	e8 00 00 00 00	 call	 Py_BuildValue
$LN4@islice_red:

; 1536 : }

  0009c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000a0	c3		 ret	 0
islice_reduce ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$islice_setstate DD imagerel islice_setstate
	DD	imagerel islice_setstate+92
	DD	imagerel $unwind$islice_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$islice_setstate DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT islice_setstate
_TEXT	SEGMENT
cnt$ = 32
lz$ = 64
state$ = 72
islice_setstate PROC					; COMDAT

; 1540 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1541 :     Py_ssize_t cnt = PyLong_AsSsize_t(state);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR state$[rsp]
  00013	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00018	48 89 44 24 20	 mov	 QWORD PTR cnt$[rsp], rax

; 1542 :     if (cnt == -1 && PyErr_Occurred())

  0001d	48 83 7c 24 20
	ff		 cmp	 QWORD PTR cnt$[rsp], -1
  00023	75 0e		 jne	 SHORT $LN1@islice_set
  00025	e8 00 00 00 00	 call	 PyErr_Occurred
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 04		 je	 SHORT $LN1@islice_set

; 1543 :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 24		 jmp	 SHORT $LN2@islice_set
$LN1@islice_set:

; 1544 :     lz->cnt = cnt;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 8b 4c 24 20	 mov	 rcx, QWORD PTR cnt$[rsp]
  0003d	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 1545 :     Py_RETURN_NONE;

  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0004b	e8 00 00 00 00	 call	 _Py_IncRef
  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@islice_set:

; 1546 : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
islice_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_07EPPJNKLC@starmap?$AA@			; `string'
PUBLIC	??_C@_09MCONDALK@starmap?$CI?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$starmap_new DD imagerel starmap_new
	DD	imagerel starmap_new+238
	DD	imagerel $unwind$starmap_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$starmap_new DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_07EPPJNKLC@starmap?$AA@
CONST	SEGMENT
??_C@_07EPPJNKLC@starmap?$AA@ DB 'starmap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09MCONDALK@starmap?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_09MCONDALK@starmap?$CI?$CJ?$AA@ DB 'starmap()', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT starmap_new
_TEXT	SEGMENT
it$ = 48
lz$ = 56
seq$ = 64
func$ = 72
type$ = 96
args$ = 104
kwds$ = 112
starmap_new PROC					; COMDAT

; 1624 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1625 :     PyObject *func, *seq;
; 1626 :     PyObject *it;
; 1627 :     starmapobject *lz;
; 1628 : 
; 1629 :     if (type == &starmap_type && !_PyArg_NoKeywords("starmap()", kwds))

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:starmap_type
  0001a	48 39 44 24 60	 cmp	 QWORD PTR type$[rsp], rax
  0001f	75 1c		 jne	 SHORT $LN4@starmap_ne
  00021	48 8b 54 24 70	 mov	 rdx, QWORD PTR kwds$[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09MCONDALK@starmap?$CI?$CJ?$AA@
  0002d	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN4@starmap_ne

; 1630 :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 ac 00 00 00	 jmp	 $LN5@starmap_ne
$LN4@starmap_ne:

; 1631 : 
; 1632 :     if (!PyArg_UnpackTuple(args, "starmap", 2, 2, &func, &seq))

  0003d	48 8d 44 24 40	 lea	 rax, QWORD PTR seq$[rsp]
  00042	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00047	48 8d 44 24 48	 lea	 rax, QWORD PTR func$[rsp]
  0004c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00051	41 b9 02 00 00
	00		 mov	 r9d, 2
  00057	41 b8 02 00 00
	00		 mov	 r8d, 2
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EPPJNKLC@starmap?$AA@
  00064	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00069	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0006e	85 c0		 test	 eax, eax
  00070	75 04		 jne	 SHORT $LN3@starmap_ne

; 1633 :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	eb 73		 jmp	 SHORT $LN5@starmap_ne
$LN3@starmap_ne:

; 1634 : 
; 1635 :     /* Get iterator. */
; 1636 :     it = PyObject_GetIter(seq);

  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$[rsp]
  0007b	e8 00 00 00 00	 call	 PyObject_GetIter
  00080	48 89 44 24 30	 mov	 QWORD PTR it$[rsp], rax

; 1637 :     if (it == NULL)

  00085	48 83 7c 24 30
	00		 cmp	 QWORD PTR it$[rsp], 0
  0008b	75 04		 jne	 SHORT $LN2@starmap_ne

; 1638 :         return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	eb 58		 jmp	 SHORT $LN5@starmap_ne
$LN2@starmap_ne:

; 1639 : 
; 1640 :     /* create starmapobject structure */
; 1641 :     lz = (starmapobject *)type->tp_alloc(type, 0);

  00091	33 d2		 xor	 edx, edx
  00093	48 8b 4c 24 60	 mov	 rcx, QWORD PTR type$[rsp]
  00098	48 8b 44 24 60	 mov	 rax, QWORD PTR type$[rsp]
  0009d	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  000a3	48 89 44 24 38	 mov	 QWORD PTR lz$[rsp], rax

; 1642 :     if (lz == NULL) {

  000a8	48 83 7c 24 38
	00		 cmp	 QWORD PTR lz$[rsp], 0
  000ae	75 0e		 jne	 SHORT $LN1@starmap_ne

; 1643 :         Py_DECREF(it);

  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000b5	e8 00 00 00 00	 call	 _Py_DecRef

; 1644 :         return NULL;

  000ba	33 c0		 xor	 eax, eax
  000bc	eb 2b		 jmp	 SHORT $LN5@starmap_ne
$LN1@starmap_ne:

; 1645 :     }
; 1646 :     Py_INCREF(func);

  000be	48 8b 4c 24 48	 mov	 rcx, QWORD PTR func$[rsp]
  000c3	e8 00 00 00 00	 call	 _Py_IncRef

; 1647 :     lz->func = func;

  000c8	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000cd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR func$[rsp]
  000d2	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1648 :     lz->it = it;

  000d6	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000e0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1649 : 
; 1650 :     return (PyObject *)lz;

  000e4	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
$LN5@starmap_ne:

; 1651 : }

  000e9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ed	c3		 ret	 0
starmap_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$starmap_dealloc DD imagerel starmap_dealloc
	DD	imagerel starmap_dealloc+108
	DD	imagerel $unwind$starmap_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$starmap_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT starmap_dealloc
_TEXT	SEGMENT
lz$ = 48
starmap_dealloc PROC					; COMDAT

; 1655 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1656 :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN8@starmap_de:

; 1657 :     Py_XDECREF(lz->func);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN5@starmap_de
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@starmap_de:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN8@starmap_de
$LN4@starmap_de:

; 1658 :     Py_XDECREF(lz->it);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0003d	74 0e		 je	 SHORT $LN1@starmap_de
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@starmap_de:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN4@starmap_de

; 1659 :     Py_TYPE(lz)->tp_free(lz);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  00061	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 1660 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
starmap_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@NLOBOMMB@starmap_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$starmap_traverse DD imagerel starmap_traverse
	DD	imagerel starmap_traverse+206
	DD	imagerel $unwind$starmap_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$starmap_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BB@NLOBOMMB@starmap_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@NLOBOMMB@starmap_traverse?$AA@ DB 'starmap_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT starmap_traverse
_TEXT	SEGMENT
vret$21846 = 32
vret$21854 = 36
lz$ = 64
visit$ = 72
arg$ = 80
starmap_traverse PROC					; COMDAT

; 1664 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@starmap_tr:

; 1665 :     Py_VISIT(lz->it);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@starmap_tr
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 81 06 00
	00		 mov	 r8d, 1665		; 00000681H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NLOBOMMB@starmap_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@starmap_tr:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00042	74 23		 je	 SHORT $LN8@starmap_tr
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$21846[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$21846[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@starmap_tr
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$21846[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@starmap_tr
$LN7@starmap_tr:
$LN8@starmap_tr:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@starmap_tr
$LN6@starmap_tr:

; 1666 :     Py_VISIT(lz->func);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@starmap_tr
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 82 06 00
	00		 mov	 r8d, 1666		; 00000682H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NLOBOMMB@starmap_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@starmap_tr:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00097	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0009c	74 23		 je	 SHORT $LN2@starmap_tr
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000a8	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$21854[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$21854[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@starmap_tr
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$21854[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@starmap_tr
$LN1@starmap_tr:
$LN2@starmap_tr:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@starmap_tr

; 1667 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@starmap_tr:

; 1668 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
starmap_traverse ENDP
_TEXT	ENDS
EXTRN	PyObject_Call:PROC
EXTRN	PySequence_Tuple:PROC
EXTRN	PyTuple_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$starmap_next DD imagerel starmap_next
	DD	imagerel starmap_next+172
	DD	imagerel $unwind$starmap_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$starmap_next DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT starmap_next
_TEXT	SEGMENT
it$ = 32
args$ = 40
result$ = 48
newargs$21870 = 56
lz$ = 80
starmap_next PROC					; COMDAT

; 1672 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1673 :     PyObject *args;
; 1674 :     PyObject *result;
; 1675 :     PyObject *it = lz->it;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00012	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 1676 : 
; 1677 :     args = (*Py_TYPE(it)->tp_iternext)(it);

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
  0001c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00020	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00025	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]
  0002b	48 89 44 24 28	 mov	 QWORD PTR args$[rsp], rax

; 1678 :     if (args == NULL)

  00030	48 83 7c 24 28
	00		 cmp	 QWORD PTR args$[rsp], 0
  00036	75 04		 jne	 SHORT $LN3@starmap_ne@2

; 1679 :         return NULL;

  00038	33 c0		 xor	 eax, eax
  0003a	eb 6b		 jmp	 SHORT $LN4@starmap_ne@2
$LN3@starmap_ne@2:

; 1680 :     if (!PyTuple_CheckExact(args)) {

  0003c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  00043	48 8b 4c 24 28	 mov	 rcx, QWORD PTR args$[rsp]
  00048	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0004c	74 2f		 je	 SHORT $LN2@starmap_ne@2

; 1681 :         PyObject *newargs = PySequence_Tuple(args);

  0004e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR args$[rsp]
  00053	e8 00 00 00 00	 call	 PySequence_Tuple
  00058	48 89 44 24 38	 mov	 QWORD PTR newargs$21870[rsp], rax

; 1682 :         Py_DECREF(args);

  0005d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR args$[rsp]
  00062	e8 00 00 00 00	 call	 _Py_DecRef

; 1683 :         if (newargs == NULL)

  00067	48 83 7c 24 38
	00		 cmp	 QWORD PTR newargs$21870[rsp], 0
  0006d	75 04		 jne	 SHORT $LN1@starmap_ne@2

; 1684 :             return NULL;

  0006f	33 c0		 xor	 eax, eax
  00071	eb 34		 jmp	 SHORT $LN4@starmap_ne@2
$LN1@starmap_ne@2:

; 1685 :         args = newargs;

  00073	48 8b 44 24 38	 mov	 rax, QWORD PTR newargs$21870[rsp]
  00078	48 89 44 24 28	 mov	 QWORD PTR args$[rsp], rax
$LN2@starmap_ne@2:

; 1686 :     }
; 1687 :     result = PyObject_Call(lz->func, args, NULL);

  0007d	45 33 c0	 xor	 r8d, r8d
  00080	48 8b 54 24 28	 mov	 rdx, QWORD PTR args$[rsp]
  00085	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0008a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0008e	e8 00 00 00 00	 call	 PyObject_Call
  00093	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1688 :     Py_DECREF(args);

  00098	48 8b 4c 24 28	 mov	 rcx, QWORD PTR args$[rsp]
  0009d	e8 00 00 00 00	 call	 _Py_DecRef

; 1689 :     return result;

  000a2	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
$LN4@starmap_ne@2:

; 1690 : }

  000a7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ab	c3		 ret	 0
starmap_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$starmap_reduce DD imagerel starmap_reduce
	DD	imagerel starmap_reduce+53
	DD	imagerel $unwind$starmap_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$starmap_reduce DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT starmap_reduce
_TEXT	SEGMENT
lz$ = 48
starmap_reduce PROC					; COMDAT

; 1694 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1695 :     /* Just pickle the iterator */
; 1696 :     return Py_BuildValue("O(OO)", Py_TYPE(lz), lz->func, lz->it);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00017	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00020	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LNHFJPFN@O?$CIOO?$CJ?$AA@
  0002b	e8 00 00 00 00	 call	 Py_BuildValue

; 1697 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
starmap_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_07ICILEEAM@chain?$CI?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$chain_new DD imagerel chain_new
	DD	imagerel chain_new+105
	DD	imagerel $unwind$chain_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$chain_new DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_07ICILEEAM@chain?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_07ICILEEAM@chain?$CI?$CJ?$AA@ DB 'chain()', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT chain_new
_TEXT	SEGMENT
source$ = 32
type$ = 64
args$ = 72
kwds$ = 80
chain_new PROC						; COMDAT

; 1784 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1785 :     PyObject *source;
; 1786 : 
; 1787 :     if (type == &chain_type && !_PyArg_NoKeywords("chain()", kwds))

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:chain_type
  0001a	48 39 44 24 40	 cmp	 QWORD PTR type$[rsp], rax
  0001f	75 19		 jne	 SHORT $LN2@chain_new
  00021	48 8b 54 24 50	 mov	 rdx, QWORD PTR kwds$[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07ICILEEAM@chain?$CI?$CJ?$AA@
  0002d	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00032	85 c0		 test	 eax, eax
  00034	75 04		 jne	 SHORT $LN2@chain_new

; 1788 :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	eb 2a		 jmp	 SHORT $LN3@chain_new
$LN2@chain_new:

; 1789 : 
; 1790 :     source = PyObject_GetIter(args);

  0003a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0003f	e8 00 00 00 00	 call	 PyObject_GetIter
  00044	48 89 44 24 20	 mov	 QWORD PTR source$[rsp], rax

; 1791 :     if (source == NULL)

  00049	48 83 7c 24 20
	00		 cmp	 QWORD PTR source$[rsp], 0
  0004f	75 04		 jne	 SHORT $LN1@chain_new

; 1792 :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	eb 0f		 jmp	 SHORT $LN3@chain_new
$LN1@chain_new:

; 1793 : 
; 1794 :     return chain_new_internal(type, source);

  00055	48 8b 54 24 20	 mov	 rdx, QWORD PTR source$[rsp]
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  0005f	e8 00 00 00 00	 call	 chain_new_internal
$LN3@chain_new:

; 1795 : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
chain_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$chain_new_internal DD imagerel chain_new_internal
	DD	imagerel chain_new_internal+96
	DD	imagerel $unwind$chain_new_internal
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$chain_new_internal DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT chain_new_internal
_TEXT	SEGMENT
lz$ = 32
type$ = 64
source$ = 72
chain_new_internal PROC					; COMDAT

; 1768 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1769 :     chainobject *lz;
; 1770 : 
; 1771 :     lz = (chainobject *)type->tp_alloc(type, 0);

  0000e	33 d2		 xor	 edx, edx
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR type$[rsp]
  0001a	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00020	48 89 44 24 20	 mov	 QWORD PTR lz$[rsp], rax

; 1772 :     if (lz == NULL) {

  00025	48 83 7c 24 20
	00		 cmp	 QWORD PTR lz$[rsp], 0
  0002b	75 0e		 jne	 SHORT $LN1@chain_new_

; 1773 :         Py_DECREF(source);

  0002d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR source$[rsp]
  00032	e8 00 00 00 00	 call	 _Py_DecRef

; 1774 :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	eb 20		 jmp	 SHORT $LN2@chain_new_
$LN1@chain_new_:

; 1775 :     }
; 1776 : 
; 1777 :     lz->source = source;

  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR lz$[rsp]
  00040	48 8b 4c 24 48	 mov	 rcx, QWORD PTR source$[rsp]
  00045	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1778 :     lz->active = NULL;

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 1779 :     return (PyObject *)lz;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR lz$[rsp]
$LN2@chain_new_:

; 1780 : }

  0005b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005f	c3		 ret	 0
chain_new_internal ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$chain_new_from_iterable DD imagerel chain_new_from_iterable
	DD	imagerel chain_new_from_iterable+61
	DD	imagerel $unwind$chain_new_from_iterable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$chain_new_from_iterable DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT chain_new_from_iterable
_TEXT	SEGMENT
source$ = 32
type$ = 64
arg$ = 72
chain_new_from_iterable PROC				; COMDAT

; 1799 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1800 :     PyObject *source;
; 1801 : 
; 1802 :     source = PyObject_GetIter(arg);

  0000e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR arg$[rsp]
  00013	e8 00 00 00 00	 call	 PyObject_GetIter
  00018	48 89 44 24 20	 mov	 QWORD PTR source$[rsp], rax

; 1803 :     if (source == NULL)

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR source$[rsp], 0
  00023	75 04		 jne	 SHORT $LN1@chain_new_@2

; 1804 :         return NULL;

  00025	33 c0		 xor	 eax, eax
  00027	eb 0f		 jmp	 SHORT $LN2@chain_new_@2
$LN1@chain_new_@2:

; 1805 : 
; 1806 :     return chain_new_internal(type, source);

  00029	48 8b 54 24 20	 mov	 rdx, QWORD PTR source$[rsp]
  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR type$[rsp]
  00033	e8 00 00 00 00	 call	 chain_new_internal
$LN2@chain_new_@2:

; 1807 : }

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	c3		 ret	 0
chain_new_from_iterable ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$chain_dealloc DD imagerel chain_dealloc
	DD	imagerel chain_dealloc+108
	DD	imagerel $unwind$chain_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$chain_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT chain_dealloc
_TEXT	SEGMENT
lz$ = 48
chain_dealloc PROC					; COMDAT

; 1811 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1812 :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN8@chain_deal:

; 1813 :     Py_XDECREF(lz->active);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0001d	74 0e		 je	 SHORT $LN5@chain_deal
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@chain_deal:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN8@chain_deal
$LN4@chain_deal:

; 1814 :     Py_XDECREF(lz->source);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0003d	74 0e		 je	 SHORT $LN1@chain_deal
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@chain_deal:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN4@chain_deal

; 1815 :     Py_TYPE(lz)->tp_free(lz);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  00061	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 1816 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
chain_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@IFJBADFM@chain_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$chain_traverse DD imagerel chain_traverse
	DD	imagerel chain_traverse+206
	DD	imagerel $unwind$chain_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$chain_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0P@IFJBADFM@chain_traverse?$AA@
CONST	SEGMENT
??_C@_0P@IFJBADFM@chain_traverse?$AA@ DB 'chain_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT chain_traverse
_TEXT	SEGMENT
vret$21979 = 32
vret$21987 = 36
lz$ = 64
visit$ = 72
arg$ = 80
chain_traverse PROC					; COMDAT

; 1820 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@chain_trav:

; 1821 :     Py_VISIT(lz->source);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@chain_trav
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 1d 07 00
	00		 mov	 r8d, 1821		; 0000071dH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IFJBADFM@chain_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@chain_trav:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN8@chain_trav
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$21979[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$21979[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@chain_trav
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$21979[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@chain_trav
$LN7@chain_trav:
$LN8@chain_trav:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@chain_trav
$LN6@chain_trav:

; 1822 :     Py_VISIT(lz->active);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@chain_trav
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 1e 07 00
	00		 mov	 r8d, 1822		; 0000071eH
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@IFJBADFM@chain_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@chain_trav:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00097	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0009c	74 23		 je	 SHORT $LN2@chain_trav
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000a8	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$21987[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$21987[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@chain_trav
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$21987[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@chain_trav
$LN1@chain_trav:
$LN2@chain_trav:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@chain_trav

; 1823 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@chain_trav:

; 1824 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
chain_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@GNIBCEE@chain_next?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$chain_next DD imagerel chain_next
	DD	imagerel chain_next+518
	DD	imagerel $unwind$chain_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$chain_next DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_0L@GNIBCEE@chain_next?$AA@
CONST	SEGMENT
??_C@_0L@GNIBCEE@chain_next?$AA@ DB 'chain_next', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT chain_next
_TEXT	SEGMENT
item$ = 48
iterable$22000 = 56
_py_tmp$22008 = 64
_py_tmp$22020 = 72
_py_tmp$22035 = 80
lz$ = 112
chain_next PROC						; COMDAT

; 1828 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1829 :     PyObject *item;
; 1830 : 
; 1831 :     if (lz->source == NULL)

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	75 07		 jne	 SHORT $LN20@chain_next

; 1832 :         return NULL;                                    /* already stopped */

  00015	33 c0		 xor	 eax, eax
  00017	e9 e5 01 00 00	 jmp	 $LN21@chain_next
$LN20@chain_next:

; 1833 : 
; 1834 :     if (lz->active == NULL) {

  0001c	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00021	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00026	0f 85 1c 01 00
	00		 jne	 $LN19@chain_next

; 1835 :         PyObject *iterable = PyIter_Next(lz->source);

  0002c	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00031	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00035	e8 00 00 00 00	 call	 PyIter_Next
  0003a	48 89 44 24 38	 mov	 QWORD PTR iterable$22000[rsp], rax

; 1836 :         if (iterable == NULL) {

  0003f	48 83 7c 24 38
	00		 cmp	 QWORD PTR iterable$22000[rsp], 0
  00045	75 6c		 jne	 SHORT $LN18@chain_next
$LN17@chain_next:

; 1837 :             Py_CLEAR(lz->source);

  00047	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  0004c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00051	74 53		 je	 SHORT $LN14@chain_next
  00053	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005b	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00060	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  00064	41 b8 2d 07 00
	00		 mov	 r8d, 1837		; 0000072dH
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@GNIBCEE@chain_next?$AA@
  00078	e8 00 00 00 00	 call	 _PyParallel_Guard
  0007d	85 c0		 test	 eax, eax
  0007f	75 25		 jne	 SHORT $LN14@chain_next
  00081	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00086	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008a	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$22008[rsp], rax
  0008f	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00094	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$22008[rsp]
  000a1	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@chain_next:
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 9b		 jne	 SHORT $LN17@chain_next

; 1838 :             return NULL;                                /* no more input sources */

  000ac	33 c0		 xor	 eax, eax
  000ae	e9 4e 01 00 00	 jmp	 $LN21@chain_next
$LN18@chain_next:

; 1839 :         }
; 1840 :         lz->active = PyObject_GetIter(iterable);

  000b3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR iterable$22000[rsp]
  000b8	e8 00 00 00 00	 call	 PyObject_GetIter
  000bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lz$[rsp]
  000c2	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 1841 :         Py_DECREF(iterable);

  000c6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR iterable$22000[rsp]
  000cb	e8 00 00 00 00	 call	 _Py_DecRef

; 1842 :         if (lz->active == NULL) {

  000d0	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  000d5	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000da	75 6c		 jne	 SHORT $LN13@chain_next
$LN12@chain_next:

; 1843 :             Py_CLEAR(lz->source);

  000dc	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  000e1	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000e6	74 53		 je	 SHORT $LN9@chain_next
  000e8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000f0	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  000f5	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  000f9	41 b8 33 07 00
	00		 mov	 r8d, 1843		; 00000733H
  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@GNIBCEE@chain_next?$AA@
  0010d	e8 00 00 00 00	 call	 _PyParallel_Guard
  00112	85 c0		 test	 eax, eax
  00114	75 25		 jne	 SHORT $LN9@chain_next
  00116	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  0011b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0011f	48 89 44 24 48	 mov	 QWORD PTR _py_tmp$22020[rsp], rax
  00124	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00129	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  00131	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _py_tmp$22020[rsp]
  00136	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@chain_next:
  0013b	33 c0		 xor	 eax, eax
  0013d	85 c0		 test	 eax, eax
  0013f	75 9b		 jne	 SHORT $LN12@chain_next

; 1844 :             return NULL;                                /* input not iterable */

  00141	33 c0		 xor	 eax, eax
  00143	e9 b9 00 00 00	 jmp	 $LN21@chain_next
$LN13@chain_next:
$LN19@chain_next:

; 1845 :         }
; 1846 :     }
; 1847 :     item = PyIter_Next(lz->active);

  00148	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  0014d	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00151	e8 00 00 00 00	 call	 PyIter_Next
  00156	48 89 44 24 30	 mov	 QWORD PTR item$[rsp], rax

; 1848 :     if (item != NULL)

  0015b	48 83 7c 24 30
	00		 cmp	 QWORD PTR item$[rsp], 0
  00161	74 0a		 je	 SHORT $LN8@chain_next

; 1849 :         return item;

  00163	48 8b 44 24 30	 mov	 rax, QWORD PTR item$[rsp]
  00168	e9 94 00 00 00	 jmp	 $LN21@chain_next
$LN8@chain_next:

; 1850 :     if (PyErr_Occurred()) {

  0016d	e8 00 00 00 00	 call	 PyErr_Occurred
  00172	48 85 c0	 test	 rax, rax
  00175	74 1b		 je	 SHORT $LN7@chain_next

; 1851 :         if (PyErr_ExceptionMatches(PyExc_StopIteration))

  00177	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  0017e	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00183	85 c0		 test	 eax, eax
  00185	74 07		 je	 SHORT $LN6@chain_next

; 1852 :             PyErr_Clear();

  00187	e8 00 00 00 00	 call	 PyErr_Clear

; 1853 :         else

  0018c	eb 04		 jmp	 SHORT $LN5@chain_next
$LN6@chain_next:

; 1854 :             return NULL;                                /* input raised an exception */

  0018e	33 c0		 xor	 eax, eax
  00190	eb 6f		 jmp	 SHORT $LN21@chain_next
$LN5@chain_next:
$LN7@chain_next:
$LN4@chain_next:

; 1855 :     }
; 1856 :     Py_CLEAR(lz->active);

  00192	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  00197	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0019c	74 53		 je	 SHORT $LN1@chain_next
  0019e	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001a6	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  001ab	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  001af	41 b8 40 07 00
	00		 mov	 r8d, 1856		; 00000740H
  001b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  001bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@GNIBCEE@chain_next?$AA@
  001c3	e8 00 00 00 00	 call	 _PyParallel_Guard
  001c8	85 c0		 test	 eax, eax
  001ca	75 25		 jne	 SHORT $LN1@chain_next
  001cc	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  001d1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001d5	48 89 44 24 50	 mov	 QWORD PTR _py_tmp$22035[rsp], rax
  001da	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  001df	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
  001e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _py_tmp$22035[rsp]
  001ec	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@chain_next:
  001f1	33 c0		 xor	 eax, eax
  001f3	85 c0		 test	 eax, eax
  001f5	75 9b		 jne	 SHORT $LN4@chain_next

; 1857 :     return chain_next(lz);                      /* recurse and use next active */

  001f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lz$[rsp]
  001fc	e8 00 00 00 00	 call	 chain_next
$LN21@chain_next:

; 1858 : }

  00201	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00205	c3		 ret	 0
chain_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_03GPNEOADL@O?$CI?$CJ?$AA@			; `string'
PUBLIC	??_C@_06KNPIDNPI@O?$CI?$CJ?$CIO?$CJ?$AA@	; `string'
PUBLIC	??_C@_07LLNHKKGK@O?$CI?$CJ?$CIOO?$CJ?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$chain_reduce DD imagerel chain_reduce
	DD	imagerel chain_reduce+140
	DD	imagerel $unwind$chain_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$chain_reduce DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_03GPNEOADL@O?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_03GPNEOADL@O?$CI?$CJ?$AA@ DB 'O()', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KNPIDNPI@O?$CI?$CJ?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_06KNPIDNPI@O?$CI?$CJ?$CIO?$CJ?$AA@ DB 'O()(O)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07LLNHKKGK@O?$CI?$CJ?$CIOO?$CJ?$AA@
CONST	SEGMENT
??_C@_07LLNHKKGK@O?$CI?$CJ?$CIOO?$CJ?$AA@ DB 'O()(OO)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT chain_reduce
_TEXT	SEGMENT
lz$ = 48
chain_reduce PROC					; COMDAT

; 1862 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1863 :     if (lz->source) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 59		 je	 SHORT $LN4@chain_redu

; 1864 :         /* we can't pickle function objects (itertools.from_iterable) so
; 1865 :          * we must use setstate to replace the iterable.  One day we
; 1866 :          * will fix pickling of functions
; 1867 :          */
; 1868 :         if (lz->active) {

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0001a	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0001f	74 2b		 je	 SHORT $LN3@chain_redu

; 1869 :             return Py_BuildValue("O()(OO)", Py_TYPE(lz), lz->source, lz->active);

  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00026	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0002f	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07LLNHKKGK@O?$CI?$CJ?$CIOO?$CJ?$AA@
  00043	e8 00 00 00 00	 call	 Py_BuildValue
  00048	eb 3d		 jmp	 SHORT $LN5@chain_redu

; 1870 :         } else {

  0004a	eb 20		 jmp	 SHORT $LN2@chain_redu
$LN3@chain_redu:

; 1871 :             return Py_BuildValue("O()(O)", Py_TYPE(lz), lz->source);

  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00051	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0005a	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06KNPIDNPI@O?$CI?$CJ?$CIO?$CJ?$AA@
  00065	e8 00 00 00 00	 call	 Py_BuildValue
  0006a	eb 1b		 jmp	 SHORT $LN5@chain_redu
$LN2@chain_redu:

; 1872 :         }
; 1873 :     } else {

  0006c	eb 17		 jmp	 SHORT $LN1@chain_redu
$LN4@chain_redu:

; 1874 :         return Py_BuildValue("O()", Py_TYPE(lz)); /* exhausted */

  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00073	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03GPNEOADL@O?$CI?$CJ?$AA@
  0007e	e8 00 00 00 00	 call	 Py_BuildValue
  00083	eb 02		 jmp	 SHORT $LN5@chain_redu
$LN1@chain_redu:

; 1875 :     }
; 1876 :     return NULL;

  00085	33 c0		 xor	 eax, eax
$LN5@chain_redu:

; 1877 : }

  00087	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008b	c3		 ret	 0
chain_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@OIMGCELL@chain_setstate?$AA@		; `string'
PUBLIC	??_C@_03DHMGKKHG@O?$HMO?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$chain_setstate DD imagerel chain_setstate
	DD	imagerel chain_setstate+361
	DD	imagerel $unwind$chain_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$chain_setstate DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0P@OIMGCELL@chain_setstate?$AA@
CONST	SEGMENT
??_C@_0P@OIMGCELL@chain_setstate?$AA@ DB 'chain_setstate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03DHMGKKHG@O?$HMO?$AA@
CONST	SEGMENT
??_C@_03DHMGKKHG@O?$HMO?$AA@ DB 'O|O', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT chain_setstate
_TEXT	SEGMENT
active$ = 48
source$ = 56
_py_tmp$22071 = 64
_py_tmp$22080 = 72
lz$ = 96
state$ = 104
chain_setstate PROC					; COMDAT

; 1881 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1882 :     PyObject *source, *active=NULL;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR active$[rsp], 0

; 1883 :     if (! PyArg_ParseTuple(state, "O|O", &source, &active))

  00017	4c 8d 4c 24 30	 lea	 r9, QWORD PTR active$[rsp]
  0001c	4c 8d 44 24 38	 lea	 r8, QWORD PTR source$[rsp]
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03DHMGKKHG@O?$HMO?$AA@
  00028	48 8b 4c 24 68	 mov	 rcx, QWORD PTR state$[rsp]
  0002d	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN13@chain_sets

; 1884 :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 27 01 00 00	 jmp	 $LN14@chain_sets
$LN13@chain_sets:
$LN12@chain_sets:

; 1885 : 
; 1886 :     Py_CLEAR(lz->source);

  0003d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00042	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00047	74 53		 je	 SHORT $LN9@chain_sets
  00049	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00051	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00056	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  0005a	41 b8 5e 07 00
	00		 mov	 r8d, 1886		; 0000075eH
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OIMGCELL@chain_setstate?$AA@
  0006e	e8 00 00 00 00	 call	 _PyParallel_Guard
  00073	85 c0		 test	 eax, eax
  00075	75 25		 jne	 SHORT $LN9@chain_sets
  00077	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0007c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00080	48 89 44 24 40	 mov	 QWORD PTR _py_tmp$22071[rsp], rax
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0008a	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _py_tmp$22071[rsp]
  00097	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@chain_sets:
  0009c	33 c0		 xor	 eax, eax
  0009e	85 c0		 test	 eax, eax
  000a0	75 9b		 jne	 SHORT $LN12@chain_sets

; 1887 :     lz->source = source;

  000a2	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR source$[rsp]
  000ac	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1888 :     Py_INCREF(lz->source);

  000b0	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000b5	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000b9	e8 00 00 00 00	 call	 _Py_IncRef
$LN8@chain_sets:

; 1889 :     Py_CLEAR(lz->active);

  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000c3	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000c8	74 53		 je	 SHORT $LN5@chain_sets
  000ca	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000d2	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000d7	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  000db	41 b8 61 07 00
	00		 mov	 r8d, 1889		; 00000761H
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@OIMGCELL@chain_setstate?$AA@
  000ef	e8 00 00 00 00	 call	 _PyParallel_Guard
  000f4	85 c0		 test	 eax, eax
  000f6	75 25		 jne	 SHORT $LN5@chain_sets
  000f8	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000fd	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00101	48 89 44 24 48	 mov	 QWORD PTR _py_tmp$22080[rsp], rax
  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0010b	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
  00113	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _py_tmp$22080[rsp]
  00118	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@chain_sets:
  0011d	33 c0		 xor	 eax, eax
  0011f	85 c0		 test	 eax, eax
  00121	75 9b		 jne	 SHORT $LN8@chain_sets

; 1890 :     lz->active = active;

  00123	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00128	48 8b 4c 24 30	 mov	 rcx, QWORD PTR active$[rsp]
  0012d	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN4@chain_sets:

; 1891 :     Py_XINCREF(lz->active);

  00131	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00136	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0013b	74 0e		 je	 SHORT $LN1@chain_sets
  0013d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00142	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00146	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@chain_sets:
  0014b	33 c0		 xor	 eax, eax
  0014d	85 c0		 test	 eax, eax
  0014f	75 e0		 jne	 SHORT $LN4@chain_sets

; 1892 :     Py_RETURN_NONE;

  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00158	e8 00 00 00 00	 call	 _Py_IncRef
  0015d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN14@chain_sets:

; 1893 : }

  00164	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00168	c3		 ret	 0
chain_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CI@KAJNBGPM@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CD@PADFKNPL@repeat?5argument?5cannot?5be?5negati@ ; `string'
PUBLIC	??_C@_0L@LOFFFBN@?$HMn?3product?$AA@		; `string'
PUBLIC	??_C@_06LGDBIFHB@repeat?$AA@			; `string'
EXTRN	PyMem_Free:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$product_new DD imagerel product_new
	DD	imagerel product_new+824
	DD	imagerel $unwind$product_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$product_new DD 021601H
	DD	0150116H
xdata	ENDS
;	COMDAT ??_C@_1CI@KAJNBGPM@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@KAJNBGPM@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'T', 00H, 'u', 00H, 'p', 00H, 'l', 00H, 'e', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'a', 00H, 'r', 00H, 'g', 00H, 's', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@PADFKNPL@repeat?5argument?5cannot?5be?5negati@
CONST	SEGMENT
??_C@_0CD@PADFKNPL@repeat?5argument?5cannot?5be?5negati@ DB 'repeat argum'
	DB	'ent cannot be negative', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LOFFFBN@?$HMn?3product?$AA@
CONST	SEGMENT
??_C@_0L@LOFFFBN@?$HMn?3product?$AA@ DB '|n:product', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06LGDBIFHB@repeat?$AA@
CONST	SEGMENT
??_C@_06LGDBIFHB@repeat?$AA@ DB 'repeat', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT product_new
_TEXT	SEGMENT
i$ = 48
pools$ = 56
indices$ = 64
repeat$ = 72
lz$ = 80
npools$ = 88
nargs$ = 96
kwlist$22144 = 104
tmpargs$22146 = 120
item$22171 = 128
pool$22173 = 136
pool$22180 = 144
tv90 = 152
type$ = 176
args$ = 184
kwds$ = 192
product_new PROC					; COMDAT

; 1977 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1978 :     productobject *lz;
; 1979 :     Py_ssize_t nargs, npools, repeat=1;

  00016	48 c7 44 24 48
	01 00 00 00	 mov	 QWORD PTR repeat$[rsp], 1

; 1980 :     PyObject *pools = NULL;

  0001f	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pools$[rsp], 0

; 1981 :     Py_ssize_t *indices = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR indices$[rsp], 0

; 1982 :     Py_ssize_t i;
; 1983 : 
; 1984 :     if (kwds != NULL) {

  00031	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR kwds$[rsp], 0
  0003a	0f 84 99 00 00
	00		 je	 $LN19@product_ne

; 1985 :         char *kwlist[] = {"repeat", 0};

  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06LGDBIFHB@repeat?$AA@
  00047	48 89 44 24 68	 mov	 QWORD PTR kwlist$22144[rsp], rax
  0004c	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR kwlist$22144[rsp+8], 0

; 1986 :         PyObject *tmpargs = PyTuple_New(0);

  00055	33 c9		 xor	 ecx, ecx
  00057	e8 00 00 00 00	 call	 PyTuple_New
  0005c	48 89 44 24 78	 mov	 QWORD PTR tmpargs$22146[rsp], rax

; 1987 :         if (tmpargs == NULL)

  00061	48 83 7c 24 78
	00		 cmp	 QWORD PTR tmpargs$22146[rsp], 0
  00067	75 07		 jne	 SHORT $LN18@product_ne

; 1988 :             return NULL;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 c0 02 00 00	 jmp	 $LN20@product_ne
$LN18@product_ne:

; 1989 :         if (!PyArg_ParseTupleAndKeywords(tmpargs, kwds, "|n:product", kwlist, &repeat)) {

  00070	48 8d 44 24 48	 lea	 rax, QWORD PTR repeat$[rsp]
  00075	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007a	4c 8d 4c 24 68	 lea	 r9, QWORD PTR kwlist$22144[rsp]
  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@LOFFFBN@?$HMn?3product?$AA@
  00086	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  0008e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tmpargs$22146[rsp]
  00093	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00098	85 c0		 test	 eax, eax
  0009a	75 11		 jne	 SHORT $LN17@product_ne

; 1990 :             Py_DECREF(tmpargs);

  0009c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tmpargs$22146[rsp]
  000a1	e8 00 00 00 00	 call	 _Py_DecRef

; 1991 :             return NULL;

  000a6	33 c0		 xor	 eax, eax
  000a8	e9 83 02 00 00	 jmp	 $LN20@product_ne
$LN17@product_ne:

; 1992 :         }
; 1993 :         Py_DECREF(tmpargs);

  000ad	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tmpargs$22146[rsp]
  000b2	e8 00 00 00 00	 call	 _Py_DecRef

; 1994 :         if (repeat < 0) {

  000b7	48 83 7c 24 48
	00		 cmp	 QWORD PTR repeat$[rsp], 0
  000bd	7d 1a		 jge	 SHORT $LN16@product_ne

; 1995 :             PyErr_SetString(PyExc_ValueError,
; 1996 :                             "repeat argument cannot be negative");

  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@PADFKNPL@repeat?5argument?5cannot?5be?5negati@
  000c6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000cd	e8 00 00 00 00	 call	 PyErr_SetString

; 1997 :             return NULL;

  000d2	33 c0		 xor	 eax, eax
  000d4	e9 57 02 00 00	 jmp	 $LN20@product_ne
$LN16@product_ne:
$LN19@product_ne:

; 1998 :         }
; 1999 :     }
; 2000 : 
; 2001 :     assert(PyTuple_Check(args));

  000d9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  000e1	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000e5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000eb	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  000f0	85 c0		 test	 eax, eax
  000f2	75 1c		 jne	 SHORT $LN22@product_ne
  000f4	41 b8 d1 07 00
	00		 mov	 r8d, 2001		; 000007d1H
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00101	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KAJNBGPM@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?$AA@
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0010e	33 c0		 xor	 eax, eax
$LN22@product_ne:

; 2002 :     nargs = (repeat == 0) ? 0 : PyTuple_GET_SIZE(args);

  00110	48 83 7c 24 48
	00		 cmp	 QWORD PTR repeat$[rsp], 0
  00116	75 0e		 jne	 SHORT $LN23@product_ne
  00118	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv90[rsp], 0
  00124	eb 14		 jmp	 SHORT $LN24@product_ne
$LN23@product_ne:
  00126	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  0012e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00132	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
$LN24@product_ne:
  0013a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv90[rsp]
  00142	48 89 44 24 60	 mov	 QWORD PTR nargs$[rsp], rax

; 2003 :     npools = nargs * repeat;

  00147	48 8b 44 24 60	 mov	 rax, QWORD PTR nargs$[rsp]
  0014c	48 0f af 44 24
	48		 imul	 rax, QWORD PTR repeat$[rsp]
  00152	48 89 44 24 58	 mov	 QWORD PTR npools$[rsp], rax

; 2004 : 
; 2005 :     indices = PyMem_Malloc(npools * sizeof(Py_ssize_t));

  00157	48 8b 44 24 58	 mov	 rax, QWORD PTR npools$[rsp]
  0015c	48 c1 e0 03	 shl	 rax, 3
  00160	48 8b c8	 mov	 rcx, rax
  00163	e8 00 00 00 00	 call	 PyMem_Malloc
  00168	48 89 44 24 40	 mov	 QWORD PTR indices$[rsp], rax

; 2006 :     if (indices == NULL) {

  0016d	48 83 7c 24 40
	00		 cmp	 QWORD PTR indices$[rsp], 0
  00173	75 0a		 jne	 SHORT $LN15@product_ne

; 2007 :         PyErr_NoMemory();

  00175	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2008 :         goto error;

  0017a	e9 85 01 00 00	 jmp	 $error$22165
$LN15@product_ne:

; 2009 :     }
; 2010 : 
; 2011 :     pools = PyTuple_New(npools);

  0017f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR npools$[rsp]
  00184	e8 00 00 00 00	 call	 PyTuple_New
  00189	48 89 44 24 38	 mov	 QWORD PTR pools$[rsp], rax

; 2012 :     if (pools == NULL)

  0018e	48 83 7c 24 38
	00		 cmp	 QWORD PTR pools$[rsp], 0
  00194	75 05		 jne	 SHORT $LN14@product_ne

; 2013 :         goto error;

  00196	e9 69 01 00 00	 jmp	 $error$22165
$LN14@product_ne:

; 2014 : 
; 2015 :     for (i=0; i < nargs ; ++i) {

  0019b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001a4	eb 0d		 jmp	 SHORT $LN13@product_ne
$LN12@product_ne:
  001a6	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  001ab	48 ff c0	 inc	 rax
  001ae	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN13@product_ne:
  001b3	48 8b 44 24 60	 mov	 rax, QWORD PTR nargs$[rsp]
  001b8	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  001bd	7d 6d		 jge	 SHORT $LN11@product_ne

; 2016 :         PyObject *item = PyTuple_GET_ITEM(args, i);

  001bf	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR args$[rsp]
  001c7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  001cc	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  001d1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR item$22171[rsp], rax

; 2017 :         PyObject *pool = PySequence_Tuple(item);

  001d9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR item$22171[rsp]
  001e1	e8 00 00 00 00	 call	 PySequence_Tuple
  001e6	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pool$22173[rsp], rax

; 2018 :         if (pool == NULL)

  001ee	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR pool$22173[rsp], 0
  001f7	75 05		 jne	 SHORT $LN10@product_ne

; 2019 :             goto error;

  001f9	e9 06 01 00 00	 jmp	 $error$22165
$LN10@product_ne:

; 2020 :         PyTuple_SET_ITEM(pools, i, pool);

  001fe	48 8b 44 24 38	 mov	 rax, QWORD PTR pools$[rsp]
  00203	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00208	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pool$22173[rsp]
  00210	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2021 :         indices[i] = 0;

  00215	48 8b 44 24 40	 mov	 rax, QWORD PTR indices$[rsp]
  0021a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0021f	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0

; 2022 :     }

  00227	e9 7a ff ff ff	 jmp	 $LN12@product_ne
$LN11@product_ne:

; 2023 :     for ( ; i < npools; ++i) {

  0022c	eb 0d		 jmp	 SHORT $LN9@product_ne
$LN8@product_ne:
  0022e	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00233	48 ff c0	 inc	 rax
  00236	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN9@product_ne:
  0023b	48 8b 44 24 58	 mov	 rax, QWORD PTR npools$[rsp]
  00240	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00245	7d 5a		 jge	 SHORT $LN7@product_ne

; 2024 :         PyObject *pool = PyTuple_GET_ITEM(pools, i - nargs);

  00247	48 8b 44 24 60	 mov	 rax, QWORD PTR nargs$[rsp]
  0024c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00251	48 2b c8	 sub	 rcx, rax
  00254	48 8b c1	 mov	 rax, rcx
  00257	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pools$[rsp]
  0025c	48 8b 44 c1 70	 mov	 rax, QWORD PTR [rcx+rax*8+112]
  00261	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pool$22180[rsp], rax

; 2025 :         Py_INCREF(pool);

  00269	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pool$22180[rsp]
  00271	e8 00 00 00 00	 call	 _Py_IncRef

; 2026 :         PyTuple_SET_ITEM(pools, i, pool);

  00276	48 8b 44 24 38	 mov	 rax, QWORD PTR pools$[rsp]
  0027b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00280	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pool$22180[rsp]
  00288	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2027 :         indices[i] = 0;

  0028d	48 8b 44 24 40	 mov	 rax, QWORD PTR indices$[rsp]
  00292	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00297	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0

; 2028 :     }

  0029f	eb 8d		 jmp	 SHORT $LN8@product_ne
$LN7@product_ne:

; 2029 : 
; 2030 :     /* create productobject structure */
; 2031 :     lz = (productobject *)type->tp_alloc(type, 0);

  002a1	33 d2		 xor	 edx, edx
  002a3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  002ab	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  002b3	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  002b9	48 89 44 24 50	 mov	 QWORD PTR lz$[rsp], rax

; 2032 :     if (lz == NULL)

  002be	48 83 7c 24 50
	00		 cmp	 QWORD PTR lz$[rsp], 0
  002c4	75 02		 jne	 SHORT $LN6@product_ne

; 2033 :         goto error;

  002c6	eb 3c		 jmp	 SHORT $error$22165
$LN6@product_ne:

; 2034 : 
; 2035 :     lz->pools = pools;

  002c8	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  002cd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pools$[rsp]
  002d2	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 2036 :     lz->indices = indices;

  002d6	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  002db	48 8b 4c 24 40	 mov	 rcx, QWORD PTR indices$[rsp]
  002e0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 2037 :     lz->result = NULL;

  002e4	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  002e9	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 2038 :     lz->stopped = 0;

  002f1	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  002f6	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [rax+120], 0

; 2039 : 
; 2040 :     return (PyObject *)lz;

  002fd	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00302	eb 2c		 jmp	 SHORT $LN20@product_ne
$error$22165:

; 2041 : 
; 2042 : error:
; 2043 :     if (indices != NULL)

  00304	48 83 7c 24 40
	00		 cmp	 QWORD PTR indices$[rsp], 0
  0030a	74 0a		 je	 SHORT $LN5@product_ne

; 2044 :         PyMem_Free(indices);

  0030c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR indices$[rsp]
  00311	e8 00 00 00 00	 call	 PyMem_Free
$LN5@product_ne:
$LN4@product_ne:

; 2045 :     Py_XDECREF(pools);

  00316	48 83 7c 24 38
	00		 cmp	 QWORD PTR pools$[rsp], 0
  0031c	74 0a		 je	 SHORT $LN1@product_ne
  0031e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pools$[rsp]
  00323	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@product_ne:
  00328	33 c0		 xor	 eax, eax
  0032a	85 c0		 test	 eax, eax
  0032c	75 e8		 jne	 SHORT $LN4@product_ne

; 2046 :     return NULL;

  0032e	33 c0		 xor	 eax, eax
$LN20@product_ne:

; 2047 : }

  00330	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00337	c3		 ret	 0
product_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$product_dealloc DD imagerel product_dealloc
	DD	imagerel product_dealloc+134
	DD	imagerel $unwind$product_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$product_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT product_dealloc
_TEXT	SEGMENT
lz$ = 48
product_dealloc PROC					; COMDAT

; 2051 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2052 :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN9@product_de:

; 2053 :     Py_XDECREF(lz->pools);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN6@product_de
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@product_de:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN9@product_de
$LN5@product_de:

; 2054 :     Py_XDECREF(lz->result);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0003d	74 0e		 je	 SHORT $LN2@product_de
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@product_de:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN5@product_de

; 2055 :     if (lz->indices != NULL)

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00058	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0005d	74 0e		 je	 SHORT $LN1@product_de

; 2056 :         PyMem_Free(lz->indices);

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00064	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00068	e8 00 00 00 00	 call	 PyMem_Free
$LN1@product_de:

; 2057 :     Py_TYPE(lz)->tp_free(lz);

  0006d	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00072	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0007b	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 2058 : }

  00081	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00085	c3		 ret	 0
product_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@BKAPCJKE@product_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$product_traverse DD imagerel product_traverse
	DD	imagerel product_traverse+206
	DD	imagerel $unwind$product_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$product_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BB@BKAPCJKE@product_traverse?$AA@
CONST	SEGMENT
??_C@_0BB@BKAPCJKE@product_traverse?$AA@ DB 'product_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT product_traverse
_TEXT	SEGMENT
vret$22228 = 32
vret$22236 = 36
lz$ = 64
visit$ = 72
arg$ = 80
product_traverse PROC					; COMDAT

; 2062 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@product_tr:

; 2063 :     Py_VISIT(lz->pools);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@product_tr
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 0f 08 00
	00		 mov	 r8d, 2063		; 0000080fH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@BKAPCJKE@product_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@product_tr:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN8@product_tr
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$22228[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$22228[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@product_tr
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$22228[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@product_tr
$LN7@product_tr:
$LN8@product_tr:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@product_tr
$LN6@product_tr:

; 2064 :     Py_VISIT(lz->result);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@product_tr
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 10 08 00
	00		 mov	 r8d, 2064		; 00000810H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@BKAPCJKE@product_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@product_tr:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00097	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0009c	74 23		 je	 SHORT $LN2@product_tr
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000a8	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$22236[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$22236[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@product_tr
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$22236[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@product_tr
$LN1@product_tr:
$LN2@product_tr:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@product_tr

; 2065 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@product_tr:

; 2066 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
product_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EI@GPCLHHFK@?$AAn?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?$DN?$AA?$DN?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AA_?$AAR?$AAE?$AAF?$AAC?$AAN?$AAT?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$product_next DD imagerel product_next
	DD	imagerel product_next+848
	DD	imagerel $unwind$product_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$product_next DD 010901H
	DD	0e209H
xdata	ENDS
;	COMDAT ??_C@_1EI@GPCLHHFK@?$AAn?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?$DN?$AA?$DN?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AA_?$AAR?$AAE?$AAF?$AAC?$AAN?$AAT?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN@
CONST	SEGMENT
??_C@_1EI@GPCLHHFK@?$AAn?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?$DN?$AA?$DN?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AA_?$AAR?$AAE?$AAF?$AAC?$AAN?$AAT?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN@ DB 'n'
	DB	00H, 'p', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '=', 00H
	DB	'=', 00H, '0', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, 'P'
	DB	00H, 'y', 00H, '_', 00H, 'R', 00H, 'E', 00H, 'F', 00H, 'C', 00H
	DB	'N', 00H, 'T', 00H, '(', 00H, 'r', 00H, 'e', 00H, 's', 00H, 'u'
	DB	00H, 'l', 00H, 't', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, '1', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT product_next
_TEXT	SEGMENT
elem$ = 32
i$ = 40
oldelem$ = 48
pools$ = 56
npools$ = 64
result$ = 72
pool$ = 80
indices$22268 = 88
old_result$22271 = 96
lz$ = 128
product_next PROC					; COMDAT

; 2070 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2071 :     PyObject *pool;
; 2072 :     PyObject *elem;
; 2073 :     PyObject *oldelem;
; 2074 :     PyObject *pools = lz->pools;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00011	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00015	48 89 44 24 38	 mov	 QWORD PTR pools$[rsp], rax

; 2075 :     PyObject *result = lz->result;

  0001a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00022	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00026	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 2076 :     Py_ssize_t npools = PyTuple_GET_SIZE(pools);

  0002b	48 8b 44 24 38	 mov	 rax, QWORD PTR pools$[rsp]
  00030	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00034	48 89 44 24 40	 mov	 QWORD PTR npools$[rsp], rax

; 2077 :     Py_ssize_t i;
; 2078 : 
; 2079 :     if (lz->stopped)

  00039	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00041	83 78 78 00	 cmp	 DWORD PTR [rax+120], 0
  00045	74 07		 je	 SHORT $LN19@product_ne@2

; 2080 :         return NULL;

  00047	33 c0		 xor	 eax, eax
  00049	e9 fd 02 00 00	 jmp	 $LN20@product_ne@2
$LN19@product_ne@2:

; 2081 : 
; 2082 :     if (result == NULL) {

  0004e	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  00054	0f 85 a9 00 00
	00		 jne	 $LN18@product_ne@2

; 2083 :         /* On the first pass, return an initial tuple filled with the
; 2084 :            first element from each pool. */
; 2085 :         result = PyTuple_New(npools);

  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR npools$[rsp]
  0005f	e8 00 00 00 00	 call	 PyTuple_New
  00064	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 2086 :         if (result == NULL)

  00069	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  0006f	75 05		 jne	 SHORT $LN17@product_ne@2

; 2087 :             goto empty;

  00071	e9 c4 02 00 00	 jmp	 $empty$22257
$LN17@product_ne@2:

; 2088 :         lz->result = result;

  00076	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0007e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00083	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2089 :         for (i=0; i < npools; i++) {

  00087	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00090	eb 0d		 jmp	 SHORT $LN16@product_ne@2
$LN15@product_ne@2:
  00092	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00097	48 ff c0	 inc	 rax
  0009a	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN16@product_ne@2:
  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR npools$[rsp]
  000a4	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000a9	7d 53		 jge	 SHORT $LN14@product_ne@2

; 2090 :             pool = PyTuple_GET_ITEM(pools, i);

  000ab	48 8b 44 24 38	 mov	 rax, QWORD PTR pools$[rsp]
  000b0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000b5	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  000ba	48 89 44 24 50	 mov	 QWORD PTR pool$[rsp], rax

; 2091 :             if (PyTuple_GET_SIZE(pool) == 0)

  000bf	48 8b 44 24 50	 mov	 rax, QWORD PTR pool$[rsp]
  000c4	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000c9	75 05		 jne	 SHORT $LN13@product_ne@2

; 2092 :                 goto empty;

  000cb	e9 6a 02 00 00	 jmp	 $empty$22257
$LN13@product_ne@2:

; 2093 :             elem = PyTuple_GET_ITEM(pool, 0);

  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR pool$[rsp]
  000d5	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000d9	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 2094 :             Py_INCREF(elem);

  000de	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  000e3	e8 00 00 00 00	 call	 _Py_IncRef

; 2095 :             PyTuple_SET_ITEM(result, i, elem);

  000e8	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  000ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000f2	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  000f7	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2096 :         }

  000fc	eb 94		 jmp	 SHORT $LN15@product_ne@2
$LN14@product_ne@2:

; 2097 :     } else {

  000fe	e9 26 02 00 00	 jmp	 $LN12@product_ne@2
$LN18@product_ne@2:

; 2098 :         Py_ssize_t *indices = lz->indices;

  00103	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0010b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010f	48 89 44 24 58	 mov	 QWORD PTR indices$22268[rsp], rax

; 2099 : 
; 2100 :         /* Copy the previous result tuple or re-use it if available */
; 2101 :         if (Py_REFCNT(result) > 1) {

  00114	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00119	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  0011e	0f 8e 99 00 00
	00		 jle	 $LN11@product_ne@2

; 2102 :             PyObject *old_result = result;

  00124	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00129	48 89 44 24 60	 mov	 QWORD PTR old_result$22271[rsp], rax

; 2103 :             result = PyTuple_New(npools);

  0012e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR npools$[rsp]
  00133	e8 00 00 00 00	 call	 PyTuple_New
  00138	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 2104 :             if (result == NULL)

  0013d	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  00143	75 05		 jne	 SHORT $LN10@product_ne@2

; 2105 :                 goto empty;

  00145	e9 f0 01 00 00	 jmp	 $empty$22257
$LN10@product_ne@2:

; 2106 :             lz->result = result;

  0014a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00152	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00157	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2107 :             for (i=0; i < npools; i++) {

  0015b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00164	eb 0d		 jmp	 SHORT $LN9@product_ne@2
$LN8@product_ne@2:
  00166	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0016b	48 ff c0	 inc	 rax
  0016e	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN9@product_ne@2:
  00173	48 8b 44 24 40	 mov	 rax, QWORD PTR npools$[rsp]
  00178	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  0017d	7d 34		 jge	 SHORT $LN7@product_ne@2

; 2108 :                 elem = PyTuple_GET_ITEM(old_result, i);

  0017f	48 8b 44 24 60	 mov	 rax, QWORD PTR old_result$22271[rsp]
  00184	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00189	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  0018e	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 2109 :                 Py_INCREF(elem);

  00193	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  00198	e8 00 00 00 00	 call	 _Py_IncRef

; 2110 :                 PyTuple_SET_ITEM(result, i, elem);

  0019d	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  001a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  001a7	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  001ac	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2111 :             }

  001b1	eb b3		 jmp	 SHORT $LN8@product_ne@2
$LN7@product_ne@2:

; 2112 :             Py_DECREF(old_result);

  001b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR old_result$22271[rsp]
  001b8	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@product_ne@2:

; 2113 :         }
; 2114 :         /* Now, we've got the only copy so we can update it in-place */
; 2115 :         assert (npools==0 || Py_REFCNT(result) == 1);

  001bd	48 83 7c 24 40
	00		 cmp	 QWORD PTR npools$[rsp], 0
  001c3	74 28		 je	 SHORT $LN22@product_ne@2
  001c5	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  001ca	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  001cf	74 1c		 je	 SHORT $LN22@product_ne@2
  001d1	41 b8 43 08 00
	00		 mov	 r8d, 2115		; 00000843H
  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EI@GPCLHHFK@?$AAn?$AAp?$AAo?$AAo?$AAl?$AAs?$AA?$DN?$AA?$DN?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AA_?$AAR?$AAE?$AAF?$AAC?$AAN?$AAT?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN@
  001e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001eb	33 c0		 xor	 eax, eax
$LN22@product_ne@2:

; 2116 : 
; 2117 :         /* Update the pool indices right-to-left.  Only advance to the
; 2118 :            next pool when the previous one rolls-over */
; 2119 :         for (i=npools-1 ; i >= 0 ; i--) {

  001ed	48 8b 44 24 40	 mov	 rax, QWORD PTR npools$[rsp]
  001f2	48 ff c8	 dec	 rax
  001f5	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  001fa	eb 0d		 jmp	 SHORT $LN6@product_ne@2
$LN5@product_ne@2:
  001fc	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00201	48 ff c8	 dec	 rax
  00204	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN6@product_ne@2:
  00209	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  0020f	0f 8c 0a 01 00
	00		 jl	 $LN4@product_ne@2

; 2120 :             pool = PyTuple_GET_ITEM(pools, i);

  00215	48 8b 44 24 38	 mov	 rax, QWORD PTR pools$[rsp]
  0021a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0021f	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00224	48 89 44 24 50	 mov	 QWORD PTR pool$[rsp], rax

; 2121 :             indices[i]++;

  00229	48 8b 44 24 58	 mov	 rax, QWORD PTR indices$22268[rsp]
  0022e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00233	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00237	48 ff c0	 inc	 rax
  0023a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR indices$22268[rsp]
  0023f	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00244	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 2122 :             if (indices[i] == PyTuple_GET_SIZE(pool)) {

  00248	48 8b 44 24 58	 mov	 rax, QWORD PTR indices$22268[rsp]
  0024d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00252	48 8b 54 24 50	 mov	 rdx, QWORD PTR pool$[rsp]
  00257	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  0025b	48 39 14 c8	 cmp	 QWORD PTR [rax+rcx*8], rdx
  0025f	75 5e		 jne	 SHORT $LN3@product_ne@2

; 2123 :                 /* Roll-over and advance to next pool */
; 2124 :                 indices[i] = 0;

  00261	48 8b 44 24 58	 mov	 rax, QWORD PTR indices$22268[rsp]
  00266	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0026b	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0

; 2125 :                 elem = PyTuple_GET_ITEM(pool, 0);

  00273	48 8b 44 24 50	 mov	 rax, QWORD PTR pool$[rsp]
  00278	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0027c	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 2126 :                 Py_INCREF(elem);

  00281	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  00286	e8 00 00 00 00	 call	 _Py_IncRef

; 2127 :                 oldelem = PyTuple_GET_ITEM(result, i);

  0028b	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00290	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00295	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  0029a	48 89 44 24 30	 mov	 QWORD PTR oldelem$[rsp], rax

; 2128 :                 PyTuple_SET_ITEM(result, i, elem);

  0029f	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  002a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  002a9	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  002ae	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2129 :                 Py_DECREF(oldelem);

  002b3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR oldelem$[rsp]
  002b8	e8 00 00 00 00	 call	 _Py_DecRef

; 2130 :             } else {

  002bd	eb 5b		 jmp	 SHORT $LN2@product_ne@2
$LN3@product_ne@2:

; 2131 :                 /* No rollover. Just increment and stop here. */
; 2132 :                 elem = PyTuple_GET_ITEM(pool, indices[i]);

  002bf	48 8b 44 24 58	 mov	 rax, QWORD PTR indices$22268[rsp]
  002c4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  002c9	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  002cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pool$[rsp]
  002d2	48 8b 44 c1 70	 mov	 rax, QWORD PTR [rcx+rax*8+112]
  002d7	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 2133 :                 Py_INCREF(elem);

  002dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  002e1	e8 00 00 00 00	 call	 _Py_IncRef

; 2134 :                 oldelem = PyTuple_GET_ITEM(result, i);

  002e6	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  002eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  002f0	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  002f5	48 89 44 24 30	 mov	 QWORD PTR oldelem$[rsp], rax

; 2135 :                 PyTuple_SET_ITEM(result, i, elem);

  002fa	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  002ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00304	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  00309	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2136 :                 Py_DECREF(oldelem);

  0030e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR oldelem$[rsp]
  00313	e8 00 00 00 00	 call	 _Py_DecRef

; 2137 :                 break;

  00318	eb 05		 jmp	 SHORT $LN4@product_ne@2
$LN2@product_ne@2:

; 2138 :             }
; 2139 :         }

  0031a	e9 dd fe ff ff	 jmp	 $LN5@product_ne@2
$LN4@product_ne@2:

; 2140 : 
; 2141 :         /* If i is negative, then the indices have all rolled-over
; 2142 :            and we're done. */
; 2143 :         if (i < 0)

  0031f	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00325	7d 02		 jge	 SHORT $LN1@product_ne@2

; 2144 :             goto empty;

  00327	eb 11		 jmp	 SHORT $empty$22257
$LN1@product_ne@2:
$LN12@product_ne@2:

; 2145 :     }
; 2146 : 
; 2147 :     Py_INCREF(result);

  00329	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  0032e	e8 00 00 00 00	 call	 _Py_IncRef

; 2148 :     return result;

  00333	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00338	eb 11		 jmp	 SHORT $LN20@product_ne@2
$empty$22257:

; 2149 : 
; 2150 : empty:
; 2151 :     lz->stopped = 1;

  0033a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00342	c7 40 78 01 00
	00 00		 mov	 DWORD PTR [rax+120], 1

; 2152 :     return NULL;

  00349	33 c0		 xor	 eax, eax
$LN20@product_ne@2:

; 2153 : }

  0034b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0034f	c3		 ret	 0
product_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_03IPAMAPO@OON?$AA@			; `string'
PUBLIC	??_C@_02MJJLPNK@OO?$AA@				; `string'
PUBLIC	??_C@_05FHNOOHHF@O?$CI?$CI?$CJ?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$product_reduce DD imagerel product_reduce
	DD	imagerel product_reduce+299
	DD	imagerel $unwind$product_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$product_reduce DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_03IPAMAPO@OON?$AA@
CONST	SEGMENT
??_C@_03IPAMAPO@OON?$AA@ DB 'OON', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MJJLPNK@OO?$AA@
CONST	SEGMENT
??_C@_02MJJLPNK@OO?$AA@ DB 'OO', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05FHNOOHHF@O?$CI?$CI?$CJ?$CJ?$AA@
CONST	SEGMENT
??_C@_05FHNOOHHF@O?$CI?$CI?$CJ?$CJ?$AA@ DB 'O(())', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT product_reduce
_TEXT	SEGMENT
i$22319 = 32
n$22318 = 40
indices$22317 = 48
index$22327 = 56
lz$ = 80
product_reduce PROC					; COMDAT

; 2157 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2158 :     if (lz->stopped) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	83 78 78 00	 cmp	 DWORD PTR [rax+120], 0
  00012	74 1f		 je	 SHORT $LN9@product_re

; 2159 :         return Py_BuildValue("O(())", Py_TYPE(lz));

  00014	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00019	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05FHNOOHHF@O?$CI?$CI?$CJ?$CJ?$AA@
  00024	e8 00 00 00 00	 call	 Py_BuildValue
  00029	e9 f8 00 00 00	 jmp	 $LN10@product_re
  0002e	e9 f3 00 00 00	 jmp	 $LN8@product_re
$LN9@product_re:

; 2160 :     } else if (lz->result == NULL) {

  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0003d	75 28		 jne	 SHORT $LN7@product_re

; 2161 :         return Py_BuildValue("OO", Py_TYPE(lz), lz->pools);

  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00044	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0004d	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02MJJLPNK@OO?$AA@
  00058	e8 00 00 00 00	 call	 Py_BuildValue
  0005d	e9 c4 00 00 00	 jmp	 $LN10@product_re

; 2162 :     } else {

  00062	e9 bf 00 00 00	 jmp	 $LN6@product_re
$LN7@product_re:

; 2163 :         PyObject *indices;
; 2164 :         Py_ssize_t n, i;
; 2165 : 
; 2166 :         /* we must pickle the indices use them for setstate, and
; 2167 :          * additionally indicate that the iterator has started
; 2168 :          */
; 2169 :         n = PyTuple_GET_SIZE(lz->pools);

  00067	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0006c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00070	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00074	48 89 44 24 28	 mov	 QWORD PTR n$22318[rsp], rax

; 2170 :         indices = PyTuple_New(n);

  00079	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$22318[rsp]
  0007e	e8 00 00 00 00	 call	 PyTuple_New
  00083	48 89 44 24 30	 mov	 QWORD PTR indices$22317[rsp], rax

; 2171 :         if (indices == NULL)

  00088	48 83 7c 24 30
	00		 cmp	 QWORD PTR indices$22317[rsp], 0
  0008e	75 07		 jne	 SHORT $LN5@product_re

; 2172 :             return NULL;

  00090	33 c0		 xor	 eax, eax
  00092	e9 8f 00 00 00	 jmp	 $LN10@product_re
$LN5@product_re:

; 2173 :         for (i=0; i<n; i++){

  00097	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$22319[rsp], 0
  000a0	eb 0d		 jmp	 SHORT $LN4@product_re
$LN3@product_re:
  000a2	48 8b 44 24 20	 mov	 rax, QWORD PTR i$22319[rsp]
  000a7	48 ff c0	 inc	 rax
  000aa	48 89 44 24 20	 mov	 QWORD PTR i$22319[rsp], rax
$LN4@product_re:
  000af	48 8b 44 24 28	 mov	 rax, QWORD PTR n$22318[rsp]
  000b4	48 39 44 24 20	 cmp	 QWORD PTR i$22319[rsp], rax
  000b9	7d 48		 jge	 SHORT $LN2@product_re

; 2174 :             PyObject* index = PyLong_FromSsize_t(lz->indices[i]);

  000bb	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  000c0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$22319[rsp]
  000c9	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  000cd	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  000d2	48 89 44 24 38	 mov	 QWORD PTR index$22327[rsp], rax

; 2175 :             if (!index) {

  000d7	48 83 7c 24 38
	00		 cmp	 QWORD PTR index$22327[rsp], 0
  000dd	75 0e		 jne	 SHORT $LN1@product_re

; 2176 :                 Py_DECREF(indices);

  000df	48 8b 4c 24 30	 mov	 rcx, QWORD PTR indices$22317[rsp]
  000e4	e8 00 00 00 00	 call	 _Py_DecRef

; 2177 :                 return NULL;

  000e9	33 c0		 xor	 eax, eax
  000eb	eb 39		 jmp	 SHORT $LN10@product_re
$LN1@product_re:

; 2178 :             }
; 2179 :             PyTuple_SET_ITEM(indices, i, index);

  000ed	48 8b 44 24 30	 mov	 rax, QWORD PTR indices$22317[rsp]
  000f2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$22319[rsp]
  000f7	48 8b 54 24 38	 mov	 rdx, QWORD PTR index$22327[rsp]
  000fc	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2180 :         }

  00101	eb 9f		 jmp	 SHORT $LN3@product_re
$LN2@product_re:

; 2181 :         return Py_BuildValue("OON", Py_TYPE(lz), lz->pools, indices);

  00103	4c 8b 4c 24 30	 mov	 r9, QWORD PTR indices$22317[rsp]
  00108	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0010d	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00111	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00116	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IPAMAPO@OON?$AA@
  00121	e8 00 00 00 00	 call	 Py_BuildValue
$LN6@product_re:
$LN8@product_re:
$LN10@product_re:

; 2182 :     }
; 2183 : }

  00126	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012a	c3		 ret	 0
product_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@HHFIAOED@product_setstate?$AA@	; `string'
PUBLIC	??_C@_0BC@KNPMEBHA@invalid?5arguments?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$product_setstate DD imagerel product_setstate
	DD	imagerel product_setstate+603
	DD	imagerel $unwind$product_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$product_setstate DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0BB@HHFIAOED@product_setstate?$AA@
CONST	SEGMENT
??_C@_0BB@HHFIAOED@product_setstate?$AA@ DB 'product_setstate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KNPMEBHA@invalid?5arguments?$AA@
CONST	SEGMENT
??_C@_0BC@KNPMEBHA@invalid?5arguments?$AA@ DB 'invalid arguments', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT product_setstate
_TEXT	SEGMENT
i$ = 48
n$ = 56
result$ = 64
index$22355 = 72
indexObject$22353 = 80
element$22368 = 88
pool$22366 = 96
_py_tmp$22377 = 104
lz$ = 128
state$ = 136
product_setstate PROC					; COMDAT

; 2187 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2188 :     PyObject *result;
; 2189 :     Py_ssize_t n, i;
; 2190 : 
; 2191 :     n = PyTuple_GET_SIZE(lz->pools);

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00016	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001e	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax

; 2192 :     if (!PyTuple_Check(state) || PyTuple_GET_SIZE(state) != n) {

  00023	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0003a	85 c0		 test	 eax, eax
  0003c	74 13		 je	 SHORT $LN16@product_se
  0003e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00046	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  0004b	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0004f	74 1a		 je	 SHORT $LN17@product_se
$LN16@product_se:

; 2193 :         PyErr_SetString(PyExc_ValueError, "invalid arguments");

  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@KNPMEBHA@invalid?5arguments?$AA@
  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0005f	e8 00 00 00 00	 call	 PyErr_SetString

; 2194 :         return NULL;

  00064	33 c0		 xor	 eax, eax
  00066	e9 eb 01 00 00	 jmp	 $LN18@product_se
$LN17@product_se:

; 2195 :     }
; 2196 :     for (i=0; i<n; i++)

  0006b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00074	eb 0d		 jmp	 SHORT $LN15@product_se
$LN14@product_se:
  00076	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0007b	48 ff c0	 inc	 rax
  0007e	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN15@product_se:
  00083	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  00088	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0008d	0f 8d 8d 00 00
	00		 jge	 $LN13@product_se

; 2197 :     {
; 2198 :         PyObject* indexObject = PyTuple_GET_ITEM(state, i);

  00093	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0009b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  000a0	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  000a5	48 89 44 24 50	 mov	 QWORD PTR indexObject$22353[rsp], rax

; 2199 :         Py_ssize_t index = PyLong_AsSsize_t(indexObject);

  000aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR indexObject$22353[rsp]
  000af	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000b4	48 89 44 24 48	 mov	 QWORD PTR index$22355[rsp], rax

; 2200 :         if (index < 0 && PyErr_Occurred())

  000b9	48 83 7c 24 48
	00		 cmp	 QWORD PTR index$22355[rsp], 0
  000bf	7d 11		 jge	 SHORT $LN12@product_se
  000c1	e8 00 00 00 00	 call	 PyErr_Occurred
  000c6	48 85 c0	 test	 rax, rax
  000c9	74 07		 je	 SHORT $LN12@product_se

; 2201 :             return NULL; /* not an integer */

  000cb	33 c0		 xor	 eax, eax
  000cd	e9 84 01 00 00	 jmp	 $LN18@product_se
$LN12@product_se:

; 2202 :         /* clamp the index */
; 2203 :         if (index < 0)

  000d2	48 83 7c 24 48
	00		 cmp	 QWORD PTR index$22355[rsp], 0
  000d8	7d 0b		 jge	 SHORT $LN11@product_se

; 2204 :             index = 0;

  000da	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR index$22355[rsp], 0
  000e3	eb 1c		 jmp	 SHORT $LN10@product_se
$LN11@product_se:

; 2205 :         else if (index > n-1)

  000e5	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  000ea	48 ff c8	 dec	 rax
  000ed	48 39 44 24 48	 cmp	 QWORD PTR index$22355[rsp], rax
  000f2	7e 0d		 jle	 SHORT $LN9@product_se

; 2206 :             index = n-1;

  000f4	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  000f9	48 ff c8	 dec	 rax
  000fc	48 89 44 24 48	 mov	 QWORD PTR index$22355[rsp], rax
$LN9@product_se:
$LN10@product_se:

; 2207 :         lz->indices[i] = index;

  00101	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00109	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00112	48 8b 54 24 48	 mov	 rdx, QWORD PTR index$22355[rsp]
  00117	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 2208 :     }

  0011b	e9 56 ff ff ff	 jmp	 $LN14@product_se
$LN13@product_se:

; 2209 : 
; 2210 :     result = PyTuple_New(n);

  00120	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  00125	e8 00 00 00 00	 call	 PyTuple_New
  0012a	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 2211 :     if (!result)

  0012f	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$[rsp], 0
  00135	75 07		 jne	 SHORT $LN8@product_se

; 2212 :         return NULL;

  00137	33 c0		 xor	 eax, eax
  00139	e9 18 01 00 00	 jmp	 $LN18@product_se
$LN8@product_se:

; 2213 :     for (i=0; i<n; i++) {

  0013e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00147	eb 0d		 jmp	 SHORT $LN7@product_se
$LN6@product_se:
  00149	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0014e	48 ff c0	 inc	 rax
  00151	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN7@product_se:
  00156	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  0015b	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00160	7d 5f		 jge	 SHORT $LN5@product_se

; 2214 :         PyObject *pool = PyTuple_GET_ITEM(lz->pools, i);

  00162	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0016a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0016e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00173	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00178	48 89 44 24 60	 mov	 QWORD PTR pool$22366[rsp], rax

; 2215 :         PyObject *element = PyTuple_GET_ITEM(pool, lz->indices[i]);

  0017d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00185	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00189	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0018e	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00192	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pool$22366[rsp]
  00197	48 8b 44 c1 70	 mov	 rax, QWORD PTR [rcx+rax*8+112]
  0019c	48 89 44 24 58	 mov	 QWORD PTR element$22368[rsp], rax

; 2216 :         Py_INCREF(element);

  001a1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR element$22368[rsp]
  001a6	e8 00 00 00 00	 call	 _Py_IncRef

; 2217 :         PyTuple_SET_ITEM(result, i, element);

  001ab	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  001b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  001b5	48 8b 54 24 58	 mov	 rdx, QWORD PTR element$22368[rsp]
  001ba	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2218 :     }

  001bf	eb 88		 jmp	 SHORT $LN6@product_se
$LN5@product_se:
$LN4@product_se:

; 2219 :     Py_CLEAR(lz->result);

  001c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  001c9	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  001ce	74 5c		 je	 SHORT $LN1@product_se
  001d0	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001d8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  001e0	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  001e4	41 b8 ab 08 00
	00		 mov	 r8d, 2219		; 000008abH
  001ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  001f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@HHFIAOED@product_setstate?$AA@
  001f8	e8 00 00 00 00	 call	 _PyParallel_Guard
  001fd	85 c0		 test	 eax, eax
  001ff	75 2b		 jne	 SHORT $LN1@product_se
  00201	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00209	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0020d	48 89 44 24 68	 mov	 QWORD PTR _py_tmp$22377[rsp], rax
  00212	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0021a	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
  00222	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _py_tmp$22377[rsp]
  00227	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@product_se:
  0022c	33 c0		 xor	 eax, eax
  0022e	85 c0		 test	 eax, eax
  00230	75 8f		 jne	 SHORT $LN4@product_se

; 2220 :     lz->result = result;

  00232	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0023a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  0023f	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2221 :     Py_RETURN_NONE;

  00243	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0024a	e8 00 00 00 00	 call	 _Py_IncRef
  0024f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN18@product_se:

; 2222 : }

  00256	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0025a	c3		 ret	 0
product_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@GBDHCGGF@r?5must?5be?5non?9negative?$AA@ ; `string'
PUBLIC	??_C@_0BA@PLDOBPMO@On?3combinations?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$combinations_new DD imagerel combinations_new
	DD	imagerel combinations_new+478
	DD	imagerel $unwind$combinations_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$combinations_new DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_0BH@GBDHCGGF@r?5must?5be?5non?9negative?$AA@
CONST	SEGMENT
??_C@_0BH@GBDHCGGF@r?5must?5be?5non?9negative?$AA@ DB 'r must be non-nega'
	DB	'tive', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PLDOBPMO@On?3combinations?$AA@
CONST	SEGMENT
??_C@_0BA@PLDOBPMO@On?3combinations?$AA@ DB 'On:combinations', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT combinations_new
_TEXT	SEGMENT
i$ = 48
n$ = 56
indices$ = 64
co$ = 72
iterable$ = 80
r$ = 88
pool$ = 96
tv130 = 104
type$ = 128
args$ = 136
kwds$ = 144
combinations_new PROC					; COMDAT

; 2306 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2307 :     combinationsobject *co;
; 2308 :     Py_ssize_t n;
; 2309 :     Py_ssize_t r;
; 2310 :     PyObject *pool = NULL;

  00013	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR pool$[rsp], 0

; 2311 :     PyObject *iterable = NULL;

  0001c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR iterable$[rsp], 0

; 2312 :     Py_ssize_t *indices = NULL;

  00025	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR indices$[rsp], 0

; 2313 :     Py_ssize_t i;
; 2314 :     static char *kwargs[] = {"iterable", "r", NULL};
; 2315 : 
; 2316 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "On:combinations", kwargs,
; 2317 :                                      &iterable, &r))

  0002e	48 8d 44 24 58	 lea	 rax, QWORD PTR r$[rsp]
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 44 24 50	 lea	 rax, QWORD PTR iterable$[rsp]
  0003d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00042	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwargs@?1??combinations_new@@9@9
  00049	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BA@PLDOBPMO@On?3combinations?$AA@
  00050	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00058	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00060	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00065	85 c0		 test	 eax, eax
  00067	75 07		 jne	 SHORT $LN13@combinatio

; 2318 :         return NULL;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 69 01 00 00	 jmp	 $LN14@combinatio
$LN13@combinatio:

; 2319 : 
; 2320 :     pool = PySequence_Tuple(iterable);

  00070	48 8b 4c 24 50	 mov	 rcx, QWORD PTR iterable$[rsp]
  00075	e8 00 00 00 00	 call	 PySequence_Tuple
  0007a	48 89 44 24 60	 mov	 QWORD PTR pool$[rsp], rax

; 2321 :     if (pool == NULL)

  0007f	48 83 7c 24 60
	00		 cmp	 QWORD PTR pool$[rsp], 0
  00085	75 05		 jne	 SHORT $LN12@combinatio

; 2322 :         goto error;

  00087	e9 21 01 00 00	 jmp	 $error$22442
$LN12@combinatio:

; 2323 :     n = PyTuple_GET_SIZE(pool);

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR pool$[rsp]
  00091	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00095	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax

; 2324 :     if (r < 0) {

  0009a	48 83 7c 24 58
	00		 cmp	 QWORD PTR r$[rsp], 0
  000a0	7d 18		 jge	 SHORT $LN11@combinatio

; 2325 :         PyErr_SetString(PyExc_ValueError, "r must be non-negative");

  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@GBDHCGGF@r?5must?5be?5non?9negative?$AA@
  000a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000b0	e8 00 00 00 00	 call	 PyErr_SetString

; 2326 :         goto error;

  000b5	e9 f3 00 00 00	 jmp	 $error$22442
$LN11@combinatio:

; 2327 :     }
; 2328 : 
; 2329 :     indices = PyMem_Malloc(r * sizeof(Py_ssize_t));

  000ba	48 8b 44 24 58	 mov	 rax, QWORD PTR r$[rsp]
  000bf	48 c1 e0 03	 shl	 rax, 3
  000c3	48 8b c8	 mov	 rcx, rax
  000c6	e8 00 00 00 00	 call	 PyMem_Malloc
  000cb	48 89 44 24 40	 mov	 QWORD PTR indices$[rsp], rax

; 2330 :     if (indices == NULL) {

  000d0	48 83 7c 24 40
	00		 cmp	 QWORD PTR indices$[rsp], 0
  000d6	75 0a		 jne	 SHORT $LN10@combinatio

; 2331 :         PyErr_NoMemory();

  000d8	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2332 :         goto error;

  000dd	e9 cb 00 00 00	 jmp	 $error$22442
$LN10@combinatio:

; 2333 :     }
; 2334 : 
; 2335 :     for (i=0 ; i<r ; i++)

  000e2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000eb	eb 0d		 jmp	 SHORT $LN9@combinatio
$LN8@combinatio:
  000ed	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000f2	48 ff c0	 inc	 rax
  000f5	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN9@combinatio:
  000fa	48 8b 44 24 58	 mov	 rax, QWORD PTR r$[rsp]
  000ff	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00104	7d 15		 jge	 SHORT $LN7@combinatio

; 2336 :         indices[i] = i;

  00106	48 8b 44 24 40	 mov	 rax, QWORD PTR indices$[rsp]
  0010b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00110	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  00115	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  00119	eb d2		 jmp	 SHORT $LN8@combinatio
$LN7@combinatio:

; 2337 : 
; 2338 :     /* create combinationsobject structure */
; 2339 :     co = (combinationsobject *)type->tp_alloc(type, 0);

  0011b	33 d2		 xor	 edx, edx
  0011d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  00125	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  0012d	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00133	48 89 44 24 48	 mov	 QWORD PTR co$[rsp], rax

; 2340 :     if (co == NULL)

  00138	48 83 7c 24 48
	00		 cmp	 QWORD PTR co$[rsp], 0
  0013e	75 02		 jne	 SHORT $LN6@combinatio

; 2341 :         goto error;

  00140	eb 6b		 jmp	 SHORT $error$22442
$LN6@combinatio:

; 2342 : 
; 2343 :     co->pool = pool;

  00142	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  00147	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pool$[rsp]
  0014c	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 2344 :     co->indices = indices;

  00150	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  00155	48 8b 4c 24 40	 mov	 rcx, QWORD PTR indices$[rsp]
  0015a	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 2345 :     co->result = NULL;

  0015e	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  00163	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 2346 :     co->r = r;

  0016b	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  00170	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$[rsp]
  00175	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 2347 :     co->stopped = r > n ? 1 : 0;

  00179	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  0017e	48 39 44 24 58	 cmp	 QWORD PTR r$[rsp], rax
  00183	7e 0a		 jle	 SHORT $LN16@combinatio
  00185	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  0018d	eb 08		 jmp	 SHORT $LN17@combinatio
$LN16@combinatio:
  0018f	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN17@combinatio:
  00197	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  0019c	8b 4c 24 68	 mov	 ecx, DWORD PTR tv130[rsp]
  001a0	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx

; 2348 : 
; 2349 :     return (PyObject *)co;

  001a6	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  001ab	eb 2c		 jmp	 SHORT $LN14@combinatio
$error$22442:

; 2350 : 
; 2351 : error:
; 2352 :     if (indices != NULL)

  001ad	48 83 7c 24 40
	00		 cmp	 QWORD PTR indices$[rsp], 0
  001b3	74 0a		 je	 SHORT $LN5@combinatio

; 2353 :         PyMem_Free(indices);

  001b5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR indices$[rsp]
  001ba	e8 00 00 00 00	 call	 PyMem_Free
$LN5@combinatio:
$LN4@combinatio:

; 2354 :     Py_XDECREF(pool);

  001bf	48 83 7c 24 60
	00		 cmp	 QWORD PTR pool$[rsp], 0
  001c5	74 0a		 je	 SHORT $LN1@combinatio
  001c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pool$[rsp]
  001cc	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@combinatio:
  001d1	33 c0		 xor	 eax, eax
  001d3	85 c0		 test	 eax, eax
  001d5	75 e8		 jne	 SHORT $LN4@combinatio

; 2355 :     return NULL;

  001d7	33 c0		 xor	 eax, eax
$LN14@combinatio:

; 2356 : }

  001d9	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001dd	c3		 ret	 0
combinations_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$combinations_dealloc DD imagerel combinations_dealloc
	DD	imagerel combinations_dealloc+134
	DD	imagerel $unwind$combinations_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$combinations_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT combinations_dealloc
_TEXT	SEGMENT
co$ = 48
combinations_dealloc PROC				; COMDAT

; 2360 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2361 :     PyObject_GC_UnTrack(co);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR co$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN9@combinatio@2:

; 2362 :     Py_XDECREF(co->pool);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN6@combinatio@2
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@combinatio@2:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN9@combinatio@2
$LN5@combinatio@2:

; 2363 :     Py_XDECREF(co->result);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00038	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0003d	74 0e		 je	 SHORT $LN2@combinatio@2
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00044	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@combinatio@2:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN5@combinatio@2

; 2364 :     if (co->indices != NULL)

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00058	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0005d	74 0e		 je	 SHORT $LN1@combinatio@2

; 2365 :         PyMem_Free(co->indices);

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00064	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00068	e8 00 00 00 00	 call	 PyMem_Free
$LN1@combinatio@2:

; 2366 :     Py_TYPE(co)->tp_free(co);

  0006d	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00072	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR co$[rsp]
  0007b	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 2367 : }

  00081	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00085	c3		 ret	 0
combinations_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@DLMDFOIG@combinations_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$combinations_traverse DD imagerel combinations_traverse
	DD	imagerel combinations_traverse+206
	DD	imagerel $unwind$combinations_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$combinations_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BG@DLMDFOIG@combinations_traverse?$AA@
CONST	SEGMENT
??_C@_0BG@DLMDFOIG@combinations_traverse?$AA@ DB 'combinations_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT combinations_traverse
_TEXT	SEGMENT
vret$22496 = 32
vret$22504 = 36
co$ = 64
visit$ = 72
arg$ = 80
combinations_traverse PROC				; COMDAT

; 2371 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@combinatio@3:

; 2372 :     Py_VISIT(co->pool);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@combinatio@3
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 44 09 00
	00		 mov	 r8d, 2372		; 00000944H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@DLMDFOIG@combinations_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@combinatio@3:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR co$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN8@combinatio@3
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR co$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$22496[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$22496[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@combinatio@3
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$22496[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@combinatio@3
$LN7@combinatio@3:
$LN8@combinatio@3:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@combinatio@3
$LN6@combinatio@3:

; 2373 :     Py_VISIT(co->result);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@combinatio@3
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 45 09 00
	00		 mov	 r8d, 2373		; 00000945H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@DLMDFOIG@combinations_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@combinatio@3:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR co$[rsp]
  00097	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0009c	74 23		 je	 SHORT $LN2@combinatio@3
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR co$[rsp]
  000a8	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$22504[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$22504[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@combinatio@3
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$22504[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@combinatio@3
$LN1@combinatio@3:
$LN2@combinatio@3:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@combinatio@3

; 2374 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@combinatio@3:

; 2375 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
combinations_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EC@JPBKELHI@?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AA_?$AAR?$AAE?$AAF?$AAC?$AAN?$AAT?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$combinations_next DD imagerel combinations_next
	DD	imagerel combinations_next+870
	DD	imagerel $unwind$combinations_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$combinations_next DD 020c01H
	DD	011010cH
xdata	ENDS
;	COMDAT ??_C@_1EC@JPBKELHI@?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AA_?$AAR?$AAE?$AAF?$AAC?$AAN?$AAT?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1@
CONST	SEGMENT
??_C@_1EC@JPBKELHI@?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AA_?$AAR?$AAE?$AAF?$AAC?$AAN?$AAT?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1@ DB 'r'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H
	DB	'|', 00H, '|', 00H, ' ', 00H, 'P', 00H, 'y', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'F', 00H, 'C', 00H, 'N', 00H, 'T', 00H, '(', 00H
	DB	'r', 00H, 'e', 00H, 's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT combinations_next
_TEXT	SEGMENT
elem$ = 32
i$ = 40
n$ = 48
oldelem$ = 56
index$ = 64
indices$ = 72
r$ = 80
result$ = 88
j$ = 96
pool$ = 104
old_result$22538 = 112
co$ = 144
combinations_next PROC					; COMDAT

; 2379 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2380 :     PyObject *elem;
; 2381 :     PyObject *oldelem;
; 2382 :     PyObject *pool = co->pool;

  0000c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00014	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00018	48 89 44 24 68	 mov	 QWORD PTR pool$[rsp], rax

; 2383 :     Py_ssize_t *indices = co->indices;

  0001d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00025	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00029	48 89 44 24 48	 mov	 QWORD PTR indices$[rsp], rax

; 2384 :     PyObject *result = co->result;

  0002e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00036	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0003a	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 2385 :     Py_ssize_t n = PyTuple_GET_SIZE(pool);

  0003f	48 8b 44 24 68	 mov	 rax, QWORD PTR pool$[rsp]
  00044	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00048	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 2386 :     Py_ssize_t r = co->r;

  0004d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00055	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00059	48 89 44 24 50	 mov	 QWORD PTR r$[rsp], rax

; 2387 :     Py_ssize_t i, j, index;
; 2388 : 
; 2389 :     if (co->stopped)

  0005e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00066	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [rax+128], 0
  0006d	74 07		 je	 SHORT $LN22@combinatio@4

; 2390 :         return NULL;

  0006f	33 c0		 xor	 eax, eax
  00071	e9 e8 02 00 00	 jmp	 $LN23@combinatio@4
$LN22@combinatio@4:

; 2391 : 
; 2392 :     if (result == NULL) {

  00076	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  0007c	0f 85 9d 00 00
	00		 jne	 $LN21@combinatio@4

; 2393 :         /* On the first pass, initialize result tuple using the indices */
; 2394 :         result = PyTuple_New(r);

  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$[rsp]
  00087	e8 00 00 00 00	 call	 PyTuple_New
  0008c	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 2395 :         if (result == NULL)

  00091	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  00097	75 05		 jne	 SHORT $LN20@combinatio@4

; 2396 :             goto empty;

  00099	e9 ac 02 00 00	 jmp	 $empty$22528
$LN20@combinatio@4:

; 2397 :         co->result = result;

  0009e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  000a6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  000ab	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2398 :         for (i=0; i<r ; i++) {

  000af	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000b8	eb 0d		 jmp	 SHORT $LN19@combinatio@4
$LN18@combinatio@4:
  000ba	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000bf	48 ff c0	 inc	 rax
  000c2	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN19@combinatio@4:
  000c7	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  000cc	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000d1	7d 47		 jge	 SHORT $LN17@combinatio@4

; 2399 :             index = indices[i];

  000d3	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  000d8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000dd	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000e1	48 89 44 24 40	 mov	 QWORD PTR index$[rsp], rax

; 2400 :             elem = PyTuple_GET_ITEM(pool, index);

  000e6	48 8b 44 24 68	 mov	 rax, QWORD PTR pool$[rsp]
  000eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR index$[rsp]
  000f0	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  000f5	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 2401 :             Py_INCREF(elem);

  000fa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  000ff	e8 00 00 00 00	 call	 _Py_IncRef

; 2402 :             PyTuple_SET_ITEM(result, i, elem);

  00104	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00109	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0010e	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  00113	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2403 :         }

  00118	eb a0		 jmp	 SHORT $LN18@combinatio@4
$LN17@combinatio@4:

; 2404 :     } else {

  0011a	e9 1a 02 00 00	 jmp	 $LN16@combinatio@4
$LN21@combinatio@4:

; 2405 :         /* Copy the previous result tuple or re-use it if available */
; 2406 :         if (Py_REFCNT(result) > 1) {

  0011f	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00124	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  00129	0f 8e 99 00 00
	00		 jle	 $LN15@combinatio@4

; 2407 :             PyObject *old_result = result;

  0012f	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00134	48 89 44 24 70	 mov	 QWORD PTR old_result$22538[rsp], rax

; 2408 :             result = PyTuple_New(r);

  00139	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$[rsp]
  0013e	e8 00 00 00 00	 call	 PyTuple_New
  00143	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 2409 :             if (result == NULL)

  00148	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  0014e	75 05		 jne	 SHORT $LN14@combinatio@4

; 2410 :                 goto empty;

  00150	e9 f5 01 00 00	 jmp	 $empty$22528
$LN14@combinatio@4:

; 2411 :             co->result = result;

  00155	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  0015d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  00162	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2412 :             for (i=0; i<r ; i++) {

  00166	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0016f	eb 0d		 jmp	 SHORT $LN13@combinatio@4
$LN12@combinatio@4:
  00171	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00176	48 ff c0	 inc	 rax
  00179	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN13@combinatio@4:
  0017e	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  00183	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00188	7d 34		 jge	 SHORT $LN11@combinatio@4

; 2413 :                 elem = PyTuple_GET_ITEM(old_result, i);

  0018a	48 8b 44 24 70	 mov	 rax, QWORD PTR old_result$22538[rsp]
  0018f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00194	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00199	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 2414 :                 Py_INCREF(elem);

  0019e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  001a3	e8 00 00 00 00	 call	 _Py_IncRef

; 2415 :                 PyTuple_SET_ITEM(result, i, elem);

  001a8	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  001b2	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  001b7	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2416 :             }

  001bc	eb b3		 jmp	 SHORT $LN12@combinatio@4
$LN11@combinatio@4:

; 2417 :             Py_DECREF(old_result);

  001be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR old_result$22538[rsp]
  001c3	e8 00 00 00 00	 call	 _Py_DecRef
$LN15@combinatio@4:

; 2418 :         }
; 2419 :         /* Now, we've got the only copy so we can update it in-place
; 2420 :          * CPython's empty tuple is a singleton and cached in
; 2421 :          * PyTuple's freelist.
; 2422 :          */
; 2423 :         assert(r == 0 || Py_REFCNT(result) == 1);

  001c8	48 83 7c 24 50
	00		 cmp	 QWORD PTR r$[rsp], 0
  001ce	74 28		 je	 SHORT $LN25@combinatio@4
  001d0	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001d5	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  001da	74 1c		 je	 SHORT $LN25@combinatio@4
  001dc	41 b8 77 09 00
	00		 mov	 r8d, 2423		; 00000977H
  001e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@JPBKELHI@?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AA_?$AAR?$AAE?$AAF?$AAC?$AAN?$AAT?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1@
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001f6	33 c0		 xor	 eax, eax
$LN25@combinatio@4:

; 2424 : 
; 2425 :         /* Scan indices right-to-left until finding one that is not
; 2426 :            at its maximum (i + n - r). */
; 2427 :         for (i=r-1 ; i >= 0 && indices[i] == i+n-r ; i--)

  001f8	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  001fd	48 ff c8	 dec	 rax
  00200	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00205	eb 0d		 jmp	 SHORT $LN10@combinatio@4
$LN9@combinatio@4:
  00207	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0020c	48 ff c8	 dec	 rax
  0020f	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN10@combinatio@4:
  00214	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  0021a	7c 27		 jl	 SHORT $LN8@combinatio@4
  0021c	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00221	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00226	48 03 c8	 add	 rcx, rax
  00229	48 8b c1	 mov	 rax, rcx
  0022c	48 2b 44 24 50	 sub	 rax, QWORD PTR r$[rsp]
  00231	48 8b 4c 24 48	 mov	 rcx, QWORD PTR indices$[rsp]
  00236	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  0023b	48 39 04 d1	 cmp	 QWORD PTR [rcx+rdx*8], rax
  0023f	75 02		 jne	 SHORT $LN8@combinatio@4

; 2428 :             ;

  00241	eb c4		 jmp	 SHORT $LN9@combinatio@4
$LN8@combinatio@4:

; 2429 : 
; 2430 :         /* If i is negative, then the indices are all at
; 2431 :            their maximum value and we're done. */
; 2432 :         if (i < 0)

  00243	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00249	7d 05		 jge	 SHORT $LN7@combinatio@4

; 2433 :             goto empty;

  0024b	e9 fa 00 00 00	 jmp	 $empty$22528
$LN7@combinatio@4:

; 2434 : 
; 2435 :         /* Increment the current index which we know is not at its
; 2436 :            maximum.  Then move back to the right setting each index
; 2437 :            to its lowest possible value (one higher than the index
; 2438 :            to its left -- this maintains the sort order invariant). */
; 2439 :         indices[i]++;

  00250	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  00255	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0025a	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0025e	48 ff c0	 inc	 rax
  00261	48 8b 4c 24 48	 mov	 rcx, QWORD PTR indices$[rsp]
  00266	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  0026b	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 2440 :         for (j=i+1 ; j<r ; j++)

  0026f	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00274	48 ff c0	 inc	 rax
  00277	48 89 44 24 60	 mov	 QWORD PTR j$[rsp], rax
  0027c	eb 0d		 jmp	 SHORT $LN6@combinatio@4
$LN5@combinatio@4:
  0027e	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00283	48 ff c0	 inc	 rax
  00286	48 89 44 24 60	 mov	 QWORD PTR j$[rsp], rax
$LN6@combinatio@4:
  0028b	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  00290	48 39 44 24 60	 cmp	 QWORD PTR j$[rsp], rax
  00295	7d 22		 jge	 SHORT $LN4@combinatio@4

; 2441 :             indices[j] = indices[j-1] + 1;

  00297	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  0029c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  002a1	48 8b 44 c8 f8	 mov	 rax, QWORD PTR [rax+rcx*8-8]
  002a6	48 ff c0	 inc	 rax
  002a9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR indices$[rsp]
  002ae	48 8b 54 24 60	 mov	 rdx, QWORD PTR j$[rsp]
  002b3	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  002b7	eb c5		 jmp	 SHORT $LN5@combinatio@4
$LN4@combinatio@4:

; 2442 : 
; 2443 :         /* Update the result tuple for the new indices
; 2444 :            starting with i, the leftmost index that changed */
; 2445 :         for ( ; i<r ; i++) {

  002b9	eb 0d		 jmp	 SHORT $LN3@combinatio@4
$LN2@combinatio@4:
  002bb	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  002c0	48 ff c0	 inc	 rax
  002c3	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN3@combinatio@4:
  002c8	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  002cd	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  002d2	7d 65		 jge	 SHORT $LN1@combinatio@4

; 2446 :             index = indices[i];

  002d4	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  002d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  002de	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  002e2	48 89 44 24 40	 mov	 QWORD PTR index$[rsp], rax

; 2447 :             elem = PyTuple_GET_ITEM(pool, index);

  002e7	48 8b 44 24 68	 mov	 rax, QWORD PTR pool$[rsp]
  002ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR index$[rsp]
  002f1	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  002f6	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 2448 :             Py_INCREF(elem);

  002fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  00300	e8 00 00 00 00	 call	 _Py_IncRef

; 2449 :             oldelem = PyTuple_GET_ITEM(result, i);

  00305	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  0030a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0030f	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00314	48 89 44 24 38	 mov	 QWORD PTR oldelem$[rsp], rax

; 2450 :             PyTuple_SET_ITEM(result, i, elem);

  00319	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  0031e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00323	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  00328	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2451 :             Py_DECREF(oldelem);

  0032d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR oldelem$[rsp]
  00332	e8 00 00 00 00	 call	 _Py_DecRef

; 2452 :         }

  00337	eb 82		 jmp	 SHORT $LN2@combinatio@4
$LN1@combinatio@4:
$LN16@combinatio@4:

; 2453 :     }
; 2454 : 
; 2455 :     Py_INCREF(result);

  00339	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  0033e	e8 00 00 00 00	 call	 _Py_IncRef

; 2456 :     return result;

  00343	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00348	eb 14		 jmp	 SHORT $LN23@combinatio@4
$empty$22528:

; 2457 : 
; 2458 : empty:
; 2459 :     co->stopped = 1;

  0034a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00352	c7 80 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+128], 1

; 2460 :     return NULL;

  0035c	33 c0		 xor	 eax, eax
$LN23@combinatio@4:

; 2461 : }

  0035e	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00365	c3		 ret	 0
combinations_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_06GDBDPCAG@O?$CIOn?$CJN?$AA@		; `string'
PUBLIC	??_C@_06BBKLFPPK@O?$CI?$CI?$CJn?$CJ?$AA@	; `string'
PUBLIC	??_C@_05IEPKLDIK@O?$CIOn?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$combinations_reduce DD imagerel combinations_reduce
	DD	imagerel combinations_reduce+324
	DD	imagerel $unwind$combinations_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$combinations_reduce DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_06GDBDPCAG@O?$CIOn?$CJN?$AA@
CONST	SEGMENT
??_C@_06GDBDPCAG@O?$CIOn?$CJN?$AA@ DB 'O(On)N', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06BBKLFPPK@O?$CI?$CI?$CJn?$CJ?$AA@
CONST	SEGMENT
??_C@_06BBKLFPPK@O?$CI?$CI?$CJn?$CJ?$AA@ DB 'O(()n)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05IEPKLDIK@O?$CIOn?$CJ?$AA@
CONST	SEGMENT
??_C@_05IEPKLDIK@O?$CIOn?$CJ?$AA@ DB 'O(On)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT combinations_reduce
_TEXT	SEGMENT
i$22582 = 48
indices$22581 = 56
index$22588 = 64
lz$ = 96
combinations_reduce PROC				; COMDAT

; 2465 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2466 :     if (lz->result == NULL) {

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00013	75 31		 jne	 SHORT $LN9@combinatio@5

; 2467 :         return Py_BuildValue("O(On)", Py_TYPE(lz), lz->pool, lz->r);

  00015	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0001a	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00023	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00027	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0002c	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IEPKLDIK@O?$CIOn?$CJ?$AA@
  00037	e8 00 00 00 00	 call	 Py_BuildValue
  0003c	e9 fe 00 00 00	 jmp	 $LN10@combinatio@5
  00041	e9 f9 00 00 00	 jmp	 $LN8@combinatio@5
$LN9@combinatio@5:

; 2468 :     } else if (lz->stopped) {

  00046	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0004b	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [rax+128], 0
  00052	74 28		 je	 SHORT $LN7@combinatio@5

; 2469 :         return Py_BuildValue("O(()n)", Py_TYPE(lz), lz->r);

  00054	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00059	4c 8b 40 78	 mov	 r8, QWORD PTR [rax+120]
  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00062	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06BBKLFPPK@O?$CI?$CI?$CJn?$CJ?$AA@
  0006d	e8 00 00 00 00	 call	 Py_BuildValue
  00072	e9 c8 00 00 00	 jmp	 $LN10@combinatio@5

; 2470 :     } else {

  00077	e9 c3 00 00 00	 jmp	 $LN6@combinatio@5
$LN7@combinatio@5:

; 2471 :         PyObject *indices;
; 2472 :         Py_ssize_t i;
; 2473 : 
; 2474 :         /* we must pickle the indices and use them for setstate */
; 2475 :         indices = PyTuple_New(lz->r);

  0007c	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00081	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00085	e8 00 00 00 00	 call	 PyTuple_New
  0008a	48 89 44 24 38	 mov	 QWORD PTR indices$22581[rsp], rax

; 2476 :         if (!indices)

  0008f	48 83 7c 24 38
	00		 cmp	 QWORD PTR indices$22581[rsp], 0
  00095	75 07		 jne	 SHORT $LN5@combinatio@5

; 2477 :             return NULL;

  00097	33 c0		 xor	 eax, eax
  00099	e9 a1 00 00 00	 jmp	 $LN10@combinatio@5
$LN5@combinatio@5:

; 2478 :         for (i=0; i<lz->r; i++)

  0009e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$22582[rsp], 0
  000a7	eb 0d		 jmp	 SHORT $LN4@combinatio@5
$LN3@combinatio@5:
  000a9	48 8b 44 24 30	 mov	 rax, QWORD PTR i$22582[rsp]
  000ae	48 ff c0	 inc	 rax
  000b1	48 89 44 24 30	 mov	 QWORD PTR i$22582[rsp], rax
$LN4@combinatio@5:
  000b6	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000bb	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000bf	48 39 44 24 30	 cmp	 QWORD PTR i$22582[rsp], rax
  000c4	7d 48		 jge	 SHORT $LN2@combinatio@5

; 2479 :         {
; 2480 :             PyObject* index = PyLong_FromSsize_t(lz->indices[i]);

  000c6	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000cb	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$22582[rsp]
  000d4	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  000d8	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  000dd	48 89 44 24 40	 mov	 QWORD PTR index$22588[rsp], rax

; 2481 :             if (!index) {

  000e2	48 83 7c 24 40
	00		 cmp	 QWORD PTR index$22588[rsp], 0
  000e8	75 0e		 jne	 SHORT $LN1@combinatio@5

; 2482 :                 Py_DECREF(indices);

  000ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR indices$22581[rsp]
  000ef	e8 00 00 00 00	 call	 _Py_DecRef

; 2483 :                 return NULL;

  000f4	33 c0		 xor	 eax, eax
  000f6	eb 47		 jmp	 SHORT $LN10@combinatio@5
$LN1@combinatio@5:

; 2484 :             }
; 2485 :             PyTuple_SET_ITEM(indices, i, index);

  000f8	48 8b 44 24 38	 mov	 rax, QWORD PTR indices$22581[rsp]
  000fd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$22582[rsp]
  00102	48 8b 54 24 40	 mov	 rdx, QWORD PTR index$22588[rsp]
  00107	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2486 :         }

  0010c	eb 9b		 jmp	 SHORT $LN3@combinatio@5
$LN2@combinatio@5:

; 2487 : 
; 2488 :         return Py_BuildValue("O(On)N", Py_TYPE(lz), lz->pool, lz->r, indices);

  0010e	48 8b 44 24 38	 mov	 rax, QWORD PTR indices$22581[rsp]
  00113	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00118	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0011d	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  00121	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00126	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0012a	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0012f	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06GDBDPCAG@O?$CIOn?$CJN?$AA@
  0013a	e8 00 00 00 00	 call	 Py_BuildValue
$LN6@combinatio@5:
$LN8@combinatio@5:
$LN10@combinatio@5:

; 2489 :     }
; 2490 : }

  0013f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00143	c3		 ret	 0
combinations_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@FGJEHJGB@combinations_setstate?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$combinations_setstate DD imagerel combinations_setstate
	DD	imagerel combinations_setstate+636
	DD	imagerel $unwind$combinations_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$combinations_setstate DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0BG@FGJEHJGB@combinations_setstate?$AA@
CONST	SEGMENT
??_C@_0BG@FGJEHJGB@combinations_setstate?$AA@ DB 'combinations_setstate', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT combinations_setstate
_TEXT	SEGMENT
n$ = 48
i$ = 56
result$ = 64
index$22616 = 72
indexObject$22614 = 80
max$22613 = 88
element$22627 = 96
_py_tmp$22636 = 104
lz$ = 128
state$ = 136
combinations_setstate PROC				; COMDAT

; 2494 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2495 :     PyObject *result;
; 2496 :     Py_ssize_t i;
; 2497 :     Py_ssize_t n = PyTuple_GET_SIZE(lz->pool);

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00016	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001e	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 2498 : 
; 2499 :     if (!PyTuple_Check(state) || PyTuple_GET_SIZE(state) != lz->r)

  00023	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0003a	85 c0		 test	 eax, eax
  0003c	74 1a		 je	 SHORT $LN15@combinatio@6
  0003e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00046	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR lz$[rsp]
  0004e	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  00052	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00056	74 1a		 je	 SHORT $LN16@combinatio@6
$LN15@combinatio@6:

; 2500 :     {
; 2501 :         PyErr_SetString(PyExc_ValueError, "invalid arguments");

  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@KNPMEBHA@invalid?5arguments?$AA@
  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00066	e8 00 00 00 00	 call	 PyErr_SetString

; 2502 :         return NULL;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 05 02 00 00	 jmp	 $LN17@combinatio@6
$LN16@combinatio@6:

; 2503 :     }
; 2504 : 
; 2505 :     for (i=0; i<lz->r; i++)

  00072	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0007b	eb 0d		 jmp	 SHORT $LN14@combinatio@6
$LN13@combinatio@6:
  0007d	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00082	48 ff c0	 inc	 rax
  00085	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN14@combinatio@6:
  0008a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00092	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00096	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  0009b	0f 8d a6 00 00
	00		 jge	 $LN12@combinatio@6

; 2506 :     {
; 2507 :         Py_ssize_t max;
; 2508 :         PyObject* indexObject = PyTuple_GET_ITEM(state, i);

  000a1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000a9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000ae	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  000b3	48 89 44 24 50	 mov	 QWORD PTR indexObject$22614[rsp], rax

; 2509 :         Py_ssize_t index = PyLong_AsSsize_t(indexObject);

  000b8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR indexObject$22614[rsp]
  000bd	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000c2	48 89 44 24 48	 mov	 QWORD PTR index$22616[rsp], rax

; 2510 :         if (index == -1 && PyErr_Occurred())

  000c7	48 83 7c 24 48
	ff		 cmp	 QWORD PTR index$22616[rsp], -1
  000cd	75 11		 jne	 SHORT $LN11@combinatio@6
  000cf	e8 00 00 00 00	 call	 PyErr_Occurred
  000d4	48 85 c0	 test	 rax, rax
  000d7	74 07		 je	 SHORT $LN11@combinatio@6

; 2511 :             return NULL; /* not an integer */

  000d9	33 c0		 xor	 eax, eax
  000db	e9 97 01 00 00	 jmp	 $LN17@combinatio@6
$LN11@combinatio@6:

; 2512 :         max = i + n - lz->r;

  000e0	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  000ea	48 03 c8	 add	 rcx, rax
  000ed	48 8b c1	 mov	 rax, rcx
  000f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR lz$[rsp]
  000f8	48 2b 41 78	 sub	 rax, QWORD PTR [rcx+120]
  000fc	48 89 44 24 58	 mov	 QWORD PTR max$22613[rsp], rax

; 2513 :         /* clamp the index (beware of negative max) */
; 2514 :         if (index > max)

  00101	48 8b 44 24 58	 mov	 rax, QWORD PTR max$22613[rsp]
  00106	48 39 44 24 48	 cmp	 QWORD PTR index$22616[rsp], rax
  0010b	7e 0a		 jle	 SHORT $LN10@combinatio@6

; 2515 :             index = max;

  0010d	48 8b 44 24 58	 mov	 rax, QWORD PTR max$22613[rsp]
  00112	48 89 44 24 48	 mov	 QWORD PTR index$22616[rsp], rax
$LN10@combinatio@6:

; 2516 :         if (index < 0)

  00117	48 83 7c 24 48
	00		 cmp	 QWORD PTR index$22616[rsp], 0
  0011d	7d 09		 jge	 SHORT $LN9@combinatio@6

; 2517 :             index = 0;

  0011f	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR index$22616[rsp], 0
$LN9@combinatio@6:

; 2518 :         lz->indices[i] = index;

  00128	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00130	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00134	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  00139	48 8b 54 24 48	 mov	 rdx, QWORD PTR index$22616[rsp]
  0013e	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 2519 :     }

  00142	e9 36 ff ff ff	 jmp	 $LN13@combinatio@6
$LN12@combinatio@6:

; 2520 : 
; 2521 :     result = PyTuple_New(lz->r);

  00147	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0014f	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00153	e8 00 00 00 00	 call	 PyTuple_New
  00158	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 2522 :     if (result == NULL)

  0015d	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$[rsp], 0
  00163	75 07		 jne	 SHORT $LN8@combinatio@6

; 2523 :         return NULL;

  00165	33 c0		 xor	 eax, eax
  00167	e9 0b 01 00 00	 jmp	 $LN17@combinatio@6
$LN8@combinatio@6:

; 2524 :     for (i=0; i<lz->r; i++) {

  0016c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00175	eb 0d		 jmp	 SHORT $LN7@combinatio@6
$LN6@combinatio@6:
  00177	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  0017c	48 ff c0	 inc	 rax
  0017f	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN7@combinatio@6:
  00184	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0018c	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00190	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  00195	7d 4b		 jge	 SHORT $LN5@combinatio@6

; 2525 :         PyObject *element = PyTuple_GET_ITEM(lz->pool, lz->indices[i]);

  00197	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0019f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001a3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR lz$[rsp]
  001ab	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  001af	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  001b4	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  001b8	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  001bd	48 89 44 24 60	 mov	 QWORD PTR element$22627[rsp], rax

; 2526 :         Py_INCREF(element);

  001c2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR element$22627[rsp]
  001c7	e8 00 00 00 00	 call	 _Py_IncRef

; 2527 :         PyTuple_SET_ITEM(result, i, element);

  001cc	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  001d1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  001d6	48 8b 54 24 60	 mov	 rdx, QWORD PTR element$22627[rsp]
  001db	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2528 :     }

  001e0	eb 95		 jmp	 SHORT $LN6@combinatio@6
$LN5@combinatio@6:
$LN4@combinatio@6:

; 2529 : 
; 2530 :     Py_CLEAR(lz->result);

  001e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  001ea	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  001ef	74 5c		 je	 SHORT $LN1@combinatio@6
  001f1	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001f9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00201	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00205	41 b8 e2 09 00
	00		 mov	 r8d, 2530		; 000009e2H
  0020b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@FGJEHJGB@combinations_setstate?$AA@
  00219	e8 00 00 00 00	 call	 _PyParallel_Guard
  0021e	85 c0		 test	 eax, eax
  00220	75 2b		 jne	 SHORT $LN1@combinatio@6
  00222	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0022a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0022e	48 89 44 24 68	 mov	 QWORD PTR _py_tmp$22636[rsp], rax
  00233	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0023b	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
  00243	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _py_tmp$22636[rsp]
  00248	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@combinatio@6:
  0024d	33 c0		 xor	 eax, eax
  0024f	85 c0		 test	 eax, eax
  00251	75 8f		 jne	 SHORT $LN4@combinatio@6

; 2531 :     lz->result = result;

  00253	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  0025b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  00260	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2532 :     Py_RETURN_NONE;

  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0026b	e8 00 00 00 00	 call	 _Py_IncRef
  00270	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN17@combinatio@6:

; 2533 : }

  00277	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0027b	c3		 ret	 0
combinations_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@CJEKPALN@On?3combinations_with_replacement@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cwr_new DD imagerel cwr_new
	DD	imagerel cwr_new+481
	DD	imagerel $unwind$cwr_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cwr_new DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_0CB@CJEKPALN@On?3combinations_with_replacement@
CONST	SEGMENT
??_C@_0CB@CJEKPALN@On?3combinations_with_replacement@ DB 'On:combinations'
	DB	'_with_replacement', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cwr_new
_TEXT	SEGMENT
i$ = 48
n$ = 56
indices$ = 64
co$ = 72
iterable$ = 80
r$ = 88
pool$ = 96
tv131 = 104
type$ = 128
args$ = 136
kwds$ = 144
cwr_new	PROC						; COMDAT

; 2635 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2636 :     cwrobject *co;
; 2637 :     Py_ssize_t n;
; 2638 :     Py_ssize_t r;
; 2639 :     PyObject *pool = NULL;

  00013	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR pool$[rsp], 0

; 2640 :     PyObject *iterable = NULL;

  0001c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR iterable$[rsp], 0

; 2641 :     Py_ssize_t *indices = NULL;

  00025	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR indices$[rsp], 0

; 2642 :     Py_ssize_t i;
; 2643 :     static char *kwargs[] = {"iterable", "r", NULL};
; 2644 : 
; 2645 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "On:combinations_with_replacement", kwargs,
; 2646 :                                      &iterable, &r))

  0002e	48 8d 44 24 58	 lea	 rax, QWORD PTR r$[rsp]
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 44 24 50	 lea	 rax, QWORD PTR iterable$[rsp]
  0003d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00042	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwargs@?1??cwr_new@@9@9
  00049	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CB@CJEKPALN@On?3combinations_with_replacement@
  00050	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00058	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00060	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00065	85 c0		 test	 eax, eax
  00067	75 07		 jne	 SHORT $LN13@cwr_new

; 2647 :         return NULL;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 6c 01 00 00	 jmp	 $LN14@cwr_new
$LN13@cwr_new:

; 2648 : 
; 2649 :     pool = PySequence_Tuple(iterable);

  00070	48 8b 4c 24 50	 mov	 rcx, QWORD PTR iterable$[rsp]
  00075	e8 00 00 00 00	 call	 PySequence_Tuple
  0007a	48 89 44 24 60	 mov	 QWORD PTR pool$[rsp], rax

; 2650 :     if (pool == NULL)

  0007f	48 83 7c 24 60
	00		 cmp	 QWORD PTR pool$[rsp], 0
  00085	75 05		 jne	 SHORT $LN12@cwr_new

; 2651 :         goto error;

  00087	e9 24 01 00 00	 jmp	 $error$22700
$LN12@cwr_new:

; 2652 :     n = PyTuple_GET_SIZE(pool);

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR pool$[rsp]
  00091	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00095	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax

; 2653 :     if (r < 0) {

  0009a	48 83 7c 24 58
	00		 cmp	 QWORD PTR r$[rsp], 0
  000a0	7d 18		 jge	 SHORT $LN11@cwr_new

; 2654 :         PyErr_SetString(PyExc_ValueError, "r must be non-negative");

  000a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@GBDHCGGF@r?5must?5be?5non?9negative?$AA@
  000a9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000b0	e8 00 00 00 00	 call	 PyErr_SetString

; 2655 :         goto error;

  000b5	e9 f6 00 00 00	 jmp	 $error$22700
$LN11@cwr_new:

; 2656 :     }
; 2657 : 
; 2658 :     indices = PyMem_Malloc(r * sizeof(Py_ssize_t));

  000ba	48 8b 44 24 58	 mov	 rax, QWORD PTR r$[rsp]
  000bf	48 c1 e0 03	 shl	 rax, 3
  000c3	48 8b c8	 mov	 rcx, rax
  000c6	e8 00 00 00 00	 call	 PyMem_Malloc
  000cb	48 89 44 24 40	 mov	 QWORD PTR indices$[rsp], rax

; 2659 :     if (indices == NULL) {

  000d0	48 83 7c 24 40
	00		 cmp	 QWORD PTR indices$[rsp], 0
  000d6	75 0a		 jne	 SHORT $LN10@cwr_new

; 2660 :         PyErr_NoMemory();

  000d8	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2661 :         goto error;

  000dd	e9 ce 00 00 00	 jmp	 $error$22700
$LN10@cwr_new:

; 2662 :     }
; 2663 : 
; 2664 :     for (i=0 ; i<r ; i++)

  000e2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000eb	eb 0d		 jmp	 SHORT $LN9@cwr_new
$LN8@cwr_new:
  000ed	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000f2	48 ff c0	 inc	 rax
  000f5	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN9@cwr_new:
  000fa	48 8b 44 24 58	 mov	 rax, QWORD PTR r$[rsp]
  000ff	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00104	7d 14		 jge	 SHORT $LN7@cwr_new

; 2665 :         indices[i] = 0;

  00106	48 8b 44 24 40	 mov	 rax, QWORD PTR indices$[rsp]
  0010b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00110	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0
  00118	eb d3		 jmp	 SHORT $LN8@cwr_new
$LN7@cwr_new:

; 2666 : 
; 2667 :     /* create cwrobject structure */
; 2668 :     co = (cwrobject *)type->tp_alloc(type, 0);

  0011a	33 d2		 xor	 edx, edx
  0011c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  00124	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  0012c	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00132	48 89 44 24 48	 mov	 QWORD PTR co$[rsp], rax

; 2669 :     if (co == NULL)

  00137	48 83 7c 24 48
	00		 cmp	 QWORD PTR co$[rsp], 0
  0013d	75 02		 jne	 SHORT $LN6@cwr_new

; 2670 :         goto error;

  0013f	eb 6f		 jmp	 SHORT $error$22700
$LN6@cwr_new:

; 2671 : 
; 2672 :     co->pool = pool;

  00141	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  00146	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pool$[rsp]
  0014b	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 2673 :     co->indices = indices;

  0014f	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  00154	48 8b 4c 24 40	 mov	 rcx, QWORD PTR indices$[rsp]
  00159	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 2674 :     co->result = NULL;

  0015d	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  00162	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0

; 2675 :     co->r = r;

  0016a	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  0016f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$[rsp]
  00174	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 2676 :     co->stopped = !n && r;

  00178	48 83 7c 24 38
	00		 cmp	 QWORD PTR n$[rsp], 0
  0017e	75 12		 jne	 SHORT $LN16@cwr_new
  00180	48 83 7c 24 58
	00		 cmp	 QWORD PTR r$[rsp], 0
  00186	74 0a		 je	 SHORT $LN16@cwr_new
  00188	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  00190	eb 08		 jmp	 SHORT $LN17@cwr_new
$LN16@cwr_new:
  00192	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN17@cwr_new:
  0019a	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  0019f	8b 4c 24 68	 mov	 ecx, DWORD PTR tv131[rsp]
  001a3	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx

; 2677 : 
; 2678 :     return (PyObject *)co;

  001a9	48 8b 44 24 48	 mov	 rax, QWORD PTR co$[rsp]
  001ae	eb 2c		 jmp	 SHORT $LN14@cwr_new
$error$22700:

; 2679 : 
; 2680 : error:
; 2681 :     if (indices != NULL)

  001b0	48 83 7c 24 40
	00		 cmp	 QWORD PTR indices$[rsp], 0
  001b6	74 0a		 je	 SHORT $LN5@cwr_new

; 2682 :         PyMem_Free(indices);

  001b8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR indices$[rsp]
  001bd	e8 00 00 00 00	 call	 PyMem_Free
$LN5@cwr_new:
$LN4@cwr_new:

; 2683 :     Py_XDECREF(pool);

  001c2	48 83 7c 24 60
	00		 cmp	 QWORD PTR pool$[rsp], 0
  001c8	74 0a		 je	 SHORT $LN1@cwr_new
  001ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pool$[rsp]
  001cf	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@cwr_new:
  001d4	33 c0		 xor	 eax, eax
  001d6	85 c0		 test	 eax, eax
  001d8	75 e8		 jne	 SHORT $LN4@cwr_new

; 2684 :     return NULL;

  001da	33 c0		 xor	 eax, eax
$LN14@cwr_new:

; 2685 : }

  001dc	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001e0	c3		 ret	 0
cwr_new	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cwr_dealloc DD imagerel cwr_dealloc
	DD	imagerel cwr_dealloc+134
	DD	imagerel $unwind$cwr_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cwr_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT cwr_dealloc
_TEXT	SEGMENT
co$ = 48
cwr_dealloc PROC					; COMDAT

; 2689 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2690 :     PyObject_GC_UnTrack(co);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR co$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN9@cwr_deallo:

; 2691 :     Py_XDECREF(co->pool);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN6@cwr_deallo
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@cwr_deallo:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN9@cwr_deallo
$LN5@cwr_deallo:

; 2692 :     Py_XDECREF(co->result);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00038	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0003d	74 0e		 je	 SHORT $LN2@cwr_deallo
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00044	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@cwr_deallo:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN5@cwr_deallo

; 2693 :     if (co->indices != NULL)

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00058	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0005d	74 0e		 je	 SHORT $LN1@cwr_deallo

; 2694 :         PyMem_Free(co->indices);

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00064	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00068	e8 00 00 00 00	 call	 PyMem_Free
$LN1@cwr_deallo:

; 2695 :     Py_TYPE(co)->tp_free(co);

  0006d	48 8b 44 24 30	 mov	 rax, QWORD PTR co$[rsp]
  00072	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00076	48 8b 4c 24 30	 mov	 rcx, QWORD PTR co$[rsp]
  0007b	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 2696 : }

  00081	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00085	c3		 ret	 0
cwr_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@JAGICFBJ@cwr_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cwr_traverse DD imagerel cwr_traverse
	DD	imagerel cwr_traverse+206
	DD	imagerel $unwind$cwr_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cwr_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0N@JAGICFBJ@cwr_traverse?$AA@
CONST	SEGMENT
??_C@_0N@JAGICFBJ@cwr_traverse?$AA@ DB 'cwr_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cwr_traverse
_TEXT	SEGMENT
vret$22753 = 32
vret$22761 = 36
co$ = 64
visit$ = 72
arg$ = 80
cwr_traverse PROC					; COMDAT

; 2700 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@cwr_traver:

; 2701 :     Py_VISIT(co->pool);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@cwr_traver
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 8d 0a 00
	00		 mov	 r8d, 2701		; 00000a8dH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@JAGICFBJ@cwr_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@cwr_traver:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR co$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN8@cwr_traver
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR co$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$22753[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$22753[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@cwr_traver
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$22753[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@cwr_traver
$LN7@cwr_traver:
$LN8@cwr_traver:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@cwr_traver
$LN6@cwr_traver:

; 2702 :     Py_VISIT(co->result);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@cwr_traver
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 8e 0a 00
	00		 mov	 r8d, 2702		; 00000a8eH
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@JAGICFBJ@cwr_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@cwr_traver:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR co$[rsp]
  00097	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0009c	74 23		 je	 SHORT $LN2@cwr_traver
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR co$[rsp]
  000a8	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$22761[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$22761[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@cwr_traver
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$22761[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@cwr_traver
$LN1@cwr_traver:
$LN2@cwr_traver:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@cwr_traver

; 2703 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@cwr_traver:

; 2704 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
cwr_traverse ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BE@FPFGLEOI@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CA@MPILJIJI@?$AAi?$AAn?$AAd?$AAi?$AAc?$AAe?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cwr_next DD imagerel cwr_next
	DD	imagerel cwr_next+828
	DD	imagerel $unwind$cwr_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cwr_next DD 010901H
	DD	0e209H
xdata	ENDS
;	COMDAT ??_C@_1BE@FPFGLEOI@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@FPFGLEOI@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAn?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H, '<', 00H
	DB	' ', 00H, 'n', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@MPILJIJI@?$AAi?$AAn?$AAd?$AAi?$AAc?$AAe?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@MPILJIJI@?$AAi?$AAn?$AAd?$AAi?$AAc?$AAe?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'd', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H
	DB	'[', 00H, 'i', 00H, ']', 00H, ' ', 00H, '=', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cwr_next
_TEXT	SEGMENT
elem$ = 32
i$ = 40
n$ = 48
oldelem$ = 56
index$ = 64
indices$ = 72
r$ = 80
result$ = 88
pool$ = 96
old_result$22796 = 104
co$ = 128
cwr_next PROC						; COMDAT

; 2708 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2709 :     PyObject *elem;
; 2710 :     PyObject *oldelem;
; 2711 :     PyObject *pool = co->pool;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00011	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00015	48 89 44 24 60	 mov	 QWORD PTR pool$[rsp], rax

; 2712 :     Py_ssize_t *indices = co->indices;

  0001a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00022	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00026	48 89 44 24 48	 mov	 QWORD PTR indices$[rsp], rax

; 2713 :     PyObject *result = co->result;

  0002b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00033	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00037	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 2714 :     Py_ssize_t n = PyTuple_GET_SIZE(pool);

  0003c	48 8b 44 24 60	 mov	 rax, QWORD PTR pool$[rsp]
  00041	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00045	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 2715 :     Py_ssize_t r = co->r;

  0004a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00052	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00056	48 89 44 24 50	 mov	 QWORD PTR r$[rsp], rax

; 2716 :     Py_ssize_t i, index;
; 2717 : 
; 2718 :     if (co->stopped)

  0005b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  00063	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [rax+128], 0
  0006a	74 07		 je	 SHORT $LN19@cwr_next

; 2719 :         return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	e9 c4 02 00 00	 jmp	 $LN20@cwr_next
$LN19@cwr_next:

; 2720 : 
; 2721 :     if (result == NULL) {

  00073	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  00079	0f 85 b1 00 00
	00		 jne	 $LN18@cwr_next

; 2722 :         /* On the first pass, initialize result tuple with pool[0] */
; 2723 :         result = PyTuple_New(r);

  0007f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$[rsp]
  00084	e8 00 00 00 00	 call	 PyTuple_New
  00089	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 2724 :         if (result == NULL)

  0008e	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  00094	75 05		 jne	 SHORT $LN17@cwr_next

; 2725 :             goto empty;

  00096	e9 88 02 00 00	 jmp	 $empty$22784
$LN17@cwr_next:

; 2726 :         co->result = result;

  0009b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  000a3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  000a8	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2727 :         elem = PyTuple_GET_ITEM(pool, 0);

  000ac	48 8b 44 24 60	 mov	 rax, QWORD PTR pool$[rsp]
  000b1	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000b5	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 2728 :         for (i=0; i<r ; i++) {

  000ba	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000c3	eb 0d		 jmp	 SHORT $LN16@cwr_next
$LN15@cwr_next:
  000c5	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000ca	48 ff c0	 inc	 rax
  000cd	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN16@cwr_next:
  000d2	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  000d7	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000dc	7d 4d		 jge	 SHORT $LN14@cwr_next

; 2729 :             assert(indices[i] == 0);

  000de	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  000e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000e8	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  000ed	74 1c		 je	 SHORT $LN22@cwr_next
  000ef	41 b8 a9 0a 00
	00		 mov	 r8d, 2729		; 00000aa9H
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@MPILJIJI@?$AAi?$AAn?$AAd?$AAi?$AAc?$AAe?$AAs?$AA?$FL?$AAi?$AA?$FN?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00109	33 c0		 xor	 eax, eax
$LN22@cwr_next:

; 2730 :             Py_INCREF(elem);

  0010b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  00110	e8 00 00 00 00	 call	 _Py_IncRef

; 2731 :             PyTuple_SET_ITEM(result, i, elem);

  00115	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  0011a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0011f	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  00124	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2732 :         }

  00129	eb 9a		 jmp	 SHORT $LN15@cwr_next
$LN14@cwr_next:

; 2733 :     } else {

  0012b	e9 e2 01 00 00	 jmp	 $LN13@cwr_next
$LN18@cwr_next:

; 2734 :         /* Copy the previous result tuple or re-use it if available */
; 2735 :         if (Py_REFCNT(result) > 1) {

  00130	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00135	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  0013a	0f 8e 99 00 00
	00		 jle	 $LN12@cwr_next

; 2736 :             PyObject *old_result = result;

  00140	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00145	48 89 44 24 68	 mov	 QWORD PTR old_result$22796[rsp], rax

; 2737 :             result = PyTuple_New(r);

  0014a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$[rsp]
  0014f	e8 00 00 00 00	 call	 PyTuple_New
  00154	48 89 44 24 58	 mov	 QWORD PTR result$[rsp], rax

; 2738 :             if (result == NULL)

  00159	48 83 7c 24 58
	00		 cmp	 QWORD PTR result$[rsp], 0
  0015f	75 05		 jne	 SHORT $LN11@cwr_next

; 2739 :                 goto empty;

  00161	e9 bd 01 00 00	 jmp	 $empty$22784
$LN11@cwr_next:

; 2740 :             co->result = result;

  00166	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  0016e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  00173	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2741 :             for (i=0; i<r ; i++) {

  00177	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00180	eb 0d		 jmp	 SHORT $LN10@cwr_next
$LN9@cwr_next:
  00182	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00187	48 ff c0	 inc	 rax
  0018a	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN10@cwr_next:
  0018f	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  00194	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  00199	7d 34		 jge	 SHORT $LN8@cwr_next

; 2742 :                 elem = PyTuple_GET_ITEM(old_result, i);

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR old_result$22796[rsp]
  001a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  001a5	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  001aa	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 2743 :                 Py_INCREF(elem);

  001af	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  001b4	e8 00 00 00 00	 call	 _Py_IncRef

; 2744 :                 PyTuple_SET_ITEM(result, i, elem);

  001b9	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001be	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  001c3	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  001c8	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2745 :             }

  001cd	eb b3		 jmp	 SHORT $LN9@cwr_next
$LN8@cwr_next:

; 2746 :             Py_DECREF(old_result);

  001cf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR old_result$22796[rsp]
  001d4	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@cwr_next:

; 2747 :         }
; 2748 :         /* Now, we've got the only copy so we can update it in-place CPython's
; 2749 :            empty tuple is a singleton and cached in PyTuple's freelist. */
; 2750 :         assert(r == 0 || Py_REFCNT(result) == 1);

  001d9	48 83 7c 24 50
	00		 cmp	 QWORD PTR r$[rsp], 0
  001df	74 28		 je	 SHORT $LN23@cwr_next
  001e1	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  001e6	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  001eb	74 1c		 je	 SHORT $LN23@cwr_next
  001ed	41 b8 be 0a 00
	00		 mov	 r8d, 2750		; 00000abeH
  001f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@JPBKELHI@?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AA_?$AAR?$AAE?$AAF?$AAC?$AAN?$AAT?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1@
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00207	33 c0		 xor	 eax, eax
$LN23@cwr_next:

; 2751 : 
; 2752 :        /* Scan indices right-to-left until finding one that is not
; 2753 :         * at its maximum (n-1). */
; 2754 :         for (i=r-1 ; i >= 0 && indices[i] == n-1; i--)

  00209	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  0020e	48 ff c8	 dec	 rax
  00211	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  00216	eb 0d		 jmp	 SHORT $LN7@cwr_next
$LN6@cwr_next:
  00218	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0021d	48 ff c8	 dec	 rax
  00220	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN7@cwr_next:
  00225	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  0022b	7c 1a		 jl	 SHORT $LN5@cwr_next
  0022d	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00232	48 ff c8	 dec	 rax
  00235	48 8b 4c 24 48	 mov	 rcx, QWORD PTR indices$[rsp]
  0023a	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  0023f	48 39 04 d1	 cmp	 QWORD PTR [rcx+rdx*8], rax
  00243	75 02		 jne	 SHORT $LN5@cwr_next

; 2755 :             ;

  00245	eb d1		 jmp	 SHORT $LN6@cwr_next
$LN5@cwr_next:

; 2756 : 
; 2757 :         /* If i is negative, then the indices are all at
; 2758 :            their maximum value and we're done. */
; 2759 :         if (i < 0)

  00247	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  0024d	7d 05		 jge	 SHORT $LN4@cwr_next

; 2760 :             goto empty;

  0024f	e9 cf 00 00 00	 jmp	 $empty$22784
$LN4@cwr_next:

; 2761 : 
; 2762 :         /* Increment the current index which we know is not at its
; 2763 :            maximum.  Then set all to the right to the same value. */
; 2764 :         index = indices[i] + 1;

  00254	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  00259	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0025e	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00262	48 ff c0	 inc	 rax
  00265	48 89 44 24 40	 mov	 QWORD PTR index$[rsp], rax

; 2765 :         assert(index < n);

  0026a	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  0026f	48 39 44 24 40	 cmp	 QWORD PTR index$[rsp], rax
  00274	7c 1c		 jl	 SHORT $LN24@cwr_next
  00276	41 b8 cd 0a 00
	00		 mov	 r8d, 2765		; 00000acdH
  0027c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00283	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@FPFGLEOI@?$AAi?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAn?$AA?$AA@
  0028a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00290	33 c0		 xor	 eax, eax
$LN24@cwr_next:

; 2766 :         elem = PyTuple_GET_ITEM(pool, index);

  00292	48 8b 44 24 60	 mov	 rax, QWORD PTR pool$[rsp]
  00297	48 8b 4c 24 40	 mov	 rcx, QWORD PTR index$[rsp]
  0029c	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  002a1	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 2767 :         for ( ; i<r ; i++) {

  002a6	eb 0d		 jmp	 SHORT $LN3@cwr_next
$LN2@cwr_next:
  002a8	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  002ad	48 ff c0	 inc	 rax
  002b0	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN3@cwr_next:
  002b5	48 8b 44 24 50	 mov	 rax, QWORD PTR r$[rsp]
  002ba	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  002bf	7d 51		 jge	 SHORT $LN1@cwr_next

; 2768 :             indices[i] = index;

  002c1	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  002c6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  002cb	48 8b 54 24 40	 mov	 rdx, QWORD PTR index$[rsp]
  002d0	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 2769 :             Py_INCREF(elem);

  002d4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  002d9	e8 00 00 00 00	 call	 _Py_IncRef

; 2770 :             oldelem = PyTuple_GET_ITEM(result, i);

  002de	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  002e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  002e8	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  002ed	48 89 44 24 38	 mov	 QWORD PTR oldelem$[rsp], rax

; 2771 :             PyTuple_SET_ITEM(result, i, elem);

  002f2	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  002f7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  002fc	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  00301	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2772 :             Py_DECREF(oldelem);

  00306	48 8b 4c 24 38	 mov	 rcx, QWORD PTR oldelem$[rsp]
  0030b	e8 00 00 00 00	 call	 _Py_DecRef

; 2773 :         }

  00310	eb 96		 jmp	 SHORT $LN2@cwr_next
$LN1@cwr_next:
$LN13@cwr_next:

; 2774 :     }
; 2775 : 
; 2776 :     Py_INCREF(result);

  00312	48 8b 4c 24 58	 mov	 rcx, QWORD PTR result$[rsp]
  00317	e8 00 00 00 00	 call	 _Py_IncRef

; 2777 :     return result;

  0031c	48 8b 44 24 58	 mov	 rax, QWORD PTR result$[rsp]
  00321	eb 14		 jmp	 SHORT $LN20@cwr_next
$empty$22784:

; 2778 : 
; 2779 : empty:
; 2780 :     co->stopped = 1;

  00323	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR co$[rsp]
  0032b	c7 80 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+128], 1

; 2781 :     return NULL;

  00335	33 c0		 xor	 eax, eax
$LN20@cwr_next:

; 2782 : }

  00337	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0033b	c3		 ret	 0
cwr_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cwr_reduce DD imagerel cwr_reduce
	DD	imagerel cwr_reduce+324
	DD	imagerel $unwind$cwr_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cwr_reduce DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT cwr_reduce
_TEXT	SEGMENT
i$22836 = 48
indices$22835 = 56
index$22842 = 64
lz$ = 96
cwr_reduce PROC						; COMDAT

; 2786 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2787 :     if (lz->result == NULL) {

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00013	75 31		 jne	 SHORT $LN9@cwr_reduce

; 2788 :         return Py_BuildValue("O(On)", Py_TYPE(lz), lz->pool, lz->r);

  00015	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0001a	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00023	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00027	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0002c	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IEPKLDIK@O?$CIOn?$CJ?$AA@
  00037	e8 00 00 00 00	 call	 Py_BuildValue
  0003c	e9 fe 00 00 00	 jmp	 $LN10@cwr_reduce
  00041	e9 f9 00 00 00	 jmp	 $LN8@cwr_reduce
$LN9@cwr_reduce:

; 2789 :     } else if (lz->stopped) {

  00046	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0004b	83 b8 80 00 00
	00 00		 cmp	 DWORD PTR [rax+128], 0
  00052	74 28		 je	 SHORT $LN7@cwr_reduce

; 2790 :         return Py_BuildValue("O(()n)", Py_TYPE(lz), lz->r);

  00054	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00059	4c 8b 40 78	 mov	 r8, QWORD PTR [rax+120]
  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00062	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06BBKLFPPK@O?$CI?$CI?$CJn?$CJ?$AA@
  0006d	e8 00 00 00 00	 call	 Py_BuildValue
  00072	e9 c8 00 00 00	 jmp	 $LN10@cwr_reduce

; 2791 :     } else {

  00077	e9 c3 00 00 00	 jmp	 $LN6@cwr_reduce
$LN7@cwr_reduce:

; 2792 :         PyObject *indices;
; 2793 :         Py_ssize_t i;
; 2794 : 
; 2795 :         /* we must pickle the indices and use them for setstate */
; 2796 :         indices = PyTuple_New(lz->r);

  0007c	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00081	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00085	e8 00 00 00 00	 call	 PyTuple_New
  0008a	48 89 44 24 38	 mov	 QWORD PTR indices$22835[rsp], rax

; 2797 :         if (!indices)

  0008f	48 83 7c 24 38
	00		 cmp	 QWORD PTR indices$22835[rsp], 0
  00095	75 07		 jne	 SHORT $LN5@cwr_reduce

; 2798 :             return NULL;

  00097	33 c0		 xor	 eax, eax
  00099	e9 a1 00 00 00	 jmp	 $LN10@cwr_reduce
$LN5@cwr_reduce:

; 2799 :         for (i=0; i<lz->r; i++)

  0009e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$22836[rsp], 0
  000a7	eb 0d		 jmp	 SHORT $LN4@cwr_reduce
$LN3@cwr_reduce:
  000a9	48 8b 44 24 30	 mov	 rax, QWORD PTR i$22836[rsp]
  000ae	48 ff c0	 inc	 rax
  000b1	48 89 44 24 30	 mov	 QWORD PTR i$22836[rsp], rax
$LN4@cwr_reduce:
  000b6	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000bb	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  000bf	48 39 44 24 30	 cmp	 QWORD PTR i$22836[rsp], rax
  000c4	7d 48		 jge	 SHORT $LN2@cwr_reduce

; 2800 :         {
; 2801 :             PyObject* index = PyLong_FromSsize_t(lz->indices[i]);

  000c6	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000cb	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$22836[rsp]
  000d4	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  000d8	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  000dd	48 89 44 24 40	 mov	 QWORD PTR index$22842[rsp], rax

; 2802 :             if (!index) {

  000e2	48 83 7c 24 40
	00		 cmp	 QWORD PTR index$22842[rsp], 0
  000e8	75 0e		 jne	 SHORT $LN1@cwr_reduce

; 2803 :                 Py_DECREF(indices);

  000ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR indices$22835[rsp]
  000ef	e8 00 00 00 00	 call	 _Py_DecRef

; 2804 :                 return NULL;

  000f4	33 c0		 xor	 eax, eax
  000f6	eb 47		 jmp	 SHORT $LN10@cwr_reduce
$LN1@cwr_reduce:

; 2805 :             }
; 2806 :             PyTuple_SET_ITEM(indices, i, index);

  000f8	48 8b 44 24 38	 mov	 rax, QWORD PTR indices$22835[rsp]
  000fd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$22836[rsp]
  00102	48 8b 54 24 40	 mov	 rdx, QWORD PTR index$22842[rsp]
  00107	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2807 :         }

  0010c	eb 9b		 jmp	 SHORT $LN3@cwr_reduce
$LN2@cwr_reduce:

; 2808 : 
; 2809 :         return Py_BuildValue("O(On)N", Py_TYPE(lz), lz->pool, lz->r, indices);

  0010e	48 8b 44 24 38	 mov	 rax, QWORD PTR indices$22835[rsp]
  00113	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00118	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0011d	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  00121	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00126	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0012a	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0012f	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06GDBDPCAG@O?$CIOn?$CJN?$AA@
  0013a	e8 00 00 00 00	 call	 Py_BuildValue
$LN6@cwr_reduce:
$LN8@cwr_reduce:
$LN10@cwr_reduce:

; 2810 :     }
; 2811 : }

  0013f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00143	c3		 ret	 0
cwr_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0N@PNDPACPO@cwr_setstate?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$cwr_setstate DD imagerel cwr_setstate
	DD	imagerel cwr_setstate+611
	DD	imagerel $unwind$cwr_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cwr_setstate DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0N@PNDPACPO@cwr_setstate?$AA@
CONST	SEGMENT
??_C@_0N@PNDPACPO@cwr_setstate?$AA@ DB 'cwr_setstate', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT cwr_setstate
_TEXT	SEGMENT
i$ = 48
n$ = 56
result$ = 64
index$22868 = 72
indexObject$22866 = 80
element$22880 = 88
_py_tmp$22889 = 96
lz$ = 128
state$ = 136
cwr_setstate PROC					; COMDAT

; 2815 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2816 :     PyObject *result;
; 2817 :     Py_ssize_t n, i;
; 2818 : 
; 2819 :     if (!PyTuple_Check(state) || PyTuple_GET_SIZE(state) != lz->r)

  0000e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00016	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00020	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00025	85 c0		 test	 eax, eax
  00027	74 1a		 je	 SHORT $LN16@cwr_setsta
  00029	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00031	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR lz$[rsp]
  00039	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  0003d	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00041	74 1a		 je	 SHORT $LN17@cwr_setsta
$LN16@cwr_setsta:

; 2820 :     {
; 2821 :         PyErr_SetString(PyExc_ValueError, "invalid arguments");

  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@KNPMEBHA@invalid?5arguments?$AA@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00051	e8 00 00 00 00	 call	 PyErr_SetString

; 2822 :         return NULL;

  00056	33 c0		 xor	 eax, eax
  00058	e9 01 02 00 00	 jmp	 $LN18@cwr_setsta
$LN17@cwr_setsta:

; 2823 :     }
; 2824 : 
; 2825 :     n = PyTuple_GET_SIZE(lz->pool);

  0005d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00065	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00069	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006d	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax

; 2826 :     for (i=0; i<lz->r; i++)

  00072	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0007b	eb 0d		 jmp	 SHORT $LN15@cwr_setsta
$LN14@cwr_setsta:
  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00082	48 ff c0	 inc	 rax
  00085	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN15@cwr_setsta:
  0008a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00092	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00096	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0009b	0f 8d 8d 00 00
	00		 jge	 $LN13@cwr_setsta

; 2827 :     {
; 2828 :         PyObject* indexObject = PyTuple_GET_ITEM(state, i);

  000a1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  000ae	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  000b3	48 89 44 24 50	 mov	 QWORD PTR indexObject$22866[rsp], rax

; 2829 :         Py_ssize_t index = PyLong_AsSsize_t(indexObject);

  000b8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR indexObject$22866[rsp]
  000bd	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000c2	48 89 44 24 48	 mov	 QWORD PTR index$22868[rsp], rax

; 2830 :         if (index < 0 && PyErr_Occurred())

  000c7	48 83 7c 24 48
	00		 cmp	 QWORD PTR index$22868[rsp], 0
  000cd	7d 11		 jge	 SHORT $LN12@cwr_setsta
  000cf	e8 00 00 00 00	 call	 PyErr_Occurred
  000d4	48 85 c0	 test	 rax, rax
  000d7	74 07		 je	 SHORT $LN12@cwr_setsta

; 2831 :             return NULL; /* not an integer */

  000d9	33 c0		 xor	 eax, eax
  000db	e9 7e 01 00 00	 jmp	 $LN18@cwr_setsta
$LN12@cwr_setsta:

; 2832 :         /* clamp the index */
; 2833 :         if (index < 0)

  000e0	48 83 7c 24 48
	00		 cmp	 QWORD PTR index$22868[rsp], 0
  000e6	7d 0b		 jge	 SHORT $LN11@cwr_setsta

; 2834 :             index = 0;

  000e8	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR index$22868[rsp], 0
  000f1	eb 1c		 jmp	 SHORT $LN10@cwr_setsta
$LN11@cwr_setsta:

; 2835 :         else if (index > n-1)

  000f3	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  000f8	48 ff c8	 dec	 rax
  000fb	48 39 44 24 48	 cmp	 QWORD PTR index$22868[rsp], rax
  00100	7e 0d		 jle	 SHORT $LN9@cwr_setsta

; 2836 :             index = n-1;

  00102	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  00107	48 ff c8	 dec	 rax
  0010a	48 89 44 24 48	 mov	 QWORD PTR index$22868[rsp], rax
$LN9@cwr_setsta:
$LN10@cwr_setsta:

; 2837 :         lz->indices[i] = index;

  0010f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00117	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0011b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00120	48 8b 54 24 48	 mov	 rdx, QWORD PTR index$22868[rsp]
  00125	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 2838 :     }

  00129	e9 4f ff ff ff	 jmp	 $LN14@cwr_setsta
$LN13@cwr_setsta:

; 2839 :     result = PyTuple_New(lz->r);

  0012e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00136	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  0013a	e8 00 00 00 00	 call	 PyTuple_New
  0013f	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 2840 :     if (result == NULL)

  00144	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$[rsp], 0
  0014a	75 07		 jne	 SHORT $LN8@cwr_setsta

; 2841 :         return NULL;

  0014c	33 c0		 xor	 eax, eax
  0014e	e9 0b 01 00 00	 jmp	 $LN18@cwr_setsta
$LN8@cwr_setsta:

; 2842 :     for (i=0; i<lz->r; i++) {

  00153	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0015c	eb 0d		 jmp	 SHORT $LN7@cwr_setsta
$LN6@cwr_setsta:
  0015e	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00163	48 ff c0	 inc	 rax
  00166	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN7@cwr_setsta:
  0016b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00173	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00177	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0017c	7d 4b		 jge	 SHORT $LN5@cwr_setsta

; 2843 :         PyObject *element = PyTuple_GET_ITEM(lz->pool, lz->indices[i]);

  0017e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00186	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0018a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR lz$[rsp]
  00192	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00196	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  0019b	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0019f	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  001a4	48 89 44 24 58	 mov	 QWORD PTR element$22880[rsp], rax

; 2844 :         Py_INCREF(element);

  001a9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR element$22880[rsp]
  001ae	e8 00 00 00 00	 call	 _Py_IncRef

; 2845 :         PyTuple_SET_ITEM(result, i, element);

  001b3	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  001b8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  001bd	48 8b 54 24 58	 mov	 rdx, QWORD PTR element$22880[rsp]
  001c2	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 2846 :     }

  001c7	eb 95		 jmp	 SHORT $LN6@cwr_setsta
$LN5@cwr_setsta:
$LN4@cwr_setsta:

; 2847 :     Py_CLEAR(lz->result);

  001c9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  001d1	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  001d6	74 5c		 je	 SHORT $LN1@cwr_setsta
  001d8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  001e8	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  001ec	41 b8 1f 0b 00
	00		 mov	 r8d, 2847		; 00000b1fH
  001f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  001f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@PNDPACPO@cwr_setstate?$AA@
  00200	e8 00 00 00 00	 call	 _PyParallel_Guard
  00205	85 c0		 test	 eax, eax
  00207	75 2b		 jne	 SHORT $LN1@cwr_setsta
  00209	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00211	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00215	48 89 44 24 60	 mov	 QWORD PTR _py_tmp$22889[rsp], rax
  0021a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00222	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
  0022a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _py_tmp$22889[rsp]
  0022f	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@cwr_setsta:
  00234	33 c0		 xor	 eax, eax
  00236	85 c0		 test	 eax, eax
  00238	75 8f		 jne	 SHORT $LN4@cwr_setsta

; 2848 :     lz->result = result;

  0023a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR lz$[rsp]
  00242	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  00247	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2849 :     Py_RETURN_NONE;

  0024b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00252	e8 00 00 00 00	 call	 _Py_IncRef
  00257	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN18@cwr_setsta:

; 2850 : }

  0025e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00262	c3		 ret	 0
cwr_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@KNAONBFI@Expected?5int?5as?5r?$AA@	; `string'
PUBLIC	??_C@_0BB@CEDADCBD@O?$HMO?3permutations?$AA@	; `string'
EXTRN	PyExc_TypeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$permutations_new DD imagerel permutations_new
	DD	imagerel permutations_new+748
	DD	imagerel $unwind$permutations_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$permutations_new DD 021601H
	DD	0110116H
xdata	ENDS
;	COMDAT ??_C@_0BC@KNAONBFI@Expected?5int?5as?5r?$AA@
CONST	SEGMENT
??_C@_0BC@KNAONBFI@Expected?5int?5as?5r?$AA@ DB 'Expected int as r', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CEDADCBD@O?$HMO?3permutations?$AA@
CONST	SEGMENT
??_C@_0BB@CEDADCBD@O?$HMO?3permutations?$AA@ DB 'O|O:permutations', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT permutations_new
_TEXT	SEGMENT
robj$ = 48
i$ = 56
n$ = 64
indices$ = 72
cycles$ = 80
po$ = 88
iterable$ = 96
r$ = 104
pool$ = 112
tv152 = 120
type$ = 144
args$ = 152
kwds$ = 160
permutations_new PROC					; COMDAT

; 2951 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2952 :     permutationsobject *po;
; 2953 :     Py_ssize_t n;
; 2954 :     Py_ssize_t r;
; 2955 :     PyObject *robj = Py_None;

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001d	48 89 44 24 30	 mov	 QWORD PTR robj$[rsp], rax

; 2956 :     PyObject *pool = NULL;

  00022	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR pool$[rsp], 0

; 2957 :     PyObject *iterable = NULL;

  0002b	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR iterable$[rsp], 0

; 2958 :     Py_ssize_t *indices = NULL;

  00034	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR indices$[rsp], 0

; 2959 :     Py_ssize_t *cycles = NULL;

  0003d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR cycles$[rsp], 0

; 2960 :     Py_ssize_t i;
; 2961 :     static char *kwargs[] = {"iterable", "r", NULL};
; 2962 : 
; 2963 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|O:permutations", kwargs,
; 2964 :                                      &iterable, &robj))

  00046	48 8d 44 24 30	 lea	 rax, QWORD PTR robj$[rsp]
  0004b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00050	48 8d 44 24 60	 lea	 rax, QWORD PTR iterable$[rsp]
  00055	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwargs@?1??permutations_new@@9@9
  00061	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BB@CEDADCBD@O?$HMO?3permutations?$AA@
  00068	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00070	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00078	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0007d	85 c0		 test	 eax, eax
  0007f	75 07		 jne	 SHORT $LN21@permutatio

; 2965 :         return NULL;

  00081	33 c0		 xor	 eax, eax
  00083	e9 5c 02 00 00	 jmp	 $LN22@permutatio
$LN21@permutatio:

; 2966 : 
; 2967 :     pool = PySequence_Tuple(iterable);

  00088	48 8b 4c 24 60	 mov	 rcx, QWORD PTR iterable$[rsp]
  0008d	e8 00 00 00 00	 call	 PySequence_Tuple
  00092	48 89 44 24 70	 mov	 QWORD PTR pool$[rsp], rax

; 2968 :     if (pool == NULL)

  00097	48 83 7c 24 70
	00		 cmp	 QWORD PTR pool$[rsp], 0
  0009d	75 05		 jne	 SHORT $LN20@permutatio

; 2969 :         goto error;

  0009f	e9 02 02 00 00	 jmp	 $error$22957
$LN20@permutatio:

; 2970 :     n = PyTuple_GET_SIZE(pool);

  000a4	48 8b 44 24 70	 mov	 rax, QWORD PTR pool$[rsp]
  000a9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ad	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax

; 2971 : 
; 2972 :     r = n;

  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR n$[rsp]
  000b7	48 89 44 24 68	 mov	 QWORD PTR r$[rsp], rax

; 2973 :     if (robj != Py_None) {

  000bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000c3	48 39 44 24 30	 cmp	 QWORD PTR robj$[rsp], rax
  000c8	74 56		 je	 SHORT $LN19@permutatio

; 2974 :         if (!PyLong_Check(robj)) {

  000ca	48 8b 44 24 30	 mov	 rax, QWORD PTR robj$[rsp]
  000cf	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d9	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000de	85 c0		 test	 eax, eax
  000e0	75 18		 jne	 SHORT $LN18@permutatio

; 2975 :             PyErr_SetString(PyExc_TypeError, "Expected int as r");

  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@KNAONBFI@Expected?5int?5as?5r?$AA@
  000e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000f0	e8 00 00 00 00	 call	 PyErr_SetString

; 2976 :             goto error;

  000f5	e9 ac 01 00 00	 jmp	 $error$22957
$LN18@permutatio:

; 2977 :         }
; 2978 :         r = PyLong_AsSsize_t(robj);

  000fa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR robj$[rsp]
  000ff	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  00104	48 89 44 24 68	 mov	 QWORD PTR r$[rsp], rax

; 2979 :         if (r == -1 && PyErr_Occurred())

  00109	48 83 7c 24 68
	ff		 cmp	 QWORD PTR r$[rsp], -1
  0010f	75 0f		 jne	 SHORT $LN17@permutatio
  00111	e8 00 00 00 00	 call	 PyErr_Occurred
  00116	48 85 c0	 test	 rax, rax
  00119	74 05		 je	 SHORT $LN17@permutatio

; 2980 :             goto error;

  0011b	e9 86 01 00 00	 jmp	 $error$22957
$LN17@permutatio:
$LN19@permutatio:

; 2981 :     }
; 2982 :     if (r < 0) {

  00120	48 83 7c 24 68
	00		 cmp	 QWORD PTR r$[rsp], 0
  00126	7d 18		 jge	 SHORT $LN16@permutatio

; 2983 :         PyErr_SetString(PyExc_ValueError, "r must be non-negative");

  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@GBDHCGGF@r?5must?5be?5non?9negative?$AA@
  0012f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00136	e8 00 00 00 00	 call	 PyErr_SetString

; 2984 :         goto error;

  0013b	e9 66 01 00 00	 jmp	 $error$22957
$LN16@permutatio:

; 2985 :     }
; 2986 : 
; 2987 :     indices = PyMem_Malloc(n * sizeof(Py_ssize_t));

  00140	48 8b 44 24 40	 mov	 rax, QWORD PTR n$[rsp]
  00145	48 c1 e0 03	 shl	 rax, 3
  00149	48 8b c8	 mov	 rcx, rax
  0014c	e8 00 00 00 00	 call	 PyMem_Malloc
  00151	48 89 44 24 48	 mov	 QWORD PTR indices$[rsp], rax

; 2988 :     cycles = PyMem_Malloc(r * sizeof(Py_ssize_t));

  00156	48 8b 44 24 68	 mov	 rax, QWORD PTR r$[rsp]
  0015b	48 c1 e0 03	 shl	 rax, 3
  0015f	48 8b c8	 mov	 rcx, rax
  00162	e8 00 00 00 00	 call	 PyMem_Malloc
  00167	48 89 44 24 50	 mov	 QWORD PTR cycles$[rsp], rax

; 2989 :     if (indices == NULL || cycles == NULL) {

  0016c	48 83 7c 24 48
	00		 cmp	 QWORD PTR indices$[rsp], 0
  00172	74 08		 je	 SHORT $LN14@permutatio
  00174	48 83 7c 24 50
	00		 cmp	 QWORD PTR cycles$[rsp], 0
  0017a	75 0a		 jne	 SHORT $LN15@permutatio
$LN14@permutatio:

; 2990 :         PyErr_NoMemory();

  0017c	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2991 :         goto error;

  00181	e9 20 01 00 00	 jmp	 $error$22957
$LN15@permutatio:

; 2992 :     }
; 2993 : 
; 2994 :     for (i=0 ; i<n ; i++)

  00186	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0018f	eb 0d		 jmp	 SHORT $LN13@permutatio
$LN12@permutatio:
  00191	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  00196	48 ff c0	 inc	 rax
  00199	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN13@permutatio:
  0019e	48 8b 44 24 40	 mov	 rax, QWORD PTR n$[rsp]
  001a3	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  001a8	7d 15		 jge	 SHORT $LN11@permutatio

; 2995 :         indices[i] = i;

  001aa	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  001af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR i$[rsp]
  001b4	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  001b9	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  001bd	eb d2		 jmp	 SHORT $LN12@permutatio
$LN11@permutatio:

; 2996 :     for (i=0 ; i<r ; i++)

  001bf	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001c8	eb 0d		 jmp	 SHORT $LN10@permutatio
$LN9@permutatio:
  001ca	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  001cf	48 ff c0	 inc	 rax
  001d2	48 89 44 24 38	 mov	 QWORD PTR i$[rsp], rax
$LN10@permutatio:
  001d7	48 8b 44 24 68	 mov	 rax, QWORD PTR r$[rsp]
  001dc	48 39 44 24 38	 cmp	 QWORD PTR i$[rsp], rax
  001e1	7d 20		 jge	 SHORT $LN8@permutatio

; 2997 :         cycles[i] = n - i;

  001e3	48 8b 44 24 38	 mov	 rax, QWORD PTR i$[rsp]
  001e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  001ed	48 2b c8	 sub	 rcx, rax
  001f0	48 8b c1	 mov	 rax, rcx
  001f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cycles$[rsp]
  001f8	48 8b 54 24 38	 mov	 rdx, QWORD PTR i$[rsp]
  001fd	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax
  00201	eb c7		 jmp	 SHORT $LN9@permutatio
$LN8@permutatio:

; 2998 : 
; 2999 :     /* create permutationsobject structure */
; 3000 :     po = (permutationsobject *)type->tp_alloc(type, 0);

  00203	33 d2		 xor	 edx, edx
  00205	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  0020d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  00215	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  0021b	48 89 44 24 58	 mov	 QWORD PTR po$[rsp], rax

; 3001 :     if (po == NULL)

  00220	48 83 7c 24 58
	00		 cmp	 QWORD PTR po$[rsp], 0
  00226	75 02		 jne	 SHORT $LN7@permutatio

; 3002 :         goto error;

  00228	eb 7c		 jmp	 SHORT $error$22957
$LN7@permutatio:

; 3003 : 
; 3004 :     po->pool = pool;

  0022a	48 8b 44 24 58	 mov	 rax, QWORD PTR po$[rsp]
  0022f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pool$[rsp]
  00234	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3005 :     po->indices = indices;

  00238	48 8b 44 24 58	 mov	 rax, QWORD PTR po$[rsp]
  0023d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR indices$[rsp]
  00242	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 3006 :     po->cycles = cycles;

  00246	48 8b 44 24 58	 mov	 rax, QWORD PTR po$[rsp]
  0024b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cycles$[rsp]
  00250	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 3007 :     po->result = NULL;

  00254	48 8b 44 24 58	 mov	 rax, QWORD PTR po$[rsp]
  00259	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 3008 :     po->r = r;

  00261	48 8b 44 24 58	 mov	 rax, QWORD PTR po$[rsp]
  00266	48 8b 4c 24 68	 mov	 rcx, QWORD PTR r$[rsp]
  0026b	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 3009 :     po->stopped = r > n ? 1 : 0;

  00272	48 8b 44 24 40	 mov	 rax, QWORD PTR n$[rsp]
  00277	48 39 44 24 68	 cmp	 QWORD PTR r$[rsp], rax
  0027c	7e 0a		 jle	 SHORT $LN24@permutatio
  0027e	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv152[rsp], 1
  00286	eb 08		 jmp	 SHORT $LN25@permutatio
$LN24@permutatio:
  00288	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN25@permutatio:
  00290	48 8b 44 24 58	 mov	 rax, QWORD PTR po$[rsp]
  00295	8b 4c 24 78	 mov	 ecx, DWORD PTR tv152[rsp]
  00299	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 3010 : 
; 3011 :     return (PyObject *)po;

  0029f	48 8b 44 24 58	 mov	 rax, QWORD PTR po$[rsp]
  002a4	eb 3e		 jmp	 SHORT $LN22@permutatio
$error$22957:

; 3012 : 
; 3013 : error:
; 3014 :     if (indices != NULL)

  002a6	48 83 7c 24 48
	00		 cmp	 QWORD PTR indices$[rsp], 0
  002ac	74 0a		 je	 SHORT $LN6@permutatio

; 3015 :         PyMem_Free(indices);

  002ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR indices$[rsp]
  002b3	e8 00 00 00 00	 call	 PyMem_Free
$LN6@permutatio:

; 3016 :     if (cycles != NULL)

  002b8	48 83 7c 24 50
	00		 cmp	 QWORD PTR cycles$[rsp], 0
  002be	74 0a		 je	 SHORT $LN5@permutatio

; 3017 :         PyMem_Free(cycles);

  002c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cycles$[rsp]
  002c5	e8 00 00 00 00	 call	 PyMem_Free
$LN5@permutatio:
$LN4@permutatio:

; 3018 :     Py_XDECREF(pool);

  002ca	48 83 7c 24 70
	00		 cmp	 QWORD PTR pool$[rsp], 0
  002d0	74 0a		 je	 SHORT $LN1@permutatio
  002d2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pool$[rsp]
  002d7	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@permutatio:
  002dc	33 c0		 xor	 eax, eax
  002de	85 c0		 test	 eax, eax
  002e0	75 e8		 jne	 SHORT $LN4@permutatio

; 3019 :     return NULL;

  002e2	33 c0		 xor	 eax, eax
$LN22@permutatio:

; 3020 : }

  002e4	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002eb	c3		 ret	 0
permutations_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$permutations_dealloc DD imagerel permutations_dealloc
	DD	imagerel permutations_dealloc+136
	DD	imagerel $unwind$permutations_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$permutations_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT permutations_dealloc
_TEXT	SEGMENT
po$ = 48
permutations_dealloc PROC				; COMDAT

; 3024 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3025 :     PyObject_GC_UnTrack(po);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR po$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN8@permutatio@2:

; 3026 :     Py_XDECREF(po->pool);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR po$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN5@permutatio@2
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR po$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@permutatio@2:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN8@permutatio@2
$LN4@permutatio@2:

; 3027 :     Py_XDECREF(po->result);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR po$[rsp]
  00038	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0003d	74 0e		 je	 SHORT $LN1@permutatio@2
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR po$[rsp]
  00044	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@permutatio@2:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN4@permutatio@2

; 3028 :     PyMem_Free(po->indices);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR po$[rsp]
  00058	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  0005c	e8 00 00 00 00	 call	 PyMem_Free

; 3029 :     PyMem_Free(po->cycles);

  00061	48 8b 44 24 30	 mov	 rax, QWORD PTR po$[rsp]
  00066	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0006a	e8 00 00 00 00	 call	 PyMem_Free

; 3030 :     Py_TYPE(po)->tp_free(po);

  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR po$[rsp]
  00074	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR po$[rsp]
  0007d	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 3031 : }

  00083	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00087	c3		 ret	 0
permutations_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@KCJLJPHA@permutations_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$permutations_traverse DD imagerel permutations_traverse
	DD	imagerel permutations_traverse+206
	DD	imagerel $unwind$permutations_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$permutations_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BG@KCJLJPHA@permutations_traverse?$AA@
CONST	SEGMENT
??_C@_0BG@KCJLJPHA@permutations_traverse?$AA@ DB 'permutations_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT permutations_traverse
_TEXT	SEGMENT
vret$23021 = 32
vret$23029 = 36
po$ = 64
visit$ = 72
arg$ = 80
permutations_traverse PROC				; COMDAT

; 3035 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@permutatio@3:

; 3036 :     Py_VISIT(po->pool);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@permutatio@3
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 dc 0b 00
	00		 mov	 r8d, 3036		; 00000bdcH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@KCJLJPHA@permutations_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@permutatio@3:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR po$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN8@permutatio@3
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR po$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$23021[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$23021[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@permutatio@3
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$23021[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@permutatio@3
$LN7@permutatio@3:
$LN8@permutatio@3:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@permutatio@3
$LN6@permutatio@3:

; 3037 :     Py_VISIT(po->result);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@permutatio@3
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 dd 0b 00
	00		 mov	 r8d, 3037		; 00000bddH
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@KCJLJPHA@permutations_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@permutatio@3:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR po$[rsp]
  00097	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0009c	74 23		 je	 SHORT $LN2@permutatio@3
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR po$[rsp]
  000a8	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$23029[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$23029[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@permutatio@3
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$23029[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@permutatio@3
$LN1@permutatio@3:
$LN2@permutatio@3:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@permutatio@3

; 3038 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@permutatio@3:

; 3039 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
permutations_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$permutations_next DD imagerel permutations_next
	DD	imagerel permutations_next+1090
	DD	imagerel $unwind$permutations_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$permutations_next DD 020c01H
	DD	013010cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT permutations_next
_TEXT	SEGMENT
elem$ = 32
i$ = 40
n$ = 48
oldelem$ = 56
index$ = 64
indices$ = 72
cycles$ = 80
k$ = 88
r$ = 96
result$ = 104
j$ = 112
pool$ = 120
old_result$23066 = 128
po$ = 160
permutations_next PROC					; COMDAT

; 3043 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 3044 :     PyObject *elem;
; 3045 :     PyObject *oldelem;
; 3046 :     PyObject *pool = po->pool;

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00014	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00018	48 89 44 24 78	 mov	 QWORD PTR pool$[rsp], rax

; 3047 :     Py_ssize_t *indices = po->indices;

  0001d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00025	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00029	48 89 44 24 48	 mov	 QWORD PTR indices$[rsp], rax

; 3048 :     Py_ssize_t *cycles = po->cycles;

  0002e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00036	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0003a	48 89 44 24 50	 mov	 QWORD PTR cycles$[rsp], rax

; 3049 :     PyObject *result = po->result;

  0003f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00047	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  0004b	48 89 44 24 68	 mov	 QWORD PTR result$[rsp], rax

; 3050 :     Py_ssize_t n = PyTuple_GET_SIZE(pool);

  00050	48 8b 44 24 78	 mov	 rax, QWORD PTR pool$[rsp]
  00055	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00059	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 3051 :     Py_ssize_t r = po->r;

  0005e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00066	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0006d	48 89 44 24 60	 mov	 QWORD PTR r$[rsp], rax

; 3052 :     Py_ssize_t i, j, k, index;
; 3053 : 
; 3054 :     if (po->stopped)

  00072	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  0007a	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00081	74 07		 je	 SHORT $LN25@permutatio@4

; 3055 :         return NULL;

  00083	33 c0		 xor	 eax, eax
  00085	e9 b0 03 00 00	 jmp	 $LN26@permutatio@4
$LN25@permutatio@4:

; 3056 : 
; 3057 :     if (result == NULL) {

  0008a	48 83 7c 24 68
	00		 cmp	 QWORD PTR result$[rsp], 0
  00090	0f 85 9d 00 00
	00		 jne	 $LN24@permutatio@4

; 3058 :         /* On the first pass, initialize result tuple using the indices */
; 3059 :         result = PyTuple_New(r);

  00096	48 8b 4c 24 60	 mov	 rcx, QWORD PTR r$[rsp]
  0009b	e8 00 00 00 00	 call	 PyTuple_New
  000a0	48 89 44 24 68	 mov	 QWORD PTR result$[rsp], rax

; 3060 :         if (result == NULL)

  000a5	48 83 7c 24 68
	00		 cmp	 QWORD PTR result$[rsp], 0
  000ab	75 05		 jne	 SHORT $LN23@permutatio@4

; 3061 :             goto empty;

  000ad	e9 74 03 00 00	 jmp	 $empty$23055
$LN23@permutatio@4:

; 3062 :         po->result = result;

  000b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  000ba	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result$[rsp]
  000bf	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 3063 :         for (i=0; i<r ; i++) {

  000c3	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000cc	eb 0d		 jmp	 SHORT $LN22@permutatio@4
$LN21@permutatio@4:
  000ce	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000d3	48 ff c0	 inc	 rax
  000d6	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN22@permutatio@4:
  000db	48 8b 44 24 60	 mov	 rax, QWORD PTR r$[rsp]
  000e0	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000e5	7d 47		 jge	 SHORT $LN20@permutatio@4

; 3064 :             index = indices[i];

  000e7	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  000ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000f1	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000f5	48 89 44 24 40	 mov	 QWORD PTR index$[rsp], rax

; 3065 :             elem = PyTuple_GET_ITEM(pool, index);

  000fa	48 8b 44 24 78	 mov	 rax, QWORD PTR pool$[rsp]
  000ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR index$[rsp]
  00104	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00109	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 3066 :             Py_INCREF(elem);

  0010e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  00113	e8 00 00 00 00	 call	 _Py_IncRef

; 3067 :             PyTuple_SET_ITEM(result, i, elem);

  00118	48 8b 44 24 68	 mov	 rax, QWORD PTR result$[rsp]
  0011d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00122	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  00127	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 3068 :         }

  0012c	eb a0		 jmp	 SHORT $LN21@permutatio@4
$LN20@permutatio@4:

; 3069 :     } else {

  0012e	e9 e2 02 00 00	 jmp	 $LN19@permutatio@4
$LN24@permutatio@4:

; 3070 :         if (n == 0)

  00133	48 83 7c 24 30
	00		 cmp	 QWORD PTR n$[rsp], 0
  00139	75 05		 jne	 SHORT $LN18@permutatio@4

; 3071 :             goto empty;

  0013b	e9 e6 02 00 00	 jmp	 $empty$23055
$LN18@permutatio@4:

; 3072 : 
; 3073 :         /* Copy the previous result tuple or re-use it if available */
; 3074 :         if (Py_REFCNT(result) > 1) {

  00140	48 8b 44 24 68	 mov	 rax, QWORD PTR result$[rsp]
  00145	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  0014a	0f 8e a2 00 00
	00		 jle	 $LN17@permutatio@4

; 3075 :             PyObject *old_result = result;

  00150	48 8b 44 24 68	 mov	 rax, QWORD PTR result$[rsp]
  00155	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR old_result$23066[rsp], rax

; 3076 :             result = PyTuple_New(r);

  0015d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR r$[rsp]
  00162	e8 00 00 00 00	 call	 PyTuple_New
  00167	48 89 44 24 68	 mov	 QWORD PTR result$[rsp], rax

; 3077 :             if (result == NULL)

  0016c	48 83 7c 24 68
	00		 cmp	 QWORD PTR result$[rsp], 0
  00172	75 05		 jne	 SHORT $LN16@permutatio@4

; 3078 :                 goto empty;

  00174	e9 ad 02 00 00	 jmp	 $empty$23055
$LN16@permutatio@4:

; 3079 :             po->result = result;

  00179	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00181	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result$[rsp]
  00186	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 3080 :             for (i=0; i<r ; i++) {

  0018a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00193	eb 0d		 jmp	 SHORT $LN15@permutatio@4
$LN14@permutatio@4:
  00195	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0019a	48 ff c0	 inc	 rax
  0019d	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN15@permutatio@4:
  001a2	48 8b 44 24 60	 mov	 rax, QWORD PTR r$[rsp]
  001a7	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  001ac	7d 37		 jge	 SHORT $LN13@permutatio@4

; 3081 :                 elem = PyTuple_GET_ITEM(old_result, i);

  001ae	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR old_result$23066[rsp]
  001b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  001bb	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  001c0	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 3082 :                 Py_INCREF(elem);

  001c5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  001ca	e8 00 00 00 00	 call	 _Py_IncRef

; 3083 :                 PyTuple_SET_ITEM(result, i, elem);

  001cf	48 8b 44 24 68	 mov	 rax, QWORD PTR result$[rsp]
  001d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  001d9	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  001de	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 3084 :             }

  001e3	eb b0		 jmp	 SHORT $LN14@permutatio@4
$LN13@permutatio@4:

; 3085 :             Py_DECREF(old_result);

  001e5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR old_result$23066[rsp]
  001ed	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@permutatio@4:

; 3086 :         }
; 3087 :         /* Now, we've got the only copy so we can update it in-place */
; 3088 :         assert(r == 0 || Py_REFCNT(result) == 1);

  001f2	48 83 7c 24 60
	00		 cmp	 QWORD PTR r$[rsp], 0
  001f8	74 28		 je	 SHORT $LN28@permutatio@4
  001fa	48 8b 44 24 68	 mov	 rax, QWORD PTR result$[rsp]
  001ff	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  00204	74 1c		 je	 SHORT $LN28@permutatio@4
  00206	41 b8 10 0c 00
	00		 mov	 r8d, 3088		; 00000c10H
  0020c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@JPBKELHI@?$AAr?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AAP?$AAy?$AA_?$AAR?$AAE?$AAF?$AAC?$AAN?$AAT?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1@
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00220	33 c0		 xor	 eax, eax
$LN28@permutatio@4:

; 3089 : 
; 3090 :         /* Decrement rightmost cycle, moving leftward upon zero rollover */
; 3091 :         for (i=r-1 ; i>=0 ; i--) {

  00222	48 8b 44 24 60	 mov	 rax, QWORD PTR r$[rsp]
  00227	48 ff c8	 dec	 rax
  0022a	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
  0022f	eb 0d		 jmp	 SHORT $LN12@permutatio@4
$LN11@permutatio@4:
  00231	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00236	48 ff c8	 dec	 rax
  00239	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN12@permutatio@4:
  0023e	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00244	0f 8c c1 01 00
	00		 jl	 $LN10@permutatio@4

; 3092 :             cycles[i] -= 1;

  0024a	48 8b 44 24 50	 mov	 rax, QWORD PTR cycles$[rsp]
  0024f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00254	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00258	48 ff c8	 dec	 rax
  0025b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cycles$[rsp]
  00260	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00265	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 3093 :             if (cycles[i] == 0) {

  00269	48 8b 44 24 50	 mov	 rax, QWORD PTR cycles$[rsp]
  0026e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00273	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00278	0f 85 91 00 00
	00		 jne	 $LN9@permutatio@4

; 3094 :                 /* rotatation: indices[i:] = indices[i+1:] + indices[i:i+1] */
; 3095 :                 index = indices[i];

  0027e	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  00283	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00288	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0028c	48 89 44 24 40	 mov	 QWORD PTR index$[rsp], rax

; 3096 :                 for (j=i ; j<n-1 ; j++)

  00291	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  00296	48 89 44 24 70	 mov	 QWORD PTR j$[rsp], rax
  0029b	eb 0d		 jmp	 SHORT $LN8@permutatio@4
$LN7@permutatio@4:
  0029d	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  002a2	48 ff c0	 inc	 rax
  002a5	48 89 44 24 70	 mov	 QWORD PTR j$[rsp], rax
$LN8@permutatio@4:
  002aa	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  002af	48 ff c8	 dec	 rax
  002b2	48 39 44 24 70	 cmp	 QWORD PTR j$[rsp], rax
  002b7	7d 1f		 jge	 SHORT $LN6@permutatio@4

; 3097 :                     indices[j] = indices[j+1];

  002b9	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  002be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR j$[rsp]
  002c3	48 8b 54 24 48	 mov	 rdx, QWORD PTR indices$[rsp]
  002c8	4c 8b 44 24 70	 mov	 r8, QWORD PTR j$[rsp]
  002cd	4a 8b 54 c2 08	 mov	 rdx, QWORD PTR [rdx+r8*8+8]
  002d2	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx
  002d6	eb c5		 jmp	 SHORT $LN7@permutatio@4
$LN6@permutatio@4:

; 3098 :                 indices[n-1] = index;

  002d8	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  002dd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  002e2	48 8b 54 24 40	 mov	 rdx, QWORD PTR index$[rsp]
  002e7	48 89 54 c8 f8	 mov	 QWORD PTR [rax+rcx*8-8], rdx

; 3099 :                 cycles[i] = n - i;

  002ec	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  002f1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  002f6	48 2b c8	 sub	 rcx, rax
  002f9	48 8b c1	 mov	 rax, rcx
  002fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cycles$[rsp]
  00301	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00306	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 3100 :             } else {

  0030a	e9 f7 00 00 00	 jmp	 $LN5@permutatio@4
$LN9@permutatio@4:

; 3101 :                 j = cycles[i];

  0030f	48 8b 44 24 50	 mov	 rax, QWORD PTR cycles$[rsp]
  00314	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00319	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0031d	48 89 44 24 70	 mov	 QWORD PTR j$[rsp], rax

; 3102 :                 index = indices[i];

  00322	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  00327	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0032c	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00330	48 89 44 24 40	 mov	 QWORD PTR index$[rsp], rax

; 3103 :                 indices[i] = indices[n-j];

  00335	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  0033a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  0033f	48 2b c8	 sub	 rcx, rax
  00342	48 8b c1	 mov	 rax, rcx
  00345	48 8b 4c 24 48	 mov	 rcx, QWORD PTR indices$[rsp]
  0034a	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  0034f	4c 8b 44 24 48	 mov	 r8, QWORD PTR indices$[rsp]
  00354	49 8b 04 c0	 mov	 rax, QWORD PTR [r8+rax*8]
  00358	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 3104 :                 indices[n-j] = index;

  0035c	48 8b 44 24 70	 mov	 rax, QWORD PTR j$[rsp]
  00361	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  00366	48 2b c8	 sub	 rcx, rax
  00369	48 8b c1	 mov	 rax, rcx
  0036c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR indices$[rsp]
  00371	48 8b 54 24 40	 mov	 rdx, QWORD PTR index$[rsp]
  00376	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 3105 : 
; 3106 :                 for (k=i; k<r ; k++) {

  0037a	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0037f	48 89 44 24 58	 mov	 QWORD PTR k$[rsp], rax
  00384	eb 0d		 jmp	 SHORT $LN4@permutatio@4
$LN3@permutatio@4:
  00386	48 8b 44 24 58	 mov	 rax, QWORD PTR k$[rsp]
  0038b	48 ff c0	 inc	 rax
  0038e	48 89 44 24 58	 mov	 QWORD PTR k$[rsp], rax
$LN4@permutatio@4:
  00393	48 8b 44 24 60	 mov	 rax, QWORD PTR r$[rsp]
  00398	48 39 44 24 58	 cmp	 QWORD PTR k$[rsp], rax
  0039d	7d 65		 jge	 SHORT $LN2@permutatio@4

; 3107 :                     /* start with i, the leftmost element that changed */
; 3108 :                     /* yield tuple(pool[k] for k in indices[:r]) */
; 3109 :                     index = indices[k];

  0039f	48 8b 44 24 48	 mov	 rax, QWORD PTR indices$[rsp]
  003a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR k$[rsp]
  003a9	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  003ad	48 89 44 24 40	 mov	 QWORD PTR index$[rsp], rax

; 3110 :                     elem = PyTuple_GET_ITEM(pool, index);

  003b2	48 8b 44 24 78	 mov	 rax, QWORD PTR pool$[rsp]
  003b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR index$[rsp]
  003bc	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  003c1	48 89 44 24 20	 mov	 QWORD PTR elem$[rsp], rax

; 3111 :                     Py_INCREF(elem);

  003c6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR elem$[rsp]
  003cb	e8 00 00 00 00	 call	 _Py_IncRef

; 3112 :                     oldelem = PyTuple_GET_ITEM(result, k);

  003d0	48 8b 44 24 68	 mov	 rax, QWORD PTR result$[rsp]
  003d5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR k$[rsp]
  003da	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  003df	48 89 44 24 38	 mov	 QWORD PTR oldelem$[rsp], rax

; 3113 :                     PyTuple_SET_ITEM(result, k, elem);

  003e4	48 8b 44 24 68	 mov	 rax, QWORD PTR result$[rsp]
  003e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR k$[rsp]
  003ee	48 8b 54 24 20	 mov	 rdx, QWORD PTR elem$[rsp]
  003f3	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 3114 :                     Py_DECREF(oldelem);

  003f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR oldelem$[rsp]
  003fd	e8 00 00 00 00	 call	 _Py_DecRef

; 3115 :                 }

  00402	eb 82		 jmp	 SHORT $LN3@permutatio@4
$LN2@permutatio@4:

; 3116 :                 break;

  00404	eb 05		 jmp	 SHORT $LN10@permutatio@4
$LN5@permutatio@4:

; 3117 :             }
; 3118 :         }

  00406	e9 26 fe ff ff	 jmp	 $LN11@permutatio@4
$LN10@permutatio@4:

; 3119 :         /* If i is negative, then the cycles have all
; 3120 :            rolled-over and we're done. */
; 3121 :         if (i < 0)

  0040b	48 83 7c 24 28
	00		 cmp	 QWORD PTR i$[rsp], 0
  00411	7d 02		 jge	 SHORT $LN1@permutatio@4

; 3122 :             goto empty;

  00413	eb 11		 jmp	 SHORT $empty$23055
$LN1@permutatio@4:
$LN19@permutatio@4:

; 3123 :     }
; 3124 :     Py_INCREF(result);

  00415	48 8b 4c 24 68	 mov	 rcx, QWORD PTR result$[rsp]
  0041a	e8 00 00 00 00	 call	 _Py_IncRef

; 3125 :     return result;

  0041f	48 8b 44 24 68	 mov	 rax, QWORD PTR result$[rsp]
  00424	eb 14		 jmp	 SHORT $LN26@permutatio@4
$empty$23055:

; 3126 : 
; 3127 : empty:
; 3128 :     po->stopped = 1;

  00426	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  0042e	c7 80 88 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+136], 1

; 3129 :     return NULL;

  00438	33 c0		 xor	 eax, eax
$LN26@permutatio@4:

; 3130 : }

  0043a	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00441	c3		 ret	 0
permutations_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_09PFECCMPC@O?$CIOn?$CJ?$CINN?$CJ?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$permutations_reduce DD imagerel permutations_reduce
	DD	imagerel permutations_reduce+550
	DD	imagerel $unwind$permutations_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$permutations_reduce DD 010901H
	DD	0c209H
xdata	ENDS
;	COMDAT ??_C@_09PFECCMPC@O?$CIOn?$CJ?$CINN?$CJ?$AA@
CONST	SEGMENT
??_C@_09PFECCMPC@O?$CIOn?$CJ?$CINN?$CJ?$AA@ DB 'O(On)(NN)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT permutations_reduce
_TEXT	SEGMENT
i$23113 = 48
n$23112 = 56
indices$23108 = 64
cycles$23110 = 72
index$23121 = 80
index$23129 = 88
po$ = 112
permutations_reduce PROC				; COMDAT

; 3134 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3135 :     if (po->result == NULL) {

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  0000e	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00013	75 34		 jne	 SHORT $LN22@permutatio@5

; 3136 :         return Py_BuildValue("O(On)", Py_TYPE(po), po->pool, po->r);

  00015	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  0001a	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  00021	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  00026	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0002a	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  0002f	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IEPKLDIK@O?$CIOn?$CJ?$AA@
  0003a	e8 00 00 00 00	 call	 Py_BuildValue
  0003f	e9 dd 01 00 00	 jmp	 $LN23@permutatio@5
  00044	e9 d8 01 00 00	 jmp	 $LN21@permutatio@5
$LN22@permutatio@5:

; 3137 :     } else if (po->stopped) {

  00049	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  0004e	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00055	74 2b		 je	 SHORT $LN20@permutatio@5

; 3138 :         return Py_BuildValue("O(()n)", Py_TYPE(po), po->r);

  00057	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  0005c	4c 8b 80 80 00
	00 00		 mov	 r8, QWORD PTR [rax+128]
  00063	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  00068	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06BBKLFPPK@O?$CI?$CI?$CJn?$CJ?$AA@
  00073	e8 00 00 00 00	 call	 Py_BuildValue
  00078	e9 a4 01 00 00	 jmp	 $LN23@permutatio@5

; 3139 :     } else {

  0007d	e9 9f 01 00 00	 jmp	 $LN19@permutatio@5
$LN20@permutatio@5:

; 3140 :         PyObject *indices=NULL, *cycles=NULL;

  00082	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR indices$23108[rsp], 0
  0008b	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR cycles$23110[rsp], 0

; 3141 :         Py_ssize_t n, i;
; 3142 : 
; 3143 :         /* we must pickle the indices and cycles and use them for setstate */
; 3144 :         n = PyTuple_GET_SIZE(po->pool);

  00094	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  00099	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0009d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a1	48 89 44 24 38	 mov	 QWORD PTR n$23112[rsp], rax

; 3145 :         indices = PyTuple_New(n);

  000a6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$23112[rsp]
  000ab	e8 00 00 00 00	 call	 PyTuple_New
  000b0	48 89 44 24 40	 mov	 QWORD PTR indices$23108[rsp], rax

; 3146 :         if (indices == NULL)

  000b5	48 83 7c 24 40
	00		 cmp	 QWORD PTR indices$23108[rsp], 0
  000bb	75 05		 jne	 SHORT $LN18@permutatio@5

; 3147 :             goto err;

  000bd	e9 2d 01 00 00	 jmp	 $err$23117
$LN18@permutatio@5:

; 3148 :         for (i=0; i<n; i++){

  000c2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$23113[rsp], 0
  000cb	eb 0d		 jmp	 SHORT $LN17@permutatio@5
$LN16@permutatio@5:
  000cd	48 8b 44 24 30	 mov	 rax, QWORD PTR i$23113[rsp]
  000d2	48 ff c0	 inc	 rax
  000d5	48 89 44 24 30	 mov	 QWORD PTR i$23113[rsp], rax
$LN17@permutatio@5:
  000da	48 8b 44 24 38	 mov	 rax, QWORD PTR n$23112[rsp]
  000df	48 39 44 24 30	 cmp	 QWORD PTR i$23113[rsp], rax
  000e4	7d 3f		 jge	 SHORT $LN15@permutatio@5

; 3149 :             PyObject* index = PyLong_FromSsize_t(po->indices[i]);

  000e6	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  000eb	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ef	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$23113[rsp]
  000f4	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  000f8	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  000fd	48 89 44 24 50	 mov	 QWORD PTR index$23121[rsp], rax

; 3150 :             if (!index)

  00102	48 83 7c 24 50
	00		 cmp	 QWORD PTR index$23121[rsp], 0
  00108	75 05		 jne	 SHORT $LN14@permutatio@5

; 3151 :                 goto err;

  0010a	e9 e0 00 00 00	 jmp	 $err$23117
$LN14@permutatio@5:

; 3152 :             PyTuple_SET_ITEM(indices, i, index);

  0010f	48 8b 44 24 40	 mov	 rax, QWORD PTR indices$23108[rsp]
  00114	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$23113[rsp]
  00119	48 8b 54 24 50	 mov	 rdx, QWORD PTR index$23121[rsp]
  0011e	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 3153 :         }

  00123	eb a8		 jmp	 SHORT $LN16@permutatio@5
$LN15@permutatio@5:

; 3154 : 
; 3155 :         cycles = PyTuple_New(po->r);

  00125	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  0012a	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00131	e8 00 00 00 00	 call	 PyTuple_New
  00136	48 89 44 24 48	 mov	 QWORD PTR cycles$23110[rsp], rax

; 3156 :         if (cycles == NULL)

  0013b	48 83 7c 24 48
	00		 cmp	 QWORD PTR cycles$23110[rsp], 0
  00141	75 05		 jne	 SHORT $LN13@permutatio@5

; 3157 :             goto err;

  00143	e9 a7 00 00 00	 jmp	 $err$23117
$LN13@permutatio@5:

; 3158 :         for (i=0; i<po->r; i++)

  00148	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$23113[rsp], 0
  00151	eb 0d		 jmp	 SHORT $LN12@permutatio@5
$LN11@permutatio@5:
  00153	48 8b 44 24 30	 mov	 rax, QWORD PTR i$23113[rsp]
  00158	48 ff c0	 inc	 rax
  0015b	48 89 44 24 30	 mov	 QWORD PTR i$23113[rsp], rax
$LN12@permutatio@5:
  00160	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  00165	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0016c	48 39 44 24 30	 cmp	 QWORD PTR i$23113[rsp], rax
  00171	7d 3c		 jge	 SHORT $LN10@permutatio@5

; 3159 :         {
; 3160 :             PyObject* index = PyLong_FromSsize_t(po->cycles[i]);

  00173	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  00178	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0017c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$23113[rsp]
  00181	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00185	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  0018a	48 89 44 24 58	 mov	 QWORD PTR index$23129[rsp], rax

; 3161 :             if (!index)

  0018f	48 83 7c 24 58
	00		 cmp	 QWORD PTR index$23129[rsp], 0
  00195	75 02		 jne	 SHORT $LN9@permutatio@5

; 3162 :                 goto err;

  00197	eb 56		 jmp	 SHORT $err$23117
$LN9@permutatio@5:

; 3163 :             PyTuple_SET_ITEM(cycles, i, index);

  00199	48 8b 44 24 48	 mov	 rax, QWORD PTR cycles$23110[rsp]
  0019e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$23113[rsp]
  001a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR index$23129[rsp]
  001a8	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 3164 :         }

  001ad	eb a4		 jmp	 SHORT $LN11@permutatio@5
$LN10@permutatio@5:

; 3165 :         return Py_BuildValue("O(On)(NN)", Py_TYPE(po),
; 3166 :                              po->pool, po->r,
; 3167 :                              indices, cycles);

  001af	48 8b 44 24 48	 mov	 rax, QWORD PTR cycles$23110[rsp]
  001b4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b9	48 8b 44 24 40	 mov	 rax, QWORD PTR indices$23108[rsp]
  001be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c3	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  001c8	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  001cf	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  001d4	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  001d8	48 8b 44 24 70	 mov	 rax, QWORD PTR po$[rsp]
  001dd	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  001e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09PFECCMPC@O?$CIOn?$CJ?$CINN?$CJ?$AA@
  001e8	e8 00 00 00 00	 call	 Py_BuildValue
  001ed	eb 32		 jmp	 SHORT $LN23@permutatio@5
$err$23117:
$LN8@permutatio@5:

; 3168 :     err:
; 3169 :         Py_XDECREF(indices);

  001ef	48 83 7c 24 40
	00		 cmp	 QWORD PTR indices$23108[rsp], 0
  001f5	74 0a		 je	 SHORT $LN5@permutatio@5
  001f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR indices$23108[rsp]
  001fc	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@permutatio@5:
  00201	33 c0		 xor	 eax, eax
  00203	85 c0		 test	 eax, eax
  00205	75 e8		 jne	 SHORT $LN8@permutatio@5
$LN4@permutatio@5:

; 3170 :         Py_XDECREF(cycles);

  00207	48 83 7c 24 48
	00		 cmp	 QWORD PTR cycles$23110[rsp], 0
  0020d	74 0a		 je	 SHORT $LN1@permutatio@5
  0020f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cycles$23110[rsp]
  00214	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@permutatio@5:
  00219	33 c0		 xor	 eax, eax
  0021b	85 c0		 test	 eax, eax
  0021d	75 e8		 jne	 SHORT $LN4@permutatio@5

; 3171 :         return NULL;

  0021f	33 c0		 xor	 eax, eax
$LN19@permutatio@5:
$LN21@permutatio@5:
$LN23@permutatio@5:

; 3172 :     }
; 3173 : }

  00221	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00225	c3		 ret	 0
permutations_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@MPMMLIJH@permutations_setstate?$AA@	; `string'
PUBLIC	??_C@_04MKJNADP@O?$CBO?$CB?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$permutations_setstate DD imagerel permutations_setstate
	DD	imagerel permutations_setstate+877
	DD	imagerel $unwind$permutations_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$permutations_setstate DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0BG@MPMMLIJH@permutations_setstate?$AA@
CONST	SEGMENT
??_C@_0BG@MPMMLIJH@permutations_setstate?$AA@ DB 'permutations_setstate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKJNADP@O?$CBO?$CB?$AA@
CONST	SEGMENT
??_C@_04MKJNADP@O?$CBO?$CB?$AA@ DB 'O!O!', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT permutations_setstate
_TEXT	SEGMENT
i$ = 48
n$ = 56
indices$ = 64
cycles$ = 72
result$ = 80
index$23170 = 88
indexObject$23168 = 96
index$23181 = 104
indexObject$23179 = 112
element$23193 = 120
_py_tmp$23202 = 128
po$ = 160
state$ = 168
permutations_setstate PROC				; COMDAT

; 3177 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 3178 :     PyObject *indices, *cycles, *result;
; 3179 :     Py_ssize_t n, i;
; 3180 : 
; 3181 :     if (!PyArg_ParseTuple(state, "O!O!",
; 3182 :                           &PyTuple_Type, &indices,
; 3183 :                           &PyTuple_Type, &cycles))

  00011	48 8d 44 24 48	 lea	 rax, QWORD PTR cycles$[rsp]
  00016	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  00022	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00027	4c 8d 4c 24 40	 lea	 r9, QWORD PTR indices$[rsp]
  0002c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:PyTuple_Type
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04MKJNADP@O?$CBO?$CB?$AA@
  0003a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00042	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00047	85 c0		 test	 eax, eax
  00049	75 07		 jne	 SHORT $LN25@permutatio@6

; 3184 :         return NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	e9 13 03 00 00	 jmp	 $LN26@permutatio@6
$LN25@permutatio@6:

; 3185 : 
; 3186 :     n = PyTuple_GET_SIZE(po->pool);

  00052	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  0005a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0005e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00062	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax

; 3187 :     if (PyTuple_GET_SIZE(indices) != n ||
; 3188 :         PyTuple_GET_SIZE(cycles) != po->r)

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR indices$[rsp]
  0006c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  00071	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00075	75 1a		 jne	 SHORT $LN23@permutatio@6
  00077	48 8b 44 24 48	 mov	 rax, QWORD PTR cycles$[rsp]
  0007c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR po$[rsp]
  00084	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0008b	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0008f	74 1a		 je	 SHORT $LN24@permutatio@6
$LN23@permutatio@6:

; 3189 :     {
; 3190 :         PyErr_SetString(PyExc_ValueError, "invalid arguments");

  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@KNPMEBHA@invalid?5arguments?$AA@
  00098	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0009f	e8 00 00 00 00	 call	 PyErr_SetString

; 3191 :         return NULL;

  000a4	33 c0		 xor	 eax, eax
  000a6	e9 ba 02 00 00	 jmp	 $LN26@permutatio@6
$LN24@permutatio@6:

; 3192 :     }
; 3193 : 
; 3194 :     for (i=0; i<n; i++)

  000ab	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000b4	eb 0d		 jmp	 SHORT $LN22@permutatio@6
$LN21@permutatio@6:
  000b6	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  000bb	48 ff c0	 inc	 rax
  000be	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN22@permutatio@6:
  000c3	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  000c8	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  000cd	0f 8d 8a 00 00
	00		 jge	 $LN20@permutatio@6

; 3195 :     {
; 3196 :         PyObject* indexObject = PyTuple_GET_ITEM(indices, i);

  000d3	48 8b 44 24 40	 mov	 rax, QWORD PTR indices$[rsp]
  000d8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  000dd	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  000e2	48 89 44 24 60	 mov	 QWORD PTR indexObject$23168[rsp], rax

; 3197 :         Py_ssize_t index = PyLong_AsSsize_t(indexObject);

  000e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR indexObject$23168[rsp]
  000ec	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000f1	48 89 44 24 58	 mov	 QWORD PTR index$23170[rsp], rax

; 3198 :         if (index < 0 && PyErr_Occurred())

  000f6	48 83 7c 24 58
	00		 cmp	 QWORD PTR index$23170[rsp], 0
  000fc	7d 11		 jge	 SHORT $LN19@permutatio@6
  000fe	e8 00 00 00 00	 call	 PyErr_Occurred
  00103	48 85 c0	 test	 rax, rax
  00106	74 07		 je	 SHORT $LN19@permutatio@6

; 3199 :             return NULL; /* not an integer */

  00108	33 c0		 xor	 eax, eax
  0010a	e9 56 02 00 00	 jmp	 $LN26@permutatio@6
$LN19@permutatio@6:

; 3200 :         /* clamp the index */
; 3201 :         if (index < 0)

  0010f	48 83 7c 24 58
	00		 cmp	 QWORD PTR index$23170[rsp], 0
  00115	7d 0b		 jge	 SHORT $LN18@permutatio@6

; 3202 :             index = 0;

  00117	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR index$23170[rsp], 0
  00120	eb 1c		 jmp	 SHORT $LN17@permutatio@6
$LN18@permutatio@6:

; 3203 :         else if (index > n-1)

  00122	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  00127	48 ff c8	 dec	 rax
  0012a	48 39 44 24 58	 cmp	 QWORD PTR index$23170[rsp], rax
  0012f	7e 0d		 jle	 SHORT $LN16@permutatio@6

; 3204 :             index = n-1;

  00131	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
  00136	48 ff c8	 dec	 rax
  00139	48 89 44 24 58	 mov	 QWORD PTR index$23170[rsp], rax
$LN16@permutatio@6:
$LN17@permutatio@6:

; 3205 :         po->indices[i] = index;

  0013e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00146	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0014a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0014f	48 8b 54 24 58	 mov	 rdx, QWORD PTR index$23170[rsp]
  00154	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 3206 :     }

  00158	e9 59 ff ff ff	 jmp	 $LN21@permutatio@6
$LN20@permutatio@6:

; 3207 : 
; 3208 :     for (i=0; i<po->r; i++)

  0015d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00166	eb 0d		 jmp	 SHORT $LN15@permutatio@6
$LN14@permutatio@6:
  00168	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0016d	48 ff c0	 inc	 rax
  00170	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN15@permutatio@6:
  00175	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  0017d	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00184	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00189	0f 8d 9a 00 00
	00		 jge	 $LN13@permutatio@6

; 3209 :     {
; 3210 :         PyObject* indexObject = PyTuple_GET_ITEM(cycles, i);

  0018f	48 8b 44 24 48	 mov	 rax, QWORD PTR cycles$[rsp]
  00194	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00199	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  0019e	48 89 44 24 70	 mov	 QWORD PTR indexObject$23179[rsp], rax

; 3211 :         Py_ssize_t index = PyLong_AsSsize_t(indexObject);

  001a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR indexObject$23179[rsp]
  001a8	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  001ad	48 89 44 24 68	 mov	 QWORD PTR index$23181[rsp], rax

; 3212 :         if (index < 0 && PyErr_Occurred())

  001b2	48 83 7c 24 68
	00		 cmp	 QWORD PTR index$23181[rsp], 0
  001b8	7d 11		 jge	 SHORT $LN12@permutatio@6
  001ba	e8 00 00 00 00	 call	 PyErr_Occurred
  001bf	48 85 c0	 test	 rax, rax
  001c2	74 07		 je	 SHORT $LN12@permutatio@6

; 3213 :             return NULL; /* not an integer */

  001c4	33 c0		 xor	 eax, eax
  001c6	e9 9a 01 00 00	 jmp	 $LN26@permutatio@6
$LN12@permutatio@6:

; 3214 :         if (index < 1)

  001cb	48 83 7c 24 68
	01		 cmp	 QWORD PTR index$23181[rsp], 1
  001d1	7d 0b		 jge	 SHORT $LN11@permutatio@6

; 3215 :             index = 1;

  001d3	48 c7 44 24 68
	01 00 00 00	 mov	 QWORD PTR index$23181[rsp], 1
  001dc	eb 2c		 jmp	 SHORT $LN10@permutatio@6
$LN11@permutatio@6:

; 3216 :         else if (index > n-i)

  001de	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  001e3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  001e8	48 2b c8	 sub	 rcx, rax
  001eb	48 8b c1	 mov	 rax, rcx
  001ee	48 39 44 24 68	 cmp	 QWORD PTR index$23181[rsp], rax
  001f3	7e 15		 jle	 SHORT $LN9@permutatio@6

; 3217 :             index = n-i;

  001f5	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  001fa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  001ff	48 2b c8	 sub	 rcx, rax
  00202	48 8b c1	 mov	 rax, rcx
  00205	48 89 44 24 68	 mov	 QWORD PTR index$23181[rsp], rax
$LN9@permutatio@6:
$LN10@permutatio@6:

; 3218 :         po->cycles[i] = index;

  0020a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00212	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00216	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0021b	48 8b 54 24 68	 mov	 rdx, QWORD PTR index$23181[rsp]
  00220	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 3219 :     }

  00224	e9 3f ff ff ff	 jmp	 $LN14@permutatio@6
$LN13@permutatio@6:

; 3220 :     result = PyTuple_New(po->r);

  00229	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00231	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00238	e8 00 00 00 00	 call	 PyTuple_New
  0023d	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 3221 :     if (result == NULL)

  00242	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  00248	75 07		 jne	 SHORT $LN8@permutatio@6

; 3222 :         return NULL;

  0024a	33 c0		 xor	 eax, eax
  0024c	e9 14 01 00 00	 jmp	 $LN26@permutatio@6
$LN8@permutatio@6:

; 3223 :     for (i=0; i<po->r; i++) {

  00251	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0025a	eb 0d		 jmp	 SHORT $LN7@permutatio@6
$LN6@permutatio@6:
  0025c	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00261	48 ff c0	 inc	 rax
  00264	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN7@permutatio@6:
  00269	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00271	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00278	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0027d	7d 4b		 jge	 SHORT $LN5@permutatio@6

; 3224 :         PyObject *element = PyTuple_GET_ITEM(po->pool, po->indices[i]);

  0027f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00287	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0028b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR po$[rsp]
  00293	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00297	48 8b 54 24 30	 mov	 rdx, QWORD PTR i$[rsp]
  0029c	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  002a0	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  002a5	48 89 44 24 78	 mov	 QWORD PTR element$23193[rsp], rax

; 3225 :         Py_INCREF(element);

  002aa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR element$23193[rsp]
  002af	e8 00 00 00 00	 call	 _Py_IncRef

; 3226 :         PyTuple_SET_ITEM(result, i, element);

  002b4	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  002b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  002be	48 8b 54 24 78	 mov	 rdx, QWORD PTR element$23193[rsp]
  002c3	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 3227 :     }

  002c8	eb 92		 jmp	 SHORT $LN6@permutatio@6
$LN5@permutatio@6:
$LN4@permutatio@6:

; 3228 :     Py_CLEAR(po->result);

  002ca	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  002d2	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  002d7	74 62		 je	 SHORT $LN1@permutatio@6
  002d9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  002e1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  002e9	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  002ed	41 b8 9c 0c 00
	00		 mov	 r8d, 3228		; 00000c9cH
  002f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  002fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@MPMMLIJH@permutations_setstate?$AA@
  00301	e8 00 00 00 00	 call	 _PyParallel_Guard
  00306	85 c0		 test	 eax, eax
  00308	75 31		 jne	 SHORT $LN1@permutatio@6
  0030a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00312	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00316	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR _py_tmp$23202[rsp], rax
  0031e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00326	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0
  0032e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _py_tmp$23202[rsp]
  00336	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@permutatio@6:
  0033b	33 c0		 xor	 eax, eax
  0033d	85 c0		 test	 eax, eax
  0033f	75 89		 jne	 SHORT $LN4@permutatio@6

; 3229 :     po->result = result;

  00341	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR po$[rsp]
  00349	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  0034e	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 3230 :     Py_RETURN_NONE;

  00352	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00359	e8 00 00 00 00	 call	 _Py_IncRef
  0035e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN26@permutatio@6:

; 3231 : }

  00365	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0036c	c3		 ret	 0
permutations_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@BNFGMMGG@O?$HMO?3accumulate?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$accumulate_new DD imagerel accumulate_new
	DD	imagerel accumulate_new+255
	DD	imagerel $unwind$accumulate_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$accumulate_new DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0P@BNFGMMGG@O?$HMO?3accumulate?$AA@
CONST	SEGMENT
??_C@_0P@BNFGMMGG@O?$HMO?3accumulate?$AA@ DB 'O|O:accumulate', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT accumulate_new
_TEXT	SEGMENT
it$ = 48
binop$ = 56
lz$ = 64
iterable$ = 72
type$ = 96
args$ = 104
kwds$ = 112
accumulate_new PROC					; COMDAT

; 3304 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3305 :     static char *kwargs[] = {"iterable", "func", NULL};
; 3306 :     PyObject *iterable;
; 3307 :     PyObject *it;
; 3308 :     PyObject *binop = Py_None;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001a	48 89 44 24 38	 mov	 QWORD PTR binop$[rsp], rax

; 3309 :     accumulateobject *lz;
; 3310 : 
; 3311 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|O:accumulate",
; 3312 :                                      kwargs, &iterable, &binop))

  0001f	48 8d 44 24 38	 lea	 rax, QWORD PTR binop$[rsp]
  00024	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00029	48 8d 44 24 48	 lea	 rax, QWORD PTR iterable$[rsp]
  0002e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00033	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwargs@?1??accumulate_new@@9@9
  0003a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0P@BNFGMMGG@O?$HMO?3accumulate?$AA@
  00041	48 8b 54 24 70	 mov	 rdx, QWORD PTR kwds$[rsp]
  00046	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0004b	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00050	85 c0		 test	 eax, eax
  00052	75 07		 jne	 SHORT $LN8@accumulate

; 3313 :         return NULL;

  00054	33 c0		 xor	 eax, eax
  00056	e9 9f 00 00 00	 jmp	 $LN9@accumulate
$LN8@accumulate:

; 3314 : 
; 3315 :     /* Get iterator. */
; 3316 :     it = PyObject_GetIter(iterable);

  0005b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR iterable$[rsp]
  00060	e8 00 00 00 00	 call	 PyObject_GetIter
  00065	48 89 44 24 30	 mov	 QWORD PTR it$[rsp], rax

; 3317 :     if (it == NULL)

  0006a	48 83 7c 24 30
	00		 cmp	 QWORD PTR it$[rsp], 0
  00070	75 07		 jne	 SHORT $LN7@accumulate

; 3318 :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	e9 81 00 00 00	 jmp	 $LN9@accumulate
$LN7@accumulate:

; 3319 : 
; 3320 :     /* create accumulateobject structure */
; 3321 :     lz = (accumulateobject *)type->tp_alloc(type, 0);

  00079	33 d2		 xor	 edx, edx
  0007b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR type$[rsp]
  00080	48 8b 44 24 60	 mov	 rax, QWORD PTR type$[rsp]
  00085	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  0008b	48 89 44 24 40	 mov	 QWORD PTR lz$[rsp], rax

; 3322 :     if (lz == NULL) {

  00090	48 83 7c 24 40
	00		 cmp	 QWORD PTR lz$[rsp], 0
  00096	75 0e		 jne	 SHORT $LN6@accumulate

; 3323 :         Py_DECREF(it);

  00098	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  0009d	e8 00 00 00 00	 call	 _Py_DecRef

; 3324 :         return NULL;

  000a2	33 c0		 xor	 eax, eax
  000a4	eb 54		 jmp	 SHORT $LN9@accumulate
$LN6@accumulate:

; 3325 :     }
; 3326 : 
; 3327 :     if (binop != Py_None) {

  000a6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  000ad	48 39 44 24 38	 cmp	 QWORD PTR binop$[rsp], rax
  000b2	74 26		 je	 SHORT $LN5@accumulate
$LN4@accumulate:

; 3328 :         Py_XINCREF(binop);

  000b4	48 83 7c 24 38
	00		 cmp	 QWORD PTR binop$[rsp], 0
  000ba	74 0a		 je	 SHORT $LN1@accumulate
  000bc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR binop$[rsp]
  000c1	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@accumulate:
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 e8		 jne	 SHORT $LN4@accumulate

; 3329 :         lz->binop = binop;

  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000d1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR binop$[rsp]
  000d6	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
$LN5@accumulate:

; 3330 :     }
; 3331 :     lz->total = NULL;

  000da	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000df	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 3332 :     lz->it = it;

  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000ec	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000f1	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 3333 :     return (PyObject *)lz;

  000f5	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
$LN9@accumulate:

; 3334 : }

  000fa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000fe	c3		 ret	 0
accumulate_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$accumulate_dealloc DD imagerel accumulate_dealloc
	DD	imagerel accumulate_dealloc+140
	DD	imagerel $unwind$accumulate_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$accumulate_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT accumulate_dealloc
_TEXT	SEGMENT
lz$ = 48
accumulate_dealloc PROC					; COMDAT

; 3338 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3339 :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN12@accumulate@2:

; 3340 :     Py_XDECREF(lz->binop);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0001d	74 0e		 je	 SHORT $LN9@accumulate@2
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@accumulate@2:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN12@accumulate@2
$LN8@accumulate@2:

; 3341 :     Py_XDECREF(lz->total);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0003d	74 0e		 je	 SHORT $LN5@accumulate@2
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@accumulate@2:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN8@accumulate@2
$LN4@accumulate@2:

; 3342 :     Py_XDECREF(lz->it);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00058	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0005d	74 0e		 je	 SHORT $LN1@accumulate@2
  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00064	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00068	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@accumulate@2:
  0006d	33 c0		 xor	 eax, eax
  0006f	85 c0		 test	 eax, eax
  00071	75 e0		 jne	 SHORT $LN4@accumulate@2

; 3343 :     Py_TYPE(lz)->tp_free(lz);

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00078	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  00081	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 3344 : }

  00087	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008b	c3		 ret	 0
accumulate_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@LMNABLBL@accumulate_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$accumulate_traverse DD imagerel accumulate_traverse
	DD	imagerel accumulate_traverse+299
	DD	imagerel $unwind$accumulate_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$accumulate_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BE@LMNABLBL@accumulate_traverse?$AA@
CONST	SEGMENT
??_C@_0BE@LMNABLBL@accumulate_traverse?$AA@ DB 'accumulate_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT accumulate_traverse
_TEXT	SEGMENT
vret$23307 = 32
vret$23315 = 36
vret$23323 = 40
lz$ = 64
visit$ = 72
arg$ = 80
accumulate_traverse PROC				; COMDAT

; 3348 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN18@accumulate@3:

; 3349 :     Py_VISIT(lz->binop);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN15@accumulate@3
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 15 0d 00
	00		 mov	 r8d, 3349		; 00000d15H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LMNABLBL@accumulate_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@accumulate@3:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00042	74 26		 je	 SHORT $LN14@accumulate@3
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$23307[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$23307[rsp], 0
  0005f	74 09		 je	 SHORT $LN13@accumulate@3
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$23307[rsp]
  00065	e9 bc 00 00 00	 jmp	 $LN19@accumulate@3
$LN13@accumulate@3:
$LN14@accumulate@3:
  0006a	33 c0		 xor	 eax, eax
  0006c	85 c0		 test	 eax, eax
  0006e	75 a3		 jne	 SHORT $LN18@accumulate@3
$LN12@accumulate@3:

; 3350 :     Py_VISIT(lz->it);

  00070	e8 00 00 00 00	 call	 _Py_PXCTX
  00075	85 c0		 test	 eax, eax
  00077	74 1c		 je	 SHORT $LN9@accumulate@3
  00079	45 33 c9	 xor	 r9d, r9d
  0007c	41 b8 16 0d 00
	00		 mov	 r8d, 3350		; 00000d16H
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LMNABLBL@accumulate_traverse?$AA@
  00090	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@accumulate@3:
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0009a	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0009f	74 23		 je	 SHORT $LN8@accumulate@3
  000a1	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a6	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000ab	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000af	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b3	89 44 24 24	 mov	 DWORD PTR vret$23315[rsp], eax
  000b7	83 7c 24 24 00	 cmp	 DWORD PTR vret$23315[rsp], 0
  000bc	74 06		 je	 SHORT $LN7@accumulate@3
  000be	8b 44 24 24	 mov	 eax, DWORD PTR vret$23315[rsp]
  000c2	eb 62		 jmp	 SHORT $LN19@accumulate@3
$LN7@accumulate@3:
$LN8@accumulate@3:
  000c4	33 c0		 xor	 eax, eax
  000c6	85 c0		 test	 eax, eax
  000c8	75 a6		 jne	 SHORT $LN12@accumulate@3
$LN6@accumulate@3:

; 3351 :     Py_VISIT(lz->total);

  000ca	e8 00 00 00 00	 call	 _Py_PXCTX
  000cf	85 c0		 test	 eax, eax
  000d1	74 1c		 je	 SHORT $LN3@accumulate@3
  000d3	45 33 c9	 xor	 r9d, r9d
  000d6	41 b8 17 0d 00
	00		 mov	 r8d, 3351		; 00000d17H
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@LMNABLBL@accumulate_traverse?$AA@
  000ea	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@accumulate@3:
  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000f4	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000f9	74 23		 je	 SHORT $LN2@accumulate@3
  000fb	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00100	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00105	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00109	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  0010d	89 44 24 28	 mov	 DWORD PTR vret$23323[rsp], eax
  00111	83 7c 24 28 00	 cmp	 DWORD PTR vret$23323[rsp], 0
  00116	74 06		 je	 SHORT $LN1@accumulate@3
  00118	8b 44 24 28	 mov	 eax, DWORD PTR vret$23323[rsp]
  0011c	eb 08		 jmp	 SHORT $LN19@accumulate@3
$LN1@accumulate@3:
$LN2@accumulate@3:
  0011e	33 c0		 xor	 eax, eax
  00120	85 c0		 test	 eax, eax
  00122	75 a6		 jne	 SHORT $LN6@accumulate@3

; 3352 :     return 0;

  00124	33 c0		 xor	 eax, eax
$LN19@accumulate@3:

; 3353 : }

  00126	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012a	c3		 ret	 0
accumulate_traverse ENDP
_TEXT	ENDS
EXTRN	PyNumber_Add:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$accumulate_next DD imagerel accumulate_next
	DD	imagerel accumulate_next+247
	DD	imagerel $unwind$accumulate_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$accumulate_next DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT accumulate_next
_TEXT	SEGMENT
oldtotal$ = 32
newtotal$ = 40
val$ = 48
lz$ = 80
accumulate_next PROC					; COMDAT

; 3357 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3358 :     PyObject *val, *oldtotal, *newtotal;
; 3359 : 
; 3360 :     val = PyIter_Next(lz->it);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00012	e8 00 00 00 00	 call	 PyIter_Next
  00017	48 89 44 24 30	 mov	 QWORD PTR val$[rsp], rax

; 3361 :     if (val == NULL)

  0001c	48 83 7c 24 30
	00		 cmp	 QWORD PTR val$[rsp], 0
  00022	75 07		 jne	 SHORT $LN5@accumulate@4

; 3362 :         return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	e9 c7 00 00 00	 jmp	 $LN6@accumulate@4
$LN5@accumulate@4:

; 3363 : 
; 3364 :     if (lz->total == NULL) {

  0002b	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00030	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00035	75 26		 jne	 SHORT $LN4@accumulate@4

; 3365 :         Py_INCREF(val);

  00037	48 8b 4c 24 30	 mov	 rcx, QWORD PTR val$[rsp]
  0003c	e8 00 00 00 00	 call	 _Py_IncRef

; 3366 :         lz->total = val;

  00041	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR val$[rsp]
  0004b	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3367 :         return lz->total;

  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00054	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00058	e9 95 00 00 00	 jmp	 $LN6@accumulate@4
$LN4@accumulate@4:

; 3368 :     }
; 3369 : 
; 3370 :     if (lz->binop == NULL)

  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00062	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00067	75 1a		 jne	 SHORT $LN3@accumulate@4

; 3371 :         newtotal = PyNumber_Add(lz->total, val);

  00069	48 8b 54 24 30	 mov	 rdx, QWORD PTR val$[rsp]
  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00073	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00077	e8 00 00 00 00	 call	 PyNumber_Add
  0007c	48 89 44 24 28	 mov	 QWORD PTR newtotal$[rsp], rax

; 3372 :     else

  00081	eb 24		 jmp	 SHORT $LN2@accumulate@4
$LN3@accumulate@4:

; 3373 :         newtotal = PyObject_CallFunctionObjArgs(lz->binop, lz->total, val, NULL);

  00083	45 33 c9	 xor	 r9d, r9d
  00086	4c 8b 44 24 30	 mov	 r8, QWORD PTR val$[rsp]
  0008b	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00090	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00099	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0009d	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  000a2	48 89 44 24 28	 mov	 QWORD PTR newtotal$[rsp], rax
$LN2@accumulate@4:

; 3374 :     Py_DECREF(val);

  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR val$[rsp]
  000ac	e8 00 00 00 00	 call	 _Py_DecRef

; 3375 :     if (newtotal == NULL)

  000b1	48 83 7c 24 28
	00		 cmp	 QWORD PTR newtotal$[rsp], 0
  000b7	75 04		 jne	 SHORT $LN1@accumulate@4

; 3376 :         return NULL;

  000b9	33 c0		 xor	 eax, eax
  000bb	eb 35		 jmp	 SHORT $LN6@accumulate@4
$LN1@accumulate@4:

; 3377 : 
; 3378 :     oldtotal = lz->total;

  000bd	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  000c2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000c6	48 89 44 24 20	 mov	 QWORD PTR oldtotal$[rsp], rax

; 3379 :     lz->total = newtotal;

  000cb	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  000d0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtotal$[rsp]
  000d5	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3380 :     Py_DECREF(oldtotal);

  000d9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR oldtotal$[rsp]
  000de	e8 00 00 00 00	 call	 _Py_DecRef

; 3381 : 
; 3382 :     Py_INCREF(newtotal);

  000e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newtotal$[rsp]
  000e8	e8 00 00 00 00	 call	 _Py_IncRef

; 3383 :     return newtotal;

  000ed	48 8b 44 24 28	 mov	 rax, QWORD PTR newtotal$[rsp]
$LN6@accumulate@4:

; 3384 : }

  000f2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f6	c3		 ret	 0
accumulate_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_06GCIGALBM@O?$CIOO?$CJO?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$accumulate_reduce DD imagerel accumulate_reduce
	DD	imagerel accumulate_reduce+139
	DD	imagerel $unwind$accumulate_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$accumulate_reduce DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_06GCIGALBM@O?$CIOO?$CJO?$AA@
CONST	SEGMENT
??_C@_06GCIGALBM@O?$CIOO?$CJO?$AA@ DB 'O(OO)O', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT accumulate_reduce
_TEXT	SEGMENT
tv68 = 48
tv73 = 56
lz$ = 80
accumulate_reduce PROC					; COMDAT

; 3388 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3389 :     return Py_BuildValue("O(OO)O", Py_TYPE(lz),
; 3390 :                             lz->it, lz->binop?lz->binop:Py_None,
; 3391 :                             lz->total?lz->total:Py_None);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00013	74 10		 je	 SHORT $LN3@accumulate@5
  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0001a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001e	48 89 44 24 30	 mov	 QWORD PTR tv68[rsp], rax
  00023	eb 0c		 jmp	 SHORT $LN4@accumulate@5
$LN3@accumulate@5:
  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0002c	48 89 44 24 30	 mov	 QWORD PTR tv68[rsp], rax
$LN4@accumulate@5:
  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00036	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0003b	74 10		 je	 SHORT $LN5@accumulate@5
  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00042	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00046	48 89 44 24 38	 mov	 QWORD PTR tv73[rsp], rax
  0004b	eb 0c		 jmp	 SHORT $LN6@accumulate@5
$LN5@accumulate@5:
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00054	48 89 44 24 38	 mov	 QWORD PTR tv73[rsp], rax
$LN6@accumulate@5:
  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR tv68[rsp]
  0005e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00063	4c 8b 4c 24 38	 mov	 r9, QWORD PTR tv73[rsp]
  00068	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0006d	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00071	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00076	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06GCIGALBM@O?$CIOO?$CJO?$AA@
  00081	e8 00 00 00 00	 call	 Py_BuildValue

; 3392 :  }

  00086	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008a	c3		 ret	 0
accumulate_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BE@NBIHDMPM@accumulate_setstate?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$accumulate_setstate DD imagerel accumulate_setstate
	DD	imagerel accumulate_setstate+167
	DD	imagerel $unwind$accumulate_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$accumulate_setstate DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BE@NBIHDMPM@accumulate_setstate?$AA@
CONST	SEGMENT
??_C@_0BE@NBIHDMPM@accumulate_setstate?$AA@ DB 'accumulate_setstate', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT accumulate_setstate
_TEXT	SEGMENT
_py_tmp$23366 = 48
lz$ = 80
state$ = 88
accumulate_setstate PROC				; COMDAT

; 3396 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@accumulate@6:

; 3397 :     Py_CLEAR(lz->total);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00013	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00018	74 53		 je	 SHORT $LN1@accumulate@6
  0001a	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00027	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]
  0002b	41 b8 45 0d 00
	00		 mov	 r8d, 3397		; 00000d45H
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@NBIHDMPM@accumulate_setstate?$AA@
  0003f	e8 00 00 00 00	 call	 _PyParallel_Guard
  00044	85 c0		 test	 eax, eax
  00046	75 25		 jne	 SHORT $LN1@accumulate@6
  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0004d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00051	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$23366[rsp], rax
  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0005b	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0
  00063	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$23366[rsp]
  00068	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@accumulate@6:
  0006d	33 c0		 xor	 eax, eax
  0006f	85 c0		 test	 eax, eax
  00071	75 9b		 jne	 SHORT $LN4@accumulate@6

; 3398 :     lz->total = state;

  00073	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00078	48 8b 4c 24 58	 mov	 rcx, QWORD PTR state$[rsp]
  0007d	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3399 :     Py_INCREF(lz->total);

  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00086	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0008a	e8 00 00 00 00	 call	 _Py_IncRef

; 3400 :     Py_RETURN_NONE;

  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00096	e8 00 00 00 00	 call	 _Py_IncRef
  0009b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 3401 : }

  000a2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a6	c3		 ret	 0
accumulate_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@KMJFIJPJ@OO?3compress?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress_new DD imagerel compress_new
	DD	imagerel compress_new+273
	DD	imagerel $unwind$compress_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress_new DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0M@KMJFIJPJ@OO?3compress?$AA@
CONST	SEGMENT
??_C@_0M@KMJFIJPJ@OO?3compress?$AA@ DB 'OO:compress', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compress_new
_TEXT	SEGMENT
selectors$ = 48
lz$ = 56
seq1$ = 64
data$ = 72
seq2$ = 80
type$ = 112
args$ = 120
kwds$ = 128
compress_new PROC					; COMDAT

; 3480 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3481 :     PyObject *seq1, *seq2;
; 3482 :     PyObject *data=NULL, *selectors=NULL;

  00013	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR data$[rsp], 0
  0001c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR selectors$[rsp], 0

; 3483 :     compressobject *lz;
; 3484 :     static char *kwargs[] = {"data", "selectors", NULL};
; 3485 : 
; 3486 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO:compress", kwargs, &seq1, &seq2))

  00025	48 8d 44 24 50	 lea	 rax, QWORD PTR seq2$[rsp]
  0002a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002f	48 8d 44 24 40	 lea	 rax, QWORD PTR seq1$[rsp]
  00034	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00039	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwargs@?1??compress_new@@9@9
  00040	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@KMJFIJPJ@OO?3compress?$AA@
  00047	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  0004f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00054	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  00059	85 c0		 test	 eax, eax
  0005b	75 07		 jne	 SHORT $LN12@compress_n

; 3487 :         return NULL;

  0005d	33 c0		 xor	 eax, eax
  0005f	e9 a8 00 00 00	 jmp	 $LN13@compress_n
$LN12@compress_n:

; 3488 : 
; 3489 :     data = PyObject_GetIter(seq1);

  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq1$[rsp]
  00069	e8 00 00 00 00	 call	 PyObject_GetIter
  0006e	48 89 44 24 48	 mov	 QWORD PTR data$[rsp], rax

; 3490 :     if (data == NULL)

  00073	48 83 7c 24 48
	00		 cmp	 QWORD PTR data$[rsp], 0
  00079	75 02		 jne	 SHORT $LN11@compress_n

; 3491 :         goto fail;

  0007b	eb 5d		 jmp	 SHORT $fail$23427
$LN11@compress_n:

; 3492 :     selectors = PyObject_GetIter(seq2);

  0007d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR seq2$[rsp]
  00082	e8 00 00 00 00	 call	 PyObject_GetIter
  00087	48 89 44 24 30	 mov	 QWORD PTR selectors$[rsp], rax

; 3493 :     if (selectors == NULL)

  0008c	48 83 7c 24 30
	00		 cmp	 QWORD PTR selectors$[rsp], 0
  00092	75 02		 jne	 SHORT $LN10@compress_n

; 3494 :         goto fail;

  00094	eb 44		 jmp	 SHORT $fail$23427
$LN10@compress_n:

; 3495 : 
; 3496 :     /* create compressobject structure */
; 3497 :     lz = (compressobject *)type->tp_alloc(type, 0);

  00096	33 d2		 xor	 edx, edx
  00098	48 8b 4c 24 70	 mov	 rcx, QWORD PTR type$[rsp]
  0009d	48 8b 44 24 70	 mov	 rax, QWORD PTR type$[rsp]
  000a2	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  000a8	48 89 44 24 38	 mov	 QWORD PTR lz$[rsp], rax

; 3498 :     if (lz == NULL)

  000ad	48 83 7c 24 38
	00		 cmp	 QWORD PTR lz$[rsp], 0
  000b3	75 02		 jne	 SHORT $LN9@compress_n

; 3499 :         goto fail;

  000b5	eb 23		 jmp	 SHORT $fail$23427
$LN9@compress_n:

; 3500 :     lz->data = data;

  000b7	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000bc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR data$[rsp]
  000c1	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3501 :     lz->selectors = selectors;

  000c5	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR selectors$[rsp]
  000cf	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 3502 :     return (PyObject *)lz;

  000d3	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000d8	eb 32		 jmp	 SHORT $LN13@compress_n
$fail$23427:
$LN8@compress_n:

; 3503 : 
; 3504 : fail:
; 3505 :     Py_XDECREF(data);

  000da	48 83 7c 24 48
	00		 cmp	 QWORD PTR data$[rsp], 0
  000e0	74 0a		 je	 SHORT $LN5@compress_n
  000e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR data$[rsp]
  000e7	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@compress_n:
  000ec	33 c0		 xor	 eax, eax
  000ee	85 c0		 test	 eax, eax
  000f0	75 e8		 jne	 SHORT $LN8@compress_n
$LN4@compress_n:

; 3506 :     Py_XDECREF(selectors);

  000f2	48 83 7c 24 30
	00		 cmp	 QWORD PTR selectors$[rsp], 0
  000f8	74 0a		 je	 SHORT $LN1@compress_n
  000fa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR selectors$[rsp]
  000ff	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@compress_n:
  00104	33 c0		 xor	 eax, eax
  00106	85 c0		 test	 eax, eax
  00108	75 e8		 jne	 SHORT $LN4@compress_n

; 3507 :     return NULL;

  0010a	33 c0		 xor	 eax, eax
$LN13@compress_n:

; 3508 : }

  0010c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00110	c3		 ret	 0
compress_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress_dealloc DD imagerel compress_dealloc
	DD	imagerel compress_dealloc+108
	DD	imagerel $unwind$compress_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compress_dealloc
_TEXT	SEGMENT
lz$ = 48
compress_dealloc PROC					; COMDAT

; 3512 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3513 :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN8@compress_d:

; 3514 :     Py_XDECREF(lz->data);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN5@compress_d
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@compress_d:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN8@compress_d
$LN4@compress_d:

; 3515 :     Py_XDECREF(lz->selectors);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0003d	74 0e		 je	 SHORT $LN1@compress_d
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@compress_d:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN4@compress_d

; 3516 :     Py_TYPE(lz)->tp_free(lz);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  00061	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 3517 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
compress_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@BPBGIEMH@compress_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress_traverse DD imagerel compress_traverse
	DD	imagerel compress_traverse+206
	DD	imagerel $unwind$compress_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BC@BPBGIEMH@compress_traverse?$AA@
CONST	SEGMENT
??_C@_0BC@BPBGIEMH@compress_traverse?$AA@ DB 'compress_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT compress_traverse
_TEXT	SEGMENT
vret$23474 = 32
vret$23482 = 36
lz$ = 64
visit$ = 72
arg$ = 80
compress_traverse PROC					; COMDAT

; 3521 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@compress_t:

; 3522 :     Py_VISIT(lz->data);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@compress_t
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 c2 0d 00
	00		 mov	 r8d, 3522		; 00000dc2H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@BPBGIEMH@compress_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@compress_t:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN8@compress_t
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$23474[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$23474[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@compress_t
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$23474[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@compress_t
$LN7@compress_t:
$LN8@compress_t:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@compress_t
$LN6@compress_t:

; 3523 :     Py_VISIT(lz->selectors);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@compress_t
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 c3 0d 00
	00		 mov	 r8d, 3523		; 00000dc3H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@BPBGIEMH@compress_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@compress_t:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00097	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0009c	74 23		 je	 SHORT $LN2@compress_t
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000a8	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$23482[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$23482[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@compress_t
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$23482[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@compress_t
$LN1@compress_t:
$LN2@compress_t:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@compress_t

; 3524 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@compress_t:

; 3525 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
compress_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress_next DD imagerel compress_next
	DD	imagerel compress_next+217
	DD	imagerel $unwind$compress_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress_next DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compress_next
_TEXT	SEGMENT
selectors$ = 32
selectornext$ = 40
datanext$ = 48
ok$ = 56
selector$ = 64
datum$ = 72
data$ = 80
lz$ = 112
compress_next PROC					; COMDAT

; 3529 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3530 :     PyObject *data = lz->data, *selectors = lz->selectors;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 89 44 24 50	 mov	 QWORD PTR data$[rsp], rax
  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR lz$[rsp]
  0001c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00020	48 89 44 24 20	 mov	 QWORD PTR selectors$[rsp], rax

; 3531 :     PyObject *datum, *selector;
; 3532 :     PyObject *(*datanext)(PyObject *) = *Py_TYPE(data)->tp_iternext;

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR data$[rsp]
  0002a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002e	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00035	48 89 44 24 30	 mov	 QWORD PTR datanext$[rsp], rax

; 3533 :     PyObject *(*selectornext)(PyObject *) = *Py_TYPE(selectors)->tp_iternext;

  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR selectors$[rsp]
  0003f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00043	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  0004a	48 89 44 24 28	 mov	 QWORD PTR selectornext$[rsp], rax
$LN6@compress_n@2:

; 3534 :     int ok;
; 3535 : 
; 3536 :     while (1) {

  0004f	33 c0		 xor	 eax, eax
  00051	83 f8 01	 cmp	 eax, 1
  00054	74 7e		 je	 SHORT $LN5@compress_n@2

; 3537 :         /* Steps:  get datum, get selector, evaluate selector.
; 3538 :            Order is important (to match the pure python version
; 3539 :            in terms of which input gets a chance to raise an
; 3540 :            exception first).
; 3541 :         */
; 3542 : 
; 3543 :         datum = datanext(data);

  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  0005b	ff 54 24 30	 call	 QWORD PTR datanext$[rsp]
  0005f	48 89 44 24 48	 mov	 QWORD PTR datum$[rsp], rax

; 3544 :         if (datum == NULL)

  00064	48 83 7c 24 48
	00		 cmp	 QWORD PTR datum$[rsp], 0
  0006a	75 04		 jne	 SHORT $LN4@compress_n@2

; 3545 :             return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	eb 64		 jmp	 SHORT $LN7@compress_n@2
$LN4@compress_n@2:

; 3546 : 
; 3547 :         selector = selectornext(selectors);

  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR selectors$[rsp]
  00075	ff 54 24 28	 call	 QWORD PTR selectornext$[rsp]
  00079	48 89 44 24 40	 mov	 QWORD PTR selector$[rsp], rax

; 3548 :         if (selector == NULL) {

  0007e	48 83 7c 24 40
	00		 cmp	 QWORD PTR selector$[rsp], 0
  00084	75 0e		 jne	 SHORT $LN3@compress_n@2

; 3549 :             Py_DECREF(datum);

  00086	48 8b 4c 24 48	 mov	 rcx, QWORD PTR datum$[rsp]
  0008b	e8 00 00 00 00	 call	 _Py_DecRef

; 3550 :             return NULL;

  00090	33 c0		 xor	 eax, eax
  00092	eb 40		 jmp	 SHORT $LN7@compress_n@2
$LN3@compress_n@2:

; 3551 :         }
; 3552 : 
; 3553 :         ok = PyObject_IsTrue(selector);

  00094	48 8b 4c 24 40	 mov	 rcx, QWORD PTR selector$[rsp]
  00099	e8 00 00 00 00	 call	 PyObject_IsTrue
  0009e	89 44 24 38	 mov	 DWORD PTR ok$[rsp], eax

; 3554 :         Py_DECREF(selector);

  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR selector$[rsp]
  000a7	e8 00 00 00 00	 call	 _Py_DecRef

; 3555 :         if (ok == 1)

  000ac	83 7c 24 38 01	 cmp	 DWORD PTR ok$[rsp], 1
  000b1	75 07		 jne	 SHORT $LN2@compress_n@2

; 3556 :             return datum;

  000b3	48 8b 44 24 48	 mov	 rax, QWORD PTR datum$[rsp]
  000b8	eb 1a		 jmp	 SHORT $LN7@compress_n@2
$LN2@compress_n@2:

; 3557 :         Py_DECREF(datum);

  000ba	48 8b 4c 24 48	 mov	 rcx, QWORD PTR datum$[rsp]
  000bf	e8 00 00 00 00	 call	 _Py_DecRef

; 3558 :         if (ok < 0)

  000c4	83 7c 24 38 00	 cmp	 DWORD PTR ok$[rsp], 0
  000c9	7d 04		 jge	 SHORT $LN1@compress_n@2

; 3559 :             return NULL;

  000cb	33 c0		 xor	 eax, eax
  000cd	eb 05		 jmp	 SHORT $LN7@compress_n@2
$LN1@compress_n@2:

; 3560 :     }

  000cf	e9 7b ff ff ff	 jmp	 $LN6@compress_n@2
$LN5@compress_n@2:
$LN7@compress_n@2:

; 3561 : }

  000d4	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000d8	c3		 ret	 0
compress_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress_reduce DD imagerel compress_reduce
	DD	imagerel compress_reduce+53
	DD	imagerel $unwind$compress_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress_reduce DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compress_reduce
_TEXT	SEGMENT
lz$ = 48
compress_reduce PROC					; COMDAT

; 3565 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3566 :     return Py_BuildValue("O(OO)", Py_TYPE(lz),
; 3567 :         lz->data, lz->selectors);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00017	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00020	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LNHFJPFN@O?$CIOO?$CJ?$AA@
  0002b	e8 00 00 00 00	 call	 Py_BuildValue

; 3568 :     }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
compress_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@KIIGPCNF@filterfalse?$AA@		; `string'
PUBLIC	??_C@_0O@NNOEICFP@filterfalse?$CI?$CJ?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$filterfalse_new DD imagerel filterfalse_new
	DD	imagerel filterfalse_new+238
	DD	imagerel $unwind$filterfalse_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$filterfalse_new DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0M@KIIGPCNF@filterfalse?$AA@
CONST	SEGMENT
??_C@_0M@KIIGPCNF@filterfalse?$AA@ DB 'filterfalse', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NNOEICFP@filterfalse?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@NNOEICFP@filterfalse?$CI?$CJ?$AA@ DB 'filterfalse()', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT filterfalse_new
_TEXT	SEGMENT
it$ = 48
lz$ = 56
seq$ = 64
func$ = 72
type$ = 96
args$ = 104
kwds$ = 112
filterfalse_new PROC					; COMDAT

; 3640 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3641 :     PyObject *func, *seq;
; 3642 :     PyObject *it;
; 3643 :     filterfalseobject *lz;
; 3644 : 
; 3645 :     if (type == &filterfalse_type &&
; 3646 :         !_PyArg_NoKeywords("filterfalse()", kwds))

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:filterfalse_type
  0001a	48 39 44 24 60	 cmp	 QWORD PTR type$[rsp], rax
  0001f	75 1c		 jne	 SHORT $LN4@filterfals
  00021	48 8b 54 24 70	 mov	 rdx, QWORD PTR kwds$[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@NNOEICFP@filterfalse?$CI?$CJ?$AA@
  0002d	e8 00 00 00 00	 call	 _PyArg_NoKeywords
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN4@filterfals

; 3647 :         return NULL;

  00036	33 c0		 xor	 eax, eax
  00038	e9 ac 00 00 00	 jmp	 $LN5@filterfals
$LN4@filterfals:

; 3648 : 
; 3649 :     if (!PyArg_UnpackTuple(args, "filterfalse", 2, 2, &func, &seq))

  0003d	48 8d 44 24 40	 lea	 rax, QWORD PTR seq$[rsp]
  00042	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00047	48 8d 44 24 48	 lea	 rax, QWORD PTR func$[rsp]
  0004c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00051	41 b9 02 00 00
	00		 mov	 r9d, 2
  00057	41 b8 02 00 00
	00		 mov	 r8d, 2
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@KIIGPCNF@filterfalse?$AA@
  00064	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00069	e8 00 00 00 00	 call	 PyArg_UnpackTuple
  0006e	85 c0		 test	 eax, eax
  00070	75 04		 jne	 SHORT $LN3@filterfals

; 3650 :         return NULL;

  00072	33 c0		 xor	 eax, eax
  00074	eb 73		 jmp	 SHORT $LN5@filterfals
$LN3@filterfals:

; 3651 : 
; 3652 :     /* Get iterator. */
; 3653 :     it = PyObject_GetIter(seq);

  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$[rsp]
  0007b	e8 00 00 00 00	 call	 PyObject_GetIter
  00080	48 89 44 24 30	 mov	 QWORD PTR it$[rsp], rax

; 3654 :     if (it == NULL)

  00085	48 83 7c 24 30
	00		 cmp	 QWORD PTR it$[rsp], 0
  0008b	75 04		 jne	 SHORT $LN2@filterfals

; 3655 :         return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	eb 58		 jmp	 SHORT $LN5@filterfals
$LN2@filterfals:

; 3656 : 
; 3657 :     /* create filterfalseobject structure */
; 3658 :     lz = (filterfalseobject *)type->tp_alloc(type, 0);

  00091	33 d2		 xor	 edx, edx
  00093	48 8b 4c 24 60	 mov	 rcx, QWORD PTR type$[rsp]
  00098	48 8b 44 24 60	 mov	 rax, QWORD PTR type$[rsp]
  0009d	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  000a3	48 89 44 24 38	 mov	 QWORD PTR lz$[rsp], rax

; 3659 :     if (lz == NULL) {

  000a8	48 83 7c 24 38
	00		 cmp	 QWORD PTR lz$[rsp], 0
  000ae	75 0e		 jne	 SHORT $LN1@filterfals

; 3660 :         Py_DECREF(it);

  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000b5	e8 00 00 00 00	 call	 _Py_DecRef

; 3661 :         return NULL;

  000ba	33 c0		 xor	 eax, eax
  000bc	eb 2b		 jmp	 SHORT $LN5@filterfals
$LN1@filterfals:

; 3662 :     }
; 3663 :     Py_INCREF(func);

  000be	48 8b 4c 24 48	 mov	 rcx, QWORD PTR func$[rsp]
  000c3	e8 00 00 00 00	 call	 _Py_IncRef

; 3664 :     lz->func = func;

  000c8	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000cd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR func$[rsp]
  000d2	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3665 :     lz->it = it;

  000d6	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
  000db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR it$[rsp]
  000e0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 3666 : 
; 3667 :     return (PyObject *)lz;

  000e4	48 8b 44 24 38	 mov	 rax, QWORD PTR lz$[rsp]
$LN5@filterfals:

; 3668 : }

  000e9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ed	c3		 ret	 0
filterfalse_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$filterfalse_dealloc DD imagerel filterfalse_dealloc
	DD	imagerel filterfalse_dealloc+108
	DD	imagerel $unwind$filterfalse_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$filterfalse_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT filterfalse_dealloc
_TEXT	SEGMENT
lz$ = 48
filterfalse_dealloc PROC				; COMDAT

; 3672 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3673 :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN8@filterfals@2:

; 3674 :     Py_XDECREF(lz->func);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN5@filterfals@2
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@filterfals@2:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN8@filterfals@2
$LN4@filterfals@2:

; 3675 :     Py_XDECREF(lz->it);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0003d	74 0e		 je	 SHORT $LN1@filterfals@2
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@filterfals@2:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN4@filterfals@2

; 3676 :     Py_TYPE(lz)->tp_free(lz);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  00061	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 3677 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
filterfalse_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@NIBBPCLH@filterfalse_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$filterfalse_traverse DD imagerel filterfalse_traverse
	DD	imagerel filterfalse_traverse+206
	DD	imagerel $unwind$filterfalse_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$filterfalse_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BF@NIBBPCLH@filterfalse_traverse?$AA@
CONST	SEGMENT
??_C@_0BF@NIBBPCLH@filterfalse_traverse?$AA@ DB 'filterfalse_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT filterfalse_traverse
_TEXT	SEGMENT
vret$23606 = 32
vret$23614 = 36
lz$ = 64
visit$ = 72
arg$ = 80
filterfalse_traverse PROC				; COMDAT

; 3681 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@filterfals@3:

; 3682 :     Py_VISIT(lz->it);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@filterfals@3
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 62 0e 00
	00		 mov	 r8d, 3682		; 00000e62H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@NIBBPCLH@filterfalse_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@filterfals@3:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00042	74 23		 je	 SHORT $LN8@filterfals@3
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$23606[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$23606[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@filterfals@3
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$23606[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@filterfals@3
$LN7@filterfals@3:
$LN8@filterfals@3:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@filterfals@3
$LN6@filterfals@3:

; 3683 :     Py_VISIT(lz->func);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@filterfals@3
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 63 0e 00
	00		 mov	 r8d, 3683		; 00000e63H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@NIBBPCLH@filterfalse_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@filterfals@3:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00097	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0009c	74 23		 je	 SHORT $LN2@filterfals@3
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000a8	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$23614[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$23614[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@filterfals@3
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$23614[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@filterfals@3
$LN1@filterfals@3:
$LN2@filterfals@3:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@filterfals@3

; 3684 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@filterfals@3:

; 3685 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
filterfalse_traverse ENDP
_TEXT	ENDS
EXTRN	PyBool_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$filterfalse_next DD imagerel filterfalse_next
	DD	imagerel filterfalse_next+243
	DD	imagerel $unwind$filterfalse_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$filterfalse_next DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT filterfalse_next
_TEXT	SEGMENT
it$ = 32
iternext$ = 40
ok$ = 48
item$ = 56
good$23637 = 64
lz$ = 96
filterfalse_next PROC					; COMDAT

; 3689 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3690 :     PyObject *item;
; 3691 :     PyObject *it = lz->it;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00012	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 3692 :     long ok;
; 3693 :     PyObject *(*iternext)(PyObject *);
; 3694 : 
; 3695 :     iternext = *Py_TYPE(it)->tp_iternext;

  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR it$[rsp]
  0001c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00020	48 8b 80 38 01
	00 00		 mov	 rax, QWORD PTR [rax+312]
  00027	48 89 44 24 28	 mov	 QWORD PTR iternext$[rsp], rax
$LN9@filterfals@4:

; 3696 :     for (;;) {
; 3697 :         item = iternext(it);

  0002c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00031	ff 54 24 28	 call	 QWORD PTR iternext$[rsp]
  00035	48 89 44 24 38	 mov	 QWORD PTR item$[rsp], rax

; 3698 :         if (item == NULL)

  0003a	48 83 7c 24 38
	00		 cmp	 QWORD PTR item$[rsp], 0
  00040	75 07		 jne	 SHORT $LN7@filterfals@4

; 3699 :             return NULL;

  00042	33 c0		 xor	 eax, eax
  00044	e9 a5 00 00 00	 jmp	 $LN10@filterfals@4
$LN7@filterfals@4:

; 3700 : 
; 3701 :         if (lz->func == Py_None || lz->func == (PyObject *)&PyBool_Type) {

  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00050	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  00055	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  00059	74 12		 je	 SHORT $LN5@filterfals@4
  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyBool_Type
  00062	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  00067	48 39 41 60	 cmp	 QWORD PTR [rcx+96], rax
  0006b	75 10		 jne	 SHORT $LN6@filterfals@4
$LN5@filterfals@4:

; 3702 :             ok = PyObject_IsTrue(item);

  0006d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR item$[rsp]
  00072	e8 00 00 00 00	 call	 PyObject_IsTrue
  00077	89 44 24 30	 mov	 DWORD PTR ok$[rsp], eax

; 3703 :         } else {

  0007b	eb 49		 jmp	 SHORT $LN4@filterfals@4
$LN6@filterfals@4:

; 3704 :             PyObject *good;
; 3705 :             good = PyObject_CallFunctionObjArgs(lz->func,
; 3706 :                                                 item, NULL);

  0007d	45 33 c0	 xor	 r8d, r8d
  00080	48 8b 54 24 38	 mov	 rdx, QWORD PTR item$[rsp]
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0008a	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0008e	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  00093	48 89 44 24 40	 mov	 QWORD PTR good$23637[rsp], rax

; 3707 :             if (good == NULL) {

  00098	48 83 7c 24 40
	00		 cmp	 QWORD PTR good$23637[rsp], 0
  0009e	75 0e		 jne	 SHORT $LN3@filterfals@4

; 3708 :                 Py_DECREF(item);

  000a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR item$[rsp]
  000a5	e8 00 00 00 00	 call	 _Py_DecRef

; 3709 :                 return NULL;

  000aa	33 c0		 xor	 eax, eax
  000ac	eb 40		 jmp	 SHORT $LN10@filterfals@4
$LN3@filterfals@4:

; 3710 :             }
; 3711 :             ok = PyObject_IsTrue(good);

  000ae	48 8b 4c 24 40	 mov	 rcx, QWORD PTR good$23637[rsp]
  000b3	e8 00 00 00 00	 call	 PyObject_IsTrue
  000b8	89 44 24 30	 mov	 DWORD PTR ok$[rsp], eax

; 3712 :             Py_DECREF(good);

  000bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR good$23637[rsp]
  000c1	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@filterfals@4:

; 3713 :         }
; 3714 :         if (ok == 0)

  000c6	83 7c 24 30 00	 cmp	 DWORD PTR ok$[rsp], 0
  000cb	75 07		 jne	 SHORT $LN2@filterfals@4

; 3715 :             return item;

  000cd	48 8b 44 24 38	 mov	 rax, QWORD PTR item$[rsp]
  000d2	eb 1a		 jmp	 SHORT $LN10@filterfals@4
$LN2@filterfals@4:

; 3716 :         Py_DECREF(item);

  000d4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR item$[rsp]
  000d9	e8 00 00 00 00	 call	 _Py_DecRef

; 3717 :         if (ok < 0)

  000de	83 7c 24 30 00	 cmp	 DWORD PTR ok$[rsp], 0
  000e3	7d 04		 jge	 SHORT $LN1@filterfals@4

; 3718 :             return NULL;

  000e5	33 c0		 xor	 eax, eax
  000e7	eb 05		 jmp	 SHORT $LN10@filterfals@4
$LN1@filterfals@4:

; 3719 :     }

  000e9	e9 3e ff ff ff	 jmp	 $LN9@filterfals@4
$LN10@filterfals@4:

; 3720 : }

  000ee	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f2	c3		 ret	 0
filterfalse_next ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$filterfalse_reduce DD imagerel filterfalse_reduce
	DD	imagerel filterfalse_reduce+53
	DD	imagerel $unwind$filterfalse_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$filterfalse_reduce DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT filterfalse_reduce
_TEXT	SEGMENT
lz$ = 48
filterfalse_reduce PROC					; COMDAT

; 3724 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3725 :     return Py_BuildValue("O(OO)", Py_TYPE(lz),
; 3726 :         lz->func, lz->it);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  00012	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00017	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00020	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LNHFJPFN@O?$CIOO?$CJ?$AA@
  0002b	e8 00 00 00 00	 call	 Py_BuildValue

; 3727 :     }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
filterfalse_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_1JC@PDAEHOFL@?$AAs?$AAl?$AAo?$AAw?$AA_?$AAm?$AAo?$AAd?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA_@ ; `string'
PUBLIC	??_C@_1OM@MOOKLHJN@?$AA?$CI?$AAc?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA_?$AAc@ ; `string'
PUBLIC	??_C@_09EFCNLPME@count_new?$AA@			; `string'
PUBLIC	??_C@_1EM@NJMOEBOK@?$AAl?$AAo?$AAn?$AAg?$AA_?$AAc?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA_?$AAs?$AAt?$AAe?$AAp?$AA?5?$AA?$CB?$AA?$DN@ ; `string'
PUBLIC	??_C@_0BF@EMLKNKNJ@a?5number?5is?5required?$AA@	; `string'
PUBLIC	??_C@_09MNHMIDAK@?$HMOO?3count?$AA@		; `string'
EXTRN	PyLong_AsLong:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyNumber_Check:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_new DD imagerel count_new
	DD	imagerel count_new+848
	DD	imagerel $unwind$count_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_new DD 011301H
	DD	0e213H
xdata	ENDS
;	COMDAT ??_C@_1JC@PDAEHOFL@?$AAs?$AAl?$AAo?$AAw?$AA_?$AAm?$AAo?$AAd?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA_@
CONST	SEGMENT
??_C@_1JC@PDAEHOFL@?$AAs?$AAl?$AAo?$AAw?$AA_?$AAm?$AAo?$AAd?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA_@ DB 's'
	DB	00H, 'l', 00H, 'o', 00H, 'w', 00H, '_', 00H, 'm', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, ' ', 00H, '|', 00H, '|', 00H, ' ', 00H, '('
	DB	00H, 'P', 00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'l', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H, 's', 00H
	DB	't', 00H, 'e', 00H, 'p', 00H, ')', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'P', 00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H
	DB	'g', 00H, '_', 00H, 'A', 00H, 'S', 00H, '_', 00H, 'L', 00H, 'O'
	DB	00H, 'N', 00H, 'G', 00H, '(', 00H, 'l', 00H, 'o', 00H, 'n', 00H
	DB	'g', 00H, '_', 00H, 's', 00H, 't', 00H, 'e', 00H, 'p', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1OM@MOOKLHJN@?$AA?$CI?$AAc?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA_?$AAc@
CONST	SEGMENT
??_C@_1OM@MOOKLHJN@?$AA?$CI?$AAc?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA_?$AAc@ DB '('
	DB	00H, 'c', 00H, 'n', 00H, 't', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'P', 00H, 'Y', 00H, '_', 00H, 'S', 00H, 'S', 00H, 'I'
	DB	00H, 'Z', 00H, 'E', 00H, '_', 00H, 'T', 00H, '_', 00H, 'M', 00H
	DB	'A', 00H, 'X', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'l'
	DB	00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'c', 00H, 'n', 00H
	DB	't', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'!', 00H, 's', 00H, 'l', 00H, 'o', 00H, 'w', 00H, '_', 00H, 'm'
	DB	00H, 'o', 00H, 'd', 00H, 'e', 00H, ')', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, '(', 00H, 'c', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'Y', 00H, '_', 00H
	DB	'S', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '_', 00H, 'T'
	DB	00H, '_', 00H, 'M', 00H, 'A', 00H, 'X', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_'
	DB	00H, 'c', 00H, 'n', 00H, 't', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 's', 00H, 'l', 00H, 'o', 00H, 'w', 00H
	DB	'_', 00H, 'm', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_09EFCNLPME@count_new?$AA@
CONST	SEGMENT
??_C@_09EFCNLPME@count_new?$AA@ DB 'count_new', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@NJMOEBOK@?$AAl?$AAo?$AAn?$AAg?$AA_?$AAc?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA_?$AAs?$AAt?$AAe?$AAp?$AA?5?$AA?$CB?$AA?$DN@
CONST	SEGMENT
??_C@_1EM@NJMOEBOK@?$AAl?$AAo?$AAn?$AAg?$AA_?$AAc?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA_?$AAs?$AAt?$AAe?$AAp?$AA?5?$AA?$CB?$AA?$DN@ DB 'l'
	DB	00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'c', 00H, 'n', 00H
	DB	't', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U'
	DB	00H, 'L', 00H, 'L', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H
	DB	'l', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H, 's', 00H, 't'
	DB	00H, 'e', 00H, 'p', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EMLKNKNJ@a?5number?5is?5required?$AA@
CONST	SEGMENT
??_C@_0BF@EMLKNKNJ@a?5number?5is?5required?$AA@ DB 'a number is required', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09MNHMIDAK@?$HMOO?3count?$AA@
CONST	SEGMENT
??_C@_09MNHMIDAK@?$HMOO?3count?$AA@ DB '|OO:count', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT count_new
_TEXT	SEGMENT
slow_mode$ = 48
cnt$ = 56
step$ = 64
lz$ = 72
long_step$ = 80
long_cnt$ = 88
_py_tmp$23744 = 96
type$ = 128
args$ = 136
kwds$ = 144
count_new PROC						; COMDAT

; 3816 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 3817 :     countobject *lz;
; 3818 :     int slow_mode = 0;

  00013	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR slow_mode$[rsp], 0

; 3819 :     Py_ssize_t cnt = 0;

  0001b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR cnt$[rsp], 0

; 3820 :     PyObject *long_cnt = NULL;

  00024	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR long_cnt$[rsp], 0

; 3821 :     PyObject *long_step = NULL;

  0002d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR long_step$[rsp], 0

; 3822 :     long step;
; 3823 :     static char *kwlist[] = {"start", "step", 0};
; 3824 : 
; 3825 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "|OO:count",
; 3826 :                     kwlist, &long_cnt, &long_step))

  00036	48 8d 44 24 50	 lea	 rax, QWORD PTR long_step$[rsp]
  0003b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00040	48 8d 44 24 58	 lea	 rax, QWORD PTR long_cnt$[rsp]
  00045	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwlist@?1??count_new@@9@9
  00051	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_09MNHMIDAK@?$HMOO?3count?$AA@
  00058	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR kwds$[rsp]
  00060	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00068	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0006d	85 c0		 test	 eax, eax
  0006f	75 07		 jne	 SHORT $LN25@count_new

; 3827 :         return NULL;

  00071	33 c0		 xor	 eax, eax
  00073	e9 d3 02 00 00	 jmp	 $LN26@count_new
$LN25@count_new:

; 3828 : 
; 3829 :     if ((long_cnt != NULL && !PyNumber_Check(long_cnt)) ||
; 3830 :         (long_step != NULL && !PyNumber_Check(long_step))) {

  00078	48 83 7c 24 58
	00		 cmp	 QWORD PTR long_cnt$[rsp], 0
  0007e	74 0e		 je	 SHORT $LN22@count_new
  00080	48 8b 4c 24 58	 mov	 rcx, QWORD PTR long_cnt$[rsp]
  00085	e8 00 00 00 00	 call	 PyNumber_Check
  0008a	85 c0		 test	 eax, eax
  0008c	74 16		 je	 SHORT $LN23@count_new
$LN22@count_new:
  0008e	48 83 7c 24 50
	00		 cmp	 QWORD PTR long_step$[rsp], 0
  00094	74 28		 je	 SHORT $LN24@count_new
  00096	48 8b 4c 24 50	 mov	 rcx, QWORD PTR long_step$[rsp]
  0009b	e8 00 00 00 00	 call	 PyNumber_Check
  000a0	85 c0		 test	 eax, eax
  000a2	75 1a		 jne	 SHORT $LN24@count_new
$LN23@count_new:

; 3831 :                     PyErr_SetString(PyExc_TypeError, "a number is required");

  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@EMLKNKNJ@a?5number?5is?5required?$AA@
  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000b2	e8 00 00 00 00	 call	 PyErr_SetString

; 3832 :                     return NULL;

  000b7	33 c0		 xor	 eax, eax
  000b9	e9 8d 02 00 00	 jmp	 $LN26@count_new
$LN24@count_new:

; 3833 :     }
; 3834 : 
; 3835 :     if (long_cnt != NULL) {

  000be	48 83 7c 24 58
	00		 cmp	 QWORD PTR long_cnt$[rsp], 0
  000c4	74 52		 je	 SHORT $LN21@count_new

; 3836 :         cnt = PyLong_AsSsize_t(long_cnt);

  000c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR long_cnt$[rsp]
  000cb	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  000d0	48 89 44 24 38	 mov	 QWORD PTR cnt$[rsp], rax

; 3837 :         if ((cnt == -1 && PyErr_Occurred()) || !PyLong_Check(long_cnt)) {

  000d5	48 83 7c 24 38
	ff		 cmp	 QWORD PTR cnt$[rsp], -1
  000db	75 0a		 jne	 SHORT $LN18@count_new
  000dd	e8 00 00 00 00	 call	 PyErr_Occurred
  000e2	48 85 c0	 test	 rax, rax
  000e5	75 18		 jne	 SHORT $LN19@count_new
$LN18@count_new:
  000e7	48 8b 44 24 58	 mov	 rax, QWORD PTR long_cnt$[rsp]
  000ec	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f6	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000fb	85 c0		 test	 eax, eax
  000fd	75 0d		 jne	 SHORT $LN20@count_new
$LN19@count_new:

; 3838 :             PyErr_Clear();

  000ff	e8 00 00 00 00	 call	 PyErr_Clear

; 3839 :             slow_mode = 1;

  00104	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR slow_mode$[rsp], 1
$LN20@count_new:

; 3840 :         }
; 3841 :         Py_INCREF(long_cnt);

  0010c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR long_cnt$[rsp]
  00111	e8 00 00 00 00	 call	 _Py_IncRef

; 3842 :     } else {

  00116	eb 15		 jmp	 SHORT $LN17@count_new
$LN21@count_new:

; 3843 :         cnt = 0;

  00118	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR cnt$[rsp], 0

; 3844 :         long_cnt = PyLong_FromLong(0);

  00121	33 c9		 xor	 ecx, ecx
  00123	e8 00 00 00 00	 call	 PyLong_FromLong
  00128	48 89 44 24 58	 mov	 QWORD PTR long_cnt$[rsp], rax
$LN17@count_new:

; 3845 :     }
; 3846 : 
; 3847 :     /* If not specified, step defaults to 1 */
; 3848 :     if (long_step == NULL) {

  0012d	48 83 7c 24 50
	00		 cmp	 QWORD PTR long_step$[rsp], 0
  00133	75 2a		 jne	 SHORT $LN16@count_new

; 3849 :         long_step = PyLong_FromLong(1);

  00135	b9 01 00 00 00	 mov	 ecx, 1
  0013a	e8 00 00 00 00	 call	 PyLong_FromLong
  0013f	48 89 44 24 50	 mov	 QWORD PTR long_step$[rsp], rax

; 3850 :         if (long_step == NULL) {

  00144	48 83 7c 24 50
	00		 cmp	 QWORD PTR long_step$[rsp], 0
  0014a	75 11		 jne	 SHORT $LN15@count_new

; 3851 :             Py_DECREF(long_cnt);

  0014c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR long_cnt$[rsp]
  00151	e8 00 00 00 00	 call	 _Py_DecRef

; 3852 :             return NULL;

  00156	33 c0		 xor	 eax, eax
  00158	e9 ee 01 00 00	 jmp	 $LN26@count_new
$LN15@count_new:

; 3853 :         }
; 3854 :     } else

  0015d	eb 0a		 jmp	 SHORT $LN14@count_new
$LN16@count_new:

; 3855 :         Py_INCREF(long_step);

  0015f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR long_step$[rsp]
  00164	e8 00 00 00 00	 call	 _Py_IncRef
$LN14@count_new:

; 3856 : 
; 3857 :     assert(long_cnt != NULL && long_step != NULL);

  00169	48 83 7c 24 58
	00		 cmp	 QWORD PTR long_cnt$[rsp], 0
  0016f	74 08		 je	 SHORT $LN28@count_new
  00171	48 83 7c 24 50
	00		 cmp	 QWORD PTR long_step$[rsp], 0
  00177	75 1c		 jne	 SHORT $LN29@count_new
$LN28@count_new:
  00179	41 b8 11 0f 00
	00		 mov	 r8d, 3857		; 00000f11H
  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@NJMOEBOK@?$AAl?$AAo?$AAn?$AAg?$AA_?$AAc?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA_?$AAs?$AAt?$AAe?$AAp?$AA?5?$AA?$CB?$AA?$DN@
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00193	33 c0		 xor	 eax, eax
$LN29@count_new:

; 3858 : 
; 3859 :     /* Fast mode only works when the step is 1 */
; 3860 :     step = PyLong_AsLong(long_step);

  00195	48 8b 4c 24 50	 mov	 rcx, QWORD PTR long_step$[rsp]
  0019a	e8 00 00 00 00	 call	 PyLong_AsLong
  0019f	89 44 24 40	 mov	 DWORD PTR step$[rsp], eax

; 3861 :     if (step != 1) {

  001a3	83 7c 24 40 01	 cmp	 DWORD PTR step$[rsp], 1
  001a8	74 1e		 je	 SHORT $LN13@count_new

; 3862 :         slow_mode = 1;

  001aa	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR slow_mode$[rsp], 1

; 3863 :         if (step == -1 && PyErr_Occurred())

  001b2	83 7c 24 40 ff	 cmp	 DWORD PTR step$[rsp], -1
  001b7	75 0f		 jne	 SHORT $LN12@count_new
  001b9	e8 00 00 00 00	 call	 PyErr_Occurred
  001be	48 85 c0	 test	 rax, rax
  001c1	74 05		 je	 SHORT $LN12@count_new

; 3864 :             PyErr_Clear();

  001c3	e8 00 00 00 00	 call	 PyErr_Clear
$LN12@count_new:
$LN13@count_new:

; 3865 :     }
; 3866 : 
; 3867 :     if (slow_mode)

  001c8	83 7c 24 30 00	 cmp	 DWORD PTR slow_mode$[rsp], 0
  001cd	74 11		 je	 SHORT $LN11@count_new

; 3868 :         cnt = PY_SSIZE_T_MAX;

  001cf	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  001d9	48 89 44 24 38	 mov	 QWORD PTR cnt$[rsp], rax

; 3869 :     else

  001de	eb 55		 jmp	 SHORT $LN10@count_new
$LN11@count_new:
$LN9@count_new:

; 3870 :         Py_CLEAR(long_cnt);

  001e0	48 83 7c 24 58
	00		 cmp	 QWORD PTR long_cnt$[rsp], 0
  001e6	74 47		 je	 SHORT $LN6@count_new
  001e8	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001f0	4c 8b 4c 24 58	 mov	 r9, QWORD PTR long_cnt$[rsp]
  001f5	41 b8 1e 0f 00
	00		 mov	 r8d, 3870		; 00000f1eH
  001fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09EFCNLPME@count_new?$AA@
  00209	e8 00 00 00 00	 call	 _PyParallel_Guard
  0020e	85 c0		 test	 eax, eax
  00210	75 1d		 jne	 SHORT $LN6@count_new
  00212	48 8b 44 24 58	 mov	 rax, QWORD PTR long_cnt$[rsp]
  00217	48 89 44 24 60	 mov	 QWORD PTR _py_tmp$23744[rsp], rax
  0021c	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR long_cnt$[rsp], 0
  00225	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _py_tmp$23744[rsp]
  0022a	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@count_new:
  0022f	33 c0		 xor	 eax, eax
  00231	85 c0		 test	 eax, eax
  00233	75 ab		 jne	 SHORT $LN9@count_new
$LN10@count_new:

; 3871 : 
; 3872 :     assert((cnt != PY_SSIZE_T_MAX && long_cnt == NULL && !slow_mode) ||
; 3873 :            (cnt == PY_SSIZE_T_MAX && long_cnt != NULL && slow_mode));

  00235	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0023f	48 39 44 24 38	 cmp	 QWORD PTR cnt$[rsp], rax
  00244	74 0f		 je	 SHORT $LN30@count_new
  00246	48 83 7c 24 58
	00		 cmp	 QWORD PTR long_cnt$[rsp], 0
  0024c	75 07		 jne	 SHORT $LN30@count_new
  0024e	83 7c 24 30 00	 cmp	 DWORD PTR slow_mode$[rsp], 0
  00253	74 3c		 je	 SHORT $LN32@count_new
$LN30@count_new:
  00255	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0025f	48 39 44 24 38	 cmp	 QWORD PTR cnt$[rsp], rax
  00264	75 0f		 jne	 SHORT $LN31@count_new
  00266	48 83 7c 24 58
	00		 cmp	 QWORD PTR long_cnt$[rsp], 0
  0026c	74 07		 je	 SHORT $LN31@count_new
  0026e	83 7c 24 30 00	 cmp	 DWORD PTR slow_mode$[rsp], 0
  00273	75 1c		 jne	 SHORT $LN32@count_new
$LN31@count_new:
  00275	41 b8 21 0f 00
	00		 mov	 r8d, 3873		; 00000f21H
  0027b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1OM@MOOKLHJN@?$AA?$CI?$AAc?$AAn?$AAt?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn?$AAg?$AA_?$AAc@
  00289	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0028f	33 c0		 xor	 eax, eax
$LN32@count_new:

; 3874 :     assert(slow_mode ||
; 3875 :            (PyLong_Check(long_step) && PyLong_AS_LONG(long_step) == 1));

  00291	83 7c 24 30 00	 cmp	 DWORD PTR slow_mode$[rsp], 0
  00296	75 43		 jne	 SHORT $LN34@count_new
  00298	48 8b 44 24 50	 mov	 rax, QWORD PTR long_step$[rsp]
  0029d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002a1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002a7	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  002ac	85 c0		 test	 eax, eax
  002ae	74 0f		 je	 SHORT $LN33@count_new
  002b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR long_step$[rsp]
  002b5	e8 00 00 00 00	 call	 PyLong_AsLong
  002ba	83 f8 01	 cmp	 eax, 1
  002bd	74 1c		 je	 SHORT $LN34@count_new
$LN33@count_new:
  002bf	41 b8 23 0f 00
	00		 mov	 r8d, 3875		; 00000f23H
  002c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  002cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1JC@PDAEHOFL@?$AAs?$AAl?$AAo?$AAw?$AA_?$AAm?$AAo?$AAd?$AAe?$AA?5?$AA?$HM?$AA?$HM?$AA?5?$AA?$CI?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAl?$AAo?$AAn?$AAg?$AA_@
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  002d9	33 c0		 xor	 eax, eax
$LN34@count_new:

; 3876 : 
; 3877 :     /* create countobject structure */
; 3878 :     lz = (countobject *)type->tp_alloc(type, 0);

  002db	33 d2		 xor	 edx, edx
  002dd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  002e5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR type$[rsp]
  002ed	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  002f3	48 89 44 24 48	 mov	 QWORD PTR lz$[rsp], rax

; 3879 :     if (lz == NULL) {

  002f8	48 83 7c 24 48
	00		 cmp	 QWORD PTR lz$[rsp], 0
  002fe	75 1c		 jne	 SHORT $LN5@count_new
$LN4@count_new:

; 3880 :         Py_XDECREF(long_cnt);

  00300	48 83 7c 24 58
	00		 cmp	 QWORD PTR long_cnt$[rsp], 0
  00306	74 0a		 je	 SHORT $LN1@count_new
  00308	48 8b 4c 24 58	 mov	 rcx, QWORD PTR long_cnt$[rsp]
  0030d	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@count_new:
  00312	33 c0		 xor	 eax, eax
  00314	85 c0		 test	 eax, eax
  00316	75 e8		 jne	 SHORT $LN4@count_new

; 3881 :         return NULL;

  00318	33 c0		 xor	 eax, eax
  0031a	eb 2f		 jmp	 SHORT $LN26@count_new
$LN5@count_new:

; 3882 :     }
; 3883 :     lz->cnt = cnt;

  0031c	48 8b 44 24 48	 mov	 rax, QWORD PTR lz$[rsp]
  00321	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cnt$[rsp]
  00326	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 3884 :     lz->long_cnt = long_cnt;

  0032a	48 8b 44 24 48	 mov	 rax, QWORD PTR lz$[rsp]
  0032f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR long_cnt$[rsp]
  00334	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 3885 :     lz->long_step = long_step;

  00338	48 8b 44 24 48	 mov	 rax, QWORD PTR lz$[rsp]
  0033d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR long_step$[rsp]
  00342	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 3886 : 
; 3887 :     return (PyObject *)lz;

  00346	48 8b 44 24 48	 mov	 rax, QWORD PTR lz$[rsp]
$LN26@count_new:

; 3888 : }

  0034b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0034f	c3		 ret	 0
count_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_dealloc DD imagerel count_dealloc
	DD	imagerel count_dealloc+108
	DD	imagerel $unwind$count_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT count_dealloc
_TEXT	SEGMENT
lz$ = 48
count_dealloc PROC					; COMDAT

; 3892 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3893 :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN8@count_deal:

; 3894 :     Py_XDECREF(lz->long_cnt);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0001d	74 0e		 je	 SHORT $LN5@count_deal
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@count_deal:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN8@count_deal
$LN4@count_deal:

; 3895 :     Py_XDECREF(lz->long_step);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0003d	74 0e		 je	 SHORT $LN1@count_deal
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@count_deal:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN4@count_deal

; 3896 :     Py_TYPE(lz)->tp_free(lz);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  00061	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 3897 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
count_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@KMCDBABA@count_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_traverse DD imagerel count_traverse
	DD	imagerel count_traverse+206
	DD	imagerel $unwind$count_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0P@KMCDBABA@count_traverse?$AA@
CONST	SEGMENT
??_C@_0P@KMCDBABA@count_traverse?$AA@ DB 'count_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT count_traverse
_TEXT	SEGMENT
vret$23798 = 32
vret$23806 = 36
lz$ = 64
visit$ = 72
arg$ = 80
count_traverse PROC					; COMDAT

; 3901 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN12@count_trav:

; 3902 :     Py_VISIT(lz->long_cnt);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN9@count_trav
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 3e 0f 00
	00		 mov	 r8d, 3902		; 00000f3eH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@KMCDBABA@count_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@count_trav:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00042	74 23		 je	 SHORT $LN8@count_trav
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$23798[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$23798[rsp], 0
  0005f	74 06		 je	 SHORT $LN7@count_trav
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$23798[rsp]
  00065	eb 62		 jmp	 SHORT $LN13@count_trav
$LN7@count_trav:
$LN8@count_trav:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN12@count_trav
$LN6@count_trav:

; 3903 :     Py_VISIT(lz->long_step);

  0006d	e8 00 00 00 00	 call	 _Py_PXCTX
  00072	85 c0		 test	 eax, eax
  00074	74 1c		 je	 SHORT $LN3@count_trav
  00076	45 33 c9	 xor	 r9d, r9d
  00079	41 b8 3f 0f 00
	00		 mov	 r8d, 3903		; 00000f3fH
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@KMCDBABA@count_traverse?$AA@
  0008d	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@count_trav:
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00097	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0009c	74 23		 je	 SHORT $LN2@count_trav
  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000a8	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  000ac	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b0	89 44 24 24	 mov	 DWORD PTR vret$23806[rsp], eax
  000b4	83 7c 24 24 00	 cmp	 DWORD PTR vret$23806[rsp], 0
  000b9	74 06		 je	 SHORT $LN1@count_trav
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR vret$23806[rsp]
  000bf	eb 08		 jmp	 SHORT $LN13@count_trav
$LN1@count_trav:
$LN2@count_trav:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 a6		 jne	 SHORT $LN6@count_trav

; 3904 :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN13@count_trav:

; 3905 : }

  000c9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cd	c3		 ret	 0
count_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_next DD imagerel count_next
	DD	imagerel count_next+92
	DD	imagerel $unwind$count_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_next DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT count_next
_TEXT	SEGMENT
tv73 = 32
lz$ = 64
count_next PROC						; COMDAT

; 3931 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3932 :     if (lz->cnt == PY_SSIZE_T_MAX)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00018	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0001c	75 0c		 jne	 SHORT $LN1@count_next

; 3933 :         return count_nextlong(lz);

  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lz$[rsp]
  00023	e8 00 00 00 00	 call	 count_nextlong
  00028	eb 2d		 jmp	 SHORT $LN2@count_next
$LN1@count_next:

; 3934 :     return PyLong_FromSsize_t(lz->cnt++);

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0002f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00033	48 89 44 24 20	 mov	 QWORD PTR tv73[rsp], rax
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00041	48 ff c0	 inc	 rax
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR lz$[rsp]
  00049	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv73[rsp]
  00052	e8 00 00 00 00	 call	 PyLong_FromSsize_t
$LN2@count_next:

; 3935 : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
count_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_1FM@PFBCBGOL@?$AAl?$AAz?$AA?9?$AA?$DO?$AAc?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_nextlong DD imagerel count_nextlong
	DD	imagerel count_nextlong+180
	DD	imagerel $unwind$count_nextlong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_nextlong DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_1FM@PFBCBGOL@?$AAl?$AAz?$AA?9?$AA?$DO?$AAc?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn@
CONST	SEGMENT
??_C@_1FM@PFBCBGOL@?$AAl?$AAz?$AA?9?$AA?$DO?$AAc?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn@ DB 'l'
	DB	00H, 'z', 00H, '-', 00H, '>', 00H, 'c', 00H, 'n', 00H, 't', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'P', 00H, 'Y', 00H, '_'
	DB	00H, 'S', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '_', 00H
	DB	'T', 00H, '_', 00H, 'M', 00H, 'A', 00H, 'X', 00H, ' ', 00H, '&'
	DB	00H, '&', 00H, ' ', 00H, 'l', 00H, 'o', 00H, 'n', 00H, 'g', 00H
	DB	'_', 00H, 'c', 00H, 'n', 00H, 't', 00H, ' ', 00H, '!', 00H, '='
	DB	00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT count_nextlong
_TEXT	SEGMENT
stepped_up$ = 32
long_cnt$ = 40
lz$ = 64
count_nextlong PROC					; COMDAT

; 3909 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3910 :     PyObject *long_cnt;
; 3911 :     PyObject *stepped_up;
; 3912 : 
; 3913 :     long_cnt = lz->long_cnt;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00012	48 89 44 24 28	 mov	 QWORD PTR long_cnt$[rsp], rax

; 3914 :     if (long_cnt == NULL) {

  00017	48 83 7c 24 28
	00		 cmp	 QWORD PTR long_cnt$[rsp], 0
  0001d	75 20		 jne	 SHORT $LN3@count_next@2

; 3915 :         /* Switch to slow_mode */
; 3916 :         long_cnt = PyLong_FromSsize_t(PY_SSIZE_T_MAX);

  0001f	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00029	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  0002e	48 89 44 24 28	 mov	 QWORD PTR long_cnt$[rsp], rax

; 3917 :         if (long_cnt == NULL)

  00033	48 83 7c 24 28
	00		 cmp	 QWORD PTR long_cnt$[rsp], 0
  00039	75 04		 jne	 SHORT $LN2@count_next@2

; 3918 :             return NULL;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 70		 jmp	 SHORT $LN4@count_next@2
$LN2@count_next@2:
$LN3@count_next@2:

; 3919 :     }
; 3920 :     assert(lz->cnt == PY_SSIZE_T_MAX && long_cnt != NULL);

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  0004e	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  00052	75 08		 jne	 SHORT $LN6@count_next@2
  00054	48 83 7c 24 28
	00		 cmp	 QWORD PTR long_cnt$[rsp], 0
  0005a	75 1c		 jne	 SHORT $LN7@count_next@2
$LN6@count_next@2:
  0005c	41 b8 50 0f 00
	00		 mov	 r8d, 3920		; 00000f50H
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1FM@PFBCBGOL@?$AAl?$AAz?$AA?9?$AA?$DO?$AAc?$AAn?$AAt?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAP?$AAY?$AA_?$AAS?$AAS?$AAI?$AAZ?$AAE?$AA_?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAl?$AAo?$AAn@
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00076	33 c0		 xor	 eax, eax
$LN7@count_next@2:

; 3921 : 
; 3922 :     stepped_up = PyNumber_Add(long_cnt, lz->long_step);

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0007d	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00081	48 8b 4c 24 28	 mov	 rcx, QWORD PTR long_cnt$[rsp]
  00086	e8 00 00 00 00	 call	 PyNumber_Add
  0008b	48 89 44 24 20	 mov	 QWORD PTR stepped_up$[rsp], rax

; 3923 :     if (stepped_up == NULL)

  00090	48 83 7c 24 20
	00		 cmp	 QWORD PTR stepped_up$[rsp], 0
  00096	75 04		 jne	 SHORT $LN1@count_next@2

; 3924 :         return NULL;

  00098	33 c0		 xor	 eax, eax
  0009a	eb 13		 jmp	 SHORT $LN4@count_next@2
$LN1@count_next@2:

; 3925 :     lz->long_cnt = stepped_up;

  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR stepped_up$[rsp]
  000a6	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 3926 :     return long_cnt;

  000aa	48 8b 44 24 28	 mov	 rax, QWORD PTR long_cnt$[rsp]
$LN4@count_next@2:

; 3927 : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
count_nextlong ENDP
_TEXT	ENDS
PUBLIC	??_C@_0O@IHFKCJPO@count?$CI?$CFR?0?5?$CFR?$CJ?$AA@ ; `string'
PUBLIC	??_C@_09EHNGNPOI@count?$CI?$CFR?$CJ?$AA@	; `string'
PUBLIC	??_C@_0L@PHBELKDM@count?$CI?$CFzd?$CJ?$AA@	; `string'
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_repr DD imagerel count_repr
	DD	imagerel count_repr+189
	DD	imagerel $unwind$count_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_repr DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0O@IHFKCJPO@count?$CI?$CFR?0?5?$CFR?$CJ?$AA@
CONST	SEGMENT
??_C@_0O@IHFKCJPO@count?$CI?$CFR?0?5?$CFR?$CJ?$AA@ DB 'count(%R, %R)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09EHNGNPOI@count?$CI?$CFR?$CJ?$AA@
CONST	SEGMENT
??_C@_09EHNGNPOI@count?$CI?$CFR?$CJ?$AA@ DB 'count(%R)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PHBELKDM@count?$CI?$CFzd?$CJ?$AA@
CONST	SEGMENT
??_C@_0L@PHBELKDM@count?$CI?$CFzd?$CJ?$AA@ DB 'count(%zd)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT count_repr
_TEXT	SEGMENT
step$23847 = 32
lz$ = 64
count_repr PROC						; COMDAT

; 3939 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3940 :     if (lz->cnt != PY_SSIZE_T_MAX)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00018	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0001c	74 1a		 je	 SHORT $LN4@count_repr

; 3941 :         return PyUnicode_FromFormat("count(%zd)", lz->cnt);

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00023	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@PHBELKDM@count?$CI?$CFzd?$CJ?$AA@
  0002e	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00033	e9 80 00 00 00	 jmp	 $LN5@count_repr
$LN4@count_repr:

; 3942 : 
; 3943 :     if (PyLong_Check(lz->long_step)) {

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00041	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00045	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0004b	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00050	85 c0		 test	 eax, eax
  00052	74 46		 je	 SHORT $LN3@count_repr

; 3944 :         long step = PyLong_AsLong(lz->long_step);

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00059	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0005d	e8 00 00 00 00	 call	 PyLong_AsLong
  00062	89 44 24 20	 mov	 DWORD PTR step$23847[rsp], eax

; 3945 :         if (step == -1 && PyErr_Occurred()) {

  00066	83 7c 24 20 ff	 cmp	 DWORD PTR step$23847[rsp], -1
  0006b	75 0f		 jne	 SHORT $LN2@count_repr
  0006d	e8 00 00 00 00	 call	 PyErr_Occurred
  00072	48 85 c0	 test	 rax, rax
  00075	74 05		 je	 SHORT $LN2@count_repr

; 3946 :             PyErr_Clear();

  00077	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@count_repr:

; 3947 :         }
; 3948 :         if (step == 1) {

  0007c	83 7c 24 20 01	 cmp	 DWORD PTR step$23847[rsp], 1
  00081	75 17		 jne	 SHORT $LN1@count_repr

; 3949 :             /* Don't display step when it is an integer equal to 1 */
; 3950 :             return PyUnicode_FromFormat("count(%R)", lz->long_cnt);

  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00088	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09EHNGNPOI@count?$CI?$CFR?$CJ?$AA@
  00093	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00098	eb 1e		 jmp	 SHORT $LN5@count_repr
$LN1@count_repr:
$LN3@count_repr:

; 3951 :         }
; 3952 :     }
; 3953 :     return PyUnicode_FromFormat("count(%R, %R)",
; 3954 :                                                             lz->long_cnt, lz->long_step);

  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0009f	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000a8	48 8b 50 68	 mov	 rdx, QWORD PTR [rax+104]
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@IHFKCJPO@count?$CI?$CFR?0?5?$CFR?$CJ?$AA@
  000b3	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN5@count_repr:

; 3955 : }

  000b8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bc	c3		 ret	 0
count_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_04IAPHDJGK@O?$CIn?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$count_reduce DD imagerel count_reduce
	DD	imagerel count_reduce+106
	DD	imagerel $unwind$count_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$count_reduce DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_04IAPHDJGK@O?$CIn?$CJ?$AA@
CONST	SEGMENT
??_C@_04IAPHDJGK@O?$CIn?$CJ?$AA@ DB 'O(n)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT count_reduce
_TEXT	SEGMENT
lz$ = 48
count_reduce PROC					; COMDAT

; 3959 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3960 :     if (lz->cnt == PY_SSIZE_T_MAX)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 b9 ff ff ff
	ff ff ff ff 7f	 mov	 rcx, 9223372036854775807 ; 7fffffffffffffffH
  00018	48 39 48 60	 cmp	 QWORD PTR [rax+96], rcx
  0001c	75 29		 jne	 SHORT $LN1@count_redu

; 3961 :         return Py_BuildValue("O(OO)", Py_TYPE(lz), lz->long_cnt, lz->long_step);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00023	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0002c	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00035	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05LNHFJPFN@O?$CIOO?$CJ?$AA@
  00040	e8 00 00 00 00	 call	 Py_BuildValue
  00045	eb 1e		 jmp	 SHORT $LN2@count_redu
$LN1@count_redu:

; 3962 :     return Py_BuildValue("O(n)", Py_TYPE(lz), lz->cnt);

  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0004c	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00055	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04IAPHDJGK@O?$CIn?$CJ?$AA@
  00060	e8 00 00 00 00	 call	 Py_BuildValue
$LN2@count_redu:

; 3963 : }

  00065	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00069	c3		 ret	 0
count_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@GJLDHGFP@O?$HMn?3repeat?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$repeat_new DD imagerel repeat_new
	DD	imagerel repeat_new+201
	DD	imagerel $unwind$repeat_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$repeat_new DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0L@GJLDHGFP@O?$HMn?3repeat?$AA@
CONST	SEGMENT
??_C@_0L@GJLDHGFP@O?$HMn?3repeat?$AA@ DB 'O|n:repeat', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT repeat_new
_TEXT	SEGMENT
element$ = 48
cnt$ = 56
ro$ = 64
type$ = 96
args$ = 104
kwds$ = 112
repeat_new PROC						; COMDAT

; 4039 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4040 :     repeatobject *ro;
; 4041 :     PyObject *element;
; 4042 :     Py_ssize_t cnt = -1;

  00013	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR cnt$[rsp], -1

; 4043 :     static char *kwargs[] = {"object", "times", NULL};
; 4044 : 
; 4045 :     if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|n:repeat", kwargs,
; 4046 :                                      &element, &cnt))

  0001c	48 8d 44 24 38	 lea	 rax, QWORD PTR cnt$[rsp]
  00021	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00026	48 8d 44 24 30	 lea	 rax, QWORD PTR element$[rsp]
  0002b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00030	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?kwargs@?1??repeat_new@@9@9
  00037	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0L@GJLDHGFP@O?$HMn?3repeat?$AA@
  0003e	48 8b 54 24 70	 mov	 rdx, QWORD PTR kwds$[rsp]
  00043	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  00048	e8 00 00 00 00	 call	 PyArg_ParseTupleAndKeywords
  0004d	85 c0		 test	 eax, eax
  0004f	75 04		 jne	 SHORT $LN3@repeat_new

; 4047 :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	eb 6f		 jmp	 SHORT $LN4@repeat_new
$LN3@repeat_new:

; 4048 : 
; 4049 :     if (PyTuple_Size(args) == 2 && cnt < 0)

  00055	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0005a	e8 00 00 00 00	 call	 PyTuple_Size
  0005f	48 83 f8 02	 cmp	 rax, 2
  00063	75 11		 jne	 SHORT $LN2@repeat_new
  00065	48 83 7c 24 38
	00		 cmp	 QWORD PTR cnt$[rsp], 0
  0006b	7d 09		 jge	 SHORT $LN2@repeat_new

; 4050 :         cnt = 0;

  0006d	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR cnt$[rsp], 0
$LN2@repeat_new:

; 4051 : 
; 4052 :     ro = (repeatobject *)type->tp_alloc(type, 0);

  00076	33 d2		 xor	 edx, edx
  00078	48 8b 4c 24 60	 mov	 rcx, QWORD PTR type$[rsp]
  0007d	48 8b 44 24 60	 mov	 rax, QWORD PTR type$[rsp]
  00082	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00088	48 89 44 24 40	 mov	 QWORD PTR ro$[rsp], rax

; 4053 :     if (ro == NULL)

  0008d	48 83 7c 24 40
	00		 cmp	 QWORD PTR ro$[rsp], 0
  00093	75 04		 jne	 SHORT $LN1@repeat_new

; 4054 :         return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	eb 2b		 jmp	 SHORT $LN4@repeat_new
$LN1@repeat_new:

; 4055 :     Py_INCREF(element);

  00099	48 8b 4c 24 30	 mov	 rcx, QWORD PTR element$[rsp]
  0009e	e8 00 00 00 00	 call	 _Py_IncRef

; 4056 :     ro->element = element;

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR ro$[rsp]
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR element$[rsp]
  000ad	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 4057 :     ro->cnt = cnt;

  000b1	48 8b 44 24 40	 mov	 rax, QWORD PTR ro$[rsp]
  000b6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cnt$[rsp]
  000bb	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 4058 :     return (PyObject *)ro;

  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR ro$[rsp]
$LN4@repeat_new:

; 4059 : }

  000c4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c8	c3		 ret	 0
repeat_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$repeat_dealloc DD imagerel repeat_dealloc
	DD	imagerel repeat_dealloc+76
	DD	imagerel $unwind$repeat_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$repeat_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT repeat_dealloc
_TEXT	SEGMENT
ro$ = 48
repeat_dealloc PROC					; COMDAT

; 4063 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4064 :     PyObject_GC_UnTrack(ro);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ro$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN4@repeat_dea:

; 4065 :     Py_XDECREF(ro->element);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  00018	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0001d	74 0e		 je	 SHORT $LN1@repeat_dea
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  00024	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@repeat_dea:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN4@repeat_dea

; 4066 :     Py_TYPE(ro)->tp_free(ro);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  00038	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ro$[rsp]
  00041	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 4067 : }

  00047	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004b	c3		 ret	 0
repeat_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@BLMCKLBL@repeat_traverse?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$repeat_traverse DD imagerel repeat_traverse
	DD	imagerel repeat_traverse+116
	DD	imagerel $unwind$repeat_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$repeat_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BA@BLMCKLBL@repeat_traverse?$AA@
CONST	SEGMENT
??_C@_0BA@BLMCKLBL@repeat_traverse?$AA@ DB 'repeat_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT repeat_traverse
_TEXT	SEGMENT
vret$23942 = 32
ro$ = 64
visit$ = 72
arg$ = 80
repeat_traverse PROC					; COMDAT

; 4071 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@repeat_tra:

; 4072 :     Py_VISIT(ro->element);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN3@repeat_tra
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 e8 0f 00
	00		 mov	 r8d, 4072		; 00000fe8H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@BLMCKLBL@repeat_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@repeat_tra:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR ro$[rsp]
  0003d	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00042	74 23		 je	 SHORT $LN2@repeat_tra
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR ro$[rsp]
  0004e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$23942[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$23942[rsp], 0
  0005f	74 06		 je	 SHORT $LN1@repeat_tra
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$23942[rsp]
  00065	eb 08		 jmp	 SHORT $LN7@repeat_tra
$LN1@repeat_tra:
$LN2@repeat_tra:
  00067	33 c0		 xor	 eax, eax
  00069	85 c0		 test	 eax, eax
  0006b	75 a6		 jne	 SHORT $LN6@repeat_tra

; 4073 :     return 0;

  0006d	33 c0		 xor	 eax, eax
$LN7@repeat_tra:

; 4074 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
repeat_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$repeat_next DD imagerel repeat_next
	DD	imagerel repeat_next+86
	DD	imagerel $unwind$repeat_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$repeat_next DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT repeat_next
_TEXT	SEGMENT
ro$ = 48
repeat_next PROC					; COMDAT

; 4078 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4079 :     if (ro->cnt == 0)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	75 04		 jne	 SHORT $LN2@repeat_nex

; 4080 :         return NULL;

  00015	33 c0		 xor	 eax, eax
  00017	eb 38		 jmp	 SHORT $LN3@repeat_nex
$LN2@repeat_nex:

; 4081 :     if (ro->cnt > 0)

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0001e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00023	7e 15		 jle	 SHORT $LN1@repeat_nex

; 4082 :         ro->cnt--;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0002a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0002e	48 ff c8	 dec	 rax
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ro$[rsp]
  00036	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN1@repeat_nex:

; 4083 :     Py_INCREF(ro->element);

  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0003f	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00043	e8 00 00 00 00	 call	 _Py_IncRef

; 4084 :     return ro->element;

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0004d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
$LN3@repeat_nex:

; 4085 : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
repeat_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@LEOBDIJA@repeat?$CI?$CFR?0?5?$CFzd?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0L@JNABFBGF@repeat?$CI?$CFR?$CJ?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$repeat_repr DD imagerel repeat_repr
	DD	imagerel repeat_repr+81
	DD	imagerel $unwind$repeat_repr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$repeat_repr DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BA@LEOBDIJA@repeat?$CI?$CFR?0?5?$CFzd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BA@LEOBDIJA@repeat?$CI?$CFR?0?5?$CFzd?$CJ?$AA@ DB 'repeat(%R, %zd)'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JNABFBGF@repeat?$CI?$CFR?$CJ?$AA@
CONST	SEGMENT
??_C@_0L@JNABFBGF@repeat?$CI?$CFR?$CJ?$AA@ DB 'repeat(%R)', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT repeat_repr
_TEXT	SEGMENT
ro$ = 48
repeat_repr PROC					; COMDAT

; 4089 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4090 :     if (ro->cnt == -1)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0000e	48 83 78 68 ff	 cmp	 QWORD PTR [rax+104], -1
  00013	75 19		 jne	 SHORT $LN2@repeat_rep

; 4091 :         return PyUnicode_FromFormat("repeat(%R)", ro->element);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0001a	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@JNABFBGF@repeat?$CI?$CFR?$CJ?$AA@
  00025	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0002a	eb 20		 jmp	 SHORT $LN3@repeat_rep

; 4092 :     else

  0002c	eb 1e		 jmp	 SHORT $LN1@repeat_rep
$LN2@repeat_rep:

; 4093 :         return PyUnicode_FromFormat("repeat(%R, %zd)", ro->element, ro->cnt);

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  00033	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0003c	48 8b 50 60	 mov	 rdx, QWORD PTR [rax+96]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@LEOBDIJA@repeat?$CI?$CFR?0?5?$CFzd?$CJ?$AA@
  00047	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN1@repeat_rep:
$LN3@repeat_rep:

; 4094 : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
repeat_repr ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@HLGAKMHH@len?$CI?$CJ?5of?5unsized?5object?$AA@ ; `string'
EXTRN	PyLong_FromSize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$repeat_len DD imagerel repeat_len
	DD	imagerel repeat_len+63
	DD	imagerel $unwind$repeat_len
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$repeat_len DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_0BI@HLGAKMHH@len?$CI?$CJ?5of?5unsized?5object?$AA@
CONST	SEGMENT
??_C@_0BI@HLGAKMHH@len?$CI?$CJ?5of?5unsized?5object?$AA@ DB 'len() of uns'
	DB	'ized object', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT repeat_len
_TEXT	SEGMENT
ro$ = 48
repeat_len PROC						; COMDAT

; 4098 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4099 :     if (ro->cnt == -1) {

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0000e	48 83 78 68 ff	 cmp	 QWORD PTR [rax+104], -1
  00013	75 17		 jne	 SHORT $LN1@repeat_len

; 4100 :         PyErr_SetString(PyExc_TypeError, "len() of unsized object");

  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@HLGAKMHH@len?$CI?$CJ?5of?5unsized?5object?$AA@
  0001c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00023	e8 00 00 00 00	 call	 PyErr_SetString

; 4101 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 0e		 jmp	 SHORT $LN2@repeat_len
$LN1@repeat_len:

; 4102 :     }
; 4103 :     return PyLong_FromSize_t(ro->cnt);

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  00031	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00035	e8 00 00 00 00	 call	 PyLong_FromSize_t
$LN2@repeat_len:

; 4104 : }

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
repeat_len ENDP
_TEXT	ENDS
PUBLIC	??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@		; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$repeat_reduce DD imagerel repeat_reduce
	DD	imagerel repeat_reduce+99
	DD	imagerel $unwind$repeat_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$repeat_reduce DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT ??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@
CONST	SEGMENT
??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@ DB 'O(O)', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT repeat_reduce
_TEXT	SEGMENT
ro$ = 48
repeat_reduce PROC					; COMDAT

; 4110 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4111 :     /* unpickle this so that a new repeat iterator is constructed with an
; 4112 :      * object, then call __setstate__ on it to set cnt
; 4113 :      */
; 4114 :     if (ro->cnt >= 0)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0000e	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00013	7c 2b		 jl	 SHORT $LN2@repeat_red

; 4115 :         return Py_BuildValue("O(On)", Py_TYPE(ro), ro->element, ro->cnt);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0001a	4c 8b 48 68	 mov	 r9, QWORD PTR [rax+104]
  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  00023	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0002c	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05IEPKLDIK@O?$CIOn?$CJ?$AA@
  00037	e8 00 00 00 00	 call	 Py_BuildValue
  0003c	eb 20		 jmp	 SHORT $LN3@repeat_red

; 4116 :     else

  0003e	eb 1e		 jmp	 SHORT $LN1@repeat_red
$LN2@repeat_red:

; 4117 :         return Py_BuildValue("O(O)", Py_TYPE(ro), ro->element);

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  00045	4c 8b 40 60	 mov	 r8, QWORD PTR [rax+96]
  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR ro$[rsp]
  0004e	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04LJHIBFLN@O?$CIO?$CJ?$AA@
  00059	e8 00 00 00 00	 call	 Py_BuildValue
$LN1@repeat_red:
$LN3@repeat_red:

; 4118 : }

  0005e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00062	c3		 ret	 0
repeat_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@HEDIPOBC@zip_longest?5argument?5?$CD?$CFzd?5must?5s@ ; `string'
PUBLIC	??_C@_0DB@DOPEADI@zip_longest?$CI?$CJ?5got?5an?5unexpected?5@ ; `string'
PUBLIC	??_C@_09LJHHIKOH@fillvalue?$AA@			; `string'
EXTRN	PyErr_Format:PROC
EXTRN	PyDict_GetItemString:PROC
EXTRN	PyDict_Size:PROC
EXTRN	PyDict_Type:BYTE
EXTRN	PySequence_Size:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$zip_longest_new DD imagerel zip_longest_new
	DD	imagerel zip_longest_new+712
	DD	imagerel $unwind$zip_longest_new
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zip_longest_new DD 011301H
	DD	0c213H
xdata	ENDS
;	COMDAT ??_C@_0DB@HEDIPOBC@zip_longest?5argument?5?$CD?$CFzd?5must?5s@
CONST	SEGMENT
??_C@_0DB@HEDIPOBC@zip_longest?5argument?5?$CD?$CFzd?5must?5s@ DB 'zip_lo'
	DB	'ngest argument #%zd must support iteration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@DOPEADI@zip_longest?$CI?$CJ?5got?5an?5unexpected?5@
CONST	SEGMENT
??_C@_0DB@DOPEADI@zip_longest?$CI?$CJ?5got?5an?5unexpected?5@ DB 'zip_lon'
	DB	'gest() got an unexpected keyword argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LJHHIKOH@fillvalue?$AA@
CONST	SEGMENT
??_C@_09LJHHIKOH@fillvalue?$AA@ DB 'fillvalue', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT zip_longest_new
_TEXT	SEGMENT
tuplesize$ = 32
fillvalue$ = 40
i$ = 48
ittuple$ = 56
lz$ = 64
result$ = 72
it$24048 = 80
item$24046 = 88
type$ = 112
args$ = 120
kwds$ = 128
zip_longest_new PROC					; COMDAT

; 4192 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4193 :     ziplongestobject *lz;
; 4194 :     Py_ssize_t i;
; 4195 :     PyObject *ittuple;  /* tuple of iterators */
; 4196 :     PyObject *result;
; 4197 :     PyObject *fillvalue = Py_None;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0001a	48 89 44 24 28	 mov	 QWORD PTR fillvalue$[rsp], rax

; 4198 :     Py_ssize_t tuplesize = PySequence_Length(args);

  0001f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PySequence_Size
  00029	48 89 44 24 20	 mov	 QWORD PTR tuplesize$[rsp], rax

; 4199 : 
; 4200 :     if (kwds != NULL && PyDict_CheckExact(kwds) && PyDict_Size(kwds) > 0) {

  0002e	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR kwds$[rsp], 0
  00037	0f 84 8a 00 00
	00		 je	 $LN15@zip_longes
  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00044	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR kwds$[rsp]
  0004c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00050	74 15		 je	 SHORT $LN14@zip_longes
  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00059	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR kwds$[rsp]
  00061	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  00065	75 60		 jne	 SHORT $LN15@zip_longes
$LN14@zip_longes:
  00067	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR kwds$[rsp]
  0006f	e8 00 00 00 00	 call	 PyDict_Size
  00074	48 85 c0	 test	 rax, rax
  00077	7e 4e		 jle	 SHORT $LN15@zip_longes

; 4201 :         fillvalue = PyDict_GetItemString(kwds, "fillvalue");

  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LJHHIKOH@fillvalue?$AA@
  00080	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR kwds$[rsp]
  00088	e8 00 00 00 00	 call	 PyDict_GetItemString
  0008d	48 89 44 24 28	 mov	 QWORD PTR fillvalue$[rsp], rax

; 4202 :         if (fillvalue == NULL  ||  PyDict_Size(kwds) > 1) {

  00092	48 83 7c 24 28
	00		 cmp	 QWORD PTR fillvalue$[rsp], 0
  00098	74 13		 je	 SHORT $LN12@zip_longes
  0009a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR kwds$[rsp]
  000a2	e8 00 00 00 00	 call	 PyDict_Size
  000a7	48 83 f8 01	 cmp	 rax, 1
  000ab	7e 1a		 jle	 SHORT $LN13@zip_longes
$LN12@zip_longes:

; 4203 :             PyErr_SetString(PyExc_TypeError,
; 4204 :                 "zip_longest() got an unexpected keyword argument");

  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@DOPEADI@zip_longest?$CI?$CJ?5got?5an?5unexpected?5@
  000b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000bb	e8 00 00 00 00	 call	 PyErr_SetString

; 4205 :             return NULL;

  000c0	33 c0		 xor	 eax, eax
  000c2	e9 fc 01 00 00	 jmp	 $LN16@zip_longes
$LN13@zip_longes:
$LN15@zip_longes:

; 4206 :         }
; 4207 :     }
; 4208 : 
; 4209 :     /* args must be a tuple */
; 4210 :     assert(PyTuple_Check(args));

  000c7	48 8b 44 24 78	 mov	 rax, QWORD PTR args$[rsp]
  000cc	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d6	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  000db	85 c0		 test	 eax, eax
  000dd	75 1c		 jne	 SHORT $LN18@zip_longes
  000df	41 b8 72 10 00
	00		 mov	 r8d, 4210		; 00001072H
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@KAJNBGPM@?$AAP?$AAy?$AAT?$AAu?$AAp?$AAl?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAa?$AAr?$AAg?$AAs?$AA?$CJ?$AA?$AA@
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000f9	33 c0		 xor	 eax, eax
$LN18@zip_longes:

; 4211 : 
; 4212 :     /* obtain iterators */
; 4213 :     ittuple = PyTuple_New(tuplesize);

  000fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tuplesize$[rsp]
  00100	e8 00 00 00 00	 call	 PyTuple_New
  00105	48 89 44 24 38	 mov	 QWORD PTR ittuple$[rsp], rax

; 4214 :     if (ittuple == NULL)

  0010a	48 83 7c 24 38
	00		 cmp	 QWORD PTR ittuple$[rsp], 0
  00110	75 07		 jne	 SHORT $LN11@zip_longes

; 4215 :         return NULL;

  00112	33 c0		 xor	 eax, eax
  00114	e9 aa 01 00 00	 jmp	 $LN16@zip_longes
$LN11@zip_longes:

; 4216 :     for (i=0; i < tuplesize; ++i) {

  00119	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00122	eb 0d		 jmp	 SHORT $LN10@zip_longes
$LN9@zip_longes:
  00124	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00129	48 ff c0	 inc	 rax
  0012c	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN10@zip_longes:
  00131	48 8b 44 24 20	 mov	 rax, QWORD PTR tuplesize$[rsp]
  00136	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0013b	0f 8d 83 00 00
	00		 jge	 $LN8@zip_longes

; 4217 :         PyObject *item = PyTuple_GET_ITEM(args, i);

  00141	48 8b 44 24 78	 mov	 rax, QWORD PTR args$[rsp]
  00146	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  0014b	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00150	48 89 44 24 58	 mov	 QWORD PTR item$24046[rsp], rax

; 4218 :         PyObject *it = PyObject_GetIter(item);

  00155	48 8b 4c 24 58	 mov	 rcx, QWORD PTR item$24046[rsp]
  0015a	e8 00 00 00 00	 call	 PyObject_GetIter
  0015f	48 89 44 24 50	 mov	 QWORD PTR it$24048[rsp], rax

; 4219 :         if (it == NULL) {

  00164	48 83 7c 24 50
	00		 cmp	 QWORD PTR it$24048[rsp], 0
  0016a	75 3f		 jne	 SHORT $LN7@zip_longes

; 4220 :             if (PyErr_ExceptionMatches(PyExc_TypeError))

  0016c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00173	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00178	85 c0		 test	 eax, eax
  0017a	74 1e		 je	 SHORT $LN6@zip_longes

; 4221 :                 PyErr_Format(PyExc_TypeError,
; 4222 :                     "zip_longest argument #%zd must support iteration",
; 4223 :                     i+1);

  0017c	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00181	48 ff c0	 inc	 rax
  00184	4c 8b c0	 mov	 r8, rax
  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@HEDIPOBC@zip_longest?5argument?5?$CD?$CFzd?5must?5s@
  0018e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00195	e8 00 00 00 00	 call	 PyErr_Format
$LN6@zip_longes:

; 4224 :             Py_DECREF(ittuple);

  0019a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ittuple$[rsp]
  0019f	e8 00 00 00 00	 call	 _Py_DecRef

; 4225 :             return NULL;

  001a4	33 c0		 xor	 eax, eax
  001a6	e9 18 01 00 00	 jmp	 $LN16@zip_longes
$LN7@zip_longes:

; 4226 :         }
; 4227 :         PyTuple_SET_ITEM(ittuple, i, it);

  001ab	48 8b 44 24 38	 mov	 rax, QWORD PTR ittuple$[rsp]
  001b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  001b5	48 8b 54 24 50	 mov	 rdx, QWORD PTR it$24048[rsp]
  001ba	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 4228 :     }

  001bf	e9 60 ff ff ff	 jmp	 $LN9@zip_longes
$LN8@zip_longes:

; 4229 : 
; 4230 :     /* create a result holder */
; 4231 :     result = PyTuple_New(tuplesize);

  001c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tuplesize$[rsp]
  001c9	e8 00 00 00 00	 call	 PyTuple_New
  001ce	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 4232 :     if (result == NULL) {

  001d3	48 83 7c 24 48
	00		 cmp	 QWORD PTR result$[rsp], 0
  001d9	75 11		 jne	 SHORT $LN5@zip_longes

; 4233 :         Py_DECREF(ittuple);

  001db	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ittuple$[rsp]
  001e0	e8 00 00 00 00	 call	 _Py_DecRef

; 4234 :         return NULL;

  001e5	33 c0		 xor	 eax, eax
  001e7	e9 d7 00 00 00	 jmp	 $LN16@zip_longes
$LN5@zip_longes:

; 4235 :     }
; 4236 :     for (i=0 ; i < tuplesize ; i++) {

  001ec	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001f5	eb 0d		 jmp	 SHORT $LN4@zip_longes
$LN3@zip_longes:
  001f7	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  001fc	48 ff c0	 inc	 rax
  001ff	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN4@zip_longes:
  00204	48 8b 44 24 20	 mov	 rax, QWORD PTR tuplesize$[rsp]
  00209	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  0020e	7d 24		 jge	 SHORT $LN2@zip_longes

; 4237 :         Py_INCREF(Py_None);

  00210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00217	e8 00 00 00 00	 call	 _Py_IncRef

; 4238 :         PyTuple_SET_ITEM(result, i, Py_None);

  0021c	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]
  00221	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00226	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  0022d	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 4239 :     }

  00232	eb c3		 jmp	 SHORT $LN3@zip_longes
$LN2@zip_longes:

; 4240 : 
; 4241 :     /* create ziplongestobject structure */
; 4242 :     lz = (ziplongestobject *)type->tp_alloc(type, 0);

  00234	33 d2		 xor	 edx, edx
  00236	48 8b 4c 24 70	 mov	 rcx, QWORD PTR type$[rsp]
  0023b	48 8b 44 24 70	 mov	 rax, QWORD PTR type$[rsp]
  00240	ff 90 88 01 00
	00		 call	 QWORD PTR [rax+392]
  00246	48 89 44 24 40	 mov	 QWORD PTR lz$[rsp], rax

; 4243 :     if (lz == NULL) {

  0024b	48 83 7c 24 40
	00		 cmp	 QWORD PTR lz$[rsp], 0
  00251	75 18		 jne	 SHORT $LN1@zip_longes

; 4244 :         Py_DECREF(ittuple);

  00253	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ittuple$[rsp]
  00258	e8 00 00 00 00	 call	 _Py_DecRef

; 4245 :         Py_DECREF(result);

  0025d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00262	e8 00 00 00 00	 call	 _Py_DecRef

; 4246 :         return NULL;

  00267	33 c0		 xor	 eax, eax
  00269	eb 58		 jmp	 SHORT $LN16@zip_longes
$LN1@zip_longes:

; 4247 :     }
; 4248 :     lz->ittuple = ittuple;

  0026b	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00270	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ittuple$[rsp]
  00275	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 4249 :     lz->tuplesize = tuplesize;

  00279	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0027e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tuplesize$[rsp]
  00283	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 4250 :     lz->numactive = tuplesize;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0028c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tuplesize$[rsp]
  00291	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 4251 :     lz->result = result;

  00295	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0029a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  0029f	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 4252 :     Py_INCREF(fillvalue);

  002a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fillvalue$[rsp]
  002a8	e8 00 00 00 00	 call	 _Py_IncRef

; 4253 :     lz->fillvalue = fillvalue;

  002ad	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  002b2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR fillvalue$[rsp]
  002b7	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 4254 :     return (PyObject *)lz;

  002be	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
$LN16@zip_longes:

; 4255 : }

  002c3	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002c7	c3		 ret	 0
zip_longest_new ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$zip_longest_dealloc DD imagerel zip_longest_dealloc
	DD	imagerel zip_longest_dealloc+146
	DD	imagerel $unwind$zip_longest_dealloc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zip_longest_dealloc DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT zip_longest_dealloc
_TEXT	SEGMENT
lz$ = 48
zip_longest_dealloc PROC				; COMDAT

; 4259 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4260 :     PyObject_GC_UnTrack(lz);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_GC_UnTrack
$LN12@zip_longes@2:

; 4261 :     Py_XDECREF(lz->ittuple);

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00018	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0001d	74 0e		 je	 SHORT $LN9@zip_longes@2
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00024	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00028	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@zip_longes@2:
  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 e0		 jne	 SHORT $LN12@zip_longes@2
$LN8@zip_longes@2:

; 4262 :     Py_XDECREF(lz->result);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00038	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0003d	74 0e		 je	 SHORT $LN5@zip_longes@2
  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00044	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00048	e8 00 00 00 00	 call	 _Py_DecRef
$LN5@zip_longes@2:
  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 e0		 jne	 SHORT $LN8@zip_longes@2
$LN4@zip_longes@2:

; 4263 :     Py_XDECREF(lz->fillvalue);

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00058	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00060	74 11		 je	 SHORT $LN1@zip_longes@2
  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  00067	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0006e	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@zip_longes@2:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 da		 jne	 SHORT $LN4@zip_longes@2

; 4264 :     Py_TYPE(lz)->tp_free(lz);

  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR lz$[rsp]
  0007e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00082	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lz$[rsp]
  00087	ff 90 98 01 00
	00		 call	 QWORD PTR [rax+408]

; 4265 : }

  0008d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00091	c3		 ret	 0
zip_longest_dealloc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@KGJJGDGN@zip_longest_traverse?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$zip_longest_traverse DD imagerel zip_longest_traverse
	DD	imagerel zip_longest_traverse+305
	DD	imagerel $unwind$zip_longest_traverse
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zip_longest_traverse DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BF@KGJJGDGN@zip_longest_traverse?$AA@
CONST	SEGMENT
??_C@_0BF@KGJJGDGN@zip_longest_traverse?$AA@ DB 'zip_longest_traverse', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT zip_longest_traverse
_TEXT	SEGMENT
vret$24107 = 32
vret$24115 = 36
vret$24123 = 40
lz$ = 64
visit$ = 72
arg$ = 80
zip_longest_traverse PROC				; COMDAT

; 4269 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN18@zip_longes@3:

; 4270 :     Py_VISIT(lz->ittuple);

  00013	e8 00 00 00 00	 call	 _Py_PXCTX
  00018	85 c0		 test	 eax, eax
  0001a	74 1c		 je	 SHORT $LN15@zip_longes@3
  0001c	45 33 c9	 xor	 r9d, r9d
  0001f	41 b8 ae 10 00
	00		 mov	 r8d, 4270		; 000010aeH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@KGJJGDGN@zip_longest_traverse?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN15@zip_longes@3:
  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0003d	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00042	74 26		 je	 SHORT $LN14@zip_longes@3
  00044	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0004e	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00052	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00056	89 44 24 20	 mov	 DWORD PTR vret$24107[rsp], eax
  0005a	83 7c 24 20 00	 cmp	 DWORD PTR vret$24107[rsp], 0
  0005f	74 09		 je	 SHORT $LN13@zip_longes@3
  00061	8b 44 24 20	 mov	 eax, DWORD PTR vret$24107[rsp]
  00065	e9 c2 00 00 00	 jmp	 $LN19@zip_longes@3
$LN13@zip_longes@3:
$LN14@zip_longes@3:
  0006a	33 c0		 xor	 eax, eax
  0006c	85 c0		 test	 eax, eax
  0006e	75 a3		 jne	 SHORT $LN18@zip_longes@3
$LN12@zip_longes@3:

; 4271 :     Py_VISIT(lz->result);

  00070	e8 00 00 00 00	 call	 _Py_PXCTX
  00075	85 c0		 test	 eax, eax
  00077	74 1c		 je	 SHORT $LN9@zip_longes@3
  00079	45 33 c9	 xor	 r9d, r9d
  0007c	41 b8 af 10 00
	00		 mov	 r8d, 4271		; 000010afH
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@KGJJGDGN@zip_longest_traverse?$AA@
  00090	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN9@zip_longes@3:
  00095	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  0009a	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0009f	74 23		 je	 SHORT $LN8@zip_longes@3
  000a1	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  000a6	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000ab	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  000af	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  000b3	89 44 24 24	 mov	 DWORD PTR vret$24115[rsp], eax
  000b7	83 7c 24 24 00	 cmp	 DWORD PTR vret$24115[rsp], 0
  000bc	74 06		 je	 SHORT $LN7@zip_longes@3
  000be	8b 44 24 24	 mov	 eax, DWORD PTR vret$24115[rsp]
  000c2	eb 68		 jmp	 SHORT $LN19@zip_longes@3
$LN7@zip_longes@3:
$LN8@zip_longes@3:
  000c4	33 c0		 xor	 eax, eax
  000c6	85 c0		 test	 eax, eax
  000c8	75 a6		 jne	 SHORT $LN12@zip_longes@3
$LN6@zip_longes@3:

; 4272 :     Py_VISIT(lz->fillvalue);

  000ca	e8 00 00 00 00	 call	 _Py_PXCTX
  000cf	85 c0		 test	 eax, eax
  000d1	74 1c		 je	 SHORT $LN3@zip_longes@3
  000d3	45 33 c9	 xor	 r9d, r9d
  000d6	41 b8 b0 10 00
	00		 mov	 r8d, 4272		; 000010b0H
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@KGJJGDGN@zip_longest_traverse?$AA@
  000ea	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@zip_longes@3:
  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  000f4	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000fc	74 26		 je	 SHORT $LN2@zip_longes@3
  000fe	48 8b 54 24 50	 mov	 rdx, QWORD PTR arg$[rsp]
  00103	48 8b 44 24 40	 mov	 rax, QWORD PTR lz$[rsp]
  00108	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0010f	ff 54 24 48	 call	 QWORD PTR visit$[rsp]
  00113	89 44 24 28	 mov	 DWORD PTR vret$24123[rsp], eax
  00117	83 7c 24 28 00	 cmp	 DWORD PTR vret$24123[rsp], 0
  0011c	74 06		 je	 SHORT $LN1@zip_longes@3
  0011e	8b 44 24 28	 mov	 eax, DWORD PTR vret$24123[rsp]
  00122	eb 08		 jmp	 SHORT $LN19@zip_longes@3
$LN1@zip_longes@3:
$LN2@zip_longes@3:
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	75 a0		 jne	 SHORT $LN6@zip_longes@3

; 4273 :     return 0;

  0012a	33 c0		 xor	 eax, eax
$LN19@zip_longes@3:

; 4274 : }

  0012c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00130	c3		 ret	 0
zip_longest_traverse ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$zip_longest_next DD imagerel zip_longest_next
	DD	imagerel zip_longest_next+779
	DD	imagerel $unwind$zip_longest_next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zip_longest_next DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT zip_longest_next
_TEXT	SEGMENT
it$ = 32
tuplesize$ = 40
i$ = 48
result$ = 56
olditem$ = 64
item$ = 72
lz$ = 96
zip_longest_next PROC					; COMDAT

; 4278 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4279 :     Py_ssize_t i;
; 4280 :     Py_ssize_t tuplesize = lz->tuplesize;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 89 44 24 28	 mov	 QWORD PTR tuplesize$[rsp], rax

; 4281 :     PyObject *result = lz->result;

  00017	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0001c	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00020	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 4282 :     PyObject *it;
; 4283 :     PyObject *item;
; 4284 :     PyObject *olditem;
; 4285 : 
; 4286 :     if (tuplesize == 0)

  00025	48 83 7c 24 28
	00		 cmp	 QWORD PTR tuplesize$[rsp], 0
  0002b	75 07		 jne	 SHORT $LN23@zip_longes@4

; 4287 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	e9 d2 02 00 00	 jmp	 $LN24@zip_longes@4
$LN23@zip_longes@4:

; 4288 :     if (lz->numactive == 0)

  00034	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00039	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0003e	75 07		 jne	 SHORT $LN22@zip_longes@4

; 4289 :         return NULL;

  00040	33 c0		 xor	 eax, eax
  00042	e9 bf 02 00 00	 jmp	 $LN24@zip_longes@4
$LN22@zip_longes@4:

; 4290 :     if (Py_REFCNT(result) == 1) {

  00047	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  0004c	48 83 78 50 01	 cmp	 QWORD PTR [rax+80], 1
  00051	0f 85 5e 01 00
	00		 jne	 $LN21@zip_longes@4

; 4291 :         Py_INCREF(result);

  00057	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  0005c	e8 00 00 00 00	 call	 _Py_IncRef

; 4292 :         for (i=0 ; i < tuplesize ; i++) {

  00061	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0006a	eb 0d		 jmp	 SHORT $LN20@zip_longes@4
$LN19@zip_longes@4:
  0006c	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  00071	48 ff c0	 inc	 rax
  00074	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN20@zip_longes@4:
  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR tuplesize$[rsp]
  0007e	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  00083	0f 8d 27 01 00
	00		 jge	 $LN18@zip_longes@4

; 4293 :             it = PyTuple_GET_ITEM(lz->ittuple, i);

  00089	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0008e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00097	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  0009c	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 4294 :             if (it == NULL) {

  000a1	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  000a7	75 27		 jne	 SHORT $LN17@zip_longes@4

; 4295 :                 Py_INCREF(lz->fillvalue);

  000a9	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000ae	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  000b5	e8 00 00 00 00	 call	 _Py_IncRef

; 4296 :                 item = lz->fillvalue;

  000ba	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000bf	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  000c6	48 89 44 24 48	 mov	 QWORD PTR item$[rsp], rax

; 4297 :             } else {

  000cb	e9 a9 00 00 00	 jmp	 $LN16@zip_longes@4
$LN17@zip_longes@4:

; 4298 :                 item = PyIter_Next(it);

  000d0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000d5	e8 00 00 00 00	 call	 PyIter_Next
  000da	48 89 44 24 48	 mov	 QWORD PTR item$[rsp], rax

; 4299 :                 if (item == NULL) {

  000df	48 83 7c 24 48
	00		 cmp	 QWORD PTR item$[rsp], 0
  000e5	0f 85 8e 00 00
	00		 jne	 $LN15@zip_longes@4

; 4300 :                     lz->numactive -= 1;

  000eb	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  000f0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f4	48 ff c8	 dec	 rax
  000f7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  000fc	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 4301 :                     if (lz->numactive == 0 || PyErr_Occurred()) {

  00100	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00105	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0010a	74 0a		 je	 SHORT $LN13@zip_longes@4
  0010c	e8 00 00 00 00	 call	 PyErr_Occurred
  00111	48 85 c0	 test	 rax, rax
  00114	74 20		 je	 SHORT $LN14@zip_longes@4
$LN13@zip_longes@4:

; 4302 :                         lz->numactive = 0;

  00116	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0011b	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 4303 :                         Py_DECREF(result);

  00123	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  00128	e8 00 00 00 00	 call	 _Py_DecRef

; 4304 :                         return NULL;

  0012d	33 c0		 xor	 eax, eax
  0012f	e9 d2 01 00 00	 jmp	 $LN24@zip_longes@4

; 4305 :                     } else {

  00134	eb 43		 jmp	 SHORT $LN12@zip_longes@4
$LN14@zip_longes@4:

; 4306 :                         Py_INCREF(lz->fillvalue);

  00136	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0013b	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00142	e8 00 00 00 00	 call	 _Py_IncRef

; 4307 :                         item = lz->fillvalue;

  00147	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0014c	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00153	48 89 44 24 48	 mov	 QWORD PTR item$[rsp], rax

; 4308 :                         PyTuple_SET_ITEM(lz->ittuple, i, NULL);

  00158	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0015d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00161	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00166	48 c7 44 c8 70
	00 00 00 00	 mov	 QWORD PTR [rax+rcx*8+112], 0

; 4309 :                         Py_DECREF(it);

  0016f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00174	e8 00 00 00 00	 call	 _Py_DecRef
$LN12@zip_longes@4:
$LN15@zip_longes@4:
$LN16@zip_longes@4:

; 4310 :                     }
; 4311 :                 }
; 4312 :             }
; 4313 :             olditem = PyTuple_GET_ITEM(result, i);

  00179	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  0017e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00183	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  00188	48 89 44 24 40	 mov	 QWORD PTR olditem$[rsp], rax

; 4314 :             PyTuple_SET_ITEM(result, i, item);

  0018d	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  00192	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00197	48 8b 54 24 48	 mov	 rdx, QWORD PTR item$[rsp]
  0019c	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 4315 :             Py_DECREF(olditem);

  001a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR olditem$[rsp]
  001a6	e8 00 00 00 00	 call	 _Py_DecRef

; 4316 :         }

  001ab	e9 bc fe ff ff	 jmp	 $LN19@zip_longes@4
$LN18@zip_longes@4:

; 4317 :     } else {

  001b0	e9 4c 01 00 00	 jmp	 $LN11@zip_longes@4
$LN21@zip_longes@4:

; 4318 :         result = PyTuple_New(tuplesize);

  001b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tuplesize$[rsp]
  001ba	e8 00 00 00 00	 call	 PyTuple_New
  001bf	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 4319 :         if (result == NULL)

  001c4	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  001ca	75 07		 jne	 SHORT $LN10@zip_longes@4

; 4320 :             return NULL;

  001cc	33 c0		 xor	 eax, eax
  001ce	e9 33 01 00 00	 jmp	 $LN24@zip_longes@4
$LN10@zip_longes@4:

; 4321 :         for (i=0 ; i < tuplesize ; i++) {

  001d3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  001dc	eb 0d		 jmp	 SHORT $LN9@zip_longes@4
$LN8@zip_longes@4:
  001de	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  001e3	48 ff c0	 inc	 rax
  001e6	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax
$LN9@zip_longes@4:
  001eb	48 8b 44 24 28	 mov	 rax, QWORD PTR tuplesize$[rsp]
  001f0	48 39 44 24 30	 cmp	 QWORD PTR i$[rsp], rax
  001f5	0f 8d 06 01 00
	00		 jge	 $LN7@zip_longes@4

; 4322 :             it = PyTuple_GET_ITEM(lz->ittuple, i);

  001fb	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00200	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00204	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  00209	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  0020e	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 4323 :             if (it == NULL) {

  00213	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00219	75 27		 jne	 SHORT $LN6@zip_longes@4

; 4324 :                 Py_INCREF(lz->fillvalue);

  0021b	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00220	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00227	e8 00 00 00 00	 call	 _Py_IncRef

; 4325 :                 item = lz->fillvalue;

  0022c	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00231	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00238	48 89 44 24 48	 mov	 QWORD PTR item$[rsp], rax

; 4326 :             } else {

  0023d	e9 a6 00 00 00	 jmp	 $LN5@zip_longes@4
$LN6@zip_longes@4:

; 4327 :                 item = PyIter_Next(it);

  00242	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00247	e8 00 00 00 00	 call	 PyIter_Next
  0024c	48 89 44 24 48	 mov	 QWORD PTR item$[rsp], rax

; 4328 :                 if (item == NULL) {

  00251	48 83 7c 24 48
	00		 cmp	 QWORD PTR item$[rsp], 0
  00257	0f 85 8b 00 00
	00		 jne	 $LN4@zip_longes@4

; 4329 :                     lz->numactive -= 1;

  0025d	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00262	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00266	48 ff c8	 dec	 rax
  00269	48 8b 4c 24 60	 mov	 rcx, QWORD PTR lz$[rsp]
  0026e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 4330 :                     if (lz->numactive == 0 || PyErr_Occurred()) {

  00272	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  00277	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0027c	74 0a		 je	 SHORT $LN2@zip_longes@4
  0027e	e8 00 00 00 00	 call	 PyErr_Occurred
  00283	48 85 c0	 test	 rax, rax
  00286	74 1d		 je	 SHORT $LN3@zip_longes@4
$LN2@zip_longes@4:

; 4331 :                         lz->numactive = 0;

  00288	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  0028d	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0

; 4332 :                         Py_DECREF(result);

  00295	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  0029a	e8 00 00 00 00	 call	 _Py_DecRef

; 4333 :                         return NULL;

  0029f	33 c0		 xor	 eax, eax
  002a1	eb 63		 jmp	 SHORT $LN24@zip_longes@4

; 4334 :                     } else {

  002a3	eb 43		 jmp	 SHORT $LN1@zip_longes@4
$LN3@zip_longes@4:

; 4335 :                         Py_INCREF(lz->fillvalue);

  002a5	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  002aa	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  002b1	e8 00 00 00 00	 call	 _Py_IncRef

; 4336 :                         item = lz->fillvalue;

  002b6	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  002bb	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  002c2	48 89 44 24 48	 mov	 QWORD PTR item$[rsp], rax

; 4337 :                         PyTuple_SET_ITEM(lz->ittuple, i, NULL);

  002c7	48 8b 44 24 60	 mov	 rax, QWORD PTR lz$[rsp]
  002cc	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  002d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  002d5	48 c7 44 c8 70
	00 00 00 00	 mov	 QWORD PTR [rax+rcx*8+112], 0

; 4338 :                         Py_DECREF(it);

  002de	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  002e3	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@zip_longes@4:
$LN4@zip_longes@4:
$LN5@zip_longes@4:

; 4339 :                     }
; 4340 :                 }
; 4341 :             }
; 4342 :             PyTuple_SET_ITEM(result, i, item);

  002e8	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  002ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$[rsp]
  002f2	48 8b 54 24 48	 mov	 rdx, QWORD PTR item$[rsp]
  002f7	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 4343 :         }

  002fc	e9 dd fe ff ff	 jmp	 $LN8@zip_longes@4
$LN7@zip_longes@4:
$LN11@zip_longes@4:

; 4344 :     }
; 4345 :     return result;

  00301	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN24@zip_longes@4:

; 4346 : }

  00306	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0030a	c3		 ret	 0
zip_longest_next ENDP
_TEXT	ENDS
PUBLIC	??_C@_03BACJJLII@ONO?$AA@			; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$zip_longest_reduce DD imagerel zip_longest_reduce
	DD	imagerel zip_longest_reduce+233
	DD	imagerel $unwind$zip_longest_reduce
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zip_longest_reduce DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_03BACJJLII@ONO?$AA@
CONST	SEGMENT
??_C@_03BACJJLII@ONO?$AA@ DB 'ONO', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT zip_longest_reduce
_TEXT	SEGMENT
args$ = 32
i$ = 40
elem$24203 = 48
lz$ = 80
zip_longest_reduce PROC					; COMDAT

; 4350 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4351 : 
; 4352 :     /* Create a new tuple with empty sequences where appropriate to pickle.
; 4353 :      * Then use setstate to set the fillvalue
; 4354 :      */
; 4355 :     int i;
; 4356 :     PyObject *args = PyTuple_New(PyTuple_GET_SIZE(lz->ittuple));

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0000e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00012	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00016	e8 00 00 00 00	 call	 PyTuple_New
  0001b	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 4357 :     if (args == NULL)

  00020	48 83 7c 24 20
	00		 cmp	 QWORD PTR args$[rsp], 0
  00026	75 07		 jne	 SHORT $LN7@zip_longes@5

; 4358 :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	e9 b5 00 00 00	 jmp	 $LN8@zip_longes@5
$LN7@zip_longes@5:

; 4359 :     for (i=0; i<PyTuple_GET_SIZE(lz->ittuple); i++) {

  0002f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00037	eb 0a		 jmp	 SHORT $LN6@zip_longes@5
$LN5@zip_longes@5:
  00039	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0003d	ff c0		 inc	 eax
  0003f	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN6@zip_longes@5:
  00043	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00048	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lz$[rsp]
  0004d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00051	48 3b 41 60	 cmp	 rax, QWORD PTR [rcx+96]
  00055	7d 67		 jge	 SHORT $LN4@zip_longes@5

; 4360 :         PyObject *elem = PyTuple_GET_ITEM(lz->ittuple, i);

  00057	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0005c	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00060	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR i$[rsp]
  00065	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  0006a	48 89 44 24 30	 mov	 QWORD PTR elem$24203[rsp], rax

; 4361 :         if (elem == NULL) {

  0006f	48 83 7c 24 30
	00		 cmp	 QWORD PTR elem$24203[rsp], 0
  00075	75 24		 jne	 SHORT $LN3@zip_longes@5

; 4362 :             elem = PyTuple_New(0);

  00077	33 c9		 xor	 ecx, ecx
  00079	e8 00 00 00 00	 call	 PyTuple_New
  0007e	48 89 44 24 30	 mov	 QWORD PTR elem$24203[rsp], rax

; 4363 :             if (elem == NULL) {

  00083	48 83 7c 24 30
	00		 cmp	 QWORD PTR elem$24203[rsp], 0
  00089	75 0e		 jne	 SHORT $LN2@zip_longes@5

; 4364 :                 Py_DECREF(args);

  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  00090	e8 00 00 00 00	 call	 _Py_DecRef

; 4365 :                 return NULL;

  00095	33 c0		 xor	 eax, eax
  00097	eb 4b		 jmp	 SHORT $LN8@zip_longes@5
$LN2@zip_longes@5:

; 4366 :             }
; 4367 :         } else

  00099	eb 0a		 jmp	 SHORT $LN1@zip_longes@5
$LN3@zip_longes@5:

; 4368 :             Py_INCREF(elem);

  0009b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR elem$24203[rsp]
  000a0	e8 00 00 00 00	 call	 _Py_IncRef
$LN1@zip_longes@5:

; 4369 :         PyTuple_SET_ITEM(args, i, elem);

  000a5	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  000aa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  000af	48 8b 54 24 30	 mov	 rdx, QWORD PTR elem$24203[rsp]
  000b4	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 4370 :     }

  000b9	e9 7b ff ff ff	 jmp	 $LN5@zip_longes@5
$LN4@zip_longes@5:

; 4371 :     return Py_BuildValue("ONO", Py_TYPE(lz), args, lz->fillvalue);

  000be	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  000c3	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  000ca	4c 8b 44 24 20	 mov	 r8, QWORD PTR args$[rsp]
  000cf	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  000d4	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03BACJJLII@ONO?$AA@
  000df	e8 00 00 00 00	 call	 Py_BuildValue
$LN8@zip_longes@5:

; 4372 : }

  000e4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e8	c3		 ret	 0
zip_longest_reduce ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@MLMOEEIK@zip_longest_setstate?$AA@	; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$zip_longest_setstate DD imagerel zip_longest_setstate
	DD	imagerel zip_longest_setstate+185
	DD	imagerel $unwind$zip_longest_setstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$zip_longest_setstate DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0BF@MLMOEEIK@zip_longest_setstate?$AA@
CONST	SEGMENT
??_C@_0BF@MLMOEEIK@zip_longest_setstate?$AA@ DB 'zip_longest_setstate', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT zip_longest_setstate
_TEXT	SEGMENT
_py_tmp$24227 = 48
lz$ = 80
state$ = 88
zip_longest_setstate PROC				; COMDAT

; 4376 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@zip_longes@6:

; 4377 :     Py_CLEAR(lz->fillvalue);

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00013	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0001b	74 5c		 je	 SHORT $LN1@zip_longes@6
  0001d	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  0002a	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  00031	41 b8 19 11 00
	00		 mov	 r8d, 4377		; 00001119H
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@PMILGFFG@?4?4?2Modules?2itertoolsmodule?4c?$AA@
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@MLMOEEIK@zip_longest_setstate?$AA@
  00045	e8 00 00 00 00	 call	 _PyParallel_Guard
  0004a	85 c0		 test	 eax, eax
  0004c	75 2b		 jne	 SHORT $LN1@zip_longes@6
  0004e	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00053	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0005a	48 89 44 24 30	 mov	 QWORD PTR _py_tmp$24227[rsp], rax
  0005f	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00064	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0
  0006f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _py_tmp$24227[rsp]
  00074	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@zip_longes@6:
  00079	33 c0		 xor	 eax, eax
  0007b	85 c0		 test	 eax, eax
  0007d	75 8f		 jne	 SHORT $LN4@zip_longes@6

; 4378 :     lz->fillvalue = state;

  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00084	48 8b 4c 24 58	 mov	 rcx, QWORD PTR state$[rsp]
  00089	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 4379 :     Py_INCREF(lz->fillvalue);

  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR lz$[rsp]
  00095	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0009c	e8 00 00 00 00	 call	 _Py_IncRef

; 4380 :     Py_RETURN_NONE;

  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  000a8	e8 00 00 00 00	 call	 _Py_IncRef
  000ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 4381 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
zip_longest_setstate ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BK@EILABNJE@?$AAn?$AAa?$AAm?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	PyInit_itertools
EXTRN	PyModule_AddObject:PROC
EXTRN	__imp_strchr:PROC
EXTRN	PyType_Ready:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
EXTRN	PyType_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_itertools DD imagerel $LN9
	DD	imagerel $LN9+545
	DD	imagerel $unwind$PyInit_itertools
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_itertools DD 020701H
	DD	01f0107H
xdata	ENDS
;	COMDAT ??_C@_1BK@EILABNJE@?$AAn?$AAa?$AAm?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@EILABNJE@?$AAn?$AAa?$AAm?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'n'
	DB	00H, 'a', 00H, 'm', 00H, 'e', 00H, ' ', 00H, '!', 00H, '=', 00H
	DB	' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit_itertools
_TEXT	SEGMENT
i$ = 32
name$ = 40
typelist$ = 48
m$ = 224
PyInit_itertools PROC					; COMDAT

; 4499 : {

$LN9:
  00000	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 4500 :     int i;
; 4501 :     PyObject *m;
; 4502 :     char *name;
; 4503 :     PyTypeObject *typelist[] = {
; 4504 :         &accumulate_type,

  00007	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:accumulate_type
  0000e	48 89 44 24 30	 mov	 QWORD PTR typelist$[rsp], rax

; 4505 :         &combinations_type,

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:combinations_type
  0001a	48 89 44 24 38	 mov	 QWORD PTR typelist$[rsp+8], rax

; 4506 :         &cwr_type,

  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cwr_type
  00026	48 89 44 24 40	 mov	 QWORD PTR typelist$[rsp+16], rax

; 4507 :         &cycle_type,

  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cycle_type
  00032	48 89 44 24 48	 mov	 QWORD PTR typelist$[rsp+24], rax

; 4508 :         &dropwhile_type,

  00037	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dropwhile_type
  0003e	48 89 44 24 50	 mov	 QWORD PTR typelist$[rsp+32], rax

; 4509 :         &takewhile_type,

  00043	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:takewhile_type
  0004a	48 89 44 24 58	 mov	 QWORD PTR typelist$[rsp+40], rax

; 4510 :         &islice_type,

  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:islice_type
  00056	48 89 44 24 60	 mov	 QWORD PTR typelist$[rsp+48], rax

; 4511 :         &starmap_type,

  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:starmap_type
  00062	48 89 44 24 68	 mov	 QWORD PTR typelist$[rsp+56], rax

; 4512 :         &chain_type,

  00067	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:chain_type
  0006e	48 89 44 24 70	 mov	 QWORD PTR typelist$[rsp+64], rax

; 4513 :         &compress_type,

  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:compress_type
  0007a	48 89 44 24 78	 mov	 QWORD PTR typelist$[rsp+72], rax

; 4514 :         &filterfalse_type,

  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:filterfalse_type
  00086	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR typelist$[rsp+80], rax

; 4515 :         &count_type,

  0008e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:count_type
  00095	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR typelist$[rsp+88], rax

; 4516 :         &ziplongest_type,

  0009d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:ziplongest_type
  000a4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR typelist$[rsp+96], rax

; 4517 :         &permutations_type,

  000ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:permutations_type
  000b3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR typelist$[rsp+104], rax

; 4518 :         &product_type,

  000bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:product_type
  000c2	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR typelist$[rsp+112], rax

; 4519 :         &repeat_type,

  000ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:repeat_type
  000d1	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR typelist$[rsp+120], rax

; 4520 :         &groupby_type,

  000d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:groupby_type
  000e0	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR typelist$[rsp+128], rax

; 4521 :         &_grouper_type,

  000e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_grouper_type
  000ef	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR typelist$[rsp+136], rax

; 4522 :         &tee_type,

  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:tee_type
  000fe	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR typelist$[rsp+144], rax

; 4523 :         &teedataobject_type,

  00106	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:teedataobject_type
  0010d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR typelist$[rsp+152], rax

; 4524 :         NULL
; 4525 :     };

  00115	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR typelist$[rsp+160], 0

; 4526 : 
; 4527 :     Py_TYPE(&teedataobject_type) = &PyType_Type;

  00121	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyType_Type
  00128	48 89 05 58 00
	00 00		 mov	 QWORD PTR teedataobject_type+88, rax

; 4528 :     m = PyModule_Create(&itertoolsmodule);

  0012f	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:itertoolsmodule
  0013b	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00140	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR m$[rsp], rax

; 4529 :     if (m == NULL)

  00148	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR m$[rsp], 0
  00151	75 07		 jne	 SHORT $LN5@PyInit_ite

; 4530 :         return NULL;

  00153	33 c0		 xor	 eax, eax
  00155	e9 bf 00 00 00	 jmp	 $LN6@PyInit_ite
$LN5@PyInit_ite:

; 4531 : 
; 4532 :     for (i=0 ; typelist[i] != NULL ; i++) {

  0015a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00162	eb 0a		 jmp	 SHORT $LN4@PyInit_ite
$LN3@PyInit_ite:
  00164	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00168	ff c0		 inc	 eax
  0016a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@PyInit_ite:
  0016e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00173	48 83 7c c4 30
	00		 cmp	 QWORD PTR typelist$[rsp+rax*8], 0
  00179	0f 84 92 00 00
	00		 je	 $LN2@PyInit_ite

; 4533 :         if (PyType_Ready(typelist[i]) < 0)

  0017f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00184	48 8b 4c c4 30	 mov	 rcx, QWORD PTR typelist$[rsp+rax*8]
  00189	e8 00 00 00 00	 call	 PyType_Ready
  0018e	85 c0		 test	 eax, eax
  00190	7d 07		 jge	 SHORT $LN1@PyInit_ite

; 4534 :             return NULL;

  00192	33 c0		 xor	 eax, eax
  00194	e9 80 00 00 00	 jmp	 $LN6@PyInit_ite
$LN1@PyInit_ite:

; 4535 :         name = strchr(typelist[i]->tp_name, '.');

  00199	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0019e	48 8b 44 c4 30	 mov	 rax, QWORD PTR typelist$[rsp+rax*8]
  001a3	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  001a8	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  001b2	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 4536 :         assert (name != NULL);

  001b7	48 83 7c 24 28
	00		 cmp	 QWORD PTR name$[rsp], 0
  001bd	75 1c		 jne	 SHORT $LN8@PyInit_ite
  001bf	41 b8 b8 11 00
	00		 mov	 r8d, 4536		; 000011b8H
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1DK@PAEBPALI@?$AA?4?$AA?4?$AA?2?$AAM?$AAo?$AAd?$AAu?$AAl?$AAe?$AAs?$AA?2?$AAi?$AAt?$AAe?$AAr?$AAt?$AAo?$AAo?$AAl?$AAs?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?4?$AAc?$AA?$AA@
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@EILABNJE@?$AAn?$AAa?$AAm?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001d9	33 c0		 xor	 eax, eax
$LN8@PyInit_ite:

; 4537 :         Py_INCREF(typelist[i]);

  001db	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001e0	48 8b 4c c4 30	 mov	 rcx, QWORD PTR typelist$[rsp+rax*8]
  001e5	e8 00 00 00 00	 call	 _Py_IncRef

; 4538 :         PyModule_AddObject(m, name+1, (PyObject *)typelist[i]);

  001ea	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR name$[rsp]
  001f4	48 ff c1	 inc	 rcx
  001f7	4c 8b 44 c4 30	 mov	 r8, QWORD PTR typelist$[rsp+rax*8]
  001fc	48 8b d1	 mov	 rdx, rcx
  001ff	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR m$[rsp]
  00207	e8 00 00 00 00	 call	 PyModule_AddObject

; 4539 :     }

  0020c	e9 53 ff ff ff	 jmp	 $LN3@PyInit_ite
$LN2@PyInit_ite:

; 4540 : 
; 4541 :     return m;

  00211	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
$LN6@PyInit_ite:

; 4542 : }

  00219	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00220	c3		 ret	 0
PyInit_itertools ENDP
_TEXT	ENDS
END
