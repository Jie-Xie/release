; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_08IBFKALI@__dict__?$AA@			; `string'
PUBLIC	??_C@_07HHBPHOLM@__all__?$AA@			; `string'
PUBLIC	??_C@_09OAJHKKGH@__enter__?$AA@			; `string'
PUBLIC	??_C@_08CMFIGCJD@__exit__?$AA@			; `string'
PUBLIC	??_C@_0L@KEEJPJHH@__import__?$AA@		; `string'
PUBLIC	??_C@_0BA@JDLNCAMO@__build_class__?$AA@		; `string'
PUBLIC	??_C@_04MIIPNNEF@send?$AA@			; `string'
PUBLIC	??_C@_0L@JFJKGIKJ@__ltrace__?$AA@		; `string'
PUBLIC	??_C@_0M@JAEGONOO@_after_fork?$AA@		; `string'
PUBLIC	_Py_CheckRecursionLimit
_BSS	SEGMENT
pending_lock DQ	01H DUP (?)
main_thread DD	01H DUP (?)
eval_breaker DD	01H DUP (?)
gil_drop_request DD 01H DUP (?)
pendingcalls_to_do DD 01H DUP (?)
pending_async_exc DD 01H DUP (?)
gil_switch_number DD 01H DUP (?)
gil_last_holder DQ 01H DUP (?)
pendingfirst DD	01H DUP (?)
pendinglast DD	01H DUP (?)
?busy@?1??Py_MakePendingCalls@@9@9 DD 01H DUP (?)	; `Py_MakePendingCalls'::`2'::busy
_Py_TracingPossible DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_08IBFKALI@__dict__?$AA@
CONST	SEGMENT
??_C@_08IBFKALI@__dict__?$AA@ DB '__dict__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07HHBPHOLM@__all__?$AA@
CONST	SEGMENT
??_C@_07HHBPHOLM@__all__?$AA@ DB '__all__', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OAJHKKGH@__enter__?$AA@
CONST	SEGMENT
??_C@_09OAJHKKGH@__enter__?$AA@ DB '__enter__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CMFIGCJD@__exit__?$AA@
CONST	SEGMENT
??_C@_08CMFIGCJD@__exit__?$AA@ DB '__exit__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KEEJPJHH@__import__?$AA@
CONST	SEGMENT
??_C@_0L@KEEJPJHH@__import__?$AA@ DB '__import__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JDLNCAMO@__build_class__?$AA@
CONST	SEGMENT
??_C@_0BA@JDLNCAMO@__build_class__?$AA@ DB '__build_class__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04MIIPNNEF@send?$AA@
CONST	SEGMENT
??_C@_04MIIPNNEF@send?$AA@ DB 'send', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JFJKGIKJ@__ltrace__?$AA@
CONST	SEGMENT
??_C@_0L@JFJKGIKJ@__ltrace__?$AA@ DB '__ltrace__', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___dict__@?1??import_all_from@@9@9 DQ 0000000000000000H ; `import_all_from'::`2'::PyId___dict__
	DQ	FLAT:??_C@_08IBFKALI@__dict__?$AA@
	DQ	0000000000000000H
?PyId___all__@?1??import_all_from@@9@9 DQ 0000000000000000H ; `import_all_from'::`2'::PyId___all__
	DQ	FLAT:??_C@_07HHBPHOLM@__all__?$AA@
	DQ	0000000000000000H
?PyId___enter__@?KM@??PyEval_EvalFrameEx@@9@9 DQ 0000000000000000H ; `PyEval_EvalFrameEx'::`172'::PyId___enter__
	DQ	FLAT:??_C@_09OAJHKKGH@__enter__?$AA@
	DQ	0000000000000000H
?PyId___exit__@?KM@??PyEval_EvalFrameEx@@9@9 DQ 0000000000000000H ; `PyEval_EvalFrameEx'::`172'::PyId___exit__
	DQ	FLAT:??_C@_08CMFIGCJD@__exit__?$AA@
	DQ	0000000000000000H
?PyId___import__@?IL@??PyEval_EvalFrameEx@@9@9 DQ 0000000000000000H ; `PyEval_EvalFrameEx'[::L]::PyId___import__
	DQ	FLAT:??_C@_0L@KEEJPJHH@__import__?$AA@
	DQ	0000000000000000H
?PyId___build_class__@?EO@??PyEval_EvalFrameEx@@9@9 DQ 0000000000000000H ; `PyEval_EvalFrameEx'::`78'::PyId___build_class__
	DQ	FLAT:??_C@_0BA@JDLNCAMO@__build_class__?$AA@
	DQ	0000000000000000H
?PyId_send@?DF@??PyEval_EvalFrameEx@@9@9 DQ 0000000000000000H ; `PyEval_EvalFrameEx'::`53'::PyId_send
	DQ	FLAT:??_C@_04MIIPNNEF@send?$AA@
	DQ	0000000000000000H
?PyId___ltrace__@?1??PyEval_EvalFrameEx@@9@9 DQ 0000000000000000H ; `PyEval_EvalFrameEx'::`2'::PyId___ltrace__
	DQ	FLAT:??_C@_0L@JFJKGIKJ@__ltrace__?$AA@
	DQ	0000000000000000H
?PyId__after_fork@?1??PyEval_ReInitThreads@@9@9 DQ 0000000000000000H ; `PyEval_ReInitThreads'::`2'::PyId__after_fork
	DQ	FLAT:??_C@_0M@JAEGONOO@_after_fork?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_0M@JAEGONOO@_after_fork?$AA@
CONST	SEGMENT
??_C@_0M@JAEGONOO@_after_fork?$AA@ DB '_after_fork', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
gil_interval DD	01388H
gil_locked DD	0ffffffffH
recursion_limit DD 03e8H
_Py_CheckRecursionLimit DD 03e8H
_DATA	ENDS
PUBLIC	_Py_IncRef
PUBLIC	PyEval_GetCallStats
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval.c
pdata	SEGMENT
$pdata$PyEval_GetCallStats DD imagerel $LN3
	DD	imagerel $LN3+28
	DD	imagerel $unwind$PyEval_GetCallStats
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_GetCallStats DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyEval_GetCallStats
_TEXT	SEGMENT
self$ = 48
PyEval_GetCallStats PROC				; COMDAT

; 217  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 218  :     Py_INCREF(Py_None);

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0000b	e8 00 00 00 00	 call	 _Py_IncRef

; 219  :     return Py_None;

  00010	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct

; 220  : }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
PyEval_GetCallStats ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+90
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 42		 jne	 SHORT $LN2@Py_IncRef
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00020	4c 8b cb	 mov	 r9, rbx
  00023	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00029	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00031	e8 00 00 00 00	 call	 _PyParallel_Guard
  00036	85 c0		 test	 eax, eax
  00038	75 06		 jne	 SHORT $LN1@Py_IncRef
  0003a	f6 43 20 20	 test	 BYTE PTR [rbx+32], 32	; 00000020H
  0003e	74 14		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  00040	e8 00 00 00 00	 call	 _Py_PXCTX
  00045	85 c0		 test	 eax, eax
  00047	75 07		 jne	 SHORT $LN6@Py_IncRef
  00049	48 ff 05 00 00
	00 00		 inc	 QWORD PTR _Py_RefTotal
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  00050	48 ff 43 50	 inc	 QWORD PTR [rbx+80]
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	_PyEval_SetSwitchInterval
; Function compile flags: /Ogtp
; File c:\src\pyparallel\python\ceval_gil.h
;	COMDAT _PyEval_SetSwitchInterval
_TEXT	SEGMENT
microseconds$ = 8
_PyEval_SetSwitchInterval PROC				; COMDAT

; 276  :     gil_interval = microseconds;

  00000	89 0d 00 00 00
	00		 mov	 DWORD PTR gil_interval, ecx

; 277  : }

  00006	c3		 ret	 0
_PyEval_SetSwitchInterval ENDP
_TEXT	ENDS
PUBLIC	_PyEval_GetSwitchInterval
; Function compile flags: /Ogtp
;	COMDAT _PyEval_GetSwitchInterval
_TEXT	SEGMENT
_PyEval_GetSwitchInterval PROC				; COMDAT

; 281  :     return gil_interval;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR gil_interval

; 282  : }

  00006	c3		 ret	 0
_PyEval_GetSwitchInterval ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@NJBENHLP@PyEval_ThreadsInitialized?$AA@ ; `string'
PUBLIC	??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@	; `string'
PUBLIC	PyEval_ThreadsInitialized
EXTRN	_PyParallel_ContextGuardFailure:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval.c
pdata	SEGMENT
$pdata$PyEval_ThreadsInitialized DD imagerel $LN4
	DD	imagerel $LN4+50
	DD	imagerel $unwind$PyEval_ThreadsInitialized
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_ThreadsInitialized DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BK@NJBENHLP@PyEval_ThreadsInitialized?$AA@
CONST	SEGMENT
??_C@_0BK@NJBENHLP@PyEval_ThreadsInitialized?$AA@ DB 'PyEval_ThreadsIniti'
	DB	'alized', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
CONST	SEGMENT
??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@ DB '..\Python\ceval.c', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_ThreadsInitialized
_TEXT	SEGMENT
PyEval_ThreadsInitialized PROC				; COMDAT

; 303  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 304  :     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN1@PyEval_Thr
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@NJBENHLP@PyEval_ThreadsInitialized?$AA@
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	41 b8 30 01 00
	00		 mov	 r8d, 304		; 00000130H
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN1@PyEval_Thr:

; 305  :     return gil_created();
; 306  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	e9 00 00 00 00	 jmp	 gil_created
PyEval_ThreadsInitialized ENDP
; Function compile flags: /Ogtp
; File c:\src\pyparallel\python\ceval_gil.h
_TEXT	ENDS
;	COMDAT gil_created
_TEXT	SEGMENT
gil_created PROC					; COMDAT

; 132  :     return _Py_atomic_load_explicit(&gil_locked, _Py_memory_order_acquire) >= 0;

  00000	33 c0		 xor	 eax, eax
  00002	39 05 00 00 00
	00		 cmp	 DWORD PTR gil_locked, eax
  00008	0f 9d c0	 setge	 al

; 133  : }

  0000b	c3		 ret	 0
gil_created ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@IFFAKDAD@PyEval_InitThreads?$AA@	; `string'
PUBLIC	PyEval_InitThreads
EXTRN	PyThread_allocate_lock:PROC
EXTRN	PyThread_get_thread_ident:PROC
EXTRN	PyThreadState_Get:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval.c
pdata	SEGMENT
$pdata$PyEval_InitThreads DD imagerel $LN6
	DD	imagerel $LN6+106
	DD	imagerel $unwind$PyEval_InitThreads
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_InitThreads DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BD@IFFAKDAD@PyEval_InitThreads?$AA@
CONST	SEGMENT
??_C@_0BD@IFFAKDAD@PyEval_InitThreads?$AA@ DB 'PyEval_InitThreads', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_InitThreads
_TEXT	SEGMENT
PyEval_InitThreads PROC					; COMDAT

; 310  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 311  :     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN3@PyEval_Ini
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@IFFAKDAD@PyEval_InitThreads?$AA@
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	41 b8 37 01 00
	00		 mov	 r8d, 311		; 00000137H
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@PyEval_Ini:

; 312  :     if (gil_created())

  00029	e8 00 00 00 00	 call	 gil_created
  0002e	85 c0		 test	 eax, eax
  00030	75 33		 jne	 SHORT $LN1@PyEval_Ini

; 313  :         return;
; 314  :     create_gil();

  00032	e8 00 00 00 00	 call	 create_gil

; 315  :     take_gil(PyThreadState_GET());

  00037	e8 00 00 00 00	 call	 PyThreadState_Get
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	e8 00 00 00 00	 call	 take_gil

; 316  :     main_thread = PyThread_get_thread_ident();

  00044	e8 00 00 00 00	 call	 PyThread_get_thread_ident

; 317  :     if (!pending_lock)

  00049	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pending_lock, 0
  00051	89 05 00 00 00
	00		 mov	 DWORD PTR main_thread, eax
  00057	75 0c		 jne	 SHORT $LN1@PyEval_Ini

; 318  :         pending_lock = PyThread_allocate_lock();

  00059	e8 00 00 00 00	 call	 PyThread_allocate_lock
  0005e	48 89 05 00 00
	00 00		 mov	 QWORD PTR pending_lock, rax
$LN1@PyEval_Ini:

; 319  : }

  00065	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00069	c3		 ret	 0
PyEval_InitThreads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@JELFKHKC@PyCOND_INIT?$CIswitch_cond?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BN@GEIJFMD@PyCOND_INIT?$CIgil_cond?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0CC@OAPCBLHB@PyMUTEX_INIT?$CIswitch_mutex?$CJ?5faile@ ; `string'
PUBLIC	??_C@_0BP@JKHMFMNF@PyMUTEX_INIT?$CIgil_mutex?$CJ?5failed?$AA@ ; `string'
EXTRN	_PyParallel_CreatedGIL:PROC
EXTRN	Py_FatalError:PROC
_BSS	SEGMENT
switch_cond DB	010H DUP (?)
gil_cond DB	010H DUP (?)
switch_mutex DB	028H DUP (?)
gil_mutex DB	028H DUP (?)
_BSS	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval_gil.h
pdata	SEGMENT
$pdata$create_gil DD imagerel create_gil
	DD	imagerel create_gil+140
	DD	imagerel $unwind$create_gil
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$create_gil DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CA@JELFKHKC@PyCOND_INIT?$CIswitch_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0CA@JELFKHKC@PyCOND_INIT?$CIswitch_cond?$CJ?5failed?$AA@ DB 'PyCOND'
	DB	'_INIT(switch_cond) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GEIJFMD@PyCOND_INIT?$CIgil_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0BN@GEIJFMD@PyCOND_INIT?$CIgil_cond?$CJ?5failed?$AA@ DB 'PyCOND_INI'
	DB	'T(gil_cond) failed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@OAPCBLHB@PyMUTEX_INIT?$CIswitch_mutex?$CJ?5faile@
CONST	SEGMENT
??_C@_0CC@OAPCBLHB@PyMUTEX_INIT?$CIswitch_mutex?$CJ?5faile@ DB 'PyMUTEX_I'
	DB	'NIT(switch_mutex) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JKHMFMNF@PyMUTEX_INIT?$CIgil_mutex?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0BP@JKHMFMNF@PyMUTEX_INIT?$CIgil_mutex?$CJ?5failed?$AA@ DB 'PyMUTEX'
	DB	'_INIT(gil_mutex) failed', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT create_gil
_TEXT	SEGMENT
create_gil PROC						; COMDAT

; 136  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 137  :     MUTEX_INIT(gil_mutex);

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  0000b	e8 00 00 00 00	 call	 PyMUTEX_INIT
  00010	85 c0		 test	 eax, eax
  00012	74 0c		 je	 SHORT $LN4@create_gil
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@JKHMFMNF@PyMUTEX_INIT?$CIgil_mutex?$CJ?5failed?$AA@
  0001b	e8 00 00 00 00	 call	 Py_FatalError
$LN4@create_gil:

; 138  : #ifdef FORCE_SWITCHING
; 139  :     MUTEX_INIT(switch_mutex);

  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  00027	e8 00 00 00 00	 call	 PyMUTEX_INIT
  0002c	85 c0		 test	 eax, eax
  0002e	74 0c		 je	 SHORT $LN3@create_gil
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@OAPCBLHB@PyMUTEX_INIT?$CIswitch_mutex?$CJ?5faile@
  00037	e8 00 00 00 00	 call	 Py_FatalError
$LN3@create_gil:

; 140  : #endif
; 141  :     COND_INIT(gil_cond);

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_cond
  00043	e8 00 00 00 00	 call	 PyCOND_INIT
  00048	85 c0		 test	 eax, eax
  0004a	74 0c		 je	 SHORT $LN2@create_gil
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@GEIJFMD@PyCOND_INIT?$CIgil_cond?$CJ?5failed?$AA@
  00053	e8 00 00 00 00	 call	 Py_FatalError
$LN2@create_gil:

; 142  : #ifdef FORCE_SWITCHING
; 143  :     COND_INIT(switch_cond);

  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_cond
  0005f	e8 00 00 00 00	 call	 PyCOND_INIT
  00064	85 c0		 test	 eax, eax
  00066	74 0c		 je	 SHORT $LN1@create_gil
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@JELFKHKC@PyCOND_INIT?$CIswitch_cond?$CJ?5failed?$AA@
  0006f	e8 00 00 00 00	 call	 Py_FatalError
$LN1@create_gil:

; 144  : #endif
; 145  :     _Py_atomic_store_relaxed(&gil_last_holder, NULL);

  00074	33 c0		 xor	 eax, eax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR gil_last_holder, rax

; 146  :     _Py_ANNOTATE_RWLOCK_CREATE(&gil_locked);
; 147  :     _Py_atomic_store_explicit(&gil_locked, 0, _Py_memory_order_release);

  0007d	89 05 00 00 00
	00		 mov	 DWORD PTR gil_locked, eax

; 148  : #ifdef WITH_PARALLEL
; 149  :     _PyParallel_CreatedGIL();
; 150  : #endif
; 151  : }

  00083	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00087	e9 00 00 00 00	 jmp	 _PyParallel_CreatedGIL
create_gil ENDP
_TEXT	ENDS
EXTRN	__imp_InitializeCriticalSection:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$PyMUTEX_INIT DD imagerel PyMUTEX_INIT
	DD	imagerel PyMUTEX_INIT+17
	DD	imagerel $unwind$PyMUTEX_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_INIT DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyMUTEX_INIT
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_INIT PROC					; COMDAT

; 175  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 176  :     InitializeCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 177  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 178  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_INIT ENDP
_TEXT	ENDS
EXTRN	__imp_CreateSemaphoreA:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_INIT DD imagerel PyCOND_INIT
	DD	imagerel PyCOND_INIT+60
	DD	imagerel $unwind$PyCOND_INIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_INIT DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyCOND_INIT
_TEXT	SEGMENT
cv$ = 48
PyCOND_INIT PROC					; COMDAT

; 213  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 214  :     /* A semaphore with a "large" max value,  The positive value
; 215  :      * is only needed to catch those "lost wakeup" events and
; 216  :      * race conditions when a timed wait elapses.
; 217  :      */
; 218  :     cv->sem = CreateSemaphore(NULL, 0, 100000, NULL);

  00009	45 33 c9	 xor	 r9d, r9d
  0000c	33 d2		 xor	 edx, edx
  0000e	33 c9		 xor	 ecx, ecx
  00010	41 b8 a0 86 01
	00		 mov	 r8d, 100000		; 000186a0H
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateSemaphoreA
  0001c	48 89 03	 mov	 QWORD PTR [rbx], rax

; 219  :     if (cv->sem==NULL)

  0001f	48 85 c0	 test	 rax, rax
  00022	75 09		 jne	 SHORT $LN1@PyCOND_INI

; 220  :         return -1;

  00024	83 c8 ff	 or	 eax, -1

; 223  : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
$LN1@PyCOND_INI:

; 221  :     cv->waiting = 0;

  0002d	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [rbx+8], 0

; 222  :     return 0;

  00034	33 c0		 xor	 eax, eax

; 223  : }

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
PyCOND_INIT ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@BPNPHLO@PyMUTEX_UNLOCK?$CIgil_mutex?$CJ?5failed@ ; `string'
PUBLIC	_PyEval_SignalAsyncExc
PUBLIC	??_C@_0CE@HDDMOJLP@PyMUTEX_UNLOCK?$CIswitch_mutex?$CJ?5fai@ ; `string'
PUBLIC	??_C@_0CC@PEOKDNHK@PyCOND_SIGNAL?$CIswitch_cond?$CJ?5faile@ ; `string'
PUBLIC	??_C@_0CC@PELEBGED@PyMUTEX_LOCK?$CIswitch_mutex?$CJ?5faile@ ; `string'
PUBLIC	??_C@_0BN@CIBICMCM@PyCOND_WAIT?$CIgil_cond?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BP@ELBEKAFN@PyMUTEX_LOCK?$CIgil_mutex?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BG@IIFMMKGM@take_gil?3?5NULL?5tstate?$AA@ ; `string'
EXTRN	_PyParallel_JustAcquiredGIL:PROC
EXTRN	__imp__errno:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval_gil.h
pdata	SEGMENT
$pdata$take_gil DD imagerel take_gil
	DD	imagerel take_gil+6
	DD	imagerel $unwind$take_gil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$take_gil DD imagerel take_gil+6
	DD	imagerel take_gil+86
	DD	imagerel $chain$0$take_gil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$take_gil DD imagerel take_gil+86
	DD	imagerel take_gil+212
	DD	imagerel $chain$2$take_gil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$take_gil DD imagerel take_gil+212
	DD	imagerel take_gil+385
	DD	imagerel $chain$3$take_gil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$take_gil DD imagerel take_gil+385
	DD	imagerel take_gil+432
	DD	imagerel $chain$4$take_gil
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$take_gil DD 021H
	DD	imagerel take_gil
	DD	imagerel take_gil+6
	DD	imagerel $unwind$take_gil
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$take_gil DD 021H
	DD	imagerel take_gil+6
	DD	imagerel take_gil+86
	DD	imagerel $chain$0$take_gil
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$take_gil DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel take_gil+6
	DD	imagerel take_gil+86
	DD	imagerel $chain$0$take_gil
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$take_gil DD 020521H
	DD	087405H
	DD	imagerel take_gil
	DD	imagerel take_gil+6
	DD	imagerel $unwind$take_gil
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$take_gil DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT ??_C@_0CB@BPNPHLO@PyMUTEX_UNLOCK?$CIgil_mutex?$CJ?5failed@
CONST	SEGMENT
??_C@_0CB@BPNPHLO@PyMUTEX_UNLOCK?$CIgil_mutex?$CJ?5failed@ DB 'PyMUTEX_UN'
	DB	'LOCK(gil_mutex) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@HDDMOJLP@PyMUTEX_UNLOCK?$CIswitch_mutex?$CJ?5fai@
CONST	SEGMENT
??_C@_0CE@HDDMOJLP@PyMUTEX_UNLOCK?$CIswitch_mutex?$CJ?5fai@ DB 'PyMUTEX_U'
	DB	'NLOCK(switch_mutex) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PEOKDNHK@PyCOND_SIGNAL?$CIswitch_cond?$CJ?5faile@
CONST	SEGMENT
??_C@_0CC@PEOKDNHK@PyCOND_SIGNAL?$CIswitch_cond?$CJ?5faile@ DB 'PyCOND_SI'
	DB	'GNAL(switch_cond) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@PELEBGED@PyMUTEX_LOCK?$CIswitch_mutex?$CJ?5faile@
CONST	SEGMENT
??_C@_0CC@PELEBGED@PyMUTEX_LOCK?$CIswitch_mutex?$CJ?5faile@ DB 'PyMUTEX_L'
	DB	'OCK(switch_mutex) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CIBICMCM@PyCOND_WAIT?$CIgil_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0BN@CIBICMCM@PyCOND_WAIT?$CIgil_cond?$CJ?5failed?$AA@ DB 'PyCOND_WA'
	DB	'IT(gil_cond) failed', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ELBEKAFN@PyMUTEX_LOCK?$CIgil_mutex?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0BP@ELBEKAFN@PyMUTEX_LOCK?$CIgil_mutex?$CJ?5failed?$AA@ DB 'PyMUTEX'
	DB	'_LOCK(gil_mutex) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IIFMMKGM@take_gil?3?5NULL?5tstate?$AA@
CONST	SEGMENT
??_C@_0BG@IIFMMKGM@take_gil?3?5NULL?5tstate?$AA@ DB 'take_gil: NULL tstat'
	DB	'e', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT take_gil
_TEXT	SEGMENT
tstate$ = 48
take_gil PROC						; COMDAT

; 217  : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0000b	48 8b f9	 mov	 rdi, rcx

; 218  :     int err;
; 219  :     if (tstate == NULL)

  0000e	48 85 c9	 test	 rcx, rcx
  00011	75 0c		 jne	 SHORT $LN22@take_gil

; 220  :         Py_FatalError("take_gil: NULL tstate");

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@IIFMMKGM@take_gil?3?5NULL?5tstate?$AA@
  0001a	e8 00 00 00 00	 call	 Py_FatalError
$LN22@take_gil:

; 221  : 
; 222  :     err = errno;

  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 223  :     MUTEX_LOCK(gil_mutex);

  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  0002c	8b 28		 mov	 ebp, DWORD PTR [rax]
  0002e	e8 00 00 00 00	 call	 PyMUTEX_LOCK
  00033	85 c0		 test	 eax, eax
  00035	74 0c		 je	 SHORT $LN21@take_gil
  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@ELBEKAFN@PyMUTEX_LOCK?$CIgil_mutex?$CJ?5failed?$AA@
  0003e	e8 00 00 00 00	 call	 Py_FatalError
$LN21@take_gil:

; 224  : 
; 225  :     if (!_Py_atomic_load_relaxed(&gil_locked))

  00043	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gil_locked, 0
  0004a	0f 84 84 00 00
	00		 je	 $_ready$64149
  00050	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR gil_switch_number
  00056	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0005b	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
$LL19@take_gil:

; 229  :         int timed_out = 0;
; 230  :         unsigned long saved_switchnum;
; 231  : 
; 232  :         saved_switchnum = gil_switch_number;
; 233  :         COND_TIMED_WAIT(gil_cond, gil_mutex, INTERVAL, timed_out);

  00060	41 b8 01 00 00
	00		 mov	 r8d, 1
  00066	8b f0		 mov	 esi, eax
  00068	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR gil_interval
  0006e	41 3b c0	 cmp	 eax, r8d
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gil_mutex
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_cond
  0007f	44 0f 43 c0	 cmovae	 r8d, eax
  00083	e8 00 00 00 00	 call	 PyCOND_TIMEDWAIT
  00088	8b d8		 mov	 ebx, eax
  0008a	85 c0		 test	 eax, eax
  0008c	79 0c		 jns	 SHORT $LN17@take_gil
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@CIBICMCM@PyCOND_WAIT?$CIgil_cond?$CJ?5failed?$AA@
  00095	e8 00 00 00 00	 call	 Py_FatalError
$LN17@take_gil:
  0009a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR gil_locked
  000a0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR gil_switch_number
  000a6	85 db		 test	 ebx, ebx

; 234  :         /* If we timed out and no switch occurred in the meantime, it is time
; 235  :            to ask the GIL-holding thread to drop it. */
; 236  :         if (timed_out &&
; 237  :             _Py_atomic_load_relaxed(&gil_locked) &&
; 238  :             gil_switch_number == saved_switchnum) {

  000a8	74 1c		 je	 SHORT $LN11@take_gil
  000aa	85 c9		 test	 ecx, ecx
  000ac	74 1c		 je	 SHORT $LN32@take_gil
  000ae	3b c6		 cmp	 eax, esi
  000b0	75 14		 jne	 SHORT $LN11@take_gil

; 239  :             SET_GIL_DROP_REQUEST();

  000b2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR gil_drop_request, 1
  000bc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR eval_breaker, 1
$LN11@take_gil:

; 226  :         goto _ready;
; 227  :     
; 228  :     while (_Py_atomic_load_relaxed(&gil_locked)) {

  000c6	85 c9		 test	 ecx, ecx
  000c8	75 96		 jne	 SHORT $LL19@take_gil
$LN32@take_gil:
  000ca	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cf	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
$_ready$64149:

; 240  :         }
; 241  :     }
; 242  : _ready:
; 243  : #ifdef FORCE_SWITCHING
; 244  :     /* This mutex must be taken before modifying gil_last_holder (see drop_gil()). */
; 245  :     MUTEX_LOCK(switch_mutex);

  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  000db	e8 00 00 00 00	 call	 PyMUTEX_LOCK
  000e0	85 c0		 test	 eax, eax
  000e2	74 0c		 je	 SHORT $LN10@take_gil
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@PELEBGED@PyMUTEX_LOCK?$CIswitch_mutex?$CJ?5faile@
  000eb	e8 00 00 00 00	 call	 Py_FatalError
$LN10@take_gil:

; 246  : #endif
; 247  :     /* We now hold the GIL */
; 248  : #ifdef WITH_PARALLEL
; 249  :     _PyParallel_JustAcquiredGIL();

  000f0	e8 00 00 00 00	 call	 _PyParallel_JustAcquiredGIL

; 250  : #endif
; 251  :     _Py_atomic_store_relaxed(&gil_locked, 1);
; 252  :     _Py_ANNOTATE_RWLOCK_ACQUIRED(&gil_locked, /*is_write=*/1);
; 253  : 
; 254  :     if (tstate != _Py_atomic_load_relaxed(&gil_last_holder)) {

  000f5	48 3b 3d 00 00
	00 00		 cmp	 rdi, QWORD PTR gil_last_holder
  000fc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR gil_locked, 1
  00106	74 0d		 je	 SHORT $LN9@take_gil

; 255  :         _Py_atomic_store_relaxed(&gil_last_holder, tstate);
; 256  :         ++gil_switch_number;

  00108	ff 05 00 00 00
	00		 inc	 DWORD PTR gil_switch_number
  0010e	48 89 3d 00 00
	00 00		 mov	 QWORD PTR gil_last_holder, rdi
$LN9@take_gil:

; 257  :     }
; 258  : 
; 259  : #ifdef FORCE_SWITCHING
; 260  :     COND_SIGNAL(switch_cond);

  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_cond
  0011c	e8 00 00 00 00	 call	 PyCOND_SIGNAL
  00121	85 c0		 test	 eax, eax
  00123	74 0c		 je	 SHORT $LN8@take_gil
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@PEOKDNHK@PyCOND_SIGNAL?$CIswitch_cond?$CJ?5faile@
  0012c	e8 00 00 00 00	 call	 Py_FatalError
$LN8@take_gil:

; 261  :     MUTEX_UNLOCK(switch_mutex);

  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  00138	e8 00 00 00 00	 call	 PyMUTEX_UNLOCK
  0013d	85 c0		 test	 eax, eax
  0013f	74 0c		 je	 SHORT $LN7@take_gil
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@HDDMOJLP@PyMUTEX_UNLOCK?$CIswitch_mutex?$CJ?5fai@
  00148	e8 00 00 00 00	 call	 Py_FatalError
$LN7@take_gil:

; 262  : #endif
; 263  :     if (_Py_atomic_load_relaxed(&gil_drop_request)) {

  0014d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gil_drop_request, 0
  00154	74 1c		 je	 SHORT $LN3@take_gil

; 264  :         RESET_GIL_DROP_REQUEST();

  00156	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pending_async_exc
  0015c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR gil_drop_request, 0
  00166	0b 05 00 00 00
	00		 or	 eax, DWORD PTR pendingcalls_to_do
  0016c	89 05 00 00 00
	00		 mov	 DWORD PTR eval_breaker, eax
$LN3@take_gil:

; 265  :     }
; 266  :     if (tstate->async_exc != NULL) {

  00172	48 83 bf 88 00
	00 00 00	 cmp	 QWORD PTR [rdi+136], 0
  0017a	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0017f	74 05		 je	 SHORT $LN2@take_gil

; 267  :         _PyEval_SignalAsyncExc();

  00181	e8 00 00 00 00	 call	 _PyEval_SignalAsyncExc
$LN2@take_gil:

; 268  :     }
; 269  :     
; 270  :     MUTEX_UNLOCK(gil_mutex);

  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  0018d	e8 00 00 00 00	 call	 PyMUTEX_UNLOCK
  00192	85 c0		 test	 eax, eax
  00194	74 0c		 je	 SHORT $LN1@take_gil
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@BPNPHLO@PyMUTEX_UNLOCK?$CIgil_mutex?$CJ?5failed@
  0019d	e8 00 00 00 00	 call	 Py_FatalError
$LN1@take_gil:

; 271  :     errno = err;

  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001a8	89 28		 mov	 DWORD PTR [rax], ebp

; 272  : }

  001aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ae	5d		 pop	 rbp
  001af	c3		 ret	 0
take_gil ENDP
_TEXT	ENDS
EXTRN	__imp_EnterCriticalSection:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$PyMUTEX_LOCK DD imagerel PyMUTEX_LOCK
	DD	imagerel PyMUTEX_LOCK+17
	DD	imagerel $unwind$PyMUTEX_LOCK
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_LOCK DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyMUTEX_LOCK
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_LOCK PROC					; COMDAT

; 189  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 190  :     EnterCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 191  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 192  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_LOCK ENDP
_TEXT	ENDS
EXTRN	__imp_LeaveCriticalSection:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMUTEX_UNLOCK DD imagerel PyMUTEX_UNLOCK
	DD	imagerel PyMUTEX_UNLOCK+17
	DD	imagerel $unwind$PyMUTEX_UNLOCK
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_UNLOCK DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyMUTEX_UNLOCK
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_UNLOCK PROC					; COMDAT

; 196  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 197  :     LeaveCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 198  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 199  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_UNLOCK ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT PyCOND_TIMEDWAIT
_TEXT	SEGMENT
cv$ = 8
cs$ = 16
us$ = 24
PyCOND_TIMEDWAIT PROC					; COMDAT

; 274  : {

  00000	4c 8b ca	 mov	 r9, rdx

; 275  :     return _PyCOND_WAIT_MS(cv, cs, us/1000);

  00003	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00008	41 f7 e8	 imul	 r8d
  0000b	c1 fa 06	 sar	 edx, 6
  0000e	44 8b c2	 mov	 r8d, edx
  00011	41 c1 e8 1f	 shr	 r8d, 31
  00015	44 03 c2	 add	 r8d, edx
  00018	49 8b d1	 mov	 rdx, r9

; 276  : }

  0001b	e9 00 00 00 00	 jmp	 _PyCOND_WAIT_MS
PyCOND_TIMEDWAIT ENDP
_TEXT	ENDS
EXTRN	__imp_WaitForSingleObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyCOND_WAIT_MS DD imagerel _PyCOND_WAIT_MS
	DD	imagerel _PyCOND_WAIT_MS+110
	DD	imagerel $unwind$_PyCOND_WAIT_MS
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyCOND_WAIT_MS DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT _PyCOND_WAIT_MS
_TEXT	SEGMENT
cv$ = 48
cs$ = 56
ms$ = 64
_PyCOND_WAIT_MS PROC					; COMDAT

; 236  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 237  :     DWORD wait;
; 238  :     cv->waiting++;

  0000f	ff 41 08	 inc	 DWORD PTR [rcx+8]
  00012	48 8b f1	 mov	 rsi, rcx

; 239  :     PyMUTEX_UNLOCK(cs);

  00015	48 8b ca	 mov	 rcx, rdx
  00018	41 8b d8	 mov	 ebx, r8d
  0001b	48 8b fa	 mov	 rdi, rdx
  0001e	e8 00 00 00 00	 call	 PyMUTEX_UNLOCK

; 240  :     /* "lost wakeup bug" would occur if the caller were interrupted here,
; 241  :      * but we are safe because we are using a semaphore wich has an internal
; 242  :      * count.
; 243  :      */
; 244  :     wait = WaitForSingleObject(cv->sem, ms);

  00023	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00026	8b d3		 mov	 edx, ebx
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 245  :     PyMUTEX_LOCK(cs);

  0002e	48 8b cf	 mov	 rcx, rdi
  00031	8b d8		 mov	 ebx, eax
  00033	e8 00 00 00 00	 call	 PyMUTEX_LOCK

; 246  :     if (wait != WAIT_OBJECT_0)

  00038	85 db		 test	 ebx, ebx
  0003a	74 03		 je	 SHORT $LN2@PyCOND_WAI

; 247  :         --cv->waiting;

  0003c	ff 4e 08	 dec	 DWORD PTR [rsi+8]
$LN2@PyCOND_WAI:

; 248  :         /* Here we have a benign race condition with PyCOND_SIGNAL.
; 249  :          * When failure occurs or timeout, it is possible that
; 250  :          * PyCOND_SIGNAL also decrements this value
; 251  :          * and signals releases the mutex.  This is benign because it
; 252  :          * just means an extra spurious wakeup for a waiting thread.
; 253  :          * ('waiting' corresponds to the semaphore's "negative" count and
; 254  :          * we may end up with e.g. (waiting == -1 && sem.count == 1).  When
; 255  :          * a new thread comes along, it will pass right throuhgh, having
; 256  :          * adjusted it to (waiting == 0 && sem.count == 0).
; 257  :          */
; 258  :          
; 259  :     if (wait == WAIT_FAILED)

  0003f	83 fb ff	 cmp	 ebx, -1			; ffffffffH
  00042	75 13		 jne	 SHORT $LN1@PyCOND_WAI

; 260  :         return -1;

  00044	83 c8 ff	 or	 eax, -1

; 261  :     /* return 0 on success, 1 on timeout */
; 262  :     return wait != WAIT_OBJECT_0;
; 263  : }

  00047	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5f		 pop	 rdi
  00056	c3		 ret	 0
$LN1@PyCOND_WAI:
  00057	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005c	33 c0		 xor	 eax, eax
  0005e	85 db		 test	 ebx, ebx
  00060	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00065	0f 95 c0	 setne	 al
  00068	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
_PyCOND_WAIT_MS ENDP
_TEXT	ENDS
EXTRN	__imp_ReleaseSemaphore:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_SIGNAL DD imagerel PyCOND_SIGNAL
	DD	imagerel PyCOND_SIGNAL+52
	DD	imagerel $unwind$PyCOND_SIGNAL
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_SIGNAL DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyCOND_SIGNAL
_TEXT	SEGMENT
cv$ = 48
PyCOND_SIGNAL PROC					; COMDAT

; 280  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 281  :     /* this test allows PyCOND_SIGNAL to be a no-op unless required
; 282  :      * to wake someone up, thus preventing an unbounded increase of
; 283  :      * the semaphore's internal counter.
; 284  :      */
; 285  :     if (cv->waiting > 0) {

  00004	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00007	85 c0		 test	 eax, eax
  00009	7e 22		 jle	 SHORT $LN1@PyCOND_SIG

; 286  :         /* notifying thread decreases the cv->waiting count so that
; 287  :          * a delay between notify and actual wakeup of the target thread
; 288  :          * doesn't cause a number of extra ReleaseSemaphore calls.
; 289  :          */
; 290  :         cv->waiting--;

  0000b	ff c8		 dec	 eax

; 291  :         return ReleaseSemaphore(cv->sem, 1, NULL) ? 0 : -1;

  0000d	45 33 c0	 xor	 r8d, r8d
  00010	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00016	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
  00020	f7 d8		 neg	 eax
  00022	1b c0		 sbb	 eax, eax
  00024	f7 d8		 neg	 eax
  00026	ff c8		 dec	 eax

; 294  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
$LN1@PyCOND_SIG:

; 292  :     }
; 293  :     return 0;

  0002d	33 c0		 xor	 eax, eax

; 294  : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
PyCOND_SIGNAL ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BO@DEKOAGGH@?$AA?$CB?$AAg?$AAi?$AAl?$AA_?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BE@BNNALOFO@_PyEval_FiniThreads?$AA@	; `string'
PUBLIC	_PyEval_FiniThreads
EXTRN	__imp__wassert:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval.c
pdata	SEGMENT
$pdata$_PyEval_FiniThreads DD imagerel $LN6
	DD	imagerel $LN6+95
	DD	imagerel $unwind$_PyEval_FiniThreads
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyEval_FiniThreads DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_1BO@DEKOAGGH@?$AA?$CB?$AAg?$AAi?$AAl?$AA_?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@DEKOAGGH@?$AA?$CB?$AAg?$AAi?$AAl?$AA_?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ DB '!'
	DB	00H, 'g', 00H, 'i', 00H, 'l', 00H, '_', 00H, 'c', 00H, 'r', 00H
	DB	'e', 00H, 'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, '(', 00H, ')'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'y', 00H, 't', 00H, 'h', 00H
	DB	'o', 00H, 'n', 00H, '\', 00H, 'c', 00H, 'e', 00H, 'v', 00H, 'a'
	DB	00H, 'l', 00H, '.', 00H, 'c', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BNNALOFO@_PyEval_FiniThreads?$AA@
CONST	SEGMENT
??_C@_0BE@BNNALOFO@_PyEval_FiniThreads?$AA@ DB '_PyEval_FiniThreads', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _PyEval_FiniThreads
_TEXT	SEGMENT
_PyEval_FiniThreads PROC				; COMDAT

; 323  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 324  :     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN2@PyEval_Fin
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@BNNALOFO@_PyEval_FiniThreads?$AA@
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	41 b8 44 01 00
	00		 mov	 r8d, 324		; 00000144H
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN2@PyEval_Fin:

; 325  :     if (!gil_created())

  00029	e8 00 00 00 00	 call	 gil_created
  0002e	85 c0		 test	 eax, eax
  00030	74 28		 je	 SHORT $LN5@PyEval_Fin

; 326  :         return;
; 327  :     destroy_gil();

  00032	e8 00 00 00 00	 call	 destroy_gil

; 328  :     assert(!gil_created());

  00037	e8 00 00 00 00	 call	 gil_created
  0003c	85 c0		 test	 eax, eax
  0003e	74 1a		 je	 SHORT $LN5@PyEval_Fin
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@DEKOAGGH@?$AA?$CB?$AAg?$AAi?$AAl?$AA_?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
  0004e	41 b8 48 01 00
	00		 mov	 r8d, 328		; 00000148H
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN5@PyEval_Fin:

; 329  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
_PyEval_FiniThreads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@ILEAIBJ@PyMUTEX_FINI?$CIswitch_mutex?$CJ?5faile@ ; `string'
PUBLIC	??_C@_0CA@GKHCPMOF@PyCOND_FINI?$CIswitch_cond?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BP@LGNFJCMN@PyMUTEX_FINI?$CIgil_mutex?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BN@HGBIAGHN@PyCOND_FINI?$CIgil_cond?$CJ?5failed?$AA@ ; `string'
EXTRN	_PyParallel_DestroyedGIL:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval_gil.h
pdata	SEGMENT
$pdata$destroy_gil DD imagerel destroy_gil
	DD	imagerel destroy_gil+135
	DD	imagerel $unwind$destroy_gil
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$destroy_gil DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CC@ILEAIBJ@PyMUTEX_FINI?$CIswitch_mutex?$CJ?5faile@
CONST	SEGMENT
??_C@_0CC@ILEAIBJ@PyMUTEX_FINI?$CIswitch_mutex?$CJ?5faile@ DB 'PyMUTEX_FI'
	DB	'NI(switch_mutex) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@GKHCPMOF@PyCOND_FINI?$CIswitch_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0CA@GKHCPMOF@PyCOND_FINI?$CIswitch_cond?$CJ?5failed?$AA@ DB 'PyCOND'
	DB	'_FINI(switch_cond) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LGNFJCMN@PyMUTEX_FINI?$CIgil_mutex?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0BP@LGNFJCMN@PyMUTEX_FINI?$CIgil_mutex?$CJ?5failed?$AA@ DB 'PyMUTEX'
	DB	'_FINI(gil_mutex) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HGBIAGHN@PyCOND_FINI?$CIgil_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0BN@HGBIAGHN@PyCOND_FINI?$CIgil_cond?$CJ?5failed?$AA@ DB 'PyCOND_FI'
	DB	'NI(gil_cond) failed', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT destroy_gil
_TEXT	SEGMENT
destroy_gil PROC					; COMDAT

; 154  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 155  :     /* some pthread-like implementations tie the mutex to the cond
; 156  :      * and must have the cond destroyed first.
; 157  :      */
; 158  :     COND_FINI(gil_cond);

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_cond
  0000b	e8 00 00 00 00	 call	 PyCOND_FINI
  00010	85 c0		 test	 eax, eax
  00012	74 0c		 je	 SHORT $LN4@destroy_gi
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@HGBIAGHN@PyCOND_FINI?$CIgil_cond?$CJ?5failed?$AA@
  0001b	e8 00 00 00 00	 call	 Py_FatalError
$LN4@destroy_gi:

; 159  :     MUTEX_FINI(gil_mutex);

  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  00027	e8 00 00 00 00	 call	 PyMUTEX_FINI
  0002c	85 c0		 test	 eax, eax
  0002e	74 0c		 je	 SHORT $LN3@destroy_gi
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@LGNFJCMN@PyMUTEX_FINI?$CIgil_mutex?$CJ?5failed?$AA@
  00037	e8 00 00 00 00	 call	 Py_FatalError
$LN3@destroy_gi:

; 160  : #ifdef FORCE_SWITCHING
; 161  :     COND_FINI(switch_cond);

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_cond
  00043	e8 00 00 00 00	 call	 PyCOND_FINI
  00048	85 c0		 test	 eax, eax
  0004a	74 0c		 je	 SHORT $LN2@destroy_gi
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@GKHCPMOF@PyCOND_FINI?$CIswitch_cond?$CJ?5failed?$AA@
  00053	e8 00 00 00 00	 call	 Py_FatalError
$LN2@destroy_gi:

; 162  :     MUTEX_FINI(switch_mutex);

  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  0005f	e8 00 00 00 00	 call	 PyMUTEX_FINI
  00064	85 c0		 test	 eax, eax
  00066	74 0c		 je	 SHORT $LN1@destroy_gi
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@ILEAIBJ@PyMUTEX_FINI?$CIswitch_mutex?$CJ?5faile@
  0006f	e8 00 00 00 00	 call	 Py_FatalError
$LN1@destroy_gi:

; 163  : #endif
; 164  :     _Py_atomic_store_explicit(&gil_locked, -1, _Py_memory_order_release);

  00074	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR gil_locked, -1

; 165  :     _Py_ANNOTATE_RWLOCK_DESTROY(&gil_locked);
; 166  : #ifdef WITH_PARALLEL
; 167  :     _PyParallel_DestroyedGIL();
; 168  : #endif
; 169  : }

  0007e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00082	e9 00 00 00 00	 jmp	 _PyParallel_DestroyedGIL
destroy_gil ENDP
_TEXT	ENDS
EXTRN	__imp_DeleteCriticalSection:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$PyMUTEX_FINI DD imagerel PyMUTEX_FINI
	DD	imagerel PyMUTEX_FINI+17
	DD	imagerel $unwind$PyMUTEX_FINI
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMUTEX_FINI DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyMUTEX_FINI
_TEXT	SEGMENT
cs$ = 48
PyMUTEX_FINI PROC					; COMDAT

; 182  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 183  :     DeleteCriticalSection(cs);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 184  :     return 0;

  0000a	33 c0		 xor	 eax, eax

; 185  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	c3		 ret	 0
PyMUTEX_FINI ENDP
_TEXT	ENDS
EXTRN	__imp_CloseHandle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyCOND_FINI DD imagerel PyCOND_FINI
	DD	imagerel PyCOND_FINI+26
	DD	imagerel $unwind$PyCOND_FINI
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_FINI DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyCOND_FINI
_TEXT	SEGMENT
cv$ = 48
PyCOND_FINI PROC					; COMDAT

; 227  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 228  :     return CloseHandle(cv->sem) ? 0 : -1;

  00004	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00007	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  0000d	f7 d8		 neg	 eax
  0000f	1b c0		 sbb	 eax, eax
  00011	f7 d8		 neg	 eax
  00013	ff c8		 dec	 eax

; 229  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
PyCOND_FINI ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@OLFNGBME@PyEval_AcquireLock?3?5current?5thre@ ; `string'
PUBLIC	??_C@_0BD@DCFEODA@PyEval_AcquireLock?$AA@	; `string'
PUBLIC	PyEval_AcquireLock
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval.c
pdata	SEGMENT
$pdata$PyEval_AcquireLock DD imagerel $LN5
	DD	imagerel $LN5+81
	DD	imagerel $unwind$PyEval_AcquireLock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_AcquireLock DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DB@OLFNGBME@PyEval_AcquireLock?3?5current?5thre@
CONST	SEGMENT
??_C@_0DB@OLFNGBME@PyEval_AcquireLock?3?5current?5thre@ DB 'PyEval_Acquir'
	DB	'eLock: current thread state is NULL', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCFEODA@PyEval_AcquireLock?$AA@
CONST	SEGMENT
??_C@_0BD@DCFEODA@PyEval_AcquireLock?$AA@ DB 'PyEval_AcquireLock', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_AcquireLock
_TEXT	SEGMENT
PyEval_AcquireLock PROC					; COMDAT

; 333  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 334  :     PyThreadState *tstate = PyThreadState_GET();

  00006	e8 00 00 00 00	 call	 PyThreadState_Get
  0000b	48 8b d8	 mov	 rbx, rax

; 335  :     Py_GUARD

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 1c		 je	 SHORT $LN2@PyEval_Acq
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@DCFEODA@PyEval_AcquireLock?$AA@
  00025	45 33 c9	 xor	 r9d, r9d
  00028	41 b8 4f 01 00
	00		 mov	 r8d, 335		; 0000014fH
  0002e	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN2@PyEval_Acq:

; 336  :     if (tstate == NULL)

  00033	48 85 db	 test	 rbx, rbx
  00036	75 0c		 jne	 SHORT $LN1@PyEval_Acq

; 337  :         Py_FatalError("PyEval_AcquireLock: current thread state is NULL");

  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@OLFNGBME@PyEval_AcquireLock?3?5current?5thre@
  0003f	e8 00 00 00 00	 call	 Py_FatalError
$LN1@PyEval_Acq:

; 338  :     take_gil(tstate);

  00044	48 8b cb	 mov	 rcx, rbx

; 339  : }

  00047	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004b	5b		 pop	 rbx
  0004c	e9 00 00 00 00	 jmp	 take_gil
PyEval_AcquireLock ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@JLBEODFH@PyEval_ReleaseLock?$AA@	; `string'
PUBLIC	PyEval_ReleaseLock
EXTRN	_PyThreadState_Current:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_ReleaseLock DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$PyEval_ReleaseLock
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_ReleaseLock DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BD@JLBEODFH@PyEval_ReleaseLock?$AA@
CONST	SEGMENT
??_C@_0BD@JLBEODFH@PyEval_ReleaseLock?$AA@ DB 'PyEval_ReleaseLock', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_ReleaseLock
_TEXT	SEGMENT
PyEval_ReleaseLock PROC					; COMDAT

; 343  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 344  :     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN1@PyEval_Rel
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@JLBEODFH@PyEval_ReleaseLock?$AA@
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	41 b8 58 01 00
	00		 mov	 r8d, 344		; 00000158H
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN1@PyEval_Rel:

; 345  :     /* This function must succeed when the current thread state is NULL.
; 346  :        We therefore avoid PyThreadState_GET() which dumps a fatal error
; 347  :        in debug mode.
; 348  :     */
; 349  :     drop_gil((PyThreadState*)_Py_atomic_load_relaxed(
; 350  :         &_PyThreadState_Current));

  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyThreadState_Current

; 351  : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	e9 00 00 00 00	 jmp	 drop_gil
PyEval_ReleaseLock ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@GIGHHEBE@PyCOND_WAIT?$CIswitch_cond?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BP@HKOAHNPN@PyCOND_SIGNAL?$CIgil_cond?$CJ?5failed?$AA@ ; `string'
PUBLIC	??_C@_0BM@DHPNFLDF@drop_gil?3?5GIL?5is?5not?5locked?$AA@ ; `string'
EXTRN	_PyParallel_AboutToDropGIL:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval_gil.h
pdata	SEGMENT
$pdata$drop_gil DD imagerel drop_gil
	DD	imagerel drop_gil+306
	DD	imagerel $unwind$drop_gil
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$drop_gil DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CA@GIGHHEBE@PyCOND_WAIT?$CIswitch_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0CA@GIGHHEBE@PyCOND_WAIT?$CIswitch_cond?$CJ?5failed?$AA@ DB 'PyCOND'
	DB	'_WAIT(switch_cond) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@HKOAHNPN@PyCOND_SIGNAL?$CIgil_cond?$CJ?5failed?$AA@
CONST	SEGMENT
??_C@_0BP@HKOAHNPN@PyCOND_SIGNAL?$CIgil_cond?$CJ?5failed?$AA@ DB 'PyCOND_'
	DB	'SIGNAL(gil_cond) failed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DHPNFLDF@drop_gil?3?5GIL?5is?5not?5locked?$AA@
CONST	SEGMENT
??_C@_0BM@DHPNFLDF@drop_gil?3?5GIL?5is?5not?5locked?$AA@ DB 'drop_gil: GI'
	DB	'L is not locked', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT drop_gil
_TEXT	SEGMENT
tstate$ = 48
drop_gil PROC						; COMDAT

; 179  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 180  :     if (!_Py_atomic_load_relaxed(&gil_locked))

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gil_locked, 0
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	75 0c		 jne	 SHORT $LN13@drop_gil

; 181  :         Py_FatalError("drop_gil: GIL is not locked");

  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@DHPNFLDF@drop_gil?3?5GIL?5is?5not?5locked?$AA@
  00019	e8 00 00 00 00	 call	 Py_FatalError
$LN13@drop_gil:

; 182  :     /* tstate is allowed to be NULL (early interpreter init) */
; 183  :     if (tstate != NULL) {

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR gil_last_holder
  00025	48 85 db	 test	 rbx, rbx
  00028	48 0f 45 c3	 cmovne	 rax, rbx
  0002c	48 89 05 00 00
	00 00		 mov	 QWORD PTR gil_last_holder, rax

; 184  :         /* Sub-interpreter support: threads might have been switched
; 185  :            under our feet using PyThreadState_Swap(). Fix the GIL last
; 186  :            holder variable so that our heuristics work. */
; 187  :         _Py_atomic_store_relaxed(&gil_last_holder, tstate);
; 188  :     }
; 189  : 
; 190  : #ifdef WITH_PARALLEL
; 191  :     _PyParallel_AboutToDropGIL();

  00033	e8 00 00 00 00	 call	 _PyParallel_AboutToDropGIL

; 192  : #endif
; 193  :     MUTEX_LOCK(gil_mutex);

  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  0003f	e8 00 00 00 00	 call	 PyMUTEX_LOCK
  00044	85 c0		 test	 eax, eax
  00046	74 0c		 je	 SHORT $LN11@drop_gil
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@ELBEKAFN@PyMUTEX_LOCK?$CIgil_mutex?$CJ?5failed?$AA@
  0004f	e8 00 00 00 00	 call	 Py_FatalError
$LN11@drop_gil:

; 194  :     _Py_ANNOTATE_RWLOCK_RELEASED(&gil_locked, /*is_write=*/1);
; 195  :     _Py_atomic_store_relaxed(&gil_locked, 0);
; 196  :     COND_SIGNAL(gil_cond);

  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_cond
  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR gil_locked, 0
  00065	e8 00 00 00 00	 call	 PyCOND_SIGNAL
  0006a	85 c0		 test	 eax, eax
  0006c	74 0c		 je	 SHORT $LN10@drop_gil
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@HKOAHNPN@PyCOND_SIGNAL?$CIgil_cond?$CJ?5failed?$AA@
  00075	e8 00 00 00 00	 call	 Py_FatalError
$LN10@drop_gil:

; 197  :     MUTEX_UNLOCK(gil_mutex);

  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gil_mutex
  00081	e8 00 00 00 00	 call	 PyMUTEX_UNLOCK
  00086	85 c0		 test	 eax, eax
  00088	74 0c		 je	 SHORT $LN9@drop_gil
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@BPNPHLO@PyMUTEX_UNLOCK?$CIgil_mutex?$CJ?5failed@
  00091	e8 00 00 00 00	 call	 Py_FatalError
$LN9@drop_gil:

; 198  :     
; 199  : #ifdef FORCE_SWITCHING
; 200  :     if (_Py_atomic_load_relaxed(&gil_drop_request) && tstate != NULL) {

  00096	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gil_drop_request, 0
  0009d	0f 84 89 00 00
	00		 je	 $LN1@drop_gil
  000a3	48 85 db	 test	 rbx, rbx
  000a6	0f 84 80 00 00
	00		 je	 $LN1@drop_gil

; 201  :         MUTEX_LOCK(switch_mutex);

  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  000b3	e8 00 00 00 00	 call	 PyMUTEX_LOCK
  000b8	85 c0		 test	 eax, eax
  000ba	74 0c		 je	 SHORT $LN7@drop_gil
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@PELEBGED@PyMUTEX_LOCK?$CIswitch_mutex?$CJ?5faile@
  000c3	e8 00 00 00 00	 call	 Py_FatalError
$LN7@drop_gil:

; 202  :         /* Not switched yet => wait */
; 203  :         if (_Py_atomic_load_relaxed(&gil_last_holder) == tstate) {

  000c8	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR gil_last_holder, rbx
  000cf	75 3f		 jne	 SHORT $LN2@drop_gil

; 204  :         RESET_GIL_DROP_REQUEST();

  000d1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pending_async_exc

; 205  :             /* NOTE: if COND_WAIT does not atomically start waiting when
; 206  :                releasing the mutex, another thread can run through, take
; 207  :                the GIL and drop it again, and reset the condition
; 208  :                before we even had a chance to wait for it. */
; 209  :             COND_WAIT(switch_cond, switch_mutex);

  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:switch_mutex
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_cond
  000e5	0b 05 00 00 00
	00		 or	 eax, DWORD PTR pendingcalls_to_do
  000eb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR gil_drop_request, 0
  000f5	89 05 00 00 00
	00		 mov	 DWORD PTR eval_breaker, eax
  000fb	e8 00 00 00 00	 call	 PyCOND_WAIT
  00100	85 c0		 test	 eax, eax
  00102	74 0c		 je	 SHORT $LN2@drop_gil
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@GIGHHEBE@PyCOND_WAIT?$CIswitch_cond?$CJ?5failed?$AA@
  0010b	e8 00 00 00 00	 call	 Py_FatalError
$LN2@drop_gil:

; 210  :     }
; 211  :         MUTEX_UNLOCK(switch_mutex);

  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:switch_mutex
  00117	e8 00 00 00 00	 call	 PyMUTEX_UNLOCK
  0011c	85 c0		 test	 eax, eax
  0011e	74 0c		 je	 SHORT $LN1@drop_gil
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@HDDMOJLP@PyMUTEX_UNLOCK?$CIswitch_mutex?$CJ?5fai@
  00127	e8 00 00 00 00	 call	 Py_FatalError
$LN1@drop_gil:

; 212  :     }
; 213  : #endif
; 214  : }

  0012c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00130	5b		 pop	 rbx
  00131	c3		 ret	 0
drop_gil ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\src\pyparallel\python\condvar.h
pdata	SEGMENT
$pdata$PyCOND_WAIT DD imagerel PyCOND_WAIT
	DD	imagerel PyCOND_WAIT+25
	DD	imagerel $unwind$PyCOND_WAIT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyCOND_WAIT DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyCOND_WAIT
_TEXT	SEGMENT
cv$ = 48
cs$ = 56
PyCOND_WAIT PROC					; COMDAT

; 267  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 268  :     int result = _PyCOND_WAIT_MS(cv, cs, INFINITE);

  00004	41 83 c8 ff	 or	 r8d, -1			; ffffffffH
  00008	e8 00 00 00 00	 call	 _PyCOND_WAIT_MS

; 269  :     return result >= 0 ? 0 : result;

  0000d	33 c9		 xor	 ecx, ecx
  0000f	85 c0		 test	 eax, eax
  00011	0f 49 c1	 cmovns	 eax, ecx

; 270  : }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
PyCOND_WAIT ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@ICJLMIKE@PyEval_AcquireThread?3?5non?9NULL?5o@ ; `string'
PUBLIC	??_C@_1BM@GJGCNEDH@?$AAg?$AAi?$AAl?$AA_?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CM@FOIANINH@PyEval_AcquireThread?3?5NULL?5new?5t@ ; `string'
PUBLIC	??_C@_0BF@PCMNHNOF@PyEval_AcquireThread?$AA@	; `string'
PUBLIC	PyEval_AcquireThread
EXTRN	PyThreadState_Swap:PROC
;	COMDAT pdata
; File c:\src\pyparallel\python\ceval.c
pdata	SEGMENT
$pdata$PyEval_AcquireThread DD imagerel $LN7
	DD	imagerel $LN7+137
	DD	imagerel $unwind$PyEval_AcquireThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_AcquireThread DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0DA@ICJLMIKE@PyEval_AcquireThread?3?5non?9NULL?5o@
CONST	SEGMENT
??_C@_0DA@ICJLMIKE@PyEval_AcquireThread?3?5non?9NULL?5o@ DB 'PyEval_Acqui'
	DB	'reThread: non-NULL old thread state', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@GJGCNEDH@?$AAg?$AAi?$AAl?$AA_?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@GJGCNEDH@?$AAg?$AAi?$AAl?$AA_?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@ DB 'g'
	DB	00H, 'i', 00H, 'l', 00H, '_', 00H, 'c', 00H, 'r', 00H, 'e', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'd', 00H, '(', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FOIANINH@PyEval_AcquireThread?3?5NULL?5new?5t@
CONST	SEGMENT
??_C@_0CM@FOIANINH@PyEval_AcquireThread?3?5NULL?5new?5t@ DB 'PyEval_Acqui'
	DB	'reThread: NULL new thread state', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PCMNHNOF@PyEval_AcquireThread?$AA@
CONST	SEGMENT
??_C@_0BF@PCMNHNOF@PyEval_AcquireThread?$AA@ DB 'PyEval_AcquireThread', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_AcquireThread
_TEXT	SEGMENT
tstate$ = 48
PyEval_AcquireThread PROC				; COMDAT

; 355  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 356  :     Py_GUARD

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 1c		 je	 SHORT $LN3@PyEval_Acq@2
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PCMNHNOF@PyEval_AcquireThread?$AA@
  00020	45 33 c9	 xor	 r9d, r9d
  00023	41 b8 64 01 00
	00		 mov	 r8d, 356		; 00000164H
  00029	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@PyEval_Acq@2:

; 357  :     if (tstate == NULL)

  0002e	48 85 db	 test	 rbx, rbx
  00031	75 0c		 jne	 SHORT $LN2@PyEval_Acq@2

; 358  :         Py_FatalError("PyEval_AcquireThread: NULL new thread state");

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CM@FOIANINH@PyEval_AcquireThread?3?5NULL?5new?5t@
  0003a	e8 00 00 00 00	 call	 Py_FatalError
$LN2@PyEval_Acq@2:

; 359  :     /* Check someone has called PyEval_InitThreads() to create the lock */
; 360  :     assert(gil_created());

  0003f	e8 00 00 00 00	 call	 gil_created
  00044	85 c0		 test	 eax, eax
  00046	75 1a		 jne	 SHORT $LN6@PyEval_Acq@2
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BM@GJGCNEDH@?$AAg?$AAi?$AAl?$AA_?$AAc?$AAr?$AAe?$AAa?$AAt?$AAe?$AAd?$AA?$CI?$AA?$CJ?$AA?$AA@
  00056	41 b8 68 01 00
	00		 mov	 r8d, 360		; 00000168H
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN6@PyEval_Acq@2:

; 361  :     take_gil(tstate);

  00062	48 8b cb	 mov	 rcx, rbx
  00065	e8 00 00 00 00	 call	 take_gil

; 362  :     if (PyThreadState_Swap(tstate) != NULL)

  0006a	48 8b cb	 mov	 rcx, rbx
  0006d	e8 00 00 00 00	 call	 PyThreadState_Swap
  00072	48 85 c0	 test	 rax, rax
  00075	74 0c		 je	 SHORT $LN1@PyEval_Acq@2

; 363  :         Py_FatalError(
; 364  :             "PyEval_AcquireThread: non-NULL old thread state");

  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DA@ICJLMIKE@PyEval_AcquireThread?3?5non?9NULL?5o@
  0007e	e8 00 00 00 00	 call	 Py_FatalError
$LN1@PyEval_Acq@2:

; 365  : }

  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5b		 pop	 rbx
  00088	c3		 ret	 0
PyEval_AcquireThread ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@OFBAFBEO@PyEval_ReleaseThread?3?5wrong?5thre@ ; `string'
PUBLIC	??_C@_0CI@LNKLMPPG@PyEval_ReleaseThread?3?5NULL?5threa@ ; `string'
PUBLIC	??_C@_0BF@HABGMHOB@PyEval_ReleaseThread?$AA@	; `string'
PUBLIC	PyEval_ReleaseThread
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_ReleaseThread DD imagerel $LN6
	DD	imagerel $LN6+100
	DD	imagerel $unwind$PyEval_ReleaseThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_ReleaseThread DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CJ@OFBAFBEO@PyEval_ReleaseThread?3?5wrong?5thre@
CONST	SEGMENT
??_C@_0CJ@OFBAFBEO@PyEval_ReleaseThread?3?5wrong?5thre@ DB 'PyEval_Releas'
	DB	'eThread: wrong thread state', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@LNKLMPPG@PyEval_ReleaseThread?3?5NULL?5threa@
CONST	SEGMENT
??_C@_0CI@LNKLMPPG@PyEval_ReleaseThread?3?5NULL?5threa@ DB 'PyEval_Releas'
	DB	'eThread: NULL thread state', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HABGMHOB@PyEval_ReleaseThread?$AA@
CONST	SEGMENT
??_C@_0BF@HABGMHOB@PyEval_ReleaseThread?$AA@ DB 'PyEval_ReleaseThread', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_ReleaseThread
_TEXT	SEGMENT
tstate$ = 48
PyEval_ReleaseThread PROC				; COMDAT

; 369  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 370  :     Py_GUARD

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	74 1c		 je	 SHORT $LN3@PyEval_Rel@2
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@HABGMHOB@PyEval_ReleaseThread?$AA@
  00020	45 33 c9	 xor	 r9d, r9d
  00023	41 b8 72 01 00
	00		 mov	 r8d, 370		; 00000172H
  00029	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN3@PyEval_Rel@2:

; 371  :     if (tstate == NULL)

  0002e	48 85 db	 test	 rbx, rbx
  00031	75 0c		 jne	 SHORT $LN2@PyEval_Rel@2

; 372  :         Py_FatalError("PyEval_ReleaseThread: NULL thread state");

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@LNKLMPPG@PyEval_ReleaseThread?3?5NULL?5threa@
  0003a	e8 00 00 00 00	 call	 Py_FatalError
$LN2@PyEval_Rel@2:

; 373  :     if (PyThreadState_Swap(NULL) != tstate)

  0003f	33 c9		 xor	 ecx, ecx
  00041	e8 00 00 00 00	 call	 PyThreadState_Swap
  00046	48 3b c3	 cmp	 rax, rbx
  00049	74 0c		 je	 SHORT $LN1@PyEval_Rel@2

; 374  :         Py_FatalError("PyEval_ReleaseThread: wrong thread state");

  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@OFBAFBEO@PyEval_ReleaseThread?3?5wrong?5thre@
  00052	e8 00 00 00 00	 call	 Py_FatalError
$LN1@PyEval_Rel@2:

; 375  :     drop_gil(tstate);

  00057	48 8b cb	 mov	 rcx, rbx

; 376  : }

  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5b		 pop	 rbx
  0005f	e9 00 00 00 00	 jmp	 drop_gil
PyEval_ReleaseThread ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	??_C@_09LCFGMKMJ@threading?$AA@			; `string'
PUBLIC	??_C@_0BF@HOBAOGPA@PyEval_ReInitThreads?$AA@	; `string'
PUBLIC	PyEval_ReInitThreads
EXTRN	PyErr_WriteUnraisable:PROC
EXTRN	_PyObject_CallMethodId:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyMapping_GetItemString:PROC
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_ReInitThreads DD imagerel $LN8
	DD	imagerel $LN8+226
	DD	imagerel $unwind$PyEval_ReInitThreads
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_ReInitThreads DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_09LCFGMKMJ@threading?$AA@
CONST	SEGMENT
??_C@_09LCFGMKMJ@threading?$AA@ DB 'threading', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOBAOGPA@PyEval_ReInitThreads?$AA@
CONST	SEGMENT
??_C@_0BF@HOBAOGPA@PyEval_ReInitThreads?$AA@ DB 'PyEval_ReInitThreads', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_ReInitThreads
_TEXT	SEGMENT
PyEval_ReInitThreads PROC				; COMDAT

; 385  : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 386  :     _Py_IDENTIFIER(_after_fork);
; 387  :     PyObject *threading, *result;
; 388  :     PyThreadState *tstate = PyThreadState_GET();

  00006	e8 00 00 00 00	 call	 PyThreadState_Get
  0000b	48 8b d8	 mov	 rbx, rax

; 389  :     Py_GUARD

  0000e	e8 00 00 00 00	 call	 _Py_PXCTX
  00013	85 c0		 test	 eax, eax
  00015	74 1c		 je	 SHORT $LN5@PyEval_ReI
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@HOBAOGPA@PyEval_ReInitThreads?$AA@
  00025	45 33 c9	 xor	 r9d, r9d
  00028	41 b8 85 01 00
	00		 mov	 r8d, 389		; 00000185H
  0002e	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN5@PyEval_ReI:

; 390  : 
; 391  :     if (!gil_created())

  00033	e8 00 00 00 00	 call	 gil_created
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 9c 00 00
	00		 je	 $LN6@PyEval_ReI

; 392  :         return;
; 393  :     recreate_gil();

  00040	e8 00 00 00 00	 call	 recreate_gil

; 394  :     pending_lock = PyThread_allocate_lock();

  00045	e8 00 00 00 00	 call	 PyThread_allocate_lock

; 395  :     take_gil(tstate);

  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	48 89 05 00 00
	00 00		 mov	 QWORD PTR pending_lock, rax
  00054	e8 00 00 00 00	 call	 take_gil

; 396  :     main_thread = PyThread_get_thread_ident();

  00059	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  0005e	89 05 00 00 00
	00		 mov	 DWORD PTR main_thread, eax

; 397  : 
; 398  :     /* Update the threading module with the new state.
; 399  :      */
; 400  :     tstate = PyThreadState_GET();

  00064	e8 00 00 00 00	 call	 PyThreadState_Get

; 401  :     threading = PyMapping_GetItemString(tstate->interp->modules,
; 402  :                                         "threading");

  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LCFGMKMJ@threading?$AA@
  00070	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00074	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00078	e8 00 00 00 00	 call	 PyMapping_GetItemString
  0007d	48 8b d8	 mov	 rbx, rax

; 403  :     if (threading == NULL) {

  00080	48 85 c0	 test	 rax, rax
  00083	75 0a		 jne	 SHORT $LN3@PyEval_ReI

; 414  : }

  00085	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00089	5b		 pop	 rbx
  0008a	e9 00 00 00 00	 jmp	 PyErr_Clear
$LN3@PyEval_ReI:

; 404  :         /* threading not imported */
; 405  :         PyErr_Clear();
; 406  :         return;
; 407  :     }
; 408  :     result = _PyObject_CallMethodId(threading, &PyId__after_fork, NULL);

  0008f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00095	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  0009e	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId__after_fork@?1??PyEval_ReInitThreads@@9@9
  000a3	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  000a7	45 33 c0	 xor	 r8d, r8d
  000aa	48 8b cb	 mov	 rcx, rbx
  000ad	e8 00 00 00 00	 call	 _PyObject_CallMethodId

; 409  :     if (result == NULL)

  000b2	48 85 c0	 test	 rax, rax
  000b5	75 15		 jne	 SHORT $LN2@PyEval_ReI

; 410  :         PyErr_WriteUnraisable(threading);

  000b7	48 8b cb	 mov	 rcx, rbx
  000ba	e8 00 00 00 00	 call	 PyErr_WriteUnraisable

; 413  :     Py_DECREF(threading);

  000bf	48 8b cb	 mov	 rcx, rbx

; 414  : }

  000c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c6	5b		 pop	 rbx
  000c7	e9 00 00 00 00	 jmp	 _Py_DecRef
$LN2@PyEval_ReI:

; 411  :     else
; 412  :         Py_DECREF(result);

  000cc	48 8b c8	 mov	 rcx, rax
  000cf	e8 00 00 00 00	 call	 _Py_DecRef

; 413  :     Py_DECREF(threading);

  000d4	48 8b cb	 mov	 rcx, rbx
  000d7	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@PyEval_ReI:

; 414  : }

  000dc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e0	5b		 pop	 rbx
  000e1	c3		 ret	 0
PyEval_ReInitThreads ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	Px_DecRef:PROC
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+159
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
op$ = 64
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 83 00 00
	00		 jne	 $LN1@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0001a	a8 20		 test	 al, 32			; 00000020H
  0001c	75 73		 jne	 SHORT $LN6@Py_DecRef
  0001e	84 c0		 test	 al, al
  00020	78 6f		 js	 SHORT $LN6@Py_DecRef

; 927  :         else if (!Px_ISPX(op)) {

  00022	a8 02		 test	 al, 2
  00024	75 73		 jne	 SHORT $LN1@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00026	e8 00 00 00 00	 call	 _Py_PXCTX
  0002b	85 c0		 test	 eax, eax
  0002d	75 07		 jne	 SHORT $LN12@Py_DecRef
  0002f	48 ff 0d 00 00
	00 00		 dec	 QWORD PTR _Py_RefTotal
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  00036	48 ff 4b 50	 dec	 QWORD PTR [rbx+80]
  0003a	74 48		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  0004a	4c 8b cb	 mov	 r9, rbx
  0004d	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  00053	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0005b	e8 00 00 00 00	 call	 _PyParallel_Guard
  00060	85 c0		 test	 eax, eax
  00062	75 35		 jne	 SHORT $LN1@Py_DecRef
  00064	48 83 7b 50 00	 cmp	 QWORD PTR [rbx+80], 0
  00069	7d 2e		 jge	 SHORT $LN1@Py_DecRef
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  00072	4c 8b c3	 mov	 r8, rbx
  00075	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H

; 933  :         }
; 934  :     }
; 935  : }

  0007a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007e	5b		 pop	 rbx
  0007f	e9 00 00 00 00	 jmp	 _Py_NegativeRefcount
$LN3@Py_DecRef:

; 931  :             } else
; 932  :                 _Py_Dealloc((PyObject *)(op));

  00084	48 8b cb	 mov	 rcx, rbx

; 933  :         }
; 934  :     }
; 935  : }

  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5b		 pop	 rbx
  0008c	e9 00 00 00 00	 jmp	 _Py_Dealloc
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  00091	48 8b cb	 mov	 rcx, rbx
  00094	e8 00 00 00 00	 call	 Px_DecRef
$LN1@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  00099	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009d	5b		 pop	 rbx
  0009e	c3		 ret	 0
_Py_DecRef ENDP
; Function compile flags: /Ogtp
; File c:\src\pyparallel\python\ceval_gil.h
_TEXT	ENDS
;	COMDAT recreate_gil
_TEXT	SEGMENT
recreate_gil PROC					; COMDAT

; 173  :     _Py_ANNOTATE_RWLOCK_DESTROY(&gil_locked);
; 174  :     /* XXX should we destroy the old OS resources here? */
; 175  :     create_gil();
; 176  : }

  00000	e9 00 00 00 00	 jmp	 create_gil
recreate_gil ENDP
; Function compile flags: /Ogtp
; File c:\src\pyparallel\python\ceval.c
_TEXT	ENDS
;	COMDAT _PyEval_SignalAsyncExc
_TEXT	SEGMENT
_PyEval_SignalAsyncExc PROC				; COMDAT

; 427  :     SIGNAL_ASYNC_EXC();

  00000	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR pending_async_exc, 1
  0000a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR eval_breaker, 1

; 428  : }

  00014	c3		 ret	 0
_PyEval_SignalAsyncExc ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@LBIOHLHB@PyEval_SaveThread?3?5NULL?5tstate?$AA@ ; `string'
PUBLIC	??_C@_1EA@JOGJDCFF@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAi?$AAs?$AA_?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@IOBEGALE@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_?$AAi?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAu?$AAr?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_@ ; `string'
PUBLIC	??_C@_1BO@MBEBCIGB@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@HHJCOJKH@?$AAt?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAi?$AAs?$AA_?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	PyEval_SaveThread
EXTRN	_PyParallel_BlockingCall:PROC
EXTRN	_PyParallel_GetThreadState:PROC
EXTRN	_PyParallel_GetCurrentThreadState:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_SaveThread DD imagerel $LN11
	DD	imagerel $LN11+308
	DD	imagerel $unwind$PyEval_SaveThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_SaveThread DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0BP@LBIOHLHB@PyEval_SaveThread?3?5NULL?5tstate?$AA@
CONST	SEGMENT
??_C@_0BP@LBIOHLHB@PyEval_SaveThread?3?5NULL?5tstate?$AA@ DB 'PyEval_Save'
	DB	'Thread: NULL tstate', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@JOGJDCFF@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAi?$AAs?$AA_?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@JOGJDCFF@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAi?$AAs?$AA_?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'p'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'i', 00H, 's', 00H, '_', 00H, 'p', 00H, 'a', 00H, 'r'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'l', 00H, '_', 00H
	DB	't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@IOBEGALE@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_?$AAi?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAu?$AAr?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_@
CONST	SEGMENT
??_C@_1EG@IOBEGALE@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_?$AAi?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAu?$AAr?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_@ DB 'p'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd'
	DB	00H, '_', 00H, 'i', 00H, 'd', 00H, ' ', 00H, '=', 00H, '=', 00H
	DB	' ', 00H, 'c', 00H, 'u', 00H, 'r', 00H, '_', 00H, 't', 00H, 'h'
	DB	00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, '_', 00H, 'i', 00H
	DB	'd', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MBEBCIGB@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MBEBCIGB@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'p'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@HHJCOJKH@?$AAt?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAi?$AAs?$AA_?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@HHJCOJKH@?$AAt?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAi?$AAs?$AA_?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 't'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, '-', 00H
	DB	'>', 00H, 'i', 00H, 's', 00H, '_', 00H, 'p', 00H, 'a', 00H, 'r'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'e', 00H, 'l', 00H, '_', 00H
	DB	't', 00H, 'h', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'd', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_SaveThread
_TEXT	SEGMENT
PyEval_SaveThread PROC					; COMDAT

; 440  : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 441  :     PyThreadState *tstate;
; 442  : #ifdef WITH_PARALLEL
; 443  :     PyThreadState *pstate;
; 444  :     long cur_thread_id = _Py_get_current_thread_id();

  0000f	65 8b 34 25 48
	00 00 00	 mov	 esi, DWORD PTR gs:72

; 445  :     tstate = _PyParallel_GetCurrentThreadState();

  00017	e8 00 00 00 00	 call	 _PyParallel_GetCurrentThreadState
  0001c	48 8b f8	 mov	 rdi, rax

; 446  :     /*tstate = (PyThreadState*)_Py_atomic_load_relaxed(&_PyThreadState_Current);*/
; 447  :     if (tstate->thread_id != cur_thread_id) {

  0001f	39 b0 90 00 00
	00		 cmp	 DWORD PTR [rax+144], esi
  00025	0f 84 a7 00 00
	00		 je	 $LN3@PyEval_Sav

; 448  :         /* Verify we've been called from a parallel thread. */
; 449  :         pstate = _PyParallel_GetThreadState();

  0002b	e8 00 00 00 00	 call	 _PyParallel_GetThreadState

; 450  :         assert(tstate->is_parallel_thread == 0);

  00030	83 bf a8 00 00
	00 00		 cmp	 DWORD PTR [rdi+168], 0
  00037	48 8b d8	 mov	 rbx, rax
  0003a	74 1a		 je	 SHORT $LN6@PyEval_Sav
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@HHJCOJKH@?$AAt?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAi?$AAs?$AA_?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0004a	41 b8 c2 01 00
	00		 mov	 r8d, 450		; 000001c2H
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN6@PyEval_Sav:

; 451  :         assert(pstate != NULL);

  00056	48 85 db	 test	 rbx, rbx
  00059	75 1a		 jne	 SHORT $LN7@PyEval_Sav
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@MBEBCIGB@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00069	41 b8 c3 01 00
	00		 mov	 r8d, 451		; 000001c3H
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN7@PyEval_Sav:

; 452  :         assert(pstate->thread_id == cur_thread_id);

  00075	39 b3 90 00 00
	00		 cmp	 DWORD PTR [rbx+144], esi
  0007b	74 1a		 je	 SHORT $LN8@PyEval_Sav
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@IOBEGALE@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_?$AAi?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAc?$AAu?$AAr?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA_@
  0008b	41 b8 c4 01 00
	00		 mov	 r8d, 452		; 000001c4H
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN8@PyEval_Sav:

; 453  :         assert(pstate->is_parallel_thread == 1);

  00097	83 bb a8 00 00
	00 01		 cmp	 DWORD PTR [rbx+168], 1
  0009e	74 1a		 je	 SHORT $LN9@PyEval_Sav
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@JOGJDCFF@?$AAp?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAi?$AAs?$AA_?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  000ae	41 b8 c5 01 00
	00		 mov	 r8d, 453		; 000001c5H
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN9@PyEval_Sav:

; 454  :         _PyParallel_BlockingCall();

  000ba	e8 00 00 00 00	 call	 _PyParallel_BlockingCall

; 465  : #endif
; 466  :     return tstate;

  000bf	48 8b c3	 mov	 rax, rbx

; 467  : }

  000c2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c7	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d0	5f		 pop	 rdi
  000d1	c3		 ret	 0
$LN3@PyEval_Sav:

; 455  :         return pstate;
; 456  :     }
; 457  :     assert(tstate->is_parallel_thread == 0);

  000d2	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [rax+168], 0
  000d9	74 1a		 je	 SHORT $LN10@PyEval_Sav
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@HHJCOJKH@?$AAt?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?9?$AA?$DO?$AAi?$AAs?$AA_?$AAp?$AAa?$AAr?$AAa?$AAl?$AAl?$AAe?$AAl?$AA_?$AAt?$AAh?$AAr?$AAe?$AAa?$AAd?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  000e9	41 b8 c9 01 00
	00		 mov	 r8d, 457		; 000001c9H
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN10@PyEval_Sav:

; 458  : #endif
; 459  :     tstate = PyThreadState_Swap(NULL);

  000f5	33 c9		 xor	 ecx, ecx
  000f7	e8 00 00 00 00	 call	 PyThreadState_Swap
  000fc	48 8b d8	 mov	 rbx, rax

; 460  :     if (tstate == NULL)

  000ff	48 85 c0	 test	 rax, rax
  00102	75 0c		 jne	 SHORT $LN2@PyEval_Sav

; 461  :         Py_FatalError("PyEval_SaveThread: NULL tstate");

  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@LBIOHLHB@PyEval_SaveThread?3?5NULL?5tstate?$AA@
  0010b	e8 00 00 00 00	 call	 Py_FatalError
$LN2@PyEval_Sav:

; 462  : #ifdef WITH_THREAD
; 463  :     if (gil_created())

  00110	e8 00 00 00 00	 call	 gil_created
  00115	85 c0		 test	 eax, eax
  00117	74 08		 je	 SHORT $LN1@PyEval_Sav

; 464  :         drop_gil(tstate);

  00119	48 8b cb	 mov	 rcx, rbx
  0011c	e8 00 00 00 00	 call	 drop_gil
$LN1@PyEval_Sav:

; 467  : }

  00121	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00126	48 8b c3	 mov	 rax, rbx
  00129	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0012e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00132	5f		 pop	 rdi
  00133	c3		 ret	 0
PyEval_SaveThread ENDP
_TEXT	ENDS
PUBLIC	??_C@_13COJANIEC@?$AA0?$AA?$AA@			; `string'
PUBLIC	??_C@_0CC@FHDJCMNN@PyEval_RestoreThread?3?5NULL?5tstat@ ; `string'
PUBLIC	PyEval_RestoreThread
EXTRN	PyThread_exit_thread:PROC
EXTRN	_Py_Finalizing:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_RestoreThread DD imagerel $LN8
	DD	imagerel $LN8+44
	DD	imagerel $unwind$PyEval_RestoreThread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyEval_RestoreThread DD imagerel $LN8+44
	DD	imagerel $LN8+134
	DD	imagerel $chain$0$PyEval_RestoreThread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyEval_RestoreThread DD imagerel $LN8+134
	DD	imagerel $LN8+148
	DD	imagerel $chain$1$PyEval_RestoreThread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyEval_RestoreThread DD 021H
	DD	imagerel $LN8
	DD	imagerel $LN8+44
	DD	imagerel $unwind$PyEval_RestoreThread
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyEval_RestoreThread DD 020521H
	DD	067405H
	DD	imagerel $LN8
	DD	imagerel $LN8+44
	DD	imagerel $unwind$PyEval_RestoreThread
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_RestoreThread DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_13COJANIEC@?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_13COJANIEC@?$AA0?$AA?$AA@ DB '0', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@FHDJCMNN@PyEval_RestoreThread?3?5NULL?5tstat@
CONST	SEGMENT
??_C@_0CC@FHDJCMNN@PyEval_RestoreThread?3?5NULL?5tstat@ DB 'PyEval_Restor'
	DB	'eThread: NULL tstate', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_RestoreThread
_TEXT	SEGMENT
tstate$ = 48
PyEval_RestoreThread PROC				; COMDAT

; 471  : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 472  :     if (tstate == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0c		 jne	 SHORT $LN4@PyEval_Res

; 473  :         Py_FatalError("PyEval_RestoreThread: NULL tstate");

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@FHDJCMNN@PyEval_RestoreThread?3?5NULL?5tstat@
  00015	e8 00 00 00 00	 call	 Py_FatalError
$LN4@PyEval_Res:

; 474  : #ifdef WITH_PARALLEL
; 475  :     /* Ensure this is a no-op when called from a parallel context thread. */
; 476  :     if (tstate->is_parallel_thread == 1)

  0001a	83 bb a8 00 00
	00 01		 cmp	 DWORD PTR [rbx+168], 1
  00021	74 6b		 je	 SHORT $LN5@PyEval_Res

; 477  :         return;
; 478  : #endif
; 479  : #ifdef WITH_THREAD
; 480  :     if (gil_created()) {

  00023	e8 00 00 00 00	 call	 gil_created
  00028	85 c0		 test	 eax, eax
  0002a	74 5a		 je	 SHORT $LN2@PyEval_Res

; 481  :         int err = errno;

  0002c	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno

; 482  :         take_gil(tstate);

  00037	48 8b cb	 mov	 rcx, rbx
  0003a	8b 38		 mov	 edi, DWORD PTR [rax]
  0003c	e8 00 00 00 00	 call	 take_gil

; 483  :         /* _Py_Finalizing is protected by the GIL */
; 484  :         if (_Py_Finalizing && tstate != _Py_Finalizing) {

  00041	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR _Py_Finalizing
  00048	4d 85 db	 test	 r11, r11
  0004b	74 2c		 je	 SHORT $LN7@PyEval_Res
  0004d	49 3b db	 cmp	 rbx, r11
  00050	74 27		 je	 SHORT $LN7@PyEval_Res

; 485  :             drop_gil(tstate);

  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 drop_gil

; 486  :             PyThread_exit_thread();

  0005a	e8 00 00 00 00	 call	 PyThread_exit_thread

; 487  :             assert(0);  /* unreachable */

  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_13COJANIEC@?$AA0?$AA?$AA@
  0006d	41 b8 e7 01 00
	00		 mov	 r8d, 487		; 000001e7H
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN7@PyEval_Res:

; 488  :         }
; 489  :         errno = err;

  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0007f	89 38		 mov	 DWORD PTR [rax], edi
  00081	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN2@PyEval_Res:

; 490  :     }
; 491  : #endif
; 492  :     PyThreadState_Swap(tstate);

  00086	48 8b cb	 mov	 rcx, rbx
  00089	e8 00 00 00 00	 call	 PyThreadState_Swap
$LN5@PyEval_Res:

; 493  : }

  0008e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00092	5b		 pop	 rbx
  00093	c3		 ret	 0
PyEval_RestoreThread ENDP
_TEXT	ENDS
PUBLIC	Py_AddPendingCall
EXTRN	PyThread_release_lock:PROC
EXTRN	PyThread_acquire_lock:PROC
_BSS	SEGMENT
pendingcalls DB	0200H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_AddPendingCall DD imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$Py_AddPendingCall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$Py_AddPendingCall DD imagerel $LN19+41
	DD	imagerel $LN19+79
	DD	imagerel $chain$0$Py_AddPendingCall
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$Py_AddPendingCall DD imagerel $LN19+79
	DD	imagerel $LN19+206
	DD	imagerel $chain$1$Py_AddPendingCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$Py_AddPendingCall DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$Py_AddPendingCall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$Py_AddPendingCall DD 020521H
	DD	063405H
	DD	imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$Py_AddPendingCall
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_AddPendingCall DD 081501H
	DD	097415H
	DD	086415H
	DD	075415H
	DD	0c0113215H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT Py_AddPendingCall
_TEXT	SEGMENT
func$ = 48
arg$ = 56
Py_AddPendingCall PROC					; COMDAT

; 537  : {

$LN19:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 54		 push	 r12
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 538  :     int i, j, result=0;
; 539  :     PyThread_type_lock lock = pending_lock;

  00015	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR pending_lock
  0001c	33 ff		 xor	 edi, edi
  0001e	48 8b ea	 mov	 rbp, rdx
  00021	4c 8b e1	 mov	 r12, rcx

; 540  : 
; 541  :     /* try a few times for the lock.  Since this mechanism is used
; 542  :      * for signal handling (on the main thread), there is a (slim)
; 543  :      * chance that a signal is delivered on the same thread while we
; 544  :      * hold the lock during the Py_MakePendingCalls() function.
; 545  :      * This avoids a deadlock in that case.
; 546  :      * Note that signals can be delivered on any thread.  In particular,
; 547  :      * on Windows, a SIGINT is delivered on a system-created worker
; 548  :      * thread.
; 549  :      * We also check for lock being NULL, in the unlikely case that
; 550  :      * this function is called before any bytecode evaluation takes place.
; 551  :      */
; 552  :     if (lock != NULL) {

  00024	48 85 f6	 test	 rsi, rsi
  00027	74 2b		 je	 SHORT $LN7@Py_AddPend

; 553  :         for (i = 0; i<100; i++) {

  00029	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002e	8b df		 mov	 ebx, edi
$LL11@Py_AddPend:

; 554  :             if (PyThread_acquire_lock(lock, NOWAIT_LOCK))

  00030	33 d2		 xor	 edx, edx
  00032	48 8b ce	 mov	 rcx, rsi
  00035	e8 00 00 00 00	 call	 PyThread_acquire_lock
  0003a	85 c0		 test	 eax, eax
  0003c	75 07		 jne	 SHORT $LN16@Py_AddPend

; 553  :         for (i = 0; i<100; i++) {

  0003e	ff c3		 inc	 ebx
  00040	83 fb 64	 cmp	 ebx, 100		; 00000064H
  00043	7c eb		 jl	 SHORT $LL11@Py_AddPend
$LN16@Py_AddPend:

; 555  :                 break;
; 556  :         }
; 557  :         if (i == 100)

  00045	83 fb 64	 cmp	 ebx, 100		; 00000064H
  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	75 05		 jne	 SHORT $LN7@Py_AddPend

; 558  :             return -1;

  0004f	83 c8 ff	 or	 eax, -1
  00052	eb 64		 jmp	 SHORT $LN13@Py_AddPend
$LN7@Py_AddPend:

; 559  :     }
; 560  : 
; 561  :     i = pendinglast;
; 562  :     j = (i + 1) % NPENDINGCALLS;

  00054	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR pendinglast
  0005b	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  0005e	25 1f 00 00 80	 and	 eax, -2147483617	; ffffffff8000001fH
  00063	7d 07		 jge	 SHORT $LN18@Py_AddPend
  00065	ff c8		 dec	 eax
  00067	83 c8 e0	 or	 eax, -32		; ffffffffffffffe0H
  0006a	ff c0		 inc	 eax
$LN18@Py_AddPend:

; 563  :     if (j == pendingfirst) {

  0006c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR pendingfirst
  00072	75 05		 jne	 SHORT $LN6@Py_AddPend

; 564  :         result = -1; /* Queue full */

  00074	83 cf ff	 or	 edi, -1

; 565  :     } else {

  00077	eb 1c		 jmp	 SHORT $LN4@Py_AddPend
$LN6@Py_AddPend:

; 566  :         pendingcalls[i].func = func;

  00079	48 8b d1	 mov	 rdx, rcx
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pendingcalls

; 567  :         pendingcalls[i].arg = arg;
; 568  :         pendinglast = j;

  00083	89 05 00 00 00
	00		 mov	 DWORD PTR pendinglast, eax
  00089	48 03 d2	 add	 rdx, rdx
  0008c	4c 89 24 d1	 mov	 QWORD PTR [rcx+rdx*8], r12
  00090	48 89 6c d1 08	 mov	 QWORD PTR [rcx+rdx*8+8], rbp
$LN4@Py_AddPend:

; 569  :     }
; 570  :     /* signal main loop */
; 571  :     SIGNAL_PENDING_CALLS();

  00095	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR pendingcalls_to_do, 1
  0009f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR eval_breaker, 1

; 572  :     if (lock != NULL)

  000a9	48 85 f6	 test	 rsi, rsi
  000ac	74 08		 je	 SHORT $LN1@Py_AddPend

; 573  :         PyThread_release_lock(lock);

  000ae	48 8b ce	 mov	 rcx, rsi
  000b1	e8 00 00 00 00	 call	 PyThread_release_lock
$LN1@Py_AddPend:

; 574  :     return result;

  000b6	8b c7		 mov	 eax, edi
$LN13@Py_AddPend:

; 575  : }

  000b8	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000bd	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000c2	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000c7	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cb	41 5c		 pop	 r12
  000cd	c3		 ret	 0
Py_AddPendingCall ENDP
_TEXT	ENDS
PUBLIC	Py_MakePendingCalls
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_MakePendingCalls DD imagerel $LN32
	DD	imagerel $LN32+364
	DD	imagerel $unwind$Py_MakePendingCalls
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_MakePendingCalls DD 0b7801H
	DD	04d478H
	DD	0a7473H
	DD	09546eH
	DD	083469H
	DD	0c0044208H
	DD	06002H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT Py_MakePendingCalls
_TEXT	SEGMENT
Py_MakePendingCalls PROC				; COMDAT

; 579  : {

$LN32:
  00000	40 56		 push	 rsi
  00002	41 54		 push	 r12
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 580  :     static int busy = 0;
; 581  :     int i;
; 582  :     int r = 0;
; 583  : 
; 584  :     if (!pending_lock) {

  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pending_lock
  0000f	45 33 e4	 xor	 r12d, r12d
  00012	41 8b f4	 mov	 esi, r12d
  00015	48 85 c0	 test	 rax, rax
  00018	75 1c		 jne	 SHORT $LN18@Py_MakePen

; 585  :         /* initial allocation of the lock */
; 586  :         pending_lock = PyThread_allocate_lock();

  0001a	e8 00 00 00 00	 call	 PyThread_allocate_lock
  0001f	48 89 05 00 00
	00 00		 mov	 QWORD PTR pending_lock, rax

; 587  :         if (pending_lock == NULL)

  00026	48 85 c0	 test	 rax, rax
  00029	75 0b		 jne	 SHORT $LN18@Py_MakePen

; 588  :             return -1;

  0002b	83 c8 ff	 or	 eax, -1

; 628  : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	41 5c		 pop	 r12
  00034	5e		 pop	 rsi
  00035	c3		 ret	 0
$LN18@Py_MakePen:

; 589  :     }
; 590  : 
; 591  :     /* only service pending calls on main thread */
; 592  :     if (main_thread && PyThread_get_thread_ident() != main_thread)

  00036	39 35 00 00 00
	00		 cmp	 DWORD PTR main_thread, esi
  0003c	74 1e		 je	 SHORT $LN17@Py_MakePen
  0003e	e8 00 00 00 00	 call	 PyThread_get_thread_ident
  00043	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR main_thread
  00049	74 0a		 je	 SHORT $LN27@Py_MakePen
$LN31@Py_MakePen:

; 593  :         return 0;

  0004b	33 c0		 xor	 eax, eax

; 628  : }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	41 5c		 pop	 r12
  00053	5e		 pop	 rsi
  00054	c3		 ret	 0
$LN27@Py_MakePen:

; 593  :         return 0;

  00055	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pending_lock
$LN17@Py_MakePen:

; 594  :     /* don't perform recursive pending calls */
; 595  :     if (busy)

  0005c	39 35 00 00 00
	00		 cmp	 DWORD PTR ?busy@?1??Py_MakePendingCalls@@9@9, esi

; 596  :         return 0;

  00062	75 e7		 jne	 SHORT $LN31@Py_MakePen

; 597  :     busy = 1;

  00064	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00069	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0006e	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00073	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00078	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?busy@?1??Py_MakePendingCalls@@9@9, 1

; 598  :     /* perform a bounded number of calls, in case of recursion */
; 599  :     for (i=0; i<NPENDINGCALLS; i++) {

  00082	41 8b dc	 mov	 ebx, r12d
  00085	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:pendingcalls
  0008c	0f 1f 40 00	 npad	 4
$LL15@Py_MakePen:

; 600  :         int j;
; 601  :         int (*func)(void *);
; 602  :         void *arg = NULL;
; 603  : 
; 604  :         /* pop one item off the queue while holding the lock */
; 605  :         PyThread_acquire_lock(pending_lock, WAIT_LOCK);

  00090	ba 01 00 00 00	 mov	 edx, 1
  00095	48 8b c8	 mov	 rcx, rax
  00098	49 8b ec	 mov	 rbp, r12
  0009b	e8 00 00 00 00	 call	 PyThread_acquire_lock

; 606  :         j = pendingfirst;
; 607  :         if (j == pendinglast) {

  000a0	4c 63 1d 00 00
	00 00		 movsxd	 r11, DWORD PTR pendingfirst
  000a7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR pendinglast
  000ad	44 3b d9	 cmp	 r11d, ecx
  000b0	75 05		 jne	 SHORT $LN12@Py_MakePen

; 608  :             func = NULL; /* Queue empty */

  000b2	49 8b fc	 mov	 rdi, r12

; 609  :         } else {

  000b5	eb 2d		 jmp	 SHORT $LN11@Py_MakePen
$LN12@Py_MakePen:

; 610  :             func = pendingcalls[j].func;

  000b7	49 8b c3	 mov	 rax, r11
  000ba	48 03 c0	 add	 rax, rax

; 611  :             arg = pendingcalls[j].arg;
; 612  :             pendingfirst = (j + 1) % NPENDINGCALLS;

  000bd	41 ff c3	 inc	 r11d
  000c0	41 81 e3 1f 00
	00 80		 and	 r11d, -2147483617	; ffffffff8000001fH
  000c7	49 8b 7c c5 00	 mov	 rdi, QWORD PTR [r13+rax*8]
  000cc	49 8b 6c c5 08	 mov	 rbp, QWORD PTR [r13+rax*8+8]
  000d1	7d 0a		 jge	 SHORT $LN26@Py_MakePen
  000d3	41 ff cb	 dec	 r11d
  000d6	41 83 cb e0	 or	 r11d, -32		; ffffffffffffffe0H
  000da	41 ff c3	 inc	 r11d
$LN26@Py_MakePen:
  000dd	44 89 1d 00 00
	00 00		 mov	 DWORD PTR pendingfirst, r11d
$LN11@Py_MakePen:

; 613  :         }
; 614  :         if (pendingfirst != pendinglast)

  000e4	44 3b d9	 cmp	 r11d, ecx
  000e7	74 16		 je	 SHORT $LN5@Py_MakePen

; 615  :             SIGNAL_PENDING_CALLS();

  000e9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR pendingcalls_to_do, 1
  000f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR eval_breaker, 1

; 616  :         else

  000fd	eb 19		 jmp	 SHORT $LN3@Py_MakePen
$LN5@Py_MakePen:

; 617  :             UNSIGNAL_PENDING_CALLS();

  000ff	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pending_async_exc
  00105	44 89 25 00 00
	00 00		 mov	 DWORD PTR pendingcalls_to_do, r12d
  0010c	0b 05 00 00 00
	00		 or	 eax, DWORD PTR gil_drop_request
  00112	89 05 00 00 00
	00		 mov	 DWORD PTR eval_breaker, eax
$LN3@Py_MakePen:

; 618  :         PyThread_release_lock(pending_lock);

  00118	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pending_lock
  0011f	e8 00 00 00 00	 call	 PyThread_release_lock

; 619  :         /* having released the lock, perform the callback */
; 620  :         if (func == NULL)

  00124	48 85 ff	 test	 rdi, rdi
  00127	74 1e		 je	 SHORT $LN30@Py_MakePen

; 621  :             break;
; 622  :         r = func(arg);

  00129	48 8b cd	 mov	 rcx, rbp
  0012c	ff d7		 call	 rdi
  0012e	8b f0		 mov	 esi, eax

; 623  :         if (r)

  00130	85 c0		 test	 eax, eax
  00132	75 13		 jne	 SHORT $LN30@Py_MakePen

; 598  :     /* perform a bounded number of calls, in case of recursion */
; 599  :     for (i=0; i<NPENDINGCALLS; i++) {

  00134	ff c3		 inc	 ebx
  00136	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00139	7d 0c		 jge	 SHORT $LN30@Py_MakePen
  0013b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pending_lock
  00142	e9 49 ff ff ff	 jmp	 $LL15@Py_MakePen
$LN30@Py_MakePen:
  00147	4c 8b 6c 24 20	 mov	 r13, QWORD PTR [rsp+32]
  0014c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  00151	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00156	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 624  :             break;
; 625  :     }
; 626  :     busy = 0;

  0015b	44 89 25 00 00
	00 00		 mov	 DWORD PTR ?busy@?1??Py_MakePendingCalls@@9@9, r12d

; 627  :     return r;

  00162	8b c6		 mov	 eax, esi

; 628  : }

  00164	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00168	41 5c		 pop	 r12
  0016a	5e		 pop	 rsi
  0016b	c3		 ret	 0
Py_MakePendingCalls ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@GNEIIDJD@Py_GetRecursionLimit?$AA@	; `string'
PUBLIC	Py_GetRecursionLimit
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_GetRecursionLimit DD imagerel $LN5
	DD	imagerel $LN5+52
	DD	imagerel $unwind$Py_GetRecursionLimit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_GetRecursionLimit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0BF@GNEIIDJD@Py_GetRecursionLimit?$AA@
CONST	SEGMENT
??_C@_0BF@GNEIIDJD@Py_GetRecursionLimit?$AA@ DB 'Py_GetRecursionLimit', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT Py_GetRecursionLimit
_TEXT	SEGMENT
Py_GetRecursionLimit PROC				; COMDAT

; 731  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 732  :     Py_GUARD

  00004	e8 00 00 00 00	 call	 _Py_PXCTX
  00009	85 c0		 test	 eax, eax
  0000b	74 1c		 je	 SHORT $LN4@Py_GetRecu
  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@GNEIIDJD@Py_GetRecursionLimit?$AA@
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	41 b8 dc 02 00
	00		 mov	 r8d, 732		; 000002dcH
  00024	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN4@Py_GetRecu:

; 733  :     return recursion_limit;

  00029	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR recursion_limit

; 734  : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
Py_GetRecursionLimit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@EIEDAIIN@Py_SetRecursionLimit?$AA@	; `string'
PUBLIC	Py_SetRecursionLimit
;	COMDAT pdata
pdata	SEGMENT
$pdata$Py_SetRecursionLimit DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$Py_SetRecursionLimit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$Py_SetRecursionLimit DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0BF@EIEDAIIN@Py_SetRecursionLimit?$AA@
CONST	SEGMENT
??_C@_0BF@EIEDAIIN@Py_SetRecursionLimit?$AA@ DB 'Py_SetRecursionLimit', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT Py_SetRecursionLimit
_TEXT	SEGMENT
new_limit$ = 48
Py_SetRecursionLimit PROC				; COMDAT

; 738  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b d9		 mov	 ebx, ecx

; 739  :     Py_GUARD

  00008	e8 00 00 00 00	 call	 _Py_PXCTX
  0000d	85 c0		 test	 eax, eax
  0000f	74 1c		 je	 SHORT $LN4@Py_SetRecu
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@EIEDAIIN@Py_SetRecursionLimit?$AA@
  0001f	45 33 c9	 xor	 r9d, r9d
  00022	41 b8 e3 02 00
	00		 mov	 r8d, 739		; 000002e3H
  00028	e8 00 00 00 00	 call	 _PyParallel_ContextGuardFailure
$LN4@Py_SetRecu:

; 741  :     _Py_CheckRecursionLimit = recursion_limit;

  0002d	89 1d 00 00 00
	00		 mov	 DWORD PTR _Py_CheckRecursionLimit, ebx

; 740  :     recursion_limit = new_limit;

  00033	89 1d 00 00 00
	00		 mov	 DWORD PTR recursion_limit, ebx

; 742  : }

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
Py_SetRecursionLimit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@IHJCMPCG@maximum?5recursion?5depth?5exceeded@ ; `string'
PUBLIC	??_C@_0CE@GAIPFPA@Cannot?5recover?5from?5stack?5overfl@ ; `string'
PUBLIC	_Py_CheckRecursiveCall
EXTRN	PyErr_Format:PROC
EXTRN	PyExc_RuntimeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_CheckRecursiveCall DD imagerel $LN7
	DD	imagerel $LN7+123
	DD	imagerel $unwind$_Py_CheckRecursiveCall
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_CheckRecursiveCall DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_0CD@IHJCMPCG@maximum?5recursion?5depth?5exceeded@
CONST	SEGMENT
??_C@_0CD@IHJCMPCG@maximum?5recursion?5depth?5exceeded@ DB 'maximum recur'
	DB	'sion depth exceeded%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GAIPFPA@Cannot?5recover?5from?5stack?5overfl@
CONST	SEGMENT
??_C@_0CE@GAIPFPA@Cannot?5recover?5from?5stack?5overfl@ DB 'Cannot recove'
	DB	'r from stack overflow.', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _Py_CheckRecursiveCall
_TEXT	SEGMENT
where$ = 48
_Py_CheckRecursiveCall PROC				; COMDAT

; 751  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 752  :     PyThreadState *tstate = PyThreadState_GET();

  00009	e8 00 00 00 00	 call	 PyThreadState_Get
  0000e	4c 8b d8	 mov	 r11, rax

; 753  : 
; 754  : #ifdef USE_STACKCHECK
; 755  :     if (PyOS_CheckStack()) {
; 756  :         --tstate->recursion_depth;
; 757  :         PyErr_SetString(PyExc_MemoryError, "Stack overflow");
; 758  :         return -1;
; 759  :     }
; 760  : #endif
; 761  :     _Py_CheckRecursionLimit = recursion_limit;

  00011	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR recursion_limit
  00017	89 05 00 00 00
	00		 mov	 DWORD PTR _Py_CheckRecursionLimit, eax

; 762  :     if (tstate->recursion_critical)

  0001d	41 80 7b 1d 00	 cmp	 BYTE PTR [r11+29], 0

; 763  :         /* Somebody asked that we don't check for recursion. */
; 764  :         return 0;

  00022	75 1c		 jne	 SHORT $LN1@Py_CheckRe

; 765  :     if (tstate->overflowed) {

  00024	41 80 7b 1c 00	 cmp	 BYTE PTR [r11+28], 0
  00029	74 1d		 je	 SHORT $LN3@Py_CheckRe

; 766  :         if (tstate->recursion_depth > recursion_limit + 50) {

  0002b	83 c0 32	 add	 eax, 50			; 00000032H
  0002e	41 39 43 18	 cmp	 DWORD PTR [r11+24], eax
  00032	7e 0c		 jle	 SHORT $LN1@Py_CheckRe

; 767  :             /* Overflowing while handling an overflow. Give up. */
; 768  :             Py_FatalError("Cannot recover from stack overflow.");

  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@GAIPFPA@Cannot?5recover?5from?5stack?5overfl@
  0003b	e8 00 00 00 00	 call	 Py_FatalError
$LN1@Py_CheckRe:

; 779  :     }
; 780  :     return 0;

  00040	33 c0		 xor	 eax, eax

; 781  : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
$LN3@Py_CheckRe:

; 769  :         }
; 770  :         return 0;
; 771  :     }
; 772  :     if (tstate->recursion_depth > recursion_limit) {

  00048	41 8b 4b 18	 mov	 ecx, DWORD PTR [r11+24]
  0004c	3b c8		 cmp	 ecx, eax
  0004e	7e f0		 jle	 SHORT $LN1@Py_CheckRe

; 773  :         --tstate->recursion_depth;

  00050	8d 41 ff	 lea	 eax, DWORD PTR [rcx-1]

; 774  :         tstate->overflowed = 1;

  00053	41 c6 43 1c 01	 mov	 BYTE PTR [r11+28], 1

; 775  :         PyErr_Format(PyExc_RuntimeError,
; 776  :                      "maximum recursion depth exceeded%s",
; 777  :                      where);

  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@IHJCMPCG@maximum?5recursion?5depth?5exceeded@
  0005f	41 89 43 18	 mov	 DWORD PTR [r11+24], eax
  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0006a	4c 8b c3	 mov	 r8, rbx
  0006d	e8 00 00 00 00	 call	 PyErr_Format

; 778  :         return -1;

  00072	83 c8 ff	 or	 eax, -1

; 781  : }

  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
_Py_CheckRecursiveCall ENDP
_TEXT	ENDS
PUBLIC	PyEval_EvalCodeEx
PUBLIC	PyEval_EvalCode
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_EvalCode DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$PyEval_EvalCode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_EvalCode DD 010401H
	DD	0c204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyEval_EvalCode
_TEXT	SEGMENT
co$ = 112
globals$ = 120
locals$ = 128
PyEval_EvalCode PROC					; COMDAT

; 812  : {

$LN3:
  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 813  :     return PyEval_EvalCodeEx(co,
; 814  :                       globals, locals,
; 815  :                       (PyObject **)NULL, 0,
; 816  :                       (PyObject **)NULL, 0,
; 817  :                       (PyObject **)NULL, 0,
; 818  :                       NULL, NULL);

  00004	33 c0		 xor	 eax, eax
  00006	45 33 c9	 xor	 r9d, r9d
  00009	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0000e	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00013	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00017	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0001c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00020	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00025	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00029	e8 00 00 00 00	 call	 PyEval_EvalCodeEx

; 819  : }

  0002e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00032	c3		 ret	 0
PyEval_EvalCode ENDP
_TEXT	ENDS
PUBLIC	PyEval_EvalFrameEx
PUBLIC	PyEval_EvalFrame
; Function compile flags: /Ogtp
;	COMDAT PyEval_EvalFrame
_TEXT	SEGMENT
f$ = 8
PyEval_EvalFrame PROC					; COMDAT

; 826  :     /* This is for backward compatibility with extension modules that
; 827  :        used this API; core interpreter code should call
; 828  :        PyEval_EvalFrameEx() */
; 829  :     return PyEval_EvalFrameEx(f, 0);

  00000	33 d2		 xor	 edx, edx

; 830  : }

  00002	e9 00 00 00 00	 jmp	 PyEval_EvalFrameEx
PyEval_EvalFrame ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@INLLMHPI@PyEval_EvalFrameEx?$AA@	; `string'
PUBLIC	??_C@_0P@FENJHLBJ@unknown?5opcode?$AA@		; `string'
PUBLIC	??_C@_0BM@FPIMIFGH@XXX?5lineno?3?5?$CFd?0?5opcode?3?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0CL@HKNINBON@Stack?5unwind?5with?5exception?5set?5@ ; `string'
PUBLIC	??_C@_1DK@INACIJOP@?$AAn?$AAu?$AAm?$AA_?$AAa?$AAn?$AAn?$AAo?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAa?$AAm?$AAe?$AA_?$AAi?$AAx?$AA?$CL?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BN@BEHPHFBL@?8finally?8?5pops?5bad?5exception?$AA@ ; `string'
PUBLIC	??_C@_1DI@OCKJHPNN@?$AAb?$AA?9?$AA?$DO?$AAb?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAE?$AAX?$AAC?$AAE?$AAP?$AAT?$AA_?$AAH?$AAA?$AAN?$AAD?$AAL?$AAE?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@MGKPFLIA@?$AAw?$AAh?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAW?$AAH?$AAY?$AA_?$AAY?$AAI?$AAE?$AAL?$AAD?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@DJBOEJIH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAE?$AAX?$AAC?$AAE?$AAP?$AAT?$AA_?$AAH?$AAA?$AAN?$AAD?$AAL?$AAE?$AAR?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CC@NAHFDGJN@no?5locals?5found?5during?5?8import?5?$CK@ ; `string'
PUBLIC	??_C@_0BF@FMMPICPA@__import__?5not?5found?$AA@	; `string'
PUBLIC	??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@ ; `string'
PUBLIC	??_C@_1CK@CFBAFFEI@?$AAP?$AAy?$AAD?$AAi?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BK@BEKKDKAN@no?5locals?5when?5loading?5?$CFR?$AA@ ; `string'
PUBLIC	??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@ ; `string'
PUBLIC	??_C@_0BL@HJKLBJNK@no?5locals?5when?5deleting?5?$CFR?$AA@ ; `string'
PUBLIC	??_C@_0BN@DBLGJMNF@name?5?8?$CF?4200s?8?5is?5not?5defined?$AA@ ; `string'
PUBLIC	??_C@_0CA@PHPKHPGD@no?5locals?5found?5when?5storing?5?$CFR?$AA@ ; `string'
PUBLIC	??_C@_0BK@IAGNFEAN@__build_class__?5not?5found?$AA@ ; `string'
PUBLIC	??_C@_1EE@OJMEFFAL@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?$CI?$AAb?$AA?$CJ?$AA?9?$AA?$DO?$AAb?$AA_?$AAl?$AAe?$AAv?$AAe?$AAl?$AA?5?$AA?$CL?$AA?5@ ; `string'
PUBLIC	??_C@_0CG@CDCIJBNO@popped?5block?5is?5not?5an?5except?5ha@ ; `string'
PUBLIC	??_C@_01MJMHLOMK@O?$AA@				; `string'
PUBLIC	??_C@_0BI@INLFGEHA@bad?5RAISE_VARARGS?5oparg?$AA@ ; `string'
PUBLIC	PyEval_CallObjectWithKeywords
PUBLIC	??_C@_0BF@LDJCNLPE@lost?5sys?4displayhook?$AA@	; `string'
PUBLIC	??_C@_0M@OABHHABA@displayhook?$AA@		; `string'
PUBLIC	??_C@_0CD@PEFHABHC@error?5return?5without?5exception?5s@ ; `string'
PUBLIC	??_C@_0BG@BGJGOEKO@XXX?5undetected?5error?6?$AA@ ; `string'
PUBLIC	??_C@_0DF@HKMDOJCI@local?5variable?5?8?$CF?4200s?8?5referenc@ ; `string'
PUBLIC	??_C@_08OGNHIHGF@stackadj?$AA@			; `string'
PUBLIC	??_C@_03NJDAHFJE@pop?$AA@			; `string'
PUBLIC	??_C@_04GHHNIPCF@push?$AA@			; `string'
PUBLIC	??_C@_07BCEPPLOH@?$CFd?3?5?$CFd?6?$AA@		; `string'
PUBLIC	??_C@_0M@EEIINKGH@?$CFd?3?5?$CFd?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@OIDPILMB@ceval?3?5orphan?5tstate?$AA@	; `string'
PUBLIC	??_C@_0BF@FFPEPKAJ@ceval?3?5tstate?5mix?9up?$AA@ ; `string'
PUBLIC	??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@ ; `string'
PUBLIC	??_C@_1EC@PPDGCIBF@?$AAs?$AAt?$AAa?$AAc?$AAk?$AA_?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAf?$AA?9?$AA?$DO?$AAf?$AA_?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AAt?$AAa?$AAc?$AAk@ ; `string'
PUBLIC	??_C@_1CM@OHHBDEIG@?$AAs?$AAt?$AAa?$AAc?$AAk?$AA_?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@LNBMNGOB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
EXTRN	PyException_SetTraceback:PROC
EXTRN	PyErr_NormalizeException:PROC
EXTRN	PyErr_Fetch:PROC
EXTRN	PyFrame_GetLineNumber:PROC
EXTRN	PyTraceBack_Here:PROC
EXTRN	__imp_sprintf:PROC
EXTRN	PySlice_New:PROC
EXTRN	PyFunction_SetKwDefaults:PROC
EXTRN	PyFunction_SetDefaults:PROC
EXTRN	PyFunction_SetAnnotations:PROC
EXTRN	PyTuple_Size:PROC
EXTRN	PyDict_New:PROC
EXTRN	PyFunction_SetClosure:PROC
EXTRN	PyFunction_NewWithQualName:PROC
EXTRN	PyMethod_Type:BYTE
EXTRN	PyErr_Restore:PROC
EXTRN	PyObject_CallFunctionObjArgs:PROC
EXTRN	PyFrame_BlockSetup:PROC
EXTRN	PyLong_FromLong:PROC
EXTRN	PyList_Type:BYTE
EXTRN	PyFrame_LocalsToFast:PROC
EXTRN	PyFrame_FastToLocals:PROC
EXTRN	PyLong_AsLong:PROC
EXTRN	PyExc_ImportError:QWORD
EXTRN	PyObject_GetAttr:PROC
EXTRN	_PyDict_NewPresized:PROC
EXTRN	PySet_New:PROC
EXTRN	PyList_New:PROC
EXTRN	PyTuple_New:PROC
EXTRN	PyCell_Get:PROC
EXTRN	PyCell_Set:PROC
EXTRN	_PyDict_LoadGlobal:PROC
EXTRN	PyDict_GetItem:PROC
EXTRN	PyDict_DelItem:PROC
EXTRN	PyObject_SetAttr:PROC
EXTRN	PyDict_SetItem:PROC
EXTRN	PyExc_NameError:QWORD
EXTRN	PyExc_KeyError:QWORD
EXTRN	_PyUnicode_FromId:PROC
EXTRN	PyDict_Type:BYTE
EXTRN	PyFrame_BlockPop:PROC
EXTRN	_PyGen_FetchStopIterationValue:PROC
EXTRN	_PyGen_Send:PROC
EXTRN	PyGen_Type:BYTE
EXTRN	PyTuple_Pack:PROC
EXTRN	PySys_GetObject:PROC
EXTRN	PyObject_DelItem:PROC
EXTRN	PyObject_SetItem:PROC
EXTRN	PyNumber_InPlaceOr:PROC
EXTRN	PyNumber_InPlaceXor:PROC
EXTRN	PyNumber_InPlaceAnd:PROC
EXTRN	PyNumber_InPlaceRshift:PROC
EXTRN	PyNumber_InPlaceLshift:PROC
EXTRN	PyNumber_InPlaceSubtract:PROC
EXTRN	PyNumber_InPlaceAdd:PROC
EXTRN	PyNumber_InPlaceRemainder:PROC
EXTRN	PyNumber_InPlaceFloorDivide:PROC
EXTRN	PyNumber_InPlaceTrueDivide:PROC
EXTRN	PyNumber_InPlaceMultiply:PROC
EXTRN	PyNumber_InPlacePower:PROC
EXTRN	PySet_Add:PROC
EXTRN	PyList_Append:PROC
EXTRN	PyNumber_Or:PROC
EXTRN	PyNumber_Xor:PROC
EXTRN	PyNumber_And:PROC
EXTRN	PyNumber_Rshift:PROC
EXTRN	PyNumber_Lshift:PROC
EXTRN	PyObject_GetItem:PROC
EXTRN	PyNumber_Subtract:PROC
EXTRN	PyNumber_Add:PROC
EXTRN	PyNumber_Remainder:PROC
EXTRN	PyUnicode_Format:PROC
EXTRN	PyUnicode_Type:BYTE
EXTRN	PyNumber_FloorDivide:PROC
EXTRN	PyNumber_TrueDivide:PROC
EXTRN	PyNumber_Multiply:PROC
EXTRN	PyNumber_Power:PROC
EXTRN	PyNumber_Invert:PROC
EXTRN	PyNumber_Negative:PROC
EXTRN	PyNumber_Positive:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_StopIteration:QWORD
EXTRN	PyTuple_Type:BYTE
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_SystemError:QWORD
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	PyErr_Occurred:PROC
EXTRN	PyExc_UnboundLocalError:QWORD
EXTRN	PyObject_GetIter:PROC
EXTRN	PyObject_IsTrue:PROC
EXTRN	_Py_FalseStruct:BYTE
EXTRN	_Py_TrueStruct:BYTE
EXTRN	PyTuple_GetItem:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__imp_printf:PROC
EXTRN	PyErr_SetNone:PROC
EXTRN	_PyDict_GetItemId:PROC
_BSS	SEGMENT
lltrace	DD	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_EvalFrameEx DD imagerel $LN1073
	DD	imagerel $LN1073+229
	DD	imagerel $unwind$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$PyEval_EvalFrameEx DD imagerel $LN1073+229
	DD	imagerel $LN1073+237
	DD	imagerel $chain$0$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$PyEval_EvalFrameEx DD imagerel $LN1073+237
	DD	imagerel $LN1073+17191
	DD	imagerel $chain$1$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$PyEval_EvalFrameEx DD imagerel $LN1073+17191
	DD	imagerel $LN1073+17535
	DD	imagerel $chain$2$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$PyEval_EvalFrameEx DD imagerel $LN1073+17535
	DD	imagerel $LN1073+17608
	DD	imagerel $chain$3$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$PyEval_EvalFrameEx DD imagerel $LN1073+17608
	DD	imagerel $LN1073+18143
	DD	imagerel $chain$4$PyEval_EvalFrameEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$PyEval_EvalFrameEx DD 040021H
	DD	028c400H
	DD	0316400H
	DD	imagerel $LN1073
	DD	imagerel $LN1073+229
	DD	imagerel $unwind$PyEval_EvalFrameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$PyEval_EvalFrameEx DD 021H
	DD	imagerel $LN1073
	DD	imagerel $LN1073+229
	DD	imagerel $unwind$PyEval_EvalFrameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$PyEval_EvalFrameEx DD 021H
	DD	imagerel $LN1073+229
	DD	imagerel $LN1073+237
	DD	imagerel $chain$0$PyEval_EvalFrameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$PyEval_EvalFrameEx DD 020821H
	DD	028c408H
	DD	imagerel $LN1073+229
	DD	imagerel $LN1073+237
	DD	imagerel $chain$0$PyEval_EvalFrameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$PyEval_EvalFrameEx DD 020821H
	DD	0316408H
	DD	imagerel $LN1073
	DD	imagerel $LN1073+229
	DD	imagerel $unwind$PyEval_EvalFrameEx
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_EvalFrameEx DD 081a01H
	DD	029011aH
	DD	0e00cf00eH
	DD	07008d00aH
	DD	050063007H
xdata	ENDS
;	COMDAT ??_C@_0BD@INLLMHPI@PyEval_EvalFrameEx?$AA@
CONST	SEGMENT
??_C@_0BD@INLLMHPI@PyEval_EvalFrameEx?$AA@ DB 'PyEval_EvalFrameEx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@FENJHLBJ@unknown?5opcode?$AA@
CONST	SEGMENT
??_C@_0P@FENJHLBJ@unknown?5opcode?$AA@ DB 'unknown opcode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FPIMIFGH@XXX?5lineno?3?5?$CFd?0?5opcode?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BM@FPIMIFGH@XXX?5lineno?3?5?$CFd?0?5opcode?3?5?$CFd?6?$AA@ DB 'XXX'
	DB	' lineno: %d, opcode: %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HKNINBON@Stack?5unwind?5with?5exception?5set?5@
CONST	SEGMENT
??_C@_0CL@HKNINBON@Stack?5unwind?5with?5exception?5set?5@ DB 'Stack unwin'
	DB	'd with exception set and why=%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DK@INACIJOP@?$AAn?$AAu?$AAm?$AA_?$AAa?$AAn?$AAn?$AAo?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAa?$AAm?$AAe?$AA_?$AAi?$AAx?$AA?$CL?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1DK@INACIJOP@?$AAn?$AAu?$AAm?$AA_?$AAa?$AAn?$AAn?$AAo?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAa?$AAm?$AAe?$AA_?$AAi?$AAx?$AA?$CL?$AA1?$AA?$AA@ DB 'n'
	DB	00H, 'u', 00H, 'm', 00H, '_', 00H, 'a', 00H, 'n', 00H, 'n', 00H
	DB	'o', 00H, 't', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n'
	DB	00H, 's', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'n', 00H
	DB	'a', 00H, 'm', 00H, 'e', 00H, '_', 00H, 'i', 00H, 'x', 00H, '+'
	DB	00H, '1', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@BEHPHFBL@?8finally?8?5pops?5bad?5exception?$AA@
CONST	SEGMENT
??_C@_0BN@BEHPHFBL@?8finally?8?5pops?5bad?5exception?$AA@ DB '''finally'''
	DB	' pops bad exception', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DI@OCKJHPNN@?$AAb?$AA?9?$AA?$DO?$AAb?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAE?$AAX?$AAC?$AAE?$AAP?$AAT?$AA_?$AAH?$AAA?$AAN?$AAD?$AAL?$AAE?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1DI@OCKJHPNN@?$AAb?$AA?9?$AA?$DO?$AAb?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAE?$AAX?$AAC?$AAE?$AAP?$AAT?$AA_?$AAH?$AAA?$AAN?$AAD?$AAL?$AAE?$AAR?$AA?$AA@ DB 'b'
	DB	00H, '-', 00H, '>', 00H, 'b', 00H, '_', 00H, 't', 00H, 'y', 00H
	DB	'p', 00H, 'e', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'E'
	DB	00H, 'X', 00H, 'C', 00H, 'E', 00H, 'P', 00H, 'T', 00H, '_', 00H
	DB	'H', 00H, 'A', 00H, 'N', 00H, 'D', 00H, 'L', 00H, 'E', 00H, 'R'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@MGKPFLIA@?$AAw?$AAh?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAW?$AAH?$AAY?$AA_?$AAY?$AAI?$AAE?$AAL?$AAD?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@MGKPFLIA@?$AAw?$AAh?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAW?$AAH?$AAY?$AA_?$AAY?$AAI?$AAE?$AAL?$AAD?$AA?$AA@ DB 'w'
	DB	00H, 'h', 00H, 'y', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H
	DB	'W', 00H, 'H', 00H, 'Y', 00H, '_', 00H, 'Y', 00H, 'I', 00H, 'E'
	DB	00H, 'L', 00H, 'D', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@DJBOEJIH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAE?$AAX?$AAC?$AAE?$AAP?$AAT?$AA_?$AAH?$AAA?$AAN?$AAD?$AAL?$AAE?$AAR?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@DJBOEJIH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAE?$AAX?$AAC?$AAE?$AAP?$AAT?$AA_?$AAH?$AAA?$AAN?$AAD?$AAL?$AAE?$AAR?$AA?$AA@ DB 'b'
	DB	00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, '-', 00H, '>', 00H
	DB	'b', 00H, '_', 00H, 't', 00H, 'y', 00H, 'p', 00H, 'e', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, 'E', 00H, 'X', 00H, 'C', 00H
	DB	'E', 00H, 'P', 00H, 'T', 00H, '_', 00H, 'H', 00H, 'A', 00H, 'N'
	DB	00H, 'D', 00H, 'L', 00H, 'E', 00H, 'R', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NAHFDGJN@no?5locals?5found?5during?5?8import?5?$CK@
CONST	SEGMENT
??_C@_0CC@NAHFDGJN@no?5locals?5found?5during?5?8import?5?$CK@ DB 'no loca'
	DB	'ls found during ''import *''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FMMPICPA@__import__?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BF@FMMPICPA@__import__?5not?5found?$AA@ DB '__import__ not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@
CONST	SEGMENT
??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@ DB 'import not p'
	DB	'ermitted within parallel context', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@CFBAFFEI@?$AAP?$AAy?$AAD?$AAi?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@CFBAFFEI@?$AAP?$AAy?$AAD?$AAi?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'D', 00H, 'i', 00H, 'c', 00H, 't', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, 'E', 00H, 'x'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, '(', 00H, 'v', 00H, ')', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BEKKDKAN@no?5locals?5when?5loading?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BK@BEKKDKAN@no?5locals?5when?5loading?5?$CFR?$AA@ DB 'no locals wh'
	DB	'en loading %R', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@
CONST	SEGMENT
??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@ DB 'global'
	DB	' name ''%.200s'' is not defined', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HJKLBJNK@no?5locals?5when?5deleting?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0BL@HJKLBJNK@no?5locals?5when?5deleting?5?$CFR?$AA@ DB 'no locals w'
	DB	'hen deleting %R', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@DBLGJMNF@name?5?8?$CF?4200s?8?5is?5not?5defined?$AA@
CONST	SEGMENT
??_C@_0BN@DBLGJMNF@name?5?8?$CF?4200s?8?5is?5not?5defined?$AA@ DB 'name '''
	DB	'%.200s'' is not defined', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PHPKHPGD@no?5locals?5found?5when?5storing?5?$CFR?$AA@
CONST	SEGMENT
??_C@_0CA@PHPKHPGD@no?5locals?5found?5when?5storing?5?$CFR?$AA@ DB 'no lo'
	DB	'cals found when storing %R', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IAGNFEAN@__build_class__?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BK@IAGNFEAN@__build_class__?5not?5found?$AA@ DB '__build_class__ n'
	DB	'ot found', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@OJMEFFAL@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?$CI?$AAb?$AA?$CJ?$AA?9?$AA?$DO?$AAb?$AA_?$AAl?$AAe?$AAv?$AAe?$AAl?$AA?5?$AA?$CL?$AA?5@
CONST	SEGMENT
??_C@_1EE@OJMEFFAL@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?$CI?$AAb?$AA?$CJ?$AA?9?$AA?$DO?$AAb?$AA_?$AAl?$AAe?$AAv?$AAe?$AAl?$AA?5?$AA?$CL?$AA?5@ DB 'S'
	DB	00H, 'T', 00H, 'A', 00H, 'C', 00H, 'K', 00H, '_', 00H, 'L', 00H
	DB	'E', 00H, 'V', 00H, 'E', 00H, 'L', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, '>', 00H, '=', 00H, ' ', 00H, '(', 00H, 'b', 00H, ')', 00H
	DB	'-', 00H, '>', 00H, 'b', 00H, '_', 00H, 'l', 00H, 'e', 00H, 'v'
	DB	00H, 'e', 00H, 'l', 00H, ' ', 00H, '+', 00H, ' ', 00H, '3', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CDCIJBNO@popped?5block?5is?5not?5an?5except?5ha@
CONST	SEGMENT
??_C@_0CG@CDCIJBNO@popped?5block?5is?5not?5an?5except?5ha@ DB 'popped blo'
	DB	'ck is not an except handler', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01MJMHLOMK@O?$AA@
CONST	SEGMENT
??_C@_01MJMHLOMK@O?$AA@ DB 'O', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@INLFGEHA@bad?5RAISE_VARARGS?5oparg?$AA@
CONST	SEGMENT
??_C@_0BI@INLFGEHA@bad?5RAISE_VARARGS?5oparg?$AA@ DB 'bad RAISE_VARARGS o'
	DB	'parg', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@LDJCNLPE@lost?5sys?4displayhook?$AA@
CONST	SEGMENT
??_C@_0BF@LDJCNLPE@lost?5sys?4displayhook?$AA@ DB 'lost sys.displayhook', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OABHHABA@displayhook?$AA@
CONST	SEGMENT
??_C@_0M@OABHHABA@displayhook?$AA@ DB 'displayhook', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@PEFHABHC@error?5return?5without?5exception?5s@
CONST	SEGMENT
??_C@_0CD@PEFHABHC@error?5return?5without?5exception?5s@ DB 'error return'
	DB	' without exception set', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BGJGOEKO@XXX?5undetected?5error?6?$AA@
CONST	SEGMENT
??_C@_0BG@BGJGOEKO@XXX?5undetected?5error?6?$AA@ DB 'XXX undetected error'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HKMDOJCI@local?5variable?5?8?$CF?4200s?8?5referenc@
CONST	SEGMENT
??_C@_0DF@HKMDOJCI@local?5variable?5?8?$CF?4200s?8?5referenc@ DB 'local v'
	DB	'ariable ''%.200s'' referenced before assignment', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08OGNHIHGF@stackadj?$AA@
CONST	SEGMENT
??_C@_08OGNHIHGF@stackadj?$AA@ DB 'stackadj', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03NJDAHFJE@pop?$AA@
CONST	SEGMENT
??_C@_03NJDAHFJE@pop?$AA@ DB 'pop', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHHNIPCF@push?$AA@
CONST	SEGMENT
??_C@_04GHHNIPCF@push?$AA@ DB 'push', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07BCEPPLOH@?$CFd?3?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_07BCEPPLOH@?$CFd?3?5?$CFd?6?$AA@ DB '%d: %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EEIINKGH@?$CFd?3?5?$CFd?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0M@EEIINKGH@?$CFd?3?5?$CFd?0?5?$CFd?6?$AA@ DB '%d: %d, %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@OIDPILMB@ceval?3?5orphan?5tstate?$AA@
CONST	SEGMENT
??_C@_0BF@OIDPILMB@ceval?3?5orphan?5tstate?$AA@ DB 'ceval: orphan tstate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FFPEPKAJ@ceval?3?5tstate?5mix?9up?$AA@
CONST	SEGMENT
??_C@_0BF@FFPEPKAJ@ceval?3?5tstate?5mix?9up?$AA@ DB 'ceval: tstate mix-up'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
CONST	SEGMENT
??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@ DB 'S'
	DB	00H, 'T', 00H, 'A', 00H, 'C', 00H, 'K', 00H, '_', 00H, 'L', 00H
	DB	'E', 00H, 'V', 00H, 'E', 00H, 'L', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, 'c', 00H, 'o', 00H, '-', 00H
	DB	'>', 00H, 'c', 00H, 'o', 00H, '_', 00H, 's', 00H, 't', 00H, 'a'
	DB	00H, 'c', 00H, 'k', 00H, 's', 00H, 'i', 00H, 'z', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@PPDGCIBF@?$AAs?$AAt?$AAa?$AAc?$AAk?$AA_?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAf?$AA?9?$AA?$DO?$AAf?$AA_?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AAt?$AAa?$AAc?$AAk@
CONST	SEGMENT
??_C@_1EC@PPDGCIBF@?$AAs?$AAt?$AAa?$AAc?$AAk?$AA_?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAf?$AA?9?$AA?$DO?$AAf?$AA_?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AAt?$AAa?$AAc?$AAk@ DB 's'
	DB	00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '_', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, '>', 00H, '=', 00H, ' ', 00H, 'f', 00H, '-', 00H, '>', 00H
	DB	'f', 00H, '_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@OHHBDEIG@?$AAs?$AAt?$AAa?$AAc?$AAk?$AA_?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@OHHBDEIG@?$AAs?$AAt?$AAa?$AAc?$AAk?$AA_?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H, '_', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H
	DB	'L', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@LNBMNGOB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@LNBMNGOB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'c', 00H, 'o', 00H, '-', 00H, '>', 00H, 'c', 00H, 'o', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_EvalFrameEx
_TEXT	SEGMENT
tmp$1$ = 48
tstate$1$ = 56
next_instr$1$ = 64
co$1$ = 72
first_instr$1$ = 80
names$1$ = 88
retval$1$ = 96
val$65700 = 104
tb$65701 = 112
freevars$1$ = 120
exc$65699 = 128
instr_prev$ = 136
instr_lb$ = 140
kwdefaults$1$ = 144
v$56$ = 144
instr_ub$ = 152
posdefaults$1$ = 156
sp$65500 = 160
sp$65517 = 168
consts$1$ = 176
val$64895 = 184
buf$65638 = 192
f$ = 384
throwflag$ = 392
why$1$ = 400
err$1$ = 408
PyEval_EvalFrameEx PROC					; COMDAT

; 834  : {

$LN1073:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	57		 push	 rdi
  00008	41 55		 push	 r13
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 8d 6c 24 b8	 lea	 rbp, QWORD PTR [rsp-72]
  00013	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H

; 835  : #ifdef DXPAIRS
; 836  :     int lastopcode = 0;
; 837  : #endif
; 838  :     register PyObject **stack_pointer;  /* Next free slot in value stack */
; 839  :     register unsigned char *next_instr;
; 840  :     register int opcode;        /* Current opcode */
; 841  :     register int oparg;         /* Current opcode argument, if any */
; 842  :     register enum why_code why; /* Reason for block stack unwind */
; 843  :     register int err;           /* Error status -- nonzero if error */
; 844  :     register PyObject *x;       /* Result object -- NULL if error */
; 845  :     register PyObject *v;       /* Temporary objects popped off stack */
; 846  :     register PyObject *w;
; 847  :     register PyObject *u;
; 848  :     register PyObject *t;
; 849  :     register PyObject **fastlocals, **freevars;
; 850  :     PyObject *retval = NULL;            /* Return value */

  0001a	45 33 f6	 xor	 r14d, r14d
  0001d	8b da		 mov	 ebx, edx
  0001f	4c 8b f9	 mov	 r15, rcx
  00022	45 8b ee	 mov	 r13d, r14d
  00025	4c 89 74 24 60	 mov	 QWORD PTR retval$1$[rsp], r14

; 851  :     PyThreadState *tstate = PyThreadState_GET();

  0002a	e8 00 00 00 00	 call	 PyThreadState_Get

; 852  :     PyCodeObject *co;
; 853  : 
; 854  :     /* when tracing we set things up so that
; 855  : 
; 856  :            not (instr_lb <= current_bytecode_offset < instr_ub)
; 857  : 
; 858  :        is true when the line being executed has changed.  The
; 859  :        initial values are such as to make this false the first
; 860  :        time it is tested. */
; 861  :     int instr_ub = -1, instr_lb = 0, instr_prev = -1;

  0002f	c7 45 98 ff ff
	ff ff		 mov	 DWORD PTR instr_ub$[rbp-256], -1
  00036	44 89 75 8c	 mov	 DWORD PTR instr_lb$[rbp-256], r14d
  0003a	c7 45 88 ff ff
	ff ff		 mov	 DWORD PTR instr_prev$[rbp-256], -1
  00041	48 8b f8	 mov	 rdi, rax
  00044	48 89 44 24 38	 mov	 QWORD PTR tstate$1$[rsp], rax

; 862  : 
; 863  :     unsigned char *first_instr;
; 864  :     PyObject *names;
; 865  :     PyObject *consts;
; 866  : 
; 867  : #ifdef LLTRACE
; 868  :     _Py_IDENTIFIER(__ltrace__);
; 869  : #endif
; 870  : 
; 871  : /* Computed GOTOs, or
; 872  :        the-optimization-commonly-but-improperly-known-as-"threaded code"
; 873  :    using gcc's labels-as-values extension
; 874  :    (http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html).
; 875  : 
; 876  :    The traditional bytecode evaluation loop uses a "switch" statement, which
; 877  :    decent compilers will optimize as a single indirect branch instruction
; 878  :    combined with a lookup table of jump addresses. However, since the
; 879  :    indirect jump instruction is shared by all opcodes, the CPU will have a
; 880  :    hard time making the right prediction for where to jump next (actually,
; 881  :    it will be always wrong except in the uncommon case of a sequence of
; 882  :    several identical opcodes).
; 883  : 
; 884  :    "Threaded code" in contrast, uses an explicit jump table and an explicit
; 885  :    indirect jump instruction at the end of each opcode. Since the jump
; 886  :    instruction is at a different address for each opcode, the CPU will make a
; 887  :    separate prediction for each of these instructions, which is equivalent to
; 888  :    predicting the second opcode of each opcode pair. These predictions have
; 889  :    a much better chance to turn out valid, especially in small bytecode loops.
; 890  : 
; 891  :    A mispredicted branch on a modern CPU flushes the whole pipeline and
; 892  :    can cost several CPU cycles (depending on the pipeline depth),
; 893  :    and potentially many more instructions (depending on the pipeline width).
; 894  :    A correctly predicted branch, however, is nearly free.
; 895  : 
; 896  :    At the time of this writing, the "threaded code" version is up to 15-20%
; 897  :    faster than the normal "switch" version, depending on the compiler and the
; 898  :    CPU architecture.
; 899  : 
; 900  :    We disable the optimization if DYNAMIC_EXECUTION_PROFILE is defined,
; 901  :    because it would render the measurements invalid.
; 902  : 
; 903  : 
; 904  :    NOTE: care must be taken that the compiler doesn't try to "optimize" the
; 905  :    indirect jumps by sharing them between all opcodes. Such optimizations
; 906  :    can be disabled on gcc by using the -fno-gcse flag (or possibly
; 907  :    -fno-crossjumping).
; 908  : */
; 909  : 
; 910  : #ifdef DYNAMIC_EXECUTION_PROFILE
; 911  : #undef USE_COMPUTED_GOTOS
; 912  : #define USE_COMPUTED_GOTOS 0
; 913  : #endif
; 914  : 
; 915  : #ifdef HAVE_COMPUTED_GOTOS
; 916  :     #ifndef USE_COMPUTED_GOTOS
; 917  :     #define USE_COMPUTED_GOTOS 1
; 918  :     #endif
; 919  : #else
; 920  :     #if defined(USE_COMPUTED_GOTOS) && USE_COMPUTED_GOTOS
; 921  :     #error "Computed gotos are not supported on this compiler."
; 922  :     #endif
; 923  :     #undef USE_COMPUTED_GOTOS
; 924  :     #define USE_COMPUTED_GOTOS 0
; 925  : #endif
; 926  : 
; 927  : #if USE_COMPUTED_GOTOS
; 928  : /* Import the static jump table */
; 929  : #include "opcode_targets.h"
; 930  : 
; 931  : /* This macro is used when several opcodes defer to the same implementation
; 932  :    (e.g. SETUP_LOOP, SETUP_FINALLY) */
; 933  : #define TARGET_WITH_IMPL(op, impl) \
; 934  :     TARGET_##op: \
; 935  :         opcode = op; \
; 936  :         if (HAS_ARG(op)) \
; 937  :             oparg = NEXTARG(); \
; 938  :     case op: \
; 939  :         goto impl; \
; 940  : 
; 941  : #define TARGET(op) \
; 942  :     TARGET_##op: \
; 943  :         opcode = op; \
; 944  :         if (HAS_ARG(op)) \
; 945  :             oparg = NEXTARG(); \
; 946  :     case op:
; 947  : 
; 948  : 
; 949  : #define DISPATCH() \
; 950  :     { \
; 951  :         if (!_Py_atomic_load_relaxed(&eval_breaker)) {      \
; 952  :                     FAST_DISPATCH(); \
; 953  :         } \
; 954  :         continue; \
; 955  :     }
; 956  : 
; 957  : #ifdef LLTRACE
; 958  : #define FAST_DISPATCH() \
; 959  :     { \
; 960  :         if (!lltrace && !_Py_TracingPossible) { \
; 961  :             f->f_lasti = INSTR_OFFSET(); \
; 962  :             goto *opcode_targets[*next_instr++]; \
; 963  :         } \
; 964  :         goto fast_next_opcode; \
; 965  :     }
; 966  : #else
; 967  : #define FAST_DISPATCH() \
; 968  :     { \
; 969  :         if (!_Py_TracingPossible) { \
; 970  :             f->f_lasti = INSTR_OFFSET(); \
; 971  :             goto *opcode_targets[*next_instr++]; \
; 972  :         } \
; 973  :         goto fast_next_opcode; \
; 974  :     }
; 975  : #endif
; 976  : 
; 977  : #else
; 978  : #define TARGET(op) \
; 979  :     case op:
; 980  : #define TARGET_WITH_IMPL(op, impl) \
; 981  :     /* silence compiler warnings about `impl` unused */ \
; 982  :     if (0) goto impl; \
; 983  :     case op:
; 984  : #define DISPATCH() continue
; 985  : #define FAST_DISPATCH() goto fast_next_opcode
; 986  : #endif
; 987  : 
; 988  : 
; 989  : /* Tuple access macros */
; 990  : 
; 991  : #ifndef Py_DEBUG
; 992  : #define GETITEM(v, i) PyTuple_GET_ITEM((PyTupleObject *)(v), (i))
; 993  : #else
; 994  : #define GETITEM(v, i) PyTuple_GetItem((v), (i))
; 995  : #endif
; 996  : 
; 997  : #ifdef WITH_TSC
; 998  : /* Use Pentium timestamp counter to mark certain events:
; 999  :    inst0 -- beginning of switch statement for opcode dispatch
; 1000 :    inst1 -- end of switch statement (may be skipped)
; 1001 :    loop0 -- the top of the mainloop
; 1002 :    loop1 -- place where control returns again to top of mainloop
; 1003 :             (may be skipped)
; 1004 :    intr1 -- beginning of long interruption
; 1005 :    intr2 -- end of long interruption
; 1006 : 
; 1007 :    Many opcodes call out to helper C functions.  In some cases, the
; 1008 :    time in those functions should be counted towards the time for the
; 1009 :    opcode, but not in all cases.  For example, a CALL_FUNCTION opcode
; 1010 :    calls another Python function; there's no point in charge all the
; 1011 :    bytecode executed by the called function to the caller.
; 1012 : 
; 1013 :    It's hard to make a useful judgement statically.  In the presence
; 1014 :    of operator overloading, it's impossible to tell if a call will
; 1015 :    execute new Python code or not.
; 1016 : 
; 1017 :    It's a case-by-case judgement.  I'll use intr1 for the following
; 1018 :    cases:
; 1019 : 
; 1020 :    IMPORT_STAR
; 1021 :    IMPORT_FROM
; 1022 :    CALL_FUNCTION (and friends)
; 1023 : 
; 1024 :  */
; 1025 :     uint64 inst0, inst1, loop0, loop1, intr0 = 0, intr1 = 0;
; 1026 :     int ticked = 0;
; 1027 : 
; 1028 :     READ_TIMESTAMP(inst0);
; 1029 :     READ_TIMESTAMP(inst1);
; 1030 :     READ_TIMESTAMP(loop0);
; 1031 :     READ_TIMESTAMP(loop1);
; 1032 : 
; 1033 :     /* shut up the compiler */
; 1034 :     opcode = 0;
; 1035 : #endif
; 1036 : 
; 1037 : /* Code access macros */
; 1038 : 
; 1039 : #define INSTR_OFFSET()  ((int)(next_instr - first_instr))
; 1040 : #define NEXTOP()        (*next_instr++)
; 1041 : #define NEXTARG()       (next_instr += 2, (next_instr[-1]<<8) + next_instr[-2])
; 1042 : #define PEEKARG()       ((next_instr[2]<<8) + next_instr[1])
; 1043 : #define JUMPTO(x)       (next_instr = first_instr + (x))
; 1044 : #define JUMPBY(x)       (next_instr += (x))
; 1045 : 
; 1046 : /* OpCode prediction macros
; 1047 :     Some opcodes tend to come in pairs thus making it possible to
; 1048 :     predict the second code when the first is run.  For example,
; 1049 :     COMPARE_OP is often followed by JUMP_IF_FALSE or JUMP_IF_TRUE.  And,
; 1050 :     those opcodes are often followed by a POP_TOP.
; 1051 : 
; 1052 :     Verifying the prediction costs a single high-speed test of a register
; 1053 :     variable against a constant.  If the pairing was good, then the
; 1054 :     processor's own internal branch predication has a high likelihood of
; 1055 :     success, resulting in a nearly zero-overhead transition to the
; 1056 :     next opcode.  A successful prediction saves a trip through the eval-loop
; 1057 :     including its two unpredictable branches, the HAS_ARG test and the
; 1058 :     switch-case.  Combined with the processor's internal branch prediction,
; 1059 :     a successful PREDICT has the effect of making the two opcodes run as if
; 1060 :     they were a single new opcode with the bodies combined.
; 1061 : 
; 1062 :     If collecting opcode statistics, your choices are to either keep the
; 1063 :     predictions turned-on and interpret the results as if some opcodes
; 1064 :     had been combined or turn-off predictions so that the opcode frequency
; 1065 :     counter updates for both opcodes.
; 1066 : 
; 1067 :     Opcode prediction is disabled with threaded code, since the latter allows
; 1068 :     the CPU to record separate branch prediction information for each
; 1069 :     opcode.
; 1070 : 
; 1071 : */
; 1072 : 
; 1073 : #if defined(DYNAMIC_EXECUTION_PROFILE) || USE_COMPUTED_GOTOS
; 1074 : #define PREDICT(op)             if (0) goto PRED_##op
; 1075 : #define PREDICTED(op)           PRED_##op:
; 1076 : #define PREDICTED_WITH_ARG(op)  PRED_##op:
; 1077 : #else
; 1078 : #define PREDICT(op)             if (*next_instr == op) goto PRED_##op
; 1079 : #define PREDICTED(op)           PRED_##op: next_instr++
; 1080 : #define PREDICTED_WITH_ARG(op)  PRED_##op: oparg = PEEKARG(); next_instr += 3
; 1081 : #endif
; 1082 : 
; 1083 : 
; 1084 : /* Stack manipulation macros */
; 1085 : 
; 1086 : /* The stack can grow at most MAXINT deep, as co_nlocals and
; 1087 :    co_stacksize are ints. */
; 1088 : #define STACK_LEVEL()     ((int)(stack_pointer - f->f_valuestack))
; 1089 : #define EMPTY()           (STACK_LEVEL() == 0)
; 1090 : #define TOP()             (stack_pointer[-1])
; 1091 : #define SECOND()          (stack_pointer[-2])
; 1092 : #define THIRD()           (stack_pointer[-3])
; 1093 : #define FOURTH()          (stack_pointer[-4])
; 1094 : #define PEEK(n)           (stack_pointer[-(n)])
; 1095 : #define SET_TOP(v)        (stack_pointer[-1] = (v))
; 1096 : #define SET_SECOND(v)     (stack_pointer[-2] = (v))
; 1097 : #define SET_THIRD(v)      (stack_pointer[-3] = (v))
; 1098 : #define SET_FOURTH(v)     (stack_pointer[-4] = (v))
; 1099 : #define SET_VALUE(n, v)   (stack_pointer[-(n)] = (v))
; 1100 : #define BASIC_STACKADJ(n) (stack_pointer += n)
; 1101 : #define BASIC_PUSH(v)     (*stack_pointer++ = (v))
; 1102 : #define BASIC_POP()       (*--stack_pointer)
; 1103 : 
; 1104 : #ifdef LLTRACE
; 1105 : #define PUSH(v)         { (void)(BASIC_PUSH(v), \
; 1106 :                           lltrace && prtrace(TOP(), "push")); \
; 1107 :                           assert(STACK_LEVEL() <= co->co_stacksize); }
; 1108 : #define POP()           ((void)(lltrace && prtrace(TOP(), "pop")), \
; 1109 :                          BASIC_POP())
; 1110 : #define STACKADJ(n)     { (void)(BASIC_STACKADJ(n), \
; 1111 :                           lltrace && prtrace(TOP(), "stackadj")); \
; 1112 :                           assert(STACK_LEVEL() <= co->co_stacksize); }
; 1113 : #define EXT_POP(STACK_POINTER) ((void)(lltrace && \
; 1114 :                                 prtrace((STACK_POINTER)[-1], "ext_pop")), \
; 1115 :                                 *--(STACK_POINTER))
; 1116 : #else
; 1117 : #define PUSH(v)                BASIC_PUSH(v)
; 1118 : #define POP()                  BASIC_POP()
; 1119 : #define STACKADJ(n)            BASIC_STACKADJ(n)
; 1120 : #define EXT_POP(STACK_POINTER) (*--(STACK_POINTER))
; 1121 : #endif
; 1122 : 
; 1123 : /* Local variable macros */
; 1124 : 
; 1125 : #define GETLOCAL(i)     (fastlocals[i])
; 1126 : 
; 1127 : /* The SETLOCAL() macro must not DECREF the local variable in-place and
; 1128 :    then store the new value; it must copy the old value to a temporary
; 1129 :    value, then store the new value, and then DECREF the temporary value.
; 1130 :    This is because it is possible that during the DECREF the frame is
; 1131 :    accessed by other code (e.g. a __del__ method or gc.collect()) and the
; 1132 :    variable would be pointing to already-freed memory. */
; 1133 : #define SETLOCAL(i, value)      do { PyObject *tmp = GETLOCAL(i); \
; 1134 :                                      GETLOCAL(i) = value; \
; 1135 :                                      Py_XDECREF(tmp); } while (0)
; 1136 : 
; 1137 : 
; 1138 : #define UNWIND_BLOCK(b) \
; 1139 :     while (STACK_LEVEL() > (b)->b_level) { \
; 1140 :         PyObject *v = POP(); \
; 1141 :         Py_XDECREF(v); \
; 1142 :     }
; 1143 : 
; 1144 : #define UNWIND_EXCEPT_HANDLER(b) \
; 1145 :     { \
; 1146 :         PyObject *type, *value, *traceback; \
; 1147 :         assert(STACK_LEVEL() >= (b)->b_level + 3); \
; 1148 :         while (STACK_LEVEL() > (b)->b_level + 3) { \
; 1149 :             value = POP(); \
; 1150 :             Py_XDECREF(value); \
; 1151 :         } \
; 1152 :         type = tstate->exc_type; \
; 1153 :         value = tstate->exc_value; \
; 1154 :         traceback = tstate->exc_traceback; \
; 1155 :         tstate->exc_type = POP(); \
; 1156 :         tstate->exc_value = POP(); \
; 1157 :         tstate->exc_traceback = POP(); \
; 1158 :         Py_XDECREF(type); \
; 1159 :         Py_XDECREF(value); \
; 1160 :         Py_XDECREF(traceback); \
; 1161 :     }
; 1162 : 
; 1163 : /* Start of code */
; 1164 : 
; 1165 :     /* push frame */
; 1166 :     if (Py_EnterRecursiveCall(""))

  00049	e8 00 00 00 00	 call	 PyThreadState_Get
  0004e	ff 40 18	 inc	 DWORD PTR [rax+24]
  00051	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00054	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _Py_CheckRecursionLimit
  0005a	7e 23		 jle	 SHORT $LN548@PyEval_Eva
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00063	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00068	85 c0		 test	 eax, eax
  0006a	74 13		 je	 SHORT $LN548@PyEval_Eva

; 1167 :         return NULL;

  0006c	33 c0		 xor	 eax, eax

; 3150 : }

  0006e	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  00075	41 5f		 pop	 r15
  00077	41 5e		 pop	 r14
  00079	41 5d		 pop	 r13
  0007b	5f		 pop	 rdi
  0007c	5b		 pop	 rbx
  0007d	5d		 pop	 rbp
  0007e	c3		 ret	 0
$LN548@PyEval_Eva:

; 1168 : 
; 1169 :     tstate->frame = f;

  0007f	4c 89 7f 10	 mov	 QWORD PTR [rdi+16], r15

; 1170 : 
; 1171 :     if (tstate->use_tracing) {

  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0008a	44 39 6f 24	 cmp	 DWORD PTR [rdi+36], r13d
  0008e	74 51		 je	 SHORT $LN543@PyEval_Eva

; 1172 :         if (tstate->c_tracefunc != NULL) {

  00090	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  00094	48 85 c9	 test	 rcx, rcx
  00097	74 23		 je	 SHORT $LN545@PyEval_Eva

; 1173 :             /* tstate->c_tracefunc, if defined, is a
; 1174 :                function that will be called on *every* entry
; 1175 :                to a code block.  Its return value, if not
; 1176 :                None, is a function that will be called at
; 1177 :                the start of each executed line of code.
; 1178 :                (Actually, the function must return itself
; 1179 :                in order to continue tracing.)  The trace
; 1180 :                functions are called with three arguments:
; 1181 :                a pointer to the current frame, a string
; 1182 :                indicating why the function is called, and
; 1183 :                an argument which depends on the situation.
; 1184 :                The global trace function is also called
; 1185 :                whenever an exception is detected. */
; 1186 :             if (call_trace_protected(tstate->c_tracefunc,
; 1187 :                                      tstate->c_traceobj,
; 1188 :                                      f, PyTrace_CALL, Py_None)) {

  00099	48 8b 57 40	 mov	 rdx, QWORD PTR [rdi+64]
  0009d	45 33 c9	 xor	 r9d, r9d
  000a0	4d 8b c7	 mov	 r8, r15
  000a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a8	e8 00 00 00 00	 call	 call_trace_protected
  000ad	85 c0		 test	 eax, eax
  000af	0f 85 ca 43 00
	00		 jne	 $exit_eval_frame$64503
  000b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN545@PyEval_Eva:

; 1189 :                 /* Trace function raised an error */
; 1190 :                 goto exit_eval_frame;
; 1191 :             }
; 1192 :         }
; 1193 :         if (tstate->c_profilefunc != NULL) {

  000bc	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  000c0	48 85 c9	 test	 rcx, rcx
  000c3	74 1c		 je	 SHORT $LN543@PyEval_Eva

; 1194 :             /* Similar for c_profilefunc, except it needn't
; 1195 :                return itself and isn't called for "line" events */
; 1196 :             if (call_trace_protected(tstate->c_profilefunc,
; 1197 :                                      tstate->c_profileobj,
; 1198 :                                      f, PyTrace_CALL, Py_None)) {

  000c5	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  000c9	45 33 c9	 xor	 r9d, r9d
  000cc	4d 8b c7	 mov	 r8, r15
  000cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d4	e8 00 00 00 00	 call	 call_trace_protected
  000d9	85 c0		 test	 eax, eax
  000db	0f 85 9e 43 00
	00		 jne	 $exit_eval_frame$64503
$LN543@PyEval_Eva:

; 1199 :                 /* Profile function raised an error */
; 1200 :                 goto exit_eval_frame;
; 1201 :             }
; 1202 :         }
; 1203 :     }
; 1204 : 
; 1205 :     co = f->f_code;

  000e1	4d 8b 6f 78	 mov	 r13, QWORD PTR [r15+120]
  000e5	48 89 b4 24 88
	01 00 00	 mov	 QWORD PTR [rsp+392], rsi
  000ed	4c 89 a4 24 40
	01 00 00	 mov	 QWORD PTR [rsp+320], r12

; 1206 :     names = co->co_names;

  000f5	49 8b 85 88 00
	00 00		 mov	 rax, QWORD PTR [r13+136]
  000fc	4c 89 6c 24 48	 mov	 QWORD PTR co$1$[rsp], r13
  00101	48 89 44 24 58	 mov	 QWORD PTR names$1$[rsp], rax

; 1207 :     consts = co->co_consts;

  00106	49 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR [r13+128]
  0010d	48 89 45 b0	 mov	 QWORD PTR consts$1$[rbp-256], rax

; 1208 :     fastlocals = f->f_localsplus;
; 1209 :     freevars = f->f_localsplus + co->co_nlocals;

  00111	49 63 45 68	 movsxd	 rax, DWORD PTR [r13+104]
  00115	49 8d 84 c7 d0
	01 00 00	 lea	 rax, QWORD PTR [r15+rax*8+464]
  0011d	48 89 44 24 78	 mov	 QWORD PTR freevars$1$[rsp], rax

; 1210 :     first_instr = (unsigned char*) PyBytes_AS_STRING(co->co_code);

  00122	49 8b 45 78	 mov	 rax, QWORD PTR [r13+120]
  00126	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0012a	f7 81 00 01 00
	00 00 00 00 08	 test	 DWORD PTR [rcx+256], 134217728 ; 08000000H
  00134	75 1a		 jne	 SHORT $LN551@PyEval_Eva
  00136	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@LNBMNGOB@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAc?$AAo?$AAd?$AAe?$AA?$CJ?$AA?$AA@
  00144	41 b8 ba 04 00
	00		 mov	 r8d, 1210		; 000004baH
  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN551@PyEval_Eva:
  00150	49 8b 4d 78	 mov	 rcx, QWORD PTR [r13+120]

; 1211 :     /* An explanation is in order for the next line.
; 1212 : 
; 1213 :        f->f_lasti now refers to the index of the last instruction
; 1214 :        executed.  You might think this was obvious from the name, but
; 1215 :        this wasn't always true before 2.3!  PyFrame_New now sets
; 1216 :        f->f_lasti to -1 (i.e. the index *before* the first instruction)
; 1217 :        and YIELD_VALUE doesn't fiddle with f_lasti any more.  So this
; 1218 :        does work.  Promise.
; 1219 :        YIELD_FROM sets f_lasti to itself, in order to repeated yield
; 1220 :        multiple values.
; 1221 : 
; 1222 :        When the PREDICT() macros are enabled, some opcode pairs follow in
; 1223 :        direct succession without updating f->f_lasti.  A successful
; 1224 :        prediction effectively links the two codes together as if they
; 1225 :        were a single new opcode; accordingly,f->f_lasti will point to
; 1226 :        the first code in the pair (for instance, GET_ITER followed by
; 1227 :        FOR_ITER is effectively a single opcode and f->f_lasti will point
; 1228 :        at to the beginning of the combined pair.)
; 1229 :     */
; 1230 :     next_instr = first_instr + f->f_lasti + 1;

  00154	49 63 87 d0 00
	00 00		 movsxd	 rax, DWORD PTR [r15+208]

; 1231 :     stack_pointer = f->f_stacktop;

  0015b	49 8b b7 a0 00
	00 00		 mov	 rsi, QWORD PTR [r15+160]
  00162	48 83 c1 78	 add	 rcx, 120		; 00000078H
  00166	48 89 4c 24 50	 mov	 QWORD PTR first_instr$1$[rsp], rcx
  0016b	4c 8d 64 08 01	 lea	 r12, QWORD PTR [rax+rcx+1]
  00170	4c 89 64 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r12

; 1232 :     assert(stack_pointer != NULL);

  00175	48 85 f6	 test	 rsi, rsi
  00178	75 1a		 jne	 SHORT $LN552@PyEval_Eva
  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@OHHBDEIG@?$AAs?$AAt?$AAa?$AAc?$AAk?$AA_?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00188	41 b8 d0 04 00
	00		 mov	 r8d, 1232		; 000004d0H
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN552@PyEval_Eva:

; 1233 :     f->f_stacktop = NULL;       /* remains NULL unless yield suspends frame */

  00194	4d 89 b7 a0 00
	00 00		 mov	 QWORD PTR [r15+160], r14

; 1234 : 
; 1235 :     if (co->co_flags & CO_GENERATOR && !throwflag) {

  0019b	41 f6 45 70 20	 test	 BYTE PTR [r13+112], 32	; 00000020H
  001a0	74 34		 je	 SHORT $LN540@PyEval_Eva
  001a2	85 db		 test	 ebx, ebx
  001a4	75 30		 jne	 SHORT $LN540@PyEval_Eva

; 1236 :         if (f->f_exc_type != NULL && f->f_exc_type != Py_None) {

  001a6	49 8b 87 b0 00
	00 00		 mov	 rax, QWORD PTR [r15+176]
  001ad	48 85 c0	 test	 rax, rax
  001b0	74 19		 je	 SHORT $LN541@PyEval_Eva
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  001b9	48 3b c1	 cmp	 rax, rcx
  001bc	74 0d		 je	 SHORT $LN541@PyEval_Eva

; 1237 :             /* We were in an except handler when we left,
; 1238 :                restore the exception state which was put aside
; 1239 :                (see YIELD_VALUE). */
; 1240 :             swap_exc_state(tstate, f);

  001be	49 8b d7	 mov	 rdx, r15
  001c1	48 8b cf	 mov	 rcx, rdi
  001c4	e8 00 00 00 00	 call	 swap_exc_state

; 1241 :         }
; 1242 :         else

  001c9	eb 0b		 jmp	 SHORT $LN540@PyEval_Eva
$LN541@PyEval_Eva:

; 1243 :             save_exc_state(tstate, f);

  001cb	49 8b d7	 mov	 rdx, r15
  001ce	48 8b cf	 mov	 rcx, rdi
  001d1	e8 00 00 00 00	 call	 save_exc_state
$LN540@PyEval_Eva:

; 1244 :     }
; 1245 : 
; 1246 : #ifdef LLTRACE
; 1247 :     lltrace = _PyDict_GetItemId(f->f_globals, &PyId___ltrace__) != NULL;

  001d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  001dc	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  001e5	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___ltrace__@?1??PyEval_EvalFrameEx@@9@9
  001ea	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  001ee	49 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [r15+136]
  001f5	e8 00 00 00 00	 call	 _PyDict_GetItemId
  001fa	41 8b ce	 mov	 ecx, r14d

; 1248 : #endif
; 1249 : 
; 1250 :     why = WHY_NOT;
; 1251 :     err = 0;

  001fd	45 8b ee	 mov	 r13d, r14d
  00200	48 85 c0	 test	 rax, rax

; 1252 :     x = Py_None;        /* Not a reference, just anything non-NULL */

  00203	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0020a	44 89 b5 98 00
	00 00		 mov	 DWORD PTR err$1$[rbp-256], r14d
  00211	0f 95 c1	 setne	 cl
  00214	4c 8b f0	 mov	 r14, rax
  00217	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  0021c	89 0d 00 00 00
	00		 mov	 DWORD PTR lltrace, ecx
  00222	c7 85 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR why$1$[rbp-256], 1

; 1253 :     w = NULL;
; 1254 : 
; 1255 :     if (throwflag) { /* support for generator.throw() */

  0022c	85 db		 test	 ebx, ebx
  0022e	74 1c		 je	 SHORT $LN1020@PyEval_Eva

; 1256 :         why = WHY_EXCEPTION;

  00230	bb 02 00 00 00	 mov	 ebx, 2
  00235	8b c3		 mov	 eax, ebx
  00237	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx

; 1257 :         goto on_error;

  0023d	e9 da 09 00 00	 jmp	 $LN1029@PyEval_Eva
$LN1064@PyEval_Eva:

; 2484 :                 ;
; 2485 :             else
; 2486 :                 break;
; 2487 :             DISPATCH();

  00242	4c 8b 64 24 40	 mov	 r12, QWORD PTR next_instr$1$[rsp]
$LN1065@PyEval_Eva:
  00247	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
$LN1020@PyEval_Eva:

; 3078 :             break;
; 3079 :         READ_TIMESTAMP(loop1);
; 3080 : 
; 3081 :     } /* main loop */

  0024c	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
$LN538@PyEval_Eva:

; 1258 :     }
; 1259 : 
; 1260 :     for (;;) {
; 1261 : #ifdef WITH_TSC
; 1262 :         if (inst1 == 0) {
; 1263 :             /* Almost surely, the opcode executed a break
; 1264 :                or a continue, preventing inst1 from being set
; 1265 :                on the way out of the loop.
; 1266 :             */
; 1267 :             READ_TIMESTAMP(inst1);
; 1268 :             loop1 = inst1;
; 1269 :         }
; 1270 :         dump_tsc(opcode, ticked, inst0, inst1, loop0, loop1,
; 1271 :                  intr0, intr1);
; 1272 :         ticked = 0;
; 1273 :         inst1 = 0;
; 1274 :         intr0 = 0;
; 1275 :         intr1 = 0;
; 1276 :         READ_TIMESTAMP(loop0);
; 1277 : #endif
; 1278 :         assert(stack_pointer >= f->f_valuestack); /* else underflow */

  00251	49 3b b7 98 00
	00 00		 cmp	 rsi, QWORD PTR [r15+152]
  00258	73 1a		 jae	 SHORT $LN553@PyEval_Eva
  0025a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@PPDGCIBF@?$AAs?$AAt?$AAa?$AAc?$AAk?$AA_?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AAf?$AA?9?$AA?$DO?$AAf?$AA_?$AAv?$AAa?$AAl?$AAu?$AAe?$AAs?$AAt?$AAa?$AAc?$AAk@
  00268	41 b8 fe 04 00
	00		 mov	 r8d, 1278		; 000004feH
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN553@PyEval_Eva:

; 1279 :         assert(STACK_LEVEL() <= co->co_stacksize);  /* else overflow */

  00274	48 8b c6	 mov	 rax, rsi
  00277	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  0027e	48 c1 f8 03	 sar	 rax, 3
  00282	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  00285	7e 1a		 jle	 SHORT $LN554@PyEval_Eva
  00287	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0028e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  00295	41 b8 ff 04 00
	00		 mov	 r8d, 1279		; 000004ffH
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN554@PyEval_Eva:

; 1280 : 
; 1281 : #ifdef WITH_PARALLEL
; 1282 :         /* Parallel threads skip the normal thread periodic tasks below. */
; 1283 : 
; 1284 :         if (tstate->is_parallel_thread) {

  002a1	83 bf a8 00 00
	00 00		 cmp	 DWORD PTR [rdi+168], 0
  002a8	0f 85 e5 00 00
	00		 jne	 $fast_next_opcode_notracing$64533

; 1285 :             goto fast_next_opcode_notracing;
; 1286 :         }
; 1287 : #endif /* WITH_PARALLEL */
; 1288 : 
; 1289 : 
; 1290 :         /* Do periodic things.  Doing this every time through
; 1291 :            the loop would add too much overhead, so we do it
; 1292 :            only every Nth instruction.  We also do it if
; 1293 :            ``pendingcalls_to_do'' is set, i.e. when an asynchronous
; 1294 :            event needs attention (e.g. a signal handler or
; 1295 :            async I/O handler); see Py_AddPendingCall() and
; 1296 :            Py_MakePendingCalls() above. */
; 1297 : 
; 1298 :         if (_Py_atomic_load_relaxed(&eval_breaker)) {

  002ae	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR eval_breaker, 0
  002b5	0f 84 89 08 00
	00		 je	 $LN983@PyEval_Eva

; 1299 :             if (*next_instr == SETUP_FINALLY) {

  002bb	41 80 3c 24 7a	 cmp	 BYTE PTR [r12], 122	; 0000007aH
  002c0	0f 84 7e 08 00
	00		 je	 $LN983@PyEval_Eva

; 1300 :                 /* Make the last opcode before
; 1301 :                    a try: finally: block uninterruptible. */
; 1302 :                 goto fast_next_opcode;
; 1303 :             }
; 1304 :             tstate->tick_counter++;

  002c6	ff 87 80 00 00
	00		 inc	 DWORD PTR [rdi+128]

; 1305 : #ifdef WITH_TSC
; 1306 :             ticked = 1;
; 1307 : #endif
; 1308 :             if (_Py_atomic_load_relaxed(&pendingcalls_to_do)) {

  002cc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pendingcalls_to_do, 0
  002d3	74 19		 je	 SHORT $LN944@PyEval_Eva

; 1309 :                 if (Py_MakePendingCalls() < 0) {

  002d5	e8 00 00 00 00	 call	 Py_MakePendingCalls
  002da	85 c0		 test	 eax, eax
  002dc	79 10		 jns	 SHORT $LN944@PyEval_Eva

; 1310 :                     why = WHY_EXCEPTION;

  002de	bb 02 00 00 00	 mov	 ebx, 2
  002e3	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx

; 1311 :                     goto on_error;

  002e9	e9 8a 09 00 00	 jmp	 $LN82@PyEval_Eva
$LN944@PyEval_Eva:

; 1312 :                 }
; 1313 :             }
; 1314 : #ifdef WITH_THREAD
; 1315 :             if (_Py_atomic_load_relaxed(&gil_drop_request)) {

  002ee	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR gil_drop_request, 0
  002f5	74 41		 je	 SHORT $LN945@PyEval_Eva

; 1316 :                 /* Give another thread a chance */
; 1317 :                 if (PyThreadState_Swap(NULL) != tstate)

  002f7	33 c9		 xor	 ecx, ecx
  002f9	e8 00 00 00 00	 call	 PyThreadState_Swap
  002fe	48 3b c7	 cmp	 rax, rdi
  00301	74 0c		 je	 SHORT $LN530@PyEval_Eva

; 1318 :                     Py_FatalError("ceval: tstate mix-up");

  00303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@FFPEPKAJ@ceval?3?5tstate?5mix?9up?$AA@
  0030a	e8 00 00 00 00	 call	 Py_FatalError
$LN530@PyEval_Eva:

; 1319 :                 drop_gil(tstate);

  0030f	48 8b cf	 mov	 rcx, rdi
  00312	e8 00 00 00 00	 call	 drop_gil

; 1320 : 
; 1321 :                 /* Other threads may run now */
; 1322 : 
; 1323 :                 take_gil(tstate);

  00317	48 8b cf	 mov	 rcx, rdi
  0031a	e8 00 00 00 00	 call	 take_gil

; 1324 :                 if (PyThreadState_Swap(tstate) != NULL)

  0031f	48 8b cf	 mov	 rcx, rdi
  00322	e8 00 00 00 00	 call	 PyThreadState_Swap
  00327	48 85 c0	 test	 rax, rax
  0032a	74 0c		 je	 SHORT $LN945@PyEval_Eva

; 1325 :                     Py_FatalError("ceval: orphan tstate");

  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@OIDPILMB@ceval?3?5orphan?5tstate?$AA@
  00333	e8 00 00 00 00	 call	 Py_FatalError
$LN945@PyEval_Eva:

; 1326 :             }
; 1327 : #endif
; 1328 :             /* Check for asynchronous exceptions. */
; 1329 :             if (tstate->async_exc != NULL) {

  00338	48 8b 87 88 00
	00 00		 mov	 rax, QWORD PTR [rdi+136]
  0033f	48 85 c0	 test	 rax, rax
  00342	0f 84 fc 07 00
	00		 je	 $LN983@PyEval_Eva

; 1330 :                 x = tstate->async_exc;

  00348	4c 8b f0	 mov	 r14, rax
  0034b	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 1331 :                 tstate->async_exc = NULL;
; 1332 :                 UNSIGNAL_ASYNC_EXC();

  00350	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR gil_drop_request
  00356	0b 05 00 00 00
	00		 or	 eax, DWORD PTR pendingcalls_to_do
  0035c	45 33 e4	 xor	 r12d, r12d

; 1333 :                 PyErr_SetNone(x);

  0035f	49 8b ce	 mov	 rcx, r14
  00362	89 05 00 00 00
	00		 mov	 DWORD PTR eval_breaker, eax
  00368	4c 89 a7 88 00
	00 00		 mov	 QWORD PTR [rdi+136], r12
  0036f	44 89 25 00 00
	00 00		 mov	 DWORD PTR pending_async_exc, r12d
  00376	e8 00 00 00 00	 call	 PyErr_SetNone

; 1334 :                 Py_DECREF(x);

  0037b	49 8b ce	 mov	 rcx, r14
  0037e	e8 00 00 00 00	 call	 _Py_DecRef

; 1335 :                 why = WHY_EXCEPTION;

  00383	bb 02 00 00 00	 mov	 ebx, 2
  00388	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx

; 1336 :                 goto on_error;

  0038e	e9 e5 08 00 00	 jmp	 $LN82@PyEval_Eva
$fast_next_opcode_notracing$64533:

; 1362 :                 /* trace function raised an exception */
; 1363 :                 goto on_error;
; 1364 :             }
; 1365 :         }
; 1366 : 
; 1367 :         /* Extract opcode and argument */
; 1368 : #ifdef WITH_PARALLEL
; 1369 :     fast_next_opcode_notracing:
; 1370 : #endif
; 1371 :         opcode = NEXTOP();

  00393	48 8b 44 24 40	 mov	 rax, QWORD PTR next_instr$1$[rsp]

; 1372 :         oparg = 0;   /* allows oparg to be stored in a register because

  00398	45 33 ed	 xor	 r13d, r13d
  0039b	0f b6 38	 movzx	 edi, BYTE PTR [rax]
  0039e	48 ff c0	 inc	 rax
  003a1	48 89 44 24 40	 mov	 QWORD PTR next_instr$1$[rsp], rax

; 1373 :             it doesn't have to be remembered across a full loop */
; 1374 :         if (HAS_ARG(opcode))

  003a6	83 ff 5a	 cmp	 edi, 90			; 0000005aH
  003a9	7c 19		 jl	 SHORT $LN953@PyEval_Eva

; 1375 :             oparg = NEXTARG();

  003ab	44 0f b6 68 01	 movzx	 r13d, BYTE PTR [rax+1]
  003b0	48 83 c0 02	 add	 rax, 2
  003b4	48 89 44 24 40	 mov	 QWORD PTR next_instr$1$[rsp], rax
  003b9	0f b6 40 fe	 movzx	 eax, BYTE PTR [rax-2]
  003bd	41 c1 e5 08	 shl	 r13d, 8
  003c1	44 03 e8	 add	 r13d, eax
$LN953@PyEval_Eva:
  003c4	4c 8b 64 24 40	 mov	 r12, QWORD PTR next_instr$1$[rsp]
  003c9	0f 1f 80 00 00
	00 00		 npad	 7
$dispatch_opcode$64561:

; 1376 :     dispatch_opcode:
; 1377 : #ifdef DYNAMIC_EXECUTION_PROFILE
; 1378 : #ifdef DXPAIRS
; 1379 :         dxpairs[lastopcode][opcode]++;
; 1380 :         lastopcode = opcode;
; 1381 : #endif
; 1382 :         dxp[opcode]++;
; 1383 : #endif
; 1384 : 
; 1385 : #ifdef LLTRACE
; 1386 :         /* Instruction tracing */
; 1387 : 
; 1388 :         if (lltrace) {

  003d0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  003d7	74 2e		 je	 SHORT $LN518@PyEval_Eva

; 1389 :             if (HAS_ARG(opcode)) {
; 1390 :                 printf("%d: %d, %d\n",
; 1391 :                        f->f_lasti, opcode, oparg);

  003d9	41 8b 97 d0 00
	00 00		 mov	 edx, DWORD PTR [r15+208]
  003e0	44 8b c7	 mov	 r8d, edi
  003e3	83 ff 5a	 cmp	 edi, 90			; 0000005aH
  003e6	7c 12		 jl	 SHORT $LN519@PyEval_Eva
  003e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@EEIINKGH@?$CFd?3?5?$CFd?0?5?$CFd?6?$AA@
  003ef	45 8b cd	 mov	 r9d, r13d
  003f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 1392 :             }
; 1393 :             else {

  003f8	eb 0d		 jmp	 SHORT $LN518@PyEval_Eva
$LN519@PyEval_Eva:

; 1394 :                 printf("%d: %d\n",
; 1395 :                        f->f_lasti, opcode);

  003fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07BCEPPLOH@?$CFd?3?5?$CFd?6?$AA@
  00401	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN518@PyEval_Eva:

; 1396 :             }
; 1397 :         }
; 1398 : #endif
; 1399 : 
; 1400 :         /* Main switch on opcode */
; 1401 :         READ_TIMESTAMP(inst0);
; 1402 : 
; 1403 :         switch (opcode) {

  00407	8d 47 ff	 lea	 eax, DWORD PTR [rdi-1]
  0040a	3d 92 00 00 00	 cmp	 eax, 146		; 00000092H
  0040f	0f 87 21 37 00
	00		 ja	 $LN88@PyEval_Eva
  00415	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  0041c	48 98		 cdqe
  0041e	0f b6 84 02 00
	00 00 00	 movzx	 eax, BYTE PTR $LN922@PyEval_Eva[rdx+rax]
  00426	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN923@PyEval_Eva[rdx+rax*4]
  0042d	48 03 ca	 add	 rcx, rdx
  00430	ff e1		 jmp	 rcx
$LN89@PyEval_Eva:

; 2913 :             break;
; 2914 : 
; 2915 :         TARGET(EXTENDED_ARG)
; 2916 :             opcode = NEXTOP();
; 2917 :             oparg = oparg<<16 | NEXTARG();

  00432	41 0f b6 44 24
	01		 movzx	 eax, BYTE PTR [r12+1]
  00438	41 0f b6 3c 24	 movzx	 edi, BYTE PTR [r12]
  0043d	41 0f b6 4c 24
	02		 movzx	 ecx, BYTE PTR [r12+2]
  00443	49 83 c4 03	 add	 r12, 3
  00447	c1 e1 08	 shl	 ecx, 8
  0044a	03 c8		 add	 ecx, eax
  0044c	41 8b c5	 mov	 eax, r13d
  0044f	4c 89 64 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r12
  00454	c1 e0 10	 shl	 eax, 16
  00457	44 8b e9	 mov	 r13d, ecx
  0045a	44 0b e8	 or	 r13d, eax

; 2918 :             goto dispatch_opcode;

  0045d	e9 6e ff ff ff	 jmp	 $dispatch_opcode$64561
$LN514@PyEval_Eva:

; 1404 : 
; 1405 :         /* BEWARE!
; 1406 :            It is essential that any operation that fails sets either
; 1407 :            x to NULL, err to nonzero, or why to anything but WHY_NOT,
; 1408 :            and that no operation that succeeds does this! */
; 1409 : 
; 1410 :         TARGET(NOP)
; 1411 :             FAST_DISPATCH();
; 1412 : 
; 1413 :         TARGET(LOAD_FAST)
; 1414 :             x = GETLOCAL(oparg);

  00462	49 63 c5	 movsxd	 rax, r13d
  00465	4d 8b b4 c7 d0
	01 00 00	 mov	 r14, QWORD PTR [r15+rax*8+464]
  0046d	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14

; 1415 :             if (x != NULL) {

  00472	4d 85 f6	 test	 r14, r14
  00475	0f 84 6a 07 00
	00		 je	 $LN513@PyEval_Eva

; 1416 :                 Py_INCREF(x);

  0047b	49 8b ce	 mov	 rcx, r14
  0047e	e8 00 00 00 00	 call	 _Py_IncRef

; 1417 :                 PUSH(x);

  00483	4c 89 36	 mov	 QWORD PTR [rsi], r14
  00486	48 83 c6 08	 add	 rsi, 8
  0048a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00491	74 10		 je	 SHORT $LN555@PyEval_Eva
  00493	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  00497	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  0049e	e8 00 00 00 00	 call	 prtrace
$LN555@PyEval_Eva:
  004a3	48 8b c6	 mov	 rax, rsi
  004a6	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  004ad	48 c1 f8 03	 sar	 rax, 3
  004b1	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  004b4	0f 8e 85 06 00
	00		 jle	 $LN980@PyEval_Eva
  004ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  004c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  004c8	41 b8 89 05 00
	00		 mov	 r8d, 1417		; 00000589H
  004ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 1418 :                 FAST_DISPATCH();

  004d4	e9 66 06 00 00	 jmp	 $LN980@PyEval_Eva
$LN512@PyEval_Eva:

; 1424 : 
; 1425 :         TARGET(LOAD_CONST)
; 1426 :             x = GETITEM(consts, oparg);

  004d9	48 8b 4d b0	 mov	 rcx, QWORD PTR consts$1$[rbp-256]
  004dd	49 63 d5	 movsxd	 rdx, r13d
  004e0	e8 00 00 00 00	 call	 PyTuple_GetItem

; 1427 :             Py_INCREF(x);

  004e5	48 8b c8	 mov	 rcx, rax
  004e8	4c 8b f0	 mov	 r14, rax
  004eb	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  004f0	e8 00 00 00 00	 call	 _Py_IncRef

; 1428 :             PUSH(x);

  004f5	4c 89 36	 mov	 QWORD PTR [rsi], r14
  004f8	48 83 c6 08	 add	 rsi, 8
  004fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00503	74 10		 je	 SHORT $LN557@PyEval_Eva
  00505	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  00509	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  00510	e8 00 00 00 00	 call	 prtrace
$LN557@PyEval_Eva:
  00515	48 8b c6	 mov	 rax, rsi
  00518	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  0051f	48 c1 f8 03	 sar	 rax, 3
  00523	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  00526	0f 8e 13 06 00
	00		 jle	 $LN980@PyEval_Eva
  0052c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00533	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  0053a	41 b8 94 05 00
	00		 mov	 r8d, 1428		; 00000594H
  00540	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 1429 :             FAST_DISPATCH();

  00546	e9 f4 05 00 00	 jmp	 $LN980@PyEval_Eva
$LN503@PyEval_Eva:

; 1435 :             FAST_DISPATCH();
; 1436 : 
; 1437 :         TARGET(POP_TOP)
; 1438 :             v = POP();

  0054b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00552	74 10		 je	 SHORT $LN560@PyEval_Eva
  00554	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  00558	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0055f	e8 00 00 00 00	 call	 prtrace
$LN560@PyEval_Eva:

; 1439 :             Py_DECREF(v);

  00564	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  00568	48 83 ee 08	 sub	 rsi, 8

; 1440 :             FAST_DISPATCH();

  0056c	e9 c9 05 00 00	 jmp	 $LN1072@PyEval_Eva
$LN502@PyEval_Eva:

; 1441 : 
; 1442 :         TARGET(ROT_TWO)
; 1443 :             v = TOP();

  00571	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]

; 1444 :             w = SECOND();
; 1445 :             SET_TOP(w);

  00575	48 8b 46 f0	 mov	 rax, QWORD PTR [rsi-16]
  00579	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax

; 1446 :             SET_SECOND(v);

  0057d	48 89 4e f0	 mov	 QWORD PTR [rsi-16], rcx

; 1447 :             FAST_DISPATCH();

  00581	e9 b9 05 00 00	 jmp	 $LN980@PyEval_Eva
$LN501@PyEval_Eva:

; 1448 : 
; 1449 :         TARGET(ROT_THREE)
; 1450 :             v = TOP();
; 1451 :             w = SECOND();
; 1452 :             x = THIRD();

  00586	4c 8b 76 e8	 mov	 r14, QWORD PTR [rsi-24]
  0058a	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]

; 1453 :             SET_TOP(w);

  0058e	48 8b 46 f0	 mov	 rax, QWORD PTR [rsi-16]
  00592	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14
  00597	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax

; 1454 :             SET_SECOND(x);

  0059b	4c 89 76 f0	 mov	 QWORD PTR [rsi-16], r14

; 1455 :             SET_THIRD(v);

  0059f	48 89 4e e8	 mov	 QWORD PTR [rsi-24], rcx

; 1456 :             FAST_DISPATCH();

  005a3	e9 97 05 00 00	 jmp	 $LN980@PyEval_Eva
$LN500@PyEval_Eva:

; 1457 : 
; 1458 :         TARGET(DUP_TOP)
; 1459 :             v = TOP();

  005a8	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]

; 1460 :             Py_INCREF(v);

  005ac	48 8b cb	 mov	 rcx, rbx
  005af	e8 00 00 00 00	 call	 _Py_IncRef

; 1461 :             PUSH(v);

  005b4	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  005b7	48 83 c6 08	 add	 rsi, 8
  005bb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  005c2	74 10		 je	 SHORT $LN561@PyEval_Eva
  005c4	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  005c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  005cf	e8 00 00 00 00	 call	 prtrace
$LN561@PyEval_Eva:
  005d4	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  005d9	48 8b c6	 mov	 rax, rsi
  005dc	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  005e3	48 c1 f8 03	 sar	 rax, 3
  005e7	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  005ea	0f 8e 4f 05 00
	00		 jle	 $LN980@PyEval_Eva
  005f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  005f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  005fe	41 b8 b5 05 00
	00		 mov	 r8d, 1461		; 000005b5H
  00604	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 1462 :             FAST_DISPATCH();

  0060a	e9 30 05 00 00	 jmp	 $LN980@PyEval_Eva
$LN499@PyEval_Eva:

; 1463 : 
; 1464 :         TARGET(DUP_TOP_TWO)
; 1465 :             x = TOP();

  0060f	4c 8b 76 f8	 mov	 r14, QWORD PTR [rsi-8]

; 1466 :             Py_INCREF(x);

  00613	49 8b ce	 mov	 rcx, r14
  00616	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14
  0061b	e8 00 00 00 00	 call	 _Py_IncRef

; 1467 :             w = SECOND();

  00620	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]

; 1468 :             Py_INCREF(w);

  00624	48 8b cb	 mov	 rcx, rbx
  00627	e8 00 00 00 00	 call	 _Py_IncRef

; 1469 :             STACKADJ(2);

  0062c	48 83 c6 10	 add	 rsi, 16
  00630	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00637	74 10		 je	 SHORT $LN563@PyEval_Eva
  00639	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0063d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  00644	e8 00 00 00 00	 call	 prtrace
$LN563@PyEval_Eva:
  00649	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  0064e	48 8b c6	 mov	 rax, rsi
  00651	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  00658	48 c1 f8 03	 sar	 rax, 3
  0065c	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  0065f	7e 1a		 jle	 SHORT $LN564@PyEval_Eva
  00661	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00668	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  0066f	41 b8 bd 05 00
	00		 mov	 r8d, 1469		; 000005bdH
  00675	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN564@PyEval_Eva:

; 1470 :             SET_TOP(x);
; 1471 :             SET_SECOND(w);

  0067b	48 89 5e f0	 mov	 QWORD PTR [rsi-16], rbx

; 1472 :             FAST_DISPATCH();

  0067f	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  00684	4c 89 76 f8	 mov	 QWORD PTR [rsi-8], r14
  00688	e9 b2 04 00 00	 jmp	 $LN980@PyEval_Eva
$LN223@PyEval_Eva:

; 2334 :             Py_DECREF(v);
; 2335 :             SET_TOP(x);
; 2336 :             if (x != NULL) DISPATCH();
; 2337 :             break;
; 2338 : 
; 2339 :         TARGET(COMPARE_OP)
; 2340 :             w = POP();

  0068d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00694	74 10		 je	 SHORT $LN666@PyEval_Eva
  00696	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0069a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  006a1	e8 00 00 00 00	 call	 prtrace
$LN666@PyEval_Eva:
  006a6	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 2341 :             v = TOP();

  006aa	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  006ae	48 83 ee 08	 sub	 rsi, 8

; 2342 :             x = cmp_outcome(oparg, v, w);

  006b2	4c 8b c7	 mov	 r8, rdi
  006b5	48 8b d3	 mov	 rdx, rbx
  006b8	41 8b cd	 mov	 ecx, r13d
  006bb	e8 00 00 00 00	 call	 cmp_outcome

; 2343 :             Py_DECREF(v);

  006c0	48 8b cb	 mov	 rcx, rbx
  006c3	4c 8b f0	 mov	 r14, rax
  006c6	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  006cb	e8 00 00 00 00	 call	 _Py_DecRef

; 2344 :             Py_DECREF(w);

  006d0	48 8b cf	 mov	 rcx, rdi
  006d3	e8 00 00 00 00	 call	 _Py_DecRef

; 2345 :             SET_TOP(x);

  006d8	4c 89 76 f8	 mov	 QWORD PTR [rsi-8], r14

; 2346 :             if (x == NULL) break;

  006dc	4d 85 f6	 test	 r14, r14
  006df	0f 84 25 05 00
	00		 je	 $LN1017@PyEval_Eva

; 2347 :             PREDICT(POP_JUMP_IF_FALSE);

  006e5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next_instr$1$[rsp]
  006ea	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  006ed	3c 72		 cmp	 al, 114			; 00000072H
  006ef	75 5c		 jne	 SHORT $LN221@PyEval_Eva

; 2442 : 
; 2443 :         PREDICTED_WITH_ARG(POP_JUMP_IF_FALSE);

  006f1	44 0f b6 69 02	 movzx	 r13d, BYTE PTR [rcx+2]
  006f6	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
$PRED_POP_JUMP_IF_FALSE$65290:
  006fa	41 c1 e5 08	 shl	 r13d, 8
  006fe	44 03 e8	 add	 r13d, eax
  00701	48 83 c1 03	 add	 rcx, 3
  00705	48 89 4c 24 40	 mov	 QWORD PTR next_instr$1$[rsp], rcx
$LN194@PyEval_Eva:

; 2444 :         TARGET(POP_JUMP_IF_FALSE)
; 2445 :             w = POP();

  0070a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00711	74 10		 je	 SHORT $LN676@PyEval_Eva
  00713	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  00717	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0071e	e8 00 00 00 00	 call	 prtrace
$LN676@PyEval_Eva:
  00723	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  00727	48 83 ee 08	 sub	 rsi, 8

; 2446 :             if (w == Py_True) {

  0072b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00732	48 3b d8	 cmp	 rbx, rax
  00735	0f 85 a4 00 00
	00		 jne	 $LN193@PyEval_Eva
$LN1032@PyEval_Eva:

; 2447 :                 Py_DECREF(w);

  0073b	48 8b cb	 mov	 rcx, rbx
  0073e	e8 00 00 00 00	 call	 _Py_DecRef

; 2448 :                 FAST_DISPATCH();

  00743	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  00748	e9 f2 03 00 00	 jmp	 $LN980@PyEval_Eva
$LN221@PyEval_Eva:

; 2348 :             PREDICT(POP_JUMP_IF_TRUE);

  0074d	3c 73		 cmp	 al, 115			; 00000073H
  0074f	0f 85 ed fa ff
	ff		 jne	 $LN1064@PyEval_Eva

; 2464 : 
; 2465 :         PREDICTED_WITH_ARG(POP_JUMP_IF_TRUE);

  00755	44 0f b6 69 02	 movzx	 r13d, BYTE PTR [rcx+2]
  0075a	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
$PRED_POP_JUMP_IF_TRUE$65292:
  0075e	41 c1 e5 08	 shl	 r13d, 8
  00762	44 03 e8	 add	 r13d, eax
  00765	48 83 c1 03	 add	 rcx, 3
  00769	48 89 4c 24 40	 mov	 QWORD PTR next_instr$1$[rsp], rcx
$LN187@PyEval_Eva:

; 2466 :         TARGET(POP_JUMP_IF_TRUE)
; 2467 :             w = POP();

  0076e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00775	74 10		 je	 SHORT $LN677@PyEval_Eva
  00777	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0077b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  00782	e8 00 00 00 00	 call	 prtrace
$LN677@PyEval_Eva:
  00787	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  0078b	48 83 ee 08	 sub	 rsi, 8

; 2468 :             if (w == Py_False) {

  0078f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00796	48 3b d8	 cmp	 rbx, rax

; 2469 :                 Py_DECREF(w);
; 2470 :                 FAST_DISPATCH();

  00799	74 a0		 je	 SHORT $LN1032@PyEval_Eva

; 2471 :             }
; 2472 :             if (w == Py_True) {

  0079b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct

; 2473 :                 Py_DECREF(w);

  007a2	48 8b cb	 mov	 rcx, rbx
  007a5	48 3b d8	 cmp	 rbx, rax
  007a8	0f 85 34 05 00
	00		 jne	 $LN185@PyEval_Eva
  007ae	e8 00 00 00 00	 call	 _Py_DecRef

; 2474 :                 JUMPTO(oparg);
; 2475 :                 FAST_DISPATCH();

  007b3	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  007b8	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  007bd	4d 63 dd	 movsxd	 r11, r13d
  007c0	4c 03 5c 24 50	 add	 r11, QWORD PTR first_instr$1$[rsp]
  007c5	4c 89 5c 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r11
  007ca	e9 7a 03 00 00	 jmp	 $fast_next_opcode$64536
$LN195@PyEval_Eva:

; 2438 : 
; 2439 :         TARGET(JUMP_FORWARD)
; 2440 :             JUMPBY(oparg);

  007cf	49 63 c5	 movsxd	 rax, r13d
  007d2	4c 03 e0	 add	 r12, rax
  007d5	4c 89 64 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r12

; 2441 :             FAST_DISPATCH();

  007da	e9 60 03 00 00	 jmp	 $LN980@PyEval_Eva
$LN193@PyEval_Eva:

; 2449 :             }
; 2450 :             if (w == Py_False) {

  007df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct

; 2451 :                 Py_DECREF(w);

  007e6	48 8b cb	 mov	 rcx, rbx
  007e9	48 3b d8	 cmp	 rbx, rax
  007ec	0f 85 b2 04 00
	00		 jne	 $LN192@PyEval_Eva
  007f2	e8 00 00 00 00	 call	 _Py_DecRef
$LN1033@PyEval_Eva:

; 2452 :                 JUMPTO(oparg);
; 2453 :                 FAST_DISPATCH();

  007f7	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  007fc	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  00801	4d 63 dd	 movsxd	 r11, r13d
  00804	4c 03 5c 24 50	 add	 r11, QWORD PTR first_instr$1$[rsp]
  00809	4c 89 5c 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r11
  0080e	e9 36 03 00 00	 jmp	 $fast_next_opcode$64536
$LN180@PyEval_Eva:

; 2488 : 
; 2489 :         TARGET(JUMP_IF_FALSE_OR_POP)
; 2490 :             w = TOP();

  00813	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  00817	48 8d 46 f8	 lea	 rax, QWORD PTR [rsi-8]

; 2491 :             if (w == Py_True) {

  0081b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00822	48 3b d9	 cmp	 rbx, rcx
  00825	75 64		 jne	 SHORT $LN179@PyEval_Eva

; 2492 :                 STACKADJ(-1);

  00827	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0082e	48 8b f0	 mov	 rsi, rax
  00831	74 10		 je	 SHORT $LN678@PyEval_Eva
  00833	48 8b 48 f8	 mov	 rcx, QWORD PTR [rax-8]
  00837	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  0083e	e8 00 00 00 00	 call	 prtrace
$LN678@PyEval_Eva:
  00843	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  00848	48 8b c6	 mov	 rax, rsi
  0084b	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  00852	48 c1 f8 03	 sar	 rax, 3
  00856	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  00859	0f 8e dc fe ff
	ff		 jle	 $LN1032@PyEval_Eva
  0085f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00866	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  0086d	41 b8 bc 09 00
	00		 mov	 r8d, 2492		; 000009bcH
  00873	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00879	48 8b cb	 mov	 rcx, rbx
  0087c	e8 00 00 00 00	 call	 _Py_DecRef
  00881	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  00886	e9 b4 02 00 00	 jmp	 $LN980@PyEval_Eva
$LN179@PyEval_Eva:

; 2493 :                 Py_DECREF(w);
; 2494 :                 FAST_DISPATCH();
; 2495 :             }
; 2496 :             if (w == Py_False) {

  0088b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_FalseStruct
  00892	48 3b d8	 cmp	 rbx, rax
  00895	0f 84 5c ff ff
	ff		 je	 $LN1033@PyEval_Eva

; 2497 :                 JUMPTO(oparg);
; 2498 :                 FAST_DISPATCH();
; 2499 :             }
; 2500 :             err = PyObject_IsTrue(w);

  0089b	48 8b cb	 mov	 rcx, rbx
  0089e	e8 00 00 00 00	 call	 PyObject_IsTrue
  008a3	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax

; 2501 :             if (err > 0) {

  008a9	85 c0		 test	 eax, eax
  008ab	0f 8e 74 04 00
	00		 jle	 $LN1035@PyEval_Eva

; 2502 :                 STACKADJ(-1);

  008b1	48 83 ee 08	 sub	 rsi, 8
  008b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  008bc	74 10		 je	 SHORT $LN680@PyEval_Eva
  008be	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  008c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  008c9	e8 00 00 00 00	 call	 prtrace
$LN680@PyEval_Eva:
  008ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  008d3	48 8b c6	 mov	 rax, rsi
  008d6	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  008dd	48 c1 f8 03	 sar	 rax, 3
  008e1	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  008e4	7e 1a		 jle	 SHORT $LN681@PyEval_Eva
  008e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  008ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  008f4	41 b8 c6 09 00
	00		 mov	 r8d, 2502		; 000009c6H
  008fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN681@PyEval_Eva:

; 2503 :                 Py_DECREF(w);

  00900	48 8b cb	 mov	 rcx, rbx
  00903	e8 00 00 00 00	 call	 _Py_DecRef

; 2504 :                 err = 0;

  00908	33 ff		 xor	 edi, edi
  0090a	89 bd 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], edi
  00910	e9 32 f9 ff ff	 jmp	 $LN1065@PyEval_Eva
$LN173@PyEval_Eva:

; 2511 : 
; 2512 :         TARGET(JUMP_IF_TRUE_OR_POP)
; 2513 :             w = TOP();

  00915	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  00919	48 8d 46 f8	 lea	 rax, QWORD PTR [rsi-8]

; 2514 :             if (w == Py_False) {

  0091d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_FalseStruct
  00924	48 3b d9	 cmp	 rbx, rcx
  00927	75 64		 jne	 SHORT $LN172@PyEval_Eva

; 2515 :                 STACKADJ(-1);

  00929	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00930	48 8b f0	 mov	 rsi, rax
  00933	74 10		 je	 SHORT $LN682@PyEval_Eva
  00935	48 8b 48 f8	 mov	 rcx, QWORD PTR [rax-8]
  00939	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  00940	e8 00 00 00 00	 call	 prtrace
$LN682@PyEval_Eva:
  00945	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  0094a	48 8b c6	 mov	 rax, rsi
  0094d	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  00954	48 c1 f8 03	 sar	 rax, 3
  00958	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  0095b	0f 8e da fd ff
	ff		 jle	 $LN1032@PyEval_Eva
  00961	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00968	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  0096f	41 b8 d3 09 00
	00		 mov	 r8d, 2515		; 000009d3H
  00975	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0097b	48 8b cb	 mov	 rcx, rbx
  0097e	e8 00 00 00 00	 call	 _Py_DecRef
  00983	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  00988	e9 b2 01 00 00	 jmp	 $LN980@PyEval_Eva
$LN172@PyEval_Eva:

; 2516 :                 Py_DECREF(w);
; 2517 :                 FAST_DISPATCH();
; 2518 :             }
; 2519 :             if (w == Py_True) {

  0098d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_TrueStruct
  00994	48 3b d8	 cmp	 rbx, rax
  00997	0f 84 5a fe ff
	ff		 je	 $LN1033@PyEval_Eva

; 2520 :                 JUMPTO(oparg);
; 2521 :                 FAST_DISPATCH();
; 2522 :             }
; 2523 :             err = PyObject_IsTrue(w);

  0099d	48 8b cb	 mov	 rcx, rbx
  009a0	e8 00 00 00 00	 call	 PyObject_IsTrue
  009a5	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax

; 2524 :             if (err > 0) {

  009ab	85 c0		 test	 eax, eax

; 2525 :                 err = 0;
; 2526 :                 JUMPTO(oparg);

  009ad	0f 8f 48 03 00
	00		 jg	 $LN1036@PyEval_Eva

; 2527 :             }
; 2528 :             else if (err == 0) {

  009b3	44 8b e8	 mov	 r13d, eax
  009b6	85 c0		 test	 eax, eax
  009b8	0f 85 53 02 00
	00		 jne	 $LN1039@PyEval_Eva

; 2529 :                 STACKADJ(-1);

  009be	48 83 ee 08	 sub	 rsi, 8
  009c2	39 05 00 00 00
	00		 cmp	 DWORD PTR lltrace, eax
  009c8	74 10		 je	 SHORT $LN684@PyEval_Eva
  009ca	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  009ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  009d5	e8 00 00 00 00	 call	 prtrace
$LN684@PyEval_Eva:
  009da	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  009df	48 8b c6	 mov	 rax, rsi
  009e2	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  009e9	48 c1 f8 03	 sar	 rax, 3
  009ed	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  009f0	7e 1a		 jle	 SHORT $LN685@PyEval_Eva
  009f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  009f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  00a00	41 b8 e1 09 00
	00		 mov	 r8d, 2529		; 000009e1H
  00a06	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN685@PyEval_Eva:

; 2530 :                 Py_DECREF(w);

  00a0c	48 8b cb	 mov	 rcx, rbx
  00a0f	e8 00 00 00 00	 call	 _Py_DecRef

; 2531 :             }
; 2532 :             else
; 2533 :                 break;
; 2534 :             DISPATCH();

  00a14	e9 2e f8 ff ff	 jmp	 $LN1065@PyEval_Eva
$LN165@PyEval_Eva:

; 2550 : #endif
; 2551 : 
; 2552 :         TARGET(GET_ITER)
; 2553 :             /* before: [obj]; after [getiter(obj)] */
; 2554 :             v = TOP();

  00a19	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]

; 2555 :             x = PyObject_GetIter(v);

  00a1d	48 8b cb	 mov	 rcx, rbx
  00a20	e8 00 00 00 00	 call	 PyObject_GetIter

; 2556 :             Py_DECREF(v);

  00a25	48 8b cb	 mov	 rcx, rbx
  00a28	4c 8b f0	 mov	 r14, rax
  00a2b	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  00a30	e8 00 00 00 00	 call	 _Py_DecRef

; 2557 :             if (x != NULL) {

  00a35	4d 85 f6	 test	 r14, r14
  00a38	0f 84 ff 02 00
	00		 je	 $LN164@PyEval_Eva

; 2558 :                 SET_TOP(x);
; 2559 :                 PREDICT(FOR_ITER);

  00a3e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next_instr$1$[rsp]
  00a43	4c 89 76 f8	 mov	 QWORD PTR [rsi-8], r14
  00a47	80 39 5d	 cmp	 BYTE PTR [rcx], 93	; 0000005dH
  00a4a	0f 85 f2 f7 ff
	ff		 jne	 $LN1064@PyEval_Eva

; 2564 : 
; 2565 :         PREDICTED_WITH_ARG(FOR_ITER);

  00a50	44 0f b6 69 02	 movzx	 r13d, BYTE PTR [rcx+2]
  00a55	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00a59	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  00a5e	41 c1 e5 08	 shl	 r13d, 8
$PRED_FOR_ITER$65414:
  00a62	44 03 e8	 add	 r13d, eax
  00a65	48 83 c1 03	 add	 rcx, 3
  00a69	48 89 4c 24 40	 mov	 QWORD PTR next_instr$1$[rsp], rcx
$LN162@PyEval_Eva:

; 2566 :         TARGET(FOR_ITER)
; 2567 :             /* before: [iter]; after: [iter, iter()] *or* [] */
; 2568 :             v = TOP();

  00a6e	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]

; 2569 :             x = (*v->ob_type->tp_iternext)(v);

  00a72	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00a76	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]
  00a7c	4c 8b f0	 mov	 r14, rax
  00a7f	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2570 :             if (x != NULL) {

  00a84	48 85 c0	 test	 rax, rax
  00a87	0f 84 06 04 00
	00		 je	 $LN161@PyEval_Eva

; 2571 :                 PUSH(x);

  00a8d	48 89 06	 mov	 QWORD PTR [rsi], rax
  00a90	48 83 c6 08	 add	 rsi, 8
  00a94	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00a9b	74 10		 je	 SHORT $LN688@PyEval_Eva
  00a9d	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  00aa1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  00aa8	e8 00 00 00 00	 call	 prtrace
$LN688@PyEval_Eva:
  00aad	48 8b c6	 mov	 rax, rsi
  00ab0	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  00ab7	48 c1 f8 03	 sar	 rax, 3
  00abb	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  00abe	7e 1a		 jle	 SHORT $LN689@PyEval_Eva
  00ac0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00ac7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  00ace	41 b8 0b 0a 00
	00		 mov	 r8d, 2571		; 00000a0bH
  00ad4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN689@PyEval_Eva:

; 2572 :                 PREDICT(STORE_FAST);

  00ada	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next_instr$1$[rsp]
  00adf	80 39 7d	 cmp	 BYTE PTR [rcx], 125	; 0000007dH
  00ae2	0f 85 ad 02 00
	00		 jne	 $LN160@PyEval_Eva

; 1430 : 
; 1431 :         PREDICTED_WITH_ARG(STORE_FAST);

  00ae8	44 0f b6 69 02	 movzx	 r13d, BYTE PTR [rcx+2]
  00aed	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
$PRED_STORE_FAST$64586:
  00af1	41 c1 e5 08	 shl	 r13d, 8
  00af5	44 03 e8	 add	 r13d, eax
  00af8	48 83 c1 03	 add	 rcx, 3
  00afc	48 89 4c 24 40	 mov	 QWORD PTR next_instr$1$[rsp], rcx
$LN511@PyEval_Eva:

; 1432 :         TARGET(STORE_FAST)
; 1433 :             v = POP();

  00b01	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00b08	74 10		 je	 SHORT $LN559@PyEval_Eva
  00b0a	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  00b0e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  00b15	e8 00 00 00 00	 call	 prtrace
$LN559@PyEval_Eva:

; 1434 :             SETLOCAL(oparg, v);

  00b1a	48 8b 46 f8	 mov	 rax, QWORD PTR [rsi-8]
  00b1e	49 63 d5	 movsxd	 rdx, r13d
  00b21	48 83 ee 08	 sub	 rsi, 8
  00b25	49 8b 8c d7 d0
	01 00 00	 mov	 rcx, QWORD PTR [r15+rdx*8+464]
  00b2d	49 89 84 d7 d0
	01 00 00	 mov	 QWORD PTR [r15+rdx*8+464], rax
  00b35	48 85 c9	 test	 rcx, rcx
  00b38	74 05		 je	 SHORT $LN980@PyEval_Eva
$LN1072@PyEval_Eva:
  00b3a	e8 00 00 00 00	 call	 _Py_DecRef
$LN980@PyEval_Eva:

; 2989 : 
; 2990 :             if (tstate->c_tracefunc != NULL)

  00b3f	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
$LN983@PyEval_Eva:

; 1434 :             SETLOCAL(oparg, v);

  00b44	4c 8b 5c 24 40	 mov	 r11, QWORD PTR next_instr$1$[rsp]
$fast_next_opcode$64536:

; 1337 :             }
; 1338 :         }
; 1339 : 
; 1340 :     fast_next_opcode:
; 1341 :         f->f_lasti = INSTR_OFFSET();

  00b49	41 8b c3	 mov	 eax, r11d
  00b4c	2b 44 24 50	 sub	 eax, DWORD PTR first_instr$1$[rsp]

; 1342 : 
; 1343 :         /* line-by-line tracing support */
; 1344 : 
; 1345 :         if (_Py_TracingPossible &&
; 1346 :             tstate->c_tracefunc != NULL && !tstate->tracing) {

  00b50	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _Py_TracingPossible, 0
  00b57	41 89 87 d0 00
	00 00		 mov	 DWORD PTR [r15+208], eax
  00b5e	0f 84 2f f8 ff
	ff		 je	 $fast_next_opcode_notracing$64533
  00b64	48 83 7f 30 00	 cmp	 QWORD PTR [rdi+48], 0
  00b69	0f 84 24 f8 ff
	ff		 je	 $fast_next_opcode_notracing$64533
  00b6f	83 7f 20 00	 cmp	 DWORD PTR [rdi+32], 0
  00b73	0f 85 1a f8 ff
	ff		 jne	 $fast_next_opcode_notracing$64533

; 1347 :             /* see maybe_call_line_trace
; 1348 :                for expository comments */
; 1349 :             f->f_stacktop = stack_pointer;

  00b79	49 89 b7 a0 00
	00 00		 mov	 QWORD PTR [r15+160], rsi

; 1350 : 
; 1351 :             err = maybe_call_line_trace(tstate->c_tracefunc,
; 1352 :                                         tstate->c_traceobj,
; 1353 :                                         f, &instr_lb, &instr_ub,
; 1354 :                                         &instr_prev);

  00b80	48 8b 57 40	 mov	 rdx, QWORD PTR [rdi+64]
  00b84	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  00b88	48 8d 45 88	 lea	 rax, QWORD PTR instr_prev$[rbp-256]
  00b8c	4c 8d 4d 8c	 lea	 r9, QWORD PTR instr_lb$[rbp-256]
  00b90	4d 8b c7	 mov	 r8, r15
  00b93	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b98	48 8d 45 98	 lea	 rax, QWORD PTR instr_ub$[rbp-256]
  00b9c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ba1	e8 00 00 00 00	 call	 maybe_call_line_trace

; 1355 :             /* Reload possibly changed frame fields */
; 1356 :             JUMPTO(f->f_lasti);

  00ba6	4d 63 9f d0 00
	00 00		 movsxd	 r11, DWORD PTR [r15+208]
  00bad	4c 03 5c 24 50	 add	 r11, QWORD PTR first_instr$1$[rsp]
  00bb2	44 8b e8	 mov	 r13d, eax
  00bb5	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax

; 1357 :             if (f->f_stacktop != NULL) {

  00bbb	49 8b 87 a0 00
	00 00		 mov	 rax, QWORD PTR [r15+160]
  00bc2	4c 89 5c 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r11
  00bc7	48 85 c0	 test	 rax, rax
  00bca	74 0e		 je	 SHORT $LN523@PyEval_Eva

; 1358 :                 stack_pointer = f->f_stacktop;

  00bcc	48 8b f0	 mov	 rsi, rax

; 1359 :                 f->f_stacktop = NULL;

  00bcf	49 c7 87 a0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [r15+160], 0
$LN523@PyEval_Eva:

; 1360 :             }
; 1361 :             if (err) {

  00bda	45 85 ed	 test	 r13d, r13d
  00bdd	0f 84 b0 f7 ff
	ff		 je	 $fast_next_opcode_notracing$64533
  00be3	eb 2c		 jmp	 SHORT $LN1039@PyEval_Eva
$LN513@PyEval_Eva:

; 1419 :             }
; 1420 :             format_exc_check_arg(PyExc_UnboundLocalError,
; 1421 :                 UNBOUNDLOCAL_ERROR_MSG,
; 1422 :                 PyTuple_GetItem(co->co_varnames, oparg));

  00be5	49 63 d5	 movsxd	 rdx, r13d
$LN261@PyEval_Eva:
  00be8	48 8b 8b 90 00
	00 00		 mov	 rcx, QWORD PTR [rbx+144]
  00bef	e8 00 00 00 00	 call	 PyTuple_GetItem
  00bf4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnboundLocalError
  00bfb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@HKMDOJCI@local?5variable?5?8?$CF?4200s?8?5referenc@
  00c02	4c 8b c0	 mov	 r8, rax
$LN1056@PyEval_Eva:

; 2164 :                                 format_exc_check_arg(
; 2165 :                                             PyExc_NameError,
; 2166 :                                             NAME_ERROR_MSG, w);

  00c05	e8 00 00 00 00	 call	 format_exc_check_arg
$LN1017@PyEval_Eva:

; 1423 :             break;

  00c0a	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
$LN1039@PyEval_Eva:
  00c11	bb 02 00 00 00	 mov	 ebx, 2
$LN1046@PyEval_Eva:
  00c16	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR why$1$[rbp-256]
$LN1029@PyEval_Eva:
  00c1c	45 33 e4	 xor	 r12d, r12d
$LN1042@PyEval_Eva:
  00c1f	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
$on_error$64523:

; 2930 :             break;
; 2931 : 
; 2932 : #ifdef CASE_TOO_BIG
; 2933 :         }
; 2934 : #endif
; 2935 : 
; 2936 :         } /* switch */
; 2937 : 
; 2938 :         on_error:
; 2939 : 
; 2940 :         READ_TIMESTAMP(inst1);
; 2941 : 
; 2942 :         /* Quickly continue if no error occurred */
; 2943 : 
; 2944 :         if (why == WHY_NOT) {

  00c26	83 f8 01	 cmp	 eax, 1
  00c29	0f 85 95 2e 00
	00		 jne	 $LN87@PyEval_Eva

; 2945 :             if (err == 0 && x != NULL) {

  00c2f	45 85 ed	 test	 r13d, r13d
  00c32	75 2a		 jne	 SHORT $LN84@PyEval_Eva
  00c34	4d 85 f6	 test	 r14, r14
  00c37	74 25		 je	 SHORT $LN84@PyEval_Eva

; 2946 : #ifdef CHECKEXC
; 2947 :                 /* This check is expensive! */
; 2948 :                 if (PyErr_Occurred())

  00c39	e8 00 00 00 00	 call	 PyErr_Occurred
  00c3e	48 85 c0	 test	 rax, rax
  00c41	0f 84 fb f5 ff
	ff		 je	 $LN1064@PyEval_Eva

; 2949 :                     fprintf(stderr,
; 2950 :                         "XXX undetected error\n");

  00c47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00c4d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@BGJGOEKO@XXX?5undetected?5error?6?$AA@
  00c54	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  00c58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
$LN84@PyEval_Eva:

; 2951 :                 else {
; 2952 : #endif
; 2953 :                     READ_TIMESTAMP(loop1);
; 2954 :                     continue; /* Normal, fast path */
; 2955 : #ifdef CHECKEXC
; 2956 :                 }
; 2957 : #endif
; 2958 :             }
; 2959 :             why = WHY_EXCEPTION;

  00c5e	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx

; 2960 :             x = Py_None;

  00c64	4c 8b f7	 mov	 r14, rdi
  00c67	48 89 7c 24 30	 mov	 QWORD PTR tmp$1$[rsp], rdi

; 2961 :             err = 0;

  00c6c	44 89 a5 98 00
	00 00		 mov	 DWORD PTR err$1$[rbp-256], r12d
$LN1028@PyEval_Eva:

; 2929 :             why = WHY_EXCEPTION;

  00c73	bb 02 00 00 00	 mov	 ebx, 2
$LN82@PyEval_Eva:

; 2967 :             if (!PyErr_Occurred()) {

  00c78	e8 00 00 00 00	 call	 PyErr_Occurred
  00c7d	48 85 c0	 test	 rax, rax
  00c80	0f 85 7b 2e 00
	00		 jne	 $LN81@PyEval_Eva

; 2968 :                 PyErr_SetString(PyExc_SystemError,
; 2969 :                     "error return without exception set");

  00c86	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00c8d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@PEFHABHC@error?5return?5without?5exception?5s@
  00c94	e8 00 00 00 00	 call	 PyErr_SetString

; 2970 :                 why = WHY_EXCEPTION;

  00c99	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx

; 2981 :             }
; 2982 :         }
; 2983 : #endif
; 2984 : 
; 2985 :         /* Log traceback info if this is a real exception */
; 2986 : 
; 2987 :         if (why == WHY_EXCEPTION) {

  00c9f	e9 68 2e 00 00	 jmp	 $LN881@PyEval_Eva
$LN192@PyEval_Eva:

; 2454 :             }
; 2455 :             err = PyObject_IsTrue(w);

  00ca4	e8 00 00 00 00	 call	 PyObject_IsTrue

; 2456 :             Py_DECREF(w);

  00ca9	48 8b cb	 mov	 rcx, rbx
  00cac	8b f8		 mov	 edi, eax
  00cae	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  00cb4	e8 00 00 00 00	 call	 _Py_DecRef

; 2457 :             if (err > 0)

  00cb9	85 ff		 test	 edi, edi
  00cbb	7e 0d		 jle	 SHORT $LN1034@PyEval_Eva

; 2458 :                 err = 0;

  00cbd	33 ff		 xor	 edi, edi
  00cbf	89 bd 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], edi
  00cc5	e9 78 f5 ff ff	 jmp	 $LN1064@PyEval_Eva
$LN1034@PyEval_Eva:

; 2459 :             else if (err == 0)

  00cca	0f 85 b4 2d 00
	00		 jne	 $LN992@PyEval_Eva

; 2460 :                 JUMPTO(oparg);

  00cd0	49 63 c5	 movsxd	 rax, r13d
  00cd3	48 03 44 24 50	 add	 rax, QWORD PTR first_instr$1$[rsp]
  00cd8	48 89 44 24 40	 mov	 QWORD PTR next_instr$1$[rsp], rax

; 2461 :             else
; 2462 :                 break;
; 2463 :             DISPATCH();

  00cdd	e9 60 f5 ff ff	 jmp	 $LN1064@PyEval_Eva
$LN185@PyEval_Eva:

; 2476 :             }
; 2477 :             err = PyObject_IsTrue(w);

  00ce2	e8 00 00 00 00	 call	 PyObject_IsTrue

; 2478 :             Py_DECREF(w);

  00ce7	48 8b cb	 mov	 rcx, rbx
  00cea	8b f8		 mov	 edi, eax
  00cec	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  00cf2	e8 00 00 00 00	 call	 _Py_DecRef

; 2479 :             if (err > 0) {

  00cf7	85 ff		 test	 edi, edi
  00cf9	7e 1a		 jle	 SHORT $LN184@PyEval_Eva
$LN1036@PyEval_Eva:

; 2480 :                 err = 0;

  00cfb	33 ff		 xor	 edi, edi

; 2481 :                 JUMPTO(oparg);

  00cfd	4d 63 e5	 movsxd	 r12, r13d
  00d00	4c 03 64 24 50	 add	 r12, QWORD PTR first_instr$1$[rsp]
  00d05	89 bd 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], edi
  00d0b	4c 89 64 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r12
  00d10	e9 32 f5 ff ff	 jmp	 $LN1065@PyEval_Eva
$LN184@PyEval_Eva:

; 2482 :             }
; 2483 :             else if (err == 0)

  00d15	44 8b ef	 mov	 r13d, edi
  00d18	85 ff		 test	 edi, edi
  00d1a	0f 85 f1 fe ff
	ff		 jne	 $LN1039@PyEval_Eva

; 2484 :                 ;
; 2485 :             else
; 2486 :                 break;
; 2487 :             DISPATCH();

  00d20	e9 1d f5 ff ff	 jmp	 $LN1064@PyEval_Eva
$LN1035@PyEval_Eva:

; 2505 :             }
; 2506 :             else if (err == 0)

  00d25	0f 85 df fe ff
	ff		 jne	 $LN1017@PyEval_Eva

; 2507 :                 JUMPTO(oparg);

  00d2b	4d 63 e5	 movsxd	 r12, r13d
  00d2e	4c 03 64 24 50	 add	 r12, QWORD PTR first_instr$1$[rsp]
  00d33	4c 89 64 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r12

; 2508 :             else
; 2509 :                 break;
; 2510 :             DISPATCH();

  00d38	e9 0a f5 ff ff	 jmp	 $LN1065@PyEval_Eva
$LN164@PyEval_Eva:

; 2560 :                 DISPATCH();
; 2561 :             }
; 2562 :             STACKADJ(-1);

  00d3d	48 83 ee 08	 sub	 rsi, 8
  00d41	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00d48	74 10		 je	 SHORT $LN686@PyEval_Eva
  00d4a	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  00d4e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  00d55	e8 00 00 00 00	 call	 prtrace
$LN686@PyEval_Eva:
  00d5a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  00d5f	48 8b c6	 mov	 rax, rsi
  00d62	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  00d69	48 c1 f8 03	 sar	 rax, 3
  00d6d	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  00d70	0f 8e 94 fe ff
	ff		 jle	 $LN1017@PyEval_Eva
  00d76	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00d7d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  00d84	41 b8 02 0a 00
	00		 mov	 r8d, 2562		; 00000a02H
  00d8a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2563 :             break;

  00d90	e9 75 fe ff ff	 jmp	 $LN1017@PyEval_Eva
$LN160@PyEval_Eva:

; 2573 :                 PREDICT(UNPACK_SEQUENCE);

  00d95	80 39 5c	 cmp	 BYTE PTR [rcx], 92	; 0000005cH
  00d98	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  00d9d	0f 85 e6 00 00
	00		 jne	 $LN984@PyEval_Eva

; 2042 : 
; 2043 :         PREDICTED_WITH_ARG(UNPACK_SEQUENCE);

  00da3	44 0f b6 69 02	 movzx	 r13d, BYTE PTR [rcx+2]
  00da8	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
$PRED_UNPACK_SEQUENCE$65055:
  00dac	41 c1 e5 08	 shl	 r13d, 8
  00db0	44 03 e8	 add	 r13d, eax
  00db3	48 83 c1 03	 add	 rcx, 3
  00db7	48 89 4c 24 40	 mov	 QWORD PTR next_instr$1$[rsp], rcx
$LN316@PyEval_Eva:

; 2044 :         TARGET(UNPACK_SEQUENCE)
; 2045 :             v = POP();

  00dbc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00dc3	74 10		 je	 SHORT $LN628@PyEval_Eva
  00dc5	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  00dc9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  00dd0	e8 00 00 00 00	 call	 prtrace
$LN628@PyEval_Eva:
  00dd5	4c 8b 76 f8	 mov	 r14, QWORD PTR [rsi-8]
  00dd9	48 83 ee 08	 sub	 rsi, 8

; 2046 :             if (PyTuple_CheckExact(v) &&
; 2047 :                 PyTuple_GET_SIZE(v) == oparg) {

  00ddd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyTuple_Type
  00de4	49 8b 46 58	 mov	 rax, QWORD PTR [r14+88]
  00de8	4c 89 75 90	 mov	 QWORD PTR v$56$[rbp-256], r14
  00dec	49 63 fd	 movsxd	 rdi, r13d
  00def	48 3b c1	 cmp	 rax, rcx
  00df2	0f 85 e0 1e 00
	00		 jne	 $LN315@PyEval_Eva
  00df8	49 39 7e 60	 cmp	 QWORD PTR [r14+96], rdi
  00dfc	0f 85 d6 1e 00
	00		 jne	 $LN315@PyEval_Eva

; 2048 :                 PyObject **items = \
; 2049 :                     ((PyTupleObject *)v)->ob_item;
; 2050 :                 while (oparg--) {

  00e02	45 85 ed	 test	 r13d, r13d
  00e05	74 70		 je	 SHORT $LN849@PyEval_Eva
  00e07	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL314@PyEval_Eva:

; 2051 :                     w = items[oparg];

  00e10	49 8b 5c fe 68	 mov	 rbx, QWORD PTR [r14+rdi*8+104]
  00e15	48 ff cf	 dec	 rdi

; 2052 :                     Py_INCREF(w);

  00e18	48 8b cb	 mov	 rcx, rbx
  00e1b	e8 00 00 00 00	 call	 _Py_IncRef

; 2053 :                     PUSH(w);

  00e20	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00e23	48 83 c6 08	 add	 rsi, 8
  00e27	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00e2e	74 10		 je	 SHORT $LN629@PyEval_Eva
  00e30	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  00e34	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  00e3b	e8 00 00 00 00	 call	 prtrace
$LN629@PyEval_Eva:
  00e40	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  00e45	48 8b c6	 mov	 rax, rsi
  00e48	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  00e4f	48 c1 f8 03	 sar	 rax, 3
  00e53	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  00e56	7e 1a		 jle	 SHORT $LN630@PyEval_Eva
  00e58	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00e5f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  00e66	41 b8 05 08 00
	00		 mov	 r8d, 2053		; 00000805H
  00e6c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN630@PyEval_Eva:

; 2048 :                 PyObject **items = \
; 2049 :                     ((PyTupleObject *)v)->ob_item;
; 2050 :                 while (oparg--) {

  00e72	48 85 ff	 test	 rdi, rdi
  00e75	75 99		 jne	 SHORT $LL314@PyEval_Eva
$LN849@PyEval_Eva:

; 2054 :                 }
; 2055 :                 Py_DECREF(v);

  00e77	49 8b ce	 mov	 rcx, r14
  00e7a	e8 00 00 00 00	 call	 _Py_DecRef

; 2056 :                 DISPATCH();

  00e7f	4c 8b 74 24 30	 mov	 r14, QWORD PTR tmp$1$[rsp]
  00e84	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
$LN984@PyEval_Eva:
  00e89	4c 8b 64 24 40	 mov	 r12, QWORD PTR next_instr$1$[rsp]
  00e8e	e9 be f3 ff ff	 jmp	 $LN538@PyEval_Eva
$LN161@PyEval_Eva:

; 2574 :                 DISPATCH();
; 2575 :             }
; 2576 :             if (PyErr_Occurred()) {

  00e93	e8 00 00 00 00	 call	 PyErr_Occurred
  00e98	48 85 c0	 test	 rax, rax
  00e9b	74 19		 je	 SHORT $LN158@PyEval_Eva

; 2577 :                 if (!PyErr_ExceptionMatches(
; 2578 :                                 PyExc_StopIteration))

  00e9d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  00ea4	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00ea9	85 c0		 test	 eax, eax
  00eab	0f 84 59 fd ff
	ff		 je	 $LN1017@PyEval_Eva

; 2579 :                     break;
; 2580 :                 PyErr_Clear();

  00eb1	e8 00 00 00 00	 call	 PyErr_Clear
$LN158@PyEval_Eva:

; 2581 :             }
; 2582 :             /* iterator ended normally */
; 2583 :             x = v = POP();

  00eb6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00ebd	74 10		 je	 SHORT $LN690@PyEval_Eva
  00ebf	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  00ec3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  00eca	e8 00 00 00 00	 call	 prtrace
$LN690@PyEval_Eva:
  00ecf	4c 8b 76 f8	 mov	 r14, QWORD PTR [rsi-8]
  00ed3	48 83 ee 08	 sub	 rsi, 8

; 2584 :             Py_DECREF(v);

  00ed7	49 8b ce	 mov	 rcx, r14
  00eda	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14
  00edf	e8 00 00 00 00	 call	 _Py_DecRef

; 2585 :             JUMPBY(oparg);

  00ee4	4c 8b 64 24 40	 mov	 r12, QWORD PTR next_instr$1$[rsp]

; 2586 :             DISPATCH();

  00ee9	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  00eee	4d 63 dd	 movsxd	 r11, r13d
  00ef1	4d 03 e3	 add	 r12, r11
  00ef4	4c 89 64 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r12
  00ef9	e9 53 f3 ff ff	 jmp	 $LN538@PyEval_Eva
$LN498@PyEval_Eva:

; 1473 : 
; 1474 :         TARGET(UNARY_POSITIVE)
; 1475 :             v = TOP();

  00efe	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]

; 1476 :             x = PyNumber_Positive(v);

  00f02	48 8b cb	 mov	 rcx, rbx
  00f05	e8 00 00 00 00	 call	 PyNumber_Positive

; 1477 :             Py_DECREF(v);

  00f0a	48 8b cb	 mov	 rcx, rbx
  00f0d	4c 8b f0	 mov	 r14, rax
  00f10	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 1478 :             SET_TOP(x);
; 1479 :             if (x != NULL) DISPATCH();
; 1480 :             break;

  00f15	e9 53 2b 00 00	 jmp	 $LN1051@PyEval_Eva
$LN496@PyEval_Eva:

; 1481 : 
; 1482 :         TARGET(UNARY_NEGATIVE)
; 1483 :             v = TOP();

  00f1a	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]

; 1484 :             x = PyNumber_Negative(v);

  00f1e	48 8b cb	 mov	 rcx, rbx
  00f21	e8 00 00 00 00	 call	 PyNumber_Negative

; 1485 :             Py_DECREF(v);

  00f26	48 8b cb	 mov	 rcx, rbx
  00f29	4c 8b f0	 mov	 r14, rax
  00f2c	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 1486 :             SET_TOP(x);
; 1487 :             if (x != NULL) DISPATCH();
; 1488 :             break;

  00f31	e9 37 2b 00 00	 jmp	 $LN1051@PyEval_Eva
$LN494@PyEval_Eva:

; 1489 : 
; 1490 :         TARGET(UNARY_NOT)
; 1491 :             v = TOP();

  00f36	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  00f3a	48 8d 7e f8	 lea	 rdi, QWORD PTR [rsi-8]

; 1492 :             err = PyObject_IsTrue(v);

  00f3e	48 8b cb	 mov	 rcx, rbx
  00f41	e8 00 00 00 00	 call	 PyObject_IsTrue

; 1493 :             Py_DECREF(v);

  00f46	48 8b cb	 mov	 rcx, rbx
  00f49	44 8b e8	 mov	 r13d, eax
  00f4c	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  00f52	e8 00 00 00 00	 call	 _Py_DecRef

; 1494 :             if (err == 0) {

  00f57	45 85 ed	 test	 r13d, r13d
  00f5a	75 17		 jne	 SHORT $LN1038@PyEval_Eva

; 1495 :                 Py_INCREF(Py_True);

  00f5c	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_TrueStruct
  00f63	48 8b cb	 mov	 rcx, rbx
  00f66	e8 00 00 00 00	 call	 _Py_IncRef

; 1496 :                 SET_TOP(Py_True);

  00f6b	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 1497 :                 DISPATCH();

  00f6e	e9 d4 f2 ff ff	 jmp	 $LN1065@PyEval_Eva
$LN1038@PyEval_Eva:

; 1498 :             }
; 1499 :             else if (err > 0) {

  00f73	7e 1f		 jle	 SHORT $LN491@PyEval_Eva

; 1500 :                 Py_INCREF(Py_False);

  00f75	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  00f7c	48 8b cb	 mov	 rcx, rbx
  00f7f	e8 00 00 00 00	 call	 _Py_IncRef

; 1501 :                 SET_TOP(Py_False);

  00f84	48 89 1f	 mov	 QWORD PTR [rdi], rbx

; 1502 :                 err = 0;

  00f87	33 ff		 xor	 edi, edi
  00f89	89 bd 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], edi

; 1503 :                 DISPATCH();

  00f8f	e9 b3 f2 ff ff	 jmp	 $LN1065@PyEval_Eva
$LN491@PyEval_Eva:

; 1504 :             }
; 1505 :             STACKADJ(-1);

  00f94	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00f9b	48 8b f7	 mov	 rsi, rdi
  00f9e	74 10		 je	 SHORT $LN565@PyEval_Eva
  00fa0	48 8b 4f f8	 mov	 rcx, QWORD PTR [rdi-8]
  00fa4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  00fab	e8 00 00 00 00	 call	 prtrace
$LN565@PyEval_Eva:
  00fb0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  00fb5	48 8b c7	 mov	 rax, rdi
  00fb8	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  00fbf	48 c1 f8 03	 sar	 rax, 3
  00fc3	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  00fc6	0f 8e 45 fc ff
	ff		 jle	 $LN1039@PyEval_Eva
  00fcc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00fd3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  00fda	41 b8 e1 05 00
	00		 mov	 r8d, 1505		; 000005e1H
  00fe0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 1506 :             break;

  00fe6	e9 26 fc ff ff	 jmp	 $LN1039@PyEval_Eva
$LN490@PyEval_Eva:

; 1507 : 
; 1508 :         TARGET(UNARY_INVERT)
; 1509 :             v = TOP();

  00feb	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]

; 1510 :             x = PyNumber_Invert(v);

  00fef	48 8b cb	 mov	 rcx, rbx
  00ff2	e8 00 00 00 00	 call	 PyNumber_Invert

; 1511 :             Py_DECREF(v);

  00ff7	48 8b cb	 mov	 rcx, rbx
  00ffa	4c 8b f0	 mov	 r14, rax
  00ffd	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 1512 :             SET_TOP(x);
; 1513 :             if (x != NULL) DISPATCH();
; 1514 :             break;

  01002	e9 66 2a 00 00	 jmp	 $LN1051@PyEval_Eva
$LN488@PyEval_Eva:

; 1515 : 
; 1516 :         TARGET(BINARY_POWER)
; 1517 :             w = POP();

  01007	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0100e	74 10		 je	 SHORT $LN567@PyEval_Eva
  01010	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0101b	e8 00 00 00 00	 call	 prtrace
$LN567@PyEval_Eva:
  01020	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1518 :             v = TOP();

  01024	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  01028	48 83 ee 08	 sub	 rsi, 8

; 1519 :             x = PyNumber_Power(v, w, Py_None);

  0102c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  01033	48 8b d7	 mov	 rdx, rdi
  01036	48 8b cb	 mov	 rcx, rbx
  01039	e8 00 00 00 00	 call	 PyNumber_Power
$LN1069@PyEval_Eva:

; 1520 :             Py_DECREF(v);

  0103e	48 8b cb	 mov	 rcx, rbx
  01041	4c 8b f0	 mov	 r14, rax
  01044	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  01049	e8 00 00 00 00	 call	 _Py_DecRef

; 1521 :             Py_DECREF(w);

  0104e	48 8b cf	 mov	 rcx, rdi

; 1522 :             SET_TOP(x);
; 1523 :             if (x != NULL) DISPATCH();
; 1524 :             break;

  01051	e9 17 2a 00 00	 jmp	 $LN1051@PyEval_Eva
$LN486@PyEval_Eva:

; 1525 : 
; 1526 :         TARGET(BINARY_MULTIPLY)
; 1527 :             w = POP();

  01056	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0105d	74 10		 je	 SHORT $LN568@PyEval_Eva
  0105f	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0106a	e8 00 00 00 00	 call	 prtrace
$LN568@PyEval_Eva:
  0106f	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1528 :             v = TOP();

  01073	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  01077	48 83 ee 08	 sub	 rsi, 8

; 1529 :             x = PyNumber_Multiply(v, w);

  0107b	48 8b d7	 mov	 rdx, rdi
  0107e	48 8b cb	 mov	 rcx, rbx
  01081	e8 00 00 00 00	 call	 PyNumber_Multiply

; 1530 :             Py_DECREF(v);
; 1531 :             Py_DECREF(w);
; 1532 :             SET_TOP(x);
; 1533 :             if (x != NULL) DISPATCH();
; 1534 :             break;

  01086	eb b6		 jmp	 SHORT $LN1069@PyEval_Eva
$LN484@PyEval_Eva:

; 1535 : 
; 1536 :         TARGET(BINARY_TRUE_DIVIDE)
; 1537 :             w = POP();

  01088	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0108f	74 10		 je	 SHORT $LN569@PyEval_Eva
  01091	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0109c	e8 00 00 00 00	 call	 prtrace
$LN569@PyEval_Eva:
  010a1	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1538 :             v = TOP();

  010a5	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  010a9	48 83 ee 08	 sub	 rsi, 8

; 1539 :             x = PyNumber_TrueDivide(v, w);

  010ad	48 8b d7	 mov	 rdx, rdi
  010b0	48 8b cb	 mov	 rcx, rbx
  010b3	e8 00 00 00 00	 call	 PyNumber_TrueDivide

; 1540 :             Py_DECREF(v);
; 1541 :             Py_DECREF(w);
; 1542 :             SET_TOP(x);
; 1543 :             if (x != NULL) DISPATCH();
; 1544 :             break;

  010b8	eb 84		 jmp	 SHORT $LN1069@PyEval_Eva
$LN482@PyEval_Eva:

; 1545 : 
; 1546 :         TARGET(BINARY_FLOOR_DIVIDE)
; 1547 :             w = POP();

  010ba	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  010c1	74 10		 je	 SHORT $LN570@PyEval_Eva
  010c3	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  010c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  010ce	e8 00 00 00 00	 call	 prtrace
$LN570@PyEval_Eva:
  010d3	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1548 :             v = TOP();

  010d7	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  010db	48 83 ee 08	 sub	 rsi, 8

; 1549 :             x = PyNumber_FloorDivide(v, w);

  010df	48 8b d7	 mov	 rdx, rdi
  010e2	48 8b cb	 mov	 rcx, rbx
  010e5	e8 00 00 00 00	 call	 PyNumber_FloorDivide

; 1550 :             Py_DECREF(v);
; 1551 :             Py_DECREF(w);
; 1552 :             SET_TOP(x);
; 1553 :             if (x != NULL) DISPATCH();
; 1554 :             break;

  010ea	e9 4f ff ff ff	 jmp	 $LN1069@PyEval_Eva
$LN480@PyEval_Eva:

; 1555 : 
; 1556 :         TARGET(BINARY_MODULO)
; 1557 :             w = POP();

  010ef	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  010f6	74 10		 je	 SHORT $LN571@PyEval_Eva
  010f8	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  010fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01103	e8 00 00 00 00	 call	 prtrace
$LN571@PyEval_Eva:

; 1558 :             v = TOP();

  01108	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  0110c	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]
  01110	48 83 ee 08	 sub	 rsi, 8

; 1559 :             if (PyUnicode_CheckExact(v))

  01114	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:PyUnicode_Type

; 1560 :                 x = PyUnicode_Format(v, w);

  0111b	48 8b d7	 mov	 rdx, rdi
  0111e	48 8b cb	 mov	 rcx, rbx
  01121	4c 39 6b 58	 cmp	 QWORD PTR [rbx+88], r13
  01125	75 1d		 jne	 SHORT $LN479@PyEval_Eva
  01127	e8 00 00 00 00	 call	 PyUnicode_Format
  0112c	48 8b cb	 mov	 rcx, rbx

; 1561 :             else
; 1562 :                 x = PyNumber_Remainder(v, w);

  0112f	4c 8b f0	 mov	 r14, rax
  01132	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  01137	e8 00 00 00 00	 call	 _Py_DecRef
  0113c	48 8b cf	 mov	 rcx, rdi
  0113f	e9 29 29 00 00	 jmp	 $LN1051@PyEval_Eva
$LN479@PyEval_Eva:
  01144	e8 00 00 00 00	 call	 PyNumber_Remainder
  01149	48 8b cb	 mov	 rcx, rbx
  0114c	4c 8b f0	 mov	 r14, rax
  0114f	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  01154	e8 00 00 00 00	 call	 _Py_DecRef
  01159	48 8b cf	 mov	 rcx, rdi
  0115c	e9 0c 29 00 00	 jmp	 $LN1051@PyEval_Eva
$LN476@PyEval_Eva:

; 1563 :             Py_DECREF(v);
; 1564 :             Py_DECREF(w);
; 1565 :             SET_TOP(x);
; 1566 :             if (x != NULL) DISPATCH();
; 1567 :             break;
; 1568 : 
; 1569 :         TARGET(BINARY_ADD)
; 1570 :             w = POP();

  01161	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01168	74 10		 je	 SHORT $LN572@PyEval_Eva
  0116a	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0116e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01175	e8 00 00 00 00	 call	 prtrace
$LN572@PyEval_Eva:

; 1571 :             v = TOP();

  0117a	48 8b 7e f0	 mov	 rdi, QWORD PTR [rsi-16]
  0117e	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  01182	48 83 ee 08	 sub	 rsi, 8

; 1572 :             if (PyUnicode_CheckExact(v) &&
; 1573 :                      PyUnicode_CheckExact(w)) {

  01186	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:PyUnicode_Type
  0118d	4c 39 6f 58	 cmp	 QWORD PTR [rdi+88], r13
  01191	75 27		 jne	 SHORT $LN475@PyEval_Eva
  01193	4c 39 6b 58	 cmp	 QWORD PTR [rbx+88], r13
  01197	75 21		 jne	 SHORT $LN475@PyEval_Eva

; 1574 :                 x = unicode_concatenate(v, w, f, next_instr);

  01199	4d 8b cc	 mov	 r9, r12
  0119c	4d 8b c7	 mov	 r8, r15
  0119f	48 8b d3	 mov	 rdx, rbx
  011a2	48 8b cf	 mov	 rcx, rdi
  011a5	e8 00 00 00 00	 call	 unicode_concatenate
$skip_decref_v$64774:

; 1582 :           skip_decref_vx:
; 1583 :             Py_DECREF(w);

  011aa	48 8b cb	 mov	 rcx, rbx
  011ad	4c 8b f0	 mov	 r14, rax
  011b0	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 1584 :             SET_TOP(x);
; 1585 :             if (x != NULL) DISPATCH();
; 1586 :             break;

  011b5	e9 b3 28 00 00	 jmp	 $LN1051@PyEval_Eva
$LN475@PyEval_Eva:

; 1575 :                 /* unicode_concatenate consumed the ref to v */
; 1576 :                 goto skip_decref_vx;
; 1577 :             }
; 1578 :             else {
; 1579 :                 x = PyNumber_Add(v, w);

  011ba	48 8b d3	 mov	 rdx, rbx
  011bd	48 8b cf	 mov	 rcx, rdi
  011c0	e8 00 00 00 00	 call	 PyNumber_Add
$LN1071@PyEval_Eva:

; 1580 :             }
; 1581 :             Py_DECREF(v);

  011c5	48 8b cf	 mov	 rcx, rdi
  011c8	4c 8b f0	 mov	 r14, rax
  011cb	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  011d0	e8 00 00 00 00	 call	 _Py_DecRef

; 1582 :           skip_decref_vx:
; 1583 :             Py_DECREF(w);

  011d5	48 8b cb	 mov	 rcx, rbx
$skip_decref_v_1$64774:
$skip_decref_vx$64680:

; 1584 :             SET_TOP(x);
; 1585 :             if (x != NULL) DISPATCH();
; 1586 :             break;

  011d8	e9 90 28 00 00	 jmp	 $LN1051@PyEval_Eva
$LN472@PyEval_Eva:

; 1587 : 
; 1588 :         TARGET(BINARY_SUBTRACT)
; 1589 :             w = POP();

  011dd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  011e4	74 10		 je	 SHORT $LN573@PyEval_Eva
  011e6	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  011ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  011f1	e8 00 00 00 00	 call	 prtrace
$LN573@PyEval_Eva:
  011f6	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1590 :             v = TOP();

  011fa	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  011fe	48 83 ee 08	 sub	 rsi, 8

; 1591 :             x = PyNumber_Subtract(v, w);

  01202	48 8b d7	 mov	 rdx, rdi
  01205	48 8b cb	 mov	 rcx, rbx
  01208	e8 00 00 00 00	 call	 PyNumber_Subtract

; 1592 :             Py_DECREF(v);
; 1593 :             Py_DECREF(w);
; 1594 :             SET_TOP(x);
; 1595 :             if (x != NULL) DISPATCH();
; 1596 :             break;

  0120d	e9 2c fe ff ff	 jmp	 $LN1069@PyEval_Eva
$LN470@PyEval_Eva:

; 1597 : 
; 1598 :         TARGET(BINARY_SUBSCR)
; 1599 :             w = POP();

  01212	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01219	74 10		 je	 SHORT $LN574@PyEval_Eva
  0121b	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0121f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01226	e8 00 00 00 00	 call	 prtrace
$LN574@PyEval_Eva:
  0122b	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1600 :             v = TOP();

  0122f	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  01233	48 83 ee 08	 sub	 rsi, 8

; 1601 :             x = PyObject_GetItem(v, w);

  01237	48 8b d7	 mov	 rdx, rdi
  0123a	48 8b cb	 mov	 rcx, rbx
  0123d	e8 00 00 00 00	 call	 PyObject_GetItem

; 1602 :             Py_DECREF(v);
; 1603 :             Py_DECREF(w);
; 1604 :             SET_TOP(x);
; 1605 :             if (x != NULL) DISPATCH();
; 1606 :             break;

  01242	e9 f7 fd ff ff	 jmp	 $LN1069@PyEval_Eva
$LN468@PyEval_Eva:

; 1607 : 
; 1608 :         TARGET(BINARY_LSHIFT)
; 1609 :             w = POP();

  01247	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0124e	74 10		 je	 SHORT $LN575@PyEval_Eva
  01250	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01254	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0125b	e8 00 00 00 00	 call	 prtrace
$LN575@PyEval_Eva:
  01260	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1610 :             v = TOP();

  01264	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  01268	48 83 ee 08	 sub	 rsi, 8

; 1611 :             x = PyNumber_Lshift(v, w);

  0126c	48 8b d7	 mov	 rdx, rdi
  0126f	48 8b cb	 mov	 rcx, rbx
  01272	e8 00 00 00 00	 call	 PyNumber_Lshift

; 1612 :             Py_DECREF(v);
; 1613 :             Py_DECREF(w);
; 1614 :             SET_TOP(x);
; 1615 :             if (x != NULL) DISPATCH();
; 1616 :             break;

  01277	e9 c2 fd ff ff	 jmp	 $LN1069@PyEval_Eva
$LN466@PyEval_Eva:

; 1617 : 
; 1618 :         TARGET(BINARY_RSHIFT)
; 1619 :             w = POP();

  0127c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01283	74 10		 je	 SHORT $LN576@PyEval_Eva
  01285	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01289	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01290	e8 00 00 00 00	 call	 prtrace
$LN576@PyEval_Eva:
  01295	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1620 :             v = TOP();

  01299	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  0129d	48 83 ee 08	 sub	 rsi, 8

; 1621 :             x = PyNumber_Rshift(v, w);

  012a1	48 8b d7	 mov	 rdx, rdi
  012a4	48 8b cb	 mov	 rcx, rbx
  012a7	e8 00 00 00 00	 call	 PyNumber_Rshift

; 1622 :             Py_DECREF(v);
; 1623 :             Py_DECREF(w);
; 1624 :             SET_TOP(x);
; 1625 :             if (x != NULL) DISPATCH();
; 1626 :             break;

  012ac	e9 8d fd ff ff	 jmp	 $LN1069@PyEval_Eva
$LN464@PyEval_Eva:

; 1627 : 
; 1628 :         TARGET(BINARY_AND)
; 1629 :             w = POP();

  012b1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  012b8	74 10		 je	 SHORT $LN577@PyEval_Eva
  012ba	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  012be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  012c5	e8 00 00 00 00	 call	 prtrace
$LN577@PyEval_Eva:
  012ca	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1630 :             v = TOP();

  012ce	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  012d2	48 83 ee 08	 sub	 rsi, 8

; 1631 :             x = PyNumber_And(v, w);

  012d6	48 8b d7	 mov	 rdx, rdi
  012d9	48 8b cb	 mov	 rcx, rbx
  012dc	e8 00 00 00 00	 call	 PyNumber_And

; 1632 :             Py_DECREF(v);
; 1633 :             Py_DECREF(w);
; 1634 :             SET_TOP(x);
; 1635 :             if (x != NULL) DISPATCH();
; 1636 :             break;

  012e1	e9 58 fd ff ff	 jmp	 $LN1069@PyEval_Eva
$LN462@PyEval_Eva:

; 1637 : 
; 1638 :         TARGET(BINARY_XOR)
; 1639 :             w = POP();

  012e6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  012ed	74 10		 je	 SHORT $LN578@PyEval_Eva
  012ef	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  012f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  012fa	e8 00 00 00 00	 call	 prtrace
$LN578@PyEval_Eva:
  012ff	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1640 :             v = TOP();

  01303	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  01307	48 83 ee 08	 sub	 rsi, 8

; 1641 :             x = PyNumber_Xor(v, w);

  0130b	48 8b d7	 mov	 rdx, rdi
  0130e	48 8b cb	 mov	 rcx, rbx
  01311	e8 00 00 00 00	 call	 PyNumber_Xor

; 1642 :             Py_DECREF(v);
; 1643 :             Py_DECREF(w);
; 1644 :             SET_TOP(x);
; 1645 :             if (x != NULL) DISPATCH();
; 1646 :             break;

  01316	e9 23 fd ff ff	 jmp	 $LN1069@PyEval_Eva
$LN460@PyEval_Eva:

; 1647 : 
; 1648 :         TARGET(BINARY_OR)
; 1649 :             w = POP();

  0131b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01322	74 10		 je	 SHORT $LN579@PyEval_Eva
  01324	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01328	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0132f	e8 00 00 00 00	 call	 prtrace
$LN579@PyEval_Eva:
  01334	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1650 :             v = TOP();

  01338	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  0133c	48 83 ee 08	 sub	 rsi, 8

; 1651 :             x = PyNumber_Or(v, w);

  01340	48 8b d7	 mov	 rdx, rdi
  01343	48 8b cb	 mov	 rcx, rbx
  01346	e8 00 00 00 00	 call	 PyNumber_Or

; 1652 :             Py_DECREF(v);
; 1653 :             Py_DECREF(w);
; 1654 :             SET_TOP(x);
; 1655 :             if (x != NULL) DISPATCH();
; 1656 :             break;

  0134b	e9 ee fc ff ff	 jmp	 $LN1069@PyEval_Eva
$LN458@PyEval_Eva:

; 1657 : 
; 1658 :         TARGET(LIST_APPEND)
; 1659 :             w = POP();

  01350	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01357	74 10		 je	 SHORT $LN580@PyEval_Eva
  01359	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0135d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01364	e8 00 00 00 00	 call	 prtrace
$LN580@PyEval_Eva:
  01369	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  0136d	48 83 ee 08	 sub	 rsi, 8

; 1660 :             v = PEEK(oparg);

  01371	49 63 d5	 movsxd	 rdx, r13d
  01374	48 c1 e2 03	 shl	 rdx, 3
  01378	48 8b c6	 mov	 rax, rsi
  0137b	48 2b c2	 sub	 rax, rdx

; 1661 :             err = PyList_Append(v, w);

  0137e	48 8b d3	 mov	 rdx, rbx
  01381	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  01384	e8 00 00 00 00	 call	 PyList_Append

; 1662 :             Py_DECREF(w);
; 1663 :             if (err == 0) {
; 1664 :                 PREDICT(JUMP_ABSOLUTE);
; 1665 :                 DISPATCH();

  01389	eb 39		 jmp	 SHORT $LN1067@PyEval_Eva
$LN455@PyEval_Eva:

; 1666 :             }
; 1667 :             break;
; 1668 : 
; 1669 :         TARGET(SET_ADD)
; 1670 :             w = POP();

  0138b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01392	74 10		 je	 SHORT $LN581@PyEval_Eva
  01394	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01398	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0139f	e8 00 00 00 00	 call	 prtrace
$LN581@PyEval_Eva:
  013a4	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  013a8	48 83 ee 08	 sub	 rsi, 8

; 1671 :             v = stack_pointer[-oparg];

  013ac	49 63 d5	 movsxd	 rdx, r13d
  013af	48 c1 e2 03	 shl	 rdx, 3
  013b3	48 8b c6	 mov	 rax, rsi
  013b6	48 2b c2	 sub	 rax, rdx

; 1672 :             err = PySet_Add(v, w);

  013b9	48 8b d3	 mov	 rdx, rbx
  013bc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  013bf	e8 00 00 00 00	 call	 PySet_Add
$LN1067@PyEval_Eva:

; 1673 :             Py_DECREF(w);

  013c4	48 8b cb	 mov	 rcx, rbx
  013c7	44 8b e8	 mov	 r13d, eax
  013ca	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  013d0	e8 00 00 00 00	 call	 _Py_DecRef

; 1674 :             if (err == 0) {

  013d5	45 85 ed	 test	 r13d, r13d
  013d8	0f 85 33 f8 ff
	ff		 jne	 $LN1039@PyEval_Eva

; 1675 :                 PREDICT(JUMP_ABSOLUTE);

  013de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next_instr$1$[rsp]
  013e3	80 39 71	 cmp	 BYTE PTR [rcx], 113	; 00000071H
  013e6	0f 84 d4 15 00
	00		 je	 $PRED_JUMP_ABSOLUTE$64733

; 1676 :                 DISPATCH();

  013ec	e9 51 ee ff ff	 jmp	 $LN1064@PyEval_Eva
$LN452@PyEval_Eva:

; 1677 :             }
; 1678 :             break;
; 1679 : 
; 1680 :         TARGET(INPLACE_POWER)
; 1681 :             w = POP();

  013f1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  013f8	74 10		 je	 SHORT $LN582@PyEval_Eva
  013fa	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  013fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01405	e8 00 00 00 00	 call	 prtrace
$LN582@PyEval_Eva:
  0140a	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1682 :             v = TOP();

  0140e	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  01412	48 83 ee 08	 sub	 rsi, 8

; 1683 :             x = PyNumber_InPlacePower(v, w, Py_None);

  01416	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:_Py_NoneStruct
  0141d	48 8b d7	 mov	 rdx, rdi
  01420	48 8b cb	 mov	 rcx, rbx
  01423	e8 00 00 00 00	 call	 PyNumber_InPlacePower

; 1684 :             Py_DECREF(v);
; 1685 :             Py_DECREF(w);
; 1686 :             SET_TOP(x);
; 1687 :             if (x != NULL) DISPATCH();
; 1688 :             break;

  01428	e9 11 fc ff ff	 jmp	 $LN1069@PyEval_Eva
$LN450@PyEval_Eva:

; 1689 : 
; 1690 :         TARGET(INPLACE_MULTIPLY)
; 1691 :             w = POP();

  0142d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01434	74 10		 je	 SHORT $LN583@PyEval_Eva
  01436	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0143a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01441	e8 00 00 00 00	 call	 prtrace
$LN583@PyEval_Eva:
  01446	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1692 :             v = TOP();

  0144a	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  0144e	48 83 ee 08	 sub	 rsi, 8

; 1693 :             x = PyNumber_InPlaceMultiply(v, w);

  01452	48 8b d7	 mov	 rdx, rdi
  01455	48 8b cb	 mov	 rcx, rbx
  01458	e8 00 00 00 00	 call	 PyNumber_InPlaceMultiply

; 1694 :             Py_DECREF(v);
; 1695 :             Py_DECREF(w);
; 1696 :             SET_TOP(x);
; 1697 :             if (x != NULL) DISPATCH();
; 1698 :             break;

  0145d	e9 dc fb ff ff	 jmp	 $LN1069@PyEval_Eva
$LN448@PyEval_Eva:

; 1699 : 
; 1700 :         TARGET(INPLACE_TRUE_DIVIDE)
; 1701 :             w = POP();

  01462	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01469	74 10		 je	 SHORT $LN584@PyEval_Eva
  0146b	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0146f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01476	e8 00 00 00 00	 call	 prtrace
$LN584@PyEval_Eva:
  0147b	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1702 :             v = TOP();

  0147f	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  01483	48 83 ee 08	 sub	 rsi, 8

; 1703 :             x = PyNumber_InPlaceTrueDivide(v, w);

  01487	48 8b d7	 mov	 rdx, rdi
  0148a	48 8b cb	 mov	 rcx, rbx
  0148d	e8 00 00 00 00	 call	 PyNumber_InPlaceTrueDivide

; 1704 :             Py_DECREF(v);
; 1705 :             Py_DECREF(w);
; 1706 :             SET_TOP(x);
; 1707 :             if (x != NULL) DISPATCH();
; 1708 :             break;

  01492	e9 a7 fb ff ff	 jmp	 $LN1069@PyEval_Eva
$LN446@PyEval_Eva:

; 1709 : 
; 1710 :         TARGET(INPLACE_FLOOR_DIVIDE)
; 1711 :             w = POP();

  01497	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0149e	74 10		 je	 SHORT $LN585@PyEval_Eva
  014a0	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  014a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  014ab	e8 00 00 00 00	 call	 prtrace
$LN585@PyEval_Eva:
  014b0	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1712 :             v = TOP();

  014b4	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  014b8	48 83 ee 08	 sub	 rsi, 8

; 1713 :             x = PyNumber_InPlaceFloorDivide(v, w);

  014bc	48 8b d7	 mov	 rdx, rdi
  014bf	48 8b cb	 mov	 rcx, rbx
  014c2	e8 00 00 00 00	 call	 PyNumber_InPlaceFloorDivide

; 1714 :             Py_DECREF(v);
; 1715 :             Py_DECREF(w);
; 1716 :             SET_TOP(x);
; 1717 :             if (x != NULL) DISPATCH();
; 1718 :             break;

  014c7	e9 72 fb ff ff	 jmp	 $LN1069@PyEval_Eva
$LN444@PyEval_Eva:

; 1719 : 
; 1720 :         TARGET(INPLACE_MODULO)
; 1721 :             w = POP();

  014cc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  014d3	74 10		 je	 SHORT $LN586@PyEval_Eva
  014d5	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  014d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  014e0	e8 00 00 00 00	 call	 prtrace
$LN586@PyEval_Eva:
  014e5	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1722 :             v = TOP();

  014e9	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  014ed	48 83 ee 08	 sub	 rsi, 8

; 1723 :             x = PyNumber_InPlaceRemainder(v, w);

  014f1	48 8b d7	 mov	 rdx, rdi
  014f4	48 8b cb	 mov	 rcx, rbx
  014f7	e8 00 00 00 00	 call	 PyNumber_InPlaceRemainder

; 1724 :             Py_DECREF(v);
; 1725 :             Py_DECREF(w);
; 1726 :             SET_TOP(x);
; 1727 :             if (x != NULL) DISPATCH();
; 1728 :             break;

  014fc	e9 3d fb ff ff	 jmp	 $LN1069@PyEval_Eva
$LN442@PyEval_Eva:

; 1729 : 
; 1730 :         TARGET(INPLACE_ADD)
; 1731 :             w = POP();

  01501	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01508	74 10		 je	 SHORT $LN587@PyEval_Eva
  0150a	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0150e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01515	e8 00 00 00 00	 call	 prtrace
$LN587@PyEval_Eva:

; 1732 :             v = TOP();

  0151a	48 8b 7e f0	 mov	 rdi, QWORD PTR [rsi-16]
  0151e	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  01522	48 83 ee 08	 sub	 rsi, 8

; 1733 :             if (PyUnicode_CheckExact(v) &&
; 1734 :                      PyUnicode_CheckExact(w)) {

  01526	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:PyUnicode_Type
  0152d	4c 39 6f 58	 cmp	 QWORD PTR [rdi+88], r13
  01531	75 27		 jne	 SHORT $LN441@PyEval_Eva
  01533	4c 39 6b 58	 cmp	 QWORD PTR [rbx+88], r13
  01537	75 21		 jne	 SHORT $LN441@PyEval_Eva

; 1735 :                 x = unicode_concatenate(v, w, f, next_instr);

  01539	4d 8b cc	 mov	 r9, r12
  0153c	4d 8b c7	 mov	 r8, r15
  0153f	48 8b d3	 mov	 rdx, rbx
  01542	48 8b cf	 mov	 rcx, rdi
  01545	e8 00 00 00 00	 call	 unicode_concatenate
$skip_decref_v_2$64774:
  0154a	48 8b cb	 mov	 rcx, rbx
  0154d	4c 8b f0	 mov	 r14, rax
  01550	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  01555	e9 13 25 00 00	 jmp	 $LN1051@PyEval_Eva
$LN441@PyEval_Eva:

; 1736 :                 /* unicode_concatenate consumed the ref to v */
; 1737 :                 goto skip_decref_v;
; 1738 :             }
; 1739 :             else {
; 1740 :                 x = PyNumber_InPlaceAdd(v, w);

  0155a	48 8b d3	 mov	 rdx, rbx
  0155d	48 8b cf	 mov	 rcx, rdi
  01560	e8 00 00 00 00	 call	 PyNumber_InPlaceAdd

; 1741 :             }
; 1742 :             Py_DECREF(v);
; 1743 :           skip_decref_v:
; 1744 :             Py_DECREF(w);
; 1745 :             SET_TOP(x);
; 1746 :             if (x != NULL) DISPATCH();
; 1747 :             break;

  01565	e9 5b fc ff ff	 jmp	 $LN1071@PyEval_Eva
$LN438@PyEval_Eva:

; 1748 : 
; 1749 :         TARGET(INPLACE_SUBTRACT)
; 1750 :             w = POP();

  0156a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01571	74 10		 je	 SHORT $LN588@PyEval_Eva
  01573	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01577	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0157e	e8 00 00 00 00	 call	 prtrace
$LN588@PyEval_Eva:
  01583	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1751 :             v = TOP();

  01587	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  0158b	48 83 ee 08	 sub	 rsi, 8

; 1752 :             x = PyNumber_InPlaceSubtract(v, w);

  0158f	48 8b d7	 mov	 rdx, rdi
  01592	48 8b cb	 mov	 rcx, rbx
  01595	e8 00 00 00 00	 call	 PyNumber_InPlaceSubtract

; 1753 :             Py_DECREF(v);
; 1754 :             Py_DECREF(w);
; 1755 :             SET_TOP(x);
; 1756 :             if (x != NULL) DISPATCH();
; 1757 :             break;

  0159a	e9 9f fa ff ff	 jmp	 $LN1069@PyEval_Eva
$LN436@PyEval_Eva:

; 1758 : 
; 1759 :         TARGET(INPLACE_LSHIFT)
; 1760 :             w = POP();

  0159f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  015a6	74 10		 je	 SHORT $LN589@PyEval_Eva
  015a8	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  015ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  015b3	e8 00 00 00 00	 call	 prtrace
$LN589@PyEval_Eva:
  015b8	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1761 :             v = TOP();

  015bc	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  015c0	48 83 ee 08	 sub	 rsi, 8

; 1762 :             x = PyNumber_InPlaceLshift(v, w);

  015c4	48 8b d7	 mov	 rdx, rdi
  015c7	48 8b cb	 mov	 rcx, rbx
  015ca	e8 00 00 00 00	 call	 PyNumber_InPlaceLshift

; 1763 :             Py_DECREF(v);
; 1764 :             Py_DECREF(w);
; 1765 :             SET_TOP(x);
; 1766 :             if (x != NULL) DISPATCH();
; 1767 :             break;

  015cf	e9 6a fa ff ff	 jmp	 $LN1069@PyEval_Eva
$LN434@PyEval_Eva:

; 1768 : 
; 1769 :         TARGET(INPLACE_RSHIFT)
; 1770 :             w = POP();

  015d4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  015db	74 10		 je	 SHORT $LN590@PyEval_Eva
  015dd	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  015e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  015e8	e8 00 00 00 00	 call	 prtrace
$LN590@PyEval_Eva:
  015ed	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1771 :             v = TOP();

  015f1	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  015f5	48 83 ee 08	 sub	 rsi, 8

; 1772 :             x = PyNumber_InPlaceRshift(v, w);

  015f9	48 8b d7	 mov	 rdx, rdi
  015fc	48 8b cb	 mov	 rcx, rbx
  015ff	e8 00 00 00 00	 call	 PyNumber_InPlaceRshift

; 1773 :             Py_DECREF(v);
; 1774 :             Py_DECREF(w);
; 1775 :             SET_TOP(x);
; 1776 :             if (x != NULL) DISPATCH();
; 1777 :             break;

  01604	e9 35 fa ff ff	 jmp	 $LN1069@PyEval_Eva
$LN432@PyEval_Eva:

; 1778 : 
; 1779 :         TARGET(INPLACE_AND)
; 1780 :             w = POP();

  01609	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01610	74 10		 je	 SHORT $LN591@PyEval_Eva
  01612	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01616	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0161d	e8 00 00 00 00	 call	 prtrace
$LN591@PyEval_Eva:
  01622	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1781 :             v = TOP();

  01626	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  0162a	48 83 ee 08	 sub	 rsi, 8

; 1782 :             x = PyNumber_InPlaceAnd(v, w);

  0162e	48 8b d7	 mov	 rdx, rdi
  01631	48 8b cb	 mov	 rcx, rbx
  01634	e8 00 00 00 00	 call	 PyNumber_InPlaceAnd

; 1783 :             Py_DECREF(v);
; 1784 :             Py_DECREF(w);
; 1785 :             SET_TOP(x);
; 1786 :             if (x != NULL) DISPATCH();
; 1787 :             break;

  01639	e9 00 fa ff ff	 jmp	 $LN1069@PyEval_Eva
$LN430@PyEval_Eva:

; 1788 : 
; 1789 :         TARGET(INPLACE_XOR)
; 1790 :             w = POP();

  0163e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01645	74 10		 je	 SHORT $LN592@PyEval_Eva
  01647	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0164b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01652	e8 00 00 00 00	 call	 prtrace
$LN592@PyEval_Eva:
  01657	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1791 :             v = TOP();

  0165b	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  0165f	48 83 ee 08	 sub	 rsi, 8

; 1792 :             x = PyNumber_InPlaceXor(v, w);

  01663	48 8b d7	 mov	 rdx, rdi
  01666	48 8b cb	 mov	 rcx, rbx
  01669	e8 00 00 00 00	 call	 PyNumber_InPlaceXor

; 1793 :             Py_DECREF(v);
; 1794 :             Py_DECREF(w);
; 1795 :             SET_TOP(x);
; 1796 :             if (x != NULL) DISPATCH();
; 1797 :             break;

  0166e	e9 cb f9 ff ff	 jmp	 $LN1069@PyEval_Eva
$LN428@PyEval_Eva:

; 1798 : 
; 1799 :         TARGET(INPLACE_OR)
; 1800 :             w = POP();

  01673	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0167a	74 10		 je	 SHORT $LN593@PyEval_Eva
  0167c	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01680	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01687	e8 00 00 00 00	 call	 prtrace
$LN593@PyEval_Eva:
  0168c	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 1801 :             v = TOP();

  01690	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  01694	48 83 ee 08	 sub	 rsi, 8

; 1802 :             x = PyNumber_InPlaceOr(v, w);

  01698	48 8b d7	 mov	 rdx, rdi
  0169b	48 8b cb	 mov	 rcx, rbx
  0169e	e8 00 00 00 00	 call	 PyNumber_InPlaceOr

; 1803 :             Py_DECREF(v);
; 1804 :             Py_DECREF(w);
; 1805 :             SET_TOP(x);
; 1806 :             if (x != NULL) DISPATCH();
; 1807 :             break;

  016a3	e9 96 f9 ff ff	 jmp	 $LN1069@PyEval_Eva
$LN426@PyEval_Eva:

; 1808 : 
; 1809 :         TARGET(STORE_SUBSCR)
; 1810 :             w = TOP();

  016a8	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]

; 1811 :             v = SECOND();

  016ac	48 8b 7e f0	 mov	 rdi, QWORD PTR [rsi-16]

; 1812 :             u = THIRD();

  016b0	4c 8b 66 e8	 mov	 r12, QWORD PTR [rsi-24]
  016b4	48 83 c6 e8	 add	 rsi, -24

; 1813 :             STACKADJ(-3);

  016b8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  016bf	74 10		 je	 SHORT $LN594@PyEval_Eva
  016c1	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  016c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  016cc	e8 00 00 00 00	 call	 prtrace
$LN594@PyEval_Eva:
  016d1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  016d6	48 8b c6	 mov	 rax, rsi
  016d9	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  016e0	48 c1 f8 03	 sar	 rax, 3
  016e4	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  016e7	7e 1a		 jle	 SHORT $LN595@PyEval_Eva
  016e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  016f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  016f7	41 b8 15 07 00
	00		 mov	 r8d, 1813		; 00000715H
  016fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN595@PyEval_Eva:

; 1814 :             /* v[w] = u */
; 1815 :             err = PyObject_SetItem(v, w, u);

  01703	4d 8b c4	 mov	 r8, r12
  01706	48 8b d3	 mov	 rdx, rbx
  01709	48 8b cf	 mov	 rcx, rdi
  0170c	e8 00 00 00 00	 call	 PyObject_SetItem

; 1816 :             Py_DECREF(u);

  01711	49 8b cc	 mov	 rcx, r12
  01714	44 8b e8	 mov	 r13d, eax
  01717	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  0171d	e8 00 00 00 00	 call	 _Py_DecRef
$LN1057@PyEval_Eva:

; 1817 :             Py_DECREF(v);

  01722	48 8b cf	 mov	 rcx, rdi
  01725	e8 00 00 00 00	 call	 _Py_DecRef
$LN1058@PyEval_Eva:

; 1818 :             Py_DECREF(w);

  0172a	48 8b cb	 mov	 rcx, rbx
$LN1059@PyEval_Eva:
  0172d	e8 00 00 00 00	 call	 _Py_DecRef

; 1819 :             if (err == 0) DISPATCH();

  01732	45 85 ed	 test	 r13d, r13d
  01735	0f 84 07 eb ff
	ff		 je	 $LN1064@PyEval_Eva

; 1820 :             break;

  0173b	e9 d1 f4 ff ff	 jmp	 $LN1039@PyEval_Eva
$LN424@PyEval_Eva:

; 1821 : 
; 1822 :         TARGET(DELETE_SUBSCR)
; 1823 :             w = TOP();

  01740	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]

; 1824 :             v = SECOND();

  01744	48 8b 7e f0	 mov	 rdi, QWORD PTR [rsi-16]
  01748	48 83 c6 f0	 add	 rsi, -16

; 1825 :             STACKADJ(-2);

  0174c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01753	74 10		 je	 SHORT $LN596@PyEval_Eva
  01755	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01759	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  01760	e8 00 00 00 00	 call	 prtrace
$LN596@PyEval_Eva:
  01765	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  0176a	48 8b c6	 mov	 rax, rsi
  0176d	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  01774	48 c1 f8 03	 sar	 rax, 3
  01778	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  0177b	7e 1a		 jle	 SHORT $LN597@PyEval_Eva
  0177d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  01784	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  0178b	41 b8 21 07 00
	00		 mov	 r8d, 1825		; 00000721H
  01791	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN597@PyEval_Eva:

; 1826 :             /* del v[w] */
; 1827 :             err = PyObject_DelItem(v, w);

  01797	48 8b d3	 mov	 rdx, rbx
  0179a	48 8b cf	 mov	 rcx, rdi
  0179d	e8 00 00 00 00	 call	 PyObject_DelItem
  017a2	44 8b e8	 mov	 r13d, eax
  017a5	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax

; 1828 :             Py_DECREF(v);
; 1829 :             Py_DECREF(w);
; 1830 :             if (err == 0) DISPATCH();
; 1831 :             break;

  017ab	e9 72 ff ff ff	 jmp	 $LN1057@PyEval_Eva
$LN422@PyEval_Eva:

; 1832 : 
; 1833 :         TARGET(PRINT_EXPR)
; 1834 :             v = POP();

  017b0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  017b7	74 10		 je	 SHORT $LN598@PyEval_Eva
  017b9	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  017bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  017c4	e8 00 00 00 00	 call	 prtrace
$LN598@PyEval_Eva:
  017c9	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]
  017cd	48 83 ee 08	 sub	 rsi, 8

; 1835 :             w = PySys_GetObject("displayhook");

  017d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@OABHHABA@displayhook?$AA@
  017d8	e8 00 00 00 00	 call	 PySys_GetObject
  017dd	48 8b d8	 mov	 rbx, rax

; 1836 :             if (w == NULL) {

  017e0	48 85 c0	 test	 rax, rax
  017e3	75 21		 jne	 SHORT $LN421@PyEval_Eva

; 1837 :                 PyErr_SetString(PyExc_RuntimeError,
; 1838 :                                 "lost sys.displayhook");

  017e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  017ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@LDJCNLPE@lost?5sys?4displayhook?$AA@
  017f3	e8 00 00 00 00	 call	 PyErr_SetString

; 1839 :                 err = -1;

  017f8	41 83 cd ff	 or	 r13d, -1

; 1840 :                 x = NULL;

  017fc	45 33 f6	 xor	 r14d, r14d
  017ff	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14

; 1841 :             }
; 1842 :             if (err == 0) {

  01804	eb 46		 jmp	 SHORT $LN1041@PyEval_Eva
$LN421@PyEval_Eva:
  01806	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  0180d	45 85 ed	 test	 r13d, r13d
  01810	75 41		 jne	 SHORT $LN413@PyEval_Eva

; 1843 :                 x = PyTuple_Pack(1, v);

  01812	41 8d 4d 01	 lea	 ecx, QWORD PTR [r13+1]
  01816	48 8b d7	 mov	 rdx, rdi
  01819	e8 00 00 00 00	 call	 PyTuple_Pack
  0181e	4c 8b f0	 mov	 r14, rax
  01821	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 1844 :                 if (x == NULL)

  01826	48 85 c0	 test	 rax, rax

; 1845 :                     err = -1;
; 1846 :             }
; 1847 :             if (err == 0) {

  01829	74 1d		 je	 SHORT $LN858@PyEval_Eva

; 1848 :                 w = PyEval_CallObject(w, x);

  0182b	45 33 c0	 xor	 r8d, r8d
  0182e	48 8b d0	 mov	 rdx, rax
  01831	48 8b cb	 mov	 rcx, rbx
  01834	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords

; 1849 :                 Py_XDECREF(w);

  01839	48 85 c0	 test	 rax, rax
  0183c	74 0a		 je	 SHORT $LN858@PyEval_Eva
  0183e	48 8b c8	 mov	 rcx, rax
  01841	e8 00 00 00 00	 call	 _Py_DecRef

; 1850 :                 if (w == NULL)

  01846	eb 0b		 jmp	 SHORT $LN413@PyEval_Eva
$LN858@PyEval_Eva:

; 1851 :                     err = -1;

  01848	41 83 cd ff	 or	 r13d, -1
$LN1041@PyEval_Eva:
  0184c	44 89 ad 98 00
	00 00		 mov	 DWORD PTR err$1$[rbp-256], r13d
$LN413@PyEval_Eva:

; 1852 :             }
; 1853 :             Py_DECREF(v);

  01853	48 8b cf	 mov	 rcx, rdi
  01856	e8 00 00 00 00	 call	 _Py_DecRef

; 1854 :             Py_XDECREF(x);

  0185b	4d 85 f6	 test	 r14, r14
  0185e	0f 84 ad f3 ff
	ff		 je	 $LN1039@PyEval_Eva
  01864	49 8b ce	 mov	 rcx, r14
  01867	e8 00 00 00 00	 call	 _Py_DecRef

; 1855 :             break;

  0186c	e9 a0 f3 ff ff	 jmp	 $LN1039@PyEval_Eva
$LN408@PyEval_Eva:

; 1856 : 
; 1857 : #ifdef CASE_TOO_BIG
; 1858 :         default: switch (opcode) {
; 1859 : #endif
; 1860 :         TARGET(RAISE_VARARGS)
; 1861 :             v = w = NULL;

  01871	45 33 e4	 xor	 r12d, r12d
  01874	41 8b cc	 mov	 ecx, r12d
  01877	41 8b dc	 mov	 ebx, r12d

; 1862 :             switch (oparg) {

  0187a	45 85 ed	 test	 r13d, r13d
  0187d	74 6e		 je	 SHORT $LN403@PyEval_Eva
  0187f	41 ff cd	 dec	 r13d
  01882	74 48		 je	 SHORT $LN404@PyEval_Eva
  01884	41 ff cd	 dec	 r13d
  01887	74 23		 je	 SHORT $LN405@PyEval_Eva

; 1869 :                 break;
; 1870 :             default:
; 1871 :                 PyErr_SetString(PyExc_SystemError,
; 1872 :                            "bad RAISE_VARARGS oparg");

  01889	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  01890	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@INLFGEHA@bad?5RAISE_VARARGS?5oparg?$AA@
  01897	e8 00 00 00 00	 call	 PyErr_SetString

; 1873 :                 why = WHY_EXCEPTION;

  0189c	bb 02 00 00 00	 mov	 ebx, 2
  018a1	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx

; 1874 :                 break;

  018a7	e9 cc f3 ff ff	 jmp	 $LN82@PyEval_Eva
$LN405@PyEval_Eva:

; 1863 :             case 2:
; 1864 :                 v = POP(); /* cause */

  018ac	39 0d 00 00 00
	00		 cmp	 DWORD PTR lltrace, ecx
  018b2	74 10		 je	 SHORT $LN599@PyEval_Eva
  018b4	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  018b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  018bf	e8 00 00 00 00	 call	 prtrace
$LN599@PyEval_Eva:
  018c4	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  018c8	48 83 ee 08	 sub	 rsi, 8
$LN404@PyEval_Eva:

; 1865 :             case 1:
; 1866 :                 w = POP(); /* exc */

  018cc	44 39 25 00 00
	00 00		 cmp	 DWORD PTR lltrace, r12d
  018d3	74 10		 je	 SHORT $LN600@PyEval_Eva
  018d5	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  018d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  018e0	e8 00 00 00 00	 call	 prtrace
$LN600@PyEval_Eva:
  018e5	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  018e9	48 83 ee 08	 sub	 rsi, 8
$LN403@PyEval_Eva:

; 1867 :             case 0: /* Fallthrough */
; 1868 :                 why = do_raise(w, v);

  018ed	48 8b d3	 mov	 rdx, rbx
  018f0	e8 00 00 00 00	 call	 do_raise

; 1875 :             }
; 1876 :             break;

  018f5	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  018fc	bb 02 00 00 00	 mov	 ebx, 2
  01901	89 85 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], eax
  01907	e9 13 f3 ff ff	 jmp	 $LN1042@PyEval_Eva
$LN401@PyEval_Eva:

; 1877 : 
; 1878 :         TARGET(STORE_LOCALS)
; 1879 :             x = POP();

  0190c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01913	74 10		 je	 SHORT $LN601@PyEval_Eva
  01915	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01919	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01920	e8 00 00 00 00	 call	 prtrace
$LN601@PyEval_Eva:

; 1880 :             v = f->f_locals;

  01925	49 8b 8f 90 00
	00 00		 mov	 rcx, QWORD PTR [r15+144]
  0192c	4c 8b 76 f8	 mov	 r14, QWORD PTR [rsi-8]
  01930	48 83 ee 08	 sub	 rsi, 8
  01934	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14

; 1881 :             Py_XDECREF(v);

  01939	48 85 c9	 test	 rcx, rcx
  0193c	74 05		 je	 SHORT $LN399@PyEval_Eva
  0193e	e8 00 00 00 00	 call	 _Py_DecRef
$LN399@PyEval_Eva:

; 1882 :             f->f_locals = x;
; 1883 :             DISPATCH();

  01943	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  01948	4d 89 b7 90 00
	00 00		 mov	 QWORD PTR [r15+144], r14
  0194f	e9 fd e8 ff ff	 jmp	 $LN538@PyEval_Eva
$LN396@PyEval_Eva:

; 1884 : 
; 1885 :         TARGET(RETURN_VALUE)
; 1886 :             retval = POP();

  01954	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0195b	74 10		 je	 SHORT $LN602@PyEval_Eva
  0195d	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01961	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01968	e8 00 00 00 00	 call	 prtrace
$LN602@PyEval_Eva:
  0196d	48 8b 46 f8	 mov	 rax, QWORD PTR [rsi-8]
  01971	48 83 ee 08	 sub	 rsi, 8

; 1887 :             why = WHY_RETURN;

  01975	b9 08 00 00 00	 mov	 ecx, 8
  0197a	48 89 44 24 60	 mov	 QWORD PTR retval$1$[rsp], rax

; 1888 :             goto fast_block_end;

  0197f	e9 07 22 00 00	 jmp	 $LN1043@PyEval_Eva
$LN395@PyEval_Eva:

; 1889 : 
; 1890 :         TARGET(YIELD_FROM)
; 1891 :             u = POP();

  01984	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0198b	74 10		 je	 SHORT $LN603@PyEval_Eva
  0198d	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01991	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01998	e8 00 00 00 00	 call	 prtrace
$LN603@PyEval_Eva:
  0199d	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  019a1	48 83 ee 08	 sub	 rsi, 8

; 1892 :             x = TOP();
; 1893 :             /* send u to x */
; 1894 :             if (PyGen_CheckExact(x)) {

  019a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyGen_Type
  019ac	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  019b0	48 8d 7e f8	 lea	 rdi, QWORD PTR [rsi-8]
  019b4	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  019b8	48 3b c2	 cmp	 rax, rdx
  019bb	75 0a		 jne	 SHORT $LN394@PyEval_Eva

; 1895 :                 retval = _PyGen_Send((PyGenObject *)x, u);

  019bd	48 8b d3	 mov	 rdx, rbx
  019c0	e8 00 00 00 00	 call	 _PyGen_Send

; 1896 :             } else {

  019c5	eb 3c		 jmp	 SHORT $LN1044@PyEval_Eva
$LN394@PyEval_Eva:

; 1897 :                 _Py_IDENTIFIER(send);
; 1898 :                 if (u == Py_None)

  019c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_Py_NoneStruct
  019ce	48 3b da	 cmp	 rbx, rdx
  019d1	75 08		 jne	 SHORT $LN392@PyEval_Eva

; 1899 :                     retval = Py_TYPE(x)->tp_iternext(x);

  019d3	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]

; 1900 :                 else

  019d9	eb 28		 jmp	 SHORT $LN1044@PyEval_Eva
$LN392@PyEval_Eva:

; 1901 :                     retval = _PyObject_CallMethodId(x, &PyId_send, "O", u);

  019db	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  019e2	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  019eb	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId_send@?DF@??PyEval_EvalFrameEx@@9@9
  019f0	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  019f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MJMHLOMK@O?$AA@
  019fb	4c 8b cb	 mov	 r9, rbx
  019fe	e8 00 00 00 00	 call	 _PyObject_CallMethodId
$LN1044@PyEval_Eva:

; 1902 :             }
; 1903 :             Py_DECREF(u);

  01a03	48 8b cb	 mov	 rcx, rbx
  01a06	4c 8b e8	 mov	 r13, rax
  01a09	48 89 44 24 60	 mov	 QWORD PTR retval$1$[rsp], rax
  01a0e	e8 00 00 00 00	 call	 _Py_DecRef

; 1904 :             if (!retval) {

  01a13	4d 85 ed	 test	 r13, r13
  01a16	0f 85 20 28 00
	00		 jne	 $LN390@PyEval_Eva

; 1905 :                 PyObject *val;
; 1906 :                 x = POP(); /* Remove iter from stack */

  01a1c	44 39 2d 00 00
	00 00		 cmp	 DWORD PTR lltrace, r13d
  01a23	74 0f		 je	 SHORT $LN604@PyEval_Eva
  01a25	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  01a28	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01a2f	e8 00 00 00 00	 call	 prtrace
$LN604@PyEval_Eva:

; 1907 :                 Py_DECREF(x);

  01a34	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  01a37	48 8b f7	 mov	 rsi, rdi
  01a3a	e8 00 00 00 00	 call	 _Py_DecRef

; 1908 :                 err = _PyGen_FetchStopIterationValue(&val);

  01a3f	48 8d 4d b8	 lea	 rcx, QWORD PTR val$64895[rbp-256]
  01a43	e8 00 00 00 00	 call	 _PyGen_FetchStopIterationValue
  01a48	44 8b e8	 mov	 r13d, eax
  01a4b	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax

; 1909 :                 if (err < 0) {

  01a51	85 c0		 test	 eax, eax
  01a53	79 1b		 jns	 SHORT $LN389@PyEval_Eva

; 1910 :                     x = NULL;
; 1911 :                     break;

  01a55	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR why$1$[rbp-256]
  01a5b	45 33 e4	 xor	 r12d, r12d
  01a5e	41 8d 5c 24 02	 lea	 ebx, QWORD PTR [r12+2]
  01a63	45 8b f4	 mov	 r14d, r12d
  01a66	4c 89 64 24 30	 mov	 QWORD PTR tmp$1$[rsp], r12
  01a6b	e9 af f1 ff ff	 jmp	 $LN1042@PyEval_Eva
$LN389@PyEval_Eva:

; 1912 :                 }
; 1913 :                 x = val;

  01a70	4c 8b 75 b8	 mov	 r14, QWORD PTR val$64895[rbp-256]

; 1914 :                 PUSH(x);

  01a74	48 83 c6 08	 add	 rsi, 8
  01a78	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01a7f	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14
  01a84	4c 89 37	 mov	 QWORD PTR [rdi], r14
  01a87	74 10		 je	 SHORT $LN605@PyEval_Eva
  01a89	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01a8d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  01a94	e8 00 00 00 00	 call	 prtrace
$LN605@PyEval_Eva:
  01a99	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  01a9e	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  01aa3	48 8b c6	 mov	 rax, rsi
  01aa6	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  01aad	48 c1 f8 03	 sar	 rax, 3
  01ab1	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  01ab4	0f 8e 97 e7 ff
	ff		 jle	 $LN538@PyEval_Eva
  01aba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  01ac1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  01ac8	41 b8 7a 07 00
	00		 mov	 r8d, 1914		; 0000077aH
  01ace	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 1915 :                 continue;

  01ad4	e9 78 e7 ff ff	 jmp	 $LN538@PyEval_Eva
$LN387@PyEval_Eva:

; 1929 : 
; 1930 :         TARGET(POP_EXCEPT)
; 1931 :             {
; 1932 :                 PyTryBlock *b = PyFrame_BlockPop(f);

  01ad9	49 8b cf	 mov	 rcx, r15
  01adc	e8 00 00 00 00	 call	 PyFrame_BlockPop
  01ae1	48 8b d8	 mov	 rbx, rax

; 1933 :                 if (b->b_type != EXCEPT_HANDLER) {

  01ae4	81 38 01 01 00
	00		 cmp	 DWORD PTR [rax], 257	; 00000101H
  01aea	74 23		 je	 SHORT $LN386@PyEval_Eva

; 1934 :                     PyErr_SetString(PyExc_SystemError,
; 1935 :                         "popped block is not an except handler");

  01aec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  01af3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@CDCIJBNO@popped?5block?5is?5not?5an?5except?5ha@
  01afa	e8 00 00 00 00	 call	 PyErr_SetString

; 1936 :                     why = WHY_EXCEPTION;

  01aff	bb 02 00 00 00	 mov	 ebx, 2
  01b04	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx

; 1937 :                     break;

  01b0a	e9 69 f1 ff ff	 jmp	 $LN82@PyEval_Eva
$LN386@PyEval_Eva:

; 1938 :                 }
; 1939 :                 UNWIND_EXCEPT_HANDLER(b);

  01b0f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  01b12	48 8b ce	 mov	 rcx, rsi
  01b15	49 2b 8f 98 00
	00 00		 sub	 rcx, QWORD PTR [r15+152]
  01b1c	83 c0 03	 add	 eax, 3
  01b1f	48 c1 f9 03	 sar	 rcx, 3
  01b23	3b c8		 cmp	 ecx, eax
  01b25	7d 1a		 jge	 SHORT $LN820@PyEval_Eva
  01b27	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  01b2e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@OJMEFFAL@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?$CI?$AAb?$AA?$CJ?$AA?9?$AA?$DO?$AAb?$AA_?$AAl?$AAe?$AAv?$AAe?$AAl?$AA?5?$AA?$CL?$AA?5@
  01b35	41 b8 93 07 00
	00		 mov	 r8d, 1939		; 00000793H
  01b3b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN820@PyEval_Eva:
  01b41	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  01b44	48 8b ce	 mov	 rcx, rsi
  01b47	49 2b 8f 98 00
	00 00		 sub	 rcx, QWORD PTR [r15+152]
  01b4e	83 c0 03	 add	 eax, 3
  01b51	48 c1 f9 03	 sar	 rcx, 3
  01b55	3b c8		 cmp	 ecx, eax
  01b57	7e 4a		 jle	 SHORT $LN946@PyEval_Eva
  01b59	0f 1f 80 00 00
	00 00		 npad	 7
$LL385@PyEval_Eva:
  01b60	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01b67	74 10		 je	 SHORT $LN609@PyEval_Eva
  01b69	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01b6d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01b74	e8 00 00 00 00	 call	 prtrace
$LN609@PyEval_Eva:
  01b79	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01b7d	48 83 ee 08	 sub	 rsi, 8
  01b81	48 85 c9	 test	 rcx, rcx
  01b84	74 05		 je	 SHORT $LN382@PyEval_Eva
  01b86	e8 00 00 00 00	 call	 _Py_DecRef
$LN382@PyEval_Eva:
  01b8b	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  01b8e	48 8b ce	 mov	 rcx, rsi
  01b91	49 2b 8f 98 00
	00 00		 sub	 rcx, QWORD PTR [r15+152]
  01b98	83 c0 03	 add	 eax, 3
  01b9b	48 c1 f9 03	 sar	 rcx, 3
  01b9f	3b c8		 cmp	 ecx, eax
  01ba1	7f bd		 jg	 SHORT $LL385@PyEval_Eva
$LN946@PyEval_Eva:
  01ba3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01baa	4c 8b 6c 24 38	 mov	 r13, QWORD PTR tstate$1$[rsp]
  01baf	49 8b 5d 60	 mov	 rbx, QWORD PTR [r13+96]
  01bb3	49 8b 7d 68	 mov	 rdi, QWORD PTR [r13+104]
  01bb7	4d 8b 65 70	 mov	 r12, QWORD PTR [r13+112]
  01bbb	74 10		 je	 SHORT $LN610@PyEval_Eva
  01bbd	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01bc1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01bc8	e8 00 00 00 00	 call	 prtrace
$LN610@PyEval_Eva:
  01bcd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01bd4	48 8b 46 f8	 mov	 rax, QWORD PTR [rsi-8]
  01bd8	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  01bdc	74 10		 je	 SHORT $LN611@PyEval_Eva
  01bde	48 8b 4e f0	 mov	 rcx, QWORD PTR [rsi-16]
  01be2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01be9	e8 00 00 00 00	 call	 prtrace
$LN611@PyEval_Eva:
  01bee	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01bf5	48 8b 46 f0	 mov	 rax, QWORD PTR [rsi-16]
  01bf9	49 89 45 68	 mov	 QWORD PTR [r13+104], rax
  01bfd	74 10		 je	 SHORT $LN612@PyEval_Eva
  01bff	48 8b 4e e8	 mov	 rcx, QWORD PTR [rsi-24]
  01c03	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01c0a	e8 00 00 00 00	 call	 prtrace
$LN612@PyEval_Eva:
  01c0f	48 8b 46 e8	 mov	 rax, QWORD PTR [rsi-24]
  01c13	48 83 ee 18	 sub	 rsi, 24
  01c17	49 89 45 70	 mov	 QWORD PTR [r13+112], rax
  01c1b	48 85 db	 test	 rbx, rbx
  01c1e	74 08		 je	 SHORT $LN378@PyEval_Eva
  01c20	48 8b cb	 mov	 rcx, rbx
  01c23	e8 00 00 00 00	 call	 _Py_DecRef
$LN378@PyEval_Eva:
  01c28	48 85 ff	 test	 rdi, rdi
  01c2b	74 08		 je	 SHORT $LN374@PyEval_Eva
  01c2d	48 8b cf	 mov	 rcx, rdi
  01c30	e8 00 00 00 00	 call	 _Py_DecRef
$LN374@PyEval_Eva:
  01c35	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  01c3a	49 8b fd	 mov	 rdi, r13
  01c3d	4d 85 e4	 test	 r12, r12
  01c40	0f 84 43 f2 ff
	ff		 je	 $LN984@PyEval_Eva
  01c46	49 8b cc	 mov	 rcx, r12
  01c49	e8 00 00 00 00	 call	 _Py_DecRef

; 1940 :             }
; 1941 :             DISPATCH();

  01c4e	4c 8b 64 24 40	 mov	 r12, QWORD PTR next_instr$1$[rsp]
  01c53	e9 f9 e5 ff ff	 jmp	 $LN538@PyEval_Eva
$LN367@PyEval_Eva:

; 1942 : 
; 1943 :         TARGET(POP_BLOCK)
; 1944 :             {
; 1945 :                 PyTryBlock *b = PyFrame_BlockPop(f);

  01c58	49 8b cf	 mov	 rcx, r15
  01c5b	e8 00 00 00 00	 call	 PyFrame_BlockPop

; 1946 :                 UNWIND_BLOCK(b);

  01c60	48 8b ce	 mov	 rcx, rsi
  01c63	49 2b 8f 98 00
	00 00		 sub	 rcx, QWORD PTR [r15+152]
  01c6a	48 8b d8	 mov	 rbx, rax
  01c6d	48 c1 f9 03	 sar	 rcx, 3
  01c71	3b 48 08	 cmp	 ecx, DWORD PTR [rax+8]
  01c74	0f 8e c8 e5 ff
	ff		 jle	 $LN1064@PyEval_Eva
  01c7a	66 0f 1f 44 00
	00		 npad	 6
$LL366@PyEval_Eva:
  01c80	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01c87	74 10		 je	 SHORT $LN613@PyEval_Eva
  01c89	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01c8d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01c94	e8 00 00 00 00	 call	 prtrace
$LN613@PyEval_Eva:
  01c99	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01c9d	48 83 ee 08	 sub	 rsi, 8
  01ca1	48 85 c9	 test	 rcx, rcx
  01ca4	74 05		 je	 SHORT $LN363@PyEval_Eva
  01ca6	e8 00 00 00 00	 call	 _Py_DecRef
$LN363@PyEval_Eva:
  01cab	48 8b c6	 mov	 rax, rsi
  01cae	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  01cb5	48 c1 f8 03	 sar	 rax, 3
  01cb9	3b 43 08	 cmp	 eax, DWORD PTR [rbx+8]
  01cbc	7f c2		 jg	 SHORT $LL366@PyEval_Eva

; 1947 :             }
; 1948 :             DISPATCH();

  01cbe	e9 84 e5 ff ff	 jmp	 $LN1065@PyEval_Eva
$LN333@PyEval_Eva:

; 1984 : 
; 1985 :         TARGET(LOAD_BUILD_CLASS)
; 1986 :         {
; 1987 :             _Py_IDENTIFIER(__build_class__);
; 1988 : 
; 1989 :             if (PyDict_CheckExact(f->f_builtins)) {

  01cc3	49 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [r15+128]
  01cca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  01cd1	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  01cd5	74 74		 je	 SHORT $LN331@PyEval_Eva
  01cd7	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  01cdb	74 6e		 je	 SHORT $LN331@PyEval_Eva

; 1997 :             }
; 1998 :             else {
; 1999 :                 PyObject *build_class_str = _PyUnicode_FromId(&PyId___build_class__);

  01cdd	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _tls_index
  01ce3	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  01cec	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:?PyId___build_class__@?EO@??PyEval_EvalFrameEx@@9@9
  01cf1	48 03 0c d0	 add	 rcx, QWORD PTR [rax+rdx*8]
  01cf5	e8 00 00 00 00	 call	 _PyUnicode_FromId

; 2000 :                 if (build_class_str == NULL)

  01cfa	48 85 c0	 test	 rax, rax
  01cfd	0f 84 a0 1d 00
	00		 je	 $LN1016@PyEval_Eva

; 2001 :                     break;
; 2002 :                 x = PyObject_GetItem(f->f_builtins, build_class_str);

  01d03	49 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [r15+128]
  01d0a	48 8b d0	 mov	 rdx, rax
  01d0d	e8 00 00 00 00	 call	 PyObject_GetItem
  01d12	4c 8b f0	 mov	 r14, rax
  01d15	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2003 :                 if (x == NULL) {

  01d1a	48 85 c0	 test	 rax, rax
  01d1d	75 5f		 jne	 SHORT $LN327@PyEval_Eva

; 2004 :                     if (PyErr_ExceptionMatches(PyExc_KeyError))

  01d1f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  01d26	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  01d2b	85 c0		 test	 eax, eax
  01d2d	0f 84 d7 ee ff
	ff		 je	 $LN1017@PyEval_Eva
$LN1052@PyEval_Eva:

; 2005 :                         PyErr_SetString(PyExc_NameError,
; 2006 :                                         "__build_class__ not found");

  01d33	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  01d3a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@IAGNFEAN@__build_class__?5not?5found?$AA@
  01d41	e8 00 00 00 00	 call	 PyErr_SetString

; 2007 :                     break;

  01d46	e9 bf ee ff ff	 jmp	 $LN1017@PyEval_Eva
$LN331@PyEval_Eva:

; 1990 :                 x = _PyDict_GetItemId(f->f_builtins, &PyId___build_class__);

  01d4b	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  01d52	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  01d5b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___build_class__@?EO@??PyEval_EvalFrameEx@@9@9
  01d60	4a 03 14 c0	 add	 rdx, QWORD PTR [rax+r8*8]
  01d64	e8 00 00 00 00	 call	 _PyDict_GetItemId
  01d69	4c 8b f0	 mov	 r14, rax
  01d6c	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 1991 :                 if (x == NULL) {

  01d71	48 85 c0	 test	 rax, rax

; 1992 :                     PyErr_SetString(PyExc_NameError,
; 1993 :                                     "__build_class__ not found");
; 1994 :                     break;

  01d74	74 bd		 je	 SHORT $LN1052@PyEval_Eva

; 1995 :                 }
; 1996 :                 Py_INCREF(x);

  01d76	48 8b c8	 mov	 rcx, rax
  01d79	e8 00 00 00 00	 call	 _Py_IncRef
$LN327@PyEval_Eva:

; 2008 :                 }
; 2009 :             }
; 2010 :             PUSH(x);

  01d7e	4c 89 36	 mov	 QWORD PTR [rsi], r14
  01d81	48 83 c6 08	 add	 rsi, 8
  01d85	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01d8c	74 10		 je	 SHORT $LN625@PyEval_Eva
  01d8e	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01d92	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  01d99	e8 00 00 00 00	 call	 prtrace
$LN625@PyEval_Eva:
  01d9e	48 8b c6	 mov	 rax, rsi
  01da1	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  01da8	48 c1 f8 03	 sar	 rax, 3
  01dac	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  01daf	0f 8e 55 ee ff
	ff		 jle	 $LN1017@PyEval_Eva
  01db5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  01dbc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  01dc3	41 b8 da 07 00
	00		 mov	 r8d, 2010		; 000007daH
  01dc9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2011 :             break;

  01dcf	e9 36 ee ff ff	 jmp	 $LN1017@PyEval_Eva
$LN325@PyEval_Eva:

; 2012 :         }
; 2013 : 
; 2014 :         TARGET(STORE_NAME)
; 2015 :             w = GETITEM(names, oparg);

  01dd4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR names$1$[rsp]
  01dd9	49 63 d5	 movsxd	 rdx, r13d
  01ddc	e8 00 00 00 00	 call	 PyTuple_GetItem

; 2016 :             v = POP();

  01de1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01de8	48 8b f8	 mov	 rdi, rax
  01deb	74 10		 je	 SHORT $LN627@PyEval_Eva
  01ded	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01df1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01df8	e8 00 00 00 00	 call	 prtrace
$LN627@PyEval_Eva:

; 2017 :             if ((x = f->f_locals) != NULL) {

  01dfd	4d 8b b7 90 00
	00 00		 mov	 r14, QWORD PTR [r15+144]
  01e04	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  01e08	48 83 ee 08	 sub	 rsi, 8
  01e0c	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14
  01e11	4d 85 f6	 test	 r14, r14
  01e14	74 4b		 je	 SHORT $LN324@PyEval_Eva

; 2018 :                 if (PyDict_CheckExact(x))

  01e16	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  01e1d	49 39 46 58	 cmp	 QWORD PTR [r14+88], rax
  01e21	74 22		 je	 SHORT $LN322@PyEval_Eva
  01e23	49 39 46 38	 cmp	 QWORD PTR [r14+56], rax
  01e27	74 1c		 je	 SHORT $LN322@PyEval_Eva

; 2020 :                 else
; 2021 :                     err = PyObject_SetItem(x, w, v);

  01e29	4c 8b c3	 mov	 r8, rbx
  01e2c	48 8b d7	 mov	 rdx, rdi
  01e2f	49 8b ce	 mov	 rcx, r14
  01e32	e8 00 00 00 00	 call	 PyObject_SetItem
  01e37	44 8b e8	 mov	 r13d, eax
  01e3a	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax

; 2022 :                 Py_DECREF(v);
; 2023 :                 if (err == 0) DISPATCH();
; 2024 :                 break;

  01e40	e9 e5 f8 ff ff	 jmp	 $LN1058@PyEval_Eva
$LN322@PyEval_Eva:

; 2019 :                     err = PyDict_SetItem(x, w, v);

  01e45	4c 8b c3	 mov	 r8, rbx
  01e48	48 8b d7	 mov	 rdx, rdi
  01e4b	49 8b ce	 mov	 rcx, r14
  01e4e	e8 00 00 00 00	 call	 PyDict_SetItem
  01e53	44 8b e8	 mov	 r13d, eax
  01e56	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax

; 2022 :                 Py_DECREF(v);
; 2023 :                 if (err == 0) DISPATCH();
; 2024 :                 break;

  01e5c	e9 c9 f8 ff ff	 jmp	 $LN1058@PyEval_Eva
$LN324@PyEval_Eva:

; 2025 :             }
; 2026 :             PyErr_Format(PyExc_SystemError,
; 2027 :                          "no locals found when storing %R", w);

  01e61	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  01e68	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@PHPKHPGD@no?5locals?5found?5when?5storing?5?$CFR?$AA@
  01e6f	4c 8b c7	 mov	 r8, rdi
  01e72	e8 00 00 00 00	 call	 PyErr_Format

; 2028 :             break;

  01e77	e9 8e ed ff ff	 jmp	 $LN1017@PyEval_Eva
$LN319@PyEval_Eva:

; 2029 : 
; 2030 :         TARGET(DELETE_NAME)
; 2031 :             w = GETITEM(names, oparg);

  01e7c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR names$1$[rsp]
  01e81	49 63 d5	 movsxd	 rdx, r13d
  01e84	e8 00 00 00 00	 call	 PyTuple_GetItem

; 2032 :             if ((x = f->f_locals) != NULL) {

  01e89	4d 8b b7 90 00
	00 00		 mov	 r14, QWORD PTR [r15+144]
  01e90	48 8b d8	 mov	 rbx, rax
  01e93	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14
  01e98	4d 85 f6	 test	 r14, r14
  01e9b	74 37		 je	 SHORT $LN318@PyEval_Eva

; 2033 :                 if ((err = PyObject_DelItem(x, w)) != 0)

  01e9d	48 8b d0	 mov	 rdx, rax
  01ea0	49 8b ce	 mov	 rcx, r14
  01ea3	e8 00 00 00 00	 call	 PyObject_DelItem
  01ea8	44 8b e8	 mov	 r13d, eax
  01eab	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  01eb1	85 c0		 test	 eax, eax
  01eb3	0f 84 58 ed ff
	ff		 je	 $LN1039@PyEval_Eva

; 2034 :                     format_exc_check_arg(PyExc_NameError,
; 2035 :                                          NAME_ERROR_MSG,
; 2036 :                                          w);

  01eb9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  01ec0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DBLGJMNF@name?5?8?$CF?4200s?8?5is?5not?5defined?$AA@
  01ec7	4c 8b c3	 mov	 r8, rbx
  01eca	e8 00 00 00 00	 call	 format_exc_check_arg

; 2037 :                 break;

  01ecf	e9 3d ed ff ff	 jmp	 $LN1039@PyEval_Eva
$LN318@PyEval_Eva:

; 2038 :             }
; 2039 :             PyErr_Format(PyExc_SystemError,
; 2040 :                          "no locals when deleting %R", w);

  01ed4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  01edb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@HJKLBJNK@no?5locals?5when?5deleting?5?$CFR?$AA@
  01ee2	4c 8b c0	 mov	 r8, rax
  01ee5	e8 00 00 00 00	 call	 PyErr_Format

; 2041 :             break;

  01eea	e9 1b ed ff ff	 jmp	 $LN1017@PyEval_Eva
$LN305@PyEval_Eva:

; 2075 : 
; 2076 :         TARGET(UNPACK_EX)
; 2077 :         {
; 2078 :             int totalargs = 1 + (oparg & 0xFF) + (oparg >> 8);

  01eef	41 0f b6 fd	 movzx	 edi, r13b
  01ef3	41 c1 fd 08	 sar	 r13d, 8

; 2079 :             v = POP();

  01ef7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01efe	41 8d 5c 3d 01	 lea	 ebx, DWORD PTR [r13+rdi+1]
  01f03	74 10		 je	 SHORT $LN635@PyEval_Eva
  01f05	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01f09	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  01f10	e8 00 00 00 00	 call	 prtrace
$LN635@PyEval_Eva:
  01f15	4c 8b 66 f8	 mov	 r12, QWORD PTR [rsi-8]
  01f19	48 83 ee 08	 sub	 rsi, 8

; 2080 : 
; 2081 :             if (unpack_iterable(v, oparg & 0xFF, oparg >> 8,
; 2082 :                                 stack_pointer + totalargs)) {

  01f1d	48 63 c3	 movsxd	 rax, ebx
  01f20	48 8d 1c c6	 lea	 rbx, QWORD PTR [rsi+rax*8]
  01f24	45 8b c5	 mov	 r8d, r13d
  01f27	8b d7		 mov	 edx, edi
  01f29	49 8b cc	 mov	 rcx, r12
  01f2c	4c 8b cb	 mov	 r9, rbx
  01f2f	e8 00 00 00 00	 call	 unpack_iterable
  01f34	85 c0		 test	 eax, eax
  01f36	74 1c		 je	 SHORT $LN304@PyEval_Eva

; 2086 :             }
; 2087 :             Py_DECREF(v);

  01f38	49 8b cc	 mov	 rcx, r12
  01f3b	48 8b f3	 mov	 rsi, rbx
  01f3e	bb 02 00 00 00	 mov	 ebx, 2
  01f43	e8 00 00 00 00	 call	 _Py_DecRef

; 2088 :             break;

  01f48	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  01f4f	e9 c2 ec ff ff	 jmp	 $LN1046@PyEval_Eva
$LN304@PyEval_Eva:

; 2083 :                 stack_pointer += totalargs;
; 2084 :             } else {
; 2085 :                 why = WHY_EXCEPTION;

  01f54	bb 02 00 00 00	 mov	 ebx, 2

; 2086 :             }
; 2087 :             Py_DECREF(v);

  01f59	49 8b cc	 mov	 rcx, r12
  01f5c	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx
  01f62	e8 00 00 00 00	 call	 _Py_DecRef
$LN986@PyEval_Eva:

; 2088 :             break;

  01f67	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  01f6e	e9 a3 ec ff ff	 jmp	 $LN1046@PyEval_Eva
$LN302@PyEval_Eva:

; 2089 :         }
; 2090 : 
; 2091 :         TARGET(STORE_ATTR)
; 2092 :             w = GETITEM(names, oparg);

  01f73	48 8b 4c 24 58	 mov	 rcx, QWORD PTR names$1$[rsp]
  01f78	49 63 d5	 movsxd	 rdx, r13d
  01f7b	e8 00 00 00 00	 call	 PyTuple_GetItem

; 2093 :             v = TOP();

  01f80	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]

; 2094 :             u = SECOND();

  01f84	48 8b 7e f0	 mov	 rdi, QWORD PTR [rsi-16]
  01f88	48 83 c6 f0	 add	 rsi, -16

; 2095 :             STACKADJ(-2);

  01f8c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  01f93	4c 8b e0	 mov	 r12, rax
  01f96	74 10		 je	 SHORT $LN636@PyEval_Eva
  01f98	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  01f9c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  01fa3	e8 00 00 00 00	 call	 prtrace
$LN636@PyEval_Eva:
  01fa8	48 8b 44 24 48	 mov	 rax, QWORD PTR co$1$[rsp]
  01fad	48 8b d6	 mov	 rdx, rsi
  01fb0	49 2b 97 98 00
	00 00		 sub	 rdx, QWORD PTR [r15+152]
  01fb7	48 c1 fa 03	 sar	 rdx, 3
  01fbb	3b 50 6c	 cmp	 edx, DWORD PTR [rax+108]
  01fbe	7e 1a		 jle	 SHORT $LN637@PyEval_Eva
  01fc0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  01fc7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  01fce	41 b8 2f 08 00
	00		 mov	 r8d, 2095		; 0000082fH
  01fd4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN637@PyEval_Eva:

; 2096 :             err = PyObject_SetAttr(v, w, u); /* v.w = u */

  01fda	4c 8b c7	 mov	 r8, rdi
  01fdd	49 8b d4	 mov	 rdx, r12
  01fe0	48 8b cb	 mov	 rcx, rbx
  01fe3	e8 00 00 00 00	 call	 PyObject_SetAttr

; 2097 :             Py_DECREF(v);

  01fe8	48 8b cb	 mov	 rcx, rbx
  01feb	44 8b e8	 mov	 r13d, eax
  01fee	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  01ff4	e8 00 00 00 00	 call	 _Py_DecRef

; 2098 :             Py_DECREF(u);

  01ff9	48 8b cf	 mov	 rcx, rdi

; 2099 :             if (err == 0) DISPATCH();
; 2100 :             break;

  01ffc	e9 2c f7 ff ff	 jmp	 $LN1059@PyEval_Eva
$LN300@PyEval_Eva:

; 2101 : 
; 2102 :         TARGET(DELETE_ATTR)
; 2103 :             w = GETITEM(names, oparg);

  02001	48 8b 4c 24 58	 mov	 rcx, QWORD PTR names$1$[rsp]
  02006	49 63 d5	 movsxd	 rdx, r13d
  02009	e8 00 00 00 00	 call	 PyTuple_GetItem

; 2104 :             v = POP();

  0200e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02015	48 8b f8	 mov	 rdi, rax
  02018	74 10		 je	 SHORT $LN638@PyEval_Eva
  0201a	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0201e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  02025	e8 00 00 00 00	 call	 prtrace
$LN638@PyEval_Eva:
  0202a	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  0202e	48 83 ee 08	 sub	 rsi, 8

; 2105 :             err = PyObject_SetAttr(v, w, (PyObject *)NULL);

  02032	45 33 c0	 xor	 r8d, r8d
  02035	48 8b cb	 mov	 rcx, rbx
  02038	48 8b d7	 mov	 rdx, rdi
  0203b	e8 00 00 00 00	 call	 PyObject_SetAttr

; 2106 :                                             /* del v.w */
; 2107 :             Py_DECREF(v);

  02040	48 8b cb	 mov	 rcx, rbx
  02043	44 8b e8	 mov	 r13d, eax
  02046	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  0204c	e8 00 00 00 00	 call	 _Py_DecRef

; 2108 :             break;

  02051	e9 bb eb ff ff	 jmp	 $LN1039@PyEval_Eva
$LN299@PyEval_Eva:

; 2109 : 
; 2110 :         TARGET(STORE_GLOBAL)
; 2111 :             w = GETITEM(names, oparg);

  02056	48 8b 4c 24 58	 mov	 rcx, QWORD PTR names$1$[rsp]
  0205b	49 63 d5	 movsxd	 rdx, r13d
  0205e	e8 00 00 00 00	 call	 PyTuple_GetItem

; 2112 :             v = POP();

  02063	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0206a	48 8b f8	 mov	 rdi, rax
  0206d	74 10		 je	 SHORT $LN639@PyEval_Eva
  0206f	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  02073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0207a	e8 00 00 00 00	 call	 prtrace
$LN639@PyEval_Eva:
  0207f	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]

; 2113 :             err = PyDict_SetItem(f->f_globals, w, v);

  02083	49 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [r15+136]
  0208a	48 83 ee 08	 sub	 rsi, 8
  0208e	4c 8b c3	 mov	 r8, rbx
  02091	48 8b d7	 mov	 rdx, rdi
  02094	e8 00 00 00 00	 call	 PyDict_SetItem
  02099	44 8b e8	 mov	 r13d, eax
  0209c	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax

; 2114 :             Py_DECREF(v);
; 2115 :             if (err == 0) DISPATCH();
; 2116 :             break;

  020a2	e9 83 f6 ff ff	 jmp	 $LN1058@PyEval_Eva
$LN297@PyEval_Eva:

; 2117 : 
; 2118 :         TARGET(DELETE_GLOBAL)
; 2119 :             w = GETITEM(names, oparg);

  020a7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR names$1$[rsp]
  020ac	49 63 d5	 movsxd	 rdx, r13d
  020af	e8 00 00 00 00	 call	 PyTuple_GetItem

; 2120 :             if ((err = PyDict_DelItem(f->f_globals, w)) != 0)

  020b4	49 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [r15+136]
  020bb	48 8b d0	 mov	 rdx, rax
  020be	48 8b d8	 mov	 rbx, rax
  020c1	e8 00 00 00 00	 call	 PyDict_DelItem
  020c6	44 8b e8	 mov	 r13d, eax
  020c9	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  020cf	85 c0		 test	 eax, eax
  020d1	0f 84 3a eb ff
	ff		 je	 $LN1039@PyEval_Eva

; 2121 :                 format_exc_check_arg(
; 2122 :                     PyExc_NameError, GLOBAL_NAME_ERROR_MSG, w);

  020d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  020de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@
  020e5	4c 8b c3	 mov	 r8, rbx
  020e8	e8 00 00 00 00	 call	 format_exc_check_arg

; 2123 :             break;

  020ed	e9 1f eb ff ff	 jmp	 $LN1039@PyEval_Eva
$LN295@PyEval_Eva:

; 2124 : 
; 2125 :         TARGET(LOAD_NAME)
; 2126 :             w = GETITEM(names, oparg);

  020f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR names$1$[rsp]
  020f7	49 63 d5	 movsxd	 rdx, r13d
  020fa	e8 00 00 00 00	 call	 PyTuple_GetItem

; 2127 :             if ((v = f->f_locals) == NULL) {

  020ff	49 8b 8f 90 00
	00 00		 mov	 rcx, QWORD PTR [r15+144]
  02106	48 8b d8	 mov	 rbx, rax
  02109	48 85 c9	 test	 rcx, rcx
  0210c	75 26		 jne	 SHORT $LN294@PyEval_Eva

; 2128 :                 PyErr_Format(PyExc_SystemError,
; 2129 :                              "no locals when loading %R", w);

  0210e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  02115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@BEKKDKAN@no?5locals?5when?5loading?5?$CFR?$AA@
  0211c	4c 8b c0	 mov	 r8, rax
  0211f	e8 00 00 00 00	 call	 PyErr_Format

; 2130 :                 why = WHY_EXCEPTION;

  02124	bb 02 00 00 00	 mov	 ebx, 2
  02129	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx

; 2131 :                 break;

  0212f	e9 44 eb ff ff	 jmp	 $LN82@PyEval_Eva
$LN294@PyEval_Eva:

; 2132 :             }
; 2133 :             if (PyDict_CheckExact(v)) {

  02134	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:PyDict_Type
  0213b	4c 39 69 58	 cmp	 QWORD PTR [rcx+88], r13
  0213f	74 44		 je	 SHORT $LN292@PyEval_Eva
  02141	4c 39 69 38	 cmp	 QWORD PTR [rcx+56], r13
  02145	74 3e		 je	 SHORT $LN292@PyEval_Eva

; 2136 :             }
; 2137 :             else {
; 2138 :                 x = PyObject_GetItem(v, w);

  02147	48 8b d0	 mov	 rdx, rax
  0214a	e8 00 00 00 00	 call	 PyObject_GetItem
  0214f	4c 8b f0	 mov	 r14, rax
  02152	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2139 :                 if (x == NULL && _PyErr_OCCURRED()) {

  02157	48 85 c0	 test	 rax, rax
  0215a	0f 85 c9 00 00
	00		 jne	 $LN274@PyEval_Eva
  02160	e8 00 00 00 00	 call	 PyErr_Occurred
  02165	48 85 c0	 test	 rax, rax
  02168	74 34		 je	 SHORT $LN857@PyEval_Eva

; 2140 :                     if (!PyErr_ExceptionMatches(
; 2141 :                                     PyExc_KeyError))

  0216a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  02171	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  02176	85 c0		 test	 eax, eax
  02178	0f 84 8c ea ff
	ff		 je	 $LN1017@PyEval_Eva

; 2142 :                         break;
; 2143 :                     PyErr_Clear();

  0217e	e8 00 00 00 00	 call	 PyErr_Clear
  02183	eb 19		 jmp	 SHORT $LN857@PyEval_Eva
$LN292@PyEval_Eva:

; 2134 :                 x = PyDict_GetItem(v, w);

  02185	48 8b d0	 mov	 rdx, rax
  02188	e8 00 00 00 00	 call	 PyDict_GetItem
  0218d	4c 8b f0	 mov	 r14, rax
  02190	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2135 :                 Py_XINCREF(x);

  02195	48 85 c0	 test	 rax, rax

; 2144 :                 }
; 2145 :             }
; 2146 :             if (x == NULL) {

  02198	0f 85 83 00 00
	00		 jne	 $LN276@PyEval_Eva
$LN857@PyEval_Eva:

; 2147 :                 x = PyDict_GetItem(f->f_globals, w);

  0219e	49 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [r15+136]
  021a5	48 8b d3	 mov	 rdx, rbx
  021a8	e8 00 00 00 00	 call	 PyDict_GetItem
  021ad	4c 8b f0	 mov	 r14, rax
  021b0	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2148 :                 Py_XINCREF(x);

  021b5	48 85 c0	 test	 rax, rax

; 2149 :                 if (x == NULL) {

  021b8	75 67		 jne	 SHORT $LN276@PyEval_Eva

; 2150 :                     if (PyDict_CheckExact(f->f_builtins)) {

  021ba	49 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [r15+128]
  021c1	4c 39 69 58	 cmp	 QWORD PTR [rcx+88], r13
  021c5	74 45		 je	 SHORT $LN277@PyEval_Eva
  021c7	4c 39 69 38	 cmp	 QWORD PTR [rcx+56], r13
  021cb	74 3f		 je	 SHORT $LN277@PyEval_Eva

; 2159 :                     }
; 2160 :                     else {
; 2161 :                         x = PyObject_GetItem(f->f_builtins, w);

  021cd	48 8b d3	 mov	 rdx, rbx
  021d0	e8 00 00 00 00	 call	 PyObject_GetItem
  021d5	4c 8b f0	 mov	 r14, rax
  021d8	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2162 :                         if (x == NULL) {

  021dd	48 85 c0	 test	 rax, rax
  021e0	75 47		 jne	 SHORT $LN274@PyEval_Eva

; 2163 :                             if (PyErr_ExceptionMatches(PyExc_KeyError))

  021e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  021e9	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  021ee	85 c0		 test	 eax, eax
  021f0	0f 84 14 ea ff
	ff		 je	 $LN1017@PyEval_Eva
$LN1054@PyEval_Eva:

; 2164 :                                 format_exc_check_arg(
; 2165 :                                             PyExc_NameError,
; 2166 :                                             NAME_ERROR_MSG, w);

  021f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  021fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@DBLGJMNF@name?5?8?$CF?4200s?8?5is?5not?5defined?$AA@
  02204	4c 8b c3	 mov	 r8, rbx

; 2167 :                             break;

  02207	e9 f9 e9 ff ff	 jmp	 $LN1056@PyEval_Eva
$LN277@PyEval_Eva:

; 2151 :                         x = PyDict_GetItem(f->f_builtins, w);

  0220c	48 8b d3	 mov	 rdx, rbx
  0220f	e8 00 00 00 00	 call	 PyDict_GetItem
  02214	4c 8b f0	 mov	 r14, rax
  02217	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2152 :                         if (x == NULL) {

  0221c	48 85 c0	 test	 rax, rax

; 2153 :                             format_exc_check_arg(
; 2154 :                                         PyExc_NameError,
; 2155 :                                         NAME_ERROR_MSG, w);
; 2156 :                             break;

  0221f	74 d5		 je	 SHORT $LN1054@PyEval_Eva
$LN276@PyEval_Eva:

; 2157 :                         }
; 2158 :                         Py_INCREF(x);

  02221	48 8b c8	 mov	 rcx, rax
  02224	e8 00 00 00 00	 call	 _Py_IncRef
$LN274@PyEval_Eva:

; 2168 :                         }
; 2169 :                     }
; 2170 :                 }
; 2171 :             }
; 2172 :             PUSH(x);

  02229	4c 89 36	 mov	 QWORD PTR [rsi], r14
  0222c	48 83 c6 08	 add	 rsi, 8
  02230	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02237	74 10		 je	 SHORT $LN640@PyEval_Eva
  02239	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0223d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  02244	e8 00 00 00 00	 call	 prtrace
$LN640@PyEval_Eva:
  02249	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  0224e	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  02253	48 8b c6	 mov	 rax, rsi
  02256	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  0225d	48 c1 f8 03	 sar	 rax, 3
  02261	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  02264	0f 8e e7 df ff
	ff		 jle	 $LN538@PyEval_Eva
  0226a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  02271	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  02278	41 b8 7c 08 00
	00		 mov	 r8d, 2172		; 0000087cH
  0227e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2173 :             DISPATCH();

  02284	e9 c8 df ff ff	 jmp	 $LN538@PyEval_Eva
$LN272@PyEval_Eva:

; 2174 : 
; 2175 :         TARGET(LOAD_GLOBAL)
; 2176 :             w = GETITEM(names, oparg);

  02289	48 8b 4c 24 58	 mov	 rcx, QWORD PTR names$1$[rsp]
  0228e	49 63 d5	 movsxd	 rdx, r13d
  02291	e8 00 00 00 00	 call	 PyTuple_GetItem

; 2177 :             if (PyDict_CheckExact(f->f_globals)
; 2178 :                 && PyDict_CheckExact(f->f_builtins)) {

  02296	49 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [r15+136]
  0229d	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:PyDict_Type
  022a4	48 8b d8	 mov	 rbx, rax
  022a7	4c 39 69 58	 cmp	 QWORD PTR [rcx+88], r13
  022ab	74 06		 je	 SHORT $LN270@PyEval_Eva
  022ad	4c 39 69 38	 cmp	 QWORD PTR [rcx+56], r13
  022b1	75 13		 jne	 SHORT $LN271@PyEval_Eva
$LN270@PyEval_Eva:
  022b3	49 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [r15+128]
  022ba	4c 39 6a 58	 cmp	 QWORD PTR [rdx+88], r13
  022be	74 65		 je	 SHORT $LN269@PyEval_Eva
  022c0	4c 39 6a 38	 cmp	 QWORD PTR [rdx+56], r13
  022c4	74 5f		 je	 SHORT $LN269@PyEval_Eva
$LN271@PyEval_Eva:

; 2189 :             }
; 2190 :             else {
; 2191 :                 /* Slow-path if globals or builtins is not a dict */
; 2192 :                 x = PyObject_GetItem(f->f_globals, w);

  022c6	48 8b d0	 mov	 rdx, rax
  022c9	e8 00 00 00 00	 call	 PyObject_GetItem
  022ce	4c 8b f0	 mov	 r14, rax
  022d1	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2193 :                 if (x == NULL) {

  022d6	48 85 c0	 test	 rax, rax
  022d9	0f 85 87 00 00
	00		 jne	 $LN264@PyEval_Eva

; 2194 :                     x = PyObject_GetItem(f->f_builtins, w);

  022df	49 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [r15+128]
  022e6	48 8b d3	 mov	 rdx, rbx
  022e9	e8 00 00 00 00	 call	 PyObject_GetItem
  022ee	4c 8b f0	 mov	 r14, rax
  022f1	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2195 :                     if (x == NULL) {

  022f6	48 85 c0	 test	 rax, rax
  022f9	75 6b		 jne	 SHORT $LN264@PyEval_Eva

; 2196 :                         if (PyErr_ExceptionMatches(PyExc_KeyError))

  022fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_KeyError
  02302	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  02307	85 c0		 test	 eax, eax
  02309	0f 84 fb e8 ff
	ff		 je	 $LN1017@PyEval_Eva

; 2197 :                             format_exc_check_arg(
; 2198 :                                         PyExc_NameError,
; 2199 :                                         GLOBAL_NAME_ERROR_MSG, w);

  0230f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  02316	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@
  0231d	4c 8b c3	 mov	 r8, rbx
  02320	e9 e0 e8 ff ff	 jmp	 $LN1056@PyEval_Eva
$LN269@PyEval_Eva:

; 2179 :                 x = _PyDict_LoadGlobal((PyDictObject *)f->f_globals,
; 2180 :                                        (PyDictObject *)f->f_builtins,
; 2181 :                                        w);

  02325	4c 8b c0	 mov	 r8, rax
  02328	e8 00 00 00 00	 call	 _PyDict_LoadGlobal
  0232d	4c 8b f0	 mov	 r14, rax
  02330	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2182 :                 if (x == NULL) {

  02335	48 85 c0	 test	 rax, rax
  02338	75 24		 jne	 SHORT $LN268@PyEval_Eva

; 2183 :                     if (!_PyErr_OCCURRED())

  0233a	e8 00 00 00 00	 call	 PyErr_Occurred
  0233f	48 85 c0	 test	 rax, rax
  02342	0f 85 c2 e8 ff
	ff		 jne	 $LN1017@PyEval_Eva

; 2184 :                         format_exc_check_arg(PyExc_NameError,
; 2185 :                                              GLOBAL_NAME_ERROR_MSG, w);

  02348	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  0234f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@NDGHHJP@global?5name?5?8?$CF?4200s?8?5is?5not?5defi@
  02356	4c 8b c3	 mov	 r8, rbx
  02359	e9 a7 e8 ff ff	 jmp	 $LN1056@PyEval_Eva
$LN268@PyEval_Eva:

; 2186 :                     break;
; 2187 :                 }
; 2188 :                 Py_INCREF(x);

  0235e	48 8b c8	 mov	 rcx, rax
  02361	e8 00 00 00 00	 call	 _Py_IncRef
$LN264@PyEval_Eva:

; 2200 :                         break;
; 2201 :                     }
; 2202 :                 }
; 2203 :             }
; 2204 :             PUSH(x);

  02366	4c 89 36	 mov	 QWORD PTR [rsi], r14
  02369	48 83 c6 08	 add	 rsi, 8
  0236d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02374	74 10		 je	 SHORT $LN642@PyEval_Eva
  02376	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0237a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  02381	e8 00 00 00 00	 call	 prtrace
$LN642@PyEval_Eva:
  02386	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  0238b	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  02390	48 8b c6	 mov	 rax, rsi
  02393	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  0239a	48 c1 f8 03	 sar	 rax, 3
  0239e	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  023a1	0f 8e aa de ff
	ff		 jle	 $LN538@PyEval_Eva
  023a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  023ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  023b5	41 b8 9c 08 00
	00		 mov	 r8d, 2204		; 0000089cH
  023bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2205 :             DISPATCH();

  023c1	e9 8b de ff ff	 jmp	 $LN538@PyEval_Eva
$LN262@PyEval_Eva:

; 2206 : 
; 2207 :         TARGET(DELETE_FAST)
; 2208 :             x = GETLOCAL(oparg);

  023c6	49 63 d5	 movsxd	 rdx, r13d
  023c9	4d 8b b4 d7 d0
	01 00 00	 mov	 r14, QWORD PTR [r15+rdx*8+464]
  023d1	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14

; 2209 :             if (x != NULL) {

  023d6	4d 85 f6	 test	 r14, r14
  023d9	0f 84 09 e8 ff
	ff		 je	 $LN261@PyEval_Eva

; 2210 :                 SETLOCAL(oparg, NULL);

  023df	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  023e4	49 8b ce	 mov	 rcx, r14
  023e7	49 c7 84 d7 d0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR [r15+rdx*8+464], 0
  023f3	e8 00 00 00 00	 call	 _Py_DecRef

; 2211 :                 DISPATCH();

  023f8	e9 54 de ff ff	 jmp	 $LN538@PyEval_Eva
$LN253@PyEval_Eva:

; 2212 :             }
; 2213 :             format_exc_check_arg(
; 2214 :                 PyExc_UnboundLocalError,
; 2215 :                 UNBOUNDLOCAL_ERROR_MSG,
; 2216 :                 PyTuple_GetItem(co->co_varnames, oparg)
; 2217 :                 );
; 2218 :             break;
; 2219 : 
; 2220 :         TARGET(DELETE_DEREF)
; 2221 :             x = freevars[oparg];

  023fd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR freevars$1$[rsp]
  02402	49 63 c5	 movsxd	 rax, r13d
  02405	4c 8b 34 c1	 mov	 r14, QWORD PTR [rcx+rax*8]
  02409	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14

; 2222 :             if (PyCell_GET(x) != NULL) {

  0240e	49 83 7e 60 00	 cmp	 QWORD PTR [r14+96], 0
  02413	74 14		 je	 SHORT $LN252@PyEval_Eva

; 2223 :                 PyCell_Set(x, NULL);

  02415	33 d2		 xor	 edx, edx
  02417	49 8b ce	 mov	 rcx, r14
  0241a	e8 00 00 00 00	 call	 PyCell_Set

; 2224 :                 DISPATCH();

  0241f	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  02424	e9 28 de ff ff	 jmp	 $LN538@PyEval_Eva
$LN252@PyEval_Eva:

; 2225 :             }
; 2226 :             err = -1;
; 2227 :             format_exc_unbound(co, oparg);

  02429	41 8b d5	 mov	 edx, r13d
  0242c	48 8b cb	 mov	 rcx, rbx
  0242f	c7 85 98 00 00
	00 ff ff ff ff	 mov	 DWORD PTR err$1$[rbp-256], -1
  02439	e8 00 00 00 00	 call	 format_exc_unbound

; 2228 :             break;

  0243e	e9 c7 e7 ff ff	 jmp	 $LN1017@PyEval_Eva
$LN251@PyEval_Eva:

; 2229 : 
; 2230 :         TARGET(LOAD_CLOSURE)
; 2231 :             x = freevars[oparg];

  02443	48 8b 4c 24 78	 mov	 rcx, QWORD PTR freevars$1$[rsp]
  02448	49 63 c5	 movsxd	 rax, r13d
  0244b	4c 8b 34 c1	 mov	 r14, QWORD PTR [rcx+rax*8]

; 2232 :             Py_INCREF(x);

  0244f	49 8b ce	 mov	 rcx, r14
  02452	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14
  02457	e8 00 00 00 00	 call	 _Py_IncRef

; 2233 :             PUSH(x);

  0245c	4c 89 36	 mov	 QWORD PTR [rsi], r14
  0245f	48 83 c6 08	 add	 rsi, 8
  02463	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0246a	74 10		 je	 SHORT $LN644@PyEval_Eva
  0246c	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  02470	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  02477	e8 00 00 00 00	 call	 prtrace
$LN644@PyEval_Eva:
  0247c	48 8b c6	 mov	 rax, rsi
  0247f	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  02486	48 c1 f8 03	 sar	 rax, 3
  0248a	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  0248d	7e 1a		 jle	 SHORT $LN645@PyEval_Eva
  0248f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  02496	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  0249d	41 b8 b9 08 00
	00		 mov	 r8d, 2233		; 000008b9H
  024a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN645@PyEval_Eva:

; 2234 :             if (x != NULL) DISPATCH();

  024a9	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  024ae	4d 85 f6	 test	 r14, r14
  024b1	0f 85 9a dd ff
	ff		 jne	 $LN538@PyEval_Eva

; 2235 :             break;

  024b7	e9 4e e7 ff ff	 jmp	 $LN1017@PyEval_Eva
$LN249@PyEval_Eva:

; 2236 : 
; 2237 :         TARGET(LOAD_DEREF)
; 2238 :             x = freevars[oparg];

  024bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR freevars$1$[rsp]
  024c1	49 63 c5	 movsxd	 rax, r13d
  024c4	4c 8b 34 c1	 mov	 r14, QWORD PTR [rcx+rax*8]

; 2239 :             w = PyCell_Get(x);

  024c8	49 8b ce	 mov	 rcx, r14
  024cb	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14
  024d0	e8 00 00 00 00	 call	 PyCell_Get

; 2240 :             if (w != NULL) {

  024d5	48 85 c0	 test	 rax, rax
  024d8	0f 84 4b ff ff
	ff		 je	 $LN252@PyEval_Eva

; 2241 :                 PUSH(w);

  024de	48 89 06	 mov	 QWORD PTR [rsi], rax
  024e1	48 83 c6 08	 add	 rsi, 8
  024e5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  024ec	74 10		 je	 SHORT $LN646@PyEval_Eva
  024ee	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  024f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  024f9	e8 00 00 00 00	 call	 prtrace
$LN646@PyEval_Eva:
  024fe	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  02503	48 8b c6	 mov	 rax, rsi
  02506	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  0250d	48 c1 f8 03	 sar	 rax, 3
  02511	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  02514	0f 8e 37 dd ff
	ff		 jle	 $LN538@PyEval_Eva
  0251a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  02521	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  02528	41 b8 c1 08 00
	00		 mov	 r8d, 2241		; 000008c1H
  0252e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2242 :                 DISPATCH();

  02534	e9 18 dd ff ff	 jmp	 $LN538@PyEval_Eva
$LN247@PyEval_Eva:

; 2243 :             }
; 2244 :             err = -1;
; 2245 :             format_exc_unbound(co, oparg);
; 2246 :             break;
; 2247 : 
; 2248 :         TARGET(STORE_DEREF)
; 2249 :             w = POP();

  02539	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02540	74 10		 je	 SHORT $LN648@PyEval_Eva
  02542	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  02546	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0254d	e8 00 00 00 00	 call	 prtrace
$LN648@PyEval_Eva:

; 2250 :             x = freevars[oparg];

  02552	48 8b 4c 24 78	 mov	 rcx, QWORD PTR freevars$1$[rsp]
  02557	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  0255b	49 63 c5	 movsxd	 rax, r13d
  0255e	4c 8b 34 c1	 mov	 r14, QWORD PTR [rcx+rax*8]
  02562	48 83 ee 08	 sub	 rsi, 8

; 2251 :             PyCell_Set(x, w);

  02566	48 8b d3	 mov	 rdx, rbx
  02569	49 8b ce	 mov	 rcx, r14
  0256c	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14
  02571	e8 00 00 00 00	 call	 PyCell_Set

; 2530 :                 Py_DECREF(w);

  02576	48 8b cb	 mov	 rcx, rbx
  02579	e8 00 00 00 00	 call	 _Py_DecRef

; 2531 :             }
; 2532 :             else
; 2533 :                 break;
; 2534 :             DISPATCH();

  0257e	e9 c4 dc ff ff	 jmp	 $LN1065@PyEval_Eva
$LN246@PyEval_Eva:

; 2252 :             Py_DECREF(w);
; 2253 :             DISPATCH();
; 2254 : 
; 2255 :         TARGET(BUILD_TUPLE)
; 2256 :             x = PyTuple_New(oparg);

  02583	49 63 cd	 movsxd	 rcx, r13d
  02586	e8 00 00 00 00	 call	 PyTuple_New
  0258b	4c 8b f0	 mov	 r14, rax
  0258e	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2257 :             if (x != NULL) {

  02593	48 85 c0	 test	 rax, rax
  02596	0f 84 6e e6 ff
	ff		 je	 $LN1017@PyEval_Eva

; 2258 :                 for (; --oparg >= 0;) {

  0259c	41 ff cd	 dec	 r13d
  0259f	49 63 dd	 movsxd	 rbx, r13d
  025a2	78 3a		 js	 SHORT $LN947@PyEval_Eva
  025a4	48 8d 7c d8 70	 lea	 rdi, QWORD PTR [rax+rbx*8+112]
  025a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL244@PyEval_Eva:

; 2259 :                     w = POP();

  025b0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  025b7	74 10		 je	 SHORT $LN649@PyEval_Eva
  025b9	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  025bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  025c4	e8 00 00 00 00	 call	 prtrace
$LN649@PyEval_Eva:

; 2260 :                     PyTuple_SET_ITEM(x, oparg, w);

  025c9	48 8b 46 f8	 mov	 rax, QWORD PTR [rsi-8]
  025cd	48 83 ee 08	 sub	 rsi, 8
  025d1	48 83 ef 08	 sub	 rdi, 8
  025d5	48 ff cb	 dec	 rbx
  025d8	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  025dc	79 d2		 jns	 SHORT $LL244@PyEval_Eva
$LN947@PyEval_Eva:

; 2261 :                 }
; 2262 :                 PUSH(x);

  025de	4c 89 36	 mov	 QWORD PTR [rsi], r14
  025e1	48 83 c6 08	 add	 rsi, 8
  025e5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  025ec	74 10		 je	 SHORT $LN650@PyEval_Eva
  025ee	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  025f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  025f9	e8 00 00 00 00	 call	 prtrace
$LN650@PyEval_Eva:
  025fe	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  02603	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  02608	48 8b c6	 mov	 rax, rsi
  0260b	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  02612	48 c1 f8 03	 sar	 rax, 3
  02616	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  02619	0f 8e 32 dc ff
	ff		 jle	 $LN538@PyEval_Eva
  0261f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  02626	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  0262d	41 b8 d6 08 00
	00		 mov	 r8d, 2262		; 000008d6H
  02633	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2263 :                 DISPATCH();

  02639	e9 13 dc ff ff	 jmp	 $LN538@PyEval_Eva
$LN242@PyEval_Eva:

; 2264 :             }
; 2265 :             break;
; 2266 : 
; 2267 :         TARGET(BUILD_LIST)
; 2268 :             x =  PyList_New(oparg);

  0263e	49 63 cd	 movsxd	 rcx, r13d
  02641	e8 00 00 00 00	 call	 PyList_New
  02646	4c 8b f0	 mov	 r14, rax
  02649	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2269 :             if (x != NULL) {

  0264e	48 85 c0	 test	 rax, rax
  02651	0f 84 b3 e5 ff
	ff		 je	 $LN1017@PyEval_Eva

; 2270 :                 for (; --oparg >= 0;) {

  02657	41 ff cd	 dec	 r13d
  0265a	49 63 dd	 movsxd	 rbx, r13d
  0265d	78 30		 js	 SHORT $LN948@PyEval_Eva
  0265f	90		 npad	 1
$LL240@PyEval_Eva:

; 2271 :                     w = POP();

  02660	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02667	74 10		 je	 SHORT $LN652@PyEval_Eva
  02669	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0266d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  02674	e8 00 00 00 00	 call	 prtrace
$LN652@PyEval_Eva:

; 2272 :                     PyList_SET_ITEM(x, oparg, w);

  02679	49 8b 4e 70	 mov	 rcx, QWORD PTR [r14+112]
  0267d	48 8b 46 f8	 mov	 rax, QWORD PTR [rsi-8]
  02681	48 83 ee 08	 sub	 rsi, 8
  02685	48 ff cb	 dec	 rbx
  02688	48 89 44 d9 08	 mov	 QWORD PTR [rcx+rbx*8+8], rax
  0268d	79 d1		 jns	 SHORT $LL240@PyEval_Eva
$LN948@PyEval_Eva:

; 2273 :                 }
; 2274 :                 PUSH(x);

  0268f	4c 89 36	 mov	 QWORD PTR [rsi], r14
  02692	48 83 c6 08	 add	 rsi, 8
  02696	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0269d	74 10		 je	 SHORT $LN653@PyEval_Eva
  0269f	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  026a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  026aa	e8 00 00 00 00	 call	 prtrace
$LN653@PyEval_Eva:
  026af	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  026b4	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  026b9	48 8b c6	 mov	 rax, rsi
  026bc	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  026c3	48 c1 f8 03	 sar	 rax, 3
  026c7	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  026ca	0f 8e 81 db ff
	ff		 jle	 $LN538@PyEval_Eva
  026d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  026d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  026de	41 b8 e2 08 00
	00		 mov	 r8d, 2274		; 000008e2H
  026e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2275 :                 DISPATCH();

  026ea	e9 62 db ff ff	 jmp	 $LN538@PyEval_Eva
$LN238@PyEval_Eva:

; 2276 :             }
; 2277 :             break;
; 2278 : 
; 2279 :         TARGET(BUILD_SET)
; 2280 :             x = PySet_New(NULL);

  026ef	33 c9		 xor	 ecx, ecx
  026f1	e8 00 00 00 00	 call	 PySet_New
  026f6	4c 8b f0	 mov	 r14, rax
  026f9	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2281 :             if (x != NULL) {

  026fe	48 85 c0	 test	 rax, rax
  02701	0f 84 03 e5 ff
	ff		 je	 $LN1017@PyEval_Eva

; 2282 :                 for (; --oparg >= 0;) {

  02707	41 ff cd	 dec	 r13d
  0270a	78 50		 js	 SHORT $LN235@PyEval_Eva
  0270c	8b bd 98 00 00
	00		 mov	 edi, DWORD PTR err$1$[rbp-256]
$LL236@PyEval_Eva:

; 2283 :                     w = POP();

  02712	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02719	74 10		 je	 SHORT $LN655@PyEval_Eva
  0271b	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0271f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  02726	e8 00 00 00 00	 call	 prtrace
$LN655@PyEval_Eva:
  0272b	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  0272f	48 83 ee 08	 sub	 rsi, 8

; 2284 :                     if (err == 0)

  02733	85 ff		 test	 edi, edi
  02735	75 0d		 jne	 SHORT $LN234@PyEval_Eva

; 2285 :                         err = PySet_Add(x, w);

  02737	48 8b d3	 mov	 rdx, rbx
  0273a	49 8b ce	 mov	 rcx, r14
  0273d	e8 00 00 00 00	 call	 PySet_Add
  02742	8b f8		 mov	 edi, eax
$LN234@PyEval_Eva:

; 2286 :                     Py_DECREF(w);

  02744	48 8b cb	 mov	 rcx, rbx
  02747	e8 00 00 00 00	 call	 _Py_DecRef
  0274c	41 ff cd	 dec	 r13d
  0274f	79 c1		 jns	 SHORT $LL236@PyEval_Eva
  02751	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  02756	89 bd 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], edi
$LN235@PyEval_Eva:

; 2287 :                 }
; 2288 :                 if (err != 0) {

  0275c	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  02763	45 85 ed	 test	 r13d, r13d
  02766	74 0d		 je	 SHORT $LN233@PyEval_Eva

; 2289 :                     Py_DECREF(x);

  02768	49 8b ce	 mov	 rcx, r14
  0276b	e8 00 00 00 00	 call	 _Py_DecRef

; 2290 :                     break;

  02770	e9 9c e4 ff ff	 jmp	 $LN1039@PyEval_Eva
$LN233@PyEval_Eva:

; 2291 :                 }
; 2292 :                 PUSH(x);

  02775	4c 89 36	 mov	 QWORD PTR [rsi], r14
  02778	48 83 c6 08	 add	 rsi, 8
  0277c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02783	74 10		 je	 SHORT $LN656@PyEval_Eva
  02785	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  02789	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  02790	e8 00 00 00 00	 call	 prtrace
$LN656@PyEval_Eva:
  02795	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  0279a	48 8b c6	 mov	 rax, rsi
  0279d	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  027a4	48 c1 f8 03	 sar	 rax, 3
  027a8	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  027ab	0f 8e a0 da ff
	ff		 jle	 $LN538@PyEval_Eva
  027b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  027b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  027bf	41 b8 f4 08 00
	00		 mov	 r8d, 2292		; 000008f4H
  027c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2293 :                 DISPATCH();

  027cb	e9 81 da ff ff	 jmp	 $LN538@PyEval_Eva
$LN232@PyEval_Eva:

; 2294 :             }
; 2295 :             break;
; 2296 : 
; 2297 :         TARGET(BUILD_MAP)
; 2298 :             x = _PyDict_NewPresized((Py_ssize_t)oparg);

  027d0	49 63 cd	 movsxd	 rcx, r13d
  027d3	e8 00 00 00 00	 call	 _PyDict_NewPresized

; 2299 :             PUSH(x);

  027d8	48 83 c6 08	 add	 rsi, 8
  027dc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  027e3	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax
  027e7	4c 8b f0	 mov	 r14, rax
  027ea	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  027ef	74 10		 je	 SHORT $LN658@PyEval_Eva
  027f1	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  027f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  027fc	e8 00 00 00 00	 call	 prtrace
$LN658@PyEval_Eva:
  02801	48 8b c6	 mov	 rax, rsi
  02804	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  0280b	48 c1 f8 03	 sar	 rax, 3
  0280f	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  02812	7e 1a		 jle	 SHORT $LN659@PyEval_Eva
  02814	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0281b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  02822	41 b8 fb 08 00
	00		 mov	 r8d, 2299		; 000008fbH
  02828	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN659@PyEval_Eva:

; 2300 :             if (x != NULL) DISPATCH();

  0282e	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  02833	4d 85 f6	 test	 r14, r14
  02836	0f 85 15 da ff
	ff		 jne	 $LN538@PyEval_Eva

; 2301 :             break;

  0283c	e9 c9 e3 ff ff	 jmp	 $LN1017@PyEval_Eva
$LN230@PyEval_Eva:

; 2302 : 
; 2303 :         TARGET(STORE_MAP)
; 2304 :             w = TOP();     /* key */
; 2305 :             u = SECOND();  /* value */
; 2306 :             v = THIRD();   /* dict */
; 2307 :             STACKADJ(-2);

  02841	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02848	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]
  0284c	48 8b 5e e8	 mov	 rbx, QWORD PTR [rsi-24]
  02850	4c 8b 66 f0	 mov	 r12, QWORD PTR [rsi-16]
  02854	48 8d 46 f0	 lea	 rax, QWORD PTR [rsi-16]
  02858	48 8b f0	 mov	 rsi, rax
  0285b	74 10		 je	 SHORT $LN660@PyEval_Eva
  0285d	48 8b 48 f8	 mov	 rcx, QWORD PTR [rax-8]
  02861	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  02868	e8 00 00 00 00	 call	 prtrace
$LN660@PyEval_Eva:
  0286d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  02872	48 8b c6	 mov	 rax, rsi
  02875	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  0287c	48 c1 f8 03	 sar	 rax, 3
  02880	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  02883	7e 1a		 jle	 SHORT $LN661@PyEval_Eva
  02885	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0288c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  02893	41 b8 03 09 00
	00		 mov	 r8d, 2307		; 00000903H
  02899	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN661@PyEval_Eva:

; 2308 :             assert (PyDict_CheckExact(v));

  0289f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  028a6	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  028aa	74 20		 je	 SHORT $LN662@PyEval_Eva
  028ac	48 39 43 38	 cmp	 QWORD PTR [rbx+56], rax
  028b0	74 1a		 je	 SHORT $LN662@PyEval_Eva
  028b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  028b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@CFBAFFEI@?$AAP?$AAy?$AAD?$AAi?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  028c0	41 b8 04 09 00
	00		 mov	 r8d, 2308		; 00000904H
  028c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN662@PyEval_Eva:

; 2309 :             err = PyDict_SetItem(v, w, u);  /* v[w] = u */

  028cc	4d 8b c4	 mov	 r8, r12
  028cf	48 8b d7	 mov	 rdx, rdi
  028d2	48 8b cb	 mov	 rcx, rbx
  028d5	e8 00 00 00 00	 call	 PyDict_SetItem

; 2310 :             Py_DECREF(u);

  028da	49 8b cc	 mov	 rcx, r12
  028dd	44 8b e8	 mov	 r13d, eax
  028e0	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  028e6	e8 00 00 00 00	 call	 _Py_DecRef

; 2311 :             Py_DECREF(w);

  028eb	48 8b cf	 mov	 rcx, rdi

; 2312 :             if (err == 0) DISPATCH();
; 2313 :             break;

  028ee	e9 3a ee ff ff	 jmp	 $LN1059@PyEval_Eva
$LN228@PyEval_Eva:

; 2314 : 
; 2315 :         TARGET(MAP_ADD)
; 2316 :             w = TOP();     /* key */

  028f3	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 2317 :             u = SECOND();  /* value */

  028f7	4c 8b 66 f0	 mov	 r12, QWORD PTR [rsi-16]
  028fb	48 83 c6 f0	 add	 rsi, -16

; 2318 :             STACKADJ(-2);

  028ff	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02906	74 10		 je	 SHORT $LN663@PyEval_Eva
  02908	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0290c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  02913	e8 00 00 00 00	 call	 prtrace
$LN663@PyEval_Eva:
  02918	48 8b c6	 mov	 rax, rsi
  0291b	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  02922	48 c1 f8 03	 sar	 rax, 3
  02926	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  02929	7e 1a		 jle	 SHORT $LN664@PyEval_Eva
  0292b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  02932	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  02939	41 b8 0e 09 00
	00		 mov	 r8d, 2318		; 0000090eH
  0293f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN664@PyEval_Eva:

; 2319 :             v = stack_pointer[-oparg];  /* dict */

  02945	49 63 cd	 movsxd	 rcx, r13d
  02948	48 8b c6	 mov	 rax, rsi
  0294b	48 c1 e1 03	 shl	 rcx, 3
  0294f	48 2b c1	 sub	 rax, rcx
  02952	48 8b 18	 mov	 rbx, QWORD PTR [rax]

; 2320 :             assert (PyDict_CheckExact(v));

  02955	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  0295c	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  02960	74 20		 je	 SHORT $LN665@PyEval_Eva
  02962	48 39 43 38	 cmp	 QWORD PTR [rbx+56], rax
  02966	74 1a		 je	 SHORT $LN665@PyEval_Eva
  02968	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0296f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@CFBAFFEI@?$AAP?$AAy?$AAD?$AAi?$AAc?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAv?$AA?$CJ?$AA?$AA@
  02976	41 b8 10 09 00
	00		 mov	 r8d, 2320		; 00000910H
  0297c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN665@PyEval_Eva:

; 2321 :             err = PyDict_SetItem(v, w, u);  /* v[w] = u */

  02982	4d 8b c4	 mov	 r8, r12
  02985	48 8b d7	 mov	 rdx, rdi
  02988	48 8b cb	 mov	 rcx, rbx
  0298b	e8 00 00 00 00	 call	 PyDict_SetItem

; 2322 :             Py_DECREF(u);

  02990	49 8b cc	 mov	 rcx, r12
  02993	44 8b e8	 mov	 r13d, eax
  02996	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  0299c	e8 00 00 00 00	 call	 _Py_DecRef

; 2323 :             Py_DECREF(w);

  029a1	48 8b cf	 mov	 rcx, rdi
  029a4	e8 00 00 00 00	 call	 _Py_DecRef

; 2324 :             if (err == 0) {

  029a9	45 85 ed	 test	 r13d, r13d
  029ac	0f 85 5f e2 ff
	ff		 jne	 $LN1039@PyEval_Eva

; 2325 :                 PREDICT(JUMP_ABSOLUTE);

  029b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR next_instr$1$[rsp]
  029b7	80 39 71	 cmp	 BYTE PTR [rcx], 113	; 00000071H
  029ba	0f 85 82 d8 ff
	ff		 jne	 $LN1064@PyEval_Eva
$PRED_JUMP_ABSOLUTE$64733:

; 2535 : 
; 2536 :         PREDICTED_WITH_ARG(JUMP_ABSOLUTE);

  029c0	44 0f b6 69 02	 movzx	 r13d, BYTE PTR [rcx+2]
  029c5	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  029c9	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  029ce	41 c1 e5 08	 shl	 r13d, 8
  029d2	44 03 e8	 add	 r13d, eax
$LN166@PyEval_Eva:

; 2537 :         TARGET(JUMP_ABSOLUTE)
; 2538 :             JUMPTO(oparg);
; 2539 : #if FAST_LOOPS
; 2540 :             /* Enabling this path speeds-up all while and for-loops by bypassing
; 2541 :                the per-loop checks for signals.  By default, this should be turned-off
; 2542 :                because it prevents detection of a control-break in tight loops like
; 2543 :                "while 1: pass".  Compile with this option turned-on when you need
; 2544 :                the speed-up and do not need break checking inside tight loops (ones
; 2545 :                that contain only instructions ending with FAST_DISPATCH).
; 2546 :             */
; 2547 :             FAST_DISPATCH();
; 2548 : #else
; 2549 :             DISPATCH();

  029d5	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  029da	4d 63 e5	 movsxd	 r12, r13d
  029dd	4c 03 64 24 50	 add	 r12, QWORD PTR first_instr$1$[rsp]
  029e2	4c 89 64 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r12
  029e7	e9 65 d8 ff ff	 jmp	 $LN538@PyEval_Eva
$LN225@PyEval_Eva:

; 2326 :                 DISPATCH();
; 2327 :             }
; 2328 :             break;
; 2329 : 
; 2330 :         TARGET(LOAD_ATTR)
; 2331 :             w = GETITEM(names, oparg);

  029ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR names$1$[rsp]
  029f1	49 63 d5	 movsxd	 rdx, r13d
  029f4	e8 00 00 00 00	 call	 PyTuple_GetItem

; 2332 :             v = TOP();

  029f9	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]

; 2333 :             x = PyObject_GetAttr(v, w);

  029fd	48 8b cb	 mov	 rcx, rbx
  02a00	48 8b d0	 mov	 rdx, rax
  02a03	e8 00 00 00 00	 call	 PyObject_GetAttr
$skip_decref_v_3$64774:
  02a08	48 8b cb	 mov	 rcx, rbx
  02a0b	4c 8b f0	 mov	 r14, rax
  02a0e	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  02a13	e9 55 10 00 00	 jmp	 $LN1051@PyEval_Eva
$LN218@PyEval_Eva:

; 2349 :             DISPATCH();
; 2350 : 
; 2351 : #ifdef WITH_PARALLEL
; 2352 : #define PREVENT_PARALLEL_IMPORT() do {                                      \
; 2353 :     if (Py_PXCTX) {                                                         \
; 2354 :         PyErr_SetString(PyExc_ImportError,                                  \
; 2355 :                         "import not permitted within parallel context");    \
; 2356 :         break;                                                              \
; 2357 :     }                                                                       \
; 2358 : } while (0)
; 2359 : #else
; 2360 : #define PREVENT_PARALLEL_IMPORT()
; 2361 : #endif
; 2362 : 
; 2363 :         TARGET(IMPORT_NAME)
; 2364 :         {
; 2365 :             _Py_IDENTIFIER(__import__);
; 2366 :             PREVENT_PARALLEL_IMPORT();

  02a18	e8 00 00 00 00	 call	 _Py_PXCTX
  02a1d	85 c0		 test	 eax, eax
  02a1f	74 13		 je	 SHORT $LN217@PyEval_Eva
  02a21	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  02a28	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@
  02a2f	e8 00 00 00 00	 call	 PyErr_SetString
$LN217@PyEval_Eva:

; 2367 :             w = GETITEM(names, oparg);

  02a34	48 8b 4c 24 58	 mov	 rcx, QWORD PTR names$1$[rsp]
  02a39	49 63 d5	 movsxd	 rdx, r13d
  02a3c	e8 00 00 00 00	 call	 PyTuple_GetItem

; 2368 :             x = _PyDict_GetItemId(f->f_builtins, &PyId___import__);

  02a41	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  02a48	65 48 8b 0c 25
	58 00 00 00	 mov	 rcx, QWORD PTR gs:88
  02a51	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___import__@?IL@??PyEval_EvalFrameEx@@9@9
  02a56	48 8b f8	 mov	 rdi, rax
  02a59	4a 03 14 c1	 add	 rdx, QWORD PTR [rcx+r8*8]
  02a5d	49 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [r15+128]
  02a64	e8 00 00 00 00	 call	 _PyDict_GetItemId
  02a69	4c 8b f0	 mov	 r14, rax
  02a6c	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2369 :             if (x == NULL) {

  02a71	48 85 c0	 test	 rax, rax
  02a74	75 18		 jne	 SHORT $LN214@PyEval_Eva

; 2370 :                 PyErr_SetString(PyExc_ImportError,
; 2371 :                                 "__import__ not found");

  02a76	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  02a7d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@FMMPICPA@__import__?5not?5found?$AA@
  02a84	e8 00 00 00 00	 call	 PyErr_SetString
  02a89	e9 7c e1 ff ff	 jmp	 $LN1017@PyEval_Eva
$LN214@PyEval_Eva:

; 2372 :                 break;
; 2373 :             }
; 2374 :             Py_INCREF(x);

  02a8e	48 8b c8	 mov	 rcx, rax
  02a91	e8 00 00 00 00	 call	 _Py_IncRef

; 2375 :             v = POP();

  02a96	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02a9d	74 10		 je	 SHORT $LN667@PyEval_Eva
  02a9f	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  02aa3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  02aaa	e8 00 00 00 00	 call	 prtrace
$LN667@PyEval_Eva:

; 2376 :             u = TOP();

  02aaf	4c 8b 66 f0	 mov	 r12, QWORD PTR [rsi-16]
  02ab3	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  02ab7	48 83 ee 08	 sub	 rsi, 8

; 2377 :             if (PyLong_AsLong(u) != -1 || PyErr_Occurred())

  02abb	49 8b cc	 mov	 rcx, r12
  02abe	e8 00 00 00 00	 call	 PyLong_AsLong
  02ac3	83 f8 ff	 cmp	 eax, -1
  02ac6	75 3a		 jne	 SHORT $LN212@PyEval_Eva
  02ac8	e8 00 00 00 00	 call	 PyErr_Occurred
  02acd	48 85 c0	 test	 rax, rax
  02ad0	75 30		 jne	 SHORT $LN212@PyEval_Eva

; 2385 :             else
; 2386 :                 w = PyTuple_Pack(4,
; 2387 :                             w,
; 2388 :                             f->f_globals,
; 2389 :                             f->f_locals == NULL ?
; 2390 :                                   Py_None : f->f_locals,
; 2391 :                             v);

  02ad2	49 8b 87 90 00
	00 00		 mov	 rax, QWORD PTR [r15+144]
  02ad9	4d 8b 87 88 00
	00 00		 mov	 r8, QWORD PTR [r15+136]
  02ae0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  02ae7	48 85 c0	 test	 rax, rax
  02aea	48 8b d7	 mov	 rdx, rdi
  02aed	b9 04 00 00 00	 mov	 ecx, 4
  02af2	4c 0f 45 c8	 cmovne	 r9, rax
  02af6	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  02afb	e8 00 00 00 00	 call	 PyTuple_Pack
  02b00	eb 33		 jmp	 SHORT $LN1047@PyEval_Eva
$LN212@PyEval_Eva:

; 2378 :                 w = PyTuple_Pack(5,
; 2379 :                             w,
; 2380 :                             f->f_globals,
; 2381 :                             f->f_locals == NULL ?
; 2382 :                                   Py_None : f->f_locals,
; 2383 :                             v,
; 2384 :                             u);

  02b02	49 8b 87 90 00
	00 00		 mov	 rax, QWORD PTR [r15+144]
  02b09	4d 8b 87 88 00
	00 00		 mov	 r8, QWORD PTR [r15+136]
  02b10	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:_Py_NoneStruct
  02b17	48 85 c0	 test	 rax, rax
  02b1a	48 8b d7	 mov	 rdx, rdi
  02b1d	b9 05 00 00 00	 mov	 ecx, 5
  02b22	4c 0f 45 c8	 cmovne	 r9, rax
  02b26	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  02b2b	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  02b30	e8 00 00 00 00	 call	 PyTuple_Pack
$LN1047@PyEval_Eva:

; 2392 :             Py_DECREF(v);

  02b35	48 8b cb	 mov	 rcx, rbx
  02b38	48 8b f8	 mov	 rdi, rax
  02b3b	e8 00 00 00 00	 call	 _Py_DecRef

; 2393 :             Py_DECREF(u);

  02b40	49 8b cc	 mov	 rcx, r12
  02b43	e8 00 00 00 00	 call	 _Py_DecRef

; 2394 :             if (w == NULL) {

  02b48	48 85 ff	 test	 rdi, rdi
  02b4b	75 46		 jne	 SHORT $LN210@PyEval_Eva

; 2395 :                 u = POP();

  02b4d	39 3d 00 00 00
	00		 cmp	 DWORD PTR lltrace, edi
  02b53	74 10		 je	 SHORT $LN672@PyEval_Eva
  02b55	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  02b59	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  02b60	e8 00 00 00 00	 call	 prtrace
$LN672@PyEval_Eva:

; 2396 :                 Py_DECREF(x);

  02b65	49 8b ce	 mov	 rcx, r14
  02b68	48 83 c6 f8	 add	 rsi, -8
  02b6c	e8 00 00 00 00	 call	 _Py_DecRef
$LN1060@PyEval_Eva:

; 2397 :                 x = NULL;
; 2398 :                 break;

  02b71	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR why$1$[rbp-256]
  02b77	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  02b7e	45 33 e4	 xor	 r12d, r12d
  02b81	41 8d 5c 24 02	 lea	 ebx, QWORD PTR [r12+2]
  02b86	4c 89 64 24 30	 mov	 QWORD PTR tmp$1$[rsp], r12
  02b8b	45 8b f4	 mov	 r14d, r12d
  02b8e	e9 8c e0 ff ff	 jmp	 $LN1042@PyEval_Eva
$LN210@PyEval_Eva:

; 2399 :             }
; 2400 :             READ_TIMESTAMP(intr0);
; 2401 :             v = x;
; 2402 :             x = PyEval_CallObject(v, w);

  02b93	45 33 c0	 xor	 r8d, r8d
  02b96	48 8b d7	 mov	 rdx, rdi
  02b99	49 8b ce	 mov	 rcx, r14
  02b9c	49 8b de	 mov	 rbx, r14
  02b9f	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords

; 2403 :             Py_DECREF(v);
; 2404 :             READ_TIMESTAMP(intr1);
; 2405 :             Py_DECREF(w);
; 2406 :             SET_TOP(x);
; 2407 :             if (x != NULL) DISPATCH();
; 2408 :             break;

  02ba4	e9 95 e4 ff ff	 jmp	 $LN1069@PyEval_Eva
$LN207@PyEval_Eva:

; 2409 :         }
; 2410 : 
; 2411 :         TARGET(IMPORT_STAR)
; 2412 :             PREVENT_PARALLEL_IMPORT();

  02ba9	e8 00 00 00 00	 call	 _Py_PXCTX
  02bae	85 c0		 test	 eax, eax
  02bb0	74 13		 je	 SHORT $LN206@PyEval_Eva
  02bb2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  02bb9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@
  02bc0	e8 00 00 00 00	 call	 PyErr_SetString
$LN206@PyEval_Eva:

; 2413 :             v = POP();

  02bc5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02bcc	74 10		 je	 SHORT $LN673@PyEval_Eva
  02bce	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  02bd2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  02bd9	e8 00 00 00 00	 call	 prtrace
$LN673@PyEval_Eva:
  02bde	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  02be2	48 83 ee 08	 sub	 rsi, 8

; 2414 :             PyFrame_FastToLocals(f);

  02be6	49 8b cf	 mov	 rcx, r15
  02be9	e8 00 00 00 00	 call	 PyFrame_FastToLocals

; 2415 :             if ((x = f->f_locals) == NULL) {

  02bee	4d 8b b7 90 00
	00 00		 mov	 r14, QWORD PTR [r15+144]
  02bf5	4c 89 74 24 30	 mov	 QWORD PTR tmp$1$[rsp], r14
  02bfa	4d 85 f6	 test	 r14, r14
  02bfd	75 18		 jne	 SHORT $LN203@PyEval_Eva

; 2416 :                 PyErr_SetString(PyExc_SystemError,
; 2417 :                     "no locals found during 'import *'");

  02bff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  02c06	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@NAHFDGJN@no?5locals?5found?5during?5?8import?5?$CK@
  02c0d	e8 00 00 00 00	 call	 PyErr_SetString
  02c12	e9 f3 df ff ff	 jmp	 $LN1017@PyEval_Eva
$LN203@PyEval_Eva:

; 2418 :                 break;
; 2419 :             }
; 2420 :             READ_TIMESTAMP(intr0);
; 2421 :             err = import_all_from(x, v);

  02c17	48 8b d3	 mov	 rdx, rbx
  02c1a	49 8b ce	 mov	 rcx, r14
  02c1d	e8 00 00 00 00	 call	 import_all_from

; 2422 :             READ_TIMESTAMP(intr1);
; 2423 :             PyFrame_LocalsToFast(f, 0);

  02c22	33 d2		 xor	 edx, edx
  02c24	49 8b cf	 mov	 rcx, r15
  02c27	44 8b e8	 mov	 r13d, eax
  02c2a	89 85 98 00 00
	00		 mov	 DWORD PTR err$1$[rbp-256], eax
  02c30	e8 00 00 00 00	 call	 PyFrame_LocalsToFast

; 2424 :             Py_DECREF(v);
; 2425 :             if (err == 0) DISPATCH();
; 2426 :             break;

  02c35	e9 f0 ea ff ff	 jmp	 $LN1058@PyEval_Eva
$LN200@PyEval_Eva:

; 2427 : 
; 2428 :         TARGET(IMPORT_FROM)
; 2429 :             PREVENT_PARALLEL_IMPORT();

  02c3a	e8 00 00 00 00	 call	 _Py_PXCTX
  02c3f	85 c0		 test	 eax, eax
  02c41	74 13		 je	 SHORT $LN199@PyEval_Eva
  02c43	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  02c4a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@GGOGIMDP@import?5not?5permitted?5within?5para@
  02c51	e8 00 00 00 00	 call	 PyErr_SetString
$LN199@PyEval_Eva:

; 2430 :             w = GETITEM(names, oparg);

  02c56	48 8b 4c 24 58	 mov	 rcx, QWORD PTR names$1$[rsp]
  02c5b	49 63 d5	 movsxd	 rdx, r13d
  02c5e	e8 00 00 00 00	 call	 PyTuple_GetItem

; 2431 :             v = TOP();
; 2432 :             READ_TIMESTAMP(intr0);
; 2433 :             x = import_from(v, w);

  02c63	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  02c67	48 8b d0	 mov	 rdx, rax
  02c6a	e8 00 00 00 00	 call	 import_from

; 2434 :             READ_TIMESTAMP(intr1);
; 2435 :             PUSH(x);

  02c6f	48 83 c6 08	 add	 rsi, 8
  02c73	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02c7a	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax
  02c7e	4c 8b f0	 mov	 r14, rax
  02c81	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  02c86	74 10		 je	 SHORT $LN674@PyEval_Eva
  02c88	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  02c8c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  02c93	e8 00 00 00 00	 call	 prtrace
$LN674@PyEval_Eva:
  02c98	48 8b c6	 mov	 rax, rsi
  02c9b	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  02ca2	48 c1 f8 03	 sar	 rax, 3
  02ca6	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  02ca9	7e 1a		 jle	 SHORT $LN675@PyEval_Eva
  02cab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  02cb2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  02cb9	41 b8 83 09 00
	00		 mov	 r8d, 2435		; 00000983H
  02cbf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN675@PyEval_Eva:

; 2436 :             if (x != NULL) DISPATCH();

  02cc5	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  02cca	4d 85 f6	 test	 r14, r14
  02ccd	0f 85 7e d5 ff
	ff		 jne	 $LN538@PyEval_Eva

; 2437 :             break;

  02cd3	e9 32 df ff ff	 jmp	 $LN1017@PyEval_Eva
$LN315@PyEval_Eva:

; 2057 :             } else if (PyList_CheckExact(v) &&
; 2058 :                        PyList_GET_SIZE(v) == oparg) {

  02cd8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyList_Type
  02cdf	48 3b c1	 cmp	 rax, rcx
  02ce2	0f 85 9d 00 00
	00		 jne	 $LN311@PyEval_Eva
  02ce8	49 39 7e 60	 cmp	 QWORD PTR [r14+96], rdi
  02cec	0f 85 93 00 00
	00		 jne	 $LN311@PyEval_Eva

; 2059 :                 PyObject **items = \
; 2060 :                     ((PyListObject *)v)->ob_item;

  02cf2	4d 8b 66 70	 mov	 r12, QWORD PTR [r14+112]

; 2061 :                 while (oparg--) {

  02cf6	45 85 ed	 test	 r13d, r13d
  02cf9	74 6c		 je	 SHORT $LN1026@PyEval_Eva
  02cfb	4c 8b 74 24 48	 mov	 r14, QWORD PTR co$1$[rsp]
$LL310@PyEval_Eva:

; 2062 :                     w = items[oparg];

  02d00	49 8b 5c fc f8	 mov	 rbx, QWORD PTR [r12+rdi*8-8]
  02d05	48 ff cf	 dec	 rdi

; 2063 :                     Py_INCREF(w);

  02d08	48 8b cb	 mov	 rcx, rbx
  02d0b	e8 00 00 00 00	 call	 _Py_IncRef

; 2064 :                     PUSH(w);

  02d10	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  02d13	48 83 c6 08	 add	 rsi, 8
  02d17	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02d1e	74 10		 je	 SHORT $LN631@PyEval_Eva
  02d20	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  02d24	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  02d2b	e8 00 00 00 00	 call	 prtrace
$LN631@PyEval_Eva:
  02d30	48 8b c6	 mov	 rax, rsi
  02d33	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  02d3a	48 c1 f8 03	 sar	 rax, 3
  02d3e	41 3b 46 6c	 cmp	 eax, DWORD PTR [r14+108]
  02d42	7e 1a		 jle	 SHORT $LN632@PyEval_Eva
  02d44	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  02d4b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  02d52	41 b8 10 08 00
	00		 mov	 r8d, 2064		; 00000810H
  02d58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN632@PyEval_Eva:

; 2061 :                 while (oparg--) {

  02d5e	48 85 ff	 test	 rdi, rdi
  02d61	75 9d		 jne	 SHORT $LL310@PyEval_Eva
  02d63	4c 8b 75 90	 mov	 r14, QWORD PTR v$56$[rbp-256]
$LN1026@PyEval_Eva:

; 2070 :                 /* unpack_iterable() raised an exception */
; 2071 :                 why = WHY_EXCEPTION;

  02d67	bb 02 00 00 00	 mov	 ebx, 2
$LN306@PyEval_Eva:

; 2072 :             }
; 2073 :             Py_DECREF(v);

  02d6c	49 8b ce	 mov	 rcx, r14
  02d6f	e8 00 00 00 00	 call	 _Py_DecRef

; 2074 :             break;

  02d74	4c 8b 74 24 30	 mov	 r14, QWORD PTR tmp$1$[rsp]
  02d79	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  02d80	e9 91 de ff ff	 jmp	 $LN1046@PyEval_Eva
$LN311@PyEval_Eva:

; 2065 :                 }
; 2066 :             } else if (unpack_iterable(v, oparg, -1,
; 2067 :                                        stack_pointer + oparg)) {

  02d85	48 8d 1c fe	 lea	 rbx, QWORD PTR [rsi+rdi*8]
  02d89	41 83 c8 ff	 or	 r8d, -1
  02d8d	41 8b d5	 mov	 edx, r13d
  02d90	4c 8b cb	 mov	 r9, rbx
  02d93	49 8b ce	 mov	 rcx, r14
  02d96	e8 00 00 00 00	 call	 unpack_iterable
  02d9b	85 c0		 test	 eax, eax
  02d9d	74 53		 je	 SHORT $LN307@PyEval_Eva

; 2068 :                 STACKADJ(oparg);

  02d9f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02da6	48 8b f3	 mov	 rsi, rbx
  02da9	74 10		 je	 SHORT $LN633@PyEval_Eva
  02dab	48 8b 4b f8	 mov	 rcx, QWORD PTR [rbx-8]
  02daf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08OGNHIHGF@stackadj?$AA@
  02db6	e8 00 00 00 00	 call	 prtrace
$LN633@PyEval_Eva:
  02dbb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  02dc0	48 8b c3	 mov	 rax, rbx
  02dc3	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  02dca	48 c1 f8 03	 sar	 rax, 3
  02dce	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  02dd1	7e 94		 jle	 SHORT $LN1026@PyEval_Eva
  02dd3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  02dda	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  02de1	41 b8 14 08 00
	00		 mov	 r8d, 2068		; 00000814H
  02de7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2069 :             } else {

  02ded	e9 75 ff ff ff	 jmp	 $LN1026@PyEval_Eva
$LN307@PyEval_Eva:

; 2070 :                 /* unpack_iterable() raised an exception */
; 2071 :                 why = WHY_EXCEPTION;

  02df2	bb 02 00 00 00	 mov	 ebx, 2
  02df7	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx
  02dfd	e9 6a ff ff ff	 jmp	 $LN306@PyEval_Eva
$LN156@PyEval_Eva:

; 2587 : 
; 2588 :         TARGET(BREAK_LOOP)
; 2589 :             why = WHY_BREAK;

  02e02	b9 10 00 00 00	 mov	 ecx, 16

; 2590 :             goto fast_block_end;

  02e07	e9 7f 0d 00 00	 jmp	 $LN1043@PyEval_Eva
$LN155@PyEval_Eva:

; 2591 : 
; 2592 :         TARGET(CONTINUE_LOOP)
; 2593 :             retval = PyLong_FromLong(oparg);

  02e0c	41 8b cd	 mov	 ecx, r13d
  02e0f	e8 00 00 00 00	 call	 PyLong_FromLong
  02e14	48 89 44 24 60	 mov	 QWORD PTR retval$1$[rsp], rax

; 2594 :             if (!retval) {

  02e19	48 85 c0	 test	 rax, rax

; 2595 :                 x = NULL;
; 2596 :                 break;

  02e1c	0f 84 4f fd ff
	ff		 je	 $LN1060@PyEval_Eva

; 2597 :             }
; 2598 :             why = WHY_CONTINUE;

  02e22	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H

; 2599 :             goto fast_block_end;

  02e27	e9 5f 0d 00 00	 jmp	 $LN1043@PyEval_Eva
$_setup_finally$65435:

; 2600 : 
; 2601 :         TARGET_WITH_IMPL(SETUP_LOOP, _setup_finally)
; 2602 :         TARGET_WITH_IMPL(SETUP_EXCEPT, _setup_finally)
; 2603 :         TARGET(SETUP_FINALLY)
; 2604 :         _setup_finally:
; 2605 :             /* NOTE: If you add any new block-setup opcodes that
; 2606 :                are not try/except/finally handlers, you may need
; 2607 :                to update the PyGen_NeedsFinalizing() function.
; 2608 :                */
; 2609 : 
; 2610 :             PyFrame_BlockSetup(f, opcode, INSTR_OFFSET() + oparg,
; 2611 :                                STACK_LEVEL());

  02e2c	45 8b c4	 mov	 r8d, r12d
  02e2f	4c 8b ce	 mov	 r9, rsi
  02e32	8b d7		 mov	 edx, edi
  02e34	4d 2b 8f 98 00
	00 00		 sub	 r9, QWORD PTR [r15+152]
  02e3b	44 2b 44 24 50	 sub	 r8d, DWORD PTR first_instr$1$[rsp]
  02e40	49 8b cf	 mov	 rcx, r15
  02e43	49 c1 f9 03	 sar	 r9, 3
  02e47	45 03 c5	 add	 r8d, r13d
  02e4a	e8 00 00 00 00	 call	 PyFrame_BlockSetup

; 2612 :             DISPATCH();

  02e4f	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  02e54	e9 f8 d3 ff ff	 jmp	 $LN538@PyEval_Eva
$LN149@PyEval_Eva:

; 2613 : 
; 2614 :         TARGET(SETUP_WITH)
; 2615 :         {
; 2616 :             _Py_IDENTIFIER(__exit__);
; 2617 :             _Py_IDENTIFIER(__enter__);
; 2618 :             w = TOP();
; 2619 :             x = special_lookup(w, &PyId___exit__);

  02e59	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  02e5f	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  02e68	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]
  02e6c	48 8b 1c c8	 mov	 rbx, QWORD PTR [rax+rcx*8]
  02e70	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___exit__@?KM@??PyEval_EvalFrameEx@@9@9
  02e75	48 8b cf	 mov	 rcx, rdi
  02e78	48 03 d3	 add	 rdx, rbx
  02e7b	e8 00 00 00 00	 call	 special_lookup
  02e80	4c 8b f0	 mov	 r14, rax
  02e83	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax

; 2620 :             if (!x)

  02e88	48 85 c0	 test	 rax, rax
  02e8b	0f 84 79 dd ff
	ff		 je	 $LN1017@PyEval_Eva

; 2621 :                 break;
; 2622 :             SET_TOP(x);
; 2623 :             u = special_lookup(w, &PyId___enter__);

  02e91	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___enter__@?KM@??PyEval_EvalFrameEx@@9@9
  02e96	48 8b cf	 mov	 rcx, rdi
  02e99	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax
  02e9d	48 03 d3	 add	 rdx, rbx
  02ea0	e8 00 00 00 00	 call	 special_lookup

; 2624 :             Py_DECREF(w);

  02ea5	48 8b cf	 mov	 rcx, rdi
  02ea8	48 8b d8	 mov	 rbx, rax
  02eab	e8 00 00 00 00	 call	 _Py_DecRef

; 2625 :             if (!u) {

  02eb0	48 85 db	 test	 rbx, rbx

; 2626 :                 x = NULL;
; 2627 :                 break;

  02eb3	0f 84 b8 fc ff
	ff		 je	 $LN1060@PyEval_Eva

; 2628 :             }
; 2629 :             x = PyObject_CallFunctionObjArgs(u, NULL);

  02eb9	33 d2		 xor	 edx, edx
  02ebb	48 8b cb	 mov	 rcx, rbx
  02ebe	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 2630 :             Py_DECREF(u);

  02ec3	48 8b cb	 mov	 rcx, rbx
  02ec6	4c 8b f0	 mov	 r14, rax
  02ec9	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  02ece	e8 00 00 00 00	 call	 _Py_DecRef

; 2631 :             if (!x)

  02ed3	4d 85 f6	 test	 r14, r14
  02ed6	0f 84 2e dd ff
	ff		 je	 $LN1017@PyEval_Eva

; 2632 :                 break;
; 2633 :             /* Setup the finally block before pushing the result
; 2634 :                of __enter__ on the stack. */
; 2635 :             PyFrame_BlockSetup(f, SETUP_FINALLY, INSTR_OFFSET() + oparg,
; 2636 :                                STACK_LEVEL());

  02edc	45 8b c4	 mov	 r8d, r12d
  02edf	4c 8b ce	 mov	 r9, rsi
  02ee2	ba 7a 00 00 00	 mov	 edx, 122		; 0000007aH
  02ee7	4d 2b 8f 98 00
	00 00		 sub	 r9, QWORD PTR [r15+152]
  02eee	44 2b 44 24 50	 sub	 r8d, DWORD PTR first_instr$1$[rsp]
  02ef3	49 8b cf	 mov	 rcx, r15
  02ef6	49 c1 f9 03	 sar	 r9, 3
  02efa	45 03 c5	 add	 r8d, r13d
  02efd	e8 00 00 00 00	 call	 PyFrame_BlockSetup

; 2637 : 
; 2638 :             PUSH(x);

  02f02	4c 89 36	 mov	 QWORD PTR [rsi], r14
  02f05	48 83 c6 08	 add	 rsi, 8
  02f09	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02f10	74 10		 je	 SHORT $LN691@PyEval_Eva
  02f12	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  02f16	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  02f1d	e8 00 00 00 00	 call	 prtrace
$LN691@PyEval_Eva:
  02f22	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  02f27	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  02f2c	48 8b c6	 mov	 rax, rsi
  02f2f	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  02f36	48 c1 f8 03	 sar	 rax, 3
  02f3a	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  02f3d	0f 8e 0e d3 ff
	ff		 jle	 $LN538@PyEval_Eva
  02f43	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  02f4a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  02f51	41 b8 4e 0a 00
	00		 mov	 r8d, 2638		; 00000a4eH
  02f57	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2639 :             DISPATCH();

  02f5d	e9 ef d2 ff ff	 jmp	 $LN538@PyEval_Eva
$LN145@PyEval_Eva:

; 2640 :         }
; 2641 : 
; 2642 :         TARGET(WITH_CLEANUP)
; 2643 :         {
; 2644 :             /* At the top of the stack are 1-6 values indicating
; 2645 :                how/why we entered the finally clause:
; 2646 :                - TOP = None
; 2647 :                - (TOP, SECOND) = (WHY_{RETURN,CONTINUE}), retval
; 2648 :                - TOP = WHY_*; no retval below it
; 2649 :                - (TOP, SECOND, THIRD) = exc_info()
; 2650 :                  (FOURTH, FITH, SIXTH) = previous exception for EXCEPT_HANDLER
; 2651 :                Below them is EXIT, the context.__exit__ bound method.
; 2652 :                In the last case, we must call
; 2653 :                  EXIT(TOP, SECOND, THIRD)
; 2654 :                otherwise we must call
; 2655 :                  EXIT(None, None, None)
; 2656 : 
; 2657 :                In the first three cases, we remove EXIT from the
; 2658 :                stack, leaving the rest in the same order.  In the
; 2659 :                fourth case, we shift the bottom 3 values of the
; 2660 :                stack down, and replace the empty spot with NULL.
; 2661 : 
; 2662 :                In addition, if the stack represents an exception,
; 2663 :                *and* the function call returns a 'true' value, we
; 2664 :                push WHY_SILENCED onto the stack.  END_FINALLY will
; 2665 :                then not re-raise the exception.  (But non-local
; 2666 :                gotos should still be resumed.)
; 2667 :             */
; 2668 : 
; 2669 :             PyObject *exit_func;
; 2670 :             u = TOP();

  02f62	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  02f66	48 8d 7e f8	 lea	 rdi, QWORD PTR [rsi-8]

; 2671 :             if (u == Py_None) {

  02f6a	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:_Py_NoneStruct
  02f71	49 3b dc	 cmp	 rbx, r12
  02f74	75 2e		 jne	 SHORT $LN144@PyEval_Eva

; 2672 :                 (void)POP();

  02f76	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02f7d	74 0f		 je	 SHORT $LN693@PyEval_Eva
  02f7f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  02f86	48 8b cb	 mov	 rcx, rbx
  02f89	e8 00 00 00 00	 call	 prtrace
$LN693@PyEval_Eva:
  02f8e	48 8b f7	 mov	 rsi, rdi

; 2673 :                 exit_func = TOP();

  02f91	48 8b 7f f8	 mov	 rdi, QWORD PTR [rdi-8]

; 2674 :                 SET_TOP(u);
; 2675 :                 v = w = Py_None;

  02f95	4d 8b ec	 mov	 r13, r12
  02f98	48 89 5e f8	 mov	 QWORD PTR [rsi-8], rbx
  02f9c	4d 8b f4	 mov	 r14, r12
  02f9f	e9 d9 00 00 00	 jmp	 $LN137@PyEval_Eva
$LN144@PyEval_Eva:

; 2676 :             }
; 2677 :             else if (PyLong_Check(u)) {

  02fa4	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  02fa8	f7 80 00 01 00
	00 00 00 00 01	 test	 DWORD PTR [rax+256], 16777216 ; 01000000H
  02fb2	74 5e		 je	 SHORT $LN142@PyEval_Eva

; 2678 :                 (void)POP();

  02fb4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  02fbb	74 0f		 je	 SHORT $LN694@PyEval_Eva
  02fbd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  02fc4	48 8b cb	 mov	 rcx, rbx
  02fc7	e8 00 00 00 00	 call	 prtrace
$LN694@PyEval_Eva:

; 2679 :                 switch(PyLong_AsLong(u)) {

  02fcc	48 8b cb	 mov	 rcx, rbx
  02fcf	48 8b f7	 mov	 rsi, rdi
  02fd2	e8 00 00 00 00	 call	 PyLong_AsLong
  02fd7	83 f8 08	 cmp	 eax, 8
  02fda	74 1b		 je	 SHORT $LN139@PyEval_Eva
  02fdc	83 f8 20	 cmp	 eax, 32			; 00000020H
  02fdf	74 16		 je	 SHORT $LN139@PyEval_Eva

; 2686 :                     break;
; 2687 :                 default:
; 2688 :                     exit_func = TOP();

  02fe1	48 8b 7f f8	 mov	 rdi, QWORD PTR [rdi-8]
  02fe5	48 89 5e f8	 mov	 QWORD PTR [rsi-8], rbx

; 2689 :                     SET_TOP(u);
; 2690 :                     break;
; 2691 :                 }
; 2692 :                 u = v = w = Py_None;

  02fe9	4d 8b ec	 mov	 r13, r12
  02fec	49 8b dc	 mov	 rbx, r12
  02fef	4d 8b f4	 mov	 r14, r12

; 2693 :             }
; 2694 :             else {

  02ff2	e9 86 00 00 00	 jmp	 $LN137@PyEval_Eva
$LN139@PyEval_Eva:

; 2680 :                 case WHY_RETURN:
; 2681 :                 case WHY_CONTINUE:
; 2682 :                     /* Retval in TOP. */
; 2683 :                     exit_func = SECOND();
; 2684 :                     SET_SECOND(TOP());

  02ff7	48 8b 46 f8	 mov	 rax, QWORD PTR [rsi-8]
  02ffb	48 8b 7f f0	 mov	 rdi, QWORD PTR [rdi-16]

; 2685 :                     SET_TOP(u);

  02fff	48 89 5e f8	 mov	 QWORD PTR [rsi-8], rbx
  03003	48 89 46 f0	 mov	 QWORD PTR [rsi-16], rax

; 2689 :                     SET_TOP(u);
; 2690 :                     break;
; 2691 :                 }
; 2692 :                 u = v = w = Py_None;

  03007	4d 8b ec	 mov	 r13, r12
  0300a	4d 8b f4	 mov	 r14, r12
  0300d	49 8b dc	 mov	 rbx, r12

; 2693 :             }
; 2694 :             else {

  03010	eb 6b		 jmp	 SHORT $LN137@PyEval_Eva
$LN142@PyEval_Eva:

; 2695 :                 PyObject *tp, *exc, *tb;
; 2696 :                 PyTryBlock *block;
; 2697 :                 v = SECOND();
; 2698 :                 w = THIRD();
; 2699 :                 tp = FOURTH();
; 2700 :                 exc = PEEK(5);
; 2701 :                 tb = PEEK(6);
; 2702 :                 exit_func = PEEK(7);
; 2703 :                 SET_VALUE(7, tb);

  03012	48 8b 46 d0	 mov	 rax, QWORD PTR [rsi-48]
  03016	48 8b 7e c8	 mov	 rdi, QWORD PTR [rsi-56]
  0301a	4c 8b 76 f0	 mov	 r14, QWORD PTR [rsi-16]
  0301e	4c 8b 6e e8	 mov	 r13, QWORD PTR [rsi-24]
  03022	48 89 46 c8	 mov	 QWORD PTR [rsi-56], rax

; 2704 :                 SET_VALUE(6, exc);

  03026	48 8b 46 d8	 mov	 rax, QWORD PTR [rsi-40]
  0302a	48 89 46 d0	 mov	 QWORD PTR [rsi-48], rax

; 2705 :                 SET_VALUE(5, tp);

  0302e	48 8b 46 e0	 mov	 rax, QWORD PTR [rsi-32]

; 2706 :                 /* UNWIND_EXCEPT_HANDLER will pop this off. */
; 2707 :                 SET_FOURTH(NULL);

  03032	48 c7 46 e0 00
	00 00 00	 mov	 QWORD PTR [rsi-32], 0
  0303a	48 89 46 d8	 mov	 QWORD PTR [rsi-40], rax

; 2708 :                 /* We just shifted the stack down, so we have
; 2709 :                    to tell the except handler block that the
; 2710 :                    values are lower than it expects. */
; 2711 :                 block = &f->f_blockstack[f->f_iblock - 1];

  0303e	41 8b 87 d8 00
	00 00		 mov	 eax, DWORD PTR [r15+216]
  03045	ff c8		 dec	 eax
  03047	48 98		 cdqe
  03049	4c 8d 24 40	 lea	 r12, QWORD PTR [rax+rax*2]

; 2712 :                 assert(block->b_type == EXCEPT_HANDLER);

  0304d	43 81 bc a7 dc
	00 00 00 01 01
	00 00		 cmp	 DWORD PTR [r15+r12*4+220], 257 ; 00000101H
  03059	74 1a		 je	 SHORT $LN695@PyEval_Eva
  0305b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  03062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EA@DJBOEJIH@?$AAb?$AAl?$AAo?$AAc?$AAk?$AA?9?$AA?$DO?$AAb?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAE?$AAX?$AAC?$AAE?$AAP?$AAT?$AA_?$AAH?$AAA?$AAN?$AAD?$AAL?$AAE?$AAR?$AA?$AA@
  03069	41 b8 98 0a 00
	00		 mov	 r8d, 2712		; 00000a98H
  0306f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN695@PyEval_Eva:

; 2713 :                 block->b_level--;

  03075	43 ff 8c a7 e4
	00 00 00	 dec	 DWORD PTR [r15+r12*4+228]
$LN137@PyEval_Eva:

; 2714 :             }
; 2715 :             /* XXX Not the fastest way to call it... */
; 2716 :             x = PyObject_CallFunctionObjArgs(exit_func, u, v, w,
; 2717 :                                              NULL);

  0307d	45 33 e4	 xor	 r12d, r12d
  03080	4d 8b cd	 mov	 r9, r13
  03083	4d 8b c6	 mov	 r8, r14
  03086	48 8b d3	 mov	 rdx, rbx
  03089	48 8b cf	 mov	 rcx, rdi
  0308c	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  03091	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs

; 2718 :             Py_DECREF(exit_func);

  03096	48 8b cf	 mov	 rcx, rdi
  03099	4c 8b f0	 mov	 r14, rax
  0309c	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  030a1	e8 00 00 00 00	 call	 _Py_DecRef

; 2719 :             if (x == NULL)
; 2720 :                 break; /* Go to error exit */
; 2721 : 
; 2722 :             if (u != Py_None)

  030a6	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
  030ad	4d 85 f6	 test	 r14, r14
  030b0	0f 84 d6 09 00
	00		 je	 $LN1011@PyEval_Eva
  030b6	48 3b df	 cmp	 rbx, rdi
  030b9	74 0d		 je	 SHORT $LN135@PyEval_Eva

; 2723 :                 err = PyObject_IsTrue(x);

  030bb	49 8b ce	 mov	 rcx, r14
  030be	e8 00 00 00 00	 call	 PyObject_IsTrue
  030c3	44 8b e8	 mov	 r13d, eax

; 2724 :             else

  030c6	eb 03		 jmp	 SHORT $LN1049@PyEval_Eva
$LN135@PyEval_Eva:

; 2725 :                 err = 0;

  030c8	45 8b ec	 mov	 r13d, r12d
$LN1049@PyEval_Eva:

; 2726 :             Py_DECREF(x);

  030cb	49 8b ce	 mov	 rcx, r14
  030ce	44 89 ad 98 00
	00 00		 mov	 DWORD PTR err$1$[rbp-256], r13d
  030d5	e8 00 00 00 00	 call	 _Py_DecRef

; 2727 : 
; 2728 :             if (err < 0)

  030da	45 85 ed	 test	 r13d, r13d
  030dd	0f 88 d1 09 00
	00		 js	 $LN1050@PyEval_Eva

; 2729 :                 break; /* Go to error exit */
; 2730 :             else if (err > 0) {

  030e3	7e 67		 jle	 SHORT $LN949@PyEval_Eva

; 2731 :                 err = 0;
; 2732 :                 /* There was an exception and a True return */
; 2733 :                 PUSH(PyLong_FromLong((long) WHY_SILENCED));

  030e5	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  030ea	45 8b ec	 mov	 r13d, r12d
  030ed	44 89 a5 98 00
	00 00		 mov	 DWORD PTR err$1$[rbp-256], r12d
  030f4	e8 00 00 00 00	 call	 PyLong_FromLong
  030f9	48 83 c6 08	 add	 rsi, 8
  030fd	44 39 25 00 00
	00 00		 cmp	 DWORD PTR lltrace, r12d
  03104	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax
  03108	74 10		 je	 SHORT $LN696@PyEval_Eva
  0310a	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0310e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  03115	e8 00 00 00 00	 call	 prtrace
$LN696@PyEval_Eva:
  0311a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  0311f	48 8b c6	 mov	 rax, rsi
  03122	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  03129	48 c1 f8 03	 sar	 rax, 3
  0312d	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  03130	7e 1a		 jle	 SHORT $LN949@PyEval_Eva
  03132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  03139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  03140	41 b8 ad 0a 00
	00		 mov	 r8d, 2733		; 00000aadH
  03146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN949@PyEval_Eva:

; 2734 :             }
; 2735 :             PREDICT(END_FINALLY);

  0314c	4c 8b 64 24 40	 mov	 r12, QWORD PTR next_instr$1$[rsp]
  03151	41 80 3c 24 58	 cmp	 BYTE PTR [r12], 88	; 00000058H
  03156	0f 85 55 09 00
	00		 jne	 $LN987@PyEval_Eva

; 1949 : 
; 1950 :         PREDICTED(END_FINALLY);

  0315c	49 ff c4	 inc	 r12
$PRED_END_FINALLY$64957:
  0315f	4c 89 64 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r12
  03164	eb 07		 jmp	 SHORT $LN360@PyEval_Eva
$LN1021@PyEval_Eva:

; 1207 :     consts = co->co_consts;

  03166	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
$LN360@PyEval_Eva:

; 1951 :         TARGET(END_FINALLY)
; 1952 :             v = POP();

  0316d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03174	74 10		 je	 SHORT $LN614@PyEval_Eva
  03176	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0317a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03181	e8 00 00 00 00	 call	 prtrace
$LN614@PyEval_Eva:
  03186	4c 8b 6e f8	 mov	 r13, QWORD PTR [rsi-8]
  0318a	48 83 ee 08	 sub	 rsi, 8

; 1953 :             if (PyLong_Check(v)) {

  0318e	49 8b 45 58	 mov	 rax, QWORD PTR [r13+88]
  03192	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  03198	0f ba e1 18	 bt	 ecx, 24
  0319c	0f 83 fe 01 00
	00		 jae	 $LN359@PyEval_Eva

; 1954 :                 why = (enum why_code) PyLong_AS_LONG(v);

  031a2	49 8b cd	 mov	 rcx, r13
  031a5	e8 00 00 00 00	 call	 PyLong_AsLong
  031aa	89 85 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], eax

; 1955 :                 assert(why != WHY_YIELD);

  031b0	83 f8 40	 cmp	 eax, 64			; 00000040H
  031b3	75 33		 jne	 SHORT $LN615@PyEval_Eva
  031b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  031bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MGKPFLIA@?$AAw?$AAh?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAW?$AAH?$AAY?$AA_?$AAY?$AAI?$AAE?$AAL?$AAD?$AA?$AA@
  031c3	41 b8 a3 07 00
	00		 mov	 r8d, 1955		; 000007a3H
  031c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN1024@PyEval_Eva:

; 1981 :             }
; 1982 :             Py_DECREF(v);

  031cf	49 8b cd	 mov	 rcx, r13
  031d2	bb 02 00 00 00	 mov	 ebx, 2
  031d7	e8 00 00 00 00	 call	 _Py_DecRef

; 1983 :             break;

  031dc	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  031e3	e9 2e da ff ff	 jmp	 $LN1046@PyEval_Eva
$LN615@PyEval_Eva:

; 1956 :                 if (why == WHY_RETURN ||
; 1957 :                     why == WHY_CONTINUE)

  031e8	83 f8 08	 cmp	 eax, 8
  031eb	74 05		 je	 SHORT $LN357@PyEval_Eva
  031ed	83 f8 20	 cmp	 eax, 32			; 00000020H
  031f0	75 2c		 jne	 SHORT $LN358@PyEval_Eva
$LN357@PyEval_Eva:

; 1958 :                     retval = POP();

  031f2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  031f9	74 16		 je	 SHORT $LN616@PyEval_Eva
  031fb	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  031ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03206	e8 00 00 00 00	 call	 prtrace
  0320b	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR why$1$[rbp-256]
$LN616@PyEval_Eva:
  03211	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03215	48 83 ee 08	 sub	 rsi, 8
  03219	48 89 4c 24 60	 mov	 QWORD PTR retval$1$[rsp], rcx
$LN358@PyEval_Eva:

; 1959 :                 if (why == WHY_SILENCED) {

  0321e	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  03223	75 aa		 jne	 SHORT $LN1024@PyEval_Eva

; 1960 :                     /* An exception was silenced by 'with', we must
; 1961 :                     manually unwind the EXCEPT_HANDLER block which was
; 1962 :                     created when the exception was caught, otherwise
; 1963 :                     the stack will be in an inconsistent state. */
; 1964 :                     PyTryBlock *b = PyFrame_BlockPop(f);

  03225	49 8b cf	 mov	 rcx, r15
  03228	e8 00 00 00 00	 call	 PyFrame_BlockPop
  0322d	48 8b d8	 mov	 rbx, rax

; 1965 :                     assert(b->b_type == EXCEPT_HANDLER);

  03230	81 38 01 01 00
	00		 cmp	 DWORD PTR [rax], 257	; 00000101H
  03236	74 1a		 je	 SHORT $LN617@PyEval_Eva
  03238	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0323f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DI@OCKJHPNN@?$AAb?$AA?9?$AA?$DO?$AAb?$AA_?$AAt?$AAy?$AAp?$AAe?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAE?$AAX?$AAC?$AAE?$AAP?$AAT?$AA_?$AAH?$AAA?$AAN?$AAD?$AAL?$AAE?$AAR?$AA?$AA@
  03246	41 b8 ad 07 00
	00		 mov	 r8d, 1965		; 000007adH
  0324c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN617@PyEval_Eva:

; 1966 :                     UNWIND_EXCEPT_HANDLER(b);

  03252	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  03255	48 8b ce	 mov	 rcx, rsi
  03258	49 2b 8f 98 00
	00 00		 sub	 rcx, QWORD PTR [r15+152]
  0325f	83 c0 03	 add	 eax, 3
  03262	48 c1 f9 03	 sar	 rcx, 3
  03266	3b c8		 cmp	 ecx, eax
  03268	7d 1a		 jge	 SHORT $LN827@PyEval_Eva
  0326a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  03271	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@OJMEFFAL@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?$CI?$AAb?$AA?$CJ?$AA?9?$AA?$DO?$AAb?$AA_?$AAl?$AAe?$AAv?$AAe?$AAl?$AA?5?$AA?$CL?$AA?5@
  03278	41 b8 ae 07 00
	00		 mov	 r8d, 1966		; 000007aeH
  0327e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN827@PyEval_Eva:
  03284	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  03287	48 8b ce	 mov	 rcx, rsi
  0328a	49 2b 8f 98 00
	00 00		 sub	 rcx, QWORD PTR [r15+152]
  03291	83 c0 03	 add	 eax, 3
  03294	48 c1 f9 03	 sar	 rcx, 3
  03298	3b c8		 cmp	 ecx, eax
  0329a	7e 47		 jle	 SHORT $LN950@PyEval_Eva
  0329c	0f 1f 40 00	 npad	 4
$LL355@PyEval_Eva:
  032a0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  032a7	74 10		 je	 SHORT $LN619@PyEval_Eva
  032a9	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  032ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  032b4	e8 00 00 00 00	 call	 prtrace
$LN619@PyEval_Eva:
  032b9	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  032bd	48 83 ee 08	 sub	 rsi, 8
  032c1	48 85 c9	 test	 rcx, rcx
  032c4	74 05		 je	 SHORT $LN352@PyEval_Eva
  032c6	e8 00 00 00 00	 call	 _Py_DecRef
$LN352@PyEval_Eva:
  032cb	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  032ce	48 8b ce	 mov	 rcx, rsi
  032d1	49 2b 8f 98 00
	00 00		 sub	 rcx, QWORD PTR [r15+152]
  032d8	83 c0 03	 add	 eax, 3
  032db	48 c1 f9 03	 sar	 rcx, 3
  032df	3b c8		 cmp	 ecx, eax
  032e1	7f bd		 jg	 SHORT $LL355@PyEval_Eva
$LN950@PyEval_Eva:
  032e3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  032ea	48 8b 44 24 38	 mov	 rax, QWORD PTR tstate$1$[rsp]
  032ef	48 8b 58 60	 mov	 rbx, QWORD PTR [rax+96]
  032f3	48 8b 78 68	 mov	 rdi, QWORD PTR [rax+104]
  032f7	4c 8b 60 70	 mov	 r12, QWORD PTR [rax+112]
  032fb	74 10		 je	 SHORT $LN620@PyEval_Eva
  032fd	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03301	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03308	e8 00 00 00 00	 call	 prtrace
$LN620@PyEval_Eva:
  0330d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03314	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tstate$1$[rsp]
  03319	48 8b 46 f8	 mov	 rax, QWORD PTR [rsi-8]
  0331d	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  03321	74 15		 je	 SHORT $LN621@PyEval_Eva
  03323	48 8b 4e f0	 mov	 rcx, QWORD PTR [rsi-16]
  03327	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0332e	e8 00 00 00 00	 call	 prtrace
  03333	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tstate$1$[rsp]
$LN621@PyEval_Eva:
  03338	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0333f	48 8b 46 f0	 mov	 rax, QWORD PTR [rsi-16]
  03343	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  03347	74 15		 je	 SHORT $LN622@PyEval_Eva
  03349	48 8b 4e e8	 mov	 rcx, QWORD PTR [rsi-24]
  0334d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03354	e8 00 00 00 00	 call	 prtrace
  03359	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tstate$1$[rsp]
$LN622@PyEval_Eva:
  0335e	48 8b 46 e8	 mov	 rax, QWORD PTR [rsi-24]
  03362	48 83 ee 18	 sub	 rsi, 24
  03366	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax
  0336a	48 85 db	 test	 rbx, rbx
  0336d	74 08		 je	 SHORT $LN348@PyEval_Eva
  0336f	48 8b cb	 mov	 rcx, rbx
  03372	e8 00 00 00 00	 call	 _Py_DecRef
$LN348@PyEval_Eva:
  03377	48 85 ff	 test	 rdi, rdi
  0337a	74 08		 je	 SHORT $LN344@PyEval_Eva
  0337c	48 8b cf	 mov	 rcx, rdi
  0337f	e8 00 00 00 00	 call	 _Py_DecRef
$LN344@PyEval_Eva:
  03384	4d 85 e4	 test	 r12, r12
  03387	74 08		 je	 SHORT $LN340@PyEval_Eva
  03389	49 8b cc	 mov	 rcx, r12
  0338c	e8 00 00 00 00	 call	 _Py_DecRef
$LN340@PyEval_Eva:

; 1967 :                     why = WHY_NOT;

  03391	c7 85 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR why$1$[rbp-256], 1

; 1968 :                 }

  0339b	e9 2f fe ff ff	 jmp	 $LN1024@PyEval_Eva
$LN359@PyEval_Eva:

; 1969 :             }
; 1970 :             else if (PyExceptionClass_Check(v)) {

  033a0	85 c9		 test	 ecx, ecx
  033a2	79 65		 jns	 SHORT $LN336@PyEval_Eva
  033a4	41 f7 85 00 01
	00 00 00 00 00
	40		 test	 DWORD PTR [r13+256], 1073741824 ; 40000000H
  033af	74 58		 je	 SHORT $LN336@PyEval_Eva

; 1971 :                 w = POP();

  033b1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  033b8	74 10		 je	 SHORT $LN623@PyEval_Eva
  033ba	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  033be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  033c5	e8 00 00 00 00	 call	 prtrace
$LN623@PyEval_Eva:

; 1972 :                 u = POP();

  033ca	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  033d1	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  033d5	74 10		 je	 SHORT $LN624@PyEval_Eva
  033d7	48 8b 4e f0	 mov	 rcx, QWORD PTR [rsi-16]
  033db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  033e2	e8 00 00 00 00	 call	 prtrace
$LN624@PyEval_Eva:

; 1973 :                 PyErr_Restore(v, w, u);

  033e7	4c 8b 46 f0	 mov	 r8, QWORD PTR [rsi-16]
  033eb	48 83 ee 10	 sub	 rsi, 16
  033ef	48 8b d3	 mov	 rdx, rbx
  033f2	49 8b cd	 mov	 rcx, r13
  033f5	e8 00 00 00 00	 call	 PyErr_Restore

; 1974 :                 why = WHY_RERAISE;

  033fa	c7 85 90 00 00
	00 04 00 00 00	 mov	 DWORD PTR why$1$[rbp-256], 4

; 1975 :                 break;

  03404	e9 6a d8 ff ff	 jmp	 $LN1028@PyEval_Eva
$LN336@PyEval_Eva:

; 1976 :             }
; 1977 :             else if (v != Py_None) {

  03409	4c 3b ef	 cmp	 r13, rdi
  0340c	0f 84 bd fd ff
	ff		 je	 $LN1024@PyEval_Eva

; 1978 :                 PyErr_SetString(PyExc_SystemError,
; 1979 :                     "'finally' pops bad exception");

  03412	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  03419	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@BEHPHFBL@?8finally?8?5pops?5bad?5exception?$AA@
  03420	e8 00 00 00 00	 call	 PyErr_SetString

; 1980 :                 why = WHY_EXCEPTION;

  03425	bb 02 00 00 00	 mov	 ebx, 2

; 1981 :             }
; 1982 :             Py_DECREF(v);

  0342a	49 8b cd	 mov	 rcx, r13
  0342d	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx
  03433	e8 00 00 00 00	 call	 _Py_DecRef

; 1983 :             break;

  03438	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  0343f	e9 d2 d7 ff ff	 jmp	 $LN1046@PyEval_Eva
$LN129@PyEval_Eva:

; 2736 :             break;
; 2737 :         }
; 2738 : 
; 2739 :         TARGET(CALL_FUNCTION)
; 2740 :         {
; 2741 :             PyObject **sp;
; 2742 :             PCALL(PCALL_ALL);
; 2743 :             sp = stack_pointer;
; 2744 : #ifdef WITH_TSC
; 2745 :             x = call_function(&sp, oparg, &intr0, &intr1);
; 2746 : #else
; 2747 :             x = call_function(&sp, oparg);

  03444	48 8d 4d a0	 lea	 rcx, QWORD PTR sp$65500[rbp-256]
  03448	41 8b d5	 mov	 edx, r13d
  0344b	48 89 75 a0	 mov	 QWORD PTR sp$65500[rbp-256], rsi
  0344f	e8 00 00 00 00	 call	 call_function

; 2748 : #endif
; 2749 :             stack_pointer = sp;

  03454	48 8b 75 a0	 mov	 rsi, QWORD PTR sp$65500[rbp-256]

; 2750 :             PUSH(x);

  03458	48 89 06	 mov	 QWORD PTR [rsi], rax
  0345b	48 83 c6 08	 add	 rsi, 8
  0345f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03466	4c 8b f0	 mov	 r14, rax
  03469	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  0346e	74 10		 je	 SHORT $LN698@PyEval_Eva
  03470	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03474	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  0347b	e8 00 00 00 00	 call	 prtrace
$LN698@PyEval_Eva:
  03480	48 8b c6	 mov	 rax, rsi
  03483	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  0348a	48 c1 f8 03	 sar	 rax, 3
  0348e	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  03491	7e 1a		 jle	 SHORT $LN699@PyEval_Eva
  03493	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0349a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  034a1	41 b8 be 0a 00
	00		 mov	 r8d, 2750		; 00000abeH
  034a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN699@PyEval_Eva:

; 2751 :             if (x != NULL)

  034ad	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  034b2	4d 85 f6	 test	 r14, r14
  034b5	0f 85 96 cd ff
	ff		 jne	 $LN538@PyEval_Eva

; 2752 :                 DISPATCH();
; 2753 :             break;

  034bb	e9 4a d7 ff ff	 jmp	 $LN1017@PyEval_Eva
$_call_function_var_kw$65507:

; 2754 :         }
; 2755 : 
; 2756 :         TARGET_WITH_IMPL(CALL_FUNCTION_VAR, _call_function_var_kw)
; 2757 :         TARGET_WITH_IMPL(CALL_FUNCTION_KW, _call_function_var_kw)
; 2758 :         TARGET(CALL_FUNCTION_VAR_KW)
; 2759 :         _call_function_var_kw:
; 2760 :         {
; 2761 :             int na = oparg & 0xff;

  034c0	45 0f b6 f5	 movzx	 r14d, r13b

; 2762 :             int nk = (oparg>>8) & 0xff;

  034c4	41 c1 fd 08	 sar	 r13d, 8
  034c8	45 0f b6 fd	 movzx	 r15d, r13b

; 2763 :             int flags = (opcode - CALL_FUNCTION) & 3;

  034cc	44 8d 6f 01	 lea	 r13d, DWORD PTR [rdi+1]
  034d0	41 83 e5 03	 and	 r13d, 3

; 2764 :             int n = na + 2 * nk;

  034d4	43 8d 04 7e	 lea	 eax, DWORD PTR [r14+r15*2]

; 2765 :             PyObject **pfunc, *func, **sp;
; 2766 :             PCALL(PCALL_ALL);
; 2767 :             if (flags & CALL_FLAG_VAR)

  034d8	41 f6 c5 01	 test	 r13b, 1
  034dc	74 02		 je	 SHORT $LN123@PyEval_Eva

; 2768 :                 n++;

  034de	ff c0		 inc	 eax
$LN123@PyEval_Eva:

; 2769 :             if (flags & CALL_FLAG_KW)

  034e0	41 f6 c5 02	 test	 r13b, 2
  034e4	74 02		 je	 SHORT $LN122@PyEval_Eva

; 2770 :                 n++;

  034e6	ff c0		 inc	 eax
$LN122@PyEval_Eva:

; 2771 :             pfunc = stack_pointer - n - 1;

  034e8	48 98		 cdqe
  034ea	4c 8b e6	 mov	 r12, rsi
  034ed	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  034f5	4c 2b e0	 sub	 r12, rax

; 2772 :             func = *pfunc;
; 2773 : 
; 2774 :             if (PyMethod_Check(func)
; 2775 :                 && PyMethod_GET_SELF(func) != NULL) {

  034f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyMethod_Type
  034ff	49 8b 1c 24	 mov	 rbx, QWORD PTR [r12]
  03503	48 39 43 58	 cmp	 QWORD PTR [rbx+88], rax
  03507	75 2f		 jne	 SHORT $LN121@PyEval_Eva
  03509	48 8b 7b 68	 mov	 rdi, QWORD PTR [rbx+104]
  0350d	48 85 ff	 test	 rdi, rdi
  03510	74 26		 je	 SHORT $LN121@PyEval_Eva

; 2776 :                 PyObject *self = PyMethod_GET_SELF(func);
; 2777 :                 Py_INCREF(self);

  03512	48 8b cf	 mov	 rcx, rdi
  03515	e8 00 00 00 00	 call	 _Py_IncRef

; 2778 :                 func = PyMethod_GET_FUNCTION(func);

  0351a	48 8b 5b 60	 mov	 rbx, QWORD PTR [rbx+96]

; 2779 :                 Py_INCREF(func);

  0351e	48 8b cb	 mov	 rcx, rbx
  03521	e8 00 00 00 00	 call	 _Py_IncRef

; 2780 :                 Py_DECREF(*pfunc);

  03526	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  0352a	e8 00 00 00 00	 call	 _Py_DecRef

; 2781 :                 *pfunc = self;

  0352f	49 89 3c 24	 mov	 QWORD PTR [r12], rdi

; 2782 :                 na++;

  03533	41 ff c6	 inc	 r14d

; 2783 :                 /* n++; */
; 2784 :             } else

  03536	eb 08		 jmp	 SHORT $LN120@PyEval_Eva
$LN121@PyEval_Eva:

; 2785 :                 Py_INCREF(func);

  03538	48 8b cb	 mov	 rcx, rbx
  0353b	e8 00 00 00 00	 call	 _Py_IncRef
$LN120@PyEval_Eva:

; 2786 :             sp = stack_pointer;
; 2787 :             READ_TIMESTAMP(intr0);
; 2788 :             x = ext_do_call(func, &sp, flags, na, nk);

  03540	48 8d 55 a8	 lea	 rdx, QWORD PTR sp$65517[rbp-256]
  03544	45 8b ce	 mov	 r9d, r14d
  03547	45 8b c5	 mov	 r8d, r13d
  0354a	48 8b cb	 mov	 rcx, rbx
  0354d	48 89 75 a8	 mov	 QWORD PTR sp$65517[rbp-256], rsi
  03551	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  03556	e8 00 00 00 00	 call	 ext_do_call

; 2789 :             READ_TIMESTAMP(intr1);
; 2790 :             stack_pointer = sp;

  0355b	48 8b 75 a8	 mov	 rsi, QWORD PTR sp$65517[rbp-256]

; 2791 :             Py_DECREF(func);

  0355f	48 8b cb	 mov	 rcx, rbx
  03562	4c 8b f0	 mov	 r14, rax
  03565	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  0356a	e8 00 00 00 00	 call	 _Py_DecRef

; 2792 : 
; 2793 :             while (stack_pointer > pfunc) {

  0356f	49 3b f4	 cmp	 rsi, r12
  03572	76 2b		 jbe	 SHORT $LN118@PyEval_Eva
$LL119@PyEval_Eva:

; 2794 :                 w = POP();

  03574	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0357b	74 10		 je	 SHORT $LN700@PyEval_Eva
  0357d	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03581	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03588	e8 00 00 00 00	 call	 prtrace
$LN700@PyEval_Eva:

; 2795 :                 Py_DECREF(w);

  0358d	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03591	48 83 ee 08	 sub	 rsi, 8
  03595	e8 00 00 00 00	 call	 _Py_DecRef
  0359a	49 3b f4	 cmp	 rsi, r12
  0359d	77 d5		 ja	 SHORT $LL119@PyEval_Eva
$LN118@PyEval_Eva:

; 2796 :             }
; 2797 :             PUSH(x);

  0359f	4c 89 36	 mov	 QWORD PTR [rsi], r14
  035a2	48 83 c6 08	 add	 rsi, 8
  035a6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  035ad	74 10		 je	 SHORT $LN701@PyEval_Eva
  035af	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  035b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  035ba	e8 00 00 00 00	 call	 prtrace
$LN701@PyEval_Eva:
  035bf	4c 8b bd 80 00
	00 00		 mov	 r15, QWORD PTR f$[rbp-256]
  035c6	48 8b 5c 24 48	 mov	 rbx, QWORD PTR co$1$[rsp]
  035cb	48 8b c6	 mov	 rax, rsi
  035ce	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  035d5	48 c1 f8 03	 sar	 rax, 3
  035d9	3b 43 6c	 cmp	 eax, DWORD PTR [rbx+108]
  035dc	7e 1a		 jle	 SHORT $LN702@PyEval_Eva
  035de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  035e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  035ec	41 b8 ed 0a 00
	00		 mov	 r8d, 2797		; 00000aedH
  035f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN702@PyEval_Eva:

; 2798 :             if (x != NULL)

  035f8	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  035fd	4c 8b 64 24 40	 mov	 r12, QWORD PTR next_instr$1$[rsp]
  03602	4d 85 f6	 test	 r14, r14
  03605	0f 85 46 cc ff
	ff		 jne	 $LN538@PyEval_Eva

; 2799 :                 DISPATCH();
; 2800 :             break;

  0360b	e9 fa d5 ff ff	 jmp	 $LN1017@PyEval_Eva
$_make_function$65543:

; 2801 :         }
; 2802 : 
; 2803 :         TARGET_WITH_IMPL(MAKE_CLOSURE, _make_function)
; 2804 :         TARGET(MAKE_FUNCTION)
; 2805 :         _make_function:
; 2806 :         {
; 2807 :             int posdefaults = oparg & 0xff;
; 2808 :             int kwdefaults = (oparg>>8) & 0xff;

  03610	41 8b c5	 mov	 eax, r13d
  03613	45 0f b6 f5	 movzx	 r14d, r13b

; 2809 :             int num_annotations = (oparg >> 16) & 0x7fff;

  03617	41 c1 fd 10	 sar	 r13d, 16
  0361b	c1 f8 08	 sar	 eax, 8
  0361e	41 81 e5 ff 7f
	00 00		 and	 r13d, 32767		; 00007fffH

; 2810 : 
; 2811 :             w = POP(); /* qualname */

  03625	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0362c	44 0f b6 f8	 movzx	 r15d, al
  03630	44 89 75 9c	 mov	 DWORD PTR posdefaults$1$[rbp-256], r14d
  03634	44 89 7d 90	 mov	 DWORD PTR kwdefaults$1$[rbp-256], r15d
  03638	74 10		 je	 SHORT $LN703@PyEval_Eva
  0363a	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0363e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03645	e8 00 00 00 00	 call	 prtrace
$LN703@PyEval_Eva:

; 2812 :             v = POP(); /* code object */

  0364a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03651	4c 8b 66 f8	 mov	 r12, QWORD PTR [rsi-8]
  03655	74 10		 je	 SHORT $LN704@PyEval_Eva
  03657	48 8b 4e f0	 mov	 rcx, QWORD PTR [rsi-16]
  0365b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03662	e8 00 00 00 00	 call	 prtrace
$LN704@PyEval_Eva:
  03667	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]

; 2813 :             x = PyFunction_NewWithQualName(v, f->f_globals, w);

  0366b	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR f$[rbp-256]
  03672	48 83 ee 10	 sub	 rsi, 16
  03676	48 8b 92 88 00
	00 00		 mov	 rdx, QWORD PTR [rdx+136]
  0367d	48 8b cb	 mov	 rcx, rbx
  03680	4d 8b c4	 mov	 r8, r12
  03683	e8 00 00 00 00	 call	 PyFunction_NewWithQualName

; 2814 :             Py_DECREF(v);

  03688	48 8b cb	 mov	 rcx, rbx
  0368b	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  03690	e8 00 00 00 00	 call	 _Py_DecRef

; 2815 :             Py_DECREF(w);

  03695	49 8b cc	 mov	 rcx, r12
  03698	e8 00 00 00 00	 call	 _Py_DecRef

; 2816 : 
; 2817 :             if (x != NULL && opcode == MAKE_CLOSURE) {

  0369d	4c 8b 64 24 30	 mov	 r12, QWORD PTR tmp$1$[rsp]
  036a2	4d 85 e4	 test	 r12, r12
  036a5	0f 84 cf 02 00
	00		 je	 $LN1022@PyEval_Eva
  036ab	81 ff 86 00 00
	00		 cmp	 edi, 134		; 00000086H
  036b1	75 4a		 jne	 SHORT $LN114@PyEval_Eva

; 2818 :                 v = POP();

  036b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  036ba	74 10		 je	 SHORT $LN705@PyEval_Eva
  036bc	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  036c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  036c7	e8 00 00 00 00	 call	 prtrace
$LN705@PyEval_Eva:
  036cc	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  036d0	48 83 ee 08	 sub	 rsi, 8

; 2819 :                 if (PyFunction_SetClosure(x, v) != 0) {

  036d4	49 8b cc	 mov	 rcx, r12
  036d7	48 8b d3	 mov	 rdx, rbx
  036da	e8 00 00 00 00	 call	 PyFunction_SetClosure
  036df	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR why$1$[rbp-256]
  036e5	85 c0		 test	 eax, eax
  036e7	b8 02 00 00 00	 mov	 eax, 2
  036ec	0f 45 c8	 cmovne	 ecx, eax
  036ef	89 8d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ecx

; 2820 :                     /* Can't happen unless bytecode is corrupt. */
; 2821 :                     why = WHY_EXCEPTION;
; 2822 :                 }
; 2823 :                 Py_DECREF(v);

  036f5	48 8b cb	 mov	 rcx, rbx
  036f8	e8 00 00 00 00	 call	 _Py_DecRef
$LN114@PyEval_Eva:

; 2824 :             }
; 2825 : 
; 2826 :             if (x != NULL && num_annotations > 0) {

  036fd	45 85 ed	 test	 r13d, r13d
  03700	0f 8e 05 01 00
	00		 jle	 $LN973@PyEval_Eva

; 2827 :                 Py_ssize_t name_ix;
; 2828 :                 u = POP(); /* names of args with annotations */

  03706	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0370d	74 10		 je	 SHORT $LN706@PyEval_Eva
  0370f	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03713	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0371a	e8 00 00 00 00	 call	 prtrace
$LN706@PyEval_Eva:
  0371f	4c 8b 7e f8	 mov	 r15, QWORD PTR [rsi-8]
  03723	48 83 ee 08	 sub	 rsi, 8

; 2829 :                 v = PyDict_New();

  03727	e8 00 00 00 00	 call	 PyDict_New
  0372c	4c 8b f0	 mov	 r14, rax

; 2830 :                 if (v == NULL) {

  0372f	48 85 c0	 test	 rax, rax
  03732	75 14		 jne	 SHORT $LN111@PyEval_Eva

; 2831 :                     Py_DECREF(x);

  03734	49 8b cc	 mov	 rcx, r12
  03737	e8 00 00 00 00	 call	 _Py_DecRef

; 2832 :                     x = NULL;
; 2833 :                     break;

  0373c	4c 8b bd 80 00
	00 00		 mov	 r15, QWORD PTR f$[rbp-256]
  03743	e9 29 f4 ff ff	 jmp	 $LN1060@PyEval_Eva
$LN111@PyEval_Eva:

; 2834 :                 }
; 2835 :                 name_ix = PyTuple_Size(u);

  03748	49 8b cf	 mov	 rcx, r15
  0374b	e8 00 00 00 00	 call	 PyTuple_Size

; 2836 :                 assert(num_annotations == name_ix+1);

  03750	49 63 cd	 movsxd	 rcx, r13d
  03753	48 8d 50 01	 lea	 rdx, QWORD PTR [rax+1]
  03757	48 8b f8	 mov	 rdi, rax
  0375a	48 3b ca	 cmp	 rcx, rdx
  0375d	74 1a		 je	 SHORT $LN829@PyEval_Eva
  0375f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  03766	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DK@INACIJOP@?$AAn?$AAu?$AAm?$AA_?$AAa?$AAn?$AAn?$AAo?$AAt?$AAa?$AAt?$AAi?$AAo?$AAn?$AAs?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAn?$AAa?$AAm?$AAe?$AA_?$AAi?$AAx?$AA?$CL?$AA1?$AA?$AA@
  0376d	41 b8 14 0b 00
	00		 mov	 r8d, 2836		; 00000b14H
  03773	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN829@PyEval_Eva:

; 2837 :                 while (name_ix > 0) {

  03779	48 85 ff	 test	 rdi, rdi
  0377c	7e 4d		 jle	 SHORT $LN109@PyEval_Eva
  0377e	4d 8d 64 ff 70	 lea	 r12, QWORD PTR [r15+rdi*8+112]
$LL110@PyEval_Eva:

; 2838 :                     --name_ix;
; 2839 :                     t = PyTuple_GET_ITEM(u, name_ix);

  03783	4d 8b 6c 24 f8	 mov	 r13, QWORD PTR [r12-8]
  03788	49 83 ec 08	 sub	 r12, 8
  0378c	48 ff cf	 dec	 rdi

; 2840 :                     w = POP();

  0378f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03796	74 10		 je	 SHORT $LN708@PyEval_Eva
  03798	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  0379c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  037a3	e8 00 00 00 00	 call	 prtrace
$LN708@PyEval_Eva:
  037a8	48 8b 5e f8	 mov	 rbx, QWORD PTR [rsi-8]
  037ac	48 83 ee 08	 sub	 rsi, 8

; 2841 :                     /* XXX(nnorwitz): check for errors */
; 2842 :                     PyDict_SetItem(v, t, w);

  037b0	49 8b d5	 mov	 rdx, r13
  037b3	4c 8b c3	 mov	 r8, rbx
  037b6	49 8b ce	 mov	 rcx, r14
  037b9	e8 00 00 00 00	 call	 PyDict_SetItem

; 2843 :                     Py_DECREF(w);

  037be	48 8b cb	 mov	 rcx, rbx
  037c1	e8 00 00 00 00	 call	 _Py_DecRef
  037c6	48 85 ff	 test	 rdi, rdi
  037c9	7f b8		 jg	 SHORT $LL110@PyEval_Eva
$LN109@PyEval_Eva:

; 2844 :                 }
; 2845 : 
; 2846 :                 if (PyFunction_SetAnnotations(x, v) != 0) {

  037cb	4c 8b 6c 24 30	 mov	 r13, QWORD PTR tmp$1$[rsp]
  037d0	49 8b d6	 mov	 rdx, r14
  037d3	49 8b cd	 mov	 rcx, r13
  037d6	e8 00 00 00 00	 call	 PyFunction_SetAnnotations
  037db	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR why$1$[rbp-256]
  037e1	bb 02 00 00 00	 mov	 ebx, 2
  037e6	85 c0		 test	 eax, eax
  037e8	0f 45 cb	 cmovne	 ecx, ebx
  037eb	89 8d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ecx

; 2847 :                     /* Can't happen unless
; 2848 :                        PyFunction_SetAnnotations changes. */
; 2849 :                     why = WHY_EXCEPTION;
; 2850 :                 }
; 2851 :                 Py_DECREF(v);

  037f1	49 8b ce	 mov	 rcx, r14
  037f4	e8 00 00 00 00	 call	 _Py_DecRef

; 2852 :                 Py_DECREF(u);

  037f9	49 8b cf	 mov	 rcx, r15
  037fc	e8 00 00 00 00	 call	 _Py_DecRef
  03801	44 8b 75 9c	 mov	 r14d, DWORD PTR posdefaults$1$[rbp-256]
  03805	44 8b 7d 90	 mov	 r15d, DWORD PTR kwdefaults$1$[rbp-256]
  03809	eb 08		 jmp	 SHORT $LN112@PyEval_Eva
$LN973@PyEval_Eva:

; 2816 : 
; 2817 :             if (x != NULL && opcode == MAKE_CLOSURE) {

  0380b	4d 8b ec	 mov	 r13, r12
  0380e	bb 02 00 00 00	 mov	 ebx, 2
$LN112@PyEval_Eva:

; 2853 :             }
; 2854 : 
; 2855 :             /* XXX Maybe this should be a separate opcode? */
; 2856 :             if (x != NULL && posdefaults > 0) {

  03813	45 85 f6	 test	 r14d, r14d
  03816	0f 8e a5 00 00
	00		 jle	 $LN1018@PyEval_Eva

; 2857 :                 v = PyTuple_New(posdefaults);

  0381c	49 63 ce	 movsxd	 rcx, r14d
  0381f	e8 00 00 00 00	 call	 PyTuple_New
  03824	4c 8b e0	 mov	 r12, rax

; 2858 :                 if (v == NULL) {

  03827	48 85 c0	 test	 rax, rax
  0382a	75 2c		 jne	 SHORT $LN830@PyEval_Eva
$LN1062@PyEval_Eva:

; 2859 :                     Py_DECREF(x);

  0382c	49 8b cd	 mov	 rcx, r13
  0382f	e8 00 00 00 00	 call	 _Py_DecRef

; 2860 :                     x = NULL;
; 2861 :                     break;

  03834	4c 8b bd 80 00
	00 00		 mov	 r15, QWORD PTR f$[rbp-256]
  0383b	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR why$1$[rbp-256]
  03841	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  03848	45 33 e4	 xor	 r12d, r12d
  0384b	45 8b f4	 mov	 r14d, r12d
  0384e	4c 89 64 24 30	 mov	 QWORD PTR tmp$1$[rsp], r12
  03853	e9 c7 d3 ff ff	 jmp	 $LN1042@PyEval_Eva
$LN830@PyEval_Eva:

; 2862 :                 }
; 2863 :                 while (--posdefaults >= 0) {

  03858	41 ff ce	 dec	 r14d
  0385b	49 63 de	 movsxd	 rbx, r14d
  0385e	78 33		 js	 SHORT $LN104@PyEval_Eva
  03860	48 8d 7c d8 70	 lea	 rdi, QWORD PTR [rax+rbx*8+112]
$LL105@PyEval_Eva:

; 2864 :                     w = POP();

  03865	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0386c	74 10		 je	 SHORT $LN709@PyEval_Eva
  0386e	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03872	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03879	e8 00 00 00 00	 call	 prtrace
$LN709@PyEval_Eva:

; 2865 :                     PyTuple_SET_ITEM(v, posdefaults, w);

  0387e	48 8b 46 f8	 mov	 rax, QWORD PTR [rsi-8]
  03882	48 83 ee 08	 sub	 rsi, 8
  03886	48 83 ef 08	 sub	 rdi, 8
  0388a	48 ff cb	 dec	 rbx
  0388d	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  03891	79 d2		 jns	 SHORT $LL105@PyEval_Eva
$LN104@PyEval_Eva:

; 2866 :                 }
; 2867 :                 if (PyFunction_SetDefaults(x, v) != 0) {

  03893	49 8b d4	 mov	 rdx, r12
  03896	49 8b cd	 mov	 rcx, r13
  03899	e8 00 00 00 00	 call	 PyFunction_SetDefaults
  0389e	44 8b b5 90 00
	00 00		 mov	 r14d, DWORD PTR why$1$[rbp-256]
  038a5	bb 02 00 00 00	 mov	 ebx, 2
  038aa	85 c0		 test	 eax, eax

; 2868 :                     /* Can't happen unless
; 2869 :                        PyFunction_SetDefaults changes. */
; 2870 :                     why = WHY_EXCEPTION;
; 2871 :                 }
; 2872 :                 Py_DECREF(v);

  038ac	49 8b cc	 mov	 rcx, r12
  038af	44 0f 45 f3	 cmovne	 r14d, ebx
  038b3	44 89 b5 90 00
	00 00		 mov	 DWORD PTR why$1$[rbp-256], r14d
  038ba	e8 00 00 00 00	 call	 _Py_DecRef
  038bf	eb 07		 jmp	 SHORT $LN107@PyEval_Eva
$LN1018@PyEval_Eva:

; 2888 :                 }
; 2889 :                 if (PyFunction_SetKwDefaults(x, v) != 0) {

  038c1	44 8b b5 90 00
	00 00		 mov	 r14d, DWORD PTR why$1$[rbp-256]
$LN107@PyEval_Eva:

; 2873 :             }
; 2874 :             if (x != NULL && kwdefaults > 0) {

  038c8	45 85 ff	 test	 r15d, r15d
  038cb	0f 8e ae 00 00
	00		 jle	 $LN102@PyEval_Eva

; 2875 :                 v = PyDict_New();

  038d1	e8 00 00 00 00	 call	 PyDict_New
  038d6	4c 8b e0	 mov	 r12, rax

; 2876 :                 if (v == NULL) {

  038d9	48 85 c0	 test	 rax, rax

; 2877 :                     Py_DECREF(x);
; 2878 :                     x = NULL;
; 2879 :                     break;

  038dc	0f 84 4a ff ff
	ff		 je	 $LN1062@PyEval_Eva

; 2880 :                 }
; 2881 :                 while (--kwdefaults >= 0) {

  038e2	41 ff cf	 dec	 r15d
  038e5	78 71		 js	 SHORT $LN99@PyEval_Eva
  038e7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL100@PyEval_Eva:

; 2882 :                     w = POP(); /* default value */

  038f0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lltrace
  038f6	85 c0		 test	 eax, eax
  038f8	74 16		 je	 SHORT $LN710@PyEval_Eva
  038fa	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  038fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03905	e8 00 00 00 00	 call	 prtrace
  0390a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lltrace
$LN710@PyEval_Eva:
  03910	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 2883 :                     u = POP(); /* kw only arg name */

  03914	85 c0		 test	 eax, eax
  03916	74 10		 je	 SHORT $LN711@PyEval_Eva
  03918	48 8b 4e f0	 mov	 rcx, QWORD PTR [rsi-16]
  0391c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03923	e8 00 00 00 00	 call	 prtrace
$LN711@PyEval_Eva:
  03928	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  0392c	48 83 ee 10	 sub	 rsi, 16

; 2884 :                     /* XXX(nnorwitz): check for errors */
; 2885 :                     PyDict_SetItem(v, u, w);

  03930	4c 8b c7	 mov	 r8, rdi
  03933	48 8b d3	 mov	 rdx, rbx
  03936	49 8b cc	 mov	 rcx, r12
  03939	e8 00 00 00 00	 call	 PyDict_SetItem

; 2886 :                     Py_DECREF(w);

  0393e	48 8b cf	 mov	 rcx, rdi
  03941	e8 00 00 00 00	 call	 _Py_DecRef

; 2887 :                     Py_DECREF(u);

  03946	48 8b cb	 mov	 rcx, rbx
  03949	e8 00 00 00 00	 call	 _Py_DecRef
  0394e	41 ff cf	 dec	 r15d
  03951	79 9d		 jns	 SHORT $LL100@PyEval_Eva
  03953	bb 02 00 00 00	 mov	 ebx, 2
$LN99@PyEval_Eva:

; 2888 :                 }
; 2889 :                 if (PyFunction_SetKwDefaults(x, v) != 0) {

  03958	49 8b d4	 mov	 rdx, r12
  0395b	49 8b cd	 mov	 rcx, r13
  0395e	e8 00 00 00 00	 call	 PyFunction_SetKwDefaults

; 2890 :                     /* Can't happen unless
; 2891 :                        PyFunction_SetKwDefaults changes. */
; 2892 :                     why = WHY_EXCEPTION;
; 2893 :                 }
; 2894 :                 Py_DECREF(v);

  03963	49 8b cc	 mov	 rcx, r12
  03966	85 c0		 test	 eax, eax
  03968	44 0f 45 f3	 cmovne	 r14d, ebx
  0396c	44 89 b5 90 00
	00 00		 mov	 DWORD PTR why$1$[rbp-256], r14d
  03973	e8 00 00 00 00	 call	 _Py_DecRef
  03978	eb 05		 jmp	 SHORT $LN102@PyEval_Eva
$LN1022@PyEval_Eva:

; 1949 : 
; 1950 :         PREDICTED(END_FINALLY);

  0397a	bb 02 00 00 00	 mov	 ebx, 2
$LN102@PyEval_Eva:

; 2895 :             }
; 2896 :             PUSH(x);

  0397f	4c 8b 74 24 30	 mov	 r14, QWORD PTR tmp$1$[rsp]
  03984	48 83 c6 08	 add	 rsi, 8
  03988	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0398f	4c 89 76 f8	 mov	 QWORD PTR [rsi-8], r14
  03993	74 10		 je	 SHORT $LN712@PyEval_Eva
  03995	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03999	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  039a0	e8 00 00 00 00	 call	 prtrace
$LN712@PyEval_Eva:
  039a5	4c 8b bd 80 00
	00 00		 mov	 r15, QWORD PTR f$[rbp-256]
  039ac	48 8b 4c 24 48	 mov	 rcx, QWORD PTR co$1$[rsp]
  039b1	48 8b c6	 mov	 rax, rsi
  039b4	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  039bb	48 c1 f8 03	 sar	 rax, 3
  039bf	3b 41 6c	 cmp	 eax, DWORD PTR [rcx+108]
  039c2	0f 8e 9f e5 ff
	ff		 jle	 $LN986@PyEval_Eva
  039c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  039cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  039d6	41 b8 50 0b 00
	00		 mov	 r8d, 2896		; 00000b50H
  039dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert

; 2897 :             break;

  039e2	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  039e9	e9 28 d2 ff ff	 jmp	 $LN1046@PyEval_Eva
$LN97@PyEval_Eva:

; 2898 :         }
; 2899 : 
; 2900 :         TARGET(BUILD_SLICE)
; 2901 :             if (oparg == 3)

  039ee	41 83 fd 03	 cmp	 r13d, 3
  039f2	75 23		 jne	 SHORT $LN96@PyEval_Eva

; 2902 :                 w = POP();

  039f4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  039fb	74 10		 je	 SHORT $LN714@PyEval_Eva
  039fd	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03a01	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03a08	e8 00 00 00 00	 call	 prtrace
$LN714@PyEval_Eva:
  03a0d	4c 8b 66 f8	 mov	 r12, QWORD PTR [rsi-8]
  03a11	48 83 ee 08	 sub	 rsi, 8

; 2903 :             else

  03a15	eb 03		 jmp	 SHORT $LN95@PyEval_Eva
$LN96@PyEval_Eva:

; 2904 :                 w = NULL;

  03a17	45 33 e4	 xor	 r12d, r12d
$LN95@PyEval_Eva:

; 2905 :             v = POP();

  03a1a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03a21	74 10		 je	 SHORT $LN715@PyEval_Eva
  03a23	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03a27	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03a2e	e8 00 00 00 00	 call	 prtrace
$LN715@PyEval_Eva:
  03a33	48 8b 7e f8	 mov	 rdi, QWORD PTR [rsi-8]

; 2906 :             u = TOP();

  03a37	48 8b 5e f0	 mov	 rbx, QWORD PTR [rsi-16]
  03a3b	48 83 ee 08	 sub	 rsi, 8

; 2907 :             x = PySlice_New(u, v, w);

  03a3f	48 8b d7	 mov	 rdx, rdi
  03a42	48 8b cb	 mov	 rcx, rbx
  03a45	4d 8b c4	 mov	 r8, r12
  03a48	e8 00 00 00 00	 call	 PySlice_New

; 2908 :             Py_DECREF(u);

  03a4d	48 8b cb	 mov	 rcx, rbx
  03a50	4c 8b f0	 mov	 r14, rax
  03a53	48 89 44 24 30	 mov	 QWORD PTR tmp$1$[rsp], rax
  03a58	e8 00 00 00 00	 call	 _Py_DecRef

; 2909 :             Py_DECREF(v);

  03a5d	48 8b cf	 mov	 rcx, rdi
  03a60	e8 00 00 00 00	 call	 _Py_DecRef

; 2910 :             Py_XDECREF(w);

  03a65	4d 85 e4	 test	 r12, r12
  03a68	74 08		 je	 SHORT $LN93@PyEval_Eva
  03a6a	49 8b cc	 mov	 rcx, r12
$LN1051@PyEval_Eva:
  03a6d	e8 00 00 00 00	 call	 _Py_DecRef
$LN93@PyEval_Eva:

; 2911 :             SET_TOP(x);

  03a72	4c 89 76 f8	 mov	 QWORD PTR [rsi-8], r14

; 2912 :             if (x != NULL) DISPATCH();

  03a76	4d 85 f6	 test	 r14, r14
  03a79	0f 85 c3 c7 ff
	ff		 jne	 $LN1064@PyEval_Eva
  03a7f	e9 86 d1 ff ff	 jmp	 $LN1017@PyEval_Eva
$LN992@PyEval_Eva:

; 1867 :             case 0: /* Fallthrough */
; 1868 :                 why = do_raise(w, v);

  03a84	44 8b ef	 mov	 r13d, edi
  03a87	e9 85 d1 ff ff	 jmp	 $LN1039@PyEval_Eva
$LN1011@PyEval_Eva:
  03a8c	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  03a93	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR why$1$[rbp-256]
  03a99	bb 02 00 00 00	 mov	 ebx, 2
  03a9e	e9 83 d1 ff ff	 jmp	 $on_error$64523
$LN1016@PyEval_Eva:
  03aa3	44 8b ad 98 00
	00 00		 mov	 r13d, DWORD PTR err$1$[rbp-256]
  03aaa	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:_Py_NoneStruct
$LN987@PyEval_Eva:
  03ab1	45 33 e4	 xor	 r12d, r12d
$LN1050@PyEval_Eva:
  03ab4	8b 85 90 00 00
	00		 mov	 eax, DWORD PTR why$1$[rbp-256]
  03aba	bb 02 00 00 00	 mov	 ebx, 2
  03abf	e9 62 d1 ff ff	 jmp	 $on_error$64523
$LN87@PyEval_Eva:

; 2962 :         }
; 2963 : 
; 2964 :         /* Double-check exception status */
; 2965 : 
; 2966 :         if (why == WHY_EXCEPTION || why == WHY_RERAISE) {

  03ac4	83 f8 02	 cmp	 eax, 2
  03ac7	0f 84 a6 d1 ff
	ff		 je	 $LN1028@PyEval_Eva
  03acd	83 f8 04	 cmp	 eax, 4
  03ad0	0f 84 9d d1 ff
	ff		 je	 $LN1028@PyEval_Eva

; 2971 :             }
; 2972 :         }
; 2973 : #ifdef CHECKEXC
; 2974 :         else {
; 2975 :             /* This check is expensive! */
; 2976 :             if (PyErr_Occurred()) {

  03ad6	e8 00 00 00 00	 call	 PyErr_Occurred
  03adb	48 85 c0	 test	 rax, rax
  03ade	74 21		 je	 SHORT $LN81@PyEval_Eva

; 2977 :                 char buf[128];
; 2978 :                 sprintf(buf, "Stack unwind with exception "
; 2979 :                     "set and why=%d", why);

  03ae0	44 8b 85 90 00
	00 00		 mov	 r8d, DWORD PTR why$1$[rbp-256]
  03ae7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@HKNINBON@Stack?5unwind?5with?5exception?5set?5@
  03aee	48 8d 4d c0	 lea	 rcx, QWORD PTR buf$65638[rbp-256]
  03af2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 2980 :                 Py_FatalError(buf);

  03af8	48 8d 4d c0	 lea	 rcx, QWORD PTR buf$65638[rbp-256]
  03afc	e8 00 00 00 00	 call	 Py_FatalError
$LN81@PyEval_Eva:

; 2981 :             }
; 2982 :         }
; 2983 : #endif
; 2984 : 
; 2985 :         /* Log traceback info if this is a real exception */
; 2986 : 
; 2987 :         if (why == WHY_EXCEPTION) {

  03b01	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR why$1$[rbp-256]
  03b07	83 f9 02	 cmp	 ecx, 2
  03b0a	75 74		 jne	 SHORT $LN77@PyEval_Eva
$LN881@PyEval_Eva:

; 2988 :             PyTraceBack_Here(f);

  03b0c	49 8b cf	 mov	 rcx, r15
  03b0f	e8 00 00 00 00	 call	 PyTraceBack_Here

; 2989 : 
; 2990 :             if (tstate->c_tracefunc != NULL)

  03b14	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  03b19	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  03b1d	48 85 c9	 test	 rcx, rcx
  03b20	74 0c		 je	 SHORT $LN951@PyEval_Eva

; 2991 :                 call_exc_trace(tstate->c_tracefunc,
; 2992 :                                tstate->c_traceobj, f);

  03b22	48 8b 57 40	 mov	 rdx, QWORD PTR [rdi+64]
  03b26	4d 8b c7	 mov	 r8, r15
  03b29	e8 00 00 00 00	 call	 call_exc_trace
$LN951@PyEval_Eva:

; 2993 :         }
; 2994 : 
; 2995 :         /* For the rest, treat WHY_RERAISE as WHY_EXCEPTION */
; 2996 : 
; 2997 :         if (why == WHY_RERAISE)

  03b2e	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR why$1$[rbp-256]
  03b34	eb 60		 jmp	 SHORT $LN832@PyEval_Eva
$LN88@PyEval_Eva:

; 2919 : 
; 2920 : #if USE_COMPUTED_GOTOS
; 2921 :         _unknown_opcode:
; 2922 : #endif
; 2923 :         default:
; 2924 :             fprintf(stderr,
; 2925 :                 "XXX lineno: %d, opcode: %d\n",
; 2926 :                 PyFrame_GetLineNumber(f),
; 2927 :                 opcode);

  03b36	49 8b cf	 mov	 rcx, r15
  03b39	e8 00 00 00 00	 call	 PyFrame_GetLineNumber
  03b3e	8b d8		 mov	 ebx, eax
  03b40	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  03b46	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@FPIMIFGH@XXX?5lineno?3?5?$CFd?0?5opcode?3?5?$CFd?6?$AA@
  03b4d	48 8d 48 60	 lea	 rcx, QWORD PTR [rax+96]
  03b51	44 8b cf	 mov	 r9d, edi
  03b54	44 8b c3	 mov	 r8d, ebx
  03b57	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 2928 :             PyErr_SetString(PyExc_SystemError, "unknown opcode");

  03b5d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  03b64	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@FENJHLBJ@unknown?5opcode?$AA@
  03b6b	e8 00 00 00 00	 call	 PyErr_SetString

; 2929 :             why = WHY_EXCEPTION;

  03b70	bb 02 00 00 00	 mov	 ebx, 2
  03b75	89 9d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ebx
  03b7b	e9 f8 d0 ff ff	 jmp	 $LN82@PyEval_Eva
$LN77@PyEval_Eva:

; 2993 :         }
; 2994 : 
; 2995 :         /* For the rest, treat WHY_RERAISE as WHY_EXCEPTION */
; 2996 : 
; 2997 :         if (why == WHY_RERAISE)

  03b80	83 f9 04	 cmp	 ecx, 4
  03b83	b8 02 00 00 00	 mov	 eax, 2
  03b88	0f 44 c8	 cmove	 ecx, eax
$LN1043@PyEval_Eva:
  03b8b	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  03b90	89 8d 90 00 00
	00		 mov	 DWORD PTR why$1$[rbp-256], ecx
$LN832@PyEval_Eva:

; 2998 :             why = WHY_EXCEPTION;
; 2999 : 
; 3000 :         /* Unwind stacks if a (pseudo) exception occurred */
; 3001 : 
; 3002 : fast_block_end:
; 3003 :         while (why != WHY_NOT && f->f_iblock > 0) {

  03b96	4c 63 e9	 movsxd	 r13, ecx
  03b99	0f 1f 80 00 00
	00 00		 npad	 7
$fast_block_end$64879:
  03ba0	49 83 fd 01	 cmp	 r13, 1
  03ba4	0f 84 7d 06 00
	00		 je	 $LN74@PyEval_Eva
  03baa	41 8b 87 d8 00
	00 00		 mov	 eax, DWORD PTR [r15+216]
  03bb1	85 c0		 test	 eax, eax
  03bb3	0f 8e 6e 06 00
	00		 jle	 $LN74@PyEval_Eva

; 3004 :             /* Peek at the current block. */
; 3005 :             PyTryBlock *b = &f->f_blockstack[f->f_iblock - 1];

  03bb9	ff c8		 dec	 eax
  03bbb	48 63 c8	 movsxd	 rcx, eax
  03bbe	48 8d 1c 49	 lea	 rbx, QWORD PTR [rcx+rcx*2]

; 3006 : 
; 3007 :             assert(why != WHY_YIELD);

  03bc2	49 83 fd 40	 cmp	 r13, 64			; 00000040H
  03bc6	75 1a		 jne	 SHORT $LN716@PyEval_Eva
  03bc8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  03bcf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MGKPFLIA@?$AAw?$AAh?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAW?$AAH?$AAY?$AA_?$AAY?$AAI?$AAE?$AAL?$AAD?$AA?$AA@
  03bd6	41 b8 bf 0b 00
	00		 mov	 r8d, 3007		; 00000bbfH
  03bdc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN716@PyEval_Eva:

; 3008 :             if (b->b_type == SETUP_LOOP && why == WHY_CONTINUE) {

  03be2	41 83 bc 9f dc
	00 00 00 78	 cmp	 DWORD PTR [r15+rbx*4+220], 120 ; 00000078H
  03beb	75 0a		 jne	 SHORT $LN73@PyEval_Eva
  03bed	49 83 fd 20	 cmp	 r13, 32			; 00000020H
  03bf1	0f 84 94 03 00
	00		 je	 $LN841@PyEval_Eva
$LN73@PyEval_Eva:

; 3013 :             }
; 3014 :             /* Now we have to pop the block. */
; 3015 :             f->f_iblock--;

  03bf7	41 ff 8f d8 00
	00 00		 dec	 DWORD PTR [r15+216]

; 3016 : 
; 3017 :             if (b->b_type == EXCEPT_HANDLER) {

  03bfe	41 81 bc 9f dc
	00 00 00 01 01
	00 00		 cmp	 DWORD PTR [r15+rbx*4+220], 257 ; 00000101H
  03c0a	0f 85 58 01 00
	00		 jne	 $LN835@PyEval_Eva

; 3018 :                 UNWIND_EXCEPT_HANDLER(b);

  03c10	41 8b 84 9f e4
	00 00 00	 mov	 eax, DWORD PTR [r15+rbx*4+228]
  03c18	48 8b ce	 mov	 rcx, rsi
  03c1b	49 2b 8f 98 00
	00 00		 sub	 rcx, QWORD PTR [r15+152]
  03c22	83 c0 03	 add	 eax, 3
  03c25	48 c1 f9 03	 sar	 rcx, 3
  03c29	3b c8		 cmp	 ecx, eax
  03c2b	7d 1a		 jge	 SHORT $LN834@PyEval_Eva
  03c2d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  03c34	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@OJMEFFAL@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA?$CI?$AAb?$AA?$CJ?$AA?9?$AA?$DO?$AAb?$AA_?$AAl?$AAe?$AAv?$AAe?$AAl?$AA?5?$AA?$CL?$AA?5@
  03c3b	41 b8 ca 0b 00
	00		 mov	 r8d, 3018		; 00000bcaH
  03c41	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN834@PyEval_Eva:
  03c47	41 8b 84 9f e4
	00 00 00	 mov	 eax, DWORD PTR [r15+rbx*4+228]
  03c4f	48 8b ce	 mov	 rcx, rsi
  03c52	49 2b 8f 98 00
	00 00		 sub	 rcx, QWORD PTR [r15+152]
  03c59	83 c0 03	 add	 eax, 3
  03c5c	48 c1 f9 03	 sar	 rcx, 3
  03c60	3b c8		 cmp	 ecx, eax
  03c62	7e 48		 jle	 SHORT $LN70@PyEval_Eva
$LL71@PyEval_Eva:
  03c64	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03c6b	74 10		 je	 SHORT $LN718@PyEval_Eva
  03c6d	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03c71	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03c78	e8 00 00 00 00	 call	 prtrace
$LN718@PyEval_Eva:
  03c7d	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03c81	48 83 ee 08	 sub	 rsi, 8
  03c85	48 85 c9	 test	 rcx, rcx
  03c88	74 05		 je	 SHORT $LN68@PyEval_Eva
  03c8a	e8 00 00 00 00	 call	 _Py_DecRef
$LN68@PyEval_Eva:
  03c8f	41 8b 84 9f e4
	00 00 00	 mov	 eax, DWORD PTR [r15+rbx*4+228]
  03c97	48 8b ce	 mov	 rcx, rsi
  03c9a	49 2b 8f 98 00
	00 00		 sub	 rcx, QWORD PTR [r15+152]
  03ca1	83 c0 03	 add	 eax, 3
  03ca4	48 c1 f9 03	 sar	 rcx, 3
  03ca8	3b c8		 cmp	 ecx, eax
  03caa	7f b8		 jg	 SHORT $LL71@PyEval_Eva
$LN70@PyEval_Eva:
  03cac	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03cb3	48 8b 44 24 38	 mov	 rax, QWORD PTR tstate$1$[rsp]
  03cb8	48 8b 5f 60	 mov	 rbx, QWORD PTR [rdi+96]
  03cbc	4c 8b 60 70	 mov	 r12, QWORD PTR [rax+112]
  03cc0	48 8b 7f 68	 mov	 rdi, QWORD PTR [rdi+104]
  03cc4	74 10		 je	 SHORT $LN719@PyEval_Eva
  03cc6	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03cca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03cd1	e8 00 00 00 00	 call	 prtrace
$LN719@PyEval_Eva:
  03cd6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03cdd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tstate$1$[rsp]
  03ce2	48 8b 46 f8	 mov	 rax, QWORD PTR [rsi-8]
  03ce6	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  03cea	74 15		 je	 SHORT $LN720@PyEval_Eva
  03cec	48 8b 4e f0	 mov	 rcx, QWORD PTR [rsi-16]
  03cf0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03cf7	e8 00 00 00 00	 call	 prtrace
  03cfc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tstate$1$[rsp]
$LN720@PyEval_Eva:
  03d01	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03d08	48 8b 46 f0	 mov	 rax, QWORD PTR [rsi-16]
  03d0c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  03d10	74 15		 je	 SHORT $LN721@PyEval_Eva
  03d12	48 8b 4e e8	 mov	 rcx, QWORD PTR [rsi-24]
  03d16	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03d1d	e8 00 00 00 00	 call	 prtrace
  03d22	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tstate$1$[rsp]
$LN721@PyEval_Eva:
  03d27	48 8b 46 e8	 mov	 rax, QWORD PTR [rsi-24]
  03d2b	48 83 ee 18	 sub	 rsi, 24
  03d2f	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax
  03d33	48 85 db	 test	 rbx, rbx
  03d36	74 08		 je	 SHORT $LN64@PyEval_Eva
  03d38	48 8b cb	 mov	 rcx, rbx
  03d3b	e8 00 00 00 00	 call	 _Py_DecRef
$LN64@PyEval_Eva:
  03d40	48 85 ff	 test	 rdi, rdi
  03d43	74 08		 je	 SHORT $LN60@PyEval_Eva
  03d45	48 8b cf	 mov	 rcx, rdi
  03d48	e8 00 00 00 00	 call	 _Py_DecRef
$LN60@PyEval_Eva:
  03d4d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  03d52	4d 85 e4	 test	 r12, r12
  03d55	0f 84 45 fe ff
	ff		 je	 $fast_block_end$64879
  03d5b	49 8b cc	 mov	 rcx, r12
  03d5e	e8 00 00 00 00	 call	 _Py_DecRef

; 3019 :                 continue;

  03d63	e9 38 fe ff ff	 jmp	 $fast_block_end$64879
$LN835@PyEval_Eva:

; 3020 :             }
; 3021 :             UNWIND_BLOCK(b);

  03d68	48 8b c6	 mov	 rax, rsi
  03d6b	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  03d72	48 c1 f8 03	 sar	 rax, 3
  03d76	41 3b 84 9f e4
	00 00 00	 cmp	 eax, DWORD PTR [r15+rbx*4+228]
  03d7e	7e 43		 jle	 SHORT $LN52@PyEval_Eva
$LL53@PyEval_Eva:
  03d80	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03d87	74 10		 je	 SHORT $LN722@PyEval_Eva
  03d89	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03d8d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  03d94	e8 00 00 00 00	 call	 prtrace
$LN722@PyEval_Eva:
  03d99	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03d9d	48 83 ee 08	 sub	 rsi, 8
  03da1	48 85 c9	 test	 rcx, rcx
  03da4	74 05		 je	 SHORT $LN50@PyEval_Eva
  03da6	e8 00 00 00 00	 call	 _Py_DecRef
$LN50@PyEval_Eva:
  03dab	48 8b c6	 mov	 rax, rsi
  03dae	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  03db5	48 c1 f8 03	 sar	 rax, 3
  03db9	41 3b 84 9f e4
	00 00 00	 cmp	 eax, DWORD PTR [r15+rbx*4+228]
  03dc1	7f bd		 jg	 SHORT $LL53@PyEval_Eva
$LN52@PyEval_Eva:

; 3022 :             if (b->b_type == SETUP_LOOP && why == WHY_BREAK) {

  03dc3	41 8b 84 9f dc
	00 00 00	 mov	 eax, DWORD PTR [r15+rbx*4+220]
  03dcb	83 f8 78	 cmp	 eax, 120		; 00000078H
  03dce	75 0a		 jne	 SHORT $LN47@PyEval_Eva
  03dd0	49 83 fd 10	 cmp	 r13, 16
  03dd4	0f 84 2c 04 00
	00		 je	 $LN740@PyEval_Eva
$LN47@PyEval_Eva:

; 3023 :                 why = WHY_NOT;
; 3024 :                 JUMPTO(b->b_handler);
; 3025 :                 break;
; 3026 :             }
; 3027 :             if (why == WHY_EXCEPTION && (b->b_type == SETUP_EXCEPT
; 3028 :                 || b->b_type == SETUP_FINALLY)) {

  03dda	49 83 fd 02	 cmp	 r13, 2
  03dde	0f 85 2b 01 00
	00		 jne	 $LN46@PyEval_Eva
  03de4	83 f8 79	 cmp	 eax, 121		; 00000079H
  03de7	74 09		 je	 SHORT $LN45@PyEval_Eva
  03de9	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  03dec	0f 85 ae fd ff
	ff		 jne	 $fast_block_end$64879
$LN45@PyEval_Eva:

; 3029 :                 PyObject *exc, *val, *tb;
; 3030 :                 int handler = b->b_handler;

  03df2	49 63 9c 9f e0
	00 00 00	 movsxd	 rbx, DWORD PTR [r15+rbx*4+224]

; 3031 :                 /* Beware, this invalidates all b->b_* fields */
; 3032 :                 PyFrame_BlockSetup(f, EXCEPT_HANDLER, -1, STACK_LEVEL());

  03dfa	4c 8b ce	 mov	 r9, rsi
  03dfd	41 83 c8 ff	 or	 r8d, -1
  03e01	4d 2b 8f 98 00
	00 00		 sub	 r9, QWORD PTR [r15+152]
  03e08	ba 01 01 00 00	 mov	 edx, 257		; 00000101H
  03e0d	49 8b cf	 mov	 rcx, r15
  03e10	49 c1 f9 03	 sar	 r9, 3
  03e14	e8 00 00 00 00	 call	 PyFrame_BlockSetup

; 3033 :                 PUSH(tstate->exc_traceback);

  03e19	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03e20	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  03e24	48 89 06	 mov	 QWORD PTR [rsi], rax
  03e27	74 0f		 je	 SHORT $LN723@PyEval_Eva
  03e29	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  03e30	48 8b c8	 mov	 rcx, rax
  03e33	e8 00 00 00 00	 call	 prtrace
$LN723@PyEval_Eva:
  03e38	4c 8b 64 24 48	 mov	 r12, QWORD PTR co$1$[rsp]
  03e3d	48 8d 46 08	 lea	 rax, QWORD PTR [rsi+8]
  03e41	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  03e48	48 c1 f8 03	 sar	 rax, 3
  03e4c	41 3b 44 24 6c	 cmp	 eax, DWORD PTR [r12+108]
  03e51	7e 1a		 jle	 SHORT $LN724@PyEval_Eva
  03e53	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  03e5a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  03e61	41 b8 d9 0b 00
	00		 mov	 r8d, 3033		; 00000bd9H
  03e67	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN724@PyEval_Eva:

; 3034 :                 PUSH(tstate->exc_value);

  03e6d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03e74	48 8b 47 68	 mov	 rax, QWORD PTR [rdi+104]
  03e78	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
  03e7c	74 0f		 je	 SHORT $LN725@PyEval_Eva
  03e7e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  03e85	48 8b c8	 mov	 rcx, rax
  03e88	e8 00 00 00 00	 call	 prtrace
$LN725@PyEval_Eva:
  03e8d	48 8d 46 10	 lea	 rax, QWORD PTR [rsi+16]
  03e91	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  03e98	48 c1 f8 03	 sar	 rax, 3
  03e9c	41 3b 44 24 6c	 cmp	 eax, DWORD PTR [r12+108]
  03ea1	7e 1a		 jle	 SHORT $LN726@PyEval_Eva
  03ea3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  03eaa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  03eb1	41 b8 da 0b 00
	00		 mov	 r8d, 3034		; 00000bdaH
  03eb7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN726@PyEval_Eva:

; 3035 :                 if (tstate->exc_type != NULL) {

  03ebd	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  03ec1	48 85 c0	 test	 rax, rax
  03ec4	0f 84 f2 00 00
	00		 je	 $LN44@PyEval_Eva

; 3036 :                     PUSH(tstate->exc_type);

  03eca	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
  03ece	48 83 c6 18	 add	 rsi, 24
  03ed2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03ed9	74 10		 je	 SHORT $LN727@PyEval_Eva
  03edb	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03edf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  03ee6	e8 00 00 00 00	 call	 prtrace
$LN727@PyEval_Eva:
  03eeb	48 8b c6	 mov	 rax, rsi
  03eee	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  03ef5	48 c1 f8 03	 sar	 rax, 3
  03ef9	41 3b 44 24 6c	 cmp	 eax, DWORD PTR [r12+108]
  03efe	0f 8e 1b 01 00
	00		 jle	 $LN730@PyEval_Eva
  03f04	41 b8 dc 0b 00
	00		 mov	 r8d, 3036		; 00000bdcH

; 3037 :                 }
; 3038 :                 else {

  03f0a	e9 fc 00 00 00	 jmp	 $LN1063@PyEval_Eva
$LN46@PyEval_Eva:

; 3064 :             }
; 3065 :             if (b->b_type == SETUP_FINALLY) {

  03f0f	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  03f12	0f 85 88 fc ff
	ff		 jne	 $fast_block_end$64879

; 3066 :                 if (why & (WHY_RETURN | WHY_CONTINUE))

  03f18	44 8b a5 90 00
	00 00		 mov	 r12d, DWORD PTR why$1$[rbp-256]
  03f1f	41 f6 c4 28	 test	 r12b, 40		; 00000028H
  03f23	0f 84 81 02 00
	00		 je	 $LN1019@PyEval_Eva

; 3067 :                     PUSH(retval);

  03f29	48 8b 44 24 60	 mov	 rax, QWORD PTR retval$1$[rsp]
  03f2e	48 83 c6 08	 add	 rsi, 8
  03f32	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03f39	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax
  03f3d	74 10		 je	 SHORT $LN737@PyEval_Eva
  03f3f	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03f43	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  03f4a	e8 00 00 00 00	 call	 prtrace
$LN737@PyEval_Eva:
  03f4f	4c 8b 6c 24 48	 mov	 r13, QWORD PTR co$1$[rsp]
  03f54	48 8b c6	 mov	 rax, rsi
  03f57	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  03f5e	48 c1 f8 03	 sar	 rax, 3
  03f62	41 3b 45 6c	 cmp	 eax, DWORD PTR [r13+108]
  03f66	0f 8e 43 02 00
	00		 jle	 $LN738@PyEval_Eva
  03f6c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  03f73	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  03f7a	41 b8 fb 0b 00
	00		 mov	 r8d, 3067		; 00000bfbH
  03f80	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  03f86	e9 24 02 00 00	 jmp	 $LN738@PyEval_Eva
$LN841@PyEval_Eva:

; 3009 :                 why = WHY_NOT;
; 3010 :                 JUMPTO(PyLong_AS_LONG(retval));

  03f8b	48 8b 5c 24 60	 mov	 rbx, QWORD PTR retval$1$[rsp]
  03f90	c7 85 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR why$1$[rbp-256], 1
  03f9a	48 8b cb	 mov	 rcx, rbx
  03f9d	e8 00 00 00 00	 call	 PyLong_AsLong

; 3011 :                 Py_DECREF(retval);

  03fa2	48 8b cb	 mov	 rcx, rbx
  03fa5	4c 63 e0	 movsxd	 r12, eax
  03fa8	4c 03 64 24 50	 add	 r12, QWORD PTR first_instr$1$[rsp]
  03fad	4c 89 64 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r12
  03fb2	e8 00 00 00 00	 call	 _Py_DecRef

; 3012 :                 break;

  03fb7	e9 90 c2 ff ff	 jmp	 $LN1020@PyEval_Eva
$LN44@PyEval_Eva:

; 3039 :                     Py_INCREF(Py_None);

  03fbc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  03fc3	e8 00 00 00 00	 call	 _Py_IncRef

; 3040 :                     PUSH(Py_None);

  03fc8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  03fcf	48 83 c6 18	 add	 rsi, 24
  03fd3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  03fda	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax
  03fde	74 10		 je	 SHORT $LN729@PyEval_Eva
  03fe0	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  03fe4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  03feb	e8 00 00 00 00	 call	 prtrace
$LN729@PyEval_Eva:
  03ff0	48 8b c6	 mov	 rax, rsi
  03ff3	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  03ffa	48 c1 f8 03	 sar	 rax, 3
  03ffe	41 3b 44 24 6c	 cmp	 eax, DWORD PTR [r12+108]
  04003	7e 1a		 jle	 SHORT $LN730@PyEval_Eva
  04005	41 b8 e0 0b 00
	00		 mov	 r8d, 3040		; 00000be0H
$LN1063@PyEval_Eva:
  0400b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  04012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  04019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN730@PyEval_Eva:

; 3041 :                 }
; 3042 :                 PyErr_Fetch(&exc, &val, &tb);

  0401f	4c 8d 44 24 70	 lea	 r8, QWORD PTR tb$65701[rsp]
  04024	48 8d 54 24 68	 lea	 rdx, QWORD PTR val$65700[rsp]
  04029	48 8d 4d 80	 lea	 rcx, QWORD PTR exc$65699[rbp-256]
  0402d	e8 00 00 00 00	 call	 PyErr_Fetch

; 3043 :                 /* Make the raw exception data
; 3044 :                    available to the handler,
; 3045 :                    so a program can emulate the
; 3046 :                    Python main loop. */
; 3047 :                 PyErr_NormalizeException(
; 3048 :                     &exc, &val, &tb);

  04032	4c 8d 44 24 70	 lea	 r8, QWORD PTR tb$65701[rsp]
  04037	48 8d 54 24 68	 lea	 rdx, QWORD PTR val$65700[rsp]
  0403c	48 8d 4d 80	 lea	 rcx, QWORD PTR exc$65699[rbp-256]
  04040	e8 00 00 00 00	 call	 PyErr_NormalizeException

; 3049 :                 PyException_SetTraceback(val, tb);

  04045	48 8b 54 24 70	 mov	 rdx, QWORD PTR tb$65701[rsp]
  0404a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR val$65700[rsp]
  0404f	e8 00 00 00 00	 call	 PyException_SetTraceback

; 3050 :                 Py_INCREF(exc);

  04054	48 8b 4d 80	 mov	 rcx, QWORD PTR exc$65699[rbp-256]
  04058	e8 00 00 00 00	 call	 _Py_IncRef

; 3051 :                 tstate->exc_type = exc;

  0405d	4c 8b 5d 80	 mov	 r11, QWORD PTR exc$65699[rbp-256]

; 3052 :                 Py_INCREF(val);

  04061	48 8b 4c 24 68	 mov	 rcx, QWORD PTR val$65700[rsp]
  04066	4c 89 5f 60	 mov	 QWORD PTR [rdi+96], r11
  0406a	e8 00 00 00 00	 call	 _Py_IncRef

; 3053 :                 tstate->exc_value = val;
; 3054 :                 tstate->exc_traceback = tb;

  0406f	48 8b 44 24 70	 mov	 rax, QWORD PTR tb$65701[rsp]
  04074	4c 8b 5c 24 68	 mov	 r11, QWORD PTR val$65700[rsp]

; 3055 :                 if (tb == NULL)

  04079	48 85 c0	 test	 rax, rax
  0407c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  04083	48 0f 45 c8	 cmovne	 rcx, rax
  04087	4c 89 5f 68	 mov	 QWORD PTR [rdi+104], r11
  0408b	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax
  0408f	48 89 4c 24 70	 mov	 QWORD PTR tb$65701[rsp], rcx

; 3056 :                     tb = Py_None;
; 3057 :                 Py_INCREF(tb);

  04094	e8 00 00 00 00	 call	 _Py_IncRef

; 3058 :                 PUSH(tb);

  04099	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  040a0	4c 8b 5c 24 70	 mov	 r11, QWORD PTR tb$65701[rsp]
  040a5	4c 89 1e	 mov	 QWORD PTR [rsi], r11
  040a8	74 0f		 je	 SHORT $LN731@PyEval_Eva
  040aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  040b1	49 8b cb	 mov	 rcx, r11
  040b4	e8 00 00 00 00	 call	 prtrace
$LN731@PyEval_Eva:
  040b9	48 8d 46 08	 lea	 rax, QWORD PTR [rsi+8]
  040bd	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  040c4	48 c1 f8 03	 sar	 rax, 3
  040c8	41 3b 44 24 6c	 cmp	 eax, DWORD PTR [r12+108]
  040cd	7e 1a		 jle	 SHORT $LN732@PyEval_Eva
  040cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  040d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  040dd	41 b8 f2 0b 00
	00		 mov	 r8d, 3058		; 00000bf2H
  040e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN732@PyEval_Eva:

; 3059 :                 PUSH(val);

  040e9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  040f0	48 8b 44 24 68	 mov	 rax, QWORD PTR val$65700[rsp]
  040f5	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
  040f9	74 0f		 je	 SHORT $LN733@PyEval_Eva
  040fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  04102	48 8b c8	 mov	 rcx, rax
  04105	e8 00 00 00 00	 call	 prtrace
$LN733@PyEval_Eva:
  0410a	48 8d 46 10	 lea	 rax, QWORD PTR [rsi+16]
  0410e	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  04115	48 c1 f8 03	 sar	 rax, 3
  04119	41 3b 44 24 6c	 cmp	 eax, DWORD PTR [r12+108]
  0411e	7e 1a		 jle	 SHORT $LN734@PyEval_Eva
  04120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  04127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  0412e	41 b8 f3 0b 00
	00		 mov	 r8d, 3059		; 00000bf3H
  04134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN734@PyEval_Eva:

; 3060 :                 PUSH(exc);

  0413a	48 8b 45 80	 mov	 rax, QWORD PTR exc$65699[rbp-256]
  0413e	48 83 c6 18	 add	 rsi, 24
  04142	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  04149	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax
  0414d	74 10		 je	 SHORT $LN735@PyEval_Eva
  0414f	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  04153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  0415a	e8 00 00 00 00	 call	 prtrace
$LN735@PyEval_Eva:
  0415f	48 8b c6	 mov	 rax, rsi
  04162	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  04169	48 c1 f8 03	 sar	 rax, 3
  0416d	41 3b 44 24 6c	 cmp	 eax, DWORD PTR [r12+108]
  04172	7e 1a		 jle	 SHORT $LN736@PyEval_Eva
  04174	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0417b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  04182	41 b8 f4 0b 00
	00		 mov	 r8d, 3060		; 00000bf4H
  04188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN736@PyEval_Eva:

; 3061 :                 why = WHY_NOT;
; 3062 :                 JUMPTO(handler);

  0418e	4c 8b e3	 mov	 r12, rbx
  04191	c7 85 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR why$1$[rbp-256], 1
  0419b	4c 03 64 24 50	 add	 r12, QWORD PTR first_instr$1$[rsp]
  041a0	4c 89 64 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r12

; 3063 :                 break;

  041a5	e9 a2 c0 ff ff	 jmp	 $LN1020@PyEval_Eva
$LN1019@PyEval_Eva:

; 3091 :         retval = NULL;
; 3092 : 
; 3093 : fast_yield:
; 3094 :     if (co->co_flags & CO_GENERATOR && (why == WHY_YIELD || why == WHY_RETURN)) {

  041aa	4c 8b 6c 24 48	 mov	 r13, QWORD PTR co$1$[rsp]
$LN738@PyEval_Eva:

; 3068 :                 PUSH(PyLong_FromLong((long)why));

  041af	41 8b cc	 mov	 ecx, r12d
  041b2	e8 00 00 00 00	 call	 PyLong_FromLong
  041b7	48 83 c6 08	 add	 rsi, 8
  041bb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  041c2	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax
  041c6	74 10		 je	 SHORT $LN739@PyEval_Eva
  041c8	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  041cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04GHHNIPCF@push?$AA@
  041d3	e8 00 00 00 00	 call	 prtrace
$LN739@PyEval_Eva:
  041d8	48 8b c6	 mov	 rax, rsi
  041db	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  041e2	48 c1 f8 03	 sar	 rax, 3
  041e6	41 3b 45 6c	 cmp	 eax, DWORD PTR [r13+108]
  041ea	7e 1a		 jle	 SHORT $LN740@PyEval_Eva
  041ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  041f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EE@JPIFCMJD@?$AAS?$AAT?$AAA?$AAC?$AAK?$AA_?$AAL?$AAE?$AAV?$AAE?$AAL?$AA?$CI?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAs?$AAt?$AAa?$AAc?$AAk?$AAs?$AAi?$AAz@
  041fa	41 b8 fc 0b 00
	00		 mov	 r8d, 3068		; 00000bfcH
  04200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN740@PyEval_Eva:

; 3069 :                 why = WHY_NOT;
; 3070 :                 JUMPTO(b->b_handler);

  04206	4d 63 a4 9f e0
	00 00 00	 movsxd	 r12, DWORD PTR [r15+rbx*4+224]
  0420e	c7 85 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR why$1$[rbp-256], 1
  04218	4c 03 64 24 50	 add	 r12, QWORD PTR first_instr$1$[rsp]
  0421d	4c 89 64 24 40	 mov	 QWORD PTR next_instr$1$[rsp], r12

; 3071 :                 break;
; 3072 :             }
; 3073 :         } /* unwind stack */
; 3074 : 
; 3075 :         /* End the loop if we still have an error (or return) */
; 3076 : 
; 3077 :         if (why != WHY_NOT)

  04222	e9 25 c0 ff ff	 jmp	 $LN1020@PyEval_Eva
$LN74@PyEval_Eva:
  04227	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR why$1$[rbp-256]
  0422d	83 f9 01	 cmp	 ecx, 1
  04230	75 58		 jne	 SHORT $LN844@PyEval_Eva

; 3078 :             break;
; 3079 :         READ_TIMESTAMP(loop1);
; 3080 : 
; 3081 :     } /* main loop */

  04232	4c 8b 64 24 40	 mov	 r12, QWORD PTR next_instr$1$[rsp]
  04237	e9 10 c0 ff ff	 jmp	 $LN1020@PyEval_Eva
$LN390@PyEval_Eva:

; 1916 :             }
; 1917 :             /* x remains on stack, retval is value to be yielded */
; 1918 :             f->f_stacktop = stack_pointer;
; 1919 :             why = WHY_YIELD;
; 1920 :             /* and repeat... */
; 1921 :             f->f_lasti--;

  0423c	41 ff 8f d0 00
	00 00		 dec	 DWORD PTR [r15+208]
  04243	49 89 b7 a0 00
	00 00		 mov	 QWORD PTR [r15+160], rsi
  0424a	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H

; 1922 :             goto fast_yield;

  0424f	33 f6		 xor	 esi, esi
  04251	e9 be 00 00 00	 jmp	 $fast_yield$64903
$LN388@PyEval_Eva:

; 1923 : 
; 1924 :         TARGET(YIELD_VALUE)
; 1925 :             retval = POP();

  04256	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0425d	74 10		 je	 SHORT $LN607@PyEval_Eva
  0425f	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  04263	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  0426a	e8 00 00 00 00	 call	 prtrace
$LN607@PyEval_Eva:
  0426f	4c 8b 6e f8	 mov	 r13, QWORD PTR [rsi-8]
  04273	48 83 ee 08	 sub	 rsi, 8

; 1926 :             f->f_stacktop = stack_pointer;
; 1927 :             why = WHY_YIELD;

  04277	bb 40 00 00 00	 mov	 ebx, 64			; 00000040H
  0427c	49 89 b7 a0 00
	00 00		 mov	 QWORD PTR [r15+160], rsi

; 1928 :             goto fast_yield;

  04283	33 f6		 xor	 esi, esi
  04285	e9 8a 00 00 00	 jmp	 $fast_yield$64903
$LN844@PyEval_Eva:

; 3082 : 
; 3083 :     assert(why != WHY_YIELD);

  0428a	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0428d	75 1a		 jne	 SHORT $LN836@PyEval_Eva
  0428f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  04296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@MGKPFLIA@?$AAw?$AAh?$AAy?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAW?$AAH?$AAY?$AA_?$AAY?$AAI?$AAE?$AAL?$AAD?$AA?$AA@
  0429d	41 b8 0b 0c 00
	00		 mov	 r8d, 3083		; 00000c0bH
  042a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN836@PyEval_Eva:

; 3084 :     /* Pop remaining stack entries. */
; 3085 :     while (!EMPTY()) {

  042a9	48 8b c6	 mov	 rax, rsi
  042ac	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  042b3	48 c1 f8 03	 sar	 rax, 3
  042b7	85 c0		 test	 eax, eax
  042b9	74 42		 je	 SHORT $LN37@PyEval_Eva
  042bb	0f 1f 44 00 00	 npad	 5
$LL38@PyEval_Eva:

; 3086 :         v = POP();

  042c0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  042c7	74 10		 je	 SHORT $LN742@PyEval_Eva
  042c9	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  042cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03NJDAHFJE@pop?$AA@
  042d4	e8 00 00 00 00	 call	 prtrace
$LN742@PyEval_Eva:
  042d9	48 8b 4e f8	 mov	 rcx, QWORD PTR [rsi-8]
  042dd	48 83 ee 08	 sub	 rsi, 8

; 3087 :         Py_XDECREF(v);

  042e1	48 85 c9	 test	 rcx, rcx
  042e4	74 05		 je	 SHORT $LN35@PyEval_Eva
  042e6	e8 00 00 00 00	 call	 _Py_DecRef
$LN35@PyEval_Eva:

; 3084 :     /* Pop remaining stack entries. */
; 3085 :     while (!EMPTY()) {

  042eb	48 8b c6	 mov	 rax, rsi
  042ee	49 2b 87 98 00
	00 00		 sub	 rax, QWORD PTR [r15+152]
  042f5	48 c1 f8 03	 sar	 rax, 3
  042f9	85 c0		 test	 eax, eax
  042fb	75 c3		 jne	 SHORT $LL38@PyEval_Eva
$LN37@PyEval_Eva:

; 3088 :     }
; 3089 : 
; 3090 :     if (why != WHY_RETURN)

  042fd	8b 9d 90 00 00
	00		 mov	 ebx, DWORD PTR why$1$[rbp-256]
  04303	4c 8b 6c 24 60	 mov	 r13, QWORD PTR retval$1$[rsp]
  04308	be 00 00 00 00	 mov	 esi, 0
  0430d	83 fb 08	 cmp	 ebx, 8
  04310	4c 0f 45 ee	 cmovne	 r13, rsi
$fast_yield$64903:

; 3091 :         retval = NULL;
; 3092 : 
; 3093 : fast_yield:
; 3094 :     if (co->co_flags & CO_GENERATOR && (why == WHY_YIELD || why == WHY_RETURN)) {

  04314	48 8b 44 24 48	 mov	 rax, QWORD PTR co$1$[rsp]
  04319	4c 8b a4 24 40
	01 00 00	 mov	 r12, QWORD PTR [rsp+320]
  04321	f6 40 70 20	 test	 BYTE PTR [rax+112], 32	; 00000020H
  04325	74 4d		 je	 SHORT $LN975@PyEval_Eva
  04327	83 fb 40	 cmp	 ebx, 64			; 00000040H
  0432a	74 05		 je	 SHORT $LN30@PyEval_Eva
  0432c	83 fb 08	 cmp	 ebx, 8
  0432f	75 43		 jne	 SHORT $LN975@PyEval_Eva
$LN30@PyEval_Eva:

; 3095 :         /* The purpose of this block is to put aside the generator's exception
; 3096 :            state and restore that of the calling frame. If the current
; 3097 :            exception state is from the caller, we clear the exception values
; 3098 :            on the generator frame, so they are not swapped back in latter. The
; 3099 :            origin of the current exception state is determined by checking for
; 3100 :            except handler blocks, which we must be in iff a new exception
; 3101 :            state came into existence in this frame. (An uncaught exception
; 3102 :            would have why == WHY_EXCEPTION, and we wouldn't be here). */
; 3103 :         int i;
; 3104 :         for (i = 0; i < f->f_iblock; i++)

  04331	41 8b 97 d8 00
	00 00		 mov	 edx, DWORD PTR [r15+216]
  04338	8b c6		 mov	 eax, esi
  0433a	85 d2		 test	 edx, edx
  0433c	7e 19		 jle	 SHORT $LN972@PyEval_Eva
  0433e	49 8d 8f dc 00
	00 00		 lea	 rcx, QWORD PTR [r15+220]
$LL29@PyEval_Eva:

; 3105 :             if (f->f_blockstack[i].b_type == EXCEPT_HANDLER)

  04345	81 39 01 01 00
	00		 cmp	 DWORD PTR [rcx], 257	; 00000101H
  0434b	74 0a		 je	 SHORT $LN972@PyEval_Eva

; 3095 :         /* The purpose of this block is to put aside the generator's exception
; 3096 :            state and restore that of the calling frame. If the current
; 3097 :            exception state is from the caller, we clear the exception values
; 3098 :            on the generator frame, so they are not swapped back in latter. The
; 3099 :            origin of the current exception state is determined by checking for
; 3100 :            except handler blocks, which we must be in iff a new exception
; 3101 :            state came into existence in this frame. (An uncaught exception
; 3102 :            would have why == WHY_EXCEPTION, and we wouldn't be here). */
; 3103 :         int i;
; 3104 :         for (i = 0; i < f->f_iblock; i++)

  0434d	ff c0		 inc	 eax
  0434f	48 83 c1 0c	 add	 rcx, 12
  04353	3b c2		 cmp	 eax, edx
  04355	7c ee		 jl	 SHORT $LL29@PyEval_Eva
$LN972@PyEval_Eva:

; 3106 :                 break;
; 3107 :         if (i == f->f_iblock)
; 3108 :             /* We did not create this exception. */
; 3109 :             restore_and_clear_exc_state(tstate, f);

  04357	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  0435c	3b c2		 cmp	 eax, edx
  0435e	49 8b d7	 mov	 rdx, r15
  04361	48 8b cf	 mov	 rcx, rdi
  04364	75 07		 jne	 SHORT $LN25@PyEval_Eva
  04366	e8 00 00 00 00	 call	 restore_and_clear_exc_state

; 3110 :         else

  0436b	eb 0c		 jmp	 SHORT $LN24@PyEval_Eva
$LN25@PyEval_Eva:

; 3111 :             swap_exc_state(tstate, f);

  0436d	e8 00 00 00 00	 call	 swap_exc_state
  04372	eb 05		 jmp	 SHORT $LN24@PyEval_Eva
$LN975@PyEval_Eva:

; 851  :     PyThreadState *tstate = PyThreadState_GET();

  04374	48 8b 7c 24 38	 mov	 rdi, QWORD PTR tstate$1$[rsp]
$LN24@PyEval_Eva:

; 3112 :     }
; 3113 : 
; 3114 :     if (tstate->use_tracing) {

  04379	83 7f 24 00	 cmp	 DWORD PTR [rdi+36], 0
  0437d	0f 84 f4 00 00
	00		 je	 $LN6@PyEval_Eva

; 3115 :         if (tstate->c_tracefunc) {

  04383	48 8b 4f 30	 mov	 rcx, QWORD PTR [rdi+48]
  04387	48 85 c9	 test	 rcx, rcx
  0438a	74 7e		 je	 SHORT $LN19@PyEval_Eva

; 3116 :             if (why == WHY_RETURN || why == WHY_YIELD) {

  0438c	83 fb 08	 cmp	 ebx, 8
  0438f	74 21		 je	 SHORT $LN20@PyEval_Eva
  04391	83 fb 40	 cmp	 ebx, 64			; 00000040H
  04394	74 1c		 je	 SHORT $LN20@PyEval_Eva

; 3122 :                 }
; 3123 :             }
; 3124 :             else if (why == WHY_EXCEPTION) {

  04396	83 fb 02	 cmp	 ebx, 2
  04399	75 6f		 jne	 SHORT $LN19@PyEval_Eva

; 3125 :                 call_trace_protected(tstate->c_tracefunc,
; 3126 :                                      tstate->c_traceobj, f,
; 3127 :                                      PyTrace_RETURN, NULL);

  0439b	48 8b 57 40	 mov	 rdx, QWORD PTR [rdi+64]
  0439f	44 8d 4b 01	 lea	 r9d, QWORD PTR [rbx+1]
  043a3	4d 8b c7	 mov	 r8, r15
  043a6	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  043ab	e8 00 00 00 00	 call	 call_trace_protected
  043b0	eb 58		 jmp	 SHORT $LN19@PyEval_Eva
$LN20@PyEval_Eva:

; 3117 :                 if (call_trace(tstate->c_tracefunc,
; 3118 :                                tstate->c_traceobj, f,
; 3119 :                                PyTrace_RETURN, retval)) {

  043b2	48 8b 57 40	 mov	 rdx, QWORD PTR [rdi+64]
  043b6	41 b9 03 00 00
	00		 mov	 r9d, 3
  043bc	4d 8b c7	 mov	 r8, r15
  043bf	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  043c4	e8 00 00 00 00	 call	 call_trace
  043c9	85 c0		 test	 eax, eax
  043cb	74 3d		 je	 SHORT $LN19@PyEval_Eva

; 3120 :                     Py_CLEAR(retval);

  043cd	4d 85 ed	 test	 r13, r13
  043d0	74 33		 je	 SHORT $LN17@PyEval_Eva
  043d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  043d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@INLLMHPI@PyEval_EvalFrameEx?$AA@
  043e0	4d 8b cd	 mov	 r9, r13
  043e3	41 b8 30 0c 00
	00		 mov	 r8d, 3120		; 00000c30H
  043e9	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  043f1	e8 00 00 00 00	 call	 _PyParallel_Guard
  043f6	85 c0		 test	 eax, eax
  043f8	75 0b		 jne	 SHORT $LN17@PyEval_Eva
  043fa	49 8b cd	 mov	 rcx, r13
  043fd	4c 8b ee	 mov	 r13, rsi
  04400	e8 00 00 00 00	 call	 _Py_DecRef
$LN17@PyEval_Eva:

; 3121 :                     why = WHY_EXCEPTION;

  04405	bb 02 00 00 00	 mov	 ebx, 2
$LN19@PyEval_Eva:

; 3128 :             }
; 3129 :         }
; 3130 :         if (tstate->c_profilefunc) {

  0440a	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0440e	48 85 c9	 test	 rcx, rcx
  04411	74 64		 je	 SHORT $LN6@PyEval_Eva

; 3131 :             if (why == WHY_EXCEPTION)
; 3132 :                 call_trace_protected(tstate->c_profilefunc,
; 3133 :                                      tstate->c_profileobj, f,
; 3134 :                                      PyTrace_RETURN, NULL);

  04413	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  04417	41 b9 03 00 00
	00		 mov	 r9d, 3
  0441d	4d 8b c7	 mov	 r8, r15
  04420	83 fb 02	 cmp	 ebx, 2
  04423	75 0c		 jne	 SHORT $LN11@PyEval_Eva
  04425	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0442a	e8 00 00 00 00	 call	 call_trace_protected

; 3135 :             else if (call_trace(tstate->c_profilefunc,

  0442f	eb 46		 jmp	 SHORT $LN6@PyEval_Eva
$LN11@PyEval_Eva:

; 3136 :                                 tstate->c_profileobj, f,
; 3137 :                                 PyTrace_RETURN, retval)) {

  04431	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  04436	e8 00 00 00 00	 call	 call_trace
  0443b	85 c0		 test	 eax, eax
  0443d	74 38		 je	 SHORT $LN6@PyEval_Eva

; 3138 :                 Py_CLEAR(retval);

  0443f	4d 85 ed	 test	 r13, r13
  04442	74 33		 je	 SHORT $LN6@PyEval_Eva
  04444	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  0444b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@INLLMHPI@PyEval_EvalFrameEx?$AA@
  04452	4d 8b cd	 mov	 r9, r13
  04455	41 b8 42 0c 00
	00		 mov	 r8d, 3138		; 00000c42H
  0445b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  04463	e8 00 00 00 00	 call	 _PyParallel_Guard
  04468	85 c0		 test	 eax, eax
  0446a	75 0b		 jne	 SHORT $LN6@PyEval_Eva
  0446c	49 8b cd	 mov	 rcx, r13
  0446f	4c 8b ee	 mov	 r13, rsi
  04472	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@PyEval_Eva:
  04477	48 8b b4 24 88
	01 00 00	 mov	 rsi, QWORD PTR [rsp+392]
$exit_eval_frame$64503:

; 3139 :                 /* why = WHY_EXCEPTION; */
; 3140 :             }
; 3141 :         }
; 3142 :     }
; 3143 : 
; 3144 :     /* pop frame */
; 3145 : exit_eval_frame:
; 3146 :     Py_LeaveRecursiveCall();

  0447f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  04485	83 f8 64	 cmp	 eax, 100		; 00000064H
  04488	7e 05		 jle	 SHORT $LN743@PyEval_Eva
  0448a	8d 58 ce	 lea	 ebx, DWORD PTR [rax-50]
  0448d	eb 06		 jmp	 SHORT $LN744@PyEval_Eva
$LN743@PyEval_Eva:
  0448f	c1 f8 02	 sar	 eax, 2
  04492	8d 1c 40	 lea	 ebx, DWORD PTR [rax+rax*2]
$LN744@PyEval_Eva:
  04495	e8 00 00 00 00	 call	 PyThreadState_Get
  0449a	ff 48 18	 dec	 DWORD PTR [rax+24]
  0449d	39 58 18	 cmp	 DWORD PTR [rax+24], ebx
  044a0	7d 09		 jge	 SHORT $LN3@PyEval_Eva
  044a2	e8 00 00 00 00	 call	 PyThreadState_Get
  044a7	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN3@PyEval_Eva:

; 3147 :     tstate->frame = f->f_back;

  044ab	49 8b 47 70	 mov	 rax, QWORD PTR [r15+112]
  044af	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 3148 : 
; 3149 :     return retval;

  044b3	49 8b c5	 mov	 rax, r13

; 3150 : }

  044b6	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  044bd	41 5f		 pop	 r15
  044bf	41 5e		 pop	 r14
  044c1	41 5d		 pop	 r13
  044c3	5f		 pop	 rdi
  044c4	5b		 pop	 rbx
  044c5	5d		 pop	 rbp
  044c6	c3		 ret	 0
  044c7	90		 npad	 1
$LN923@PyEval_Eva:
  044c8	00 00 00 00	 DD	 $LN503@PyEval_Eva
  044cc	00 00 00 00	 DD	 $LN502@PyEval_Eva
  044d0	00 00 00 00	 DD	 $LN501@PyEval_Eva
  044d4	00 00 00 00	 DD	 $LN500@PyEval_Eva
  044d8	00 00 00 00	 DD	 $LN499@PyEval_Eva
  044dc	00 00 00 00	 DD	 $LN980@PyEval_Eva
  044e0	00 00 00 00	 DD	 $LN498@PyEval_Eva
  044e4	00 00 00 00	 DD	 $LN496@PyEval_Eva
  044e8	00 00 00 00	 DD	 $LN494@PyEval_Eva
  044ec	00 00 00 00	 DD	 $LN490@PyEval_Eva
  044f0	00 00 00 00	 DD	 $LN488@PyEval_Eva
  044f4	00 00 00 00	 DD	 $LN486@PyEval_Eva
  044f8	00 00 00 00	 DD	 $LN480@PyEval_Eva
  044fc	00 00 00 00	 DD	 $LN476@PyEval_Eva
  04500	00 00 00 00	 DD	 $LN472@PyEval_Eva
  04504	00 00 00 00	 DD	 $LN470@PyEval_Eva
  04508	00 00 00 00	 DD	 $LN482@PyEval_Eva
  0450c	00 00 00 00	 DD	 $LN484@PyEval_Eva
  04510	00 00 00 00	 DD	 $LN446@PyEval_Eva
  04514	00 00 00 00	 DD	 $LN448@PyEval_Eva
  04518	00 00 00 00	 DD	 $LN230@PyEval_Eva
  0451c	00 00 00 00	 DD	 $LN442@PyEval_Eva
  04520	00 00 00 00	 DD	 $LN438@PyEval_Eva
  04524	00 00 00 00	 DD	 $LN450@PyEval_Eva
  04528	00 00 00 00	 DD	 $LN444@PyEval_Eva
  0452c	00 00 00 00	 DD	 $LN426@PyEval_Eva
  04530	00 00 00 00	 DD	 $LN424@PyEval_Eva
  04534	00 00 00 00	 DD	 $LN468@PyEval_Eva
  04538	00 00 00 00	 DD	 $LN466@PyEval_Eva
  0453c	00 00 00 00	 DD	 $LN464@PyEval_Eva
  04540	00 00 00 00	 DD	 $LN462@PyEval_Eva
  04544	00 00 00 00	 DD	 $LN460@PyEval_Eva
  04548	00 00 00 00	 DD	 $LN452@PyEval_Eva
  0454c	00 00 00 00	 DD	 $LN165@PyEval_Eva
  04550	00 00 00 00	 DD	 $LN401@PyEval_Eva
  04554	00 00 00 00	 DD	 $LN422@PyEval_Eva
  04558	00 00 00 00	 DD	 $LN333@PyEval_Eva
  0455c	00 00 00 00	 DD	 $LN395@PyEval_Eva
  04560	00 00 00 00	 DD	 $LN436@PyEval_Eva
  04564	00 00 00 00	 DD	 $LN434@PyEval_Eva
  04568	00 00 00 00	 DD	 $LN432@PyEval_Eva
  0456c	00 00 00 00	 DD	 $LN430@PyEval_Eva
  04570	00 00 00 00	 DD	 $LN428@PyEval_Eva
  04574	00 00 00 00	 DD	 $LN156@PyEval_Eva
  04578	00 00 00 00	 DD	 $LN145@PyEval_Eva
  0457c	00 00 00 00	 DD	 $LN396@PyEval_Eva
  04580	00 00 00 00	 DD	 $LN207@PyEval_Eva
  04584	00 00 00 00	 DD	 $LN388@PyEval_Eva
  04588	00 00 00 00	 DD	 $LN367@PyEval_Eva
  0458c	00 00 00 00	 DD	 $LN1021@PyEval_Eva
  04590	00 00 00 00	 DD	 $LN387@PyEval_Eva
  04594	00 00 00 00	 DD	 $LN325@PyEval_Eva
  04598	00 00 00 00	 DD	 $LN319@PyEval_Eva
  0459c	00 00 00 00	 DD	 $LN316@PyEval_Eva
  045a0	00 00 00 00	 DD	 $LN162@PyEval_Eva
  045a4	00 00 00 00	 DD	 $LN305@PyEval_Eva
  045a8	00 00 00 00	 DD	 $LN302@PyEval_Eva
  045ac	00 00 00 00	 DD	 $LN300@PyEval_Eva
  045b0	00 00 00 00	 DD	 $LN299@PyEval_Eva
  045b4	00 00 00 00	 DD	 $LN297@PyEval_Eva
  045b8	00 00 00 00	 DD	 $LN512@PyEval_Eva
  045bc	00 00 00 00	 DD	 $LN295@PyEval_Eva
  045c0	00 00 00 00	 DD	 $LN246@PyEval_Eva
  045c4	00 00 00 00	 DD	 $LN242@PyEval_Eva
  045c8	00 00 00 00	 DD	 $LN238@PyEval_Eva
  045cc	00 00 00 00	 DD	 $LN232@PyEval_Eva
  045d0	00 00 00 00	 DD	 $LN225@PyEval_Eva
  045d4	00 00 00 00	 DD	 $LN223@PyEval_Eva
  045d8	00 00 00 00	 DD	 $LN218@PyEval_Eva
  045dc	00 00 00 00	 DD	 $LN200@PyEval_Eva
  045e0	00 00 00 00	 DD	 $LN195@PyEval_Eva
  045e4	00 00 00 00	 DD	 $LN180@PyEval_Eva
  045e8	00 00 00 00	 DD	 $LN173@PyEval_Eva
  045ec	00 00 00 00	 DD	 $LN166@PyEval_Eva
  045f0	00 00 00 00	 DD	 $LN194@PyEval_Eva
  045f4	00 00 00 00	 DD	 $LN187@PyEval_Eva
  045f8	00 00 00 00	 DD	 $LN272@PyEval_Eva
  045fc	00 00 00 00	 DD	 $LN155@PyEval_Eva
  04600	00 00 00 00	 DD	 $_setup_finally$65435
  04604	00 00 00 00	 DD	 $LN514@PyEval_Eva
  04608	00 00 00 00	 DD	 $LN511@PyEval_Eva
  0460c	00 00 00 00	 DD	 $LN262@PyEval_Eva
  04610	00 00 00 00	 DD	 $LN408@PyEval_Eva
  04614	00 00 00 00	 DD	 $LN129@PyEval_Eva
  04618	00 00 00 00	 DD	 $_make_function$65543
  0461c	00 00 00 00	 DD	 $LN97@PyEval_Eva
  04620	00 00 00 00	 DD	 $LN251@PyEval_Eva
  04624	00 00 00 00	 DD	 $LN249@PyEval_Eva
  04628	00 00 00 00	 DD	 $LN247@PyEval_Eva
  0462c	00 00 00 00	 DD	 $LN253@PyEval_Eva
  04630	00 00 00 00	 DD	 $_call_function_var_kw$65507
  04634	00 00 00 00	 DD	 $LN149@PyEval_Eva
  04638	00 00 00 00	 DD	 $LN89@PyEval_Eva
  0463c	00 00 00 00	 DD	 $LN458@PyEval_Eva
  04640	00 00 00 00	 DD	 $LN455@PyEval_Eva
  04644	00 00 00 00	 DD	 $LN228@PyEval_Eva
  04648	00 00 00 00	 DD	 $LN88@PyEval_Eva
$LN922@PyEval_Eva:
  0464c	00		 DB	 0
  0464d	01		 DB	 1
  0464e	02		 DB	 2
  0464f	03		 DB	 3
  04650	04		 DB	 4
  04651	60		 DB	 96			; 00000060H
  04652	60		 DB	 96			; 00000060H
  04653	60		 DB	 96			; 00000060H
  04654	05		 DB	 5
  04655	06		 DB	 6
  04656	07		 DB	 7
  04657	08		 DB	 8
  04658	60		 DB	 96			; 00000060H
  04659	60		 DB	 96			; 00000060H
  0465a	09		 DB	 9
  0465b	60		 DB	 96			; 00000060H
  0465c	60		 DB	 96			; 00000060H
  0465d	60		 DB	 96			; 00000060H
  0465e	0a		 DB	 10
  0465f	0b		 DB	 11
  04660	60		 DB	 96			; 00000060H
  04661	0c		 DB	 12
  04662	0d		 DB	 13
  04663	0e		 DB	 14
  04664	0f		 DB	 15
  04665	10		 DB	 16
  04666	11		 DB	 17
  04667	12		 DB	 18
  04668	13		 DB	 19
  04669	60		 DB	 96			; 00000060H
  0466a	60		 DB	 96			; 00000060H
  0466b	60		 DB	 96			; 00000060H
  0466c	60		 DB	 96			; 00000060H
  0466d	60		 DB	 96			; 00000060H
  0466e	60		 DB	 96			; 00000060H
  0466f	60		 DB	 96			; 00000060H
  04670	60		 DB	 96			; 00000060H
  04671	60		 DB	 96			; 00000060H
  04672	60		 DB	 96			; 00000060H
  04673	60		 DB	 96			; 00000060H
  04674	60		 DB	 96			; 00000060H
  04675	60		 DB	 96			; 00000060H
  04676	60		 DB	 96			; 00000060H
  04677	60		 DB	 96			; 00000060H
  04678	60		 DB	 96			; 00000060H
  04679	60		 DB	 96			; 00000060H
  0467a	60		 DB	 96			; 00000060H
  0467b	60		 DB	 96			; 00000060H
  0467c	60		 DB	 96			; 00000060H
  0467d	60		 DB	 96			; 00000060H
  0467e	60		 DB	 96			; 00000060H
  0467f	60		 DB	 96			; 00000060H
  04680	60		 DB	 96			; 00000060H
  04681	14		 DB	 20
  04682	15		 DB	 21
  04683	16		 DB	 22
  04684	17		 DB	 23
  04685	60		 DB	 96			; 00000060H
  04686	18		 DB	 24
  04687	19		 DB	 25
  04688	1a		 DB	 26
  04689	1b		 DB	 27
  0468a	1c		 DB	 28
  0468b	1d		 DB	 29
  0468c	1e		 DB	 30
  0468d	1f		 DB	 31
  0468e	20		 DB	 32			; 00000020H
  0468f	21		 DB	 33			; 00000021H
  04690	22		 DB	 34			; 00000022H
  04691	23		 DB	 35			; 00000023H
  04692	24		 DB	 36			; 00000024H
  04693	25		 DB	 37			; 00000025H
  04694	60		 DB	 96			; 00000060H
  04695	60		 DB	 96			; 00000060H
  04696	26		 DB	 38			; 00000026H
  04697	27		 DB	 39			; 00000027H
  04698	28		 DB	 40			; 00000028H
  04699	29		 DB	 41			; 00000029H
  0469a	2a		 DB	 42			; 0000002aH
  0469b	2b		 DB	 43			; 0000002bH
  0469c	2c		 DB	 44			; 0000002cH
  0469d	60		 DB	 96			; 00000060H
  0469e	2d		 DB	 45			; 0000002dH
  0469f	2e		 DB	 46			; 0000002eH
  046a0	60		 DB	 96			; 00000060H
  046a1	2f		 DB	 47			; 0000002fH
  046a2	30		 DB	 48			; 00000030H
  046a3	31		 DB	 49			; 00000031H
  046a4	32		 DB	 50			; 00000032H
  046a5	33		 DB	 51			; 00000033H
  046a6	34		 DB	 52			; 00000034H
  046a7	35		 DB	 53			; 00000035H
  046a8	36		 DB	 54			; 00000036H
  046a9	37		 DB	 55			; 00000037H
  046aa	38		 DB	 56			; 00000038H
  046ab	39		 DB	 57			; 00000039H
  046ac	3a		 DB	 58			; 0000003aH
  046ad	3b		 DB	 59			; 0000003bH
  046ae	60		 DB	 96			; 00000060H
  046af	3c		 DB	 60			; 0000003cH
  046b0	3d		 DB	 61			; 0000003dH
  046b1	3e		 DB	 62			; 0000003eH
  046b2	3f		 DB	 63			; 0000003fH
  046b3	40		 DB	 64			; 00000040H
  046b4	41		 DB	 65			; 00000041H
  046b5	42		 DB	 66			; 00000042H
  046b6	43		 DB	 67			; 00000043H
  046b7	44		 DB	 68			; 00000044H
  046b8	45		 DB	 69			; 00000045H
  046b9	46		 DB	 70			; 00000046H
  046ba	47		 DB	 71			; 00000047H
  046bb	48		 DB	 72			; 00000048H
  046bc	49		 DB	 73			; 00000049H
  046bd	4a		 DB	 74			; 0000004aH
  046be	4b		 DB	 75			; 0000004bH
  046bf	4c		 DB	 76			; 0000004cH
  046c0	60		 DB	 96			; 00000060H
  046c1	60		 DB	 96			; 00000060H
  046c2	4d		 DB	 77			; 0000004dH
  046c3	4e		 DB	 78			; 0000004eH
  046c4	4e		 DB	 78			; 0000004eH
  046c5	4e		 DB	 78			; 0000004eH
  046c6	60		 DB	 96			; 00000060H
  046c7	4f		 DB	 79			; 0000004fH
  046c8	50		 DB	 80			; 00000050H
  046c9	51		 DB	 81			; 00000051H
  046ca	60		 DB	 96			; 00000060H
  046cb	60		 DB	 96			; 00000060H
  046cc	60		 DB	 96			; 00000060H
  046cd	52		 DB	 82			; 00000052H
  046ce	53		 DB	 83			; 00000053H
  046cf	54		 DB	 84			; 00000054H
  046d0	55		 DB	 85			; 00000055H
  046d1	54		 DB	 84			; 00000054H
  046d2	56		 DB	 86			; 00000056H
  046d3	57		 DB	 87			; 00000057H
  046d4	58		 DB	 88			; 00000058H
  046d5	59		 DB	 89			; 00000059H
  046d6	60		 DB	 96			; 00000060H
  046d7	5a		 DB	 90			; 0000005aH
  046d8	5a		 DB	 90			; 0000005aH
  046d9	5a		 DB	 90			; 0000005aH
  046da	5b		 DB	 91			; 0000005bH
  046db	5c		 DB	 92			; 0000005cH
  046dc	5d		 DB	 93			; 0000005dH
  046dd	5e		 DB	 94			; 0000005eH
  046de	5f		 DB	 95			; 0000005fH
PyEval_EvalFrameEx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@FPJFGDDC@PyEval_EvalCodeEx?$AA@	; `string'
PUBLIC	??_C@_0BO@BBKJFGPP@?$CFU?$CI?$CJ?5keywords?5must?5be?5strings?$AA@ ; `string'
PUBLIC	??_C@_0CN@PIKAAEBK@?$CFU?$CI?$CJ?5got?5an?5unexpected?5keyword?5a@ ; `string'
PUBLIC	??_C@_0CL@EHMIHEHL@?$CFU?$CI?$CJ?5got?5multiple?5values?5for?5arg@ ; `string'
PUBLIC	??_C@_1BO@DAMCKEEB@?$AAt?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CA@PDMMIOFM@PyEval_EvalCodeEx?3?5NULL?5globals?$AA@ ; `string'
EXTRN	PyGen_New:PROC
EXTRN	PyCell_New:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	PyObject_RichCompareBool:PROC
EXTRN	PyFrame_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_EvalCodeEx DD imagerel $LN168
	DD	imagerel $LN168+1676
	DD	imagerel $unwind$PyEval_EvalCodeEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_EvalCodeEx DD 0a1401H
	DD	0163414H
	DD	0f010b214H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
;	COMDAT ??_C@_0BC@FPJFGDDC@PyEval_EvalCodeEx?$AA@
CONST	SEGMENT
??_C@_0BC@FPJFGDDC@PyEval_EvalCodeEx?$AA@ DB 'PyEval_EvalCodeEx', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BBKJFGPP@?$CFU?$CI?$CJ?5keywords?5must?5be?5strings?$AA@
CONST	SEGMENT
??_C@_0BO@BBKJFGPP@?$CFU?$CI?$CJ?5keywords?5must?5be?5strings?$AA@ DB '%U'
	DB	'() keywords must be strings', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@PIKAAEBK@?$CFU?$CI?$CJ?5got?5an?5unexpected?5keyword?5a@
CONST	SEGMENT
??_C@_0CN@PIKAAEBK@?$CFU?$CI?$CJ?5got?5an?5unexpected?5keyword?5a@ DB '%U'
	DB	'() got an unexpected keyword argument ''%S''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EHMIHEHL@?$CFU?$CI?$CJ?5got?5multiple?5values?5for?5arg@
CONST	SEGMENT
??_C@_0CL@EHMIHEHL@?$CFU?$CI?$CJ?5got?5multiple?5values?5for?5arg@ DB '%U'
	DB	'() got multiple values for argument ''%S''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@DAMCKEEB@?$AAt?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@DAMCKEEB@?$AAt?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 't'
	DB	00H, 's', 00H, 't', 00H, 'a', 00H, 't', 00H, 'e', 00H, ' ', 00H
	DB	'!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@PDMMIOFM@PyEval_EvalCodeEx?3?5NULL?5globals?$AA@
CONST	SEGMENT
??_C@_0CA@PDMMIOFM@PyEval_EvalCodeEx?3?5NULL?5globals?$AA@ DB 'PyEval_Eva'
	DB	'lCodeEx: NULL globals', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_EvalCodeEx
_TEXT	SEGMENT
f$1$ = 48
value$1$ = 56
kwdict$1$ = 64
$T69148 = 72
freevars$1$ = 80
tstate$1$ = 88
total_args$1$ = 160
_co$ = 160
i$2$ = 168
globals$ = 168
locals$ = 176
args$ = 184
argcount$ = 192
kws$ = 200
kwcount$ = 208
defs$ = 216
defcount$ = 224
kwdefs$ = 232
closure$ = 240
PyEval_EvalCodeEx PROC					; COMDAT

; 3310 : {

$LN168:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00014	4d 8b f1	 mov	 r14, r9
  00017	49 8b f8	 mov	 rdi, r8
  0001a	48 8b da	 mov	 rbx, rdx
  0001d	4c 8b e9	 mov	 r13, rcx

; 3311 :     PyCodeObject* co = (PyCodeObject*)_co;
; 3312 :     register PyFrameObject *f;
; 3313 :     register PyObject *retval = NULL;

  00020	45 33 e4	 xor	 r12d, r12d

; 3314 :     register PyObject **fastlocals, **freevars;
; 3315 :     PyThreadState *tstate = PyThreadState_GET();

  00023	e8 00 00 00 00	 call	 PyThreadState_Get

; 3316 :     PyObject *x, *u;
; 3317 :     int total_args = co->co_argcount + co->co_kwonlyargcount;

  00028	41 8b 75 64	 mov	 esi, DWORD PTR [r13+100]

; 3318 :     int i;
; 3319 :     int n = argcount;

  0002c	8b ac 24 c0 00
	00 00		 mov	 ebp, DWORD PTR argcount$[rsp]

; 3320 :     PyObject *kwdict = NULL;

  00033	4c 89 64 24 40	 mov	 QWORD PTR kwdict$1$[rsp], r12
  00038	41 03 75 60	 add	 esi, DWORD PTR [r13+96]
  0003c	4c 8b f8	 mov	 r15, rax
  0003f	48 89 44 24 58	 mov	 QWORD PTR tstate$1$[rsp], rax
  00044	89 b4 24 a0 00
	00 00		 mov	 DWORD PTR total_args$1$[rsp], esi

; 3321 : 
; 3322 :     if (globals == NULL) {

  0004b	48 85 db	 test	 rbx, rbx
  0004e	75 1a		 jne	 SHORT $LN123@PyEval_Eva@2

; 3323 :         PyErr_SetString(PyExc_SystemError,
; 3324 :                         "PyEval_EvalCodeEx: NULL globals");

  00050	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@PDMMIOFM@PyEval_EvalCodeEx?3?5NULL?5globals?$AA@
  0005e	e8 00 00 00 00	 call	 PyErr_SetString
$LN166@PyEval_Eva@2:

; 3325 :         return NULL;

  00063	33 c0		 xor	 eax, eax
  00065	e9 36 03 00 00	 jmp	 $LN124@PyEval_Eva@2
$LN123@PyEval_Eva@2:

; 3326 :     }
; 3327 : 
; 3328 :     assert(tstate != NULL);

  0006a	48 85 c0	 test	 rax, rax
  0006d	75 1a		 jne	 SHORT $LN126@PyEval_Eva@2
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@DAMCKEEB@?$AAt?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0007d	41 b8 00 0d 00
	00		 mov	 r8d, 3328		; 00000d00H
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN126@PyEval_Eva@2:

; 3329 :     assert(globals != NULL);
; 3330 :     f = PyFrame_New(tstate, co, globals, locals);

  00089	4c 8b cf	 mov	 r9, rdi
  0008c	4c 8b c3	 mov	 r8, rbx
  0008f	49 8b d5	 mov	 rdx, r13
  00092	49 8b cf	 mov	 rcx, r15
  00095	e8 00 00 00 00	 call	 PyFrame_New
  0009a	48 8b d8	 mov	 rbx, rax
  0009d	48 89 44 24 30	 mov	 QWORD PTR f$1$[rsp], rax

; 3331 :     if (f == NULL)

  000a2	48 85 c0	 test	 rax, rax

; 3332 :         return NULL;

  000a5	74 bc		 je	 SHORT $LN166@PyEval_Eva@2

; 3333 : 
; 3334 :     fastlocals = f->f_localsplus;
; 3335 :     freevars = f->f_localsplus + co->co_nlocals;
; 3336 : 
; 3337 :     /* Parse arguments. */
; 3338 :     if (co->co_flags & CO_VARKEYWORDS) {

  000a7	41 f6 45 70 08	 test	 BYTE PTR [r13+112], 8
  000ac	4c 8d b8 d0 01
	00 00		 lea	 r15, QWORD PTR [rax+464]
  000b3	49 63 45 68	 movsxd	 rax, DWORD PTR [r13+104]
  000b7	48 8d 84 c3 d0
	01 00 00	 lea	 rax, QWORD PTR [rbx+rax*8+464]
  000bf	48 89 44 24 50	 mov	 QWORD PTR freevars$1$[rsp], rax
  000c4	74 3d		 je	 SHORT $LN116@PyEval_Eva@2

; 3339 :         kwdict = PyDict_New();

  000c6	e8 00 00 00 00	 call	 PyDict_New
  000cb	48 8b e8	 mov	 rbp, rax
  000ce	48 89 44 24 40	 mov	 QWORD PTR kwdict$1$[rsp], rax

; 3340 :         if (kwdict == NULL)

  000d3	48 85 c0	 test	 rax, rax
  000d6	0f 84 8f 02 00
	00		 je	 $fail$65991

; 3341 :             goto fail;
; 3342 :         i = total_args;
; 3343 :         if (co->co_flags & CO_VARARGS)

  000dc	41 f6 45 70 04	 test	 BYTE PTR [r13+112], 4
  000e1	8b c6		 mov	 eax, esi
  000e3	74 03		 je	 SHORT $LN118@PyEval_Eva@2

; 3344 :             i++;

  000e5	8d 46 01	 lea	 eax, DWORD PTR [rsi+1]
$LN118@PyEval_Eva@2:

; 3345 :         SETLOCAL(i, kwdict);

  000e8	48 98		 cdqe
  000ea	49 8b 0c c7	 mov	 rcx, QWORD PTR [r15+rax*8]
  000ee	49 89 2c c7	 mov	 QWORD PTR [r15+rax*8], rbp
  000f2	48 85 c9	 test	 rcx, rcx
  000f5	74 05		 je	 SHORT $LN114@PyEval_Eva@2
  000f7	e8 00 00 00 00	 call	 _Py_DecRef
$LN114@PyEval_Eva@2:
  000fc	8b ac 24 c0 00
	00 00		 mov	 ebp, DWORD PTR argcount$[rsp]
$LN116@PyEval_Eva@2:

; 3346 :     }
; 3347 :     if (argcount > co->co_argcount)

  00103	41 8b 45 60	 mov	 eax, DWORD PTR [r13+96]
  00107	8b cd		 mov	 ecx, ebp
  00109	3b e8		 cmp	 ebp, eax
  0010b	0f 4f c8	 cmovg	 ecx, eax
  0010e	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR i$2$[rsp], ecx

; 3348 :         n = co->co_argcount;
; 3349 :     for (i = 0; i < n; i++) {

  00115	4c 63 e1	 movsxd	 r12, ecx
  00118	85 c9		 test	 ecx, ecx
  0011a	7e 4e		 jle	 SHORT $LN108@PyEval_Eva@2
  0011c	49 8b ee	 mov	 rbp, r14

; 3350 :         x = args[i];

  0011f	49 8b ff	 mov	 rdi, r15
  00122	49 8b f4	 mov	 rsi, r12
  00125	49 2b ef	 sub	 rbp, r15
  00128	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL110@PyEval_Eva@2:
  00130	48 8b 1c 2f	 mov	 rbx, QWORD PTR [rdi+rbp]

; 3351 :         Py_INCREF(x);

  00134	48 8b cb	 mov	 rcx, rbx
  00137	e8 00 00 00 00	 call	 _Py_IncRef

; 3352 :         SETLOCAL(i, x);

  0013c	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0013f	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00142	48 85 c9	 test	 rcx, rcx
  00145	74 05		 je	 SHORT $LN103@PyEval_Eva@2
  00147	e8 00 00 00 00	 call	 _Py_DecRef
$LN103@PyEval_Eva@2:

; 3348 :         n = co->co_argcount;
; 3349 :     for (i = 0; i < n; i++) {

  0014c	48 83 c7 08	 add	 rdi, 8
  00150	48 ff ce	 dec	 rsi
  00153	75 db		 jne	 SHORT $LL110@PyEval_Eva@2
  00155	8b b4 24 a0 00
	00 00		 mov	 esi, DWORD PTR total_args$1$[rsp]
  0015c	8b ac 24 c0 00
	00 00		 mov	 ebp, DWORD PTR argcount$[rsp]
  00163	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR i$2$[rsp]
$LN108@PyEval_Eva@2:

; 3353 :     }
; 3354 :     if (co->co_flags & CO_VARARGS) {

  0016a	41 f6 45 70 04	 test	 BYTE PTR [r13+112], 4
  0016f	74 67		 je	 SHORT $LN89@PyEval_Eva@2

; 3355 :         u = PyTuple_New(argcount - n);

  00171	8b c5		 mov	 eax, ebp
  00173	2b c1		 sub	 eax, ecx
  00175	48 63 c8	 movsxd	 rcx, eax
  00178	e8 00 00 00 00	 call	 PyTuple_New
  0017d	48 8b d8	 mov	 rbx, rax

; 3356 :         if (u == NULL)

  00180	48 85 c0	 test	 rax, rax
  00183	0f 84 da 01 00
	00		 je	 $LN162@PyEval_Eva@2

; 3357 :             goto fail;
; 3358 :         SETLOCAL(total_args, u);

  00189	48 63 c6	 movsxd	 rax, esi
  0018c	49 8b 0c c7	 mov	 rcx, QWORD PTR [r15+rax*8]
  00190	49 89 1c c7	 mov	 QWORD PTR [r15+rax*8], rbx
  00194	48 85 c9	 test	 rcx, rcx
  00197	74 05		 je	 SHORT $LN94@PyEval_Eva@2
  00199	e8 00 00 00 00	 call	 _Py_DecRef
$LN94@PyEval_Eva@2:

; 3359 :         for (i = n; i < argcount; i++) {

  0019e	48 63 f5	 movsxd	 rsi, ebp
  001a1	4c 3b e6	 cmp	 r12, rsi
  001a4	7d 32		 jge	 SHORT $LN89@PyEval_Eva@2
  001a6	bd 0e 00 00 00	 mov	 ebp, 14
  001ab	4b 8d 3c e6	 lea	 rdi, QWORD PTR [r14+r12*8]
  001af	49 2b ec	 sub	 rbp, r12
  001b2	48 c1 e5 03	 shl	 rbp, 3
  001b6	49 2b ee	 sub	 rbp, r14
  001b9	48 03 eb	 add	 rbp, rbx
  001bc	49 2b f4	 sub	 rsi, r12
  001bf	90		 npad	 1
$LL91@PyEval_Eva@2:

; 3360 :             x = args[i];

  001c0	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]

; 3361 :             Py_INCREF(x);

  001c3	48 8b cb	 mov	 rcx, rbx
  001c6	e8 00 00 00 00	 call	 _Py_IncRef

; 3362 :             PyTuple_SET_ITEM(u, i-n, x);

  001cb	48 89 1c 2f	 mov	 QWORD PTR [rdi+rbp], rbx
  001cf	48 83 c7 08	 add	 rdi, 8
  001d3	48 ff ce	 dec	 rsi
  001d6	75 e8		 jne	 SHORT $LL91@PyEval_Eva@2
$LN89@PyEval_Eva@2:

; 3363 :         }
; 3364 :     }
; 3365 :     for (i = 0; i < kwcount; i++) {

  001d8	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR kwcount$[rsp]

; 3379 :         for (j = 0; j < total_args; j++) {

  001e0	4c 63 b4 24 a0
	00 00 00	 movsxd	 r14, DWORD PTR total_args$1$[rsp]
  001e8	45 33 e4	 xor	 r12d, r12d
  001eb	4c 89 64 24 48	 mov	 QWORD PTR $T69148[rsp], r12
  001f0	48 85 c0	 test	 rax, rax
  001f3	0f 8e ea 00 00
	00		 jle	 $LN86@PyEval_Eva@2

; 3363 :         }
; 3364 :     }
; 3365 :     for (i = 0; i < kwcount; i++) {

  001f9	4c 8b a4 24 c8
	00 00 00	 mov	 r12, QWORD PTR kws$[rsp]
$LL88@PyEval_Eva@2:

; 3366 :         PyObject **co_varnames;
; 3367 :         PyObject *keyword = kws[2*i];

  00201	49 8b 34 24	 mov	 rsi, QWORD PTR [r12]

; 3368 :         PyObject *value = kws[2*i + 1];

  00205	49 8b 4c 24 08	 mov	 rcx, QWORD PTR [r12+8]
  0020a	48 89 4c 24 38	 mov	 QWORD PTR value$1$[rsp], rcx

; 3369 :         int j;
; 3370 :         if (keyword == NULL || !PyUnicode_Check(keyword)) {

  0020f	48 85 f6	 test	 rsi, rsi
  00212	0f 84 b3 01 00
	00		 je	 $LN84@PyEval_Eva@2
  00218	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  0021c	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00226	0f 84 9f 01 00
	00		 je	 $LN84@PyEval_Eva@2

; 3375 :         }
; 3376 :         /* Speed hack: do raw pointer compares. As names are
; 3377 :            normally interned this should almost always hit. */
; 3378 :         co_varnames = ((PyTupleObject *)(co->co_varnames))->ob_item;

  0022c	49 8b ad 90 00
	00 00		 mov	 rbp, QWORD PTR [r13+144]

; 3379 :         for (j = 0; j < total_args; j++) {

  00233	33 c0		 xor	 eax, eax
  00235	8b d8		 mov	 ebx, eax
  00237	4d 85 f6	 test	 r14, r14
  0023a	7e 17		 jle	 SHORT $LN81@PyEval_Eva@2
  0023c	0f 1f 40 00	 npad	 4
$LL83@PyEval_Eva@2:

; 3380 :             PyObject *nm = co_varnames[j];
; 3381 :             if (nm == keyword)

  00240	48 39 74 dd 70	 cmp	 QWORD PTR [rbp+rbx*8+112], rsi
  00245	0f 84 d3 00 00
	00		 je	 $kw_found$66051

; 3379 :         for (j = 0; j < total_args; j++) {

  0024b	48 ff c3	 inc	 rbx
  0024e	49 3b de	 cmp	 rbx, r14
  00251	7c ed		 jl	 SHORT $LL83@PyEval_Eva@2
$LN81@PyEval_Eva@2:

; 3382 :                 goto kw_found;
; 3383 :         }
; 3384 :         /* Slow fallback, just in case */
; 3385 :         for (j = 0; j < total_args; j++) {

  00253	8b f8		 mov	 edi, eax
  00255	48 8b d8	 mov	 rbx, rax
  00258	4d 85 f6	 test	 r14, r14
  0025b	7e 33		 jle	 SHORT $LN77@PyEval_Eva@2
  0025d	0f 1f 00	 npad	 3
$LL79@PyEval_Eva@2:

; 3386 :             PyObject *nm = co_varnames[j];
; 3387 :             int cmp = PyObject_RichCompareBool(
; 3388 :                 keyword, nm, Py_EQ);

  00260	48 8b 54 dd 70	 mov	 rdx, QWORD PTR [rbp+rbx*8+112]
  00265	41 b8 02 00 00
	00		 mov	 r8d, 2
  0026b	48 8b ce	 mov	 rcx, rsi
  0026e	e8 00 00 00 00	 call	 PyObject_RichCompareBool

; 3389 :             if (cmp > 0)

  00273	85 c0		 test	 eax, eax
  00275	0f 8f 9e 00 00
	00		 jg	 $LN158@PyEval_Eva@2

; 3390 :                 goto kw_found;
; 3391 :             else if (cmp < 0)

  0027b	0f 88 e2 00 00
	00		 js	 $LN162@PyEval_Eva@2

; 3382 :                 goto kw_found;
; 3383 :         }
; 3384 :         /* Slow fallback, just in case */
; 3385 :         for (j = 0; j < total_args; j++) {

  00281	48 ff c3	 inc	 rbx
  00284	ff c7		 inc	 edi
  00286	49 3b de	 cmp	 rbx, r14
  00289	7c d5		 jl	 SHORT $LL79@PyEval_Eva@2

; 3481 :         }
; 3482 :         if (c == NULL)

  0028b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR value$1$[rsp]
$LN77@PyEval_Eva@2:

; 3392 :                 goto fail;
; 3393 :         }
; 3394 :         if (j >= total_args && kwdict == NULL) {

  00290	48 8b 44 24 40	 mov	 rax, QWORD PTR kwdict$1$[rsp]
  00295	3b bc 24 a0 00
	00 00		 cmp	 edi, DWORD PTR total_args$1$[rsp]
  0029c	7c 09		 jl	 SHORT $LN73@PyEval_Eva@2
  0029e	48 85 c0	 test	 rax, rax
  002a1	0f 84 11 01 00
	00		 je	 $LN144@PyEval_Eva@2
$LN73@PyEval_Eva@2:

; 3401 :         }
; 3402 :         if (PyDict_SetItem(kwdict, keyword, value) == -1) {

  002a7	4c 8b c1	 mov	 r8, rcx
  002aa	48 8b d6	 mov	 rdx, rsi
  002ad	48 8b c8	 mov	 rcx, rax
  002b0	e8 00 00 00 00	 call	 PyDict_SetItem
  002b5	83 f8 ff	 cmp	 eax, -1
  002b8	0f 84 a5 00 00
	00		 je	 $LN162@PyEval_Eva@2
$LN87@PyEval_Eva@2:

; 3363 :         }
; 3364 :     }
; 3365 :     for (i = 0; i < kwcount; i++) {

  002be	48 8b 44 24 48	 mov	 rax, QWORD PTR $T69148[rsp]
  002c3	48 63 8c 24 d0
	00 00 00	 movsxd	 rcx, DWORD PTR kwcount$[rsp]
  002cb	49 83 c4 10	 add	 r12, 16
  002cf	48 ff c0	 inc	 rax
  002d2	48 89 44 24 48	 mov	 QWORD PTR $T69148[rsp], rax
  002d7	48 3b c1	 cmp	 rax, rcx
  002da	0f 8c 21 ff ff
	ff		 jl	 $LL88@PyEval_Eva@2

; 3481 :         }
; 3482 :         if (c == NULL)

  002e0	45 33 e4	 xor	 r12d, r12d
$LN86@PyEval_Eva@2:

; 3418 :     if (argcount > co->co_argcount && !(co->co_flags & CO_VARARGS)) {

  002e3	41 8b 4d 60	 mov	 ecx, DWORD PTR [r13+96]
  002e7	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR argcount$[rsp]
  002ef	3b c1		 cmp	 eax, ecx
  002f1	0f 8e f5 00 00
	00		 jle	 $LN165@PyEval_Eva@2
  002f7	41 f6 45 70 04	 test	 BYTE PTR [r13+112], 4
  002fc	0f 85 e8 00 00
	00		 jne	 $LN63@PyEval_Eva@2

; 3419 :         too_many_positional(co, argcount, defcount, fastlocals);

  00302	44 8b 84 24 e0
	00 00 00	 mov	 r8d, DWORD PTR defcount$[rsp]
  0030a	4d 8b cf	 mov	 r9, r15
  0030d	8b d0		 mov	 edx, eax
  0030f	49 8b cd	 mov	 rcx, r13
  00312	e8 00 00 00 00	 call	 too_many_positional

; 3420 :         goto fail;

  00317	eb 4d		 jmp	 SHORT $LN164@PyEval_Eva@2
$LN158@PyEval_Eva@2:

; 3481 :         }
; 3482 :         if (c == NULL)

  00319	48 8b 4c 24 38	 mov	 rcx, QWORD PTR value$1$[rsp]
$kw_found$66051:

; 3403 :             goto fail;
; 3404 :         }
; 3405 :         continue;
; 3406 :       kw_found:
; 3407 :         if (GETLOCAL(j) != NULL) {

  0031e	49 83 3c df 00	 cmp	 QWORD PTR [r15+rbx*8], 0
  00323	75 21		 jne	 SHORT $LN143@PyEval_Eva@2

; 3413 :             goto fail;
; 3414 :         }
; 3415 :         Py_INCREF(value);

  00325	e8 00 00 00 00	 call	 _Py_IncRef

; 3416 :         SETLOCAL(j, value);

  0032a	49 8b 0c df	 mov	 rcx, QWORD PTR [r15+rbx*8]
  0032e	48 8b 44 24 38	 mov	 rax, QWORD PTR value$1$[rsp]
  00333	49 89 04 df	 mov	 QWORD PTR [r15+rbx*8], rax
  00337	48 85 c9	 test	 rcx, rcx
  0033a	74 82		 je	 SHORT $LN87@PyEval_Eva@2
  0033c	e8 00 00 00 00	 call	 _Py_DecRef

; 3417 :     }

  00341	e9 78 ff ff ff	 jmp	 $LN87@PyEval_Eva@2
$LN143@PyEval_Eva@2:

; 3408 :             PyErr_Format(PyExc_TypeError,
; 3409 :                          "%U() got multiple "
; 3410 :                          "values for argument '%S'",
; 3411 :                          co->co_name,
; 3412 :                          keyword);

  00346	4d 8b 85 b8 00
	00 00		 mov	 r8, QWORD PTR [r13+184]
  0034d	4c 8b ce	 mov	 r9, rsi
  00350	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@EHMIHEHL@?$CFU?$CI?$CJ?5got?5multiple?5values?5for?5arg@
$LN167@PyEval_Eva@2:

; 3395 :             PyErr_Format(PyExc_TypeError,
; 3396 :                          "%U() got an unexpected "
; 3397 :                          "keyword argument '%S'",
; 3398 :                          co->co_name,
; 3399 :                          keyword);

  00357	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0035e	e8 00 00 00 00	 call	 PyErr_Format
$LN162@PyEval_Eva@2:

; 3502 :     }
; 3503 : 
; 3504 :     retval = PyEval_EvalFrameEx(f,0);

  00363	45 33 e4	 xor	 r12d, r12d
$LN164@PyEval_Eva@2:

; 3329 :     assert(globals != NULL);
; 3330 :     f = PyFrame_New(tstate, co, globals, locals);

  00366	48 8b 5c 24 30	 mov	 rbx, QWORD PTR f$1$[rsp]
$fail$65991:

; 3505 : 
; 3506 : fail: /* Jump here from prelude on failure */
; 3507 : 
; 3508 :     /* decref'ing the frame can cause __del__ methods to get invoked,
; 3509 :        which can call back into Python.  While we're done with the
; 3510 :        current Python frame (f), the associated C stack is still in use,
; 3511 :        so recursion_depth must be boosted for the duration.
; 3512 :     */
; 3513 :     assert(tstate != NULL);

  0036b	48 8b 7c 24 58	 mov	 rdi, QWORD PTR tstate$1$[rsp]
  00370	48 85 ff	 test	 rdi, rdi
  00373	75 1a		 jne	 SHORT $LN128@PyEval_Eva@2
  00375	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0037c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@DAMCKEEB@?$AAt?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  00383	41 b8 b9 0d 00
	00		 mov	 r8d, 3513		; 00000db9H
  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN128@PyEval_Eva@2:

; 3514 :     ++tstate->recursion_depth;

  0038f	ff 47 18	 inc	 DWORD PTR [rdi+24]

; 3515 :     Py_DECREF(f);

  00392	48 8b cb	 mov	 rcx, rbx
  00395	e8 00 00 00 00	 call	 _Py_DecRef

; 3516 :     --tstate->recursion_depth;

  0039a	ff 4f 18	 dec	 DWORD PTR [rdi+24]

; 3517 :     return retval;

  0039d	49 8b c4	 mov	 rax, r12
$LN124@PyEval_Eva@2:

; 3518 : }

  003a0	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+176]
  003a8	48 83 c4 60	 add	 rsp, 96			; 00000060H
  003ac	41 5f		 pop	 r15
  003ae	41 5e		 pop	 r14
  003b0	41 5d		 pop	 r13
  003b2	41 5c		 pop	 r12
  003b4	5f		 pop	 rdi
  003b5	5e		 pop	 rsi
  003b6	5d		 pop	 rbp
  003b7	c3		 ret	 0
$LN144@PyEval_Eva@2:

; 3395 :             PyErr_Format(PyExc_TypeError,
; 3396 :                          "%U() got an unexpected "
; 3397 :                          "keyword argument '%S'",
; 3398 :                          co->co_name,
; 3399 :                          keyword);

  003b8	4d 8b 85 b8 00
	00 00		 mov	 r8, QWORD PTR [r13+184]
  003bf	4c 8b ce	 mov	 r9, rsi
  003c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@PIKAAEBK@?$CFU?$CI?$CJ?5got?5an?5unexpected?5keyword?5a@

; 3400 :             goto fail;

  003c9	eb 8c		 jmp	 SHORT $LN167@PyEval_Eva@2
$LN84@PyEval_Eva@2:

; 3371 :             PyErr_Format(PyExc_TypeError,
; 3372 :                          "%U() keywords must be strings",
; 3373 :                          co->co_name);

  003cb	4d 8b 85 b8 00
	00 00		 mov	 r8, QWORD PTR [r13+184]
  003d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  003d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@BBKJFGPP@?$CFU?$CI?$CJ?5keywords?5must?5be?5strings?$AA@
  003e0	e8 00 00 00 00	 call	 PyErr_Format

; 3374 :             goto fail;

  003e5	e9 79 ff ff ff	 jmp	 $LN162@PyEval_Eva@2
$LN63@PyEval_Eva@2:

; 3421 :     }
; 3422 :     if (argcount < co->co_argcount) {

  003ea	3b c1		 cmp	 eax, ecx
$LN165@PyEval_Eva@2:
  003ec	0f 8d a9 00 00
	00		 jge	 $LN52@PyEval_Eva@2

; 3423 :         int m = co->co_argcount - defcount;

  003f2	4c 63 84 24 e0
	00 00 00	 movsxd	 r8, DWORD PTR defcount$[rsp]

; 3424 :         int missing = 0;

  003fa	41 8b d4	 mov	 edx, r12d
  003fd	41 2b c8	 sub	 ecx, r8d

; 3425 :         for (i = argcount; i < m; i++)

  00400	4c 63 c9	 movsxd	 r9, ecx
  00403	49 3b c1	 cmp	 rax, r9
  00406	7d 25		 jge	 SHORT $LN57@PyEval_Eva@2
$LL61@PyEval_Eva@2:

; 3426 :             if (GETLOCAL(i) == NULL)

  00408	49 83 3c c7 00	 cmp	 QWORD PTR [r15+rax*8], 0
  0040d	75 02		 jne	 SHORT $LN60@PyEval_Eva@2

; 3427 :                 missing++;

  0040f	ff c2		 inc	 edx
$LN60@PyEval_Eva@2:

; 3425 :         for (i = argcount; i < m; i++)

  00411	48 ff c0	 inc	 rax
  00414	49 3b c1	 cmp	 rax, r9
  00417	7c ef		 jl	 SHORT $LL61@PyEval_Eva@2

; 3428 :         if (missing) {

  00419	85 d2		 test	 edx, edx
  0041b	74 10		 je	 SHORT $LN57@PyEval_Eva@2

; 3429 :             missing_arguments(co, missing, defcount, fastlocals);

  0041d	4d 8b cf	 mov	 r9, r15
  00420	49 8b cd	 mov	 rcx, r13
  00423	e8 00 00 00 00	 call	 missing_arguments

; 3430 :             goto fail;

  00428	e9 39 ff ff ff	 jmp	 $LN164@PyEval_Eva@2
$LN57@PyEval_Eva@2:

; 3431 :         }
; 3432 :         if (n > m)

  0042d	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR i$2$[rsp]
  00434	3b c1		 cmp	 eax, ecx
  00436	7e 04		 jle	 SHORT $LN56@PyEval_Eva@2

; 3433 :             i = n - m;

  00438	2b c1		 sub	 eax, ecx

; 3434 :         else

  0043a	eb 03		 jmp	 SHORT $LN55@PyEval_Eva@2
$LN56@PyEval_Eva@2:

; 3435 :             i = 0;

  0043c	41 8b c4	 mov	 eax, r12d
$LN55@PyEval_Eva@2:
  0043f	48 63 c8	 movsxd	 rcx, eax

; 3436 :         for (; i < defcount; i++) {

  00442	49 8b f0	 mov	 rsi, r8
  00445	49 3b c8	 cmp	 rcx, r8
  00448	7d 51		 jge	 SHORT $LN52@PyEval_Eva@2
  0044a	48 8b ac 24 d8
	00 00 00	 mov	 rbp, QWORD PTR defs$[rsp]
  00452	4a 8d 04 09	 lea	 rax, QWORD PTR [rcx+r9]
  00456	49 8d 3c c7	 lea	 rdi, QWORD PTR [r15+rax*8]
  0045a	4a 8d 04 cd 00
	00 00 00	 lea	 rax, QWORD PTR [r9*8]
  00462	48 2b e8	 sub	 rbp, rax
  00465	49 2b ef	 sub	 rbp, r15
  00468	48 2b f1	 sub	 rsi, rcx
  0046b	0f 1f 44 00 00	 npad	 5
$LL54@PyEval_Eva@2:

; 3437 :             if (GETLOCAL(m+i) == NULL) {

  00470	48 83 3f 00	 cmp	 QWORD PTR [rdi], 0
  00474	75 1c		 jne	 SHORT $LN48@PyEval_Eva@2

; 3438 :                 PyObject *def = defs[i];

  00476	48 8b 1c 2f	 mov	 rbx, QWORD PTR [rdi+rbp]

; 3439 :                 Py_INCREF(def);

  0047a	48 8b cb	 mov	 rcx, rbx
  0047d	e8 00 00 00 00	 call	 _Py_IncRef

; 3440 :                 SETLOCAL(m+i, def);

  00482	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00485	48 89 1f	 mov	 QWORD PTR [rdi], rbx
  00488	48 85 c9	 test	 rcx, rcx
  0048b	74 05		 je	 SHORT $LN48@PyEval_Eva@2
  0048d	e8 00 00 00 00	 call	 _Py_DecRef
$LN48@PyEval_Eva@2:

; 3436 :         for (; i < defcount; i++) {

  00492	48 83 c7 08	 add	 rdi, 8
  00496	48 ff ce	 dec	 rsi
  00499	75 d5		 jne	 SHORT $LL54@PyEval_Eva@2
$LN52@PyEval_Eva@2:

; 3441 :             }
; 3442 :         }
; 3443 :     }
; 3444 :     if (co->co_kwonlyargcount > 0) {

  0049b	41 83 7d 64 00	 cmp	 DWORD PTR [r13+100], 0
  004a0	0f 8e 96 00 00
	00		 jle	 $LN29@PyEval_Eva@2

; 3445 :         int missing = 0;
; 3446 :         for (i = co->co_argcount; i < total_args; i++) {

  004a6	49 63 45 60	 movsxd	 rax, DWORD PTR [r13+96]
  004aa	41 8b f4	 mov	 esi, r12d
  004ad	49 3b c6	 cmp	 rax, r14
  004b0	0f 8d 86 00 00
	00		 jge	 $LN29@PyEval_Eva@2
  004b6	48 8b ac 24 e8
	00 00 00	 mov	 rbp, QWORD PTR kwdefs$[rsp]
  004be	41 bc 70 00 00
	00		 mov	 r12d, 112		; 00000070H
  004c4	49 8d 1c c7	 lea	 rbx, QWORD PTR [r15+rax*8]
  004c8	4d 2b e7	 sub	 r12, r15
  004cb	4c 2b f0	 sub	 r14, rax
  004ce	66 90		 npad	 2
$LL42@PyEval_Eva@2:

; 3447 :             PyObject *name;
; 3448 :             if (GETLOCAL(i) != NULL)

  004d0	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  004d4	75 40		 jne	 SHORT $LN41@PyEval_Eva@2

; 3449 :                 continue;
; 3450 :             name = PyTuple_GET_ITEM(co->co_varnames, i);

  004d6	49 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR [r13+144]
  004dd	49 8d 0c 04	 lea	 rcx, QWORD PTR [r12+rax]

; 3451 :             if (kwdefs != NULL) {

  004e1	48 85 ed	 test	 rbp, rbp
  004e4	74 2e		 je	 SHORT $LN37@PyEval_Eva@2

; 3452 :                 PyObject *def = PyDict_GetItem(kwdefs, name);

  004e6	48 8b 14 19	 mov	 rdx, QWORD PTR [rcx+rbx]
  004ea	48 8b cd	 mov	 rcx, rbp
  004ed	e8 00 00 00 00	 call	 PyDict_GetItem
  004f2	48 8b f8	 mov	 rdi, rax

; 3453 :                 if (def) {

  004f5	48 85 c0	 test	 rax, rax
  004f8	74 1a		 je	 SHORT $LN37@PyEval_Eva@2

; 3454 :                     Py_INCREF(def);

  004fa	48 8b c8	 mov	 rcx, rax
  004fd	e8 00 00 00 00	 call	 _Py_IncRef

; 3455 :                     SETLOCAL(i, def);

  00502	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00505	48 89 3b	 mov	 QWORD PTR [rbx], rdi
  00508	48 85 c9	 test	 rcx, rcx
  0050b	74 09		 je	 SHORT $LN41@PyEval_Eva@2
  0050d	e8 00 00 00 00	 call	 _Py_DecRef

; 3456 :                     continue;

  00512	eb 02		 jmp	 SHORT $LN41@PyEval_Eva@2
$LN37@PyEval_Eva@2:

; 3457 :                 }
; 3458 :             }
; 3459 :             missing++;

  00514	ff c6		 inc	 esi
$LN41@PyEval_Eva@2:

; 3445 :         int missing = 0;
; 3446 :         for (i = co->co_argcount; i < total_args; i++) {

  00516	48 83 c3 08	 add	 rbx, 8
  0051a	49 ff ce	 dec	 r14
  0051d	75 b1		 jne	 SHORT $LL42@PyEval_Eva@2

; 3460 :         }
; 3461 :         if (missing) {

  0051f	85 f6		 test	 esi, esi
  00521	74 16		 je	 SHORT $LN163@PyEval_Eva@2

; 3462 :             missing_arguments(co, missing, -1, fastlocals);

  00523	4d 8b cf	 mov	 r9, r15
  00526	41 83 c8 ff	 or	 r8d, -1
  0052a	8b d6		 mov	 edx, esi
  0052c	49 8b cd	 mov	 rcx, r13
  0052f	e8 00 00 00 00	 call	 missing_arguments

; 3463 :             goto fail;

  00534	e9 2a fe ff ff	 jmp	 $LN162@PyEval_Eva@2
$LN163@PyEval_Eva@2:

; 3502 :     }
; 3503 : 
; 3504 :     retval = PyEval_EvalFrameEx(f,0);

  00539	45 33 e4	 xor	 r12d, r12d
$LN29@PyEval_Eva@2:

; 3464 :         }
; 3465 :     }
; 3466 : 
; 3467 :     /* Allocate and initialize storage for cell vars, and copy free
; 3468 :        vars into frame. */
; 3469 :     for (i = 0; i < PyTuple_GET_SIZE(co->co_cellvars); ++i) {

  0053c	49 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR [r13+160]
  00543	41 8b ec	 mov	 ebp, r12d
  00546	49 8b f4	 mov	 rsi, r12
  00549	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0054e	7e 7b		 jle	 SHORT $LN26@PyEval_Eva@2
$LL28@PyEval_Eva@2:

; 3470 :         PyObject *c;
; 3471 :         int arg;
; 3472 :         /* Possibly account for the cell variable being an argument. */
; 3473 :         if (co->co_cell2arg != NULL &&
; 3474 :             (arg = co->co_cell2arg[i]) != CO_CELL_NOT_AN_ARG) {

  00550	49 8b 85 a8 00
	00 00		 mov	 rax, QWORD PTR [r13+168]
  00557	48 85 c0	 test	 rax, rax
  0055a	74 2e		 je	 SHORT $LN25@PyEval_Eva@2
  0055c	0f b6 0c 06	 movzx	 ecx, BYTE PTR [rsi+rax]
  00560	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  00566	74 22		 je	 SHORT $LN25@PyEval_Eva@2

; 3475 :             c = PyCell_New(GETLOCAL(arg));

  00568	8b d9		 mov	 ebx, ecx
  0056a	49 8b 0c cf	 mov	 rcx, QWORD PTR [r15+rcx*8]
  0056e	e8 00 00 00 00	 call	 PyCell_New

; 3476 :             /* Clear the local copy. */
; 3477 :             SETLOCAL(arg, NULL);

  00573	49 8b 0c df	 mov	 rcx, QWORD PTR [r15+rbx*8]
  00577	4d 89 24 df	 mov	 QWORD PTR [r15+rbx*8], r12
  0057b	48 8b f8	 mov	 rdi, rax
  0057e	48 85 c9	 test	 rcx, rcx
  00581	74 11		 je	 SHORT $LN17@PyEval_Eva@2
  00583	e8 00 00 00 00	 call	 _Py_DecRef

; 3478 :         }
; 3479 :         else {

  00588	eb 0a		 jmp	 SHORT $LN17@PyEval_Eva@2
$LN25@PyEval_Eva@2:

; 3480 :             c = PyCell_New(NULL);

  0058a	33 c9		 xor	 ecx, ecx
  0058c	e8 00 00 00 00	 call	 PyCell_New
  00591	48 8b f8	 mov	 rdi, rax
$LN17@PyEval_Eva@2:

; 3481 :         }
; 3482 :         if (c == NULL)

  00594	48 85 ff	 test	 rdi, rdi
  00597	0f 84 c9 fd ff
	ff		 je	 $LN164@PyEval_Eva@2

; 3483 :             goto fail;
; 3484 :         SETLOCAL(co->co_nlocals + i, c);

  0059d	49 63 45 68	 movsxd	 rax, DWORD PTR [r13+104]
  005a1	48 03 c6	 add	 rax, rsi
  005a4	49 8b 0c c7	 mov	 rcx, QWORD PTR [r15+rax*8]
  005a8	49 89 3c c7	 mov	 QWORD PTR [r15+rax*8], rdi
  005ac	48 85 c9	 test	 rcx, rcx
  005af	74 05		 je	 SHORT $LN11@PyEval_Eva@2
  005b1	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@PyEval_Eva@2:

; 3464 :         }
; 3465 :     }
; 3466 : 
; 3467 :     /* Allocate and initialize storage for cell vars, and copy free
; 3468 :        vars into frame. */
; 3469 :     for (i = 0; i < PyTuple_GET_SIZE(co->co_cellvars); ++i) {

  005b6	49 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR [r13+160]
  005bd	ff c5		 inc	 ebp
  005bf	48 ff c6	 inc	 rsi
  005c2	48 63 cd	 movsxd	 rcx, ebp
  005c5	48 3b 48 60	 cmp	 rcx, QWORD PTR [rax+96]
  005c9	7c 85		 jl	 SHORT $LL28@PyEval_Eva@2
$LN26@PyEval_Eva@2:

; 3485 :     }
; 3486 :     for (i = 0; i < PyTuple_GET_SIZE(co->co_freevars); ++i) {

  005cb	49 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR [r13+152]
  005d2	41 8b f4	 mov	 esi, r12d
  005d5	49 8b ec	 mov	 rbp, r12
  005d8	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  005dd	7e 47		 jle	 SHORT $LN6@PyEval_Eva@2
  005df	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR closure$[rsp]
  005e7	4c 8b 74 24 50	 mov	 r14, QWORD PTR freevars$1$[rsp]
  005ec	48 83 c7 70	 add	 rdi, 112		; 00000070H
$LL8@PyEval_Eva@2:

; 3487 :         PyObject *o = PyTuple_GET_ITEM(closure, i);

  005f0	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]

; 3488 :         Py_INCREF(o);

  005f3	48 8b cb	 mov	 rcx, rbx
  005f6	e8 00 00 00 00	 call	 _Py_IncRef

; 3489 :         freevars[PyTuple_GET_SIZE(co->co_cellvars) + i] = o;

  005fb	4d 8b 9d a0 00
	00 00		 mov	 r11, QWORD PTR [r13+160]
  00602	ff c6		 inc	 esi
  00604	49 8b 4b 60	 mov	 rcx, QWORD PTR [r11+96]
  00608	48 83 c7 08	 add	 rdi, 8
  0060c	48 03 cd	 add	 rcx, rbp
  0060f	48 ff c5	 inc	 rbp
  00612	49 89 1c ce	 mov	 QWORD PTR [r14+rcx*8], rbx
  00616	49 8b 85 98 00
	00 00		 mov	 rax, QWORD PTR [r13+152]
  0061d	48 63 ce	 movsxd	 rcx, esi
  00620	48 3b 48 60	 cmp	 rcx, QWORD PTR [rax+96]
  00624	7c ca		 jl	 SHORT $LL8@PyEval_Eva@2
$LN6@PyEval_Eva@2:

; 3490 :     }
; 3491 : 
; 3492 :     if (co->co_flags & CO_GENERATOR) {

  00626	41 f6 45 70 20	 test	 BYTE PTR [r13+112], 32	; 00000020H

; 3493 :         /* Don't need to keep the reference to f_back, it will be set
; 3494 :          * when the generator is resumed. */
; 3495 :         Py_CLEAR(f->f_back);

  0062b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR f$1$[rsp]
  00630	74 48		 je	 SHORT $LN5@PyEval_Eva@2
  00632	4c 8b 4b 70	 mov	 r9, QWORD PTR [rbx+112]
  00636	4d 85 c9	 test	 r9, r9
  00639	74 32		 je	 SHORT $LN3@PyEval_Eva@2
  0063b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@CJJEGEEJ@?4?4?2Python?2ceval?4c?$AA@
  00642	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@FPJFGDDC@PyEval_EvalCodeEx?$AA@
  00649	41 b8 a7 0d 00
	00		 mov	 r8d, 3495		; 00000da7H
  0064f	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00657	e8 00 00 00 00	 call	 _PyParallel_Guard
  0065c	85 c0		 test	 eax, eax
  0065e	75 0d		 jne	 SHORT $LN3@PyEval_Eva@2
  00660	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  00664	4c 89 63 70	 mov	 QWORD PTR [rbx+112], r12
  00668	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyEval_Eva@2:

; 3496 : 
; 3497 :         PCALL(PCALL_GENERATOR);
; 3498 : 
; 3499 :         /* Create a new generator that owns the ready to run frame
; 3500 :          * and return that as the value. */
; 3501 :         return PyGen_New(f);

  0066d	48 8b cb	 mov	 rcx, rbx
  00670	e8 00 00 00 00	 call	 PyGen_New
  00675	e9 26 fd ff ff	 jmp	 $LN124@PyEval_Eva@2
$LN5@PyEval_Eva@2:

; 3502 :     }
; 3503 : 
; 3504 :     retval = PyEval_EvalFrameEx(f,0);

  0067a	33 d2		 xor	 edx, edx
  0067c	48 8b cb	 mov	 rcx, rbx
  0067f	e8 00 00 00 00	 call	 PyEval_EvalFrameEx
  00684	4c 8b e0	 mov	 r12, rax
  00687	e9 df fc ff ff	 jmp	 $fail$65991
PyEval_EvalCodeEx ENDP
_TEXT	ENDS
PUBLIC	??_C@_1BK@GAKHIKCP@?$AAj?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?$AA@ ; `string'
PUBLIC	??_C@_0N@OOHFADNO@keyword?9only?$AA@		; `string'
PUBLIC	??_C@_0L@DLCGEICH@positional?$AA@		; `string'
EXTRN	PyObject_Repr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$missing_arguments DD imagerel missing_arguments
	DD	imagerel missing_arguments+94
	DD	imagerel $unwind$missing_arguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$missing_arguments DD imagerel missing_arguments+94
	DD	imagerel missing_arguments+266
	DD	imagerel $chain$0$missing_arguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$missing_arguments DD imagerel missing_arguments+266
	DD	imagerel missing_arguments+289
	DD	imagerel $chain$1$missing_arguments
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$missing_arguments DD 021H
	DD	imagerel missing_arguments
	DD	imagerel missing_arguments+94
	DD	imagerel $unwind$missing_arguments
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$missing_arguments DD 020521H
	DD	0ce405H
	DD	imagerel missing_arguments
	DD	imagerel missing_arguments+94
	DD	imagerel $unwind$missing_arguments
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$missing_arguments DD 0a1a01H
	DD	0f541aH
	DD	0e341aH
	DD	0f016521aH
	DD	0c012d014H
	DD	0600f7010H
xdata	ENDS
;	COMDAT ??_C@_1BK@GAKHIKCP@?$AAj?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@GAKHIKCP@?$AAj?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?$AA@ DB 'j'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'm', 00H, 'i', 00H
	DB	's', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OOHFADNO@keyword?9only?$AA@
CONST	SEGMENT
??_C@_0N@OOHFADNO@keyword?9only?$AA@ DB 'keyword-only', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DLCGEICH@positional?$AA@
CONST	SEGMENT
??_C@_0L@DLCGEICH@positional?$AA@ DB 'positional', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT missing_arguments
_TEXT	SEGMENT
kind$1$ = 32
co$ = 96
missing$ = 104
defcount$ = 112
fastlocals$ = 120
missing_arguments PROC					; COMDAT

; 3217 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 57		 push	 r15
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3218 :     int i, j = 0;

  0001a	33 ed		 xor	 ebp, ebp

; 3219 :     int start, end;
; 3220 :     int positional = defcount != -1;

  0001c	41 83 f8 ff	 cmp	 r8d, -1
  00020	4c 8b e9	 mov	 r13, rcx
  00023	8b dd		 mov	 ebx, ebp
  00025	0f 95 c3	 setne	 bl

; 3221 :     const char *kind = positional ? "positional" : "keyword-only";

  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DLCGEICH@positional?$AA@
  0002f	48 63 c2	 movsxd	 rax, edx
  00032	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_0N@OOHFADNO@keyword?9only?$AA@
  00039	85 db		 test	 ebx, ebx
  0003b	48 0f 45 f1	 cmovne	 rsi, rcx

; 3222 :     PyObject *missing_names;
; 3223 : 
; 3224 :     /* Compute the names of the arguments that are missing. */
; 3225 :     missing_names = PyList_New(missing);

  0003f	48 8b c8	 mov	 rcx, rax
  00042	4d 8b f9	 mov	 r15, r9
  00045	48 89 74 24 20	 mov	 QWORD PTR kind$1$[rsp], rsi
  0004a	41 8b f8	 mov	 edi, r8d
  0004d	e8 00 00 00 00	 call	 PyList_New
  00052	4c 8b e0	 mov	 r12, rax

; 3226 :     if (missing_names == NULL)

  00055	48 85 c0	 test	 rax, rax
  00058	0f 84 ac 00 00
	00		 je	 $LN9@missing_ar

; 3227 :         return;
; 3228 :     if (positional) {

  0005e	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  00063	85 db		 test	 ebx, ebx
  00065	74 0a		 je	 SHORT $LN7@missing_ar

; 3229 :         start = 0;
; 3230 :         end = co->co_argcount - defcount;

  00067	41 8b 45 60	 mov	 eax, DWORD PTR [r13+96]
  0006b	8b cd		 mov	 ecx, ebp
  0006d	2b c7		 sub	 eax, edi

; 3231 :     }
; 3232 :     else {

  0006f	eb 0a		 jmp	 SHORT $LN6@missing_ar
$LN7@missing_ar:

; 3233 :         start = co->co_argcount;

  00071	41 8b 4d 60	 mov	 ecx, DWORD PTR [r13+96]

; 3234 :         end = start + co->co_kwonlyargcount;

  00075	41 8b 45 64	 mov	 eax, DWORD PTR [r13+100]
  00079	03 c1		 add	 eax, ecx
$LN6@missing_ar:

; 3235 :     }
; 3236 :     for (i = start; i < end; i++) {

  0007b	48 63 f9	 movsxd	 rdi, ecx
  0007e	4c 63 f0	 movsxd	 r14, eax
  00081	49 3b fe	 cmp	 rdi, r14
  00084	7d 49		 jge	 SHORT $LN15@missing_ar
  00086	48 8b f5	 mov	 rsi, rbp
  00089	48 8d 1c fd 70
	00 00 00	 lea	 rbx, QWORD PTR [rdi*8+112]
$LL5@missing_ar:

; 3237 :         if (GETLOCAL(i) == NULL) {

  00091	49 83 7c 1f 90
	00		 cmp	 QWORD PTR [r15+rbx-112], 0
  00097	75 25		 jne	 SHORT $LN4@missing_ar

; 3238 :             PyObject *raw = PyTuple_GET_ITEM(co->co_varnames, i);

  00099	49 8b 85 90 00
	00 00		 mov	 rax, QWORD PTR [r13+144]

; 3239 :             PyObject *name = PyObject_Repr(raw);

  000a0	48 8b 0c 03	 mov	 rcx, QWORD PTR [rbx+rax]
  000a4	e8 00 00 00 00	 call	 PyObject_Repr

; 3240 :             if (name == NULL) {

  000a9	48 85 c0	 test	 rax, rax
  000ac	74 4f		 je	 SHORT $LN13@missing_ar

; 3241 :                 Py_DECREF(missing_names);
; 3242 :                 return;
; 3243 :             }
; 3244 :             PyList_SET_ITEM(missing_names, j++, name);

  000ae	49 8b 4c 24 70	 mov	 rcx, QWORD PTR [r12+112]
  000b3	ff c5		 inc	 ebp
  000b5	48 83 c6 08	 add	 rsi, 8
  000b9	48 89 44 0e f8	 mov	 QWORD PTR [rsi+rcx-8], rax
$LN4@missing_ar:

; 3235 :     }
; 3236 :     for (i = start; i < end; i++) {

  000be	48 ff c7	 inc	 rdi
  000c1	48 83 c3 08	 add	 rbx, 8
  000c5	49 3b fe	 cmp	 rdi, r14
  000c8	7c c7		 jl	 SHORT $LL5@missing_ar

; 3221 :     const char *kind = positional ? "positional" : "keyword-only";

  000ca	48 8b 74 24 20	 mov	 rsi, QWORD PTR kind$1$[rsp]
$LN15@missing_ar:

; 3245 :         }
; 3246 :     }
; 3247 :     assert(j == missing);

  000cf	3b 6c 24 68	 cmp	 ebp, DWORD PTR missing$[rsp]
  000d3	74 1a		 je	 SHORT $LN11@missing_ar
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BK@GAKHIKCP@?$AAj?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AAm?$AAi?$AAs?$AAs?$AAi?$AAn?$AAg?$AA?$AA@
  000e3	41 b8 af 0c 00
	00		 mov	 r8d, 3247		; 00000cafH
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN11@missing_ar:

; 3248 :     format_missing(kind, co, missing_names);

  000ef	4d 8b c4	 mov	 r8, r12
  000f2	49 8b d5	 mov	 rdx, r13
  000f5	48 8b ce	 mov	 rcx, rsi
  000f8	e8 00 00 00 00	 call	 format_missing
$LN13@missing_ar:

; 3249 :     Py_DECREF(missing_names);

  000fd	49 8b cc	 mov	 rcx, r12
  00100	e8 00 00 00 00	 call	 _Py_DecRef
  00105	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]
$LN9@missing_ar:

; 3250 : }

  0010a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0010f	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  00114	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00118	41 5f		 pop	 r15
  0011a	41 5d		 pop	 r13
  0011c	41 5c		 pop	 r12
  0011e	5f		 pop	 rdi
  0011f	5e		 pop	 rsi
  00120	c3		 ret	 0
missing_arguments ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@BCJPODPI@?$CFU?$CI?$CJ?5missing?5?$CFi?5required?5?$CFs?5argu@ ; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_09FOEHEDKA@?$CFU?5and?5?$CFU?$AA@		; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_0N@NOMOJHCB@?0?5?$CFU?0?5and?5?$CFU?$AA@	; `string'
PUBLIC	??_C@_1BC@FIHALOPN@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@FFOAFJED@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AAs?$AA?$CJ?$AA?$AA@ ; `string'
EXTRN	PyUnicode_Concat:PROC
EXTRN	PyUnicode_Join:PROC
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyList_SetSlice:PROC
EXTRN	PyUnicode_FromFormat:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_missing DD imagerel format_missing
	DD	imagerel format_missing+430
	DD	imagerel $unwind$format_missing
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_missing DD 0c7701H
	DD	0ec477H
	DD	0d546fH
	DD	0c3467H
	DD	0f640eH
	DD	0e00a720eH
	DD	07006d008H
xdata	ENDS
;	COMDAT ??_C@_0CL@BCJPODPI@?$CFU?$CI?$CJ?5missing?5?$CFi?5required?5?$CFs?5argu@
CONST	SEGMENT
??_C@_0CL@BCJPODPI@?$CFU?$CI?$CJ?5missing?5?$CFi?5required?5?$CFs?5argu@ DB '%'
	DB	'U() missing %i required %s argument%s: %U', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09FOEHEDKA@?$CFU?5and?5?$CFU?$AA@
CONST	SEGMENT
??_C@_09FOEHEDKA@?$CFU?5and?5?$CFU?$AA@ DB '%U and %U', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NOMOJHCB@?0?5?$CFU?0?5and?5?$CFU?$AA@
CONST	SEGMENT
??_C@_0N@NOMOJHCB@?0?5?$CFU?0?5and?5?$CFU?$AA@ DB ', %U, and %U', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BC@FIHALOPN@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
CONST	SEGMENT
??_C@_1BC@FIHALOPN@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@ DB 'l'
	DB	00H, 'e', 00H, 'n', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'1', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@FFOAFJED@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AAs?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@FFOAFJED@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AAs?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'i', 00H, 's', 00H, 't', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, 'E', 00H, 'x'
	DB	00H, 'a', 00H, 'c', 00H, 't', 00H, '(', 00H, 'n', 00H, 'a', 00H
	DB	'm', 00H, 'e', 00H, 's', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT format_missing
_TEXT	SEGMENT
kind$ = 96
co$ = 104
names$ = 112
format_missing PROC					; COMDAT

; 3154 : {

  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	57		 push	 rdi
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3155 :     int err;
; 3156 :     Py_ssize_t len = PyList_GET_SIZE(names);

  0000e	49 8b 70 60	 mov	 rsi, QWORD PTR [r8+96]

; 3157 :     PyObject *name_str, *comma, *tail, *tmp;
; 3158 : 
; 3159 :     assert(PyList_CheckExact(names));

  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  00019	49 8b f8	 mov	 rdi, r8
  0001c	4c 8b ea	 mov	 r13, rdx
  0001f	4c 8b f1	 mov	 r14, rcx
  00022	49 39 40 58	 cmp	 QWORD PTR [r8+88], rax
  00026	74 1a		 je	 SHORT $LN13@format_mis
  00028	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@FFOAFJED@?$AAP?$AAy?$AAL?$AAi?$AAs?$AAt?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AAE?$AAx?$AAa?$AAc?$AAt?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AAs?$AA?$CJ?$AA?$AA@
  00036	41 b8 57 0c 00
	00		 mov	 r8d, 3159		; 00000c57H
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN13@format_mis:

; 3160 :     assert(len >= 1);

  00042	48 83 fe 01	 cmp	 rsi, 1
  00046	7d 1a		 jge	 SHORT $LN14@format_mis
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BC@FIHALOPN@?$AAl?$AAe?$AAn?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA1?$AA?$AA@
  00056	41 b8 58 0c 00
	00		 mov	 r8d, 3160		; 00000c58H
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN14@format_mis:

; 3161 :     /* Deal with the joys of natural language. */
; 3162 :     switch (len) {

  00062	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00067	48 8b c6	 mov	 rax, rsi
  0006a	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  0006f	48 ff c8	 dec	 rax
  00072	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  00077	0f 84 b5 00 00
	00		 je	 $LN8@format_mis
  0007d	48 ff c8	 dec	 rax

; 3172 :     default:
; 3173 :         tail = PyUnicode_FromFormat(", %U, and %U",
; 3174 :                                     PyList_GET_ITEM(names, len - 2),
; 3175 :                                     PyList_GET_ITEM(names, len - 1));

  00080	48 8b 57 70	 mov	 rdx, QWORD PTR [rdi+112]
  00084	0f 84 90 00 00
	00		 je	 $LN7@format_mis
  0008a	4c 8b 44 f2 f8	 mov	 r8, QWORD PTR [rdx+rsi*8-8]
  0008f	48 8b 54 f2 f0	 mov	 rdx, QWORD PTR [rdx+rsi*8-16]
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0N@NOMOJHCB@?0?5?$CFU?0?5and?5?$CFU?$AA@
  0009b	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000a0	48 8b d8	 mov	 rbx, rax

; 3176 :         if (tail == NULL)

  000a3	48 85 c0	 test	 rax, rax
  000a6	0f 84 e4 00 00
	00		 je	 $LN11@format_mis

; 3177 :             return;
; 3178 :         /* Chop off the last two objects in the list. This shouldn't actually
; 3179 :            fail, but we can't be too careful. */
; 3180 :         err = PyList_SetSlice(names, len - 2, len, NULL);

  000ac	48 8d 56 fe	 lea	 rdx, QWORD PTR [rsi-2]
  000b0	45 33 c9	 xor	 r9d, r9d
  000b3	4c 8b c6	 mov	 r8, rsi
  000b6	48 8b cf	 mov	 rcx, rdi
  000b9	e8 00 00 00 00	 call	 PyList_SetSlice

; 3181 :         if (err == -1) {

  000be	83 f8 ff	 cmp	 eax, -1
  000c1	75 08		 jne	 SHORT $LN4@format_mis
$LN16@format_mis:

; 3182 :             Py_DECREF(tail);

  000c3	48 8b cb	 mov	 rcx, rbx

; 3183 :             return;

  000c6	e9 c0 00 00 00	 jmp	 $LN15@format_mis
$LN4@format_mis:

; 3184 :         }
; 3185 :         /* Stitch everything up into a nice comma-separated list. */
; 3186 :         comma = PyUnicode_FromString(", ");

  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
  000d2	e8 00 00 00 00	 call	 PyUnicode_FromString
  000d7	48 8b e8	 mov	 rbp, rax

; 3187 :         if (comma == NULL) {

  000da	48 85 c0	 test	 rax, rax

; 3188 :             Py_DECREF(tail);
; 3189 :             return;

  000dd	74 e4		 je	 SHORT $LN16@format_mis

; 3190 :         }
; 3191 :         tmp = PyUnicode_Join(comma, names);

  000df	48 8b d7	 mov	 rdx, rdi
  000e2	48 8b c8	 mov	 rcx, rax
  000e5	e8 00 00 00 00	 call	 PyUnicode_Join

; 3192 :         Py_DECREF(comma);

  000ea	48 8b cd	 mov	 rcx, rbp
  000ed	4c 8b e0	 mov	 r12, rax
  000f0	e8 00 00 00 00	 call	 _Py_DecRef

; 3193 :         if (tmp == NULL) {

  000f5	4d 85 e4	 test	 r12, r12

; 3194 :             Py_DECREF(tail);
; 3195 :             return;

  000f8	74 c9		 je	 SHORT $LN16@format_mis

; 3196 :         }
; 3197 :         name_str = PyUnicode_Concat(tmp, tail);

  000fa	48 8b d3	 mov	 rdx, rbx
  000fd	49 8b cc	 mov	 rcx, r12
  00100	e8 00 00 00 00	 call	 PyUnicode_Concat

; 3198 :         Py_DECREF(tmp);

  00105	49 8b cc	 mov	 rcx, r12
  00108	48 8b f8	 mov	 rdi, rax
  0010b	e8 00 00 00 00	 call	 _Py_DecRef

; 3199 :         Py_DECREF(tail);

  00110	48 8b cb	 mov	 rcx, rbx
  00113	e8 00 00 00 00	 call	 _Py_DecRef

; 3200 :         break;

  00118	eb 27		 jmp	 SHORT $LN9@format_mis
$LN7@format_mis:

; 3166 :         break;
; 3167 :     case 2:
; 3168 :         name_str = PyUnicode_FromFormat("%U and %U",
; 3169 :                                         PyList_GET_ITEM(names, len - 2),
; 3170 :                                         PyList_GET_ITEM(names, len - 1));

  0011a	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  0011e	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_09FOEHEDKA@?$CFU?5and?5?$CFU?$AA@
  00128	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  0012d	48 8b f8	 mov	 rdi, rax

; 3171 :         break;

  00130	eb 0f		 jmp	 SHORT $LN9@format_mis
$LN8@format_mis:

; 3163 :     case 1:
; 3164 :         name_str = PyList_GET_ITEM(names, 0);

  00132	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  00136	48 8b 38	 mov	 rdi, QWORD PTR [rax]

; 3165 :         Py_INCREF(name_str);

  00139	48 8b cf	 mov	 rcx, rdi
  0013c	e8 00 00 00 00	 call	 _Py_IncRef
$LN9@format_mis:

; 3201 :     }
; 3202 :     if (name_str == NULL)

  00141	48 85 ff	 test	 rdi, rdi
  00144	74 4a		 je	 SHORT $LN11@format_mis

; 3203 :         return;
; 3204 :     PyErr_Format(PyExc_TypeError,
; 3205 :                  "%U() missing %i required %s argument%s: %U",
; 3206 :                  co->co_name,
; 3207 :                  len,
; 3208 :                  kind,
; 3209 :                  len == 1 ? "" : "s",
; 3210 :                  name_str);

  00146	4d 8b 85 b8 00
	00 00		 mov	 r8, QWORD PTR [r13+184]
  0014d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00154	48 83 fe 01	 cmp	 rsi, 1
  00158	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0015d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  00164	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@BCJPODPI@?$CFU?$CI?$CJ?5missing?5?$CFi?5required?5?$CFs?5argu@
  0016b	48 0f 44 c1	 cmove	 rax, rcx
  0016f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00176	4c 8b ce	 mov	 r9, rsi
  00179	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017e	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00183	e8 00 00 00 00	 call	 PyErr_Format

; 3211 :     Py_DECREF(name_str);

  00188	48 8b cf	 mov	 rcx, rdi
$LN15@format_mis:
  0018b	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@format_mis:
  00190	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  00195	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  0019a	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]

; 3212 : }

  0019f	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  001a4	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001a8	41 5e		 pop	 r14
  001aa	41 5d		 pop	 r13
  001ac	5f		 pop	 rdi
  001ad	c3		 ret	 0
format_missing ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@JMJOHPHL@?$CFU?$CI?$CJ?5takes?5?$CFU?5positional?5argumen@ ; `string'
PUBLIC	??_C@_04DBCIBANA@were?$AA@			; `string'
PUBLIC	??_C@_03GFFEDDOE@was?$AA@			; `string'
PUBLIC	??_C@_1CG@KPJNOMNL@?$AAk?$AAw?$AAo?$AAn?$AAl?$AAy?$AA_?$AAs?$AAi?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
PUBLIC	??_C@_0DI@NKBHPHHG@?5positional?5argument?$CFs?5?$CIand?5?$CFd?5k@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_0O@EJKGNKBC@from?5?$CFd?5to?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_1EC@FLBMEDL@?$AA?$CI?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAC?$AAO?$AA_?$AAV?$AAA?$AAR?$AAA?$AAR?$AAG?$AAS?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$too_many_positional DD imagerel too_many_positional
	DD	imagerel too_many_positional+172
	DD	imagerel $unwind$too_many_positional
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$too_many_positional DD imagerel too_many_positional+172
	DD	imagerel too_many_positional+401
	DD	imagerel $chain$1$too_many_positional
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$too_many_positional DD imagerel too_many_positional+401
	DD	imagerel too_many_positional+422
	DD	imagerel $chain$2$too_many_positional
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$too_many_positional DD 021H
	DD	imagerel too_many_positional
	DD	imagerel too_many_positional+172
	DD	imagerel $unwind$too_many_positional
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$too_many_positional DD 040a21H
	DD	0ff40aH
	DD	0e5405H
	DD	imagerel too_many_positional
	DD	imagerel too_many_positional+172
	DD	imagerel $unwind$too_many_positional
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$too_many_positional DD 081101H
	DD	0103411H
	DD	0e00d7211H
	DD	0c009d00bH
	DD	060067007H
xdata	ENDS
;	COMDAT ??_C@_0DG@JMJOHPHL@?$CFU?$CI?$CJ?5takes?5?$CFU?5positional?5argumen@
CONST	SEGMENT
??_C@_0DG@JMJOHPHL@?$CFU?$CI?$CJ?5takes?5?$CFU?5positional?5argumen@ DB '%'
	DB	'U() takes %U positional argument%s but %d%U %s given', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DBCIBANA@were?$AA@
CONST	SEGMENT
??_C@_04DBCIBANA@were?$AA@ DB 'were', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03GFFEDDOE@was?$AA@
CONST	SEGMENT
??_C@_03GFFEDDOE@was?$AA@ DB 'was', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@KPJNOMNL@?$AAk?$AAw?$AAo?$AAn?$AAl?$AAy?$AA_?$AAs?$AAi?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@KPJNOMNL@?$AAk?$AAw?$AAo?$AAn?$AAl?$AAy?$AA_?$AAs?$AAi?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'k'
	DB	00H, 'w', 00H, 'o', 00H, 'n', 00H, 'l', 00H, 'y', 00H, '_', 00H
	DB	's', 00H, 'i', 00H, 'g', 00H, ' ', 00H, '!', 00H, '=', 00H, ' '
	DB	00H, 'N', 00H, 'U', 00H, 'L', 00H, 'L', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@NKBHPHHG@?5positional?5argument?$CFs?5?$CIand?5?$CFd?5k@
CONST	SEGMENT
??_C@_0DI@NKBHPHHG@?5positional?5argument?$CFs?5?$CIand?5?$CFd?5k@ DB ' p'
	DB	'ositional argument%s (and %d keyword-only argument%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EJKGNKBC@from?5?$CFd?5to?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@EJKGNKBC@from?5?$CFd?5to?5?$CFd?$AA@ DB 'from %d to %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EC@FLBMEDL@?$AA?$CI?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAC?$AAO?$AA_?$AAV?$AAA?$AAR?$AAA?$AAR?$AAG?$AAS?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
CONST	SEGMENT
??_C@_1EC@FLBMEDL@?$AA?$CI?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAC?$AAO?$AA_?$AAV?$AAA?$AAR?$AAA?$AAR?$AAG?$AAS?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@ DB '('
	DB	00H, 'c', 00H, 'o', 00H, '-', 00H, '>', 00H, 'c', 00H, 'o', 00H
	DB	'_', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' '
	DB	00H, '&', 00H, ' ', 00H, 'C', 00H, 'O', 00H, '_', 00H, 'V', 00H
	DB	'A', 00H, 'R', 00H, 'A', 00H, 'R', 00H, 'G', 00H, 'S', 00H, ')'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT too_many_positional
_TEXT	SEGMENT
co$ = 112
given$ = 120
defcount$ = 128
fastlocals$ = 136
too_many_positional PROC				; COMDAT

; 3254 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 3255 :     int plural;
; 3256 :     int kwonly_given = 0;

  00011	45 33 ed	 xor	 r13d, r13d

; 3257 :     int i;
; 3258 :     PyObject *sig, *kwonly_sig;
; 3259 : 
; 3260 :     assert((co->co_flags & CO_VARARGS) == 0);

  00014	f6 41 70 04	 test	 BYTE PTR [rcx+112], 4
  00018	49 8b f9	 mov	 rdi, r9
  0001b	41 8b f0	 mov	 esi, r8d
  0001e	44 8b f2	 mov	 r14d, edx
  00021	4c 8b e1	 mov	 r12, rcx
  00024	41 8b dd	 mov	 ebx, r13d
  00027	74 1a		 je	 SHORT $LN13@too_many_p
  00029	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EC@FLBMEDL@?$AA?$CI?$AAc?$AAo?$AA?9?$AA?$DO?$AAc?$AAo?$AA_?$AAf?$AAl?$AAa?$AAg?$AAs?$AA?5?$AA?$CG?$AA?5?$AAC?$AAO?$AA_?$AAV?$AAA?$AAR?$AAA?$AAR?$AAG?$AAS?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0@
  00037	41 b8 bc 0c 00
	00		 mov	 r8d, 3260		; 00000cbcH
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN13@too_many_p:

; 3261 :     /* Count missing keyword-only args. */
; 3262 :     for (i = co->co_argcount; i < co->co_argcount + co->co_kwonlyargcount; i++)

  00043	49 63 54 24 60	 movsxd	 rdx, DWORD PTR [r12+96]
  00048	41 8b 44 24 64	 mov	 eax, DWORD PTR [r12+100]
  0004d	8d 0c 02	 lea	 ecx, DWORD PTR [rdx+rax]
  00050	3b d1		 cmp	 edx, ecx
  00052	7d 1c		 jge	 SHORT $LN8@too_many_p
  00054	48 8d 04 d7	 lea	 rax, QWORD PTR [rdi+rdx*8]
  00058	2b ca		 sub	 ecx, edx
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL10@too_many_p:

; 3263 :         if (GETLOCAL(i) != NULL)

  00060	4c 39 28	 cmp	 QWORD PTR [rax], r13
  00063	74 02		 je	 SHORT $LN9@too_many_p

; 3264 :             kwonly_given++;

  00065	ff c3		 inc	 ebx
$LN9@too_many_p:

; 3261 :     /* Count missing keyword-only args. */
; 3262 :     for (i = co->co_argcount; i < co->co_argcount + co->co_kwonlyargcount; i++)

  00067	48 83 c0 08	 add	 rax, 8
  0006b	48 ff c9	 dec	 rcx
  0006e	75 f0		 jne	 SHORT $LL10@too_many_p
$LN8@too_many_p:

; 3265 :     if (defcount) {

  00070	85 f6		 test	 esi, esi
  00072	74 19		 je	 SHORT $LN6@too_many_p

; 3266 :         int atleast = co->co_argcount - defcount;

  00074	44 8b c2	 mov	 r8d, edx

; 3267 :         plural = 1;
; 3268 :         sig = PyUnicode_FromFormat("from %d to %d", atleast, co->co_argcount);

  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0O@EJKGNKBC@from?5?$CFd?5to?5?$CFd?$AA@
  0007e	2b d6		 sub	 edx, esi
  00080	41 bd 01 00 00
	00		 mov	 r13d, 1
  00086	e8 00 00 00 00	 call	 PyUnicode_FromFormat

; 3269 :     }
; 3270 :     else {

  0008b	eb 13		 jmp	 SHORT $LN21@too_many_p
$LN6@too_many_p:

; 3271 :         plural = co->co_argcount != 1;

  0008d	83 fa 01	 cmp	 edx, 1

; 3272 :         sig = PyUnicode_FromFormat("%d", co->co_argcount);

  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd?$AA@
  00097	41 0f 95 c5	 setne	 r13b
  0009b	e8 00 00 00 00	 call	 PyUnicode_FromFormat
$LN21@too_many_p:
  000a0	48 8b f8	 mov	 rdi, rax

; 3273 :     }
; 3274 :     if (sig == NULL)

  000a3	48 85 c0	 test	 rax, rax
  000a6	0f 84 e5 00 00
	00		 je	 $LN11@too_many_p

; 3275 :         return;
; 3276 :     if (kwonly_given) {
; 3277 :         const char *format = " positional argument%s (and %d keyword-only argument%s)";
; 3278 :         kwonly_sig = PyUnicode_FromFormat(format, given != 1 ? "s" : "", kwonly_given,
; 3279 :                                               kwonly_given != 1 ? "s" : "");

  000ac	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  000b1	4c 89 7c 24 78	 mov	 QWORD PTR [rsp+120], r15
  000b6	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000bd	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  000c4	85 db		 test	 ebx, ebx
  000c6	74 34		 je	 SHORT $LN3@too_many_p
  000c8	83 fb 01	 cmp	 ebx, 1
  000cb	4c 8b ce	 mov	 r9, rsi
  000ce	48 8b d6	 mov	 rdx, rsi
  000d1	4d 0f 45 cf	 cmovne	 r9, r15
  000d5	41 83 fe 01	 cmp	 r14d, 1
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DI@NKBHPHHG@?5positional?5argument?$CFs?5?$CIand?5?$CFd?5k@
  000e0	49 0f 45 d7	 cmovne	 rdx, r15
  000e4	44 8b c3	 mov	 r8d, ebx
  000e7	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  000ec	48 8b e8	 mov	 rbp, rax

; 3280 :         if (kwonly_sig == NULL) {

  000ef	48 85 c0	 test	 rax, rax
  000f2	75 32		 jne	 SHORT $LN14@too_many_p

; 3281 :             Py_DECREF(sig);

  000f4	48 8b cf	 mov	 rcx, rdi

; 3282 :             return;

  000f7	e9 86 00 00 00	 jmp	 $LN22@too_many_p
$LN3@too_many_p:

; 3283 :         }
; 3284 :     }
; 3285 :     else {
; 3286 :         /* This will not fail. */
; 3287 :         kwonly_sig = PyUnicode_FromString("");

  000fc	48 8b ce	 mov	 rcx, rsi
  000ff	e8 00 00 00 00	 call	 PyUnicode_FromString
  00104	48 8b e8	 mov	 rbp, rax

; 3288 :         assert(kwonly_sig != NULL);

  00107	48 85 c0	 test	 rax, rax
  0010a	75 1a		 jne	 SHORT $LN14@too_many_p
  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@KPJNOMNL@?$AAk?$AAw?$AAo?$AAn?$AAl?$AAy?$AA_?$AAs?$AAi?$AAg?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0011a	41 b8 d8 0c 00
	00		 mov	 r8d, 3288		; 00000cd8H
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN14@too_many_p:

; 3289 :     }
; 3290 :     PyErr_Format(PyExc_TypeError,
; 3291 :                  "%U() takes %U positional argument%s but %d%U %s given",
; 3292 :                  co->co_name,
; 3293 :                  sig,
; 3294 :                  plural ? "s" : "",
; 3295 :                  given,
; 3296 :                  kwonly_sig,
; 3297 :                  given == 1 && !kwonly_given ? "was" : "were");

  00126	41 83 fe 01	 cmp	 r14d, 1
  0012a	75 0b		 jne	 SHORT $LN15@too_many_p
  0012c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03GFFEDDOE@was?$AA@
  00133	85 db		 test	 ebx, ebx
  00135	74 07		 je	 SHORT $LN16@too_many_p
$LN15@too_many_p:
  00137	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04DBCIBANA@were?$AA@
$LN16@too_many_p:
  0013e	4d 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR [r12+184]
  00146	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0014d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00152	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00157	45 85 ed	 test	 r13d, r13d
  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@JMJOHPHL@?$CFU?$CI?$CJ?5takes?5?$CFU?5positional?5argumen@
  00161	49 0f 45 f7	 cmovne	 rsi, r15
  00165	4c 8b cf	 mov	 r9, rdi
  00168	44 89 74 24 28	 mov	 DWORD PTR [rsp+40], r14d
  0016d	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00172	e8 00 00 00 00	 call	 PyErr_Format

; 3298 :     Py_DECREF(sig);

  00177	48 8b cf	 mov	 rcx, rdi
  0017a	e8 00 00 00 00	 call	 _Py_DecRef

; 3299 :     Py_DECREF(kwonly_sig);

  0017f	48 8b cd	 mov	 rcx, rbp
$LN22@too_many_p:
  00182	e8 00 00 00 00	 call	 _Py_DecRef
  00187	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  0018c	4c 8b 7c 24 78	 mov	 r15, QWORD PTR [rsp+120]
$LN11@too_many_p:

; 3300 : }

  00191	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00199	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0019d	41 5e		 pop	 r14
  0019f	41 5d		 pop	 r13
  001a1	41 5c		 pop	 r12
  001a3	5f		 pop	 rdi
  001a4	5e		 pop	 rsi
  001a5	c3		 ret	 0
too_many_positional ENDP
_TEXT	ENDS
EXTRN	PyErr_SetObject:PROC
EXTRN	PyExc_AttributeError:QWORD
EXTRN	_PyObject_LookupSpecial:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$special_lookup DD imagerel special_lookup
	DD	imagerel special_lookup+79
	DD	imagerel $unwind$special_lookup
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$special_lookup DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT special_lookup
_TEXT	SEGMENT
o$ = 48
id$ = 56
special_lookup PROC					; COMDAT

; 3523 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 3524 :     PyObject *res;
; 3525 :     res = _PyObject_LookupSpecial(o, id);

  0000d	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00012	48 8b d8	 mov	 rbx, rax

; 3526 :     if (res == NULL && !PyErr_Occurred()) {

  00015	48 85 c0	 test	 rax, rax
  00018	75 27		 jne	 SHORT $LN1@special_lo
  0001a	e8 00 00 00 00	 call	 PyErr_Occurred
  0001f	48 85 c0	 test	 rax, rax
  00022	75 1d		 jne	 SHORT $LN1@special_lo

; 3527 :         PyErr_SetObject(PyExc_AttributeError, id->object);

  00024	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0002f	e8 00 00 00 00	 call	 PyErr_SetObject

; 3528 :         return NULL;

  00034	33 c0		 xor	 eax, eax

; 3531 : }

  00036	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
$LN1@special_lo:

; 3529 :     }
; 3530 :     return res;

  00041	48 8b c3	 mov	 rax, rbx

; 3531 : }

  00044	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
special_lookup ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$save_exc_state DD imagerel save_exc_state
	DD	imagerel save_exc_state+179
	DD	imagerel $unwind$save_exc_state
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$save_exc_state DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT save_exc_state
_TEXT	SEGMENT
tstate$ = 48
f$ = 56
save_exc_state PROC					; COMDAT

; 3538 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b d9	 mov	 rbx, rcx

; 3539 :     PyObject *type, *value, *traceback;
; 3540 :     Py_XINCREF(tstate->exc_type);

  00017	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0001b	48 8b ea	 mov	 rbp, rdx
  0001e	48 85 c9	 test	 rcx, rcx
  00021	74 05		 je	 SHORT $LN23@save_exc_s
  00023	e8 00 00 00 00	 call	 _Py_IncRef
$LN23@save_exc_s:

; 3541 :     Py_XINCREF(tstate->exc_value);

  00028	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0002c	48 85 c9	 test	 rcx, rcx
  0002f	74 05		 je	 SHORT $LN19@save_exc_s
  00031	e8 00 00 00 00	 call	 _Py_IncRef
$LN19@save_exc_s:

; 3542 :     Py_XINCREF(tstate->exc_traceback);

  00036	48 8b 4b 70	 mov	 rcx, QWORD PTR [rbx+112]
  0003a	48 85 c9	 test	 rcx, rcx
  0003d	74 05		 je	 SHORT $LN15@save_exc_s
  0003f	e8 00 00 00 00	 call	 _Py_IncRef
$LN15@save_exc_s:

; 3543 :     type = f->f_exc_type;
; 3544 :     value = f->f_exc_value;
; 3545 :     traceback = f->f_exc_traceback;
; 3546 :     f->f_exc_type = tstate->exc_type;

  00044	48 8b 43 60	 mov	 rax, QWORD PTR [rbx+96]
  00048	48 8b 8d b0 00
	00 00		 mov	 rcx, QWORD PTR [rbp+176]
  0004f	48 8b b5 b8 00
	00 00		 mov	 rsi, QWORD PTR [rbp+184]
  00056	48 8b bd c0 00
	00 00		 mov	 rdi, QWORD PTR [rbp+192]
  0005d	48 89 85 b0 00
	00 00		 mov	 QWORD PTR [rbp+176], rax

; 3547 :     f->f_exc_value = tstate->exc_value;

  00064	48 8b 43 68	 mov	 rax, QWORD PTR [rbx+104]
  00068	48 89 85 b8 00
	00 00		 mov	 QWORD PTR [rbp+184], rax

; 3548 :     f->f_exc_traceback = tstate->exc_traceback;

  0006f	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  00073	48 89 85 c0 00
	00 00		 mov	 QWORD PTR [rbp+192], rax

; 3549 :     Py_XDECREF(type);

  0007a	48 85 c9	 test	 rcx, rcx
  0007d	74 05		 je	 SHORT $LN11@save_exc_s
  0007f	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@save_exc_s:

; 3550 :     Py_XDECREF(value);

  00084	48 85 f6	 test	 rsi, rsi
  00087	74 08		 je	 SHORT $LN7@save_exc_s
  00089	48 8b ce	 mov	 rcx, rsi
  0008c	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@save_exc_s:

; 3551 :     Py_XDECREF(traceback);

  00091	48 85 ff	 test	 rdi, rdi
  00094	74 08		 je	 SHORT $LN3@save_exc_s
  00096	48 8b cf	 mov	 rcx, rdi
  00099	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@save_exc_s:

; 3552 : }

  0009e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a3	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
save_exc_state ENDP
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT swap_exc_state
_TEXT	SEGMENT
tstate$ = 8
f$ = 16
swap_exc_state PROC					; COMDAT

; 3557 :     PyObject *tmp;
; 3558 :     tmp = tstate->exc_type;

  00000	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]

; 3559 :     tstate->exc_type = f->f_exc_type;

  00004	48 8b 82 b0 00
	00 00		 mov	 rax, QWORD PTR [rdx+176]
  0000b	4c 8b c9	 mov	 r9, rcx
  0000e	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 3560 :     f->f_exc_type = tmp;
; 3561 :     tmp = tstate->exc_value;
; 3562 :     tstate->exc_value = f->f_exc_value;

  00012	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  00019	4c 89 82 b0 00
	00 00		 mov	 QWORD PTR [rdx+176], r8
  00020	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  00024	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 3563 :     f->f_exc_value = tmp;
; 3564 :     tmp = tstate->exc_traceback;
; 3565 :     tstate->exc_traceback = f->f_exc_traceback;

  00028	48 8b 82 c0 00
	00 00		 mov	 rax, QWORD PTR [rdx+192]
  0002f	4c 89 82 b8 00
	00 00		 mov	 QWORD PTR [rdx+184], r8
  00036	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0003a	49 89 41 70	 mov	 QWORD PTR [r9+112], rax

; 3566 :     f->f_exc_traceback = tmp;

  0003e	48 89 8a c0 00
	00 00		 mov	 QWORD PTR [rdx+192], rcx

; 3567 : }

  00045	c3		 ret	 0
swap_exc_state ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$restore_and_clear_exc_state DD imagerel restore_and_clear_exc_state
	DD	imagerel restore_and_clear_exc_state+128
	DD	imagerel $unwind$restore_and_clear_exc_state
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$restore_and_clear_exc_state DD 040a01H
	DD	06340aH
	DD	07006320aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT restore_and_clear_exc_state
_TEXT	SEGMENT
tstate$ = 48
f$ = 56
restore_and_clear_exc_state PROC			; COMDAT

; 3571 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3572 :     PyObject *type, *value, *tb;
; 3573 :     type = tstate->exc_type;
; 3574 :     value = tstate->exc_value;
; 3575 :     tb = tstate->exc_traceback;
; 3576 :     tstate->exc_type = f->f_exc_type;

  0000a	48 8b 82 b0 00
	00 00		 mov	 rax, QWORD PTR [rdx+176]
  00011	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00015	48 8b 79 68	 mov	 rdi, QWORD PTR [rcx+104]
  00019	48 8b 59 70	 mov	 rbx, QWORD PTR [rcx+112]
  0001d	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 3577 :     tstate->exc_value = f->f_exc_value;

  00021	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  00028	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 3578 :     tstate->exc_traceback = f->f_exc_traceback;

  0002c	48 8b 82 c0 00
	00 00		 mov	 rax, QWORD PTR [rdx+192]
  00033	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 3579 :     f->f_exc_type = NULL;

  00037	33 c0		 xor	 eax, eax
  00039	48 89 82 b0 00
	00 00		 mov	 QWORD PTR [rdx+176], rax

; 3580 :     f->f_exc_value = NULL;

  00040	48 89 82 b8 00
	00 00		 mov	 QWORD PTR [rdx+184], rax

; 3581 :     f->f_exc_traceback = NULL;

  00047	48 89 82 c0 00
	00 00		 mov	 QWORD PTR [rdx+192], rax

; 3582 :     Py_XDECREF(type);

  0004e	4d 85 c0	 test	 r8, r8
  00051	74 08		 je	 SHORT $LN11@restore_an
  00053	49 8b c8	 mov	 rcx, r8
  00056	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@restore_an:

; 3583 :     Py_XDECREF(value);

  0005b	48 85 ff	 test	 rdi, rdi
  0005e	74 08		 je	 SHORT $LN7@restore_an
  00060	48 8b cf	 mov	 rcx, rdi
  00063	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@restore_an:

; 3584 :     Py_XDECREF(tb);

  00068	48 85 db	 test	 rbx, rbx
  0006b	74 08		 je	 SHORT $LN3@restore_an
  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@restore_an:

; 3585 : }

  00075	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
restore_and_clear_exc_state ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@CHDNEAFG@exceptions?5must?5derive?5from?5Base@ ; `string'
PUBLIC	??_C@_0DA@JMBKLCHN@exception?5causes?5must?5derive?5fro@ ; `string'
PUBLIC	??_C@_0EF@HEFCNKAM@calling?5?$CFR?5should?5have?5returned?5@ ; `string'
PUBLIC	??_C@_0BP@PMICBCKC@No?5active?5exception?5to?5reraise?$AA@ ; `string'
EXTRN	PyException_SetCause:PROC
EXTRN	PyObject_CallObject:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_raise DD imagerel do_raise
	DD	imagerel do_raise+157
	DD	imagerel $unwind$do_raise
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$do_raise DD imagerel do_raise+157
	DD	imagerel do_raise+500
	DD	imagerel $chain$0$do_raise
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$do_raise DD imagerel do_raise+500
	DD	imagerel do_raise+521
	DD	imagerel $chain$1$do_raise
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$do_raise DD 021H
	DD	imagerel do_raise
	DD	imagerel do_raise+157
	DD	imagerel $unwind$do_raise
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$do_raise DD 020521H
	DD	065405H
	DD	imagerel do_raise
	DD	imagerel do_raise+157
	DD	imagerel $unwind$do_raise
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_raise DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CK@CHDNEAFG@exceptions?5must?5derive?5from?5Base@
CONST	SEGMENT
??_C@_0CK@CHDNEAFG@exceptions?5must?5derive?5from?5Base@ DB 'exceptions m'
	DB	'ust derive from BaseException', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@JMBKLCHN@exception?5causes?5must?5derive?5fro@
CONST	SEGMENT
??_C@_0DA@JMBKLCHN@exception?5causes?5must?5derive?5fro@ DB 'exception ca'
	DB	'uses must derive from BaseException', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@HEFCNKAM@calling?5?$CFR?5should?5have?5returned?5@
CONST	SEGMENT
??_C@_0EF@HEFCNKAM@calling?5?$CFR?5should?5have?5returned?5@ DB 'calling '
	DB	'%R should have returned an instance of BaseException, not %R', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PMICBCKC@No?5active?5exception?5to?5reraise?$AA@
CONST	SEGMENT
??_C@_0BP@PMICBCKC@No?5active?5exception?5to?5reraise?$AA@ DB 'No active '
	DB	'exception to reraise', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT do_raise
_TEXT	SEGMENT
exc$ = 48
cause$ = 56
do_raise PROC						; COMDAT

; 3592 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	48 8b d9	 mov	 rbx, rcx

; 3593 :     PyObject *type = NULL, *value = NULL;
; 3594 : 
; 3595 :     if (exc == NULL) {

  00015	48 85 c9	 test	 rcx, rcx
  00018	75 7f		 jne	 SHORT $LN48@do_raise

; 3596 :         /* Reraise */
; 3597 :         PyThreadState *tstate = PyThreadState_GET();

  0001a	e8 00 00 00 00	 call	 PyThreadState_Get

; 3598 :         PyObject *tb;
; 3599 :         type = tstate->exc_type;

  0001f	48 8b 58 60	 mov	 rbx, QWORD PTR [rax+96]

; 3600 :         value = tstate->exc_value;

  00023	48 8b 78 68	 mov	 rdi, QWORD PTR [rax+104]

; 3601 :         tb = tstate->exc_traceback;

  00027	48 8b 70 70	 mov	 rsi, QWORD PTR [rax+112]

; 3602 :         if (type == Py_None) {

  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00032	48 3b d8	 cmp	 rbx, rax
  00035	75 18		 jne	 SHORT $LN46@do_raise

; 3603 :             PyErr_SetString(PyExc_RuntimeError,
; 3604 :                             "No active exception to reraise");

  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@PMICBCKC@No?5active?5exception?5to?5reraise?$AA@
  00045	e8 00 00 00 00	 call	 PyErr_SetString

; 3605 :             return WHY_EXCEPTION;

  0004a	e9 a5 01 00 00	 jmp	 $LN53@do_raise
$LN46@do_raise:

; 3606 :             }
; 3607 :         Py_XINCREF(type);

  0004f	48 85 db	 test	 rbx, rbx
  00052	74 08		 je	 SHORT $LN45@do_raise
  00054	48 8b cb	 mov	 rcx, rbx
  00057	e8 00 00 00 00	 call	 _Py_IncRef
$LN45@do_raise:

; 3608 :         Py_XINCREF(value);

  0005c	48 85 ff	 test	 rdi, rdi
  0005f	74 08		 je	 SHORT $LN41@do_raise
  00061	48 8b cf	 mov	 rcx, rdi
  00064	e8 00 00 00 00	 call	 _Py_IncRef
$LN41@do_raise:

; 3609 :         Py_XINCREF(tb);

  00069	48 85 f6	 test	 rsi, rsi
  0006c	74 08		 je	 SHORT $LN37@do_raise
  0006e	48 8b ce	 mov	 rcx, rsi
  00071	e8 00 00 00 00	 call	 _Py_IncRef
$LN37@do_raise:

; 3610 :         PyErr_Restore(type, value, tb);

  00076	4c 8b c6	 mov	 r8, rsi
  00079	48 8b d7	 mov	 rdx, rdi
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 PyErr_Restore

; 3611 :         return WHY_RERAISE;

  00084	b8 04 00 00 00	 mov	 eax, 4

; 3680 :     return WHY_EXCEPTION;
; 3681 : }

  00089	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00093	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
$LN48@do_raise:

; 3612 :     }
; 3613 : 
; 3614 :     /* We support the following forms of raise:
; 3615 :        raise
; 3616 :        raise <instance>
; 3617 :        raise <type> */
; 3618 : 
; 3619 :     if (PyExceptionClass_Check(exc)) {

  00099	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0009d	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  000a2	8b 81 00 01 00
	00		 mov	 eax, DWORD PTR [rcx+256]
  000a8	85 c0		 test	 eax, eax
  000aa	79 4e		 jns	 SHORT $LN34@do_raise
  000ac	f7 83 00 01 00
	00 00 00 00 40	 test	 DWORD PTR [rbx+256], 1073741824 ; 40000000H
  000b6	74 42		 je	 SHORT $LN34@do_raise

; 3620 :         type = exc;
; 3621 :         value = PyObject_CallObject(exc, NULL);

  000b8	33 d2		 xor	 edx, edx
  000ba	48 8b cb	 mov	 rcx, rbx
  000bd	e8 00 00 00 00	 call	 PyObject_CallObject
  000c2	48 8b f0	 mov	 rsi, rax

; 3622 :         if (value == NULL)

  000c5	48 85 c0	 test	 rax, rax
  000c8	0f 84 ea 00 00
	00		 je	 $LN11@do_raise

; 3623 :             goto raise_error;
; 3624 :         if (!PyExceptionInstance_Check(value)) {

  000ce	4c 8b 48 58	 mov	 r9, QWORD PTR [rax+88]
  000d2	41 f7 81 00 01
	00 00 00 00 00
	40		 test	 DWORD PTR [r9+256], 1073741824 ; 40000000H
  000dd	75 30		 jne	 SHORT $LN29@do_raise

; 3625 :             PyErr_Format(PyExc_TypeError,
; 3626 :                          "calling %R should have returned an instance of "
; 3627 :                          "BaseException, not %R",
; 3628 :                          type, Py_TYPE(value));

  000df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@HEFCNKAM@calling?5?$CFR?5should?5have?5returned?5@
  000ed	4c 8b c3	 mov	 r8, rbx
  000f0	e8 00 00 00 00	 call	 PyErr_Format

; 3629 :             goto raise_error;

  000f5	e9 b1 00 00 00	 jmp	 $raise_error$66296
$LN34@do_raise:

; 3630 :         }
; 3631 :     }
; 3632 :     else if (PyExceptionInstance_Check(exc)) {

  000fa	0f ba e0 1e	 bt	 eax, 30
  000fe	0f 83 c3 00 00
	00		 jae	 $LN30@do_raise

; 3633 :         value = exc;

  00104	48 8b f3	 mov	 rsi, rbx

; 3634 :         type = PyExceptionInstance_Class(exc);

  00107	48 8b d9	 mov	 rbx, rcx

; 3635 :         Py_INCREF(type);

  0010a	e8 00 00 00 00	 call	 _Py_IncRef
$LN29@do_raise:

; 3643 :         goto raise_error;
; 3644 :     }
; 3645 : 
; 3646 :     if (cause) {

  0010f	48 85 ff	 test	 rdi, rdi
  00112	74 62		 je	 SHORT $LN28@do_raise

; 3647 :         PyObject *fixed_cause;
; 3648 :         if (PyExceptionClass_Check(cause)) {

  00114	48 8b 47 58	 mov	 rax, QWORD PTR [rdi+88]
  00118	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  0011e	85 c9		 test	 ecx, ecx
  00120	79 28		 jns	 SHORT $LN27@do_raise
  00122	f7 87 00 01 00
	00 00 00 00 40	 test	 DWORD PTR [rdi+256], 1073741824 ; 40000000H
  0012c	74 1c		 je	 SHORT $LN27@do_raise

; 3649 :             fixed_cause = PyObject_CallObject(cause, NULL);

  0012e	33 d2		 xor	 edx, edx
  00130	48 8b cf	 mov	 rcx, rdi
  00133	e8 00 00 00 00	 call	 PyObject_CallObject
  00138	48 8b e8	 mov	 rbp, rax

; 3650 :             if (fixed_cause == NULL)

  0013b	48 85 c0	 test	 rax, rax
  0013e	74 6b		 je	 SHORT $raise_error$66296

; 3651 :                 goto raise_error;
; 3652 :             Py_DECREF(cause);

  00140	48 8b cf	 mov	 rcx, rdi
  00143	e8 00 00 00 00	 call	 _Py_DecRef
  00148	eb 21		 jmp	 SHORT $LN21@do_raise
$LN27@do_raise:

; 3653 :         }
; 3654 :         else if (PyExceptionInstance_Check(cause)) {

  0014a	0f ba e1 1e	 bt	 ecx, 30
  0014e	73 05		 jae	 SHORT $LN24@do_raise

; 3655 :             fixed_cause = cause;

  00150	48 8b ef	 mov	 rbp, rdi
  00153	eb 16		 jmp	 SHORT $LN21@do_raise
$LN24@do_raise:

; 3656 :         }
; 3657 :         else if (cause == Py_None) {

  00155	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0015c	48 3b f8	 cmp	 rdi, rax
  0015f	75 37		 jne	 SHORT $LN22@do_raise

; 3658 :             Py_DECREF(cause);

  00161	48 8b cf	 mov	 rcx, rdi
  00164	e8 00 00 00 00	 call	 _Py_DecRef

; 3659 :             fixed_cause = NULL;

  00169	33 ed		 xor	 ebp, ebp
$LN21@do_raise:

; 3665 :             goto raise_error;
; 3666 :         }
; 3667 :         PyException_SetCause(value, fixed_cause);

  0016b	48 8b d5	 mov	 rdx, rbp
  0016e	48 8b ce	 mov	 rcx, rsi
  00171	e8 00 00 00 00	 call	 PyException_SetCause
$LN28@do_raise:

; 3668 :     }
; 3669 : 
; 3670 :     PyErr_SetObject(type, value);

  00176	48 8b d6	 mov	 rdx, rsi
  00179	48 8b cb	 mov	 rcx, rbx
  0017c	e8 00 00 00 00	 call	 PyErr_SetObject

; 3671 :     /* PyErr_SetObject incref's its arguments */
; 3672 :     Py_XDECREF(value);

  00181	48 85 f6	 test	 rsi, rsi
  00184	74 08		 je	 SHORT $LN19@do_raise
  00186	48 8b ce	 mov	 rcx, rsi
  00189	e8 00 00 00 00	 call	 _Py_DecRef
$LN19@do_raise:

; 3673 :     Py_XDECREF(type);

  0018e	48 85 db	 test	 rbx, rbx
  00191	74 5c		 je	 SHORT $LN3@do_raise
  00193	48 8b cb	 mov	 rcx, rbx

; 3674 :     return WHY_EXCEPTION;

  00196	eb 52		 jmp	 SHORT $LN52@do_raise
$LN22@do_raise:

; 3660 :         }
; 3661 :         else {
; 3662 :             PyErr_SetString(PyExc_TypeError,
; 3663 :                             "exception causes must derive from "
; 3664 :                             "BaseException");

  00198	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0019f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@JMBKLCHN@exception?5causes?5must?5derive?5fro@
  001a6	e8 00 00 00 00	 call	 PyErr_SetString
$raise_error$66296:

; 3675 : 
; 3676 : raise_error:
; 3677 :     Py_XDECREF(value);

  001ab	48 85 f6	 test	 rsi, rsi
  001ae	74 08		 je	 SHORT $LN11@do_raise
  001b0	48 8b ce	 mov	 rcx, rsi
  001b3	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@do_raise:

; 3678 :     Py_XDECREF(type);

  001b8	48 85 db	 test	 rbx, rbx
  001bb	74 25		 je	 SHORT $LN7@do_raise
  001bd	48 8b cb	 mov	 rcx, rbx
  001c0	e8 00 00 00 00	 call	 _Py_DecRef
  001c5	eb 1b		 jmp	 SHORT $LN7@do_raise
$LN30@do_raise:

; 3636 :     }
; 3637 :     else {
; 3638 :         /* Not something you can raise.  You get an exception
; 3639 :            anyway, just not what you specified :-) */
; 3640 :         Py_DECREF(exc);

  001c7	48 8b cb	 mov	 rcx, rbx
  001ca	e8 00 00 00 00	 call	 _Py_DecRef

; 3641 :         PyErr_SetString(PyExc_TypeError,
; 3642 :                         "exceptions must derive from BaseException");

  001cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  001d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CK@CHDNEAFG@exceptions?5must?5derive?5from?5Base@
  001dd	e8 00 00 00 00	 call	 PyErr_SetString
$LN7@do_raise:

; 3679 :     Py_XDECREF(cause);

  001e2	48 85 ff	 test	 rdi, rdi
  001e5	74 08		 je	 SHORT $LN3@do_raise
  001e7	48 8b cf	 mov	 rcx, rdi
$LN52@do_raise:
  001ea	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@do_raise:
  001ef	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
$LN53@do_raise:

; 3680 :     return WHY_EXCEPTION;
; 3681 : }

  001f4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  001f9	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  001fe	b8 02 00 00 00	 mov	 eax, 2
  00203	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00207	5f		 pop	 rdi
  00208	c3		 ret	 0
do_raise ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CE@PJIBMPGE@need?5more?5than?5?$CFzd?5values?5to?5unp@ ; `string'
PUBLIC	??_C@_0CI@NJMNGGAB@too?5many?5values?5to?5unpack?5?$CIexpec@ ; `string'
PUBLIC	??_C@_0CE@OJCLNMJJ@need?5more?5than?5?$CFd?5value?$CFs?5to?5unp@ ; `string'
PUBLIC	??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
EXTRN	PySequence_List:PROC
EXTRN	PyExc_ValueError:QWORD
EXTRN	PyIter_Next:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unpack_iterable DD imagerel unpack_iterable
	DD	imagerel unpack_iterable+452
	DD	imagerel $unwind$unpack_iterable
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unpack_iterable DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
xdata	ENDS
;	COMDAT ??_C@_0CE@PJIBMPGE@need?5more?5than?5?$CFzd?5values?5to?5unp@
CONST	SEGMENT
??_C@_0CE@PJIBMPGE@need?5more?5than?5?$CFzd?5values?5to?5unp@ DB 'need mo'
	DB	're than %zd values to unpack', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NJMNGGAB@too?5many?5values?5to?5unpack?5?$CIexpec@
CONST	SEGMENT
??_C@_0CI@NJMNGGAB@too?5many?5values?5to?5unpack?5?$CIexpec@ DB 'too many'
	DB	' values to unpack (expected %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OJCLNMJJ@need?5more?5than?5?$CFd?5value?$CFs?5to?5unp@
CONST	SEGMENT
??_C@_0CE@OJCLNMJJ@need?5more?5than?5?$CFd?5value?$CFs?5to?5unp@ DB 'need'
	DB	' more than %d value%s to unpack', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'v'
	DB	00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H
	DB	'L', 00H, 'L', 00H, 00H, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT unpack_iterable
_TEXT	SEGMENT
v$ = 48
argcnt$ = 56
argcntafter$ = 64
sp$ = 72
unpack_iterable PROC					; COMDAT

; 3692 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3693 :     int i = 0, j = 0;

  0001a	33 ff		 xor	 edi, edi
  0001c	49 8b d9	 mov	 rbx, r9
  0001f	4d 63 e0	 movsxd	 r12, r8d
  00022	48 63 ea	 movsxd	 rbp, edx
  00025	48 8b f1	 mov	 rsi, rcx

; 3694 :     Py_ssize_t ll = 0;
; 3695 :     PyObject *it;  /* iter(v) */
; 3696 :     PyObject *w;
; 3697 :     PyObject *l = NULL; /* variable list */
; 3698 : 
; 3699 :     assert(v != NULL);

  00028	48 85 c9	 test	 rcx, rcx
  0002b	75 1a		 jne	 SHORT $LN24@unpack_ite
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@GPCKPIHH@?$AAv?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0003b	41 b8 73 0e 00
	00		 mov	 r8d, 3699		; 00000e73H
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN24@unpack_ite:

; 3700 : 
; 3701 :     it = PyObject_GetIter(v);

  00047	48 8b ce	 mov	 rcx, rsi
  0004a	e8 00 00 00 00	 call	 PyObject_GetIter
  0004f	48 8b f0	 mov	 rsi, rax

; 3702 :     if (it == NULL)

  00052	48 85 c0	 test	 rax, rax
  00055	0f 84 a6 00 00
	00		 je	 $LN3@unpack_ite

; 3703 :         goto Error;
; 3704 : 
; 3705 :     for (; i < argcnt; i++) {

  0005b	85 ed		 test	 ebp, ebp
  0005d	7e 1b		 jle	 SHORT $LN18@unpack_ite
  0005f	90		 npad	 1
$LL20@unpack_ite:

; 3706 :         w = PyIter_Next(it);

  00060	48 8b ce	 mov	 rcx, rsi
  00063	e8 00 00 00 00	 call	 PyIter_Next

; 3707 :         if (w == NULL) {

  00068	48 85 c0	 test	 rax, rax
  0006b	74 41		 je	 SHORT $LN28@unpack_ite

; 3713 :             }
; 3714 :             goto Error;
; 3715 :         }
; 3716 :         *--sp = w;

  0006d	48 83 eb 08	 sub	 rbx, 8
  00071	ff c7		 inc	 edi
  00073	48 89 03	 mov	 QWORD PTR [rbx], rax
  00076	3b fd		 cmp	 edi, ebp
  00078	7c e6		 jl	 SHORT $LL20@unpack_ite
$LN18@unpack_ite:

; 3717 :     }
; 3718 : 
; 3719 :     if (argcntafter == -1) {
; 3720 :         /* We better have exhausted the iterator now. */
; 3721 :         w = PyIter_Next(it);

  0007a	48 8b ce	 mov	 rcx, rsi
  0007d	41 83 fc ff	 cmp	 r12d, -1
  00081	0f 85 b7 00 00
	00		 jne	 $LN15@unpack_ite
  00087	e8 00 00 00 00	 call	 PyIter_Next

; 3722 :         if (w == NULL) {

  0008c	48 85 c0	 test	 rax, rax
  0008f	0f 85 89 00 00
	00		 jne	 $LN14@unpack_ite

; 3723 :             if (PyErr_Occurred())

  00095	e8 00 00 00 00	 call	 PyErr_Occurred
  0009a	48 85 c0	 test	 rax, rax
  0009d	75 44		 jne	 SHORT $Error$66370

; 3724 :                 goto Error;
; 3725 :             Py_DECREF(it);

  0009f	48 8b ce	 mov	 rcx, rsi
  000a2	e8 00 00 00 00	 call	 _Py_DecRef

; 3726 :             return 1;

  000a7	41 8d 44 24 02	 lea	 eax, QWORD PTR [r12+2]
  000ac	eb 55		 jmp	 SHORT $LN22@unpack_ite
$LN28@unpack_ite:

; 3708 :             /* Iterator done, via error or exhaustion. */
; 3709 :             if (!PyErr_Occurred()) {

  000ae	e8 00 00 00 00	 call	 PyErr_Occurred
  000b3	48 85 c0	 test	 rax, rax
  000b6	75 2b		 jne	 SHORT $Error$66370

; 3710 :                 PyErr_Format(PyExc_ValueError,
; 3711 :                     "need more than %d value%s to unpack",
; 3712 :                     i, i == 1 ? "" : "s");

  000b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  000bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  000c6	83 ff 01	 cmp	 edi, 1
  000c9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@OJCLNMJJ@need?5more?5than?5?$CFd?5value?$CFs?5to?5unp@
  000d7	44 8b c7	 mov	 r8d, edi
  000da	4c 0f 44 c8	 cmove	 r9, rax
  000de	e8 00 00 00 00	 call	 PyErr_Format
$Error$66370:

; 3755 : 
; 3756 : Error:
; 3757 :     for (; i > 0; i--, sp++)

  000e3	85 ff		 test	 edi, edi
  000e5	7e 12		 jle	 SHORT $LN4@unpack_ite
$LL7@unpack_ite:

; 3758 :         Py_DECREF(*sp);

  000e7	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000ea	e8 00 00 00 00	 call	 _Py_DecRef
  000ef	ff cf		 dec	 edi
  000f1	48 83 c3 08	 add	 rbx, 8
  000f5	85 ff		 test	 edi, edi
  000f7	7f ee		 jg	 SHORT $LL7@unpack_ite
$LN4@unpack_ite:

; 3759 :     Py_XDECREF(it);

  000f9	48 8b ce	 mov	 rcx, rsi
  000fc	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@unpack_ite:

; 3760 :     return 0;

  00101	33 c0		 xor	 eax, eax
$LN22@unpack_ite:

; 3761 : }

  00103	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00108	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0010d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00112	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00117	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011b	41 5c		 pop	 r12
  0011d	c3		 ret	 0
$LN14@unpack_ite:

; 3727 :         }
; 3728 :         Py_DECREF(w);

  0011e	48 8b c8	 mov	 rcx, rax
  00121	e8 00 00 00 00	 call	 _Py_DecRef

; 3729 :         PyErr_Format(PyExc_ValueError, "too many values to unpack "
; 3730 :                      "(expected %d)", argcnt);

  00126	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@NJMNGGAB@too?5many?5values?5to?5unpack?5?$CIexpec@
  00134	44 8b c5	 mov	 r8d, ebp
  00137	e8 00 00 00 00	 call	 PyErr_Format

; 3731 :         goto Error;

  0013c	eb a5		 jmp	 SHORT $Error$66370
$LN15@unpack_ite:

; 3732 :     }
; 3733 : 
; 3734 :     l = PySequence_List(it);

  0013e	e8 00 00 00 00	 call	 PySequence_List
  00143	4c 8b d8	 mov	 r11, rax

; 3735 :     if (l == NULL)

  00146	48 85 c0	 test	 rax, rax
  00149	74 98		 je	 SHORT $Error$66370

; 3736 :         goto Error;
; 3737 :     *--sp = l;

  0014b	48 83 eb 08	 sub	 rbx, 8

; 3738 :     i++;

  0014f	ff c7		 inc	 edi
  00151	48 89 03	 mov	 QWORD PTR [rbx], rax

; 3739 : 
; 3740 :     ll = PyList_GET_SIZE(l);

  00154	4c 8b 48 60	 mov	 r9, QWORD PTR [rax+96]

; 3741 :     if (ll < argcntafter) {

  00158	4d 3b cc	 cmp	 r9, r12
  0015b	7d 1c		 jge	 SHORT $LN11@unpack_ite

; 3742 :         PyErr_Format(PyExc_ValueError, "need more than %zd values to unpack",
; 3743 :                      argcnt + ll);

  0015d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  00164	4d 8d 04 29	 lea	 r8, QWORD PTR [r9+rbp]
  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CE@PJIBMPGE@need?5more?5than?5?$CFzd?5values?5to?5unp@
  0016f	e8 00 00 00 00	 call	 PyErr_Format
  00174	e9 6a ff ff ff	 jmp	 $Error$66370
$LN11@unpack_ite:

; 3760 :     return 0;

  00179	4d 8b c4	 mov	 r8, r12
  0017c	45 85 e4	 test	 r12d, r12d
  0017f	7e 2a		 jle	 SHORT $LN8@unpack_ite

; 3744 :         goto Error;
; 3745 :     }
; 3746 : 
; 3747 :     /* Pop the "after-variable" args off the list. */
; 3748 :     for (j = argcntafter; j > 0; j--, i++) {
; 3749 :         *--sp = PyList_GET_ITEM(l, ll - j);

  00181	49 8b d1	 mov	 rdx, r9
  00184	49 2b d4	 sub	 rdx, r12
  00187	48 c1 e2 03	 shl	 rdx, 3
  0018b	0f 1f 44 00 00	 npad	 5
$LL10@unpack_ite:
  00190	49 8b 43 70	 mov	 rax, QWORD PTR [r11+112]
  00194	48 83 eb 08	 sub	 rbx, 8
  00198	49 ff c8	 dec	 r8
  0019b	48 8b 0c 02	 mov	 rcx, QWORD PTR [rdx+rax]
  0019f	48 83 c2 08	 add	 rdx, 8
  001a3	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  001a6	4d 85 c0	 test	 r8, r8
  001a9	7f e5		 jg	 SHORT $LL10@unpack_ite
$LN8@unpack_ite:

; 3750 :     }
; 3751 :     /* Resize the list. */
; 3752 :     Py_SIZE(l) = ll - argcntafter;

  001ab	4d 2b cc	 sub	 r9, r12

; 3753 :     Py_DECREF(it);

  001ae	48 8b ce	 mov	 rcx, rsi
  001b1	4d 89 4b 60	 mov	 QWORD PTR [r11+96], r9
  001b5	e8 00 00 00 00	 call	 _Py_DecRef

; 3754 :     return 1;

  001ba	b8 01 00 00 00	 mov	 eax, 1
  001bf	e9 3f ff ff ff	 jmp	 $LN22@unpack_ite
unpack_iterable ENDP
_TEXT	ENDS
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_03IKGEINEE@?$CFs?5?$AA@			; `string'
EXTRN	PyObject_Print:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$prtrace DD imagerel prtrace
	DD	imagerel prtrace+76
	DD	imagerel $unwind$prtrace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$prtrace DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03IKGEINEE@?$CFs?5?$AA@
CONST	SEGMENT
??_C@_03IKGEINEE@?$CFs?5?$AA@ DB '%s ', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT prtrace
_TEXT	SEGMENT
v$ = 48
str$ = 56
prtrace	PROC						; COMDAT

; 3767 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 3768 :     printf("%s ", str);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03IKGEINEE@?$CFs?5?$AA@
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 3769 :     if (PyObject_Print(v, stdout, 0) != 0)

  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0001c	45 33 c0	 xor	 r8d, r8d
  0001f	48 8d 50 30	 lea	 rdx, QWORD PTR [rax+48]
  00023	48 8b cb	 mov	 rcx, rbx
  00026	e8 00 00 00 00	 call	 PyObject_Print
  0002b	85 c0		 test	 eax, eax
  0002d	74 05		 je	 SHORT $LN1@prtrace

; 3770 :         PyErr_Clear(); /* Don't know what else to do */

  0002f	e8 00 00 00 00	 call	 PyErr_Clear
$LN1@prtrace:

; 3771 :     printf("\n");

  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 3772 :     return 1;

  00041	b8 01 00 00 00	 mov	 eax, 1

; 3773 : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5b		 pop	 rbx
  0004b	c3		 ret	 0
prtrace	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_exc_trace DD imagerel call_exc_trace
	DD	imagerel call_exc_trace+271
	DD	imagerel $unwind$call_exc_trace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_exc_trace DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT call_exc_trace
_TEXT	SEGMENT
type$ = 48
traceback$ = 56
func$ = 80
self$ = 88
f$ = 96
value$ = 104
call_exc_trace PROC					; COMDAT

; 3778 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	49 8b d8	 mov	 rbx, r8
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	48 8b e9	 mov	 rbp, rcx

; 3779 :     PyObject *type, *value, *traceback, *arg;
; 3780 :     int err;
; 3781 :     PyErr_Fetch(&type, &value, &traceback);

  0001d	4c 8d 44 24 38	 lea	 r8, QWORD PTR traceback$[rsp]
  00022	48 8d 54 24 68	 lea	 rdx, QWORD PTR value$[rsp]
  00027	48 8d 4c 24 30	 lea	 rcx, QWORD PTR type$[rsp]
  0002c	e8 00 00 00 00	 call	 PyErr_Fetch

; 3782 :     if (value == NULL) {

  00031	48 83 7c 24 68
	00		 cmp	 QWORD PTR value$[rsp], 0
  00037	75 11		 jne	 SHORT $LN16@call_exc_t

; 3783 :         value = Py_None;

  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00040	48 89 4c 24 68	 mov	 QWORD PTR value$[rsp], rcx

; 3784 :         Py_INCREF(value);

  00045	e8 00 00 00 00	 call	 _Py_IncRef
$LN16@call_exc_t:

; 3785 :     }
; 3786 :     PyErr_NormalizeException(&type, &value, &traceback);

  0004a	4c 8d 44 24 38	 lea	 r8, QWORD PTR traceback$[rsp]
  0004f	48 8d 54 24 68	 lea	 rdx, QWORD PTR value$[rsp]
  00054	48 8d 4c 24 30	 lea	 rcx, QWORD PTR type$[rsp]
  00059	e8 00 00 00 00	 call	 PyErr_NormalizeException

; 3787 :     arg = PyTuple_Pack(3, type, value, traceback);

  0005e	4c 8b 4c 24 38	 mov	 r9, QWORD PTR traceback$[rsp]
  00063	4c 8b 44 24 68	 mov	 r8, QWORD PTR value$[rsp]
  00068	48 8b 54 24 30	 mov	 rdx, QWORD PTR type$[rsp]
  0006d	b9 03 00 00 00	 mov	 ecx, 3
  00072	e8 00 00 00 00	 call	 PyTuple_Pack
  00077	48 8b f8	 mov	 rdi, rax

; 3788 :     if (arg == NULL) {

  0007a	48 85 c0	 test	 rax, rax
  0007d	75 16		 jne	 SHORT $LN15@call_exc_t

; 3789 :         PyErr_Restore(type, value, traceback);

  0007f	4c 8b 44 24 38	 mov	 r8, QWORD PTR traceback$[rsp]
  00084	48 8b 54 24 68	 mov	 rdx, QWORD PTR value$[rsp]
  00089	48 8b 4c 24 30	 mov	 rcx, QWORD PTR type$[rsp]
  0008e	e8 00 00 00 00	 call	 PyErr_Restore

; 3790 :         return;

  00093	eb 65		 jmp	 SHORT $LN2@call_exc_t
$LN15@call_exc_t:

; 3791 :     }
; 3792 :     err = call_trace(func, self, f, PyTrace_EXCEPTION, arg);

  00095	41 b9 01 00 00
	00		 mov	 r9d, 1
  0009b	4c 8b c3	 mov	 r8, rbx
  0009e	48 8b d6	 mov	 rdx, rsi
  000a1	48 8b cd	 mov	 rcx, rbp
  000a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a9	e8 00 00 00 00	 call	 call_trace

; 3793 :     Py_DECREF(arg);

  000ae	48 8b cf	 mov	 rcx, rdi
  000b1	8b d8		 mov	 ebx, eax
  000b3	e8 00 00 00 00	 call	 _Py_DecRef

; 3794 :     if (err == 0)
; 3795 :         PyErr_Restore(type, value, traceback);

  000b8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR type$[rsp]
  000bd	85 db		 test	 ebx, ebx
  000bf	75 11		 jne	 SHORT $LN12@call_exc_t
  000c1	4c 8b 44 24 38	 mov	 r8, QWORD PTR traceback$[rsp]
  000c6	48 8b 54 24 68	 mov	 rdx, QWORD PTR value$[rsp]
  000cb	e8 00 00 00 00	 call	 PyErr_Restore

; 3796 :     else {

  000d0	eb 28		 jmp	 SHORT $LN2@call_exc_t
$LN12@call_exc_t:

; 3797 :         Py_XDECREF(type);

  000d2	48 85 c9	 test	 rcx, rcx
  000d5	74 05		 je	 SHORT $LN11@call_exc_t
  000d7	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@call_exc_t:

; 3798 :         Py_XDECREF(value);

  000dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR value$[rsp]
  000e1	48 85 c9	 test	 rcx, rcx
  000e4	74 05		 je	 SHORT $LN7@call_exc_t
  000e6	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@call_exc_t:

; 3799 :         Py_XDECREF(traceback);

  000eb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR traceback$[rsp]
  000f0	48 85 c9	 test	 rcx, rcx
  000f3	74 05		 je	 SHORT $LN2@call_exc_t
  000f5	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@call_exc_t:

; 3800 :     }
; 3801 : }

  000fa	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000ff	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  00104	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00109	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010d	5f		 pop	 rdi
  0010e	c3		 ret	 0
call_exc_trace ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_trace_protected DD imagerel call_trace_protected
	DD	imagerel call_trace_protected+174
	DD	imagerel $unwind$call_trace_protected
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_trace_protected DD 081401H
	DD	0e6414H
	DD	0d5414H
	DD	0c3414H
	DD	070109214H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT call_trace_protected
_TEXT	SEGMENT
type$ = 48
value$ = 56
traceback$ = 64
func$ = 96
obj$ = 104
frame$ = 112
what$ = 120
arg$ = 128
call_trace_protected PROC				; COMDAT

; 3806 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00014	49 8b f8	 mov	 rdi, r8
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	48 8b e9	 mov	 rbp, rcx

; 3807 :     PyObject *type, *value, *traceback;
; 3808 :     int err;
; 3809 :     PyErr_Fetch(&type, &value, &traceback);

  0001d	4c 8d 44 24 40	 lea	 r8, QWORD PTR traceback$[rsp]
  00022	48 8d 54 24 38	 lea	 rdx, QWORD PTR value$[rsp]
  00027	48 8d 4c 24 30	 lea	 rcx, QWORD PTR type$[rsp]
  0002c	41 8b d9	 mov	 ebx, r9d
  0002f	e8 00 00 00 00	 call	 PyErr_Fetch

; 3810 :     err = call_trace(func, obj, frame, what, arg);

  00034	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR arg$[rsp]
  0003c	44 8b cb	 mov	 r9d, ebx
  0003f	4c 8b c7	 mov	 r8, rdi
  00042	48 8b d6	 mov	 rdx, rsi
  00045	48 8b cd	 mov	 rcx, rbp
  00048	4c 89 5c 24 20	 mov	 QWORD PTR [rsp+32], r11
  0004d	e8 00 00 00 00	 call	 call_trace

; 3811 :     if (err == 0)
; 3812 :     {
; 3813 :         PyErr_Restore(type, value, traceback);

  00052	48 8b 4c 24 30	 mov	 rcx, QWORD PTR type$[rsp]
  00057	85 c0		 test	 eax, eax
  00059	75 13		 jne	 SHORT $LN12@call_trace
  0005b	4c 8b 44 24 40	 mov	 r8, QWORD PTR traceback$[rsp]
  00060	48 8b 54 24 38	 mov	 rdx, QWORD PTR value$[rsp]
  00065	e8 00 00 00 00	 call	 PyErr_Restore

; 3814 :         return 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	eb 2b		 jmp	 SHORT $LN13@call_trace
$LN12@call_trace:

; 3815 :     }
; 3816 :     else {
; 3817 :         Py_XDECREF(type);

  0006e	48 85 c9	 test	 rcx, rcx
  00071	74 05		 je	 SHORT $LN11@call_trace
  00073	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@call_trace:

; 3818 :         Py_XDECREF(value);

  00078	48 8b 4c 24 38	 mov	 rcx, QWORD PTR value$[rsp]
  0007d	48 85 c9	 test	 rcx, rcx
  00080	74 05		 je	 SHORT $LN7@call_trace
  00082	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@call_trace:

; 3819 :         Py_XDECREF(traceback);

  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR traceback$[rsp]
  0008c	48 85 c9	 test	 rcx, rcx
  0008f	74 05		 je	 SHORT $LN3@call_trace
  00091	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@call_trace:

; 3820 :         return -1;

  00096	83 c8 ff	 or	 eax, -1
$LN13@call_trace:

; 3821 :     }
; 3822 : }

  00099	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  0009e	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  000a3	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000a8	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000ac	5f		 pop	 rdi
  000ad	c3		 ret	 0
call_trace_protected ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_trace DD imagerel call_trace
	DD	imagerel call_trace+118
	DD	imagerel $unwind$call_trace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_trace DD 064301H
	DD	067443H
	DD	07340aH
	DD	06006320aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT call_trace
_TEXT	SEGMENT
func$ = 48
obj$ = 56
frame$ = 64
what$ = 72
arg$ = 80
call_trace PROC						; COMDAT

; 3827 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3828 :     register PyThreadState *tstate = frame->f_tstate;

  0000a	49 8b 98 c8 00
	00 00		 mov	 rbx, QWORD PTR [r8+200]
  00011	45 8b d1	 mov	 r10d, r9d
  00014	49 8b c0	 mov	 rax, r8

; 3829 :     int result;
; 3830 :     if (tstate->tracing)

  00017	83 7b 20 00	 cmp	 DWORD PTR [rbx+32], 0
  0001b	4c 8b da	 mov	 r11, rdx
  0001e	48 8b f1	 mov	 rsi, rcx
  00021	74 0d		 je	 SHORT $LN1@call_trace@2

; 3831 :         return 0;

  00023	33 c0		 xor	 eax, eax

; 3838 :     return result;
; 3839 : }

  00025	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5e		 pop	 rsi
  0002f	c3		 ret	 0
$LN1@call_trace@2:

; 3832 :     tstate->tracing++;
; 3833 :     tstate->use_tracing = 0;
; 3834 :     result = func(obj, frame, what, arg);

  00030	4c 8b 4c 24 50	 mov	 r9, QWORD PTR arg$[rsp]
  00035	45 8b c2	 mov	 r8d, r10d
  00038	48 8b d0	 mov	 rdx, rax
  0003b	49 8b cb	 mov	 rcx, r11
  0003e	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00043	48 c7 43 20 01
	00 00 00	 mov	 QWORD PTR [rbx+32], 1
  0004b	33 ff		 xor	 edi, edi
  0004d	ff d6		 call	 rsi

; 3835 :     tstate->use_tracing = ((tstate->c_tracefunc != NULL)
; 3836 :                            || (tstate->c_profilefunc != NULL));

  0004f	48 39 7b 30	 cmp	 QWORD PTR [rbx+48], rdi
  00053	75 06		 jne	 SHORT $LN4@call_trace@2
  00055	48 39 7b 28	 cmp	 QWORD PTR [rbx+40], rdi
  00059	74 05		 je	 SHORT $LN5@call_trace@2
$LN4@call_trace@2:
  0005b	bf 01 00 00 00	 mov	 edi, 1
$LN5@call_trace@2:

; 3837 :     tstate->tracing--;

  00060	ff 4b 20	 dec	 DWORD PTR [rbx+32]
  00063	89 7b 24	 mov	 DWORD PTR [rbx+36], edi
  00066	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 3838 :     return result;
; 3839 : }

  0006b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00070	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00074	5e		 pop	 rsi
  00075	c3		 ret	 0
call_trace ENDP
_TEXT	ENDS
PUBLIC	PyEval_GetFrame
PUBLIC	_PyEval_CallTracing
EXTRN	PyObject_Call:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyEval_CallTracing DD imagerel $LN5
	DD	imagerel $LN5+124
	DD	imagerel $unwind$_PyEval_CallTracing
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyEval_CallTracing DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0c016321aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT _PyEval_CallTracing
_TEXT	SEGMENT
func$ = 48
args$ = 56
_PyEval_CallTracing PROC				; COMDAT

; 3843 : {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	48 8b fa	 mov	 rdi, rdx
  0001d	48 8b f1	 mov	 rsi, rcx

; 3844 :     PyFrameObject *frame = PyEval_GetFrame();

  00020	e8 00 00 00 00	 call	 PyEval_GetFrame

; 3845 :     PyThreadState *tstate = frame->f_tstate;

  00025	48 8b 98 c8 00
	00 00		 mov	 rbx, QWORD PTR [rax+200]

; 3846 :     int save_tracing = tstate->tracing;
; 3847 :     int save_use_tracing = tstate->use_tracing;
; 3848 :     PyObject *result;
; 3849 : 
; 3850 :     tstate->tracing = 0;

  0002c	33 c0		 xor	 eax, eax
  0002e	8b 6b 20	 mov	 ebp, DWORD PTR [rbx+32]
  00031	44 8b 63 24	 mov	 r12d, DWORD PTR [rbx+36]
  00035	89 43 20	 mov	 DWORD PTR [rbx+32], eax

; 3851 :     tstate->use_tracing = ((tstate->c_tracefunc != NULL)
; 3852 :                            || (tstate->c_profilefunc != NULL));

  00038	48 39 43 30	 cmp	 QWORD PTR [rbx+48], rax
  0003c	75 06		 jne	 SHORT $LN3@PyEval_Cal
  0003e	48 39 43 28	 cmp	 QWORD PTR [rbx+40], rax
  00042	74 05		 je	 SHORT $LN4@PyEval_Cal
$LN3@PyEval_Cal:
  00044	b8 01 00 00 00	 mov	 eax, 1
$LN4@PyEval_Cal:

; 3853 :     result = PyObject_Call(func, args, NULL);

  00049	45 33 c0	 xor	 r8d, r8d
  0004c	48 8b d7	 mov	 rdx, rdi
  0004f	48 8b ce	 mov	 rcx, rsi
  00052	89 43 24	 mov	 DWORD PTR [rbx+36], eax
  00055	e8 00 00 00 00	 call	 PyObject_Call

; 3854 :     tstate->tracing = save_tracing;
; 3855 :     tstate->use_tracing = save_use_tracing;
; 3856 :     return result;
; 3857 : }

  0005a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0005f	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00064	89 6b 20	 mov	 DWORD PTR [rbx+32], ebp
  00067	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0006c	44 89 63 24	 mov	 DWORD PTR [rbx+36], r12d
  00070	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	41 5c		 pop	 r12
  0007b	c3		 ret	 0
_PyEval_CallTracing ENDP
_TEXT	ENDS
EXTRN	_PyCode_CheckLineNumber:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$maybe_call_line_trace DD imagerel maybe_call_line_trace
	DD	imagerel maybe_call_line_trace+191
	DD	imagerel $unwind$maybe_call_line_trace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$maybe_call_line_trace DD 0a1801H
	DD	0d6418H
	DD	0b5418H
	DD	0a3418H
	DD	0d0145218H
	DD	07010c012H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT maybe_call_line_trace
_TEXT	SEGMENT
func$ = 80
obj$ = 88
bounds$66526 = 96
frame$ = 96
instr_lb$ = 104
instr_ub$ = 112
instr_prev$ = 120
maybe_call_line_trace PROC				; COMDAT

; 3864 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3865 :     int result = 0;
; 3866 :     int line = frame->f_lineno;
; 3867 : 
; 3868 :     /* If the last instruction executed isn't in the current
; 3869 :        instruction window, reset the window.
; 3870 :     */
; 3871 :     if (frame->f_lasti < *instr_lb || frame->f_lasti >= *instr_ub) {

  00018	48 8b 7c 24 70	 mov	 rdi, QWORD PTR instr_ub$[rsp]
  0001d	49 8b d8	 mov	 rbx, r8
  00020	45 8b 80 d4 00
	00 00		 mov	 r8d, DWORD PTR [r8+212]
  00027	4c 8b e2	 mov	 r12, rdx
  0002a	8b 93 d0 00 00
	00		 mov	 edx, DWORD PTR [rbx+208]
  00030	33 f6		 xor	 esi, esi
  00032	49 8b e9	 mov	 rbp, r9
  00035	4c 8b e9	 mov	 r13, rcx
  00038	41 3b 11	 cmp	 edx, DWORD PTR [r9]
  0003b	7c 04		 jl	 SHORT $LN3@maybe_call
  0003d	3b 17		 cmp	 edx, DWORD PTR [rdi]
  0003f	7c 1e		 jl	 SHORT $LN4@maybe_call
$LN3@maybe_call:

; 3872 :         PyAddrPair bounds;
; 3873 :         line = _PyCode_CheckLineNumber(frame->f_code, frame->f_lasti,
; 3874 :                                        &bounds);

  00041	48 8b 4b 78	 mov	 rcx, QWORD PTR [rbx+120]
  00045	4c 8d 44 24 60	 lea	 r8, QWORD PTR bounds$66526[rsp]
  0004a	e8 00 00 00 00	 call	 _PyCode_CheckLineNumber
  0004f	44 8b c0	 mov	 r8d, eax

; 3875 :         *instr_lb = bounds.ap_lower;

  00052	8b 44 24 60	 mov	 eax, DWORD PTR bounds$66526[rsp]
  00056	89 45 00	 mov	 DWORD PTR [rbp], eax

; 3876 :         *instr_ub = bounds.ap_upper;

  00059	8b 44 24 64	 mov	 eax, DWORD PTR bounds$66526[rsp+4]
  0005d	89 07		 mov	 DWORD PTR [rdi], eax
$LN4@maybe_call:

; 3877 :     }
; 3878 :     /* If the last instruction falls at the start of a line or if
; 3879 :        it represents a jump backwards, update the frame's line
; 3880 :        number and call the trace function. */
; 3881 :     if (frame->f_lasti == *instr_lb || frame->f_lasti < *instr_prev) {

  0005f	8b 83 d0 00 00
	00		 mov	 eax, DWORD PTR [rbx+208]
  00065	48 8b 7c 24 78	 mov	 rdi, QWORD PTR instr_prev$[rsp]
  0006a	3b 45 00	 cmp	 eax, DWORD PTR [rbp]
  0006d	74 04		 je	 SHORT $LN1@maybe_call
  0006f	3b 07		 cmp	 eax, DWORD PTR [rdi]
  00071	7d 29		 jge	 SHORT $LN2@maybe_call
$LN1@maybe_call:

; 3882 :         frame->f_lineno = line;
; 3883 :         result = call_trace(func, obj, frame, PyTrace_LINE, Py_None);

  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  0007a	44 89 83 d4 00
	00 00		 mov	 DWORD PTR [rbx+212], r8d
  00081	41 b9 02 00 00
	00		 mov	 r9d, 2
  00087	4c 8b c3	 mov	 r8, rbx
  0008a	49 8b d4	 mov	 rdx, r12
  0008d	49 8b cd	 mov	 rcx, r13
  00090	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00095	e8 00 00 00 00	 call	 call_trace
  0009a	8b f0		 mov	 esi, eax
$LN2@maybe_call:

; 3884 :     }
; 3885 :     *instr_prev = frame->f_lasti;

  0009c	8b 8b d0 00 00
	00		 mov	 ecx, DWORD PTR [rbx+208]

; 3886 :     return result;
; 3887 : }

  000a2	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000a7	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000ac	8b c6		 mov	 eax, esi
  000ae	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000b3	89 0f		 mov	 DWORD PTR [rdi], ecx
  000b5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b9	41 5d		 pop	 r13
  000bb	41 5c		 pop	 r12
  000bd	5f		 pop	 rdi
  000be	c3		 ret	 0
maybe_call_line_trace ENDP
_TEXT	ENDS
PUBLIC	PyEval_SetProfile
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_SetProfile DD imagerel $LN13
	DD	imagerel $LN13+144
	DD	imagerel $unwind$PyEval_SetProfile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_SetProfile DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyEval_SetProfile
_TEXT	SEGMENT
func$ = 48
arg$ = 56
PyEval_SetProfile PROC					; COMDAT

; 3891 : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fa	 mov	 rdi, rdx
  00017	48 8b f1	 mov	 rsi, rcx

; 3892 :     PyThreadState *tstate = PyThreadState_GET();

  0001a	e8 00 00 00 00	 call	 PyThreadState_Get

; 3893 :     PyObject *temp = tstate->c_profileobj;

  0001f	48 8b 68 38	 mov	 rbp, QWORD PTR [rax+56]
  00023	48 8b d8	 mov	 rbx, rax

; 3894 :     Py_XINCREF(arg);

  00026	48 85 ff	 test	 rdi, rdi
  00029	74 08		 je	 SHORT $LN7@PyEval_Set
  0002b	48 8b cf	 mov	 rcx, rdi
  0002e	e8 00 00 00 00	 call	 _Py_IncRef
$LN7@PyEval_Set:

; 3895 :     tstate->c_profilefunc = NULL;
; 3896 :     tstate->c_profileobj = NULL;
; 3897 :     /* Must make sure that tracing is not ignored if 'temp' is freed */
; 3898 :     tstate->use_tracing = tstate->c_tracefunc != NULL;

  00033	33 c0		 xor	 eax, eax
  00035	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0
  0003d	48 c7 43 38 00
	00 00 00	 mov	 QWORD PTR [rbx+56], 0
  00045	48 39 43 30	 cmp	 QWORD PTR [rbx+48], rax
  00049	0f 95 c0	 setne	 al
  0004c	89 43 24	 mov	 DWORD PTR [rbx+36], eax

; 3899 :     Py_XDECREF(temp);

  0004f	48 85 ed	 test	 rbp, rbp
  00052	74 08		 je	 SHORT $LN3@PyEval_Set
  00054	48 8b cd	 mov	 rcx, rbp
  00057	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyEval_Set:

; 3900 :     tstate->c_profilefunc = func;

  0005c	48 89 73 28	 mov	 QWORD PTR [rbx+40], rsi

; 3901 :     tstate->c_profileobj = arg;

  00060	48 89 7b 38	 mov	 QWORD PTR [rbx+56], rdi

; 3902 :     /* Flag that tracing or profiling is turned on */
; 3903 :     tstate->use_tracing = (func != NULL) || (tstate->c_tracefunc != NULL);

  00064	48 85 f6	 test	 rsi, rsi
  00067	75 0b		 jne	 SHORT $LN11@PyEval_Set
  00069	48 39 73 30	 cmp	 QWORD PTR [rbx+48], rsi
  0006d	75 05		 jne	 SHORT $LN11@PyEval_Set
  0006f	89 73 24	 mov	 DWORD PTR [rbx+36], esi
  00072	eb 07		 jmp	 SHORT $LN12@PyEval_Set
$LN11@PyEval_Set:
  00074	c7 43 24 01 00
	00 00		 mov	 DWORD PTR [rbx+36], 1
$LN12@PyEval_Set:

; 3904 : }

  0007b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00080	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00085	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
PyEval_SetProfile ENDP
_TEXT	ENDS
PUBLIC	PyEval_SetTrace
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_SetTrace DD imagerel $LN13
	DD	imagerel $LN13+175
	DD	imagerel $unwind$PyEval_SetTrace
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_SetTrace DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyEval_SetTrace
_TEXT	SEGMENT
func$ = 48
arg$ = 56
PyEval_SetTrace PROC					; COMDAT

; 3908 : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fa	 mov	 rdi, rdx
  00017	48 8b f1	 mov	 rsi, rcx

; 3909 :     PyThreadState *tstate = PyThreadState_GET();

  0001a	e8 00 00 00 00	 call	 PyThreadState_Get

; 3910 :     PyObject *temp = tstate->c_traceobj;

  0001f	48 8b 68 40	 mov	 rbp, QWORD PTR [rax+64]

; 3911 :     _Py_TracingPossible += (func != NULL) - (tstate->c_tracefunc != NULL);

  00023	45 33 c9	 xor	 r9d, r9d
  00026	48 8b d8	 mov	 rbx, rax
  00029	4c 39 48 30	 cmp	 QWORD PTR [rax+48], r9
  0002d	41 0f 95 c1	 setne	 r9b
  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 85 f6	 test	 rsi, rsi
  00037	41 0f 95 c0	 setne	 r8b
  0003b	45 2b c1	 sub	 r8d, r9d
  0003e	44 01 05 00 00
	00 00		 add	 DWORD PTR _Py_TracingPossible, r8d

; 3912 :     Py_XINCREF(arg);

  00045	48 85 ff	 test	 rdi, rdi
  00048	74 08		 je	 SHORT $LN7@PyEval_Set@2
  0004a	48 8b cf	 mov	 rcx, rdi
  0004d	e8 00 00 00 00	 call	 _Py_IncRef
$LN7@PyEval_Set@2:

; 3913 :     tstate->c_tracefunc = NULL;
; 3914 :     tstate->c_traceobj = NULL;
; 3915 :     /* Must make sure that profiling is not ignored if 'temp' is freed */
; 3916 :     tstate->use_tracing = tstate->c_profilefunc != NULL;

  00052	33 c0		 xor	 eax, eax
  00054	48 c7 43 30 00
	00 00 00	 mov	 QWORD PTR [rbx+48], 0
  0005c	48 c7 43 40 00
	00 00 00	 mov	 QWORD PTR [rbx+64], 0
  00064	48 39 43 28	 cmp	 QWORD PTR [rbx+40], rax
  00068	0f 95 c0	 setne	 al
  0006b	89 43 24	 mov	 DWORD PTR [rbx+36], eax

; 3917 :     Py_XDECREF(temp);

  0006e	48 85 ed	 test	 rbp, rbp
  00071	74 08		 je	 SHORT $LN3@PyEval_Set@2
  00073	48 8b cd	 mov	 rcx, rbp
  00076	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyEval_Set@2:

; 3918 :     tstate->c_tracefunc = func;

  0007b	48 89 73 30	 mov	 QWORD PTR [rbx+48], rsi

; 3919 :     tstate->c_traceobj = arg;

  0007f	48 89 7b 40	 mov	 QWORD PTR [rbx+64], rdi

; 3920 :     /* Flag that tracing or profiling is turned on */
; 3921 :     tstate->use_tracing = ((func != NULL)
; 3922 :                            || (tstate->c_profilefunc != NULL));

  00083	48 85 f6	 test	 rsi, rsi
  00086	75 0b		 jne	 SHORT $LN11@PyEval_Set@2
  00088	48 39 73 28	 cmp	 QWORD PTR [rbx+40], rsi
  0008c	75 05		 jne	 SHORT $LN11@PyEval_Set@2
  0008e	89 73 24	 mov	 DWORD PTR [rbx+36], esi
  00091	eb 07		 jmp	 SHORT $LN12@PyEval_Set@2
$LN11@PyEval_Set@2:
  00093	c7 43 24 01 00
	00 00		 mov	 DWORD PTR [rbx+36], 1
$LN12@PyEval_Set@2:

; 3923 : }

  0009a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009f	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000a4	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000a9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ad	5f		 pop	 rdi
  000ae	c3		 ret	 0
PyEval_SetTrace ENDP
_TEXT	ENDS
PUBLIC	PyEval_GetBuiltins
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_GetBuiltins DD imagerel $LN5
	DD	imagerel $LN5+44
	DD	imagerel $unwind$PyEval_GetBuiltins
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_GetBuiltins DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyEval_GetBuiltins
_TEXT	SEGMENT
PyEval_GetBuiltins PROC					; COMDAT

; 3927 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3928 :     PyFrameObject *current_frame = PyEval_GetFrame();

  00004	e8 00 00 00 00	 call	 PyEval_GetFrame

; 3929 :     if (current_frame == NULL)

  00009	48 85 c0	 test	 rax, rax
  0000c	75 12		 jne	 SHORT $LN2@PyEval_Get

; 3930 :         return PyThreadState_GET()->interp->builtins;

  0000e	e8 00 00 00 00	 call	 PyThreadState_Get
  00013	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00017	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]

; 3933 : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
$LN2@PyEval_Get:

; 3931 :     else
; 3932 :         return current_frame->f_builtins;

  00020	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]

; 3933 : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
PyEval_GetBuiltins ENDP
_TEXT	ENDS
PUBLIC	PyEval_GetLocals
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_GetLocals DD imagerel $LN4
	DD	imagerel $LN4+46
	DD	imagerel $unwind$PyEval_GetLocals
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_GetLocals DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyEval_GetLocals
_TEXT	SEGMENT
PyEval_GetLocals PROC					; COMDAT

; 3937 : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3938 :     PyFrameObject *current_frame = PyEval_GetFrame();

  00006	e8 00 00 00 00	 call	 PyEval_GetFrame
  0000b	48 8b d8	 mov	 rbx, rax

; 3939 :     if (current_frame == NULL)

  0000e	48 85 c0	 test	 rax, rax
  00011	75 06		 jne	 SHORT $LN1@PyEval_Get@2

; 3943 : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5b		 pop	 rbx
  00018	c3		 ret	 0
$LN1@PyEval_Get@2:

; 3940 :         return NULL;
; 3941 :     PyFrame_FastToLocals(current_frame);

  00019	48 8b c8	 mov	 rcx, rax
  0001c	e8 00 00 00 00	 call	 PyFrame_FastToLocals

; 3942 :     return current_frame->f_locals;

  00021	48 8b 83 90 00
	00 00		 mov	 rax, QWORD PTR [rbx+144]

; 3943 : }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx
  0002d	c3		 ret	 0
PyEval_GetLocals ENDP
_TEXT	ENDS
PUBLIC	PyEval_GetGlobals
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_GetGlobals DD imagerel $LN5
	DD	imagerel $LN5+31
	DD	imagerel $unwind$PyEval_GetGlobals
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_GetGlobals DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyEval_GetGlobals
_TEXT	SEGMENT
PyEval_GetGlobals PROC					; COMDAT

; 3947 : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3948 :     PyFrameObject *current_frame = PyEval_GetFrame();

  00004	e8 00 00 00 00	 call	 PyEval_GetFrame

; 3949 :     if (current_frame == NULL)

  00009	48 85 c0	 test	 rax, rax
  0000c	75 05		 jne	 SHORT $LN2@PyEval_Get@3

; 3953 : }

  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	c3		 ret	 0
$LN2@PyEval_Get@3:

; 3950 :         return NULL;
; 3951 :     else
; 3952 :         return current_frame->f_globals;

  00013	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]

; 3953 : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
PyEval_GetGlobals ENDP
_TEXT	ENDS
EXTRN	_PyThreadState_GetFrame:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_GetFrame DD imagerel $LN3
	DD	imagerel $LN3+23
	DD	imagerel $unwind$PyEval_GetFrame
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_GetFrame DD 010401H
	DD	04204H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyEval_GetFrame
_TEXT	SEGMENT
PyEval_GetFrame PROC					; COMDAT

; 3957 : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3958 :     PyThreadState *tstate = PyThreadState_GET();

  00004	e8 00 00 00 00	 call	 PyThreadState_Get

; 3959 :     return _PyThreadState_GetFrame(tstate);

  00009	48 8b c8	 mov	 rcx, rax

; 3960 : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00010	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR _PyThreadState_GetFrame
PyEval_GetFrame ENDP
_TEXT	ENDS
PUBLIC	PyEval_MergeCompilerFlags
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_MergeCompilerFlags DD imagerel $LN7
	DD	imagerel $LN7+72
	DD	imagerel $unwind$PyEval_MergeCompilerFlags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_MergeCompilerFlags DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT PyEval_MergeCompilerFlags
_TEXT	SEGMENT
cf$ = 48
PyEval_MergeCompilerFlags PROC				; COMDAT

; 3964 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 3965 :     PyFrameObject *current_frame = PyEval_GetFrame();

  00009	e8 00 00 00 00	 call	 PyEval_GetFrame

; 3966 :     int result = cf->cf_flags != 0;

  0000e	44 8b 03	 mov	 r8d, DWORD PTR [rbx]
  00011	33 d2		 xor	 edx, edx
  00013	45 85 c0	 test	 r8d, r8d
  00016	0f 95 c2	 setne	 dl

; 3967 : 
; 3968 :     if (current_frame != NULL) {

  00019	48 85 c0	 test	 rax, rax
  0001c	74 22		 je	 SHORT $LN6@PyEval_Mer

; 3969 :         const int codeflags = current_frame->f_code->co_flags;
; 3970 :         const int compilerflags = codeflags & PyCF_MASK;

  0001e	48 8b 40 78	 mov	 rax, QWORD PTR [rax+120]
  00022	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  00026	41 81 e1 00 e0
	07 00		 and	 r9d, 516096		; 0007e000H

; 3971 :         if (compilerflags) {

  0002d	74 11		 je	 SHORT $LN6@PyEval_Mer

; 3972 :             result = 1;
; 3973 :             cf->cf_flags |= compilerflags;

  0002f	45 0b c1	 or	 r8d, r9d

; 3974 :         }
; 3975 : #if 0 /* future keyword */
; 3976 :         if (codeflags & CO_GENERATOR_ALLOWED) {
; 3977 :             result = 1;
; 3978 :             cf->cf_flags |= CO_GENERATOR_ALLOWED;
; 3979 :         }
; 3980 : #endif
; 3981 :     }
; 3982 :     return result;

  00032	b8 01 00 00 00	 mov	 eax, 1
  00037	44 89 03	 mov	 DWORD PTR [rbx], r8d

; 3983 : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
$LN6@PyEval_Mer:

; 3974 :         }
; 3975 : #if 0 /* future keyword */
; 3976 :         if (codeflags & CO_GENERATOR_ALLOWED) {
; 3977 :             result = 1;
; 3978 :             cf->cf_flags |= CO_GENERATOR_ALLOWED;
; 3979 :         }
; 3980 : #endif
; 3981 :     }
; 3982 :     return result;

  00040	8b c2		 mov	 eax, edx

; 3983 : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
PyEval_MergeCompilerFlags ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@CDJCHJOA@keyword?5list?5must?5be?5a?5dictionar@ ; `string'
PUBLIC	??_C@_0BO@MAFBIHIP@argument?5list?5must?5be?5a?5tuple?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyEval_CallObjectWithKeywords DD imagerel $LN9
	DD	imagerel $LN9+231
	DD	imagerel $unwind$PyEval_CallObjectWithKeywords
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyEval_CallObjectWithKeywords DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT ??_C@_0CC@CDJCHJOA@keyword?5list?5must?5be?5a?5dictionar@
CONST	SEGMENT
??_C@_0CC@CDJCHJOA@keyword?5list?5must?5be?5a?5dictionar@ DB 'keyword lis'
	DB	't must be a dictionary', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@MAFBIHIP@argument?5list?5must?5be?5a?5tuple?$AA@
CONST	SEGMENT
??_C@_0BO@MAFBIHIP@argument?5list?5must?5be?5a?5tuple?$AA@ DB 'argument l'
	DB	'ist must be a tuple', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_CallObjectWithKeywords
_TEXT	SEGMENT
func$ = 48
arg$ = 56
kw$ = 64
PyEval_CallObjectWithKeywords PROC			; COMDAT

; 3991 : {

$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b d8	 mov	 rbx, r8
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 3992 :     PyObject *result;
; 3993 : 
; 3994 :     if (arg == NULL) {

  00018	48 85 d2	 test	 rdx, rdx
  0001b	75 1f		 jne	 SHORT $LN6@PyEval_Cal@2

; 3995 :         arg = PyTuple_New(0);

  0001d	33 c9		 xor	 ecx, ecx
  0001f	e8 00 00 00 00	 call	 PyTuple_New
  00024	48 8b f8	 mov	 rdi, rax

; 3996 :         if (arg == NULL)

  00027	48 85 c0	 test	 rax, rax
  0002a	75 4d		 jne	 SHORT $LN2@PyEval_Cal@2

; 4016 :     return result;
; 4017 : }

  0002c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00031	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
$LN6@PyEval_Cal@2:

; 3997 :             return NULL;
; 3998 :     }
; 3999 :     else if (!PyTuple_Check(arg)) {

  0003c	48 8b 42 58	 mov	 rax, QWORD PTR [rdx+88]
  00040	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  0004a	75 25		 jne	 SHORT $LN3@PyEval_Cal@2

; 4000 :         PyErr_SetString(PyExc_TypeError,
; 4001 :                         "argument list must be a tuple");

  0004c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@MAFBIHIP@argument?5list?5must?5be?5a?5tuple?$AA@
  0005a	e8 00 00 00 00	 call	 PyErr_SetString

; 4002 :         return NULL;

  0005f	33 c0		 xor	 eax, eax

; 4016 :     return result;
; 4017 : }

  00061	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00066	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
$LN3@PyEval_Cal@2:

; 4003 :     }
; 4004 :     else
; 4005 :         Py_INCREF(arg);

  00071	48 8b ca	 mov	 rcx, rdx
  00074	e8 00 00 00 00	 call	 _Py_IncRef
$LN2@PyEval_Cal@2:

; 4006 : 
; 4007 :     if (kw != NULL && !PyDict_Check(kw)) {

  00079	48 85 db	 test	 rbx, rbx
  0007c	74 3d		 je	 SHORT $LN1@PyEval_Cal@2
  0007e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00082	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  0008c	75 2d		 jne	 SHORT $LN1@PyEval_Cal@2

; 4008 :         PyErr_SetString(PyExc_TypeError,
; 4009 :                         "keyword list must be a dictionary");

  0008e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@CDJCHJOA@keyword?5list?5must?5be?5a?5dictionar@
  0009c	e8 00 00 00 00	 call	 PyErr_SetString

; 4010 :         Py_DECREF(arg);

  000a1	48 8b cf	 mov	 rcx, rdi
  000a4	e8 00 00 00 00	 call	 _Py_DecRef

; 4011 :         return NULL;

  000a9	33 c0		 xor	 eax, eax

; 4016 :     return result;
; 4017 : }

  000ab	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b0	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b9	5f		 pop	 rdi
  000ba	c3		 ret	 0
$LN1@PyEval_Cal@2:

; 4012 :     }
; 4013 : 
; 4014 :     result = PyObject_Call(func, arg, kw);

  000bb	4c 8b c3	 mov	 r8, rbx
  000be	48 8b d7	 mov	 rdx, rdi
  000c1	48 8b ce	 mov	 rcx, rsi
  000c4	e8 00 00 00 00	 call	 PyObject_Call

; 4015 :     Py_DECREF(arg);

  000c9	48 8b cf	 mov	 rcx, rdi
  000cc	48 8b d8	 mov	 rbx, rax
  000cf	e8 00 00 00 00	 call	 _Py_DecRef

; 4016 :     return result;
; 4017 : }

  000d4	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000d9	48 8b c3	 mov	 rax, rbx
  000dc	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	5f		 pop	 rdi
  000e6	c3		 ret	 0
PyEval_CallObjectWithKeywords ENDP
_TEXT	ENDS
PUBLIC	PyEval_GetFuncName
EXTRN	PyCFunction_Type:BYTE
EXTRN	PyUnicode_AsUTF8:PROC
EXTRN	PyFunction_Type:BYTE
; Function compile flags: /Ogtp
;	COMDAT PyEval_GetFuncName
_TEXT	SEGMENT
func$ = 8
PyEval_GetFuncName PROC					; COMDAT

; 4022 :     if (PyMethod_Check(func))

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyMethod_Type
  00007	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0000b	75 0d		 jne	 SHORT $LN6@PyEval_Get@4
  0000d	0f 1f 00	 npad	 3
$LL9@PyEval_Get@4:

; 4023 :         return PyEval_GetFuncName(PyMethod_GET_FUNCTION(func));

  00010	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00014	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00018	74 f6		 je	 SHORT $LL9@PyEval_Get@4
$LN6@PyEval_Get@4:

; 4024 :     else if (PyFunction_Check(func))

  0001a	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFunction_Type
  00025	48 3b c2	 cmp	 rax, rdx
  00028	75 0c		 jne	 SHORT $LN4@PyEval_Get@4

; 4025 :         return _PyUnicode_AsString(((PyFunctionObject*)func)->func_name);

  0002a	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]

; 4030 : }

  00031	e9 00 00 00 00	 jmp	 PyUnicode_AsUTF8
$LN4@PyEval_Get@4:

; 4026 :     else if (PyCFunction_Check(func))

  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyCFunction_Type
  0003d	48 3b c2	 cmp	 rax, rdx
  00040	75 08		 jne	 SHORT $LN2@PyEval_Get@4

; 4027 :         return ((PyCFunctionObject*)func)->m_ml->ml_name;

  00042	48 8b 41 60	 mov	 rax, QWORD PTR [rcx+96]
  00046	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 4030 : }

  00049	c3		 ret	 0
$LN2@PyEval_Get@4:

; 4028 :     else
; 4029 :         return func->ob_type->tp_name;

  0004a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]

; 4030 : }

  0004e	c3		 ret	 0
PyEval_GetFuncName ENDP
_TEXT	ENDS
PUBLIC	??_C@_07IFNBHBML@?5object?$AA@			; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ?$AA@			; `string'
PUBLIC	PyEval_GetFuncDesc
;	COMDAT ??_C@_07IFNBHBML@?5object?$AA@
CONST	SEGMENT
??_C@_07IFNBHBML@?5object?$AA@ DB ' object', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ?$AA@ DB '()', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT PyEval_GetFuncDesc
_TEXT	SEGMENT
func$ = 8
PyEval_GetFuncDesc PROC					; COMDAT

; 4035 :     if (PyMethod_Check(func))

  00000	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyMethod_Type
  0000b	48 3b c1	 cmp	 rax, rcx
  0000e	75 08		 jne	 SHORT $LN6@PyEval_Get@5
$LN9@PyEval_Get@5:

; 4036 :         return "()";

  00010	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@

; 4043 : }

  00017	c3		 ret	 0
$LN6@PyEval_Get@5:

; 4037 :     else if (PyFunction_Check(func))

  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyFunction_Type
  0001f	48 3b c1	 cmp	 rax, rcx

; 4038 :         return "()";

  00022	74 ec		 je	 SHORT $LN9@PyEval_Get@5

; 4039 :     else if (PyCFunction_Check(func))

  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyCFunction_Type
  0002b	48 3b c1	 cmp	 rax, rcx

; 4040 :         return "()";

  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02HCKGKOFO@?$CI?$CJ?$AA@
  00035	74 07		 je	 SHORT $LN1@PyEval_Get@5

; 4041 :     else
; 4042 :         return " object";

  00037	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07IFNBHBML@?5object?$AA@
$LN1@PyEval_Get@5:

; 4043 : }

  0003e	f3 c3		 fatret	 0
PyEval_GetFuncDesc ENDP
_TEXT	ENDS
PUBLIC	??_C@_07PACKFCLP@ext_pop?$AA@			; `string'
EXTRN	PyCFunction_Call:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_function DD imagerel call_function
	DD	imagerel call_function+12
	DD	imagerel $unwind$call_function
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$call_function DD imagerel call_function+12
	DD	imagerel call_function+896
	DD	imagerel $chain$4$call_function
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$call_function DD imagerel call_function+896
	DD	imagerel call_function+956
	DD	imagerel $chain$5$call_function
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$call_function DD 021H
	DD	imagerel call_function
	DD	imagerel call_function+12
	DD	imagerel $unwind$call_function
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$call_function DD 0a3121H
	DD	06f431H
	DD	07d41aH
	DD	0ec40fH
	DD	0d640aH
	DD	0c5405H
	DD	imagerel call_function
	DD	imagerel call_function+12
	DD	imagerel $unwind$call_function
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_function DD 040901H
	DD	0e0057209H
	DD	030027003H
xdata	ENDS
;	COMDAT ??_C@_07PACKFCLP@ext_pop?$AA@
CONST	SEGMENT
??_C@_07PACKFCLP@ext_pop?$AA@ DB 'ext_pop', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT call_function
_TEXT	SEGMENT
pp_stack$ = 96
oparg$ = 104
call_function PROC					; COMDAT

; 4098 : {

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 4099 :     int na = oparg & 0xff;
; 4100 :     int nk = (oparg>>8) & 0xff;
; 4101 :     int n = na + 2 * nk;
; 4102 :     PyObject **pfunc = (*pp_stack) - n - 1;

  00009	4c 8b 31	 mov	 r14, QWORD PTR [rcx]
  0000c	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00011	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  00016	4c 89 64 24 70	 mov	 QWORD PTR [rsp+112], r12
  0001b	0f b6 fa	 movzx	 edi, dl
  0001e	c1 fa 08	 sar	 edx, 8
  00021	4c 89 6c 24 38	 mov	 QWORD PTR [rsp+56], r13
  00026	44 0f b6 e2	 movzx	 r12d, dl
  0002a	48 8b d9	 mov	 rbx, rcx
  0002d	46 8d 2c 67	 lea	 r13d, DWORD PTR [rdi+r12*2]

; 4103 :     PyObject *func = *pfunc;
; 4104 :     PyObject *x, *w;
; 4105 : 
; 4106 :     /* Always dispatch PyCFunction first, because these are
; 4107 :        presumed to be the most frequent callable object.
; 4108 :     */
; 4109 :     if (PyCFunction_Check(func) && nk == 0) {

  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyCFunction_Type
  00038	4c 89 7c 24 30	 mov	 QWORD PTR [rsp+48], r15
  0003d	49 63 c5	 movsxd	 rax, r13d
  00040	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  00048	4c 2b f0	 sub	 r14, rax
  0004b	49 8b 36	 mov	 rsi, QWORD PTR [r14]
  0004e	48 8b 46 58	 mov	 rax, QWORD PTR [rsi+88]
  00052	48 3b c1	 cmp	 rax, rcx
  00055	0f 85 89 02 00
	00		 jne	 $LN42@call_funct
  0005b	84 d2		 test	 dl, dl
  0005d	0f 85 81 02 00
	00		 jne	 $LN42@call_funct

; 4110 :         int flags = PyCFunction_GET_FLAGS(func);

  00063	48 8b 46 60	 mov	 rax, QWORD PTR [rsi+96]
  00067	44 8b 60 10	 mov	 r12d, DWORD PTR [rax+16]

; 4111 :         PyThreadState *tstate = PyThreadState_GET();

  0006b	e8 00 00 00 00	 call	 PyThreadState_Get
  00070	48 8b e8	 mov	 rbp, rax

; 4112 : 
; 4113 :         PCALL(PCALL_CFUNCTION);
; 4114 :         if (flags & (METH_NOARGS | METH_O)) {

  00073	41 f6 c4 0c	 test	 r12b, 12
  00077	0f 84 ba 01 00
	00		 je	 $LN41@call_funct

; 4115 :             PyCFunction meth = PyCFunction_GET_FUNCTION(func);

  0007d	48 8b 4e 60	 mov	 rcx, QWORD PTR [rsi+96]

; 4116 :             PyObject *self = PyCFunction_GET_SELF(func);

  00081	f6 41 10 20	 test	 BYTE PTR [rcx+16], 32	; 00000020H
  00085	4c 8b 79 08	 mov	 r15, QWORD PTR [rcx+8]
  00089	74 05		 je	 SHORT $LN45@call_funct
  0008b	45 33 ed	 xor	 r13d, r13d
  0008e	eb 04		 jmp	 SHORT $LN46@call_funct
$LN45@call_funct:
  00090	4c 8b 6e 68	 mov	 r13, QWORD PTR [rsi+104]
$LN46@call_funct:

; 4117 :             if (flags & METH_NOARGS && na == 0) {

  00094	41 f6 c4 04	 test	 r12b, 4
  00098	0f 84 a5 00 00
	00		 je	 $LN40@call_funct
  0009e	85 ff		 test	 edi, edi
  000a0	0f 85 9d 00 00
	00		 jne	 $LN40@call_funct

; 4118 :                 C_TRACE(x, (*meth)(self,NULL));

  000a6	39 78 24	 cmp	 DWORD PTR [rax+36], edi
  000a9	0f 84 84 00 00
	00		 je	 $LN39@call_funct
  000af	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000b3	48 85 c9	 test	 rcx, rcx
  000b6	74 7b		 je	 SHORT $LN39@call_funct
  000b8	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  000bc	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  000c0	44 8d 4f 04	 lea	 r9d, QWORD PTR [rdi+4]
  000c4	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000c9	e8 00 00 00 00	 call	 call_trace
  000ce	85 c0		 test	 eax, eax
  000d0	74 07		 je	 SHORT $LN38@call_funct
  000d2	33 ff		 xor	 edi, edi
  000d4	e9 89 02 00 00	 jmp	 $LN49@call_funct
$LN38@call_funct:
  000d9	33 d2		 xor	 edx, edx
  000db	49 8b cd	 mov	 rcx, r13
  000de	41 ff d7	 call	 r15
  000e1	48 8b 4d 28	 mov	 rcx, QWORD PTR [rbp+40]
  000e5	48 8b f8	 mov	 rdi, rax
  000e8	48 85 c9	 test	 rcx, rcx
  000eb	0f 84 71 02 00
	00		 je	 $LN49@call_funct
  000f1	4c 8b 45 10	 mov	 r8, QWORD PTR [rbp+16]
  000f5	48 8b 55 38	 mov	 rdx, QWORD PTR [rbp+56]
  000f9	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000fe	48 85 c0	 test	 rax, rax
  00101	75 0e		 jne	 SHORT $LN35@call_funct
  00103	44 8d 48 05	 lea	 r9d, QWORD PTR [rax+5]
  00107	e8 00 00 00 00	 call	 call_trace_protected
  0010c	e9 51 02 00 00	 jmp	 $LN49@call_funct
$LN35@call_funct:
  00111	41 b9 06 00 00
	00		 mov	 r9d, 6
  00117	e8 00 00 00 00	 call	 call_trace
  0011c	85 c0		 test	 eax, eax
  0011e	0f 84 3e 02 00
	00		 je	 $LN49@call_funct
  00124	48 8b cf	 mov	 rcx, rdi
  00127	e8 00 00 00 00	 call	 _Py_DecRef
  0012c	33 ff		 xor	 edi, edi
  0012e	e9 2f 02 00 00	 jmp	 $LN49@call_funct
$LN39@call_funct:
  00133	33 d2		 xor	 edx, edx
  00135	49 8b cd	 mov	 rcx, r13
  00138	41 ff d7	 call	 r15
  0013b	48 8b f8	 mov	 rdi, rax
  0013e	e9 1f 02 00 00	 jmp	 $LN49@call_funct
$LN40@call_funct:

; 4119 :             }
; 4120 :             else if (flags & METH_O && na == 1) {

  00143	41 f6 c4 08	 test	 r12b, 8
  00147	0f 84 d5 00 00
	00		 je	 $LN30@call_funct
  0014d	83 ff 01	 cmp	 edi, 1
  00150	0f 85 cc 00 00
	00		 jne	 $LN30@call_funct

; 4121 :                 PyObject *arg = EXT_POP(*pp_stack);

  00156	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0015d	74 13		 je	 SHORT $LN47@call_funct
  0015f	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00162	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07PACKFCLP@ext_pop?$AA@
  00169	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0016d	e8 00 00 00 00	 call	 prtrace
$LN47@call_funct:
  00172	48 83 03 f8	 add	 QWORD PTR [rbx], -8

; 4122 :                 C_TRACE(x, (*meth)(self,arg));

  00176	83 7d 24 00	 cmp	 DWORD PTR [rbp+36], 0
  0017a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0017d	4c 8b 20	 mov	 r12, QWORD PTR [rax]
  00180	0f 84 88 00 00
	00		 je	 $LN29@call_funct
  00186	48 8b 4d 28	 mov	 rcx, QWORD PTR [rbp+40]
  0018a	48 85 c9	 test	 rcx, rcx
  0018d	74 7f		 je	 SHORT $LN29@call_funct
  0018f	4c 8b 45 10	 mov	 r8, QWORD PTR [rbp+16]
  00193	48 8b 55 38	 mov	 rdx, QWORD PTR [rbp+56]
  00197	41 b9 04 00 00
	00		 mov	 r9d, 4
  0019d	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  001a2	e8 00 00 00 00	 call	 call_trace
  001a7	85 c0		 test	 eax, eax
  001a9	74 0a		 je	 SHORT $LN28@call_funct
  001ab	33 ff		 xor	 edi, edi

; 4123 :                 Py_DECREF(arg);

  001ad	49 8b cc	 mov	 rcx, r12

; 4124 :             }
; 4125 :             else {

  001b0	e9 a8 01 00 00	 jmp	 $LN52@call_funct
$LN28@call_funct:

; 4122 :                 C_TRACE(x, (*meth)(self,arg));

  001b5	49 8b d4	 mov	 rdx, r12
  001b8	49 8b cd	 mov	 rcx, r13
  001bb	41 ff d7	 call	 r15
  001be	48 8b 4d 28	 mov	 rcx, QWORD PTR [rbp+40]
  001c2	48 8b f8	 mov	 rdi, rax
  001c5	48 85 c9	 test	 rcx, rcx
  001c8	74 50		 je	 SHORT $LN22@call_funct
  001ca	4c 8b 45 10	 mov	 r8, QWORD PTR [rbp+16]
  001ce	48 8b 55 38	 mov	 rdx, QWORD PTR [rbp+56]
  001d2	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  001d7	48 85 c0	 test	 rax, rax
  001da	75 11		 jne	 SHORT $LN25@call_funct
  001dc	44 8d 48 05	 lea	 r9d, QWORD PTR [rax+5]
  001e0	e8 00 00 00 00	 call	 call_trace_protected

; 4123 :                 Py_DECREF(arg);

  001e5	49 8b cc	 mov	 rcx, r12

; 4124 :             }
; 4125 :             else {

  001e8	e9 70 01 00 00	 jmp	 $LN52@call_funct
$LN25@call_funct:

; 4122 :                 C_TRACE(x, (*meth)(self,arg));

  001ed	41 b9 06 00 00
	00		 mov	 r9d, 6
  001f3	e8 00 00 00 00	 call	 call_trace
  001f8	85 c0		 test	 eax, eax
  001fa	74 1e		 je	 SHORT $LN22@call_funct
  001fc	48 8b cf	 mov	 rcx, rdi
  001ff	e8 00 00 00 00	 call	 _Py_DecRef
  00204	33 ff		 xor	 edi, edi

; 4123 :                 Py_DECREF(arg);

  00206	49 8b cc	 mov	 rcx, r12

; 4124 :             }
; 4125 :             else {

  00209	e9 4f 01 00 00	 jmp	 $LN52@call_funct
$LN29@call_funct:

; 4122 :                 C_TRACE(x, (*meth)(self,arg));

  0020e	49 8b d4	 mov	 rdx, r12
  00211	49 8b cd	 mov	 rcx, r13
  00214	41 ff d7	 call	 r15
  00217	48 8b f8	 mov	 rdi, rax
$LN22@call_funct:

; 4123 :                 Py_DECREF(arg);

  0021a	49 8b cc	 mov	 rcx, r12

; 4124 :             }
; 4125 :             else {

  0021d	e9 3b 01 00 00	 jmp	 $LN52@call_funct
$LN30@call_funct:

; 4126 :                 err_args(func, flags, na);

  00222	44 8b c7	 mov	 r8d, edi
  00225	41 8b d4	 mov	 edx, r12d
  00228	48 8b ce	 mov	 rcx, rsi
  0022b	e8 00 00 00 00	 call	 err_args

; 4127 :                 x = NULL;

  00230	33 ff		 xor	 edi, edi

; 4128 :             }
; 4129 :         }
; 4130 :         else {

  00232	e9 2b 01 00 00	 jmp	 $LN49@call_funct
$LN41@call_funct:

; 4131 :             PyObject *callargs;
; 4132 :             callargs = load_args(pp_stack, na);

  00237	8b d7		 mov	 edx, edi
  00239	48 8b cb	 mov	 rcx, rbx
  0023c	e8 00 00 00 00	 call	 load_args

; 4133 :             READ_TIMESTAMP(*pintr0);
; 4134 :             C_TRACE(x, PyCFunction_Call(func,callargs,NULL));

  00241	83 7d 24 00	 cmp	 DWORD PTR [rbp+36], 0
  00245	4c 8b e0	 mov	 r12, rax
  00248	74 7b		 je	 SHORT $LN19@call_funct
  0024a	48 8b 4d 28	 mov	 rcx, QWORD PTR [rbp+40]
  0024e	48 85 c9	 test	 rcx, rcx
  00251	74 72		 je	 SHORT $LN19@call_funct
  00253	4c 8b 45 10	 mov	 r8, QWORD PTR [rbp+16]
  00257	48 8b 55 38	 mov	 rdx, QWORD PTR [rbp+56]
  0025b	41 b9 04 00 00
	00		 mov	 r9d, 4
  00261	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00266	e8 00 00 00 00	 call	 call_trace
  0026b	85 c0		 test	 eax, eax
  0026d	74 04		 je	 SHORT $LN18@call_funct
  0026f	33 ff		 xor	 edi, edi
  00271	eb 63		 jmp	 SHORT $LN11@call_funct
$LN18@call_funct:
  00273	45 33 c0	 xor	 r8d, r8d
  00276	49 8b d4	 mov	 rdx, r12
  00279	48 8b ce	 mov	 rcx, rsi
  0027c	e8 00 00 00 00	 call	 PyCFunction_Call
  00281	48 8b 4d 28	 mov	 rcx, QWORD PTR [rbp+40]
  00285	48 8b f8	 mov	 rdi, rax
  00288	48 85 c9	 test	 rcx, rcx
  0028b	74 49		 je	 SHORT $LN11@call_funct
  0028d	4c 8b 45 10	 mov	 r8, QWORD PTR [rbp+16]
  00291	48 8b 55 38	 mov	 rdx, QWORD PTR [rbp+56]
  00295	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0029a	48 85 c0	 test	 rax, rax
  0029d	75 0b		 jne	 SHORT $LN15@call_funct
  0029f	44 8d 48 05	 lea	 r9d, QWORD PTR [rax+5]
  002a3	e8 00 00 00 00	 call	 call_trace_protected
  002a8	eb 2c		 jmp	 SHORT $LN11@call_funct
$LN15@call_funct:
  002aa	41 b9 06 00 00
	00		 mov	 r9d, 6
  002b0	e8 00 00 00 00	 call	 call_trace
  002b5	85 c0		 test	 eax, eax
  002b7	74 1d		 je	 SHORT $LN11@call_funct
  002b9	48 8b cf	 mov	 rcx, rdi
  002bc	e8 00 00 00 00	 call	 _Py_DecRef
  002c1	33 ff		 xor	 edi, edi
  002c3	eb 11		 jmp	 SHORT $LN11@call_funct
$LN19@call_funct:
  002c5	45 33 c0	 xor	 r8d, r8d
  002c8	48 8b d0	 mov	 rdx, rax
  002cb	48 8b ce	 mov	 rcx, rsi
  002ce	e8 00 00 00 00	 call	 PyCFunction_Call
  002d3	48 8b f8	 mov	 rdi, rax
$LN11@call_funct:

; 4135 :             READ_TIMESTAMP(*pintr1);
; 4136 :             Py_XDECREF(callargs);

  002d6	4d 85 e4	 test	 r12, r12
  002d9	0f 84 83 00 00
	00		 je	 $LN49@call_funct
  002df	49 8b cc	 mov	 rcx, r12

; 4137 :         }
; 4138 :     } else {

  002e2	eb 79		 jmp	 SHORT $LN52@call_funct
$LN42@call_funct:

; 4139 :         if (PyMethod_Check(func) && PyMethod_GET_SELF(func) != NULL) {

  002e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:PyMethod_Type
  002eb	48 3b c1	 cmp	 rax, rcx
  002ee	75 2f		 jne	 SHORT $LN6@call_funct
  002f0	48 8b 6e 68	 mov	 rbp, QWORD PTR [rsi+104]
  002f4	48 85 ed	 test	 rbp, rbp
  002f7	74 26		 je	 SHORT $LN6@call_funct

; 4140 :             /* optimize access to bound methods */
; 4141 :             PyObject *self = PyMethod_GET_SELF(func);
; 4142 :             PCALL(PCALL_METHOD);
; 4143 :             PCALL(PCALL_BOUND_METHOD);
; 4144 :             Py_INCREF(self);

  002f9	48 8b cd	 mov	 rcx, rbp
  002fc	e8 00 00 00 00	 call	 _Py_IncRef

; 4145 :             func = PyMethod_GET_FUNCTION(func);

  00301	48 8b 76 60	 mov	 rsi, QWORD PTR [rsi+96]

; 4146 :             Py_INCREF(func);

  00305	48 8b ce	 mov	 rcx, rsi
  00308	e8 00 00 00 00	 call	 _Py_IncRef

; 4147 :             Py_DECREF(*pfunc);

  0030d	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  00310	e8 00 00 00 00	 call	 _Py_DecRef

; 4148 :             *pfunc = self;
; 4149 :             na++;

  00315	ff c7		 inc	 edi

; 4150 :             n++;

  00317	41 ff c5	 inc	 r13d
  0031a	49 89 2e	 mov	 QWORD PTR [r14], rbp

; 4151 :         } else

  0031d	eb 08		 jmp	 SHORT $LN5@call_funct
$LN6@call_funct:

; 4152 :             Py_INCREF(func);

  0031f	48 8b ce	 mov	 rcx, rsi
  00322	e8 00 00 00 00	 call	 _Py_IncRef
$LN5@call_funct:

; 4153 :         READ_TIMESTAMP(*pintr0);
; 4154 :         if (PyFunction_Check(func))

  00327	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFunction_Type

; 4155 :             x = fast_function(func, pp_stack, n, na, nk);

  0032e	48 8b d3	 mov	 rdx, rbx
  00331	48 8b ce	 mov	 rcx, rsi
  00334	48 39 46 58	 cmp	 QWORD PTR [rsi+88], rax
  00338	75 12		 jne	 SHORT $LN4@call_funct
  0033a	44 8b cf	 mov	 r9d, edi
  0033d	45 8b c5	 mov	 r8d, r13d
  00340	44 89 64 24 20	 mov	 DWORD PTR [rsp+32], r12d
  00345	e8 00 00 00 00	 call	 fast_function

; 4156 :         else

  0034a	eb 0b		 jmp	 SHORT $LN53@call_funct
$LN4@call_funct:

; 4157 :             x = do_call(func, pp_stack, na, nk);

  0034c	45 8b cc	 mov	 r9d, r12d
  0034f	44 8b c7	 mov	 r8d, edi
  00352	e8 00 00 00 00	 call	 do_call
$LN53@call_funct:
  00357	48 8b f8	 mov	 rdi, rax

; 4158 :         READ_TIMESTAMP(*pintr1);
; 4159 :         Py_DECREF(func);

  0035a	48 8b ce	 mov	 rcx, rsi
$LN52@call_funct:
  0035d	e8 00 00 00 00	 call	 _Py_DecRef
$LN49@call_funct:
  00362	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  00367	4c 8b 6c 24 38	 mov	 r13, QWORD PTR [rsp+56]
  0036c	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  00371	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00376	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]

; 4160 :     }
; 4161 : 
; 4162 :     /* Clear the stack of the function object.  Also removes
; 4163 :        the arguments in case they weren't consumed already
; 4164 :        (fast_function() and err_args() leave them on the stack).
; 4165 :      */
; 4166 :     while ((*pp_stack) > pfunc) {

  0037b	4c 39 33	 cmp	 QWORD PTR [rbx], r14
  0037e	76 30		 jbe	 SHORT $LN51@call_funct
$LL2@call_funct:

; 4167 :         w = EXT_POP(*pp_stack);

  00380	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00387	74 13		 je	 SHORT $LN48@call_funct
  00389	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0038c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07PACKFCLP@ext_pop?$AA@
  00393	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  00397	e8 00 00 00 00	 call	 prtrace
$LN48@call_funct:
  0039c	48 83 03 f8	 add	 QWORD PTR [rbx], -8
  003a0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]

; 4168 :         Py_DECREF(w);

  003a3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003a6	e8 00 00 00 00	 call	 _Py_DecRef
  003ab	4c 39 33	 cmp	 QWORD PTR [rbx], r14
  003ae	77 d0		 ja	 SHORT $LL2@call_funct
$LN51@call_funct:

; 4169 :         PCALL(PCALL_POP);
; 4170 :     }
; 4171 :     return x;

  003b0	48 8b c7	 mov	 rax, rdi

; 4172 : }

  003b3	48 83 c4 40	 add	 rsp, 64			; 00000040H
  003b7	41 5e		 pop	 r14
  003b9	5f		 pop	 rdi
  003ba	5b		 pop	 rbx
  003bb	c3		 ret	 0
call_function ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@FPJKHNF@?$CF?4200s?$CI?$CJ?5takes?5exactly?5one?5argum@ ; `string'
PUBLIC	??_C@_0CH@DLPOCHMD@?$CF?4200s?$CI?$CJ?5takes?5no?5arguments?5?$CI?$CFd?5@ ; `string'
;	COMDAT ??_C@_0CP@FPJKHNF@?$CF?4200s?$CI?$CJ?5takes?5exactly?5one?5argum@
CONST	SEGMENT
??_C@_0CP@FPJKHNF@?$CF?4200s?$CI?$CJ?5takes?5exactly?5one?5argum@ DB '%.2'
	DB	'00s() takes exactly one argument (%d given)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DLPOCHMD@?$CF?4200s?$CI?$CJ?5takes?5no?5arguments?5?$CI?$CFd?5@
CONST	SEGMENT
??_C@_0CH@DLPOCHMD@?$CF?4200s?$CI?$CJ?5takes?5no?5arguments?5?$CI?$CFd?5@ DB '%'
	DB	'.200s() takes no arguments (%d given)', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT err_args
_TEXT	SEGMENT
func$ = 8
flags$ = 16
nargs$ = 24
err_args PROC						; COMDAT

; 4047 : {

  00000	45 8b c8	 mov	 r9d, r8d

; 4048 :     if (flags & METH_NOARGS)
; 4049 :         PyErr_Format(PyExc_TypeError,
; 4050 :                      "%.200s() takes no arguments (%d given)",
; 4051 :                      ((PyCFunctionObject *)func)->m_ml->ml_name,
; 4052 :                      nargs);

  00003	4c 8b 41 60	 mov	 r8, QWORD PTR [rcx+96]
  00007	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0000e	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00011	f6 c2 04	 test	 dl, 4
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CH@DLPOCHMD@?$CF?4200s?$CI?$CJ?5takes?5no?5arguments?5?$CI?$CFd?5@
  0001b	75 07		 jne	 SHORT $LN5@err_args

; 4053 :     else
; 4054 :         PyErr_Format(PyExc_TypeError,
; 4055 :                      "%.200s() takes exactly one argument (%d given)",
; 4056 :                      ((PyCFunctionObject *)func)->m_ml->ml_name,
; 4057 :                      nargs);

  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@FPJKHNF@?$CF?4200s?$CI?$CJ?5takes?5exactly?5one?5argum@
$LN5@err_args:

; 4058 : }

  00024	e9 00 00 00 00	 jmp	 PyErr_Format
err_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_1CA@GHOOIIIN@?$AAg?$AAl?$AAo?$AAb?$AAa?$AAl?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$fast_function DD imagerel fast_function
	DD	imagerel fast_function+432
	DD	imagerel $unwind$fast_function
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fast_function DD 0c1c01H
	DD	014641cH
	DD	013541cH
	DD	012341cH
	DD	0f018b21cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT ??_C@_1CA@GHOOIIIN@?$AAg?$AAl?$AAo?$AAb?$AAa?$AAl?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@GHOOIIIN@?$AAg?$AAl?$AAo?$AAb?$AAa?$AAl?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@ DB 'g'
	DB	00H, 'l', 00H, 'o', 00H, 'b', 00H, 'a', 00H, 'l', 00H, 's', 00H
	DB	' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'N', 00H, 'U', 00H, 'L'
	DB	00H, 'L', 00H, 00H, 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT fast_function
_TEXT	SEGMENT
func$ = 144
pp_stack$ = 152
n$ = 160
na$ = 168
nk$ = 176
fast_function PROC					; COMDAT

; 4185 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 4186 :     PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
; 4187 :     PyObject *globals = PyFunction_GET_GLOBALS(func);
; 4188 :     PyObject *argdefs = PyFunction_GET_DEFAULTS(func);

  0001c	48 8b 41 70	 mov	 rax, QWORD PTR [rcx+112]
  00020	48 8b 59 60	 mov	 rbx, QWORD PTR [rcx+96]
  00024	48 8b 71 68	 mov	 rsi, QWORD PTR [rcx+104]

; 4189 :     PyObject *kwdefs = PyFunction_GET_KW_DEFAULTS(func);

  00028	4c 8b 79 78	 mov	 r15, QWORD PTR [rcx+120]

; 4190 :     PyObject **d = NULL;
; 4191 :     int nd = 0;
; 4192 : 
; 4193 :     PCALL(PCALL_FUNCTION);
; 4194 :     PCALL(PCALL_FAST_FUNCTION);
; 4195 :     if (argdefs == NULL && co->co_argcount == n &&
; 4196 :         co->co_kwonlyargcount == 0 && nk==0 &&
; 4197 :         co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {

  0002c	44 8b 9c 24 b0
	00 00 00	 mov	 r11d, DWORD PTR nk$[rsp]
  00034	33 ff		 xor	 edi, edi
  00036	45 8b f1	 mov	 r14d, r9d
  00039	49 63 e8	 movsxd	 rbp, r8d
  0003c	4c 8b ea	 mov	 r13, rdx
  0003f	4c 8b d1	 mov	 r10, rcx
  00042	44 8b e7	 mov	 r12d, edi
  00045	48 85 c0	 test	 rax, rax
  00048	0f 85 e5 00 00
	00		 jne	 $LN13@fast_funct
  0004e	39 6b 60	 cmp	 DWORD PTR [rbx+96], ebp
  00051	0f 85 e4 00 00
	00		 jne	 $LN1@fast_funct
  00057	39 7b 64	 cmp	 DWORD PTR [rbx+100], edi
  0005a	0f 85 db 00 00
	00		 jne	 $LN1@fast_funct
  00060	45 85 db	 test	 r11d, r11d
  00063	0f 85 d2 00 00
	00		 jne	 $LN1@fast_funct
  00069	83 7b 70 43	 cmp	 DWORD PTR [rbx+112], 67	; 00000043H
  0006d	0f 85 c8 00 00
	00		 jne	 $LN1@fast_funct

; 4198 :         PyFrameObject *f;
; 4199 :         PyObject *retval = NULL;
; 4200 :         PyThreadState *tstate = PyThreadState_GET();

  00073	e8 00 00 00 00	 call	 PyThreadState_Get
  00078	4c 8b e0	 mov	 r12, rax

; 4201 :         PyObject **fastlocals, **stack;
; 4202 :         int i;
; 4203 : 
; 4204 :         PCALL(PCALL_FASTER_FUNCTION);
; 4205 :         assert(globals != NULL);

  0007b	48 85 f6	 test	 rsi, rsi
  0007e	75 1a		 jne	 SHORT $LN9@fast_funct
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CA@GHOOIIIN@?$AAg?$AAl?$AAo?$AAb?$AAa?$AAl?$AAs?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  0008e	41 b8 6d 10 00
	00		 mov	 r8d, 4205		; 0000106dH
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN9@fast_funct:

; 4206 :         /* XXX Perhaps we should create a specialized
; 4207 :            PyFrame_New() that doesn't take locals, but does
; 4208 :            take builtins without sanity checking them.
; 4209 :         */
; 4210 :         assert(tstate != NULL);

  0009a	4d 85 e4	 test	 r12, r12
  0009d	75 1a		 jne	 SHORT $LN10@fast_funct
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@DAMCKEEB@?$AAt?$AAs?$AAt?$AAa?$AAt?$AAe?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AAN?$AAU?$AAL?$AAL?$AA?$AA@
  000ad	41 b8 72 10 00
	00		 mov	 r8d, 4210		; 00001072H
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN10@fast_funct:

; 4211 :         f = PyFrame_New(tstate, co, globals, NULL);

  000b9	45 33 c9	 xor	 r9d, r9d
  000bc	4c 8b c6	 mov	 r8, rsi
  000bf	48 8b d3	 mov	 rdx, rbx
  000c2	49 8b cc	 mov	 rcx, r12
  000c5	e8 00 00 00 00	 call	 PyFrame_New
  000ca	48 8b f0	 mov	 rsi, rax

; 4212 :         if (f == NULL)

  000cd	48 85 c0	 test	 rax, rax
  000d0	0f 84 bc 00 00
	00		 je	 $LN7@fast_funct
$LN5@fast_funct:

; 4213 :             return NULL;
; 4214 : 
; 4215 :         fastlocals = f->f_localsplus;
; 4216 :         stack = (*pp_stack) - n;

  000d6	49 8b 5d 00	 mov	 rbx, QWORD PTR [r13]
  000da	48 8d 04 ed 00
	00 00 00	 lea	 rax, QWORD PTR [rbp*8]
  000e2	48 2b d8	 sub	 rbx, rax

; 4217 : 
; 4218 :         for (i = 0; i < n; i++) {

  000e5	48 85 ed	 test	 rbp, rbp
  000e8	7e 25		 jle	 SHORT $LN2@fast_funct
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL4@fast_funct:

; 4219 :             Py_INCREF(*stack);

  000f0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000f3	e8 00 00 00 00	 call	 _Py_IncRef

; 4220 :             fastlocals[i] = *stack++;

  000f8	4c 8b 1b	 mov	 r11, QWORD PTR [rbx]
  000fb	48 ff c7	 inc	 rdi
  000fe	4c 89 9c fe c8
	01 00 00	 mov	 QWORD PTR [rsi+rdi*8+456], r11
  00106	48 83 c3 08	 add	 rbx, 8
  0010a	48 3b fd	 cmp	 rdi, rbp
  0010d	7c e1		 jl	 SHORT $LL4@fast_funct
$LN2@fast_funct:

; 4221 :         }
; 4222 :         retval = PyEval_EvalFrameEx(f,0);

  0010f	33 d2		 xor	 edx, edx
  00111	48 8b ce	 mov	 rcx, rsi
  00114	e8 00 00 00 00	 call	 PyEval_EvalFrameEx

; 4223 :         ++tstate->recursion_depth;

  00119	41 ff 44 24 18	 inc	 DWORD PTR [r12+24]

; 4224 :         Py_DECREF(f);

  0011e	48 8b ce	 mov	 rcx, rsi
  00121	48 8b d8	 mov	 rbx, rax
  00124	e8 00 00 00 00	 call	 _Py_DecRef

; 4225 :         --tstate->recursion_depth;

  00129	41 ff 4c 24 18	 dec	 DWORD PTR [r12+24]

; 4226 :         return retval;

  0012e	48 8b c3	 mov	 rax, rbx
  00131	eb 5f		 jmp	 SHORT $LN7@fast_funct
$LN13@fast_funct:

; 4227 :     }
; 4228 :     if (argdefs != NULL) {
; 4229 :         d = &PyTuple_GET_ITEM(argdefs, 0);
; 4230 :         nd = Py_SIZE(argdefs);

  00133	44 8b 60 60	 mov	 r12d, DWORD PTR [rax+96]
  00137	48 8d 78 70	 lea	 rdi, QWORD PTR [rax+112]
$LN1@fast_funct:

; 4231 :     }
; 4232 :     return PyEval_EvalCodeEx((PyObject*)co, globals,
; 4233 :                              (PyObject *)NULL, (*pp_stack)-n, na,
; 4234 :                              (*pp_stack)-2*nk, nk, d, nd, kwdefs,
; 4235 :                              PyFunction_GET_CLOSURE(func));

  0013b	4c 8b 0a	 mov	 r9, QWORD PTR [rdx]
  0013e	43 8d 04 1b	 lea	 eax, DWORD PTR [r11+r11]
  00142	48 8b d6	 mov	 rdx, rsi
  00145	48 63 c8	 movsxd	 rcx, eax
  00148	4d 8b c1	 mov	 r8, r9
  0014b	48 8d 04 ed 00
	00 00 00	 lea	 rax, QWORD PTR [rbp*8]
  00153	48 c1 e1 03	 shl	 rcx, 3
  00157	4c 2b c8	 sub	 r9, rax
  0015a	49 8b 82 80 00
	00 00		 mov	 rax, QWORD PTR [r10+128]
  00161	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00166	4c 89 7c 24 48	 mov	 QWORD PTR [rsp+72], r15
  0016b	44 89 64 24 40	 mov	 DWORD PTR [rsp+64], r12d
  00170	4c 2b c1	 sub	 r8, rcx
  00173	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  00178	44 89 5c 24 30	 mov	 DWORD PTR [rsp+48], r11d
  0017d	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  00182	45 33 c0	 xor	 r8d, r8d
  00185	48 8b cb	 mov	 rcx, rbx
  00188	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  0018d	e8 00 00 00 00	 call	 PyEval_EvalCodeEx
$LN7@fast_funct:

; 4236 : }

  00192	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  00197	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  0019b	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  0019f	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  001a3	49 8b e3	 mov	 rsp, r11
  001a6	41 5f		 pop	 r15
  001a8	41 5e		 pop	 r14
  001aa	41 5d		 pop	 r13
  001ac	41 5c		 pop	 r12
  001ae	5f		 pop	 rdi
  001af	c3		 ret	 0
fast_function ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$load_args DD imagerel load_args
	DD	imagerel load_args+60
	DD	imagerel $unwind$load_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$load_args DD imagerel load_args+60
	DD	imagerel load_args+126
	DD	imagerel $chain$0$load_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$load_args DD imagerel load_args+126
	DD	imagerel load_args+145
	DD	imagerel $chain$1$load_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$load_args DD 021H
	DD	imagerel load_args
	DD	imagerel load_args+60
	DD	imagerel $unwind$load_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$load_args DD 020521H
	DD	066405H
	DD	imagerel load_args
	DD	imagerel load_args+60
	DD	imagerel $unwind$load_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$load_args DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT load_args
_TEXT	SEGMENT
pp_stack$ = 48
na$ = 56
load_args PROC						; COMDAT

; 4305 : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 63 da	 movsxd	 rbx, edx
  00012	48 8b f9	 mov	 rdi, rcx

; 4306 :     PyObject *args = PyTuple_New(na);

  00015	48 8b cb	 mov	 rcx, rbx
  00018	e8 00 00 00 00	 call	 PyTuple_New
  0001d	48 8b e8	 mov	 rbp, rax

; 4307 :     PyObject *w;
; 4308 : 
; 4309 :     if (args == NULL)

  00020	48 85 c0	 test	 rax, rax
  00023	75 10		 jne	 SHORT $LN7@load_args

; 4314 :     }
; 4315 :     return args;
; 4316 : }

  00025	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002a	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
$LN7@load_args:

; 4310 :         return NULL;
; 4311 :     while (--na >= 0) {

  00035	ff cb		 dec	 ebx
  00037	48 63 db	 movsxd	 rbx, ebx
  0003a	78 42		 js	 SHORT $LN1@load_args
  0003c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00041	48 8d 74 d8 70	 lea	 rsi, QWORD PTR [rax+rbx*8+112]
$LL2@load_args:

; 4312 :         w = EXT_POP(*pp_stack);

  00046	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  0004d	74 13		 je	 SHORT $LN6@load_args
  0004f	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07PACKFCLP@ext_pop?$AA@
  00059	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  0005d	e8 00 00 00 00	 call	 prtrace
$LN6@load_args:
  00062	48 83 07 f8	 add	 QWORD PTR [rdi], -8
  00066	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00069	48 83 ee 08	 sub	 rsi, 8
  0006d	48 ff cb	 dec	 rbx

; 4313 :         PyTuple_SET_ITEM(args, na, w);

  00070	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00073	48 89 4e 08	 mov	 QWORD PTR [rsi+8], rcx
  00077	79 cd		 jns	 SHORT $LL2@load_args
  00079	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN1@load_args:

; 4314 :     }
; 4315 :     return args;
; 4316 : }

  0007e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00083	48 8b c5	 mov	 rax, rbp
  00086	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0008b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008f	5f		 pop	 rdi
  00090	c3		 ret	 0
load_args ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_call DD imagerel do_call
	DD	imagerel do_call+330
	DD	imagerel $unwind$do_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_call DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0c016521aH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT do_call
_TEXT	SEGMENT
func$ = 64
pp_stack$ = 72
na$ = 80
nk$ = 88
do_call	PROC						; COMDAT

; 4320 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 4321 :     PyObject *callargs = NULL;
; 4322 :     PyObject *kwdict = NULL;

  0001a	33 ff		 xor	 edi, edi

; 4323 :     PyObject *result = NULL;

  0001c	33 db		 xor	 ebx, ebx
  0001e	41 8b c1	 mov	 eax, r9d
  00021	45 8b e0	 mov	 r12d, r8d
  00024	48 8b f2	 mov	 rsi, rdx
  00027	48 8b e9	 mov	 rbp, rcx

; 4324 : 
; 4325 :     if (nk > 0) {

  0002a	45 85 c9	 test	 r9d, r9d
  0002d	7e 1b		 jle	 SHORT $LN20@do_call

; 4326 :         kwdict = update_keyword_args(NULL, nk, pp_stack, func);

  0002f	4c 8b c9	 mov	 r9, rcx
  00032	4c 8b c2	 mov	 r8, rdx
  00035	8b d0		 mov	 edx, eax
  00037	33 c9		 xor	 ecx, ecx
  00039	e8 00 00 00 00	 call	 update_keyword_args
  0003e	48 8b f8	 mov	 rdi, rax

; 4327 :         if (kwdict == NULL)

  00041	48 85 c0	 test	 rax, rax

; 4357 :     Py_XDECREF(kwdict);

  00044	0f 84 e2 00 00
	00		 je	 $LN24@do_call
$LN20@do_call:

; 4328 :             goto call_fail;
; 4329 :     }
; 4330 :     callargs = load_args(pp_stack, na);

  0004a	41 8b d4	 mov	 edx, r12d
  0004d	48 8b ce	 mov	 rcx, rsi
  00050	e8 00 00 00 00	 call	 load_args
  00055	4c 8b e0	 mov	 r12, rax

; 4331 :     if (callargs == NULL)

  00058	48 85 c0	 test	 rax, rax
  0005b	0f 84 be 00 00
	00		 je	 $LN7@do_call

; 4332 :         goto call_fail;
; 4333 : #ifdef CALL_PROFILE
; 4334 :     /* At this point, we have to look at the type of func to
; 4335 :        update the call stats properly.  Do it here so as to avoid
; 4336 :        exposing the call stats machinery outside ceval.c
; 4337 :     */
; 4338 :     if (PyFunction_Check(func))
; 4339 :         PCALL(PCALL_FUNCTION);
; 4340 :     else if (PyMethod_Check(func))
; 4341 :         PCALL(PCALL_METHOD);
; 4342 :     else if (PyType_Check(func))
; 4343 :         PCALL(PCALL_TYPE);
; 4344 :     else if (PyCFunction_Check(func))
; 4345 :         PCALL(PCALL_CFUNCTION);
; 4346 :     else
; 4347 :         PCALL(PCALL_OTHER);
; 4348 : #endif
; 4349 :     if (PyCFunction_Check(func)) {

  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyCFunction_Type
  00068	48 39 45 58	 cmp	 QWORD PTR [rbp+88], rax
  0006c	0f 85 94 00 00
	00		 jne	 $LN18@do_call

; 4350 :         PyThreadState *tstate = PyThreadState_GET();

  00072	e8 00 00 00 00	 call	 PyThreadState_Get
  00077	48 8b f0	 mov	 rsi, rax

; 4351 :         C_TRACE(result, PyCFunction_Call(func, callargs, kwdict));

  0007a	39 58 24	 cmp	 DWORD PTR [rax+36], ebx
  0007d	74 77		 je	 SHORT $LN17@do_call
  0007f	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00083	48 85 c9	 test	 rcx, rcx
  00086	74 6e		 je	 SHORT $LN17@do_call
  00088	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  0008c	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  00090	41 b9 04 00 00
	00		 mov	 r9d, 4
  00096	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0009b	e8 00 00 00 00	 call	 call_trace
  000a0	85 c0		 test	 eax, eax
  000a2	75 73		 jne	 SHORT $call_fail$66933
  000a4	4c 8b c7	 mov	 r8, rdi
  000a7	49 8b d4	 mov	 rdx, r12
  000aa	48 8b cd	 mov	 rcx, rbp
  000ad	e8 00 00 00 00	 call	 PyCFunction_Call
  000b2	48 8b 4e 28	 mov	 rcx, QWORD PTR [rsi+40]
  000b6	48 8b d8	 mov	 rbx, rax
  000b9	48 85 c9	 test	 rcx, rcx
  000bc	74 59		 je	 SHORT $call_fail$66933
  000be	4c 8b 46 10	 mov	 r8, QWORD PTR [rsi+16]
  000c2	48 8b 56 38	 mov	 rdx, QWORD PTR [rsi+56]
  000c6	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  000cb	48 85 c0	 test	 rax, rax
  000ce	75 0b		 jne	 SHORT $LN13@do_call
  000d0	44 8d 48 05	 lea	 r9d, QWORD PTR [rax+5]
  000d4	e8 00 00 00 00	 call	 call_trace_protected
  000d9	eb 3c		 jmp	 SHORT $call_fail$66933
$LN13@do_call:
  000db	41 b9 06 00 00
	00		 mov	 r9d, 6
  000e1	e8 00 00 00 00	 call	 call_trace
  000e6	85 c0		 test	 eax, eax
  000e8	74 2d		 je	 SHORT $call_fail$66933
  000ea	48 8b cb	 mov	 rcx, rbx
  000ed	e8 00 00 00 00	 call	 _Py_DecRef
  000f2	33 db		 xor	 ebx, ebx
  000f4	eb 21		 jmp	 SHORT $call_fail$66933
$LN17@do_call:
  000f6	4c 8b c7	 mov	 r8, rdi
  000f9	49 8b d4	 mov	 rdx, r12
  000fc	48 8b cd	 mov	 rcx, rbp
  000ff	e8 00 00 00 00	 call	 PyCFunction_Call

; 4352 :     }
; 4353 :     else

  00104	eb 0e		 jmp	 SHORT $LN26@do_call
$LN18@do_call:

; 4354 :         result = PyObject_Call(func, callargs, kwdict);

  00106	4c 8b c7	 mov	 r8, rdi
  00109	49 8b d4	 mov	 rdx, r12
  0010c	48 8b cd	 mov	 rcx, rbp
  0010f	e8 00 00 00 00	 call	 PyObject_Call
$LN26@do_call:
  00114	48 8b d8	 mov	 rbx, rax
$call_fail$66933:

; 4355 : call_fail:
; 4356 :     Py_XDECREF(callargs);

  00117	49 8b cc	 mov	 rcx, r12
  0011a	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@do_call:

; 4357 :     Py_XDECREF(kwdict);

  0011f	48 85 ff	 test	 rdi, rdi
  00122	74 08		 je	 SHORT $LN24@do_call
  00124	48 8b cf	 mov	 rcx, rdi
  00127	e8 00 00 00 00	 call	 _Py_DecRef
$LN24@do_call:

; 4358 :     return result;
; 4359 : }

  0012c	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00131	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00136	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0013b	48 8b c3	 mov	 rax, rbx
  0013e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00143	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00147	41 5c		 pop	 r12
  00149	c3		 ret	 0
do_call	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@CDLOGKF@?$CF?4200s?$CFs?5got?5multiple?5values?5for@ ; `string'
EXTRN	PyDict_Copy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$update_keyword_args DD imagerel update_keyword_args
	DD	imagerel update_keyword_args+74
	DD	imagerel $unwind$update_keyword_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$update_keyword_args DD imagerel update_keyword_args+74
	DD	imagerel update_keyword_args+244
	DD	imagerel $chain$1$update_keyword_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$update_keyword_args DD imagerel update_keyword_args+244
	DD	imagerel update_keyword_args+263
	DD	imagerel $chain$2$update_keyword_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$update_keyword_args DD imagerel update_keyword_args+263
	DD	imagerel update_keyword_args+340
	DD	imagerel $chain$3$update_keyword_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$update_keyword_args DD 040021H
	DD	0bd400H
	DD	0ac400H
	DD	imagerel update_keyword_args
	DD	imagerel update_keyword_args+74
	DD	imagerel $unwind$update_keyword_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$update_keyword_args DD 021H
	DD	imagerel update_keyword_args
	DD	imagerel update_keyword_args+74
	DD	imagerel $unwind$update_keyword_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$update_keyword_args DD 040a21H
	DD	0bd40aH
	DD	0ac405H
	DD	imagerel update_keyword_args
	DD	imagerel update_keyword_args+74
	DD	imagerel $unwind$update_keyword_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$update_keyword_args DD 081201H
	DD	0d5412H
	DD	0c3412H
	DD	0e00e5212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT ??_C@_0DH@CDLOGKF@?$CF?4200s?$CFs?5got?5multiple?5values?5for@
CONST	SEGMENT
??_C@_0DH@CDLOGKF@?$CF?4200s?$CFs?5got?5multiple?5values?5for@ DB '%.200s'
	DB	'%s got multiple values for keyword argument ''%U''', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT update_keyword_args
_TEXT	SEGMENT
orig_kwdict$ = 80
nk$ = 88
pp_stack$ = 96
func$ = 104
update_keyword_args PROC				; COMDAT

; 4241 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00012	4d 8b f1	 mov	 r14, r9
  00015	49 8b f8	 mov	 rdi, r8
  00018	8b f2		 mov	 esi, edx
  0001a	48 8b d9	 mov	 rbx, rcx

; 4242 :     PyObject *kwdict = NULL;
; 4243 :     if (orig_kwdict == NULL)

  0001d	48 85 c9	 test	 rcx, rcx
  00020	75 0a		 jne	 SHORT $LN7@update_key

; 4244 :         kwdict = PyDict_New();

  00022	e8 00 00 00 00	 call	 PyDict_New
  00027	48 8b e8	 mov	 rbp, rax

; 4245 :     else {

  0002a	eb 10		 jmp	 SHORT $LN6@update_key
$LN7@update_key:

; 4246 :         kwdict = PyDict_Copy(orig_kwdict);

  0002c	e8 00 00 00 00	 call	 PyDict_Copy

; 4247 :         Py_DECREF(orig_kwdict);

  00031	48 8b cb	 mov	 rcx, rbx
  00034	48 8b e8	 mov	 rbp, rax
  00037	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@update_key:

; 4248 :     }
; 4249 :     if (kwdict == NULL)

  0003c	48 85 ed	 test	 rbp, rbp
  0003f	75 07		 jne	 SHORT $LN12@update_key

; 4250 :         return NULL;

  00041	33 c0		 xor	 eax, eax
  00043	e9 ac 00 00 00	 jmp	 $LN8@update_key
$LN12@update_key:

; 4251 :     while (--nk >= 0) {

  00048	ff ce		 dec	 esi
  0004a	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
  0004f	4c 89 6c 24 58	 mov	 QWORD PTR [rsp+88], r13
  00054	0f 88 8d 00 00
	00		 js	 $LN3@update_key
  0005a	66 0f 1f 44 00
	00		 npad	 6
$LL4@update_key:

; 4252 :         int err;
; 4253 :         PyObject *value = EXT_POP(*pp_stack);

  00060	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lltrace
  00066	85 c0		 test	 eax, eax
  00068	74 19		 je	 SHORT $LN10@update_key
  0006a	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07PACKFCLP@ext_pop?$AA@
  00074	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  00078	e8 00 00 00 00	 call	 prtrace
  0007d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lltrace
$LN10@update_key:
  00083	48 83 07 f8	 add	 QWORD PTR [rdi], -8
  00087	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0008a	4c 8b 29	 mov	 r13, QWORD PTR [rcx]

; 4254 :         PyObject *key = EXT_POP(*pp_stack);

  0008d	85 c0		 test	 eax, eax
  0008f	74 10		 je	 SHORT $LN11@update_key
  00091	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07PACKFCLP@ext_pop?$AA@
  0009c	e8 00 00 00 00	 call	 prtrace
$LN11@update_key:
  000a1	48 83 07 f8	 add	 QWORD PTR [rdi], -8
  000a5	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 4255 :         if (PyDict_GetItem(kwdict, key) != NULL) {

  000a8	48 8b cd	 mov	 rcx, rbp
  000ab	4c 8b 20	 mov	 r12, QWORD PTR [rax]
  000ae	49 8b d4	 mov	 rdx, r12
  000b1	e8 00 00 00 00	 call	 PyDict_GetItem
  000b6	48 85 c0	 test	 rax, rax
  000b9	75 4c		 jne	 SHORT $LN13@update_key

; 4266 :         }
; 4267 :         err = PyDict_SetItem(kwdict, key, value);

  000bb	4d 8b c5	 mov	 r8, r13
  000be	49 8b d4	 mov	 rdx, r12
  000c1	48 8b cd	 mov	 rcx, rbp
  000c4	e8 00 00 00 00	 call	 PyDict_SetItem

; 4268 :         Py_DECREF(key);

  000c9	49 8b cc	 mov	 rcx, r12
  000cc	8b d8		 mov	 ebx, eax
  000ce	e8 00 00 00 00	 call	 _Py_DecRef

; 4269 :         Py_DECREF(value);

  000d3	49 8b cd	 mov	 rcx, r13
  000d6	e8 00 00 00 00	 call	 _Py_DecRef

; 4270 :         if (err) {

  000db	85 db		 test	 ebx, ebx
  000dd	75 69		 jne	 SHORT $LN14@update_key

; 4251 :     while (--nk >= 0) {

  000df	ff ce		 dec	 esi
  000e1	0f 89 79 ff ff
	ff		 jns	 $LL4@update_key
$LN3@update_key:

; 4271 :             Py_DECREF(kwdict);
; 4272 :             return NULL;
; 4273 :         }
; 4274 :     }
; 4275 :     return kwdict;

  000e7	48 8b c5	 mov	 rax, rbp
$LN16@update_key:
  000ea	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
  000ef	4c 8b 6c 24 58	 mov	 r13, QWORD PTR [rsp+88]
$LN8@update_key:

; 4276 : }

  000f4	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000f9	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  000fe	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00102	41 5e		 pop	 r14
  00104	5f		 pop	 rdi
  00105	5e		 pop	 rsi
  00106	c3		 ret	 0
$LN13@update_key:

; 4256 :             PyErr_Format(PyExc_TypeError,
; 4257 :                          "%.200s%s got multiple values "
; 4258 :                          "for keyword argument '%U'",
; 4259 :                          PyEval_GetFuncName(func),
; 4260 :                          PyEval_GetFuncDesc(func),
; 4261 :                          key);

  00107	49 8b ce	 mov	 rcx, r14
  0010a	e8 00 00 00 00	 call	 PyEval_GetFuncDesc
  0010f	49 8b ce	 mov	 rcx, r14
  00112	48 8b d8	 mov	 rbx, rax
  00115	e8 00 00 00 00	 call	 PyEval_GetFuncName
  0011a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@CDLOGKF@?$CF?4200s?$CFs?5got?5multiple?5values?5for@
  00128	4c 8b cb	 mov	 r9, rbx
  0012b	4c 8b c0	 mov	 r8, rax
  0012e	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00133	e8 00 00 00 00	 call	 PyErr_Format

; 4262 :             Py_DECREF(key);

  00138	49 8b cc	 mov	 rcx, r12
  0013b	e8 00 00 00 00	 call	 _Py_DecRef

; 4263 :             Py_DECREF(value);

  00140	49 8b cd	 mov	 rcx, r13
  00143	e8 00 00 00 00	 call	 _Py_DecRef
$LN14@update_key:

; 4264 :             Py_DECREF(kwdict);

  00148	48 8b cd	 mov	 rcx, rbp
  0014b	e8 00 00 00 00	 call	 _Py_DecRef

; 4265 :             return NULL;

  00150	33 c0		 xor	 eax, eax
  00152	eb 96		 jmp	 SHORT $LN16@update_key
update_keyword_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DN@IOJKJILL@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?5mu@ ; `string'
PUBLIC	??_C@_0DN@GHIOPBKH@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?$CK?5m@ ; `string'
EXTRN	PySequence_Tuple:PROC
EXTRN	PyDict_Update:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$ext_do_call DD imagerel ext_do_call
	DD	imagerel ext_do_call+13
	DD	imagerel $unwind$ext_do_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$ext_do_call DD imagerel ext_do_call+13
	DD	imagerel ext_do_call+739
	DD	imagerel $chain$5$ext_do_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$ext_do_call DD imagerel ext_do_call+739
	DD	imagerel ext_do_call+757
	DD	imagerel $chain$6$ext_do_call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$ext_do_call DD 021H
	DD	imagerel ext_do_call
	DD	imagerel ext_do_call+13
	DD	imagerel $unwind$ext_do_call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$ext_do_call DD 0c1821H
	DD	06f418H
	DD	07e414H
	DD	08d410H
	DD	0ec40cH
	DD	0d7408H
	DD	0c3404H
	DD	imagerel ext_do_call
	DD	imagerel ext_do_call+13
	DD	imagerel $unwind$ext_do_call
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ext_do_call DD 030d01H
	DD	06009820dH
	DD	05008H
xdata	ENDS
;	COMDAT ??_C@_0DN@IOJKJILL@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?5mu@
CONST	SEGMENT
??_C@_0DN@IOJKJILL@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?5mu@ DB '%'
	DB	'.200s%.200s argument after * must be a sequence, not %.200s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@GHIOPBKH@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?$CK?5m@
CONST	SEGMENT
??_C@_0DN@GHIOPBKH@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?$CK?5m@ DB '%'
	DB	'.200s%.200s argument after ** must be a mapping, not %.200s', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ext_do_call
_TEXT	SEGMENT
func$ = 96
pp_stack$ = 104
flags$ = 112
na$ = 120
nk$ = 128
ext_do_call PROC					; COMDAT

; 4363 : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	44 89 48 20	 mov	 DWORD PTR [rax+32], r9d
  00007	55		 push	 rbp
  00008	56		 push	 rsi
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  0000d	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00011	48 89 78 10	 mov	 QWORD PTR [rax+16], rdi
  00015	4c 89 60 18	 mov	 QWORD PTR [rax+24], r12
  00019	4c 89 68 e8	 mov	 QWORD PTR [rax-24], r13
  0001d	4c 89 70 e0	 mov	 QWORD PTR [rax-32], r14
  00021	4c 89 78 d8	 mov	 QWORD PTR [rax-40], r15

; 4364 :     int nstar = 0;

  00025	45 33 ff	 xor	 r15d, r15d

; 4365 :     PyObject *callargs = NULL;
; 4366 :     PyObject *stararg = NULL;

  00028	33 ed		 xor	 ebp, ebp

; 4367 :     PyObject *kwdict = NULL;

  0002a	45 33 e4	 xor	 r12d, r12d

; 4368 :     PyObject *result = NULL;

  0002d	33 f6		 xor	 esi, esi
  0002f	45 8b f0	 mov	 r14d, r8d
  00032	48 8b da	 mov	 rbx, rdx
  00035	4c 8b e9	 mov	 r13, rcx

; 4369 : 
; 4370 :     if (flags & CALL_FLAG_KW) {

  00038	41 f6 c0 02	 test	 r8b, 2
  0003c	0f 84 c0 00 00
	00		 je	 $LN40@ext_do_cal

; 4371 :         kwdict = EXT_POP(*pp_stack);

  00042	39 35 00 00 00
	00		 cmp	 DWORD PTR lltrace, esi
  00048	74 13		 je	 SHORT $LN37@ext_do_cal
  0004a	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07PACKFCLP@ext_pop?$AA@
  00054	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  00058	e8 00 00 00 00	 call	 prtrace
$LN37@ext_do_cal:
  0005d	48 83 03 f8	 add	 QWORD PTR [rbx], -8
  00061	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00064	4c 8b 20	 mov	 r12, QWORD PTR [rax]

; 4372 :         if (!PyDict_Check(kwdict)) {

  00067	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  0006c	f7 80 00 01 00
	00 00 00 00 20	 test	 DWORD PTR [rax+256], 536870912 ; 20000000H
  00076	0f 85 86 00 00
	00		 jne	 $LN40@ext_do_cal

; 4373 :             PyObject *d;
; 4374 :             d = PyDict_New();

  0007c	e8 00 00 00 00	 call	 PyDict_New
  00081	48 8b f8	 mov	 rdi, rax

; 4375 :             if (d == NULL)

  00084	48 85 c0	 test	 rax, rax
  00087	0f 84 26 02 00
	00		 je	 $LN11@ext_do_cal

; 4376 :                 goto ext_call_fail;
; 4377 :             if (PyDict_Update(d, kwdict) != 0) {

  0008d	49 8b d4	 mov	 rdx, r12
  00090	48 8b c8	 mov	 rcx, rax
  00093	e8 00 00 00 00	 call	 PyDict_Update
  00098	85 c0		 test	 eax, eax
  0009a	74 5b		 je	 SHORT $LN31@ext_do_cal

; 4378 :                 Py_DECREF(d);

  0009c	48 8b cf	 mov	 rcx, rdi
  0009f	e8 00 00 00 00	 call	 _Py_DecRef

; 4379 :                 /* PyDict_Update raises attribute
; 4380 :                  * error (percolated from an attempt
; 4381 :                  * to get 'keys' attribute) instead of
; 4382 :                  * a type error if its second argument
; 4383 :                  * is not a mapping.
; 4384 :                  */
; 4385 :                 if (PyErr_ExceptionMatches(PyExc_AttributeError)) {

  000a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  000ab	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000b0	85 c0		 test	 eax, eax
  000b2	0f 84 fb 01 00
	00		 je	 $LN11@ext_do_cal

; 4386 :                     PyErr_Format(PyExc_TypeError,
; 4387 :                                  "%.200s%.200s argument after ** "
; 4388 :                                  "must be a mapping, not %.200s",
; 4389 :                                  PyEval_GetFuncName(func),
; 4390 :                                  PyEval_GetFuncDesc(func),
; 4391 :                                  kwdict->ob_type->tp_name);

  000b8	49 8b 7c 24 58	 mov	 rdi, QWORD PTR [r12+88]
  000bd	49 8b cd	 mov	 rcx, r13
  000c0	e8 00 00 00 00	 call	 PyEval_GetFuncDesc
  000c5	49 8b cd	 mov	 rcx, r13
  000c8	48 8b d8	 mov	 rbx, rax
  000cb	e8 00 00 00 00	 call	 PyEval_GetFuncName
  000d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000d7	4c 8b c0	 mov	 r8, rax
  000da	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  000de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@GHIOPBKH@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?$CK?5m@
  000e5	4c 8b cb	 mov	 r9, rbx
  000e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ed	e8 00 00 00 00	 call	 PyErr_Format

; 4392 :                 }
; 4393 :                 goto ext_call_fail;

  000f2	e9 bc 01 00 00	 jmp	 $LN11@ext_do_cal
$LN31@ext_do_cal:

; 4394 :             }
; 4395 :             Py_DECREF(kwdict);

  000f7	49 8b cc	 mov	 rcx, r12
  000fa	e8 00 00 00 00	 call	 _Py_DecRef

; 4396 :             kwdict = d;

  000ff	4c 8b e7	 mov	 r12, rdi
$LN40@ext_do_cal:

; 4397 :         }
; 4398 :     }
; 4399 :     if (flags & CALL_FLAG_VAR) {

  00102	41 f6 c6 01	 test	 r14b, 1
  00106	0f 84 a6 00 00
	00		 je	 $LN29@ext_do_cal

; 4400 :         stararg = EXT_POP(*pp_stack);

  0010c	39 35 00 00 00
	00		 cmp	 DWORD PTR lltrace, esi
  00112	74 13		 je	 SHORT $LN38@ext_do_cal
  00114	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07PACKFCLP@ext_pop?$AA@
  0011e	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  00122	e8 00 00 00 00	 call	 prtrace
$LN38@ext_do_cal:
  00127	48 83 03 f8	 add	 QWORD PTR [rbx], -8
  0012b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0012e	48 8b 28	 mov	 rbp, QWORD PTR [rax]

; 4401 :         if (!PyTuple_Check(stararg)) {

  00131	48 8b 45 58	 mov	 rax, QWORD PTR [rbp+88]
  00135	f7 80 00 01 00
	00 00 00 00 04	 test	 DWORD PTR [rax+256], 67108864 ; 04000000H
  0013f	75 6d		 jne	 SHORT $LN28@ext_do_cal

; 4402 :             PyObject *t = NULL;
; 4403 :             t = PySequence_Tuple(stararg);

  00141	48 8b cd	 mov	 rcx, rbp
  00144	e8 00 00 00 00	 call	 PySequence_Tuple
  00149	48 8b f8	 mov	 rdi, rax

; 4404 :             if (t == NULL) {

  0014c	48 85 c0	 test	 rax, rax
  0014f	75 52		 jne	 SHORT $LN27@ext_do_cal

; 4405 :                 if (PyErr_ExceptionMatches(PyExc_TypeError)) {

  00151	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00158	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  0015d	85 c0		 test	 eax, eax
  0015f	0f 84 4e 01 00
	00		 je	 $LN11@ext_do_cal

; 4406 :                     PyErr_Format(PyExc_TypeError,
; 4407 :                                  "%.200s%.200s argument after * "
; 4408 :                                  "must be a sequence, not %.200s",
; 4409 :                                  PyEval_GetFuncName(func),
; 4410 :                                  PyEval_GetFuncDesc(func),
; 4411 :                                  stararg->ob_type->tp_name);

  00165	48 8b 7d 58	 mov	 rdi, QWORD PTR [rbp+88]
  00169	49 8b cd	 mov	 rcx, r13
  0016c	e8 00 00 00 00	 call	 PyEval_GetFuncDesc
  00171	49 8b cd	 mov	 rcx, r13
  00174	48 8b d8	 mov	 rbx, rax
  00177	e8 00 00 00 00	 call	 PyEval_GetFuncName
  0017c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00183	4c 8b c0	 mov	 r8, rax
  00186	48 8b 47 70	 mov	 rax, QWORD PTR [rdi+112]
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DN@IOJKJILL@?$CF?4200s?$CF?4200s?5argument?5after?5?$CK?5mu@
  00191	4c 8b cb	 mov	 r9, rbx
  00194	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00199	e8 00 00 00 00	 call	 PyErr_Format

; 4412 :                 }
; 4413 :                 goto ext_call_fail;

  0019e	e9 10 01 00 00	 jmp	 $LN11@ext_do_cal
$LN27@ext_do_cal:

; 4414 :             }
; 4415 :             Py_DECREF(stararg);

  001a3	48 8b cd	 mov	 rcx, rbp
  001a6	e8 00 00 00 00	 call	 _Py_DecRef

; 4416 :             stararg = t;

  001ab	48 8b ef	 mov	 rbp, rdi
$LN28@ext_do_cal:

; 4417 :         }
; 4418 :         nstar = PyTuple_GET_SIZE(stararg);

  001ae	44 8b 7d 60	 mov	 r15d, DWORD PTR [rbp+96]
$LN29@ext_do_cal:

; 4419 :     }
; 4420 :     if (nk > 0) {

  001b2	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR nk$[rsp]
  001b9	85 d2		 test	 edx, edx
  001bb	7e 1a		 jle	 SHORT $LN24@ext_do_cal

; 4421 :         kwdict = update_keyword_args(kwdict, nk, pp_stack, func);

  001bd	4d 8b cd	 mov	 r9, r13
  001c0	4c 8b c3	 mov	 r8, rbx
  001c3	49 8b cc	 mov	 rcx, r12
  001c6	e8 00 00 00 00	 call	 update_keyword_args
  001cb	4c 8b e0	 mov	 r12, rax

; 4422 :         if (kwdict == NULL)

  001ce	48 85 c0	 test	 rax, rax
  001d1	0f 84 e9 00 00
	00		 je	 $LN7@ext_do_cal
$LN24@ext_do_cal:

; 4423 :             goto ext_call_fail;
; 4424 :     }
; 4425 :     callargs = update_star_args(na, nstar, stararg, pp_stack);

  001d7	8b 4c 24 78	 mov	 ecx, DWORD PTR na$[rsp]
  001db	4c 8b cb	 mov	 r9, rbx
  001de	4c 8b c5	 mov	 r8, rbp
  001e1	41 8b d7	 mov	 edx, r15d
  001e4	e8 00 00 00 00	 call	 update_star_args
  001e9	48 8b f8	 mov	 rdi, rax

; 4426 :     if (callargs == NULL)

  001ec	48 85 c0	 test	 rax, rax
  001ef	0f 84 be 00 00
	00		 je	 $LN11@ext_do_cal

; 4427 :         goto ext_call_fail;
; 4428 : #ifdef CALL_PROFILE
; 4429 :     /* At this point, we have to look at the type of func to
; 4430 :        update the call stats properly.  Do it here so as to avoid
; 4431 :        exposing the call stats machinery outside ceval.c
; 4432 :     */
; 4433 :     if (PyFunction_Check(func))
; 4434 :         PCALL(PCALL_FUNCTION);
; 4435 :     else if (PyMethod_Check(func))
; 4436 :         PCALL(PCALL_METHOD);
; 4437 :     else if (PyType_Check(func))
; 4438 :         PCALL(PCALL_TYPE);
; 4439 :     else if (PyCFunction_Check(func))
; 4440 :         PCALL(PCALL_CFUNCTION);
; 4441 :     else
; 4442 :         PCALL(PCALL_OTHER);
; 4443 : #endif
; 4444 :     if (PyCFunction_Check(func)) {

  001f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyCFunction_Type
  001fc	49 39 45 58	 cmp	 QWORD PTR [r13+88], rax
  00200	0f 85 94 00 00
	00		 jne	 $LN22@ext_do_cal

; 4445 :         PyThreadState *tstate = PyThreadState_GET();

  00206	e8 00 00 00 00	 call	 PyThreadState_Get
  0020b	48 8b d8	 mov	 rbx, rax

; 4446 :         C_TRACE(result, PyCFunction_Call(func, callargs, kwdict));

  0020e	39 70 24	 cmp	 DWORD PTR [rax+36], esi
  00211	74 77		 je	 SHORT $LN21@ext_do_cal
  00213	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00217	48 85 c9	 test	 rcx, rcx
  0021a	74 6e		 je	 SHORT $LN21@ext_do_cal
  0021c	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  00220	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  00224	41 b9 04 00 00
	00		 mov	 r9d, 4
  0022a	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0022f	e8 00 00 00 00	 call	 call_trace
  00234	85 c0		 test	 eax, eax
  00236	75 73		 jne	 SHORT $ext_call_fail$66990
  00238	4d 8b c4	 mov	 r8, r12
  0023b	48 8b d7	 mov	 rdx, rdi
  0023e	49 8b cd	 mov	 rcx, r13
  00241	e8 00 00 00 00	 call	 PyCFunction_Call
  00246	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]
  0024a	48 8b f0	 mov	 rsi, rax
  0024d	48 85 c9	 test	 rcx, rcx
  00250	74 59		 je	 SHORT $ext_call_fail$66990
  00252	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
  00256	48 8b 53 38	 mov	 rdx, QWORD PTR [rbx+56]
  0025a	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  0025f	48 85 c0	 test	 rax, rax
  00262	75 0b		 jne	 SHORT $LN17@ext_do_cal
  00264	44 8d 48 05	 lea	 r9d, QWORD PTR [rax+5]
  00268	e8 00 00 00 00	 call	 call_trace_protected
  0026d	eb 3c		 jmp	 SHORT $ext_call_fail$66990
$LN17@ext_do_cal:
  0026f	41 b9 06 00 00
	00		 mov	 r9d, 6
  00275	e8 00 00 00 00	 call	 call_trace
  0027a	85 c0		 test	 eax, eax
  0027c	74 2d		 je	 SHORT $ext_call_fail$66990
  0027e	48 8b ce	 mov	 rcx, rsi
  00281	e8 00 00 00 00	 call	 _Py_DecRef
  00286	33 f6		 xor	 esi, esi
  00288	eb 21		 jmp	 SHORT $ext_call_fail$66990
$LN21@ext_do_cal:
  0028a	4d 8b c4	 mov	 r8, r12
  0028d	48 8b d7	 mov	 rdx, rdi
  00290	49 8b cd	 mov	 rcx, r13
  00293	e8 00 00 00 00	 call	 PyCFunction_Call

; 4447 :     }
; 4448 :     else

  00298	eb 0e		 jmp	 SHORT $LN41@ext_do_cal
$LN22@ext_do_cal:

; 4449 :         result = PyObject_Call(func, callargs, kwdict);

  0029a	4d 8b c4	 mov	 r8, r12
  0029d	48 8b d7	 mov	 rdx, rdi
  002a0	49 8b cd	 mov	 rcx, r13
  002a3	e8 00 00 00 00	 call	 PyObject_Call
$LN41@ext_do_cal:
  002a8	48 8b f0	 mov	 rsi, rax
$ext_call_fail$66990:

; 4450 : ext_call_fail:
; 4451 :     Py_XDECREF(callargs);

  002ab	48 8b cf	 mov	 rcx, rdi
  002ae	e8 00 00 00 00	 call	 _Py_DecRef
$LN11@ext_do_cal:

; 4452 :     Py_XDECREF(kwdict);

  002b3	4d 85 e4	 test	 r12, r12
  002b6	74 08		 je	 SHORT $LN7@ext_do_cal
  002b8	49 8b cc	 mov	 rcx, r12
  002bb	e8 00 00 00 00	 call	 _Py_DecRef
$LN7@ext_do_cal:

; 4453 :     Py_XDECREF(stararg);

  002c0	4c 8b 7c 24 30	 mov	 r15, QWORD PTR [rsp+48]
  002c5	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]
  002ca	4c 8b 6c 24 40	 mov	 r13, QWORD PTR [rsp+64]
  002cf	4c 8b 64 24 70	 mov	 r12, QWORD PTR [rsp+112]
  002d4	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  002d9	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  002de	48 85 ed	 test	 rbp, rbp
  002e1	74 08		 je	 SHORT $LN39@ext_do_cal
  002e3	48 8b cd	 mov	 rcx, rbp
  002e6	e8 00 00 00 00	 call	 _Py_DecRef
$LN39@ext_do_cal:

; 4454 :     return result;

  002eb	48 8b c6	 mov	 rax, rsi

; 4455 : }

  002ee	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002f2	5e		 pop	 rsi
  002f3	5d		 pop	 rbp
  002f4	c3		 ret	 0
ext_do_call ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$update_star_args DD imagerel update_star_args
	DD	imagerel update_star_args+56
	DD	imagerel $unwind$update_star_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$update_star_args DD imagerel update_star_args+56
	DD	imagerel update_star_args+65
	DD	imagerel $chain$0$update_star_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$update_star_args DD imagerel update_star_args+65
	DD	imagerel update_star_args+126
	DD	imagerel $chain$1$update_star_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$update_star_args DD imagerel update_star_args+126
	DD	imagerel update_star_args+203
	DD	imagerel $chain$2$update_star_args
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$update_star_args DD imagerel update_star_args+203
	DD	imagerel update_star_args+224
	DD	imagerel $chain$3$update_star_args
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$update_star_args DD 021H
	DD	imagerel update_star_args
	DD	imagerel update_star_args+56
	DD	imagerel $unwind$update_star_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$update_star_args DD 021H
	DD	imagerel update_star_args+56
	DD	imagerel update_star_args+65
	DD	imagerel $chain$0$update_star_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$update_star_args DD 020521H
	DD	085405H
	DD	imagerel update_star_args+56
	DD	imagerel update_star_args+65
	DD	imagerel $chain$0$update_star_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$update_star_args DD 020521H
	DD	096405H
	DD	imagerel update_star_args
	DD	imagerel update_star_args+56
	DD	imagerel $unwind$update_star_args
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$update_star_args DD 081401H
	DD	0b7414H
	DD	0a3414H
	DD	0e0103214H
	DD	0c00cd00eH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT update_star_args
_TEXT	SEGMENT
nstack$ = 64
nstar$ = 72
stararg$ = 80
pp_stack$ = 88
update_star_args PROC					; COMDAT

; 4281 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	4c 63 e1	 movsxd	 r12, ecx
  00017	48 63 da	 movsxd	 rbx, edx
  0001a	49 8b f9	 mov	 rdi, r9

; 4282 :     PyObject *callargs, *w;
; 4283 : 
; 4284 :     callargs = PyTuple_New(nstack + nstar);

  0001d	41 8d 04 1c	 lea	 eax, DWORD PTR [r12+rbx]
  00021	4d 8b e8	 mov	 r13, r8
  00024	48 63 c8	 movsxd	 rcx, eax
  00027	e8 00 00 00 00	 call	 PyTuple_New
  0002c	4c 8b f0	 mov	 r14, rax

; 4285 :     if (callargs == NULL) {

  0002f	48 85 c0	 test	 rax, rax
  00032	0f 84 93 00 00
	00		 je	 $LN8@update_sta
$LN7@update_sta:
  00038	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 4286 :         return NULL;
; 4287 :     }
; 4288 :     if (nstar) {

  0003d	85 db		 test	 ebx, ebx
  0003f	74 3d		 je	 SHORT $LN12@update_sta

; 4289 :         int i;
; 4290 :         for (i = 0; i < nstar; i++) {

  00041	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  00046	48 8b eb	 mov	 rbp, rbx
  00049	7e 2e		 jle	 SHORT $LN15@update_sta
  0004b	49 8b c4	 mov	 rax, r12
  0004e	4b 8d 74 e6 70	 lea	 rsi, QWORD PTR [r14+r12*8+112]
  00053	48 c1 e0 03	 shl	 rax, 3
  00057	4c 2b e8	 sub	 r13, rax
  0005a	4d 2b ee	 sub	 r13, r14
  0005d	0f 1f 00	 npad	 3
$LL5@update_sta:

; 4291 :             PyObject *a = PyTuple_GET_ITEM(stararg, i);

  00060	49 8b 5c 35 00	 mov	 rbx, QWORD PTR [r13+rsi]

; 4292 :             Py_INCREF(a);

  00065	48 8b cb	 mov	 rcx, rbx
  00068	e8 00 00 00 00	 call	 _Py_IncRef

; 4293 :             PyTuple_SET_ITEM(callargs, nstack + i, a);

  0006d	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  00070	48 83 c6 08	 add	 rsi, 8
  00074	48 ff cd	 dec	 rbp
  00077	75 e7		 jne	 SHORT $LL5@update_sta
$LN15@update_sta:
  00079	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN12@update_sta:

; 4294 :         }
; 4295 :     }
; 4296 :     while (--nstack >= 0) {

  0007e	41 ff cc	 dec	 r12d
  00081	49 63 dc	 movsxd	 rbx, r12d
  00084	78 3d		 js	 SHORT $LN1@update_sta
  00086	49 8d 74 de 70	 lea	 rsi, QWORD PTR [r14+rbx*8+112]
  0008b	0f 1f 44 00 00	 npad	 5
$LL2@update_sta:

; 4297 :         w = EXT_POP(*pp_stack);

  00090	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR lltrace, 0
  00097	74 13		 je	 SHORT $LN10@update_sta
  00099	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07PACKFCLP@ext_pop?$AA@
  000a3	48 8b 49 f8	 mov	 rcx, QWORD PTR [rcx-8]
  000a7	e8 00 00 00 00	 call	 prtrace
$LN10@update_sta:
  000ac	48 83 07 f8	 add	 QWORD PTR [rdi], -8
  000b0	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000b3	48 83 ee 08	 sub	 rsi, 8
  000b7	48 ff cb	 dec	 rbx

; 4298 :         PyTuple_SET_ITEM(callargs, nstack, w);

  000ba	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000bd	48 89 4e 08	 mov	 QWORD PTR [rsi+8], rcx
  000c1	79 cd		 jns	 SHORT $LL2@update_sta
$LN1@update_sta:
  000c3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 4299 :     }
; 4300 :     return callargs;

  000c8	49 8b c6	 mov	 rax, r14
$LN8@update_sta:

; 4301 : }

  000cb	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000d0	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	41 5e		 pop	 r14
  000db	41 5d		 pop	 r13
  000dd	41 5c		 pop	 r12
  000df	c3		 ret	 0
update_star_args ENDP
_TEXT	ENDS
PUBLIC	??_C@_0ED@BCLNFLAD@slice?5indices?5must?5be?5integers?5o@ ; `string'
PUBLIC	_PyEval_SliceIndex
EXTRN	PyNumber_AsSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyEval_SliceIndex DD imagerel $LN8
	DD	imagerel $LN8+121
	DD	imagerel $unwind$_PyEval_SliceIndex
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyEval_SliceIndex DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0ED@BCLNFLAD@slice?5indices?5must?5be?5integers?5o@
CONST	SEGMENT
??_C@_0ED@BCLNFLAD@slice?5indices?5must?5be?5integers?5o@ DB 'slice indic'
	DB	'es must be integers or None or have an __index__ method', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT _PyEval_SliceIndex
_TEXT	SEGMENT
v$ = 48
pi$ = 56
_PyEval_SliceIndex PROC					; COMDAT

; 4469 : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 4470 :     if (v != NULL) {

  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 37		 je	 SHORT $LN4@PyEval_Sli

; 4471 :         Py_ssize_t x;
; 4472 :         if (PyIndex_Check(v)) {

  00012	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00016	4c 8b 80 b8 00
	00 00		 mov	 r8, QWORD PTR [rax+184]
  0001d	4d 85 c0	 test	 r8, r8
  00020	74 37		 je	 SHORT $LN3@PyEval_Sli
  00022	49 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [r8+264], 0
  0002a	74 2d		 je	 SHORT $LN3@PyEval_Sli

; 4473 :             x = PyNumber_AsSsize_t(v, NULL);

  0002c	33 d2		 xor	 edx, edx
  0002e	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00033	48 8b d8	 mov	 rbx, rax

; 4474 :             if (x == -1 && PyErr_Occurred())

  00036	48 83 f8 ff	 cmp	 rax, -1
  0003a	75 0a		 jne	 SHORT $LN2@PyEval_Sli
  0003c	e8 00 00 00 00	 call	 PyErr_Occurred
  00041	48 85 c0	 test	 rax, rax

; 4475 :                 return 0;

  00044	75 26		 jne	 SHORT $LN7@PyEval_Sli
$LN2@PyEval_Sli:

; 4482 :         }
; 4483 :         *pi = x;

  00046	48 89 1f	 mov	 QWORD PTR [rdi], rbx
$LN4@PyEval_Sli:

; 4484 :     }
; 4485 :     return 1;

  00049	b8 01 00 00 00	 mov	 eax, 1

; 4486 : }

  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN3@PyEval_Sli:

; 4476 :         }
; 4477 :         else {
; 4478 :             PyErr_SetString(PyExc_TypeError,
; 4479 :                             "slice indices must be integers or "
; 4480 :                             "None or have an __index__ method");

  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@BCLNFLAD@slice?5indices?5must?5be?5integers?5o@
  00067	e8 00 00 00 00	 call	 PyErr_SetString
$LN7@PyEval_Sli:

; 4481 :             return 0;

  0006c	33 c0		 xor	 eax, eax

; 4486 : }

  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
_PyEval_SliceIndex ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@OMNAMIPN@catching?5classes?5that?5do?5not?5inh@ ; `string'
EXTRN	PySequence_Contains:PROC
EXTRN	PyErr_GivenExceptionMatches:PROC
EXTRN	PyObject_RichCompare:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmp_outcome DD imagerel cmp_outcome
	DD	imagerel cmp_outcome+354
	DD	imagerel $unwind$cmp_outcome
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmp_outcome DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0EH@OMNAMIPN@catching?5classes?5that?5do?5not?5inh@
CONST	SEGMENT
??_C@_0EH@OMNAMIPN@catching?5classes?5that?5do?5not?5inh@ DB 'catching cl'
	DB	'asses that do not inherit from BaseException is not allowed', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT cmp_outcome
_TEXT	SEGMENT
op$ = 48
v$ = 56
w$ = 64
cmp_outcome PROC					; COMDAT

; 4493 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4494 :     int res = 0;
; 4495 :     switch (op) {

  0000a	44 8b c9	 mov	 r9d, ecx
  0000d	49 8b d8	 mov	 rbx, r8
  00010	48 8b fa	 mov	 rdi, rdx
  00013	41 83 e9 06	 sub	 r9d, 6
  00017	0f 84 2c 01 00
	00		 je	 $LN15@cmp_outcom
  0001d	41 ff c9	 dec	 r9d
  00020	0f 84 0d 01 00
	00		 je	 $LN13@cmp_outcom
  00026	41 ff c9	 dec	 r9d
  00029	0f 84 d2 00 00
	00		 je	 $LN17@cmp_outcom
  0002f	41 ff c9	 dec	 r9d
  00032	0f 84 bf 00 00
	00		 je	 $LN16@cmp_outcom
  00038	41 ff c9	 dec	 r9d
  0003b	74 18		 je	 SHORT $LN11@cmp_outcom

; 4535 :     default:
; 4536 :         return PyObject_RichCompare(v, w, op);

  0003d	44 8b c1	 mov	 r8d, ecx
  00040	48 8b d3	 mov	 rdx, rbx
  00043	48 8b cf	 mov	 rcx, rdi

; 4541 : }

  00046	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	e9 00 00 00 00	 jmp	 PyObject_RichCompare
$LN11@cmp_outcom:

; 4513 :     case PyCmp_EXC_MATCH:
; 4514 :         if (PyTuple_Check(w)) {

  00055	49 8b 40 58	 mov	 rax, QWORD PTR [r8+88]
  00059	8b 88 00 01 00
	00		 mov	 ecx, DWORD PTR [rax+256]
  0005f	0f ba e1 1a	 bt	 ecx, 26
  00063	73 74		 jae	 SHORT $LN10@cmp_outcom

; 4515 :             Py_ssize_t i, length;
; 4516 :             length = PyTuple_Size(w);

  00065	48 8b cb	 mov	 rcx, rbx
  00068	e8 00 00 00 00	 call	 PyTuple_Size
  0006d	4c 8b d8	 mov	 r11, rax

; 4517 :             for (i = 0; i < length; i += 1) {

  00070	33 c0		 xor	 eax, eax
  00072	4d 85 db	 test	 r11, r11
  00075	7e 73		 jle	 SHORT $LN3@cmp_outcom

; 4515 :             Py_ssize_t i, length;
; 4516 :             length = PyTuple_Size(w);

  00077	48 8d 53 70	 lea	 rdx, QWORD PTR [rbx+112]
  0007b	0f 1f 44 00 00	 npad	 5
$LL9@cmp_outcom:

; 4518 :                 PyObject *exc = PyTuple_GET_ITEM(w, i);

  00080	4c 8b 02	 mov	 r8, QWORD PTR [rdx]

; 4519 :                 if (!PyExceptionClass_Check(exc)) {

  00083	49 8b 48 58	 mov	 rcx, QWORD PTR [r8+88]
  00087	f7 81 00 01 00
	00 00 00 00 80	 test	 DWORD PTR [rcx+256], -2147483648 ; ffffffff80000000H
  00091	74 26		 je	 SHORT $LN23@cmp_outcom
  00093	41 f7 80 00 01
	00 00 00 00 00
	40		 test	 DWORD PTR [r8+256], 1073741824 ; 40000000H
  0009e	74 19		 je	 SHORT $LN23@cmp_outcom

; 4517 :             for (i = 0; i < length; i += 1) {

  000a0	48 ff c0	 inc	 rax
  000a3	48 83 c2 08	 add	 rdx, 8
  000a7	49 3b c3	 cmp	 rax, r11
  000aa	7c d4		 jl	 SHORT $LL9@cmp_outcom

; 4528 :                 PyErr_SetString(PyExc_TypeError,
; 4529 :                                 CANNOT_CATCH_MSG);
; 4530 :                 return NULL;
; 4531 :             }
; 4532 :         }
; 4533 :         res = PyErr_GivenExceptionMatches(v, w);

  000ac	48 8b d3	 mov	 rdx, rbx
  000af	48 8b cf	 mov	 rcx, rdi
  000b2	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches

; 4534 :         break;

  000b7	eb 50		 jmp	 SHORT $LN14@cmp_outcom
$LN23@cmp_outcom:

; 4520 :                     PyErr_SetString(PyExc_TypeError,
; 4521 :                                     CANNOT_CATCH_MSG);

  000b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EH@OMNAMIPN@catching?5classes?5that?5do?5not?5inh@
  000c7	e8 00 00 00 00	 call	 PyErr_SetString

; 4522 :                     return NULL;

  000cc	33 c0		 xor	 eax, eax

; 4541 : }

  000ce	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000d3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d7	5f		 pop	 rdi
  000d8	c3		 ret	 0
$LN10@cmp_outcom:

; 4523 :                 }
; 4524 :             }
; 4525 :         }
; 4526 :         else {
; 4527 :             if (!PyExceptionClass_Check(w)) {

  000d9	85 c9		 test	 ecx, ecx
  000db	79 dc		 jns	 SHORT $LN23@cmp_outcom
  000dd	41 f7 80 00 01
	00 00 00 00 00
	40		 test	 DWORD PTR [r8+256], 1073741824 ; 40000000H
  000e8	74 cf		 je	 SHORT $LN23@cmp_outcom
$LN3@cmp_outcom:

; 4528 :                 PyErr_SetString(PyExc_TypeError,
; 4529 :                                 CANNOT_CATCH_MSG);
; 4530 :                 return NULL;
; 4531 :             }
; 4532 :         }
; 4533 :         res = PyErr_GivenExceptionMatches(v, w);

  000ea	48 8b d3	 mov	 rdx, rbx
  000ed	48 8b cf	 mov	 rcx, rdi
  000f0	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches

; 4534 :         break;

  000f5	eb 12		 jmp	 SHORT $LN14@cmp_outcom
$LN16@cmp_outcom:

; 4498 :         break;
; 4499 :     case PyCmp_IS_NOT:
; 4500 :         res = (v != w);

  000f7	33 c0		 xor	 eax, eax
  000f9	48 3b d3	 cmp	 rdx, rbx
  000fc	0f 95 c0	 setne	 al

; 4501 :         break;

  000ff	eb 08		 jmp	 SHORT $LN14@cmp_outcom
$LN17@cmp_outcom:

; 4496 :     case PyCmp_IS:
; 4497 :         res = (v == w);

  00101	33 c0		 xor	 eax, eax
  00103	48 3b d3	 cmp	 rdx, rbx
$LN25@cmp_outcom:

; 4511 :         res = !res;

  00106	0f 94 c0	 sete	 al
$LN14@cmp_outcom:

; 4537 :     }
; 4538 :     v = res ? Py_True : Py_False;

  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_TrueStruct
  00110	85 c0		 test	 eax, eax
  00112	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Py_FalseStruct
  00119	48 0f 45 d9	 cmovne	 rbx, rcx

; 4539 :     Py_INCREF(v);

  0011d	48 8b cb	 mov	 rcx, rbx
  00120	e8 00 00 00 00	 call	 _Py_IncRef

; 4540 :     return v;

  00125	48 8b c3	 mov	 rax, rbx

; 4541 : }

  00128	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0012d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00131	5f		 pop	 rdi
  00132	c3		 ret	 0
$LN13@cmp_outcom:

; 4506 :         break;
; 4507 :     case PyCmp_NOT_IN:
; 4508 :         res = PySequence_Contains(w, v);

  00133	48 8b cb	 mov	 rcx, rbx
  00136	e8 00 00 00 00	 call	 PySequence_Contains
  0013b	44 8b d8	 mov	 r11d, eax

; 4509 :         if (res < 0)

  0013e	85 c0		 test	 eax, eax

; 4510 :             return NULL;

  00140	78 13		 js	 SHORT $LN26@cmp_outcom

; 4511 :         res = !res;

  00142	33 c0		 xor	 eax, eax
  00144	45 85 db	 test	 r11d, r11d

; 4512 :         break;

  00147	eb bd		 jmp	 SHORT $LN25@cmp_outcom
$LN15@cmp_outcom:

; 4502 :     case PyCmp_IN:
; 4503 :         res = PySequence_Contains(w, v);

  00149	48 8b cb	 mov	 rcx, rbx
  0014c	e8 00 00 00 00	 call	 PySequence_Contains

; 4504 :         if (res < 0)

  00151	85 c0		 test	 eax, eax
  00153	79 b4		 jns	 SHORT $LN14@cmp_outcom
$LN26@cmp_outcom:

; 4505 :             return NULL;

  00155	33 c0		 xor	 eax, eax

; 4541 : }

  00157	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0015c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00160	5f		 pop	 rdi
  00161	c3		 ret	 0
cmp_outcome ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@DOMICKHG@cannot?5import?5name?5?$CFS?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$import_from DD imagerel import_from
	DD	imagerel import_from+78
	DD	imagerel $unwind$import_from
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$import_from DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0BG@DOMICKHG@cannot?5import?5name?5?$CFS?$AA@
CONST	SEGMENT
??_C@_0BG@DOMICKHG@cannot?5import?5name?5?$CFS?$AA@ DB 'cannot import nam'
	DB	'e %S', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT import_from
_TEXT	SEGMENT
v$ = 48
name$ = 56
import_from PROC					; COMDAT

; 4545 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx

; 4546 :     PyObject *x;
; 4547 : 
; 4548 :     x = PyObject_GetAttr(v, name);

  0000d	e8 00 00 00 00	 call	 PyObject_GetAttr
  00012	48 8b d8	 mov	 rbx, rax

; 4549 :     if (x == NULL && PyErr_ExceptionMatches(PyExc_AttributeError)) {

  00015	48 85 c0	 test	 rax, rax
  00018	75 29		 jne	 SHORT $LN1@import_fro
  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00021	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00026	85 c0		 test	 eax, eax
  00028	74 16		 je	 SHORT $LN5@import_fro

; 4550 :         PyErr_Format(PyExc_ImportError, "cannot import name %S", name);

  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@DOMICKHG@cannot?5import?5name?5?$CFS?$AA@
  00038	4c 8b c7	 mov	 r8, rdi
  0003b	e8 00 00 00 00	 call	 PyErr_Format
$LN5@import_fro:

; 4551 :     }
; 4552 :     return x;

  00040	48 8b c3	 mov	 rax, rbx
$LN1@import_fro:

; 4553 : }

  00043	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
import_from ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ ; `string'
PUBLIC	??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DC@BCOPIKLM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0DE@MKAFNGIJ@from?9import?9?$CK?5object?5has?5no?5__di@ ; `string'
EXTRN	PyExc_IndexError:QWORD
EXTRN	_PyUnicode_Ready:PROC
EXTRN	PySequence_GetItem:PROC
EXTRN	PyMapping_Keys:PROC
EXTRN	_PyObject_GetAttrId:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$import_all_from DD imagerel import_all_from
	DD	imagerel import_all_from+1353
	DD	imagerel $unwind$import_all_from
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$import_all_from DD 0cde01H
	DD	0bf4deH
	DD	0a64d4H
	DD	0c3411H
	DD	0e00d3211H
	DD	0c009d00bH
	DD	050067007H
xdata	ENDS
;	COMDAT ??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
CONST	SEGMENT
??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@ DB '('
	DB	00H, '(', 00H, 'P', 00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, 'O', 00H, 'b', 00H, 'j'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, '*', 00H, ')', 00H, '(', 00H
	DB	'(', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ')', 00H, ')'
	DB	00H, ')', 00H, '-', 00H, '>', 00H, 'd', 00H, 'a', 00H, 't', 00H
	DB	'a', 00H, '.', 00H, 'a', 00H, 'n', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, '(', 00H
	DB	'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H, ')', 00H, ')', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, '(', 00H, 'n', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, ')', 00H, ')', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@BCOPIKLM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@BCOPIKLM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'I', 00H, 'S', 00H, '_', 00H, 'R'
	DB	00H, 'E', 00H, 'A', 00H, 'D', 00H, 'Y', 00H, '(', 00H, 'n', 00H
	DB	'a', 00H, 'm', 00H, 'e', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'U', 00H, 'n', 00H, 'i', 00H, 'c', 00H, 'o', 00H
	DB	'd', 00H, 'e', 00H, '_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c'
	DB	00H, 'k', 00H, '(', 00H, 'n', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	')', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@MKAFNGIJ@from?9import?9?$CK?5object?5has?5no?5__di@
CONST	SEGMENT
??_C@_0DE@MKAFNGIJ@from?9import?9?$CK?5object?5has?5no?5__di@ DB 'from-im'
	DB	'port-* object has no __dict__ and no __all__', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT import_all_from
_TEXT	SEGMENT
locals$ = 80
v$ = 88
import_all_from PROC					; COMDAT

; 4557 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4558 :     _Py_IDENTIFIER(__all__);
; 4559 :     _Py_IDENTIFIER(__dict__);
; 4560 :     PyObject *all = _PyObject_GetAttrId(v, &PyId___all__);

  00011	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR _tls_index
  00018	65 48 8b 04 25
	58 00 00 00	 mov	 rax, QWORD PTR gs:88
  00021	4c 8b f2	 mov	 r14, rdx
  00024	4a 8b 1c c0	 mov	 rbx, QWORD PTR [rax+r8*8]
  00028	4c 8b e1	 mov	 r12, rcx
  0002b	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___all__@?1??import_all_from@@9@9
  00030	48 03 d3	 add	 rdx, rbx
  00033	49 8b ce	 mov	 rcx, r14
  00036	e8 00 00 00 00	 call	 _PyObject_GetAttrId

; 4561 :     PyObject *dict, *name, *value;
; 4562 :     int skip_leading_underscores = 0;

  0003b	45 33 ed	 xor	 r13d, r13d
  0003e	48 8b e8	 mov	 rbp, rax
  00041	41 8b fd	 mov	 edi, r13d

; 4563 :     int pos, err;
; 4564 : 
; 4565 :     if (all == NULL) {

  00044	48 85 c0	 test	 rax, rax
  00047	0f 85 82 00 00
	00		 jne	 $LN22@import_all

; 4566 :         if (!PyErr_ExceptionMatches(PyExc_AttributeError))

  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00054	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00059	85 c0		 test	 eax, eax

; 4567 :             return -1; /* Unexpected error */

  0005b	74 40		 je	 SHORT $LN69@import_all

; 4568 :         PyErr_Clear();

  0005d	e8 00 00 00 00	 call	 PyErr_Clear

; 4569 :         dict = _PyObject_GetAttrId(v, &PyId___dict__);

  00062	ba 00 00 00 00	 mov	 edx, OFFSET FLAT:?PyId___dict__@?1??import_all_from@@9@9
  00067	49 8b ce	 mov	 rcx, r14
  0006a	48 03 d3	 add	 rdx, rbx
  0006d	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00072	48 8b d8	 mov	 rbx, rax

; 4570 :         if (dict == NULL) {

  00075	48 85 c0	 test	 rax, rax
  00078	75 38		 jne	 SHORT $LN20@import_all

; 4571 :             if (!PyErr_ExceptionMatches(PyExc_AttributeError))

  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00081	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00086	85 c0		 test	 eax, eax

; 4572 :                 return -1;

  00088	74 13		 je	 SHORT $LN69@import_all

; 4573 :             PyErr_SetString(PyExc_ImportError,
; 4574 :             "from-import-* object has no __dict__ and no __all__");

  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ImportError
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@MKAFNGIJ@from?9import?9?$CK?5object?5has?5no?5__di@
  00098	e8 00 00 00 00	 call	 PyErr_SetString
$LN69@import_all:

; 4575 :             return -1;

  0009d	83 c8 ff	 or	 eax, -1

; 4614 :     return err;
; 4615 : }

  000a0	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	41 5e		 pop	 r14
  000ab	41 5d		 pop	 r13
  000ad	41 5c		 pop	 r12
  000af	5f		 pop	 rdi
  000b0	5d		 pop	 rbp
  000b1	c3		 ret	 0
$LN20@import_all:

; 4576 :         }
; 4577 :         all = PyMapping_Keys(dict);

  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 PyMapping_Keys

; 4578 :         Py_DECREF(dict);

  000ba	48 8b cb	 mov	 rcx, rbx
  000bd	48 8b e8	 mov	 rbp, rax
  000c0	e8 00 00 00 00	 call	 _Py_DecRef

; 4579 :         if (all == NULL)

  000c5	48 85 ed	 test	 rbp, rbp

; 4580 :             return -1;

  000c8	74 d3		 je	 SHORT $LN69@import_all

; 4581 :         skip_leading_underscores = 1;

  000ca	bf 01 00 00 00	 mov	 edi, 1
$LN22@import_all:
  000cf	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi

; 4585 :         name = PySequence_GetItem(all, pos);

  000d4	33 d2		 xor	 edx, edx
  000d6	48 8b cd	 mov	 rcx, rbp
  000d9	4c 89 7c 24 58	 mov	 QWORD PTR [rsp+88], r15
  000de	41 8b f5	 mov	 esi, r13d
  000e1	e8 00 00 00 00	 call	 PySequence_GetItem
  000e6	48 8b d8	 mov	 rbx, rax

; 4591 :             break;
; 4592 :         }
; 4593 :         if (skip_leading_underscores &&
; 4594 :             PyUnicode_Check(name) &&
; 4595 :             PyUnicode_READY(name) != -1 &&
; 4596 :             PyUnicode_READ_CHAR(name, 0) == '_')

  000e9	4c 63 ff	 movsxd	 r15, edi
  000ec	48 85 c0	 test	 rax, rax
  000ef	0f 84 14 04 00
	00		 je	 $LN64@import_all
$LL17@import_all:
  000f5	4d 85 ff	 test	 r15, r15
  000f8	0f 84 8b 03 00
	00		 je	 $LN11@import_all
  000fe	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00102	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0010c	0f 84 77 03 00
	00		 je	 $LN11@import_all
  00112	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00116	75 11		 jne	 SHORT $LN67@import_all
  00118	48 8b cb	 mov	 rcx, rbx
  0011b	e8 00 00 00 00	 call	 _PyUnicode_Ready
  00120	83 f8 ff	 cmp	 eax, -1
  00123	0f 84 60 03 00
	00		 je	 $LN11@import_all
$LN67@import_all:
  00129	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0012d	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00137	75 1a		 jne	 SHORT $LN28@import_all
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CM@NNIOODFF@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  00147	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN28@import_all:
  00153	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00157	75 1a		 jne	 SHORT $LN29@import_all
  00159	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@BCOPIKLM@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$AA@
  00167	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN29@import_all:
  00173	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00177	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00181	75 1a		 jne	 SHORT $LN30@import_all
  00183	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0018a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00191	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN30@import_all:
  0019d	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  001a1	75 1a		 jne	 SHORT $LN31@import_all
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  001b1	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN31@import_all:
  001bd	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  001c0	24 1c		 and	 al, 28
  001c2	3c 04		 cmp	 al, 4
  001c4	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001c8	0f 85 cd 00 00
	00		 jne	 $LN60@import_all
  001ce	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  001d8	75 1a		 jne	 SHORT $LN32@import_all
  001da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  001e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  001e8	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN32@import_all:
  001f4	f6 43 70 20	 test	 BYTE PTR [rbx+112], 32	; 00000020H
  001f8	74 6e		 je	 SHORT $LN38@import_all
  001fa	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  001fe	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  00208	75 1a		 jne	 SHORT $LN33@import_all
  0020a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00218	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN33@import_all:
  00224	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00228	75 1a		 jne	 SHORT $LN34@import_all
  0022a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00238	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN34@import_all:
  00244	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H
  00248	74 0f		 je	 SHORT $LN35@import_all
  0024a	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00251	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00254	e9 21 02 00 00	 jmp	 $LN59@import_all
$LN35@import_all:
  00259	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00260	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00263	e9 12 02 00 00	 jmp	 $LN59@import_all
$LN38@import_all:
  00268	48 83 bb a0 00
	00 00 00	 cmp	 QWORD PTR [rbx+160], 0
  00270	75 1a		 jne	 SHORT $LN37@import_all
  00272	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  00280	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN37@import_all:
  0028c	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  00293	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00296	e9 df 01 00 00	 jmp	 $LN59@import_all
$LN60@import_all:
  0029b	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  002a5	75 1a		 jne	 SHORT $LN40@import_all
  002a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  002ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  002b5	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  002bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN40@import_all:
  002c1	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  002c5	75 1a		 jne	 SHORT $LN41@import_all
  002c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  002ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  002d5	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  002db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN41@import_all:
  002e1	8b 43 70	 mov	 eax, DWORD PTR [rbx+112]
  002e4	24 1c		 and	 al, 28
  002e6	3c 08		 cmp	 al, 8
  002e8	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  002ec	0f 85 cd 00 00
	00		 jne	 $LN58@import_all
  002f2	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  002fc	75 1a		 jne	 SHORT $LN42@import_all
  002fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00305	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0030c	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  00312	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN42@import_all:
  00318	f6 43 70 20	 test	 BYTE PTR [rbx+112], 32	; 00000020H
  0031c	74 6e		 je	 SHORT $LN48@import_all
  0031e	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00322	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  0032c	75 1a		 jne	 SHORT $LN43@import_all
  0032e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00335	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0033c	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  00342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN43@import_all:
  00348	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  0034c	75 1a		 jne	 SHORT $LN44@import_all
  0034e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00355	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  0035c	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN44@import_all:
  00368	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H
  0036c	74 0f		 je	 SHORT $LN45@import_all
  0036e	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00375	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00378	e9 fd 00 00 00	 jmp	 $LN59@import_all
$LN45@import_all:
  0037d	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  00384	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  00387	e9 ee 00 00 00	 jmp	 $LN59@import_all
$LN48@import_all:
  0038c	48 83 bb a0 00
	00 00 00	 cmp	 QWORD PTR [rbx+160], 0
  00394	75 1a		 jne	 SHORT $LN47@import_all
  00396	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0039d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  003a4	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  003aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN47@import_all:
  003b0	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
  003b7	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  003ba	e9 bb 00 00 00	 jmp	 $LN59@import_all
$LN58@import_all:
  003bf	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  003c9	75 1a		 jne	 SHORT $LN50@import_all
  003cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  003d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  003d9	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  003df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN50@import_all:
  003e5	f6 43 70 20	 test	 BYTE PTR [rbx+112], 32	; 00000020H
  003e9	74 62		 je	 SHORT $LN56@import_all
  003eb	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  003ef	f7 80 00 01 00
	00 00 00 00 10	 test	 DWORD PTR [rax+256], 268435456 ; 10000000H
  003f9	75 1a		 jne	 SHORT $LN51@import_all
  003fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00402	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DA@LEBIMPLA@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00409	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  0040f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN51@import_all:
  00415	f6 43 70 80	 test	 BYTE PTR [rbx+112], 128	; 00000080H
  00419	75 1a		 jne	 SHORT $LN52@import_all
  0041b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  00422	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DG@CPFELEGK@?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AA_?$AAI?$AAS?$AA_?$AAR?$AAE?$AAA?$AAD?$AAY?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$AA@
  00429	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  0042f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN52@import_all:
  00435	f6 43 70 40	 test	 BYTE PTR [rbx+112], 64	; 00000040H
  00439	74 09		 je	 SHORT $LN53@import_all
  0043b	48 8d 83 80 00
	00 00		 lea	 rax, QWORD PTR [rbx+128]
  00442	eb 34		 jmp	 SHORT $LN57@import_all
$LN53@import_all:
  00444	48 8d 83 a0 00
	00 00		 lea	 rax, QWORD PTR [rbx+160]
  0044b	eb 2b		 jmp	 SHORT $LN57@import_all
$LN56@import_all:
  0044d	48 83 bb a0 00
	00 00 00	 cmp	 QWORD PTR [rbx+160], 0
  00455	75 1a		 jne	 SHORT $LN55@import_all
  00457	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CE@BLKIPNIC@?$AA?4?$AA?4?$AA?2?$AAP?$AAy?$AAt?$AAh?$AAo?$AAn?$AA?2?$AAc?$AAe?$AAv?$AAa?$AAl?$AA?4?$AAc?$AA?$AA@
  0045e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EO@OCONNBCF@?$AA?$CI?$AA?$CI?$AAP?$AAy?$AAU?$AAn?$AAi?$AAc?$AAo?$AAd?$AAe?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AA?$CK?$AA?$CJ?$AA?$CI?$AA?$CI?$AAn?$AAa?$AAm?$AAe?$AA?$CJ?$AA?$CJ?$AA?$CJ?$AA?9?$AA?$DO?$AAd?$AAa@
  00465	41 b8 f4 11 00
	00		 mov	 r8d, 4596		; 000011f4H
  0046b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
$LN55@import_all:
  00471	48 8b 83 a0 00
	00 00		 mov	 rax, QWORD PTR [rbx+160]
$LN57@import_all:
  00478	8b 08		 mov	 ecx, DWORD PTR [rax]
$LN59@import_all:
  0047a	83 f9 5f	 cmp	 ecx, 95			; 0000005fH
  0047d	75 0a		 jne	 SHORT $LN11@import_all

; 4597 :         {
; 4598 :             Py_DECREF(name);

  0047f	48 8b cb	 mov	 rcx, rbx
  00482	e8 00 00 00 00	 call	 _Py_DecRef

; 4599 :             continue;

  00487	eb 66		 jmp	 SHORT $LN16@import_all
$LN11@import_all:

; 4600 :         }
; 4601 :         value = PyObject_GetAttr(v, name);

  00489	48 8b d3	 mov	 rdx, rbx
  0048c	49 8b ce	 mov	 rcx, r14
  0048f	e8 00 00 00 00	 call	 PyObject_GetAttr
  00494	48 8b f8	 mov	 rdi, rax

; 4602 :         if (value == NULL)

  00497	48 85 c0	 test	 rax, rax
  0049a	75 05		 jne	 SHORT $LN10@import_all

; 4603 :             err = -1;

  0049c	83 ce ff	 or	 esi, -1
  0049f	eb 35		 jmp	 SHORT $LN6@import_all
$LN10@import_all:

; 4604 :         else if (PyDict_CheckExact(locals))

  004a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  004a8	49 39 44 24 58	 cmp	 QWORD PTR [r12+88], rax
  004ad	74 17		 je	 SHORT $LN7@import_all
  004af	49 39 44 24 38	 cmp	 QWORD PTR [r12+56], rax
  004b4	74 10		 je	 SHORT $LN7@import_all

; 4606 :         else
; 4607 :             err = PyObject_SetItem(locals, name, value);

  004b6	4c 8b c7	 mov	 r8, rdi
  004b9	48 8b d3	 mov	 rdx, rbx
  004bc	49 8b cc	 mov	 rcx, r12
  004bf	e8 00 00 00 00	 call	 PyObject_SetItem
  004c4	eb 0e		 jmp	 SHORT $LN68@import_all
$LN7@import_all:

; 4605 :             err = PyDict_SetItem(locals, name, value);

  004c6	4c 8b c7	 mov	 r8, rdi
  004c9	48 8b d3	 mov	 rdx, rbx
  004cc	49 8b cc	 mov	 rcx, r12
  004cf	e8 00 00 00 00	 call	 PyDict_SetItem
$LN68@import_all:
  004d4	8b f0		 mov	 esi, eax
$LN6@import_all:

; 4608 :         Py_DECREF(name);

  004d6	48 8b cb	 mov	 rcx, rbx
  004d9	e8 00 00 00 00	 call	 _Py_DecRef

; 4609 :         Py_XDECREF(value);

  004de	48 85 ff	 test	 rdi, rdi
  004e1	74 08		 je	 SHORT $LN4@import_all
  004e3	48 8b cf	 mov	 rcx, rdi
  004e6	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@import_all:

; 4610 :         if (err != 0)

  004eb	85 f6		 test	 esi, esi
  004ed	75 34		 jne	 SHORT $LN12@import_all
$LN16@import_all:

; 4582 :     }
; 4583 : 
; 4584 :     for (pos = 0, err = 0; ; pos++) {

  004ef	41 ff c5	 inc	 r13d

; 4585 :         name = PySequence_GetItem(all, pos);

  004f2	48 8b cd	 mov	 rcx, rbp
  004f5	49 63 d5	 movsxd	 rdx, r13d
  004f8	e8 00 00 00 00	 call	 PySequence_GetItem
  004fd	48 8b d8	 mov	 rbx, rax

; 4586 :         if (name == NULL) {

  00500	48 85 c0	 test	 rax, rax
  00503	0f 85 ec fb ff
	ff		 jne	 $LL17@import_all
$LN64@import_all:

; 4587 :             if (!PyErr_ExceptionMatches(PyExc_IndexError))

  00509	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IndexError
  00510	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00515	85 c0		 test	 eax, eax
  00517	75 05		 jne	 SHORT $LN13@import_all

; 4588 :                 err = -1;

  00519	83 ce ff	 or	 esi, -1

; 4589 :             else

  0051c	eb 05		 jmp	 SHORT $LN12@import_all
$LN13@import_all:

; 4590 :                 PyErr_Clear();

  0051e	e8 00 00 00 00	 call	 PyErr_Clear
$LN12@import_all:

; 4611 :             break;
; 4612 :     }
; 4613 :     Py_DECREF(all);

  00523	48 8b cd	 mov	 rcx, rbp
  00526	e8 00 00 00 00	 call	 _Py_DecRef
  0052b	4c 8b 7c 24 58	 mov	 r15, QWORD PTR [rsp+88]

; 4614 :     return err;
; 4615 : }

  00530	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00535	8b c6		 mov	 eax, esi
  00537	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0053c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00540	41 5e		 pop	 r14
  00542	41 5d		 pop	 r13
  00544	41 5c		 pop	 r12
  00546	5f		 pop	 rdi
  00547	5d		 pop	 rbp
  00548	c3		 ret	 0
import_all_from ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_exc_check_arg DD imagerel format_exc_check_arg
	DD	imagerel format_exc_check_arg+60
	DD	imagerel $unwind$format_exc_check_arg
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_exc_check_arg DD 040f01H
	DD	06340fH
	DD	0700b320fH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT format_exc_check_arg
_TEXT	SEGMENT
exc$ = 48
format_str$ = 56
obj$ = 64
format_exc_check_arg PROC				; COMDAT

; 4620 :     const char *obj_str;
; 4621 : 
; 4622 :     if (!obj)

  00000	4d 85 c0	 test	 r8, r8
  00003	74 35		 je	 SHORT $LN5@format_exc
  00005	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4619 : {

  0000f	48 8b f9	 mov	 rdi, rcx

; 4623 :         return;
; 4624 : 
; 4625 :     obj_str = _PyUnicode_AsString(obj);

  00012	49 8b c8	 mov	 rcx, r8
  00015	48 8b da	 mov	 rbx, rdx
  00018	e8 00 00 00 00	 call	 PyUnicode_AsUTF8

; 4626 :     if (!obj_str)

  0001d	48 85 c0	 test	 rax, rax
  00020	74 0e		 je	 SHORT $LN3@format_exc

; 4627 :         return;
; 4628 : 
; 4629 :     PyErr_Format(exc, format_str, obj_str);

  00022	4c 8b c0	 mov	 r8, rax
  00025	48 8b d3	 mov	 rdx, rbx
  00028	48 8b cf	 mov	 rcx, rdi
  0002b	e8 00 00 00 00	 call	 PyErr_Format
$LN3@format_exc:

; 4630 : }

  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
$LN5@format_exc:
  0003a	f3 c3		 fatret	 0
format_exc_check_arg ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EH@DLENIDCI@free?5variable?5?8?$CF?4200s?8?5reference@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$format_exc_unbound DD imagerel format_exc_unbound
	DD	imagerel format_exc_unbound+124
	DD	imagerel $unwind$format_exc_unbound
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$format_exc_unbound DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT ??_C@_0EH@DLENIDCI@free?5variable?5?8?$CF?4200s?8?5reference@
CONST	SEGMENT
??_C@_0EH@DLENIDCI@free?5variable?5?8?$CF?4200s?8?5reference@ DB 'free va'
	DB	'riable ''%.200s'' referenced before assignment in enclosing s'
	DB	'cope', 00H					; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT format_exc_unbound
_TEXT	SEGMENT
co$ = 48
oparg$ = 56
format_exc_unbound PROC					; COMDAT

; 4634 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 63 fa	 movsxd	 rdi, edx
  0000d	48 8b d9	 mov	 rbx, rcx

; 4635 :     PyObject *name;
; 4636 :     /* Don't stomp existing exception */
; 4637 :     if (PyErr_Occurred())

  00010	e8 00 00 00 00	 call	 PyErr_Occurred
  00015	48 85 c0	 test	 rax, rax
  00018	75 57		 jne	 SHORT $LN1@format_exc@2

; 4638 :         return;
; 4639 :     if (oparg < PyTuple_GET_SIZE(co->co_cellvars)) {

  0001a	4c 8b 83 a0 00
	00 00		 mov	 r8, QWORD PTR [rbx+160]
  00021	48 8b c7	 mov	 rax, rdi
  00024	49 8b 50 60	 mov	 rdx, QWORD PTR [r8+96]
  00028	48 3b fa	 cmp	 rdi, rdx
  0002b	7d 22		 jge	 SHORT $LN2@format_exc@2

; 4640 :         name = PyTuple_GET_ITEM(co->co_cellvars,
; 4641 :                                 oparg);
; 4642 :         format_exc_check_arg(
; 4643 :             PyExc_UnboundLocalError,
; 4644 :             UNBOUNDLOCAL_ERROR_MSG,
; 4645 :             name);

  0002d	4d 8b 44 f8 70	 mov	 r8, QWORD PTR [r8+rdi*8+112]
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_UnboundLocalError
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@HKMDOJCI@local?5variable?5?8?$CF?4200s?8?5referenc@

; 4651 :     }
; 4652 : }

  00040	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	e9 00 00 00 00	 jmp	 format_exc_check_arg
$LN2@format_exc@2:

; 4646 :     } else {
; 4647 :         name = PyTuple_GET_ITEM(co->co_freevars, oparg -
; 4648 :                                 PyTuple_GET_SIZE(co->co_cellvars));
; 4649 :         format_exc_check_arg(PyExc_NameError,
; 4650 :                              UNBOUNDFREE_ERROR_MSG, name);

  0004f	4c 8b 83 98 00
	00 00		 mov	 r8, QWORD PTR [rbx+152]
  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_NameError
  0005d	48 2b c2	 sub	 rax, rdx
  00060	4d 8b 44 c0 70	 mov	 r8, QWORD PTR [r8+rax*8+112]
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EH@DLENIDCI@free?5variable?5?8?$CF?4200s?8?5reference@
  0006c	e8 00 00 00 00	 call	 format_exc_check_arg
$LN1@format_exc@2:

; 4651 :     }
; 4652 : }

  00071	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
format_exc_unbound ENDP
_TEXT	ENDS
EXTRN	PyUnicode_Append:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$unicode_concatenate DD imagerel unicode_concatenate
	DD	imagerel unicode_concatenate+190
	DD	imagerel $unwind$unicode_concatenate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$unicode_concatenate DD imagerel unicode_concatenate+190
	DD	imagerel unicode_concatenate+290
	DD	imagerel $chain$0$unicode_concatenate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$unicode_concatenate DD imagerel unicode_concatenate+290
	DD	imagerel unicode_concatenate+329
	DD	imagerel $chain$1$unicode_concatenate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$unicode_concatenate DD 021H
	DD	imagerel unicode_concatenate
	DD	imagerel unicode_concatenate+190
	DD	imagerel $unwind$unicode_concatenate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$unicode_concatenate DD 020521H
	DD	076405H
	DD	imagerel unicode_concatenate
	DD	imagerel unicode_concatenate+190
	DD	imagerel $unwind$unicode_concatenate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$unicode_concatenate DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0700b320fH
; Function compile flags: /Ogtp
xdata	ENDS
;	COMDAT unicode_concatenate
_TEXT	SEGMENT
res$ = 48
v$ = 48
w$ = 56
f$ = 64
next_instr$ = 72
unicode_concatenate PROC				; COMDAT

; 4657 : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 4658 :     PyObject *res;
; 4659 :     if (Py_REFCNT(v) == 2) {

  0000f	48 83 79 50 02	 cmp	 QWORD PTR [rcx+80], 2
  00014	49 8b f8	 mov	 rdi, r8
  00017	48 8b ea	 mov	 rbp, rdx
  0001a	48 8b d9	 mov	 rbx, rcx
  0001d	0f 85 ff 00 00
	00		 jne	 $LN1@unicode_co

; 4660 :         /* In the common case, there are 2 references to the value
; 4661 :          * stored in 'variable' when the += is performed: one on the
; 4662 :          * value stack (in 'v') and one still stored in the
; 4663 :          * 'variable'.  We try to delete the variable now to reduce
; 4664 :          * the refcnt to 1.
; 4665 :          */
; 4666 :         switch (*next_instr) {

  00023	45 0f b6 11	 movzx	 r10d, BYTE PTR [r9]
  00027	41 83 ea 5a	 sub	 r10d, 90		; 0000005aH
  0002b	0f 84 84 00 00
	00		 je	 $LN4@unicode_co
  00031	41 83 ea 23	 sub	 r10d, 35		; 00000023H
  00035	74 44		 je	 SHORT $LN15@unicode_co
  00037	41 83 fa 0c	 cmp	 r10d, 12
  0003b	0f 85 e1 00 00
	00		 jne	 $LN1@unicode_co

; 4674 :         }
; 4675 :         case STORE_DEREF:
; 4676 :         {
; 4677 :             PyObject **freevars = (f->f_localsplus +
; 4678 :                                    f->f_code->co_nlocals);
; 4679 :             PyObject *c = freevars[PEEKARG()];

  00041	49 8b 40 78	 mov	 rax, QWORD PTR [r8+120]
  00045	41 0f b6 51 02	 movzx	 edx, BYTE PTR [r9+2]
  0004a	48 63 48 68	 movsxd	 rcx, DWORD PTR [rax+104]
  0004e	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00053	48 c1 e2 08	 shl	 rdx, 8
  00057	48 03 d1	 add	 rdx, rcx
  0005a	48 03 d0	 add	 rdx, rax
  0005d	49 8b 8c d0 d0
	01 00 00	 mov	 rcx, QWORD PTR [r8+rdx*8+464]

; 4680 :             if (PyCell_GET(c) == v)

  00065	48 39 59 60	 cmp	 QWORD PTR [rcx+96], rbx
  00069	0f 85 b3 00 00
	00		 jne	 $LN1@unicode_co

; 4681 :                 PyCell_Set(c, NULL);

  0006f	33 d2		 xor	 edx, edx
  00071	e8 00 00 00 00	 call	 PyCell_Set

; 4682 :             break;

  00076	e9 a7 00 00 00	 jmp	 $LN1@unicode_co
$LN15@unicode_co:

; 4667 :         case STORE_FAST:
; 4668 :         {
; 4669 :             int oparg = PEEKARG();

  0007b	41 0f b6 49 02	 movzx	 ecx, BYTE PTR [r9+2]
  00080	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00085	c1 e1 08	 shl	 ecx, 8
  00088	03 c1		 add	 eax, ecx

; 4670 :             PyObject **fastlocals = f->f_localsplus;
; 4671 :             if (GETLOCAL(oparg) == v)

  0008a	48 98		 cdqe
  0008c	49 8b 8c c0 d0
	01 00 00	 mov	 rcx, QWORD PTR [r8+rax*8+464]
  00094	48 3b cb	 cmp	 rcx, rbx
  00097	0f 85 85 00 00
	00		 jne	 $LN1@unicode_co

; 4672 :                 SETLOCAL(oparg, NULL);

  0009d	49 c7 84 c0 d0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR [r8+rax*8+464], 0
  000a9	48 85 c9	 test	 rcx, rcx
  000ac	74 74		 je	 SHORT $LN1@unicode_co
  000ae	e8 00 00 00 00	 call	 _Py_DecRef

; 4673 :             break;

  000b3	eb 6d		 jmp	 SHORT $LN1@unicode_co
$LN4@unicode_co:

; 4683 :         }
; 4684 :         case STORE_NAME:
; 4685 :         {
; 4686 :             PyObject *names = f->f_code->co_names;

  000b5	49 8b 40 78	 mov	 rax, QWORD PTR [r8+120]

; 4687 :             PyObject *name = GETITEM(names, PEEKARG());

  000b9	41 0f b6 51 02	 movzx	 edx, BYTE PTR [r9+2]
  000be	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  000c3	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  000ca	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  000cf	c1 e2 08	 shl	 edx, 8
  000d2	03 d0		 add	 edx, eax
  000d4	48 63 d2	 movsxd	 rdx, edx
  000d7	e8 00 00 00 00	 call	 PyTuple_GetItem

; 4688 :             PyObject *locals = f->f_locals;

  000dc	48 8b bf 90 00
	00 00		 mov	 rdi, QWORD PTR [rdi+144]
  000e3	48 8b f0	 mov	 rsi, rax

; 4689 :             if (PyDict_CheckExact(locals) &&
; 4690 :                 PyDict_GetItem(locals, name) == v) {

  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  000ed	48 39 47 58	 cmp	 QWORD PTR [rdi+88], rax
  000f1	74 06		 je	 SHORT $LN2@unicode_co
  000f3	48 39 47 38	 cmp	 QWORD PTR [rdi+56], rax
  000f7	75 24		 jne	 SHORT $LN21@unicode_co
$LN2@unicode_co:
  000f9	48 8b d6	 mov	 rdx, rsi
  000fc	48 8b cf	 mov	 rcx, rdi
  000ff	e8 00 00 00 00	 call	 PyDict_GetItem
  00104	48 3b c3	 cmp	 rax, rbx
  00107	75 14		 jne	 SHORT $LN21@unicode_co

; 4691 :                 if (PyDict_DelItem(locals, name) != 0) {

  00109	48 8b d6	 mov	 rdx, rsi
  0010c	48 8b cf	 mov	 rcx, rdi
  0010f	e8 00 00 00 00	 call	 PyDict_DelItem
  00114	85 c0		 test	 eax, eax
  00116	74 05		 je	 SHORT $LN21@unicode_co

; 4692 :                     PyErr_Clear();

  00118	e8 00 00 00 00	 call	 PyErr_Clear
$LN21@unicode_co:
  0011d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
$LN1@unicode_co:

; 4693 :                 }
; 4694 :             }
; 4695 :             break;
; 4696 :         }
; 4697 :         }
; 4698 :     }
; 4699 :     res = v;
; 4700 :     PyUnicode_Append(&res, w);

  00122	48 8d 4c 24 30	 lea	 rcx, QWORD PTR res$[rsp]
  00127	48 8b d5	 mov	 rdx, rbp
  0012a	48 89 5c 24 30	 mov	 QWORD PTR res$[rsp], rbx
  0012f	e8 00 00 00 00	 call	 PyUnicode_Append

; 4701 :     return res;

  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR res$[rsp]

; 4702 : }

  00139	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0013e	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00143	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00147	5f		 pop	 rdi
  00148	c3		 ret	 0
unicode_concatenate ENDP
_TEXT	ENDS
END
