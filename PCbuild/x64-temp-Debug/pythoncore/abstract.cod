; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@	; `string'
PUBLIC	??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@	; `string'
PUBLIC	??_C@_09LFGACEKG@__class__?$AA@			; `string'
PUBLIC	??_C@_09LJKDIEEK@__bases__?$AA@			; `string'
PUBLIC	??_C@_06GEKOPAHD@values?$AA@			; `string'
PUBLIC	??_C@_05CFHBDDLG@items?$AA@			; `string'
PUBLIC	??_C@_04IEPFDAGF@keys?$AA@			; `string'
PUBLIC	??_C@_09KENBLPCG@__trunc__?$AA@			; `string'
PUBLIC	??_C@_0L@MEMCGMKL@__format__?$AA@		; `string'
PUBLIC	??_C@_0BA@BJLPBKGK@__length_hint__?$AA@		; `string'
;	COMDAT ??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@
CONST	SEGMENT
??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@ DB '__subclasscheck__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@
CONST	SEGMENT
??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@ DB '__instancecheck__', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LFGACEKG@__class__?$AA@
CONST	SEGMENT
??_C@_09LFGACEKG@__class__?$AA@ DB '__class__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LJKDIEEK@__bases__?$AA@
CONST	SEGMENT
??_C@_09LJKDIEEK@__bases__?$AA@ DB '__bases__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06GEKOPAHD@values?$AA@
CONST	SEGMENT
??_C@_06GEKOPAHD@values?$AA@ DB 'values', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFHBDDLG@items?$AA@
CONST	SEGMENT
??_C@_05CFHBDDLG@items?$AA@ DB 'items', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IEPFDAGF@keys?$AA@
CONST	SEGMENT
??_C@_04IEPFDAGF@keys?$AA@ DB 'keys', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KENBLPCG@__trunc__?$AA@
CONST	SEGMENT
??_C@_09KENBLPCG@__trunc__?$AA@ DB '__trunc__', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MEMCGMKL@__format__?$AA@
CONST	SEGMENT
??_C@_0L@MEMCGMKL@__format__?$AA@ DB '__format__', 00H	; `string'
CONST	ENDS
_TLS	SEGMENT
?PyId___subclasscheck__@?1??PyObject_IsSubclass@@9@9 DQ 0000000000000000H ; `PyObject_IsSubclass'::`2'::PyId___subclasscheck__
	DQ	FLAT:??_C@_0BC@NFPPCOGG@__subclasscheck__?$AA@
	DQ	0000000000000000H
?PyId___instancecheck__@?1??PyObject_IsInstance@@9@9 DQ 0000000000000000H ; `PyObject_IsInstance'::`2'::PyId___instancecheck__
	DQ	FLAT:??_C@_0BC@JKBHKBMG@__instancecheck__?$AA@
	DQ	0000000000000000H
?PyId___class__@?1??recursive_isinstance@@9@9 DQ 0000000000000000H ; `recursive_isinstance'::`2'::PyId___class__
	DQ	FLAT:??_C@_09LFGACEKG@__class__?$AA@
	DQ	0000000000000000H
?PyId___bases__@?1??abstract_get_bases@@9@9 DQ 0000000000000000H ; `abstract_get_bases'::`2'::PyId___bases__
	DQ	FLAT:??_C@_09LJKDIEEK@__bases__?$AA@
	DQ	0000000000000000H
?PyId_values@?1??PyMapping_Values@@9@9 DQ 0000000000000000H ; `PyMapping_Values'::`2'::PyId_values
	DQ	FLAT:??_C@_06GEKOPAHD@values?$AA@
	DQ	0000000000000000H
?PyId_items@?1??PyMapping_Items@@9@9 DQ 0000000000000000H ; `PyMapping_Items'::`2'::PyId_items
	DQ	FLAT:??_C@_05CFHBDDLG@items?$AA@
	DQ	0000000000000000H
?PyId_keys@?1??PyMapping_Keys@@9@9 DQ 0000000000000000H	; `PyMapping_Keys'::`2'::PyId_keys
	DQ	FLAT:??_C@_04IEPFDAGF@keys?$AA@
	DQ	0000000000000000H
?PyId___trunc__@?1??PyNumber_Long@@9@9 DQ 0000000000000000H ; `PyNumber_Long'::`2'::PyId___trunc__
	DQ	FLAT:??_C@_09KENBLPCG@__trunc__?$AA@
	DQ	0000000000000000H
?PyId___format__@?1??PyObject_Format@@9@9 DQ 0000000000000000H ; `PyObject_Format'::`2'::PyId___format__
	DQ	FLAT:??_C@_0L@MEMCGMKL@__format__?$AA@
	DQ	0000000000000000H
?PyId___length_hint__@?1??_PyObject_LengthHint@@9@9 DQ 0000000000000000H ; `_PyObject_LengthHint'::`2'::PyId___length_hint__
	DQ	FLAT:??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
	DQ	0000000000000000H
_TLS	ENDS
;	COMDAT ??_C@_0BA@BJLPBKGK@__length_hint__?$AA@
CONST	SEGMENT
??_C@_0BA@BJLPBKGK@__length_hint__?$AA@ DB '__length_hint__', 00H ; `string'
CONST	ENDS
PUBLIC	_Py_IncRef
PUBLIC	PyObject_Type
;	COMDAT pdata
; File c:\src\pyparallel\objects\abstract.c
pdata	SEGMENT
$pdata$PyObject_Type DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$PyObject_Type
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Type DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_Type
_TEXT	SEGMENT
v$ = 32
o$ = 64
PyObject_Type PROC					; COMDAT

; 32   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 33   :     PyObject *v;
; 34   : 
; 35   :     if (o == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN1@PyObject_T

; 36   :         return null_error();

  00011	e8 00 00 00 00	 call	 null_error
  00016	eb 1d		 jmp	 SHORT $LN2@PyObject_T
$LN1@PyObject_T:

; 37   :     v = (PyObject *)o->ob_type;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 38   :     Py_INCREF(v);

  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0002b	e8 00 00 00 00	 call	 _Py_IncRef

; 39   :     return v;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
$LN2@PyObject_T:

; 40   : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
PyObject_Type ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@DBBCKODM@null?5argument?5to?5internal?5routin@ ; `string'
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_SystemError:QWORD
EXTRN	PyErr_Occurred:PROC
;	COMDAT pdata
; File c:\src\pyparallel\objects\abstract.c
pdata	SEGMENT
$pdata$null_error DD imagerel null_error
	DD	imagerel null_error+40
	DD	imagerel $unwind$null_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$null_error DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT ??_C@_0CC@DBBCKODM@null?5argument?5to?5internal?5routin@
CONST	SEGMENT
??_C@_0CC@DBBCKODM@null?5argument?5to?5internal?5routin@ DB 'null argumen'
	DB	't to internal routine', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT null_error
_TEXT	SEGMENT
null_error PROC						; COMDAT

; 21   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 22   :     if (!PyErr_Occurred())

  00004	e8 00 00 00 00	 call	 PyErr_Occurred
  00009	48 85 c0	 test	 rax, rax
  0000c	75 13		 jne	 SHORT $LN1@null_error

; 23   :         PyErr_SetString(PyExc_SystemError,
; 24   :                         "null argument to internal routine");

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@DBBCKODM@null?5argument?5to?5internal?5routin@
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  0001c	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@null_error:

; 25   :     return NULL;

  00021	33 c0		 xor	 eax, eax

; 26   : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
null_error ENDP
_TEXT	ENDS
PUBLIC	PyMapping_Size
PUBLIC	PyObject_Size
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Size DD imagerel $LN5
	DD	imagerel $LN5+100
	DD	imagerel $unwind$PyObject_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Size DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_Size
_TEXT	SEGMENT
m$ = 32
o$ = 64
PyObject_Size PROC					; COMDAT

; 44   : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 45   :     PySequenceMethods *m;
; 46   : 
; 47   :     if (o == NULL) {

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  0000f	75 0e		 jne	 SHORT $LN2@PyObject_S

; 48   :         null_error();

  00011	e8 00 00 00 00	 call	 null_error

; 49   :         return -1;

  00016	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0001d	eb 40		 jmp	 SHORT $LN3@PyObject_S
$LN2@PyObject_S:

; 50   :     }
; 51   : 
; 52   :     m = o->ob_type->tp_as_sequence;

  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00024	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00028	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0002f	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 53   :     if (m && m->sq_length)

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  0003a	74 19		 je	 SHORT $LN1@PyObject_S
  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00041	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00045	74 0e		 je	 SHORT $LN1@PyObject_S

; 54   :         return m->sq_length(o);

  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00051	ff 10		 call	 QWORD PTR [rax]
  00053	eb 0a		 jmp	 SHORT $LN3@PyObject_S
$LN1@PyObject_S:

; 55   : 
; 56   :     return PyMapping_Size(o);

  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  0005a	e8 00 00 00 00	 call	 PyMapping_Size
$LN3@PyObject_S:

; 57   : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
PyObject_Size ENDP
_TEXT	ENDS
PUBLIC	PyObject_Length
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Length DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$PyObject_Length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Length DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_Length
_TEXT	SEGMENT
o$ = 48
PyObject_Length PROC					; COMDAT

; 62   : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 63   :     return PyObject_Size(o);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR o$[rsp]
  0000e	e8 00 00 00 00	 call	 PyObject_Size

; 64   : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
PyObject_Length ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
PUBLIC	PyObject_CallFunctionObjArgs
PUBLIC	_PyObject_LengthHint
EXTRN	PyLong_AsSsize_t:PROC
EXTRN	_PyObject_LookupSpecial:PROC
EXTRN	PyErr_Clear:PROC
EXTRN	PyErr_ExceptionMatches:PROC
EXTRN	PyExc_TypeError:QWORD
EXTRN	_tls_index:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_LengthHint DD imagerel $LN13
	DD	imagerel $LN13+329
	DD	imagerel $unwind$_PyObject_LengthHint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_LengthHint DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_LengthHint
_TEXT	SEGMENT
hintmeth$ = 32
ro$ = 40
rv$ = 48
tv130 = 56
o$ = 80
defaultvalue$ = 88
_PyObject_LengthHint PROC				; COMDAT

; 76   : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 77   :     _Py_IDENTIFIER(__length_hint__);
; 78   :     PyObject *ro, *hintmeth;
; 79   :     Py_ssize_t rv;
; 80   : 
; 81   :     /* try o.__len__() */
; 82   :     rv = PyObject_Size(o);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00013	e8 00 00 00 00	 call	 PyObject_Size
  00018	48 89 44 24 30	 mov	 QWORD PTR rv$[rsp], rax

; 83   :     if (rv >= 0)

  0001d	48 83 7c 24 30
	00		 cmp	 QWORD PTR rv$[rsp], 0
  00023	7c 0a		 jl	 SHORT $LN8@PyObject_L

; 84   :         return rv;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR rv$[rsp]
  0002a	e9 15 01 00 00	 jmp	 $LN9@PyObject_L
$LN8@PyObject_L:

; 85   :     if (PyErr_Occurred()) {

  0002f	e8 00 00 00 00	 call	 PyErr_Occurred
  00034	48 85 c0	 test	 rax, rax
  00037	74 21		 je	 SHORT $LN7@PyObject_L

; 86   :         if (!PyErr_ExceptionMatches(PyExc_TypeError))

  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00040	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00045	85 c0		 test	 eax, eax
  00047	75 0c		 jne	 SHORT $LN6@PyObject_L

; 87   :             return -1;

  00049	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00050	e9 ef 00 00 00	 jmp	 $LN9@PyObject_L
$LN6@PyObject_L:

; 88   :         PyErr_Clear();

  00055	e8 00 00 00 00	 call	 PyErr_Clear
$LN7@PyObject_L:

; 89   :     }
; 90   : 
; 91   :     /* try o.__length_hint__() */
; 92   :     hintmeth = _PyObject_LookupSpecial(o, &PyId___length_hint__);

  0005a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___length_hint__@?1??_PyObject_LengthHint@@9@9
  0005f	8b c0		 mov	 eax, eax
  00061	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00067	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00070	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00074	48 8b d0	 mov	 rdx, rax
  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  0007c	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00081	48 89 44 24 20	 mov	 QWORD PTR hintmeth$[rsp], rax

; 93   :     if (hintmeth == NULL) {

  00086	48 83 7c 24 20
	00		 cmp	 QWORD PTR hintmeth$[rsp], 0
  0008c	75 22		 jne	 SHORT $LN5@PyObject_L

; 94   :         if (PyErr_Occurred())

  0008e	e8 00 00 00 00	 call	 PyErr_Occurred
  00093	48 85 c0	 test	 rax, rax
  00096	74 0e		 je	 SHORT $LN4@PyObject_L

; 95   :             return -1;

  00098	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0009f	e9 a0 00 00 00	 jmp	 $LN9@PyObject_L

; 96   :         else

  000a4	eb 0a		 jmp	 SHORT $LN3@PyObject_L
$LN4@PyObject_L:

; 97   :             return defaultvalue;

  000a6	48 8b 44 24 58	 mov	 rax, QWORD PTR defaultvalue$[rsp]
  000ab	e9 94 00 00 00	 jmp	 $LN9@PyObject_L
$LN3@PyObject_L:
$LN5@PyObject_L:

; 98   :     }
; 99   :     ro = PyObject_CallFunctionObjArgs(hintmeth, NULL);

  000b0	33 d2		 xor	 edx, edx
  000b2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hintmeth$[rsp]
  000b7	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  000bc	48 89 44 24 28	 mov	 QWORD PTR ro$[rsp], rax

; 100  :     Py_DECREF(hintmeth);

  000c1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR hintmeth$[rsp]
  000c6	e8 00 00 00 00	 call	 _Py_DecRef

; 101  :     if (ro == NULL) {

  000cb	48 83 7c 24 28
	00		 cmp	 QWORD PTR ro$[rsp], 0
  000d1	75 25		 jne	 SHORT $LN2@PyObject_L

; 102  :         if (!PyErr_ExceptionMatches(PyExc_TypeError))

  000d3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000da	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000df	85 c0		 test	 eax, eax
  000e1	75 09		 jne	 SHORT $LN1@PyObject_L

; 103  :             return -1;

  000e3	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000ea	eb 58		 jmp	 SHORT $LN9@PyObject_L
$LN1@PyObject_L:

; 104  :         PyErr_Clear();

  000ec	e8 00 00 00 00	 call	 PyErr_Clear

; 105  :         return defaultvalue;

  000f1	48 8b 44 24 58	 mov	 rax, QWORD PTR defaultvalue$[rsp]
  000f6	eb 4c		 jmp	 SHORT $LN9@PyObject_L
$LN2@PyObject_L:

; 106  :     }
; 107  :     rv = PyLong_Check(ro) ? PyLong_AsSsize_t(ro) : defaultvalue;

  000f8	48 8b 44 24 28	 mov	 rax, QWORD PTR ro$[rsp]
  000fd	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00101	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00107	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0010c	85 c0		 test	 eax, eax
  0010e	74 11		 je	 SHORT $LN11@PyObject_L
  00110	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ro$[rsp]
  00115	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0011a	48 89 44 24 38	 mov	 QWORD PTR tv130[rsp], rax
  0011f	eb 0a		 jmp	 SHORT $LN12@PyObject_L
$LN11@PyObject_L:
  00121	48 8b 44 24 58	 mov	 rax, QWORD PTR defaultvalue$[rsp]
  00126	48 89 44 24 38	 mov	 QWORD PTR tv130[rsp], rax
$LN12@PyObject_L:
  0012b	48 8b 44 24 38	 mov	 rax, QWORD PTR tv130[rsp]
  00130	48 89 44 24 30	 mov	 QWORD PTR rv$[rsp], rax

; 108  :     Py_DECREF(ro);

  00135	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ro$[rsp]
  0013a	e8 00 00 00 00	 call	 _Py_DecRef

; 109  :     return rv;

  0013f	48 8b 44 24 30	 mov	 rax, QWORD PTR rv$[rsp]
$LN9@PyObject_L:

; 110  : }

  00144	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00148	c3		 ret	 0
_PyObject_LengthHint ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@PPLGHAMF@?8?$CF?4200s?8?5object?5is?5not?5subscript@ ; `string'
PUBLIC	??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@ ; `string'
PUBLIC	PySequence_GetItem
PUBLIC	PyNumber_AsSsize_t
PUBLIC	PyObject_GetItem
EXTRN	PyExc_IndexError:QWORD
;	COMDAT pdata
; File c:\src\pyparallel\objects\abstract.c
pdata	SEGMENT
$pdata$PyObject_GetItem DD imagerel $LN11
	DD	imagerel $LN11+299
	DD	imagerel $unwind$PyObject_GetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_GetItem DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CF@PPLGHAMF@?8?$CF?4200s?8?5object?5is?5not?5subscript@
CONST	SEGMENT
??_C@_0CF@PPLGHAMF@?8?$CF?4200s?8?5object?5is?5not?5subscript@ DB '''%.20'
	DB	'0s'' object is not subscriptable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@
CONST	SEGMENT
??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@ DB 'sequence i'
	DB	'ndex must be integer, not ''%.200s''', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_GetItem
_TEXT	SEGMENT
m$ = 32
key_value$20398 = 40
o$ = 64
key$ = 72
PyObject_GetItem PROC					; COMDAT

; 114  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 115  :     PyMappingMethods *m;
; 116  : 
; 117  :     if (o == NULL || key == NULL)

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  00014	74 08		 je	 SHORT $LN7@PyObject_G
  00016	48 83 7c 24 48
	00		 cmp	 QWORD PTR key$[rsp], 0
  0001c	75 0a		 jne	 SHORT $LN8@PyObject_G
$LN7@PyObject_G:

; 118  :         return null_error();

  0001e	e8 00 00 00 00	 call	 null_error
  00023	e9 fe 00 00 00	 jmp	 $LN9@PyObject_G
$LN8@PyObject_G:

; 119  : 
; 120  :     m = o->ob_type->tp_as_mapping;

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  0002d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00031	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00038	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 121  :     if (m && m->mp_subscript)

  0003d	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00043	74 23		 je	 SHORT $LN6@PyObject_G
  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0004a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0004f	74 17		 je	 SHORT $LN6@PyObject_G

; 122  :         return m->mp_subscript(o, key);

  00051	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00060	ff 50 08	 call	 QWORD PTR [rax+8]
  00063	e9 be 00 00 00	 jmp	 $LN9@PyObject_G
$LN6@PyObject_G:

; 123  : 
; 124  :     if (o->ob_type->tp_as_sequence) {

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  0006d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00071	48 83 b8 c0 00
	00 00 00	 cmp	 QWORD PTR [rax+192], 0
  00079	0f 84 96 00 00
	00		 je	 $LN5@PyObject_G

; 125  :         if (PyIndex_Check(key)) {

  0007f	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  00084	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00088	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00090	74 59		 je	 SHORT $LN4@PyObject_G
  00092	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  00097	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009b	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  000a2	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  000aa	74 3f		 je	 SHORT $LN4@PyObject_G

; 126  :             Py_ssize_t key_value;
; 127  :             key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);

  000ac	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  000b3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  000b8	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  000bd	48 89 44 24 28	 mov	 QWORD PTR key_value$20398[rsp], rax

; 128  :             if (key_value == -1 && PyErr_Occurred())

  000c2	48 83 7c 24 28
	ff		 cmp	 QWORD PTR key_value$20398[rsp], -1
  000c8	75 0e		 jne	 SHORT $LN3@PyObject_G
  000ca	e8 00 00 00 00	 call	 PyErr_Occurred
  000cf	48 85 c0	 test	 rax, rax
  000d2	74 04		 je	 SHORT $LN3@PyObject_G

; 129  :                 return NULL;

  000d4	33 c0		 xor	 eax, eax
  000d6	eb 4e		 jmp	 SHORT $LN9@PyObject_G
$LN3@PyObject_G:

; 130  :             return PySequence_GetItem(o, key_value);

  000d8	48 8b 54 24 28	 mov	 rdx, QWORD PTR key_value$20398[rsp]
  000dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  000e2	e8 00 00 00 00	 call	 PySequence_GetItem
  000e7	eb 3d		 jmp	 SHORT $LN9@PyObject_G
  000e9	eb 2a		 jmp	 SHORT $LN2@PyObject_G
$LN4@PyObject_G:

; 131  :         }
; 132  :         else if (o->ob_type->tp_as_sequence->sq_item)

  000eb	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  000f0	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f4	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000fb	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00100	74 13		 je	 SHORT $LN1@PyObject_G

; 133  :             return type_error("sequence index must "
; 134  :                               "be integer, not '%.200s'", key);

  00102	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@
  0010e	e8 00 00 00 00	 call	 type_error
  00113	eb 11		 jmp	 SHORT $LN9@PyObject_G
$LN1@PyObject_G:
$LN2@PyObject_G:
$LN5@PyObject_G:

; 135  :     }
; 136  : 
; 137  :     return type_error("'%.200s' object is not subscriptable", o);

  00115	48 8b 54 24 40	 mov	 rdx, QWORD PTR o$[rsp]
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@PPLGHAMF@?8?$CF?4200s?8?5object?5is?5not?5subscript@
  00121	e8 00 00 00 00	 call	 type_error
$LN9@PyObject_G:

; 138  : }

  00126	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012a	c3		 ret	 0
PyObject_GetItem ENDP
_TEXT	ENDS
EXTRN	PyErr_Format:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$type_error DD imagerel type_error
	DD	imagerel type_error+51
	DD	imagerel $unwind$type_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$type_error DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT type_error
_TEXT	SEGMENT
msg$ = 48
obj$ = 56
type_error PROC						; COMDAT

; 14   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 15   :     PyErr_Format(PyExc_TypeError, msg, obj->ob_type->tp_name);

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR obj$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0001b	48 8b 54 24 30	 mov	 rdx, QWORD PTR msg$[rsp]
  00020	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00027	e8 00 00 00 00	 call	 PyErr_Format

; 16   :     return NULL;

  0002c	33 c0		 xor	 eax, eax

; 17   : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
type_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@PKENFCMJ@?8?$CF?4200s?8?5object?5does?5not?5support@ ; `string'
PUBLIC	PySequence_SetItem
PUBLIC	PyObject_SetItem
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_SetItem DD imagerel $LN11
	DD	imagerel $LN11+340
	DD	imagerel $unwind$PyObject_SetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_SetItem DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0DB@PKENFCMJ@?8?$CF?4200s?8?5object?5does?5not?5support@
CONST	SEGMENT
??_C@_0DB@PKENFCMJ@?8?$CF?4200s?8?5object?5does?5not?5support@ DB '''%.20'
	DB	'0s'' object does not support item assignment', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_SetItem
_TEXT	SEGMENT
m$ = 32
key_value$20423 = 40
o$ = 64
key$ = 72
value$ = 80
PyObject_SetItem PROC					; COMDAT

; 142  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 143  :     PyMappingMethods *m;
; 144  : 
; 145  :     if (o == NULL || key == NULL || value == NULL) {

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  00019	74 10		 je	 SHORT $LN7@PyObject_S@2
  0001b	48 83 7c 24 48
	00		 cmp	 QWORD PTR key$[rsp], 0
  00021	74 08		 je	 SHORT $LN7@PyObject_S@2
  00023	48 83 7c 24 50
	00		 cmp	 QWORD PTR value$[rsp], 0
  00029	75 0f		 jne	 SHORT $LN8@PyObject_S@2
$LN7@PyObject_S@2:

; 146  :         null_error();

  0002b	e8 00 00 00 00	 call	 null_error

; 147  :         return -1;

  00030	b8 ff ff ff ff	 mov	 eax, -1
  00035	e9 15 01 00 00	 jmp	 $LN9@PyObject_S@2
$LN8@PyObject_S@2:

; 148  :     }
; 149  : 
; 150  :     /*
; 151  :     if (Px_CHECK_PROTECTION(o, key, value))
; 152  :         return -1;
; 153  :     */
; 154  : 
; 155  :     m = o->ob_type->tp_as_mapping;

  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  0003f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00043	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  0004a	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 156  :     if (m && m->mp_ass_subscript)

  0004f	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00055	74 28		 je	 SHORT $LN6@PyObject_S@2
  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0005c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00061	74 1c		 je	 SHORT $LN6@PyObject_S@2

; 157  :         return m->mp_ass_subscript(o, key, value);

  00063	4c 8b 44 24 50	 mov	 r8, QWORD PTR value$[rsp]
  00068	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00077	ff 50 10	 call	 QWORD PTR [rax+16]
  0007a	e9 d0 00 00 00	 jmp	 $LN9@PyObject_S@2
$LN6@PyObject_S@2:

; 158  : 
; 159  :     if (o->ob_type->tp_as_sequence) {

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00084	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00088	48 83 b8 c0 00
	00 00 00	 cmp	 QWORD PTR [rax+192], 0
  00090	0f 84 a3 00 00
	00		 je	 $LN5@PyObject_S@2

; 160  :         if (PyIndex_Check(key)) {

  00096	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0009b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009f	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  000a7	74 61		 je	 SHORT $LN4@PyObject_S@2
  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  000ae	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000b2	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  000b9	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  000c1	74 47		 je	 SHORT $LN4@PyObject_S@2

; 161  :             Py_ssize_t key_value;
; 162  :             key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);

  000c3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  000ca	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  000cf	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  000d4	48 89 44 24 28	 mov	 QWORD PTR key_value$20423[rsp], rax

; 163  :             if (key_value == -1 && PyErr_Occurred())

  000d9	48 83 7c 24 28
	ff		 cmp	 QWORD PTR key_value$20423[rsp], -1
  000df	75 11		 jne	 SHORT $LN3@PyObject_S@2
  000e1	e8 00 00 00 00	 call	 PyErr_Occurred
  000e6	48 85 c0	 test	 rax, rax
  000e9	74 07		 je	 SHORT $LN3@PyObject_S@2

; 164  :                 return -1;

  000eb	b8 ff ff ff ff	 mov	 eax, -1
  000f0	eb 5d		 jmp	 SHORT $LN9@PyObject_S@2
$LN3@PyObject_S@2:

; 165  :             return PySequence_SetItem(o, key_value, value);

  000f2	4c 8b 44 24 50	 mov	 r8, QWORD PTR value$[rsp]
  000f7	48 8b 54 24 28	 mov	 rdx, QWORD PTR key_value$20423[rsp]
  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00101	e8 00 00 00 00	 call	 PySequence_SetItem
  00106	eb 47		 jmp	 SHORT $LN9@PyObject_S@2
  00108	eb 2f		 jmp	 SHORT $LN2@PyObject_S@2
$LN4@PyObject_S@2:

; 166  :         }
; 167  :         else if (o->ob_type->tp_as_sequence->sq_ass_item) {

  0010a	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  0010f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00113	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0011a	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0011f	74 18		 je	 SHORT $LN1@PyObject_S@2

; 168  :             type_error("sequence index must be "
; 169  :                        "integer, not '%.200s'", key);

  00121	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@
  0012d	e8 00 00 00 00	 call	 type_error

; 170  :             return -1;

  00132	b8 ff ff ff ff	 mov	 eax, -1
  00137	eb 16		 jmp	 SHORT $LN9@PyObject_S@2
$LN1@PyObject_S@2:
$LN2@PyObject_S@2:
$LN5@PyObject_S@2:

; 171  :         }
; 172  :     }
; 173  : 
; 174  :     type_error("'%.200s' object does not support item assignment", o);

  00139	48 8b 54 24 40	 mov	 rdx, QWORD PTR o$[rsp]
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@PKENFCMJ@?8?$CF?4200s?8?5object?5does?5not?5support@
  00145	e8 00 00 00 00	 call	 type_error

; 175  :     return -1;

  0014a	b8 ff ff ff ff	 mov	 eax, -1
$LN9@PyObject_S@2:

; 176  : }

  0014f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00153	c3		 ret	 0
PyObject_SetItem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@DLMILHPD@?8?$CF?4200s?8?5object?5does?5not?5support@ ; `string'
PUBLIC	PySequence_DelItem
PUBLIC	PyObject_DelItem
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_DelItem DD imagerel $LN11
	DD	imagerel $LN11+320
	DD	imagerel $unwind$PyObject_DelItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_DelItem DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CP@DLMILHPD@?8?$CF?4200s?8?5object?5does?5not?5support@
CONST	SEGMENT
??_C@_0CP@DLMILHPD@?8?$CF?4200s?8?5object?5does?5not?5support@ DB '''%.20'
	DB	'0s'' object does not support item deletion', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_DelItem
_TEXT	SEGMENT
m$ = 32
key_value$20445 = 40
o$ = 64
key$ = 72
PyObject_DelItem PROC					; COMDAT

; 180  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 181  :     PyMappingMethods *m;
; 182  : 
; 183  :     if (o == NULL || key == NULL) {

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  00014	74 08		 je	 SHORT $LN7@PyObject_D
  00016	48 83 7c 24 48
	00		 cmp	 QWORD PTR key$[rsp], 0
  0001c	75 0f		 jne	 SHORT $LN8@PyObject_D
$LN7@PyObject_D:

; 184  :         null_error();

  0001e	e8 00 00 00 00	 call	 null_error

; 185  :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 0e 01 00 00	 jmp	 $LN9@PyObject_D
$LN8@PyObject_D:

; 186  :     }
; 187  : 
; 188  :     /*
; 189  :     if (Px_CHECK_PROTECTION(o, NULL, NULL))
; 190  :         return -1;
; 191  :     */
; 192  : 
; 193  :     m = o->ob_type->tp_as_mapping;

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00032	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00036	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  0003d	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 194  :     if (m && m->mp_ass_subscript)

  00042	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00048	74 26		 je	 SHORT $LN6@PyObject_D
  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0004f	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00054	74 1a		 je	 SHORT $LN6@PyObject_D

; 195  :         return m->mp_ass_subscript(o, key, (PyObject*)NULL);

  00056	45 33 c0	 xor	 r8d, r8d
  00059	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00068	ff 50 10	 call	 QWORD PTR [rax+16]
  0006b	e9 cb 00 00 00	 jmp	 $LN9@PyObject_D
$LN6@PyObject_D:

; 196  : 
; 197  :     if (o->ob_type->tp_as_sequence) {

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00075	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00079	48 83 b8 c0 00
	00 00 00	 cmp	 QWORD PTR [rax+192], 0
  00081	0f 84 9e 00 00
	00		 je	 $LN5@PyObject_D

; 198  :         if (PyIndex_Check(key)) {

  00087	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0008c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00090	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00098	74 5c		 je	 SHORT $LN4@PyObject_D
  0009a	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0009f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000a3	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  000aa	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  000b2	74 42		 je	 SHORT $LN4@PyObject_D

; 199  :             Py_ssize_t key_value;
; 200  :             key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);

  000b4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_IndexError
  000bb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  000c0	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  000c5	48 89 44 24 28	 mov	 QWORD PTR key_value$20445[rsp], rax

; 201  :             if (key_value == -1 && PyErr_Occurred())

  000ca	48 83 7c 24 28
	ff		 cmp	 QWORD PTR key_value$20445[rsp], -1
  000d0	75 11		 jne	 SHORT $LN3@PyObject_D
  000d2	e8 00 00 00 00	 call	 PyErr_Occurred
  000d7	48 85 c0	 test	 rax, rax
  000da	74 07		 je	 SHORT $LN3@PyObject_D

; 202  :                 return -1;

  000dc	b8 ff ff ff ff	 mov	 eax, -1
  000e1	eb 58		 jmp	 SHORT $LN9@PyObject_D
$LN3@PyObject_D:

; 203  :             return PySequence_DelItem(o, key_value);

  000e3	48 8b 54 24 28	 mov	 rdx, QWORD PTR key_value$20445[rsp]
  000e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  000ed	e8 00 00 00 00	 call	 PySequence_DelItem
  000f2	eb 47		 jmp	 SHORT $LN9@PyObject_D
  000f4	eb 2f		 jmp	 SHORT $LN2@PyObject_D
$LN4@PyObject_D:

; 204  :         }
; 205  :         else if (o->ob_type->tp_as_sequence->sq_ass_item) {

  000f6	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  000fb	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ff	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00106	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0010b	74 18		 je	 SHORT $LN1@PyObject_D

; 206  :             type_error("sequence index must be "
; 207  :                        "integer, not '%.200s'", key);

  0010d	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@HGAAPFBI@sequence?5index?5must?5be?5integer?0?5@
  00119	e8 00 00 00 00	 call	 type_error

; 208  :             return -1;

  0011e	b8 ff ff ff ff	 mov	 eax, -1
  00123	eb 16		 jmp	 SHORT $LN9@PyObject_D
$LN1@PyObject_D:
$LN2@PyObject_D:
$LN5@PyObject_D:

; 209  :         }
; 210  :     }
; 211  : 
; 212  :     type_error("'%.200s' object does not support item deletion", o);

  00125	48 8b 54 24 40	 mov	 rdx, QWORD PTR o$[rsp]
  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@DLMILHPD@?8?$CF?4200s?8?5object?5does?5not?5support@
  00131	e8 00 00 00 00	 call	 type_error

; 213  :     return -1;

  00136	b8 ff ff ff ff	 mov	 eax, -1
$LN9@PyObject_D:

; 214  : }

  0013b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0013f	c3		 ret	 0
PyObject_DelItem ENDP
_TEXT	ENDS
PUBLIC	PyObject_DelItemString
EXTRN	PyUnicode_FromString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_DelItemString DD imagerel $LN6
	DD	imagerel $LN6+110
	DD	imagerel $unwind$PyObject_DelItemString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_DelItemString DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_DelItemString
_TEXT	SEGMENT
ret$ = 32
okey$ = 40
o$ = 64
key$ = 72
PyObject_DelItemString PROC				; COMDAT

; 218  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 219  :     PyObject *okey;
; 220  :     int ret;
; 221  : 
; 222  :     if (o == NULL || key == NULL) {

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  00014	74 08		 je	 SHORT $LN2@PyObject_D@2
  00016	48 83 7c 24 48
	00		 cmp	 QWORD PTR key$[rsp], 0
  0001c	75 0c		 jne	 SHORT $LN3@PyObject_D@2
$LN2@PyObject_D@2:

; 223  :         null_error();

  0001e	e8 00 00 00 00	 call	 null_error

; 224  :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	eb 3f		 jmp	 SHORT $LN4@PyObject_D@2
$LN3@PyObject_D@2:

; 225  :     }
; 226  :     okey = PyUnicode_FromString(key);

  0002a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  0002f	e8 00 00 00 00	 call	 PyUnicode_FromString
  00034	48 89 44 24 28	 mov	 QWORD PTR okey$[rsp], rax

; 227  :     if (okey == NULL)

  00039	48 83 7c 24 28
	00		 cmp	 QWORD PTR okey$[rsp], 0
  0003f	75 07		 jne	 SHORT $LN1@PyObject_D@2

; 228  :         return -1;

  00041	b8 ff ff ff ff	 mov	 eax, -1
  00046	eb 21		 jmp	 SHORT $LN4@PyObject_D@2
$LN1@PyObject_D@2:

; 229  :     ret = PyObject_DelItem(o, okey);

  00048	48 8b 54 24 28	 mov	 rdx, QWORD PTR okey$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00052	e8 00 00 00 00	 call	 PyObject_DelItem
  00057	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 230  :     Py_DECREF(okey);

  0005b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR okey$[rsp]
  00060	e8 00 00 00 00	 call	 _Py_DecRef

; 231  :     return ret;

  00065	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
$LN4@PyObject_D@2:

; 232  : }

  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	c3		 ret	 0
PyObject_DelItemString ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DG@CCIPNKOK@expected?5bytes?0?5bytearray?5or?5buf@ ; `string'
PUBLIC	PyObject_AsCharBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_AsCharBuffer DD imagerel $LN13
	DD	imagerel $LN13+272
	DD	imagerel $unwind$PyObject_AsCharBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_AsCharBuffer DD 021601H
	DD	0110116H
xdata	ENDS
;	COMDAT ??_C@_0DG@CCIPNKOK@expected?5bytes?0?5bytearray?5or?5buf@
CONST	SEGMENT
??_C@_0DG@CCIPNKOK@expected?5bytes?0?5bytearray?5or?5buf@ DB 'expected by'
	DB	'tes, bytearray or buffer compatible object', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_AsCharBuffer
_TEXT	SEGMENT
view$ = 32
pb$ = 112
obj$ = 144
buffer$ = 152
buffer_len$ = 160
PyObject_AsCharBuffer PROC				; COMDAT

; 241  : {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 242  :     PyBufferProcs *pb;
; 243  :     Py_buffer view;
; 244  : 
; 245  :     if (obj == NULL || buffer == NULL || buffer_len == NULL) {

  00016	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR obj$[rsp], 0
  0001f	74 16		 je	 SHORT $LN9@PyObject_A
  00021	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  0002a	74 0b		 je	 SHORT $LN9@PyObject_A
  0002c	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR buffer_len$[rsp], 0
  00035	75 0f		 jne	 SHORT $LN10@PyObject_A
$LN9@PyObject_A:

; 246  :         null_error();

  00037	e8 00 00 00 00	 call	 null_error

; 247  :         return -1;

  0003c	b8 ff ff ff ff	 mov	 eax, -1
  00041	e9 c2 00 00 00	 jmp	 $LN11@PyObject_A
$LN10@PyObject_A:

; 248  :     }
; 249  : 
; 250  :     pb = obj->ob_type->tp_as_buffer;

  00046	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  0004e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00052	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00059	48 89 44 24 70	 mov	 QWORD PTR pb$[rsp], rax

; 251  :     if (pb == NULL || pb->bf_getbuffer == NULL) {

  0005e	48 83 7c 24 70
	00		 cmp	 QWORD PTR pb$[rsp], 0
  00064	74 0b		 je	 SHORT $LN7@PyObject_A
  00066	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  0006b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006f	75 1a		 jne	 SHORT $LN8@PyObject_A
$LN7@PyObject_A:

; 252  :         PyErr_SetString(PyExc_TypeError,
; 253  :                         "expected bytes, bytearray "
; 254  :                         "or buffer compatible object");

  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DG@CCIPNKOK@expected?5bytes?0?5bytearray?5or?5buf@
  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0007f	e8 00 00 00 00	 call	 PyErr_SetString

; 255  :         return -1;

  00084	b8 ff ff ff ff	 mov	 eax, -1
  00089	eb 7d		 jmp	 SHORT $LN11@PyObject_A
$LN8@PyObject_A:

; 256  :     }
; 257  :     if ((*pb->bf_getbuffer)(obj, &view, PyBUF_SIMPLE)) return -1;

  0008b	45 33 c0	 xor	 r8d, r8d
  0008e	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  00093	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  0009b	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  000a0	ff 10		 call	 QWORD PTR [rax]
  000a2	85 c0		 test	 eax, eax
  000a4	74 07		 je	 SHORT $LN6@PyObject_A
  000a6	b8 ff ff ff ff	 mov	 eax, -1
  000ab	eb 5b		 jmp	 SHORT $LN11@PyObject_A
$LN6@PyObject_A:

; 258  : 
; 259  :     *buffer = view.buf;

  000ad	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  000b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR view$[rsp]
  000ba	48 89 08	 mov	 QWORD PTR [rax], rcx

; 260  :     *buffer_len = view.len;

  000bd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR buffer_len$[rsp]
  000c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp+16]
  000ca	48 89 08	 mov	 QWORD PTR [rax], rcx

; 261  :     if (pb->bf_releasebuffer != NULL)

  000cd	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  000d2	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000d7	74 15		 je	 SHORT $LN5@PyObject_A

; 262  :         (*pb->bf_releasebuffer)(obj, &view);

  000d9	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  000de	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  000e6	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  000eb	ff 50 08	 call	 QWORD PTR [rax+8]
$LN5@PyObject_A:
$LN4@PyObject_A:

; 263  :     Py_XDECREF(view.obj);

  000ee	48 83 7c 24 28
	00		 cmp	 QWORD PTR view$[rsp+8], 0
  000f4	74 0a		 je	 SHORT $LN1@PyObject_A
  000f6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp+8]
  000fb	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyObject_A:
  00100	33 c0		 xor	 eax, eax
  00102	85 c0		 test	 eax, eax
  00104	75 e8		 jne	 SHORT $LN4@PyObject_A

; 264  :     return 0;

  00106	33 c0		 xor	 eax, eax
$LN11@PyObject_A:

; 265  : }

  00108	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0010f	c3		 ret	 0
PyObject_AsCharBuffer ENDP
_TEXT	ENDS
PUBLIC	PyBuffer_Release
PUBLIC	PyObject_CheckReadBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CheckReadBuffer DD imagerel $LN6
	DD	imagerel $LN6+119
	DD	imagerel $unwind$PyObject_CheckReadBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CheckReadBuffer DD 020c01H
	DD	011010cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_CheckReadBuffer
_TEXT	SEGMENT
view$ = 32
pb$ = 112
obj$ = 144
PyObject_CheckReadBuffer PROC				; COMDAT

; 269  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 270  :     PyBufferProcs *pb = obj->ob_type->tp_as_buffer;

  0000c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  00014	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00018	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  0001f	48 89 44 24 70	 mov	 QWORD PTR pb$[rsp], rax

; 271  :     Py_buffer view;
; 272  : 
; 273  :     if (pb == NULL ||
; 274  :         pb->bf_getbuffer == NULL)

  00024	48 83 7c 24 70
	00		 cmp	 QWORD PTR pb$[rsp], 0
  0002a	74 0b		 je	 SHORT $LN2@PyObject_C
  0002c	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  00031	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00035	75 04		 jne	 SHORT $LN3@PyObject_C
$LN2@PyObject_C:

; 275  :         return 0;

  00037	33 c0		 xor	 eax, eax
  00039	eb 34		 jmp	 SHORT $LN4@PyObject_C
$LN3@PyObject_C:

; 276  : 
; 277  :     if ((*pb->bf_getbuffer)(obj, &view, PyBUF_SIMPLE) == -1) {

  0003b	45 33 c0	 xor	 r8d, r8d
  0003e	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  00043	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  0004b	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  00050	ff 10		 call	 QWORD PTR [rax]
  00052	83 f8 ff	 cmp	 eax, -1
  00055	75 09		 jne	 SHORT $LN1@PyObject_C

; 278  :         PyErr_Clear();

  00057	e8 00 00 00 00	 call	 PyErr_Clear

; 279  :         return 0;

  0005c	33 c0		 xor	 eax, eax
  0005e	eb 0f		 jmp	 SHORT $LN4@PyObject_C
$LN1@PyObject_C:

; 280  :     }
; 281  :     PyBuffer_Release(&view);

  00060	48 8d 4c 24 20	 lea	 rcx, QWORD PTR view$[rsp]
  00065	e8 00 00 00 00	 call	 PyBuffer_Release

; 282  :     return 1;

  0006a	b8 01 00 00 00	 mov	 eax, 1
$LN4@PyObject_C:

; 283  : }

  0006f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00076	c3		 ret	 0
PyObject_CheckReadBuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@BHKBJCKA@expected?5an?5object?5with?5a?5buffer@ ; `string'
PUBLIC	PyObject_AsReadBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_AsReadBuffer DD imagerel $LN13
	DD	imagerel $LN13+272
	DD	imagerel $unwind$PyObject_AsReadBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_AsReadBuffer DD 021601H
	DD	0110116H
xdata	ENDS
;	COMDAT ??_C@_0CL@BHKBJCKA@expected?5an?5object?5with?5a?5buffer@
CONST	SEGMENT
??_C@_0CL@BHKBJCKA@expected?5an?5object?5with?5a?5buffer@ DB 'expected an'
	DB	' object with a buffer interface', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_AsReadBuffer
_TEXT	SEGMENT
view$ = 32
pb$ = 112
obj$ = 144
buffer$ = 152
buffer_len$ = 160
PyObject_AsReadBuffer PROC				; COMDAT

; 288  : {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 289  :     PyBufferProcs *pb;
; 290  :     Py_buffer view;
; 291  : 
; 292  :     if (obj == NULL || buffer == NULL || buffer_len == NULL) {

  00016	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR obj$[rsp], 0
  0001f	74 16		 je	 SHORT $LN9@PyObject_A@2
  00021	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  0002a	74 0b		 je	 SHORT $LN9@PyObject_A@2
  0002c	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR buffer_len$[rsp], 0
  00035	75 0f		 jne	 SHORT $LN10@PyObject_A@2
$LN9@PyObject_A@2:

; 293  :         null_error();

  00037	e8 00 00 00 00	 call	 null_error

; 294  :         return -1;

  0003c	b8 ff ff ff ff	 mov	 eax, -1
  00041	e9 c2 00 00 00	 jmp	 $LN11@PyObject_A@2
$LN10@PyObject_A@2:

; 295  :     }
; 296  : 
; 297  :     pb = obj->ob_type->tp_as_buffer;

  00046	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  0004e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00052	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00059	48 89 44 24 70	 mov	 QWORD PTR pb$[rsp], rax

; 298  :     if (pb == NULL ||
; 299  :         pb->bf_getbuffer == NULL) {

  0005e	48 83 7c 24 70
	00		 cmp	 QWORD PTR pb$[rsp], 0
  00064	74 0b		 je	 SHORT $LN7@PyObject_A@2
  00066	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  0006b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006f	75 1a		 jne	 SHORT $LN8@PyObject_A@2
$LN7@PyObject_A@2:

; 300  :         PyErr_SetString(PyExc_TypeError,
; 301  :                         "expected an object with a buffer interface");

  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@BHKBJCKA@expected?5an?5object?5with?5a?5buffer@
  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0007f	e8 00 00 00 00	 call	 PyErr_SetString

; 302  :         return -1;

  00084	b8 ff ff ff ff	 mov	 eax, -1
  00089	eb 7d		 jmp	 SHORT $LN11@PyObject_A@2
$LN8@PyObject_A@2:

; 303  :     }
; 304  : 
; 305  :     if ((*pb->bf_getbuffer)(obj, &view, PyBUF_SIMPLE)) return -1;

  0008b	45 33 c0	 xor	 r8d, r8d
  0008e	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  00093	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  0009b	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  000a0	ff 10		 call	 QWORD PTR [rax]
  000a2	85 c0		 test	 eax, eax
  000a4	74 07		 je	 SHORT $LN6@PyObject_A@2
  000a6	b8 ff ff ff ff	 mov	 eax, -1
  000ab	eb 5b		 jmp	 SHORT $LN11@PyObject_A@2
$LN6@PyObject_A@2:

; 306  : 
; 307  :     *buffer = view.buf;

  000ad	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  000b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR view$[rsp]
  000ba	48 89 08	 mov	 QWORD PTR [rax], rcx

; 308  :     *buffer_len = view.len;

  000bd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR buffer_len$[rsp]
  000c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp+16]
  000ca	48 89 08	 mov	 QWORD PTR [rax], rcx

; 309  :     if (pb->bf_releasebuffer != NULL)

  000cd	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  000d2	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000d7	74 15		 je	 SHORT $LN5@PyObject_A@2

; 310  :         (*pb->bf_releasebuffer)(obj, &view);

  000d9	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  000de	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  000e6	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  000eb	ff 50 08	 call	 QWORD PTR [rax+8]
$LN5@PyObject_A@2:
$LN4@PyObject_A@2:

; 311  :     Py_XDECREF(view.obj);

  000ee	48 83 7c 24 28
	00		 cmp	 QWORD PTR view$[rsp+8], 0
  000f4	74 0a		 je	 SHORT $LN1@PyObject_A@2
  000f6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp+8]
  000fb	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyObject_A@2:
  00100	33 c0		 xor	 eax, eax
  00102	85 c0		 test	 eax, eax
  00104	75 e8		 jne	 SHORT $LN4@PyObject_A@2

; 312  :     return 0;

  00106	33 c0		 xor	 eax, eax
$LN11@PyObject_A@2:

; 313  : }

  00108	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0010f	c3		 ret	 0
PyObject_AsReadBuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@MDAPDFOC@expected?5an?5object?5with?5a?5writab@ ; `string'
PUBLIC	PyObject_AsWriteBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_AsWriteBuffer DD imagerel $LN12
	DD	imagerel $LN12+268
	DD	imagerel $unwind$PyObject_AsWriteBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_AsWriteBuffer DD 021601H
	DD	0110116H
xdata	ENDS
;	COMDAT ??_C@_0DE@MDAPDFOC@expected?5an?5object?5with?5a?5writab@
CONST	SEGMENT
??_C@_0DE@MDAPDFOC@expected?5an?5object?5with?5a?5writab@ DB 'expected an'
	DB	' object with a writable buffer interface', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_AsWriteBuffer
_TEXT	SEGMENT
view$ = 32
pb$ = 112
obj$ = 144
buffer$ = 152
buffer_len$ = 160
PyObject_AsWriteBuffer PROC				; COMDAT

; 318  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 319  :     PyBufferProcs *pb;
; 320  :     Py_buffer view;
; 321  : 
; 322  :     if (obj == NULL || buffer == NULL || buffer_len == NULL) {

  00016	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR obj$[rsp], 0
  0001f	74 16		 je	 SHORT $LN8@PyObject_A@3
  00021	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  0002a	74 0b		 je	 SHORT $LN8@PyObject_A@3
  0002c	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR buffer_len$[rsp], 0
  00035	75 0f		 jne	 SHORT $LN9@PyObject_A@3
$LN8@PyObject_A@3:

; 323  :         null_error();

  00037	e8 00 00 00 00	 call	 null_error

; 324  :         return -1;

  0003c	b8 ff ff ff ff	 mov	 eax, -1
  00041	e9 be 00 00 00	 jmp	 $LN10@PyObject_A@3
$LN9@PyObject_A@3:

; 325  :     }
; 326  : 
; 327  :     pb = obj->ob_type->tp_as_buffer;

  00046	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR obj$[rsp]
  0004e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00052	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00059	48 89 44 24 70	 mov	 QWORD PTR pb$[rsp], rax

; 328  :     if (pb == NULL ||
; 329  :         pb->bf_getbuffer == NULL ||
; 330  :         ((*pb->bf_getbuffer)(obj, &view, PyBUF_WRITABLE) != 0)) {

  0005e	48 83 7c 24 70
	00		 cmp	 QWORD PTR pb$[rsp], 0
  00064	74 29		 je	 SHORT $LN6@PyObject_A@3
  00066	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  0006b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006f	74 1e		 je	 SHORT $LN6@PyObject_A@3
  00071	41 b8 01 00 00
	00		 mov	 r8d, 1
  00077	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  0007c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  00084	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  00089	ff 10		 call	 QWORD PTR [rax]
  0008b	85 c0		 test	 eax, eax
  0008d	74 1a		 je	 SHORT $LN7@PyObject_A@3
$LN6@PyObject_A@3:

; 331  :         PyErr_SetString(PyExc_TypeError,
; 332  :                         "expected an object with a writable buffer interface");

  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@MDAPDFOC@expected?5an?5object?5with?5a?5writab@
  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0009d	e8 00 00 00 00	 call	 PyErr_SetString

; 333  :         return -1;

  000a2	b8 ff ff ff ff	 mov	 eax, -1
  000a7	eb 5b		 jmp	 SHORT $LN10@PyObject_A@3
$LN7@PyObject_A@3:

; 334  :     }
; 335  : 
; 336  :     *buffer = view.buf;

  000a9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  000b1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR view$[rsp]
  000b6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 337  :     *buffer_len = view.len;

  000b9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR buffer_len$[rsp]
  000c1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp+16]
  000c6	48 89 08	 mov	 QWORD PTR [rax], rcx

; 338  :     if (pb->bf_releasebuffer != NULL)

  000c9	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  000ce	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000d3	74 15		 je	 SHORT $LN5@PyObject_A@3

; 339  :         (*pb->bf_releasebuffer)(obj, &view);

  000d5	48 8d 54 24 20	 lea	 rdx, QWORD PTR view$[rsp]
  000da	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR obj$[rsp]
  000e2	48 8b 44 24 70	 mov	 rax, QWORD PTR pb$[rsp]
  000e7	ff 50 08	 call	 QWORD PTR [rax+8]
$LN5@PyObject_A@3:
$LN4@PyObject_A@3:

; 340  :     Py_XDECREF(view.obj);

  000ea	48 83 7c 24 28
	00		 cmp	 QWORD PTR view$[rsp+8], 0
  000f0	74 0a		 je	 SHORT $LN1@PyObject_A@3
  000f2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR view$[rsp+8]
  000f7	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyObject_A@3:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 e8		 jne	 SHORT $LN4@PyObject_A@3

; 341  :     return 0;

  00102	33 c0		 xor	 eax, eax
$LN10@PyObject_A@3:

; 342  : }

  00104	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0010b	c3		 ret	 0
PyObject_AsWriteBuffer ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@OFNJPODG@?8?$CF?4100s?8?5does?5not?5support?5the?5bu@ ; `string'
PUBLIC	PyObject_GetBuffer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_GetBuffer DD imagerel $LN5
	DD	imagerel $LN5+137
	DD	imagerel $unwind$PyObject_GetBuffer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_GetBuffer DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT ??_C@_0CP@OFNJPODG@?8?$CF?4100s?8?5does?5not?5support?5the?5bu@
CONST	SEGMENT
??_C@_0CP@OFNJPODG@?8?$CF?4100s?8?5does?5not?5support?5the?5bu@ DB '''%.1'
	DB	'00s'' does not support the buffer interface', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_GetBuffer
_TEXT	SEGMENT
obj$ = 48
view$ = 56
flags$ = 64
PyObject_GetBuffer PROC					; COMDAT

; 348  : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 349  :     if (!PyObject_CheckBuffer(obj)) {

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR obj$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  00024	74 16		 je	 SHORT $LN1@PyObject_G@2
  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR obj$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00036	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003a	75 27		 jne	 SHORT $LN2@PyObject_G@2
$LN1@PyObject_G@2:

; 350  :         PyErr_Format(PyExc_TypeError,
; 351  :                      "'%.100s' does not support the buffer interface",
; 352  :                      Py_TYPE(obj)->tp_name);

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR obj$[rsp]
  00041	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00045	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@OFNJPODG@?8?$CF?4100s?8?5does?5not?5support?5the?5bu@
  00050	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00057	e8 00 00 00 00	 call	 PyErr_Format

; 353  :         return -1;

  0005c	b8 ff ff ff ff	 mov	 eax, -1
  00061	eb 21		 jmp	 SHORT $LN3@PyObject_G@2
$LN2@PyObject_G@2:

; 354  :     }
; 355  :     return (*(obj->ob_type->tp_as_buffer->bf_getbuffer))(obj, view, flags);

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR obj$[rsp]
  00068	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006c	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00073	44 8b 44 24 40	 mov	 r8d, DWORD PTR flags$[rsp]
  00078	48 8b 54 24 38	 mov	 rdx, QWORD PTR view$[rsp]
  0007d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR obj$[rsp]
  00082	ff 10		 call	 QWORD PTR [rax]
$LN3@PyObject_G@2:

; 356  : }

  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
PyObject_GetBuffer ENDP
_TEXT	ENDS
PUBLIC	PyBuffer_IsContiguous
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_IsContiguous DD imagerel $LN11
	DD	imagerel $LN11+146
	DD	imagerel $unwind$PyBuffer_IsContiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_IsContiguous DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyBuffer_IsContiguous
_TEXT	SEGMENT
tv82 = 32
view$ = 64
order$ = 72
PyBuffer_IsContiguous PROC				; COMDAT

; 402  : {

$LN11:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 403  : 
; 404  :     if (view->suboffsets != NULL) return 0;

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  00012	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00017	74 04		 je	 SHORT $LN6@PyBuffer_I
  00019	33 c0		 xor	 eax, eax
  0001b	eb 70		 jmp	 SHORT $LN7@PyBuffer_I
$LN6@PyBuffer_I:

; 405  : 
; 406  :     if (order == 'C')

  0001d	0f be 44 24 48	 movsx	 eax, BYTE PTR order$[rsp]
  00022	83 f8 43	 cmp	 eax, 67			; 00000043H
  00025	75 0e		 jne	 SHORT $LN5@PyBuffer_I

; 407  :         return _IsCContiguous(view);

  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR view$[rsp]
  0002c	e8 00 00 00 00	 call	 _IsCContiguous
  00031	eb 5a		 jmp	 SHORT $LN7@PyBuffer_I
  00033	eb 56		 jmp	 SHORT $LN4@PyBuffer_I
$LN5@PyBuffer_I:

; 408  :     else if (order == 'F')

  00035	0f be 44 24 48	 movsx	 eax, BYTE PTR order$[rsp]
  0003a	83 f8 46	 cmp	 eax, 70			; 00000046H
  0003d	75 0e		 jne	 SHORT $LN3@PyBuffer_I

; 409  :         return _IsFortranContiguous(view);

  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR view$[rsp]
  00044	e8 00 00 00 00	 call	 _IsFortranContiguous
  00049	eb 42		 jmp	 SHORT $LN7@PyBuffer_I
  0004b	eb 3e		 jmp	 SHORT $LN2@PyBuffer_I
$LN3@PyBuffer_I:

; 410  :     else if (order == 'A')

  0004d	0f be 44 24 48	 movsx	 eax, BYTE PTR order$[rsp]
  00052	83 f8 41	 cmp	 eax, 65			; 00000041H
  00055	75 34		 jne	 SHORT $LN1@PyBuffer_I

; 411  :         return (_IsCContiguous(view) || _IsFortranContiguous(view));

  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR view$[rsp]
  0005c	e8 00 00 00 00	 call	 _IsCContiguous
  00061	85 c0		 test	 eax, eax
  00063	75 18		 jne	 SHORT $LN9@PyBuffer_I
  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR view$[rsp]
  0006a	e8 00 00 00 00	 call	 _IsFortranContiguous
  0006f	85 c0		 test	 eax, eax
  00071	75 0a		 jne	 SHORT $LN9@PyBuffer_I
  00073	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
  0007b	eb 08		 jmp	 SHORT $LN10@PyBuffer_I
$LN9@PyBuffer_I:
  0007d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
$LN10@PyBuffer_I:
  00085	8b 44 24 20	 mov	 eax, DWORD PTR tv82[rsp]
  00089	eb 02		 jmp	 SHORT $LN7@PyBuffer_I
$LN1@PyBuffer_I:
$LN2@PyBuffer_I:
$LN4@PyBuffer_I:

; 412  :     return 0;

  0008b	33 c0		 xor	 eax, eax
$LN7@PyBuffer_I:

; 413  : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
PyBuffer_IsContiguous ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_IsFortranContiguous DD imagerel _IsFortranContiguous
	DD	imagerel _IsFortranContiguous+286
	DD	imagerel $unwind$_IsFortranContiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_IsFortranContiguous DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _IsFortranContiguous
_TEXT	SEGMENT
i$ = 0
sd$ = 8
dim$ = 16
tv70 = 24
tv80 = 28
view$ = 48
_IsFortranContiguous PROC				; COMDAT

; 360  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 361  :     Py_ssize_t sd, dim;
; 362  :     int i;
; 363  : 
; 364  :     if (view->ndim == 0) return 1;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  0000e	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00012	75 0a		 jne	 SHORT $LN8@IsFortranC
  00014	b8 01 00 00 00	 mov	 eax, 1
  00019	e9 fb 00 00 00	 jmp	 $LN9@IsFortranC
$LN8@IsFortranC:

; 365  :     if (view->strides == NULL) return (view->ndim == 1);

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00023	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00028	75 26		 jne	 SHORT $LN7@IsFortranC
  0002a	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  0002f	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  00033	75 0a		 jne	 SHORT $LN11@IsFortranC
  00035	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN12@IsFortranC
$LN11@IsFortranC:
  0003f	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN12@IsFortranC:
  00047	8b 44 24 18	 mov	 eax, DWORD PTR tv70[rsp]
  0004b	e9 c9 00 00 00	 jmp	 $LN9@IsFortranC
$LN7@IsFortranC:

; 366  : 
; 367  :     sd = view->itemsize;

  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00055	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00059	48 89 44 24 08	 mov	 QWORD PTR sd$[rsp], rax

; 368  :     if (view->ndim == 1) return (view->shape[0] == 1 ||

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00063	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  00067	75 3a		 jne	 SHORT $LN6@IsFortranC

; 369  :                                sd == view->strides[0]);

  00069	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  0006e	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00072	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  00076	74 1d		 je	 SHORT $LN13@IsFortranC
  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  0007d	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00081	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00084	48 39 44 24 08	 cmp	 QWORD PTR sd$[rsp], rax
  00089	74 0a		 je	 SHORT $LN13@IsFortranC
  0008b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
  00093	eb 08		 jmp	 SHORT $LN14@IsFortranC
$LN13@IsFortranC:
  00095	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
$LN14@IsFortranC:
  0009d	8b 44 24 1c	 mov	 eax, DWORD PTR tv80[rsp]
  000a1	eb 76		 jmp	 SHORT $LN9@IsFortranC
$LN6@IsFortranC:

; 370  :     for (i=0; i<view->ndim; i++) {

  000a3	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  000aa	eb 08		 jmp	 SHORT $LN5@IsFortranC
$LN4@IsFortranC:
  000ac	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000af	ff c0		 inc	 eax
  000b1	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN5@IsFortranC:
  000b4	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  000b9	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000bc	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  000bf	7d 53		 jge	 SHORT $LN3@IsFortranC

; 371  :         dim = view->shape[i];

  000c1	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp]
  000ca	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000ce	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000d2	48 89 44 24 10	 mov	 QWORD PTR dim$[rsp], rax

; 372  :         if (dim == 0) return 1;

  000d7	48 83 7c 24 10
	00		 cmp	 QWORD PTR dim$[rsp], 0
  000dd	75 07		 jne	 SHORT $LN2@IsFortranC
  000df	b8 01 00 00 00	 mov	 eax, 1
  000e4	eb 33		 jmp	 SHORT $LN9@IsFortranC
$LN2@IsFortranC:

; 373  :         if (view->strides[i] != sd) return 0;

  000e6	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000ea	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp]
  000ef	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000f3	48 8b 54 24 08	 mov	 rdx, QWORD PTR sd$[rsp]
  000f8	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  000fc	74 04		 je	 SHORT $LN1@IsFortranC
  000fe	33 c0		 xor	 eax, eax
  00100	eb 17		 jmp	 SHORT $LN9@IsFortranC
$LN1@IsFortranC:

; 374  :         sd *= dim;

  00102	48 8b 44 24 08	 mov	 rax, QWORD PTR sd$[rsp]
  00107	48 0f af 44 24
	10		 imul	 rax, QWORD PTR dim$[rsp]
  0010d	48 89 44 24 08	 mov	 QWORD PTR sd$[rsp], rax

; 375  :     }

  00112	eb 98		 jmp	 SHORT $LN4@IsFortranC
$LN3@IsFortranC:

; 376  :     return 1;

  00114	b8 01 00 00 00	 mov	 eax, 1
$LN9@IsFortranC:

; 377  : }

  00119	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0011d	c3		 ret	 0
_IsFortranContiguous ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_IsCContiguous DD imagerel _IsCContiguous
	DD	imagerel _IsCContiguous+257
	DD	imagerel $unwind$_IsCContiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_IsCContiguous DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _IsCContiguous
_TEXT	SEGMENT
i$ = 0
sd$ = 8
dim$ = 16
tv77 = 24
view$ = 48
_IsCContiguous PROC					; COMDAT

; 381  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 382  :     Py_ssize_t sd, dim;
; 383  :     int i;
; 384  : 
; 385  :     if (view->ndim == 0) return 1;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  0000e	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00012	75 0a		 jne	 SHORT $LN8@IsCContigu
  00014	b8 01 00 00 00	 mov	 eax, 1
  00019	e9 de 00 00 00	 jmp	 $LN9@IsCContigu
$LN8@IsCContigu:

; 386  :     if (view->strides == NULL) return 1;

  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00023	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00028	75 0a		 jne	 SHORT $LN7@IsCContigu
  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	e9 c8 00 00 00	 jmp	 $LN9@IsCContigu
$LN7@IsCContigu:

; 387  : 
; 388  :     sd = view->itemsize;

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00039	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003d	48 89 44 24 08	 mov	 QWORD PTR sd$[rsp], rax

; 389  :     if (view->ndim == 1) return (view->shape[0] == 1 ||

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00047	83 78 24 01	 cmp	 DWORD PTR [rax+36], 1
  0004b	75 3a		 jne	 SHORT $LN6@IsCContigu

; 390  :                                sd == view->strides[0]);

  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00052	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00056	48 83 38 01	 cmp	 QWORD PTR [rax], 1
  0005a	74 1d		 je	 SHORT $LN11@IsCContigu
  0005c	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00061	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00065	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00068	48 39 44 24 08	 cmp	 QWORD PTR sd$[rsp], rax
  0006d	74 0a		 je	 SHORT $LN11@IsCContigu
  0006f	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
  00077	eb 08		 jmp	 SHORT $LN12@IsCContigu
$LN11@IsCContigu:
  00079	c7 44 24 18 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
$LN12@IsCContigu:
  00081	8b 44 24 18	 mov	 eax, DWORD PTR tv77[rsp]
  00085	eb 75		 jmp	 SHORT $LN9@IsCContigu
$LN6@IsCContigu:

; 391  :     for (i=view->ndim-1; i>=0; i--) {

  00087	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  0008c	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  0008f	ff c8		 dec	 eax
  00091	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  00094	eb 08		 jmp	 SHORT $LN5@IsCContigu
$LN4@IsCContigu:
  00096	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00099	ff c8		 dec	 eax
  0009b	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN5@IsCContigu:
  0009e	83 3c 24 00	 cmp	 DWORD PTR i$[rsp], 0
  000a2	7c 53		 jl	 SHORT $LN3@IsCContigu

; 392  :         dim = view->shape[i];

  000a4	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp]
  000ad	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000b1	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000b5	48 89 44 24 10	 mov	 QWORD PTR dim$[rsp], rax

; 393  :         if (dim == 0) return 1;

  000ba	48 83 7c 24 10
	00		 cmp	 QWORD PTR dim$[rsp], 0
  000c0	75 07		 jne	 SHORT $LN2@IsCContigu
  000c2	b8 01 00 00 00	 mov	 eax, 1
  000c7	eb 33		 jmp	 SHORT $LN9@IsCContigu
$LN2@IsCContigu:

; 394  :         if (view->strides[i] != sd) return 0;

  000c9	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp]
  000d2	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000d6	48 8b 54 24 08	 mov	 rdx, QWORD PTR sd$[rsp]
  000db	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  000df	74 04		 je	 SHORT $LN1@IsCContigu
  000e1	33 c0		 xor	 eax, eax
  000e3	eb 17		 jmp	 SHORT $LN9@IsCContigu
$LN1@IsCContigu:

; 395  :         sd *= dim;

  000e5	48 8b 44 24 08	 mov	 rax, QWORD PTR sd$[rsp]
  000ea	48 0f af 44 24
	10		 imul	 rax, QWORD PTR dim$[rsp]
  000f0	48 89 44 24 08	 mov	 QWORD PTR sd$[rsp], rax

; 396  :     }

  000f5	eb 9f		 jmp	 SHORT $LN4@IsCContigu
$LN3@IsCContigu:

; 397  :     return 1;

  000f7	b8 01 00 00 00	 mov	 eax, 1
$LN9@IsCContigu:

; 398  : }

  000fc	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00100	c3		 ret	 0
_IsCContiguous ENDP
_TEXT	ENDS
PUBLIC	PyBuffer_GetPointer
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_GetPointer DD imagerel $LN7
	DD	imagerel $LN7+184
	DD	imagerel $unwind$PyBuffer_GetPointer
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_GetPointer DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyBuffer_GetPointer
_TEXT	SEGMENT
i$ = 0
pointer$ = 8
view$ = 32
indices$ = 40
PyBuffer_GetPointer PROC				; COMDAT

; 418  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 419  :     char* pointer;
; 420  :     int i;
; 421  :     pointer = (char *)view->buf;

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 89 44 24 08	 mov	 QWORD PTR pointer$[rsp], rax

; 422  :     for (i = 0; i < view->ndim; i++) {

  0001b	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00022	eb 08		 jmp	 SHORT $LN4@PyBuffer_G
$LN3@PyBuffer_G:
  00024	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00027	ff c0		 inc	 eax
  00029	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@PyBuffer_G:
  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  00031	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00034	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00037	7d 75		 jge	 SHORT $LN2@PyBuffer_G

; 423  :         pointer += view->strides[i]*indices[i];

  00039	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR view$[rsp]
  00042	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00046	48 63 14 24	 movsxd	 rdx, DWORD PTR i$[rsp]
  0004a	4c 8b 44 24 28	 mov	 r8, QWORD PTR indices$[rsp]
  0004f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00053	49 0f af 04 d0	 imul	 rax, QWORD PTR [r8+rdx*8]
  00058	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pointer$[rsp]
  0005d	48 03 c8	 add	 rcx, rax
  00060	48 8b c1	 mov	 rax, rcx
  00063	48 89 44 24 08	 mov	 QWORD PTR pointer$[rsp], rax

; 424  :         if ((view->suboffsets != NULL) && (view->suboffsets[i] >= 0)) {

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR view$[rsp]
  0006d	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  00072	74 35		 je	 SHORT $LN1@PyBuffer_G
  00074	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR view$[rsp]
  0007d	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00081	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00086	7c 21		 jl	 SHORT $LN1@PyBuffer_G

; 425  :             pointer = *((char**)pointer) + view->suboffsets[i];

  00088	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR view$[rsp]
  00091	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00095	48 8b 54 24 08	 mov	 rdx, QWORD PTR pointer$[rsp]
  0009a	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0009d	48 03 14 c1	 add	 rdx, QWORD PTR [rcx+rax*8]
  000a1	48 8b c2	 mov	 rax, rdx
  000a4	48 89 44 24 08	 mov	 QWORD PTR pointer$[rsp], rax
$LN1@PyBuffer_G:

; 426  :         }
; 427  :     }

  000a9	e9 76 ff ff ff	 jmp	 $LN3@PyBuffer_G
$LN2@PyBuffer_G:

; 428  :     return (void*)pointer;

  000ae	48 8b 44 24 08	 mov	 rax, QWORD PTR pointer$[rsp]

; 429  : }

  000b3	48 83 c4 18	 add	 rsp, 24
  000b7	c3		 ret	 0
PyBuffer_GetPointer ENDP
_TEXT	ENDS
PUBLIC	_Py_add_one_to_index_F
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_add_one_to_index_F DD imagerel $LN8
	DD	imagerel $LN8+132
	DD	imagerel $unwind$_Py_add_one_to_index_F
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_add_one_to_index_F DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_add_one_to_index_F
_TEXT	SEGMENT
k$ = 0
nd$ = 32
index$ = 40
shape$ = 48
_Py_add_one_to_index_F PROC				; COMDAT

; 434  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 435  :     int k;
; 436  : 
; 437  :     for (k=0; k<nd; k++) {

  00012	c7 04 24 00 00
	00 00		 mov	 DWORD PTR k$[rsp], 0
  00019	eb 08		 jmp	 SHORT $LN5@Py_add_one
$LN4@Py_add_one:
  0001b	8b 04 24	 mov	 eax, DWORD PTR k$[rsp]
  0001e	ff c0		 inc	 eax
  00020	89 04 24	 mov	 DWORD PTR k$[rsp], eax
$LN5@Py_add_one:
  00023	8b 44 24 20	 mov	 eax, DWORD PTR nd$[rsp]
  00027	39 04 24	 cmp	 DWORD PTR k$[rsp], eax
  0002a	7d 53		 jge	 SHORT $LN3@Py_add_one

; 438  :         if (index[k] < shape[k]-1) {

  0002c	48 63 04 24	 movsxd	 rax, DWORD PTR k$[rsp]
  00030	48 63 0c 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  00034	48 8b 54 24 30	 mov	 rdx, QWORD PTR shape$[rsp]
  00039	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0003d	48 ff c9	 dec	 rcx
  00040	48 8b 54 24 28	 mov	 rdx, QWORD PTR index$[rsp]
  00045	48 39 0c c2	 cmp	 QWORD PTR [rdx+rax*8], rcx
  00049	7d 21		 jge	 SHORT $LN2@Py_add_one

; 439  :             index[k]++;

  0004b	48 63 04 24	 movsxd	 rax, DWORD PTR k$[rsp]
  0004f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR index$[rsp]
  00054	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00058	48 ff c0	 inc	 rax
  0005b	48 63 0c 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  0005f	48 8b 54 24 28	 mov	 rdx, QWORD PTR index$[rsp]
  00064	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 440  :             break;

  00068	eb 15		 jmp	 SHORT $LN3@Py_add_one

; 441  :         }
; 442  :         else {

  0006a	eb 11		 jmp	 SHORT $LN1@Py_add_one
$LN2@Py_add_one:

; 443  :             index[k] = 0;

  0006c	48 63 04 24	 movsxd	 rax, DWORD PTR k$[rsp]
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR index$[rsp]
  00075	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
$LN1@Py_add_one:

; 444  :         }
; 445  :     }

  0007d	eb 9c		 jmp	 SHORT $LN4@Py_add_one
$LN3@Py_add_one:

; 446  : }

  0007f	48 83 c4 18	 add	 rsp, 24
  00083	c3		 ret	 0
_Py_add_one_to_index_F ENDP
_TEXT	ENDS
PUBLIC	_Py_add_one_to_index_C
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_add_one_to_index_C DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$_Py_add_one_to_index_C
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_add_one_to_index_C DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_add_one_to_index_C
_TEXT	SEGMENT
k$ = 0
nd$ = 32
index$ = 40
shape$ = 48
_Py_add_one_to_index_C PROC				; COMDAT

; 450  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 451  :     int k;
; 452  : 
; 453  :     for (k=nd-1; k>=0; k--) {

  00012	8b 44 24 20	 mov	 eax, DWORD PTR nd$[rsp]
  00016	ff c8		 dec	 eax
  00018	89 04 24	 mov	 DWORD PTR k$[rsp], eax
  0001b	eb 08		 jmp	 SHORT $LN5@Py_add_one@2
$LN4@Py_add_one@2:
  0001d	8b 04 24	 mov	 eax, DWORD PTR k$[rsp]
  00020	ff c8		 dec	 eax
  00022	89 04 24	 mov	 DWORD PTR k$[rsp], eax
$LN5@Py_add_one@2:
  00025	83 3c 24 00	 cmp	 DWORD PTR k$[rsp], 0
  00029	7c 53		 jl	 SHORT $LN3@Py_add_one@2

; 454  :         if (index[k] < shape[k]-1) {

  0002b	48 63 04 24	 movsxd	 rax, DWORD PTR k$[rsp]
  0002f	48 63 0c 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  00033	48 8b 54 24 30	 mov	 rdx, QWORD PTR shape$[rsp]
  00038	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0003c	48 ff c9	 dec	 rcx
  0003f	48 8b 54 24 28	 mov	 rdx, QWORD PTR index$[rsp]
  00044	48 39 0c c2	 cmp	 QWORD PTR [rdx+rax*8], rcx
  00048	7d 21		 jge	 SHORT $LN2@Py_add_one@2

; 455  :             index[k]++;

  0004a	48 63 04 24	 movsxd	 rax, DWORD PTR k$[rsp]
  0004e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR index$[rsp]
  00053	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00057	48 ff c0	 inc	 rax
  0005a	48 63 0c 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  0005e	48 8b 54 24 28	 mov	 rdx, QWORD PTR index$[rsp]
  00063	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 456  :             break;

  00067	eb 15		 jmp	 SHORT $LN3@Py_add_one@2

; 457  :         }
; 458  :         else {

  00069	eb 11		 jmp	 SHORT $LN1@Py_add_one@2
$LN2@Py_add_one@2:

; 459  :             index[k] = 0;

  0006b	48 63 04 24	 movsxd	 rax, DWORD PTR k$[rsp]
  0006f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR index$[rsp]
  00074	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
$LN1@Py_add_one@2:

; 460  :         }
; 461  :     }

  0007c	eb 9f		 jmp	 SHORT $LN4@Py_add_one@2
$LN3@Py_add_one@2:

; 462  : }

  0007e	48 83 c4 18	 add	 rsp, 24
  00082	c3		 ret	 0
_Py_add_one_to_index_C ENDP
_TEXT	ENDS
PUBLIC	PyBuffer_FromContiguous
EXTRN	PyMem_Free:PROC
EXTRN	PyErr_NoMemory:PROC
EXTRN	PyMem_Malloc:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_FromContiguous DD imagerel $LN13
	DD	imagerel $LN13+410
	DD	imagerel $unwind$PyBuffer_FromContiguous
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_FromContiguous DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyBuffer_FromContiguous
_TEXT	SEGMENT
addone$ = 32
ptr$ = 40
elements$ = 48
indices$ = 56
k$ = 64
src$ = 72
view$ = 96
buf$ = 104
len$ = 112
fort$ = 120
PyBuffer_FromContiguous PROC				; COMDAT

; 466  : {

$LN13:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 467  :     int k;
; 468  :     void (*addone)(int, Py_ssize_t *, const Py_ssize_t *);
; 469  :     Py_ssize_t *indices, elements;
; 470  :     char *src, *ptr;
; 471  : 
; 472  :     if (len > view->len) {

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR view$[rsp]
  0001d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00021	48 39 44 24 70	 cmp	 QWORD PTR len$[rsp], rax
  00026	7e 0e		 jle	 SHORT $LN10@PyBuffer_F

; 473  :         len = view->len;

  00028	48 8b 44 24 60	 mov	 rax, QWORD PTR view$[rsp]
  0002d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00031	48 89 44 24 70	 mov	 QWORD PTR len$[rsp], rax
$LN10@PyBuffer_F:

; 474  :     }
; 475  : 
; 476  :     if (PyBuffer_IsContiguous(view, fort)) {

  00036	0f b6 54 24 78	 movzx	 edx, BYTE PTR fort$[rsp]
  0003b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR view$[rsp]
  00040	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  00045	85 c0		 test	 eax, eax
  00047	74 1e		 je	 SHORT $LN9@PyBuffer_F

; 477  :         /* simplest copy is all that is needed */
; 478  :         memcpy(view->buf, buf, len);

  00049	4c 8b 44 24 70	 mov	 r8, QWORD PTR len$[rsp]
  0004e	48 8b 54 24 68	 mov	 rdx, QWORD PTR buf$[rsp]
  00053	48 8b 44 24 60	 mov	 rax, QWORD PTR view$[rsp]
  00058	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0005b	e8 00 00 00 00	 call	 memcpy

; 479  :         return 0;

  00060	33 c0		 xor	 eax, eax
  00062	e9 2e 01 00 00	 jmp	 $LN11@PyBuffer_F
$LN9@PyBuffer_F:

; 480  :     }
; 481  : 
; 482  :     /* Otherwise a more elaborate scheme is needed */
; 483  : 
; 484  :     /* XXX(nnorwitz): need to check for overflow! */
; 485  :     indices = (Py_ssize_t *)PyMem_Malloc(sizeof(Py_ssize_t)*(view->ndim));

  00067	48 8b 44 24 60	 mov	 rax, QWORD PTR view$[rsp]
  0006c	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  00070	48 c1 e0 03	 shl	 rax, 3
  00074	48 8b c8	 mov	 rcx, rax
  00077	e8 00 00 00 00	 call	 PyMem_Malloc
  0007c	48 89 44 24 38	 mov	 QWORD PTR indices$[rsp], rax

; 486  :     if (indices == NULL) {

  00081	48 83 7c 24 38
	00		 cmp	 QWORD PTR indices$[rsp], 0
  00087	75 0f		 jne	 SHORT $LN8@PyBuffer_F

; 487  :         PyErr_NoMemory();

  00089	e8 00 00 00 00	 call	 PyErr_NoMemory

; 488  :         return -1;

  0008e	b8 ff ff ff ff	 mov	 eax, -1
  00093	e9 fd 00 00 00	 jmp	 $LN11@PyBuffer_F
$LN8@PyBuffer_F:

; 489  :     }
; 490  :     for (k=0; k<view->ndim;k++) {

  00098	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  000a0	eb 0a		 jmp	 SHORT $LN7@PyBuffer_F
$LN6@PyBuffer_F:
  000a2	8b 44 24 40	 mov	 eax, DWORD PTR k$[rsp]
  000a6	ff c0		 inc	 eax
  000a8	89 44 24 40	 mov	 DWORD PTR k$[rsp], eax
$LN7@PyBuffer_F:
  000ac	48 8b 44 24 60	 mov	 rax, QWORD PTR view$[rsp]
  000b1	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  000b4	39 44 24 40	 cmp	 DWORD PTR k$[rsp], eax
  000b8	7d 14		 jge	 SHORT $LN5@PyBuffer_F

; 491  :         indices[k] = 0;

  000ba	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$[rsp]
  000bf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR indices$[rsp]
  000c4	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 492  :     }

  000cc	eb d4		 jmp	 SHORT $LN6@PyBuffer_F
$LN5@PyBuffer_F:

; 493  : 
; 494  :     if (fort == 'F') {

  000ce	0f be 44 24 78	 movsx	 eax, BYTE PTR fort$[rsp]
  000d3	83 f8 46	 cmp	 eax, 70			; 00000046H
  000d6	75 0e		 jne	 SHORT $LN4@PyBuffer_F

; 495  :         addone = _Py_add_one_to_index_F;

  000d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_add_one_to_index_F
  000df	48 89 44 24 20	 mov	 QWORD PTR addone$[rsp], rax

; 496  :     }
; 497  :     else {

  000e4	eb 0c		 jmp	 SHORT $LN3@PyBuffer_F
$LN4@PyBuffer_F:

; 498  :         addone = _Py_add_one_to_index_C;

  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_add_one_to_index_C
  000ed	48 89 44 24 20	 mov	 QWORD PTR addone$[rsp], rax
$LN3@PyBuffer_F:

; 499  :     }
; 500  :     src = buf;

  000f2	48 8b 44 24 68	 mov	 rax, QWORD PTR buf$[rsp]
  000f7	48 89 44 24 48	 mov	 QWORD PTR src$[rsp], rax

; 501  :     /* XXX : This is not going to be the fastest code in the world
; 502  :              several optimizations are possible.
; 503  :      */
; 504  :     elements = len / view->itemsize;

  000fc	48 8b 44 24 70	 mov	 rax, QWORD PTR len$[rsp]
  00101	48 99		 cdq
  00103	48 8b 4c 24 60	 mov	 rcx, QWORD PTR view$[rsp]
  00108	48 f7 79 18	 idiv	 QWORD PTR [rcx+24]
  0010c	48 89 44 24 30	 mov	 QWORD PTR elements$[rsp], rax
$LN2@PyBuffer_F:

; 505  :     while (elements--) {

  00111	48 8b 44 24 30	 mov	 rax, QWORD PTR elements$[rsp]
  00116	48 8b 4c 24 30	 mov	 rcx, QWORD PTR elements$[rsp]
  0011b	48 ff c9	 dec	 rcx
  0011e	48 89 4c 24 30	 mov	 QWORD PTR elements$[rsp], rcx
  00123	48 85 c0	 test	 rax, rax
  00126	74 61		 je	 SHORT $LN1@PyBuffer_F

; 506  :         addone(view->ndim, indices, view->shape);

  00128	48 8b 44 24 60	 mov	 rax, QWORD PTR view$[rsp]
  0012d	4c 8b 40 30	 mov	 r8, QWORD PTR [rax+48]
  00131	48 8b 54 24 38	 mov	 rdx, QWORD PTR indices$[rsp]
  00136	48 8b 44 24 60	 mov	 rax, QWORD PTR view$[rsp]
  0013b	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  0013e	ff 54 24 20	 call	 QWORD PTR addone$[rsp]

; 507  :         ptr = PyBuffer_GetPointer(view, indices);

  00142	48 8b 54 24 38	 mov	 rdx, QWORD PTR indices$[rsp]
  00147	48 8b 4c 24 60	 mov	 rcx, QWORD PTR view$[rsp]
  0014c	e8 00 00 00 00	 call	 PyBuffer_GetPointer
  00151	48 89 44 24 28	 mov	 QWORD PTR ptr$[rsp], rax

; 508  :         memcpy(ptr, src, view->itemsize);

  00156	48 8b 44 24 60	 mov	 rax, QWORD PTR view$[rsp]
  0015b	4c 8b 40 18	 mov	 r8, QWORD PTR [rax+24]
  0015f	48 8b 54 24 48	 mov	 rdx, QWORD PTR src$[rsp]
  00164	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ptr$[rsp]
  00169	e8 00 00 00 00	 call	 memcpy

; 509  :         src += view->itemsize;

  0016e	48 8b 44 24 60	 mov	 rax, QWORD PTR view$[rsp]
  00173	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00177	48 8b 4c 24 48	 mov	 rcx, QWORD PTR src$[rsp]
  0017c	48 03 c8	 add	 rcx, rax
  0017f	48 8b c1	 mov	 rax, rcx
  00182	48 89 44 24 48	 mov	 QWORD PTR src$[rsp], rax

; 510  :     }

  00187	eb 88		 jmp	 SHORT $LN2@PyBuffer_F
$LN1@PyBuffer_F:

; 511  : 
; 512  :     PyMem_Free(indices);

  00189	48 8b 4c 24 38	 mov	 rcx, QWORD PTR indices$[rsp]
  0018e	e8 00 00 00 00	 call	 PyMem_Free

; 513  :     return 0;

  00193	33 c0		 xor	 eax, eax
$LN11@PyBuffer_F:

; 514  : }

  00195	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00199	c3		 ret	 0
PyBuffer_FromContiguous ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@GGNMGAIA@destination?5is?5too?5small?5to?5rece@ ; `string'
PUBLIC	??_C@_0DL@MFJPONME@both?5destination?5and?5source?5must@ ; `string'
PUBLIC	PyObject_CopyData
EXTRN	PyExc_BufferError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CopyData DD imagerel $LN21
	DD	imagerel $LN21+837
	DD	imagerel $unwind$PyObject_CopyData
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CopyData DD 021101H
	DD	01f0111H
xdata	ENDS
;	COMDAT ??_C@_0DF@GGNMGAIA@destination?5is?5too?5small?5to?5rece@
CONST	SEGMENT
??_C@_0DF@GGNMGAIA@destination?5is?5too?5small?5to?5rece@ DB 'destination'
	DB	' is too small to receive data from source', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MFJPONME@both?5destination?5and?5source?5must@
CONST	SEGMENT
??_C@_0DL@MFJPONME@both?5destination?5and?5source?5must@ DB 'both destina'
	DB	'tion and source must have the buffer interface', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_CopyData
_TEXT	SEGMENT
view_dest$ = 32
view_src$ = 112
elements$ = 192
indices$ = 200
sptr$ = 208
k$ = 216
dptr$ = 224
dest$ = 256
src$ = 264
PyObject_CopyData PROC					; COMDAT

; 517  : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 518  :     Py_buffer view_dest, view_src;
; 519  :     int k;
; 520  :     Py_ssize_t *indices, elements;
; 521  :     char *dptr, *sptr;
; 522  : 
; 523  :     if (!PyObject_CheckBuffer(dest) ||
; 524  :         !PyObject_CheckBuffer(src)) {

  00011	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  00019	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001d	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  00025	74 48		 je	 SHORT $LN17@PyObject_C@2
  00027	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  0002f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00033	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  0003a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0003e	74 2f		 je	 SHORT $LN17@PyObject_C@2
  00040	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR src$[rsp]
  00048	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004c	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  00054	74 19		 je	 SHORT $LN16@PyObject_C@2
  00056	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR src$[rsp]
  0005e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00062	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00069	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006d	75 1d		 jne	 SHORT $LN18@PyObject_C@2
$LN16@PyObject_C@2:
$LN17@PyObject_C@2:

; 525  :         PyErr_SetString(PyExc_TypeError,
; 526  :                         "both destination and source must have the "\
; 527  :                         "buffer interface");

  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@MFJPONME@both?5destination?5and?5source?5must@
  00076	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0007d	e8 00 00 00 00	 call	 PyErr_SetString

; 528  :         return -1;

  00082	b8 ff ff ff ff	 mov	 eax, -1
  00087	e9 b1 02 00 00	 jmp	 $LN19@PyObject_C@2
$LN18@PyObject_C@2:

; 529  :     }
; 530  : 
; 531  :     if (PyObject_GetBuffer(dest, &view_dest, PyBUF_FULL) != 0) return -1;

  0008c	41 b8 1d 01 00
	00		 mov	 r8d, 285		; 0000011dH
  00092	48 8d 54 24 20	 lea	 rdx, QWORD PTR view_dest$[rsp]
  00097	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  0009f	e8 00 00 00 00	 call	 PyObject_GetBuffer
  000a4	85 c0		 test	 eax, eax
  000a6	74 0a		 je	 SHORT $LN15@PyObject_C@2
  000a8	b8 ff ff ff ff	 mov	 eax, -1
  000ad	e9 8b 02 00 00	 jmp	 $LN19@PyObject_C@2
$LN15@PyObject_C@2:

; 532  :     if (PyObject_GetBuffer(src, &view_src, PyBUF_FULL_RO) != 0) {

  000b2	41 b8 1c 01 00
	00		 mov	 r8d, 284		; 0000011cH
  000b8	48 8d 54 24 70	 lea	 rdx, QWORD PTR view_src$[rsp]
  000bd	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR src$[rsp]
  000c5	e8 00 00 00 00	 call	 PyObject_GetBuffer
  000ca	85 c0		 test	 eax, eax
  000cc	74 14		 je	 SHORT $LN14@PyObject_C@2

; 533  :         PyBuffer_Release(&view_dest);

  000ce	48 8d 4c 24 20	 lea	 rcx, QWORD PTR view_dest$[rsp]
  000d3	e8 00 00 00 00	 call	 PyBuffer_Release

; 534  :         return -1;

  000d8	b8 ff ff ff ff	 mov	 eax, -1
  000dd	e9 5b 02 00 00	 jmp	 $LN19@PyObject_C@2
$LN14@PyObject_C@2:

; 535  :     }
; 536  : 
; 537  :     if (view_dest.len < view_src.len) {

  000e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR view_src$[rsp+16]
  000ea	48 39 44 24 30	 cmp	 QWORD PTR view_dest$[rsp+16], rax
  000ef	7d 31		 jge	 SHORT $LN13@PyObject_C@2

; 538  :         PyErr_SetString(PyExc_BufferError,
; 539  :                         "destination is too small to receive data from source");

  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@GGNMGAIA@destination?5is?5too?5small?5to?5rece@
  000f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  000ff	e8 00 00 00 00	 call	 PyErr_SetString

; 540  :         PyBuffer_Release(&view_dest);

  00104	48 8d 4c 24 20	 lea	 rcx, QWORD PTR view_dest$[rsp]
  00109	e8 00 00 00 00	 call	 PyBuffer_Release

; 541  :         PyBuffer_Release(&view_src);

  0010e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR view_src$[rsp]
  00113	e8 00 00 00 00	 call	 PyBuffer_Release

; 542  :         return -1;

  00118	b8 ff ff ff ff	 mov	 eax, -1
  0011d	e9 1b 02 00 00	 jmp	 $LN19@PyObject_C@2
$LN13@PyObject_C@2:

; 543  :     }
; 544  : 
; 545  :     if ((PyBuffer_IsContiguous(&view_dest, 'C') &&
; 546  :          PyBuffer_IsContiguous(&view_src, 'C')) ||
; 547  :         (PyBuffer_IsContiguous(&view_dest, 'F') &&
; 548  :          PyBuffer_IsContiguous(&view_src, 'F'))) {

  00122	b2 43		 mov	 dl, 67			; 00000043H
  00124	48 8d 4c 24 20	 lea	 rcx, QWORD PTR view_dest$[rsp]
  00129	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  0012e	85 c0		 test	 eax, eax
  00130	74 10		 je	 SHORT $LN10@PyObject_C@2
  00132	b2 43		 mov	 dl, 67			; 00000043H
  00134	48 8d 4c 24 70	 lea	 rcx, QWORD PTR view_src$[rsp]
  00139	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  0013e	85 c0		 test	 eax, eax
  00140	75 20		 jne	 SHORT $LN11@PyObject_C@2
$LN10@PyObject_C@2:
  00142	b2 46		 mov	 dl, 70			; 00000046H
  00144	48 8d 4c 24 20	 lea	 rcx, QWORD PTR view_dest$[rsp]
  00149	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  0014e	85 c0		 test	 eax, eax
  00150	74 42		 je	 SHORT $LN12@PyObject_C@2
  00152	b2 46		 mov	 dl, 70			; 00000046H
  00154	48 8d 4c 24 70	 lea	 rcx, QWORD PTR view_src$[rsp]
  00159	e8 00 00 00 00	 call	 PyBuffer_IsContiguous
  0015e	85 c0		 test	 eax, eax
  00160	74 32		 je	 SHORT $LN12@PyObject_C@2
$LN11@PyObject_C@2:

; 549  :         /* simplest copy is all that is needed */
; 550  :         memcpy(view_dest.buf, view_src.buf, view_src.len);

  00162	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR view_src$[rsp+16]
  0016a	48 8b 54 24 70	 mov	 rdx, QWORD PTR view_src$[rsp]
  0016f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR view_dest$[rsp]
  00174	e8 00 00 00 00	 call	 memcpy

; 551  :         PyBuffer_Release(&view_dest);

  00179	48 8d 4c 24 20	 lea	 rcx, QWORD PTR view_dest$[rsp]
  0017e	e8 00 00 00 00	 call	 PyBuffer_Release

; 552  :         PyBuffer_Release(&view_src);

  00183	48 8d 4c 24 70	 lea	 rcx, QWORD PTR view_src$[rsp]
  00188	e8 00 00 00 00	 call	 PyBuffer_Release

; 553  :         return 0;

  0018d	33 c0		 xor	 eax, eax
  0018f	e9 a9 01 00 00	 jmp	 $LN19@PyObject_C@2
$LN12@PyObject_C@2:

; 554  :     }
; 555  : 
; 556  :     /* Otherwise a more elaborate copy scheme is needed */
; 557  : 
; 558  :     /* XXX(nnorwitz): need to check for overflow! */
; 559  :     indices = (Py_ssize_t *)PyMem_Malloc(sizeof(Py_ssize_t)*view_src.ndim);

  00194	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR view_src$[rsp+36]
  0019c	48 c1 e0 03	 shl	 rax, 3
  001a0	48 8b c8	 mov	 rcx, rax
  001a3	e8 00 00 00 00	 call	 PyMem_Malloc
  001a8	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR indices$[rsp], rax

; 560  :     if (indices == NULL) {

  001b0	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR indices$[rsp], 0
  001b9	75 23		 jne	 SHORT $LN9@PyObject_C@2

; 561  :         PyErr_NoMemory();

  001bb	e8 00 00 00 00	 call	 PyErr_NoMemory

; 562  :         PyBuffer_Release(&view_dest);

  001c0	48 8d 4c 24 20	 lea	 rcx, QWORD PTR view_dest$[rsp]
  001c5	e8 00 00 00 00	 call	 PyBuffer_Release

; 563  :         PyBuffer_Release(&view_src);

  001ca	48 8d 4c 24 70	 lea	 rcx, QWORD PTR view_src$[rsp]
  001cf	e8 00 00 00 00	 call	 PyBuffer_Release

; 564  :         return -1;

  001d4	b8 ff ff ff ff	 mov	 eax, -1
  001d9	e9 5f 01 00 00	 jmp	 $LN19@PyObject_C@2
$LN9@PyObject_C@2:

; 565  :     }
; 566  :     for (k=0; k<view_src.ndim;k++) {

  001de	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR k$[rsp], 0
  001e9	eb 10		 jmp	 SHORT $LN8@PyObject_C@2
$LN7@PyObject_C@2:
  001eb	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  001f2	ff c0		 inc	 eax
  001f4	89 84 24 d8 00
	00 00		 mov	 DWORD PTR k$[rsp], eax
$LN8@PyObject_C@2:
  001fb	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR view_src$[rsp+36]
  00202	39 84 24 d8 00
	00 00		 cmp	 DWORD PTR k$[rsp], eax
  00209	7d 1a		 jge	 SHORT $LN6@PyObject_C@2

; 567  :         indices[k] = 0;

  0020b	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  00213	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR indices$[rsp]
  0021b	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 568  :     }

  00223	eb c6		 jmp	 SHORT $LN7@PyObject_C@2
$LN6@PyObject_C@2:

; 569  :     elements = 1;

  00225	48 c7 84 24 c0
	00 00 00 01 00
	00 00		 mov	 QWORD PTR elements$[rsp], 1

; 570  :     for (k=0; k<view_src.ndim; k++) {

  00231	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR k$[rsp], 0
  0023c	eb 10		 jmp	 SHORT $LN5@PyObject_C@2
$LN4@PyObject_C@2:
  0023e	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR k$[rsp]
  00245	ff c0		 inc	 eax
  00247	89 84 24 d8 00
	00 00		 mov	 DWORD PTR k$[rsp], eax
$LN5@PyObject_C@2:
  0024e	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR view_src$[rsp+36]
  00255	39 84 24 d8 00
	00 00		 cmp	 DWORD PTR k$[rsp], eax
  0025c	7d 2a		 jge	 SHORT $LN3@PyObject_C@2

; 571  :         /* XXX(nnorwitz): can this overflow? */
; 572  :         elements *= view_src.shape[k];

  0025e	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  00266	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR view_src$[rsp+48]
  0026e	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR elements$[rsp]
  00276	48 0f af 14 c1	 imul	 rdx, QWORD PTR [rcx+rax*8]
  0027b	48 8b c2	 mov	 rax, rdx
  0027e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR elements$[rsp], rax

; 573  :     }

  00286	eb b6		 jmp	 SHORT $LN4@PyObject_C@2
$LN3@PyObject_C@2:
$LN2@PyObject_C@2:

; 574  :     while (elements--) {

  00288	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR elements$[rsp]
  00290	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR elements$[rsp]
  00298	48 ff c9	 dec	 rcx
  0029b	48 89 8c 24 c0
	00 00 00	 mov	 QWORD PTR elements$[rsp], rcx
  002a3	48 85 c0	 test	 rax, rax
  002a6	74 72		 je	 SHORT $LN1@PyObject_C@2

; 575  :         _Py_add_one_to_index_C(view_src.ndim, indices, view_src.shape);

  002a8	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR view_src$[rsp+48]
  002b0	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR indices$[rsp]
  002b8	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR view_src$[rsp+36]
  002bf	e8 00 00 00 00	 call	 _Py_add_one_to_index_C

; 576  :         dptr = PyBuffer_GetPointer(&view_dest, indices);

  002c4	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR indices$[rsp]
  002cc	48 8d 4c 24 20	 lea	 rcx, QWORD PTR view_dest$[rsp]
  002d1	e8 00 00 00 00	 call	 PyBuffer_GetPointer
  002d6	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR dptr$[rsp], rax

; 577  :         sptr = PyBuffer_GetPointer(&view_src, indices);

  002de	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR indices$[rsp]
  002e6	48 8d 4c 24 70	 lea	 rcx, QWORD PTR view_src$[rsp]
  002eb	e8 00 00 00 00	 call	 PyBuffer_GetPointer
  002f0	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR sptr$[rsp], rax

; 578  :         memcpy(dptr, sptr, view_src.itemsize);

  002f8	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR view_src$[rsp+24]
  00300	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR sptr$[rsp]
  00308	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dptr$[rsp]
  00310	e8 00 00 00 00	 call	 memcpy

; 579  :     }

  00315	e9 6e ff ff ff	 jmp	 $LN2@PyObject_C@2
$LN1@PyObject_C@2:

; 580  :     PyMem_Free(indices);

  0031a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR indices$[rsp]
  00322	e8 00 00 00 00	 call	 PyMem_Free

; 581  :     PyBuffer_Release(&view_dest);

  00327	48 8d 4c 24 20	 lea	 rcx, QWORD PTR view_dest$[rsp]
  0032c	e8 00 00 00 00	 call	 PyBuffer_Release

; 582  :     PyBuffer_Release(&view_src);

  00331	48 8d 4c 24 70	 lea	 rcx, QWORD PTR view_src$[rsp]
  00336	e8 00 00 00 00	 call	 PyBuffer_Release

; 583  :     return 0;

  0033b	33 c0		 xor	 eax, eax
$LN19@PyObject_C@2:

; 584  : }

  0033d	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00344	c3		 ret	 0
PyObject_CopyData ENDP
_TEXT	ENDS
PUBLIC	PyBuffer_FillContiguousStrides
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_FillContiguousStrides DD imagerel $LN11
	DD	imagerel $LN11+200
	DD	imagerel $unwind$PyBuffer_FillContiguousStrides
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_FillContiguousStrides DD 011701H
	DD	02217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyBuffer_FillContiguousStrides
_TEXT	SEGMENT
sd$ = 0
k$ = 8
nd$ = 32
shape$ = 40
strides$ = 48
itemsize$ = 56
fort$ = 64
PyBuffer_FillContiguousStrides PROC			; COMDAT

; 590  : {

$LN11:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 18	 sub	 rsp, 24

; 591  :     int k;
; 592  :     Py_ssize_t sd;
; 593  : 
; 594  :     sd = itemsize;

  00017	48 63 44 24 38	 movsxd	 rax, DWORD PTR itemsize$[rsp]
  0001c	48 89 04 24	 mov	 QWORD PTR sd$[rsp], rax

; 595  :     if (fort == 'F') {

  00020	0f be 44 24 40	 movsx	 eax, BYTE PTR fort$[rsp]
  00025	83 f8 46	 cmp	 eax, 70			; 00000046H
  00028	75 4e		 jne	 SHORT $LN8@PyBuffer_F@2

; 596  :         for (k=0; k<nd; k++) {

  0002a	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00032	eb 0a		 jmp	 SHORT $LN7@PyBuffer_F@2
$LN6@PyBuffer_F@2:
  00034	8b 44 24 08	 mov	 eax, DWORD PTR k$[rsp]
  00038	ff c0		 inc	 eax
  0003a	89 44 24 08	 mov	 DWORD PTR k$[rsp], eax
$LN7@PyBuffer_F@2:
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR nd$[rsp]
  00042	39 44 24 08	 cmp	 DWORD PTR k$[rsp], eax
  00046	7d 2e		 jge	 SHORT $LN5@PyBuffer_F@2

; 597  :             strides[k] = sd;

  00048	48 63 44 24 08	 movsxd	 rax, DWORD PTR k$[rsp]
  0004d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strides$[rsp]
  00052	48 8b 14 24	 mov	 rdx, QWORD PTR sd$[rsp]
  00056	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 598  :             sd *= shape[k];

  0005a	48 63 44 24 08	 movsxd	 rax, DWORD PTR k$[rsp]
  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR shape$[rsp]
  00064	48 8b 14 24	 mov	 rdx, QWORD PTR sd$[rsp]
  00068	48 0f af 14 c1	 imul	 rdx, QWORD PTR [rcx+rax*8]
  0006d	48 8b c2	 mov	 rax, rdx
  00070	48 89 04 24	 mov	 QWORD PTR sd$[rsp], rax

; 599  :         }

  00074	eb be		 jmp	 SHORT $LN6@PyBuffer_F@2
$LN5@PyBuffer_F@2:

; 600  :     }
; 601  :     else {

  00076	eb 4b		 jmp	 SHORT $LN4@PyBuffer_F@2
$LN8@PyBuffer_F@2:

; 602  :         for (k=nd-1; k>=0; k--) {

  00078	8b 44 24 20	 mov	 eax, DWORD PTR nd$[rsp]
  0007c	ff c8		 dec	 eax
  0007e	89 44 24 08	 mov	 DWORD PTR k$[rsp], eax
  00082	eb 0a		 jmp	 SHORT $LN3@PyBuffer_F@2
$LN2@PyBuffer_F@2:
  00084	8b 44 24 08	 mov	 eax, DWORD PTR k$[rsp]
  00088	ff c8		 dec	 eax
  0008a	89 44 24 08	 mov	 DWORD PTR k$[rsp], eax
$LN3@PyBuffer_F@2:
  0008e	83 7c 24 08 00	 cmp	 DWORD PTR k$[rsp], 0
  00093	7c 2e		 jl	 SHORT $LN1@PyBuffer_F@2

; 603  :             strides[k] = sd;

  00095	48 63 44 24 08	 movsxd	 rax, DWORD PTR k$[rsp]
  0009a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strides$[rsp]
  0009f	48 8b 14 24	 mov	 rdx, QWORD PTR sd$[rsp]
  000a3	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 604  :             sd *= shape[k];

  000a7	48 63 44 24 08	 movsxd	 rax, DWORD PTR k$[rsp]
  000ac	48 8b 4c 24 28	 mov	 rcx, QWORD PTR shape$[rsp]
  000b1	48 8b 14 24	 mov	 rdx, QWORD PTR sd$[rsp]
  000b5	48 0f af 14 c1	 imul	 rdx, QWORD PTR [rcx+rax*8]
  000ba	48 8b c2	 mov	 rax, rdx
  000bd	48 89 04 24	 mov	 QWORD PTR sd$[rsp], rax

; 605  :         }

  000c1	eb c1		 jmp	 SHORT $LN2@PyBuffer_F@2
$LN1@PyBuffer_F@2:
$LN4@PyBuffer_F@2:

; 606  :     }
; 607  :     return;
; 608  : }

  000c3	48 83 c4 18	 add	 rsp, 24
  000c7	c3		 ret	 0
PyBuffer_FillContiguousStrides ENDP
_TEXT	ENDS
PUBLIC	??_C@_01HMGJMAIH@B?$AA@				; `string'
PUBLIC	??_C@_0BI@KOBEJKPF@Object?5is?5not?5writable?4?$AA@ ; `string'
PUBLIC	PyBuffer_FillInfo
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_FillInfo DD imagerel $LN9
	DD	imagerel $LN9+343
	DD	imagerel $unwind$PyBuffer_FillInfo
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_FillInfo DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT ??_C@_01HMGJMAIH@B?$AA@
CONST	SEGMENT
??_C@_01HMGJMAIH@B?$AA@ DB 'B', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@KOBEJKPF@Object?5is?5not?5writable?4?$AA@
CONST	SEGMENT
??_C@_0BI@KOBEJKPF@Object?5is?5not?5writable?4?$AA@ DB 'Object is not wri'
	DB	'table.', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyBuffer_FillInfo
_TEXT	SEGMENT
view$ = 48
obj$ = 56
buf$ = 64
len$ = 72
readonly$ = 80
flags$ = 88
PyBuffer_FillInfo PROC					; COMDAT

; 613  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 614  :     if (view == NULL) return 0; /* XXX why not -1? */

  00018	48 83 7c 24 30
	00		 cmp	 QWORD PTR view$[rsp], 0
  0001e	75 07		 jne	 SHORT $LN6@PyBuffer_F@3
  00020	33 c0		 xor	 eax, eax
  00022	e9 2b 01 00 00	 jmp	 $LN7@PyBuffer_F@3
$LN6@PyBuffer_F@3:

; 615  :     if (((flags & PyBUF_WRITABLE) == PyBUF_WRITABLE) &&
; 616  :         (readonly == 1)) {

  00027	8b 44 24 58	 mov	 eax, DWORD PTR flags$[rsp]
  0002b	83 e0 01	 and	 eax, 1
  0002e	83 f8 01	 cmp	 eax, 1
  00031	75 24		 jne	 SHORT $LN5@PyBuffer_F@3
  00033	83 7c 24 50 01	 cmp	 DWORD PTR readonly$[rsp], 1
  00038	75 1d		 jne	 SHORT $LN5@PyBuffer_F@3

; 617  :         PyErr_SetString(PyExc_BufferError,
; 618  :                         "Object is not writable.");

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@KOBEJKPF@Object?5is?5not?5writable?4?$AA@
  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_BufferError
  00048	e8 00 00 00 00	 call	 PyErr_SetString

; 619  :         return -1;

  0004d	b8 ff ff ff ff	 mov	 eax, -1
  00052	e9 fb 00 00 00	 jmp	 $LN7@PyBuffer_F@3
$LN5@PyBuffer_F@3:

; 620  :     }
; 621  : 
; 622  :     view->obj = obj;

  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  0005c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obj$[rsp]
  00061	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 623  :     if (obj)

  00065	48 83 7c 24 38
	00		 cmp	 QWORD PTR obj$[rsp], 0
  0006b	74 0a		 je	 SHORT $LN4@PyBuffer_F@3

; 624  :         Py_INCREF(obj);

  0006d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obj$[rsp]
  00072	e8 00 00 00 00	 call	 _Py_IncRef
$LN4@PyBuffer_F@3:

; 625  :     view->buf = buf;

  00077	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buf$[rsp]
  00081	48 89 08	 mov	 QWORD PTR [rax], rcx

; 626  :     view->len = len;

  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00089	48 8b 4c 24 48	 mov	 rcx, QWORD PTR len$[rsp]
  0008e	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 627  :     view->readonly = readonly;

  00092	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00097	8b 4c 24 50	 mov	 ecx, DWORD PTR readonly$[rsp]
  0009b	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 628  :     view->itemsize = 1;

  0009e	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  000a3	48 c7 40 18 01
	00 00 00	 mov	 QWORD PTR [rax+24], 1

; 629  :     view->format = NULL;

  000ab	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  000b0	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 630  :     if ((flags & PyBUF_FORMAT) == PyBUF_FORMAT)

  000b8	8b 44 24 58	 mov	 eax, DWORD PTR flags$[rsp]
  000bc	83 e0 04	 and	 eax, 4
  000bf	83 f8 04	 cmp	 eax, 4
  000c2	75 10		 jne	 SHORT $LN3@PyBuffer_F@3

; 631  :         view->format = "B";

  000c4	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01HMGJMAIH@B?$AA@
  000d0	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
$LN3@PyBuffer_F@3:

; 632  :     view->ndim = 1;

  000d4	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  000d9	c7 40 24 01 00
	00 00		 mov	 DWORD PTR [rax+36], 1

; 633  :     view->shape = NULL;

  000e0	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  000e5	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 634  :     if ((flags & PyBUF_ND) == PyBUF_ND)

  000ed	8b 44 24 58	 mov	 eax, DWORD PTR flags$[rsp]
  000f1	83 e0 08	 and	 eax, 8
  000f4	83 f8 08	 cmp	 eax, 8
  000f7	75 12		 jne	 SHORT $LN2@PyBuffer_F@3

; 635  :         view->shape = &(view->len);

  000f9	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  000fe	48 83 c0 10	 add	 rax, 16
  00102	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp]
  00107	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN2@PyBuffer_F@3:

; 636  :     view->strides = NULL;

  0010b	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00110	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 637  :     if ((flags & PyBUF_STRIDES) == PyBUF_STRIDES)

  00118	8b 44 24 58	 mov	 eax, DWORD PTR flags$[rsp]
  0011c	83 e0 18	 and	 eax, 24
  0011f	83 f8 18	 cmp	 eax, 24
  00122	75 12		 jne	 SHORT $LN1@PyBuffer_F@3

; 638  :         view->strides = &(view->itemsize);

  00124	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00129	48 83 c0 18	 add	 rax, 24
  0012d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR view$[rsp]
  00132	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN1@PyBuffer_F@3:

; 639  :     view->suboffsets = NULL;

  00136	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  0013b	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 640  :     view->internal = NULL;

  00143	48 8b 44 24 30	 mov	 rax, QWORD PTR view$[rsp]
  00148	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 641  :     return 0;

  00150	33 c0		 xor	 eax, eax
$LN7@PyBuffer_F@3:

; 642  : }

  00152	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00156	c3		 ret	 0
PyBuffer_FillInfo ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyBuffer_Release DD imagerel $LN8
	DD	imagerel $LN8+144
	DD	imagerel $unwind$PyBuffer_Release
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyBuffer_Release DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyBuffer_Release
_TEXT	SEGMENT
obj$ = 32
view$ = 64
PyBuffer_Release PROC					; COMDAT

; 646  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 647  :     PyObject *obj = view->obj;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  0000e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00012	48 89 44 24 20	 mov	 QWORD PTR obj$[rsp], rax

; 648  :     if (obj && Py_TYPE(obj)->tp_as_buffer && Py_TYPE(obj)->tp_as_buffer->bf_releasebuffer)

  00017	48 83 7c 24 20
	00		 cmp	 QWORD PTR obj$[rsp], 0
  0001d	74 47		 je	 SHORT $LN5@PyBuffer_R
  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR obj$[rsp]
  00024	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00028	48 83 b8 f8 00
	00 00 00	 cmp	 QWORD PTR [rax+248], 0
  00030	74 34		 je	 SHORT $LN5@PyBuffer_R
  00032	48 8b 44 24 20	 mov	 rax, QWORD PTR obj$[rsp]
  00037	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003b	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00042	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00047	74 1d		 je	 SHORT $LN5@PyBuffer_R

; 649  :         Py_TYPE(obj)->tp_as_buffer->bf_releasebuffer(obj, view);

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR obj$[rsp]
  0004e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00052	48 8b 80 f8 00
	00 00		 mov	 rax, QWORD PTR [rax+248]
  00059	48 8b 54 24 40	 mov	 rdx, QWORD PTR view$[rsp]
  0005e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR obj$[rsp]
  00063	ff 50 08	 call	 QWORD PTR [rax+8]
$LN5@PyBuffer_R:
$LN4@PyBuffer_R:

; 650  :     Py_XDECREF(obj);

  00066	48 83 7c 24 20
	00		 cmp	 QWORD PTR obj$[rsp], 0
  0006c	74 0a		 je	 SHORT $LN1@PyBuffer_R
  0006e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR obj$[rsp]
  00073	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyBuffer_R:
  00078	33 c0		 xor	 eax, eax
  0007a	85 c0		 test	 eax, eax
  0007c	75 e8		 jne	 SHORT $LN4@PyBuffer_R

; 651  :     view->obj = NULL;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR view$[rsp]
  00083	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 652  : }

  0008b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008f	c3		 ret	 0
PyBuffer_Release ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CI@FIOEJBGE@__format__?5method?5did?5not?5return@ ; `string'
PUBLIC	??_C@_0CG@NLBIPBIO@Type?5?$CF?4100s?5doesn?8t?5define?5__for@ ; `string'
PUBLIC	PyObject_Format
EXTRN	PyUnicode_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Format DD imagerel $LN11
	DD	imagerel $LN11+297
	DD	imagerel $unwind$PyObject_Format
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Format DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0CI@FIOEJBGE@__format__?5method?5did?5not?5return@
CONST	SEGMENT
??_C@_0CI@FIOEJBGE@__format__?5method?5did?5not?5return@ DB '__format__ m'
	DB	'ethod did not return string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NLBIPBIO@Type?5?$CF?4100s?5doesn?8t?5define?5__for@
CONST	SEGMENT
??_C@_0CG@NLBIPBIO@Type?5?$CF?4100s?5doesn?8t?5define?5__for@ DB 'Type %.'
	DB	'100s doesn''t define __format__', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_Format
_TEXT	SEGMENT
empty$ = 32
result$ = 40
meth$ = 48
obj$ = 80
format_spec$ = 88
PyObject_Format PROC					; COMDAT

; 656  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 657  :     PyObject *meth;
; 658  :     PyObject *empty = NULL;

  0000e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR empty$[rsp], 0

; 659  :     PyObject *result = NULL;

  00017	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 660  :     _Py_IDENTIFIER(__format__);
; 661  : 
; 662  :     /* If no format_spec is provided, use an empty string */
; 663  :     if (format_spec == NULL) {

  00020	48 83 7c 24 58
	00		 cmp	 QWORD PTR format_spec$[rsp], 0
  00026	75 18		 jne	 SHORT $LN8@PyObject_F

; 664  :         empty = PyUnicode_New(0, 0);

  00028	33 d2		 xor	 edx, edx
  0002a	33 c9		 xor	 ecx, ecx
  0002c	e8 00 00 00 00	 call	 PyUnicode_New
  00031	48 89 44 24 20	 mov	 QWORD PTR empty$[rsp], rax

; 665  :         format_spec = empty;

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR empty$[rsp]
  0003b	48 89 44 24 58	 mov	 QWORD PTR format_spec$[rsp], rax
$LN8@PyObject_F:

; 666  :     }
; 667  : 
; 668  :     /* Find the (unbound!) __format__ method (a borrowed reference) */
; 669  :     meth = _PyObject_LookupSpecial(obj, &PyId___format__);

  00040	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___format__@?1??PyObject_Format@@9@9
  00045	8b c0		 mov	 eax, eax
  00047	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0004d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00056	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  0005a	48 8b d0	 mov	 rdx, rax
  0005d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR obj$[rsp]
  00062	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00067	48 89 44 24 30	 mov	 QWORD PTR meth$[rsp], rax

; 670  :     if (meth == NULL) {

  0006c	48 83 7c 24 30
	00		 cmp	 QWORD PTR meth$[rsp], 0
  00072	75 2c		 jne	 SHORT $LN7@PyObject_F

; 671  :         if (!PyErr_Occurred())

  00074	e8 00 00 00 00	 call	 PyErr_Occurred
  00079	48 85 c0	 test	 rax, rax
  0007c	75 20		 jne	 SHORT $LN6@PyObject_F

; 672  :             PyErr_Format(PyExc_TypeError,
; 673  :                          "Type %.100s doesn't define __format__",
; 674  :                          Py_TYPE(obj)->tp_name);

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR obj$[rsp]
  00083	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00087	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@NLBIPBIO@Type?5?$CF?4100s?5doesn?8t?5define?5__for@
  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00099	e8 00 00 00 00	 call	 PyErr_Format
$LN6@PyObject_F:

; 675  :         goto done;

  0009e	eb 67		 jmp	 SHORT $done$20807
$LN7@PyObject_F:

; 676  :     }
; 677  : 
; 678  :     /* And call it. */
; 679  :     result = PyObject_CallFunctionObjArgs(meth, format_spec, NULL);

  000a0	45 33 c0	 xor	 r8d, r8d
  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR format_spec$[rsp]
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR meth$[rsp]
  000ad	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  000b2	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 680  :     Py_DECREF(meth);

  000b7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR meth$[rsp]
  000bc	e8 00 00 00 00	 call	 _Py_DecRef

; 681  : 
; 682  :     if (result && !PyUnicode_Check(result)) {

  000c1	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  000c7	74 3e		 je	 SHORT $LN5@PyObject_F
  000c9	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
  000ce	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000d2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000d8	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  000dd	85 c0		 test	 eax, eax
  000df	75 26		 jne	 SHORT $LN5@PyObject_F

; 683  :         PyErr_SetString(PyExc_TypeError,
; 684  :                         "__format__ method did not return string");

  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@FIOEJBGE@__format__?5method?5did?5not?5return@
  000e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ef	e8 00 00 00 00	 call	 PyErr_SetString

; 685  :         Py_DECREF(result);

  000f4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  000f9	e8 00 00 00 00	 call	 _Py_DecRef

; 686  :         result = NULL;

  000fe	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0
$LN5@PyObject_F:
$done$20807:
$LN4@PyObject_F:

; 687  :         goto done;
; 688  :     }
; 689  : 
; 690  : done:
; 691  :     Py_XDECREF(empty);

  00107	48 83 7c 24 20
	00		 cmp	 QWORD PTR empty$[rsp], 0
  0010d	74 0a		 je	 SHORT $LN1@PyObject_F
  0010f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR empty$[rsp]
  00114	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PyObject_F:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	75 e8		 jne	 SHORT $LN4@PyObject_F

; 692  :     return result;

  0011f	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]

; 693  : }

  00124	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00128	c3		 ret	 0
PyObject_Format ENDP
_TEXT	ENDS
PUBLIC	PyNumber_Check
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Check DD imagerel $LN6
	DD	imagerel $LN6+112
	DD	imagerel $unwind$PyNumber_Check
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Check DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyNumber_Check
_TEXT	SEGMENT
tv76 = 0
o$ = 32
PyNumber_Check PROC					; COMDAT

; 698  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 699  :     return o && o->ob_type->tp_as_number &&
; 700  :            (o->ob_type->tp_as_number->nb_int ||
; 701  :         o->ob_type->tp_as_number->nb_float);

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR o$[rsp], 0
  0000f	74 50		 je	 SHORT $LN3@PyNumber_C
  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR o$[rsp]
  00016	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001a	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00022	74 3d		 je	 SHORT $LN3@PyNumber_C
  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR o$[rsp]
  00029	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002d	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00034	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0003c	75 1a		 jne	 SHORT $LN4@PyNumber_C
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR o$[rsp]
  00043	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00047	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0004e	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  00056	74 09		 je	 SHORT $LN3@PyNumber_C
$LN4@PyNumber_C:
  00058	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv76[rsp], 1
  0005f	eb 07		 jmp	 SHORT $LN5@PyNumber_C
$LN3@PyNumber_C:
  00061	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv76[rsp], 0
$LN5@PyNumber_C:
  00068	8b 04 24	 mov	 eax, DWORD PTR tv76[rsp]

; 702  : }

  0006b	48 83 c4 18	 add	 rsp, 24
  0006f	c3		 ret	 0
PyNumber_Check ENDP
_TEXT	ENDS
PUBLIC	??_C@_01DNKMNLPK@?$HM?$AA@			; `string'
PUBLIC	PyNumber_Or
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Or DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$PyNumber_Or
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Or DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_01DNKMNLPK@?$HM?$AA@
CONST	SEGMENT
??_C@_01DNKMNLPK@?$HM?$AA@ DB '|', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Or
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_Or PROC					; COMDAT

; 869  : BINARY_FUNC(PyNumber_Or, nb_or, "|")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01DNKMNLPK@?$HM?$AA@
  00015	41 b8 78 00 00
	00		 mov	 r8d, 120		; 00000078H
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR w$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00025	e8 00 00 00 00	 call	 binary_op
  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
PyNumber_Or ENDP
_TEXT	ENDS
EXTRN	_Py_NotImplementedStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$binary_op DD imagerel binary_op
	DD	imagerel binary_op+105
	DD	imagerel $unwind$binary_op
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binary_op DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT binary_op
_TEXT	SEGMENT
result$ = 32
v$ = 64
w$ = 72
op_slot$ = 80
op_name$ = 88
binary_op PROC						; COMDAT

; 773  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 774  :     PyObject *result = binary_op1(v, w, op_slot);

  00018	44 8b 44 24 50	 mov	 r8d, DWORD PTR op_slot$[rsp]
  0001d	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00027	e8 00 00 00 00	 call	 binary_op1
  0002c	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 775  :     if (result == Py_NotImplemented) {

  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00038	48 39 44 24 20	 cmp	 QWORD PTR result$[rsp], rax
  0003d	75 20		 jne	 SHORT $LN1@binary_op

; 776  :         Py_DECREF(result);

  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00044	e8 00 00 00 00	 call	 _Py_DecRef

; 777  :         return binop_type_error(v, w, op_name);

  00049	4c 8b 44 24 58	 mov	 r8, QWORD PTR op_name$[rsp]
  0004e	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00058	e8 00 00 00 00	 call	 binop_type_error
  0005d	eb 05		 jmp	 SHORT $LN2@binary_op
$LN1@binary_op:

; 778  :     }
; 779  :     return result;

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN2@binary_op:

; 780  : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
binary_op ENDP
_TEXT	ENDS
EXTRN	PyType_IsSubtype:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$binary_op1 DD imagerel binary_op1
	DD	imagerel binary_op1+417
	DD	imagerel $unwind$binary_op1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binary_op1 DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT binary_op1
_TEXT	SEGMENT
x$ = 32
slotv$ = 40
slotw$ = 48
v$ = 80
w$ = 88
op_slot$ = 96
binary_op1 PROC						; COMDAT

; 724  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 725  :     PyObject *x;
; 726  :     binaryfunc slotv = NULL;

  00013	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR slotv$[rsp], 0

; 727  :     binaryfunc slotw = NULL;

  0001c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR slotw$[rsp], 0

; 728  : 
; 729  :     if (v->ob_type->tp_as_number != NULL)

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0002a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002e	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00036	74 1e		 je	 SHORT $LN9@binary_op1

; 730  :         slotv = NB_BINOP(v->ob_type->tp_as_number, op_slot);

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0003d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00041	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR op_slot$[rsp]
  00046	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0004d	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00051	48 89 44 24 28	 mov	 QWORD PTR slotv$[rsp], rax
$LN9@binary_op1:

; 731  :     if (w->ob_type != v->ob_type &&
; 732  :         w->ob_type->tp_as_number != NULL) {

  00056	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  0005b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00060	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00064	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  00068	74 46		 je	 SHORT $LN8@binary_op1
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  0006f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00073	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  0007b	74 33		 je	 SHORT $LN8@binary_op1

; 733  :         slotw = NB_BINOP(w->ob_type->tp_as_number, op_slot);

  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  00082	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00086	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR op_slot$[rsp]
  0008b	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00092	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00096	48 89 44 24 30	 mov	 QWORD PTR slotw$[rsp], rax

; 734  :         if (slotw == slotv)

  0009b	48 8b 44 24 28	 mov	 rax, QWORD PTR slotv$[rsp]
  000a0	48 39 44 24 30	 cmp	 QWORD PTR slotw$[rsp], rax
  000a5	75 09		 jne	 SHORT $LN7@binary_op1

; 735  :             slotw = NULL;

  000a7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR slotw$[rsp], 0
$LN7@binary_op1:
$LN8@binary_op1:

; 736  :     }
; 737  :     if (slotv) {

  000b0	48 83 7c 24 28
	00		 cmp	 QWORD PTR slotv$[rsp], 0
  000b6	0f 84 93 00 00
	00		 je	 $LN6@binary_op1

; 738  :         if (slotw && PyType_IsSubtype(w->ob_type, v->ob_type)) {

  000bc	48 83 7c 24 30
	00		 cmp	 QWORD PTR slotw$[rsp], 0
  000c2	74 59		 je	 SHORT $LN5@binary_op1
  000c4	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  000c9	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  000cd	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  000d2	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000d6	e8 00 00 00 00	 call	 PyType_IsSubtype
  000db	85 c0		 test	 eax, eax
  000dd	74 3e		 je	 SHORT $LN5@binary_op1

; 739  :             x = slotw(v, w);

  000df	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  000e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000e9	ff 54 24 30	 call	 QWORD PTR slotw$[rsp]
  000ed	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 740  :             if (x != Py_NotImplemented)

  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000f9	48 39 44 24 20	 cmp	 QWORD PTR x$[rsp], rax
  000fe	74 0a		 je	 SHORT $LN4@binary_op1

; 741  :                 return x;

  00100	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  00105	e9 92 00 00 00	 jmp	 $LN10@binary_op1
$LN4@binary_op1:

; 742  :             Py_DECREF(x); /* can't do it */

  0010a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  0010f	e8 00 00 00 00	 call	 _Py_DecRef

; 743  :             slotw = NULL;

  00114	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR slotw$[rsp], 0
$LN5@binary_op1:

; 744  :         }
; 745  :         x = slotv(v, w);

  0011d	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  00122	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00127	ff 54 24 28	 call	 QWORD PTR slotv$[rsp]
  0012b	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 746  :         if (x != Py_NotImplemented)

  00130	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00137	48 39 44 24 20	 cmp	 QWORD PTR x$[rsp], rax
  0013c	74 07		 je	 SHORT $LN3@binary_op1

; 747  :             return x;

  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  00143	eb 57		 jmp	 SHORT $LN10@binary_op1
$LN3@binary_op1:

; 748  :         Py_DECREF(x); /* can't do it */

  00145	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  0014a	e8 00 00 00 00	 call	 _Py_DecRef
$LN6@binary_op1:

; 749  :     }
; 750  :     if (slotw) {

  0014f	48 83 7c 24 30
	00		 cmp	 QWORD PTR slotw$[rsp], 0
  00155	74 32		 je	 SHORT $LN2@binary_op1

; 751  :         x = slotw(v, w);

  00157	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  0015c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00161	ff 54 24 30	 call	 QWORD PTR slotw$[rsp]
  00165	48 89 44 24 20	 mov	 QWORD PTR x$[rsp], rax

; 752  :         if (x != Py_NotImplemented)

  0016a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00171	48 39 44 24 20	 cmp	 QWORD PTR x$[rsp], rax
  00176	74 07		 je	 SHORT $LN1@binary_op1

; 753  :             return x;

  00178	48 8b 44 24 20	 mov	 rax, QWORD PTR x$[rsp]
  0017d	eb 1d		 jmp	 SHORT $LN10@binary_op1
$LN1@binary_op1:

; 754  :         Py_DECREF(x); /* can't do it */

  0017f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR x$[rsp]
  00184	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@binary_op1:

; 755  :     }
; 756  :     Py_RETURN_NOTIMPLEMENTED;

  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NotImplementedStruct
  00190	e8 00 00 00 00	 call	 _Py_IncRef
  00195	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
$LN10@binary_op1:

; 757  : }

  0019c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a0	c3		 ret	 0
binary_op1 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@NGILOPOP@unsupported?5operand?5type?$CIs?$CJ?5for?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$binop_type_error DD imagerel binop_type_error
	DD	imagerel binop_type_error+81
	DD	imagerel $unwind$binop_type_error
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binop_type_error DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0DO@NGILOPOP@unsupported?5operand?5type?$CIs?$CJ?5for?5@
CONST	SEGMENT
??_C@_0DO@NGILOPOP@unsupported?5operand?5type?$CIs?$CJ?5for?5@ DB 'unsupp'
	DB	'orted operand type(s) for %.100s: ''%.100s'' and ''%.100s''', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT binop_type_error
_TEXT	SEGMENT
v$ = 64
w$ = 72
op_name$ = 80
binop_type_error PROC					; COMDAT

; 761  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 762  :     PyErr_Format(PyExc_TypeError,
; 763  :                  "unsupported operand type(s) for %.100s: "
; 764  :                  "'%.100s' and '%.100s'",
; 765  :                  op_name,
; 766  :                  v->ob_type->tp_name,
; 767  :                  w->ob_type->tp_name);

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR w$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00021	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00025	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00029	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002e	4c 8b 49 70	 mov	 r9, QWORD PTR [rcx+112]
  00032	4c 8b 44 24 50	 mov	 r8, QWORD PTR op_name$[rsp]
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DO@NGILOPOP@unsupported?5operand?5type?$CIs?$CJ?5for?5@
  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00045	e8 00 00 00 00	 call	 PyErr_Format

; 768  :     return NULL;

  0004a	33 c0		 xor	 eax, eax

; 769  : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
binop_type_error ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JKBOJNNK@?$FO?$AA@			; `string'
PUBLIC	PyNumber_Xor
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Xor DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$PyNumber_Xor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Xor DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_01JKBOJNNK@?$FO?$AA@
CONST	SEGMENT
??_C@_01JKBOJNNK@?$FO?$AA@ DB '^', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Xor
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_Xor PROC					; COMDAT

; 870  : BINARY_FUNC(PyNumber_Xor, nb_xor, "^")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01JKBOJNNK@?$FO?$AA@
  00015	41 b8 70 00 00
	00		 mov	 r8d, 112		; 00000070H
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR w$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00025	e8 00 00 00 00	 call	 binary_op
  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
PyNumber_Xor ENDP
_TEXT	ENDS
PUBLIC	??_C@_01HNPIGOCE@?$CG?$AA@			; `string'
PUBLIC	PyNumber_And
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_And DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$PyNumber_And
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_And DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_01HNPIGOCE@?$CG?$AA@
CONST	SEGMENT
??_C@_01HNPIGOCE@?$CG?$AA@ DB '&', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_And
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_And PROC					; COMDAT

; 871  : BINARY_FUNC(PyNumber_And, nb_and, "&")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01HNPIGOCE@?$CG?$AA@
  00015	41 b8 68 00 00
	00		 mov	 r8d, 104		; 00000068H
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR w$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00025	e8 00 00 00 00	 call	 binary_op
  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
PyNumber_And ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FODMEDOG@?$DM?$DM?$AA@			; `string'
PUBLIC	PyNumber_Lshift
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Lshift DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$PyNumber_Lshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Lshift DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_02FODMEDOG@?$DM?$DM?$AA@
CONST	SEGMENT
??_C@_02FODMEDOG@?$DM?$DM?$AA@ DB '<<', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Lshift
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_Lshift PROC					; COMDAT

; 872  : BINARY_FUNC(PyNumber_Lshift, nb_lshift, "<<")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02FODMEDOG@?$DM?$DM?$AA@
  00015	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR w$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00025	e8 00 00 00 00	 call	 binary_op
  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
PyNumber_Lshift ENDP
_TEXT	ENDS
PUBLIC	??_C@_02GPIOPFAK@?$DO?$DO?$AA@			; `string'
PUBLIC	PyNumber_Rshift
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Rshift DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$PyNumber_Rshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Rshift DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_02GPIOPFAK@?$DO?$DO?$AA@
CONST	SEGMENT
??_C@_02GPIOPFAK@?$DO?$DO?$AA@ DB '>>', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Rshift
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_Rshift PROC					; COMDAT

; 873  : BINARY_FUNC(PyNumber_Rshift, nb_rshift, ">>")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02GPIOPFAK@?$DO?$DO?$AA@
  00015	41 b8 60 00 00
	00		 mov	 r8d, 96			; 00000060H
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR w$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00025	e8 00 00 00 00	 call	 binary_op
  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
PyNumber_Rshift ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	PyNumber_Subtract
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Subtract DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$PyNumber_Subtract
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Subtract DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Subtract
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_Subtract PROC					; COMDAT

; 874  : BINARY_FUNC(PyNumber_Subtract, nb_subtract, "-")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01JOAMLHOP@?9?$AA@
  00015	41 b8 08 00 00
	00		 mov	 r8d, 8
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR w$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00025	e8 00 00 00 00	 call	 binary_op
  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
PyNumber_Subtract ENDP
_TEXT	ENDS
PUBLIC	??_C@_08DBDBHBIH@divmod?$CI?$CJ?$AA@		; `string'
PUBLIC	PyNumber_Divmod
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Divmod DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$PyNumber_Divmod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Divmod DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_08DBDBHBIH@divmod?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_08DBDBHBIH@divmod?$CI?$CJ?$AA@ DB 'divmod()', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Divmod
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_Divmod PROC					; COMDAT

; 875  : BINARY_FUNC(PyNumber_Divmod, nb_divmod, "divmod()")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_08DBDBHBIH@divmod?$CI?$CJ?$AA@
  00015	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR w$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00025	e8 00 00 00 00	 call	 binary_op
  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
PyNumber_Divmod ENDP
_TEXT	ENDS
PUBLIC	??_C@_01MIFGBAGJ@?$CL?$AA@			; `string'
PUBLIC	PyNumber_Add
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Add DD imagerel $LN5
	DD	imagerel $LN5+159
	DD	imagerel $unwind$PyNumber_Add
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Add DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_01MIFGBAGJ@?$CL?$AA@
CONST	SEGMENT
??_C@_01MIFGBAGJ@?$CL?$AA@ DB '+', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Add
_TEXT	SEGMENT
result$ = 32
m$21015 = 40
v$ = 64
w$ = 72
PyNumber_Add PROC					; COMDAT

; 879  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 880  :     PyObject *result = binary_op1(v, w, NB_SLOT(nb_add));

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0001b	e8 00 00 00 00	 call	 binary_op1
  00020	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 881  :     if (result == Py_NotImplemented) {

  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0002c	48 39 44 24 20	 cmp	 QWORD PTR result$[rsp], rax
  00031	75 62		 jne	 SHORT $LN2@PyNumber_A

; 882  :         PySequenceMethods *m = v->ob_type->tp_as_sequence;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00038	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003c	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00043	48 89 44 24 28	 mov	 QWORD PTR m$21015[rsp], rax

; 883  :         Py_DECREF(result);

  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  0004d	e8 00 00 00 00	 call	 _Py_DecRef

; 884  :         if (m && m->sq_concat) {

  00052	48 83 7c 24 28
	00		 cmp	 QWORD PTR m$21015[rsp], 0
  00058	74 20		 je	 SHORT $LN1@PyNumber_A
  0005a	48 8b 44 24 28	 mov	 rax, QWORD PTR m$21015[rsp]
  0005f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00064	74 14		 je	 SHORT $LN1@PyNumber_A

; 885  :             return (*m->sq_concat)(v, w);

  00066	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0006b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00070	48 8b 44 24 28	 mov	 rax, QWORD PTR m$21015[rsp]
  00075	ff 50 08	 call	 QWORD PTR [rax+8]
  00078	eb 20		 jmp	 SHORT $LN3@PyNumber_A
$LN1@PyNumber_A:

; 886  :         }
; 887  :         result = binop_type_error(v, w, "+");

  0007a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01MIFGBAGJ@?$CL?$AA@
  00081	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  00086	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0008b	e8 00 00 00 00	 call	 binop_type_error
  00090	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN2@PyNumber_A:

; 888  :     }
; 889  :     return result;

  00095	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN3@PyNumber_A:

; 890  : }

  0009a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009e	c3		 ret	 0
PyNumber_Add ENDP
_TEXT	ENDS
PUBLIC	??_C@_01NBENCBCI@?$CK?$AA@			; `string'
PUBLIC	PyNumber_Multiply
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Multiply DD imagerel $LN7
	DD	imagerel $LN7+241
	DD	imagerel $unwind$PyNumber_Multiply
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Multiply DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK?$AA@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK?$AA@ DB '*', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Multiply
_TEXT	SEGMENT
result$ = 32
mw$21046 = 40
mv$21045 = 48
v$ = 80
w$ = 88
PyNumber_Multiply PROC					; COMDAT

; 910  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 911  :     PyObject *result = binary_op1(v, w, NB_SLOT(nb_multiply));

  0000e	41 b8 10 00 00
	00		 mov	 r8d, 16
  00014	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  0001e	e8 00 00 00 00	 call	 binary_op1
  00023	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 912  :     if (result == Py_NotImplemented) {

  00028	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0002f	48 39 44 24 20	 cmp	 QWORD PTR result$[rsp], rax
  00034	0f 85 ad 00 00
	00		 jne	 $LN4@PyNumber_M

; 913  :         PySequenceMethods *mv = v->ob_type->tp_as_sequence;

  0003a	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0003f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00043	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004a	48 89 44 24 30	 mov	 QWORD PTR mv$21045[rsp], rax

; 914  :         PySequenceMethods *mw = w->ob_type->tp_as_sequence;

  0004f	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  00054	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00058	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0005f	48 89 44 24 28	 mov	 QWORD PTR mw$21046[rsp], rax

; 915  :         Py_DECREF(result);

  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00069	e8 00 00 00 00	 call	 _Py_DecRef

; 916  :         if  (mv && mv->sq_repeat) {

  0006e	48 83 7c 24 30
	00		 cmp	 QWORD PTR mv$21045[rsp], 0
  00074	74 28		 je	 SHORT $LN3@PyNumber_M
  00076	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$21045[rsp]
  0007b	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00080	74 1c		 je	 SHORT $LN3@PyNumber_M

; 917  :             return sequence_repeat(mv->sq_repeat, v, w);

  00082	4c 8b 44 24 58	 mov	 r8, QWORD PTR w$[rsp]
  00087	48 8b 54 24 50	 mov	 rdx, QWORD PTR v$[rsp]
  0008c	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$21045[rsp]
  00091	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00095	e8 00 00 00 00	 call	 sequence_repeat
  0009a	eb 50		 jmp	 SHORT $LN5@PyNumber_M
  0009c	eb 2e		 jmp	 SHORT $LN2@PyNumber_M
$LN3@PyNumber_M:

; 918  :         }
; 919  :         else if (mw && mw->sq_repeat) {

  0009e	48 83 7c 24 28
	00		 cmp	 QWORD PTR mw$21046[rsp], 0
  000a4	74 26		 je	 SHORT $LN1@PyNumber_M
  000a6	48 8b 44 24 28	 mov	 rax, QWORD PTR mw$21046[rsp]
  000ab	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000b0	74 1a		 je	 SHORT $LN1@PyNumber_M

; 920  :             return sequence_repeat(mw->sq_repeat, w, v);

  000b2	4c 8b 44 24 50	 mov	 r8, QWORD PTR v$[rsp]
  000b7	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  000bc	48 8b 44 24 28	 mov	 rax, QWORD PTR mw$21046[rsp]
  000c1	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000c5	e8 00 00 00 00	 call	 sequence_repeat
  000ca	eb 20		 jmp	 SHORT $LN5@PyNumber_M
$LN1@PyNumber_M:
$LN2@PyNumber_M:

; 921  :         }
; 922  :         result = binop_type_error(v, w, "*");

  000cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01NBENCBCI@?$CK?$AA@
  000d3	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  000d8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000dd	e8 00 00 00 00	 call	 binop_type_error
  000e2	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN4@PyNumber_M:

; 923  :     }
; 924  :     return result;

  000e7	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN5@PyNumber_M:

; 925  : }

  000ec	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f0	c3		 ret	 0
PyNumber_Multiply ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@LBFCGMPJ@can?8t?5multiply?5sequence?5by?5non?9i@ ; `string'
EXTRN	PyExc_OverflowError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$sequence_repeat DD imagerel sequence_repeat
	DD	imagerel sequence_repeat+148
	DD	imagerel $unwind$sequence_repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sequence_repeat DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0DE@LBFCGMPJ@can?8t?5multiply?5sequence?5by?5non?9i@
CONST	SEGMENT
??_C@_0DE@LBFCGMPJ@can?8t?5multiply?5sequence?5by?5non?9i@ DB 'can''t mul'
	DB	'tiply sequence by non-int of type ''%.200s''', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT sequence_repeat
_TEXT	SEGMENT
count$ = 32
repeatfunc$ = 64
seq$ = 72
n$ = 80
sequence_repeat PROC					; COMDAT

; 894  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 895  :     Py_ssize_t count;
; 896  :     if (PyIndex_Check(n)) {

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR n$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00024	74 48		 je	 SHORT $LN3@sequence_r
  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR n$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00036	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  0003e	74 2e		 je	 SHORT $LN3@sequence_r

; 897  :         count = PyNumber_AsSsize_t(n, PyExc_OverflowError);

  00040	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR n$[rsp]
  0004c	e8 00 00 00 00	 call	 PyNumber_AsSsize_t
  00051	48 89 44 24 20	 mov	 QWORD PTR count$[rsp], rax

; 898  :         if (count == -1 && PyErr_Occurred())

  00056	48 83 7c 24 20
	ff		 cmp	 QWORD PTR count$[rsp], -1
  0005c	75 0e		 jne	 SHORT $LN2@sequence_r
  0005e	e8 00 00 00 00	 call	 PyErr_Occurred
  00063	48 85 c0	 test	 rax, rax
  00066	74 04		 je	 SHORT $LN2@sequence_r

; 899  :             return NULL;

  00068	33 c0		 xor	 eax, eax
  0006a	eb 23		 jmp	 SHORT $LN4@sequence_r
$LN2@sequence_r:

; 900  :     }
; 901  :     else {

  0006c	eb 13		 jmp	 SHORT $LN1@sequence_r
$LN3@sequence_r:

; 902  :         return type_error("can't multiply sequence by "
; 903  :                           "non-int of type '%.200s'", n);

  0006e	48 8b 54 24 50	 mov	 rdx, QWORD PTR n$[rsp]
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DE@LBFCGMPJ@can?8t?5multiply?5sequence?5by?5non?9i@
  0007a	e8 00 00 00 00	 call	 type_error
  0007f	eb 0e		 jmp	 SHORT $LN4@sequence_r
$LN1@sequence_r:

; 904  :     }
; 905  :     return (*repeatfunc)(seq, count);

  00081	48 8b 54 24 20	 mov	 rdx, QWORD PTR count$[rsp]
  00086	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seq$[rsp]
  0008b	ff 54 24 40	 call	 QWORD PTR repeatfunc$[rsp]
$LN4@sequence_r:

; 906  : }

  0008f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00093	c3		 ret	 0
sequence_repeat ENDP
_TEXT	ENDS
PUBLIC	??_C@_02CBLDBPFN@?1?1?$AA@			; `string'
PUBLIC	PyNumber_FloorDivide
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_FloorDivide DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$PyNumber_FloorDivide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_FloorDivide DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_02CBLDBPFN@?1?1?$AA@
CONST	SEGMENT
??_C@_02CBLDBPFN@?1?1?$AA@ DB '//', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_FloorDivide
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_FloorDivide PROC				; COMDAT

; 929  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 930  :     return binary_op(v, w, NB_SLOT(nb_floor_divide), "//");

  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_02CBLDBPFN@?1?1?$AA@
  00015	41 b8 e8 00 00
	00		 mov	 r8d, 232		; 000000e8H
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR w$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00025	e8 00 00 00 00	 call	 binary_op

; 931  : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
PyNumber_FloorDivide ENDP
_TEXT	ENDS
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	PyNumber_TrueDivide
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_TrueDivide DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$PyNumber_TrueDivide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_TrueDivide DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_TrueDivide
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_TrueDivide PROC				; COMDAT

; 935  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 936  :     return binary_op(v, w, NB_SLOT(nb_true_divide), "/");

  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01KMDKNFGN@?1?$AA@
  00015	41 b8 f0 00 00
	00		 mov	 r8d, 240		; 000000f0H
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR w$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00025	e8 00 00 00 00	 call	 binary_op

; 937  : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
PyNumber_TrueDivide ENDP
_TEXT	ENDS
PUBLIC	??_C@_01FGNFDNOH@?$CF?$AA@			; `string'
PUBLIC	PyNumber_Remainder
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Remainder DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$PyNumber_Remainder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Remainder DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_01FGNFDNOH@?$CF?$AA@
CONST	SEGMENT
??_C@_01FGNFDNOH@?$CF?$AA@ DB '%', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Remainder
_TEXT	SEGMENT
v$ = 48
w$ = 56
PyNumber_Remainder PROC					; COMDAT

; 941  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 942  :     return binary_op(v, w, NB_SLOT(nb_remainder), "%");

  0000e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_01FGNFDNOH@?$CF?$AA@
  00015	41 b8 18 00 00
	00		 mov	 r8d, 24
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR w$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  00025	e8 00 00 00 00	 call	 binary_op

; 943  : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
PyNumber_Remainder ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@GLOAMCEF@?$CK?$CK?5or?5pow?$CI?$CJ?$AA@ ; `string'
PUBLIC	PyNumber_Power
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Power DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$PyNumber_Power
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Power DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0M@GLOAMCEF@?$CK?$CK?5or?5pow?$CI?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@GLOAMCEF@?$CK?$CK?5or?5pow?$CI?$CJ?$AA@ DB '** or pow()', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Power
_TEXT	SEGMENT
v$ = 64
w$ = 72
z$ = 80
PyNumber_Power PROC					; COMDAT

; 947  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 948  :     return ternary_op(v, w, z, NB_SLOT(nb_power), "** or pow()");

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0M@GLOAMCEF@?$CK?$CK?5or?5pow?$CI?$CJ?$AA@
  0001a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001f	41 b9 28 00 00
	00		 mov	 r9d, 40			; 00000028H
  00025	4c 8b 44 24 50	 mov	 r8, QWORD PTR z$[rsp]
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00034	e8 00 00 00 00	 call	 ternary_op

; 949  : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
PyNumber_Power ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EE@EIBBFPKJ@unsupported?5operand?5type?$CIs?$CJ?5for?5@ ; `string'
PUBLIC	??_C@_0ED@GPNEMHOA@unsupported?5operand?5type?$CIs?$CJ?5for?5@ ; `string'
EXTRN	_Py_NoneStruct:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$ternary_op DD imagerel ternary_op
	DD	imagerel ternary_op+801
	DD	imagerel $unwind$ternary_op
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ternary_op DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT ??_C@_0EE@EIBBFPKJ@unsupported?5operand?5type?$CIs?$CJ?5for?5@
CONST	SEGMENT
??_C@_0EE@EIBBFPKJ@unsupported?5operand?5type?$CIs?$CJ?5for?5@ DB 'unsupp'
	DB	'orted operand type(s) for pow(): ''%.100s'', ''%.100s'', ''%.'
	DB	'100s''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@GPNEMHOA@unsupported?5operand?5type?$CIs?$CJ?5for?5@
CONST	SEGMENT
??_C@_0ED@GPNEMHOA@unsupported?5operand?5type?$CIs?$CJ?5for?5@ DB 'unsupp'
	DB	'orted operand type(s) for ** or pow(): ''%.100s'' and ''%.100'
	DB	's''', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ternary_op
_TEXT	SEGMENT
x$ = 48
slotz$ = 56
mz$ = 64
mw$ = 72
mv$ = 80
slotv$ = 88
slotw$ = 96
v$ = 128
w$ = 136
z$ = 144
op_slot$ = 152
op_name$ = 160
ternary_op PROC						; COMDAT

; 796  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 797  :     PyNumberMethods *mv, *mw, *mz;
; 798  :     PyObject *x = NULL;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR x$[rsp], 0

; 799  :     ternaryfunc slotv = NULL;

  00021	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR slotv$[rsp], 0

; 800  :     ternaryfunc slotw = NULL;

  0002a	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR slotw$[rsp], 0

; 801  :     ternaryfunc slotz = NULL;

  00033	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR slotz$[rsp], 0

; 802  : 
; 803  :     mv = v->ob_type->tp_as_number;

  0003c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  00044	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00048	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0004f	48 89 44 24 50	 mov	 QWORD PTR mv$[rsp], rax

; 804  :     mw = w->ob_type->tp_as_number;

  00054	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  0005c	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00060	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00067	48 89 44 24 48	 mov	 QWORD PTR mw$[rsp], rax

; 805  :     if (mv != NULL)

  0006c	48 83 7c 24 50
	00		 cmp	 QWORD PTR mv$[rsp], 0
  00072	74 16		 je	 SHORT $LN16@ternary_op

; 806  :         slotv = NB_TERNOP(mv, op_slot);

  00074	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR op_slot$[rsp]
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mv$[rsp]
  00081	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00085	48 89 44 24 58	 mov	 QWORD PTR slotv$[rsp], rax
$LN16@ternary_op:

; 807  :     if (w->ob_type != v->ob_type &&
; 808  :         mw != NULL) {

  0008a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  00092	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  0009a	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0009e	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  000a2	74 33		 je	 SHORT $LN15@ternary_op
  000a4	48 83 7c 24 48
	00		 cmp	 QWORD PTR mw$[rsp], 0
  000aa	74 2b		 je	 SHORT $LN15@ternary_op

; 809  :         slotw = NB_TERNOP(mw, op_slot);

  000ac	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR op_slot$[rsp]
  000b4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR mw$[rsp]
  000b9	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000bd	48 89 44 24 60	 mov	 QWORD PTR slotw$[rsp], rax

; 810  :         if (slotw == slotv)

  000c2	48 8b 44 24 58	 mov	 rax, QWORD PTR slotv$[rsp]
  000c7	48 39 44 24 60	 cmp	 QWORD PTR slotw$[rsp], rax
  000cc	75 09		 jne	 SHORT $LN14@ternary_op

; 811  :             slotw = NULL;

  000ce	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR slotw$[rsp], 0
$LN14@ternary_op:
$LN15@ternary_op:

; 812  :     }
; 813  :     if (slotv) {

  000d7	48 83 7c 24 58
	00		 cmp	 QWORD PTR slotv$[rsp], 0
  000dd	0f 84 b8 00 00
	00		 je	 $LN13@ternary_op

; 814  :         if (slotw && PyType_IsSubtype(w->ob_type, v->ob_type)) {

  000e3	48 83 7c 24 60
	00		 cmp	 QWORD PTR slotw$[rsp], 0
  000e9	74 6d		 je	 SHORT $LN12@ternary_op
  000eb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR v$[rsp]
  000f3	48 8b 50 58	 mov	 rdx, QWORD PTR [rax+88]
  000f7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  000ff	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00103	e8 00 00 00 00	 call	 PyType_IsSubtype
  00108	85 c0		 test	 eax, eax
  0010a	74 4c		 je	 SHORT $LN12@ternary_op

; 815  :             x = slotw(v, w, z);

  0010c	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00114	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR w$[rsp]
  0011c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00124	ff 54 24 60	 call	 QWORD PTR slotw$[rsp]
  00128	48 89 44 24 30	 mov	 QWORD PTR x$[rsp], rax

; 816  :             if (x != Py_NotImplemented)

  0012d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00134	48 39 44 24 30	 cmp	 QWORD PTR x$[rsp], rax
  00139	74 0a		 je	 SHORT $LN11@ternary_op

; 817  :                 return x;

  0013b	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  00140	e9 d7 01 00 00	 jmp	 $LN17@ternary_op
$LN11@ternary_op:

; 818  :             Py_DECREF(x); /* can't do it */

  00145	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  0014a	e8 00 00 00 00	 call	 _Py_DecRef

; 819  :             slotw = NULL;

  0014f	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR slotw$[rsp], 0
$LN12@ternary_op:

; 820  :         }
; 821  :         x = slotv(v, w, z);

  00158	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00160	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR w$[rsp]
  00168	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00170	ff 54 24 58	 call	 QWORD PTR slotv$[rsp]
  00174	48 89 44 24 30	 mov	 QWORD PTR x$[rsp], rax

; 822  :         if (x != Py_NotImplemented)

  00179	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00180	48 39 44 24 30	 cmp	 QWORD PTR x$[rsp], rax
  00185	74 0a		 je	 SHORT $LN10@ternary_op

; 823  :             return x;

  00187	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  0018c	e9 8b 01 00 00	 jmp	 $LN17@ternary_op
$LN10@ternary_op:

; 824  :         Py_DECREF(x); /* can't do it */

  00191	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  00196	e8 00 00 00 00	 call	 _Py_DecRef
$LN13@ternary_op:

; 825  :     }
; 826  :     if (slotw) {

  0019b	48 83 7c 24 60
	00		 cmp	 QWORD PTR slotw$[rsp], 0
  001a1	74 43		 je	 SHORT $LN9@ternary_op

; 827  :         x = slotw(v, w, z);

  001a3	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR z$[rsp]
  001ab	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR w$[rsp]
  001b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  001bb	ff 54 24 60	 call	 QWORD PTR slotw$[rsp]
  001bf	48 89 44 24 30	 mov	 QWORD PTR x$[rsp], rax

; 828  :         if (x != Py_NotImplemented)

  001c4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  001cb	48 39 44 24 30	 cmp	 QWORD PTR x$[rsp], rax
  001d0	74 0a		 je	 SHORT $LN8@ternary_op

; 829  :             return x;

  001d2	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  001d7	e9 40 01 00 00	 jmp	 $LN17@ternary_op
$LN8@ternary_op:

; 830  :         Py_DECREF(x); /* can't do it */

  001dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  001e1	e8 00 00 00 00	 call	 _Py_DecRef
$LN9@ternary_op:

; 831  :     }
; 832  :     mz = z->ob_type->tp_as_number;

  001e6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  001ee	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001f2	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  001f9	48 89 44 24 40	 mov	 QWORD PTR mz$[rsp], rax

; 833  :     if (mz != NULL) {

  001fe	48 83 7c 24 40
	00		 cmp	 QWORD PTR mz$[rsp], 0
  00204	0f 84 82 00 00
	00		 je	 $LN7@ternary_op

; 834  :         slotz = NB_TERNOP(mz, op_slot);

  0020a	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR op_slot$[rsp]
  00212	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mz$[rsp]
  00217	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0021b	48 89 44 24 38	 mov	 QWORD PTR slotz$[rsp], rax

; 835  :         if (slotz == slotv || slotz == slotw)

  00220	48 8b 44 24 58	 mov	 rax, QWORD PTR slotv$[rsp]
  00225	48 39 44 24 38	 cmp	 QWORD PTR slotz$[rsp], rax
  0022a	74 0c		 je	 SHORT $LN5@ternary_op
  0022c	48 8b 44 24 60	 mov	 rax, QWORD PTR slotw$[rsp]
  00231	48 39 44 24 38	 cmp	 QWORD PTR slotz$[rsp], rax
  00236	75 09		 jne	 SHORT $LN6@ternary_op
$LN5@ternary_op:

; 836  :             slotz = NULL;

  00238	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR slotz$[rsp], 0
$LN6@ternary_op:

; 837  :         if (slotz) {

  00241	48 83 7c 24 38
	00		 cmp	 QWORD PTR slotz$[rsp], 0
  00247	74 43		 je	 SHORT $LN4@ternary_op

; 838  :             x = slotz(v, w, z);

  00249	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00251	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR w$[rsp]
  00259	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  00261	ff 54 24 38	 call	 QWORD PTR slotz$[rsp]
  00265	48 89 44 24 30	 mov	 QWORD PTR x$[rsp], rax

; 839  :             if (x != Py_NotImplemented)

  0026a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00271	48 39 44 24 30	 cmp	 QWORD PTR x$[rsp], rax
  00276	74 0a		 je	 SHORT $LN3@ternary_op

; 840  :                 return x;

  00278	48 8b 44 24 30	 mov	 rax, QWORD PTR x$[rsp]
  0027d	e9 9a 00 00 00	 jmp	 $LN17@ternary_op
$LN3@ternary_op:

; 841  :             Py_DECREF(x); /* can't do it */

  00282	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$[rsp]
  00287	e8 00 00 00 00	 call	 _Py_DecRef
$LN4@ternary_op:
$LN7@ternary_op:

; 842  :         }
; 843  :     }
; 844  : 
; 845  :     if (z == Py_None)

  0028c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
  00293	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR z$[rsp], rax
  0029b	75 35		 jne	 SHORT $LN2@ternary_op

; 846  :         PyErr_Format(
; 847  :             PyExc_TypeError,
; 848  :             "unsupported operand type(s) for ** or pow(): "
; 849  :             "'%.100s' and '%.100s'",
; 850  :             v->ob_type->tp_name,
; 851  :             w->ob_type->tp_name);

  0029d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR w$[rsp]
  002a5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002a9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR v$[rsp]
  002b1	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  002b5	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  002b9	4c 8b 41 70	 mov	 r8, QWORD PTR [rcx+112]
  002bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@GPNEMHOA@unsupported?5operand?5type?$CIs?$CJ?5for?5@
  002c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  002cb	e8 00 00 00 00	 call	 PyErr_Format

; 852  :     else

  002d0	eb 48		 jmp	 SHORT $LN1@ternary_op
$LN2@ternary_op:

; 853  :         PyErr_Format(
; 854  :             PyExc_TypeError,
; 855  :             "unsupported operand type(s) for pow(): "
; 856  :             "'%.100s', '%.100s', '%.100s'",
; 857  :             v->ob_type->tp_name,
; 858  :             w->ob_type->tp_name,
; 859  :             z->ob_type->tp_name);

  002d2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002da	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  002de	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR w$[rsp]
  002e6	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  002ea	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR v$[rsp]
  002f2	48 8b 52 58	 mov	 rdx, QWORD PTR [rdx+88]
  002f6	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  002fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ff	4c 8b 49 70	 mov	 r9, QWORD PTR [rcx+112]
  00303	4c 8b 42 70	 mov	 r8, QWORD PTR [rdx+112]
  00307	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EE@EIBBFPKJ@unsupported?5operand?5type?$CIs?$CJ?5for?5@
  0030e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00315	e8 00 00 00 00	 call	 PyErr_Format
$LN1@ternary_op:

; 860  :     return NULL;

  0031a	33 c0		 xor	 eax, eax
$LN17@ternary_op:

; 861  : }

  0031c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00320	c3		 ret	 0
ternary_op ENDP
_TEXT	ENDS
PUBLIC	??_C@_02DHLNPPGH@?$HM?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceOr
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceOr DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$PyNumber_InPlaceOr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceOr DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_02DHLNPPGH@?$HM?$DN?$AA@
CONST	SEGMENT
??_C@_02DHLNPPGH@?$HM?$DN?$AA@ DB '|=', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlaceOr
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceOr PROC					; COMDAT

; 1002 : INPLACE_BINOP(PyNumber_InPlaceOr, nb_inplace_or, nb_or, "|=")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02DHLNPPGH@?$HM?$DN?$AA@
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	41 b9 78 00 00
	00		 mov	 r9d, 120		; 00000078H
  00020	41 b8 e0 00 00
	00		 mov	 r8d, 224		; 000000e0H
  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 binary_iop
  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
PyNumber_InPlaceOr ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$binary_iop DD imagerel binary_iop
	DD	imagerel binary_iop+110
	DD	imagerel $unwind$binary_iop
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binary_iop DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT binary_iop
_TEXT	SEGMENT
result$ = 32
v$ = 64
w$ = 72
iop_slot$ = 80
op_slot$ = 88
op_name$ = 96
binary_iop PROC						; COMDAT

; 987  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 988  :     PyObject *result = binary_iop1(v, w, iop_slot, op_slot);

  00018	44 8b 4c 24 58	 mov	 r9d, DWORD PTR op_slot$[rsp]
  0001d	44 8b 44 24 50	 mov	 r8d, DWORD PTR iop_slot$[rsp]
  00022	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0002c	e8 00 00 00 00	 call	 binary_iop1
  00031	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 989  :     if (result == Py_NotImplemented) {

  00036	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0003d	48 39 44 24 20	 cmp	 QWORD PTR result$[rsp], rax
  00042	75 20		 jne	 SHORT $LN1@binary_iop

; 990  :         Py_DECREF(result);

  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00049	e8 00 00 00 00	 call	 _Py_DecRef

; 991  :         return binop_type_error(v, w, op_name);

  0004e	4c 8b 44 24 60	 mov	 r8, QWORD PTR op_name$[rsp]
  00053	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0005d	e8 00 00 00 00	 call	 binop_type_error
  00062	eb 05		 jmp	 SHORT $LN2@binary_iop
$LN1@binary_iop:

; 992  :     }
; 993  :     return result;

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN2@binary_iop:

; 994  : }

  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	c3		 ret	 0
binary_iop ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$binary_iop1 DD imagerel binary_iop1
	DD	imagerel binary_iop1+155
	DD	imagerel $unwind$binary_iop1
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$binary_iop1 DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT binary_iop1
_TEXT	SEGMENT
mv$ = 32
slot$21103 = 40
x$21107 = 48
v$ = 80
w$ = 88
iop_slot$ = 96
op_slot$ = 104
binary_iop1 PROC					; COMDAT

; 969  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 970  :     PyNumberMethods *mv = v->ob_type->tp_as_number;

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00028	48 89 44 24 20	 mov	 QWORD PTR mv$[rsp], rax

; 971  :     if (mv != NULL) {

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR mv$[rsp], 0
  00033	74 4d		 je	 SHORT $LN3@binary_iop@2

; 972  :         binaryfunc slot = NB_BINOP(mv, iop_slot);

  00035	48 63 44 24 60	 movsxd	 rax, DWORD PTR iop_slot$[rsp]
  0003a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR mv$[rsp]
  0003f	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00043	48 89 44 24 28	 mov	 QWORD PTR slot$21103[rsp], rax

; 973  :         if (slot) {

  00048	48 83 7c 24 28
	00		 cmp	 QWORD PTR slot$21103[rsp], 0
  0004e	74 32		 je	 SHORT $LN2@binary_iop@2

; 974  :             PyObject *x = (slot)(v, w);

  00050	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  00055	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  0005a	ff 54 24 28	 call	 QWORD PTR slot$21103[rsp]
  0005e	48 89 44 24 30	 mov	 QWORD PTR x$21107[rsp], rax

; 975  :             if (x != Py_NotImplemented) {

  00063	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0006a	48 39 44 24 30	 cmp	 QWORD PTR x$21107[rsp], rax
  0006f	74 07		 je	 SHORT $LN1@binary_iop@2

; 976  :                 return x;

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR x$21107[rsp]
  00076	eb 1e		 jmp	 SHORT $LN4@binary_iop@2
$LN1@binary_iop@2:

; 977  :             }
; 978  :             Py_DECREF(x);

  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR x$21107[rsp]
  0007d	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@binary_iop@2:
$LN3@binary_iop@2:

; 979  :         }
; 980  :     }
; 981  :     return binary_op1(v, w, op_slot);

  00082	44 8b 44 24 68	 mov	 r8d, DWORD PTR op_slot$[rsp]
  00087	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  0008c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00091	e8 00 00 00 00	 call	 binary_op1
$LN4@binary_iop@2:

; 982  : }

  00096	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009a	c3		 ret	 0
binary_iop1 ENDP
_TEXT	ENDS
PUBLIC	??_C@_02MHEGNOJ@?$FO?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceXor
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceXor DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$PyNumber_InPlaceXor
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceXor DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_02MHEGNOJ@?$FO?$DN?$AA@
CONST	SEGMENT
??_C@_02MHEGNOJ@?$FO?$DN?$AA@ DB '^=', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlaceXor
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceXor PROC				; COMDAT

; 1003 : INPLACE_BINOP(PyNumber_InPlaceXor, nb_inplace_xor, nb_xor, "^=")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02MHEGNOJ@?$FO?$DN?$AA@
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	41 b9 70 00 00
	00		 mov	 r9d, 112		; 00000070H
  00020	41 b8 d8 00 00
	00		 mov	 r8d, 216		; 000000d8H
  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 binary_iop
  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
PyNumber_InPlaceXor ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FGJGFEAB@?$CG?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceAnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceAnd DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$PyNumber_InPlaceAnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceAnd DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_02FGJGFEAB@?$CG?$DN?$AA@
CONST	SEGMENT
??_C@_02FGJGFEAB@?$CG?$DN?$AA@ DB '&=', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlaceAnd
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceAnd PROC				; COMDAT

; 1004 : INPLACE_BINOP(PyNumber_InPlaceAnd, nb_inplace_and, nb_and, "&=")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02FGJGFEAB@?$CG?$DN?$AA@
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	41 b9 68 00 00
	00		 mov	 r9d, 104		; 00000068H
  00020	41 b8 d0 00 00
	00		 mov	 r8d, 208		; 000000d0H
  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 binary_iop
  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
PyNumber_InPlaceAnd ENDP
_TEXT	ENDS
PUBLIC	??_C@_03CDNPDDLA@?$DM?$DM?$DN?$AA@		; `string'
PUBLIC	PyNumber_InPlaceLshift
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceLshift DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$PyNumber_InPlaceLshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceLshift DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_03CDNPDDLA@?$DM?$DM?$DN?$AA@
CONST	SEGMENT
??_C@_03CDNPDDLA@?$DM?$DM?$DN?$AA@ DB '<<=', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlaceLshift
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceLshift PROC				; COMDAT

; 1005 : INPLACE_BINOP(PyNumber_InPlaceLshift, nb_inplace_lshift, nb_lshift, "<<=")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03CDNPDDLA@?$DM?$DM?$DN?$AA@
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	41 b9 58 00 00
	00		 mov	 r9d, 88			; 00000058H
  00020	41 b8 c0 00 00
	00		 mov	 r8d, 192		; 000000c0H
  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 binary_iop
  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
PyNumber_InPlaceLshift ENDP
_TEXT	ENDS
PUBLIC	??_C@_03IKFCCPFF@?$DO?$DO?$DN?$AA@		; `string'
PUBLIC	PyNumber_InPlaceRshift
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceRshift DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$PyNumber_InPlaceRshift
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceRshift DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_03IKFCCPFF@?$DO?$DO?$DN?$AA@
CONST	SEGMENT
??_C@_03IKFCCPFF@?$DO?$DO?$DN?$AA@ DB '>>=', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlaceRshift
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceRshift PROC				; COMDAT

; 1006 : INPLACE_BINOP(PyNumber_InPlaceRshift, nb_inplace_rshift, nb_rshift, ">>=")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03IKFCCPFF@?$DO?$DO?$DN?$AA@
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	41 b9 60 00 00
	00		 mov	 r9d, 96			; 00000060H
  00020	41 b8 c8 00 00
	00		 mov	 r8d, 200		; 000000c8H
  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 binary_iop
  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
PyNumber_InPlaceRshift ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FKMDLLOA@?9?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceSubtract
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceSubtract DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$PyNumber_InPlaceSubtract
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceSubtract DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_02FKMDLLOA@?9?$DN?$AA@
CONST	SEGMENT
??_C@_02FKMDLLOA@?9?$DN?$AA@ DB '-=', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlaceSubtract
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceSubtract PROC				; COMDAT

; 1007 : INPLACE_BINOP(PyNumber_InPlaceSubtract, nb_inplace_subtract, nb_subtract, "-=")

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02FKMDLLOA@?9?$DN?$AA@
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	41 b9 08 00 00
	00		 mov	 r9d, 8
  00020	41 b8 a0 00 00
	00		 mov	 r8d, 160		; 000000a0H
  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 binary_iop
  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
PyNumber_InPlaceSubtract ENDP
_TEXT	ENDS
PUBLIC	??_C@_03HPBDNGOI@?1?1?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceFloorDivide
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceFloorDivide DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$PyNumber_InPlaceFloorDivide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceFloorDivide DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_03HPBDNGOI@?1?1?$DN?$AA@
CONST	SEGMENT
??_C@_03HPBDNGOI@?1?1?$DN?$AA@ DB '//=', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlaceFloorDivide
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceFloorDivide PROC			; COMDAT

; 1011 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1012 :     return binary_iop(v, w, NB_SLOT(nb_inplace_floor_divide),
; 1013 :                       NB_SLOT(nb_floor_divide), "//=");

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03HPBDNGOI@?1?1?$DN?$AA@
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	41 b9 e8 00 00
	00		 mov	 r9d, 232		; 000000e8H
  00020	41 b8 f8 00 00
	00		 mov	 r8d, 248		; 000000f8H
  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 binary_iop

; 1014 : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
PyNumber_InPlaceFloorDivide ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FJEHGPIO@?1?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceTrueDivide
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceTrueDivide DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$PyNumber_InPlaceTrueDivide
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceTrueDivide DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_02FJEHGPIO@?1?$DN?$AA@
CONST	SEGMENT
??_C@_02FJEHGPIO@?1?$DN?$AA@ DB '/=', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlaceTrueDivide
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceTrueDivide PROC				; COMDAT

; 1018 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1019 :     return binary_iop(v, w, NB_SLOT(nb_inplace_true_divide),
; 1020 :                       NB_SLOT(nb_true_divide), "/=");

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02FJEHGPIO@?1?$DN?$AA@
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	41 b9 f0 00 00
	00		 mov	 r9d, 240		; 000000f0H
  00020	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 binary_iop

; 1021 : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
PyNumber_InPlaceTrueDivide ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FOEOMHFC@?$CL?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceAdd
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceAdd DD imagerel $LN7
	DD	imagerel $LN7+206
	DD	imagerel $unwind$PyNumber_InPlaceAdd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceAdd DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_02FOEOMHFC@?$CL?$DN?$AA@
CONST	SEGMENT
??_C@_02FOEOMHFC@?$CL?$DN?$AA@ DB '+=', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlaceAdd
_TEXT	SEGMENT
result$ = 32
m$21235 = 40
f$21239 = 48
v$ = 80
w$ = 88
PyNumber_InPlaceAdd PROC				; COMDAT

; 1025 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1026 :     PyObject *result = binary_iop1(v, w, NB_SLOT(nb_inplace_add),
; 1027 :                                    NB_SLOT(nb_add));

  0000e	45 33 c9	 xor	 r9d, r9d
  00011	41 b8 98 00 00
	00		 mov	 r8d, 152		; 00000098H
  00017	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  0001c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00021	e8 00 00 00 00	 call	 binary_iop1
  00026	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1028 :     if (result == Py_NotImplemented) {

  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00032	48 39 44 24 20	 cmp	 QWORD PTR result$[rsp], rax
  00037	0f 85 87 00 00
	00		 jne	 $LN4@PyNumber_I

; 1029 :         PySequenceMethods *m = v->ob_type->tp_as_sequence;

  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  00042	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00046	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004d	48 89 44 24 28	 mov	 QWORD PTR m$21235[rsp], rax

; 1030 :         Py_DECREF(result);

  00052	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00057	e8 00 00 00 00	 call	 _Py_DecRef

; 1031 :         if (m != NULL) {

  0005c	48 83 7c 24 28
	00		 cmp	 QWORD PTR m$21235[rsp], 0
  00062	74 45		 je	 SHORT $LN3@PyNumber_I

; 1032 :             binaryfunc f = NULL;

  00064	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR f$21239[rsp], 0

; 1033 :             f = m->sq_inplace_concat;

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR m$21235[rsp]
  00072	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00076	48 89 44 24 30	 mov	 QWORD PTR f$21239[rsp], rax

; 1034 :             if (f == NULL)

  0007b	48 83 7c 24 30
	00		 cmp	 QWORD PTR f$21239[rsp], 0
  00081	75 0e		 jne	 SHORT $LN2@PyNumber_I

; 1035 :                 f = m->sq_concat;

  00083	48 8b 44 24 28	 mov	 rax, QWORD PTR m$21235[rsp]
  00088	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0008c	48 89 44 24 30	 mov	 QWORD PTR f$21239[rsp], rax
$LN2@PyNumber_I:

; 1036 :             if (f != NULL)

  00091	48 83 7c 24 30
	00		 cmp	 QWORD PTR f$21239[rsp], 0
  00097	74 10		 je	 SHORT $LN1@PyNumber_I

; 1037 :                 return (*f)(v, w);

  00099	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000a3	ff 54 24 30	 call	 QWORD PTR f$21239[rsp]
  000a7	eb 20		 jmp	 SHORT $LN5@PyNumber_I
$LN1@PyNumber_I:
$LN3@PyNumber_I:

; 1038 :         }
; 1039 :         result = binop_type_error(v, w, "+=");

  000a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02FOEOMHFC@?$CL?$DN?$AA@
  000b0	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  000b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000ba	e8 00 00 00 00	 call	 binop_type_error
  000bf	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN4@PyNumber_I:

; 1040 :     }
; 1041 :     return result;

  000c4	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN5@PyNumber_I:

; 1042 : }

  000c9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cd	c3		 ret	 0
PyNumber_InPlaceAdd ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FPIMKNGF@?$CK?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceMultiply
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceMultiply DD imagerel $LN10
	DD	imagerel $LN10+284
	DD	imagerel $unwind$PyNumber_InPlaceMultiply
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceMultiply DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_02FPIMKNGF@?$CK?$DN?$AA@
CONST	SEGMENT
??_C@_02FPIMKNGF@?$CK?$DN?$AA@ DB '*=', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlaceMultiply
_TEXT	SEGMENT
result$ = 32
mw$21262 = 40
mv$21261 = 48
f$21259 = 56
v$ = 80
w$ = 88
PyNumber_InPlaceMultiply PROC				; COMDAT

; 1046 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1047 :     PyObject *result = binary_iop1(v, w, NB_SLOT(nb_inplace_multiply),
; 1048 :                                    NB_SLOT(nb_multiply));

  0000e	41 b9 10 00 00
	00		 mov	 r9d, 16
  00014	41 b8 a8 00 00
	00		 mov	 r8d, 168		; 000000a8H
  0001a	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00024	e8 00 00 00 00	 call	 binary_iop1
  00029	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1049 :     if (result == Py_NotImplemented) {

  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  00035	48 39 44 24 20	 cmp	 QWORD PTR result$[rsp], rax
  0003a	0f 85 d2 00 00
	00		 jne	 $LN7@PyNumber_I@2

; 1050 :         ssizeargfunc f = NULL;

  00040	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR f$21259[rsp], 0

; 1051 :         PySequenceMethods *mv = v->ob_type->tp_as_sequence;

  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0004e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00052	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00059	48 89 44 24 30	 mov	 QWORD PTR mv$21261[rsp], rax

; 1052 :         PySequenceMethods *mw = w->ob_type->tp_as_sequence;

  0005e	48 8b 44 24 58	 mov	 rax, QWORD PTR w$[rsp]
  00063	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00067	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0006e	48 89 44 24 28	 mov	 QWORD PTR mw$21262[rsp], rax

; 1053 :         Py_DECREF(result);

  00073	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00078	e8 00 00 00 00	 call	 _Py_DecRef

; 1054 :         if (mv != NULL) {

  0007d	48 83 7c 24 30
	00		 cmp	 QWORD PTR mv$21261[rsp], 0
  00083	74 44		 je	 SHORT $LN6@PyNumber_I@2

; 1055 :             f = mv->sq_inplace_repeat;

  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$21261[rsp]
  0008a	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0008e	48 89 44 24 38	 mov	 QWORD PTR f$21259[rsp], rax

; 1056 :             if (f == NULL)

  00093	48 83 7c 24 38
	00		 cmp	 QWORD PTR f$21259[rsp], 0
  00099	75 0e		 jne	 SHORT $LN5@PyNumber_I@2

; 1057 :                 f = mv->sq_repeat;

  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR mv$21261[rsp]
  000a0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000a4	48 89 44 24 38	 mov	 QWORD PTR f$21259[rsp], rax
$LN5@PyNumber_I@2:

; 1058 :             if (f != NULL)

  000a9	48 83 7c 24 38
	00		 cmp	 QWORD PTR f$21259[rsp], 0
  000af	74 16		 je	 SHORT $LN4@PyNumber_I@2

; 1059 :                 return sequence_repeat(f, v, w);

  000b1	4c 8b 44 24 58	 mov	 r8, QWORD PTR w$[rsp]
  000b6	48 8b 54 24 50	 mov	 rdx, QWORD PTR v$[rsp]
  000bb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$21259[rsp]
  000c0	e8 00 00 00 00	 call	 sequence_repeat
  000c5	eb 50		 jmp	 SHORT $LN8@PyNumber_I@2
$LN4@PyNumber_I@2:

; 1060 :         }
; 1061 :         else if (mw != NULL) {

  000c7	eb 2e		 jmp	 SHORT $LN3@PyNumber_I@2
$LN6@PyNumber_I@2:
  000c9	48 83 7c 24 28
	00		 cmp	 QWORD PTR mw$21262[rsp], 0
  000cf	74 26		 je	 SHORT $LN2@PyNumber_I@2

; 1062 :             /* Note that the right hand operand should not be
; 1063 :              * mutated in this case so sq_inplace_repeat is not
; 1064 :              * used. */
; 1065 :             if (mw->sq_repeat)

  000d1	48 8b 44 24 28	 mov	 rax, QWORD PTR mw$21262[rsp]
  000d6	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000db	74 1a		 je	 SHORT $LN1@PyNumber_I@2

; 1066 :                 return sequence_repeat(mw->sq_repeat, w, v);

  000dd	4c 8b 44 24 50	 mov	 r8, QWORD PTR v$[rsp]
  000e2	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  000e7	48 8b 44 24 28	 mov	 rax, QWORD PTR mw$21262[rsp]
  000ec	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000f0	e8 00 00 00 00	 call	 sequence_repeat
  000f5	eb 20		 jmp	 SHORT $LN8@PyNumber_I@2
$LN1@PyNumber_I@2:
$LN2@PyNumber_I@2:
$LN3@PyNumber_I@2:

; 1067 :         }
; 1068 :         result = binop_type_error(v, w, "*=");

  000f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_02FPIMKNGF@?$CK?$DN?$AA@
  000fe	48 8b 54 24 58	 mov	 rdx, QWORD PTR w$[rsp]
  00103	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00108	e8 00 00 00 00	 call	 binop_type_error
  0010d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax
$LN7@PyNumber_I@2:

; 1069 :     }
; 1070 :     return result;

  00112	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN8@PyNumber_I@2:

; 1071 : }

  00117	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011b	c3		 ret	 0
PyNumber_InPlaceMultiply ENDP
_TEXT	ENDS
PUBLIC	??_C@_02FENAOKFI@?$CF?$DN?$AA@			; `string'
PUBLIC	PyNumber_InPlaceRemainder
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlaceRemainder DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$PyNumber_InPlaceRemainder
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlaceRemainder DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_02FENAOKFI@?$CF?$DN?$AA@
CONST	SEGMENT
??_C@_02FENAOKFI@?$CF?$DN?$AA@ DB '%=', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlaceRemainder
_TEXT	SEGMENT
v$ = 64
w$ = 72
PyNumber_InPlaceRemainder PROC				; COMDAT

; 1075 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1076 :     return binary_iop(v, w, NB_SLOT(nb_inplace_remainder),
; 1077 :                             NB_SLOT(nb_remainder), "%=");

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_02FENAOKFI@?$CF?$DN?$AA@
  00015	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0001a	41 b9 18 00 00
	00		 mov	 r9d, 24
  00020	41 b8 b0 00 00
	00		 mov	 r8d, 176		; 000000b0H
  00026	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00030	e8 00 00 00 00	 call	 binary_iop

; 1078 : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
PyNumber_InPlaceRemainder ENDP
_TEXT	ENDS
PUBLIC	??_C@_03EOAGOEDB@?$CK?$CK?$DN?$AA@		; `string'
PUBLIC	PyNumber_InPlacePower
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_InPlacePower DD imagerel $LN5
	DD	imagerel $LN5+149
	DD	imagerel $unwind$PyNumber_InPlacePower
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_InPlacePower DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_03EOAGOEDB@?$CK?$CK?$DN?$AA@
CONST	SEGMENT
??_C@_03EOAGOEDB@?$CK?$CK?$DN?$AA@ DB '**=', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_InPlacePower
_TEXT	SEGMENT
v$ = 64
w$ = 72
z$ = 80
PyNumber_InPlacePower PROC				; COMDAT

; 1082 : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1083 :     if (v->ob_type->tp_as_number &&
; 1084 :         v->ob_type->tp_as_number->nb_inplace_power != NULL) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00024	74 44		 je	 SHORT $LN2@PyNumber_I@3
  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00036	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  0003e	74 2a		 je	 SHORT $LN2@PyNumber_I@3

; 1085 :         return ternary_op(v, w, z, NB_SLOT(nb_inplace_power), "**=");

  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03EOAGOEDB@?$CK?$CK?$DN?$AA@
  00047	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004c	41 b9 b8 00 00
	00		 mov	 r9d, 184		; 000000b8H
  00052	4c 8b 44 24 50	 mov	 r8, QWORD PTR z$[rsp]
  00057	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00061	e8 00 00 00 00	 call	 ternary_op
  00066	eb 28		 jmp	 SHORT $LN3@PyNumber_I@3

; 1086 :     }
; 1087 :     else {

  00068	eb 26		 jmp	 SHORT $LN1@PyNumber_I@3
$LN2@PyNumber_I@3:

; 1088 :         return ternary_op(v, w, z, NB_SLOT(nb_power), "**=");

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_03EOAGOEDB@?$CK?$CK?$DN?$AA@
  00071	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00076	41 b9 28 00 00
	00		 mov	 r9d, 40			; 00000028H
  0007c	4c 8b 44 24 50	 mov	 r8, QWORD PTR z$[rsp]
  00081	48 8b 54 24 48	 mov	 rdx, QWORD PTR w$[rsp]
  00086	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0008b	e8 00 00 00 00	 call	 ternary_op
$LN1@PyNumber_I@3:
$LN3@PyNumber_I@3:

; 1089 :     }
; 1090 : }

  00090	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00094	c3		 ret	 0
PyNumber_InPlacePower ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@HHCHINIE@bad?5operand?5type?5for?5unary?5?9?3?5?8?$CF@ ; `string'
PUBLIC	PyNumber_Negative
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Negative DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$PyNumber_Negative
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Negative DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CH@HHCHINIE@bad?5operand?5type?5for?5unary?5?9?3?5?8?$CF@
CONST	SEGMENT
??_C@_0CH@HHCHINIE@bad?5operand?5type?5for?5unary?5?9?3?5?8?$CF@ DB 'bad '
	DB	'operand type for unary -: ''%.200s''', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Negative
_TEXT	SEGMENT
m$ = 32
o$ = 64
PyNumber_Negative PROC					; COMDAT

; 1097 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1098 :     PyNumberMethods *m;
; 1099 : 
; 1100 :     if (o == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN2@PyNumber_N

; 1101 :         return null_error();

  00011	e8 00 00 00 00	 call	 null_error
  00016	eb 49		 jmp	 SHORT $LN3@PyNumber_N
$LN2@PyNumber_N:

; 1102 :     m = o->ob_type->tp_as_number;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00028	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1103 :     if (m && m->nb_negative)

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00033	74 1b		 je	 SHORT $LN1@PyNumber_N
  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0003a	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0003f	74 0f		 je	 SHORT $LN1@PyNumber_N

; 1104 :         return (*m->nb_negative)(o);

  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0004b	ff 50 30	 call	 QWORD PTR [rax+48]
  0004e	eb 11		 jmp	 SHORT $LN3@PyNumber_N
$LN1@PyNumber_N:

; 1105 : 
; 1106 :     return type_error("bad operand type for unary -: '%.200s'", o);

  00050	48 8b 54 24 40	 mov	 rdx, QWORD PTR o$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@HHCHINIE@bad?5operand?5type?5for?5unary?5?9?3?5?8?$CF@
  0005c	e8 00 00 00 00	 call	 type_error
$LN3@PyNumber_N:

; 1107 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
PyNumber_Negative ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@JIBKCIGE@bad?5operand?5type?5for?5unary?5?$CL?3?5?8?$CF@ ; `string'
PUBLIC	PyNumber_Positive
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Positive DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$PyNumber_Positive
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Positive DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CH@JIBKCIGE@bad?5operand?5type?5for?5unary?5?$CL?3?5?8?$CF@
CONST	SEGMENT
??_C@_0CH@JIBKCIGE@bad?5operand?5type?5for?5unary?5?$CL?3?5?8?$CF@ DB 'ba'
	DB	'd operand type for unary +: ''%.200s''', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Positive
_TEXT	SEGMENT
m$ = 32
o$ = 64
PyNumber_Positive PROC					; COMDAT

; 1111 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1112 :     PyNumberMethods *m;
; 1113 : 
; 1114 :     if (o == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN2@PyNumber_P

; 1115 :         return null_error();

  00011	e8 00 00 00 00	 call	 null_error
  00016	eb 49		 jmp	 SHORT $LN3@PyNumber_P
$LN2@PyNumber_P:

; 1116 :     m = o->ob_type->tp_as_number;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00028	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1117 :     if (m && m->nb_positive)

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00033	74 1b		 je	 SHORT $LN1@PyNumber_P
  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0003a	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0003f	74 0f		 je	 SHORT $LN1@PyNumber_P

; 1118 :         return (*m->nb_positive)(o);

  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0004b	ff 50 38	 call	 QWORD PTR [rax+56]
  0004e	eb 11		 jmp	 SHORT $LN3@PyNumber_P
$LN1@PyNumber_P:

; 1119 : 
; 1120 :     return type_error("bad operand type for unary +: '%.200s'", o);

  00050	48 8b 54 24 40	 mov	 rdx, QWORD PTR o$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@JIBKCIGE@bad?5operand?5type?5for?5unary?5?$CL?3?5?8?$CF@
  0005c	e8 00 00 00 00	 call	 type_error
$LN3@PyNumber_P:

; 1121 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
PyNumber_Positive ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CH@DMMCAFHI@bad?5operand?5type?5for?5unary?5?$HO?3?5?8?$CF@ ; `string'
PUBLIC	PyNumber_Invert
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Invert DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$PyNumber_Invert
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Invert DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CH@DMMCAFHI@bad?5operand?5type?5for?5unary?5?$HO?3?5?8?$CF@
CONST	SEGMENT
??_C@_0CH@DMMCAFHI@bad?5operand?5type?5for?5unary?5?$HO?3?5?8?$CF@ DB 'ba'
	DB	'd operand type for unary ~: ''%.200s''', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Invert
_TEXT	SEGMENT
m$ = 32
o$ = 64
PyNumber_Invert PROC					; COMDAT

; 1125 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1126 :     PyNumberMethods *m;
; 1127 : 
; 1128 :     if (o == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN2@PyNumber_I@4

; 1129 :         return null_error();

  00011	e8 00 00 00 00	 call	 null_error
  00016	eb 49		 jmp	 SHORT $LN3@PyNumber_I@4
$LN2@PyNumber_I@4:

; 1130 :     m = o->ob_type->tp_as_number;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00028	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1131 :     if (m && m->nb_invert)

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00033	74 1b		 je	 SHORT $LN1@PyNumber_I@4
  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0003a	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  0003f	74 0f		 je	 SHORT $LN1@PyNumber_I@4

; 1132 :         return (*m->nb_invert)(o);

  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0004b	ff 50 50	 call	 QWORD PTR [rax+80]
  0004e	eb 11		 jmp	 SHORT $LN3@PyNumber_I@4
$LN1@PyNumber_I@4:

; 1133 : 
; 1134 :     return type_error("bad operand type for unary ~: '%.200s'", o);

  00050	48 8b 54 24 40	 mov	 rdx, QWORD PTR o$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@DMMCAFHI@bad?5operand?5type?5for?5unary?5?$HO?3?5?8?$CF@
  0005c	e8 00 00 00 00	 call	 type_error
$LN3@PyNumber_I@4:

; 1135 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
PyNumber_Invert ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@MBAPCHJJ@bad?5operand?5type?5for?5abs?$CI?$CJ?3?5?8?$CF?42@ ; `string'
PUBLIC	PyNumber_Absolute
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Absolute DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$PyNumber_Absolute
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Absolute DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CF@MBAPCHJJ@bad?5operand?5type?5for?5abs?$CI?$CJ?3?5?8?$CF?42@
CONST	SEGMENT
??_C@_0CF@MBAPCHJJ@bad?5operand?5type?5for?5abs?$CI?$CJ?3?5?8?$CF?42@ DB 'b'
	DB	'ad operand type for abs(): ''%.200s''', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Absolute
_TEXT	SEGMENT
m$ = 32
o$ = 64
PyNumber_Absolute PROC					; COMDAT

; 1139 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1140 :     PyNumberMethods *m;
; 1141 : 
; 1142 :     if (o == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN2@PyNumber_A@2

; 1143 :         return null_error();

  00011	e8 00 00 00 00	 call	 null_error
  00016	eb 49		 jmp	 SHORT $LN3@PyNumber_A@2
$LN2@PyNumber_A@2:

; 1144 :     m = o->ob_type->tp_as_number;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  0001d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00021	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00028	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1145 :     if (m && m->nb_absolute)

  0002d	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00033	74 1b		 je	 SHORT $LN1@PyNumber_A@2
  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0003a	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  0003f	74 0f		 je	 SHORT $LN1@PyNumber_A@2

; 1146 :         return m->nb_absolute(o);

  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0004b	ff 50 40	 call	 QWORD PTR [rax+64]
  0004e	eb 11		 jmp	 SHORT $LN3@PyNumber_A@2
$LN1@PyNumber_A@2:

; 1147 : 
; 1148 :     return type_error("bad operand type for abs(): '%.200s'", o);

  00050	48 8b 54 24 40	 mov	 rdx, QWORD PTR o$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@MBAPCHJJ@bad?5operand?5type?5for?5abs?$CI?$CJ?3?5?8?$CF?42@
  0005c	e8 00 00 00 00	 call	 type_error
$LN3@PyNumber_A@2:

; 1149 : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
PyNumber_Absolute ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CJ@FIKGDNGA@__index__?5returned?5non?9int?5?$CItype@ ; `string'
PUBLIC	??_C@_0DE@GKPKFBFD@?8?$CF?4200s?8?5object?5cannot?5be?5interp@ ; `string'
PUBLIC	PyNumber_Index
EXTRN	PyLong_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Index DD imagerel $LN10
	DD	imagerel $LN10+309
	DD	imagerel $unwind$PyNumber_Index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Index DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CJ@FIKGDNGA@__index__?5returned?5non?9int?5?$CItype@
CONST	SEGMENT
??_C@_0CJ@FIKGDNGA@__index__?5returned?5non?9int?5?$CItype@ DB '__index__'
	DB	' returned non-int (type %.200s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@GKPKFBFD@?8?$CF?4200s?8?5object?5cannot?5be?5interp@
CONST	SEGMENT
??_C@_0DE@GKPKFBFD@?8?$CF?4200s?8?5object?5cannot?5be?5interp@ DB '''%.20'
	DB	'0s'' object cannot be interpreted as an integer', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Index
_TEXT	SEGMENT
result$ = 32
item$ = 64
PyNumber_Index PROC					; COMDAT

; 1157 : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1158 :     PyObject *result = NULL;

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 1159 :     if (item == NULL)

  00012	48 83 7c 24 40
	00		 cmp	 QWORD PTR item$[rsp], 0
  00018	75 0a		 jne	 SHORT $LN7@PyNumber_I@5

; 1160 :         return null_error();

  0001a	e8 00 00 00 00	 call	 null_error
  0001f	e9 0c 01 00 00	 jmp	 $LN8@PyNumber_I@5
$LN7@PyNumber_I@5:

; 1161 :     if (PyLong_Check(item)) {

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR item$[rsp]
  00029	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00033	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00038	85 c0		 test	 eax, eax
  0003a	74 14		 je	 SHORT $LN6@PyNumber_I@5

; 1162 :         Py_INCREF(item);

  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  00041	e8 00 00 00 00	 call	 _Py_IncRef

; 1163 :         return item;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR item$[rsp]
  0004b	e9 e0 00 00 00	 jmp	 $LN8@PyNumber_I@5
$LN6@PyNumber_I@5:

; 1164 :     }
; 1165 :     if (!PyIndex_Check(item)) {

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR item$[rsp]
  00055	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00059	48 83 b8 b8 00
	00 00 00	 cmp	 QWORD PTR [rax+184], 0
  00061	74 1a		 je	 SHORT $LN4@PyNumber_I@5
  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR item$[rsp]
  00068	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0006c	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00073	48 83 b8 08 01
	00 00 00	 cmp	 QWORD PTR [rax+264], 0
  0007b	75 27		 jne	 SHORT $LN5@PyNumber_I@5
$LN4@PyNumber_I@5:

; 1166 :         PyErr_Format(PyExc_TypeError,
; 1167 :                      "'%.200s' object cannot be interpreted "
; 1168 :                      "as an integer", item->ob_type->tp_name);

  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR item$[rsp]
  00082	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00086	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@GKPKFBFD@?8?$CF?4200s?8?5object?5cannot?5be?5interp@
  00091	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00098	e8 00 00 00 00	 call	 PyErr_Format

; 1169 :         return NULL;

  0009d	33 c0		 xor	 eax, eax
  0009f	e9 8c 00 00 00	 jmp	 $LN8@PyNumber_I@5
$LN5@PyNumber_I@5:

; 1170 :     }
; 1171 :     result = item->ob_type->tp_as_number->nb_index(item);

  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR item$[rsp]
  000a9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ad	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  000b4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$[rsp]
  000b9	ff 90 08 01 00
	00		 call	 QWORD PTR [rax+264]
  000bf	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 1172 :     if (!result || PyLong_CheckExact(result))

  000c4	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  000ca	74 12		 je	 SHORT $LN2@PyNumber_I@5
  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  000d3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  000d8	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000dc	75 07		 jne	 SHORT $LN3@PyNumber_I@5
$LN2@PyNumber_I@5:

; 1173 :         return result;

  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  000e3	eb 4b		 jmp	 SHORT $LN8@PyNumber_I@5
$LN3@PyNumber_I@5:

; 1174 :     if (!PyLong_Check(result)) {

  000e5	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  000ea	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ee	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f4	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000f9	85 c0		 test	 eax, eax
  000fb	75 2e		 jne	 SHORT $LN1@PyNumber_I@5

; 1175 :         PyErr_Format(PyExc_TypeError,
; 1176 :                      "__index__ returned non-int (type %.200s)",
; 1177 :                      result->ob_type->tp_name);

  000fd	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00102	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00106	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@FIKGDNGA@__index__?5returned?5non?9int?5?$CItype@
  00111	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00118	e8 00 00 00 00	 call	 PyErr_Format

; 1178 :         Py_DECREF(result);

  0011d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00122	e8 00 00 00 00	 call	 _Py_DecRef

; 1179 :         return NULL;

  00127	33 c0		 xor	 eax, eax
  00129	eb 05		 jmp	 SHORT $LN8@PyNumber_I@5
$LN1@PyNumber_I@5:

; 1180 :     }
; 1181 :     return result;

  0012b	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN8@PyNumber_I@5:

; 1182 : }

  00130	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00134	c3		 ret	 0
PyNumber_Index ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@EGNIIEGP@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5inde@ ; `string'
PUBLIC	??_C@_1CI@LDJODEPI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CM@GCNEELOK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAa?$AAb?$AAs?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ ; `string'
EXTRN	_PyLong_Sign:PROC
EXTRN	__imp__wassert:PROC
EXTRN	PyErr_GivenExceptionMatches:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_AsSsize_t DD imagerel $LN12
	DD	imagerel $LN12+284
	DD	imagerel $unwind$PyNumber_AsSsize_t
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_AsSsize_t DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0DA@EGNIIEGP@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5inde@
CONST	SEGMENT
??_C@_0DA@EGNIIEGP@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5inde@ DB 'canno'
	DB	't fit ''%.200s'' into an index-sized integer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CI@LDJODEPI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CI@LDJODEPI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'L', 00H, 'o', 00H, 'n', 00H, 'g', 00H, '_', 00H
	DB	'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '(', 00H, 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, ')', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CM@GCNEELOK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAa?$AAb?$AAs?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CM@GCNEELOK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAa?$AAb?$AAs?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'O', 00H, 'b', 00H, 'j', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'a', 00H, 'b', 00H, 's'
	DB	00H, 't', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 't', 00H, '.', 00H
	DB	'c', 00H, 00H, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_AsSsize_t
_TEXT	SEGMENT
value$ = 32
result$ = 40
runerr$ = 48
item$ = 80
err$ = 88
PyNumber_AsSsize_t PROC					; COMDAT

; 1188 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1189 :     Py_ssize_t result;
; 1190 :     PyObject *runerr;
; 1191 :     PyObject *value = PyNumber_Index(item);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR item$[rsp]
  00013	e8 00 00 00 00	 call	 PyNumber_Index
  00018	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax

; 1192 :     if (value == NULL)

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR value$[rsp], 0
  00023	75 0c		 jne	 SHORT $LN8@PyNumber_A@3

; 1193 :         return -1;

  00025	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0002c	e9 e6 00 00 00	 jmp	 $LN9@PyNumber_A@3
$LN8@PyNumber_A@3:

; 1194 : 
; 1195 :     /* We're done if PyLong_AsSsize_t() returns without error. */
; 1196 :     result = PyLong_AsSsize_t(value);

  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  00036	e8 00 00 00 00	 call	 PyLong_AsSsize_t
  0003b	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1197 :     if (result != -1 || !(runerr = PyErr_Occurred()))

  00040	48 83 7c 24 28
	ff		 cmp	 QWORD PTR result$[rsp], -1
  00046	75 12		 jne	 SHORT $LN6@PyNumber_A@3
  00048	e8 00 00 00 00	 call	 PyErr_Occurred
  0004d	48 89 44 24 30	 mov	 QWORD PTR runerr$[rsp], rax
  00052	48 83 7c 24 30
	00		 cmp	 QWORD PTR runerr$[rsp], 0
  00058	75 05		 jne	 SHORT $LN7@PyNumber_A@3
$LN6@PyNumber_A@3:

; 1198 :         goto finish;

  0005a	e9 a9 00 00 00	 jmp	 $finish$21372
$LN7@PyNumber_A@3:

; 1199 : 
; 1200 :     /* Error handling code -- only manage OverflowError differently */
; 1201 :     if (!PyErr_GivenExceptionMatches(runerr, PyExc_OverflowError))

  0005f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR PyExc_OverflowError
  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR runerr$[rsp]
  0006b	e8 00 00 00 00	 call	 PyErr_GivenExceptionMatches
  00070	85 c0		 test	 eax, eax
  00072	75 05		 jne	 SHORT $LN5@PyNumber_A@3

; 1202 :         goto finish;

  00074	e9 8f 00 00 00	 jmp	 $finish$21372
$LN5@PyNumber_A@3:

; 1203 : 
; 1204 :     PyErr_Clear();

  00079	e8 00 00 00 00	 call	 PyErr_Clear

; 1205 :     /* If no error-handling desired then the default clipping
; 1206 :        is sufficient.
; 1207 :      */
; 1208 :     if (!err) {

  0007e	48 83 7c 24 58
	00		 cmp	 QWORD PTR err$[rsp], 0
  00084	75 64		 jne	 SHORT $LN4@PyNumber_A@3

; 1209 :         assert(PyLong_Check(value));

  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  0008b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00095	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0009a	85 c0		 test	 eax, eax
  0009c	75 1c		 jne	 SHORT $LN11@PyNumber_A@3
  0009e	41 b8 b9 04 00
	00		 mov	 r8d, 1209		; 000004b9H
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@GCNEELOK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAa?$AAb?$AAs?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CI@LDJODEPI@?$AAP?$AAy?$AAL?$AAo?$AAn?$AAg?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAv?$AAa?$AAl?$AAu?$AAe?$AA?$CJ?$AA?$AA@
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  000b8	33 c0		 xor	 eax, eax
$LN11@PyNumber_A@3:

; 1210 :         /* Whether or not it is less than or equal to
; 1211 :            zero is determined by the sign of ob_size
; 1212 :         */
; 1213 :         if (_PyLong_Sign(value) < 0)

  000ba	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  000bf	e8 00 00 00 00	 call	 _PyLong_Sign
  000c4	85 c0		 test	 eax, eax
  000c6	7d 11		 jge	 SHORT $LN3@PyNumber_A@3

; 1214 :             result = PY_SSIZE_T_MIN;

  000c8	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  000d2	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1215 :         else

  000d7	eb 0f		 jmp	 SHORT $LN2@PyNumber_A@3
$LN3@PyNumber_A@3:

; 1216 :             result = PY_SSIZE_T_MAX;

  000d9	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  000e3	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax
$LN2@PyNumber_A@3:

; 1217 :     }
; 1218 :     else {

  000e8	eb 1e		 jmp	 SHORT $LN1@PyNumber_A@3
$LN4@PyNumber_A@3:

; 1219 :         /* Otherwise replace the error with caller's error object. */
; 1220 :         PyErr_Format(err,
; 1221 :                      "cannot fit '%.200s' into an index-sized integer",
; 1222 :                      item->ob_type->tp_name);

  000ea	48 8b 44 24 50	 mov	 rax, QWORD PTR item$[rsp]
  000ef	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000f3	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@EGNIIEGP@cannot?5fit?5?8?$CF?4200s?8?5into?5an?5inde@
  000fe	48 8b 4c 24 58	 mov	 rcx, QWORD PTR err$[rsp]
  00103	e8 00 00 00 00	 call	 PyErr_Format
$LN1@PyNumber_A@3:
$finish$21372:

; 1223 :     }
; 1224 : 
; 1225 :  finish:
; 1226 :     Py_DECREF(value);

  00108	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  0010d	e8 00 00 00 00	 call	 _Py_DecRef

; 1227 :     return result;

  00112	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN9@PyNumber_A@3:

; 1228 : }

  00117	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011b	c3		 ret	 0
PyNumber_AsSsize_t ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DK@NHAFGNGO@int?$CI?$CJ?5argument?5must?5be?5a?5string?5@ ; `string'
PUBLIC	??_C@_1CC@ILNNDGLK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AA?$CJ?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CO@MIONBMMP@__trunc__?5returned?5non?9Integral?5@ ; `string'
PUBLIC	PyNumber_Long
EXTRN	PyLong_FromUnicodeObject:PROC
EXTRN	_PyLong_FromBytes:PROC
EXTRN	PyEval_CallObjectWithKeywords:PROC
EXTRN	_PyLong_FromNbInt:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Long DD imagerel $LN17
	DD	imagerel $LN17+673
	DD	imagerel $unwind$PyNumber_Long
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Long DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_0DK@NHAFGNGO@int?$CI?$CJ?5argument?5must?5be?5a?5string?5@
CONST	SEGMENT
??_C@_0DK@NHAFGNGO@int?$CI?$CJ?5argument?5must?5be?5a?5string?5@ DB 'int('
	DB	') argument must be a string or a number, not ''%.200s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@ILNNDGLK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AA?$CJ?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@ILNNDGLK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AA?$CJ?$AA?$AA@ DB 'P'
	DB	00H, 'y', 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	'_', 00H, 'C', 00H, 'h', 00H, 'e', 00H, 'c', 00H, 'k', 00H, '('
	DB	00H, 'o', 00H, ')', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@MIONBMMP@__trunc__?5returned?5non?9Integral?5@
CONST	SEGMENT
??_C@_0CO@MIONBMMP@__trunc__?5returned?5non?9Integral?5@ DB '__trunc__ re'
	DB	'turned non-Integral (type %.200s)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Long
_TEXT	SEGMENT
buffer_len$ = 32
trunc_func$ = 40
buffer$ = 48
m$ = 56
int_instance$21410 = 64
truncated$21406 = 72
o$ = 96
PyNumber_Long PROC					; COMDAT

; 1233 : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1234 :     PyNumberMethods *m;
; 1235 :     PyObject *trunc_func;
; 1236 :     const char *buffer;
; 1237 :     Py_ssize_t buffer_len;
; 1238 :     _Py_IDENTIFIER(__trunc__);
; 1239 : 
; 1240 :     if (o == NULL)

  00009	48 83 7c 24 60
	00		 cmp	 QWORD PTR o$[rsp], 0
  0000f	75 0a		 jne	 SHORT $LN12@PyNumber_L

; 1241 :         return null_error();

  00011	e8 00 00 00 00	 call	 null_error
  00016	e9 81 02 00 00	 jmp	 $LN13@PyNumber_L
$LN12@PyNumber_L:

; 1242 :     if (PyLong_CheckExact(o)) {

  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyLong_Type
  00022	48 8b 4c 24 60	 mov	 rcx, QWORD PTR o$[rsp]
  00027	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  0002b	75 14		 jne	 SHORT $LN11@PyNumber_L

; 1243 :         Py_INCREF(o);

  0002d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR o$[rsp]
  00032	e8 00 00 00 00	 call	 _Py_IncRef

; 1244 :         return o;

  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR o$[rsp]
  0003c	e9 5b 02 00 00	 jmp	 $LN13@PyNumber_L
$LN11@PyNumber_L:

; 1245 :     }
; 1246 :     m = o->ob_type->tp_as_number;

  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR o$[rsp]
  00046	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0004a	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  00051	48 89 44 24 38	 mov	 QWORD PTR m$[rsp], rax

; 1247 :     if (m && m->nb_int) { /* This should include subclasses of int */

  00056	48 83 7c 24 38
	00		 cmp	 QWORD PTR m$[rsp], 0
  0005c	74 1e		 je	 SHORT $LN10@PyNumber_L
  0005e	48 8b 44 24 38	 mov	 rax, QWORD PTR m$[rsp]
  00063	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0006b	74 0f		 je	 SHORT $LN10@PyNumber_L

; 1248 :         return (PyObject *)_PyLong_FromNbInt(o);

  0006d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR o$[rsp]
  00072	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  00077	e9 20 02 00 00	 jmp	 $LN13@PyNumber_L
$LN10@PyNumber_L:

; 1249 :     }
; 1250 :     trunc_func = _PyObject_LookupSpecial(o, &PyId___trunc__);

  0007c	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___trunc__@?1??PyNumber_Long@@9@9
  00081	8b c0		 mov	 eax, eax
  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00089	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00092	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00096	48 8b d0	 mov	 rdx, rax
  00099	48 8b 4c 24 60	 mov	 rcx, QWORD PTR o$[rsp]
  0009e	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  000a3	48 89 44 24 28	 mov	 QWORD PTR trunc_func$[rsp], rax

; 1251 :     if (trunc_func) {

  000a8	48 83 7c 24 28
	00		 cmp	 QWORD PTR trunc_func$[rsp], 0
  000ae	0f 84 c8 00 00
	00		 je	 $LN9@PyNumber_L

; 1252 :         PyObject *truncated = PyEval_CallObject(trunc_func, NULL);

  000b4	45 33 c0	 xor	 r8d, r8d
  000b7	33 d2		 xor	 edx, edx
  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR trunc_func$[rsp]
  000be	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords
  000c3	48 89 44 24 48	 mov	 QWORD PTR truncated$21406[rsp], rax

; 1253 :         PyObject *int_instance;
; 1254 :         Py_DECREF(trunc_func);

  000c8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR trunc_func$[rsp]
  000cd	e8 00 00 00 00	 call	 _Py_DecRef

; 1255 :         if (truncated == NULL || PyLong_Check(truncated))

  000d2	48 83 7c 24 48
	00		 cmp	 QWORD PTR truncated$21406[rsp], 0
  000d8	74 18		 je	 SHORT $LN7@PyNumber_L
  000da	48 8b 44 24 48	 mov	 rax, QWORD PTR truncated$21406[rsp]
  000df	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000e3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000e9	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000ee	85 c0		 test	 eax, eax
  000f0	74 0a		 je	 SHORT $LN8@PyNumber_L
$LN7@PyNumber_L:

; 1256 :             return truncated;

  000f2	48 8b 44 24 48	 mov	 rax, QWORD PTR truncated$21406[rsp]
  000f7	e9 a0 01 00 00	 jmp	 $LN13@PyNumber_L
$LN8@PyNumber_L:

; 1257 :         /* __trunc__ is specified to return an Integral type,
; 1258 :            but int() needs to return a int. */
; 1259 :         m = truncated->ob_type->tp_as_number;

  000fc	48 8b 44 24 48	 mov	 rax, QWORD PTR truncated$21406[rsp]
  00101	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00105	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0010c	48 89 44 24 38	 mov	 QWORD PTR m$[rsp], rax

; 1260 :         if (m == NULL || m->nb_int == NULL) {

  00111	48 83 7c 24 38
	00		 cmp	 QWORD PTR m$[rsp], 0
  00117	74 0f		 je	 SHORT $LN5@PyNumber_L
  00119	48 8b 44 24 38	 mov	 rax, QWORD PTR m$[rsp]
  0011e	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00126	75 31		 jne	 SHORT $LN6@PyNumber_L
$LN5@PyNumber_L:

; 1261 :             PyErr_Format(
; 1262 :                 PyExc_TypeError,
; 1263 :                 "__trunc__ returned non-Integral (type %.200s)",
; 1264 :                 truncated->ob_type->tp_name);

  00128	48 8b 44 24 48	 mov	 rax, QWORD PTR truncated$21406[rsp]
  0012d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00131	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@MIONBMMP@__trunc__?5returned?5non?9Integral?5@
  0013c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00143	e8 00 00 00 00	 call	 PyErr_Format

; 1265 :             Py_DECREF(truncated);

  00148	48 8b 4c 24 48	 mov	 rcx, QWORD PTR truncated$21406[rsp]
  0014d	e8 00 00 00 00	 call	 _Py_DecRef

; 1266 :             return NULL;

  00152	33 c0		 xor	 eax, eax
  00154	e9 43 01 00 00	 jmp	 $LN13@PyNumber_L
$LN6@PyNumber_L:

; 1267 :         }
; 1268 :         int_instance = (PyObject *)_PyLong_FromNbInt(truncated);

  00159	48 8b 4c 24 48	 mov	 rcx, QWORD PTR truncated$21406[rsp]
  0015e	e8 00 00 00 00	 call	 _PyLong_FromNbInt
  00163	48 89 44 24 40	 mov	 QWORD PTR int_instance$21410[rsp], rax

; 1269 :         Py_DECREF(truncated);

  00168	48 8b 4c 24 48	 mov	 rcx, QWORD PTR truncated$21406[rsp]
  0016d	e8 00 00 00 00	 call	 _Py_DecRef

; 1270 :         return int_instance;

  00172	48 8b 44 24 40	 mov	 rax, QWORD PTR int_instance$21410[rsp]
  00177	e9 20 01 00 00	 jmp	 $LN13@PyNumber_L
$LN9@PyNumber_L:

; 1271 :     }
; 1272 :     if (PyErr_Occurred())

  0017c	e8 00 00 00 00	 call	 PyErr_Occurred
  00181	48 85 c0	 test	 rax, rax
  00184	74 07		 je	 SHORT $LN4@PyNumber_L

; 1273 :         return NULL;

  00186	33 c0		 xor	 eax, eax
  00188	e9 0f 01 00 00	 jmp	 $LN13@PyNumber_L
$LN4@PyNumber_L:

; 1274 : 
; 1275 :     if (PyBytes_Check(o))

  0018d	48 8b 44 24 60	 mov	 rax, QWORD PTR o$[rsp]
  00192	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00196	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0019c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001a1	85 c0		 test	 eax, eax
  001a3	0f 84 8a 00 00
	00		 je	 $LN3@PyNumber_L

; 1276 :         /* need to do extra error checking that PyLong_FromString()
; 1277 :          * doesn't do.  In particular int('9\x005') must raise an
; 1278 :          * exception, not truncate at the null.
; 1279 :          */
; 1280 :         return _PyLong_FromBytes(PyBytes_AS_STRING(o),
; 1281 :                                  PyBytes_GET_SIZE(o), 10);

  001a9	48 8b 44 24 60	 mov	 rax, QWORD PTR o$[rsp]
  001ae	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001b2	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001b8	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001bd	85 c0		 test	 eax, eax
  001bf	75 1c		 jne	 SHORT $LN15@PyNumber_L
  001c1	41 b8 01 05 00
	00		 mov	 r8d, 1281		; 00000501H
  001c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@GCNEELOK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAa?$AAb?$AAs?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@ILNNDGLK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AA?$CJ?$AA?$AA@
  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  001db	33 c0		 xor	 eax, eax
$LN15@PyNumber_L:
  001dd	48 8b 44 24 60	 mov	 rax, QWORD PTR o$[rsp]
  001e2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001e6	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001ec	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001f1	85 c0		 test	 eax, eax
  001f3	75 1c		 jne	 SHORT $LN16@PyNumber_L
  001f5	41 b8 00 05 00
	00		 mov	 r8d, 1280		; 00000500H
  001fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@GCNEELOK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAa?$AAb?$AAs?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CC@ILNNDGLK@?$AAP?$AAy?$AAB?$AAy?$AAt?$AAe?$AAs?$AA_?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$CI?$AAo?$AA?$CJ?$AA?$AA@
  00209	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0020f	33 c0		 xor	 eax, eax
$LN16@PyNumber_L:
  00211	48 8b 44 24 60	 mov	 rax, QWORD PTR o$[rsp]
  00216	48 83 c0 78	 add	 rax, 120		; 00000078H
  0021a	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00220	48 8b 4c 24 60	 mov	 rcx, QWORD PTR o$[rsp]
  00225	48 8b 51 60	 mov	 rdx, QWORD PTR [rcx+96]
  00229	48 8b c8	 mov	 rcx, rax
  0022c	e8 00 00 00 00	 call	 _PyLong_FromBytes
  00231	eb 69		 jmp	 SHORT $LN13@PyNumber_L
$LN3@PyNumber_L:

; 1282 :     if (PyUnicode_Check(o))

  00233	48 8b 44 24 60	 mov	 rax, QWORD PTR o$[rsp]
  00238	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0023c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00242	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00247	85 c0		 test	 eax, eax
  00249	74 11		 je	 SHORT $LN2@PyNumber_L

; 1283 :         /* The above check is done in PyLong_FromUnicode(). */
; 1284 :         return PyLong_FromUnicodeObject(o, 10);

  0024b	ba 0a 00 00 00	 mov	 edx, 10
  00250	48 8b 4c 24 60	 mov	 rcx, QWORD PTR o$[rsp]
  00255	e8 00 00 00 00	 call	 PyLong_FromUnicodeObject
  0025a	eb 40		 jmp	 SHORT $LN13@PyNumber_L
$LN2@PyNumber_L:

; 1285 :     if (!PyObject_AsCharBuffer(o, &buffer, &buffer_len))

  0025c	4c 8d 44 24 20	 lea	 r8, QWORD PTR buffer_len$[rsp]
  00261	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00266	48 8b 4c 24 60	 mov	 rcx, QWORD PTR o$[rsp]
  0026b	e8 00 00 00 00	 call	 PyObject_AsCharBuffer
  00270	85 c0		 test	 eax, eax
  00272	75 17		 jne	 SHORT $LN1@PyNumber_L

; 1286 :         return _PyLong_FromBytes(buffer, buffer_len, 10);

  00274	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0027a	48 8b 54 24 20	 mov	 rdx, QWORD PTR buffer_len$[rsp]
  0027f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buffer$[rsp]
  00284	e8 00 00 00 00	 call	 _PyLong_FromBytes
  00289	eb 11		 jmp	 SHORT $LN13@PyNumber_L
$LN1@PyNumber_L:

; 1287 : 
; 1288 :     return type_error("int() argument must be a string or a "
; 1289 :                       "number, not '%.200s'", o);

  0028b	48 8b 54 24 60	 mov	 rdx, QWORD PTR o$[rsp]
  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DK@NHAFGNGO@int?$CI?$CJ?5argument?5must?5be?5a?5string?5@
  00297	e8 00 00 00 00	 call	 type_error
$LN13@PyNumber_L:

; 1290 : }

  0029c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002a0	c3		 ret	 0
PyNumber_Long ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@FIEJPELD@__float__?5returned?5non?9float?5?$CIty@ ; `string'
PUBLIC	PyNumber_Float
EXTRN	PyFloat_FromString:PROC
EXTRN	PyFloat_FromDouble:PROC
EXTRN	PyFloat_Type:BYTE
EXTRN	_fltused:DWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_Float DD imagerel $LN8
	DD	imagerel $LN8+285
	DD	imagerel $unwind$PyNumber_Float
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_Float DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0CL@FIEJPELD@__float__?5returned?5non?9float?5?$CIty@
CONST	SEGMENT
??_C@_0CL@FIEJPELD@__float__?5returned?5non?9float?5?$CIty@ DB '__float__'
	DB	' returned non-float (type %.200s)', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_Float
_TEXT	SEGMENT
m$ = 32
res$21447 = 40
po$21458 = 48
o$ = 80
PyNumber_Float PROC					; COMDAT

; 1294 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1295 :     PyNumberMethods *m;
; 1296 : 
; 1297 :     if (o == NULL)

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR o$[rsp], 0
  0000f	75 0a		 jne	 SHORT $LN5@PyNumber_F

; 1298 :         return null_error();

  00011	e8 00 00 00 00	 call	 null_error
  00016	e9 fd 00 00 00	 jmp	 $LN6@PyNumber_F
$LN5@PyNumber_F:

; 1299 :     m = o->ob_type->tp_as_number;

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR o$[rsp]
  00020	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00024	48 8b 80 b8 00
	00 00		 mov	 rax, QWORD PTR [rax+184]
  0002b	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1300 :     if (m && m->nb_float) { /* This should include subclasses of float */

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00036	0f 84 8c 00 00
	00		 je	 $LN4@PyNumber_F
  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00041	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  00049	74 7d		 je	 SHORT $LN4@PyNumber_F

; 1301 :         PyObject *res = m->nb_float(o);

  0004b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00055	ff 90 90 00 00
	00		 call	 QWORD PTR [rax+144]
  0005b	48 89 44 24 28	 mov	 QWORD PTR res$21447[rsp], rax

; 1302 :         if (res && !PyFloat_Check(res)) {

  00060	48 83 7c 24 28
	00		 cmp	 QWORD PTR res$21447[rsp], 0
  00066	74 59		 je	 SHORT $LN3@PyNumber_F
  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  0006f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR res$21447[rsp]
  00074	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00078	74 47		 je	 SHORT $LN3@PyNumber_F
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR res$21447[rsp]
  00086	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0008a	e8 00 00 00 00	 call	 PyType_IsSubtype
  0008f	85 c0		 test	 eax, eax
  00091	75 2e		 jne	 SHORT $LN3@PyNumber_F

; 1303 :             PyErr_Format(PyExc_TypeError,
; 1304 :               "__float__ returned non-float (type %.200s)",
; 1305 :               res->ob_type->tp_name);

  00093	48 8b 44 24 28	 mov	 rax, QWORD PTR res$21447[rsp]
  00098	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009c	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@FIEJPELD@__float__?5returned?5non?9float?5?$CIty@
  000a7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000ae	e8 00 00 00 00	 call	 PyErr_Format

; 1306 :             Py_DECREF(res);

  000b3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR res$21447[rsp]
  000b8	e8 00 00 00 00	 call	 _Py_DecRef

; 1307 :             return NULL;

  000bd	33 c0		 xor	 eax, eax
  000bf	eb 57		 jmp	 SHORT $LN6@PyNumber_F
$LN3@PyNumber_F:

; 1308 :         }
; 1309 :         return res;

  000c1	48 8b 44 24 28	 mov	 rax, QWORD PTR res$21447[rsp]
  000c6	eb 50		 jmp	 SHORT $LN6@PyNumber_F
$LN4@PyNumber_F:

; 1310 :     }
; 1311 :     if (PyFloat_Check(o)) { /* A float subclass with nb_float == NULL */

  000c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyFloat_Type
  000cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  000d4	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  000d8	74 19		 je	 SHORT $LN1@PyNumber_F
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:PyFloat_Type
  000e1	48 8b 44 24 50	 mov	 rax, QWORD PTR o$[rsp]
  000e6	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  000ea	e8 00 00 00 00	 call	 PyType_IsSubtype
  000ef	85 c0		 test	 eax, eax
  000f1	74 1b		 je	 SHORT $LN2@PyNumber_F
$LN1@PyNumber_F:

; 1312 :         PyFloatObject *po = (PyFloatObject *)o;

  000f3	48 8b 44 24 50	 mov	 rax, QWORD PTR o$[rsp]
  000f8	48 89 44 24 30	 mov	 QWORD PTR po$21458[rsp], rax

; 1313 :         return PyFloat_FromDouble(po->ob_fval);

  000fd	48 8b 44 24 30	 mov	 rax, QWORD PTR po$21458[rsp]
  00102	f2 0f 10 40 60	 movsdx	 xmm0, QWORD PTR [rax+96]
  00107	e8 00 00 00 00	 call	 PyFloat_FromDouble
  0010c	eb 0a		 jmp	 SHORT $LN6@PyNumber_F
$LN2@PyNumber_F:

; 1314 :     }
; 1315 :     return PyFloat_FromString(o);

  0010e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00113	e8 00 00 00 00	 call	 PyFloat_FromString
$LN6@PyNumber_F:

; 1316 : }

  00118	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011c	c3		 ret	 0
PyNumber_Float ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@EHFNOHLP@PyNumber_ToBase?3?5index?5not?5int?$AA@ ; `string'
PUBLIC	PyNumber_ToBase
EXTRN	PyExc_ValueError:QWORD
EXTRN	_PyLong_Format:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyNumber_ToBase DD imagerel $LN6
	DD	imagerel $LN6+133
	DD	imagerel $unwind$PyNumber_ToBase
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyNumber_ToBase DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT ??_C@_0BP@EHFNOHLP@PyNumber_ToBase?3?5index?5not?5int?$AA@
CONST	SEGMENT
??_C@_0BP@EHFNOHLP@PyNumber_ToBase?3?5index?5not?5int?$AA@ DB 'PyNumber_T'
	DB	'oBase: index not int', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyNumber_ToBase
_TEXT	SEGMENT
res$ = 32
index$ = 40
n$ = 64
base$ = 72
PyNumber_ToBase PROC					; COMDAT

; 1321 : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1322 :     PyObject *res = NULL;

  0000d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR res$[rsp], 0

; 1323 :     PyObject *index = PyNumber_Index(n);

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR n$[rsp]
  0001b	e8 00 00 00 00	 call	 PyNumber_Index
  00020	48 89 44 24 28	 mov	 QWORD PTR index$[rsp], rax

; 1324 : 
; 1325 :     if (!index)

  00025	48 83 7c 24 28
	00		 cmp	 QWORD PTR index$[rsp], 0
  0002b	75 04		 jne	 SHORT $LN3@PyNumber_T

; 1326 :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 4f		 jmp	 SHORT $LN4@PyNumber_T
$LN3@PyNumber_T:

; 1327 :     if (PyLong_Check(index))

  00031	48 8b 44 24 28	 mov	 rax, QWORD PTR index$[rsp]
  00036	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00040	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00045	85 c0		 test	 eax, eax
  00047	74 15		 je	 SHORT $LN2@PyNumber_T

; 1328 :         res = _PyLong_Format(index, base);

  00049	8b 54 24 48	 mov	 edx, DWORD PTR base$[rsp]
  0004d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR index$[rsp]
  00052	e8 00 00 00 00	 call	 _PyLong_Format
  00057	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 1329 :     else

  0005c	eb 13		 jmp	 SHORT $LN1@PyNumber_T
$LN2@PyNumber_T:

; 1330 :         /* It should not be possible to get here, as
; 1331 :            PyNumber_Index already has a check for the same
; 1332 :            condition */
; 1333 :         PyErr_SetString(PyExc_ValueError, "PyNumber_ToBase: index not int");

  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@EHFNOHLP@PyNumber_ToBase?3?5index?5not?5int?$AA@
  00065	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  0006c	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@PyNumber_T:

; 1334 :     Py_DECREF(index);

  00071	48 8b 4c 24 28	 mov	 rcx, QWORD PTR index$[rsp]
  00076	e8 00 00 00 00	 call	 _Py_DecRef

; 1335 :     return res;

  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR res$[rsp]
$LN4@PyNumber_T:

; 1336 : }

  00080	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00084	c3		 ret	 0
PyNumber_ToBase ENDP
_TEXT	ENDS
PUBLIC	PySequence_Check
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Check DD imagerel $LN6
	DD	imagerel $LN6+111
	DD	imagerel $unwind$PySequence_Check
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Check DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySequence_Check
_TEXT	SEGMENT
tv76 = 0
s$ = 32
PySequence_Check PROC					; COMDAT

; 1343 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1344 :     if (PyDict_Check(s))

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00018	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0001d	85 c0		 test	 eax, eax
  0001f	74 04		 je	 SHORT $LN1@PySequence

; 1345 :         return 0;

  00021	33 c0		 xor	 eax, eax
  00023	eb 45		 jmp	 SHORT $LN2@PySequence
$LN1@PySequence:

; 1346 :     return s != NULL && s->ob_type->tp_as_sequence &&
; 1347 :         s->ob_type->tp_as_sequence->sq_item != NULL;

  00025	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  0002b	74 33		 je	 SHORT $LN4@PySequence
  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00032	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00036	48 83 b8 c0 00
	00 00 00	 cmp	 QWORD PTR [rax+192], 0
  0003e	74 20		 je	 SHORT $LN4@PySequence
  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00045	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00049	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00050	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00055	74 09		 je	 SHORT $LN4@PySequence
  00057	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv76[rsp], 1
  0005e	eb 07		 jmp	 SHORT $LN5@PySequence
$LN4@PySequence:
  00060	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv76[rsp], 0
$LN5@PySequence:
  00067	8b 04 24	 mov	 eax, DWORD PTR tv76[rsp]
$LN2@PySequence:

; 1348 : }

  0006a	48 83 c4 18	 add	 rsp, 24
  0006e	c3		 ret	 0
PySequence_Check ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@IKKNHGFK@object?5of?5type?5?8?$CF?4200s?8?5has?5no?5l@ ; `string'
PUBLIC	PySequence_Size
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Size DD imagerel $LN5
	DD	imagerel $LN5+114
	DD	imagerel $unwind$PySequence_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Size DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0CF@IKKNHGFK@object?5of?5type?5?8?$CF?4200s?8?5has?5no?5l@
CONST	SEGMENT
??_C@_0CF@IKKNHGFK@object?5of?5type?5?8?$CF?4200s?8?5has?5no?5l@ DB 'obje'
	DB	'ct of type ''%.200s'' has no len()', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySequence_Size
_TEXT	SEGMENT
m$ = 32
s$ = 64
PySequence_Size PROC					; COMDAT

; 1352 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1353 :     PySequenceMethods *m;
; 1354 : 
; 1355 :     if (s == NULL) {

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR s$[rsp], 0
  0000f	75 0e		 jne	 SHORT $LN2@PySequence@2

; 1356 :         null_error();

  00011	e8 00 00 00 00	 call	 null_error

; 1357 :         return -1;

  00016	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0001d	eb 4e		 jmp	 SHORT $LN3@PySequence@2
$LN2@PySequence@2:

; 1358 :     }
; 1359 : 
; 1360 :     m = s->ob_type->tp_as_sequence;

  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00024	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00028	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0002f	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1361 :     if (m && m->sq_length)

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  0003a	74 19		 je	 SHORT $LN1@PySequence@2
  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00041	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00045	74 0e		 je	 SHORT $LN1@PySequence@2

; 1362 :         return m->sq_length(s);

  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00051	ff 10		 call	 QWORD PTR [rax]
  00053	eb 18		 jmp	 SHORT $LN3@PySequence@2
$LN1@PySequence@2:

; 1363 : 
; 1364 :     type_error("object of type '%.200s' has no len()", s);

  00055	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@IKKNHGFK@object?5of?5type?5?8?$CF?4200s?8?5has?5no?5l@
  00061	e8 00 00 00 00	 call	 type_error

; 1365 :     return -1;

  00066	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN3@PySequence@2:

; 1366 : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
PySequence_Size ENDP
_TEXT	ENDS
PUBLIC	PySequence_Length
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Length DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$PySequence_Length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Length DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySequence_Length
_TEXT	SEGMENT
s$ = 48
PySequence_Length PROC					; COMDAT

; 1371 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1372 :     return PySequence_Size(s);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 PySequence_Size

; 1373 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
PySequence_Length ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CG@OBIBNDFJ@?8?$CF?4200s?8?5object?5can?8t?5be?5concate@ ; `string'
PUBLIC	PySequence_Concat
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Concat DD imagerel $LN8
	DD	imagerel $LN8+205
	DD	imagerel $unwind$PySequence_Concat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Concat DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CG@OBIBNDFJ@?8?$CF?4200s?8?5object?5can?8t?5be?5concate@
CONST	SEGMENT
??_C@_0CG@OBIBNDFJ@?8?$CF?4200s?8?5object?5can?8t?5be?5concate@ DB '''%.2'
	DB	'00s'' object can''t be concatenated', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySequence_Concat
_TEXT	SEGMENT
m$ = 32
result$21506 = 40
s$ = 64
o$ = 72
PySequence_Concat PROC					; COMDAT

; 1378 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1379 :     PySequenceMethods *m;
; 1380 : 
; 1381 :     if (s == NULL || o == NULL)

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR s$[rsp], 0
  00014	74 08		 je	 SHORT $LN4@PySequence@3
  00016	48 83 7c 24 48
	00		 cmp	 QWORD PTR o$[rsp], 0
  0001c	75 0a		 jne	 SHORT $LN5@PySequence@3
$LN4@PySequence@3:

; 1382 :         return null_error();

  0001e	e8 00 00 00 00	 call	 null_error
  00023	e9 a0 00 00 00	 jmp	 $LN6@PySequence@3
$LN5@PySequence@3:

; 1383 : 
; 1384 :     m = s->ob_type->tp_as_sequence;

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0002d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00031	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00038	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1385 :     if (m && m->sq_concat)

  0003d	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00043	74 20		 je	 SHORT $LN3@PySequence@3
  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0004a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0004f	74 14		 je	 SHORT $LN3@PySequence@3

; 1386 :         return m->sq_concat(s, o);

  00051	48 8b 54 24 48	 mov	 rdx, QWORD PTR o$[rsp]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00060	ff 50 08	 call	 QWORD PTR [rax+8]
  00063	eb 63		 jmp	 SHORT $LN6@PySequence@3
$LN3@PySequence@3:

; 1387 : 
; 1388 :     /* Instances of user classes defining an __add__() method only
; 1389 :        have an nb_add slot, not an sq_concat slot.      So we fall back
; 1390 :        to nb_add if both arguments appear to be sequences. */
; 1391 :     if (PySequence_Check(s) && PySequence_Check(o)) {

  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0006a	e8 00 00 00 00	 call	 PySequence_Check
  0006f	85 c0		 test	 eax, eax
  00071	74 44		 je	 SHORT $LN2@PySequence@3
  00073	48 8b 4c 24 48	 mov	 rcx, QWORD PTR o$[rsp]
  00078	e8 00 00 00 00	 call	 PySequence_Check
  0007d	85 c0		 test	 eax, eax
  0007f	74 36		 je	 SHORT $LN2@PySequence@3

; 1392 :         PyObject *result = binary_op1(s, o, NB_SLOT(nb_add));

  00081	45 33 c0	 xor	 r8d, r8d
  00084	48 8b 54 24 48	 mov	 rdx, QWORD PTR o$[rsp]
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0008e	e8 00 00 00 00	 call	 binary_op1
  00093	48 89 44 24 28	 mov	 QWORD PTR result$21506[rsp], rax

; 1393 :         if (result != Py_NotImplemented)

  00098	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  0009f	48 39 44 24 28	 cmp	 QWORD PTR result$21506[rsp], rax
  000a4	74 07		 je	 SHORT $LN1@PySequence@3

; 1394 :             return result;

  000a6	48 8b 44 24 28	 mov	 rax, QWORD PTR result$21506[rsp]
  000ab	eb 1b		 jmp	 SHORT $LN6@PySequence@3
$LN1@PySequence@3:

; 1395 :         Py_DECREF(result);

  000ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$21506[rsp]
  000b2	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PySequence@3:

; 1396 :     }
; 1397 :     return type_error("'%.200s' object can't be concatenated", s);

  000b7	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@OBIBNDFJ@?8?$CF?4200s?8?5object?5can?8t?5be?5concate@
  000c3	e8 00 00 00 00	 call	 type_error
$LN6@PySequence@3:

; 1398 : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
PySequence_Concat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CC@NJPBBLBE@?8?$CF?4200s?8?5object?5can?8t?5be?5repeate@ ; `string'
PUBLIC	PySequence_Repeat
EXTRN	PyLong_FromSsize_t:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Repeat DD imagerel $LN8
	DD	imagerel $LN8+223
	DD	imagerel $unwind$PySequence_Repeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Repeat DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0CC@NJPBBLBE@?8?$CF?4200s?8?5object?5can?8t?5be?5repeate@
CONST	SEGMENT
??_C@_0CC@NJPBBLBE@?8?$CF?4200s?8?5object?5can?8t?5be?5repeate@ DB '''%.2'
	DB	'00s'' object can''t be repeated', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySequence_Repeat
_TEXT	SEGMENT
m$ = 32
n$21523 = 40
result$21524 = 48
o$ = 80
count$ = 88
PySequence_Repeat PROC					; COMDAT

; 1402 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1403 :     PySequenceMethods *m;
; 1404 : 
; 1405 :     if (o == NULL)

  0000e	48 83 7c 24 50
	00		 cmp	 QWORD PTR o$[rsp], 0
  00014	75 0a		 jne	 SHORT $LN5@PySequence@4

; 1406 :         return null_error();

  00016	e8 00 00 00 00	 call	 null_error
  0001b	e9 ba 00 00 00	 jmp	 $LN6@PySequence@4
$LN5@PySequence@4:

; 1407 : 
; 1408 :     m = o->ob_type->tp_as_sequence;

  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR o$[rsp]
  00025	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00029	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00030	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1409 :     if (m && m->sq_repeat)

  00035	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  0003b	74 20		 je	 SHORT $LN4@PySequence@4
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00042	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00047	74 14		 je	 SHORT $LN4@PySequence@4

; 1410 :         return m->sq_repeat(o, count);

  00049	48 8b 54 24 58	 mov	 rdx, QWORD PTR count$[rsp]
  0004e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00058	ff 50 10	 call	 QWORD PTR [rax+16]
  0005b	eb 7d		 jmp	 SHORT $LN6@PySequence@4
$LN4@PySequence@4:

; 1411 : 
; 1412 :     /* Instances of user classes defining a __mul__() method only
; 1413 :        have an nb_multiply slot, not an sq_repeat slot. so we fall back
; 1414 :        to nb_multiply if o appears to be a sequence. */
; 1415 :     if (PySequence_Check(o)) {

  0005d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00062	e8 00 00 00 00	 call	 PySequence_Check
  00067	85 c0		 test	 eax, eax
  00069	74 5e		 je	 SHORT $LN3@PySequence@4

; 1416 :         PyObject *n, *result;
; 1417 :         n = PyLong_FromSsize_t(count);

  0006b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR count$[rsp]
  00070	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  00075	48 89 44 24 28	 mov	 QWORD PTR n$21523[rsp], rax

; 1418 :         if (n == NULL)

  0007a	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$21523[rsp], 0
  00080	75 04		 jne	 SHORT $LN2@PySequence@4

; 1419 :             return NULL;

  00082	33 c0		 xor	 eax, eax
  00084	eb 54		 jmp	 SHORT $LN6@PySequence@4
$LN2@PySequence@4:

; 1420 :         result = binary_op1(o, n, NB_SLOT(nb_multiply));

  00086	41 b8 10 00 00
	00		 mov	 r8d, 16
  0008c	48 8b 54 24 28	 mov	 rdx, QWORD PTR n$21523[rsp]
  00091	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00096	e8 00 00 00 00	 call	 binary_op1
  0009b	48 89 44 24 30	 mov	 QWORD PTR result$21524[rsp], rax

; 1421 :         Py_DECREF(n);

  000a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$21523[rsp]
  000a5	e8 00 00 00 00	 call	 _Py_DecRef

; 1422 :         if (result != Py_NotImplemented)

  000aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000b1	48 39 44 24 30	 cmp	 QWORD PTR result$21524[rsp], rax
  000b6	74 07		 je	 SHORT $LN1@PySequence@4

; 1423 :             return result;

  000b8	48 8b 44 24 30	 mov	 rax, QWORD PTR result$21524[rsp]
  000bd	eb 1b		 jmp	 SHORT $LN6@PySequence@4
$LN1@PySequence@4:

; 1424 :         Py_DECREF(result);

  000bf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$21524[rsp]
  000c4	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PySequence@4:

; 1425 :     }
; 1426 :     return type_error("'%.200s' object can't be repeated", o);

  000c9	48 8b 54 24 50	 mov	 rdx, QWORD PTR o$[rsp]
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@NJPBBLBE@?8?$CF?4200s?8?5object?5can?8t?5be?5repeate@
  000d5	e8 00 00 00 00	 call	 type_error
$LN6@PySequence@4:

; 1427 : }

  000da	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000de	c3		 ret	 0
PySequence_Repeat ENDP
_TEXT	ENDS
PUBLIC	PySequence_InPlaceConcat
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_InPlaceConcat DD imagerel $LN9
	DD	imagerel $LN9+254
	DD	imagerel $unwind$PySequence_InPlaceConcat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_InPlaceConcat DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySequence_InPlaceConcat
_TEXT	SEGMENT
m$ = 32
result$21548 = 40
s$ = 64
o$ = 72
PySequence_InPlaceConcat PROC				; COMDAT

; 1431 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1432 :     PySequenceMethods *m;
; 1433 : 
; 1434 :     if (s == NULL || o == NULL)

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR s$[rsp], 0
  00014	74 08		 je	 SHORT $LN5@PySequence@5
  00016	48 83 7c 24 48
	00		 cmp	 QWORD PTR o$[rsp], 0
  0001c	75 0a		 jne	 SHORT $LN6@PySequence@5
$LN5@PySequence@5:

; 1435 :         return null_error();

  0001e	e8 00 00 00 00	 call	 null_error
  00023	e9 d1 00 00 00	 jmp	 $LN7@PySequence@5
$LN6@PySequence@5:

; 1436 : 
; 1437 :     m = s->ob_type->tp_as_sequence;

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0002d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00031	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00038	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1438 :     if (m && m->sq_inplace_concat)

  0003d	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00043	74 23		 je	 SHORT $LN4@PySequence@5
  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0004a	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  0004f	74 17		 je	 SHORT $LN4@PySequence@5

; 1439 :         return m->sq_inplace_concat(s, o);

  00051	48 8b 54 24 48	 mov	 rdx, QWORD PTR o$[rsp]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00060	ff 50 40	 call	 QWORD PTR [rax+64]
  00063	e9 91 00 00 00	 jmp	 $LN7@PySequence@5
$LN4@PySequence@5:

; 1440 :     if (m && m->sq_concat)

  00068	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  0006e	74 20		 je	 SHORT $LN3@PySequence@5
  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00075	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0007a	74 14		 je	 SHORT $LN3@PySequence@5

; 1441 :         return m->sq_concat(s, o);

  0007c	48 8b 54 24 48	 mov	 rdx, QWORD PTR o$[rsp]
  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00086	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0008b	ff 50 08	 call	 QWORD PTR [rax+8]
  0008e	eb 69		 jmp	 SHORT $LN7@PySequence@5
$LN3@PySequence@5:

; 1442 : 
; 1443 :     if (PySequence_Check(s) && PySequence_Check(o)) {

  00090	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00095	e8 00 00 00 00	 call	 PySequence_Check
  0009a	85 c0		 test	 eax, eax
  0009c	74 4a		 je	 SHORT $LN2@PySequence@5
  0009e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR o$[rsp]
  000a3	e8 00 00 00 00	 call	 PySequence_Check
  000a8	85 c0		 test	 eax, eax
  000aa	74 3c		 je	 SHORT $LN2@PySequence@5

; 1444 :         PyObject *result = binary_iop1(s, o, NB_SLOT(nb_inplace_add),
; 1445 :                                        NB_SLOT(nb_add));

  000ac	45 33 c9	 xor	 r9d, r9d
  000af	41 b8 98 00 00
	00		 mov	 r8d, 152		; 00000098H
  000b5	48 8b 54 24 48	 mov	 rdx, QWORD PTR o$[rsp]
  000ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000bf	e8 00 00 00 00	 call	 binary_iop1
  000c4	48 89 44 24 28	 mov	 QWORD PTR result$21548[rsp], rax

; 1446 :         if (result != Py_NotImplemented)

  000c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000d0	48 39 44 24 28	 cmp	 QWORD PTR result$21548[rsp], rax
  000d5	74 07		 je	 SHORT $LN1@PySequence@5

; 1447 :             return result;

  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR result$21548[rsp]
  000dc	eb 1b		 jmp	 SHORT $LN7@PySequence@5
$LN1@PySequence@5:

; 1448 :         Py_DECREF(result);

  000de	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$21548[rsp]
  000e3	e8 00 00 00 00	 call	 _Py_DecRef
$LN2@PySequence@5:

; 1449 :     }
; 1450 :     return type_error("'%.200s' object can't be concatenated", s);

  000e8	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@OBIBNDFJ@?8?$CF?4200s?8?5object?5can?8t?5be?5concate@
  000f4	e8 00 00 00 00	 call	 type_error
$LN7@PySequence@5:

; 1451 : }

  000f9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fd	c3		 ret	 0
PySequence_InPlaceConcat ENDP
_TEXT	ENDS
PUBLIC	PySequence_InPlaceRepeat
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_InPlaceRepeat DD imagerel $LN9
	DD	imagerel $LN9+275
	DD	imagerel $unwind$PySequence_InPlaceRepeat
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_InPlaceRepeat DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySequence_InPlaceRepeat
_TEXT	SEGMENT
m$ = 32
n$21568 = 40
result$21569 = 48
o$ = 80
count$ = 88
PySequence_InPlaceRepeat PROC				; COMDAT

; 1455 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1456 :     PySequenceMethods *m;
; 1457 : 
; 1458 :     if (o == NULL)

  0000e	48 83 7c 24 50
	00		 cmp	 QWORD PTR o$[rsp], 0
  00014	75 0a		 jne	 SHORT $LN6@PySequence@6

; 1459 :         return null_error();

  00016	e8 00 00 00 00	 call	 null_error
  0001b	e9 ee 00 00 00	 jmp	 $LN7@PySequence@6
$LN6@PySequence@6:

; 1460 : 
; 1461 :     m = o->ob_type->tp_as_sequence;

  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR o$[rsp]
  00025	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00029	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00030	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1462 :     if (m && m->sq_inplace_repeat)

  00035	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  0003b	74 23		 je	 SHORT $LN5@PySequence@6
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00042	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00047	74 17		 je	 SHORT $LN5@PySequence@6

; 1463 :         return m->sq_inplace_repeat(o, count);

  00049	48 8b 54 24 58	 mov	 rdx, QWORD PTR count$[rsp]
  0004e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00053	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00058	ff 50 48	 call	 QWORD PTR [rax+72]
  0005b	e9 ae 00 00 00	 jmp	 $LN7@PySequence@6
$LN5@PySequence@6:

; 1464 :     if (m && m->sq_repeat)

  00060	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00066	74 23		 je	 SHORT $LN4@PySequence@6
  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0006d	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00072	74 17		 je	 SHORT $LN4@PySequence@6

; 1465 :         return m->sq_repeat(o, count);

  00074	48 8b 54 24 58	 mov	 rdx, QWORD PTR count$[rsp]
  00079	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00083	ff 50 10	 call	 QWORD PTR [rax+16]
  00086	e9 83 00 00 00	 jmp	 $LN7@PySequence@6
$LN4@PySequence@6:

; 1466 : 
; 1467 :     if (PySequence_Check(o)) {

  0008b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00090	e8 00 00 00 00	 call	 PySequence_Check
  00095	85 c0		 test	 eax, eax
  00097	74 64		 je	 SHORT $LN3@PySequence@6

; 1468 :         PyObject *n, *result;
; 1469 :         n = PyLong_FromSsize_t(count);

  00099	48 8b 4c 24 58	 mov	 rcx, QWORD PTR count$[rsp]
  0009e	e8 00 00 00 00	 call	 PyLong_FromSsize_t
  000a3	48 89 44 24 28	 mov	 QWORD PTR n$21568[rsp], rax

; 1470 :         if (n == NULL)

  000a8	48 83 7c 24 28
	00		 cmp	 QWORD PTR n$21568[rsp], 0
  000ae	75 04		 jne	 SHORT $LN2@PySequence@6

; 1471 :             return NULL;

  000b0	33 c0		 xor	 eax, eax
  000b2	eb 5a		 jmp	 SHORT $LN7@PySequence@6
$LN2@PySequence@6:

; 1472 :         result = binary_iop1(o, n, NB_SLOT(nb_inplace_multiply),
; 1473 :                              NB_SLOT(nb_multiply));

  000b4	41 b9 10 00 00
	00		 mov	 r9d, 16
  000ba	41 b8 a8 00 00
	00		 mov	 r8d, 168		; 000000a8H
  000c0	48 8b 54 24 28	 mov	 rdx, QWORD PTR n$21568[rsp]
  000c5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  000ca	e8 00 00 00 00	 call	 binary_iop1
  000cf	48 89 44 24 30	 mov	 QWORD PTR result$21569[rsp], rax

; 1474 :         Py_DECREF(n);

  000d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$21568[rsp]
  000d9	e8 00 00 00 00	 call	 _Py_DecRef

; 1475 :         if (result != Py_NotImplemented)

  000de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NotImplementedStruct
  000e5	48 39 44 24 30	 cmp	 QWORD PTR result$21569[rsp], rax
  000ea	74 07		 je	 SHORT $LN1@PySequence@6

; 1476 :             return result;

  000ec	48 8b 44 24 30	 mov	 rax, QWORD PTR result$21569[rsp]
  000f1	eb 1b		 jmp	 SHORT $LN7@PySequence@6
$LN1@PySequence@6:

; 1477 :         Py_DECREF(result);

  000f3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$21569[rsp]
  000f8	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PySequence@6:

; 1478 :     }
; 1479 :     return type_error("'%.200s' object can't be repeated", o);

  000fd	48 8b 54 24 50	 mov	 rdx, QWORD PTR o$[rsp]
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@NJPBBLBE@?8?$CF?4200s?8?5object?5can?8t?5be?5repeate@
  00109	e8 00 00 00 00	 call	 type_error
$LN7@PySequence@6:

; 1480 : }

  0010e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00112	c3		 ret	 0
PySequence_InPlaceRepeat ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CK@CHFKMAPO@?8?$CF?4200s?8?5object?5does?5not?5support@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_GetItem DD imagerel $LN8
	DD	imagerel $LN8+184
	DD	imagerel $unwind$PySequence_GetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_GetItem DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CK@CHFKMAPO@?8?$CF?4200s?8?5object?5does?5not?5support@
CONST	SEGMENT
??_C@_0CK@CHFKMAPO@?8?$CF?4200s?8?5object?5does?5not?5support@ DB '''%.20'
	DB	'0s'' object does not support indexing', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySequence_GetItem
_TEXT	SEGMENT
m$ = 32
l$21593 = 40
s$ = 64
i$ = 72
PySequence_GetItem PROC					; COMDAT

; 1484 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1485 :     PySequenceMethods *m;
; 1486 : 
; 1487 :     if (s == NULL)

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR s$[rsp], 0
  00014	75 0a		 jne	 SHORT $LN5@PySequence@7

; 1488 :         return null_error();

  00016	e8 00 00 00 00	 call	 null_error
  0001b	e9 93 00 00 00	 jmp	 $LN6@PySequence@7
$LN5@PySequence@7:

; 1489 : 
; 1490 :     m = s->ob_type->tp_as_sequence;

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00025	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00029	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00030	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1491 :     if (m && m->sq_item) {

  00035	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  0003b	74 65		 je	 SHORT $LN4@PySequence@7
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00042	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00047	74 59		 je	 SHORT $LN4@PySequence@7

; 1492 :         if (i < 0) {

  00049	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  0004f	7d 3d		 jge	 SHORT $LN3@PySequence@7

; 1493 :             if (m->sq_length) {

  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00056	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0005a	74 32		 je	 SHORT $LN2@PySequence@7

; 1494 :                 Py_ssize_t l = (*m->sq_length)(s);

  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00066	ff 10		 call	 QWORD PTR [rax]
  00068	48 89 44 24 28	 mov	 QWORD PTR l$21593[rsp], rax

; 1495 :                 if (l < 0)

  0006d	48 83 7c 24 28
	00		 cmp	 QWORD PTR l$21593[rsp], 0
  00073	7d 04		 jge	 SHORT $LN1@PySequence@7

; 1496 :                     return NULL;

  00075	33 c0		 xor	 eax, eax
  00077	eb 3a		 jmp	 SHORT $LN6@PySequence@7
$LN1@PySequence@7:

; 1497 :                 i += l;

  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR l$21593[rsp]
  0007e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  00083	48 03 c8	 add	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	48 89 44 24 48	 mov	 QWORD PTR i$[rsp], rax
$LN2@PySequence@7:
$LN3@PySequence@7:

; 1498 :             }
; 1499 :         }
; 1500 :         return m->sq_item(s, i);

  0008e	48 8b 54 24 48	 mov	 rdx, QWORD PTR i$[rsp]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0009d	ff 50 18	 call	 QWORD PTR [rax+24]
  000a0	eb 11		 jmp	 SHORT $LN6@PySequence@7
$LN4@PySequence@7:

; 1501 :     }
; 1502 : 
; 1503 :     return type_error("'%.200s' object does not support indexing", s);

  000a2	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@CHFKMAPO@?8?$CF?4200s?8?5object?5does?5not?5support@
  000ae	e8 00 00 00 00	 call	 type_error
$LN6@PySequence@7:

; 1504 : }

  000b3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b7	c3		 ret	 0
PySequence_GetItem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BP@EODAODDG@?8?$CF?4200s?8?5object?5is?5unsliceable?$AA@ ; `string'
PUBLIC	PySequence_GetSlice
EXTRN	_PySlice_FromIndices:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_GetSlice DD imagerel $LN6
	DD	imagerel $LN6+172
	DD	imagerel $unwind$PySequence_GetSlice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_GetSlice DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0BP@EODAODDG@?8?$CF?4200s?8?5object?5is?5unsliceable?$AA@
CONST	SEGMENT
??_C@_0BP@EODAODDG@?8?$CF?4200s?8?5object?5is?5unsliceable?$AA@ DB '''%.2'
	DB	'00s'' object is unsliceable', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySequence_GetSlice
_TEXT	SEGMENT
mp$ = 32
slice$21608 = 40
res$21607 = 48
s$ = 80
i1$ = 88
i2$ = 96
PySequence_GetSlice PROC				; COMDAT

; 1508 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1509 :     PyMappingMethods *mp;
; 1510 : 
; 1511 :     if (!s) return null_error();

  00013	48 83 7c 24 50
	00		 cmp	 QWORD PTR s$[rsp], 0
  00019	75 0a		 jne	 SHORT $LN3@PySequence@8
  0001b	e8 00 00 00 00	 call	 null_error
  00020	e9 82 00 00 00	 jmp	 $LN4@PySequence@8
$LN3@PySequence@8:

; 1512 : 
; 1513 :     mp = s->ob_type->tp_as_mapping;

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0002a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002e	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00035	48 89 44 24 20	 mov	 QWORD PTR mp$[rsp], rax

; 1514 :     if (mp && mp->mp_subscript) {

  0003a	48 83 7c 24 20
	00		 cmp	 QWORD PTR mp$[rsp], 0
  00040	74 54		 je	 SHORT $LN2@PySequence@8
  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR mp$[rsp]
  00047	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0004c	74 48		 je	 SHORT $LN2@PySequence@8

; 1515 :         PyObject *res;
; 1516 :         PyObject *slice = _PySlice_FromIndices(i1, i2);

  0004e	48 8b 54 24 60	 mov	 rdx, QWORD PTR i2$[rsp]
  00053	48 8b 4c 24 58	 mov	 rcx, QWORD PTR i1$[rsp]
  00058	e8 00 00 00 00	 call	 _PySlice_FromIndices
  0005d	48 89 44 24 28	 mov	 QWORD PTR slice$21608[rsp], rax

; 1517 :         if (!slice)

  00062	48 83 7c 24 28
	00		 cmp	 QWORD PTR slice$21608[rsp], 0
  00068	75 04		 jne	 SHORT $LN1@PySequence@8

; 1518 :             return NULL;

  0006a	33 c0		 xor	 eax, eax
  0006c	eb 39		 jmp	 SHORT $LN4@PySequence@8
$LN1@PySequence@8:

; 1519 :         res = mp->mp_subscript(s, slice);

  0006e	48 8b 54 24 28	 mov	 rdx, QWORD PTR slice$21608[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR mp$[rsp]
  0007d	ff 50 08	 call	 QWORD PTR [rax+8]
  00080	48 89 44 24 30	 mov	 QWORD PTR res$21607[rsp], rax

; 1520 :         Py_DECREF(slice);

  00085	48 8b 4c 24 28	 mov	 rcx, QWORD PTR slice$21608[rsp]
  0008a	e8 00 00 00 00	 call	 _Py_DecRef

; 1521 :         return res;

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR res$21607[rsp]
  00094	eb 11		 jmp	 SHORT $LN4@PySequence@8
$LN2@PySequence@8:

; 1522 :     }
; 1523 : 
; 1524 :     return type_error("'%.200s' object is unsliceable", s);

  00096	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@EODAODDG@?8?$CF?4200s?8?5object?5is?5unsliceable?$AA@
  000a2	e8 00 00 00 00	 call	 type_error
$LN4@PySequence@8:

; 1525 : }

  000a7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ab	c3		 ret	 0
PySequence_GetSlice ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_SetItem DD imagerel $LN8
	DD	imagerel $LN8+207
	DD	imagerel $unwind$PySequence_SetItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_SetItem DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySequence_SetItem
_TEXT	SEGMENT
m$ = 32
l$21626 = 40
s$ = 64
i$ = 72
o$ = 80
PySequence_SetItem PROC					; COMDAT

; 1529 : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1530 :     PySequenceMethods *m;
; 1531 : 
; 1532 :     if (s == NULL) {

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR s$[rsp], 0
  00019	75 0f		 jne	 SHORT $LN5@PySequence@9

; 1533 :         null_error();

  0001b	e8 00 00 00 00	 call	 null_error

; 1534 :         return -1;

  00020	b8 ff ff ff ff	 mov	 eax, -1
  00025	e9 a0 00 00 00	 jmp	 $LN6@PySequence@9
$LN5@PySequence@9:

; 1535 :     }
; 1536 : 
; 1537 :     /*
; 1538 :     if (Px_CHECK_PROTECTION(s, NULL, o))
; 1539 :         return -1;
; 1540 :     */
; 1541 : 
; 1542 :     m = s->ob_type->tp_as_sequence;

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0002f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00033	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0003a	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1543 :     if (m && m->sq_ass_item) {

  0003f	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00045	74 6d		 je	 SHORT $LN4@PySequence@9
  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0004c	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00051	74 61		 je	 SHORT $LN4@PySequence@9

; 1544 :         if (i < 0) {

  00053	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  00059	7d 40		 jge	 SHORT $LN3@PySequence@9

; 1545 :             if (m->sq_length) {

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00060	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00064	74 35		 je	 SHORT $LN2@PySequence@9

; 1546 :                 Py_ssize_t l = (*m->sq_length)(s);

  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0006b	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00070	ff 10		 call	 QWORD PTR [rax]
  00072	48 89 44 24 28	 mov	 QWORD PTR l$21626[rsp], rax

; 1547 :                 if (l < 0)

  00077	48 83 7c 24 28
	00		 cmp	 QWORD PTR l$21626[rsp], 0
  0007d	7d 07		 jge	 SHORT $LN1@PySequence@9

; 1548 :                     return -1;

  0007f	b8 ff ff ff ff	 mov	 eax, -1
  00084	eb 44		 jmp	 SHORT $LN6@PySequence@9
$LN1@PySequence@9:

; 1549 :                 i += l;

  00086	48 8b 44 24 28	 mov	 rax, QWORD PTR l$21626[rsp]
  0008b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  00090	48 03 c8	 add	 rcx, rax
  00093	48 8b c1	 mov	 rax, rcx
  00096	48 89 44 24 48	 mov	 QWORD PTR i$[rsp], rax
$LN2@PySequence@9:
$LN3@PySequence@9:

; 1550 :             }
; 1551 :         }
; 1552 :         return m->sq_ass_item(s, i, o);

  0009b	4c 8b 44 24 50	 mov	 r8, QWORD PTR o$[rsp]
  000a0	48 8b 54 24 48	 mov	 rdx, QWORD PTR i$[rsp]
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  000af	ff 50 28	 call	 QWORD PTR [rax+40]
  000b2	eb 16		 jmp	 SHORT $LN6@PySequence@9
$LN4@PySequence@9:

; 1553 :     }
; 1554 : 
; 1555 :     type_error("'%.200s' object does not support item assignment", s);

  000b4	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@PKENFCMJ@?8?$CF?4200s?8?5object?5does?5not?5support@
  000c0	e8 00 00 00 00	 call	 type_error

; 1556 :     return -1;

  000c5	b8 ff ff ff ff	 mov	 eax, -1
$LN6@PySequence@9:

; 1557 : }

  000ca	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ce	c3		 ret	 0
PySequence_SetItem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@CJGIKPDO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_DelItem DD imagerel $LN8
	DD	imagerel $LN8+200
	DD	imagerel $unwind$PySequence_DelItem
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_DelItem DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0CO@CJGIKPDO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
CONST	SEGMENT
??_C@_0CO@CJGIKPDO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ DB '''%.2'
	DB	'00s'' object doesn''t support item deletion', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySequence_DelItem
_TEXT	SEGMENT
m$ = 32
l$21639 = 40
s$ = 64
i$ = 72
PySequence_DelItem PROC					; COMDAT

; 1561 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1562 :     PySequenceMethods *m;
; 1563 : 
; 1564 :     if (s == NULL) {

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR s$[rsp], 0
  00014	75 0f		 jne	 SHORT $LN5@PySequence@10

; 1565 :         null_error();

  00016	e8 00 00 00 00	 call	 null_error

; 1566 :         return -1;

  0001b	b8 ff ff ff ff	 mov	 eax, -1
  00020	e9 9e 00 00 00	 jmp	 $LN6@PySequence@10
$LN5@PySequence@10:

; 1567 :     }
; 1568 : 
; 1569 :     /*
; 1570 :     if (Px_CHECK_PROTECTION(s, NULL, NULL))
; 1571 :         return -1;
; 1572 :     */
; 1573 : 
; 1574 :     m = s->ob_type->tp_as_sequence;

  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0002a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002e	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00035	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1575 :     if (m && m->sq_ass_item) {

  0003a	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  00040	74 6b		 je	 SHORT $LN4@PySequence@10
  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00047	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0004c	74 5f		 je	 SHORT $LN4@PySequence@10

; 1576 :         if (i < 0) {

  0004e	48 83 7c 24 48
	00		 cmp	 QWORD PTR i$[rsp], 0
  00054	7d 40		 jge	 SHORT $LN3@PySequence@10

; 1577 :             if (m->sq_length) {

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0005b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0005f	74 35		 je	 SHORT $LN2@PySequence@10

; 1578 :                 Py_ssize_t l = (*m->sq_length)(s);

  00061	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  0006b	ff 10		 call	 QWORD PTR [rax]
  0006d	48 89 44 24 28	 mov	 QWORD PTR l$21639[rsp], rax

; 1579 :                 if (l < 0)

  00072	48 83 7c 24 28
	00		 cmp	 QWORD PTR l$21639[rsp], 0
  00078	7d 07		 jge	 SHORT $LN1@PySequence@10

; 1580 :                     return -1;

  0007a	b8 ff ff ff ff	 mov	 eax, -1
  0007f	eb 42		 jmp	 SHORT $LN6@PySequence@10
$LN1@PySequence@10:

; 1581 :                 i += l;

  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR l$21639[rsp]
  00086	48 8b 4c 24 48	 mov	 rcx, QWORD PTR i$[rsp]
  0008b	48 03 c8	 add	 rcx, rax
  0008e	48 8b c1	 mov	 rax, rcx
  00091	48 89 44 24 48	 mov	 QWORD PTR i$[rsp], rax
$LN2@PySequence@10:
$LN3@PySequence@10:

; 1582 :             }
; 1583 :         }
; 1584 :         return m->sq_ass_item(s, i, (PyObject *)NULL);

  00096	45 33 c0	 xor	 r8d, r8d
  00099	48 8b 54 24 48	 mov	 rdx, QWORD PTR i$[rsp]
  0009e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  000a8	ff 50 28	 call	 QWORD PTR [rax+40]
  000ab	eb 16		 jmp	 SHORT $LN6@PySequence@10
$LN4@PySequence@10:

; 1585 :     }
; 1586 : 
; 1587 :     type_error("'%.200s' object doesn't support item deletion", s);

  000ad	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@CJGIKPDO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
  000b9	e8 00 00 00 00	 call	 type_error

; 1588 :     return -1;

  000be	b8 ff ff ff ff	 mov	 eax, -1
$LN6@PySequence@10:

; 1589 : }

  000c3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c7	c3		 ret	 0
PySequence_DelItem ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DB@GONKANHO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ ; `string'
PUBLIC	PySequence_SetSlice
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_SetSlice DD imagerel $LN6
	DD	imagerel $LN6+193
	DD	imagerel $unwind$PySequence_SetSlice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_SetSlice DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT ??_C@_0DB@GONKANHO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
CONST	SEGMENT
??_C@_0DB@GONKANHO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ DB '''%.2'
	DB	'00s'' object doesn''t support slice assignment', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySequence_SetSlice
_TEXT	SEGMENT
mp$ = 32
slice$21658 = 40
res$21657 = 48
s$ = 80
i1$ = 88
i2$ = 96
o$ = 104
PySequence_SetSlice PROC				; COMDAT

; 1593 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1594 :     PyMappingMethods *mp;
; 1595 : 
; 1596 :     if (s == NULL) {

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR s$[rsp], 0
  0001e	75 0f		 jne	 SHORT $LN3@PySequence@11

; 1597 :         null_error();

  00020	e8 00 00 00 00	 call	 null_error

; 1598 :         return -1;

  00025	b8 ff ff ff ff	 mov	 eax, -1
  0002a	e9 8d 00 00 00	 jmp	 $LN4@PySequence@11
$LN3@PySequence@11:

; 1599 :     }
; 1600 : 
; 1601 :     /*
; 1602 :     if (Px_CHECK_PROTECTION(s, NULL, o))
; 1603 :         return -1;
; 1604 :     */
; 1605 : 
; 1606 :     mp = s->ob_type->tp_as_mapping;

  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00034	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00038	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  0003f	48 89 44 24 20	 mov	 QWORD PTR mp$[rsp], rax

; 1607 :     if (mp && mp->mp_ass_subscript) {

  00044	48 83 7c 24 20
	00		 cmp	 QWORD PTR mp$[rsp], 0
  0004a	74 5a		 je	 SHORT $LN2@PySequence@11
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR mp$[rsp]
  00051	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00056	74 4e		 je	 SHORT $LN2@PySequence@11

; 1608 :         int res;
; 1609 :         PyObject *slice = _PySlice_FromIndices(i1, i2);

  00058	48 8b 54 24 60	 mov	 rdx, QWORD PTR i2$[rsp]
  0005d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR i1$[rsp]
  00062	e8 00 00 00 00	 call	 _PySlice_FromIndices
  00067	48 89 44 24 28	 mov	 QWORD PTR slice$21658[rsp], rax

; 1610 :         if (!slice)

  0006c	48 83 7c 24 28
	00		 cmp	 QWORD PTR slice$21658[rsp], 0
  00072	75 07		 jne	 SHORT $LN1@PySequence@11

; 1611 :             return -1;

  00074	b8 ff ff ff ff	 mov	 eax, -1
  00079	eb 41		 jmp	 SHORT $LN4@PySequence@11
$LN1@PySequence@11:

; 1612 :         res = mp->mp_ass_subscript(s, slice, o);

  0007b	4c 8b 44 24 68	 mov	 r8, QWORD PTR o$[rsp]
  00080	48 8b 54 24 28	 mov	 rdx, QWORD PTR slice$21658[rsp]
  00085	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0008a	48 8b 44 24 20	 mov	 rax, QWORD PTR mp$[rsp]
  0008f	ff 50 10	 call	 QWORD PTR [rax+16]
  00092	89 44 24 30	 mov	 DWORD PTR res$21657[rsp], eax

; 1613 :         Py_DECREF(slice);

  00096	48 8b 4c 24 28	 mov	 rcx, QWORD PTR slice$21658[rsp]
  0009b	e8 00 00 00 00	 call	 _Py_DecRef

; 1614 :         return res;

  000a0	8b 44 24 30	 mov	 eax, DWORD PTR res$21657[rsp]
  000a4	eb 16		 jmp	 SHORT $LN4@PySequence@11
$LN2@PySequence@11:

; 1615 :     }
; 1616 : 
; 1617 :     type_error("'%.200s' object doesn't support slice assignment", s);

  000a6	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@GONKANHO@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
  000b2	e8 00 00 00 00	 call	 type_error

; 1618 :     return -1;

  000b7	b8 ff ff ff ff	 mov	 eax, -1
$LN4@PySequence@11:

; 1619 : }

  000bc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c0	c3		 ret	 0
PySequence_SetSlice ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CP@OGIKHGOB@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ ; `string'
PUBLIC	PySequence_DelSlice
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_DelSlice DD imagerel $LN6
	DD	imagerel $LN6+186
	DD	imagerel $unwind$PySequence_DelSlice
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_DelSlice DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT ??_C@_0CP@OGIKHGOB@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
CONST	SEGMENT
??_C@_0CP@OGIKHGOB@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@ DB '''%.2'
	DB	'00s'' object doesn''t support slice deletion', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySequence_DelSlice
_TEXT	SEGMENT
mp$ = 32
slice$21674 = 40
res$21673 = 48
s$ = 80
i1$ = 88
i2$ = 96
PySequence_DelSlice PROC				; COMDAT

; 1623 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1624 :     PyMappingMethods *mp;
; 1625 : 
; 1626 :     if (s == NULL) {

  00013	48 83 7c 24 50
	00		 cmp	 QWORD PTR s$[rsp], 0
  00019	75 0f		 jne	 SHORT $LN3@PySequence@12

; 1627 :         null_error();

  0001b	e8 00 00 00 00	 call	 null_error

; 1628 :         return -1;

  00020	b8 ff ff ff ff	 mov	 eax, -1
  00025	e9 8b 00 00 00	 jmp	 $LN4@PySequence@12
$LN3@PySequence@12:

; 1629 :     }
; 1630 : 
; 1631 :     mp = s->ob_type->tp_as_mapping;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0002f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00033	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  0003a	48 89 44 24 20	 mov	 QWORD PTR mp$[rsp], rax

; 1632 :     if (mp && mp->mp_ass_subscript) {

  0003f	48 83 7c 24 20
	00		 cmp	 QWORD PTR mp$[rsp], 0
  00045	74 58		 je	 SHORT $LN2@PySequence@12
  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR mp$[rsp]
  0004c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00051	74 4c		 je	 SHORT $LN2@PySequence@12

; 1633 :         int res;
; 1634 :         PyObject *slice = _PySlice_FromIndices(i1, i2);

  00053	48 8b 54 24 60	 mov	 rdx, QWORD PTR i2$[rsp]
  00058	48 8b 4c 24 58	 mov	 rcx, QWORD PTR i1$[rsp]
  0005d	e8 00 00 00 00	 call	 _PySlice_FromIndices
  00062	48 89 44 24 28	 mov	 QWORD PTR slice$21674[rsp], rax

; 1635 :         if (!slice)

  00067	48 83 7c 24 28
	00		 cmp	 QWORD PTR slice$21674[rsp], 0
  0006d	75 07		 jne	 SHORT $LN1@PySequence@12

; 1636 :             return -1;

  0006f	b8 ff ff ff ff	 mov	 eax, -1
  00074	eb 3f		 jmp	 SHORT $LN4@PySequence@12
$LN1@PySequence@12:

; 1637 :         res = mp->mp_ass_subscript(s, slice, NULL);

  00076	45 33 c0	 xor	 r8d, r8d
  00079	48 8b 54 24 28	 mov	 rdx, QWORD PTR slice$21674[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR mp$[rsp]
  00088	ff 50 10	 call	 QWORD PTR [rax+16]
  0008b	89 44 24 30	 mov	 DWORD PTR res$21673[rsp], eax

; 1638 :         Py_DECREF(slice);

  0008f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR slice$21674[rsp]
  00094	e8 00 00 00 00	 call	 _Py_DecRef

; 1639 :         return res;

  00099	8b 44 24 30	 mov	 eax, DWORD PTR res$21673[rsp]
  0009d	eb 16		 jmp	 SHORT $LN4@PySequence@12
$LN2@PySequence@12:

; 1640 :     }
; 1641 :     type_error("'%.200s' object doesn't support slice deletion", s);

  0009f	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@OGIKHGOB@?8?$CF?4200s?8?5object?5doesn?8t?5support?5@
  000ab	e8 00 00 00 00	 call	 type_error

; 1642 :     return -1;

  000b0	b8 ff ff ff ff	 mov	 eax, -1
$LN4@PySequence@12:

; 1643 : }

  000b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b9	c3		 ret	 0
PySequence_DelSlice ENDP
_TEXT	ENDS
PUBLIC	PyIter_Next
PUBLIC	PyObject_GetIter
PUBLIC	PySequence_Tuple
EXTRN	_PyTuple_Resize:PROC
EXTRN	PyTuple_New:PROC
EXTRN	PyList_AsTuple:PROC
EXTRN	PyTuple_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Tuple DD imagerel $LN22
	DD	imagerel $LN22+508
	DD	imagerel $unwind$PySequence_Tuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Tuple DD 010901H
	DD	0a209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySequence_Tuple
_TEXT	SEGMENT
it$ = 32
n$ = 40
result$ = 48
j$ = 56
item$21704 = 64
oldn$21709 = 72
v$ = 96
PySequence_Tuple PROC					; COMDAT

; 1647 : {

$LN22:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1648 :     PyObject *it;  /* iter(v) */
; 1649 :     Py_ssize_t n;             /* guess for result tuple size */
; 1650 :     PyObject *result = NULL;

  00009	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 1651 :     Py_ssize_t j;
; 1652 : 
; 1653 :     if (v == NULL)

  00012	48 83 7c 24 60
	00		 cmp	 QWORD PTR v$[rsp], 0
  00018	75 0a		 jne	 SHORT $LN19@PySequence@13

; 1654 :         return null_error();

  0001a	e8 00 00 00 00	 call	 null_error
  0001f	e9 d3 01 00 00	 jmp	 $LN20@PySequence@13
$LN19@PySequence@13:

; 1655 : 
; 1656 :     /* Special-case the common tuple and list cases, for efficiency. */
; 1657 :     if (PyTuple_CheckExact(v)) {

  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  0002b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  00030	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00034	75 14		 jne	 SHORT $LN18@PySequence@13

; 1658 :         /* Note that we can't know whether it's safe to return
; 1659 :            a tuple *subclass* instance as-is, hence the restriction
; 1660 :            to exact tuples here.  In contrast, lists always make
; 1661 :            a copy, so there's no need for exactness below. */
; 1662 :         Py_INCREF(v);

  00036	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  0003b	e8 00 00 00 00	 call	 _Py_IncRef

; 1663 :         return v;

  00040	48 8b 44 24 60	 mov	 rax, QWORD PTR v$[rsp]
  00045	e9 ad 01 00 00	 jmp	 $LN20@PySequence@13
$LN18@PySequence@13:

; 1664 :     }
; 1665 :     if (PyList_Check(v))

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR v$[rsp]
  0004f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00053	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00059	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0005e	85 c0		 test	 eax, eax
  00060	74 0f		 je	 SHORT $LN17@PySequence@13

; 1666 :         return PyList_AsTuple(v);

  00062	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  00067	e8 00 00 00 00	 call	 PyList_AsTuple
  0006c	e9 86 01 00 00	 jmp	 $LN20@PySequence@13
$LN17@PySequence@13:

; 1667 : 
; 1668 :     /* Get iterator. */
; 1669 :     it = PyObject_GetIter(v);

  00071	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  00076	e8 00 00 00 00	 call	 PyObject_GetIter
  0007b	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 1670 :     if (it == NULL)

  00080	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00086	75 07		 jne	 SHORT $LN16@PySequence@13

; 1671 :         return NULL;

  00088	33 c0		 xor	 eax, eax
  0008a	e9 68 01 00 00	 jmp	 $LN20@PySequence@13
$LN16@PySequence@13:

; 1672 : 
; 1673 :     /* Guess result size and allocate space. */
; 1674 :     n = _PyObject_LengthHint(v, 10);

  0008f	ba 0a 00 00 00	 mov	 edx, 10
  00094	48 8b 4c 24 60	 mov	 rcx, QWORD PTR v$[rsp]
  00099	e8 00 00 00 00	 call	 _PyObject_LengthHint
  0009e	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 1675 :     if (n == -1)

  000a3	48 83 7c 24 28
	ff		 cmp	 QWORD PTR n$[rsp], -1
  000a9	75 05		 jne	 SHORT $LN15@PySequence@13

; 1676 :         goto Fail;

  000ab	e9 23 01 00 00	 jmp	 $Fail$21698
$LN15@PySequence@13:

; 1677 :     result = PyTuple_New(n);

  000b0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$[rsp]
  000b5	e8 00 00 00 00	 call	 PyTuple_New
  000ba	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1678 :     if (result == NULL)

  000bf	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  000c5	75 05		 jne	 SHORT $LN14@PySequence@13

; 1679 :         goto Fail;

  000c7	e9 07 01 00 00	 jmp	 $Fail$21698
$LN14@PySequence@13:

; 1680 : 
; 1681 :     /* Fill the tuple. */
; 1682 :     for (j = 0; ; ++j) {

  000cc	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR j$[rsp], 0
  000d5	eb 0d		 jmp	 SHORT $LN13@PySequence@13
$LN12@PySequence@13:
  000d7	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  000dc	48 ff c0	 inc	 rax
  000df	48 89 44 24 38	 mov	 QWORD PTR j$[rsp], rax
$LN13@PySequence@13:

; 1683 :         PyObject *item = PyIter_Next(it);

  000e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000e9	e8 00 00 00 00	 call	 PyIter_Next
  000ee	48 89 44 24 40	 mov	 QWORD PTR item$21704[rsp], rax

; 1684 :         if (item == NULL) {

  000f3	48 83 7c 24 40
	00		 cmp	 QWORD PTR item$21704[rsp], 0
  000f9	75 14		 jne	 SHORT $LN10@PySequence@13

; 1685 :             if (PyErr_Occurred())

  000fb	e8 00 00 00 00	 call	 PyErr_Occurred
  00100	48 85 c0	 test	 rax, rax
  00103	74 05		 je	 SHORT $LN9@PySequence@13

; 1686 :                 goto Fail;

  00105	e9 c9 00 00 00	 jmp	 $Fail$21698
$LN9@PySequence@13:

; 1687 :             break;

  0010a	e9 92 00 00 00	 jmp	 $LN11@PySequence@13
$LN10@PySequence@13:

; 1688 :         }
; 1689 :         if (j >= n) {

  0010f	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00114	48 39 44 24 38	 cmp	 QWORD PTR j$[rsp], rax
  00119	7c 6d		 jl	 SHORT $LN8@PySequence@13

; 1690 :             Py_ssize_t oldn = n;

  0011b	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00120	48 89 44 24 48	 mov	 QWORD PTR oldn$21709[rsp], rax

; 1691 :             /* The over-allocation strategy can grow a bit faster
; 1692 :                than for lists because unlike lists the
; 1693 :                over-allocation isn't permanent -- we reclaim
; 1694 :                the excess before the end of this routine.
; 1695 :                So, grow by ten and then add 25%.
; 1696 :             */
; 1697 :             n += 10;

  00125	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0012a	48 83 c0 0a	 add	 rax, 10
  0012e	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 1698 :             n += n >> 2;

  00133	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  00138	48 c1 f8 02	 sar	 rax, 2
  0013c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR n$[rsp]
  00141	48 03 c8	 add	 rcx, rax
  00144	48 8b c1	 mov	 rax, rcx
  00147	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 1699 :             if (n < oldn) {

  0014c	48 8b 44 24 48	 mov	 rax, QWORD PTR oldn$21709[rsp]
  00151	48 39 44 24 28	 cmp	 QWORD PTR n$[rsp], rax
  00156	7d 11		 jge	 SHORT $LN7@PySequence@13

; 1700 :                 /* Check for overflow */
; 1701 :                 PyErr_NoMemory();

  00158	e8 00 00 00 00	 call	 PyErr_NoMemory

; 1702 :                 Py_DECREF(item);

  0015d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$21704[rsp]
  00162	e8 00 00 00 00	 call	 _Py_DecRef

; 1703 :                 goto Fail;

  00167	eb 6a		 jmp	 SHORT $Fail$21698
$LN7@PySequence@13:

; 1704 :             }
; 1705 :             if (_PyTuple_Resize(&result, n) != 0) {

  00169	48 8b 54 24 28	 mov	 rdx, QWORD PTR n$[rsp]
  0016e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR result$[rsp]
  00173	e8 00 00 00 00	 call	 _PyTuple_Resize
  00178	85 c0		 test	 eax, eax
  0017a	74 0c		 je	 SHORT $LN6@PySequence@13

; 1706 :                 Py_DECREF(item);

  0017c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR item$21704[rsp]
  00181	e8 00 00 00 00	 call	 _Py_DecRef

; 1707 :                 goto Fail;

  00186	eb 4b		 jmp	 SHORT $Fail$21698
$LN6@PySequence@13:
$LN8@PySequence@13:

; 1708 :             }
; 1709 :         }
; 1710 :         PyTuple_SET_ITEM(result, j, item);

  00188	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  0018d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  00192	48 8b 54 24 40	 mov	 rdx, QWORD PTR item$21704[rsp]
  00197	48 89 54 c8 70	 mov	 QWORD PTR [rax+rcx*8+112], rdx

; 1711 :     }

  0019c	e9 36 ff ff ff	 jmp	 $LN12@PySequence@13
$LN11@PySequence@13:

; 1712 : 
; 1713 :     /* Cut tuple back if guess was too large. */
; 1714 :     if (j < n &&
; 1715 :         _PyTuple_Resize(&result, j) != 0)

  001a1	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  001a6	48 39 44 24 38	 cmp	 QWORD PTR j$[rsp], rax
  001ab	7d 15		 jge	 SHORT $LN5@PySequence@13
  001ad	48 8b 54 24 38	 mov	 rdx, QWORD PTR j$[rsp]
  001b2	48 8d 4c 24 30	 lea	 rcx, QWORD PTR result$[rsp]
  001b7	e8 00 00 00 00	 call	 _PyTuple_Resize
  001bc	85 c0		 test	 eax, eax
  001be	74 02		 je	 SHORT $LN5@PySequence@13

; 1716 :         goto Fail;

  001c0	eb 11		 jmp	 SHORT $Fail$21698
$LN5@PySequence@13:

; 1717 : 
; 1718 :     Py_DECREF(it);

  001c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  001c7	e8 00 00 00 00	 call	 _Py_DecRef

; 1719 :     return result;

  001cc	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  001d1	eb 24		 jmp	 SHORT $LN20@PySequence@13
$Fail$21698:
$LN4@PySequence@13:

; 1720 : 
; 1721 : Fail:
; 1722 :     Py_XDECREF(result);

  001d3	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  001d9	74 0a		 je	 SHORT $LN1@PySequence@13
  001db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  001e0	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PySequence@13:
  001e5	33 c0		 xor	 eax, eax
  001e7	85 c0		 test	 eax, eax
  001e9	75 e8		 jne	 SHORT $LN4@PySequence@13

; 1723 :     Py_DECREF(it);

  001eb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  001f0	e8 00 00 00 00	 call	 _Py_DecRef

; 1724 :     return NULL;

  001f5	33 c0		 xor	 eax, eax
$LN20@PySequence@13:

; 1725 : }

  001f7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001fb	c3		 ret	 0
PySequence_Tuple ENDP
_TEXT	ENDS
PUBLIC	PySequence_List
EXTRN	_PyList_Extend:PROC
EXTRN	PyList_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_List DD imagerel $LN6
	DD	imagerel $LN6+110
	DD	imagerel $unwind$PySequence_List
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_List DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySequence_List
_TEXT	SEGMENT
rv$ = 32
result$ = 40
v$ = 64
PySequence_List PROC					; COMDAT

; 1729 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1730 :     PyObject *result;  /* result list */
; 1731 :     PyObject *rv;          /* return value from PyList_Extend */
; 1732 : 
; 1733 :     if (v == NULL)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$[rsp], 0
  0000f	75 07		 jne	 SHORT $LN3@PySequence@14

; 1734 :         return null_error();

  00011	e8 00 00 00 00	 call	 null_error
  00016	eb 51		 jmp	 SHORT $LN4@PySequence@14
$LN3@PySequence@14:

; 1735 : 
; 1736 :     result = PyList_New(0);

  00018	33 c9		 xor	 ecx, ecx
  0001a	e8 00 00 00 00	 call	 PyList_New
  0001f	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1737 :     if (result == NULL)

  00024	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$[rsp], 0
  0002a	75 04		 jne	 SHORT $LN2@PySequence@14

; 1738 :         return NULL;

  0002c	33 c0		 xor	 eax, eax
  0002e	eb 39		 jmp	 SHORT $LN4@PySequence@14
$LN2@PySequence@14:

; 1739 : 
; 1740 :     rv = _PyList_Extend((PyListObject *)result, v);

  00030	48 8b 54 24 40	 mov	 rdx, QWORD PTR v$[rsp]
  00035	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  0003a	e8 00 00 00 00	 call	 _PyList_Extend
  0003f	48 89 44 24 20	 mov	 QWORD PTR rv$[rsp], rax

; 1741 :     if (rv == NULL) {

  00044	48 83 7c 24 20
	00		 cmp	 QWORD PTR rv$[rsp], 0
  0004a	75 0e		 jne	 SHORT $LN1@PySequence@14

; 1742 :         Py_DECREF(result);

  0004c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00051	e8 00 00 00 00	 call	 _Py_DecRef

; 1743 :         return NULL;

  00056	33 c0		 xor	 eax, eax
  00058	eb 0f		 jmp	 SHORT $LN4@PySequence@14
$LN1@PySequence@14:

; 1744 :     }
; 1745 :     Py_DECREF(rv);

  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rv$[rsp]
  0005f	e8 00 00 00 00	 call	 _Py_DecRef

; 1746 :     return result;

  00064	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]
$LN4@PySequence@14:

; 1747 : }

  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	c3		 ret	 0
PySequence_List ENDP
_TEXT	ENDS
PUBLIC	PySequence_Fast
EXTRN	PyList_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Fast DD imagerel $LN8
	DD	imagerel $LN8+180
	DD	imagerel $unwind$PySequence_Fast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Fast DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySequence_Fast
_TEXT	SEGMENT
it$ = 32
v$ = 64
m$ = 72
PySequence_Fast PROC					; COMDAT

; 1751 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1752 :     PyObject *it;
; 1753 : 
; 1754 :     if (v == NULL)

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR v$[rsp], 0
  00014	75 0a		 jne	 SHORT $LN5@PySequence@15

; 1755 :         return null_error();

  00016	e8 00 00 00 00	 call	 null_error
  0001b	e9 8f 00 00 00	 jmp	 $LN6@PySequence@15
$LN5@PySequence@15:

; 1756 : 
; 1757 :     if (PyList_CheckExact(v) || PyTuple_CheckExact(v)) {

  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyList_Type
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0002c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00030	74 12		 je	 SHORT $LN3@PySequence@15
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyTuple_Type
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0003e	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00042	75 11		 jne	 SHORT $LN4@PySequence@15
$LN3@PySequence@15:

; 1758 :         Py_INCREF(v);

  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  00049	e8 00 00 00 00	 call	 _Py_IncRef

; 1759 :         return v;

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
  00053	eb 5a		 jmp	 SHORT $LN6@PySequence@15
$LN4@PySequence@15:

; 1760 :     }
; 1761 : 
; 1762 :     it = PyObject_GetIter(v);

  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR v$[rsp]
  0005a	e8 00 00 00 00	 call	 PyObject_GetIter
  0005f	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 1763 :     if (it == NULL) {

  00064	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  0006a	75 25		 jne	 SHORT $LN2@PySequence@15

; 1764 :         if (PyErr_ExceptionMatches(PyExc_TypeError))

  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00073	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00078	85 c0		 test	 eax, eax
  0007a	74 11		 je	 SHORT $LN1@PySequence@15

; 1765 :             PyErr_SetString(PyExc_TypeError, m);

  0007c	48 8b 54 24 48	 mov	 rdx, QWORD PTR m$[rsp]
  00081	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00088	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@PySequence@15:

; 1766 :         return NULL;

  0008d	33 c0		 xor	 eax, eax
  0008f	eb 1e		 jmp	 SHORT $LN6@PySequence@15
$LN2@PySequence@15:

; 1767 :     }
; 1768 : 
; 1769 :     v = PySequence_List(it);

  00091	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  00096	e8 00 00 00 00	 call	 PySequence_List
  0009b	48 89 44 24 40	 mov	 QWORD PTR v$[rsp], rax

; 1770 :     Py_DECREF(it);

  000a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  000a5	e8 00 00 00 00	 call	 _Py_DecRef

; 1771 : 
; 1772 :     return v;

  000aa	48 8b 44 24 40	 mov	 rax, QWORD PTR v$[rsp]
$LN6@PySequence@15:

; 1773 : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
PySequence_Fast ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CF@GOPAGAIL@sequence?4index?$CIx?$CJ?3?5x?5not?5in?5sequ@ ; `string'
PUBLIC	??_C@_1CK@LFAELAGM@?$AA?$CB?$AA?$CC?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BC@BDMDPLFD@unknown?5operation?$AA@	; `string'
PUBLIC	??_C@_0BN@LLCOHJFH@index?5exceeds?5C?5integer?5size?$AA@ ; `string'
PUBLIC	??_C@_0BN@JCHIFKLM@count?5exceeds?5C?5integer?5size?$AA@ ; `string'
PUBLIC	??_C@_0CK@CPINFGDB@argument?5of?5type?5?8?$CF?4200s?8?5is?5not@ ; `string'
PUBLIC	_PySequence_IterSearch
EXTRN	PyObject_RichCompareBool:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PySequence_IterSearch DD imagerel $LN24
	DD	imagerel $LN24+504
	DD	imagerel $unwind$_PySequence_IterSearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PySequence_IterSearch DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0CF@GOPAGAIL@sequence?4index?$CIx?$CJ?3?5x?5not?5in?5sequ@
CONST	SEGMENT
??_C@_0CF@GOPAGAIL@sequence?4index?$CIx?$CJ?3?5x?5not?5in?5sequ@ DB 'sequ'
	DB	'ence.index(x): x not in sequence', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@LFAELAGM@?$AA?$CB?$AA?$CC?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@LFAELAGM@?$AA?$CB?$AA?$CC?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$CC?$AA?$AA@ DB '!'
	DB	00H, '"', 00H, 'u', 00H, 'n', 00H, 'k', 00H, 'n', 00H, 'o', 00H
	DB	'w', 00H, 'n', 00H, ' ', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, '"', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BDMDPLFD@unknown?5operation?$AA@
CONST	SEGMENT
??_C@_0BC@BDMDPLFD@unknown?5operation?$AA@ DB 'unknown operation', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LLCOHJFH@index?5exceeds?5C?5integer?5size?$AA@
CONST	SEGMENT
??_C@_0BN@LLCOHJFH@index?5exceeds?5C?5integer?5size?$AA@ DB 'index exceed'
	DB	's C integer size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JCHIFKLM@count?5exceeds?5C?5integer?5size?$AA@
CONST	SEGMENT
??_C@_0BN@JCHIFKLM@count?5exceeds?5C?5integer?5size?$AA@ DB 'count exceed'
	DB	's C integer size', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@CPINFGDB@argument?5of?5type?5?8?$CF?4200s?8?5is?5not@
CONST	SEGMENT
??_C@_0CK@CPINFGDB@argument?5of?5type?5?8?$CF?4200s?8?5is?5not@ DB 'argum'
	DB	'ent of type ''%.200s'' is not iterable', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PySequence_IterSearch
_TEXT	SEGMENT
it$ = 32
n$ = 40
wrapped$ = 48
item$21779 = 56
cmp$21778 = 64
tv84 = 68
seq$ = 96
obj$ = 104
operation$ = 112
_PySequence_IterSearch PROC				; COMDAT

; 1783 : {

$LN24:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1784 :     Py_ssize_t n;
; 1785 :     int wrapped;  /* for PY_ITERSEARCH_INDEX, true iff n wrapped around */
; 1786 :     PyObject *it;  /* iter(seq) */
; 1787 : 
; 1788 :     if (seq == NULL || obj == NULL) {

  00013	48 83 7c 24 60
	00		 cmp	 QWORD PTR seq$[rsp], 0
  00019	74 08		 je	 SHORT $LN19@PySequence@16
  0001b	48 83 7c 24 68
	00		 cmp	 QWORD PTR obj$[rsp], 0
  00021	75 11		 jne	 SHORT $LN20@PySequence@16
$LN19@PySequence@16:

; 1789 :         null_error();

  00023	e8 00 00 00 00	 call	 null_error

; 1790 :         return -1;

  00028	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0002f	e9 bf 01 00 00	 jmp	 $LN21@PySequence@16
$LN20@PySequence@16:

; 1791 :     }
; 1792 : 
; 1793 :     it = PyObject_GetIter(seq);

  00034	48 8b 4c 24 60	 mov	 rcx, QWORD PTR seq$[rsp]
  00039	e8 00 00 00 00	 call	 PyObject_GetIter
  0003e	48 89 44 24 20	 mov	 QWORD PTR it$[rsp], rax

; 1794 :     if (it == NULL) {

  00043	48 83 7c 24 20
	00		 cmp	 QWORD PTR it$[rsp], 0
  00049	75 1d		 jne	 SHORT $LN18@PySequence@16

; 1795 :         type_error("argument of type '%.200s' is not iterable", seq);

  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR seq$[rsp]
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@CPINFGDB@argument?5of?5type?5?8?$CF?4200s?8?5is?5not@
  00057	e8 00 00 00 00	 call	 type_error

; 1796 :         return -1;

  0005c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00063	e9 8b 01 00 00	 jmp	 $LN21@PySequence@16
$LN18@PySequence@16:

; 1797 :     }
; 1798 : 
; 1799 :     n = wrapped = 0;

  00068	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR wrapped$[rsp], 0
  00070	48 63 44 24 30	 movsxd	 rax, DWORD PTR wrapped$[rsp]
  00075	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
$LN17@PySequence@16:

; 1800 :     for (;;) {
; 1801 :         int cmp;
; 1802 :         PyObject *item = PyIter_Next(it);

  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  0007f	e8 00 00 00 00	 call	 PyIter_Next
  00084	48 89 44 24 38	 mov	 QWORD PTR item$21779[rsp], rax

; 1803 :         if (item == NULL) {

  00089	48 83 7c 24 38
	00		 cmp	 QWORD PTR item$21779[rsp], 0
  0008f	75 14		 jne	 SHORT $LN15@PySequence@16

; 1804 :             if (PyErr_Occurred())

  00091	e8 00 00 00 00	 call	 PyErr_Occurred
  00096	48 85 c0	 test	 rax, rax
  00099	74 05		 je	 SHORT $LN14@PySequence@16

; 1805 :                 goto Fail;

  0009b	e9 3b 01 00 00	 jmp	 $Fail$21783
$LN14@PySequence@16:

; 1806 :             break;

  000a0	e9 1a 01 00 00	 jmp	 $LN16@PySequence@16
$LN15@PySequence@16:

; 1807 :         }
; 1808 : 
; 1809 :         cmp = PyObject_RichCompareBool(obj, item, Py_EQ);

  000a5	41 b8 02 00 00
	00		 mov	 r8d, 2
  000ab	48 8b 54 24 38	 mov	 rdx, QWORD PTR item$21779[rsp]
  000b0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR obj$[rsp]
  000b5	e8 00 00 00 00	 call	 PyObject_RichCompareBool
  000ba	89 44 24 40	 mov	 DWORD PTR cmp$21778[rsp], eax

; 1810 :         Py_DECREF(item);

  000be	48 8b 4c 24 38	 mov	 rcx, QWORD PTR item$21779[rsp]
  000c3	e8 00 00 00 00	 call	 _Py_DecRef

; 1811 :         if (cmp < 0)

  000c8	83 7c 24 40 00	 cmp	 DWORD PTR cmp$21778[rsp], 0
  000cd	7d 05		 jge	 SHORT $LN13@PySequence@16

; 1812 :             goto Fail;

  000cf	e9 07 01 00 00	 jmp	 $Fail$21783
$LN13@PySequence@16:

; 1813 :         if (cmp > 0) {

  000d4	83 7c 24 40 00	 cmp	 DWORD PTR cmp$21778[rsp], 0
  000d9	0f 8e ae 00 00
	00		 jle	 $LN12@PySequence@16

; 1814 :             switch (operation) {

  000df	8b 44 24 70	 mov	 eax, DWORD PTR operation$[rsp]
  000e3	89 44 24 44	 mov	 DWORD PTR tv84[rsp], eax
  000e7	83 7c 24 44 01	 cmp	 DWORD PTR tv84[rsp], 1
  000ec	74 10		 je	 SHORT $LN9@PySequence@16
  000ee	83 7c 24 44 02	 cmp	 DWORD PTR tv84[rsp], 2
  000f3	74 41		 je	 SHORT $LN7@PySequence@16
  000f5	83 7c 24 44 03	 cmp	 DWORD PTR tv84[rsp], 3
  000fa	74 5e		 je	 SHORT $LN5@PySequence@16
  000fc	eb 67		 jmp	 SHORT $LN4@PySequence@16
$LN9@PySequence@16:

; 1815 :             case PY_ITERSEARCH_COUNT:
; 1816 :                 if (n == PY_SSIZE_T_MAX) {

  000fe	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00108	48 39 44 24 28	 cmp	 QWORD PTR n$[rsp], rax
  0010d	75 18		 jne	 SHORT $LN8@PySequence@16

; 1817 :                     PyErr_SetString(PyExc_OverflowError,
; 1818 :                            "count exceeds C integer size");

  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@JCHIFKLM@count?5exceeds?5C?5integer?5size?$AA@
  00116	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0011d	e8 00 00 00 00	 call	 PyErr_SetString

; 1819 :                     goto Fail;

  00122	e9 b4 00 00 00	 jmp	 $Fail$21783
$LN8@PySequence@16:

; 1820 :                 }
; 1821 :                 ++n;

  00127	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  0012c	48 ff c0	 inc	 rax
  0012f	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 1822 :                 break;

  00134	eb 57		 jmp	 SHORT $LN10@PySequence@16
$LN7@PySequence@16:

; 1823 : 
; 1824 :             case PY_ITERSEARCH_INDEX:
; 1825 :                 if (wrapped) {

  00136	83 7c 24 30 00	 cmp	 DWORD PTR wrapped$[rsp], 0
  0013b	74 18		 je	 SHORT $LN6@PySequence@16

; 1826 :                     PyErr_SetString(PyExc_OverflowError,
; 1827 :                            "index exceeds C integer size");

  0013d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@LLCOHJFH@index?5exceeds?5C?5integer?5size?$AA@
  00144	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  0014b	e8 00 00 00 00	 call	 PyErr_SetString

; 1828 :                     goto Fail;

  00150	e9 86 00 00 00	 jmp	 $Fail$21783
$LN6@PySequence@16:

; 1829 :                 }
; 1830 :                 goto Done;

  00155	e9 8a 00 00 00	 jmp	 $Done$21799
$LN5@PySequence@16:

; 1831 : 
; 1832 :             case PY_ITERSEARCH_CONTAINS:
; 1833 :                 n = 1;

  0015a	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR n$[rsp], 1

; 1834 :                 goto Done;

  00163	eb 7f		 jmp	 SHORT $Done$21799
$LN4@PySequence@16:

; 1835 : 
; 1836 :             default:
; 1837 :                 assert(!"unknown operation");

  00165	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@BDMDPLFD@unknown?5operation?$AA@
  0016c	48 85 c0	 test	 rax, rax
  0016f	74 1c		 je	 SHORT $LN23@PySequence@16
  00171	41 b8 2d 07 00
	00		 mov	 r8d, 1837		; 0000072dH
  00177	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@GCNEELOK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAa?$AAb?$AAs?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CK@LFAELAGM@?$AA?$CB?$AA?$CC?$AAu?$AAn?$AAk?$AAn?$AAo?$AAw?$AAn?$AA?5?$AAo?$AAp?$AAe?$AAr?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?$CC?$AA?$AA@
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0018b	33 c0		 xor	 eax, eax
$LN23@PySequence@16:
$LN10@PySequence@16:
$LN12@PySequence@16:

; 1838 :             }
; 1839 :         }
; 1840 : 
; 1841 :         if (operation == PY_ITERSEARCH_INDEX) {

  0018d	83 7c 24 70 02	 cmp	 DWORD PTR operation$[rsp], 2
  00192	75 26		 jne	 SHORT $LN3@PySequence@16

; 1842 :             if (n == PY_SSIZE_T_MAX)

  00194	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0019e	48 39 44 24 28	 cmp	 QWORD PTR n$[rsp], rax
  001a3	75 08		 jne	 SHORT $LN2@PySequence@16

; 1843 :                 wrapped = 1;

  001a5	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR wrapped$[rsp], 1
$LN2@PySequence@16:

; 1844 :             ++n;

  001ad	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  001b2	48 ff c0	 inc	 rax
  001b5	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
$LN3@PySequence@16:

; 1845 :         }
; 1846 :     }

  001ba	e9 bb fe ff ff	 jmp	 $LN17@PySequence@16
$LN16@PySequence@16:

; 1847 : 
; 1848 :     if (operation != PY_ITERSEARCH_INDEX)

  001bf	83 7c 24 70 02	 cmp	 DWORD PTR operation$[rsp], 2
  001c4	74 02		 je	 SHORT $LN1@PySequence@16

; 1849 :         goto Done;

  001c6	eb 1c		 jmp	 SHORT $Done$21799
$LN1@PySequence@16:

; 1850 : 
; 1851 :     PyErr_SetString(PyExc_ValueError,
; 1852 :                     "sequence.index(x): x not in sequence");

  001c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@GOPAGAIL@sequence?4index?$CIx?$CJ?3?5x?5not?5in?5sequ@
  001cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_ValueError
  001d6	e8 00 00 00 00	 call	 PyErr_SetString
$Fail$21783:

; 1853 :     /* fall into failure code */
; 1854 : Fail:
; 1855 :     n = -1;

  001db	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR n$[rsp], -1
$Done$21799:

; 1856 :     /* fall through */
; 1857 : Done:
; 1858 :     Py_DECREF(it);

  001e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR it$[rsp]
  001e9	e8 00 00 00 00	 call	 _Py_DecRef

; 1859 :     return n;

  001ee	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
$LN21@PySequence@16:

; 1860 : 
; 1861 : }

  001f3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001f7	c3		 ret	 0
_PySequence_IterSearch ENDP
_TEXT	ENDS
PUBLIC	PySequence_Count
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Count DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$PySequence_Count
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Count DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySequence_Count
_TEXT	SEGMENT
s$ = 48
o$ = 56
PySequence_Count PROC					; COMDAT

; 1866 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1867 :     return _PySequence_IterSearch(s, o, PY_ITERSEARCH_COUNT);

  0000e	41 b8 01 00 00
	00		 mov	 r8d, 1
  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR o$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0001e	e8 00 00 00 00	 call	 _PySequence_IterSearch

; 1868 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
PySequence_Count ENDP
_TEXT	ENDS
PUBLIC	??_C@_1EM@PNPIGAND@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAr?$AAe@ ; `string'
PUBLIC	PySequence_Contains
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Contains DD imagerel $LN5
	DD	imagerel $LN5+150
	DD	imagerel $unwind$PySequence_Contains
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Contains DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_1EM@PNPIGAND@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAr?$AAe@
CONST	SEGMENT
??_C@_1EM@PNPIGAND@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAr?$AAe@ DB '('
	DB	00H, 'P', 00H, 'y', 00H, '_', 00H, 's', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H, 'i'
	DB	00H, 'n', 00H, 't', 00H, ')', 00H, '(', 00H, 'r', 00H, 'e', 00H
	DB	's', 00H, 'u', 00H, 'l', 00H, 't', 00H, ')', 00H, ' ', 00H, '='
	DB	00H, '=', 00H, ' ', 00H, '(', 00H, 'r', 00H, 'e', 00H, 's', 00H
	DB	'u', 00H, 'l', 00H, 't', 00H, ')', 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PySequence_Contains
_TEXT	SEGMENT
sqm$ = 32
result$ = 40
seq$ = 64
ob$ = 72
PySequence_Contains PROC				; COMDAT

; 1875 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1876 :     Py_ssize_t result;
; 1877 :     PySequenceMethods *sqm = seq->ob_type->tp_as_sequence;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR seq$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0001e	48 89 44 24 20	 mov	 QWORD PTR sqm$[rsp], rax

; 1878 : 
; 1879 :     if (sqm != NULL && sqm->sq_contains != NULL)

  00023	48 83 7c 24 20
	00		 cmp	 QWORD PTR sqm$[rsp], 0
  00029	74 20		 je	 SHORT $LN1@PySequence@17
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR sqm$[rsp]
  00030	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00035	74 14		 je	 SHORT $LN1@PySequence@17

; 1880 :         return (*sqm->sq_contains)(seq, ob);

  00037	48 8b 54 24 48	 mov	 rdx, QWORD PTR ob$[rsp]
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$[rsp]
  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR sqm$[rsp]
  00046	ff 50 38	 call	 QWORD PTR [rax+56]
  00049	eb 46		 jmp	 SHORT $LN2@PySequence@17
$LN1@PySequence@17:

; 1881 :     result = _PySequence_IterSearch(seq, ob, PY_ITERSEARCH_CONTAINS);

  0004b	41 b8 03 00 00
	00		 mov	 r8d, 3
  00051	48 8b 54 24 48	 mov	 rdx, QWORD PTR ob$[rsp]
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR seq$[rsp]
  0005b	e8 00 00 00 00	 call	 _PySequence_IterSearch
  00060	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax

; 1882 :     return Py_SAFE_DOWNCAST(result, Py_ssize_t, int);

  00065	48 63 44 24 28	 movsxd	 rax, DWORD PTR result$[rsp]
  0006a	48 3b 44 24 28	 cmp	 rax, QWORD PTR result$[rsp]
  0006f	74 1c		 je	 SHORT $LN4@PySequence@17
  00071	41 b8 5a 07 00
	00		 mov	 r8d, 1882		; 0000075aH
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@GCNEELOK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAa?$AAb?$AAs?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EM@PNPIGAND@?$AA?$CI?$AAP?$AAy?$AA_?$AAs?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AAi?$AAn?$AAt?$AA?$CJ?$AA?$CI?$AAr?$AAe?$AAs?$AAu?$AAl?$AAt?$AA?$CJ?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA?$CI?$AAr?$AAe@
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0008b	33 c0		 xor	 eax, eax
$LN4@PySequence@17:
  0008d	8b 44 24 28	 mov	 eax, DWORD PTR result$[rsp]
$LN2@PySequence@17:

; 1883 : }

  00091	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00095	c3		 ret	 0
PySequence_Contains ENDP
_TEXT	ENDS
PUBLIC	PySequence_In
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_In DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$PySequence_In
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_In DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySequence_In
_TEXT	SEGMENT
w$ = 48
v$ = 56
PySequence_In PROC					; COMDAT

; 1889 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1890 :     return PySequence_Contains(w, v);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR v$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR w$[rsp]
  00018	e8 00 00 00 00	 call	 PySequence_Contains

; 1891 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
PySequence_In ENDP
_TEXT	ENDS
PUBLIC	PySequence_Index
;	COMDAT pdata
pdata	SEGMENT
$pdata$PySequence_Index DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$PySequence_Index
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PySequence_Index DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PySequence_Index
_TEXT	SEGMENT
s$ = 48
o$ = 56
PySequence_Index PROC					; COMDAT

; 1895 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1896 :     return _PySequence_IterSearch(s, o, PY_ITERSEARCH_INDEX);

  0000e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR o$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0001e	e8 00 00 00 00	 call	 _PySequence_IterSearch

; 1897 : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
PySequence_Index ENDP
_TEXT	ENDS
PUBLIC	PyMapping_Check
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_Check DD imagerel $LN5
	DD	imagerel $LN5+83
	DD	imagerel $unwind$PyMapping_Check
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_Check DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMapping_Check
_TEXT	SEGMENT
tv72 = 0
o$ = 32
PyMapping_Check PROC					; COMDAT

; 1903 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1904 :     return o && o->ob_type->tp_as_mapping &&
; 1905 :         o->ob_type->tp_as_mapping->mp_subscript;

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR o$[rsp], 0
  0000f	74 33		 je	 SHORT $LN3@PyMapping_
  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR o$[rsp]
  00016	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001a	48 83 b8 c8 00
	00 00 00	 cmp	 QWORD PTR [rax+200], 0
  00022	74 20		 je	 SHORT $LN3@PyMapping_
  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR o$[rsp]
  00029	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002d	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00034	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00039	74 09		 je	 SHORT $LN3@PyMapping_
  0003b	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 07		 jmp	 SHORT $LN4@PyMapping_
$LN3@PyMapping_:
  00044	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv72[rsp], 0
$LN4@PyMapping_:
  0004b	8b 04 24	 mov	 eax, DWORD PTR tv72[rsp]

; 1906 : }

  0004e	48 83 c4 18	 add	 rsp, 24
  00052	c3		 ret	 0
PyMapping_Check ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_Size DD imagerel $LN5
	DD	imagerel $LN5+114
	DD	imagerel $unwind$PyMapping_Size
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_Size DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMapping_Size
_TEXT	SEGMENT
m$ = 32
o$ = 64
PyMapping_Size PROC					; COMDAT

; 1910 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1911 :     PyMappingMethods *m;
; 1912 : 
; 1913 :     if (o == NULL) {

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR o$[rsp], 0
  0000f	75 0e		 jne	 SHORT $LN2@PyMapping_@2

; 1914 :         null_error();

  00011	e8 00 00 00 00	 call	 null_error

; 1915 :         return -1;

  00016	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0001d	eb 4e		 jmp	 SHORT $LN3@PyMapping_@2
$LN2@PyMapping_@2:

; 1916 :     }
; 1917 : 
; 1918 :     m = o->ob_type->tp_as_mapping;

  0001f	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00024	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00028	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  0002f	48 89 44 24 20	 mov	 QWORD PTR m$[rsp], rax

; 1919 :     if (m && m->mp_length)

  00034	48 83 7c 24 20
	00		 cmp	 QWORD PTR m$[rsp], 0
  0003a	74 19		 je	 SHORT $LN1@PyMapping_@2
  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00041	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00045	74 0e		 je	 SHORT $LN1@PyMapping_@2

; 1920 :         return m->mp_length(o);

  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR m$[rsp]
  00051	ff 10		 call	 QWORD PTR [rax]
  00053	eb 18		 jmp	 SHORT $LN3@PyMapping_@2
$LN1@PyMapping_@2:

; 1921 : 
; 1922 :     type_error("object of type '%.200s' has no len()", o);

  00055	48 8b 54 24 40	 mov	 rdx, QWORD PTR o$[rsp]
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@IKKNHGFK@object?5of?5type?5?8?$CF?4200s?8?5has?5no?5l@
  00061	e8 00 00 00 00	 call	 type_error

; 1923 :     return -1;

  00066	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
$LN3@PyMapping_@2:

; 1924 : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
PyMapping_Size ENDP
_TEXT	ENDS
PUBLIC	PyMapping_Length
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_Length DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$PyMapping_Length
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_Length DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMapping_Length
_TEXT	SEGMENT
o$ = 48
PyMapping_Length PROC					; COMDAT

; 1929 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1930 :     return PyMapping_Size(o);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR o$[rsp]
  0000e	e8 00 00 00 00	 call	 PyMapping_Size

; 1931 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
PyMapping_Length ENDP
_TEXT	ENDS
PUBLIC	PyMapping_GetItemString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_GetItemString DD imagerel $LN5
	DD	imagerel $LN5+96
	DD	imagerel $unwind$PyMapping_GetItemString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_GetItemString DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMapping_GetItemString
_TEXT	SEGMENT
r$ = 32
okey$ = 40
o$ = 64
key$ = 72
PyMapping_GetItemString PROC				; COMDAT

; 1936 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1937 :     PyObject *okey, *r;
; 1938 : 
; 1939 :     if (key == NULL)

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR key$[rsp], 0
  00014	75 07		 jne	 SHORT $LN2@PyMapping_@3

; 1940 :         return null_error();

  00016	e8 00 00 00 00	 call	 null_error
  0001b	eb 3e		 jmp	 SHORT $LN3@PyMapping_@3
$LN2@PyMapping_@3:

; 1941 : 
; 1942 :     okey = PyUnicode_FromString(key);

  0001d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00022	e8 00 00 00 00	 call	 PyUnicode_FromString
  00027	48 89 44 24 28	 mov	 QWORD PTR okey$[rsp], rax

; 1943 :     if (okey == NULL)

  0002c	48 83 7c 24 28
	00		 cmp	 QWORD PTR okey$[rsp], 0
  00032	75 04		 jne	 SHORT $LN1@PyMapping_@3

; 1944 :         return NULL;

  00034	33 c0		 xor	 eax, eax
  00036	eb 23		 jmp	 SHORT $LN3@PyMapping_@3
$LN1@PyMapping_@3:

; 1945 :     r = PyObject_GetItem(o, okey);

  00038	48 8b 54 24 28	 mov	 rdx, QWORD PTR okey$[rsp]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00042	e8 00 00 00 00	 call	 PyObject_GetItem
  00047	48 89 44 24 20	 mov	 QWORD PTR r$[rsp], rax

; 1946 :     Py_DECREF(okey);

  0004c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR okey$[rsp]
  00051	e8 00 00 00 00	 call	 _Py_DecRef

; 1947 :     return r;

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR r$[rsp]
$LN3@PyMapping_@3:

; 1948 : }

  0005b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005f	c3		 ret	 0
PyMapping_GetItemString ENDP
_TEXT	ENDS
PUBLIC	PyMapping_SetItemString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_SetItemString DD imagerel $LN5
	DD	imagerel $LN5+112
	DD	imagerel $unwind$PyMapping_SetItemString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_SetItemString DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMapping_SetItemString
_TEXT	SEGMENT
r$ = 32
okey$ = 40
o$ = 64
key$ = 72
value$ = 80
PyMapping_SetItemString PROC				; COMDAT

; 1952 : {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1953 :     PyObject *okey;
; 1954 :     int r;
; 1955 : 
; 1956 :     if (key == NULL) {

  00013	48 83 7c 24 48
	00		 cmp	 QWORD PTR key$[rsp], 0
  00019	75 0c		 jne	 SHORT $LN2@PyMapping_@4

; 1957 :         null_error();

  0001b	e8 00 00 00 00	 call	 null_error

; 1958 :         return -1;

  00020	b8 ff ff ff ff	 mov	 eax, -1
  00025	eb 44		 jmp	 SHORT $LN3@PyMapping_@4
$LN2@PyMapping_@4:

; 1959 :     }
; 1960 : 
; 1961 :     okey = PyUnicode_FromString(key);

  00027	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  0002c	e8 00 00 00 00	 call	 PyUnicode_FromString
  00031	48 89 44 24 28	 mov	 QWORD PTR okey$[rsp], rax

; 1962 :     if (okey == NULL)

  00036	48 83 7c 24 28
	00		 cmp	 QWORD PTR okey$[rsp], 0
  0003c	75 07		 jne	 SHORT $LN1@PyMapping_@4

; 1963 :         return -1;

  0003e	b8 ff ff ff ff	 mov	 eax, -1
  00043	eb 26		 jmp	 SHORT $LN3@PyMapping_@4
$LN1@PyMapping_@4:

; 1964 : 
; 1965 :     /*
; 1966 :     if (Px_CHECK_PROTECTION(o, okey, value))
; 1967 :         return -1;
; 1968 :     */
; 1969 : 
; 1970 :     r = PyObject_SetItem(o, okey, value);

  00045	4c 8b 44 24 50	 mov	 r8, QWORD PTR value$[rsp]
  0004a	48 8b 54 24 28	 mov	 rdx, QWORD PTR okey$[rsp]
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00054	e8 00 00 00 00	 call	 PyObject_SetItem
  00059	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 1971 :     Py_DECREF(okey);

  0005d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR okey$[rsp]
  00062	e8 00 00 00 00	 call	 _Py_DecRef

; 1972 :     return r;

  00067	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]
$LN3@PyMapping_@4:

; 1973 : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
PyMapping_SetItemString ENDP
_TEXT	ENDS
PUBLIC	PyMapping_HasKeyString
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_HasKeyString DD imagerel $LN4
	DD	imagerel $LN4+71
	DD	imagerel $unwind$PyMapping_HasKeyString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_HasKeyString DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMapping_HasKeyString
_TEXT	SEGMENT
v$ = 32
o$ = 64
key$ = 72
PyMapping_HasKeyString PROC				; COMDAT

; 1977 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1978 :     PyObject *v;
; 1979 : 
; 1980 :     v = PyMapping_GetItemString(o, key);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00018	e8 00 00 00 00	 call	 PyMapping_GetItemString
  0001d	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 1981 :     if (v) {

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00028	74 11		 je	 SHORT $LN1@PyMapping_@5

; 1982 :         Py_DECREF(v);

  0002a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0002f	e8 00 00 00 00	 call	 _Py_DecRef

; 1983 :         return 1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	eb 07		 jmp	 SHORT $LN2@PyMapping_@5
$LN1@PyMapping_@5:

; 1984 :     }
; 1985 :     PyErr_Clear();

  0003b	e8 00 00 00 00	 call	 PyErr_Clear

; 1986 :     return 0;

  00040	33 c0		 xor	 eax, eax
$LN2@PyMapping_@5:

; 1987 : }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
PyMapping_HasKeyString ENDP
_TEXT	ENDS
PUBLIC	PyMapping_HasKey
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_HasKey DD imagerel $LN4
	DD	imagerel $LN4+71
	DD	imagerel $unwind$PyMapping_HasKey
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_HasKey DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyMapping_HasKey
_TEXT	SEGMENT
v$ = 32
o$ = 64
key$ = 72
PyMapping_HasKey PROC					; COMDAT

; 1991 : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1992 :     PyObject *v;
; 1993 : 
; 1994 :     v = PyObject_GetItem(o, key);

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR key$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00018	e8 00 00 00 00	 call	 PyObject_GetItem
  0001d	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 1995 :     if (v) {

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00028	74 11		 je	 SHORT $LN1@PyMapping_@6

; 1996 :         Py_DECREF(v);

  0002a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0002f	e8 00 00 00 00	 call	 _Py_DecRef

; 1997 :         return 1;

  00034	b8 01 00 00 00	 mov	 eax, 1
  00039	eb 07		 jmp	 SHORT $LN2@PyMapping_@6
$LN1@PyMapping_@6:

; 1998 :     }
; 1999 :     PyErr_Clear();

  0003b	e8 00 00 00 00	 call	 PyErr_Clear

; 2000 :     return 0;

  00040	33 c0		 xor	 eax, eax
$LN2@PyMapping_@6:

; 2001 : }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
PyMapping_HasKey ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BK@PIAAPCC@o?4keys?$CI?$CJ?5are?5not?5iterable?$AA@ ; `string'
PUBLIC	_PyObject_CallMethodId
PUBLIC	PyMapping_Keys
EXTRN	PyDict_Keys:PROC
EXTRN	PyDict_Type:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_Keys DD imagerel $LN6
	DD	imagerel $LN6+158
	DD	imagerel $unwind$PyMapping_Keys
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_Keys DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0BK@PIAAPCC@o?4keys?$CI?$CJ?5are?5not?5iterable?$AA@
CONST	SEGMENT
??_C@_0BK@PIAAPCC@o?4keys?$CI?$CJ?5are?5not?5iterable?$AA@ DB 'o.keys() a'
	DB	're not iterable', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyMapping_Keys
_TEXT	SEGMENT
fast$ = 32
keys$ = 40
o$ = 64
PyMapping_Keys PROC					; COMDAT

; 2005 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2006 :     PyObject *keys;
; 2007 :     PyObject *fast;
; 2008 :     _Py_IDENTIFIER(keys);
; 2009 : 
; 2010 :     if (PyDict_CheckExact(o))

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 12		 je	 SHORT $LN2@PyMapping_@7
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00027	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  0002b	75 0c		 jne	 SHORT $LN3@PyMapping_@7
$LN2@PyMapping_@7:

; 2011 :         return PyDict_Keys(o);

  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00032	e8 00 00 00 00	 call	 PyDict_Keys
  00037	eb 60		 jmp	 SHORT $LN4@PyMapping_@7
$LN3@PyMapping_@7:

; 2012 :     keys = _PyObject_CallMethodId(o, &PyId_keys, NULL);

  00039	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_keys@?1??PyMapping_Keys@@9@9
  0003e	8b c0		 mov	 eax, eax
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00046	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0004f	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b d0	 mov	 rdx, rax
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  0005e	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00063	48 89 44 24 28	 mov	 QWORD PTR keys$[rsp], rax

; 2013 :     if (keys == NULL)

  00068	48 83 7c 24 28
	00		 cmp	 QWORD PTR keys$[rsp], 0
  0006e	75 04		 jne	 SHORT $LN1@PyMapping_@7

; 2014 :         return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	eb 25		 jmp	 SHORT $LN4@PyMapping_@7
$LN1@PyMapping_@7:

; 2015 :     fast = PySequence_Fast(keys, "o.keys() are not iterable");

  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PIAAPCC@o?4keys?$CI?$CJ?5are?5not?5iterable?$AA@
  0007b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR keys$[rsp]
  00080	e8 00 00 00 00	 call	 PySequence_Fast
  00085	48 89 44 24 20	 mov	 QWORD PTR fast$[rsp], rax

; 2016 :     Py_DECREF(keys);

  0008a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR keys$[rsp]
  0008f	e8 00 00 00 00	 call	 _Py_DecRef

; 2017 :     return fast;

  00094	48 8b 44 24 20	 mov	 rax, QWORD PTR fast$[rsp]
$LN4@PyMapping_@7:

; 2018 : }

  00099	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009d	c3		 ret	 0
PyMapping_Keys ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@ILJJIFEA@o?4items?$CI?$CJ?5are?5not?5iterable?$AA@ ; `string'
PUBLIC	PyMapping_Items
EXTRN	PyDict_Items:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_Items DD imagerel $LN6
	DD	imagerel $LN6+158
	DD	imagerel $unwind$PyMapping_Items
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_Items DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0BL@ILJJIFEA@o?4items?$CI?$CJ?5are?5not?5iterable?$AA@
CONST	SEGMENT
??_C@_0BL@ILJJIFEA@o?4items?$CI?$CJ?5are?5not?5iterable?$AA@ DB 'o.items('
	DB	') are not iterable', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyMapping_Items
_TEXT	SEGMENT
fast$ = 32
items$ = 40
o$ = 64
PyMapping_Items PROC					; COMDAT

; 2022 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2023 :     PyObject *items;
; 2024 :     PyObject *fast;
; 2025 :     _Py_IDENTIFIER(items);
; 2026 : 
; 2027 :     if (PyDict_CheckExact(o))

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 12		 je	 SHORT $LN2@PyMapping_@8
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00027	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  0002b	75 0c		 jne	 SHORT $LN3@PyMapping_@8
$LN2@PyMapping_@8:

; 2028 :         return PyDict_Items(o);

  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00032	e8 00 00 00 00	 call	 PyDict_Items
  00037	eb 60		 jmp	 SHORT $LN4@PyMapping_@8
$LN3@PyMapping_@8:

; 2029 :     items = _PyObject_CallMethodId(o, &PyId_items, NULL);

  00039	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_items@?1??PyMapping_Items@@9@9
  0003e	8b c0		 mov	 eax, eax
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00046	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0004f	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b d0	 mov	 rdx, rax
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  0005e	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00063	48 89 44 24 28	 mov	 QWORD PTR items$[rsp], rax

; 2030 :     if (items == NULL)

  00068	48 83 7c 24 28
	00		 cmp	 QWORD PTR items$[rsp], 0
  0006e	75 04		 jne	 SHORT $LN1@PyMapping_@8

; 2031 :         return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	eb 25		 jmp	 SHORT $LN4@PyMapping_@8
$LN1@PyMapping_@8:

; 2032 :     fast = PySequence_Fast(items, "o.items() are not iterable");

  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@ILJJIFEA@o?4items?$CI?$CJ?5are?5not?5iterable?$AA@
  0007b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR items$[rsp]
  00080	e8 00 00 00 00	 call	 PySequence_Fast
  00085	48 89 44 24 20	 mov	 QWORD PTR fast$[rsp], rax

; 2033 :     Py_DECREF(items);

  0008a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR items$[rsp]
  0008f	e8 00 00 00 00	 call	 _Py_DecRef

; 2034 :     return fast;

  00094	48 8b 44 24 20	 mov	 rax, QWORD PTR fast$[rsp]
$LN4@PyMapping_@8:

; 2035 : }

  00099	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009d	c3		 ret	 0
PyMapping_Items ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@INCHIOIK@o?4values?$CI?$CJ?5are?5not?5iterable?$AA@ ; `string'
PUBLIC	PyMapping_Values
EXTRN	PyDict_Values:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyMapping_Values DD imagerel $LN6
	DD	imagerel $LN6+158
	DD	imagerel $unwind$PyMapping_Values
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyMapping_Values DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0BM@INCHIOIK@o?4values?$CI?$CJ?5are?5not?5iterable?$AA@
CONST	SEGMENT
??_C@_0BM@INCHIOIK@o?4values?$CI?$CJ?5are?5not?5iterable?$AA@ DB 'o.value'
	DB	's() are not iterable', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyMapping_Values
_TEXT	SEGMENT
values$ = 32
fast$ = 40
o$ = 64
PyMapping_Values PROC					; COMDAT

; 2039 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2040 :     PyObject *values;
; 2041 :     PyObject *fast;
; 2042 :     _Py_IDENTIFIER(values);
; 2043 : 
; 2044 :     if (PyDict_CheckExact(o))

  00009	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00015	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00019	74 12		 je	 SHORT $LN2@PyMapping_@9
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyDict_Type
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00027	48 39 41 38	 cmp	 QWORD PTR [rcx+56], rax
  0002b	75 0c		 jne	 SHORT $LN3@PyMapping_@9
$LN2@PyMapping_@9:

; 2045 :         return PyDict_Values(o);

  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00032	e8 00 00 00 00	 call	 PyDict_Values
  00037	eb 60		 jmp	 SHORT $LN4@PyMapping_@9
$LN3@PyMapping_@9:

; 2046 :     values = _PyObject_CallMethodId(o, &PyId_values, NULL);

  00039	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId_values@?1??PyMapping_Values@@9@9
  0003e	8b c0		 mov	 eax, eax
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00046	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0004f	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b d0	 mov	 rdx, rax
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  0005e	e8 00 00 00 00	 call	 _PyObject_CallMethodId
  00063	48 89 44 24 20	 mov	 QWORD PTR values$[rsp], rax

; 2047 :     if (values == NULL)

  00068	48 83 7c 24 20
	00		 cmp	 QWORD PTR values$[rsp], 0
  0006e	75 04		 jne	 SHORT $LN1@PyMapping_@9

; 2048 :         return NULL;

  00070	33 c0		 xor	 eax, eax
  00072	eb 25		 jmp	 SHORT $LN4@PyMapping_@9
$LN1@PyMapping_@9:

; 2049 :     fast = PySequence_Fast(values, "o.values() are not iterable");

  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@INCHIOIK@o?4values?$CI?$CJ?5are?5not?5iterable?$AA@
  0007b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR values$[rsp]
  00080	e8 00 00 00 00	 call	 PySequence_Fast
  00085	48 89 44 24 28	 mov	 QWORD PTR fast$[rsp], rax

; 2050 :     Py_DECREF(values);

  0008a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR values$[rsp]
  0008f	e8 00 00 00 00	 call	 _Py_DecRef

; 2051 :     return fast;

  00094	48 8b 44 24 28	 mov	 rax, QWORD PTR fast$[rsp]
$LN4@PyMapping_@9:

; 2052 : }

  00099	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009d	c3		 ret	 0
PyMapping_Values ENDP
_TEXT	ENDS
PUBLIC	PyObject_CallObject
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CallObject DD imagerel $LN3
	DD	imagerel $LN3+37
	DD	imagerel $unwind$PyObject_CallObject
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CallObject DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_CallObject
_TEXT	SEGMENT
o$ = 48
a$ = 56
PyObject_CallObject PROC				; COMDAT

; 2060 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2061 :     return PyEval_CallObjectWithKeywords(o, a, NULL);

  0000e	45 33 c0	 xor	 r8d, r8d
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR a$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR o$[rsp]
  0001b	e8 00 00 00 00	 call	 PyEval_CallObjectWithKeywords

; 2062 : }

  00020	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00024	c3		 ret	 0
PyObject_CallObject ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@OEALHAKB@?8?$CF?4200s?8?5object?5is?5not?5callable?$AA@ ; `string'
PUBLIC	??_C@_0CL@FLDCAKFI@NULL?5result?5without?5error?5in?5PyO@ ; `string'
PUBLIC	??_C@_0BP@PDBBPPOK@?5while?5calling?5a?5Python?5object?$AA@ ; `string'
PUBLIC	PyObject_Call
EXTRN	_Py_CheckRecursiveCall:PROC
EXTRN	_Py_CheckRecursionLimit:DWORD
EXTRN	PyThreadState_Get:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_Call DD imagerel $LN12
	DD	imagerel $LN12+325
	DD	imagerel $unwind$PyObject_Call
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_Call DD 011301H
	DD	0a213H
xdata	ENDS
;	COMDAT ??_C@_0CA@OEALHAKB@?8?$CF?4200s?8?5object?5is?5not?5callable?$AA@
CONST	SEGMENT
??_C@_0CA@OEALHAKB@?8?$CF?4200s?8?5object?5is?5not?5callable?$AA@ DB '''%'
	DB	'.200s'' object is not callable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FLDCAKFI@NULL?5result?5without?5error?5in?5PyO@
CONST	SEGMENT
??_C@_0CL@FLDCAKFI@NULL?5result?5without?5error?5in?5PyO@ DB 'NULL result'
	DB	' without error in PyObject_Call', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PDBBPPOK@?5while?5calling?5a?5Python?5object?$AA@
CONST	SEGMENT
??_C@_0BP@PDBBPPOK@?5while?5calling?5a?5Python?5object?$AA@ DB ' while ca'
	DB	'lling a Python object', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_Call
_TEXT	SEGMENT
call$ = 32
result$21969 = 40
tv69 = 48
tv87 = 56
tv81 = 64
func$ = 96
arg$ = 104
kw$ = 112
PyObject_Call PROC					; COMDAT

; 2066 : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2067 :     ternaryfunc call;
; 2068 : 
; 2069 :     if ((call = func->ob_type->tp_call) != NULL) {

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR func$[rsp]
  00018	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001c	48 8b 80 d8 00
	00 00		 mov	 rax, QWORD PTR [rax+216]
  00023	48 89 44 24 20	 mov	 QWORD PTR call$[rsp], rax
  00028	48 83 7c 24 20
	00		 cmp	 QWORD PTR call$[rsp], 0
  0002e	0f 84 ea 00 00
	00		 je	 $LN7@PyObject_C@3

; 2070 :         PyObject *result;
; 2071 :         if (Py_EnterRecursiveCall(" while calling a Python object"))

  00034	e8 00 00 00 00	 call	 PyThreadState_Get
  00039	48 83 c0 18	 add	 rax, 24
  0003d	48 89 44 24 30	 mov	 QWORD PTR tv69[rsp], rax
  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR tv69[rsp]
  00047	8b 00		 mov	 eax, DWORD PTR [rax]
  00049	ff c0		 inc	 eax
  0004b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv69[rsp]
  00050	89 01		 mov	 DWORD PTR [rcx], eax
  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR tv69[rsp]
  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Py_CheckRecursionLimit
  0005d	39 08		 cmp	 DWORD PTR [rax], ecx
  0005f	7e 17		 jle	 SHORT $LN6@PyObject_C@3
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@PDBBPPOK@?5while?5calling?5a?5Python?5object?$AA@
  00068	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  0006d	85 c0		 test	 eax, eax
  0006f	74 07		 je	 SHORT $LN6@PyObject_C@3

; 2072 :             return NULL;

  00071	33 c0		 xor	 eax, eax
  00073	e9 c8 00 00 00	 jmp	 $LN8@PyObject_C@3
$LN6@PyObject_C@3:

; 2073 :         result = (*call)(func, arg, kw);

  00078	4c 8b 44 24 70	 mov	 r8, QWORD PTR kw$[rsp]
  0007d	48 8b 54 24 68	 mov	 rdx, QWORD PTR arg$[rsp]
  00082	48 8b 4c 24 60	 mov	 rcx, QWORD PTR func$[rsp]
  00087	ff 54 24 20	 call	 QWORD PTR call$[rsp]
  0008b	48 89 44 24 28	 mov	 QWORD PTR result$21969[rsp], rax
$LN5@PyObject_C@3:

; 2074 :         Py_LeaveRecursiveCall();

  00090	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _Py_CheckRecursionLimit, 100 ; 00000064H
  00097	7e 0f		 jle	 SHORT $LN10@PyObject_C@3
  00099	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  0009f	83 e8 32	 sub	 eax, 50			; 00000032H
  000a2	89 44 24 38	 mov	 DWORD PTR tv87[rsp], eax
  000a6	eb 10		 jmp	 SHORT $LN11@PyObject_C@3
$LN10@PyObject_C@3:
  000a8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  000ae	c1 f8 02	 sar	 eax, 2
  000b1	6b c0 03	 imul	 eax, 3
  000b4	89 44 24 38	 mov	 DWORD PTR tv87[rsp], eax
$LN11@PyObject_C@3:
  000b8	e8 00 00 00 00	 call	 PyThreadState_Get
  000bd	48 83 c0 18	 add	 rax, 24
  000c1	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000cb	8b 00		 mov	 eax, DWORD PTR [rax]
  000cd	ff c8		 dec	 eax
  000cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv81[rsp]
  000d4	89 01		 mov	 DWORD PTR [rcx], eax
  000d6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000db	8b 4c 24 38	 mov	 ecx, DWORD PTR tv87[rsp]
  000df	39 08		 cmp	 DWORD PTR [rax], ecx
  000e1	7d 09		 jge	 SHORT $LN2@PyObject_C@3
  000e3	e8 00 00 00 00	 call	 PyThreadState_Get
  000e8	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN2@PyObject_C@3:
  000ec	33 c0		 xor	 eax, eax
  000ee	85 c0		 test	 eax, eax
  000f0	75 9e		 jne	 SHORT $LN5@PyObject_C@3

; 2075 :         if (result == NULL && !PyErr_Occurred())

  000f2	48 83 7c 24 28
	00		 cmp	 QWORD PTR result$21969[rsp], 0
  000f8	75 1d		 jne	 SHORT $LN1@PyObject_C@3
  000fa	e8 00 00 00 00	 call	 PyErr_Occurred
  000ff	48 85 c0	 test	 rax, rax
  00102	75 13		 jne	 SHORT $LN1@PyObject_C@3

; 2076 :             PyErr_SetString(
; 2077 :                 PyExc_SystemError,
; 2078 :                 "NULL result without error in PyObject_Call");

  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@FLDCAKFI@NULL?5result?5without?5error?5in?5PyO@
  0010b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_SystemError
  00112	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@PyObject_C@3:

; 2079 :         return result;

  00117	48 8b 44 24 28	 mov	 rax, QWORD PTR result$21969[rsp]
  0011c	eb 22		 jmp	 SHORT $LN8@PyObject_C@3
$LN7@PyObject_C@3:

; 2080 :     }
; 2081 :     PyErr_Format(PyExc_TypeError, "'%.200s' object is not callable",
; 2082 :                  func->ob_type->tp_name);

  0011e	48 8b 44 24 60	 mov	 rax, QWORD PTR func$[rsp]
  00123	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00127	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@OEALHAKB@?8?$CF?4200s?8?5object?5is?5not?5callable?$AA@
  00132	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  00139	e8 00 00 00 00	 call	 PyErr_Format

; 2083 :     return NULL;

  0013e	33 c0		 xor	 eax, eax
$LN8@PyObject_C@3:

; 2084 : }

  00140	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00144	c3		 ret	 0
PyObject_Call ENDP
_TEXT	ENDS
PUBLIC	PyObject_CallFunction
EXTRN	Py_VaBuildValue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CallFunction DD imagerel $LN6
	DD	imagerel $LN6+132
	DD	imagerel $unwind$PyObject_CallFunction
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CallFunction DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_CallFunction
_TEXT	SEGMENT
args$ = 32
va$ = 40
callable$ = 64
format$ = 72
PyObject_CallFunction PROC				; COMDAT

; 2114 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2115 :     va_list va;
; 2116 :     PyObject *args;
; 2117 : 
; 2118 :     if (callable == NULL)

  00018	48 83 7c 24 40
	00		 cmp	 QWORD PTR callable$[rsp], 0
  0001e	75 07		 jne	 SHORT $LN3@PyObject_C@4

; 2119 :         return null_error();

  00020	e8 00 00 00 00	 call	 null_error
  00025	eb 58		 jmp	 SHORT $LN4@PyObject_C@4
$LN3@PyObject_C@4:

; 2120 : 
; 2121 :     if (format && *format) {

  00027	48 83 7c 24 48
	00		 cmp	 QWORD PTR format$[rsp], 0
  0002d	74 35		 je	 SHORT $LN2@PyObject_C@4
  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR format$[rsp]
  00034	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00037	85 c0		 test	 eax, eax
  00039	74 29		 je	 SHORT $LN2@PyObject_C@4

; 2122 :         va_start(va, format);

  0003b	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp+8]
  00040	48 89 44 24 28	 mov	 QWORD PTR va$[rsp], rax

; 2123 :         args = Py_VaBuildValue(format, va);

  00045	48 8b 54 24 28	 mov	 rdx, QWORD PTR va$[rsp]
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR format$[rsp]
  0004f	e8 00 00 00 00	 call	 Py_VaBuildValue
  00054	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 2124 :         va_end(va);

  00059	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 2125 :     }
; 2126 :     else

  00062	eb 0c		 jmp	 SHORT $LN1@PyObject_C@4
$LN2@PyObject_C@4:

; 2127 :         args = PyTuple_New(0);

  00064	33 c9		 xor	 ecx, ecx
  00066	e8 00 00 00 00	 call	 PyTuple_New
  0006b	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax
$LN1@PyObject_C@4:

; 2128 : 
; 2129 :     return call_function_tail(callable, args);

  00070	48 8b 54 24 20	 mov	 rdx, QWORD PTR args$[rsp]
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR callable$[rsp]
  0007a	e8 00 00 00 00	 call	 call_function_tail
$LN4@PyObject_C@4:

; 2130 : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
PyObject_CallFunction ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$call_function_tail DD imagerel call_function_tail
	DD	imagerel call_function_tail+154
	DD	imagerel $unwind$call_function_tail
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$call_function_tail DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT call_function_tail
_TEXT	SEGMENT
retval$ = 32
a$21994 = 40
callable$ = 64
args$ = 72
call_function_tail PROC					; COMDAT

; 2088 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2089 :     PyObject *retval;
; 2090 : 
; 2091 :     if (args == NULL)

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR args$[rsp], 0
  00014	75 04		 jne	 SHORT $LN3@call_funct

; 2092 :         return NULL;

  00016	33 c0		 xor	 eax, eax
  00018	eb 7b		 jmp	 SHORT $LN4@call_funct
$LN3@call_funct:

; 2093 : 
; 2094 :     if (!PyTuple_Check(args)) {

  0001a	48 8b 44 24 48	 mov	 rax, QWORD PTR args$[rsp]
  0001f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00023	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00029	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0002e	85 c0		 test	 eax, eax
  00030	75 3d		 jne	 SHORT $LN2@call_funct

; 2095 :         PyObject *a;
; 2096 : 
; 2097 :         a = PyTuple_New(1);

  00032	b9 01 00 00 00	 mov	 ecx, 1
  00037	e8 00 00 00 00	 call	 PyTuple_New
  0003c	48 89 44 24 28	 mov	 QWORD PTR a$21994[rsp], rax

; 2098 :         if (a == NULL) {

  00041	48 83 7c 24 28
	00		 cmp	 QWORD PTR a$21994[rsp], 0
  00047	75 0e		 jne	 SHORT $LN1@call_funct

; 2099 :             Py_DECREF(args);

  00049	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0004e	e8 00 00 00 00	 call	 _Py_DecRef

; 2100 :             return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	eb 3e		 jmp	 SHORT $LN4@call_funct
$LN1@call_funct:

; 2101 :         }
; 2102 :         PyTuple_SET_ITEM(a, 0, args);

  00057	48 8b 44 24 28	 mov	 rax, QWORD PTR a$21994[rsp]
  0005c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00061	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 2103 :         args = a;

  00065	48 8b 44 24 28	 mov	 rax, QWORD PTR a$21994[rsp]
  0006a	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN2@call_funct:

; 2104 :     }
; 2105 :     retval = PyObject_Call(callable, args, NULL);

  0006f	45 33 c0	 xor	 r8d, r8d
  00072	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR callable$[rsp]
  0007c	e8 00 00 00 00	 call	 PyObject_Call
  00081	48 89 44 24 20	 mov	 QWORD PTR retval$[rsp], rax

; 2106 : 
; 2107 :     Py_DECREF(args);

  00086	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0008b	e8 00 00 00 00	 call	 _Py_DecRef

; 2108 : 
; 2109 :     return retval;

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR retval$[rsp]
$LN4@call_funct:

; 2110 : }

  00095	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00099	c3		 ret	 0
call_function_tail ENDP
_TEXT	ENDS
PUBLIC	_PyObject_CallFunction_SizeT
EXTRN	_Py_VaBuildValue_SizeT:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_CallFunction_SizeT DD imagerel $LN6
	DD	imagerel $LN6+132
	DD	imagerel $unwind$_PyObject_CallFunction_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_CallFunction_SizeT DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_CallFunction_SizeT
_TEXT	SEGMENT
args$ = 32
va$ = 40
callable$ = 64
format$ = 72
_PyObject_CallFunction_SizeT PROC			; COMDAT

; 2134 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2135 :     va_list va;
; 2136 :     PyObject *args;
; 2137 : 
; 2138 :     if (callable == NULL)

  00018	48 83 7c 24 40
	00		 cmp	 QWORD PTR callable$[rsp], 0
  0001e	75 07		 jne	 SHORT $LN3@PyObject_C@5

; 2139 :         return null_error();

  00020	e8 00 00 00 00	 call	 null_error
  00025	eb 58		 jmp	 SHORT $LN4@PyObject_C@5
$LN3@PyObject_C@5:

; 2140 : 
; 2141 :     if (format && *format) {

  00027	48 83 7c 24 48
	00		 cmp	 QWORD PTR format$[rsp], 0
  0002d	74 35		 je	 SHORT $LN2@PyObject_C@5
  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR format$[rsp]
  00034	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00037	85 c0		 test	 eax, eax
  00039	74 29		 je	 SHORT $LN2@PyObject_C@5

; 2142 :         va_start(va, format);

  0003b	48 8d 44 24 50	 lea	 rax, QWORD PTR format$[rsp+8]
  00040	48 89 44 24 28	 mov	 QWORD PTR va$[rsp], rax

; 2143 :         args = _Py_VaBuildValue_SizeT(format, va);

  00045	48 8b 54 24 28	 mov	 rdx, QWORD PTR va$[rsp]
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR format$[rsp]
  0004f	e8 00 00 00 00	 call	 _Py_VaBuildValue_SizeT
  00054	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 2144 :         va_end(va);

  00059	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 2145 :     }
; 2146 :     else

  00062	eb 0c		 jmp	 SHORT $LN1@PyObject_C@5
$LN2@PyObject_C@5:

; 2147 :         args = PyTuple_New(0);

  00064	33 c9		 xor	 ecx, ecx
  00066	e8 00 00 00 00	 call	 PyTuple_New
  0006b	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax
$LN1@PyObject_C@5:

; 2148 : 
; 2149 :     return call_function_tail(callable, args);

  00070	48 8b 54 24 20	 mov	 rdx, QWORD PTR args$[rsp]
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR callable$[rsp]
  0007a	e8 00 00 00 00	 call	 call_function_tail
$LN4@PyObject_C@5:

; 2150 : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_PyObject_CallFunction_SizeT ENDP
_TEXT	ENDS
PUBLIC	PyObject_CallMethod
EXTRN	PyObject_GetAttrString:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CallMethod DD imagerel $LN6
	DD	imagerel $LN6+154
	DD	imagerel $unwind$PyObject_CallMethod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CallMethod DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_CallMethod
_TEXT	SEGMENT
retval$ = 32
va$ = 40
func$ = 48
o$ = 80
name$ = 88
format$ = 96
PyObject_CallMethod PROC				; COMDAT

; 2183 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2184 :     va_list va;
; 2185 :     PyObject *func = NULL;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR func$[rsp], 0

; 2186 :     PyObject *retval = NULL;

  00021	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR retval$[rsp], 0

; 2187 : 
; 2188 :     if (o == NULL || name == NULL)

  0002a	48 83 7c 24 50
	00		 cmp	 QWORD PTR o$[rsp], 0
  00030	74 08		 je	 SHORT $LN2@PyObject_C@6
  00032	48 83 7c 24 58
	00		 cmp	 QWORD PTR name$[rsp], 0
  00038	75 07		 jne	 SHORT $LN3@PyObject_C@6
$LN2@PyObject_C@6:

; 2189 :         return null_error();

  0003a	e8 00 00 00 00	 call	 null_error
  0003f	eb 54		 jmp	 SHORT $LN4@PyObject_C@6
$LN3@PyObject_C@6:

; 2190 : 
; 2191 :     func = PyObject_GetAttrString(o, name);

  00041	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  0004b	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00050	48 89 44 24 30	 mov	 QWORD PTR func$[rsp], rax

; 2192 :     if (func == NULL) {

  00055	48 83 7c 24 30
	00		 cmp	 QWORD PTR func$[rsp], 0
  0005b	75 04		 jne	 SHORT $LN1@PyObject_C@6

; 2193 :         return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 34		 jmp	 SHORT $LN4@PyObject_C@6
$LN1@PyObject_C@6:

; 2194 :     }
; 2195 : 
; 2196 :     va_start(va, format);

  00061	48 8d 44 24 68	 lea	 rax, QWORD PTR format$[rsp+8]
  00066	48 89 44 24 28	 mov	 QWORD PTR va$[rsp], rax

; 2197 :     retval = callmethod(func, format, va, 0);

  0006b	45 33 c9	 xor	 r9d, r9d
  0006e	4c 8b 44 24 28	 mov	 r8, QWORD PTR va$[rsp]
  00073	48 8b 54 24 60	 mov	 rdx, QWORD PTR format$[rsp]
  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR func$[rsp]
  0007d	e8 00 00 00 00	 call	 callmethod
  00082	48 89 44 24 20	 mov	 QWORD PTR retval$[rsp], rax

; 2198 :     va_end(va);

  00087	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 2199 :     return retval;

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR retval$[rsp]
$LN4@PyObject_C@6:

; 2200 : }

  00095	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00099	c3		 ret	 0
PyObject_CallMethod ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CL@BGGOELKC@attribute?5of?5type?5?8?$CF?4200s?8?5is?5no@ ; `string'
EXTRN	PyCallable_Check:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$callmethod DD imagerel callmethod
	DD	imagerel callmethod+203
	DD	imagerel $unwind$callmethod
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$callmethod DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT ??_C@_0CL@BGGOELKC@attribute?5of?5type?5?8?$CF?4200s?8?5is?5no@
CONST	SEGMENT
??_C@_0CL@BGGOELKC@attribute?5of?5type?5?8?$CF?4200s?8?5is?5no@ DB 'attri'
	DB	'bute of type ''%.200s'' is not callable', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT callmethod
_TEXT	SEGMENT
args$ = 32
retval$ = 40
func$ = 64
format$ = 72
va$ = 80
is_size_t$ = 88
callmethod PROC						; COMDAT

; 2154 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2155 :     PyObject *retval = NULL;

  00018	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR retval$[rsp], 0

; 2156 :     PyObject *args;
; 2157 : 
; 2158 :     if (!PyCallable_Check(func)) {

  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR func$[rsp]
  00026	e8 00 00 00 00	 call	 PyCallable_Check
  0002b	85 c0		 test	 eax, eax
  0002d	75 13		 jne	 SHORT $LN9@callmethod

; 2159 :         type_error("attribute of type '%.200s' is not callable", func);

  0002f	48 8b 54 24 40	 mov	 rdx, QWORD PTR func$[rsp]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CL@BGGOELKC@attribute?5of?5type?5?8?$CF?4200s?8?5is?5no@
  0003b	e8 00 00 00 00	 call	 type_error

; 2160 :         goto exit;

  00040	eb 67		 jmp	 SHORT $exit$22043
$LN9@callmethod:

; 2161 :     }
; 2162 : 
; 2163 :     if (format && *format) {

  00042	48 83 7c 24 48
	00		 cmp	 QWORD PTR format$[rsp], 0
  00048	74 3f		 je	 SHORT $LN8@callmethod
  0004a	48 8b 44 24 48	 mov	 rax, QWORD PTR format$[rsp]
  0004f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00052	85 c0		 test	 eax, eax
  00054	74 33		 je	 SHORT $LN8@callmethod

; 2164 :         if (is_size_t)

  00056	83 7c 24 58 00	 cmp	 DWORD PTR is_size_t$[rsp], 0
  0005b	74 16		 je	 SHORT $LN7@callmethod

; 2165 :             args = _Py_VaBuildValue_SizeT(format, va);

  0005d	48 8b 54 24 50	 mov	 rdx, QWORD PTR va$[rsp]
  00062	48 8b 4c 24 48	 mov	 rcx, QWORD PTR format$[rsp]
  00067	e8 00 00 00 00	 call	 _Py_VaBuildValue_SizeT
  0006c	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 2166 :         else

  00071	eb 14		 jmp	 SHORT $LN6@callmethod
$LN7@callmethod:

; 2167 :             args = Py_VaBuildValue(format, va);

  00073	48 8b 54 24 50	 mov	 rdx, QWORD PTR va$[rsp]
  00078	48 8b 4c 24 48	 mov	 rcx, QWORD PTR format$[rsp]
  0007d	e8 00 00 00 00	 call	 Py_VaBuildValue
  00082	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax
$LN6@callmethod:

; 2168 :     }
; 2169 :     else

  00087	eb 0c		 jmp	 SHORT $LN5@callmethod
$LN8@callmethod:

; 2170 :         args = PyTuple_New(0);

  00089	33 c9		 xor	 ecx, ecx
  0008b	e8 00 00 00 00	 call	 PyTuple_New
  00090	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax
$LN5@callmethod:

; 2171 : 
; 2172 :     retval = call_function_tail(func, args);

  00095	48 8b 54 24 20	 mov	 rdx, QWORD PTR args$[rsp]
  0009a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR func$[rsp]
  0009f	e8 00 00 00 00	 call	 call_function_tail
  000a4	48 89 44 24 28	 mov	 QWORD PTR retval$[rsp], rax
$exit$22043:
$LN4@callmethod:

; 2173 : 
; 2174 :   exit:
; 2175 :     /* args gets consumed in call_function_tail */
; 2176 :     Py_XDECREF(func);

  000a9	48 83 7c 24 40
	00		 cmp	 QWORD PTR func$[rsp], 0
  000af	74 0a		 je	 SHORT $LN1@callmethod
  000b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR func$[rsp]
  000b6	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@callmethod:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 e8		 jne	 SHORT $LN4@callmethod

; 2177 : 
; 2178 :     return retval;

  000c1	48 8b 44 24 28	 mov	 rax, QWORD PTR retval$[rsp]

; 2179 : }

  000c6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ca	c3		 ret	 0
callmethod ENDP
_TEXT	ENDS
EXTRN	_PyObject_GetAttrId:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_CallMethodId DD imagerel $LN6
	DD	imagerel $LN6+154
	DD	imagerel $unwind$_PyObject_CallMethodId
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_CallMethodId DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_CallMethodId
_TEXT	SEGMENT
retval$ = 32
va$ = 40
func$ = 48
o$ = 80
name$ = 88
format$ = 96
_PyObject_CallMethodId PROC				; COMDAT

; 2204 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2205 :     va_list va;
; 2206 :     PyObject *func = NULL;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR func$[rsp], 0

; 2207 :     PyObject *retval = NULL;

  00021	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR retval$[rsp], 0

; 2208 : 
; 2209 :     if (o == NULL || name == NULL)

  0002a	48 83 7c 24 50
	00		 cmp	 QWORD PTR o$[rsp], 0
  00030	74 08		 je	 SHORT $LN2@PyObject_C@7
  00032	48 83 7c 24 58
	00		 cmp	 QWORD PTR name$[rsp], 0
  00038	75 07		 jne	 SHORT $LN3@PyObject_C@7
$LN2@PyObject_C@7:

; 2210 :         return null_error();

  0003a	e8 00 00 00 00	 call	 null_error
  0003f	eb 54		 jmp	 SHORT $LN4@PyObject_C@7
$LN3@PyObject_C@7:

; 2211 : 
; 2212 :     func = _PyObject_GetAttrId(o, name);

  00041	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  00046	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  0004b	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00050	48 89 44 24 30	 mov	 QWORD PTR func$[rsp], rax

; 2213 :     if (func == NULL) {

  00055	48 83 7c 24 30
	00		 cmp	 QWORD PTR func$[rsp], 0
  0005b	75 04		 jne	 SHORT $LN1@PyObject_C@7

; 2214 :         return 0;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 34		 jmp	 SHORT $LN4@PyObject_C@7
$LN1@PyObject_C@7:

; 2215 :     }
; 2216 : 
; 2217 :     va_start(va, format);

  00061	48 8d 44 24 68	 lea	 rax, QWORD PTR format$[rsp+8]
  00066	48 89 44 24 28	 mov	 QWORD PTR va$[rsp], rax

; 2218 :     retval = callmethod(func, format, va, 0);

  0006b	45 33 c9	 xor	 r9d, r9d
  0006e	4c 8b 44 24 28	 mov	 r8, QWORD PTR va$[rsp]
  00073	48 8b 54 24 60	 mov	 rdx, QWORD PTR format$[rsp]
  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR func$[rsp]
  0007d	e8 00 00 00 00	 call	 callmethod
  00082	48 89 44 24 20	 mov	 QWORD PTR retval$[rsp], rax

; 2219 :     va_end(va);

  00087	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 2220 :     return retval;

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR retval$[rsp]
$LN4@PyObject_C@7:

; 2221 : }

  00095	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00099	c3		 ret	 0
_PyObject_CallMethodId ENDP
_TEXT	ENDS
PUBLIC	_PyObject_CallMethod_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_CallMethod_SizeT DD imagerel $LN6
	DD	imagerel $LN6+148
	DD	imagerel $unwind$_PyObject_CallMethod_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_CallMethod_SizeT DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_CallMethod_SizeT
_TEXT	SEGMENT
retval$ = 32
va$ = 40
func$ = 48
o$ = 80
name$ = 88
format$ = 96
_PyObject_CallMethod_SizeT PROC				; COMDAT

; 2225 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2226 :     va_list va;
; 2227 :     PyObject *func = NULL;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR func$[rsp], 0

; 2228 :     PyObject *retval;
; 2229 : 
; 2230 :     if (o == NULL || name == NULL)

  00021	48 83 7c 24 50
	00		 cmp	 QWORD PTR o$[rsp], 0
  00027	74 08		 je	 SHORT $LN2@PyObject_C@8
  00029	48 83 7c 24 58
	00		 cmp	 QWORD PTR name$[rsp], 0
  0002f	75 07		 jne	 SHORT $LN3@PyObject_C@8
$LN2@PyObject_C@8:

; 2231 :         return null_error();

  00031	e8 00 00 00 00	 call	 null_error
  00036	eb 57		 jmp	 SHORT $LN4@PyObject_C@8
$LN3@PyObject_C@8:

; 2232 : 
; 2233 :     func = PyObject_GetAttrString(o, name);

  00038	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  0003d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00042	e8 00 00 00 00	 call	 PyObject_GetAttrString
  00047	48 89 44 24 30	 mov	 QWORD PTR func$[rsp], rax

; 2234 :     if (func == NULL) {

  0004c	48 83 7c 24 30
	00		 cmp	 QWORD PTR func$[rsp], 0
  00052	75 04		 jne	 SHORT $LN1@PyObject_C@8

; 2235 :         return 0;

  00054	33 c0		 xor	 eax, eax
  00056	eb 37		 jmp	 SHORT $LN4@PyObject_C@8
$LN1@PyObject_C@8:

; 2236 :     }
; 2237 :     va_start(va, format);

  00058	48 8d 44 24 68	 lea	 rax, QWORD PTR format$[rsp+8]
  0005d	48 89 44 24 28	 mov	 QWORD PTR va$[rsp], rax

; 2238 :     retval = callmethod(func, format, va, 1);

  00062	41 b9 01 00 00
	00		 mov	 r9d, 1
  00068	4c 8b 44 24 28	 mov	 r8, QWORD PTR va$[rsp]
  0006d	48 8b 54 24 60	 mov	 rdx, QWORD PTR format$[rsp]
  00072	48 8b 4c 24 30	 mov	 rcx, QWORD PTR func$[rsp]
  00077	e8 00 00 00 00	 call	 callmethod
  0007c	48 89 44 24 20	 mov	 QWORD PTR retval$[rsp], rax

; 2239 :     va_end(va);

  00081	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 2240 :     return retval;

  0008a	48 8b 44 24 20	 mov	 rax, QWORD PTR retval$[rsp]
$LN4@PyObject_C@8:

; 2241 : }

  0008f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00093	c3		 ret	 0
_PyObject_CallMethod_SizeT ENDP
_TEXT	ENDS
PUBLIC	_PyObject_CallMethodId_SizeT
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_CallMethodId_SizeT DD imagerel $LN6
	DD	imagerel $LN6+148
	DD	imagerel $unwind$_PyObject_CallMethodId_SizeT
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_CallMethodId_SizeT DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_CallMethodId_SizeT
_TEXT	SEGMENT
retval$ = 32
va$ = 40
func$ = 48
o$ = 80
name$ = 88
format$ = 96
_PyObject_CallMethodId_SizeT PROC			; COMDAT

; 2245 : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2246 :     va_list va;
; 2247 :     PyObject *func = NULL;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR func$[rsp], 0

; 2248 :     PyObject *retval;
; 2249 : 
; 2250 :     if (o == NULL || name == NULL)

  00021	48 83 7c 24 50
	00		 cmp	 QWORD PTR o$[rsp], 0
  00027	74 08		 je	 SHORT $LN2@PyObject_C@9
  00029	48 83 7c 24 58
	00		 cmp	 QWORD PTR name$[rsp], 0
  0002f	75 07		 jne	 SHORT $LN3@PyObject_C@9
$LN2@PyObject_C@9:

; 2251 :         return null_error();

  00031	e8 00 00 00 00	 call	 null_error
  00036	eb 57		 jmp	 SHORT $LN4@PyObject_C@9
$LN3@PyObject_C@9:

; 2252 : 
; 2253 :     func = _PyObject_GetAttrId(o, name);

  00038	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  0003d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00042	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00047	48 89 44 24 30	 mov	 QWORD PTR func$[rsp], rax

; 2254 :     if (func == NULL) {

  0004c	48 83 7c 24 30
	00		 cmp	 QWORD PTR func$[rsp], 0
  00052	75 04		 jne	 SHORT $LN1@PyObject_C@9

; 2255 :         return NULL;

  00054	33 c0		 xor	 eax, eax
  00056	eb 37		 jmp	 SHORT $LN4@PyObject_C@9
$LN1@PyObject_C@9:

; 2256 :     }
; 2257 :     va_start(va, format);

  00058	48 8d 44 24 68	 lea	 rax, QWORD PTR format$[rsp+8]
  0005d	48 89 44 24 28	 mov	 QWORD PTR va$[rsp], rax

; 2258 :     retval = callmethod(func, format, va, 1);

  00062	41 b9 01 00 00
	00		 mov	 r9d, 1
  00068	4c 8b 44 24 28	 mov	 r8, QWORD PTR va$[rsp]
  0006d	48 8b 54 24 60	 mov	 rdx, QWORD PTR format$[rsp]
  00072	48 8b 4c 24 30	 mov	 rcx, QWORD PTR func$[rsp]
  00077	e8 00 00 00 00	 call	 callmethod
  0007c	48 89 44 24 20	 mov	 QWORD PTR retval$[rsp], rax

; 2259 :     va_end(va);

  00081	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 2260 :     return retval;

  0008a	48 8b 44 24 20	 mov	 rax, QWORD PTR retval$[rsp]
$LN4@PyObject_C@9:

; 2261 : }

  0008f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00093	c3		 ret	 0
_PyObject_CallMethodId_SizeT ENDP
_TEXT	ENDS
PUBLIC	PyObject_CallMethodObjArgs
EXTRN	PyObject_GetAttr:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CallMethodObjArgs DD imagerel $LN7
	DD	imagerel $LN7+191
	DD	imagerel $unwind$PyObject_CallMethodObjArgs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CallMethodObjArgs DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_CallMethodObjArgs
_TEXT	SEGMENT
args$ = 32
vargs$ = 40
tmp$ = 48
callable$ = 80
name$ = 88
PyObject_CallMethodObjArgs PROC				; COMDAT

; 2287 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2288 :     PyObject *args, *tmp;
; 2289 :     va_list vargs;
; 2290 : 
; 2291 :     if (callable == NULL || name == NULL)

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR callable$[rsp], 0
  0001e	74 08		 je	 SHORT $LN3@PyObject_C@10
  00020	48 83 7c 24 58
	00		 cmp	 QWORD PTR name$[rsp], 0
  00026	75 0a		 jne	 SHORT $LN4@PyObject_C@10
$LN3@PyObject_C@10:

; 2292 :         return null_error();

  00028	e8 00 00 00 00	 call	 null_error
  0002d	e9 88 00 00 00	 jmp	 $LN5@PyObject_C@10
$LN4@PyObject_C@10:

; 2293 : 
; 2294 :     callable = PyObject_GetAttr(callable, name);

  00032	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  00037	48 8b 4c 24 50	 mov	 rcx, QWORD PTR callable$[rsp]
  0003c	e8 00 00 00 00	 call	 PyObject_GetAttr
  00041	48 89 44 24 50	 mov	 QWORD PTR callable$[rsp], rax

; 2295 :     if (callable == NULL)

  00046	48 83 7c 24 50
	00		 cmp	 QWORD PTR callable$[rsp], 0
  0004c	75 04		 jne	 SHORT $LN2@PyObject_C@10

; 2296 :         return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	eb 68		 jmp	 SHORT $LN5@PyObject_C@10
$LN2@PyObject_C@10:

; 2297 : 
; 2298 :     /* count the args */
; 2299 :     va_start(vargs, name);

  00052	48 8d 44 24 60	 lea	 rax, QWORD PTR name$[rsp+8]
  00057	48 89 44 24 28	 mov	 QWORD PTR vargs$[rsp], rax

; 2300 :     args = objargs_mktuple(vargs);

  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vargs$[rsp]
  00061	e8 00 00 00 00	 call	 objargs_mktuple
  00066	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 2301 :     va_end(vargs);

  0006b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR vargs$[rsp], 0

; 2302 :     if (args == NULL) {

  00074	48 83 7c 24 20
	00		 cmp	 QWORD PTR args$[rsp], 0
  0007a	75 0e		 jne	 SHORT $LN1@PyObject_C@10

; 2303 :         Py_DECREF(callable);

  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR callable$[rsp]
  00081	e8 00 00 00 00	 call	 _Py_DecRef

; 2304 :         return NULL;

  00086	33 c0		 xor	 eax, eax
  00088	eb 30		 jmp	 SHORT $LN5@PyObject_C@10
$LN1@PyObject_C@10:

; 2305 :     }
; 2306 :     tmp = PyObject_Call(callable, args, NULL);

  0008a	45 33 c0	 xor	 r8d, r8d
  0008d	48 8b 54 24 20	 mov	 rdx, QWORD PTR args$[rsp]
  00092	48 8b 4c 24 50	 mov	 rcx, QWORD PTR callable$[rsp]
  00097	e8 00 00 00 00	 call	 PyObject_Call
  0009c	48 89 44 24 30	 mov	 QWORD PTR tmp$[rsp], rax

; 2307 :     Py_DECREF(args);

  000a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  000a6	e8 00 00 00 00	 call	 _Py_DecRef

; 2308 :     Py_DECREF(callable);

  000ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR callable$[rsp]
  000b0	e8 00 00 00 00	 call	 _Py_DecRef

; 2309 : 
; 2310 :     return tmp;

  000b5	48 8b 44 24 30	 mov	 rax, QWORD PTR tmp$[rsp]
$LN5@PyObject_C@10:

; 2311 : }

  000ba	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000be	c3		 ret	 0
PyObject_CallMethodObjArgs ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$objargs_mktuple DD imagerel objargs_mktuple
	DD	imagerel objargs_mktuple+198
	DD	imagerel $unwind$objargs_mktuple
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$objargs_mktuple DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT objargs_mktuple
_TEXT	SEGMENT
n$ = 32
i$ = 36
tmp$ = 40
countva$ = 48
result$ = 56
va$ = 80
objargs_mktuple PROC					; COMDAT

; 2265 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2266 :     int i, n = 0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 2267 :     va_list countva;
; 2268 :     PyObject *result, *tmp;
; 2269 : 
; 2270 :         Py_VA_COPY(countva, va);

  00011	48 8b 44 24 50	 mov	 rax, QWORD PTR va$[rsp]
  00016	48 89 44 24 30	 mov	 QWORD PTR countva$[rsp], rax
$LN6@objargs_mk:

; 2271 : 
; 2272 :     while (((PyObject *)va_arg(countva, PyObject *)) != NULL)

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR countva$[rsp]
  00020	48 83 c0 08	 add	 rax, 8
  00024	48 89 44 24 30	 mov	 QWORD PTR countva$[rsp], rax
  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR countva$[rsp]
  0002e	48 83 78 f8 00	 cmp	 QWORD PTR [rax-8], 0
  00033	74 0c		 je	 SHORT $LN5@objargs_mk

; 2273 :         ++n;

  00035	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00039	ff c0		 inc	 eax
  0003b	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
  0003f	eb da		 jmp	 SHORT $LN6@objargs_mk
$LN5@objargs_mk:

; 2274 :     result = PyTuple_New(n);

  00041	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$[rsp]
  00046	48 8b c8	 mov	 rcx, rax
  00049	e8 00 00 00 00	 call	 PyTuple_New
  0004e	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 2275 :     if (result != NULL && n > 0) {

  00053	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  00059	74 61		 je	 SHORT $LN4@objargs_mk
  0005b	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  00060	7e 5a		 jle	 SHORT $LN4@objargs_mk

; 2276 :         for (i = 0; i < n; ++i) {

  00062	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006a	eb 0a		 jmp	 SHORT $LN3@objargs_mk
$LN2@objargs_mk:
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00070	ff c0		 inc	 eax
  00072	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN3@objargs_mk:
  00076	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0007a	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0007e	7d 3c		 jge	 SHORT $LN1@objargs_mk

; 2277 :             tmp = (PyObject *)va_arg(va, PyObject *);

  00080	48 8b 44 24 50	 mov	 rax, QWORD PTR va$[rsp]
  00085	48 83 c0 08	 add	 rax, 8
  00089	48 89 44 24 50	 mov	 QWORD PTR va$[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR va$[rsp]
  00093	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00097	48 89 44 24 28	 mov	 QWORD PTR tmp$[rsp], rax

; 2278 :             PyTuple_SET_ITEM(result, i, tmp);

  0009c	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  000a6	48 8b 54 24 28	 mov	 rdx, QWORD PTR tmp$[rsp]
  000ab	48 89 54 c1 70	 mov	 QWORD PTR [rcx+rax*8+112], rdx

; 2279 :             Py_INCREF(tmp);

  000b0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmp$[rsp]
  000b5	e8 00 00 00 00	 call	 _Py_IncRef

; 2280 :         }

  000ba	eb b0		 jmp	 SHORT $LN2@objargs_mk
$LN1@objargs_mk:
$LN4@objargs_mk:

; 2281 :     }
; 2282 :     return result;

  000bc	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]

; 2283 : }

  000c1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c5	c3		 ret	 0
objargs_mktuple ENDP
_TEXT	ENDS
PUBLIC	_PyObject_CallMethodObjIdArgs
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_CallMethodObjIdArgs DD imagerel $LN7
	DD	imagerel $LN7+191
	DD	imagerel $unwind$_PyObject_CallMethodObjIdArgs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_CallMethodObjIdArgs DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_CallMethodObjIdArgs
_TEXT	SEGMENT
args$ = 32
vargs$ = 40
tmp$ = 48
callable$ = 80
name$ = 88
_PyObject_CallMethodObjIdArgs PROC			; COMDAT

; 2316 : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2317 :     PyObject *args, *tmp;
; 2318 :     va_list vargs;
; 2319 : 
; 2320 :     if (callable == NULL || name == NULL)

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR callable$[rsp], 0
  0001e	74 08		 je	 SHORT $LN3@PyObject_C@11
  00020	48 83 7c 24 58
	00		 cmp	 QWORD PTR name$[rsp], 0
  00026	75 0a		 jne	 SHORT $LN4@PyObject_C@11
$LN3@PyObject_C@11:

; 2321 :         return null_error();

  00028	e8 00 00 00 00	 call	 null_error
  0002d	e9 88 00 00 00	 jmp	 $LN5@PyObject_C@11
$LN4@PyObject_C@11:

; 2322 : 
; 2323 :     callable = _PyObject_GetAttrId(callable, name);

  00032	48 8b 54 24 58	 mov	 rdx, QWORD PTR name$[rsp]
  00037	48 8b 4c 24 50	 mov	 rcx, QWORD PTR callable$[rsp]
  0003c	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00041	48 89 44 24 50	 mov	 QWORD PTR callable$[rsp], rax

; 2324 :     if (callable == NULL)

  00046	48 83 7c 24 50
	00		 cmp	 QWORD PTR callable$[rsp], 0
  0004c	75 04		 jne	 SHORT $LN2@PyObject_C@11

; 2325 :         return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	eb 68		 jmp	 SHORT $LN5@PyObject_C@11
$LN2@PyObject_C@11:

; 2326 : 
; 2327 :     /* count the args */
; 2328 :     va_start(vargs, name);

  00052	48 8d 44 24 60	 lea	 rax, QWORD PTR name$[rsp+8]
  00057	48 89 44 24 28	 mov	 QWORD PTR vargs$[rsp], rax

; 2329 :     args = objargs_mktuple(vargs);

  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vargs$[rsp]
  00061	e8 00 00 00 00	 call	 objargs_mktuple
  00066	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 2330 :     va_end(vargs);

  0006b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR vargs$[rsp], 0

; 2331 :     if (args == NULL) {

  00074	48 83 7c 24 20
	00		 cmp	 QWORD PTR args$[rsp], 0
  0007a	75 0e		 jne	 SHORT $LN1@PyObject_C@11

; 2332 :         Py_DECREF(callable);

  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR callable$[rsp]
  00081	e8 00 00 00 00	 call	 _Py_DecRef

; 2333 :         return NULL;

  00086	33 c0		 xor	 eax, eax
  00088	eb 30		 jmp	 SHORT $LN5@PyObject_C@11
$LN1@PyObject_C@11:

; 2334 :     }
; 2335 :     tmp = PyObject_Call(callable, args, NULL);

  0008a	45 33 c0	 xor	 r8d, r8d
  0008d	48 8b 54 24 20	 mov	 rdx, QWORD PTR args$[rsp]
  00092	48 8b 4c 24 50	 mov	 rcx, QWORD PTR callable$[rsp]
  00097	e8 00 00 00 00	 call	 PyObject_Call
  0009c	48 89 44 24 30	 mov	 QWORD PTR tmp$[rsp], rax

; 2336 :     Py_DECREF(args);

  000a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  000a6	e8 00 00 00 00	 call	 _Py_DecRef

; 2337 :     Py_DECREF(callable);

  000ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR callable$[rsp]
  000b0	e8 00 00 00 00	 call	 _Py_DecRef

; 2338 : 
; 2339 :     return tmp;

  000b5	48 8b 44 24 30	 mov	 rax, QWORD PTR tmp$[rsp]
$LN5@PyObject_C@11:

; 2340 : }

  000ba	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000be	c3		 ret	 0
_PyObject_CallMethodObjIdArgs ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_CallFunctionObjArgs DD imagerel $LN5
	DD	imagerel $LN5+128
	DD	imagerel $unwind$PyObject_CallFunctionObjArgs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_CallFunctionObjArgs DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyObject_CallFunctionObjArgs
_TEXT	SEGMENT
args$ = 32
vargs$ = 40
tmp$ = 48
callable$ = 80
PyObject_CallFunctionObjArgs PROC			; COMDAT

; 2344 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2345 :     PyObject *args, *tmp;
; 2346 :     va_list vargs;
; 2347 : 
; 2348 :     if (callable == NULL)

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR callable$[rsp], 0
  0001e	75 07		 jne	 SHORT $LN2@PyObject_C@12

; 2349 :         return null_error();

  00020	e8 00 00 00 00	 call	 null_error
  00025	eb 54		 jmp	 SHORT $LN3@PyObject_C@12
$LN2@PyObject_C@12:

; 2350 : 
; 2351 :     /* count the args */
; 2352 :     va_start(vargs, callable);

  00027	48 8d 44 24 58	 lea	 rax, QWORD PTR callable$[rsp+8]
  0002c	48 89 44 24 28	 mov	 QWORD PTR vargs$[rsp], rax

; 2353 :     args = objargs_mktuple(vargs);

  00031	48 8b 4c 24 28	 mov	 rcx, QWORD PTR vargs$[rsp]
  00036	e8 00 00 00 00	 call	 objargs_mktuple
  0003b	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 2354 :     va_end(vargs);

  00040	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR vargs$[rsp], 0

; 2355 :     if (args == NULL)

  00049	48 83 7c 24 20
	00		 cmp	 QWORD PTR args$[rsp], 0
  0004f	75 04		 jne	 SHORT $LN1@PyObject_C@12

; 2356 :         return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	eb 26		 jmp	 SHORT $LN3@PyObject_C@12
$LN1@PyObject_C@12:

; 2357 :     tmp = PyObject_Call(callable, args, NULL);

  00055	45 33 c0	 xor	 r8d, r8d
  00058	48 8b 54 24 20	 mov	 rdx, QWORD PTR args$[rsp]
  0005d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR callable$[rsp]
  00062	e8 00 00 00 00	 call	 PyObject_Call
  00067	48 89 44 24 30	 mov	 QWORD PTR tmp$[rsp], rax

; 2358 :     Py_DECREF(args);

  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR args$[rsp]
  00071	e8 00 00 00 00	 call	 _Py_DecRef

; 2359 : 
; 2360 :     return tmp;

  00076	48 8b 44 24 30	 mov	 rax, QWORD PTR tmp$[rsp]
$LN3@PyObject_C@12:

; 2361 : }

  0007b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007f	c3		 ret	 0
PyObject_CallFunctionObjArgs ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@BEMDGCAH@?5in?5__instancecheck__?$AA@	; `string'
PUBLIC	PyObject_IsInstance
EXTRN	PyObject_IsTrue:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_IsInstance DD imagerel $LN27
	DD	imagerel $LN27+754
	DD	imagerel $unwind$PyObject_IsInstance
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_IsInstance DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0BG@BEMDGCAH@?5in?5__instancecheck__?$AA@
CONST	SEGMENT
??_C@_0BG@BEMDGCAH@?5in?5__instancecheck__?$AA@ DB ' in __instancecheck__'
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_IsInstance
_TEXT	SEGMENT
checker$ = 32
n$22352 = 40
i$22351 = 48
r$22353 = 56
item$22360 = 64
res$22369 = 72
ok$22370 = 80
tv72 = 88
tv128 = 96
tv90 = 104
tv145 = 112
tv164 = 120
tv158 = 128
inst$ = 160
cls$ = 168
PyObject_IsInstance PROC				; COMDAT

; 2512 : {

$LN27:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2513 :     _Py_IDENTIFIER(__instancecheck__);
; 2514 :     PyObject *checker;
; 2515 : 
; 2516 :     /* Quick test for an exact match */
; 2517 :     if (Py_TYPE(inst) == (PyTypeObject *)cls)

  00011	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  00019	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR cls$[rsp]
  00021	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  00025	75 0a		 jne	 SHORT $LN20@PyObject_I

; 2518 :         return 1;

  00027	b8 01 00 00 00	 mov	 eax, 1
  0002c	e9 b9 02 00 00	 jmp	 $LN21@PyObject_I
$LN20@PyObject_I:

; 2519 : 
; 2520 :     if (PyTuple_Check(cls)) {

  00031	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cls$[rsp]
  00039	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0003d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00043	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 27 01 00
	00		 je	 $LN19@PyObject_I

; 2521 :         Py_ssize_t i;
; 2522 :         Py_ssize_t n;
; 2523 :         int r = 0;

  00050	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR r$22353[rsp], 0

; 2524 : 
; 2525 :         if (Py_EnterRecursiveCall(" in __instancecheck__"))

  00058	e8 00 00 00 00	 call	 PyThreadState_Get
  0005d	48 83 c0 18	 add	 rax, 24
  00061	48 89 44 24 58	 mov	 QWORD PTR tv72[rsp], rax
  00066	48 8b 44 24 58	 mov	 rax, QWORD PTR tv72[rsp]
  0006b	8b 00		 mov	 eax, DWORD PTR [rax]
  0006d	ff c0		 inc	 eax
  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv72[rsp]
  00074	89 01		 mov	 DWORD PTR [rcx], eax
  00076	48 8b 44 24 58	 mov	 rax, QWORD PTR tv72[rsp]
  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Py_CheckRecursionLimit
  00081	39 08		 cmp	 DWORD PTR [rax], ecx
  00083	7e 1a		 jle	 SHORT $LN18@PyObject_I
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@BEMDGCAH@?5in?5__instancecheck__?$AA@
  0008c	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00091	85 c0		 test	 eax, eax
  00093	74 0a		 je	 SHORT $LN18@PyObject_I

; 2526 :             return -1;

  00095	b8 ff ff ff ff	 mov	 eax, -1
  0009a	e9 4b 02 00 00	 jmp	 $LN21@PyObject_I
$LN18@PyObject_I:

; 2527 :         n = PyTuple_GET_SIZE(cls);

  0009f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cls$[rsp]
  000a7	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000ab	48 89 44 24 28	 mov	 QWORD PTR n$22352[rsp], rax

; 2528 :         for (i = 0; i < n; ++i) {

  000b0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$22351[rsp], 0
  000b9	eb 0d		 jmp	 SHORT $LN17@PyObject_I
$LN16@PyObject_I:
  000bb	48 8b 44 24 30	 mov	 rax, QWORD PTR i$22351[rsp]
  000c0	48 ff c0	 inc	 rax
  000c3	48 89 44 24 30	 mov	 QWORD PTR i$22351[rsp], rax
$LN17@PyObject_I:
  000c8	48 8b 44 24 28	 mov	 rax, QWORD PTR n$22352[rsp]
  000cd	48 39 44 24 30	 cmp	 QWORD PTR i$22351[rsp], rax
  000d2	7d 38		 jge	 SHORT $LN15@PyObject_I

; 2529 :             PyObject *item = PyTuple_GET_ITEM(cls, i);

  000d4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cls$[rsp]
  000dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$22351[rsp]
  000e1	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  000e6	48 89 44 24 40	 mov	 QWORD PTR item$22360[rsp], rax

; 2530 :             r = PyObject_IsInstance(inst, item);

  000eb	48 8b 54 24 40	 mov	 rdx, QWORD PTR item$22360[rsp]
  000f0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000f8	e8 00 00 00 00	 call	 PyObject_IsInstance
  000fd	89 44 24 38	 mov	 DWORD PTR r$22353[rsp], eax

; 2531 :             if (r != 0)

  00101	83 7c 24 38 00	 cmp	 DWORD PTR r$22353[rsp], 0
  00106	74 02		 je	 SHORT $LN14@PyObject_I

; 2532 :                 /* either found it, or got an error */
; 2533 :                 break;

  00108	eb 02		 jmp	 SHORT $LN15@PyObject_I
$LN14@PyObject_I:

; 2534 :         }

  0010a	eb af		 jmp	 SHORT $LN16@PyObject_I
$LN15@PyObject_I:
$LN13@PyObject_I:

; 2535 :         Py_LeaveRecursiveCall();

  0010c	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _Py_CheckRecursionLimit, 100 ; 00000064H
  00113	7e 0f		 jle	 SHORT $LN23@PyObject_I
  00115	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  0011b	83 e8 32	 sub	 eax, 50			; 00000032H
  0011e	89 44 24 60	 mov	 DWORD PTR tv128[rsp], eax
  00122	eb 10		 jmp	 SHORT $LN24@PyObject_I
$LN23@PyObject_I:
  00124	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  0012a	c1 f8 02	 sar	 eax, 2
  0012d	6b c0 03	 imul	 eax, 3
  00130	89 44 24 60	 mov	 DWORD PTR tv128[rsp], eax
$LN24@PyObject_I:
  00134	e8 00 00 00 00	 call	 PyThreadState_Get
  00139	48 83 c0 18	 add	 rax, 24
  0013d	48 89 44 24 68	 mov	 QWORD PTR tv90[rsp], rax
  00142	48 8b 44 24 68	 mov	 rax, QWORD PTR tv90[rsp]
  00147	8b 00		 mov	 eax, DWORD PTR [rax]
  00149	ff c8		 dec	 eax
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv90[rsp]
  00150	89 01		 mov	 DWORD PTR [rcx], eax
  00152	48 8b 44 24 68	 mov	 rax, QWORD PTR tv90[rsp]
  00157	8b 4c 24 60	 mov	 ecx, DWORD PTR tv128[rsp]
  0015b	39 08		 cmp	 DWORD PTR [rax], ecx
  0015d	7d 09		 jge	 SHORT $LN10@PyObject_I
  0015f	e8 00 00 00 00	 call	 PyThreadState_Get
  00164	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN10@PyObject_I:
  00168	33 c0		 xor	 eax, eax
  0016a	85 c0		 test	 eax, eax
  0016c	75 9e		 jne	 SHORT $LN13@PyObject_I

; 2536 :         return r;

  0016e	8b 44 24 38	 mov	 eax, DWORD PTR r$22353[rsp]
  00172	e9 73 01 00 00	 jmp	 $LN21@PyObject_I
$LN19@PyObject_I:

; 2537 :     }
; 2538 : 
; 2539 :     checker = _PyObject_LookupSpecial(cls, &PyId___instancecheck__);

  00177	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___instancecheck__@?1??PyObject_IsInstance@@9@9
  0017c	8b c0		 mov	 eax, eax
  0017e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00184	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0018d	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00191	48 8b d0	 mov	 rdx, rax
  00194	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR cls$[rsp]
  0019c	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  001a1	48 89 44 24 20	 mov	 QWORD PTR checker$[rsp], rax

; 2540 :     if (checker != NULL) {

  001a6	48 83 7c 24 20
	00		 cmp	 QWORD PTR checker$[rsp], 0
  001ac	0f 84 12 01 00
	00		 je	 $LN9@PyObject_I

; 2541 :         PyObject *res;
; 2542 :         int ok = -1;

  001b2	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR ok$22370[rsp], -1

; 2543 :         if (Py_EnterRecursiveCall(" in __instancecheck__")) {

  001ba	e8 00 00 00 00	 call	 PyThreadState_Get
  001bf	48 83 c0 18	 add	 rax, 24
  001c3	48 89 44 24 70	 mov	 QWORD PTR tv145[rsp], rax
  001c8	48 8b 44 24 70	 mov	 rax, QWORD PTR tv145[rsp]
  001cd	8b 00		 mov	 eax, DWORD PTR [rax]
  001cf	ff c0		 inc	 eax
  001d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv145[rsp]
  001d6	89 01		 mov	 DWORD PTR [rcx], eax
  001d8	48 8b 44 24 70	 mov	 rax, QWORD PTR tv145[rsp]
  001dd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Py_CheckRecursionLimit
  001e3	39 08		 cmp	 DWORD PTR [rax], ecx
  001e5	7e 23		 jle	 SHORT $LN8@PyObject_I
  001e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@BEMDGCAH@?5in?5__instancecheck__?$AA@
  001ee	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  001f3	85 c0		 test	 eax, eax
  001f5	74 13		 je	 SHORT $LN8@PyObject_I

; 2544 :             Py_DECREF(checker);

  001f7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR checker$[rsp]
  001fc	e8 00 00 00 00	 call	 _Py_DecRef

; 2545 :             return ok;

  00201	8b 44 24 50	 mov	 eax, DWORD PTR ok$22370[rsp]
  00205	e9 e0 00 00 00	 jmp	 $LN21@PyObject_I
$LN8@PyObject_I:

; 2546 :         }
; 2547 :         res = PyObject_CallFunctionObjArgs(checker, inst, NULL);

  0020a	45 33 c0	 xor	 r8d, r8d
  0020d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR inst$[rsp]
  00215	48 8b 4c 24 20	 mov	 rcx, QWORD PTR checker$[rsp]
  0021a	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  0021f	48 89 44 24 48	 mov	 QWORD PTR res$22369[rsp], rax
$LN7@PyObject_I:

; 2548 :         Py_LeaveRecursiveCall();

  00224	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _Py_CheckRecursionLimit, 100 ; 00000064H
  0022b	7e 0f		 jle	 SHORT $LN25@PyObject_I
  0022d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00233	83 e8 32	 sub	 eax, 50			; 00000032H
  00236	89 44 24 78	 mov	 DWORD PTR tv164[rsp], eax
  0023a	eb 10		 jmp	 SHORT $LN26@PyObject_I
$LN25@PyObject_I:
  0023c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00242	c1 f8 02	 sar	 eax, 2
  00245	6b c0 03	 imul	 eax, 3
  00248	89 44 24 78	 mov	 DWORD PTR tv164[rsp], eax
$LN26@PyObject_I:
  0024c	e8 00 00 00 00	 call	 PyThreadState_Get
  00251	48 83 c0 18	 add	 rax, 24
  00255	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv158[rsp], rax
  0025d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv158[rsp]
  00265	8b 00		 mov	 eax, DWORD PTR [rax]
  00267	ff c8		 dec	 eax
  00269	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv158[rsp]
  00271	89 01		 mov	 DWORD PTR [rcx], eax
  00273	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv158[rsp]
  0027b	8b 4c 24 78	 mov	 ecx, DWORD PTR tv164[rsp]
  0027f	39 08		 cmp	 DWORD PTR [rax], ecx
  00281	7d 09		 jge	 SHORT $LN4@PyObject_I
  00283	e8 00 00 00 00	 call	 PyThreadState_Get
  00288	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN4@PyObject_I:
  0028c	33 c0		 xor	 eax, eax
  0028e	85 c0		 test	 eax, eax
  00290	75 92		 jne	 SHORT $LN7@PyObject_I

; 2549 :         Py_DECREF(checker);

  00292	48 8b 4c 24 20	 mov	 rcx, QWORD PTR checker$[rsp]
  00297	e8 00 00 00 00	 call	 _Py_DecRef

; 2550 :         if (res != NULL) {

  0029c	48 83 7c 24 48
	00		 cmp	 QWORD PTR res$22369[rsp], 0
  002a2	74 18		 je	 SHORT $LN3@PyObject_I

; 2551 :             ok = PyObject_IsTrue(res);

  002a4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR res$22369[rsp]
  002a9	e8 00 00 00 00	 call	 PyObject_IsTrue
  002ae	89 44 24 50	 mov	 DWORD PTR ok$22370[rsp], eax

; 2552 :             Py_DECREF(res);

  002b2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR res$22369[rsp]
  002b7	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyObject_I:

; 2553 :         }
; 2554 :         return ok;

  002bc	8b 44 24 50	 mov	 eax, DWORD PTR ok$22370[rsp]
  002c0	eb 28		 jmp	 SHORT $LN21@PyObject_I
  002c2	eb 11		 jmp	 SHORT $LN2@PyObject_I
$LN9@PyObject_I:

; 2555 :     }
; 2556 :     else if (PyErr_Occurred())

  002c4	e8 00 00 00 00	 call	 PyErr_Occurred
  002c9	48 85 c0	 test	 rax, rax
  002cc	74 07		 je	 SHORT $LN1@PyObject_I

; 2557 :         return -1;

  002ce	b8 ff ff ff ff	 mov	 eax, -1
  002d3	eb 15		 jmp	 SHORT $LN21@PyObject_I
$LN1@PyObject_I:
$LN2@PyObject_I:

; 2558 :     return recursive_isinstance(inst, cls);

  002d5	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR cls$[rsp]
  002dd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  002e5	e8 00 00 00 00	 call	 recursive_isinstance
$LN21@PyObject_I:

; 2559 : }

  002ea	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002f1	c3		 ret	 0
PyObject_IsInstance ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DE@JCLEIDJO@isinstance?$CI?$CJ?5arg?52?5must?5be?5a?5typ@ ; `string'
EXTRN	PyExc_AttributeError:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$recursive_isinstance DD imagerel recursive_isinstance
	DD	imagerel recursive_isinstance+436
	DD	imagerel $unwind$recursive_isinstance
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recursive_isinstance DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT ??_C@_0DE@JCLEIDJO@isinstance?$CI?$CJ?5arg?52?5must?5be?5a?5typ@
CONST	SEGMENT
??_C@_0DE@JCLEIDJO@isinstance?$CI?$CJ?5arg?52?5must?5be?5a?5typ@ DB 'isin'
	DB	'stance() arg 2 must be a type or tuple of types', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT recursive_isinstance
_TEXT	SEGMENT
retval$ = 32
icls$ = 40
c$22316 = 48
tv75 = 56
inst$ = 80
cls$ = 88
recursive_isinstance PROC				; COMDAT

; 2465 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2466 :     PyObject *icls;
; 2467 :     int retval = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR retval$[rsp], 0

; 2468 :     _Py_IDENTIFIER(__class__);
; 2469 : 
; 2470 :     if (PyType_Check(cls)) {

  00016	48 8b 44 24 58	 mov	 rax, QWORD PTR cls$[rsp]
  0001b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00025	25 00 00 00 80	 and	 eax, -2147483648	; ffffffff80000000H
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 eb 00 00
	00		 je	 $LN13@recursive_

; 2471 :         retval = PyObject_TypeCheck(inst, (PyTypeObject *)cls);

  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR inst$[rsp]
  00037	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cls$[rsp]
  0003c	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  00040	74 21		 je	 SHORT $LN16@recursive_
  00042	48 8b 54 24 58	 mov	 rdx, QWORD PTR cls$[rsp]
  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR inst$[rsp]
  0004c	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00050	e8 00 00 00 00	 call	 PyType_IsSubtype
  00055	85 c0		 test	 eax, eax
  00057	75 0a		 jne	 SHORT $LN16@recursive_
  00059	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  00061	eb 08		 jmp	 SHORT $LN17@recursive_
$LN16@recursive_:
  00063	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
$LN17@recursive_:
  0006b	8b 44 24 38	 mov	 eax, DWORD PTR tv75[rsp]
  0006f	89 44 24 20	 mov	 DWORD PTR retval$[rsp], eax

; 2472 :         if (retval == 0) {

  00073	83 7c 24 20 00	 cmp	 DWORD PTR retval$[rsp], 0
  00078	0f 85 9a 00 00
	00		 jne	 $LN12@recursive_

; 2473 :             PyObject *c = _PyObject_GetAttrId(inst, &PyId___class__);

  0007e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___class__@?1??recursive_isinstance@@9@9
  00083	8b c0		 mov	 eax, eax
  00085	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0008b	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00094	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00098	48 8b d0	 mov	 rdx, rax
  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000a0	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  000a5	48 89 44 24 30	 mov	 QWORD PTR c$22316[rsp], rax

; 2474 :             if (c == NULL) {

  000aa	48 83 7c 24 30
	00		 cmp	 QWORD PTR c$22316[rsp], 0
  000b0	75 21		 jne	 SHORT $LN11@recursive_

; 2475 :                 if (PyErr_ExceptionMatches(PyExc_AttributeError))

  000b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  000b9	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  000be	85 c0		 test	 eax, eax
  000c0	74 07		 je	 SHORT $LN10@recursive_

; 2476 :                     PyErr_Clear();

  000c2	e8 00 00 00 00	 call	 PyErr_Clear

; 2477 :                 else

  000c7	eb 08		 jmp	 SHORT $LN9@recursive_
$LN10@recursive_:

; 2478 :                     retval = -1;

  000c9	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR retval$[rsp], -1
$LN9@recursive_:

; 2479 :             }
; 2480 :             else {

  000d1	eb 45		 jmp	 SHORT $LN8@recursive_
$LN11@recursive_:

; 2481 :                 if (c != (PyObject *)(inst->ob_type) &&
; 2482 :                     PyType_Check(c))

  000d3	48 8b 44 24 50	 mov	 rax, QWORD PTR inst$[rsp]
  000d8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000dc	48 39 44 24 30	 cmp	 QWORD PTR c$22316[rsp], rax
  000e1	74 2b		 je	 SHORT $LN7@recursive_
  000e3	48 8b 44 24 30	 mov	 rax, QWORD PTR c$22316[rsp]
  000e8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000ec	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000f2	25 00 00 00 80	 and	 eax, -2147483648	; ffffffff80000000H
  000f7	85 c0		 test	 eax, eax
  000f9	74 13		 je	 SHORT $LN7@recursive_

; 2483 :                     retval = PyType_IsSubtype(
; 2484 :                         (PyTypeObject *)c,
; 2485 :                         (PyTypeObject *)cls);

  000fb	48 8b 54 24 58	 mov	 rdx, QWORD PTR cls$[rsp]
  00100	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$22316[rsp]
  00105	e8 00 00 00 00	 call	 PyType_IsSubtype
  0010a	89 44 24 20	 mov	 DWORD PTR retval$[rsp], eax
$LN7@recursive_:

; 2486 :                 Py_DECREF(c);

  0010e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$22316[rsp]
  00113	e8 00 00 00 00	 call	 _Py_DecRef
$LN8@recursive_:
$LN12@recursive_:

; 2487 :             }
; 2488 :         }
; 2489 :     }
; 2490 :     else {

  00118	e9 8e 00 00 00	 jmp	 $LN6@recursive_
$LN13@recursive_:

; 2491 :         if (!check_class(cls,
; 2492 :             "isinstance() arg 2 must be a type or tuple of types"))

  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DE@JCLEIDJO@isinstance?$CI?$CJ?5arg?52?5must?5be?5a?5typ@
  00124	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cls$[rsp]
  00129	e8 00 00 00 00	 call	 check_class
  0012e	85 c0		 test	 eax, eax
  00130	75 07		 jne	 SHORT $LN5@recursive_

; 2493 :             return -1;

  00132	b8 ff ff ff ff	 mov	 eax, -1
  00137	eb 76		 jmp	 SHORT $LN14@recursive_
$LN5@recursive_:

; 2494 :         icls = _PyObject_GetAttrId(inst, &PyId___class__);

  00139	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___class__@?1??recursive_isinstance@@9@9
  0013e	8b c0		 mov	 eax, eax
  00140	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00146	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0014f	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00153	48 8b d0	 mov	 rdx, rax
  00156	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0015b	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00160	48 89 44 24 28	 mov	 QWORD PTR icls$[rsp], rax

; 2495 :         if (icls == NULL) {

  00165	48 83 7c 24 28
	00		 cmp	 QWORD PTR icls$[rsp], 0
  0016b	75 21		 jne	 SHORT $LN4@recursive_

; 2496 :             if (PyErr_ExceptionMatches(PyExc_AttributeError))

  0016d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  00174	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00179	85 c0		 test	 eax, eax
  0017b	74 07		 je	 SHORT $LN3@recursive_

; 2497 :                 PyErr_Clear();

  0017d	e8 00 00 00 00	 call	 PyErr_Clear

; 2498 :             else

  00182	eb 08		 jmp	 SHORT $LN2@recursive_
$LN3@recursive_:

; 2499 :                 retval = -1;

  00184	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR retval$[rsp], -1
$LN2@recursive_:

; 2500 :         }
; 2501 :         else {

  0018c	eb 1d		 jmp	 SHORT $LN1@recursive_
$LN4@recursive_:

; 2502 :             retval = abstract_issubclass(icls, cls);

  0018e	48 8b 54 24 58	 mov	 rdx, QWORD PTR cls$[rsp]
  00193	48 8b 4c 24 28	 mov	 rcx, QWORD PTR icls$[rsp]
  00198	e8 00 00 00 00	 call	 abstract_issubclass
  0019d	89 44 24 20	 mov	 DWORD PTR retval$[rsp], eax

; 2503 :             Py_DECREF(icls);

  001a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR icls$[rsp]
  001a6	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@recursive_:
$LN6@recursive_:

; 2504 :         }
; 2505 :     }
; 2506 : 
; 2507 :     return retval;

  001ab	8b 44 24 20	 mov	 eax, DWORD PTR retval$[rsp]
$LN14@recursive_:

; 2508 : }

  001af	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001b3	c3		 ret	 0
recursive_isinstance ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$abstract_issubclass DD imagerel abstract_issubclass
	DD	imagerel abstract_issubclass+292
	DD	imagerel $unwind$abstract_issubclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$abstract_issubclass DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT abstract_issubclass
_TEXT	SEGMENT
n$ = 32
i$ = 40
bases$ = 48
r$ = 56
derived$ = 80
cls$ = 88
abstract_issubclass PROC				; COMDAT

; 2414 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2415 :     PyObject *bases = NULL;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR bases$[rsp], 0

; 2416 :     Py_ssize_t i, n;
; 2417 :     int r = 0;

  00017	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR r$[rsp], 0
$LN11@abstract_i:

; 2418 : 
; 2419 :     while (1) {

  0001f	33 c0		 xor	 eax, eax
  00021	83 f8 01	 cmp	 eax, 1
  00024	0f 84 f5 00 00
	00		 je	 $LN10@abstract_i

; 2420 :         if (derived == cls)

  0002a	48 8b 44 24 58	 mov	 rax, QWORD PTR cls$[rsp]
  0002f	48 39 44 24 50	 cmp	 QWORD PTR derived$[rsp], rax
  00034	75 0a		 jne	 SHORT $LN9@abstract_i

; 2421 :             return 1;

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	e9 df 00 00 00	 jmp	 $LN12@abstract_i
$LN9@abstract_i:

; 2422 :         bases = abstract_get_bases(derived);

  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR derived$[rsp]
  00045	e8 00 00 00 00	 call	 abstract_get_bases
  0004a	48 89 44 24 30	 mov	 QWORD PTR bases$[rsp], rax

; 2423 :         if (bases == NULL) {

  0004f	48 83 7c 24 30
	00		 cmp	 QWORD PTR bases$[rsp], 0
  00055	75 1b		 jne	 SHORT $LN8@abstract_i

; 2424 :             if (PyErr_Occurred())

  00057	e8 00 00 00 00	 call	 PyErr_Occurred
  0005c	48 85 c0	 test	 rax, rax
  0005f	74 0a		 je	 SHORT $LN7@abstract_i

; 2425 :                 return -1;

  00061	b8 ff ff ff ff	 mov	 eax, -1
  00066	e9 b4 00 00 00	 jmp	 $LN12@abstract_i
$LN7@abstract_i:

; 2426 :             return 0;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 ad 00 00 00	 jmp	 $LN12@abstract_i
$LN8@abstract_i:

; 2427 :         }
; 2428 :         n = PyTuple_GET_SIZE(bases);

  00072	48 8b 44 24 30	 mov	 rax, QWORD PTR bases$[rsp]
  00077	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0007b	48 89 44 24 20	 mov	 QWORD PTR n$[rsp], rax

; 2429 :         if (n == 0) {

  00080	48 83 7c 24 20
	00		 cmp	 QWORD PTR n$[rsp], 0
  00086	75 11		 jne	 SHORT $LN6@abstract_i

; 2430 :             Py_DECREF(bases);

  00088	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bases$[rsp]
  0008d	e8 00 00 00 00	 call	 _Py_DecRef

; 2431 :             return 0;

  00092	33 c0		 xor	 eax, eax
  00094	e9 86 00 00 00	 jmp	 $LN12@abstract_i
$LN6@abstract_i:

; 2432 :         }
; 2433 :         /* Avoid recursivity in the single inheritance case */
; 2434 :         if (n == 1) {

  00099	48 83 7c 24 20
	01		 cmp	 QWORD PTR n$[rsp], 1
  0009f	75 1d		 jne	 SHORT $LN5@abstract_i

; 2435 :             derived = PyTuple_GET_ITEM(bases, 0);

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR bases$[rsp]
  000a6	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000aa	48 89 44 24 50	 mov	 QWORD PTR derived$[rsp], rax

; 2436 :             Py_DECREF(bases);

  000af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bases$[rsp]
  000b4	e8 00 00 00 00	 call	 _Py_DecRef

; 2437 :             continue;

  000b9	e9 61 ff ff ff	 jmp	 $LN11@abstract_i
$LN5@abstract_i:

; 2438 :         }
; 2439 :         for (i = 0; i < n; i++) {

  000be	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000c7	eb 0d		 jmp	 SHORT $LN4@abstract_i
$LN3@abstract_i:
  000c9	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000ce	48 ff c0	 inc	 rax
  000d1	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN4@abstract_i:
  000d6	48 8b 44 24 20	 mov	 rax, QWORD PTR n$[rsp]
  000db	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000e0	7d 28		 jge	 SHORT $LN2@abstract_i

; 2440 :             r = abstract_issubclass(PyTuple_GET_ITEM(bases, i), cls);

  000e2	48 8b 54 24 58	 mov	 rdx, QWORD PTR cls$[rsp]
  000e7	48 8b 44 24 30	 mov	 rax, QWORD PTR bases$[rsp]
  000ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000f1	48 8b 4c c8 70	 mov	 rcx, QWORD PTR [rax+rcx*8+112]
  000f6	e8 00 00 00 00	 call	 abstract_issubclass
  000fb	89 44 24 38	 mov	 DWORD PTR r$[rsp], eax

; 2441 :             if (r != 0)

  000ff	83 7c 24 38 00	 cmp	 DWORD PTR r$[rsp], 0
  00104	74 02		 je	 SHORT $LN1@abstract_i

; 2442 :                 break;

  00106	eb 02		 jmp	 SHORT $LN2@abstract_i
$LN1@abstract_i:

; 2443 :         }

  00108	eb bf		 jmp	 SHORT $LN3@abstract_i
$LN2@abstract_i:

; 2444 :         Py_DECREF(bases);

  0010a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bases$[rsp]
  0010f	e8 00 00 00 00	 call	 _Py_DecRef

; 2445 :         return r;

  00114	8b 44 24 38	 mov	 eax, DWORD PTR r$[rsp]
  00118	eb 05		 jmp	 SHORT $LN12@abstract_i

; 2446 :     }

  0011a	e9 00 ff ff ff	 jmp	 $LN11@abstract_i
$LN10@abstract_i:
$LN12@abstract_i:

; 2447 : }

  0011f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00123	c3		 ret	 0
abstract_issubclass ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$abstract_get_bases DD imagerel abstract_get_bases
	DD	imagerel abstract_get_bases+175
	DD	imagerel $unwind$abstract_get_bases
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$abstract_get_bases DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT abstract_get_bases
_TEXT	SEGMENT
bases$ = 32
_old$22248 = 40
cls$ = 64
abstract_get_bases PROC					; COMDAT

; 2392 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN6@abstract_g:

; 2393 :     _Py_IDENTIFIER(__bases__);
; 2394 :     PyObject *bases;
; 2395 : 
; 2396 :     Py_ALLOW_RECURSION

  00009	e8 00 00 00 00	 call	 PyThreadState_Get
  0000e	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  00012	88 44 24 28	 mov	 BYTE PTR _old$22248[rsp], al
  00016	e8 00 00 00 00	 call	 PyThreadState_Get
  0001b	c6 40 1d 01	 mov	 BYTE PTR [rax+29], 1

; 2397 :     bases = _PyObject_GetAttrId(cls, &PyId___bases__);

  0001f	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___bases__@?1??abstract_get_bases@@9@9
  00024	8b c0		 mov	 eax, eax
  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0002c	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00035	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00039	48 8b d0	 mov	 rdx, rax
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cls$[rsp]
  00041	e8 00 00 00 00	 call	 _PyObject_GetAttrId
  00046	48 89 44 24 20	 mov	 QWORD PTR bases$[rsp], rax

; 2398 :     Py_END_ALLOW_RECURSION

  0004b	e8 00 00 00 00	 call	 PyThreadState_Get
  00050	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR _old$22248[rsp]
  00055	88 48 1d	 mov	 BYTE PTR [rax+29], cl
  00058	33 c0		 xor	 eax, eax
  0005a	85 c0		 test	 eax, eax
  0005c	75 ab		 jne	 SHORT $LN6@abstract_g

; 2399 :     if (bases == NULL) {

  0005e	48 83 7c 24 20
	00		 cmp	 QWORD PTR bases$[rsp], 0
  00064	75 19		 jne	 SHORT $LN3@abstract_g

; 2400 :         if (PyErr_ExceptionMatches(PyExc_AttributeError))

  00066	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_AttributeError
  0006d	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00072	85 c0		 test	 eax, eax
  00074	74 05		 je	 SHORT $LN2@abstract_g

; 2401 :             PyErr_Clear();

  00076	e8 00 00 00 00	 call	 PyErr_Clear
$LN2@abstract_g:

; 2402 :         return NULL;

  0007b	33 c0		 xor	 eax, eax
  0007d	eb 2b		 jmp	 SHORT $LN7@abstract_g
$LN3@abstract_g:

; 2403 :     }
; 2404 :     if (!PyTuple_Check(bases)) {

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR bases$[rsp]
  00084	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00088	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0008e	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00093	85 c0		 test	 eax, eax
  00095	75 0e		 jne	 SHORT $LN1@abstract_g

; 2405 :         Py_DECREF(bases);

  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bases$[rsp]
  0009c	e8 00 00 00 00	 call	 _Py_DecRef

; 2406 :         return NULL;

  000a1	33 c0		 xor	 eax, eax
  000a3	eb 05		 jmp	 SHORT $LN7@abstract_g
$LN1@abstract_g:

; 2407 :     }
; 2408 :     return bases;

  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR bases$[rsp]
$LN7@abstract_g:

; 2409 : }

  000aa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ae	c3		 ret	 0
abstract_get_bases ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_class DD imagerel check_class
	DD	imagerel check_class+88
	DD	imagerel $unwind$check_class
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_class DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT check_class
_TEXT	SEGMENT
bases$ = 32
cls$ = 64
error$ = 72
check_class PROC					; COMDAT

; 2451 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2452 :     PyObject *bases = abstract_get_bases(cls);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cls$[rsp]
  00013	e8 00 00 00 00	 call	 abstract_get_bases
  00018	48 89 44 24 20	 mov	 QWORD PTR bases$[rsp], rax

; 2453 :     if (bases == NULL) {

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR bases$[rsp], 0
  00023	75 1f		 jne	 SHORT $LN2@check_clas

; 2454 :         /* Do not mask errors. */
; 2455 :         if (!PyErr_Occurred())

  00025	e8 00 00 00 00	 call	 PyErr_Occurred
  0002a	48 85 c0	 test	 rax, rax
  0002d	75 11		 jne	 SHORT $LN1@check_clas

; 2456 :             PyErr_SetString(PyExc_TypeError, error);

  0002f	48 8b 54 24 48	 mov	 rdx, QWORD PTR error$[rsp]
  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  0003b	e8 00 00 00 00	 call	 PyErr_SetString
$LN1@check_clas:

; 2457 :         return 0;

  00040	33 c0		 xor	 eax, eax
  00042	eb 0f		 jmp	 SHORT $LN3@check_clas
$LN2@check_clas:

; 2458 :     }
; 2459 :     Py_DECREF(bases);

  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bases$[rsp]
  00049	e8 00 00 00 00	 call	 _Py_DecRef

; 2460 :     return -1;

  0004e	b8 ff ff ff ff	 mov	 eax, -1
$LN3@check_clas:

; 2461 : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
check_class ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@FLCLONKH@?5in?5__subclasscheck__?$AA@	; `string'
PUBLIC	PyObject_IsSubclass
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_IsSubclass DD imagerel $LN26
	DD	imagerel $LN26+722
	DD	imagerel $unwind$PyObject_IsSubclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_IsSubclass DD 021101H
	DD	0130111H
xdata	ENDS
;	COMDAT ??_C@_0BG@FLCLONKH@?5in?5__subclasscheck__?$AA@
CONST	SEGMENT
??_C@_0BG@FLCLONKH@?5in?5__subclasscheck__?$AA@ DB ' in __subclasscheck__'
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_IsSubclass
_TEXT	SEGMENT
checker$ = 32
n$22411 = 40
i$22410 = 48
r$22412 = 56
item$22419 = 64
res$22428 = 72
ok$22429 = 80
tv70 = 88
tv94 = 96
tv88 = 104
tv143 = 112
tv162 = 120
tv156 = 128
derived$ = 160
cls$ = 168
PyObject_IsSubclass PROC				; COMDAT

; 2581 : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2582 :     _Py_IDENTIFIER(__subclasscheck__);
; 2583 :     PyObject *checker;
; 2584 : 
; 2585 :     if (PyTuple_Check(cls)) {

  00011	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cls$[rsp]
  00019	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0001d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00023	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 27 01 00
	00		 je	 $LN19@PyObject_I@2

; 2586 :         Py_ssize_t i;
; 2587 :         Py_ssize_t n;
; 2588 :         int r = 0;

  00030	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR r$22412[rsp], 0

; 2589 : 
; 2590 :         if (Py_EnterRecursiveCall(" in __subclasscheck__"))

  00038	e8 00 00 00 00	 call	 PyThreadState_Get
  0003d	48 83 c0 18	 add	 rax, 24
  00041	48 89 44 24 58	 mov	 QWORD PTR tv70[rsp], rax
  00046	48 8b 44 24 58	 mov	 rax, QWORD PTR tv70[rsp]
  0004b	8b 00		 mov	 eax, DWORD PTR [rax]
  0004d	ff c0		 inc	 eax
  0004f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv70[rsp]
  00054	89 01		 mov	 DWORD PTR [rcx], eax
  00056	48 8b 44 24 58	 mov	 rax, QWORD PTR tv70[rsp]
  0005b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Py_CheckRecursionLimit
  00061	39 08		 cmp	 DWORD PTR [rax], ecx
  00063	7e 1a		 jle	 SHORT $LN18@PyObject_I@2
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@FLCLONKH@?5in?5__subclasscheck__?$AA@
  0006c	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  00071	85 c0		 test	 eax, eax
  00073	74 0a		 je	 SHORT $LN18@PyObject_I@2

; 2591 :             return -1;

  00075	b8 ff ff ff ff	 mov	 eax, -1
  0007a	e9 4b 02 00 00	 jmp	 $LN20@PyObject_I@2
$LN18@PyObject_I@2:

; 2592 :         n = PyTuple_GET_SIZE(cls);

  0007f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cls$[rsp]
  00087	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008b	48 89 44 24 28	 mov	 QWORD PTR n$22411[rsp], rax

; 2593 :         for (i = 0; i < n; ++i) {

  00090	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR i$22410[rsp], 0
  00099	eb 0d		 jmp	 SHORT $LN17@PyObject_I@2
$LN16@PyObject_I@2:
  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR i$22410[rsp]
  000a0	48 ff c0	 inc	 rax
  000a3	48 89 44 24 30	 mov	 QWORD PTR i$22410[rsp], rax
$LN17@PyObject_I@2:
  000a8	48 8b 44 24 28	 mov	 rax, QWORD PTR n$22411[rsp]
  000ad	48 39 44 24 30	 cmp	 QWORD PTR i$22410[rsp], rax
  000b2	7d 38		 jge	 SHORT $LN15@PyObject_I@2

; 2594 :             PyObject *item = PyTuple_GET_ITEM(cls, i);

  000b4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cls$[rsp]
  000bc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i$22410[rsp]
  000c1	48 8b 44 c8 70	 mov	 rax, QWORD PTR [rax+rcx*8+112]
  000c6	48 89 44 24 40	 mov	 QWORD PTR item$22419[rsp], rax

; 2595 :             r = PyObject_IsSubclass(derived, item);

  000cb	48 8b 54 24 40	 mov	 rdx, QWORD PTR item$22419[rsp]
  000d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR derived$[rsp]
  000d8	e8 00 00 00 00	 call	 PyObject_IsSubclass
  000dd	89 44 24 38	 mov	 DWORD PTR r$22412[rsp], eax

; 2596 :             if (r != 0)

  000e1	83 7c 24 38 00	 cmp	 DWORD PTR r$22412[rsp], 0
  000e6	74 02		 je	 SHORT $LN14@PyObject_I@2

; 2597 :                 /* either found it, or got an error */
; 2598 :                 break;

  000e8	eb 02		 jmp	 SHORT $LN15@PyObject_I@2
$LN14@PyObject_I@2:

; 2599 :         }

  000ea	eb af		 jmp	 SHORT $LN16@PyObject_I@2
$LN15@PyObject_I@2:
$LN13@PyObject_I@2:

; 2600 :         Py_LeaveRecursiveCall();

  000ec	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _Py_CheckRecursionLimit, 100 ; 00000064H
  000f3	7e 0f		 jle	 SHORT $LN22@PyObject_I@2
  000f5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  000fb	83 e8 32	 sub	 eax, 50			; 00000032H
  000fe	89 44 24 60	 mov	 DWORD PTR tv94[rsp], eax
  00102	eb 10		 jmp	 SHORT $LN23@PyObject_I@2
$LN22@PyObject_I@2:
  00104	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  0010a	c1 f8 02	 sar	 eax, 2
  0010d	6b c0 03	 imul	 eax, 3
  00110	89 44 24 60	 mov	 DWORD PTR tv94[rsp], eax
$LN23@PyObject_I@2:
  00114	e8 00 00 00 00	 call	 PyThreadState_Get
  00119	48 83 c0 18	 add	 rax, 24
  0011d	48 89 44 24 68	 mov	 QWORD PTR tv88[rsp], rax
  00122	48 8b 44 24 68	 mov	 rax, QWORD PTR tv88[rsp]
  00127	8b 00		 mov	 eax, DWORD PTR [rax]
  00129	ff c8		 dec	 eax
  0012b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv88[rsp]
  00130	89 01		 mov	 DWORD PTR [rcx], eax
  00132	48 8b 44 24 68	 mov	 rax, QWORD PTR tv88[rsp]
  00137	8b 4c 24 60	 mov	 ecx, DWORD PTR tv94[rsp]
  0013b	39 08		 cmp	 DWORD PTR [rax], ecx
  0013d	7d 09		 jge	 SHORT $LN10@PyObject_I@2
  0013f	e8 00 00 00 00	 call	 PyThreadState_Get
  00144	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN10@PyObject_I@2:
  00148	33 c0		 xor	 eax, eax
  0014a	85 c0		 test	 eax, eax
  0014c	75 9e		 jne	 SHORT $LN13@PyObject_I@2

; 2601 :         return r;

  0014e	8b 44 24 38	 mov	 eax, DWORD PTR r$22412[rsp]
  00152	e9 73 01 00 00	 jmp	 $LN20@PyObject_I@2
$LN19@PyObject_I@2:

; 2602 :     }
; 2603 : 
; 2604 :     checker = _PyObject_LookupSpecial(cls, &PyId___subclasscheck__);

  00157	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?PyId___subclasscheck__@?1??PyObject_IsSubclass@@9@9
  0015c	8b c0		 mov	 eax, eax
  0015e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00164	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0016d	48 03 04 ca	 add	 rax, QWORD PTR [rdx+rcx*8]
  00171	48 8b d0	 mov	 rdx, rax
  00174	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR cls$[rsp]
  0017c	e8 00 00 00 00	 call	 _PyObject_LookupSpecial
  00181	48 89 44 24 20	 mov	 QWORD PTR checker$[rsp], rax

; 2605 :     if (checker != NULL) {

  00186	48 83 7c 24 20
	00		 cmp	 QWORD PTR checker$[rsp], 0
  0018c	0f 84 12 01 00
	00		 je	 $LN9@PyObject_I@2

; 2606 :         PyObject *res;
; 2607 :         int ok = -1;

  00192	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR ok$22429[rsp], -1

; 2608 :         if (Py_EnterRecursiveCall(" in __subclasscheck__")) {

  0019a	e8 00 00 00 00	 call	 PyThreadState_Get
  0019f	48 83 c0 18	 add	 rax, 24
  001a3	48 89 44 24 70	 mov	 QWORD PTR tv143[rsp], rax
  001a8	48 8b 44 24 70	 mov	 rax, QWORD PTR tv143[rsp]
  001ad	8b 00		 mov	 eax, DWORD PTR [rax]
  001af	ff c0		 inc	 eax
  001b1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv143[rsp]
  001b6	89 01		 mov	 DWORD PTR [rcx], eax
  001b8	48 8b 44 24 70	 mov	 rax, QWORD PTR tv143[rsp]
  001bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Py_CheckRecursionLimit
  001c3	39 08		 cmp	 DWORD PTR [rax], ecx
  001c5	7e 23		 jle	 SHORT $LN8@PyObject_I@2
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@FLCLONKH@?5in?5__subclasscheck__?$AA@
  001ce	e8 00 00 00 00	 call	 _Py_CheckRecursiveCall
  001d3	85 c0		 test	 eax, eax
  001d5	74 13		 je	 SHORT $LN8@PyObject_I@2

; 2609 :             Py_DECREF(checker);

  001d7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR checker$[rsp]
  001dc	e8 00 00 00 00	 call	 _Py_DecRef

; 2610 :             return ok;

  001e1	8b 44 24 50	 mov	 eax, DWORD PTR ok$22429[rsp]
  001e5	e9 e0 00 00 00	 jmp	 $LN20@PyObject_I@2
$LN8@PyObject_I@2:

; 2611 :         }
; 2612 :         res = PyObject_CallFunctionObjArgs(checker, derived, NULL);

  001ea	45 33 c0	 xor	 r8d, r8d
  001ed	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR derived$[rsp]
  001f5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR checker$[rsp]
  001fa	e8 00 00 00 00	 call	 PyObject_CallFunctionObjArgs
  001ff	48 89 44 24 48	 mov	 QWORD PTR res$22428[rsp], rax
$LN7@PyObject_I@2:

; 2613 :         Py_LeaveRecursiveCall();

  00204	83 3d 00 00 00
	00 64		 cmp	 DWORD PTR _Py_CheckRecursionLimit, 100 ; 00000064H
  0020b	7e 0f		 jle	 SHORT $LN24@PyObject_I@2
  0020d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00213	83 e8 32	 sub	 eax, 50			; 00000032H
  00216	89 44 24 78	 mov	 DWORD PTR tv162[rsp], eax
  0021a	eb 10		 jmp	 SHORT $LN25@PyObject_I@2
$LN24@PyObject_I@2:
  0021c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR _Py_CheckRecursionLimit
  00222	c1 f8 02	 sar	 eax, 2
  00225	6b c0 03	 imul	 eax, 3
  00228	89 44 24 78	 mov	 DWORD PTR tv162[rsp], eax
$LN25@PyObject_I@2:
  0022c	e8 00 00 00 00	 call	 PyThreadState_Get
  00231	48 83 c0 18	 add	 rax, 24
  00235	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv156[rsp], rax
  0023d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv156[rsp]
  00245	8b 00		 mov	 eax, DWORD PTR [rax]
  00247	ff c8		 dec	 eax
  00249	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv156[rsp]
  00251	89 01		 mov	 DWORD PTR [rcx], eax
  00253	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv156[rsp]
  0025b	8b 4c 24 78	 mov	 ecx, DWORD PTR tv162[rsp]
  0025f	39 08		 cmp	 DWORD PTR [rax], ecx
  00261	7d 09		 jge	 SHORT $LN4@PyObject_I@2
  00263	e8 00 00 00 00	 call	 PyThreadState_Get
  00268	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0
$LN4@PyObject_I@2:
  0026c	33 c0		 xor	 eax, eax
  0026e	85 c0		 test	 eax, eax
  00270	75 92		 jne	 SHORT $LN7@PyObject_I@2

; 2614 :         Py_DECREF(checker);

  00272	48 8b 4c 24 20	 mov	 rcx, QWORD PTR checker$[rsp]
  00277	e8 00 00 00 00	 call	 _Py_DecRef

; 2615 :         if (res != NULL) {

  0027c	48 83 7c 24 48
	00		 cmp	 QWORD PTR res$22428[rsp], 0
  00282	74 18		 je	 SHORT $LN3@PyObject_I@2

; 2616 :             ok = PyObject_IsTrue(res);

  00284	48 8b 4c 24 48	 mov	 rcx, QWORD PTR res$22428[rsp]
  00289	e8 00 00 00 00	 call	 PyObject_IsTrue
  0028e	89 44 24 50	 mov	 DWORD PTR ok$22429[rsp], eax

; 2617 :             Py_DECREF(res);

  00292	48 8b 4c 24 48	 mov	 rcx, QWORD PTR res$22428[rsp]
  00297	e8 00 00 00 00	 call	 _Py_DecRef
$LN3@PyObject_I@2:

; 2618 :         }
; 2619 :         return ok;

  0029c	8b 44 24 50	 mov	 eax, DWORD PTR ok$22429[rsp]
  002a0	eb 28		 jmp	 SHORT $LN20@PyObject_I@2
  002a2	eb 11		 jmp	 SHORT $LN2@PyObject_I@2
$LN9@PyObject_I@2:

; 2620 :     }
; 2621 :     else if (PyErr_Occurred())

  002a4	e8 00 00 00 00	 call	 PyErr_Occurred
  002a9	48 85 c0	 test	 rax, rax
  002ac	74 07		 je	 SHORT $LN1@PyObject_I@2

; 2622 :         return -1;

  002ae	b8 ff ff ff ff	 mov	 eax, -1
  002b3	eb 15		 jmp	 SHORT $LN20@PyObject_I@2
$LN1@PyObject_I@2:
$LN2@PyObject_I@2:

; 2623 :     return recursive_issubclass(derived, cls);

  002b5	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR cls$[rsp]
  002bd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR derived$[rsp]
  002c5	e8 00 00 00 00	 call	 recursive_issubclass
$LN20@PyObject_I@2:

; 2624 : }

  002ca	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002d1	c3		 ret	 0
PyObject_IsSubclass ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DH@MDGECDNF@issubclass?$CI?$CJ?5arg?52?5must?5be?5a?5cla@ ; `string'
PUBLIC	??_C@_0CD@NDJAFIBK@issubclass?$CI?$CJ?5arg?51?5must?5be?5a?5cla@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$recursive_issubclass DD imagerel recursive_issubclass
	DD	imagerel recursive_issubclass+155
	DD	imagerel $unwind$recursive_issubclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$recursive_issubclass DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_0DH@MDGECDNF@issubclass?$CI?$CJ?5arg?52?5must?5be?5a?5cla@
CONST	SEGMENT
??_C@_0DH@MDGECDNF@issubclass?$CI?$CJ?5arg?52?5must?5be?5a?5cla@ DB 'issu'
	DB	'bclass() arg 2 must be a class or tuple of classes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NDJAFIBK@issubclass?$CI?$CJ?5arg?51?5must?5be?5a?5cla@
CONST	SEGMENT
??_C@_0CD@NDJAFIBK@issubclass?$CI?$CJ?5arg?51?5must?5be?5a?5cla@ DB 'issu'
	DB	'bclass() arg 1 must be a class', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT recursive_issubclass
_TEXT	SEGMENT
derived$ = 48
cls$ = 56
recursive_issubclass PROC				; COMDAT

; 2563 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2564 :     if (PyType_Check(cls) && PyType_Check(derived)) {

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR cls$[rsp]
  00013	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00017	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001d	25 00 00 00 80	 and	 eax, -2147483648	; ffffffff80000000H
  00022	85 c0		 test	 eax, eax
  00024	74 29		 je	 SHORT $LN3@recursive_@2
  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR derived$[rsp]
  0002b	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00035	25 00 00 00 80	 and	 eax, -2147483648	; ffffffff80000000H
  0003a	85 c0		 test	 eax, eax
  0003c	74 11		 je	 SHORT $LN3@recursive_@2

; 2565 :         /* Fast path (non-recursive) */
; 2566 :         return PyType_IsSubtype((PyTypeObject *)derived, (PyTypeObject *)cls);

  0003e	48 8b 54 24 38	 mov	 rdx, QWORD PTR cls$[rsp]
  00043	48 8b 4c 24 30	 mov	 rcx, QWORD PTR derived$[rsp]
  00048	e8 00 00 00 00	 call	 PyType_IsSubtype
  0004d	eb 47		 jmp	 SHORT $LN4@recursive_@2
$LN3@recursive_@2:

; 2567 :     }
; 2568 :     if (!check_class(derived,
; 2569 :                      "issubclass() arg 1 must be a class"))

  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@NDJAFIBK@issubclass?$CI?$CJ?5arg?51?5must?5be?5a?5cla@
  00056	48 8b 4c 24 30	 mov	 rcx, QWORD PTR derived$[rsp]
  0005b	e8 00 00 00 00	 call	 check_class
  00060	85 c0		 test	 eax, eax
  00062	75 07		 jne	 SHORT $LN2@recursive_@2

; 2570 :         return -1;

  00064	b8 ff ff ff ff	 mov	 eax, -1
  00069	eb 2b		 jmp	 SHORT $LN4@recursive_@2
$LN2@recursive_@2:

; 2571 :     if (!check_class(cls,
; 2572 :                     "issubclass() arg 2 must be a class"
; 2573 :                     " or tuple of classes"))

  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@MDGECDNF@issubclass?$CI?$CJ?5arg?52?5must?5be?5a?5cla@
  00072	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cls$[rsp]
  00077	e8 00 00 00 00	 call	 check_class
  0007c	85 c0		 test	 eax, eax
  0007e	75 07		 jne	 SHORT $LN1@recursive_@2

; 2574 :         return -1;

  00080	b8 ff ff ff ff	 mov	 eax, -1
  00085	eb 0f		 jmp	 SHORT $LN4@recursive_@2
$LN1@recursive_@2:

; 2575 : 
; 2576 :     return abstract_issubclass(derived, cls);

  00087	48 8b 54 24 38	 mov	 rdx, QWORD PTR cls$[rsp]
  0008c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR derived$[rsp]
  00091	e8 00 00 00 00	 call	 abstract_issubclass
$LN4@recursive_@2:

; 2577 : }

  00096	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009a	c3		 ret	 0
recursive_issubclass ENDP
_TEXT	ENDS
PUBLIC	_PyObject_RealIsInstance
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_RealIsInstance DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$_PyObject_RealIsInstance
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_RealIsInstance DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_RealIsInstance
_TEXT	SEGMENT
inst$ = 48
cls$ = 56
_PyObject_RealIsInstance PROC				; COMDAT

; 2628 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2629 :     return recursive_isinstance(inst, cls);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR cls$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inst$[rsp]
  00018	e8 00 00 00 00	 call	 recursive_isinstance

; 2630 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
_PyObject_RealIsInstance ENDP
_TEXT	ENDS
PUBLIC	_PyObject_RealIsSubclass
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PyObject_RealIsSubclass DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$_PyObject_RealIsSubclass
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PyObject_RealIsSubclass DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _PyObject_RealIsSubclass
_TEXT	SEGMENT
derived$ = 48
cls$ = 56
_PyObject_RealIsSubclass PROC				; COMDAT

; 2634 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2635 :     return recursive_issubclass(derived, cls);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR cls$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR derived$[rsp]
  00018	e8 00 00 00 00	 call	 recursive_issubclass

; 2636 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
_PyObject_RealIsSubclass ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CO@KBCBOPMB@iter?$CI?$CJ?5returned?5non?9iterator?5of?5@ ; `string'
PUBLIC	??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@ ; `string'
EXTRN	_PyObject_NextNotImplemented:PROC
EXTRN	PySeqIter_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyObject_GetIter DD imagerel $LN8
	DD	imagerel $LN8+234
	DD	imagerel $unwind$PyObject_GetIter
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyObject_GetIter DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0CO@KBCBOPMB@iter?$CI?$CJ?5returned?5non?9iterator?5of?5@
CONST	SEGMENT
??_C@_0CO@KBCBOPMB@iter?$CI?$CJ?5returned?5non?9iterator?5of?5@ DB 'iter('
	DB	') returned non-iterator of type ''%.100s''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@
CONST	SEGMENT
??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@ DB '''%'
	DB	'.200s'' object is not iterable', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyObject_GetIter
_TEXT	SEGMENT
f$ = 32
t$ = 40
res$22464 = 48
o$ = 80
PyObject_GetIter PROC					; COMDAT

; 2641 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2642 :     PyTypeObject *t = o->ob_type;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR o$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax

; 2643 :     getiterfunc f = NULL;

  00017	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR f$[rsp], 0

; 2644 : 
; 2645 :     f = t->tp_iter;

  00020	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00025	48 8b 80 30 01
	00 00		 mov	 rax, QWORD PTR [rax+304]
  0002c	48 89 44 24 20	 mov	 QWORD PTR f$[rsp], rax

; 2646 :     if (f == NULL) {

  00031	48 83 7c 24 20
	00		 cmp	 QWORD PTR f$[rsp], 0
  00037	75 32		 jne	 SHORT $LN5@PyObject_G@3

; 2647 :         if (PySequence_Check(o))

  00039	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  0003e	e8 00 00 00 00	 call	 PySequence_Check
  00043	85 c0		 test	 eax, eax
  00045	74 0f		 je	 SHORT $LN4@PyObject_G@3

; 2648 :             return PySeqIter_New(o);

  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  0004c	e8 00 00 00 00	 call	 PySeqIter_New
  00051	e9 8f 00 00 00	 jmp	 $LN6@PyObject_G@3
$LN4@PyObject_G@3:

; 2649 :         return type_error("'%.200s' object is not iterable", o);

  00056	48 8b 54 24 50	 mov	 rdx, QWORD PTR o$[rsp]
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@OJDKODEI@?8?$CF?4200s?8?5object?5is?5not?5iterable?$AA@
  00062	e8 00 00 00 00	 call	 type_error
  00067	eb 7c		 jmp	 SHORT $LN6@PyObject_G@3

; 2650 :     }
; 2651 :     else {

  00069	eb 7a		 jmp	 SHORT $LN3@PyObject_G@3
$LN5@PyObject_G@3:

; 2652 :         PyObject *res = (*f)(o);

  0006b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR o$[rsp]
  00070	ff 54 24 20	 call	 QWORD PTR f$[rsp]
  00074	48 89 44 24 30	 mov	 QWORD PTR res$22464[rsp], rax

; 2653 :         if (res != NULL && !PyIter_Check(res)) {

  00079	48 83 7c 24 30
	00		 cmp	 QWORD PTR res$22464[rsp], 0
  0007f	74 5f		 je	 SHORT $LN2@PyObject_G@3
  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR res$22464[rsp]
  00086	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0008a	48 83 b8 38 01
	00 00 00	 cmp	 QWORD PTR [rax+312], 0
  00092	74 19		 je	 SHORT $LN1@PyObject_G@3
  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR res$22464[rsp]
  00099	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_PyObject_NextNotImplemented
  000a4	48 39 88 38 01
	00 00		 cmp	 QWORD PTR [rax+312], rcx
  000ab	75 33		 jne	 SHORT $LN2@PyObject_G@3
$LN1@PyObject_G@3:

; 2654 :             PyErr_Format(PyExc_TypeError,
; 2655 :                          "iter() returned non-iterator "
; 2656 :                          "of type '%.100s'",
; 2657 :                          res->ob_type->tp_name);

  000ad	48 8b 44 24 30	 mov	 rax, QWORD PTR res$22464[rsp]
  000b2	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  000b6	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@KBCBOPMB@iter?$CI?$CJ?5returned?5non?9iterator?5of?5@
  000c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_TypeError
  000c8	e8 00 00 00 00	 call	 PyErr_Format

; 2658 :             Py_DECREF(res);

  000cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR res$22464[rsp]
  000d2	e8 00 00 00 00	 call	 _Py_DecRef

; 2659 :             res = NULL;

  000d7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR res$22464[rsp], 0
$LN2@PyObject_G@3:

; 2660 :         }
; 2661 :         return res;

  000e0	48 8b 44 24 30	 mov	 rax, QWORD PTR res$22464[rsp]
$LN3@PyObject_G@3:
$LN6@PyObject_G@3:

; 2662 :     }
; 2663 : }

  000e5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e9	c3		 ret	 0
PyObject_GetIter ENDP
_TEXT	ENDS
EXTRN	PyExc_StopIteration:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyIter_Next DD imagerel $LN4
	DD	imagerel $LN4+83
	DD	imagerel $unwind$PyIter_Next
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyIter_Next DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyIter_Next
_TEXT	SEGMENT
result$ = 32
iter$ = 64
PyIter_Next PROC					; COMDAT

; 2674 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2675 :     PyObject *result;
; 2676 : 
; 2677 :     result = (*iter->ob_type->tp_iternext)(iter);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR iter$[rsp]
  0000e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR iter$[rsp]
  00017	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]
  0001d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 2678 :     if (result == NULL &&
; 2679 :         PyErr_Occurred() &&
; 2680 :         PyErr_ExceptionMatches(PyExc_StopIteration))

  00022	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  00028	75 1f		 jne	 SHORT $LN1@PyIter_Nex
  0002a	e8 00 00 00 00	 call	 PyErr_Occurred
  0002f	48 85 c0	 test	 rax, rax
  00032	74 15		 je	 SHORT $LN1@PyIter_Nex
  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_StopIteration
  0003b	e8 00 00 00 00	 call	 PyErr_ExceptionMatches
  00040	85 c0		 test	 eax, eax
  00042	74 05		 je	 SHORT $LN1@PyIter_Nex

; 2681 :         PyErr_Clear();

  00044	e8 00 00 00 00	 call	 PyErr_Clear
$LN1@PyIter_Nex:

; 2682 :     return result;

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 2683 : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
PyIter_Next ENDP
_TEXT	ENDS
PUBLIC	_Py_FreeCharPArray
PUBLIC	??_C@_1BE@MFLFFNKK@?$AAa?$AAr?$AAg?$AAc?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	_PySequence_BytesToCharpArray
EXTRN	__imp_strdup:PROC
EXTRN	PyBytes_AsString:PROC
EXTRN	__imp_malloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_PySequence_BytesToCharpArray DD imagerel $LN17
	DD	imagerel $LN17+424
	DD	imagerel $unwind$_PySequence_BytesToCharpArray
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_PySequence_BytesToCharpArray DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT ??_C@_1BE@MFLFFNKK@?$AAa?$AAr?$AAg?$AAc?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BE@MFLFFNKK@?$AAa?$AAr?$AAg?$AAc?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'a'
	DB	00H, 'r', 00H, 'g', 00H, 'c', 00H, ' ', 00H, '>', 00H, '=', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _PySequence_BytesToCharpArray
_TEXT	SEGMENT
argc$ = 32
i$ = 40
item$ = 48
array$ = 56
data$22504 = 64
self$ = 96
_PySequence_BytesToCharpArray PROC			; COMDAT

; 2696 : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2697 :     char **array;
; 2698 :     Py_ssize_t i, argc;
; 2699 :     PyObject *item = NULL;

  00009	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR item$[rsp], 0

; 2700 : 
; 2701 :     argc = PySequence_Size(self);

  00012	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  00017	e8 00 00 00 00	 call	 PySequence_Size
  0001c	48 89 44 24 20	 mov	 QWORD PTR argc$[rsp], rax

; 2702 :     if (argc == -1)

  00021	48 83 7c 24 20
	ff		 cmp	 QWORD PTR argc$[rsp], -1
  00027	75 07		 jne	 SHORT $LN13@PySequence@18

; 2703 :         return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	e9 73 01 00 00	 jmp	 $LN14@PySequence@18
$LN13@PySequence@18:

; 2704 : 
; 2705 :     assert(argc >= 0);

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR argc$[rsp], 0
  00036	7d 1c		 jge	 SHORT $LN16@PySequence@18
  00038	41 b8 91 0a 00
	00		 mov	 r8d, 2705		; 00000a91H
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CM@GCNEELOK@?$AA?4?$AA?4?$AA?2?$AAO?$AAb?$AAj?$AAe?$AAc?$AAt?$AAs?$AA?2?$AAa?$AAb?$AAs?$AAt?$AAr?$AAa?$AAc?$AAt?$AA?4?$AAc?$AA?$AA@
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BE@MFLFFNKK@?$AAa?$AAr?$AAg?$AAc?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  00052	33 c0		 xor	 eax, eax
$LN16@PySequence@18:

; 2706 : 
; 2707 :     if ((size_t)argc > (PY_SSIZE_T_MAX-sizeof(char *)) / sizeof(char *)) {

  00054	48 b8 fe ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846974 ; 0ffffffffffffffeH
  0005e	48 39 44 24 20	 cmp	 QWORD PTR argc$[rsp], rax
  00063	76 0c		 jbe	 SHORT $LN12@PySequence@18

; 2708 :         PyErr_NoMemory();

  00065	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2709 :         return NULL;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 32 01 00 00	 jmp	 $LN14@PySequence@18
$LN12@PySequence@18:

; 2710 :     }
; 2711 : 
; 2712 :     array = malloc((argc + 1) * sizeof(char *));

  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR argc$[rsp]
  00076	48 8d 04 c5 08
	00 00 00	 lea	 rax, QWORD PTR [rax*8+8]
  0007e	48 8b c8	 mov	 rcx, rax
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00087	48 89 44 24 38	 mov	 QWORD PTR array$[rsp], rax

; 2713 :     if (array == NULL) {

  0008c	48 83 7c 24 38
	00		 cmp	 QWORD PTR array$[rsp], 0
  00092	75 0c		 jne	 SHORT $LN11@PySequence@18

; 2714 :         PyErr_NoMemory();

  00094	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2715 :         return NULL;

  00099	33 c0		 xor	 eax, eax
  0009b	e9 03 01 00 00	 jmp	 $LN14@PySequence@18
$LN11@PySequence@18:

; 2716 :     }
; 2717 :     for (i = 0; i < argc; ++i) {

  000a0	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000a9	eb 0d		 jmp	 SHORT $LN10@PySequence@18
$LN9@PySequence@18:
  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  000b0	48 ff c0	 inc	 rax
  000b3	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN10@PySequence@18:
  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR argc$[rsp]
  000bd	48 39 44 24 28	 cmp	 QWORD PTR i$[rsp], rax
  000c2	0f 8d 9e 00 00
	00		 jge	 $LN8@PySequence@18

; 2718 :         char *data;
; 2719 :         item = PySequence_GetItem(self, i);

  000c8	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  000cd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR self$[rsp]
  000d2	e8 00 00 00 00	 call	 PySequence_GetItem
  000d7	48 89 44 24 30	 mov	 QWORD PTR item$[rsp], rax

; 2720 :         if (item == NULL) {

  000dc	48 83 7c 24 30
	00		 cmp	 QWORD PTR item$[rsp], 0
  000e2	75 17		 jne	 SHORT $LN7@PySequence@18

; 2721 :             /* NULL terminate before freeing. */
; 2722 :             array[i] = NULL;

  000e4	48 8b 44 24 38	 mov	 rax, QWORD PTR array$[rsp]
  000e9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  000ee	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0

; 2723 :             goto fail;

  000f6	e9 84 00 00 00	 jmp	 $fail$22508
$LN7@PySequence@18:

; 2724 :         }
; 2725 :         data = PyBytes_AsString(item);

  000fb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$[rsp]
  00100	e8 00 00 00 00	 call	 PyBytes_AsString
  00105	48 89 44 24 40	 mov	 QWORD PTR data$22504[rsp], rax

; 2726 :         if (data == NULL) {

  0010a	48 83 7c 24 40
	00		 cmp	 QWORD PTR data$22504[rsp], 0
  00110	75 14		 jne	 SHORT $LN6@PySequence@18

; 2727 :             /* NULL terminate before freeing. */
; 2728 :             array[i] = NULL;

  00112	48 8b 44 24 38	 mov	 rax, QWORD PTR array$[rsp]
  00117	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  0011c	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0

; 2729 :             goto fail;

  00124	eb 59		 jmp	 SHORT $fail$22508
$LN6@PySequence@18:

; 2730 :         }
; 2731 :         array[i] = strdup(data);

  00126	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$22504[rsp]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00131	48 8b 4c 24 38	 mov	 rcx, QWORD PTR array$[rsp]
  00136	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  0013b	48 89 04 d1	 mov	 QWORD PTR [rcx+rdx*8], rax

; 2732 :         if (!array[i]) {

  0013f	48 8b 44 24 38	 mov	 rax, QWORD PTR array$[rsp]
  00144	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00149	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  0014e	75 07		 jne	 SHORT $LN5@PySequence@18

; 2733 :             PyErr_NoMemory();

  00150	e8 00 00 00 00	 call	 PyErr_NoMemory

; 2734 :             goto fail;

  00155	eb 28		 jmp	 SHORT $fail$22508
$LN5@PySequence@18:

; 2735 :         }
; 2736 :         Py_DECREF(item);

  00157	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$[rsp]
  0015c	e8 00 00 00 00	 call	 _Py_DecRef

; 2737 :     }

  00161	e9 45 ff ff ff	 jmp	 $LN9@PySequence@18
$LN8@PySequence@18:

; 2738 :     array[argc] = NULL;

  00166	48 8b 44 24 38	 mov	 rax, QWORD PTR array$[rsp]
  0016b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR argc$[rsp]
  00170	48 c7 04 c8 00
	00 00 00	 mov	 QWORD PTR [rax+rcx*8], 0

; 2739 : 
; 2740 :     return array;

  00178	48 8b 44 24 38	 mov	 rax, QWORD PTR array$[rsp]
  0017d	eb 24		 jmp	 SHORT $LN14@PySequence@18
$fail$22508:
$LN4@PySequence@18:

; 2741 : 
; 2742 : fail:
; 2743 :     Py_XDECREF(item);

  0017f	48 83 7c 24 30
	00		 cmp	 QWORD PTR item$[rsp], 0
  00185	74 0a		 je	 SHORT $LN1@PySequence@18
  00187	48 8b 4c 24 30	 mov	 rcx, QWORD PTR item$[rsp]
  0018c	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@PySequence@18:
  00191	33 c0		 xor	 eax, eax
  00193	85 c0		 test	 eax, eax
  00195	75 e8		 jne	 SHORT $LN4@PySequence@18

; 2744 :     _Py_FreeCharPArray(array);

  00197	48 8b 4c 24 38	 mov	 rcx, QWORD PTR array$[rsp]
  0019c	e8 00 00 00 00	 call	 _Py_FreeCharPArray

; 2745 :     return NULL;

  001a1	33 c0		 xor	 eax, eax
$LN14@PySequence@18:

; 2746 : }

  001a3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001a7	c3		 ret	 0
_PySequence_BytesToCharpArray ENDP
_TEXT	ENDS
EXTRN	__imp_free:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$_Py_FreeCharPArray DD imagerel $LN6
	DD	imagerel $LN6+88
	DD	imagerel $unwind$_Py_FreeCharPArray
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_FreeCharPArray DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT _Py_FreeCharPArray
_TEXT	SEGMENT
i$ = 32
array$ = 64
_Py_FreeCharPArray PROC					; COMDAT

; 2752 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2753 :     Py_ssize_t i;
; 2754 :     for (i = 0; array[i] != NULL; ++i) {

  00009	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00012	eb 0d		 jmp	 SHORT $LN3@Py_FreeCha
$LN2@Py_FreeCha:
  00014	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00019	48 ff c0	 inc	 rax
  0001c	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN3@Py_FreeCha:
  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR array$[rsp]
  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0002b	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00030	74 16		 je	 SHORT $LN1@Py_FreeCha

; 2755 :         free(array[i]);

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR array$[rsp]
  00037	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  0003c	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2756 :     }

  00046	eb cc		 jmp	 SHORT $LN2@Py_FreeCha
$LN1@Py_FreeCha:

; 2757 :     free((void*)array);

  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR array$[rsp]
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2758 : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
_Py_FreeCharPArray ENDP
_TEXT	ENDS
END
