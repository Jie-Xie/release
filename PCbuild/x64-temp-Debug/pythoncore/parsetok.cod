; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	PyParser_ParseStringFlagsFilename
PUBLIC	PyParser_ParseString
;	COMDAT pdata
; File c:\src\pyparallel\parser\parsetok.c
pdata	SEGMENT
$pdata$PyParser_ParseString DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$PyParser_ParseString
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseString DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyParser_ParseString
_TEXT	SEGMENT
s$ = 64
g$ = 72
start$ = 80
err_ret$ = 88
PyParser_ParseString PROC				; COMDAT

; 21   : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 22   :     return PyParser_ParseStringFlagsFilename(s, NULL, g, start, err_ret, 0);

  00018	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00020	48 8b 44 24 58	 mov	 rax, QWORD PTR err_ret$[rsp]
  00025	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002a	44 8b 4c 24 50	 mov	 r9d, DWORD PTR start$[rsp]
  0002f	4c 8b 44 24 48	 mov	 r8, QWORD PTR g$[rsp]
  00034	33 d2		 xor	 edx, edx
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	e8 00 00 00 00	 call	 PyParser_ParseStringFlagsFilename

; 23   : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	c3		 ret	 0
PyParser_ParseString ENDP
_TEXT	ENDS
PUBLIC	PyParser_ParseStringFlags
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_ParseStringFlags DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$PyParser_ParseStringFlags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseStringFlags DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyParser_ParseStringFlags
_TEXT	SEGMENT
s$ = 64
g$ = 72
start$ = 80
err_ret$ = 88
flags$ = 96
PyParser_ParseStringFlags PROC				; COMDAT

; 28   : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 29   :     return PyParser_ParseStringFlagsFilename(s, NULL,
; 30   :                                              g, start, err_ret, flags);

  00018	8b 44 24 60	 mov	 eax, DWORD PTR flags$[rsp]
  0001c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00020	48 8b 44 24 58	 mov	 rax, QWORD PTR err_ret$[rsp]
  00025	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002a	44 8b 4c 24 50	 mov	 r9d, DWORD PTR start$[rsp]
  0002f	4c 8b 44 24 48	 mov	 r8, QWORD PTR g$[rsp]
  00034	33 d2		 xor	 edx, edx
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	e8 00 00 00 00	 call	 PyParser_ParseStringFlagsFilename

; 31   : }

  00040	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00044	c3		 ret	 0
PyParser_ParseStringFlags ENDP
_TEXT	ENDS
PUBLIC	PyParser_ParseStringFlagsFilenameEx
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_ParseStringFlagsFilename DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$PyParser_ParseStringFlagsFilename
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseStringFlagsFilename DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyParser_ParseStringFlagsFilename
_TEXT	SEGMENT
iflags$ = 48
s$ = 80
filename$ = 88
g$ = 96
start$ = 104
err_ret$ = 112
flags$ = 120
PyParser_ParseStringFlagsFilename PROC			; COMDAT

; 37   : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 38   :     int iflags = flags;

  00018	8b 44 24 78	 mov	 eax, DWORD PTR flags$[rsp]
  0001c	89 44 24 30	 mov	 DWORD PTR iflags$[rsp], eax

; 39   :     return PyParser_ParseStringFlagsFilenameEx(s, filename, g, start,
; 40   :                                                err_ret, &iflags);

  00020	48 8d 44 24 30	 lea	 rax, QWORD PTR iflags$[rsp]
  00025	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002a	48 8b 44 24 70	 mov	 rax, QWORD PTR err_ret$[rsp]
  0002f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00034	44 8b 4c 24 68	 mov	 r9d, DWORD PTR start$[rsp]
  00039	4c 8b 44 24 60	 mov	 r8, QWORD PTR g$[rsp]
  0003e	48 8b 54 24 58	 mov	 rdx, QWORD PTR filename$[rsp]
  00043	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00048	e8 00 00 00 00	 call	 PyParser_ParseStringFlagsFilenameEx

; 41   : }

  0004d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00051	c3		 ret	 0
PyParser_ParseStringFlagsFilename ENDP
_TEXT	ENDS
PUBLIC	_Py_IncRef
EXTRN	PyErr_Occurred:PROC
EXTRN	PyTokenizer_FromString:PROC
EXTRN	PyTokenizer_FromUTF8:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_ParseStringFlagsFilenameEx DD imagerel $LN11
	DD	imagerel $LN11+287
	DD	imagerel $unwind$PyParser_ParseStringFlagsFilenameEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseStringFlagsFilenameEx DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyParser_ParseStringFlagsFilenameEx
_TEXT	SEGMENT
tok$ = 48
exec_input$ = 56
tv65 = 60
tv81 = 64
s$ = 96
filename$ = 104
g$ = 112
start$ = 120
err_ret$ = 128
flags$ = 136
PyParser_ParseStringFlagsFilenameEx PROC		; COMDAT

; 47   : {

$LN11:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 48   :     struct tok_state *tok;
; 49   :     int exec_input = start == file_input;

  00018	81 7c 24 78 01
	01 00 00	 cmp	 DWORD PTR start$[rsp], 257 ; 00000101H
  00020	75 0a		 jne	 SHORT $LN7@PyParser_P
  00022	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0002a	eb 08		 jmp	 SHORT $LN8@PyParser_P
$LN7@PyParser_P:
  0002c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN8@PyParser_P:
  00034	8b 44 24 3c	 mov	 eax, DWORD PTR tv65[rsp]
  00038	89 44 24 38	 mov	 DWORD PTR exec_input$[rsp], eax

; 50   : 
; 51   :     if (initerr(err_ret, filename) < 0)

  0003c	48 8b 54 24 68	 mov	 rdx, QWORD PTR filename$[rsp]
  00041	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR err_ret$[rsp]
  00049	e8 00 00 00 00	 call	 initerr
  0004e	85 c0		 test	 eax, eax
  00050	7d 07		 jge	 SHORT $LN4@PyParser_P

; 52   :         return NULL;

  00052	33 c0		 xor	 eax, eax
  00054	e9 c1 00 00 00	 jmp	 $LN5@PyParser_P
$LN4@PyParser_P:

; 53   : 
; 54   :     if (*flags & PyPARSE_IGNORE_COOKIE)

  00059	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR flags$[rsp]
  00061	8b 00		 mov	 eax, DWORD PTR [rax]
  00063	83 e0 10	 and	 eax, 16
  00066	85 c0		 test	 eax, eax
  00068	74 15		 je	 SHORT $LN3@PyParser_P

; 55   :         tok = PyTokenizer_FromUTF8(s, exec_input);

  0006a	8b 54 24 38	 mov	 edx, DWORD PTR exec_input$[rsp]
  0006e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00073	e8 00 00 00 00	 call	 PyTokenizer_FromUTF8
  00078	48 89 44 24 30	 mov	 QWORD PTR tok$[rsp], rax

; 56   :     else

  0007d	eb 13		 jmp	 SHORT $LN2@PyParser_P
$LN3@PyParser_P:

; 57   :         tok = PyTokenizer_FromString(s, exec_input);

  0007f	8b 54 24 38	 mov	 edx, DWORD PTR exec_input$[rsp]
  00083	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00088	e8 00 00 00 00	 call	 PyTokenizer_FromString
  0008d	48 89 44 24 30	 mov	 QWORD PTR tok$[rsp], rax
$LN2@PyParser_P:

; 58   :     if (tok == NULL) {

  00092	48 83 7c 24 30
	00		 cmp	 QWORD PTR tok$[rsp], 0
  00098	75 2e		 jne	 SHORT $LN1@PyParser_P

; 59   :         err_ret->error = PyErr_Occurred() ? E_DECODE : E_NOMEM;

  0009a	e8 00 00 00 00	 call	 PyErr_Occurred
  0009f	48 85 c0	 test	 rax, rax
  000a2	74 0a		 je	 SHORT $LN9@PyParser_P
  000a4	c7 44 24 40 16
	00 00 00	 mov	 DWORD PTR tv81[rsp], 22
  000ac	eb 08		 jmp	 SHORT $LN10@PyParser_P
$LN9@PyParser_P:
  000ae	c7 44 24 40 0f
	00 00 00	 mov	 DWORD PTR tv81[rsp], 15
$LN10@PyParser_P:
  000b6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  000be	8b 4c 24 40	 mov	 ecx, DWORD PTR tv81[rsp]
  000c2	89 08		 mov	 DWORD PTR [rax], ecx

; 60   :         return NULL;

  000c4	33 c0		 xor	 eax, eax
  000c6	eb 52		 jmp	 SHORT $LN5@PyParser_P
$LN1@PyParser_P:

; 61   :     }
; 62   : 
; 63   : #ifndef PGEN
; 64   :     Py_INCREF(err_ret->filename);

  000c8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  000d0	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000d4	e8 00 00 00 00	 call	 _Py_IncRef

; 65   :     tok->filename = err_ret->filename;

  000d9	48 8b 44 24 30	 mov	 rax, QWORD PTR tok$[rsp]
  000de	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR err_ret$[rsp]
  000e6	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000ea	48 89 88 f0 01
	00 00		 mov	 QWORD PTR [rax+496], rcx

; 66   : #endif
; 67   :     return parsetok(tok, g, start, err_ret, flags);

  000f1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR flags$[rsp]
  000f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fe	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR err_ret$[rsp]
  00106	44 8b 44 24 78	 mov	 r8d, DWORD PTR start$[rsp]
  0010b	48 8b 54 24 70	 mov	 rdx, QWORD PTR g$[rsp]
  00110	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tok$[rsp]
  00115	e8 00 00 00 00	 call	 parsetok
$LN5@PyParser_P:

; 68   : }

  0011a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011e	c3		 ret	 0
PyParser_ParseStringFlagsFilenameEx ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	PyParser_ParseFileFlags
PUBLIC	PyParser_ParseFile
;	COMDAT pdata
; File c:\src\pyparallel\parser\parsetok.c
pdata	SEGMENT
$pdata$PyParser_ParseFile DD imagerel $LN3
	DD	imagerel $LN3+107
	DD	imagerel $unwind$PyParser_ParseFile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseFile DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyParser_ParseFile
_TEXT	SEGMENT
fp$ = 96
filename$ = 104
g$ = 112
start$ = 120
ps1$ = 128
ps2$ = 136
err_ret$ = 144
PyParser_ParseFile PROC					; COMDAT

; 75   : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 76   :     return PyParser_ParseFileFlags(fp, filename, NULL,
; 77   :                                    g, start, ps1, ps2, err_ret, 0);

  00018	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR [rsp+64], 0
  00020	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00028	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0002d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ps2$[rsp]
  00035	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0003a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ps1$[rsp]
  00042	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00047	8b 44 24 78	 mov	 eax, DWORD PTR start$[rsp]
  0004b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0004f	4c 8b 4c 24 70	 mov	 r9, QWORD PTR g$[rsp]
  00054	45 33 c0	 xor	 r8d, r8d
  00057	48 8b 54 24 68	 mov	 rdx, QWORD PTR filename$[rsp]
  0005c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  00061	e8 00 00 00 00	 call	 PyParser_ParseFileFlags

; 78   : }

  00066	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006a	c3		 ret	 0
PyParser_ParseFile ENDP
_TEXT	ENDS
PUBLIC	PyParser_ParseFileFlagsEx
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_ParseFileFlags DD imagerel $LN3
	DD	imagerel $LN3+131
	DD	imagerel $unwind$PyParser_ParseFileFlags
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseFileFlags DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyParser_ParseFileFlags
_TEXT	SEGMENT
iflags$ = 80
fp$ = 112
filename$ = 120
enc$ = 128
g$ = 136
start$ = 144
ps1$ = 152
ps2$ = 160
err_ret$ = 168
flags$ = 176
PyParser_ParseFileFlags PROC				; COMDAT

; 84   : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 85   :     int iflags = flags;

  00018	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0001f	89 44 24 50	 mov	 DWORD PTR iflags$[rsp], eax

; 86   :     return PyParser_ParseFileFlagsEx(fp, filename, enc, g, start, ps1,
; 87   :                                      ps2, err_ret, &iflags);

  00023	48 8d 44 24 50	 lea	 rax, QWORD PTR iflags$[rsp]
  00028	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0002d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00035	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0003a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ps2$[rsp]
  00042	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00047	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ps1$[rsp]
  0004f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00054	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR start$[rsp]
  0005b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0005f	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR g$[rsp]
  00067	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR enc$[rsp]
  0006f	48 8b 54 24 78	 mov	 rdx, QWORD PTR filename$[rsp]
  00074	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fp$[rsp]
  00079	e8 00 00 00 00	 call	 PyParser_ParseFileFlagsEx

; 88   : }

  0007e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00082	c3		 ret	 0
PyParser_ParseFileFlags ENDP
_TEXT	ENDS
EXTRN	PyTokenizer_FromFile:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyParser_ParseFileFlagsEx DD imagerel $LN5
	DD	imagerel $LN5+199
	DD	imagerel $unwind$PyParser_ParseFileFlagsEx
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyParser_ParseFileFlagsEx DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyParser_ParseFileFlagsEx
_TEXT	SEGMENT
tok$ = 48
fp$ = 80
filename$ = 88
enc$ = 96
g$ = 104
start$ = 112
ps1$ = 120
ps2$ = 128
err_ret$ = 136
flags$ = 144
PyParser_ParseFileFlagsEx PROC				; COMDAT

; 94   : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 95   :     struct tok_state *tok;
; 96   : 
; 97   :     if (initerr(err_ret, filename) < 0)

  00018	48 8b 54 24 58	 mov	 rdx, QWORD PTR filename$[rsp]
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR err_ret$[rsp]
  00025	e8 00 00 00 00	 call	 initerr
  0002a	85 c0		 test	 eax, eax
  0002c	7d 07		 jge	 SHORT $LN2@PyParser_P@2

; 98   :         return NULL;

  0002e	33 c0		 xor	 eax, eax
  00030	e9 8d 00 00 00	 jmp	 $LN3@PyParser_P@2
$LN2@PyParser_P@2:

; 99   : 
; 100  :     if ((tok = PyTokenizer_FromFile(fp, (char *)enc, ps1, ps2)) == NULL) {

  00035	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR ps2$[rsp]
  0003d	4c 8b 44 24 78	 mov	 r8, QWORD PTR ps1$[rsp]
  00042	48 8b 54 24 60	 mov	 rdx, QWORD PTR enc$[rsp]
  00047	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fp$[rsp]
  0004c	e8 00 00 00 00	 call	 PyTokenizer_FromFile
  00051	48 89 44 24 30	 mov	 QWORD PTR tok$[rsp], rax
  00056	48 83 7c 24 30
	00		 cmp	 QWORD PTR tok$[rsp], 0
  0005c	75 12		 jne	 SHORT $LN1@PyParser_P@2

; 101  :         err_ret->error = E_NOMEM;

  0005e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00066	c7 00 0f 00 00
	00		 mov	 DWORD PTR [rax], 15

; 102  :         return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	eb 52		 jmp	 SHORT $LN3@PyParser_P@2
$LN1@PyParser_P@2:

; 103  :     }
; 104  : #ifndef PGEN
; 105  :     Py_INCREF(err_ret->filename);

  00070	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00078	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0007c	e8 00 00 00 00	 call	 _Py_IncRef

; 106  :     tok->filename = err_ret->filename;

  00081	48 8b 44 24 30	 mov	 rax, QWORD PTR tok$[rsp]
  00086	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR err_ret$[rsp]
  0008e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00092	48 89 88 f0 01
	00 00		 mov	 QWORD PTR [rax+496], rcx

; 107  : #endif
; 108  :     return parsetok(tok, g, start, err_ret, flags);

  00099	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR flags$[rsp]
  000a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a6	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR err_ret$[rsp]
  000ae	44 8b 44 24 70	 mov	 r8d, DWORD PTR start$[rsp]
  000b3	48 8b 54 24 68	 mov	 rdx, QWORD PTR g$[rsp]
  000b8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tok$[rsp]
  000bd	e8 00 00 00 00	 call	 parsetok
$LN3@PyParser_P@2:

; 109  : }

  000c2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c6	c3		 ret	 0
PyParser_ParseFileFlagsEx ENDP
_TEXT	ENDS
PUBLIC	??_C@_1DM@EEJCMBLD@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AA?5?$AA?9?$AA?5?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?5?$AAI?$AAN?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CK@HACFMFLM@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAp?$AAa?$AAr?$AAs?$AAe?$AAt?$AAo?$AAk?$AA?4?$AAc?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CN@IGILJKKH@with?5Barry?5as?5BDFL?0?5use?5?8?$DM?$DO?8?5ins@ ; `string'
PUBLIC	??_C@_02GMAKCBGE@?$DM?$DO?$AA@			; `string'
PUBLIC	??_C@_02FDNJECIE@?$CB?$DN?$AA@			; `string'
PUBLIC	??_C@_0BH@LGHHEPFB@no?5mem?5for?5next?5token?6?$AA@ ; `string'
PUBLIC	??_C@_0BH@PCOGNDBL@no?5mem?5for?5new?5parser?6?$AA@ ; `string'
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	PyNode_New:PROC
EXTRN	__imp__wassert:PROC
EXTRN	PyParser_Delete:PROC
EXTRN	PyNode_Free:PROC
EXTRN	PyParser_AddToken:PROC
EXTRN	_PyObject_DebugFree:PROC
EXTRN	strcmp:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	_PyObject_DebugMalloc:PROC
EXTRN	PyTokenizer_Get:PROC
EXTRN	PyTokenizer_Free:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	PyParser_New:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$parsetok DD imagerel parsetok
	DD	imagerel parsetok+1873
	DD	imagerel $unwind$parsetok
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parsetok DD 021b01H
	DD	015011bH
xdata	ENDS
;	COMDAT ??_C@_1DM@EEJCMBLD@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AA?5?$AA?9?$AA?5?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?5?$AAI?$AAN?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@EEJCMBLD@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AA?5?$AA?9?$AA?5?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?5?$AAI?$AAN?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?$AA@ DB 't'
	DB	00H, 'o', 00H, 'k', 00H, '-', 00H, '>', 00H, 'c', 00H, 'u', 00H
	DB	'r', 00H, ' ', 00H, '-', 00H, ' ', 00H, 't', 00H, 'o', 00H, 'k'
	DB	00H, '-', 00H, '>', 00H, 'b', 00H, 'u', 00H, 'f', 00H, ' ', 00H
	DB	'<', 00H, ' ', 00H, 'I', 00H, 'N', 00H, 'T', 00H, '_', 00H, 'M'
	DB	00H, 'A', 00H, 'X', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@HACFMFLM@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAp?$AAa?$AAr?$AAs?$AAe?$AAt?$AAo?$AAk?$AA?4?$AAc?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@HACFMFLM@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAp?$AAa?$AAr?$AAs?$AAe?$AAt?$AAo?$AAk?$AA?4?$AAc?$AA?$AA@ DB '.'
	DB	00H, '.', 00H, '\', 00H, 'P', 00H, 'a', 00H, 'r', 00H, 's', 00H
	DB	'e', 00H, 'r', 00H, '\', 00H, 'p', 00H, 'a', 00H, 'r', 00H, 's'
	DB	00H, 'e', 00H, 't', 00H, 'o', 00H, 'k', 00H, '.', 00H, 'c', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IGILJKKH@with?5Barry?5as?5BDFL?0?5use?5?8?$DM?$DO?8?5ins@
CONST	SEGMENT
??_C@_0CN@IGILJKKH@with?5Barry?5as?5BDFL?0?5use?5?8?$DM?$DO?8?5ins@ DB 'w'
	DB	'ith Barry as BDFL, use ''<>'' instead of ''!=''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMAKCBGE@?$DM?$DO?$AA@
CONST	SEGMENT
??_C@_02GMAKCBGE@?$DM?$DO?$AA@ DB '<>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02FDNJECIE@?$CB?$DN?$AA@
CONST	SEGMENT
??_C@_02FDNJECIE@?$CB?$DN?$AA@ DB '!=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LGHHEPFB@no?5mem?5for?5next?5token?6?$AA@
CONST	SEGMENT
??_C@_0BH@LGHHEPFB@no?5mem?5for?5next?5token?6?$AA@ DB 'no mem for next t'
	DB	'oken', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@PCOGNDBL@no?5mem?5for?5new?5parser?6?$AA@
CONST	SEGMENT
??_C@_0BH@PCOGNDBL@no?5mem?5for?5new?5parser?6?$AA@ DB 'no mem for new pa'
	DB	'rser', 0aH, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT parsetok
_TEXT	SEGMENT
ps$ = 48
n$ = 56
started$ = 64
a$21011 = 72
type$21013 = 80
col_offset$21016 = 84
len$21014 = 88
b$21012 = 96
str$21015 = 104
cur$21041 = 112
c$21042 = 120
len$21063 = 128
r$21075 = 136
tv263 = 144
tok$ = 176
g$ = 184
start$ = 192
err_ret$ = 200
flags$ = 208
parsetok PROC						; COMDAT

; 135  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 136  :     parser_state *ps;
; 137  :     node *n;
; 138  :     int started = 0;

  0001b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR started$[rsp], 0

; 139  : 
; 140  :     if ((ps = PyParser_New(g, start)) == NULL) {

  00023	8b 94 24 c0 00
	00 00		 mov	 edx, DWORD PTR start$[rsp]
  0002a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00032	e8 00 00 00 00	 call	 PyParser_New
  00037	48 89 44 24 30	 mov	 QWORD PTR ps$[rsp], rax
  0003c	48 83 7c 24 30
	00		 cmp	 QWORD PTR ps$[rsp], 0
  00042	75 3c		 jne	 SHORT $LN41@parsetok

; 141  :         fprintf(stderr, "no mem for new parser\n");

  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  0004a	48 83 c0 60	 add	 rax, 96			; 00000060H
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@PCOGNDBL@no?5mem?5for?5new?5parser?6?$AA@
  00055	48 8b c8	 mov	 rcx, rax
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 142  :         err_ret->error = E_NOMEM;

  0005e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00066	c7 00 0f 00 00
	00		 mov	 DWORD PTR [rax], 15

; 143  :         PyTokenizer_Free(tok);

  0006c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00074	e8 00 00 00 00	 call	 PyTokenizer_Free

; 144  :         return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 c9 06 00 00	 jmp	 $LN42@parsetok
$LN41@parsetok:

; 145  :     }
; 146  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 147  :     if (*flags & PyPARSE_BARRY_AS_BDFL)

  00080	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR flags$[rsp]
  00088	8b 00		 mov	 eax, DWORD PTR [rax]
  0008a	83 e0 20	 and	 eax, 32			; 00000020H
  0008d	85 c0		 test	 eax, eax
  0008f	74 1a		 je	 SHORT $LN40@parsetok

; 148  :         ps->p_flags |= CO_FUTURE_BARRY_AS_BDFL;

  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR ps$[rsp]
  00096	8b 80 b8 8c 00
	00		 mov	 eax, DWORD PTR [rax+36024]
  0009c	0f ba e8 12	 bts	 eax, 18
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ps$[rsp]
  000a5	89 81 b8 8c 00
	00		 mov	 DWORD PTR [rcx+36024], eax
$LN40@parsetok:
$LN39@parsetok:

; 149  : #endif
; 150  : 
; 151  :     for (;;) {
; 152  :         char *a, *b;
; 153  :         int type;
; 154  :         size_t len;
; 155  :         char *str;
; 156  :         int col_offset;
; 157  : 
; 158  :         type = PyTokenizer_Get(tok, &a, &b);

  000ab	4c 8d 44 24 60	 lea	 r8, QWORD PTR b$21012[rsp]
  000b0	48 8d 54 24 48	 lea	 rdx, QWORD PTR a$21011[rsp]
  000b5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  000bd	e8 00 00 00 00	 call	 PyTokenizer_Get
  000c2	89 44 24 50	 mov	 DWORD PTR type$21013[rsp], eax

; 159  :         if (type == ERRORTOKEN) {

  000c6	83 7c 24 50 35	 cmp	 DWORD PTR type$21013[rsp], 53 ; 00000035H
  000cb	75 1a		 jne	 SHORT $LN37@parsetok

; 160  :             err_ret->error = tok->done;

  000cd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  000d5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  000dd	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  000e0	89 08		 mov	 DWORD PTR [rax], ecx

; 161  :             break;

  000e2	e9 69 02 00 00	 jmp	 $LN38@parsetok
$LN37@parsetok:

; 162  :         }
; 163  :         if (type == ENDMARKER && started) {

  000e7	83 7c 24 50 00	 cmp	 DWORD PTR type$21013[rsp], 0
  000ec	75 62		 jne	 SHORT $LN36@parsetok
  000ee	83 7c 24 40 00	 cmp	 DWORD PTR started$[rsp], 0
  000f3	74 5b		 je	 SHORT $LN36@parsetok

; 164  :             type = NEWLINE; /* Add an extra newline */

  000f5	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR type$21013[rsp], 4

; 165  :             started = 0;

  000fd	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR started$[rsp], 0

; 166  :             /* Add the right number of dedent tokens,
; 167  :                except if a certain flag is given --
; 168  :                codeop.py uses this. */
; 169  :             if (tok->indent &&
; 170  :                 !(*flags & PyPARSE_DONT_IMPLY_DEDENT))

  00105	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0010d	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00111	74 3b		 je	 SHORT $LN35@parsetok
  00113	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR flags$[rsp]
  0011b	8b 00		 mov	 eax, DWORD PTR [rax]
  0011d	83 e0 02	 and	 eax, 2
  00120	85 c0		 test	 eax, eax
  00122	75 2a		 jne	 SHORT $LN35@parsetok

; 171  :             {
; 172  :                 tok->pendin = -tok->indent;

  00124	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0012c	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0012f	f7 d8		 neg	 eax
  00131	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00139	89 81 d4 01 00
	00		 mov	 DWORD PTR [rcx+468], eax

; 173  :                 tok->indent = 0;

  0013f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00147	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [rax+60], 0
$LN35@parsetok:

; 174  :             }
; 175  :         }
; 176  :         else

  0014e	eb 08		 jmp	 SHORT $LN34@parsetok
$LN36@parsetok:

; 177  :             started = 1;

  00150	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR started$[rsp], 1
$LN34@parsetok:

; 178  :         len = b - a; /* XXX this may compute NULL - NULL */

  00158	48 8b 44 24 48	 mov	 rax, QWORD PTR a$21011[rsp]
  0015d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR b$21012[rsp]
  00162	48 2b c8	 sub	 rcx, rax
  00165	48 8b c1	 mov	 rax, rcx
  00168	48 89 44 24 58	 mov	 QWORD PTR len$21014[rsp], rax

; 179  :         str = (char *) PyObject_MALLOC(len + 1);

  0016d	48 8b 44 24 58	 mov	 rax, QWORD PTR len$21014[rsp]
  00172	48 ff c0	 inc	 rax
  00175	48 8b c8	 mov	 rcx, rax
  00178	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  0017d	48 89 44 24 68	 mov	 QWORD PTR str$21015[rsp], rax

; 180  :         if (str == NULL) {

  00182	48 83 7c 24 68
	00		 cmp	 QWORD PTR str$21015[rsp], 0
  00188	75 2d		 jne	 SHORT $LN33@parsetok

; 181  :             fprintf(stderr, "no mem for next token\n");

  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00190	48 83 c0 60	 add	 rax, 96			; 00000060H
  00194	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LGHHEPFB@no?5mem?5for?5next?5token?6?$AA@
  0019b	48 8b c8	 mov	 rcx, rax
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 182  :             err_ret->error = E_NOMEM;

  001a4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  001ac	c7 00 0f 00 00
	00		 mov	 DWORD PTR [rax], 15

; 183  :             break;

  001b2	e9 99 01 00 00	 jmp	 $LN38@parsetok
$LN33@parsetok:

; 184  :         }
; 185  :         if (len > 0)

  001b7	48 83 7c 24 58
	00		 cmp	 QWORD PTR len$21014[rsp], 0
  001bd	76 15		 jbe	 SHORT $LN32@parsetok

; 186  :             strncpy(str, a, len);

  001bf	4c 8b 44 24 58	 mov	 r8, QWORD PTR len$21014[rsp]
  001c4	48 8b 54 24 48	 mov	 rdx, QWORD PTR a$21011[rsp]
  001c9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$21015[rsp]
  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
$LN32@parsetok:

; 187  :         str[len] = '\0';

  001d4	48 8b 44 24 58	 mov	 rax, QWORD PTR len$21014[rsp]
  001d9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$21015[rsp]
  001de	48 03 c8	 add	 rcx, rax
  001e1	48 8b c1	 mov	 rax, rcx
  001e4	c6 00 00	 mov	 BYTE PTR [rax], 0

; 188  : 
; 189  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 190  :         if (type == NOTEQUAL) {

  001e7	83 7c 24 50 1c	 cmp	 DWORD PTR type$21013[rsp], 28
  001ec	0f 85 a1 00 00
	00		 jne	 $LN31@parsetok

; 191  :             if (!(ps->p_flags & CO_FUTURE_BARRY_AS_BDFL) &&
; 192  :                             strcmp(str, "!=")) {

  001f2	48 8b 44 24 30	 mov	 rax, QWORD PTR ps$[rsp]
  001f7	8b 80 b8 8c 00
	00		 mov	 eax, DWORD PTR [rax+36024]
  001fd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00202	85 c0		 test	 eax, eax
  00204	75 34		 jne	 SHORT $LN30@parsetok
  00206	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02FDNJECIE@?$CB?$DN?$AA@
  0020d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$21015[rsp]
  00212	e8 00 00 00 00	 call	 strcmp
  00217	85 c0		 test	 eax, eax
  00219	74 1f		 je	 SHORT $LN30@parsetok

; 193  :                 PyObject_FREE(str);

  0021b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$21015[rsp]
  00220	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 194  :                 err_ret->error = E_SYNTAX;

  00225	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  0022d	c7 00 0e 00 00
	00		 mov	 DWORD PTR [rax], 14

; 195  :                 break;

  00233	e9 18 01 00 00	 jmp	 $LN38@parsetok

; 196  :             }
; 197  :             else if ((ps->p_flags & CO_FUTURE_BARRY_AS_BDFL) &&

  00238	eb 59		 jmp	 SHORT $LN29@parsetok
$LN30@parsetok:

; 198  :                             strcmp(str, "<>")) {

  0023a	48 8b 44 24 30	 mov	 rax, QWORD PTR ps$[rsp]
  0023f	8b 80 b8 8c 00
	00		 mov	 eax, DWORD PTR [rax+36024]
  00245	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0024a	85 c0		 test	 eax, eax
  0024c	74 45		 je	 SHORT $LN28@parsetok
  0024e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02GMAKCBGE@?$DM?$DO?$AA@
  00255	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$21015[rsp]
  0025a	e8 00 00 00 00	 call	 strcmp
  0025f	85 c0		 test	 eax, eax
  00261	74 30		 je	 SHORT $LN28@parsetok

; 199  :                 PyObject_FREE(str);

  00263	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$21015[rsp]
  00268	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 200  :                 err_ret->text = "with Barry as BDFL, use '<>' "
; 201  :                                 "instead of '!='";

  0026d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CN@IGILJKKH@with?5Barry?5as?5BDFL?0?5use?5?8?$DM?$DO?8?5ins@
  0027c	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 202  :                 err_ret->error = E_SYNTAX;

  00280	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00288	c7 00 0e 00 00
	00		 mov	 DWORD PTR [rax], 14

; 203  :                 break;

  0028e	e9 bd 00 00 00	 jmp	 $LN38@parsetok
$LN28@parsetok:
$LN29@parsetok:
$LN31@parsetok:

; 204  :             }
; 205  :         }
; 206  : #endif
; 207  :         if (a >= tok->line_start)

  00293	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0029b	48 8b 80 b0 03
	00 00		 mov	 rax, QWORD PTR [rax+944]
  002a2	48 39 44 24 48	 cmp	 QWORD PTR a$21011[rsp], rax
  002a7	72 20		 jb	 SHORT $LN27@parsetok

; 208  :             col_offset = a - tok->line_start;

  002a9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  002b1	48 8b 80 b0 03
	00 00		 mov	 rax, QWORD PTR [rax+944]
  002b8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR a$21011[rsp]
  002bd	48 2b c8	 sub	 rcx, rax
  002c0	48 8b c1	 mov	 rax, rcx
  002c3	89 44 24 54	 mov	 DWORD PTR col_offset$21016[rsp], eax

; 209  :         else

  002c7	eb 08		 jmp	 SHORT $LN26@parsetok
$LN27@parsetok:

; 210  :             col_offset = -1;

  002c9	c7 44 24 54 ff
	ff ff ff	 mov	 DWORD PTR col_offset$21016[rsp], -1
$LN26@parsetok:

; 211  : 
; 212  :         if ((err_ret->error =
; 213  :              PyParser_AddToken(ps, (int)type, str,
; 214  :                                tok->lineno, col_offset,
; 215  :                                &(err_ret->expected))) != E_OK) {

  002d1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  002d9	48 83 c0 24	 add	 rax, 36			; 00000024H
  002dd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002e2	8b 44 24 54	 mov	 eax, DWORD PTR col_offset$21016[rsp]
  002e6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002ea	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  002f2	44 8b 88 e8 01
	00 00		 mov	 r9d, DWORD PTR [rax+488]
  002f9	4c 8b 44 24 68	 mov	 r8, QWORD PTR str$21015[rsp]
  002fe	8b 54 24 50	 mov	 edx, DWORD PTR type$21013[rsp]
  00302	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ps$[rsp]
  00307	e8 00 00 00 00	 call	 PyParser_AddToken
  0030c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR err_ret$[rsp]
  00314	89 01		 mov	 DWORD PTR [rcx], eax
  00316	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  0031e	83 38 0a	 cmp	 DWORD PTR [rax], 10
  00321	74 28		 je	 SHORT $LN25@parsetok

; 216  :             if (err_ret->error != E_DONE) {

  00323	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  0032b	83 38 10	 cmp	 DWORD PTR [rax], 16
  0032e	74 19		 je	 SHORT $LN24@parsetok

; 217  :                 PyObject_FREE(str);

  00330	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$21015[rsp]
  00335	e8 00 00 00 00	 call	 _PyObject_DebugFree

; 218  :                 err_ret->token = type;

  0033a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00342	8b 4c 24 50	 mov	 ecx, DWORD PTR type$21013[rsp]
  00346	89 48 20	 mov	 DWORD PTR [rax+32], ecx
$LN24@parsetok:

; 219  :             }
; 220  :             break;

  00349	eb 05		 jmp	 SHORT $LN38@parsetok
$LN25@parsetok:

; 221  :         }
; 222  :     }

  0034b	e9 5b fd ff ff	 jmp	 $LN39@parsetok
$LN38@parsetok:

; 223  : 
; 224  :     if (err_ret->error == E_DONE) {

  00350	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00358	83 38 10	 cmp	 DWORD PTR [rax], 16
  0035b	0f 85 06 01 00
	00		 jne	 $LN23@parsetok

; 225  :         n = ps->p_tree;

  00361	48 8b 44 24 30	 mov	 rax, QWORD PTR ps$[rsp]
  00366	48 8b 80 b0 8c
	00 00		 mov	 rax, QWORD PTR [rax+36016]
  0036d	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax

; 226  :         ps->p_tree = NULL;

  00372	48 8b 44 24 30	 mov	 rax, QWORD PTR ps$[rsp]
  00377	48 c7 80 b0 8c
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+36016], 0

; 227  : 
; 228  : #ifndef PGEN
; 229  :         /* Check that the source for a single input statement really
; 230  :            is a single statement by looking at what is left in the
; 231  :            buffer after parsing.  Trailing whitespace and comments
; 232  :            are OK.  */
; 233  :         if (start == single_input) {

  00382	81 bc 24 c0 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR start$[rsp], 256 ; 00000100H
  0038d	0f 85 d2 00 00
	00		 jne	 $LN22@parsetok

; 234  :             char *cur = tok->cur;

  00393	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0039b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0039f	48 89 44 24 70	 mov	 QWORD PTR cur$21041[rsp], rax

; 235  :             char c = *tok->cur;

  003a4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  003ac	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003b0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003b3	88 44 24 78	 mov	 BYTE PTR c$21042[rsp], al
$LN21@parsetok:
$LN19@parsetok:

; 236  : 
; 237  :             for (;;) {
; 238  :                 while (c == ' ' || c == '\t' || c == '\n' || c == '\014')

  003b7	0f be 44 24 78	 movsx	 eax, BYTE PTR c$21042[rsp]
  003bc	83 f8 20	 cmp	 eax, 32			; 00000020H
  003bf	74 1e		 je	 SHORT $LN17@parsetok
  003c1	0f be 44 24 78	 movsx	 eax, BYTE PTR c$21042[rsp]
  003c6	83 f8 09	 cmp	 eax, 9
  003c9	74 14		 je	 SHORT $LN17@parsetok
  003cb	0f be 44 24 78	 movsx	 eax, BYTE PTR c$21042[rsp]
  003d0	83 f8 0a	 cmp	 eax, 10
  003d3	74 0a		 je	 SHORT $LN17@parsetok
  003d5	0f be 44 24 78	 movsx	 eax, BYTE PTR c$21042[rsp]
  003da	83 f8 0c	 cmp	 eax, 12
  003dd	75 1b		 jne	 SHORT $LN18@parsetok
$LN17@parsetok:

; 239  :                     c = *++cur;

  003df	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$21041[rsp]
  003e4	48 ff c0	 inc	 rax
  003e7	48 89 44 24 70	 mov	 QWORD PTR cur$21041[rsp], rax
  003ec	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$21041[rsp]
  003f1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003f4	88 44 24 78	 mov	 BYTE PTR c$21042[rsp], al
  003f8	eb bd		 jmp	 SHORT $LN19@parsetok
$LN18@parsetok:

; 240  : 
; 241  :                 if (!c)

  003fa	0f be 44 24 78	 movsx	 eax, BYTE PTR c$21042[rsp]
  003ff	85 c0		 test	 eax, eax
  00401	75 02		 jne	 SHORT $LN16@parsetok

; 242  :                     break;

  00403	eb 60		 jmp	 SHORT $LN20@parsetok
$LN16@parsetok:

; 243  : 
; 244  :                 if (c != '#') {

  00405	0f be 44 24 78	 movsx	 eax, BYTE PTR c$21042[rsp]
  0040a	83 f8 23	 cmp	 eax, 35			; 00000023H
  0040d	74 23		 je	 SHORT $LN15@parsetok

; 245  :                     err_ret->error = E_BADSINGLE;

  0040f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00417	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 246  :                     PyNode_Free(n);

  0041d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  00422	e8 00 00 00 00	 call	 PyNode_Free

; 247  :                     n = NULL;

  00427	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0

; 248  :                     break;

  00430	eb 33		 jmp	 SHORT $LN20@parsetok
$LN15@parsetok:
$LN14@parsetok:

; 249  :                 }
; 250  : 
; 251  :                 /* Suck up comment. */
; 252  :                 while (c && c != '\n')

  00432	0f be 44 24 78	 movsx	 eax, BYTE PTR c$21042[rsp]
  00437	85 c0		 test	 eax, eax
  00439	74 25		 je	 SHORT $LN13@parsetok
  0043b	0f be 44 24 78	 movsx	 eax, BYTE PTR c$21042[rsp]
  00440	83 f8 0a	 cmp	 eax, 10
  00443	74 1b		 je	 SHORT $LN13@parsetok

; 253  :                     c = *++cur;

  00445	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$21041[rsp]
  0044a	48 ff c0	 inc	 rax
  0044d	48 89 44 24 70	 mov	 QWORD PTR cur$21041[rsp], rax
  00452	48 8b 44 24 70	 mov	 rax, QWORD PTR cur$21041[rsp]
  00457	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0045a	88 44 24 78	 mov	 BYTE PTR c$21042[rsp], al
  0045e	eb d2		 jmp	 SHORT $LN14@parsetok
$LN13@parsetok:

; 254  :             }

  00460	e9 52 ff ff ff	 jmp	 $LN21@parsetok
$LN20@parsetok:
$LN22@parsetok:

; 255  :         }
; 256  : #endif
; 257  :     }
; 258  :     else

  00465	eb 09		 jmp	 SHORT $LN12@parsetok
$LN23@parsetok:

; 259  :         n = NULL;

  00467	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0
$LN12@parsetok:

; 260  : 
; 261  : #ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD
; 262  :     *flags = ps->p_flags;

  00470	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR flags$[rsp]
  00478	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ps$[rsp]
  0047d	8b 89 b8 8c 00
	00		 mov	 ecx, DWORD PTR [rcx+36024]
  00483	89 08		 mov	 DWORD PTR [rax], ecx

; 263  : #endif
; 264  :     PyParser_Delete(ps);

  00485	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ps$[rsp]
  0048a	e8 00 00 00 00	 call	 PyParser_Delete

; 265  : 
; 266  :     if (n == NULL) {

  0048f	48 83 7c 24 38
	00		 cmp	 QWORD PTR n$[rsp], 0
  00495	0f 85 47 01 00
	00		 jne	 $LN11@parsetok

; 267  :         if (tok->done == E_EOF)

  0049b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  004a3	83 78 28 0b	 cmp	 DWORD PTR [rax+40], 11
  004a7	75 0e		 jne	 SHORT $LN10@parsetok

; 268  :             err_ret->error = E_EOF;

  004a9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  004b1	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11
$LN10@parsetok:

; 269  :         err_ret->lineno = tok->lineno;

  004b7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  004bf	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  004c7	8b 89 e8 01 00
	00		 mov	 ecx, DWORD PTR [rcx+488]
  004cd	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 270  :         if (tok->buf != NULL) {

  004d0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  004d8	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  004dc	0f 84 fb 00 00
	00		 je	 $LN9@parsetok

; 271  :             size_t len;
; 272  :             assert(tok->cur - tok->buf < INT_MAX);

  004e2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  004ea	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  004f2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004f5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  004f9	48 2b c1	 sub	 rax, rcx
  004fc	48 3d ff ff ff
	7f		 cmp	 rax, 2147483647		; 7fffffffH
  00502	7c 1c		 jl	 SHORT $LN44@parsetok
  00504	41 b8 10 01 00
	00		 mov	 r8d, 272		; 00000110H
  0050a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CK@HACFMFLM@?$AA?4?$AA?4?$AA?2?$AAP?$AAa?$AAr?$AAs?$AAe?$AAr?$AA?2?$AAp?$AAa?$AAr?$AAs?$AAe?$AAt?$AAo?$AAk?$AA?4?$AAc?$AA?$AA@
  00511	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DM@EEJCMBLD@?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAc?$AAu?$AAr?$AA?5?$AA?9?$AA?5?$AAt?$AAo?$AAk?$AA?9?$AA?$DO?$AAb?$AAu?$AAf?$AA?5?$AA?$DM?$AA?5?$AAI?$AAN?$AAT?$AA_?$AAM?$AAA?$AAX?$AA?$AA@
  00518	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wassert
  0051e	33 c0		 xor	 eax, eax
$LN44@parsetok:

; 273  :             err_ret->offset = (int)(tok->cur - tok->buf);

  00520	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00528	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00530	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00533	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00537	48 2b c1	 sub	 rax, rcx
  0053a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR err_ret$[rsp]
  00542	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 274  :             len = tok->inp - tok->buf;

  00545	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0054d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  00555	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00558	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0055c	48 2b c1	 sub	 rax, rcx
  0055f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR len$21063[rsp], rax

; 275  :             err_ret->text = (char *) PyObject_MALLOC(len + 1);

  00567	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR len$21063[rsp]
  0056f	48 ff c0	 inc	 rax
  00572	48 8b c8	 mov	 rcx, rax
  00575	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  0057a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR err_ret$[rsp]
  00582	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 276  :             if (err_ret->text != NULL) {

  00586	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  0058e	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00593	74 48		 je	 SHORT $LN8@parsetok

; 277  :                 if (len > 0)

  00595	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR len$21063[rsp], 0
  0059e	76 25		 jbe	 SHORT $LN7@parsetok

; 278  :                     strncpy(err_ret->text, tok->buf, len);

  005a0	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR len$21063[rsp]
  005a8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  005b0	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  005b3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  005bb	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  005bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
$LN7@parsetok:

; 279  :                 err_ret->text[len] = '\0';

  005c5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  005cd	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  005d1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR len$21063[rsp]
  005d9	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN8@parsetok:
$LN9@parsetok:

; 280  :             }
; 281  :         }

  005dd	e9 55 01 00 00	 jmp	 $LN6@parsetok
$LN11@parsetok:

; 282  :     } else if (tok->encoding != NULL) {

  005e2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  005ea	48 83 b8 a0 03
	00 00 00	 cmp	 QWORD PTR [rax+928], 0
  005f2	0f 84 3f 01 00
	00		 je	 $LN5@parsetok

; 283  :         /* 'nodes->n_str' uses PyObject_*, while 'tok->encoding' was
; 284  :          * allocated using PyMem_
; 285  :          */
; 286  :         node* r = PyNode_New(encoding_decl);

  005f8	b9 4f 01 00 00	 mov	 ecx, 335		; 0000014fH
  005fd	e8 00 00 00 00	 call	 PyNode_New
  00602	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR r$21075[rsp], rax

; 287  :         if (r)

  0060a	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR r$21075[rsp], 0
  00613	74 2b		 je	 SHORT $LN4@parsetok

; 288  :             r->n_str = PyObject_MALLOC(strlen(tok->encoding)+1);

  00615	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  0061d	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  00624	e8 00 00 00 00	 call	 strlen
  00629	48 ff c0	 inc	 rax
  0062c	48 8b c8	 mov	 rcx, rax
  0062f	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00634	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR r$21075[rsp]
  0063c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN4@parsetok:

; 289  :         if (!r || !r->n_str) {

  00640	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR r$21075[rsp], 0
  00649	74 0f		 je	 SHORT $LN2@parsetok
  0064b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR r$21075[rsp]
  00653	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00658	75 34		 jne	 SHORT $LN3@parsetok
$LN2@parsetok:

; 290  :             err_ret->error = E_NOMEM;

  0065a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR err_ret$[rsp]
  00662	c7 00 0f 00 00
	00		 mov	 DWORD PTR [rax], 15

; 291  :             if (r)

  00668	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR r$21075[rsp], 0
  00671	74 0d		 je	 SHORT $LN1@parsetok

; 292  :                 PyObject_FREE(r);

  00673	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR r$21075[rsp]
  0067b	e8 00 00 00 00	 call	 _PyObject_DebugFree
$LN1@parsetok:

; 293  :             n = NULL;

  00680	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0

; 294  :             goto done;

  00689	e9 a9 00 00 00	 jmp	 $done$21081
$LN3@parsetok:

; 295  :         }
; 296  :         strcpy(r->n_str, tok->encoding);

  0068e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  00696	48 8b 90 a0 03
	00 00		 mov	 rdx, QWORD PTR [rax+928]
  0069d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR r$21075[rsp]
  006a5	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  006a9	e8 00 00 00 00	 call	 strcpy

; 297  :         PyMem_FREE(tok->encoding);

  006ae	e8 00 00 00 00	 call	 _Py_PXCTX
  006b3	85 c0		 test	 eax, eax
  006b5	74 21		 je	 SHORT $LN45@parsetok
  006b7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  006bf	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  006c6	e8 00 00 00 00	 call	 _PxMem_Free
  006cb	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv263[rsp], 0
  006d6	eb 1f		 jmp	 SHORT $LN46@parsetok
$LN45@parsetok:
  006d8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  006e0	48 8b 88 a0 03
	00 00		 mov	 rcx, QWORD PTR [rax+928]
  006e7	e8 00 00 00 00	 call	 _PyMem_DebugFree
  006ec	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv263[rsp], 0
$LN46@parsetok:

; 298  :         tok->encoding = NULL;

  006f7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tok$[rsp]
  006ff	48 c7 80 a0 03
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+928], 0

; 299  :         r->n_nchildren = 1;

  0070a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR r$21075[rsp]
  00712	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [rax+24], 1

; 300  :         r->n_child = n;

  00719	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR r$21075[rsp]
  00721	48 8b 4c 24 38	 mov	 rcx, QWORD PTR n$[rsp]
  00726	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 301  :         n = r;

  0072a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR r$21075[rsp]
  00732	48 89 44 24 38	 mov	 QWORD PTR n$[rsp], rax
$LN5@parsetok:
$LN6@parsetok:
$done$21081:

; 302  :     }
; 303  : 
; 304  : done:
; 305  :     PyTokenizer_Free(tok);

  00737	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tok$[rsp]
  0073f	e8 00 00 00 00	 call	 PyTokenizer_Free

; 306  : 
; 307  :     return n;

  00744	48 8b 44 24 38	 mov	 rax, QWORD PTR n$[rsp]
$LN42@parsetok:

; 308  : }

  00749	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00750	c3		 ret	 0
parsetok ENDP
_TEXT	ENDS
PUBLIC	??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@		; `string'
EXTRN	PyUnicode_FromString:PROC
EXTRN	PyUnicode_DecodeFSDefault:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$initerr DD imagerel initerr
	DD	imagerel initerr+173
	DD	imagerel $unwind$initerr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$initerr DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@
CONST	SEGMENT
??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@ DB '<string>', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT initerr
_TEXT	SEGMENT
err_ret$ = 48
filename$ = 56
initerr	PROC						; COMDAT

; 312  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 313  :     err_ret->error = E_OK;

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR err_ret$[rsp]
  00013	c7 00 0a 00 00
	00		 mov	 DWORD PTR [rax], 10

; 314  :     err_ret->lineno = 0;

  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR err_ret$[rsp]
  0001e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 315  :     err_ret->offset = 0;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR err_ret$[rsp]
  0002a	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 316  :     err_ret->text = NULL;

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR err_ret$[rsp]
  00036	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 317  :     err_ret->token = -1;

  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR err_ret$[rsp]
  00043	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 318  :     err_ret->expected = -1;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR err_ret$[rsp]
  0004f	c7 40 24 ff ff
	ff ff		 mov	 DWORD PTR [rax+36], -1

; 319  : #ifndef PGEN
; 320  :     if (filename)

  00056	48 83 7c 24 38
	00		 cmp	 QWORD PTR filename$[rsp], 0
  0005c	74 15		 je	 SHORT $LN3@initerr

; 321  :         err_ret->filename = PyUnicode_DecodeFSDefault(filename);

  0005e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR filename$[rsp]
  00063	e8 00 00 00 00	 call	 PyUnicode_DecodeFSDefault
  00068	48 8b 4c 24 30	 mov	 rcx, QWORD PTR err_ret$[rsp]
  0006d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 322  :     else

  00071	eb 15		 jmp	 SHORT $LN2@initerr
$LN3@initerr:

; 323  :         err_ret->filename = PyUnicode_FromString("<string>");

  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08OOGHEFMC@?$DMstring?$DO?$AA@
  0007a	e8 00 00 00 00	 call	 PyUnicode_FromString
  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR err_ret$[rsp]
  00084	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN2@initerr:

; 324  :     if (err_ret->filename == NULL) {

  00088	48 8b 44 24 30	 mov	 rax, QWORD PTR err_ret$[rsp]
  0008d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00092	75 12		 jne	 SHORT $LN1@initerr

; 325  :         err_ret->error = E_ERROR;

  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR err_ret$[rsp]
  00099	c7 00 11 00 00
	00		 mov	 DWORD PTR [rax], 17

; 326  :         return -1;

  0009f	b8 ff ff ff ff	 mov	 eax, -1
  000a4	eb 02		 jmp	 SHORT $LN4@initerr
$LN1@initerr:

; 327  :     }
; 328  : #endif
; 329  :     return 0;

  000a6	33 c0		 xor	 eax, eax
$LN4@initerr:

; 330  : }

  000a8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ac	c3		 ret	 0
initerr	ENDP
_TEXT	ENDS
END
