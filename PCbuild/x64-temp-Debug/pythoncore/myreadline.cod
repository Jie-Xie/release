; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	PyOS_InputHook
_DATA	SEGMENT
COMM	PyOS_ReadlineFunctionPointer:QWORD
COMM	_PyOS_ReadlineTState:QWORD
_DATA	ENDS
_BSS	SEGMENT
_PyOS_ReadlineLock DQ 01H DUP (?)
PyOS_InputHook DQ 01H DUP (?)
_BSS	ENDS
PUBLIC	??_C@_0BE@LNELFCP@input?5line?5too?5long?$AA@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	PyOS_StdioReadline
EXTRN	PyErr_NoMemory:PROC
EXTRN	_PyMem_DebugRealloc:PROC
EXTRN	_PxMem_Realloc:PROC
EXTRN	PyErr_SetString:PROC
EXTRN	PyExc_OverflowError:QWORD
EXTRN	strlen:PROC
EXTRN	_PyMem_DebugFree:PROC
EXTRN	_PxMem_Free:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	__imp_fflush:PROC
EXTRN	_PyMem_DebugMalloc:PROC
EXTRN	_PxMem_Malloc:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\parser\myreadline.c
pdata	SEGMENT
$pdata$PyOS_StdioReadline DD imagerel $LN30
	DD	imagerel $LN30+838
	DD	imagerel $unwind$PyOS_StdioReadline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_StdioReadline DD 021601H
	DD	0110116H
xdata	ENDS
;	COMDAT ??_C@_0BE@LNELFCP@input?5line?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@LNELFCP@input?5line?5too?5long?$AA@ DB 'input line too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyOS_StdioReadline
_TEXT	SEGMENT
p$ = 32
pr$ = 40
n$ = 48
incr$63718 = 56
tv70 = 64
tv86 = 72
tv91 = 76
tv139 = 80
tv152 = 88
tv158 = 96
tv179 = 104
tv185 = 112
sys_stdin$ = 144
sys_stdout$ = 152
prompt$ = 160
PyOS_StdioReadline PROC					; COMDAT

; 113  : {

$LN30:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 114  :     size_t n;
; 115  :     char *p, *pr;
; 116  :     n = 100;

  00016	48 c7 44 24 30
	64 00 00 00	 mov	 QWORD PTR n$[rsp], 100	; 00000064H

; 117  :     if ((p = (char *)PyMem_MALLOC(n)) == NULL)

  0001f	e8 00 00 00 00	 call	 _Py_PXCTX
  00024	85 c0		 test	 eax, eax
  00026	74 11		 je	 SHORT $LN16@PyOS_Stdio
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  0002d	e8 00 00 00 00	 call	 _PxMem_Malloc
  00032	48 89 44 24 40	 mov	 QWORD PTR tv70[rsp], rax
  00037	eb 0f		 jmp	 SHORT $LN17@PyOS_Stdio
$LN16@PyOS_Stdio:
  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  0003e	e8 00 00 00 00	 call	 _PyMem_DebugMalloc
  00043	48 89 44 24 40	 mov	 QWORD PTR tv70[rsp], rax
$LN17@PyOS_Stdio:
  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR tv70[rsp]
  0004d	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00052	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$[rsp], 0
  00058	75 07		 jne	 SHORT $LN13@PyOS_Stdio

; 118  :         return NULL;

  0005a	33 c0		 xor	 eax, eax
  0005c	e9 dd 02 00 00	 jmp	 $LN14@PyOS_Stdio
$LN13@PyOS_Stdio:

; 119  :     fflush(sys_stdout);

  00061	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR sys_stdout$[rsp]
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 120  :     if (prompt)

  0006f	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR prompt$[rsp], 0
  00078	74 22		 je	 SHORT $LN12@PyOS_Stdio

; 121  :         fprintf(stderr, "%s", prompt);

  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00080	48 83 c0 60	 add	 rax, 96			; 00000060H
  00084	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR prompt$[rsp]
  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DKCKIIND@?$CFs?$AA@
  00093	48 8b c8	 mov	 rcx, rax
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
$LN12@PyOS_Stdio:

; 122  :     fflush(stderr);

  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  000a2	48 83 c0 60	 add	 rax, 96			; 00000060H
  000a6	48 8b c8	 mov	 rcx, rax
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 123  :     switch (my_fgets(p, (int)n, sys_stdin)) {

  000af	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR sys_stdin$[rsp]
  000b7	8b 54 24 30	 mov	 edx, DWORD PTR n$[rsp]
  000bb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000c0	e8 00 00 00 00	 call	 my_fgets
  000c5	89 44 24 48	 mov	 DWORD PTR tv86[rsp], eax
  000c9	83 7c 24 48 00	 cmp	 DWORD PTR tv86[rsp], 0
  000ce	74 09		 je	 SHORT $LN9@PyOS_Stdio
  000d0	83 7c 24 48 01	 cmp	 DWORD PTR tv86[rsp], 1
  000d5	74 04		 je	 SHORT $LN8@PyOS_Stdio
  000d7	eb 38		 jmp	 SHORT $LN7@PyOS_Stdio
$LN9@PyOS_Stdio:

; 124  :     case 0: /* Normal case */
; 125  :         break;

  000d9	eb 3e		 jmp	 SHORT $LN10@PyOS_Stdio
$LN8@PyOS_Stdio:

; 126  :     case 1: /* Interrupt */
; 127  :         PyMem_FREE(p);

  000db	e8 00 00 00 00	 call	 _Py_PXCTX
  000e0	85 c0		 test	 eax, eax
  000e2	74 14		 je	 SHORT $LN18@PyOS_Stdio
  000e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000e9	e8 00 00 00 00	 call	 _PxMem_Free
  000ee	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
  000f6	eb 12		 jmp	 SHORT $LN19@PyOS_Stdio
$LN18@PyOS_Stdio:
  000f8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  000fd	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00102	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN19@PyOS_Stdio:

; 128  :         return NULL;

  0010a	33 c0		 xor	 eax, eax
  0010c	e9 2d 02 00 00	 jmp	 $LN14@PyOS_Stdio
$LN7@PyOS_Stdio:

; 129  :     case -1: /* EOF */
; 130  :     case -2: /* Error */
; 131  :     default: /* Shouldn't happen */
; 132  :         *p = '\0';

  00111	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  00116	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN10@PyOS_Stdio:

; 133  :         break;
; 134  :     }
; 135  :     n = strlen(p);

  00119	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0011e	e8 00 00 00 00	 call	 strlen
  00123	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax
$LN6@PyOS_Stdio:

; 136  :     while (n > 0 && p[n-1] != '\n') {

  00128	48 83 7c 24 30
	00		 cmp	 QWORD PTR n$[rsp], 0
  0012e	0f 86 7c 01 00
	00		 jbe	 $LN5@PyOS_Stdio
  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00139	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0013e	48 03 c8	 add	 rcx, rax
  00141	48 8b c1	 mov	 rax, rcx
  00144	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  00148	83 f8 0a	 cmp	 eax, 10
  0014b	0f 84 5f 01 00
	00		 je	 $LN5@PyOS_Stdio

; 137  :         size_t incr = n+2;

  00151	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00156	48 83 c0 02	 add	 rax, 2
  0015a	48 89 44 24 38	 mov	 QWORD PTR incr$63718[rsp], rax

; 138  :         if (incr > INT_MAX) {

  0015f	48 81 7c 24 38
	ff ff ff 7f	 cmp	 QWORD PTR incr$63718[rsp], 2147483647 ; 7fffffffH
  00168	76 49		 jbe	 SHORT $LN4@PyOS_Stdio

; 139  :             PyMem_FREE(p);

  0016a	e8 00 00 00 00	 call	 _Py_PXCTX
  0016f	85 c0		 test	 eax, eax
  00171	74 14		 je	 SHORT $LN20@PyOS_Stdio
  00173	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00178	e8 00 00 00 00	 call	 _PxMem_Free
  0017d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
  00185	eb 12		 jmp	 SHORT $LN21@PyOS_Stdio
$LN20@PyOS_Stdio:
  00187	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0018c	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00191	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
$LN21@PyOS_Stdio:

; 140  :             PyErr_SetString(PyExc_OverflowError, "input line too long");

  00199	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@LNELFCP@input?5line?5too?5long?$AA@
  001a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_OverflowError
  001a7	e8 00 00 00 00	 call	 PyErr_SetString

; 141  :             return NULL;

  001ac	33 c0		 xor	 eax, eax
  001ae	e9 8b 01 00 00	 jmp	 $LN14@PyOS_Stdio
$LN4@PyOS_Stdio:

; 142  :         }
; 143  :         pr = (char *)PyMem_REALLOC(p, n + incr);

  001b3	e8 00 00 00 00	 call	 _Py_PXCTX
  001b8	85 c0		 test	 eax, eax
  001ba	74 24		 je	 SHORT $LN22@PyOS_Stdio
  001bc	48 8b 44 24 38	 mov	 rax, QWORD PTR incr$63718[rsp]
  001c1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  001c6	48 03 c8	 add	 rcx, rax
  001c9	48 8b c1	 mov	 rax, rcx
  001cc	48 8b d0	 mov	 rdx, rax
  001cf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001d4	e8 00 00 00 00	 call	 _PxMem_Realloc
  001d9	48 89 44 24 58	 mov	 QWORD PTR tv152[rsp], rax
  001de	eb 22		 jmp	 SHORT $LN23@PyOS_Stdio
$LN22@PyOS_Stdio:
  001e0	48 8b 44 24 38	 mov	 rax, QWORD PTR incr$63718[rsp]
  001e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  001ea	48 03 c8	 add	 rcx, rax
  001ed	48 8b c1	 mov	 rax, rcx
  001f0	48 8b d0	 mov	 rdx, rax
  001f3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001f8	e8 00 00 00 00	 call	 _PyMem_DebugRealloc
  001fd	48 89 44 24 58	 mov	 QWORD PTR tv152[rsp], rax
$LN23@PyOS_Stdio:
  00202	48 8b 44 24 58	 mov	 rax, QWORD PTR tv152[rsp]
  00207	48 89 44 24 28	 mov	 QWORD PTR pr$[rsp], rax

; 144  :         if (pr == NULL) {

  0020c	48 83 7c 24 28
	00		 cmp	 QWORD PTR pr$[rsp], 0
  00212	75 3b		 jne	 SHORT $LN3@PyOS_Stdio

; 145  :             PyMem_FREE(p);

  00214	e8 00 00 00 00	 call	 _Py_PXCTX
  00219	85 c0		 test	 eax, eax
  0021b	74 14		 je	 SHORT $LN24@PyOS_Stdio
  0021d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00222	e8 00 00 00 00	 call	 _PxMem_Free
  00227	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
  0022f	eb 12		 jmp	 SHORT $LN25@PyOS_Stdio
$LN24@PyOS_Stdio:
  00231	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00236	e8 00 00 00 00	 call	 _PyMem_DebugFree
  0023b	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN25@PyOS_Stdio:

; 146  :             PyErr_NoMemory();

  00243	e8 00 00 00 00	 call	 PyErr_NoMemory

; 147  :             return NULL;

  00248	33 c0		 xor	 eax, eax
  0024a	e9 ef 00 00 00	 jmp	 $LN14@PyOS_Stdio
$LN3@PyOS_Stdio:

; 148  :         }
; 149  :         p = pr;

  0024f	48 8b 44 24 28	 mov	 rax, QWORD PTR pr$[rsp]
  00254	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 150  :         if (my_fgets(p+n, (int)incr, sys_stdin) != 0)

  00259	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  0025e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00263	48 03 c8	 add	 rcx, rax
  00266	48 8b c1	 mov	 rax, rcx
  00269	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR sys_stdin$[rsp]
  00271	8b 54 24 38	 mov	 edx, DWORD PTR incr$63718[rsp]
  00275	48 8b c8	 mov	 rcx, rax
  00278	e8 00 00 00 00	 call	 my_fgets
  0027d	85 c0		 test	 eax, eax
  0027f	74 02		 je	 SHORT $LN2@PyOS_Stdio

; 151  :             break;

  00281	eb 2d		 jmp	 SHORT $LN5@PyOS_Stdio
$LN2@PyOS_Stdio:

; 152  :         n += strlen(p+n);

  00283	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  00288	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0028d	48 03 c8	 add	 rcx, rax
  00290	48 8b c1	 mov	 rax, rcx
  00293	48 8b c8	 mov	 rcx, rax
  00296	e8 00 00 00 00	 call	 strlen
  0029b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR n$[rsp]
  002a0	48 03 c8	 add	 rcx, rax
  002a3	48 8b c1	 mov	 rax, rcx
  002a6	48 89 44 24 30	 mov	 QWORD PTR n$[rsp], rax

; 153  :     }

  002ab	e9 78 fe ff ff	 jmp	 $LN6@PyOS_Stdio
$LN5@PyOS_Stdio:

; 154  :     pr = (char *)PyMem_REALLOC(p, n+1);

  002b0	e8 00 00 00 00	 call	 _Py_PXCTX
  002b5	85 c0		 test	 eax, eax
  002b7	74 1c		 je	 SHORT $LN26@PyOS_Stdio
  002b9	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  002be	48 ff c0	 inc	 rax
  002c1	48 8b d0	 mov	 rdx, rax
  002c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  002c9	e8 00 00 00 00	 call	 _PxMem_Realloc
  002ce	48 89 44 24 68	 mov	 QWORD PTR tv179[rsp], rax
  002d3	eb 1a		 jmp	 SHORT $LN27@PyOS_Stdio
$LN26@PyOS_Stdio:
  002d5	48 8b 44 24 30	 mov	 rax, QWORD PTR n$[rsp]
  002da	48 ff c0	 inc	 rax
  002dd	48 8b d0	 mov	 rdx, rax
  002e0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  002e5	e8 00 00 00 00	 call	 _PyMem_DebugRealloc
  002ea	48 89 44 24 68	 mov	 QWORD PTR tv179[rsp], rax
$LN27@PyOS_Stdio:
  002ef	48 8b 44 24 68	 mov	 rax, QWORD PTR tv179[rsp]
  002f4	48 89 44 24 28	 mov	 QWORD PTR pr$[rsp], rax

; 155  :     if (pr == NULL) {

  002f9	48 83 7c 24 28
	00		 cmp	 QWORD PTR pr$[rsp], 0
  002ff	75 38		 jne	 SHORT $LN1@PyOS_Stdio

; 156  :         PyMem_FREE(p);

  00301	e8 00 00 00 00	 call	 _Py_PXCTX
  00306	85 c0		 test	 eax, eax
  00308	74 14		 je	 SHORT $LN28@PyOS_Stdio
  0030a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0030f	e8 00 00 00 00	 call	 _PxMem_Free
  00314	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
  0031c	eb 12		 jmp	 SHORT $LN29@PyOS_Stdio
$LN28@PyOS_Stdio:
  0031e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00323	e8 00 00 00 00	 call	 _PyMem_DebugFree
  00328	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN29@PyOS_Stdio:

; 157  :         PyErr_NoMemory();

  00330	e8 00 00 00 00	 call	 PyErr_NoMemory

; 158  :         return NULL;

  00335	33 c0		 xor	 eax, eax
  00337	eb 05		 jmp	 SHORT $LN14@PyOS_Stdio
$LN1@PyOS_Stdio:

; 159  :     }
; 160  :     return pr;

  00339	48 8b 44 24 28	 mov	 rax, QWORD PTR pr$[rsp]
$LN14@PyOS_Stdio:

; 161  : }

  0033e	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00345	c3		 ret	 0
PyOS_StdioReadline ENDP
_TEXT	ENDS
EXTRN	PyOS_InterruptOccurred:PROC
EXTRN	PyEval_SaveThread:PROC
EXTRN	PyErr_CheckSignals:PROC
EXTRN	PyEval_RestoreThread:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_ResetEvent:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	_PyOS_SigintEvent:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_fgets:PROC
EXTRN	_PyVerify_fd:PROC
EXTRN	__imp_fileno:PROC
EXTRN	__imp_clearerr:PROC
EXTRN	__imp__errno:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$my_fgets DD imagerel my_fgets
	DD	imagerel my_fgets+355
	DD	imagerel $unwind$my_fgets
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$my_fgets DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT my_fgets
_TEXT	SEGMENT
p$ = 32
hInterruptEvent$ = 40
err$ = 48
s$63684 = 52
tv85 = 56
buf$ = 80
len$ = 88
fp$ = 96
my_fgets PROC						; COMDAT

; 37   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN15@my_fgets:

; 38   : #ifdef MS_WINDOWS
; 39   :     HANDLE hInterruptEvent;
; 40   : #endif
; 41   :     char *p;
; 42   :     int err;
; 43   :     while (1) {

  00012	33 c0		 xor	 eax, eax
  00014	83 f8 01	 cmp	 eax, 1
  00017	0f 84 41 01 00
	00		 je	 $LN14@my_fgets

; 44   :         if (PyOS_InputHook != NULL)

  0001d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR PyOS_InputHook, 0
  00025	74 06		 je	 SHORT $LN13@my_fgets

; 45   :             (void)(PyOS_InputHook)();

  00027	ff 15 00 00 00
	00		 call	 QWORD PTR PyOS_InputHook
$LN13@my_fgets:

; 46   :         errno = 0;

  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 47   :         clearerr(fp);

  00039	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clearerr

; 48   :         if (_PyVerify_fd(fileno(fp)))

  00044	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  0004f	8b c8		 mov	 ecx, eax
  00051	e8 00 00 00 00	 call	 _PyVerify_fd
  00056	85 c0		 test	 eax, eax
  00058	74 1b		 je	 SHORT $LN12@my_fgets

; 49   :             p = fgets(buf, len, fp);

  0005a	4c 8b 44 24 60	 mov	 r8, QWORD PTR fp$[rsp]
  0005f	8b 54 24 58	 mov	 edx, DWORD PTR len$[rsp]
  00063	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buf$[rsp]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  0006e	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 50   :         else

  00073	eb 09		 jmp	 SHORT $LN11@my_fgets
$LN12@my_fgets:

; 51   :             p = NULL;

  00075	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR p$[rsp], 0
$LN11@my_fgets:

; 52   :         if (p != NULL)

  0007e	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$[rsp], 0
  00084	74 07		 je	 SHORT $LN10@my_fgets

; 53   :             return 0; /* No error */

  00086	33 c0		 xor	 eax, eax
  00088	e9 d1 00 00 00	 jmp	 $LN16@my_fgets
$LN10@my_fgets:

; 54   :         err = errno;

  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00093	8b 00		 mov	 eax, DWORD PTR [rax]
  00095	89 44 24 30	 mov	 DWORD PTR err$[rsp], eax

; 55   : #ifdef MS_WINDOWS
; 56   :         /* Ctrl-C anywhere on the line or Ctrl-Z if the only character
; 57   :            on a line will set ERROR_OPERATION_ABORTED. Under normal
; 58   :            circumstances Ctrl-C will also have caused the SIGINT handler
; 59   :            to fire which will have set the event object returned by
; 60   :            _PyOS_SigintEvent. This signal fires in another thread and
; 61   :            is not guaranteed to have occurred before this point in the
; 62   :            code.
; 63   : 
; 64   :            Therefore: check whether the event is set with a small timeout.
; 65   :            If it is, assume this is a Ctrl-C and reset the event. If it
; 66   :            isn't set assume that this is a Ctrl-Z on its own and drop
; 67   :            through to check for EOF.
; 68   :         */
; 69   :         if (GetLastError()==ERROR_OPERATION_ABORTED) {

  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0009f	3d e3 03 00 00	 cmp	 eax, 995		; 000003e3H
  000a4	75 47		 jne	 SHORT $LN9@my_fgets

; 70   :             hInterruptEvent = _PyOS_SigintEvent();

  000a6	e8 00 00 00 00	 call	 _PyOS_SigintEvent
  000ab	48 89 44 24 28	 mov	 QWORD PTR hInterruptEvent$[rsp], rax

; 71   :             switch (WaitForSingleObject(hInterruptEvent, 10)) {

  000b0	ba 0a 00 00 00	 mov	 edx, 10
  000b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hInterruptEvent$[rsp]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  000c0	89 44 24 38	 mov	 DWORD PTR tv85[rsp], eax
  000c4	83 7c 24 38 00	 cmp	 DWORD PTR tv85[rsp], 0
  000c9	74 09		 je	 SHORT $LN6@my_fgets
  000cb	83 7c 24 38 ff	 cmp	 DWORD PTR tv85[rsp], -1	; ffffffffH
  000d0	74 14		 je	 SHORT $LN5@my_fgets
  000d2	eb 19		 jmp	 SHORT $LN7@my_fgets
$LN6@my_fgets:

; 72   :             case WAIT_OBJECT_0:
; 73   :                 ResetEvent(hInterruptEvent);

  000d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hInterruptEvent$[rsp]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ResetEvent

; 74   :                 return 1; /* Interrupt */

  000df	b8 01 00 00 00	 mov	 eax, 1
  000e4	eb 78		 jmp	 SHORT $LN16@my_fgets
$LN5@my_fgets:

; 75   :             case WAIT_FAILED:
; 76   :                 return -2; /* Error */

  000e6	b8 fe ff ff ff	 mov	 eax, -2
  000eb	eb 71		 jmp	 SHORT $LN16@my_fgets
$LN7@my_fgets:
$LN9@my_fgets:

; 77   :             }
; 78   :         }
; 79   : #endif /* MS_WINDOWS */
; 80   :         if (feof(fp)) {

  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  000f8	85 c0		 test	 eax, eax
  000fa	74 12		 je	 SHORT $LN4@my_fgets

; 81   :             clearerr(fp);

  000fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clearerr

; 82   :             return -1; /* EOF */

  00107	b8 ff ff ff ff	 mov	 eax, -1
  0010c	eb 50		 jmp	 SHORT $LN16@my_fgets
$LN4@my_fgets:

; 83   :         }
; 84   : #ifdef EINTR
; 85   :         if (err == EINTR) {

  0010e	83 7c 24 30 04	 cmp	 DWORD PTR err$[rsp], 4
  00113	75 2d		 jne	 SHORT $LN3@my_fgets

; 86   :             int s;
; 87   : #ifdef WITH_THREAD
; 88   :             PyEval_RestoreThread(_PyOS_ReadlineTState);

  00115	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyOS_ReadlineTState
  0011c	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 89   : #endif
; 90   :             s = PyErr_CheckSignals();

  00121	e8 00 00 00 00	 call	 PyErr_CheckSignals
  00126	89 44 24 34	 mov	 DWORD PTR s$63684[rsp], eax

; 91   : #ifdef WITH_THREAD
; 92   :             PyEval_SaveThread();

  0012a	e8 00 00 00 00	 call	 PyEval_SaveThread

; 93   : #endif
; 94   :             if (s < 0)

  0012f	83 7c 24 34 00	 cmp	 DWORD PTR s$63684[rsp], 0
  00134	7d 07		 jge	 SHORT $LN2@my_fgets

; 95   :                     return 1;

  00136	b8 01 00 00 00	 mov	 eax, 1
  0013b	eb 21		 jmp	 SHORT $LN16@my_fgets
$LN2@my_fgets:

; 96   :         /* try again */
; 97   :             continue;

  0013d	e9 d0 fe ff ff	 jmp	 $LN15@my_fgets
$LN3@my_fgets:

; 98   :         }
; 99   : #endif
; 100  :         if (PyOS_InterruptOccurred()) {

  00142	e8 00 00 00 00	 call	 PyOS_InterruptOccurred
  00147	85 c0		 test	 eax, eax
  00149	74 07		 je	 SHORT $LN1@my_fgets

; 101  :             return 1; /* Interrupt */

  0014b	b8 01 00 00 00	 mov	 eax, 1
  00150	eb 0c		 jmp	 SHORT $LN16@my_fgets
$LN1@my_fgets:

; 102  :         }
; 103  :         return -2; /* Error */

  00152	b8 fe ff ff ff	 mov	 eax, -2
  00157	eb 05		 jmp	 SHORT $LN16@my_fgets

; 104  :     }

  00159	e9 b4 fe ff ff	 jmp	 $LN15@my_fgets
$LN14@my_fgets:
$LN16@my_fgets:

; 105  :     /* NOTREACHED */
; 106  : }

  0015e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00162	c3		 ret	 0
my_fgets ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BI@GIJGGCON@can?8t?5re?9enter?5readline?$AA@ ; `string'
PUBLIC	PyOS_Readline
EXTRN	PyThread_release_lock:PROC
EXTRN	__imp_isatty:PROC
EXTRN	PyThread_acquire_lock:PROC
EXTRN	PyThread_allocate_lock:PROC
EXTRN	PyExc_RuntimeError:QWORD
EXTRN	PyThreadState_Get:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyOS_Readline DD imagerel $LN9
	DD	imagerel $LN9+266
	DD	imagerel $unwind$PyOS_Readline
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyOS_Readline DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT ??_C@_0BI@GIJGGCON@can?8t?5re?9enter?5readline?$AA@
CONST	SEGMENT
??_C@_0BI@GIJGGCON@can?8t?5re?9enter?5readline?$AA@ DB 'can''t re-enter r'
	DB	'eadline', 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyOS_Readline
_TEXT	SEGMENT
rv$ = 32
sys_stdin$ = 64
sys_stdout$ = 72
prompt$ = 80
PyOS_Readline PROC					; COMDAT

; 176  : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 177  :     char *rv;
; 178  : 
; 179  :     if (_PyOS_ReadlineTState == PyThreadState_GET()) {

  00013	e8 00 00 00 00	 call	 PyThreadState_Get
  00018	48 39 05 00 00
	00 00		 cmp	 QWORD PTR _PyOS_ReadlineTState, rax
  0001f	75 1a		 jne	 SHORT $LN6@PyOS_Readl

; 180  :         PyErr_SetString(PyExc_RuntimeError,
; 181  :                         "can't re-enter readline");

  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@GIJGGCON@can?8t?5re?9enter?5readline?$AA@
  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_RuntimeError
  0002f	e8 00 00 00 00	 call	 PyErr_SetString

; 182  :         return NULL;

  00034	33 c0		 xor	 eax, eax
  00036	e9 ca 00 00 00	 jmp	 $LN7@PyOS_Readl
$LN6@PyOS_Readl:

; 183  :     }
; 184  : 
; 185  : 
; 186  :     if (PyOS_ReadlineFunctionPointer == NULL) {

  0003b	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR PyOS_ReadlineFunctionPointer, 0
  00043	75 0e		 jne	 SHORT $LN5@PyOS_Readl

; 187  : #ifdef __VMS
; 188  :         PyOS_ReadlineFunctionPointer = vms__StdioReadline;
; 189  : #else
; 190  :         PyOS_ReadlineFunctionPointer = PyOS_StdioReadline;

  00045	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:PyOS_StdioReadline
  0004c	48 89 05 00 00
	00 00		 mov	 QWORD PTR PyOS_ReadlineFunctionPointer, rax
$LN5@PyOS_Readl:

; 191  : #endif
; 192  :     }
; 193  : 
; 194  : #ifdef WITH_THREAD
; 195  :     if (_PyOS_ReadlineLock == NULL) {

  00053	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR _PyOS_ReadlineLock, 0
  0005b	75 0c		 jne	 SHORT $LN4@PyOS_Readl

; 196  :         _PyOS_ReadlineLock = PyThread_allocate_lock();

  0005d	e8 00 00 00 00	 call	 PyThread_allocate_lock
  00062	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyOS_ReadlineLock, rax
$LN4@PyOS_Readl:

; 197  :     }
; 198  : #endif
; 199  : 
; 200  :     _PyOS_ReadlineTState = PyThreadState_GET();

  00069	e8 00 00 00 00	 call	 PyThreadState_Get
  0006e	48 89 05 00 00
	00 00		 mov	 QWORD PTR _PyOS_ReadlineTState, rax

; 201  :     /*
; 202  :     Py_BEGIN_ALLOW_THREADS
; 203  :     */
; 204  : #ifdef WITH_THREAD
; 205  :     PyThread_acquire_lock(_PyOS_ReadlineLock, 1);

  00075	ba 01 00 00 00	 mov	 edx, 1
  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyOS_ReadlineLock
  00081	e8 00 00 00 00	 call	 PyThread_acquire_lock

; 206  : #endif
; 207  : 
; 208  :     /* This is needed to handle the unlikely case that the
; 209  :      * interpreter is in interactive mode *and* stdin/out are not
; 210  :      * a tty.  This can happen, for example if python is run like
; 211  :      * this: python -i < test1.py
; 212  :      */
; 213  :     if (!isatty (fileno (sys_stdin)) || !isatty (fileno (sys_stdout)))

  00086	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sys_stdin$[rsp]
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  00091	8b c8		 mov	 ecx, eax
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  00099	85 c0		 test	 eax, eax
  0009b	74 17		 je	 SHORT $LN2@PyOS_Readl
  0009d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sys_stdout$[rsp]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  000a8	8b c8		 mov	 ecx, eax
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  000b0	85 c0		 test	 eax, eax
  000b2	75 1b		 jne	 SHORT $LN3@PyOS_Readl
$LN2@PyOS_Readl:

; 214  :         rv = PyOS_StdioReadline (sys_stdin, sys_stdout, prompt);

  000b4	4c 8b 44 24 50	 mov	 r8, QWORD PTR prompt$[rsp]
  000b9	48 8b 54 24 48	 mov	 rdx, QWORD PTR sys_stdout$[rsp]
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sys_stdin$[rsp]
  000c3	e8 00 00 00 00	 call	 PyOS_StdioReadline
  000c8	48 89 44 24 20	 mov	 QWORD PTR rv$[rsp], rax

; 215  :     else

  000cd	eb 1a		 jmp	 SHORT $LN1@PyOS_Readl
$LN3@PyOS_Readl:

; 216  :         rv = (*PyOS_ReadlineFunctionPointer)(sys_stdin, sys_stdout,
; 217  :                                              prompt);

  000cf	4c 8b 44 24 50	 mov	 r8, QWORD PTR prompt$[rsp]
  000d4	48 8b 54 24 48	 mov	 rdx, QWORD PTR sys_stdout$[rsp]
  000d9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sys_stdin$[rsp]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR PyOS_ReadlineFunctionPointer
  000e4	48 89 44 24 20	 mov	 QWORD PTR rv$[rsp], rax
$LN1@PyOS_Readl:

; 218  :     /*
; 219  :     Py_END_ALLOW_THREADS
; 220  :     */
; 221  : 
; 222  : #ifdef WITH_THREAD
; 223  :     PyThread_release_lock(_PyOS_ReadlineLock);

  000e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR _PyOS_ReadlineLock
  000f0	e8 00 00 00 00	 call	 PyThread_release_lock

; 224  : #endif
; 225  : 
; 226  :     _PyOS_ReadlineTState = NULL;

  000f5	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR _PyOS_ReadlineTState, 0

; 227  : 
; 228  :     return rv;

  00100	48 8b 44 24 20	 mov	 rax, QWORD PTR rv$[rsp]
$LN7@PyOS_Readl:

; 229  : }

  00105	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00109	c3		 ret	 0
PyOS_Readline ENDP
_TEXT	ENDS
END
