; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
CONST	ENDS
PUBLIC	inflateReset
;	COMDAT pdata
; File c:\src\pyparallel\modules\zlib\inflate.c
pdata	SEGMENT
$pdata$inflateReset DD imagerel $LN5
	DD	imagerel $LN5+314
	DD	imagerel $unwind$inflateReset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateReset
_TEXT	SEGMENT
state$ = 0
tv85 = 8
strm$ = 32
inflateReset PROC					; COMDAT

; 105  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN1@inflateRes
  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 0a		 jne	 SHORT $LN2@inflateRes
$LN1@inflateRes:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	e9 0e 01 00 00	 jmp	 $LN3@inflateRes
$LN2@inflateRes:

; 109  :     state = (struct inflate_state FAR *)strm->state;

  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00030	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 110  :     strm->total_in = strm->total_out = state->total = 0;

  00034	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00038	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00044	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 111  :     strm->msg = Z_NULL;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0005c	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 112  :     strm->adler = 1;        /* to support ill-conceived Java test suite */

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00069	c7 40 4c 01 00
	00 00		 mov	 DWORD PTR [rax+76], 1

; 113  :     state->mode = HEAD;

  00070	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00074	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 114  :     state->last = 0;

  0007a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0007e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 115  :     state->havedict = 0;

  00085	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00089	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 116  :     state->dmax = 32768U;

  00090	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00094	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [rax+20], 32768 ; 00008000H

; 117  :     state->head = Z_NULL;

  0009b	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0009f	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 118  :     state->wsize = 0;

  000a7	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000ab	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [rax+44], 0

; 119  :     state->whave = 0;

  000b2	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000b6	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 120  :     state->wnext = 0;

  000bd	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000c1	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 121  :     state->hold = 0;

  000c8	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000cc	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 122  :     state->bits = 0;

  000d3	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000d7	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [rax+68], 0

; 123  :     state->lencode = state->distcode = state->next = state->codes;

  000de	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000e2	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  000e8	48 89 44 24 08	 mov	 QWORD PTR tv85[rsp], rax
  000ed	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000f1	48 8b 4c 24 08	 mov	 rcx, QWORD PTR tv85[rsp]
  000f6	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx
  000fd	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00101	48 8b 4c 24 08	 mov	 rcx, QWORD PTR tv85[rsp]
  00106	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
  0010a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0010e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR tv85[rsp]
  00113	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 124  :     state->sane = 1;

  00117	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0011b	c7 80 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7128], 1

; 125  :     state->back = -1;

  00125	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00129	c7 80 dc 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+7132], -1

; 126  :     Tracev((stderr, "inflate: reset\n"));
; 127  :     return Z_OK;

  00133	33 c0		 xor	 eax, eax
$LN3@inflateRes:

; 128  : }

  00135	48 83 c4 18	 add	 rsp, 24
  00139	c3		 ret	 0
inflateReset ENDP
_TEXT	ENDS
PUBLIC	inflateReset2
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN11
	DD	imagerel $LN11+247
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateReset2
_TEXT	SEGMENT
wrap$ = 32
state$ = 40
strm$ = 64
windowBits$ = 72
inflateReset2 PROC					; COMDAT

; 133  : {

$LN11:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 134  :     int wrap;
; 135  :     struct inflate_state FAR *state;
; 136  : 
; 137  :     /* get the state */
; 138  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000d	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00013	74 0c		 je	 SHORT $LN7@inflateRes@2
  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0001a	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001f	75 0a		 jne	 SHORT $LN8@inflateRes@2
$LN7@inflateRes@2:
  00021	b8 fe ff ff ff	 mov	 eax, -2
  00026	e9 c7 00 00 00	 jmp	 $LN9@inflateRes@2
$LN8@inflateRes@2:

; 139  :     state = (struct inflate_state FAR *)strm->state;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00030	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00034	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 140  : 
; 141  :     /* extract wrap request from windowBits parameter */
; 142  :     if (windowBits < 0) {

  00039	83 7c 24 48 00	 cmp	 DWORD PTR windowBits$[rsp], 0
  0003e	7d 14		 jge	 SHORT $LN6@inflateRes@2

; 143  :         wrap = 0;

  00040	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 0

; 144  :         windowBits = -windowBits;

  00048	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  0004c	f7 d8		 neg	 eax
  0004e	89 44 24 48	 mov	 DWORD PTR windowBits$[rsp], eax

; 145  :     }
; 146  :     else {

  00052	eb 1f		 jmp	 SHORT $LN5@inflateRes@2
$LN6@inflateRes@2:

; 147  :         wrap = (windowBits >> 4) + 1;

  00054	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  00058	c1 f8 04	 sar	 eax, 4
  0005b	ff c0		 inc	 eax
  0005d	89 44 24 20	 mov	 DWORD PTR wrap$[rsp], eax

; 148  : #ifdef GUNZIP
; 149  :         if (windowBits < 48)

  00061	83 7c 24 48 30	 cmp	 DWORD PTR windowBits$[rsp], 48 ; 00000030H
  00066	7d 0b		 jge	 SHORT $LN4@inflateRes@2

; 150  :             windowBits &= 15;

  00068	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  0006c	83 e0 0f	 and	 eax, 15
  0006f	89 44 24 48	 mov	 DWORD PTR windowBits$[rsp], eax
$LN4@inflateRes@2:
$LN5@inflateRes@2:

; 151  : #endif
; 152  :     }
; 153  : 
; 154  :     /* set number of window bits, free window if different */
; 155  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00073	83 7c 24 48 00	 cmp	 DWORD PTR windowBits$[rsp], 0
  00078	74 15		 je	 SHORT $LN3@inflateRes@2
  0007a	83 7c 24 48 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  0007f	7c 07		 jl	 SHORT $LN2@inflateRes@2
  00081	83 7c 24 48 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  00086	7e 07		 jle	 SHORT $LN3@inflateRes@2
$LN2@inflateRes@2:

; 156  :         return Z_STREAM_ERROR;

  00088	b8 fe ff ff ff	 mov	 eax, -2
  0008d	eb 63		 jmp	 SHORT $LN9@inflateRes@2
$LN3@inflateRes@2:

; 157  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  0008f	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00094	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00099	74 35		 je	 SHORT $LN1@inflateRes@2
  0009b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000a0	8b 4c 24 48	 mov	 ecx, DWORD PTR windowBits$[rsp]
  000a4	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  000a7	74 27		 je	 SHORT $LN1@inflateRes@2

; 158  :         ZFREE(strm, state->window);

  000a9	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000ae	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000b7	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000bb	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c0	ff 50 38	 call	 QWORD PTR [rax+56]

; 159  :         state->window = Z_NULL;

  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000c8	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0
$LN1@inflateRes@2:

; 160  :     }
; 161  : 
; 162  :     /* update state and reset the rest of it */
; 163  :     state->wrap = wrap;

  000d0	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000d5	8b 4c 24 20	 mov	 ecx, DWORD PTR wrap$[rsp]
  000d9	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 164  :     state->wbits = (unsigned)windowBits;

  000dc	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000e1	8b 4c 24 48	 mov	 ecx, DWORD PTR windowBits$[rsp]
  000e5	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 165  :     return inflateReset(strm);

  000e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000ed	e8 00 00 00 00	 call	 inflateReset
$LN9@inflateRes@2:

; 166  : }

  000f2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f6	c3		 ret	 0
inflateReset2 ENDP
_TEXT	ENDS
PUBLIC	??_C@_05DFCKICEH@1?42?45?$AA@			; `string'
PUBLIC	inflateInit2_
EXTRN	zcfree:PROC
EXTRN	zcalloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN10
	DD	imagerel $LN10+311
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT ??_C@_05DFCKICEH@1?42?45?$AA@
CONST	SEGMENT
??_C@_05DFCKICEH@1?42?45?$AA@ DB '1.2.5', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT inflateInit2_
_TEXT	SEGMENT
ret$ = 32
state$ = 40
strm$ = 64
windowBits$ = 72
version$ = 80
stream_size$ = 88
inflateInit2_ PROC					; COMDAT

; 173  : {

$LN10:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 174  :     int ret;
; 175  :     struct inflate_state FAR *state;
; 176  : 
; 177  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 178  :         stream_size != (int)(sizeof(z_stream)))

  00017	48 83 7c 24 50
	00		 cmp	 QWORD PTR version$[rsp], 0
  0001d	74 1a		 je	 SHORT $LN6@inflateIni
  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR version$[rsp]
  00024	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00027	0f be 0d 00 00
	00 00		 movsx	 ecx, BYTE PTR ??_C@_05DFCKICEH@1?42?45?$AA@
  0002e	3b c1		 cmp	 eax, ecx
  00030	75 07		 jne	 SHORT $LN6@inflateIni
  00032	83 7c 24 58 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  00037	74 0a		 je	 SHORT $LN7@inflateIni
$LN6@inflateIni:

; 179  :         return Z_VERSION_ERROR;

  00039	b8 fa ff ff ff	 mov	 eax, -6
  0003e	e9 ef 00 00 00	 jmp	 $LN8@inflateIni
$LN7@inflateIni:

; 180  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00049	75 0a		 jne	 SHORT $LN5@inflateIni
  0004b	b8 fe ff ff ff	 mov	 eax, -2
  00050	e9 dd 00 00 00	 jmp	 $LN8@inflateIni
$LN5@inflateIni:

; 181  :     strm->msg = Z_NULL;                 /* in case we return an error */

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0005a	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 182  :     if (strm->zalloc == (alloc_func)0) {

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00067	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0006c	75 1d		 jne	 SHORT $LN4@inflateIni

; 183  :         strm->zalloc = zcalloc;

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcalloc
  0007a	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 184  :         strm->opaque = (voidpf)0;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00083	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN4@inflateIni:

; 185  :     }
; 186  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00090	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00095	75 10		 jne	 SHORT $LN3@inflateIni
  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zcfree
  000a3	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN3@inflateIni:

; 187  :     state = (struct inflate_state FAR *)
; 188  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  000a7	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  000ad	ba 01 00 00 00	 mov	 edx, 1
  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000b7	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000bb	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c0	ff 50 30	 call	 QWORD PTR [rax+48]
  000c3	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 189  :     if (state == Z_NULL) return Z_MEM_ERROR;

  000c8	48 83 7c 24 28
	00		 cmp	 QWORD PTR state$[rsp], 0
  000ce	75 07		 jne	 SHORT $LN2@inflateIni
  000d0	b8 fc ff ff ff	 mov	 eax, -4
  000d5	eb 5b		 jmp	 SHORT $LN8@inflateIni
$LN2@inflateIni:

; 190  :     Tracev((stderr, "inflate: allocated\n"));
; 191  :     strm->state = (struct internal_state FAR *)state;

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000e1	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 192  :     state->window = Z_NULL;

  000e5	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000ea	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 193  :     ret = inflateReset2(strm, windowBits);

  000f2	8b 54 24 48	 mov	 edx, DWORD PTR windowBits$[rsp]
  000f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000fb	e8 00 00 00 00	 call	 inflateReset2
  00100	89 44 24 20	 mov	 DWORD PTR ret$[rsp], eax

; 194  :     if (ret != Z_OK) {

  00104	83 7c 24 20 00	 cmp	 DWORD PTR ret$[rsp], 0
  00109	74 23		 je	 SHORT $LN1@inflateIni

; 195  :         ZFREE(strm, state);

  0010b	48 8b 54 24 28	 mov	 rdx, QWORD PTR state$[rsp]
  00110	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00115	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00119	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0011e	ff 50 38	 call	 QWORD PTR [rax+56]

; 196  :         strm->state = Z_NULL;

  00121	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00126	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0
$LN1@inflateIni:

; 197  :     }
; 198  :     return ret;

  0012e	8b 44 24 20	 mov	 eax, DWORD PTR ret$[rsp]
$LN8@inflateIni:

; 199  : }

  00132	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00136	c3		 ret	 0
inflateInit2_ ENDP
_TEXT	ENDS
PUBLIC	inflateInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit_ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$inflateInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit_ DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 48
version$ = 56
stream_size$ = 64
inflateInit_ PROC					; COMDAT

; 205  : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 206  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00013	44 8b 4c 24 40	 mov	 r9d, DWORD PTR stream_size$[rsp]
  00018	4c 8b 44 24 38	 mov	 r8, QWORD PTR version$[rsp]
  0001d	ba 0f 00 00 00	 mov	 edx, 15
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strm$[rsp]
  00027	e8 00 00 00 00	 call	 inflateInit2_

; 207  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
inflateInit_ ENDP
_TEXT	ENDS
PUBLIC	inflatePrime
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflatePrime DD imagerel $LN8
	DD	imagerel $LN8+215
	DD	imagerel $unwind$inflatePrime
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflatePrime DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflatePrime
_TEXT	SEGMENT
state$ = 0
tv132 = 8
strm$ = 32
bits$ = 40
value$ = 48
inflatePrime PROC					; COMDAT

; 213  : {

$LN8:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 214  :     struct inflate_state FAR *state;
; 215  : 
; 216  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00012	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00018	74 0c		 je	 SHORT $LN4@inflatePri
  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0001f	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00024	75 0a		 jne	 SHORT $LN5@inflatePri
$LN4@inflatePri:
  00026	b8 fe ff ff ff	 mov	 eax, -2
  0002b	e9 a2 00 00 00	 jmp	 $LN6@inflatePri
$LN5@inflatePri:

; 217  :     state = (struct inflate_state FAR *)strm->state;

  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00035	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00039	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 218  :     if (bits < 0) {

  0003d	83 7c 24 28 00	 cmp	 DWORD PTR bits$[rsp], 0
  00042	7d 1a		 jge	 SHORT $LN3@inflatePri

; 219  :         state->hold = 0;

  00044	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00048	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 220  :         state->bits = 0;

  0004f	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00053	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [rax+68], 0

; 221  :         return Z_OK;

  0005a	33 c0		 xor	 eax, eax
  0005c	eb 74		 jmp	 SHORT $LN6@inflatePri
$LN3@inflatePri:

; 222  :     }
; 223  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0005e	83 7c 24 28 10	 cmp	 DWORD PTR bits$[rsp], 16
  00063	7f 10		 jg	 SHORT $LN1@inflatePri
  00065	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00069	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0006c	03 44 24 28	 add	 eax, DWORD PTR bits$[rsp]
  00070	83 f8 20	 cmp	 eax, 32			; 00000020H
  00073	76 07		 jbe	 SHORT $LN2@inflatePri
$LN1@inflatePri:
  00075	b8 fe ff ff ff	 mov	 eax, -2
  0007a	eb 56		 jmp	 SHORT $LN6@inflatePri
$LN2@inflatePri:

; 224  :     value &= (1L << bits) - 1;

  0007c	8b 44 24 28	 mov	 eax, DWORD PTR bits$[rsp]
  00080	b9 01 00 00 00	 mov	 ecx, 1
  00085	89 4c 24 08	 mov	 DWORD PTR tv132[rsp], ecx
  00089	0f b6 c8	 movzx	 ecx, al
  0008c	8b 44 24 08	 mov	 eax, DWORD PTR tv132[rsp]
  00090	d3 e0		 shl	 eax, cl
  00092	ff c8		 dec	 eax
  00094	8b 4c 24 30	 mov	 ecx, DWORD PTR value$[rsp]
  00098	23 c8		 and	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	89 44 24 30	 mov	 DWORD PTR value$[rsp], eax

; 225  :     state->hold += value << state->bits;

  000a0	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000a4	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000a7	0f b6 c8	 movzx	 ecx, al
  000aa	8b 44 24 30	 mov	 eax, DWORD PTR value$[rsp]
  000ae	d3 e0		 shl	 eax, cl
  000b0	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  000b4	03 41 40	 add	 eax, DWORD PTR [rcx+64]
  000b7	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  000bb	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 226  :     state->bits += bits;

  000be	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000c2	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000c5	03 44 24 28	 add	 eax, DWORD PTR bits$[rsp]
  000c9	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  000cd	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 227  :     return Z_OK;

  000d0	33 c0		 xor	 eax, eax
$LN6@inflatePri:

; 228  : }

  000d2	48 83 c4 18	 add	 rsp, 24
  000d6	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	inflate
EXTRN	inflate_fast:PROC
EXTRN	inflate_table:PROC
EXTRN	memcpy:PROC
EXTRN	adler32:PROC
EXTRN	crc32:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN527
	DD	imagerel $LN527+12420
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 021001H
	DD	0210110H
xdata	ENDS
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT inflate
_TEXT	SEGMENT
put$ = 48
last$ = 56
here$ = 60
have$ = 64
in$ = 68
len$ = 72
bits$ = 76
left$ = 80
next$ = 88
ret$ = 96
hold$ = 100
hbuf$ = 104
copy$ = 108
from$ = 112
out$ = 120
state$ = 128
tv80 = 136
tv1648 = 140
tv178 = 144
tv184 = 148
tv350 = 152
tv494 = 156
tv520 = 160
tv532 = 164
tv561 = 168
tv706 = 176
tv2087 = 184
tv879 = 192
tv900 = 200
tv2263 = 208
tv956 = 212
tv2337 = 216
tv2361 = 220
tv1101 = 224
tv2431 = 228
tv1262 = 232
tv1276 = 236
tv1351 = 240
tv1356 = 244
tv1359 = 248
tv1363 = 252
strm$ = 272
flush$ = 280
inflate	PROC						; COMDAT

; 592  : {

$LN527:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H

; 593  :     struct inflate_state FAR *state;
; 594  :     unsigned char FAR *next;    /* next input */
; 595  :     unsigned char FAR *put;     /* next output */
; 596  :     unsigned have, left;        /* available input and output */
; 597  :     unsigned long hold;         /* bit buffer */
; 598  :     unsigned bits;              /* bits in bit buffer */
; 599  :     unsigned in, out;           /* save starting available input and output */
; 600  :     unsigned copy;              /* number of stored or match bytes to copy */
; 601  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 602  :     code here;                  /* current decoding table entry */
; 603  :     code last;                  /* parent table entry */
; 604  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 605  :     int ret;                    /* return code */
; 606  : #ifdef GUNZIP
; 607  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 608  : #endif
; 609  :     static const unsigned short order[19] = /* permutation of code lengths */
; 610  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 611  : 
; 612  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 613  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00010	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR strm$[rsp], 0
  00019	74 3a		 je	 SHORT $LN506@inflate
  0001b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	74 2b		 je	 SHORT $LN506@inflate
  0002a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00032	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00037	74 1c		 je	 SHORT $LN506@inflate
  00039	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00041	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00045	75 18		 jne	 SHORT $LN507@inflate
  00047	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00053	74 0a		 je	 SHORT $LN507@inflate
$LN506@inflate:

; 614  :         return Z_STREAM_ERROR;

  00055	b8 fe ff ff ff	 mov	 eax, -2
  0005a	e9 9e 2f 00 00	 jmp	 $LN508@inflate
$LN507@inflate:

; 615  : 
; 616  :     state = (struct inflate_state FAR *)strm->state;

  0005f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00067	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0006b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR state$[rsp], rax

; 617  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00073	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0007b	83 38 0b	 cmp	 DWORD PTR [rax], 11
  0007e	75 0e		 jne	 SHORT $LN505@inflate
  00080	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00088	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12
$LN505@inflate:
$LN504@inflate:

; 618  :     LOAD();

  0008e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00096	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009a	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  0009f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000a7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000aa	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax
  000ae	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b9	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  000be	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000c6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000c9	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  000cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000d5	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000d8	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  000dc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000e4	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000e7	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  000eb	33 c0		 xor	 eax, eax
  000ed	85 c0		 test	 eax, eax
  000ef	75 9d		 jne	 SHORT $LN504@inflate

; 619  :     in = have;

  000f1	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  000f5	89 44 24 44	 mov	 DWORD PTR in$[rsp], eax

; 620  :     out = left;

  000f9	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  000fd	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 621  :     ret = Z_OK;

  00101	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0
$LN501@inflate:

; 622  :     for (;;)
; 623  :         switch (state->mode) {

  00109	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00111	8b 00		 mov	 eax, DWORD PTR [rax]
  00113	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv80[rsp], eax
  0011a	83 bc 24 88 00
	00 00 1e	 cmp	 DWORD PTR tv80[rsp], 30
  00122	0f 87 00 2c 00
	00		 ja	 $LN11@inflate
  00128	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR tv80[rsp]
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00137	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN526@inflate[rcx+rax*4]
  0013e	48 03 c1	 add	 rax, rcx
  00141	ff e0		 jmp	 rax
$LN497@inflate:

; 624  :         case HEAD:
; 625  :             if (state->wrap == 0) {

  00143	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0014b	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0014f	75 13		 jne	 SHORT $LN496@inflate

; 626  :                 state->mode = TYPEDO;

  00151	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00159	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 627  :                 break;

  0015f	e9 ce 2b 00 00	 jmp	 $LN498@inflate
$LN496@inflate:
$LN495@inflate:
$LN492@inflate:

; 628  :             }
; 629  :             NEEDBITS(16);

  00164	83 7c 24 4c 10	 cmp	 DWORD PTR bits$[rsp], 16
  00169	73 50		 jae	 SHORT $LN491@inflate
$LN490@inflate:
  0016b	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00170	75 05		 jne	 SHORT $LN487@inflate
  00172	e9 c0 2b 00 00	 jmp	 $inf_leave$4986
$LN487@inflate:
  00177	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0017b	ff c8		 dec	 eax
  0017d	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00181	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00186	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00189	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  0018d	d3 e0		 shl	 eax, cl
  0018f	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00193	03 c8		 add	 ecx, eax
  00195	8b c1		 mov	 eax, ecx
  00197	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0019b	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  001a0	48 ff c0	 inc	 rax
  001a3	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  001a8	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  001ac	83 c0 08	 add	 eax, 8
  001af	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  001b3	33 c0		 xor	 eax, eax
  001b5	85 c0		 test	 eax, eax
  001b7	75 b2		 jne	 SHORT $LN490@inflate
  001b9	eb a9		 jmp	 SHORT $LN492@inflate
$LN491@inflate:
  001bb	33 c0		 xor	 eax, eax
  001bd	85 c0		 test	 eax, eax
  001bf	75 a3		 jne	 SHORT $LN495@inflate

; 630  : #ifdef GUNZIP
; 631  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  001c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  001c9	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001cc	83 e0 02	 and	 eax, 2
  001cf	85 c0		 test	 eax, eax
  001d1	0f 84 8e 00 00
	00		 je	 $LN486@inflate
  001d7	81 7c 24 64 1f
	8b 00 00	 cmp	 DWORD PTR hold$[rsp], 35615 ; 00008b1fH
  001df	0f 85 80 00 00
	00		 jne	 $LN486@inflate

; 632  :                 state->check = crc32(0L, Z_NULL, 0);

  001e5	45 33 c0	 xor	 r8d, r8d
  001e8	33 d2		 xor	 edx, edx
  001ea	33 c9		 xor	 ecx, ecx
  001ec	e8 00 00 00 00	 call	 crc32
  001f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  001f9	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN485@inflate:

; 633  :                 CRC2(state->check, hold);

  001fc	0f b6 44 24 64	 movzx	 eax, BYTE PTR hold$[rsp]
  00201	88 44 24 68	 mov	 BYTE PTR hbuf$[rsp], al
  00205	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00209	c1 e8 08	 shr	 eax, 8
  0020c	88 44 24 69	 mov	 BYTE PTR hbuf$[rsp+1], al
  00210	41 b8 02 00 00
	00		 mov	 r8d, 2
  00216	48 8d 54 24 68	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0021b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00223	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00226	e8 00 00 00 00	 call	 crc32
  0022b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00233	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  00236	33 c0		 xor	 eax, eax
  00238	85 c0		 test	 eax, eax
  0023a	75 c0		 jne	 SHORT $LN485@inflate
$LN482@inflate:

; 634  :                 INITBITS();

  0023c	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00244	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  0024c	33 c0		 xor	 eax, eax
  0024e	85 c0		 test	 eax, eax
  00250	75 ea		 jne	 SHORT $LN482@inflate

; 635  :                 state->mode = FLAGS;

  00252	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0025a	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 636  :                 break;

  00260	e9 cd 2a 00 00	 jmp	 $LN498@inflate
$LN486@inflate:

; 637  :             }
; 638  :             state->flags = 0;           /* expect zlib header */

  00265	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0026d	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 639  :             if (state->head != Z_NULL)

  00274	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0027c	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00281	74 13		 je	 SHORT $LN479@inflate

; 640  :                 state->head->done = -1;

  00283	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0028b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0028f	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN479@inflate:

; 641  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 642  : #else
; 643  :             if (
; 644  : #endif
; 645  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  00296	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0029e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002a1	83 e0 01	 and	 eax, 1
  002a4	85 c0		 test	 eax, eax
  002a6	74 24		 je	 SHORT $LN477@inflate
  002a8	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  002ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002b1	c1 e0 08	 shl	 eax, 8
  002b4	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  002b8	c1 e9 08	 shr	 ecx, 8
  002bb	03 c1		 add	 eax, ecx
  002bd	33 d2		 xor	 edx, edx
  002bf	b9 1f 00 00 00	 mov	 ecx, 31
  002c4	f7 f1		 div	 ecx
  002c6	8b c2		 mov	 eax, edx
  002c8	85 c0		 test	 eax, eax
  002ca	74 26		 je	 SHORT $LN478@inflate
$LN477@inflate:

; 646  :                 strm->msg = (char *)"incorrect header check";

  002cc	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
  002db	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 647  :                 state->mode = BAD;

  002df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  002e7	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 648  :                 break;

  002ed	e9 40 2a 00 00	 jmp	 $LN498@inflate
$LN478@inflate:

; 649  :             }
; 650  :             if (BITS(4) != Z_DEFLATED) {

  002f2	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  002f6	83 e0 0f	 and	 eax, 15
  002f9	83 f8 08	 cmp	 eax, 8
  002fc	74 26		 je	 SHORT $LN476@inflate

; 651  :                 strm->msg = (char *)"unknown compression method";

  002fe	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  0030d	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 652  :                 state->mode = BAD;

  00311	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00319	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 653  :                 break;

  0031f	e9 0e 2a 00 00	 jmp	 $LN498@inflate
$LN476@inflate:
$LN475@inflate:

; 654  :             }
; 655  :             DROPBITS(4);

  00324	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00328	c1 e8 04	 shr	 eax, 4
  0032b	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0032f	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00333	83 e8 04	 sub	 eax, 4
  00336	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0033a	33 c0		 xor	 eax, eax
  0033c	85 c0		 test	 eax, eax
  0033e	75 e4		 jne	 SHORT $LN475@inflate

; 656  :             len = BITS(4) + 8;

  00340	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00344	83 e0 0f	 and	 eax, 15
  00347	83 c0 08	 add	 eax, 8
  0034a	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax

; 657  :             if (state->wbits == 0)

  0034e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00356	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  0035a	75 11		 jne	 SHORT $LN472@inflate

; 658  :                 state->wbits = len;

  0035c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00364	8b 4c 24 48	 mov	 ecx, DWORD PTR len$[rsp]
  00368	89 48 28	 mov	 DWORD PTR [rax+40], ecx
  0036b	eb 37		 jmp	 SHORT $LN471@inflate
$LN472@inflate:

; 659  :             else if (len > state->wbits) {

  0036d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00375	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00378	39 44 24 48	 cmp	 DWORD PTR len$[rsp], eax
  0037c	76 26		 jbe	 SHORT $LN470@inflate

; 660  :                 strm->msg = (char *)"invalid window size";

  0037e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00386	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
  0038d	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 661  :                 state->mode = BAD;

  00391	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00399	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 662  :                 break;

  0039f	e9 8e 29 00 00	 jmp	 $LN498@inflate
$LN470@inflate:
$LN471@inflate:

; 663  :             }
; 664  :             state->dmax = 1U << len;

  003a4	8b 44 24 48	 mov	 eax, DWORD PTR len$[rsp]
  003a8	b9 01 00 00 00	 mov	 ecx, 1
  003ad	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv1648[rsp], ecx
  003b4	0f b6 c8	 movzx	 ecx, al
  003b7	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv1648[rsp]
  003be	d3 e0		 shl	 eax, cl
  003c0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  003c8	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 665  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 666  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  003cb	45 33 c0	 xor	 r8d, r8d
  003ce	33 d2		 xor	 edx, edx
  003d0	33 c9		 xor	 ecx, ecx
  003d2	e8 00 00 00 00	 call	 adler32
  003d7	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv178[rsp], eax
  003de	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003e6	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv178[rsp]
  003ed	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  003f0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  003f8	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv178[rsp]
  003ff	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 667  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00402	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00406	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0040b	85 c0		 test	 eax, eax
  0040d	74 0d		 je	 SHORT $LN510@inflate
  0040f	c7 84 24 94 00
	00 00 09 00 00
	00		 mov	 DWORD PTR tv184[rsp], 9
  0041a	eb 0b		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  0041c	c7 84 24 94 00
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv184[rsp], 11
$LN511@inflate:
  00427	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0042f	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv184[rsp]
  00436	89 08		 mov	 DWORD PTR [rax], ecx
$LN469@inflate:

; 668  :             INITBITS();

  00438	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00440	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00448	33 c0		 xor	 eax, eax
  0044a	85 c0		 test	 eax, eax
  0044c	75 ea		 jne	 SHORT $LN469@inflate

; 669  :             break;

  0044e	e9 df 28 00 00	 jmp	 $LN498@inflate
$LN466@inflate:
$LN465@inflate:
$LN462@inflate:

; 670  : #ifdef GUNZIP
; 671  :         case FLAGS:
; 672  :             NEEDBITS(16);

  00453	83 7c 24 4c 10	 cmp	 DWORD PTR bits$[rsp], 16
  00458	73 50		 jae	 SHORT $LN461@inflate
$LN460@inflate:
  0045a	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0045f	75 05		 jne	 SHORT $LN457@inflate
  00461	e9 d1 28 00 00	 jmp	 $inf_leave$4986
$LN457@inflate:
  00466	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0046a	ff c8		 dec	 eax
  0046c	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00470	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00475	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00478	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  0047c	d3 e0		 shl	 eax, cl
  0047e	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00482	03 c8		 add	 ecx, eax
  00484	8b c1		 mov	 eax, ecx
  00486	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0048a	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0048f	48 ff c0	 inc	 rax
  00492	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  00497	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0049b	83 c0 08	 add	 eax, 8
  0049e	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  004a2	33 c0		 xor	 eax, eax
  004a4	85 c0		 test	 eax, eax
  004a6	75 b2		 jne	 SHORT $LN460@inflate
  004a8	eb a9		 jmp	 SHORT $LN462@inflate
$LN461@inflate:
  004aa	33 c0		 xor	 eax, eax
  004ac	85 c0		 test	 eax, eax
  004ae	75 a3		 jne	 SHORT $LN465@inflate

; 673  :             state->flags = (int)(hold);

  004b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  004b8	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  004bc	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 674  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  004bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  004c7	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  004ca	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004cf	83 f8 08	 cmp	 eax, 8
  004d2	74 26		 je	 SHORT $LN456@inflate

; 675  :                 strm->msg = (char *)"unknown compression method";

  004d4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  004dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  004e3	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 676  :                 state->mode = BAD;

  004e7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  004ef	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 677  :                 break;

  004f5	e9 38 28 00 00	 jmp	 $LN498@inflate
$LN456@inflate:

; 678  :             }
; 679  :             if (state->flags & 0xe000) {

  004fa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00502	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00505	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  0050a	85 c0		 test	 eax, eax
  0050c	74 26		 je	 SHORT $LN455@inflate

; 680  :                 strm->msg = (char *)"unknown header flags set";

  0050e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00516	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  0051d	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 681  :                 state->mode = BAD;

  00521	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00529	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 682  :                 break;

  0052f	e9 fe 27 00 00	 jmp	 $LN498@inflate
$LN455@inflate:

; 683  :             }
; 684  :             if (state->head != Z_NULL)

  00534	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0053c	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00541	74 18		 je	 SHORT $LN454@inflate

; 685  :                 state->head->text = (int)((hold >> 8) & 1);

  00543	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00547	c1 e8 08	 shr	 eax, 8
  0054a	83 e0 01	 and	 eax, 1
  0054d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00555	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00559	89 01		 mov	 DWORD PTR [rcx], eax
$LN454@inflate:

; 686  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  0055b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00563	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00566	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0056b	85 c0		 test	 eax, eax
  0056d	74 40		 je	 SHORT $LN453@inflate
$LN452@inflate:
  0056f	0f b6 44 24 64	 movzx	 eax, BYTE PTR hold$[rsp]
  00574	88 44 24 68	 mov	 BYTE PTR hbuf$[rsp], al
  00578	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0057c	c1 e8 08	 shr	 eax, 8
  0057f	88 44 24 69	 mov	 BYTE PTR hbuf$[rsp+1], al
  00583	41 b8 02 00 00
	00		 mov	 r8d, 2
  00589	48 8d 54 24 68	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0058e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00596	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00599	e8 00 00 00 00	 call	 crc32
  0059e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  005a6	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  005a9	33 c0		 xor	 eax, eax
  005ab	85 c0		 test	 eax, eax
  005ad	75 c0		 jne	 SHORT $LN452@inflate
$LN453@inflate:
$LN449@inflate:

; 687  :             INITBITS();

  005af	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  005b7	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  005bf	33 c0		 xor	 eax, eax
  005c1	85 c0		 test	 eax, eax
  005c3	75 ea		 jne	 SHORT $LN449@inflate

; 688  :             state->mode = TIME;

  005c5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  005cd	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
$LN446@inflate:
$LN445@inflate:
$LN442@inflate:

; 689  :         case TIME:
; 690  :             NEEDBITS(32);

  005d3	83 7c 24 4c 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  005d8	73 50		 jae	 SHORT $LN441@inflate
$LN440@inflate:
  005da	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  005df	75 05		 jne	 SHORT $LN437@inflate
  005e1	e9 51 27 00 00	 jmp	 $inf_leave$4986
$LN437@inflate:
  005e6	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  005ea	ff c8		 dec	 eax
  005ec	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  005f0	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  005f5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005f8	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  005fc	d3 e0		 shl	 eax, cl
  005fe	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00602	03 c8		 add	 ecx, eax
  00604	8b c1		 mov	 eax, ecx
  00606	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0060a	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0060f	48 ff c0	 inc	 rax
  00612	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  00617	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0061b	83 c0 08	 add	 eax, 8
  0061e	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  00622	33 c0		 xor	 eax, eax
  00624	85 c0		 test	 eax, eax
  00626	75 b2		 jne	 SHORT $LN440@inflate
  00628	eb a9		 jmp	 SHORT $LN442@inflate
$LN441@inflate:
  0062a	33 c0		 xor	 eax, eax
  0062c	85 c0		 test	 eax, eax
  0062e	75 a3		 jne	 SHORT $LN445@inflate

; 691  :             if (state->head != Z_NULL)

  00630	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00638	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0063d	74 13		 je	 SHORT $LN436@inflate

; 692  :                 state->head->time = hold;

  0063f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00647	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0064b	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  0064f	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN436@inflate:

; 693  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  00652	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0065a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0065d	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00662	85 c0		 test	 eax, eax
  00664	74 56		 je	 SHORT $LN435@inflate
$LN434@inflate:
  00666	0f b6 44 24 64	 movzx	 eax, BYTE PTR hold$[rsp]
  0066b	88 44 24 68	 mov	 BYTE PTR hbuf$[rsp], al
  0066f	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00673	c1 e8 08	 shr	 eax, 8
  00676	88 44 24 69	 mov	 BYTE PTR hbuf$[rsp+1], al
  0067a	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0067e	c1 e8 10	 shr	 eax, 16
  00681	88 44 24 6a	 mov	 BYTE PTR hbuf$[rsp+2], al
  00685	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00689	c1 e8 18	 shr	 eax, 24
  0068c	88 44 24 6b	 mov	 BYTE PTR hbuf$[rsp+3], al
  00690	41 b8 04 00 00
	00		 mov	 r8d, 4
  00696	48 8d 54 24 68	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0069b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  006a3	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  006a6	e8 00 00 00 00	 call	 crc32
  006ab	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  006b3	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  006b6	33 c0		 xor	 eax, eax
  006b8	85 c0		 test	 eax, eax
  006ba	75 aa		 jne	 SHORT $LN434@inflate
$LN435@inflate:
$LN431@inflate:

; 694  :             INITBITS();

  006bc	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  006c4	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  006cc	33 c0		 xor	 eax, eax
  006ce	85 c0		 test	 eax, eax
  006d0	75 ea		 jne	 SHORT $LN431@inflate

; 695  :             state->mode = OS;

  006d2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  006da	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
$LN428@inflate:
$LN427@inflate:
$LN424@inflate:

; 696  :         case OS:
; 697  :             NEEDBITS(16);

  006e0	83 7c 24 4c 10	 cmp	 DWORD PTR bits$[rsp], 16
  006e5	73 50		 jae	 SHORT $LN423@inflate
$LN422@inflate:
  006e7	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  006ec	75 05		 jne	 SHORT $LN419@inflate
  006ee	e9 44 26 00 00	 jmp	 $inf_leave$4986
$LN419@inflate:
  006f3	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  006f7	ff c8		 dec	 eax
  006f9	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  006fd	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00702	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00705	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  00709	d3 e0		 shl	 eax, cl
  0070b	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  0070f	03 c8		 add	 ecx, eax
  00711	8b c1		 mov	 eax, ecx
  00713	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  00717	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0071c	48 ff c0	 inc	 rax
  0071f	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  00724	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00728	83 c0 08	 add	 eax, 8
  0072b	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0072f	33 c0		 xor	 eax, eax
  00731	85 c0		 test	 eax, eax
  00733	75 b2		 jne	 SHORT $LN422@inflate
  00735	eb a9		 jmp	 SHORT $LN424@inflate
$LN423@inflate:
  00737	33 c0		 xor	 eax, eax
  00739	85 c0		 test	 eax, eax
  0073b	75 a3		 jne	 SHORT $LN427@inflate

; 698  :             if (state->head != Z_NULL) {

  0073d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00745	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0074a	74 2e		 je	 SHORT $LN418@inflate

; 699  :                 state->head->xflags = (int)(hold & 0xff);

  0074c	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00750	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00755	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0075d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00761	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 700  :                 state->head->os = (int)(hold >> 8);

  00764	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00768	c1 e8 08	 shr	 eax, 8
  0076b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00773	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00777	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
$LN418@inflate:

; 701  :             }
; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  0077a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00782	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00785	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0078a	85 c0		 test	 eax, eax
  0078c	74 40		 je	 SHORT $LN417@inflate
$LN416@inflate:
  0078e	0f b6 44 24 64	 movzx	 eax, BYTE PTR hold$[rsp]
  00793	88 44 24 68	 mov	 BYTE PTR hbuf$[rsp], al
  00797	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0079b	c1 e8 08	 shr	 eax, 8
  0079e	88 44 24 69	 mov	 BYTE PTR hbuf$[rsp+1], al
  007a2	41 b8 02 00 00
	00		 mov	 r8d, 2
  007a8	48 8d 54 24 68	 lea	 rdx, QWORD PTR hbuf$[rsp]
  007ad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  007b5	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  007b8	e8 00 00 00 00	 call	 crc32
  007bd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  007c5	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  007c8	33 c0		 xor	 eax, eax
  007ca	85 c0		 test	 eax, eax
  007cc	75 c0		 jne	 SHORT $LN416@inflate
$LN417@inflate:
$LN413@inflate:

; 703  :             INITBITS();

  007ce	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  007d6	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  007de	33 c0		 xor	 eax, eax
  007e0	85 c0		 test	 eax, eax
  007e2	75 ea		 jne	 SHORT $LN413@inflate

; 704  :             state->mode = EXLEN;

  007e4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  007ec	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN410@inflate:

; 705  :         case EXLEN:
; 706  :             if (state->flags & 0x0400) {

  007f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  007fa	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  007fd	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00802	85 c0		 test	 eax, eax
  00804	0f 84 fa 00 00
	00		 je	 $LN409@inflate
$LN408@inflate:
$LN405@inflate:

; 707  :                 NEEDBITS(16);

  0080a	83 7c 24 4c 10	 cmp	 DWORD PTR bits$[rsp], 16
  0080f	73 50		 jae	 SHORT $LN404@inflate
$LN403@inflate:
  00811	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00816	75 05		 jne	 SHORT $LN400@inflate
  00818	e9 1a 25 00 00	 jmp	 $inf_leave$4986
$LN400@inflate:
  0081d	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00821	ff c8		 dec	 eax
  00823	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00827	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0082c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0082f	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  00833	d3 e0		 shl	 eax, cl
  00835	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00839	03 c8		 add	 ecx, eax
  0083b	8b c1		 mov	 eax, ecx
  0083d	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  00841	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00846	48 ff c0	 inc	 rax
  00849	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  0084e	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00852	83 c0 08	 add	 eax, 8
  00855	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  00859	33 c0		 xor	 eax, eax
  0085b	85 c0		 test	 eax, eax
  0085d	75 b2		 jne	 SHORT $LN403@inflate
  0085f	eb a9		 jmp	 SHORT $LN405@inflate
$LN404@inflate:
  00861	33 c0		 xor	 eax, eax
  00863	85 c0		 test	 eax, eax
  00865	75 a3		 jne	 SHORT $LN408@inflate

; 708  :                 state->length = (unsigned)(hold);

  00867	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0086f	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00873	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 709  :                 if (state->head != Z_NULL)

  00876	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0087e	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00883	74 13		 je	 SHORT $LN399@inflate

; 710  :                     state->head->extra_len = (unsigned)hold;

  00885	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0088d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00891	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00895	89 48 18	 mov	 DWORD PTR [rax+24], ecx
$LN399@inflate:

; 711  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  00898	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  008a0	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  008a3	25 00 02 00 00	 and	 eax, 512		; 00000200H
  008a8	85 c0		 test	 eax, eax
  008aa	74 40		 je	 SHORT $LN398@inflate
$LN397@inflate:
  008ac	0f b6 44 24 64	 movzx	 eax, BYTE PTR hold$[rsp]
  008b1	88 44 24 68	 mov	 BYTE PTR hbuf$[rsp], al
  008b5	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  008b9	c1 e8 08	 shr	 eax, 8
  008bc	88 44 24 69	 mov	 BYTE PTR hbuf$[rsp+1], al
  008c0	41 b8 02 00 00
	00		 mov	 r8d, 2
  008c6	48 8d 54 24 68	 lea	 rdx, QWORD PTR hbuf$[rsp]
  008cb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  008d3	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  008d6	e8 00 00 00 00	 call	 crc32
  008db	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  008e3	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  008e6	33 c0		 xor	 eax, eax
  008e8	85 c0		 test	 eax, eax
  008ea	75 c0		 jne	 SHORT $LN397@inflate
$LN398@inflate:
$LN394@inflate:

; 712  :                 INITBITS();

  008ec	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  008f4	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  008fc	33 c0		 xor	 eax, eax
  008fe	85 c0		 test	 eax, eax
  00900	75 ea		 jne	 SHORT $LN394@inflate

; 713  :             }
; 714  :             else if (state->head != Z_NULL)

  00902	eb 23		 jmp	 SHORT $LN391@inflate
$LN409@inflate:
  00904	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0090c	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00911	74 14		 je	 SHORT $LN390@inflate

; 715  :                 state->head->extra = Z_NULL;

  00913	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0091b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0091f	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN390@inflate:
$LN391@inflate:

; 716  :             state->mode = EXTRA;

  00927	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0092f	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
$LN389@inflate:

; 717  :         case EXTRA:
; 718  :             if (state->flags & 0x0400) {

  00935	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0093d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00940	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00945	85 c0		 test	 eax, eax
  00947	0f 84 73 01 00
	00		 je	 $LN388@inflate

; 719  :                 copy = state->length;

  0094d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00955	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00958	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 720  :                 if (copy > have) copy = have;

  0095c	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00960	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  00964	76 08		 jbe	 SHORT $LN387@inflate
  00966	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0096a	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN387@inflate:

; 721  :                 if (copy) {

  0096e	83 7c 24 6c 00	 cmp	 DWORD PTR copy$[rsp], 0
  00973	0f 84 34 01 00
	00		 je	 $LN386@inflate

; 722  :                     if (state->head != Z_NULL &&
; 723  :                         state->head->extra != Z_NULL) {

  00979	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00981	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00986	0f 84 a8 00 00
	00		 je	 $LN385@inflate
  0098c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00994	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00998	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0099d	0f 84 91 00 00
	00		 je	 $LN385@inflate

; 724  :                         len = state->head->extra_len - state->length;

  009a3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  009ab	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  009af	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  009b7	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  009ba	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  009bd	2b c1		 sub	 eax, ecx
  009bf	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax

; 725  :                         zmemcpy(state->head->extra + len, next,
; 726  :                                 len + copy > state->head->extra_max ?
; 727  :                                 state->head->extra_max - len : copy);

  009c3	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  009c7	8b 4c 24 48	 mov	 ecx, DWORD PTR len$[rsp]
  009cb	03 c8		 add	 ecx, eax
  009cd	8b c1		 mov	 eax, ecx
  009cf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  009d7	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  009db	3b 41 1c	 cmp	 eax, DWORD PTR [rcx+28]
  009de	76 1e		 jbe	 SHORT $LN512@inflate
  009e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  009e8	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  009ec	8b 4c 24 48	 mov	 ecx, DWORD PTR len$[rsp]
  009f0	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  009f3	2b c1		 sub	 eax, ecx
  009f5	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv350[rsp], eax
  009fc	eb 0b		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  009fe	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00a02	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv350[rsp], eax
$LN513@inflate:
  00a09	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv350[rsp]
  00a10	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00a18	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00a1c	8b 54 24 48	 mov	 edx, DWORD PTR len$[rsp]
  00a20	48 03 51 10	 add	 rdx, QWORD PTR [rcx+16]
  00a24	48 8b ca	 mov	 rcx, rdx
  00a27	44 8b c0	 mov	 r8d, eax
  00a2a	48 8b 54 24 58	 mov	 rdx, QWORD PTR next$[rsp]
  00a2f	e8 00 00 00 00	 call	 memcpy
$LN385@inflate:

; 728  :                     }
; 729  :                     if (state->flags & 0x0200)

  00a34	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a3c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00a3f	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00a44	85 c0		 test	 eax, eax
  00a46	74 25		 je	 SHORT $LN384@inflate

; 730  :                         state->check = crc32(state->check, next, copy);

  00a48	44 8b 44 24 6c	 mov	 r8d, DWORD PTR copy$[rsp]
  00a4d	48 8b 54 24 58	 mov	 rdx, QWORD PTR next$[rsp]
  00a52	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a5a	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00a5d	e8 00 00 00 00	 call	 crc32
  00a62	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00a6a	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN384@inflate:

; 731  :                     have -= copy;

  00a6d	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00a71	8b 4c 24 40	 mov	 ecx, DWORD PTR have$[rsp]
  00a75	2b c8		 sub	 ecx, eax
  00a77	8b c1		 mov	 eax, ecx
  00a79	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 732  :                     next += copy;

  00a7d	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00a81	48 8b 4c 24 58	 mov	 rcx, QWORD PTR next$[rsp]
  00a86	48 03 c8	 add	 rcx, rax
  00a89	48 8b c1	 mov	 rax, rcx
  00a8c	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax

; 733  :                     state->length -= copy;

  00a91	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a99	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  00a9d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00aa0	2b c1		 sub	 eax, ecx
  00aa2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00aaa	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN386@inflate:

; 734  :                 }
; 735  :                 if (state->length) goto inf_leave;

  00aad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ab5	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  00ab9	74 05		 je	 SHORT $LN383@inflate
  00abb	e9 77 22 00 00	 jmp	 $inf_leave$4986
$LN383@inflate:
$LN388@inflate:

; 736  :             }
; 737  :             state->length = 0;

  00ac0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ac8	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 738  :             state->mode = NAME;

  00acf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ad7	c7 00 06 00 00
	00		 mov	 DWORD PTR [rax], 6
$LN382@inflate:

; 739  :         case NAME:
; 740  :             if (state->flags & 0x0800) {

  00add	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ae5	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00ae8	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00aed	85 c0		 test	 eax, eax
  00aef	0f 84 28 01 00
	00		 je	 $LN381@inflate

; 741  :                 if (have == 0) goto inf_leave;

  00af5	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00afa	75 05		 jne	 SHORT $LN380@inflate
  00afc	e9 36 22 00 00	 jmp	 $inf_leave$4986
$LN380@inflate:

; 742  :                 copy = 0;

  00b01	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR copy$[rsp], 0
$LN379@inflate:

; 743  :                 do {
; 744  :                     len = (unsigned)(next[copy++]);

  00b09	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00b0d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR next$[rsp]
  00b12	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b16	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax
  00b1a	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00b1e	ff c0		 inc	 eax
  00b20	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 745  :                     if (state->head != Z_NULL &&
; 746  :                             state->head->name != Z_NULL &&
; 747  :                             state->length < state->head->name_max)

  00b24	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b2c	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00b31	74 6a		 je	 SHORT $LN376@inflate
  00b33	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b3b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00b3f	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00b44	74 57		 je	 SHORT $LN376@inflate
  00b46	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b4e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00b52	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00b5a	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b5d	39 41 48	 cmp	 DWORD PTR [rcx+72], eax
  00b60	73 3b		 jae	 SHORT $LN376@inflate

; 748  :                         state->head->name[state->length++] = len;

  00b62	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b6a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00b6e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00b76	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  00b79	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00b7d	0f b6 54 24 48	 movzx	 edx, BYTE PTR len$[rsp]
  00b82	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00b85	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b8d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00b90	ff c0		 inc	 eax
  00b92	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00b9a	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN376@inflate:

; 749  :                 } while (len && copy < have);

  00b9d	83 7c 24 48 00	 cmp	 DWORD PTR len$[rsp], 0
  00ba2	74 0e		 je	 SHORT $LN375@inflate
  00ba4	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00ba8	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  00bac	0f 82 57 ff ff
	ff		 jb	 $LN379@inflate
$LN375@inflate:

; 750  :                 if (state->flags & 0x0200)

  00bb2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00bba	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00bbd	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00bc2	85 c0		 test	 eax, eax
  00bc4	74 25		 je	 SHORT $LN374@inflate

; 751  :                     state->check = crc32(state->check, next, copy);

  00bc6	44 8b 44 24 6c	 mov	 r8d, DWORD PTR copy$[rsp]
  00bcb	48 8b 54 24 58	 mov	 rdx, QWORD PTR next$[rsp]
  00bd0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00bd8	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00bdb	e8 00 00 00 00	 call	 crc32
  00be0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00be8	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN374@inflate:

; 752  :                 have -= copy;

  00beb	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00bef	8b 4c 24 40	 mov	 ecx, DWORD PTR have$[rsp]
  00bf3	2b c8		 sub	 ecx, eax
  00bf5	8b c1		 mov	 eax, ecx
  00bf7	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 753  :                 next += copy;

  00bfb	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00bff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR next$[rsp]
  00c04	48 03 c8	 add	 rcx, rax
  00c07	48 8b c1	 mov	 rax, rcx
  00c0a	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax

; 754  :                 if (len) goto inf_leave;

  00c0f	83 7c 24 48 00	 cmp	 DWORD PTR len$[rsp], 0
  00c14	74 05		 je	 SHORT $LN373@inflate
  00c16	e9 1c 21 00 00	 jmp	 $inf_leave$4986
$LN373@inflate:

; 755  :             }
; 756  :             else if (state->head != Z_NULL)

  00c1b	eb 23		 jmp	 SHORT $LN372@inflate
$LN381@inflate:
  00c1d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c25	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00c2a	74 14		 je	 SHORT $LN371@inflate

; 757  :                 state->head->name = Z_NULL;

  00c2c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c34	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00c38	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN371@inflate:
$LN372@inflate:

; 758  :             state->length = 0;

  00c40	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c48	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 759  :             state->mode = COMMENT;

  00c4f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c57	c7 00 07 00 00
	00		 mov	 DWORD PTR [rax], 7
$LN370@inflate:

; 760  :         case COMMENT:
; 761  :             if (state->flags & 0x1000) {

  00c5d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c65	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00c68	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00c6d	85 c0		 test	 eax, eax
  00c6f	0f 84 28 01 00
	00		 je	 $LN369@inflate

; 762  :                 if (have == 0) goto inf_leave;

  00c75	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00c7a	75 05		 jne	 SHORT $LN368@inflate
  00c7c	e9 b6 20 00 00	 jmp	 $inf_leave$4986
$LN368@inflate:

; 763  :                 copy = 0;

  00c81	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR copy$[rsp], 0
$LN367@inflate:

; 764  :                 do {
; 765  :                     len = (unsigned)(next[copy++]);

  00c89	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00c8d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR next$[rsp]
  00c92	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c96	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax
  00c9a	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00c9e	ff c0		 inc	 eax
  00ca0	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 766  :                     if (state->head != Z_NULL &&
; 767  :                             state->head->comment != Z_NULL &&
; 768  :                             state->length < state->head->comm_max)

  00ca4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00cac	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00cb1	74 6a		 je	 SHORT $LN364@inflate
  00cb3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00cbb	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00cbf	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00cc4	74 57		 je	 SHORT $LN364@inflate
  00cc6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00cce	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00cd2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00cda	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00cdd	39 41 48	 cmp	 DWORD PTR [rcx+72], eax
  00ce0	73 3b		 jae	 SHORT $LN364@inflate

; 769  :                         state->head->comment[state->length++] = len;

  00ce2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00cea	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00cee	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00cf6	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  00cf9	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00cfd	0f b6 54 24 48	 movzx	 edx, BYTE PTR len$[rsp]
  00d02	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00d05	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d0d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00d10	ff c0		 inc	 eax
  00d12	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00d1a	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN364@inflate:

; 770  :                 } while (len && copy < have);

  00d1d	83 7c 24 48 00	 cmp	 DWORD PTR len$[rsp], 0
  00d22	74 0e		 je	 SHORT $LN363@inflate
  00d24	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00d28	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  00d2c	0f 82 57 ff ff
	ff		 jb	 $LN367@inflate
$LN363@inflate:

; 771  :                 if (state->flags & 0x0200)

  00d32	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d3a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00d3d	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00d42	85 c0		 test	 eax, eax
  00d44	74 25		 je	 SHORT $LN362@inflate

; 772  :                     state->check = crc32(state->check, next, copy);

  00d46	44 8b 44 24 6c	 mov	 r8d, DWORD PTR copy$[rsp]
  00d4b	48 8b 54 24 58	 mov	 rdx, QWORD PTR next$[rsp]
  00d50	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d58	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00d5b	e8 00 00 00 00	 call	 crc32
  00d60	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00d68	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN362@inflate:

; 773  :                 have -= copy;

  00d6b	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00d6f	8b 4c 24 40	 mov	 ecx, DWORD PTR have$[rsp]
  00d73	2b c8		 sub	 ecx, eax
  00d75	8b c1		 mov	 eax, ecx
  00d77	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 774  :                 next += copy;

  00d7b	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  00d7f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR next$[rsp]
  00d84	48 03 c8	 add	 rcx, rax
  00d87	48 8b c1	 mov	 rax, rcx
  00d8a	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax

; 775  :                 if (len) goto inf_leave;

  00d8f	83 7c 24 48 00	 cmp	 DWORD PTR len$[rsp], 0
  00d94	74 05		 je	 SHORT $LN361@inflate
  00d96	e9 9c 1f 00 00	 jmp	 $inf_leave$4986
$LN361@inflate:

; 776  :             }
; 777  :             else if (state->head != Z_NULL)

  00d9b	eb 23		 jmp	 SHORT $LN360@inflate
$LN369@inflate:
  00d9d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00da5	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00daa	74 14		 je	 SHORT $LN359@inflate

; 778  :                 state->head->comment = Z_NULL;

  00dac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00db4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00db8	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0
$LN359@inflate:
$LN360@inflate:

; 779  :             state->mode = HCRC;

  00dc0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00dc8	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8
$LN358@inflate:

; 780  :         case HCRC:
; 781  :             if (state->flags & 0x0200) {

  00dce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00dd6	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00dd9	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00dde	85 c0		 test	 eax, eax
  00de0	0f 84 af 00 00
	00		 je	 $LN357@inflate
$LN356@inflate:
$LN353@inflate:

; 782  :                 NEEDBITS(16);

  00de6	83 7c 24 4c 10	 cmp	 DWORD PTR bits$[rsp], 16
  00deb	73 50		 jae	 SHORT $LN352@inflate
$LN351@inflate:
  00ded	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00df2	75 05		 jne	 SHORT $LN348@inflate
  00df4	e9 3e 1f 00 00	 jmp	 $inf_leave$4986
$LN348@inflate:
  00df9	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00dfd	ff c8		 dec	 eax
  00dff	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00e03	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00e08	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e0b	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  00e0f	d3 e0		 shl	 eax, cl
  00e11	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00e15	03 c8		 add	 ecx, eax
  00e17	8b c1		 mov	 eax, ecx
  00e19	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  00e1d	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00e22	48 ff c0	 inc	 rax
  00e25	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  00e2a	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00e2e	83 c0 08	 add	 eax, 8
  00e31	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  00e35	33 c0		 xor	 eax, eax
  00e37	85 c0		 test	 eax, eax
  00e39	75 b2		 jne	 SHORT $LN351@inflate
  00e3b	eb a9		 jmp	 SHORT $LN353@inflate
$LN352@inflate:
  00e3d	33 c0		 xor	 eax, eax
  00e3f	85 c0		 test	 eax, eax
  00e41	75 a3		 jne	 SHORT $LN356@inflate

; 783  :                 if (hold != (state->check & 0xffff)) {

  00e43	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00e4b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00e4e	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00e53	39 44 24 64	 cmp	 DWORD PTR hold$[rsp], eax
  00e57	74 26		 je	 SHORT $LN347@inflate

; 784  :                     strm->msg = (char *)"header crc mismatch";

  00e59	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00e61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  00e68	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 785  :                     state->mode = BAD;

  00e6c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00e74	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 786  :                     break;

  00e7a	e9 b3 1e 00 00	 jmp	 $LN498@inflate
$LN347@inflate:
$LN346@inflate:

; 787  :                 }
; 788  :                 INITBITS();

  00e7f	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00e87	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00e8f	33 c0		 xor	 eax, eax
  00e91	85 c0		 test	 eax, eax
  00e93	75 ea		 jne	 SHORT $LN346@inflate
$LN357@inflate:

; 789  :             }
; 790  :             if (state->head != Z_NULL) {

  00e95	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00e9d	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00ea2	74 33		 je	 SHORT $LN343@inflate

; 791  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00ea4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00eac	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00eaf	c1 f8 09	 sar	 eax, 9
  00eb2	83 e0 01	 and	 eax, 1
  00eb5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00ebd	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00ec1	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 792  :                 state->head->done = 1;

  00ec4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ecc	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00ed0	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN343@inflate:

; 793  :             }
; 794  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00ed7	45 33 c0	 xor	 r8d, r8d
  00eda	33 d2		 xor	 edx, edx
  00edc	33 c9		 xor	 ecx, ecx
  00ede	e8 00 00 00 00	 call	 crc32
  00ee3	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv494[rsp], eax
  00eea	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ef2	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv494[rsp]
  00ef9	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  00efc	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00f04	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv494[rsp]
  00f0b	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 795  :             state->mode = TYPE;

  00f0e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00f16	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 796  :             break;

  00f1c	e9 11 1e 00 00	 jmp	 $LN498@inflate
$LN342@inflate:
$LN341@inflate:
$LN338@inflate:

; 797  : #endif
; 798  :         case DICTID:
; 799  :             NEEDBITS(32);

  00f21	83 7c 24 4c 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  00f26	73 50		 jae	 SHORT $LN337@inflate
$LN336@inflate:
  00f28	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  00f2d	75 05		 jne	 SHORT $LN333@inflate
  00f2f	e9 03 1e 00 00	 jmp	 $inf_leave$4986
$LN333@inflate:
  00f34	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  00f38	ff c8		 dec	 eax
  00f3a	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  00f3e	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00f43	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00f46	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  00f4a	d3 e0		 shl	 eax, cl
  00f4c	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00f50	03 c8		 add	 ecx, eax
  00f52	8b c1		 mov	 eax, ecx
  00f54	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  00f58	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  00f5d	48 ff c0	 inc	 rax
  00f60	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  00f65	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  00f69	83 c0 08	 add	 eax, 8
  00f6c	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  00f70	33 c0		 xor	 eax, eax
  00f72	85 c0		 test	 eax, eax
  00f74	75 b2		 jne	 SHORT $LN336@inflate
  00f76	eb a9		 jmp	 SHORT $LN338@inflate
$LN337@inflate:
  00f78	33 c0		 xor	 eax, eax
  00f7a	85 c0		 test	 eax, eax
  00f7c	75 a3		 jne	 SHORT $LN341@inflate

; 800  :             strm->adler = state->check = REVERSE(hold);

  00f7e	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  00f82	c1 e8 18	 shr	 eax, 24
  00f85	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f8a	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00f8e	c1 e9 08	 shr	 ecx, 8
  00f91	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00f97	03 c1		 add	 eax, ecx
  00f99	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00f9d	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00fa3	c1 e1 08	 shl	 ecx, 8
  00fa6	03 c1		 add	 eax, ecx
  00fa8	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  00fac	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00fb2	c1 e1 18	 shl	 ecx, 24
  00fb5	03 c1		 add	 eax, ecx
  00fb7	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv520[rsp], eax
  00fbe	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00fc6	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv520[rsp]
  00fcd	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  00fd0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00fd8	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv520[rsp]
  00fdf	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
$LN332@inflate:

; 801  :             INITBITS();

  00fe2	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00fea	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00ff2	33 c0		 xor	 eax, eax
  00ff4	85 c0		 test	 eax, eax
  00ff6	75 ea		 jne	 SHORT $LN332@inflate

; 802  :             state->mode = DICT;

  00ff8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01000	c7 00 0a 00 00
	00		 mov	 DWORD PTR [rax], 10
$LN329@inflate:

; 803  :         case DICT:
; 804  :             if (state->havedict == 0) {

  01006	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0100e	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  01012	75 6d		 jne	 SHORT $LN328@inflate
$LN327@inflate:

; 805  :                 RESTORE();

  01014	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0101c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  01021	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  01025	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0102d	8b 4c 24 50	 mov	 ecx, DWORD PTR left$[rsp]
  01031	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  01034	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0103c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR next$[rsp]
  01041	48 89 08	 mov	 QWORD PTR [rax], rcx
  01044	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0104c	8b 4c 24 40	 mov	 ecx, DWORD PTR have$[rsp]
  01050	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  01053	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0105b	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  0105f	89 48 40	 mov	 DWORD PTR [rax+64], ecx
  01062	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0106a	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  0106e	89 48 44	 mov	 DWORD PTR [rax+68], ecx
  01071	33 c0		 xor	 eax, eax
  01073	85 c0		 test	 eax, eax
  01075	75 9d		 jne	 SHORT $LN327@inflate

; 806  :                 return Z_NEED_DICT;

  01077	b8 02 00 00 00	 mov	 eax, 2
  0107c	e9 7c 1f 00 00	 jmp	 $LN508@inflate
$LN328@inflate:

; 807  :             }
; 808  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  01081	45 33 c0	 xor	 r8d, r8d
  01084	33 d2		 xor	 edx, edx
  01086	33 c9		 xor	 ecx, ecx
  01088	e8 00 00 00 00	 call	 adler32
  0108d	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv532[rsp], eax
  01094	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0109c	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv532[rsp]
  010a3	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  010a6	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  010ae	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv532[rsp]
  010b5	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 809  :             state->mode = TYPE;

  010b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  010c0	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11
$LN324@inflate:

; 810  :         case TYPE:
; 811  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  010c6	83 bc 24 18 01
	00 00 05	 cmp	 DWORD PTR flush$[rsp], 5
  010ce	74 0a		 je	 SHORT $LN322@inflate
  010d0	83 bc 24 18 01
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  010d8	75 05		 jne	 SHORT $LN323@inflate
$LN322@inflate:
  010da	e9 58 1c 00 00	 jmp	 $inf_leave$4986
$LN323@inflate:
$LN321@inflate:

; 812  :         case TYPEDO:
; 813  :             if (state->last) {

  010df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  010e7	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  010eb	74 40		 je	 SHORT $LN320@inflate
$LN319@inflate:

; 814  :                 BYTEBITS();

  010ed	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  010f1	83 e0 07	 and	 eax, 7
  010f4	0f b6 c8	 movzx	 ecx, al
  010f7	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  010fb	d3 e8		 shr	 eax, cl
  010fd	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01101	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01105	83 e0 07	 and	 eax, 7
  01108	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  0110c	2b c8		 sub	 ecx, eax
  0110e	8b c1		 mov	 eax, ecx
  01110	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01114	33 c0		 xor	 eax, eax
  01116	85 c0		 test	 eax, eax
  01118	75 d3		 jne	 SHORT $LN319@inflate

; 815  :                 state->mode = CHECK;

  0111a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01122	c7 00 1a 00 00
	00		 mov	 DWORD PTR [rax], 26

; 816  :                 break;

  01128	e9 05 1c 00 00	 jmp	 $LN498@inflate
$LN320@inflate:
$LN316@inflate:
$LN313@inflate:

; 817  :             }
; 818  :             NEEDBITS(3);

  0112d	83 7c 24 4c 03	 cmp	 DWORD PTR bits$[rsp], 3
  01132	73 50		 jae	 SHORT $LN312@inflate
$LN311@inflate:
  01134	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01139	75 05		 jne	 SHORT $LN308@inflate
  0113b	e9 f7 1b 00 00	 jmp	 $inf_leave$4986
$LN308@inflate:
  01140	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01144	ff c8		 dec	 eax
  01146	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0114a	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0114f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01152	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  01156	d3 e0		 shl	 eax, cl
  01158	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  0115c	03 c8		 add	 ecx, eax
  0115e	8b c1		 mov	 eax, ecx
  01160	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01164	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01169	48 ff c0	 inc	 rax
  0116c	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01171	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01175	83 c0 08	 add	 eax, 8
  01178	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0117c	33 c0		 xor	 eax, eax
  0117e	85 c0		 test	 eax, eax
  01180	75 b2		 jne	 SHORT $LN311@inflate
  01182	eb a9		 jmp	 SHORT $LN313@inflate
$LN312@inflate:
  01184	33 c0		 xor	 eax, eax
  01186	85 c0		 test	 eax, eax
  01188	75 a3		 jne	 SHORT $LN316@inflate

; 819  :             state->last = BITS(1);

  0118a	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0118e	83 e0 01	 and	 eax, 1
  01191	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01199	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN307@inflate:

; 820  :             DROPBITS(1);

  0119c	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  011a0	d1 e8		 shr	 eax, 1
  011a2	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  011a6	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  011aa	ff c8		 dec	 eax
  011ac	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  011b0	33 c0		 xor	 eax, eax
  011b2	85 c0		 test	 eax, eax
  011b4	75 e6		 jne	 SHORT $LN307@inflate

; 821  :             switch (BITS(2)) {

  011b6	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  011ba	83 e0 03	 and	 eax, 3
  011bd	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv561[rsp], eax
  011c4	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR tv561[rsp], 0
  011cc	74 23		 je	 SHORT $LN302@inflate
  011ce	83 bc 24 a8 00
	00 00 01	 cmp	 DWORD PTR tv561[rsp], 1
  011d6	74 29		 je	 SHORT $LN301@inflate
  011d8	83 bc 24 a8 00
	00 00 02	 cmp	 DWORD PTR tv561[rsp], 2
  011e0	74 67		 je	 SHORT $LN296@inflate
  011e2	83 bc 24 a8 00
	00 00 03	 cmp	 DWORD PTR tv561[rsp], 3
  011ea	74 6d		 je	 SHORT $LN295@inflate
  011ec	e9 89 00 00 00	 jmp	 $LN303@inflate
$LN302@inflate:

; 822  :             case 0:                             /* stored block */
; 823  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 824  :                         state->last ? " (last)" : ""));
; 825  :                 state->mode = STORED;

  011f1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  011f9	c7 00 0d 00 00
	00		 mov	 DWORD PTR [rax], 13

; 826  :                 break;

  011ff	eb 79		 jmp	 SHORT $LN303@inflate
$LN301@inflate:

; 827  :             case 1:                             /* fixed block */
; 828  :                 fixedtables(state);

  01201	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01209	e8 00 00 00 00	 call	 fixedtables

; 829  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 830  :                         state->last ? " (last)" : ""));
; 831  :                 state->mode = LEN_;             /* decode codes */

  0120e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01216	c7 00 13 00 00
	00		 mov	 DWORD PTR [rax], 19

; 832  :                 if (flush == Z_TREES) {

  0121c	83 bc 24 18 01
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  01224	75 21		 jne	 SHORT $LN300@inflate
$LN299@inflate:

; 833  :                     DROPBITS(2);

  01226	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0122a	c1 e8 02	 shr	 eax, 2
  0122d	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01231	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01235	83 e8 02	 sub	 eax, 2
  01238	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0123c	33 c0		 xor	 eax, eax
  0123e	85 c0		 test	 eax, eax
  01240	75 e4		 jne	 SHORT $LN299@inflate

; 834  :                     goto inf_leave;

  01242	e9 f0 1a 00 00	 jmp	 $inf_leave$4986
$LN300@inflate:

; 835  :                 }
; 836  :                 break;

  01247	eb 31		 jmp	 SHORT $LN303@inflate
$LN296@inflate:

; 837  :             case 2:                             /* dynamic block */
; 838  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = TABLE;

  01249	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01251	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 841  :                 break;

  01257	eb 21		 jmp	 SHORT $LN303@inflate
$LN295@inflate:

; 842  :             case 3:
; 843  :                 strm->msg = (char *)"invalid block type";

  01259	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
  01268	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 844  :                 state->mode = BAD;

  0126c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01274	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29
$LN303@inflate:
$LN294@inflate:

; 845  :             }
; 846  :             DROPBITS(2);

  0127a	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0127e	c1 e8 02	 shr	 eax, 2
  01281	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01285	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01289	83 e8 02	 sub	 eax, 2
  0128c	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01290	33 c0		 xor	 eax, eax
  01292	85 c0		 test	 eax, eax
  01294	75 e4		 jne	 SHORT $LN294@inflate

; 847  :             break;

  01296	e9 97 1a 00 00	 jmp	 $LN498@inflate
$LN291@inflate:
$LN290@inflate:

; 848  :         case STORED:
; 849  :             BYTEBITS();                         /* go to byte boundary */

  0129b	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0129f	83 e0 07	 and	 eax, 7
  012a2	0f b6 c8	 movzx	 ecx, al
  012a5	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  012a9	d3 e8		 shr	 eax, cl
  012ab	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  012af	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  012b3	83 e0 07	 and	 eax, 7
  012b6	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  012ba	2b c8		 sub	 ecx, eax
  012bc	8b c1		 mov	 eax, ecx
  012be	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  012c2	33 c0		 xor	 eax, eax
  012c4	85 c0		 test	 eax, eax
  012c6	75 d3		 jne	 SHORT $LN290@inflate
$LN287@inflate:
$LN284@inflate:

; 850  :             NEEDBITS(32);

  012c8	83 7c 24 4c 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  012cd	73 50		 jae	 SHORT $LN283@inflate
$LN282@inflate:
  012cf	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  012d4	75 05		 jne	 SHORT $LN279@inflate
  012d6	e9 5c 1a 00 00	 jmp	 $inf_leave$4986
$LN279@inflate:
  012db	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  012df	ff c8		 dec	 eax
  012e1	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  012e5	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  012ea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  012ed	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  012f1	d3 e0		 shl	 eax, cl
  012f3	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  012f7	03 c8		 add	 ecx, eax
  012f9	8b c1		 mov	 eax, ecx
  012fb	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  012ff	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01304	48 ff c0	 inc	 rax
  01307	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  0130c	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01310	83 c0 08	 add	 eax, 8
  01313	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01317	33 c0		 xor	 eax, eax
  01319	85 c0		 test	 eax, eax
  0131b	75 b2		 jne	 SHORT $LN282@inflate
  0131d	eb a9		 jmp	 SHORT $LN284@inflate
$LN283@inflate:
  0131f	33 c0		 xor	 eax, eax
  01321	85 c0		 test	 eax, eax
  01323	75 a3		 jne	 SHORT $LN287@inflate

; 851  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  01325	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01329	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0132e	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  01332	c1 e9 10	 shr	 ecx, 16
  01335	81 f1 ff ff 00
	00		 xor	 ecx, 65535		; 0000ffffH
  0133b	3b c1		 cmp	 eax, ecx
  0133d	74 26		 je	 SHORT $LN278@inflate

; 852  :                 strm->msg = (char *)"invalid stored block lengths";

  0133f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01347	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  0134e	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 853  :                 state->mode = BAD;

  01352	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0135a	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 854  :                 break;

  01360	e9 cd 19 00 00	 jmp	 $LN498@inflate
$LN278@inflate:

; 855  :             }
; 856  :             state->length = (unsigned)hold & 0xffff;

  01365	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01369	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0136e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01376	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN277@inflate:

; 857  :             Tracev((stderr, "inflate:       stored length %u\n",
; 858  :                     state->length));
; 859  :             INITBITS();

  01379	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  01381	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  01389	33 c0		 xor	 eax, eax
  0138b	85 c0		 test	 eax, eax
  0138d	75 ea		 jne	 SHORT $LN277@inflate

; 860  :             state->mode = COPY_;

  0138f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01397	c7 00 0e 00 00
	00		 mov	 DWORD PTR [rax], 14

; 861  :             if (flush == Z_TREES) goto inf_leave;

  0139d	83 bc 24 18 01
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  013a5	75 05		 jne	 SHORT $LN274@inflate
  013a7	e9 8b 19 00 00	 jmp	 $inf_leave$4986
$LN274@inflate:
$LN273@inflate:

; 862  :         case COPY_:
; 863  :             state->mode = COPY;

  013ac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  013b4	c7 00 0f 00 00
	00		 mov	 DWORD PTR [rax], 15
$LN272@inflate:

; 864  :         case COPY:
; 865  :             copy = state->length;

  013ba	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  013c2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  013c5	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 866  :             if (copy) {

  013c9	83 7c 24 6c 00	 cmp	 DWORD PTR copy$[rsp], 0
  013ce	0f 84 af 00 00
	00		 je	 $LN271@inflate

; 867  :                 if (copy > have) copy = have;

  013d4	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  013d8	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  013dc	76 08		 jbe	 SHORT $LN270@inflate
  013de	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  013e2	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN270@inflate:

; 868  :                 if (copy > left) copy = left;

  013e6	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  013ea	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  013ee	76 08		 jbe	 SHORT $LN269@inflate
  013f0	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  013f4	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN269@inflate:

; 869  :                 if (copy == 0) goto inf_leave;

  013f8	83 7c 24 6c 00	 cmp	 DWORD PTR copy$[rsp], 0
  013fd	75 05		 jne	 SHORT $LN268@inflate
  013ff	e9 33 19 00 00	 jmp	 $inf_leave$4986
$LN268@inflate:

; 870  :                 zmemcpy(put, next, copy);

  01404	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  01408	44 8b c0	 mov	 r8d, eax
  0140b	48 8b 54 24 58	 mov	 rdx, QWORD PTR next$[rsp]
  01410	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  01415	e8 00 00 00 00	 call	 memcpy

; 871  :                 have -= copy;

  0141a	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  0141e	8b 4c 24 40	 mov	 ecx, DWORD PTR have$[rsp]
  01422	2b c8		 sub	 ecx, eax
  01424	8b c1		 mov	 eax, ecx
  01426	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax

; 872  :                 next += copy;

  0142a	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  0142e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR next$[rsp]
  01433	48 03 c8	 add	 rcx, rax
  01436	48 8b c1	 mov	 rax, rcx
  01439	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax

; 873  :                 left -= copy;

  0143e	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  01442	8b 4c 24 50	 mov	 ecx, DWORD PTR left$[rsp]
  01446	2b c8		 sub	 ecx, eax
  01448	8b c1		 mov	 eax, ecx
  0144a	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax

; 874  :                 put += copy;

  0144e	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  01452	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  01457	48 03 c8	 add	 rcx, rax
  0145a	48 8b c1	 mov	 rax, rcx
  0145d	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 875  :                 state->length -= copy;

  01462	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0146a	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  0146e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01471	2b c1		 sub	 eax, ecx
  01473	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0147b	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 876  :                 break;

  0147e	e9 af 18 00 00	 jmp	 $LN498@inflate
$LN271@inflate:

; 877  :             }
; 878  :             Tracev((stderr, "inflate:       stored end\n"));
; 879  :             state->mode = TYPE;

  01483	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0148b	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 880  :             break;

  01491	e9 9c 18 00 00	 jmp	 $LN498@inflate
$LN267@inflate:
$LN266@inflate:
$LN263@inflate:

; 881  :         case TABLE:
; 882  :             NEEDBITS(14);

  01496	83 7c 24 4c 0e	 cmp	 DWORD PTR bits$[rsp], 14
  0149b	73 50		 jae	 SHORT $LN262@inflate
$LN261@inflate:
  0149d	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  014a2	75 05		 jne	 SHORT $LN258@inflate
  014a4	e9 8e 18 00 00	 jmp	 $inf_leave$4986
$LN258@inflate:
  014a9	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  014ad	ff c8		 dec	 eax
  014af	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  014b3	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  014b8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  014bb	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  014bf	d3 e0		 shl	 eax, cl
  014c1	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  014c5	03 c8		 add	 ecx, eax
  014c7	8b c1		 mov	 eax, ecx
  014c9	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  014cd	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  014d2	48 ff c0	 inc	 rax
  014d5	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  014da	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  014de	83 c0 08	 add	 eax, 8
  014e1	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  014e5	33 c0		 xor	 eax, eax
  014e7	85 c0		 test	 eax, eax
  014e9	75 b2		 jne	 SHORT $LN261@inflate
  014eb	eb a9		 jmp	 SHORT $LN263@inflate
$LN262@inflate:
  014ed	33 c0		 xor	 eax, eax
  014ef	85 c0		 test	 eax, eax
  014f1	75 a3		 jne	 SHORT $LN266@inflate

; 883  :             state->nlen = BITS(5) + 257;

  014f3	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  014f7	83 e0 1f	 and	 eax, 31
  014fa	05 01 01 00 00	 add	 eax, 257		; 00000101H
  014ff	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01507	89 41 74	 mov	 DWORD PTR [rcx+116], eax
$LN257@inflate:

; 884  :             DROPBITS(5);

  0150a	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0150e	c1 e8 05	 shr	 eax, 5
  01511	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01515	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01519	83 e8 05	 sub	 eax, 5
  0151c	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01520	33 c0		 xor	 eax, eax
  01522	85 c0		 test	 eax, eax
  01524	75 e4		 jne	 SHORT $LN257@inflate

; 885  :             state->ndist = BITS(5) + 1;

  01526	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0152a	83 e0 1f	 and	 eax, 31
  0152d	ff c0		 inc	 eax
  0152f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01537	89 41 78	 mov	 DWORD PTR [rcx+120], eax
$LN254@inflate:

; 886  :             DROPBITS(5);

  0153a	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0153e	c1 e8 05	 shr	 eax, 5
  01541	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01545	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01549	83 e8 05	 sub	 eax, 5
  0154c	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01550	33 c0		 xor	 eax, eax
  01552	85 c0		 test	 eax, eax
  01554	75 e4		 jne	 SHORT $LN254@inflate

; 887  :             state->ncode = BITS(4) + 4;

  01556	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0155a	83 e0 0f	 and	 eax, 15
  0155d	83 c0 04	 add	 eax, 4
  01560	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01568	89 41 70	 mov	 DWORD PTR [rcx+112], eax
$LN251@inflate:

; 888  :             DROPBITS(4);

  0156b	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0156f	c1 e8 04	 shr	 eax, 4
  01572	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01576	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0157a	83 e8 04	 sub	 eax, 4
  0157d	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01581	33 c0		 xor	 eax, eax
  01583	85 c0		 test	 eax, eax
  01585	75 e4		 jne	 SHORT $LN251@inflate

; 889  : #ifndef PKZIP_BUG_WORKAROUND
; 890  :             if (state->nlen > 286 || state->ndist > 30) {

  01587	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0158f	81 78 74 1e 01
	00 00		 cmp	 DWORD PTR [rax+116], 286 ; 0000011eH
  01596	77 0e		 ja	 SHORT $LN247@inflate
  01598	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  015a0	83 78 78 1e	 cmp	 DWORD PTR [rax+120], 30
  015a4	76 26		 jbe	 SHORT $LN248@inflate
$LN247@inflate:

; 891  :                 strm->msg = (char *)"too many length or distance symbols";

  015a6	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  015ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  015b5	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 892  :                 state->mode = BAD;

  015b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  015c1	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 893  :                 break;

  015c7	e9 66 17 00 00	 jmp	 $LN498@inflate
$LN248@inflate:

; 894  :             }
; 895  : #endif
; 896  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 897  :             state->have = 0;

  015cc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  015d4	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 898  :             state->mode = LENLENS;

  015db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  015e3	c7 00 11 00 00
	00		 mov	 DWORD PTR [rax], 17
$LN246@inflate:
$LN245@inflate:

; 899  :         case LENLENS:
; 900  :             while (state->have < state->ncode) {

  015e9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  015f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  015f9	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  015fc	39 48 7c	 cmp	 DWORD PTR [rax+124], ecx
  015ff	0f 83 c3 00 00
	00		 jae	 $LN244@inflate
$LN243@inflate:
$LN240@inflate:

; 901  :                 NEEDBITS(3);

  01605	83 7c 24 4c 03	 cmp	 DWORD PTR bits$[rsp], 3
  0160a	73 50		 jae	 SHORT $LN239@inflate
$LN238@inflate:
  0160c	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01611	75 05		 jne	 SHORT $LN235@inflate
  01613	e9 1f 17 00 00	 jmp	 $inf_leave$4986
$LN235@inflate:
  01618	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  0161c	ff c8		 dec	 eax
  0161e	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01622	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01627	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0162a	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  0162e	d3 e0		 shl	 eax, cl
  01630	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  01634	03 c8		 add	 ecx, eax
  01636	8b c1		 mov	 eax, ecx
  01638	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0163c	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01641	48 ff c0	 inc	 rax
  01644	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01649	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  0164d	83 c0 08	 add	 eax, 8
  01650	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01654	33 c0		 xor	 eax, eax
  01656	85 c0		 test	 eax, eax
  01658	75 b2		 jne	 SHORT $LN238@inflate
  0165a	eb a9		 jmp	 SHORT $LN240@inflate
$LN239@inflate:
  0165c	33 c0		 xor	 eax, eax
  0165e	85 c0		 test	 eax, eax
  01660	75 a3		 jne	 SHORT $LN243@inflate

; 902  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  01662	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01666	83 e0 07	 and	 eax, 7
  01669	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01671	8b 49 7c	 mov	 ecx, DWORD PTR [rcx+124]
  01674	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?order@?1??inflate@@9@9
  0167b	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  0167f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  01687	66 89 84 4a 88
	00 00 00	 mov	 WORD PTR [rdx+rcx*2+136], ax
  0168f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01697	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  0169a	ff c0		 inc	 eax
  0169c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  016a4	89 41 7c	 mov	 DWORD PTR [rcx+124], eax
$LN234@inflate:

; 903  :                 DROPBITS(3);

  016a7	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  016ab	c1 e8 03	 shr	 eax, 3
  016ae	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  016b2	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  016b6	83 e8 03	 sub	 eax, 3
  016b9	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  016bd	33 c0		 xor	 eax, eax
  016bf	85 c0		 test	 eax, eax
  016c1	75 e4		 jne	 SHORT $LN234@inflate

; 904  :             }

  016c3	e9 21 ff ff ff	 jmp	 $LN245@inflate
$LN244@inflate:
$LN231@inflate:

; 905  :             while (state->have < 19)

  016c8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  016d0	83 78 7c 13	 cmp	 DWORD PTR [rax+124], 19
  016d4	73 42		 jae	 SHORT $LN230@inflate

; 906  :                 state->lens[order[state->have++]] = 0;

  016d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  016de	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  016e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?order@?1??inflate@@9@9
  016e8	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  016ec	33 c9		 xor	 ecx, ecx
  016ee	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  016f6	66 89 8c 42 88
	00 00 00	 mov	 WORD PTR [rdx+rax*2+136], cx
  016fe	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01706	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  01709	ff c0		 inc	 eax
  0170b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01713	89 41 7c	 mov	 DWORD PTR [rcx+124], eax
  01716	eb b0		 jmp	 SHORT $LN231@inflate
$LN230@inflate:

; 907  :             state->next = state->codes;

  01718	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01720	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  01726	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0172e	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 908  :             state->lencode = (code const FAR *)(state->next);

  01735	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0173d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01745	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0174c	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 909  :             state->lenbits = 7;

  01750	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01758	c7 40 68 07 00
	00 00		 mov	 DWORD PTR [rax+104], 7

; 910  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 911  :                                 &(state->lenbits), state->work);

  0175f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01767	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  0176d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01775	48 83 c1 68	 add	 rcx, 104		; 00000068H
  01779	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  01781	48 81 c2 80 00
	00 00		 add	 rdx, 128		; 00000080H
  01788	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR state$[rsp]
  01790	49 81 c0 88 00
	00 00		 add	 r8, 136			; 00000088H
  01797	4c 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv706[rsp], r8
  0179f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  017a4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  017a9	4c 8b ca	 mov	 r9, rdx
  017ac	41 b8 13 00 00
	00		 mov	 r8d, 19
  017b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv706[rsp]
  017ba	48 8b d0	 mov	 rdx, rax
  017bd	33 c9		 xor	 ecx, ecx
  017bf	e8 00 00 00 00	 call	 inflate_table
  017c4	89 44 24 60	 mov	 DWORD PTR ret$[rsp], eax

; 912  :             if (ret) {

  017c8	83 7c 24 60 00	 cmp	 DWORD PTR ret$[rsp], 0
  017cd	74 26		 je	 SHORT $LN229@inflate

; 913  :                 strm->msg = (char *)"invalid code lengths set";

  017cf	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  017d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  017de	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 914  :                 state->mode = BAD;

  017e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  017ea	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 915  :                 break;

  017f0	e9 3d 15 00 00	 jmp	 $LN498@inflate
$LN229@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 918  :             state->have = 0;

  017f5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  017fd	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 919  :             state->mode = CODELENS;

  01804	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0180c	c7 00 12 00 00
	00		 mov	 DWORD PTR [rax], 18
$LN228@inflate:
$LN227@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  01812	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0181a	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0181d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01825	03 41 78	 add	 eax, DWORD PTR [rcx+120]
  01828	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01830	39 41 7c	 cmp	 DWORD PTR [rcx+124], eax
  01833	0f 83 c6 04 00
	00		 jae	 $LN226@inflate
$LN225@inflate:

; 922  :                 for (;;) {
; 923  :                     here = state->lencode[BITS(state->lenbits)];

  01839	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01841	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  01844	b9 01 00 00 00	 mov	 ecx, 1
  01849	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv2087[rsp], ecx
  01850	0f b6 c8	 movzx	 ecx, al
  01853	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv2087[rsp]
  0185a	d3 e0		 shl	 eax, cl
  0185c	ff c8		 dec	 eax
  0185e	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  01862	23 c8		 and	 ecx, eax
  01864	8b c1		 mov	 eax, ecx
  01866	8b c0		 mov	 eax, eax
  01868	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01870	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  01874	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  01877	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 924  :                     if ((unsigned)(here.bits) <= bits) break;

  0187b	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01880	3b 44 24 4c	 cmp	 eax, DWORD PTR bits$[rsp]
  01884	77 02		 ja	 SHORT $LN223@inflate
  01886	eb 53		 jmp	 SHORT $LN224@inflate
$LN223@inflate:
$LN222@inflate:

; 925  :                     PULLBYTE();

  01888	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0188d	75 05		 jne	 SHORT $LN219@inflate
  0188f	e9 a3 14 00 00	 jmp	 $inf_leave$4986
$LN219@inflate:
  01894	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01898	ff c8		 dec	 eax
  0189a	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0189e	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  018a3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  018a6	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  018aa	d3 e0		 shl	 eax, cl
  018ac	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  018b0	03 c8		 add	 ecx, eax
  018b2	8b c1		 mov	 eax, ecx
  018b4	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  018b8	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  018bd	48 ff c0	 inc	 rax
  018c0	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  018c5	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  018c9	83 c0 08	 add	 eax, 8
  018cc	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  018d0	33 c0		 xor	 eax, eax
  018d2	85 c0		 test	 eax, eax
  018d4	75 b2		 jne	 SHORT $LN222@inflate

; 926  :                 }

  018d6	e9 5e ff ff ff	 jmp	 $LN225@inflate
$LN224@inflate:

; 927  :                 if (here.val < 16) {

  018db	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  018e0	83 f8 10	 cmp	 eax, 16
  018e3	0f 8d c7 00 00
	00		 jge	 $LN218@inflate
$LN217@inflate:
$LN214@inflate:

; 928  :                     NEEDBITS(here.bits);

  018e9	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  018ee	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  018f2	73 50		 jae	 SHORT $LN213@inflate
$LN212@inflate:
  018f4	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  018f9	75 05		 jne	 SHORT $LN209@inflate
  018fb	e9 37 14 00 00	 jmp	 $inf_leave$4986
$LN209@inflate:
  01900	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01904	ff c8		 dec	 eax
  01906	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0190a	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0190f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01912	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  01916	d3 e0		 shl	 eax, cl
  01918	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  0191c	03 c8		 add	 ecx, eax
  0191e	8b c1		 mov	 eax, ecx
  01920	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01924	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01929	48 ff c0	 inc	 rax
  0192c	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01931	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01935	83 c0 08	 add	 eax, 8
  01938	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0193c	33 c0		 xor	 eax, eax
  0193e	85 c0		 test	 eax, eax
  01940	75 b2		 jne	 SHORT $LN212@inflate
  01942	eb a5		 jmp	 SHORT $LN214@inflate
$LN213@inflate:
  01944	33 c0		 xor	 eax, eax
  01946	85 c0		 test	 eax, eax
  01948	75 9f		 jne	 SHORT $LN217@inflate
$LN208@inflate:

; 929  :                     DROPBITS(here.bits);

  0194a	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  0194f	0f b6 c8	 movzx	 ecx, al
  01952	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01956	d3 e8		 shr	 eax, cl
  01958	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0195c	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01961	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  01965	2b c8		 sub	 ecx, eax
  01967	8b c1		 mov	 eax, ecx
  01969	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0196d	33 c0		 xor	 eax, eax
  0196f	85 c0		 test	 eax, eax
  01971	75 d7		 jne	 SHORT $LN208@inflate

; 930  :                     state->lens[state->have++] = here.val;

  01973	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0197b	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  0197e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01986	0f b7 54 24 3e	 movzx	 edx, WORD PTR here$[rsp+2]
  0198b	66 89 94 41 88
	00 00 00	 mov	 WORD PTR [rcx+rax*2+136], dx
  01993	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0199b	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  0199e	ff c0		 inc	 eax
  019a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  019a8	89 41 7c	 mov	 DWORD PTR [rcx+124], eax

; 931  :                 }
; 932  :                 else {

  019ab	e9 4a 03 00 00	 jmp	 $LN205@inflate
$LN218@inflate:

; 933  :                     if (here.val == 16) {

  019b0	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  019b5	83 f8 10	 cmp	 eax, 16
  019b8	0f 85 13 01 00
	00		 jne	 $LN204@inflate
$LN203@inflate:
$LN200@inflate:

; 934  :                         NEEDBITS(here.bits + 2);

  019be	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  019c3	83 c0 02	 add	 eax, 2
  019c6	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  019ca	73 50		 jae	 SHORT $LN199@inflate
$LN198@inflate:
  019cc	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  019d1	75 05		 jne	 SHORT $LN195@inflate
  019d3	e9 5f 13 00 00	 jmp	 $inf_leave$4986
$LN195@inflate:
  019d8	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  019dc	ff c8		 dec	 eax
  019de	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  019e2	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  019e7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  019ea	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  019ee	d3 e0		 shl	 eax, cl
  019f0	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  019f4	03 c8		 add	 ecx, eax
  019f6	8b c1		 mov	 eax, ecx
  019f8	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  019fc	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01a01	48 ff c0	 inc	 rax
  01a04	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01a09	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01a0d	83 c0 08	 add	 eax, 8
  01a10	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01a14	33 c0		 xor	 eax, eax
  01a16	85 c0		 test	 eax, eax
  01a18	75 b2		 jne	 SHORT $LN198@inflate
  01a1a	eb a2		 jmp	 SHORT $LN200@inflate
$LN199@inflate:
  01a1c	33 c0		 xor	 eax, eax
  01a1e	85 c0		 test	 eax, eax
  01a20	75 9c		 jne	 SHORT $LN203@inflate
$LN194@inflate:

; 935  :                         DROPBITS(here.bits);

  01a22	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01a27	0f b6 c8	 movzx	 ecx, al
  01a2a	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01a2e	d3 e8		 shr	 eax, cl
  01a30	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01a34	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01a39	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  01a3d	2b c8		 sub	 ecx, eax
  01a3f	8b c1		 mov	 eax, ecx
  01a41	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01a45	33 c0		 xor	 eax, eax
  01a47	85 c0		 test	 eax, eax
  01a49	75 d7		 jne	 SHORT $LN194@inflate

; 936  :                         if (state->have == 0) {

  01a4b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01a53	83 78 7c 00	 cmp	 DWORD PTR [rax+124], 0
  01a57	75 26		 jne	 SHORT $LN191@inflate

; 937  :                             strm->msg = (char *)"invalid bit length repeat";

  01a59	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01a61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  01a68	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 938  :                             state->mode = BAD;

  01a6c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01a74	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 939  :                             break;

  01a7a	e9 80 02 00 00	 jmp	 $LN226@inflate
$LN191@inflate:

; 940  :                         }
; 941  :                         len = state->lens[state->have - 1];

  01a7f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01a87	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  01a8a	ff c8		 dec	 eax
  01a8c	8b c0		 mov	 eax, eax
  01a8e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01a96	0f b7 84 41 88
	00 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+136]
  01a9e	89 44 24 48	 mov	 DWORD PTR len$[rsp], eax

; 942  :                         copy = 3 + BITS(2);

  01aa2	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01aa6	83 e0 03	 and	 eax, 3
  01aa9	83 c0 03	 add	 eax, 3
  01aac	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN190@inflate:

; 943  :                         DROPBITS(2);

  01ab0	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01ab4	c1 e8 02	 shr	 eax, 2
  01ab7	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01abb	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01abf	83 e8 02	 sub	 eax, 2
  01ac2	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01ac6	33 c0		 xor	 eax, eax
  01ac8	85 c0		 test	 eax, eax
  01aca	75 e4		 jne	 SHORT $LN190@inflate

; 944  :                     }
; 945  :                     else if (here.val == 17) {

  01acc	e9 91 01 00 00	 jmp	 $LN187@inflate
$LN204@inflate:
  01ad1	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  01ad6	83 f8 11	 cmp	 eax, 17
  01ad9	0f 85 c4 00 00
	00		 jne	 $LN186@inflate
$LN185@inflate:
$LN182@inflate:

; 946  :                         NEEDBITS(here.bits + 3);

  01adf	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01ae4	83 c0 03	 add	 eax, 3
  01ae7	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  01aeb	73 50		 jae	 SHORT $LN181@inflate
$LN180@inflate:
  01aed	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01af2	75 05		 jne	 SHORT $LN177@inflate
  01af4	e9 3e 12 00 00	 jmp	 $inf_leave$4986
$LN177@inflate:
  01af9	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01afd	ff c8		 dec	 eax
  01aff	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01b03	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01b08	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01b0b	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  01b0f	d3 e0		 shl	 eax, cl
  01b11	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  01b15	03 c8		 add	 ecx, eax
  01b17	8b c1		 mov	 eax, ecx
  01b19	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01b1d	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01b22	48 ff c0	 inc	 rax
  01b25	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01b2a	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01b2e	83 c0 08	 add	 eax, 8
  01b31	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01b35	33 c0		 xor	 eax, eax
  01b37	85 c0		 test	 eax, eax
  01b39	75 b2		 jne	 SHORT $LN180@inflate
  01b3b	eb a2		 jmp	 SHORT $LN182@inflate
$LN181@inflate:
  01b3d	33 c0		 xor	 eax, eax
  01b3f	85 c0		 test	 eax, eax
  01b41	75 9c		 jne	 SHORT $LN185@inflate
$LN176@inflate:

; 947  :                         DROPBITS(here.bits);

  01b43	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01b48	0f b6 c8	 movzx	 ecx, al
  01b4b	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01b4f	d3 e8		 shr	 eax, cl
  01b51	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01b55	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01b5a	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  01b5e	2b c8		 sub	 ecx, eax
  01b60	8b c1		 mov	 eax, ecx
  01b62	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01b66	33 c0		 xor	 eax, eax
  01b68	85 c0		 test	 eax, eax
  01b6a	75 d7		 jne	 SHORT $LN176@inflate

; 948  :                         len = 0;

  01b6c	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 949  :                         copy = 3 + BITS(3);

  01b74	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01b78	83 e0 07	 and	 eax, 7
  01b7b	83 c0 03	 add	 eax, 3
  01b7e	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN173@inflate:

; 950  :                         DROPBITS(3);

  01b82	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01b86	c1 e8 03	 shr	 eax, 3
  01b89	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01b8d	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01b91	83 e8 03	 sub	 eax, 3
  01b94	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01b98	33 c0		 xor	 eax, eax
  01b9a	85 c0		 test	 eax, eax
  01b9c	75 e4		 jne	 SHORT $LN173@inflate

; 951  :                     }
; 952  :                     else {

  01b9e	e9 bf 00 00 00	 jmp	 $LN170@inflate
$LN186@inflate:
$LN169@inflate:
$LN166@inflate:

; 953  :                         NEEDBITS(here.bits + 7);

  01ba3	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01ba8	83 c0 07	 add	 eax, 7
  01bab	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  01baf	73 50		 jae	 SHORT $LN165@inflate
$LN164@inflate:
  01bb1	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  01bb6	75 05		 jne	 SHORT $LN161@inflate
  01bb8	e9 7a 11 00 00	 jmp	 $inf_leave$4986
$LN161@inflate:
  01bbd	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  01bc1	ff c8		 dec	 eax
  01bc3	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01bc7	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01bcc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01bcf	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  01bd3	d3 e0		 shl	 eax, cl
  01bd5	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  01bd9	03 c8		 add	 ecx, eax
  01bdb	8b c1		 mov	 eax, ecx
  01bdd	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01be1	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  01be6	48 ff c0	 inc	 rax
  01be9	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01bee	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01bf2	83 c0 08	 add	 eax, 8
  01bf5	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01bf9	33 c0		 xor	 eax, eax
  01bfb	85 c0		 test	 eax, eax
  01bfd	75 b2		 jne	 SHORT $LN164@inflate
  01bff	eb a2		 jmp	 SHORT $LN166@inflate
$LN165@inflate:
  01c01	33 c0		 xor	 eax, eax
  01c03	85 c0		 test	 eax, eax
  01c05	75 9c		 jne	 SHORT $LN169@inflate
$LN160@inflate:

; 954  :                         DROPBITS(here.bits);

  01c07	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01c0c	0f b6 c8	 movzx	 ecx, al
  01c0f	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01c13	d3 e8		 shr	 eax, cl
  01c15	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01c19	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  01c1e	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  01c22	2b c8		 sub	 ecx, eax
  01c24	8b c1		 mov	 eax, ecx
  01c26	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01c2a	33 c0		 xor	 eax, eax
  01c2c	85 c0		 test	 eax, eax
  01c2e	75 d7		 jne	 SHORT $LN160@inflate

; 955  :                         len = 0;

  01c30	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 956  :                         copy = 11 + BITS(7);

  01c38	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01c3c	83 e0 7f	 and	 eax, 127		; 0000007fH
  01c3f	83 c0 0b	 add	 eax, 11
  01c42	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN157@inflate:

; 957  :                         DROPBITS(7);

  01c46	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  01c4a	c1 e8 07	 shr	 eax, 7
  01c4d	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  01c51	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  01c55	83 e8 07	 sub	 eax, 7
  01c58	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  01c5c	33 c0		 xor	 eax, eax
  01c5e	85 c0		 test	 eax, eax
  01c60	75 e4		 jne	 SHORT $LN157@inflate
$LN170@inflate:
$LN187@inflate:

; 958  :                     }
; 959  :                     if (state->have + copy > state->nlen + state->ndist) {

  01c62	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01c6a	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  01c6d	03 44 24 6c	 add	 eax, DWORD PTR copy$[rsp]
  01c71	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01c79	8b 49 74	 mov	 ecx, DWORD PTR [rcx+116]
  01c7c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  01c84	03 4a 78	 add	 ecx, DWORD PTR [rdx+120]
  01c87	3b c1		 cmp	 eax, ecx
  01c89	76 23		 jbe	 SHORT $LN154@inflate

; 960  :                         strm->msg = (char *)"invalid bit length repeat";

  01c8b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01c93	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  01c9a	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 961  :                         state->mode = BAD;

  01c9e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01ca6	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 962  :                         break;

  01cac	eb 51		 jmp	 SHORT $LN226@inflate
$LN154@inflate:
$LN153@inflate:

; 963  :                     }
; 964  :                     while (copy--)

  01cae	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  01cb2	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  01cb6	ff c9		 dec	 ecx
  01cb8	89 4c 24 6c	 mov	 DWORD PTR copy$[rsp], ecx
  01cbc	85 c0		 test	 eax, eax
  01cbe	74 3a		 je	 SHORT $LN152@inflate

; 965  :                         state->lens[state->have++] = (unsigned short)len;

  01cc0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01cc8	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  01ccb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01cd3	0f b7 54 24 48	 movzx	 edx, WORD PTR len$[rsp]
  01cd8	66 89 94 41 88
	00 00 00	 mov	 WORD PTR [rcx+rax*2+136], dx
  01ce0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01ce8	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  01ceb	ff c0		 inc	 eax
  01ced	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01cf5	89 41 7c	 mov	 DWORD PTR [rcx+124], eax
  01cf8	eb b4		 jmp	 SHORT $LN153@inflate
$LN152@inflate:
$LN205@inflate:

; 966  :                 }
; 967  :             }

  01cfa	e9 13 fb ff ff	 jmp	 $LN227@inflate
$LN226@inflate:

; 968  : 
; 969  :             /* handle error breaks in while */
; 970  :             if (state->mode == BAD) break;

  01cff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d07	83 38 1d	 cmp	 DWORD PTR [rax], 29
  01d0a	75 05		 jne	 SHORT $LN151@inflate
  01d0c	e9 21 10 00 00	 jmp	 $LN498@inflate
$LN151@inflate:

; 971  : 
; 972  :             /* check for end-of-block code (better have one) */
; 973  :             if (state->lens[256] == 0) {

  01d11	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d19	0f b7 80 88 02
	00 00		 movzx	 eax, WORD PTR [rax+648]
  01d20	85 c0		 test	 eax, eax
  01d22	75 26		 jne	 SHORT $LN150@inflate

; 974  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  01d24	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01d2c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
  01d33	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 975  :                 state->mode = BAD;

  01d37	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d3f	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 976  :                 break;

  01d45	e9 e8 0f 00 00	 jmp	 $LN498@inflate
$LN150@inflate:

; 977  :             }
; 978  : 
; 979  :             /* build code tables -- note: do not change the lenbits or distbits
; 980  :                values here (9 and 6) without reading the comments in inftrees.h
; 981  :                concerning the ENOUGH constants, which depend on those values */
; 982  :             state->next = state->codes;

  01d4a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d52	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  01d58	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01d60	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 983  :             state->lencode = (code const FAR *)(state->next);

  01d67	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d6f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01d77	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  01d7e	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 984  :             state->lenbits = 9;

  01d82	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d8a	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 985  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 986  :                                 &(state->lenbits), state->work);

  01d91	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d99	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  01d9f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01da7	48 83 c1 68	 add	 rcx, 104		; 00000068H
  01dab	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  01db3	48 81 c2 80 00
	00 00		 add	 rdx, 128		; 00000080H
  01dba	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR state$[rsp]
  01dc2	49 81 c0 88 00
	00 00		 add	 r8, 136			; 00000088H
  01dc9	4c 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv879[rsp], r8
  01dd1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01dd6	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01ddb	4c 8b ca	 mov	 r9, rdx
  01dde	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01de6	44 8b 40 74	 mov	 r8d, DWORD PTR [rax+116]
  01dea	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv879[rsp]
  01df2	48 8b d0	 mov	 rdx, rax
  01df5	b9 01 00 00 00	 mov	 ecx, 1
  01dfa	e8 00 00 00 00	 call	 inflate_table
  01dff	89 44 24 60	 mov	 DWORD PTR ret$[rsp], eax

; 987  :             if (ret) {

  01e03	83 7c 24 60 00	 cmp	 DWORD PTR ret$[rsp], 0
  01e08	74 26		 je	 SHORT $LN149@inflate

; 988  :                 strm->msg = (char *)"invalid literal/lengths set";

  01e0a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01e12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  01e19	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 989  :                 state->mode = BAD;

  01e1d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e25	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 990  :                 break;

  01e2b	e9 02 0f 00 00	 jmp	 $LN498@inflate
$LN149@inflate:

; 991  :             }
; 992  :             state->distcode = (code const FAR *)(state->next);

  01e30	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e38	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01e40	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  01e47	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 993  :             state->distbits = 6;

  01e4b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e53	c7 40 6c 06 00
	00 00		 mov	 DWORD PTR [rax+108], 6

; 994  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 995  :                             &(state->next), &(state->distbits), state->work);

  01e5a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e62	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  01e68	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01e70	48 83 c1 6c	 add	 rcx, 108		; 0000006cH
  01e74	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  01e7c	48 81 c2 80 00
	00 00		 add	 rdx, 128		; 00000080H
  01e83	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR state$[rsp]
  01e8b	45 8b 40 74	 mov	 r8d, DWORD PTR [r8+116]
  01e8f	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR state$[rsp]
  01e97	4f 8d 84 41 88
	00 00 00	 lea	 r8, QWORD PTR [r9+r8*2+136]
  01e9f	4c 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv900[rsp], r8
  01ea7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01eac	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01eb1	4c 8b ca	 mov	 r9, rdx
  01eb4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01ebc	44 8b 40 78	 mov	 r8d, DWORD PTR [rax+120]
  01ec0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv900[rsp]
  01ec8	48 8b d0	 mov	 rdx, rax
  01ecb	b9 02 00 00 00	 mov	 ecx, 2
  01ed0	e8 00 00 00 00	 call	 inflate_table
  01ed5	89 44 24 60	 mov	 DWORD PTR ret$[rsp], eax

; 996  :             if (ret) {

  01ed9	83 7c 24 60 00	 cmp	 DWORD PTR ret$[rsp], 0
  01ede	74 26		 je	 SHORT $LN148@inflate

; 997  :                 strm->msg = (char *)"invalid distances set";

  01ee0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01ee8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  01eef	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 998  :                 state->mode = BAD;

  01ef3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01efb	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 999  :                 break;

  01f01	e9 2c 0e 00 00	 jmp	 $LN498@inflate
$LN148@inflate:

; 1000 :             }
; 1001 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1002 :             state->mode = LEN_;

  01f06	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01f0e	c7 00 13 00 00
	00		 mov	 DWORD PTR [rax], 19

; 1003 :             if (flush == Z_TREES) goto inf_leave;

  01f14	83 bc 24 18 01
	00 00 06	 cmp	 DWORD PTR flush$[rsp], 6
  01f1c	75 05		 jne	 SHORT $LN147@inflate
  01f1e	e9 14 0e 00 00	 jmp	 $inf_leave$4986
$LN147@inflate:
$LN146@inflate:

; 1004 :         case LEN_:
; 1005 :             state->mode = LEN;

  01f23	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01f2b	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20
$LN145@inflate:

; 1006 :         case LEN:
; 1007 :             if (have >= 6 && left >= 258) {

  01f31	83 7c 24 40 06	 cmp	 DWORD PTR have$[rsp], 6
  01f36	0f 82 09 01 00
	00		 jb	 $LN144@inflate
  01f3c	81 7c 24 50 02
	01 00 00	 cmp	 DWORD PTR left$[rsp], 258 ; 00000102H
  01f44	0f 82 fb 00 00
	00		 jb	 $LN144@inflate
$LN143@inflate:

; 1008 :                 RESTORE();

  01f4a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f52	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  01f57	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  01f5b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f63	8b 4c 24 50	 mov	 ecx, DWORD PTR left$[rsp]
  01f67	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  01f6a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f72	48 8b 4c 24 58	 mov	 rcx, QWORD PTR next$[rsp]
  01f77	48 89 08	 mov	 QWORD PTR [rax], rcx
  01f7a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f82	8b 4c 24 40	 mov	 ecx, DWORD PTR have$[rsp]
  01f86	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  01f89	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01f91	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  01f95	89 48 40	 mov	 DWORD PTR [rax+64], ecx
  01f98	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01fa0	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  01fa4	89 48 44	 mov	 DWORD PTR [rax+68], ecx
  01fa7	33 c0		 xor	 eax, eax
  01fa9	85 c0		 test	 eax, eax
  01fab	75 9d		 jne	 SHORT $LN143@inflate

; 1009 :                 inflate_fast(strm, out);

  01fad	8b 54 24 78	 mov	 edx, DWORD PTR out$[rsp]
  01fb1	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01fb9	e8 00 00 00 00	 call	 inflate_fast
$LN140@inflate:

; 1010 :                 LOAD();

  01fbe	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01fc6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01fca	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  01fcf	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01fd7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01fda	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax
  01fde	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01fe6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01fe9	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  01fee	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01ff6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  01ff9	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  01ffd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02005	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  02008	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  0200c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02014	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  02017	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0201b	33 c0		 xor	 eax, eax
  0201d	85 c0		 test	 eax, eax
  0201f	75 9d		 jne	 SHORT $LN140@inflate

; 1011 :                 if (state->mode == TYPE)

  02021	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02029	83 38 0b	 cmp	 DWORD PTR [rax], 11
  0202c	75 12		 jne	 SHORT $LN137@inflate

; 1012 :                     state->back = -1;

  0202e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02036	c7 80 dc 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+7132], -1
$LN137@inflate:

; 1013 :                 break;

  02040	e9 ed 0c 00 00	 jmp	 $LN498@inflate
$LN144@inflate:

; 1014 :             }
; 1015 :             state->back = 0;

  02045	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0204d	c7 80 dc 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+7132], 0
$LN136@inflate:

; 1016 :             for (;;) {
; 1017 :                 here = state->lencode[BITS(state->lenbits)];

  02057	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0205f	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  02062	b9 01 00 00 00	 mov	 ecx, 1
  02067	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv2263[rsp], ecx
  0206e	0f b6 c8	 movzx	 ecx, al
  02071	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv2263[rsp]
  02078	d3 e0		 shl	 eax, cl
  0207a	ff c8		 dec	 eax
  0207c	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02080	23 c8		 and	 ecx, eax
  02082	8b c1		 mov	 eax, ecx
  02084	8b c0		 mov	 eax, eax
  02086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0208e	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  02092	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  02095	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 1018 :                 if ((unsigned)(here.bits) <= bits) break;

  02099	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  0209e	3b 44 24 4c	 cmp	 eax, DWORD PTR bits$[rsp]
  020a2	77 02		 ja	 SHORT $LN134@inflate
  020a4	eb 53		 jmp	 SHORT $LN135@inflate
$LN134@inflate:
$LN133@inflate:

; 1019 :                 PULLBYTE();

  020a6	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  020ab	75 05		 jne	 SHORT $LN130@inflate
  020ad	e9 85 0c 00 00	 jmp	 $inf_leave$4986
$LN130@inflate:
  020b2	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  020b6	ff c8		 dec	 eax
  020b8	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  020bc	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  020c1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  020c4	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  020c8	d3 e0		 shl	 eax, cl
  020ca	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  020ce	03 c8		 add	 ecx, eax
  020d0	8b c1		 mov	 eax, ecx
  020d2	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  020d6	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  020db	48 ff c0	 inc	 rax
  020de	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  020e3	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  020e7	83 c0 08	 add	 eax, 8
  020ea	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  020ee	33 c0		 xor	 eax, eax
  020f0	85 c0		 test	 eax, eax
  020f2	75 b2		 jne	 SHORT $LN133@inflate

; 1020 :             }

  020f4	e9 5e ff ff ff	 jmp	 $LN136@inflate
$LN135@inflate:

; 1021 :             if (here.op && (here.op & 0xf0) == 0) {

  020f9	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  020fe	85 c0		 test	 eax, eax
  02100	0f 84 20 01 00
	00		 je	 $LN129@inflate
  02106	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  0210b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  02110	85 c0		 test	 eax, eax
  02112	0f 85 0e 01 00
	00		 jne	 $LN129@inflate

; 1022 :                 last = here;

  02118	8b 44 24 3c	 mov	 eax, DWORD PTR here$[rsp]
  0211c	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN128@inflate:

; 1023 :                 for (;;) {
; 1024 :                     here = state->lencode[last.val +
; 1025 :                             (BITS(last.bits + last.op) >> last.bits)];

  02120	0f b7 44 24 3a	 movzx	 eax, WORD PTR last$[rsp+2]
  02125	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  0212a	0f b6 54 24 38	 movzx	 edx, BYTE PTR last$[rsp]
  0212f	03 ca		 add	 ecx, edx
  02131	ba 01 00 00 00	 mov	 edx, 1
  02136	d3 e2		 shl	 edx, cl
  02138	8b ca		 mov	 ecx, edx
  0213a	ff c9		 dec	 ecx
  0213c	8b 54 24 64	 mov	 edx, DWORD PTR hold$[rsp]
  02140	23 d1		 and	 edx, ecx
  02142	8b ca		 mov	 ecx, edx
  02144	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv956[rsp], ecx
  0214b	0f b6 54 24 39	 movzx	 edx, BYTE PTR last$[rsp+1]
  02150	0f b6 ca	 movzx	 ecx, dl
  02153	8b 94 24 d4 00
	00 00		 mov	 edx, DWORD PTR tv956[rsp]
  0215a	d3 ea		 shr	 edx, cl
  0215c	8b ca		 mov	 ecx, edx
  0215e	03 c1		 add	 eax, ecx
  02160	8b c0		 mov	 eax, eax
  02162	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0216a	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0216e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  02171	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 1026 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  02175	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  0217a	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  0217f	03 c1		 add	 eax, ecx
  02181	3b 44 24 4c	 cmp	 eax, DWORD PTR bits$[rsp]
  02185	77 02		 ja	 SHORT $LN126@inflate
  02187	eb 53		 jmp	 SHORT $LN127@inflate
$LN126@inflate:
$LN125@inflate:

; 1027 :                     PULLBYTE();

  02189	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  0218e	75 05		 jne	 SHORT $LN122@inflate
  02190	e9 a2 0b 00 00	 jmp	 $inf_leave$4986
$LN122@inflate:
  02195	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  02199	ff c8		 dec	 eax
  0219b	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0219f	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  021a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  021a7	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  021ab	d3 e0		 shl	 eax, cl
  021ad	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  021b1	03 c8		 add	 ecx, eax
  021b3	8b c1		 mov	 eax, ecx
  021b5	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  021b9	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  021be	48 ff c0	 inc	 rax
  021c1	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  021c6	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  021ca	83 c0 08	 add	 eax, 8
  021cd	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  021d1	33 c0		 xor	 eax, eax
  021d3	85 c0		 test	 eax, eax
  021d5	75 b2		 jne	 SHORT $LN125@inflate

; 1028 :                 }

  021d7	e9 44 ff ff ff	 jmp	 $LN128@inflate
$LN127@inflate:
$LN121@inflate:

; 1029 :                 DROPBITS(last.bits);

  021dc	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  021e1	0f b6 c8	 movzx	 ecx, al
  021e4	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  021e8	d3 e8		 shr	 eax, cl
  021ea	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  021ee	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  021f3	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  021f7	2b c8		 sub	 ecx, eax
  021f9	8b c1		 mov	 eax, ecx
  021fb	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  021ff	33 c0		 xor	 eax, eax
  02201	85 c0		 test	 eax, eax
  02203	75 d7		 jne	 SHORT $LN121@inflate

; 1030 :                 state->back += last.bits;

  02205	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  0220a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02212	03 81 dc 1b 00
	00		 add	 eax, DWORD PTR [rcx+7132]
  02218	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02220	89 81 dc 1b 00
	00		 mov	 DWORD PTR [rcx+7132], eax
$LN129@inflate:
$LN118@inflate:

; 1031 :             }
; 1032 :             DROPBITS(here.bits);

  02226	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  0222b	0f b6 c8	 movzx	 ecx, al
  0222e	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  02232	d3 e8		 shr	 eax, cl
  02234	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02238	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  0223d	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  02241	2b c8		 sub	 ecx, eax
  02243	8b c1		 mov	 eax, ecx
  02245	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  02249	33 c0		 xor	 eax, eax
  0224b	85 c0		 test	 eax, eax
  0224d	75 d7		 jne	 SHORT $LN118@inflate

; 1033 :             state->back += here.bits;

  0224f	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  02254	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0225c	03 81 dc 1b 00
	00		 add	 eax, DWORD PTR [rcx+7132]
  02262	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0226a	89 81 dc 1b 00
	00		 mov	 DWORD PTR [rcx+7132], eax

; 1034 :             state->length = (unsigned)here.val;

  02270	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  02275	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0227d	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 1035 :             if ((int)(here.op) == 0) {

  02280	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  02285	85 c0		 test	 eax, eax
  02287	75 13		 jne	 SHORT $LN115@inflate

; 1036 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1037 :                         "inflate:         literal '%c'\n" :
; 1038 :                         "inflate:         literal 0x%02x\n", here.val));
; 1039 :                 state->mode = LIT;

  02289	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02291	c7 00 19 00 00
	00		 mov	 DWORD PTR [rax], 25

; 1040 :                 break;

  02297	e9 96 0a 00 00	 jmp	 $LN498@inflate
$LN115@inflate:

; 1041 :             }
; 1042 :             if (here.op & 32) {

  0229c	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  022a1	83 e0 20	 and	 eax, 32			; 00000020H
  022a4	85 c0		 test	 eax, eax
  022a6	74 25		 je	 SHORT $LN114@inflate

; 1043 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1044 :                 state->back = -1;

  022a8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  022b0	c7 80 dc 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+7132], -1

; 1045 :                 state->mode = TYPE;

  022ba	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  022c2	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 1046 :                 break;

  022c8	e9 65 0a 00 00	 jmp	 $LN498@inflate
$LN114@inflate:

; 1047 :             }
; 1048 :             if (here.op & 64) {

  022cd	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  022d2	83 e0 40	 and	 eax, 64			; 00000040H
  022d5	85 c0		 test	 eax, eax
  022d7	74 26		 je	 SHORT $LN113@inflate

; 1049 :                 strm->msg = (char *)"invalid literal/length code";

  022d9	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  022e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  022e8	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1050 :                 state->mode = BAD;

  022ec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  022f4	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 1051 :                 break;

  022fa	e9 33 0a 00 00	 jmp	 $LN498@inflate
$LN113@inflate:

; 1052 :             }
; 1053 :             state->extra = (unsigned)(here.op) & 15;

  022ff	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  02304	83 e0 0f	 and	 eax, 15
  02307	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0230f	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 1054 :             state->mode = LENEXT;

  02312	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0231a	c7 00 15 00 00
	00		 mov	 DWORD PTR [rax], 21
$LN112@inflate:

; 1055 :         case LENEXT:
; 1056 :             if (state->extra) {

  02320	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02328	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  0232c	0f 84 06 01 00
	00		 je	 $LN111@inflate
$LN110@inflate:
$LN107@inflate:

; 1057 :                 NEEDBITS(state->extra);

  02332	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0233a	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0233d	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  02341	73 50		 jae	 SHORT $LN106@inflate
$LN105@inflate:
  02343	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  02348	75 05		 jne	 SHORT $LN102@inflate
  0234a	e9 e8 09 00 00	 jmp	 $inf_leave$4986
$LN102@inflate:
  0234f	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  02353	ff c8		 dec	 eax
  02355	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  02359	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0235e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02361	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  02365	d3 e0		 shl	 eax, cl
  02367	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  0236b	03 c8		 add	 ecx, eax
  0236d	8b c1		 mov	 eax, ecx
  0236f	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02373	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02378	48 ff c0	 inc	 rax
  0237b	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  02380	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02384	83 c0 08	 add	 eax, 8
  02387	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0238b	33 c0		 xor	 eax, eax
  0238d	85 c0		 test	 eax, eax
  0238f	75 b2		 jne	 SHORT $LN105@inflate
  02391	eb 9f		 jmp	 SHORT $LN107@inflate
$LN106@inflate:
  02393	33 c0		 xor	 eax, eax
  02395	85 c0		 test	 eax, eax
  02397	75 99		 jne	 SHORT $LN110@inflate

; 1058 :                 state->length += BITS(state->extra);

  02399	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  023a1	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  023a4	b9 01 00 00 00	 mov	 ecx, 1
  023a9	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv2337[rsp], ecx
  023b0	0f b6 c8	 movzx	 ecx, al
  023b3	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv2337[rsp]
  023ba	d3 e0		 shl	 eax, cl
  023bc	ff c8		 dec	 eax
  023be	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  023c2	23 c8		 and	 ecx, eax
  023c4	8b c1		 mov	 eax, ecx
  023c6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  023ce	03 41 48	 add	 eax, DWORD PTR [rcx+72]
  023d1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  023d9	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN101@inflate:

; 1059 :                 DROPBITS(state->extra);

  023dc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  023e4	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  023e7	0f b6 c8	 movzx	 ecx, al
  023ea	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  023ee	d3 e8		 shr	 eax, cl
  023f0	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  023f4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  023fc	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  023ff	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  02403	2b c8		 sub	 ecx, eax
  02405	8b c1		 mov	 eax, ecx
  02407	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  0240b	33 c0		 xor	 eax, eax
  0240d	85 c0		 test	 eax, eax
  0240f	75 cb		 jne	 SHORT $LN101@inflate

; 1060 :                 state->back += state->extra;

  02411	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02419	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  0241f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02427	03 41 50	 add	 eax, DWORD PTR [rcx+80]
  0242a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02432	89 81 dc 1b 00
	00		 mov	 DWORD PTR [rcx+7132], eax
$LN111@inflate:

; 1061 :             }
; 1062 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1063 :             state->was = state->length;

  02438	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02440	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02448	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  0244b	89 88 e0 1b 00
	00		 mov	 DWORD PTR [rax+7136], ecx

; 1064 :             state->mode = DIST;

  02451	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02459	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
$LN98@inflate:
$LN97@inflate:

; 1065 :         case DIST:
; 1066 :             for (;;) {
; 1067 :                 here = state->distcode[BITS(state->distbits)];

  0245f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02467	8b 40 6c	 mov	 eax, DWORD PTR [rax+108]
  0246a	b9 01 00 00 00	 mov	 ecx, 1
  0246f	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv2361[rsp], ecx
  02476	0f b6 c8	 movzx	 ecx, al
  02479	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR tv2361[rsp]
  02480	d3 e0		 shl	 eax, cl
  02482	ff c8		 dec	 eax
  02484	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02488	23 c8		 and	 ecx, eax
  0248a	8b c1		 mov	 eax, ecx
  0248c	8b c0		 mov	 eax, eax
  0248e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02496	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0249a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0249d	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 1068 :                 if ((unsigned)(here.bits) <= bits) break;

  024a1	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  024a6	3b 44 24 4c	 cmp	 eax, DWORD PTR bits$[rsp]
  024aa	77 02		 ja	 SHORT $LN95@inflate
  024ac	eb 53		 jmp	 SHORT $LN96@inflate
$LN95@inflate:
$LN94@inflate:

; 1069 :                 PULLBYTE();

  024ae	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  024b3	75 05		 jne	 SHORT $LN91@inflate
  024b5	e9 7d 08 00 00	 jmp	 $inf_leave$4986
$LN91@inflate:
  024ba	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  024be	ff c8		 dec	 eax
  024c0	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  024c4	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  024c9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  024cc	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  024d0	d3 e0		 shl	 eax, cl
  024d2	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  024d6	03 c8		 add	 ecx, eax
  024d8	8b c1		 mov	 eax, ecx
  024da	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  024de	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  024e3	48 ff c0	 inc	 rax
  024e6	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  024eb	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  024ef	83 c0 08	 add	 eax, 8
  024f2	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  024f6	33 c0		 xor	 eax, eax
  024f8	85 c0		 test	 eax, eax
  024fa	75 b2		 jne	 SHORT $LN94@inflate

; 1070 :             }

  024fc	e9 5e ff ff ff	 jmp	 $LN97@inflate
$LN96@inflate:

; 1071 :             if ((here.op & 0xf0) == 0) {

  02501	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  02506	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0250b	85 c0		 test	 eax, eax
  0250d	0f 85 0e 01 00
	00		 jne	 $LN90@inflate

; 1072 :                 last = here;

  02513	8b 44 24 3c	 mov	 eax, DWORD PTR here$[rsp]
  02517	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN89@inflate:

; 1073 :                 for (;;) {
; 1074 :                     here = state->distcode[last.val +
; 1075 :                             (BITS(last.bits + last.op) >> last.bits)];

  0251b	0f b7 44 24 3a	 movzx	 eax, WORD PTR last$[rsp+2]
  02520	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  02525	0f b6 54 24 38	 movzx	 edx, BYTE PTR last$[rsp]
  0252a	03 ca		 add	 ecx, edx
  0252c	ba 01 00 00 00	 mov	 edx, 1
  02531	d3 e2		 shl	 edx, cl
  02533	8b ca		 mov	 ecx, edx
  02535	ff c9		 dec	 ecx
  02537	8b 54 24 64	 mov	 edx, DWORD PTR hold$[rsp]
  0253b	23 d1		 and	 edx, ecx
  0253d	8b ca		 mov	 ecx, edx
  0253f	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR tv1101[rsp], ecx
  02546	0f b6 54 24 39	 movzx	 edx, BYTE PTR last$[rsp+1]
  0254b	0f b6 ca	 movzx	 ecx, dl
  0254e	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR tv1101[rsp]
  02555	d3 ea		 shr	 edx, cl
  02557	8b ca		 mov	 ecx, edx
  02559	03 c1		 add	 eax, ecx
  0255b	8b c0		 mov	 eax, eax
  0255d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02565	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  02569	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0256c	89 44 24 3c	 mov	 DWORD PTR here$[rsp], eax

; 1076 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  02570	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  02575	0f b6 4c 24 3d	 movzx	 ecx, BYTE PTR here$[rsp+1]
  0257a	03 c1		 add	 eax, ecx
  0257c	3b 44 24 4c	 cmp	 eax, DWORD PTR bits$[rsp]
  02580	77 02		 ja	 SHORT $LN87@inflate
  02582	eb 53		 jmp	 SHORT $LN88@inflate
$LN87@inflate:
$LN86@inflate:

; 1077 :                     PULLBYTE();

  02584	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  02589	75 05		 jne	 SHORT $LN83@inflate
  0258b	e9 a7 07 00 00	 jmp	 $inf_leave$4986
$LN83@inflate:
  02590	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  02594	ff c8		 dec	 eax
  02596	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  0259a	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0259f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  025a2	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  025a6	d3 e0		 shl	 eax, cl
  025a8	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  025ac	03 c8		 add	 ecx, eax
  025ae	8b c1		 mov	 eax, ecx
  025b0	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  025b4	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  025b9	48 ff c0	 inc	 rax
  025bc	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  025c1	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  025c5	83 c0 08	 add	 eax, 8
  025c8	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  025cc	33 c0		 xor	 eax, eax
  025ce	85 c0		 test	 eax, eax
  025d0	75 b2		 jne	 SHORT $LN86@inflate

; 1078 :                 }

  025d2	e9 44 ff ff ff	 jmp	 $LN89@inflate
$LN88@inflate:
$LN82@inflate:

; 1079 :                 DROPBITS(last.bits);

  025d7	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  025dc	0f b6 c8	 movzx	 ecx, al
  025df	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  025e3	d3 e8		 shr	 eax, cl
  025e5	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  025e9	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  025ee	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  025f2	2b c8		 sub	 ecx, eax
  025f4	8b c1		 mov	 eax, ecx
  025f6	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  025fa	33 c0		 xor	 eax, eax
  025fc	85 c0		 test	 eax, eax
  025fe	75 d7		 jne	 SHORT $LN82@inflate

; 1080 :                 state->back += last.bits;

  02600	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  02605	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0260d	03 81 dc 1b 00
	00		 add	 eax, DWORD PTR [rcx+7132]
  02613	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0261b	89 81 dc 1b 00
	00		 mov	 DWORD PTR [rcx+7132], eax
$LN90@inflate:
$LN79@inflate:

; 1081 :             }
; 1082 :             DROPBITS(here.bits);

  02621	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  02626	0f b6 c8	 movzx	 ecx, al
  02629	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0262d	d3 e8		 shr	 eax, cl
  0262f	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02633	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  02638	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  0263c	2b c8		 sub	 ecx, eax
  0263e	8b c1		 mov	 eax, ecx
  02640	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  02644	33 c0		 xor	 eax, eax
  02646	85 c0		 test	 eax, eax
  02648	75 d7		 jne	 SHORT $LN79@inflate

; 1083 :             state->back += here.bits;

  0264a	0f b6 44 24 3d	 movzx	 eax, BYTE PTR here$[rsp+1]
  0264f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02657	03 81 dc 1b 00
	00		 add	 eax, DWORD PTR [rcx+7132]
  0265d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02665	89 81 dc 1b 00
	00		 mov	 DWORD PTR [rcx+7132], eax

; 1084 :             if (here.op & 64) {

  0266b	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  02670	83 e0 40	 and	 eax, 64			; 00000040H
  02673	85 c0		 test	 eax, eax
  02675	74 26		 je	 SHORT $LN76@inflate

; 1085 :                 strm->msg = (char *)"invalid distance code";

  02677	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0267f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  02686	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1086 :                 state->mode = BAD;

  0268a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02692	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 1087 :                 break;

  02698	e9 95 06 00 00	 jmp	 $LN498@inflate
$LN76@inflate:

; 1088 :             }
; 1089 :             state->offset = (unsigned)here.val;

  0269d	0f b7 44 24 3e	 movzx	 eax, WORD PTR here$[rsp+2]
  026a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  026aa	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 1090 :             state->extra = (unsigned)(here.op) & 15;

  026ad	0f b6 44 24 3c	 movzx	 eax, BYTE PTR here$[rsp]
  026b2	83 e0 0f	 and	 eax, 15
  026b5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  026bd	89 41 50	 mov	 DWORD PTR [rcx+80], eax

; 1091 :             state->mode = DISTEXT;

  026c0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  026c8	c7 00 17 00 00
	00		 mov	 DWORD PTR [rax], 23
$LN75@inflate:

; 1092 :         case DISTEXT:
; 1093 :             if (state->extra) {

  026ce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  026d6	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  026da	0f 84 06 01 00
	00		 je	 $LN74@inflate
$LN73@inflate:
$LN70@inflate:

; 1094 :                 NEEDBITS(state->extra);

  026e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  026e8	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  026eb	39 44 24 4c	 cmp	 DWORD PTR bits$[rsp], eax
  026ef	73 50		 jae	 SHORT $LN69@inflate
$LN68@inflate:
  026f1	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  026f6	75 05		 jne	 SHORT $LN65@inflate
  026f8	e9 3a 06 00 00	 jmp	 $inf_leave$4986
$LN65@inflate:
  026fd	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  02701	ff c8		 dec	 eax
  02703	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  02707	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  0270c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0270f	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  02713	d3 e0		 shl	 eax, cl
  02715	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02719	03 c8		 add	 ecx, eax
  0271b	8b c1		 mov	 eax, ecx
  0271d	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02721	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02726	48 ff c0	 inc	 rax
  02729	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  0272e	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02732	83 c0 08	 add	 eax, 8
  02735	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  02739	33 c0		 xor	 eax, eax
  0273b	85 c0		 test	 eax, eax
  0273d	75 b2		 jne	 SHORT $LN68@inflate
  0273f	eb 9f		 jmp	 SHORT $LN70@inflate
$LN69@inflate:
  02741	33 c0		 xor	 eax, eax
  02743	85 c0		 test	 eax, eax
  02745	75 99		 jne	 SHORT $LN73@inflate

; 1095 :                 state->offset += BITS(state->extra);

  02747	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0274f	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  02752	b9 01 00 00 00	 mov	 ecx, 1
  02757	89 8c 24 e4 00
	00 00		 mov	 DWORD PTR tv2431[rsp], ecx
  0275e	0f b6 c8	 movzx	 ecx, al
  02761	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR tv2431[rsp]
  02768	d3 e0		 shl	 eax, cl
  0276a	ff c8		 dec	 eax
  0276c	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02770	23 c8		 and	 ecx, eax
  02772	8b c1		 mov	 eax, ecx
  02774	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0277c	03 41 4c	 add	 eax, DWORD PTR [rcx+76]
  0277f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02787	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN64@inflate:

; 1096 :                 DROPBITS(state->extra);

  0278a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02792	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  02795	0f b6 c8	 movzx	 ecx, al
  02798	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  0279c	d3 e8		 shr	 eax, cl
  0279e	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  027a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  027aa	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  027ad	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  027b1	2b c8		 sub	 ecx, eax
  027b3	8b c1		 mov	 eax, ecx
  027b5	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  027b9	33 c0		 xor	 eax, eax
  027bb	85 c0		 test	 eax, eax
  027bd	75 cb		 jne	 SHORT $LN64@inflate

; 1097 :                 state->back += state->extra;

  027bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  027c7	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  027cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  027d5	03 41 50	 add	 eax, DWORD PTR [rcx+80]
  027d8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  027e0	89 81 dc 1b 00
	00		 mov	 DWORD PTR [rcx+7132], eax
$LN74@inflate:

; 1098 :             }
; 1099 : #ifdef INFLATE_STRICT
; 1100 :             if (state->offset > state->dmax) {
; 1101 :                 strm->msg = (char *)"invalid distance too far back";
; 1102 :                 state->mode = BAD;
; 1103 :                 break;
; 1104 :             }
; 1105 : #endif
; 1106 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1107 :             state->mode = MATCH;

  027e6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  027ee	c7 00 18 00 00
	00		 mov	 DWORD PTR [rax], 24
$LN61@inflate:

; 1108 :         case MATCH:
; 1109 :             if (left == 0) goto inf_leave;

  027f4	83 7c 24 50 00	 cmp	 DWORD PTR left$[rsp], 0
  027f9	75 05		 jne	 SHORT $LN60@inflate
  027fb	e9 37 05 00 00	 jmp	 $inf_leave$4986
$LN60@inflate:

; 1110 :             copy = out - left;

  02800	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  02804	8b 4c 24 78	 mov	 ecx, DWORD PTR out$[rsp]
  02808	2b c8		 sub	 ecx, eax
  0280a	8b c1		 mov	 eax, ecx
  0280c	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 1111 :             if (state->offset > copy) {         /* copy from window */

  02810	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02818	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  0281c	39 48 4c	 cmp	 DWORD PTR [rax+76], ecx
  0281f	0f 86 f1 00 00
	00		 jbe	 $LN59@inflate

; 1112 :                 copy = state->offset - copy;

  02825	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0282d	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  02831	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  02834	2b c1		 sub	 eax, ecx
  02836	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 1113 :                 if (copy > state->whave) {

  0283a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02842	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  02845	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  02849	76 37		 jbe	 SHORT $LN58@inflate

; 1114 :                     if (state->sane) {

  0284b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02853	83 b8 d8 1b 00
	00 00		 cmp	 DWORD PTR [rax+7128], 0
  0285a	74 26		 je	 SHORT $LN57@inflate

; 1115 :                         strm->msg = (char *)"invalid distance too far back";

  0285c	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02864	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  0286b	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1116 :                         state->mode = BAD;

  0286f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02877	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 1117 :                         break;

  0287d	e9 b0 04 00 00	 jmp	 $LN498@inflate
$LN57@inflate:
$LN58@inflate:

; 1118 :                     }
; 1119 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1120 :                     Trace((stderr, "inflate.c too far\n"));
; 1121 :                     copy -= state->whave;
; 1122 :                     if (copy > state->length) copy = state->length;
; 1123 :                     if (copy > left) copy = left;
; 1124 :                     left -= copy;
; 1125 :                     state->length -= copy;
; 1126 :                     do {
; 1127 :                         *put++ = 0;
; 1128 :                     } while (--copy);
; 1129 :                     if (state->length == 0) state->mode = LEN;
; 1130 :                     break;
; 1131 : #endif
; 1132 :                 }
; 1133 :                 if (copy > state->wnext) {

  02882	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0288a	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0288d	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  02891	76 3d		 jbe	 SHORT $LN56@inflate

; 1134 :                     copy -= state->wnext;

  02893	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0289b	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0289e	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  028a2	2b c8		 sub	 ecx, eax
  028a4	8b c1		 mov	 eax, ecx
  028a6	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax

; 1135 :                     from = state->window + (state->wsize - copy);

  028aa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  028b2	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  028b6	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  028b9	2b c1		 sub	 eax, ecx
  028bb	8b c0		 mov	 eax, eax
  028bd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  028c5	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  028c9	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax

; 1136 :                 }
; 1137 :                 else

  028ce	eb 24		 jmp	 SHORT $LN55@inflate
$LN56@inflate:

; 1138 :                     from = state->window + (state->wnext - copy);

  028d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  028d8	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  028dc	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  028df	2b c1		 sub	 eax, ecx
  028e1	8b c0		 mov	 eax, eax
  028e3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  028eb	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  028ef	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax
$LN55@inflate:

; 1139 :                 if (copy > state->length) copy = state->length;

  028f4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  028fc	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  028ff	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  02903	76 0f		 jbe	 SHORT $LN54@inflate
  02905	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0290d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02910	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN54@inflate:

; 1140 :             }
; 1141 :             else {                              /* copy from output */

  02914	eb 2a		 jmp	 SHORT $LN53@inflate
$LN59@inflate:

; 1142 :                 from = put - state->offset;

  02916	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0291e	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  02921	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  02926	48 2b c8	 sub	 rcx, rax
  02929	48 8b c1	 mov	 rax, rcx
  0292c	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax

; 1143 :                 copy = state->length;

  02931	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02939	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0293c	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN53@inflate:

; 1144 :             }
; 1145 :             if (copy > left) copy = left;

  02940	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  02944	39 44 24 6c	 cmp	 DWORD PTR copy$[rsp], eax
  02948	76 08		 jbe	 SHORT $LN52@inflate
  0294a	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  0294e	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
$LN52@inflate:

; 1146 :             left -= copy;

  02952	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  02956	8b 4c 24 50	 mov	 ecx, DWORD PTR left$[rsp]
  0295a	2b c8		 sub	 ecx, eax
  0295c	8b c1		 mov	 eax, ecx
  0295e	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax

; 1147 :             state->length -= copy;

  02962	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0296a	8b 4c 24 6c	 mov	 ecx, DWORD PTR copy$[rsp]
  0296e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02971	2b c1		 sub	 eax, ecx
  02973	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0297b	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN51@inflate:

; 1148 :             do {
; 1149 :                 *put++ = *from++;

  0297e	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  02983	48 8b 4c 24 70	 mov	 rcx, QWORD PTR from$[rsp]
  02988	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0298b	88 08		 mov	 BYTE PTR [rax], cl
  0298d	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  02992	48 ff c0	 inc	 rax
  02995	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  0299a	48 8b 44 24 70	 mov	 rax, QWORD PTR from$[rsp]
  0299f	48 ff c0	 inc	 rax
  029a2	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax

; 1150 :             } while (--copy);

  029a7	8b 44 24 6c	 mov	 eax, DWORD PTR copy$[rsp]
  029ab	ff c8		 dec	 eax
  029ad	89 44 24 6c	 mov	 DWORD PTR copy$[rsp], eax
  029b1	83 7c 24 6c 00	 cmp	 DWORD PTR copy$[rsp], 0
  029b6	75 c6		 jne	 SHORT $LN51@inflate

; 1151 :             if (state->length == 0) state->mode = LEN;

  029b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  029c0	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  029c4	75 0e		 jne	 SHORT $LN48@inflate
  029c6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  029ce	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20
$LN48@inflate:

; 1152 :             break;

  029d4	e9 59 03 00 00	 jmp	 $LN498@inflate
$LN47@inflate:

; 1153 :         case LIT:
; 1154 :             if (left == 0) goto inf_leave;

  029d9	83 7c 24 50 00	 cmp	 DWORD PTR left$[rsp], 0
  029de	75 05		 jne	 SHORT $LN46@inflate
  029e0	e9 52 03 00 00	 jmp	 $inf_leave$4986
$LN46@inflate:

; 1155 :             *put++ = (unsigned char)(state->length);

  029e5	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  029ea	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  029f2	0f b6 49 48	 movzx	 ecx, BYTE PTR [rcx+72]
  029f6	88 08		 mov	 BYTE PTR [rax], cl
  029f8	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  029fd	48 ff c0	 inc	 rax
  02a00	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 1156 :             left--;

  02a05	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  02a09	ff c8		 dec	 eax
  02a0b	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax

; 1157 :             state->mode = LEN;

  02a0f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02a17	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20

; 1158 :             break;

  02a1d	e9 10 03 00 00	 jmp	 $LN498@inflate
$LN45@inflate:

; 1159 :         case CHECK:
; 1160 :             if (state->wrap) {

  02a22	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02a2a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  02a2e	0f 84 ef 01 00
	00		 je	 $LN44@inflate
$LN43@inflate:
$LN40@inflate:

; 1161 :                 NEEDBITS(32);

  02a34	83 7c 24 4c 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  02a39	73 50		 jae	 SHORT $LN39@inflate
$LN38@inflate:
  02a3b	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  02a40	75 05		 jne	 SHORT $LN35@inflate
  02a42	e9 f0 02 00 00	 jmp	 $inf_leave$4986
$LN35@inflate:
  02a47	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  02a4b	ff c8		 dec	 eax
  02a4d	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  02a51	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02a56	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02a59	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  02a5d	d3 e0		 shl	 eax, cl
  02a5f	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02a63	03 c8		 add	 ecx, eax
  02a65	8b c1		 mov	 eax, ecx
  02a67	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02a6b	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02a70	48 ff c0	 inc	 rax
  02a73	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  02a78	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02a7c	83 c0 08	 add	 eax, 8
  02a7f	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  02a83	33 c0		 xor	 eax, eax
  02a85	85 c0		 test	 eax, eax
  02a87	75 b2		 jne	 SHORT $LN38@inflate
  02a89	eb a9		 jmp	 SHORT $LN40@inflate
$LN39@inflate:
  02a8b	33 c0		 xor	 eax, eax
  02a8d	85 c0		 test	 eax, eax
  02a8f	75 a3		 jne	 SHORT $LN43@inflate

; 1162 :                 out -= left;

  02a91	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  02a95	8b 4c 24 78	 mov	 ecx, DWORD PTR out$[rsp]
  02a99	2b c8		 sub	 ecx, eax
  02a9b	8b c1		 mov	 eax, ecx
  02a9d	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 1163 :                 strm->total_out += out;

  02aa1	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02aa9	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  02aac	03 44 24 78	 add	 eax, DWORD PTR out$[rsp]
  02ab0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02ab8	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1164 :                 state->total += out;

  02abb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02ac3	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  02ac6	03 44 24 78	 add	 eax, DWORD PTR out$[rsp]
  02aca	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02ad2	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1165 :                 if (out)

  02ad5	83 7c 24 78 00	 cmp	 DWORD PTR out$[rsp], 0
  02ada	0f 84 90 00 00
	00		 je	 $LN34@inflate

; 1166 :                     strm->adler = state->check =
; 1167 :                         UPDATE(state->check, put - out, out);

  02ae0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02ae8	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02aec	74 30		 je	 SHORT $LN514@inflate
  02aee	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02af2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  02af7	48 2b c8	 sub	 rcx, rax
  02afa	48 8b c1	 mov	 rax, rcx
  02afd	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  02b02	48 8b d0	 mov	 rdx, rax
  02b05	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02b0d	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02b10	e8 00 00 00 00	 call	 crc32
  02b15	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv1262[rsp], eax
  02b1c	eb 2e		 jmp	 SHORT $LN515@inflate
$LN514@inflate:
  02b1e	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02b22	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  02b27	48 2b c8	 sub	 rcx, rax
  02b2a	48 8b c1	 mov	 rax, rcx
  02b2d	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  02b32	48 8b d0	 mov	 rdx, rax
  02b35	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02b3d	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02b40	e8 00 00 00 00	 call	 adler32
  02b45	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv1262[rsp], eax
$LN515@inflate:
  02b4c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02b54	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv1262[rsp]
  02b5b	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  02b5e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02b66	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv1262[rsp]
  02b6d	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
$LN34@inflate:

; 1168 :                 out = left;

  02b70	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  02b74	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 1169 :                 if ((
; 1170 : #ifdef GUNZIP
; 1171 :                      state->flags ? hold :
; 1172 : #endif
; 1173 :                      REVERSE(hold)) != state->check) {

  02b78	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02b80	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02b84	74 0d		 je	 SHORT $LN516@inflate
  02b86	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  02b8a	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv1276[rsp], eax
  02b91	eb 40		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  02b93	8b 44 24 64	 mov	 eax, DWORD PTR hold$[rsp]
  02b97	c1 e8 18	 shr	 eax, 24
  02b9a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  02b9f	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02ba3	c1 e9 08	 shr	 ecx, 8
  02ba6	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  02bac	03 c1		 add	 eax, ecx
  02bae	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02bb2	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  02bb8	c1 e1 08	 shl	 ecx, 8
  02bbb	03 c1		 add	 eax, ecx
  02bbd	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02bc1	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  02bc7	c1 e1 18	 shl	 ecx, 24
  02bca	03 c1		 add	 eax, ecx
  02bcc	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv1276[rsp], eax
$LN517@inflate:
  02bd3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02bdb	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02bde	39 84 24 ec 00
	00 00		 cmp	 DWORD PTR tv1276[rsp], eax
  02be5	74 26		 je	 SHORT $LN33@inflate

; 1174 :                     strm->msg = (char *)"incorrect data check";

  02be7	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02bef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  02bf6	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1175 :                     state->mode = BAD;

  02bfa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02c02	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 1176 :                     break;

  02c08	e9 25 01 00 00	 jmp	 $LN498@inflate
$LN33@inflate:
$LN32@inflate:

; 1177 :                 }
; 1178 :                 INITBITS();

  02c0d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  02c15	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  02c1d	33 c0		 xor	 eax, eax
  02c1f	85 c0		 test	 eax, eax
  02c21	75 ea		 jne	 SHORT $LN32@inflate
$LN44@inflate:

; 1179 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1180 :             }
; 1181 : #ifdef GUNZIP
; 1182 :             state->mode = LENGTH;

  02c23	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02c2b	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27
$LN29@inflate:

; 1183 :         case LENGTH:
; 1184 :             if (state->wrap && state->flags) {

  02c31	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02c39	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  02c3d	0f 84 b9 00 00
	00		 je	 $LN28@inflate
  02c43	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02c4b	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02c4f	0f 84 a7 00 00
	00		 je	 $LN28@inflate
$LN27@inflate:
$LN24@inflate:

; 1185 :                 NEEDBITS(32);

  02c55	83 7c 24 4c 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  02c5a	73 50		 jae	 SHORT $LN23@inflate
$LN22@inflate:
  02c5c	83 7c 24 40 00	 cmp	 DWORD PTR have$[rsp], 0
  02c61	75 05		 jne	 SHORT $LN19@inflate
  02c63	e9 cf 00 00 00	 jmp	 $inf_leave$4986
$LN19@inflate:
  02c68	8b 44 24 40	 mov	 eax, DWORD PTR have$[rsp]
  02c6c	ff c8		 dec	 eax
  02c6e	89 44 24 40	 mov	 DWORD PTR have$[rsp], eax
  02c72	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02c77	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02c7a	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  02c7e	d3 e0		 shl	 eax, cl
  02c80	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02c84	03 c8		 add	 ecx, eax
  02c86	8b c1		 mov	 eax, ecx
  02c88	89 44 24 64	 mov	 DWORD PTR hold$[rsp], eax
  02c8c	48 8b 44 24 58	 mov	 rax, QWORD PTR next$[rsp]
  02c91	48 ff c0	 inc	 rax
  02c94	48 89 44 24 58	 mov	 QWORD PTR next$[rsp], rax
  02c99	8b 44 24 4c	 mov	 eax, DWORD PTR bits$[rsp]
  02c9d	83 c0 08	 add	 eax, 8
  02ca0	89 44 24 4c	 mov	 DWORD PTR bits$[rsp], eax
  02ca4	33 c0		 xor	 eax, eax
  02ca6	85 c0		 test	 eax, eax
  02ca8	75 b2		 jne	 SHORT $LN22@inflate
  02caa	eb a9		 jmp	 SHORT $LN24@inflate
$LN23@inflate:
  02cac	33 c0		 xor	 eax, eax
  02cae	85 c0		 test	 eax, eax
  02cb0	75 a3		 jne	 SHORT $LN27@inflate

; 1186 :                 if (hold != (state->total & 0xffffffffUL)) {

  02cb2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02cba	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  02cbd	39 44 24 64	 cmp	 DWORD PTR hold$[rsp], eax
  02cc1	74 23		 je	 SHORT $LN18@inflate

; 1187 :                     strm->msg = (char *)"incorrect length check";

  02cc3	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02ccb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  02cd2	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1188 :                     state->mode = BAD;

  02cd6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02cde	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 1189 :                     break;

  02ce4	eb 4c		 jmp	 SHORT $LN498@inflate
$LN18@inflate:
$LN17@inflate:

; 1190 :                 }
; 1191 :                 INITBITS();

  02ce6	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  02cee	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  02cf6	33 c0		 xor	 eax, eax
  02cf8	85 c0		 test	 eax, eax
  02cfa	75 ea		 jne	 SHORT $LN17@inflate
$LN28@inflate:

; 1192 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1193 :             }
; 1194 : #endif
; 1195 :             state->mode = DONE;

  02cfc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02d04	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28
$LN14@inflate:

; 1196 :         case DONE:
; 1197 :             ret = Z_STREAM_END;

  02d0a	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR ret$[rsp], 1

; 1198 :             goto inf_leave;

  02d12	eb 23		 jmp	 SHORT $inf_leave$4986
$LN13@inflate:

; 1199 :         case BAD:
; 1200 :             ret = Z_DATA_ERROR;

  02d14	c7 44 24 60 fd
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -3

; 1201 :             goto inf_leave;

  02d1c	eb 19		 jmp	 SHORT $inf_leave$4986
$LN12@inflate:

; 1202 :         case MEM:
; 1203 :             return Z_MEM_ERROR;

  02d1e	b8 fc ff ff ff	 mov	 eax, -4
  02d23	e9 d5 02 00 00	 jmp	 $LN508@inflate
$LN11@inflate:

; 1204 :         case SYNC:
; 1205 :         default:
; 1206 :             return Z_STREAM_ERROR;

  02d28	b8 fe ff ff ff	 mov	 eax, -2
  02d2d	e9 cb 02 00 00	 jmp	 $LN508@inflate
$LN498@inflate:

; 1207 :         }

  02d32	e9 d2 d3 ff ff	 jmp	 $LN501@inflate
$inf_leave$4986:
$LN10@inflate:

; 1208 : 
; 1209 :     /*
; 1210 :        Return from inflate(), updating the total counts and the check value.
; 1211 :        If there was no progress during the inflate() call, return a buffer
; 1212 :        error.  Call updatewindow() to create and/or update the window state.
; 1213 :        Note: a memory error from inflate() is non-recoverable.
; 1214 :      */
; 1215 :   inf_leave:
; 1216 :     RESTORE();

  02d37	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02d3f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  02d44	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  02d48	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02d50	8b 4c 24 50	 mov	 ecx, DWORD PTR left$[rsp]
  02d54	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  02d57	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02d5f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR next$[rsp]
  02d64	48 89 08	 mov	 QWORD PTR [rax], rcx
  02d67	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02d6f	8b 4c 24 40	 mov	 ecx, DWORD PTR have$[rsp]
  02d73	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  02d76	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02d7e	8b 4c 24 64	 mov	 ecx, DWORD PTR hold$[rsp]
  02d82	89 48 40	 mov	 DWORD PTR [rax+64], ecx
  02d85	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02d8d	8b 4c 24 4c	 mov	 ecx, DWORD PTR bits$[rsp]
  02d91	89 48 44	 mov	 DWORD PTR [rax+68], ecx
  02d94	33 c0		 xor	 eax, eax
  02d96	85 c0		 test	 eax, eax
  02d98	75 9d		 jne	 SHORT $LN10@inflate

; 1217 :     if (state->wsize || (state->mode < CHECK && out != strm->avail_out))

  02d9a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02da2	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  02da6	75 1e		 jne	 SHORT $LN6@inflate
  02da8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02db0	83 38 1a	 cmp	 DWORD PTR [rax], 26
  02db3	7d 3e		 jge	 SHORT $LN7@inflate
  02db5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02dbd	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02dc0	39 44 24 78	 cmp	 DWORD PTR out$[rsp], eax
  02dc4	74 2d		 je	 SHORT $LN7@inflate
$LN6@inflate:

; 1218 :         if (updatewindow(strm, out)) {

  02dc6	8b 54 24 78	 mov	 edx, DWORD PTR out$[rsp]
  02dca	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02dd2	e8 00 00 00 00	 call	 updatewindow
  02dd7	85 c0		 test	 eax, eax
  02dd9	74 18		 je	 SHORT $LN5@inflate

; 1219 :             state->mode = MEM;

  02ddb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02de3	c7 00 1e 00 00
	00		 mov	 DWORD PTR [rax], 30

; 1220 :             return Z_MEM_ERROR;

  02de9	b8 fc ff ff ff	 mov	 eax, -4
  02dee	e9 0a 02 00 00	 jmp	 $LN508@inflate
$LN5@inflate:
$LN7@inflate:

; 1221 :         }
; 1222 :     in -= strm->avail_in;

  02df3	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02dfb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  02dfe	8b 4c 24 44	 mov	 ecx, DWORD PTR in$[rsp]
  02e02	2b c8		 sub	 ecx, eax
  02e04	8b c1		 mov	 eax, ecx
  02e06	89 44 24 44	 mov	 DWORD PTR in$[rsp], eax

; 1223 :     out -= strm->avail_out;

  02e0a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02e12	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02e15	8b 4c 24 78	 mov	 ecx, DWORD PTR out$[rsp]
  02e19	2b c8		 sub	 ecx, eax
  02e1b	8b c1		 mov	 eax, ecx
  02e1d	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 1224 :     strm->total_in += in;

  02e21	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02e29	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  02e2c	03 44 24 44	 add	 eax, DWORD PTR in$[rsp]
  02e30	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02e38	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 1225 :     strm->total_out += out;

  02e3b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02e43	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  02e46	03 44 24 78	 add	 eax, DWORD PTR out$[rsp]
  02e4a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02e52	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1226 :     state->total += out;

  02e55	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02e5d	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  02e60	03 44 24 78	 add	 eax, DWORD PTR out$[rsp]
  02e64	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02e6c	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1227 :     if (state->wrap && out)

  02e6f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02e77	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  02e7b	0f 84 a9 00 00
	00		 je	 $LN4@inflate
  02e81	83 7c 24 78 00	 cmp	 DWORD PTR out$[rsp], 0
  02e86	0f 84 9e 00 00
	00		 je	 $LN4@inflate

; 1228 :         strm->adler = state->check =
; 1229 :             UPDATE(state->check, strm->next_out - out, out);

  02e8c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02e94	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02e98	74 37		 je	 SHORT $LN518@inflate
  02e9a	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02e9e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02ea6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  02eaa	48 2b c8	 sub	 rcx, rax
  02ead	48 8b c1	 mov	 rax, rcx
  02eb0	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  02eb5	48 8b d0	 mov	 rdx, rax
  02eb8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02ec0	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02ec3	e8 00 00 00 00	 call	 crc32
  02ec8	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv1351[rsp], eax
  02ecf	eb 35		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  02ed1	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02ed5	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02edd	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  02ee1	48 2b c8	 sub	 rcx, rax
  02ee4	48 8b c1	 mov	 rax, rcx
  02ee7	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  02eec	48 8b d0	 mov	 rdx, rax
  02eef	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02ef7	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02efa	e8 00 00 00 00	 call	 adler32
  02eff	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv1351[rsp], eax
$LN519@inflate:
  02f06	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02f0e	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv1351[rsp]
  02f15	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  02f18	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02f20	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv1351[rsp]
  02f27	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
$LN4@inflate:

; 1230 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1231 :                       (state->mode == TYPE ? 128 : 0) +
; 1232 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  02f2a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02f32	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  02f36	74 0d		 je	 SHORT $LN520@inflate
  02f38	c7 84 24 f4 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv1356[rsp], 64 ; 00000040H
  02f43	eb 0b		 jmp	 SHORT $LN521@inflate
$LN520@inflate:
  02f45	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1356[rsp], 0
$LN521@inflate:
  02f50	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02f58	83 38 0b	 cmp	 DWORD PTR [rax], 11
  02f5b	75 0d		 jne	 SHORT $LN522@inflate
  02f5d	c7 84 24 f8 00
	00 00 80 00 00
	00		 mov	 DWORD PTR tv1359[rsp], 128 ; 00000080H
  02f68	eb 0b		 jmp	 SHORT $LN523@inflate
$LN522@inflate:
  02f6a	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1359[rsp], 0
$LN523@inflate:
  02f75	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02f7d	83 38 13	 cmp	 DWORD PTR [rax], 19
  02f80	74 1a		 je	 SHORT $LN524@inflate
  02f82	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02f8a	83 38 0e	 cmp	 DWORD PTR [rax], 14
  02f8d	74 0d		 je	 SHORT $LN524@inflate
  02f8f	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1363[rsp], 0
  02f9a	eb 0b		 jmp	 SHORT $LN525@inflate
$LN524@inflate:
  02f9c	c7 84 24 fc 00
	00 00 00 01 00
	00		 mov	 DWORD PTR tv1363[rsp], 256 ; 00000100H
$LN525@inflate:
  02fa7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02faf	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  02fb2	03 84 24 f4 00
	00 00		 add	 eax, DWORD PTR tv1356[rsp]
  02fb9	03 84 24 f8 00
	00 00		 add	 eax, DWORD PTR tv1359[rsp]
  02fc0	03 84 24 fc 00
	00 00		 add	 eax, DWORD PTR tv1363[rsp]
  02fc7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02fcf	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 1233 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  02fd2	83 7c 24 44 00	 cmp	 DWORD PTR in$[rsp], 0
  02fd7	75 07		 jne	 SHORT $LN1@inflate
  02fd9	83 7c 24 78 00	 cmp	 DWORD PTR out$[rsp], 0
  02fde	74 0a		 je	 SHORT $LN2@inflate
$LN1@inflate:
  02fe0	83 bc 24 18 01
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  02fe8	75 0f		 jne	 SHORT $LN3@inflate
$LN2@inflate:
  02fea	83 7c 24 60 00	 cmp	 DWORD PTR ret$[rsp], 0
  02fef	75 08		 jne	 SHORT $LN3@inflate

; 1234 :         ret = Z_BUF_ERROR;

  02ff1	c7 44 24 60 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
$LN3@inflate:

; 1235 :     return ret;

  02ff9	8b 44 24 60	 mov	 eax, DWORD PTR ret$[rsp]
$LN508@inflate:

; 1236 : }

  02ffd	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  03004	c3		 ret	 0
  03005	0f 1f 00	 npad	 3
$LN526@inflate:
  03008	00 00 00 00	 DD	 $LN497@inflate
  0300c	00 00 00 00	 DD	 $LN466@inflate
  03010	00 00 00 00	 DD	 $LN446@inflate
  03014	00 00 00 00	 DD	 $LN428@inflate
  03018	00 00 00 00	 DD	 $LN410@inflate
  0301c	00 00 00 00	 DD	 $LN389@inflate
  03020	00 00 00 00	 DD	 $LN382@inflate
  03024	00 00 00 00	 DD	 $LN370@inflate
  03028	00 00 00 00	 DD	 $LN358@inflate
  0302c	00 00 00 00	 DD	 $LN342@inflate
  03030	00 00 00 00	 DD	 $LN329@inflate
  03034	00 00 00 00	 DD	 $LN324@inflate
  03038	00 00 00 00	 DD	 $LN321@inflate
  0303c	00 00 00 00	 DD	 $LN291@inflate
  03040	00 00 00 00	 DD	 $LN273@inflate
  03044	00 00 00 00	 DD	 $LN272@inflate
  03048	00 00 00 00	 DD	 $LN267@inflate
  0304c	00 00 00 00	 DD	 $LN246@inflate
  03050	00 00 00 00	 DD	 $LN228@inflate
  03054	00 00 00 00	 DD	 $LN146@inflate
  03058	00 00 00 00	 DD	 $LN145@inflate
  0305c	00 00 00 00	 DD	 $LN112@inflate
  03060	00 00 00 00	 DD	 $LN98@inflate
  03064	00 00 00 00	 DD	 $LN75@inflate
  03068	00 00 00 00	 DD	 $LN61@inflate
  0306c	00 00 00 00	 DD	 $LN47@inflate
  03070	00 00 00 00	 DD	 $LN45@inflate
  03074	00 00 00 00	 DD	 $LN29@inflate
  03078	00 00 00 00	 DD	 $LN14@inflate
  0307c	00 00 00 00	 DD	 $LN13@inflate
  03080	00 00 00 00	 DD	 $LN12@inflate
inflate	ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 242  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 243  : #ifdef BUILDFIXED
; 244  :     static int virgin = 1;
; 245  :     static code *lenfix, *distfix;
; 246  :     static code fixed[544];
; 247  : 
; 248  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 249  :     if (virgin) {
; 250  :         unsigned sym, bits;
; 251  :         static code *next;
; 252  : 
; 253  :         /* literal/length table */
; 254  :         sym = 0;
; 255  :         while (sym < 144) state->lens[sym++] = 8;
; 256  :         while (sym < 256) state->lens[sym++] = 9;
; 257  :         while (sym < 280) state->lens[sym++] = 7;
; 258  :         while (sym < 288) state->lens[sym++] = 8;
; 259  :         next = fixed;
; 260  :         lenfix = next;
; 261  :         bits = 9;
; 262  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 263  : 
; 264  :         /* distance table */
; 265  :         sym = 0;
; 266  :         while (sym < 32) state->lens[sym++] = 5;
; 267  :         distfix = next;
; 268  :         bits = 5;
; 269  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 270  : 
; 271  :         /* do this just once */
; 272  :         virgin = 0;
; 273  :     }
; 274  : #else /* !BUILDFIXED */
; 275  : #   include "inffixed.h"
; 276  : #endif /* BUILDFIXED */
; 277  :     state->lencode = lenfix;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9
  00011	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 278  :     state->lenbits = 9;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0001a	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 279  :     state->distcode = distfix;

  00021	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  0002d	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 280  :     state->distbits = 5;

  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00036	c7 40 6c 05 00
	00 00		 mov	 DWORD PTR [rax+108], 5

; 281  : }

  0003d	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+603
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT updatewindow
_TEXT	SEGMENT
dist$ = 32
copy$ = 36
state$ = 40
tv187 = 48
tv196 = 52
tv148 = 56
strm$ = 80
out$ = 88
updatewindow PROC					; COMDAT

; 361  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 362  :     struct inflate_state FAR *state;
; 363  :     unsigned copy, dist;
; 364  : 
; 365  :     state = (struct inflate_state FAR *)strm->state;

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00012	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00016	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 366  : 
; 367  :     /* if it hasn't been done already, allocate space for the window */
; 368  :     if (state->window == Z_NULL) {

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00020	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00025	75 52		 jne	 SHORT $LN10@updatewind

; 369  :         state->window = (unsigned char FAR *)
; 370  :                         ZALLOC(strm, 1U << state->wbits,
; 371  :                                sizeof(unsigned char));

  00027	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0002c	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0002f	b9 01 00 00 00	 mov	 ecx, 1
  00034	89 4c 24 30	 mov	 DWORD PTR tv187[rsp], ecx
  00038	0f b6 c8	 movzx	 ecx, al
  0003b	8b 44 24 30	 mov	 eax, DWORD PTR tv187[rsp]
  0003f	d3 e0		 shl	 eax, cl
  00041	41 b8 01 00 00
	00		 mov	 r8d, 1
  00047	8b d0		 mov	 edx, eax
  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0004e	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00057	ff 50 30	 call	 QWORD PTR [rax+48]
  0005a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0005f	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 372  :         if (state->window == Z_NULL) return 1;

  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00068	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0006d	75 0a		 jne	 SHORT $LN9@updatewind
  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	e9 dd 01 00 00	 jmp	 $LN11@updatewind
$LN9@updatewind:
$LN10@updatewind:

; 373  :     }
; 374  : 
; 375  :     /* if window not in use yet, initialize */
; 376  :     if (state->wsize == 0) {

  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0007e	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00082	75 3a		 jne	 SHORT $LN8@updatewind

; 377  :         state->wsize = 1U << state->wbits;

  00084	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00089	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0008c	b9 01 00 00 00	 mov	 ecx, 1
  00091	89 4c 24 34	 mov	 DWORD PTR tv196[rsp], ecx
  00095	0f b6 c8	 movzx	 ecx, al
  00098	8b 44 24 34	 mov	 eax, DWORD PTR tv196[rsp]
  0009c	d3 e0		 shl	 eax, cl
  0009e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000a3	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 378  :         state->wnext = 0;

  000a6	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000ab	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 379  :         state->whave = 0;

  000b2	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000b7	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN8@updatewind:

; 380  :     }
; 381  : 
; 382  :     /* copy state->wsize or less output bytes into the circular window */
; 383  :     copy = out - strm->avail_out;

  000be	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000c3	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000c6	8b 4c 24 58	 mov	 ecx, DWORD PTR out$[rsp]
  000ca	2b c8		 sub	 ecx, eax
  000cc	8b c1		 mov	 eax, ecx
  000ce	89 44 24 24	 mov	 DWORD PTR copy$[rsp], eax

; 384  :     if (copy >= state->wsize) {

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000d7	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000da	39 44 24 24	 cmp	 DWORD PTR copy$[rsp], eax
  000de	72 54		 jb	 SHORT $LN7@updatewind

; 385  :         zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);

  000e0	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000e5	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000ed	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  000f0	48 8b 54 24 50	 mov	 rdx, QWORD PTR strm$[rsp]
  000f5	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000f9	48 2b d1	 sub	 rdx, rcx
  000fc	48 8b ca	 mov	 rcx, rdx
  000ff	44 8b c0	 mov	 r8d, eax
  00102	48 8b d1	 mov	 rdx, rcx
  00105	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0010a	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  0010e	e8 00 00 00 00	 call	 memcpy

; 386  :         state->wnext = 0;

  00113	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00118	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 387  :         state->whave = state->wsize;

  0011f	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00124	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00129	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  0012c	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 388  :     }
; 389  :     else {

  0012f	e9 20 01 00 00	 jmp	 $LN6@updatewind
$LN7@updatewind:

; 390  :         dist = state->wsize - state->wnext;

  00134	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00139	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0013e	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  00141	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00144	2b c1		 sub	 eax, ecx
  00146	89 44 24 20	 mov	 DWORD PTR dist$[rsp], eax

; 391  :         if (dist > copy) dist = copy;

  0014a	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  0014e	39 44 24 20	 cmp	 DWORD PTR dist$[rsp], eax
  00152	76 08		 jbe	 SHORT $LN5@updatewind
  00154	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  00158	89 44 24 20	 mov	 DWORD PTR dist$[rsp], eax
$LN5@updatewind:

; 392  :         zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);

  0015c	8b 44 24 20	 mov	 eax, DWORD PTR dist$[rsp]
  00160	8b 4c 24 24	 mov	 ecx, DWORD PTR copy$[rsp]
  00164	48 8b 54 24 50	 mov	 rdx, QWORD PTR strm$[rsp]
  00169	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0016d	48 2b d1	 sub	 rdx, rcx
  00170	48 8b ca	 mov	 rcx, rdx
  00173	48 8b 54 24 28	 mov	 rdx, QWORD PTR state$[rsp]
  00178	8b 52 34	 mov	 edx, DWORD PTR [rdx+52]
  0017b	4c 8b 44 24 28	 mov	 r8, QWORD PTR state$[rsp]
  00180	49 03 50 38	 add	 rdx, QWORD PTR [r8+56]
  00184	48 89 54 24 38	 mov	 QWORD PTR tv148[rsp], rdx
  00189	44 8b c0	 mov	 r8d, eax
  0018c	48 8b d1	 mov	 rdx, rcx
  0018f	48 8b 44 24 38	 mov	 rax, QWORD PTR tv148[rsp]
  00194	48 8b c8	 mov	 rcx, rax
  00197	e8 00 00 00 00	 call	 memcpy

; 393  :         copy -= dist;

  0019c	8b 44 24 20	 mov	 eax, DWORD PTR dist$[rsp]
  001a0	8b 4c 24 24	 mov	 ecx, DWORD PTR copy$[rsp]
  001a4	2b c8		 sub	 ecx, eax
  001a6	8b c1		 mov	 eax, ecx
  001a8	89 44 24 24	 mov	 DWORD PTR copy$[rsp], eax

; 394  :         if (copy) {

  001ac	83 7c 24 24 00	 cmp	 DWORD PTR copy$[rsp], 0
  001b1	74 49		 je	 SHORT $LN4@updatewind

; 395  :             zmemcpy(state->window, strm->next_out - copy, copy);

  001b3	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  001b7	8b 4c 24 24	 mov	 ecx, DWORD PTR copy$[rsp]
  001bb	48 8b 54 24 50	 mov	 rdx, QWORD PTR strm$[rsp]
  001c0	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  001c4	48 2b d1	 sub	 rdx, rcx
  001c7	48 8b ca	 mov	 rcx, rdx
  001ca	44 8b c0	 mov	 r8d, eax
  001cd	48 8b d1	 mov	 rdx, rcx
  001d0	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001d5	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  001d9	e8 00 00 00 00	 call	 memcpy

; 396  :             state->wnext = copy;

  001de	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001e3	8b 4c 24 24	 mov	 ecx, DWORD PTR copy$[rsp]
  001e7	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 397  :             state->whave = state->wsize;

  001ea	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  001f4	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  001f7	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 398  :         }
; 399  :         else {

  001fa	eb 58		 jmp	 SHORT $LN3@updatewind
$LN4@updatewind:

; 400  :             state->wnext += dist;

  001fc	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00201	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00204	03 44 24 20	 add	 eax, DWORD PTR dist$[rsp]
  00208	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0020d	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 401  :             if (state->wnext == state->wsize) state->wnext = 0;

  00210	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00215	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0021a	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  0021d	39 48 34	 cmp	 DWORD PTR [rax+52], ecx
  00220	75 0c		 jne	 SHORT $LN2@updatewind
  00222	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00227	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0
$LN2@updatewind:

; 402  :             if (state->whave < state->wsize) state->whave += dist;

  0022e	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00233	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00238	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  0023b	39 48 30	 cmp	 DWORD PTR [rax+48], ecx
  0023e	73 14		 jae	 SHORT $LN1@updatewind
  00240	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00245	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00248	03 44 24 20	 add	 eax, DWORD PTR dist$[rsp]
  0024c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00251	89 41 30	 mov	 DWORD PTR [rcx+48], eax
$LN1@updatewind:
$LN3@updatewind:
$LN6@updatewind:

; 403  :         }
; 404  :     }
; 405  :     return 0;

  00254	33 c0		 xor	 eax, eax
$LN11@updatewind:

; 406  : }

  00256	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0025a	c3		 ret	 0
updatewindow ENDP
_TEXT	ENDS
PUBLIC	inflateEnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN6
	DD	imagerel $LN6+146
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateEnd
_TEXT	SEGMENT
state$ = 32
strm$ = 64
inflateEnd PROC						; COMDAT

; 1240 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1241 :     struct inflate_state FAR *state;
; 1242 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 18		 je	 SHORT $LN2@inflateEnd
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	74 0c		 je	 SHORT $LN2@inflateEnd
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00022	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00027	75 07		 jne	 SHORT $LN3@inflateEnd
$LN2@inflateEnd:

; 1243 :         return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2
  0002e	eb 5d		 jmp	 SHORT $LN4@inflateEnd
$LN3@inflateEnd:

; 1244 :     state = (struct inflate_state FAR *)strm->state;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00035	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00039	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1245 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00043	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00048	74 1a		 je	 SHORT $LN1@inflateEnd
  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0004f	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  00053	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00058	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00061	ff 50 38	 call	 QWORD PTR [rax+56]
$LN1@inflateEnd:

; 1246 :     ZFREE(strm, strm->state);

  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00069	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00072	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007b	ff 50 38	 call	 QWORD PTR [rax+56]

; 1247 :     strm->state = Z_NULL;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00083	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 1248 :     Tracev((stderr, "inflate: end\n"));
; 1249 :     return Z_OK;

  0008b	33 c0		 xor	 eax, eax
$LN4@inflateEnd:

; 1250 : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
PUBLIC	inflateSetDictionary
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN11
	DD	imagerel $LN11+374
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
id$ = 32
state$ = 40
strm$ = 64
dictionary$ = 72
dictLength$ = 80
inflateSetDictionary PROC				; COMDAT

; 1256 : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1257 :     struct inflate_state FAR *state;
; 1258 :     unsigned long id;
; 1259 : 
; 1260 :     /* check state */
; 1261 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00019	74 0c		 je	 SHORT $LN7@inflateSet
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00020	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00025	75 0a		 jne	 SHORT $LN8@inflateSet
$LN7@inflateSet:
  00027	b8 fe ff ff ff	 mov	 eax, -2
  0002c	e9 40 01 00 00	 jmp	 $LN9@inflateSet
$LN8@inflateSet:

; 1262 :     state = (struct inflate_state FAR *)strm->state;

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00036	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003a	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 1263 :     if (state->wrap != 0 && state->mode != DICT)

  0003f	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00044	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00048	74 14		 je	 SHORT $LN6@inflateSet
  0004a	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0004f	83 38 0a	 cmp	 DWORD PTR [rax], 10
  00052	74 0a		 je	 SHORT $LN6@inflateSet

; 1264 :         return Z_STREAM_ERROR;

  00054	b8 fe ff ff ff	 mov	 eax, -2
  00059	e9 13 01 00 00	 jmp	 $LN9@inflateSet
$LN6@inflateSet:

; 1265 : 
; 1266 :     /* check for correct dictionary id */
; 1267 :     if (state->mode == DICT) {

  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00063	83 38 0a	 cmp	 DWORD PTR [rax], 10
  00066	75 3f		 jne	 SHORT $LN5@inflateSet

; 1268 :         id = adler32(0L, Z_NULL, 0);

  00068	45 33 c0	 xor	 r8d, r8d
  0006b	33 d2		 xor	 edx, edx
  0006d	33 c9		 xor	 ecx, ecx
  0006f	e8 00 00 00 00	 call	 adler32
  00074	89 44 24 20	 mov	 DWORD PTR id$[rsp], eax

; 1269 :         id = adler32(id, dictionary, dictLength);

  00078	44 8b 44 24 50	 mov	 r8d, DWORD PTR dictLength$[rsp]
  0007d	48 8b 54 24 48	 mov	 rdx, QWORD PTR dictionary$[rsp]
  00082	8b 4c 24 20	 mov	 ecx, DWORD PTR id$[rsp]
  00086	e8 00 00 00 00	 call	 adler32
  0008b	89 44 24 20	 mov	 DWORD PTR id$[rsp], eax

; 1270 :         if (id != state->check)

  0008f	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00094	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00097	39 44 24 20	 cmp	 DWORD PTR id$[rsp], eax
  0009b	74 0a		 je	 SHORT $LN4@inflateSet

; 1271 :             return Z_DATA_ERROR;

  0009d	b8 fd ff ff ff	 mov	 eax, -3
  000a2	e9 ca 00 00 00	 jmp	 $LN9@inflateSet
$LN4@inflateSet:
$LN5@inflateSet:

; 1272 :     }
; 1273 : 
; 1274 :     /* copy dictionary to window */
; 1275 :     if (updatewindow(strm, strm->avail_out)) {

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ac	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  000af	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000b4	e8 00 00 00 00	 call	 updatewindow
  000b9	85 c0		 test	 eax, eax
  000bb	74 15		 je	 SHORT $LN3@inflateSet

; 1276 :         state->mode = MEM;

  000bd	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000c2	c7 00 1e 00 00
	00		 mov	 DWORD PTR [rax], 30

; 1277 :         return Z_MEM_ERROR;

  000c8	b8 fc ff ff ff	 mov	 eax, -4
  000cd	e9 9f 00 00 00	 jmp	 $LN9@inflateSet
$LN3@inflateSet:

; 1278 :     }
; 1279 :     if (dictLength > state->wsize) {

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000d7	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000da	39 44 24 50	 cmp	 DWORD PTR dictLength$[rsp], eax
  000de	76 48		 jbe	 SHORT $LN2@inflateSet

; 1280 :         zmemcpy(state->window, dictionary + dictLength - state->wsize,
; 1281 :                 state->wsize);

  000e0	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000e5	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000e8	8b 4c 24 50	 mov	 ecx, DWORD PTR dictLength$[rsp]
  000ec	48 8b 54 24 48	 mov	 rdx, QWORD PTR dictionary$[rsp]
  000f1	48 03 d1	 add	 rdx, rcx
  000f4	48 8b ca	 mov	 rcx, rdx
  000f7	48 8b 54 24 28	 mov	 rdx, QWORD PTR state$[rsp]
  000fc	8b 52 2c	 mov	 edx, DWORD PTR [rdx+44]
  000ff	48 2b ca	 sub	 rcx, rdx
  00102	44 8b c0	 mov	 r8d, eax
  00105	48 8b d1	 mov	 rdx, rcx
  00108	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0010d	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00111	e8 00 00 00 00	 call	 memcpy

; 1282 :         state->whave = state->wsize;

  00116	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0011b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00120	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  00123	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 1283 :     }
; 1284 :     else {

  00126	eb 3b		 jmp	 SHORT $LN1@inflateSet
$LN2@inflateSet:

; 1285 :         zmemcpy(state->window + state->wsize - dictLength, dictionary,
; 1286 :                 dictLength);

  00128	8b 44 24 50	 mov	 eax, DWORD PTR dictLength$[rsp]
  0012c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00131	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  00134	48 8b 54 24 28	 mov	 rdx, QWORD PTR state$[rsp]
  00139	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  0013d	48 03 d1	 add	 rdx, rcx
  00140	48 8b ca	 mov	 rcx, rdx
  00143	8b 54 24 50	 mov	 edx, DWORD PTR dictLength$[rsp]
  00147	48 2b ca	 sub	 rcx, rdx
  0014a	44 8b c0	 mov	 r8d, eax
  0014d	48 8b 54 24 48	 mov	 rdx, QWORD PTR dictionary$[rsp]
  00152	e8 00 00 00 00	 call	 memcpy

; 1287 :         state->whave = dictLength;

  00157	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0015c	8b 4c 24 50	 mov	 ecx, DWORD PTR dictLength$[rsp]
  00160	89 48 30	 mov	 DWORD PTR [rax+48], ecx
$LN1@inflateSet:

; 1288 :     }
; 1289 :     state->havedict = 1;

  00163	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00168	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1

; 1290 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1291 :     return Z_OK;

  0016f	33 c0		 xor	 eax, eax
$LN9@inflateSet:

; 1292 : }

  00171	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00175	c3		 ret	 0
inflateSetDictionary ENDP
_TEXT	ENDS
PUBLIC	inflateGetHeader
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateGetHeader DD imagerel $LN6
	DD	imagerel $LN6+107
	DD	imagerel $unwind$inflateGetHeader
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateGetHeader DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
state$ = 0
strm$ = 32
head$ = 40
inflateGetHeader PROC					; COMDAT

; 1297 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 1298 :     struct inflate_state FAR *state;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000e	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00014	74 0c		 je	 SHORT $LN2@inflateGet
  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0001b	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00020	75 07		 jne	 SHORT $LN3@inflateGet
$LN2@inflateGet:
  00022	b8 fe ff ff ff	 mov	 eax, -2
  00027	eb 3d		 jmp	 SHORT $LN4@inflateGet
$LN3@inflateGet:

; 1302 :     state = (struct inflate_state FAR *)strm->state;

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0002e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00032	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 1303 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  00036	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0003a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003d	83 e0 02	 and	 eax, 2
  00040	85 c0		 test	 eax, eax
  00042	75 07		 jne	 SHORT $LN1@inflateGet
  00044	b8 fe ff ff ff	 mov	 eax, -2
  00049	eb 1b		 jmp	 SHORT $LN4@inflateGet
$LN1@inflateGet:

; 1304 : 
; 1305 :     /* save header structure */
; 1306 :     state->head = head;

  0004b	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0004f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR head$[rsp]
  00054	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 1307 :     head->done = 0;

  00058	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  0005d	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1308 :     return Z_OK;

  00064	33 c0		 xor	 eax, eax
$LN4@inflateGet:

; 1309 : }

  00066	48 83 c4 18	 add	 rsp, 24
  0006a	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
PUBLIC	inflateSync
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN10
	DD	imagerel $LN10+502
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateSync
_TEXT	SEGMENT
in$ = 32
len$ = 36
buf$ = 40
out$ = 44
state$ = 48
tv169 = 56
strm$ = 80
inflateSync PROC					; COMDAT

; 1347 : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1348 :     unsigned len;               /* number of bytes to look at or looked at */
; 1349 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1350 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1351 :     struct inflate_state FAR *state;
; 1352 : 
; 1353 :     /* check parameters */
; 1354 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN6@inflateSyn
  00011	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 0a		 jne	 SHORT $LN7@inflateSyn
$LN6@inflateSyn:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	e9 ca 01 00 00	 jmp	 $LN8@inflateSyn
$LN7@inflateSyn:

; 1355 :     state = (struct inflate_state FAR *)strm->state;

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00030	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 1356 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0003a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0003e	75 15		 jne	 SHORT $LN5@inflateSyn
  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00045	83 78 44 08	 cmp	 DWORD PTR [rax+68], 8
  00049	73 0a		 jae	 SHORT $LN5@inflateSyn
  0004b	b8 fb ff ff ff	 mov	 eax, -5
  00050	e9 9c 01 00 00	 jmp	 $LN8@inflateSyn
$LN5@inflateSyn:

; 1357 : 
; 1358 :     /* if first time, start search in bit buffer */
; 1359 :     if (state->mode != SYNC) {

  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0005a	83 38 1f	 cmp	 DWORD PTR [rax], 31
  0005d	0f 84 d1 00 00
	00		 je	 $LN4@inflateSyn

; 1360 :         state->mode = SYNC;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00068	c7 00 1f 00 00
	00		 mov	 DWORD PTR [rax], 31

; 1361 :         state->hold <<= state->bits & 7;

  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00073	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00076	83 e0 07	 and	 eax, 7
  00079	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0007e	48 89 4c 24 38	 mov	 QWORD PTR tv169[rsp], rcx
  00083	0f b6 c8	 movzx	 ecx, al
  00086	48 8b 44 24 38	 mov	 rax, QWORD PTR tv169[rsp]
  0008b	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0008e	d3 e0		 shl	 eax, cl
  00090	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00095	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 1362 :         state->bits -= state->bits & 7;

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0009d	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000a0	83 e0 07	 and	 eax, 7
  000a3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000a8	8b 49 44	 mov	 ecx, DWORD PTR [rcx+68]
  000ab	2b c8		 sub	 ecx, eax
  000ad	8b c1		 mov	 eax, ecx
  000af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000b4	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 1363 :         len = 0;

  000b7	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN3@inflateSyn:

; 1364 :         while (state->bits >= 8) {

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000c4	83 78 44 08	 cmp	 DWORD PTR [rax+68], 8
  000c8	72 43		 jb	 SHORT $LN2@inflateSyn

; 1365 :             buf[len++] = (unsigned char)(state->hold);

  000ca	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  000ce	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000d3	0f b6 49 40	 movzx	 ecx, BYTE PTR [rcx+64]
  000d7	88 4c 04 28	 mov	 BYTE PTR buf$[rsp+rax], cl
  000db	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  000df	ff c0		 inc	 eax
  000e1	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 1366 :             state->hold >>= 8;

  000e5	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000ea	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000ed	c1 e8 08	 shr	 eax, 8
  000f0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  000f5	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 1367 :             state->bits -= 8;

  000f8	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000fd	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00100	83 e8 08	 sub	 eax, 8
  00103	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00108	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 1368 :         }

  0010b	eb b2		 jmp	 SHORT $LN3@inflateSyn
$LN2@inflateSyn:

; 1369 :         state->have = 0;

  0010d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00112	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 1370 :         syncsearch(&(state->have), buf, len);

  00119	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0011e	48 83 c0 7c	 add	 rax, 124		; 0000007cH
  00122	44 8b 44 24 24	 mov	 r8d, DWORD PTR len$[rsp]
  00127	48 8d 54 24 28	 lea	 rdx, QWORD PTR buf$[rsp]
  0012c	48 8b c8	 mov	 rcx, rax
  0012f	e8 00 00 00 00	 call	 syncsearch
$LN4@inflateSyn:

; 1371 :     }
; 1372 : 
; 1373 :     /* search available input */
; 1374 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00139	48 83 c0 7c	 add	 rax, 124		; 0000007cH
  0013d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00142	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  00146	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0014b	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0014e	48 8b c8	 mov	 rcx, rax
  00151	e8 00 00 00 00	 call	 syncsearch
  00156	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 1375 :     strm->avail_in -= len;

  0015a	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0015f	8b 4c 24 24	 mov	 ecx, DWORD PTR len$[rsp]
  00163	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00166	2b c1		 sub	 eax, ecx
  00168	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0016d	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1376 :     strm->next_in += len;

  00170	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00174	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00179	48 03 01	 add	 rax, QWORD PTR [rcx]
  0017c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00181	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1377 :     strm->total_in += len;

  00184	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00189	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0018c	03 44 24 24	 add	 eax, DWORD PTR len$[rsp]
  00190	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00195	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 1378 : 
; 1379 :     /* return no joy or set up to restart inflate() on a new block */
; 1380 :     if (state->have != 4) return Z_DATA_ERROR;

  00198	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0019d	83 78 7c 04	 cmp	 DWORD PTR [rax+124], 4
  001a1	74 07		 je	 SHORT $LN1@inflateSyn
  001a3	b8 fd ff ff ff	 mov	 eax, -3
  001a8	eb 47		 jmp	 SHORT $LN8@inflateSyn
$LN1@inflateSyn:

; 1381 :     in = strm->total_in;  out = strm->total_out;

  001aa	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  001af	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  001b2	89 44 24 20	 mov	 DWORD PTR in$[rsp], eax
  001b6	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  001bb	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  001be	89 44 24 2c	 mov	 DWORD PTR out$[rsp], eax

; 1382 :     inflateReset(strm);

  001c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  001c7	e8 00 00 00 00	 call	 inflateReset

; 1383 :     strm->total_in = in;  strm->total_out = out;

  001cc	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  001d1	8b 4c 24 20	 mov	 ecx, DWORD PTR in$[rsp]
  001d5	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
  001d8	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  001dd	8b 4c 24 2c	 mov	 ecx, DWORD PTR out$[rsp]
  001e1	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1384 :     state->mode = TYPE;

  001e4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  001e9	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 1385 :     return Z_OK;

  001ef	33 c0		 xor	 eax, eax
$LN8@inflateSyn:

; 1386 : }

  001f1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f5	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+176
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT syncsearch
_TEXT	SEGMENT
next$ = 0
got$ = 4
tv70 = 8
have$ = 32
buf$ = 40
len$ = 48
syncsearch PROC						; COMDAT

; 1326 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 1327 :     unsigned got;
; 1328 :     unsigned next;
; 1329 : 
; 1330 :     got = *have;

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR have$[rsp]
  00018	8b 00		 mov	 eax, DWORD PTR [rax]
  0001a	89 44 24 04	 mov	 DWORD PTR got$[rsp], eax

; 1331 :     next = 0;

  0001e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR next$[rsp], 0
$LN6@syncsearch:

; 1332 :     while (next < len && got < 4) {

  00025	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00029	39 04 24	 cmp	 DWORD PTR next$[rsp], eax
  0002c	73 6f		 jae	 SHORT $LN5@syncsearch
  0002e	83 7c 24 04 04	 cmp	 DWORD PTR got$[rsp], 4
  00033	73 68		 jae	 SHORT $LN5@syncsearch

; 1333 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00035	83 7c 24 04 02	 cmp	 DWORD PTR got$[rsp], 2
  0003a	73 0a		 jae	 SHORT $LN9@syncsearch
  0003c	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00044	eb 08		 jmp	 SHORT $LN10@syncsearch
$LN9@syncsearch:
  00046	c7 44 24 08 ff
	00 00 00	 mov	 DWORD PTR tv70[rsp], 255 ; 000000ffH
$LN10@syncsearch:
  0004e	8b 04 24	 mov	 eax, DWORD PTR next$[rsp]
  00051	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buf$[rsp]
  00056	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0005a	3b 44 24 08	 cmp	 eax, DWORD PTR tv70[rsp]
  0005e	75 0c		 jne	 SHORT $LN4@syncsearch

; 1334 :             got++;

  00060	8b 44 24 04	 mov	 eax, DWORD PTR got$[rsp]
  00064	ff c0		 inc	 eax
  00066	89 44 24 04	 mov	 DWORD PTR got$[rsp], eax
  0006a	eb 27		 jmp	 SHORT $LN3@syncsearch
$LN4@syncsearch:

; 1335 :         else if (buf[next])

  0006c	8b 04 24	 mov	 eax, DWORD PTR next$[rsp]
  0006f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buf$[rsp]
  00074	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00078	85 c0		 test	 eax, eax
  0007a	74 0a		 je	 SHORT $LN2@syncsearch

; 1336 :             got = 0;

  0007c	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR got$[rsp], 0

; 1337 :         else

  00084	eb 0d		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1338 :             got = 4 - got;

  00086	b8 04 00 00 00	 mov	 eax, 4
  0008b	2b 44 24 04	 sub	 eax, DWORD PTR got$[rsp]
  0008f	89 44 24 04	 mov	 DWORD PTR got$[rsp], eax
$LN1@syncsearch:
$LN3@syncsearch:

; 1339 :         next++;

  00093	8b 04 24	 mov	 eax, DWORD PTR next$[rsp]
  00096	ff c0		 inc	 eax
  00098	89 04 24	 mov	 DWORD PTR next$[rsp], eax

; 1340 :     }

  0009b	eb 88		 jmp	 SHORT $LN6@syncsearch
$LN5@syncsearch:

; 1341 :     *have = got;

  0009d	48 8b 44 24 20	 mov	 rax, QWORD PTR have$[rsp]
  000a2	8b 4c 24 04	 mov	 ecx, DWORD PTR got$[rsp]
  000a6	89 08		 mov	 DWORD PTR [rax], ecx

; 1342 :     return next;

  000a8	8b 04 24	 mov	 eax, DWORD PTR next$[rsp]

; 1343 : }

  000ab	48 83 c4 18	 add	 rsp, 24
  000af	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
PUBLIC	inflateSyncPoint
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSyncPoint DD imagerel $LN7
	DD	imagerel $LN7+95
	DD	imagerel $unwind$inflateSyncPoint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSyncPoint DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
state$ = 0
tv71 = 8
strm$ = 32
inflateSyncPoint PROC					; COMDAT

; 1398 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1399 :     struct inflate_state FAR *state;
; 1400 : 
; 1401 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN1@inflateSyn@2
  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 07		 jne	 SHORT $LN2@inflateSyn@2
$LN1@inflateSyn@2:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	eb 36		 jmp	 SHORT $LN3@inflateSyn@2
$LN2@inflateSyn@2:

; 1402 :     state = (struct inflate_state FAR *)strm->state;

  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00029	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0002d	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 1403 :     return state->mode == STORED && state->bits == 0;

  00031	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00035	83 38 0d	 cmp	 DWORD PTR [rax], 13
  00038	75 14		 jne	 SHORT $LN5@inflateSyn@2
  0003a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0003e	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  00042	75 0a		 jne	 SHORT $LN5@inflateSyn@2
  00044	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
  0004c	eb 08		 jmp	 SHORT $LN6@inflateSyn@2
$LN5@inflateSyn@2:
  0004e	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN6@inflateSyn@2:
  00056	8b 44 24 08	 mov	 eax, DWORD PTR tv71[rsp]
$LN3@inflateSyn@2:

; 1404 : }

  0005a	48 83 c4 18	 add	 rsp, 24
  0005e	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
PUBLIC	inflateCopy
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN10
	DD	imagerel $LN10+605
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateCopy
_TEXT	SEGMENT
window$ = 32
wsize$ = 40
copy$ = 48
state$ = 56
tv190 = 64
tv220 = 68
dest$ = 96
source$ = 104
inflateCopy PROC					; COMDAT

; 1409 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1410 :     struct inflate_state FAR *state;
; 1411 :     struct inflate_state FAR *copy;
; 1412 :     unsigned char FAR *window;
; 1413 :     unsigned wsize;
; 1414 : 
; 1415 :     /* check input */
; 1416 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1417 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  0000e	48 83 7c 24 60
	00		 cmp	 QWORD PTR dest$[rsp], 0
  00014	74 2c		 je	 SHORT $LN6@inflateCop
  00016	48 83 7c 24 68
	00		 cmp	 QWORD PTR source$[rsp], 0
  0001c	74 24		 je	 SHORT $LN6@inflateCop
  0001e	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	74 18		 je	 SHORT $LN6@inflateCop
  0002a	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  0002f	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00034	74 0c		 je	 SHORT $LN6@inflateCop
  00036	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  0003b	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00040	75 0a		 jne	 SHORT $LN7@inflateCop
$LN6@inflateCop:

; 1418 :         return Z_STREAM_ERROR;

  00042	b8 fe ff ff ff	 mov	 eax, -2
  00047	e9 0c 02 00 00	 jmp	 $LN8@inflateCop
$LN7@inflateCop:

; 1419 :     state = (struct inflate_state FAR *)source->state;

  0004c	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  00051	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00055	48 89 44 24 38	 mov	 QWORD PTR state$[rsp], rax

; 1420 : 
; 1421 :     /* allocate space */
; 1422 :     copy = (struct inflate_state FAR *)
; 1423 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  0005a	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00060	ba 01 00 00 00	 mov	 edx, 1
  00065	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  0006a	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  0006e	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  00073	ff 50 30	 call	 QWORD PTR [rax+48]
  00076	48 89 44 24 30	 mov	 QWORD PTR copy$[rsp], rax

; 1424 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0007b	48 83 7c 24 30
	00		 cmp	 QWORD PTR copy$[rsp], 0
  00081	75 0a		 jne	 SHORT $LN5@inflateCop
  00083	b8 fc ff ff ff	 mov	 eax, -4
  00088	e9 cb 01 00 00	 jmp	 $LN8@inflateCop
$LN5@inflateCop:

; 1425 :     window = Z_NULL;

  0008d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR window$[rsp], 0

; 1426 :     if (state->window != Z_NULL) {

  00096	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0009b	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000a0	74 60		 je	 SHORT $LN4@inflateCop

; 1427 :         window = (unsigned char FAR *)
; 1428 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  000a2	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  000a7	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000aa	b9 01 00 00 00	 mov	 ecx, 1
  000af	89 4c 24 40	 mov	 DWORD PTR tv190[rsp], ecx
  000b3	0f b6 c8	 movzx	 ecx, al
  000b6	8b 44 24 40	 mov	 eax, DWORD PTR tv190[rsp]
  000ba	d3 e0		 shl	 eax, cl
  000bc	41 b8 01 00 00
	00		 mov	 r8d, 1
  000c2	8b d0		 mov	 edx, eax
  000c4	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  000c9	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000cd	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  000d2	ff 50 30	 call	 QWORD PTR [rax+48]
  000d5	48 89 44 24 20	 mov	 QWORD PTR window$[rsp], rax

; 1429 :         if (window == Z_NULL) {

  000da	48 83 7c 24 20
	00		 cmp	 QWORD PTR window$[rsp], 0
  000e0	75 20		 jne	 SHORT $LN3@inflateCop

; 1430 :             ZFREE(source, copy);

  000e2	48 8b 54 24 30	 mov	 rdx, QWORD PTR copy$[rsp]
  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  000ec	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  000f0	48 8b 44 24 68	 mov	 rax, QWORD PTR source$[rsp]
  000f5	ff 50 38	 call	 QWORD PTR [rax+56]

; 1431 :             return Z_MEM_ERROR;

  000f8	b8 fc ff ff ff	 mov	 eax, -4
  000fd	e9 56 01 00 00	 jmp	 $LN8@inflateCop
$LN3@inflateCop:
$LN4@inflateCop:

; 1432 :         }
; 1433 :     }
; 1434 : 
; 1435 :     /* copy state */
; 1436 :     zmemcpy(dest, source, sizeof(z_stream));

  00102	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  00108	48 8b 54 24 68	 mov	 rdx, QWORD PTR source$[rsp]
  0010d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dest$[rsp]
  00112	e8 00 00 00 00	 call	 memcpy

; 1437 :     zmemcpy(copy, state, sizeof(struct inflate_state));

  00117	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  0011d	48 8b 54 24 38	 mov	 rdx, QWORD PTR state$[rsp]
  00122	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  00127	e8 00 00 00 00	 call	 memcpy

; 1438 :     if (state->lencode >= state->codes &&
; 1439 :         state->lencode <= state->codes + ENOUGH - 1) {

  0012c	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00131	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  00137	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  0013c	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00140	72 7e		 jb	 SHORT $LN2@inflateCop
  00142	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00147	48 05 d4 1b 00
	00		 add	 rax, 7124		; 00001bd4H
  0014d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00152	48 39 41 58	 cmp	 QWORD PTR [rcx+88], rax
  00156	77 68		 ja	 SHORT $LN2@inflateCop

; 1440 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  00158	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0015d	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  00163	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00168	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0016c	48 2b c8	 sub	 rcx, rax
  0016f	48 8b c1	 mov	 rax, rcx
  00172	48 c1 f8 02	 sar	 rax, 2
  00176	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  0017b	48 8d 84 81 48
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+1352]
  00183	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  00188	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 1441 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  0018c	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00191	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  00197	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  0019c	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  001a0	48 2b c8	 sub	 rcx, rax
  001a3	48 8b c1	 mov	 rax, rcx
  001a6	48 c1 f8 02	 sar	 rax, 2
  001aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  001af	48 8d 84 81 48
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+1352]
  001b7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  001bc	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
$LN2@inflateCop:

; 1442 :     }
; 1443 :     copy->next = copy->codes + (state->next - state->codes);

  001c0	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  001c5	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  001cb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  001d0	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  001d7	48 2b c8	 sub	 rcx, rax
  001da	48 8b c1	 mov	 rax, rcx
  001dd	48 c1 f8 02	 sar	 rax, 2
  001e1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  001e6	48 8d 84 81 48
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+1352]
  001ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  001f3	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 1444 :     if (window != Z_NULL) {

  001fa	48 83 7c 24 20
	00		 cmp	 QWORD PTR window$[rsp], 0
  00200	74 38		 je	 SHORT $LN1@inflateCop

; 1445 :         wsize = 1U << state->wbits;

  00202	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00207	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0020a	b9 01 00 00 00	 mov	 ecx, 1
  0020f	89 4c 24 44	 mov	 DWORD PTR tv220[rsp], ecx
  00213	0f b6 c8	 movzx	 ecx, al
  00216	8b 44 24 44	 mov	 eax, DWORD PTR tv220[rsp]
  0021a	d3 e0		 shl	 eax, cl
  0021c	89 44 24 28	 mov	 DWORD PTR wsize$[rsp], eax

; 1446 :         zmemcpy(window, state->window, wsize);

  00220	8b 44 24 28	 mov	 eax, DWORD PTR wsize$[rsp]
  00224	44 8b c0	 mov	 r8d, eax
  00227	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0022c	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  00230	48 8b 4c 24 20	 mov	 rcx, QWORD PTR window$[rsp]
  00235	e8 00 00 00 00	 call	 memcpy
$LN1@inflateCop:

; 1447 :     }
; 1448 :     copy->window = window;

  0023a	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  0023f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR window$[rsp]
  00244	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 1449 :     dest->state = (struct internal_state FAR *)copy;

  00248	48 8b 44 24 60	 mov	 rax, QWORD PTR dest$[rsp]
  0024d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  00252	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1450 :     return Z_OK;

  00256	33 c0		 xor	 eax, eax
$LN8@inflateCop:

; 1451 : }

  00258	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0025c	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
PUBLIC	inflateUndermine
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateUndermine DD imagerel $LN7
	DD	imagerel $LN7+116
	DD	imagerel $unwind$inflateUndermine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateUndermine DD 010d01H
	DD	0220dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateUndermine
_TEXT	SEGMENT
state$ = 0
tv70 = 8
strm$ = 32
subvert$ = 40
inflateUndermine PROC					; COMDAT

; 1456 : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 1457 :     struct inflate_state FAR *state;
; 1458 : 
; 1459 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000d	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00013	74 0c		 je	 SHORT $LN1@inflateUnd
  00015	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0001a	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001f	75 07		 jne	 SHORT $LN2@inflateUnd
$LN1@inflateUnd:
  00021	b8 fe ff ff ff	 mov	 eax, -2
  00026	eb 47		 jmp	 SHORT $LN3@inflateUnd
$LN2@inflateUnd:

; 1460 :     state = (struct inflate_state FAR *)strm->state;

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0002d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00031	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 1461 :     state->sane = !subvert;

  00035	83 7c 24 28 00	 cmp	 DWORD PTR subvert$[rsp], 0
  0003a	75 0a		 jne	 SHORT $LN5@inflateUnd
  0003c	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN6@inflateUnd
$LN5@inflateUnd:
  00046	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN6@inflateUnd:
  0004e	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00052	8b 4c 24 08	 mov	 ecx, DWORD PTR tv70[rsp]
  00056	89 88 d8 1b 00
	00		 mov	 DWORD PTR [rax+7128], ecx

; 1462 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1463 :     return Z_OK;
; 1464 : #else
; 1465 :     state->sane = 1;

  0005c	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00060	c7 80 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7128], 1

; 1466 :     return Z_DATA_ERROR;

  0006a	b8 fd ff ff ff	 mov	 eax, -3
$LN3@inflateUnd:

; 1467 : #endif
; 1468 : }

  0006f	48 83 c4 18	 add	 rsp, 24
  00073	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
PUBLIC	inflateMark
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateMark DD imagerel $LN9
	DD	imagerel $LN9+143
	DD	imagerel $unwind$inflateMark
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateMark DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateMark
_TEXT	SEGMENT
state$ = 0
tv77 = 8
tv76 = 12
strm$ = 32
inflateMark PROC					; COMDAT

; 1472 : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN1@inflateMar
  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 07		 jne	 SHORT $LN2@inflateMar
$LN1@inflateMar:
  0001d	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H
  00022	eb 66		 jmp	 SHORT $LN3@inflateMar
$LN2@inflateMar:

; 1476 :     state = (struct inflate_state FAR *)strm->state;

  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00029	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0002d	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  00031	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00035	83 38 0f	 cmp	 DWORD PTR [rax], 15
  00038	75 0d		 jne	 SHORT $LN7@inflateMar
  0003a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0003e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00041	89 44 24 08	 mov	 DWORD PTR tv77[rsp], eax
  00045	eb 32		 jmp	 SHORT $LN8@inflateMar
$LN7@inflateMar:
  00047	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0004b	83 38 18	 cmp	 DWORD PTR [rax], 24
  0004e	75 19		 jne	 SHORT $LN5@inflateMar
  00050	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00054	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  00058	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  0005b	8b 80 e0 1b 00
	00		 mov	 eax, DWORD PTR [rax+7136]
  00061	2b c1		 sub	 eax, ecx
  00063	89 44 24 0c	 mov	 DWORD PTR tv76[rsp], eax
  00067	eb 08		 jmp	 SHORT $LN6@inflateMar
$LN5@inflateMar:
  00069	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN6@inflateMar:
  00071	8b 44 24 0c	 mov	 eax, DWORD PTR tv76[rsp]
  00075	89 44 24 08	 mov	 DWORD PTR tv77[rsp], eax
$LN8@inflateMar:
  00079	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0007d	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  00083	c1 e0 10	 shl	 eax, 16
  00086	03 44 24 08	 add	 eax, DWORD PTR tv77[rsp]
$LN3@inflateMar:

; 1480 : }

  0008a	48 83 c4 18	 add	 rsp, 24
  0008e	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
END
