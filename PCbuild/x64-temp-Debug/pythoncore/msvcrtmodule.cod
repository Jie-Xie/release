; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_06EGGDDPIF@msvcrt?$AA@			; `string'
PUBLIC	??_C@_08GNIEHJDM@ungetwch?$AA@			; `string'
PUBLIC	??_C@_06MIBLCGCE@putwch?$AA@			; `string'
PUBLIC	??_C@_07DFOBMEOJ@getwche?$AA@			; `string'
PUBLIC	??_C@_06GJLEIGPP@getwch?$AA@			; `string'
PUBLIC	??_C@_0P@NEOMJLOK@set_error_mode?$AA@		; `string'
PUBLIC	??_C@_0BB@BCJCPHHC@CrtSetReportMode?$AA@	; `string'
PUBLIC	??_C@_0BB@EODKMIAH@CrtSetReportFile?$AA@	; `string'
PUBLIC	??_C@_0N@FNBEHOIE@SetErrorMode?$AA@		; `string'
PUBLIC	??_C@_07OCCPOMBI@ungetch?$AA@			; `string'
PUBLIC	??_C@_05HHMFJPDP@putch?$AA@			; `string'
PUBLIC	??_C@_06PDENHJL@getche?$AA@			; `string'
PUBLIC	??_C@_05JPGDKJO@getch?$AA@			; `string'
PUBLIC	??_C@_05DNDLBGFJ@kbhit?$AA@			; `string'
PUBLIC	??_C@_0O@FHDEIKIH@get_osfhandle?$AA@		; `string'
PUBLIC	??_C@_0P@KCLKOFOI@open_osfhandle?$AA@		; `string'
PUBLIC	??_C@_07KEIMDCMH@setmode?$AA@			; `string'
PUBLIC	??_C@_07CODODBAF@locking?$AA@			; `string'
PUBLIC	??_C@_07PBDFNLC@heapmin?$AA@			; `string'
;	COMDAT ??_C@_06EGGDDPIF@msvcrt?$AA@
CONST	SEGMENT
??_C@_06EGGDDPIF@msvcrt?$AA@ DB 'msvcrt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08GNIEHJDM@ungetwch?$AA@
CONST	SEGMENT
??_C@_08GNIEHJDM@ungetwch?$AA@ DB 'ungetwch', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MIBLCGCE@putwch?$AA@
CONST	SEGMENT
??_C@_06MIBLCGCE@putwch?$AA@ DB 'putwch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DFOBMEOJ@getwche?$AA@
CONST	SEGMENT
??_C@_07DFOBMEOJ@getwche?$AA@ DB 'getwche', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GJLEIGPP@getwch?$AA@
CONST	SEGMENT
??_C@_06GJLEIGPP@getwch?$AA@ DB 'getwch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NEOMJLOK@set_error_mode?$AA@
CONST	SEGMENT
??_C@_0P@NEOMJLOK@set_error_mode?$AA@ DB 'set_error_mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BCJCPHHC@CrtSetReportMode?$AA@
CONST	SEGMENT
??_C@_0BB@BCJCPHHC@CrtSetReportMode?$AA@ DB 'CrtSetReportMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EODKMIAH@CrtSetReportFile?$AA@
CONST	SEGMENT
??_C@_0BB@EODKMIAH@CrtSetReportFile?$AA@ DB 'CrtSetReportFile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FNBEHOIE@SetErrorMode?$AA@
CONST	SEGMENT
??_C@_0N@FNBEHOIE@SetErrorMode?$AA@ DB 'SetErrorMode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07OCCPOMBI@ungetch?$AA@
CONST	SEGMENT
??_C@_07OCCPOMBI@ungetch?$AA@ DB 'ungetch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05HHMFJPDP@putch?$AA@
CONST	SEGMENT
??_C@_05HHMFJPDP@putch?$AA@ DB 'putch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06PDENHJL@getche?$AA@
CONST	SEGMENT
??_C@_06PDENHJL@getche?$AA@ DB 'getche', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JPGDKJO@getch?$AA@
CONST	SEGMENT
??_C@_05JPGDKJO@getch?$AA@ DB 'getch', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNDLBGFJ@kbhit?$AA@
CONST	SEGMENT
??_C@_05DNDLBGFJ@kbhit?$AA@ DB 'kbhit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FHDEIKIH@get_osfhandle?$AA@
CONST	SEGMENT
??_C@_0O@FHDEIKIH@get_osfhandle?$AA@ DB 'get_osfhandle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KCLKOFOI@open_osfhandle?$AA@
CONST	SEGMENT
??_C@_0P@KCLKOFOI@open_osfhandle?$AA@ DB 'open_osfhandle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KEIMDCMH@setmode?$AA@
CONST	SEGMENT
??_C@_07KEIMDCMH@setmode?$AA@ DB 'setmode', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CODODBAF@locking?$AA@
CONST	SEGMENT
??_C@_07CODODBAF@locking?$AA@ DB 'locking', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PBDFNLC@heapmin?$AA@
CONST	SEGMENT
??_C@_07PBDFNLC@heapmin?$AA@ DB 'heapmin', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
heapmin_doc DB	'heapmin() -> None', 0aH, 0aH, 'Force the malloc() heap t'
	DB	'o clean itself up and return unused blocks', 0aH, 'to the ope'
	DB	'rating system. On failure, this raises IOError.', 00H
	ORG $+15
locking_doc DB	'locking(fd, mode, nbytes) -> None', 0aH, 0aH, 'Lock part'
	DB	' of a file based on file descriptor fd from the C runtime.', 0aH
	DB	'Raises IOError on failure. The locked region of the file exte'
	DB	'nds from', 0aH, 'the current file position for nbytes bytes, '
	DB	'and may continue beyond', 0aH, 'the end of the file. mode mus'
	DB	't be one of the LK_* constants listed', 0aH, 'below. Multiple'
	DB	' regions in a file may be locked at the same time, but', 0aH, 'm'
	DB	'ay not overlap. Adjacent regions are not merged; they must be'
	DB	' unlocked', 0aH, 'individually.', 00H
setmode_doc DB	'setmode(fd, mode) -> Previous mode', 0aH, 0aH, 'Set the '
	DB	'line-end translation mode for the file descriptor fd. To set', 0aH
	DB	'it to text mode, flags should be os.O_TEXT; for binary, it sh'
	DB	'ould be', 0aH, 'os.O_BINARY.', 00H
	ORG $+5
open_osfhandle_doc DB 'open_osfhandle(handle, flags) -> file descriptor', 0aH
	DB	0aH, 'Create a C runtime file descriptor from the file handle '
	DB	'handle. The', 0aH, 'flags parameter should be a bitwise OR of'
	DB	' os.O_APPEND, os.O_RDONLY,', 0aH, 'and os.O_TEXT. The returne'
	DB	'd file descriptor may be used as a parameter', 0aH, 'to os.fd'
	DB	'open() to create a file object.', 00H
	ORG $+7
get_osfhandle_doc DB 'get_osfhandle(fd) -> file handle', 0aH, 0aH, 'Retur'
	DB	'n the file handle for the file descriptor fd. Raises IOError', 0aH
	DB	'if fd is not recognized.', 00H
	ORG $+3
kbhit_doc DB	'kbhit() -> bool', 0aH, 0aH, 'Return true if a keypress i'
	DB	's waiting to be read.', 00H
	ORG $+14
getch_doc DB	'getch() -> key character', 0aH, 0aH, 'Read a keypress an'
	DB	'd return the resulting character as a byte string.', 0aH, 'No'
	DB	'thing is echoed to the console. This call will block if a key'
	DB	'press is', 0aH, 'not already available, but will not wait for'
	DB	' Enter to be pressed. If the', 0aH, 'pressed key was a specia'
	DB	'l function key, this will return ''\000'' or', 0aH, '''\xe0'''
	DB	'; the next call will return the keycode. The Control-C keypre'
	DB	'ss', 0aH, 'cannot be read with this function.', 00H
	ORG $+4
getwch_doc DB	'getwch() -> Unicode key character', 0aH, 0aH, 'Wide char'
	DB	' variant of getch(), returning a Unicode value.', 00H
	ORG $+4
getche_doc DB	'getche() -> key character', 0aH, 0aH, 'Similar to getch('
	DB	'), but the keypress will be echoed if it represents', 0aH, 'a'
	DB	' printable character.', 00H
	ORG $+9
getwche_doc DB	'getwche() -> Unicode key character', 0aH, 0aH, 'Wide cha'
	DB	'r variant of getche(), returning a Unicode value.', 00H
	ORG $+2
putch_doc DB	'putch(char) -> None', 0aH, 0aH, 'Print the byte string c'
	DB	'har to the console without buffering.', 00H
	ORG $+14
putwch_doc DB	'putwch(unicode_char) -> None', 0aH, 0aH, 'Wide char vari'
	DB	'ant of putch(), accepting a Unicode value.', 00H
	ORG $+9
ungetch_doc DB	'ungetch(char) -> None', 0aH, 0aH, 'Cause the byte string'
	DB	' char to be "pushed back" into the', 0aH, 'console buffer; it'
	DB	' will be the next character read by', 0aH, 'getch() or getche'
	DB	'().', 00H
	ORG $+6
ungetwch_doc DB	'ungetwch(unicode_char) -> None', 0aH, 0aH, 'Wide char va'
	DB	'riant of ungetch(), accepting a Unicode value.', 00H
	ORG $+5
msvcrt_functions DQ FLAT:??_C@_07PBDFNLC@heapmin?$AA@
	DQ	FLAT:msvcrt_heapmin
	DD	01H
	ORG $+4
	DQ	FLAT:heapmin_doc
	DQ	FLAT:??_C@_07CODODBAF@locking?$AA@
	DQ	FLAT:msvcrt_locking
	DD	01H
	ORG $+4
	DQ	FLAT:locking_doc
	DQ	FLAT:??_C@_07KEIMDCMH@setmode?$AA@
	DQ	FLAT:msvcrt_setmode
	DD	01H
	ORG $+4
	DQ	FLAT:setmode_doc
	DQ	FLAT:??_C@_0P@KCLKOFOI@open_osfhandle?$AA@
	DQ	FLAT:msvcrt_open_osfhandle
	DD	01H
	ORG $+4
	DQ	FLAT:open_osfhandle_doc
	DQ	FLAT:??_C@_0O@FHDEIKIH@get_osfhandle?$AA@
	DQ	FLAT:msvcrt_get_osfhandle
	DD	01H
	ORG $+4
	DQ	FLAT:get_osfhandle_doc
	DQ	FLAT:??_C@_05DNDLBGFJ@kbhit?$AA@
	DQ	FLAT:msvcrt_kbhit
	DD	01H
	ORG $+4
	DQ	FLAT:kbhit_doc
	DQ	FLAT:??_C@_05JPGDKJO@getch?$AA@
	DQ	FLAT:msvcrt_getch
	DD	01H
	ORG $+4
	DQ	FLAT:getch_doc
	DQ	FLAT:??_C@_06PDENHJL@getche?$AA@
	DQ	FLAT:msvcrt_getche
	DD	01H
	ORG $+4
	DQ	FLAT:getche_doc
	DQ	FLAT:??_C@_05HHMFJPDP@putch?$AA@
	DQ	FLAT:msvcrt_putch
	DD	01H
	ORG $+4
	DQ	FLAT:putch_doc
	DQ	FLAT:??_C@_07OCCPOMBI@ungetch?$AA@
	DQ	FLAT:msvcrt_ungetch
	DD	01H
	ORG $+4
	DQ	FLAT:ungetch_doc
	DQ	FLAT:??_C@_0N@FNBEHOIE@SetErrorMode?$AA@
	DQ	FLAT:seterrormode
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0BB@EODKMIAH@CrtSetReportFile?$AA@
	DQ	FLAT:msvcrt_setreportfile
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0BB@BCJCPHHC@CrtSetReportMode?$AA@
	DQ	FLAT:msvcrt_setreportmode
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_0P@NEOMJLOK@set_error_mode?$AA@
	DQ	FLAT:msvcrt_seterrormode
	DD	01H
	ORG $+4
	ORG $+8
	DQ	FLAT:??_C@_06GJLEIGPP@getwch?$AA@
	DQ	FLAT:msvcrt_getwch
	DD	01H
	ORG $+4
	DQ	FLAT:getwch_doc
	DQ	FLAT:??_C@_07DFOBMEOJ@getwche?$AA@
	DQ	FLAT:msvcrt_getwche
	DD	01H
	ORG $+4
	DQ	FLAT:getwche_doc
	DQ	FLAT:??_C@_06MIBLCGCE@putwch?$AA@
	DQ	FLAT:msvcrt_putwch
	DD	01H
	ORG $+4
	DQ	FLAT:putwch_doc
	DQ	FLAT:??_C@_08GNIEHJDM@ungetwch?$AA@
	DQ	FLAT:msvcrt_ungetwch
	DD	01H
	ORG $+4
	DQ	FLAT:ungetwch_doc
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+16
msvcrtmodule DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000000H
	ORG $+8
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	dead1234beef5678H
	DQ	dead1234beef5678H
	DQ	0000000000000001H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
	DQ	FLAT:??_C@_06EGGDDPIF@msvcrt?$AA@
	DQ	0000000000000000H
	DQ	ffffffffffffffffH
	DQ	FLAT:msvcrt_functions
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
PUBLIC	_Py_IncRef
PUBLIC	??_C@_08DHCHNMDJ@?3heapmin?$AA@			; `string'
EXTRN	_Py_NoneStruct:BYTE
EXTRN	PyErr_SetFromErrno:PROC
EXTRN	PyExc_IOError:QWORD
EXTRN	__imp__heapmin:PROC
EXTRN	PyArg_ParseTuple:PROC
;	COMDAT pdata
; File c:\src\pyparallel\pc\msvcrtmodule.c
pdata	SEGMENT
$pdata$msvcrt_heapmin DD imagerel msvcrt_heapmin
	DD	imagerel msvcrt_heapmin+87
	DD	imagerel $unwind$msvcrt_heapmin
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_heapmin DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT ??_C@_08DHCHNMDJ@?3heapmin?$AA@
CONST	SEGMENT
??_C@_08DHCHNMDJ@?3heapmin?$AA@ DB ':heapmin', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_heapmin
_TEXT	SEGMENT
self$ = 48
args$ = 56
msvcrt_heapmin PROC					; COMDAT

; 39   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 40   :     if (!PyArg_ParseTuple(args, ":heapmin"))

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08DHCHNMDJ@?3heapmin?$AA@
  00015	48 8b 4c 24 38	 mov	 rcx, QWORD PTR args$[rsp]
  0001a	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001f	85 c0		 test	 eax, eax
  00021	75 04		 jne	 SHORT $LN2@msvcrt_hea

; 41   :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 2b		 jmp	 SHORT $LN3@msvcrt_hea
$LN2@msvcrt_hea:

; 42   : 
; 43   :     if (_heapmin() != 0)

  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__heapmin
  0002d	85 c0		 test	 eax, eax
  0002f	74 0e		 je	 SHORT $LN1@msvcrt_hea

; 44   :         return PyErr_SetFromErrno(PyExc_IOError);

  00031	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00038	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  0003d	eb 13		 jmp	 SHORT $LN3@msvcrt_hea
$LN1@msvcrt_hea:

; 45   : 
; 46   :     Py_INCREF(Py_None);

  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00046	e8 00 00 00 00	 call	 _Py_IncRef

; 47   :     return Py_None;

  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@msvcrt_hea:

; 48   : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
msvcrt_heapmin ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DHGMCEID@_Py_IncRef?$AA@		; `string'
PUBLIC	??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ ; `string'
EXTRN	_Py_RefTotal:QWORD
EXTRN	_PyParallel_Guard:PROC
EXTRN	_Py_PXCTX:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_IncRef DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$_Py_IncRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_IncRef DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT ??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
CONST	SEGMENT
??_C@_0L@DHGMCEID@_Py_IncRef?$AA@ DB '_Py_IncRef', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
CONST	SEGMENT
??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@ DB 'c:\src\pypa'
	DB	'rallel\include\object.h', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_IncRef
_TEXT	SEGMENT
op$ = 64
_Py_IncRef PROC						; COMDAT

; 904  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 905  :     if ((!Py_PXCTX && (Py_ISPY(op) || Px_PERSISTED(op)))) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	75 6d		 jne	 SHORT $LN2@Py_IncRef
  00012	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0001a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR op$[rsp]
  0001f	41 b8 89 03 00
	00		 mov	 r8d, 905		; 00000389H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DHGMCEID@_Py_IncRef?$AA@
  00033	e8 00 00 00 00	 call	 _PyParallel_Guard
  00038	85 c0		 test	 eax, eax
  0003a	75 12		 jne	 SHORT $LN1@Py_IncRef
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  00041	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00045	48 83 e0 20	 and	 rax, 32			; 00000020H
  00049	48 85 c0	 test	 rax, rax
  0004c	74 31		 je	 SHORT $LN2@Py_IncRef
$LN1@Py_IncRef:

; 906  :         _Py_INC_REFTOTAL;

  0004e	e8 00 00 00 00	 call	 _Py_PXCTX
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN5@Py_IncRef
  00057	eb 11		 jmp	 SHORT $LN6@Py_IncRef
$LN5@Py_IncRef:
  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00060	48 ff c0	 inc	 rax
  00063	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN6@Py_IncRef:

; 907  :         (((PyObject*)(op))->ob_refcnt++);

  0006a	48 8b 44 24 40	 mov	 rax, QWORD PTR op$[rsp]
  0006f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00073	48 ff c0	 inc	 rax
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op$[rsp]
  0007b	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax
$LN2@Py_IncRef:

; 908  :     }
; 909  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
_Py_IncRef ENDP
_TEXT	ENDS
PUBLIC	??_C@_0M@NOGPHIJF@iil?3locking?$AA@		; `string'
EXTRN	PyEval_RestoreThread:PROC
EXTRN	__imp__locking:PROC
EXTRN	PyEval_SaveThread:PROC
;	COMDAT pdata
; File c:\src\pyparallel\pc\msvcrtmodule.c
pdata	SEGMENT
$pdata$msvcrt_locking DD imagerel msvcrt_locking
	DD	imagerel msvcrt_locking+147
	DD	imagerel $unwind$msvcrt_locking
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_locking DD 010e01H
	DD	0a20eH
xdata	ENDS
;	COMDAT ??_C@_0M@NOGPHIJF@iil?3locking?$AA@
CONST	SEGMENT
??_C@_0M@NOGPHIJF@iil?3locking?$AA@ DB 'iil:locking', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_locking
_TEXT	SEGMENT
mode$ = 48
nbytes$ = 52
err$ = 56
fd$ = 60
_save$121114 = 64
self$ = 96
args$ = 104
msvcrt_locking PROC					; COMDAT

; 59   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 60   :     int fd;
; 61   :     int mode;
; 62   :     long nbytes;
; 63   :     int err;
; 64   : 
; 65   :     if (!PyArg_ParseTuple(args, "iil:locking", &fd, &mode, &nbytes))

  0000e	48 8d 44 24 34	 lea	 rax, QWORD PTR nbytes$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00018	4c 8d 4c 24 30	 lea	 r9, QWORD PTR mode$[rsp]
  0001d	4c 8d 44 24 3c	 lea	 r8, QWORD PTR fd$[rsp]
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@NOGPHIJF@iil?3locking?$AA@
  00029	48 8b 4c 24 68	 mov	 rcx, QWORD PTR args$[rsp]
  0002e	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00033	85 c0		 test	 eax, eax
  00035	75 04		 jne	 SHORT $LN2@msvcrt_loc

; 66   :         return NULL;

  00037	33 c0		 xor	 eax, eax
  00039	eb 53		 jmp	 SHORT $LN3@msvcrt_loc
$LN2@msvcrt_loc:

; 67   : 
; 68   :     Py_BEGIN_ALLOW_THREADS

  0003b	e8 00 00 00 00	 call	 PyEval_SaveThread
  00040	48 89 44 24 40	 mov	 QWORD PTR _save$121114[rsp], rax

; 69   :     err = _locking(fd, mode, nbytes);

  00045	44 8b 44 24 34	 mov	 r8d, DWORD PTR nbytes$[rsp]
  0004a	8b 54 24 30	 mov	 edx, DWORD PTR mode$[rsp]
  0004e	8b 4c 24 3c	 mov	 ecx, DWORD PTR fd$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__locking
  00058	89 44 24 38	 mov	 DWORD PTR err$[rsp], eax

; 70   :     Py_END_ALLOW_THREADS

  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _save$121114[rsp]
  00061	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 71   :     if (err != 0)

  00066	83 7c 24 38 00	 cmp	 DWORD PTR err$[rsp], 0
  0006b	74 0e		 je	 SHORT $LN1@msvcrt_loc

; 72   :         return PyErr_SetFromErrno(PyExc_IOError);

  0006d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00074	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  00079	eb 13		 jmp	 SHORT $LN3@msvcrt_loc
$LN1@msvcrt_loc:

; 73   : 
; 74   :     Py_INCREF(Py_None);

  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00082	e8 00 00 00 00	 call	 _Py_IncRef

; 75   :     return Py_None;

  00087	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@msvcrt_loc:

; 76   : }

  0008e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00092	c3		 ret	 0
msvcrt_locking ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@BHFNJBAJ@ii?3setmode?$AA@		; `string'
EXTRN	PyLong_FromLong:PROC
EXTRN	__imp__setmode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_setmode DD imagerel msvcrt_setmode
	DD	imagerel msvcrt_setmode+102
	DD	imagerel $unwind$msvcrt_setmode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_setmode DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0L@BHFNJBAJ@ii?3setmode?$AA@
CONST	SEGMENT
??_C@_0L@BHFNJBAJ@ii?3setmode?$AA@ DB 'ii:setmode', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_setmode
_TEXT	SEGMENT
flags$ = 32
fd$ = 36
self$ = 64
args$ = 72
msvcrt_setmode PROC					; COMDAT

; 92   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 93   :     int fd;
; 94   :     int flags;
; 95   :     if (!PyArg_ParseTuple(args,"ii:setmode", &fd, &flags))

  0000e	4c 8d 4c 24 20	 lea	 r9, QWORD PTR flags$[rsp]
  00013	4c 8d 44 24 24	 lea	 r8, QWORD PTR fd$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@BHFNJBAJ@ii?3setmode?$AA@
  0001f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN2@msvcrt_set

; 96   :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 30		 jmp	 SHORT $LN3@msvcrt_set
$LN2@msvcrt_set:

; 97   : 
; 98   :     flags = _setmode(fd, flags);

  00031	8b 54 24 20	 mov	 edx, DWORD PTR flags$[rsp]
  00035	8b 4c 24 24	 mov	 ecx, DWORD PTR fd$[rsp]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__setmode
  0003f	89 44 24 20	 mov	 DWORD PTR flags$[rsp], eax

; 99   :     if (flags == -1)

  00043	83 7c 24 20 ff	 cmp	 DWORD PTR flags$[rsp], -1
  00048	75 0e		 jne	 SHORT $LN1@msvcrt_set

; 100  :         return PyErr_SetFromErrno(PyExc_IOError);

  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00051	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  00056	eb 09		 jmp	 SHORT $LN3@msvcrt_set
$LN1@msvcrt_set:

; 101  : 
; 102  :     return PyLong_FromLong(flags);

  00058	8b 4c 24 20	 mov	 ecx, DWORD PTR flags$[rsp]
  0005c	e8 00 00 00 00	 call	 PyLong_FromLong
$LN3@msvcrt_set:

; 103  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
msvcrt_setmode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@POLILEAE@li?3open_osfhandle?$AA@	; `string'
EXTRN	__imp__open_osfhandle:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_open_osfhandle DD imagerel msvcrt_open_osfhandle
	DD	imagerel msvcrt_open_osfhandle+106
	DD	imagerel $unwind$msvcrt_open_osfhandle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_open_osfhandle DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BC@POLILEAE@li?3open_osfhandle?$AA@
CONST	SEGMENT
??_C@_0BC@POLILEAE@li?3open_osfhandle?$AA@ DB 'li:open_osfhandle', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_open_osfhandle
_TEXT	SEGMENT
flags$ = 32
fd$ = 36
handle$ = 40
self$ = 64
args$ = 72
msvcrt_open_osfhandle PROC				; COMDAT

; 115  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 116  :     long handle;
; 117  :     int flags;
; 118  :     int fd;
; 119  : 
; 120  :     if (!PyArg_ParseTuple(args, "li:open_osfhandle", &handle, &flags))

  0000e	4c 8d 4c 24 20	 lea	 r9, QWORD PTR flags$[rsp]
  00013	4c 8d 44 24 28	 lea	 r8, QWORD PTR handle$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@POLILEAE@li?3open_osfhandle?$AA@
  0001f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN2@msvcrt_ope

; 121  :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 34		 jmp	 SHORT $LN3@msvcrt_ope
$LN2@msvcrt_ope:

; 122  : 
; 123  :     fd = _open_osfhandle(handle, flags);

  00031	48 63 44 24 28	 movsxd	 rax, DWORD PTR handle$[rsp]
  00036	8b 54 24 20	 mov	 edx, DWORD PTR flags$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__open_osfhandle
  00043	89 44 24 24	 mov	 DWORD PTR fd$[rsp], eax

; 124  :     if (fd == -1)

  00047	83 7c 24 24 ff	 cmp	 DWORD PTR fd$[rsp], -1
  0004c	75 0e		 jne	 SHORT $LN1@msvcrt_ope

; 125  :         return PyErr_SetFromErrno(PyExc_IOError);

  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00055	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  0005a	eb 09		 jmp	 SHORT $LN3@msvcrt_ope
$LN1@msvcrt_ope:

; 126  : 
; 127  :     return PyLong_FromLong(fd);

  0005c	8b 4c 24 24	 mov	 ecx, DWORD PTR fd$[rsp]
  00060	e8 00 00 00 00	 call	 PyLong_FromLong
$LN3@msvcrt_ope:

; 128  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
msvcrt_open_osfhandle ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BA@CFKGOHIL@i?3get_osfhandle?$AA@	; `string'
EXTRN	PyLong_FromVoidPtr:PROC
EXTRN	__imp__get_osfhandle:PROC
EXTRN	_PyVerify_fd:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_get_osfhandle DD imagerel msvcrt_get_osfhandle
	DD	imagerel msvcrt_get_osfhandle+123
	DD	imagerel $unwind$msvcrt_get_osfhandle
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_get_osfhandle DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0BA@CFKGOHIL@i?3get_osfhandle?$AA@
CONST	SEGMENT
??_C@_0BA@CFKGOHIL@i?3get_osfhandle?$AA@ DB 'i:get_osfhandle', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_get_osfhandle
_TEXT	SEGMENT
handle$ = 32
fd$ = 40
self$ = 64
args$ = 72
msvcrt_get_osfhandle PROC				; COMDAT

; 141  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 142  :     int fd;
; 143  :     Py_intptr_t handle;
; 144  : 
; 145  :     if (!PyArg_ParseTuple(args,"i:get_osfhandle", &fd))

  0000e	4c 8d 44 24 28	 lea	 r8, QWORD PTR fd$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@CFKGOHIL@i?3get_osfhandle?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN3@msvcrt_get

; 146  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 4a		 jmp	 SHORT $LN4@msvcrt_get
$LN3@msvcrt_get:

; 147  : 
; 148  :     if (!_PyVerify_fd(fd))

  0002c	8b 4c 24 28	 mov	 ecx, DWORD PTR fd$[rsp]
  00030	e8 00 00 00 00	 call	 _PyVerify_fd
  00035	85 c0		 test	 eax, eax
  00037	75 0e		 jne	 SHORT $LN2@msvcrt_get

; 149  :         return PyErr_SetFromErrno(PyExc_IOError);

  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00040	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  00045	eb 2f		 jmp	 SHORT $LN4@msvcrt_get
$LN2@msvcrt_get:

; 150  : 
; 151  :     handle = _get_osfhandle(fd);

  00047	8b 4c 24 28	 mov	 ecx, DWORD PTR fd$[rsp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  00051	48 89 44 24 20	 mov	 QWORD PTR handle$[rsp], rax

; 152  :     if (handle == -1)

  00056	48 83 7c 24 20
	ff		 cmp	 QWORD PTR handle$[rsp], -1
  0005c	75 0e		 jne	 SHORT $LN1@msvcrt_get

; 153  :         return PyErr_SetFromErrno(PyExc_IOError);

  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00065	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  0006a	eb 0a		 jmp	 SHORT $LN4@msvcrt_get
$LN1@msvcrt_get:

; 154  : 
; 155  :     /* technically 'handle' is not a pointer, but a integer as
; 156  :        large as a pointer, Python's *VoidPtr interface is the
; 157  :        most appropriate here */
; 158  :     return PyLong_FromVoidPtr((void*)handle);

  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR handle$[rsp]
  00071	e8 00 00 00 00	 call	 PyLong_FromVoidPtr
$LN4@msvcrt_get:

; 159  : }

  00076	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007a	c3		 ret	 0
msvcrt_get_osfhandle ENDP
_TEXT	ENDS
PUBLIC	??_C@_06BNIGJCJI@?3kbhit?$AA@			; `string'
EXTRN	__imp__kbhit:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_kbhit DD imagerel msvcrt_kbhit
	DD	imagerel msvcrt_kbhit+63
	DD	imagerel $unwind$msvcrt_kbhit
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_kbhit DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_06BNIGJCJI@?3kbhit?$AA@
CONST	SEGMENT
??_C@_06BNIGJCJI@?3kbhit?$AA@ DB ':kbhit', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_kbhit
_TEXT	SEGMENT
ok$ = 32
self$ = 64
args$ = 72
msvcrt_kbhit PROC					; COMDAT

; 171  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 172  :     int ok;
; 173  : 
; 174  :     if (!PyArg_ParseTuple(args, ":kbhit"))

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06BNIGJCJI@?3kbhit?$AA@
  00015	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001a	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001f	85 c0		 test	 eax, eax
  00021	75 04		 jne	 SHORT $LN1@msvcrt_kbh

; 175  :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 13		 jmp	 SHORT $LN2@msvcrt_kbh
$LN1@msvcrt_kbh:

; 176  : 
; 177  :     ok = _kbhit();

  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__kbhit
  0002d	89 44 24 20	 mov	 DWORD PTR ok$[rsp], eax

; 178  :     return PyLong_FromLong(ok);

  00031	8b 4c 24 20	 mov	 ecx, DWORD PTR ok$[rsp]
  00035	e8 00 00 00 00	 call	 PyLong_FromLong
$LN2@msvcrt_kbh:

; 179  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
msvcrt_kbhit ENDP
_TEXT	ENDS
PUBLIC	??_C@_06CJELLOFP@?3getch?$AA@			; `string'
EXTRN	PyBytes_FromStringAndSize:PROC
EXTRN	__imp__getch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_getch DD imagerel msvcrt_getch
	DD	imagerel msvcrt_getch+98
	DD	imagerel $unwind$msvcrt_getch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_getch DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_06CJELLOFP@?3getch?$AA@
CONST	SEGMENT
??_C@_06CJELLOFP@?3getch?$AA@ DB ':getch', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_getch
_TEXT	SEGMENT
s$ = 32
ch$ = 36
_save$121182 = 40
self$ = 64
args$ = 72
msvcrt_getch PROC					; COMDAT

; 188  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 189  :     int ch;
; 190  :     char s[1];
; 191  : 
; 192  :     if (!PyArg_ParseTuple(args, ":getch"))

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06CJELLOFP@?3getch?$AA@
  00015	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001a	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001f	85 c0		 test	 eax, eax
  00021	75 04		 jne	 SHORT $LN1@msvcrt_get@2

; 193  :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 36		 jmp	 SHORT $LN2@msvcrt_get@2
$LN1@msvcrt_get@2:

; 194  : 
; 195  :     Py_BEGIN_ALLOW_THREADS

  00027	e8 00 00 00 00	 call	 PyEval_SaveThread
  0002c	48 89 44 24 28	 mov	 QWORD PTR _save$121182[rsp], rax

; 196  :     ch = _getch();

  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__getch
  00037	89 44 24 24	 mov	 DWORD PTR ch$[rsp], eax

; 197  :     Py_END_ALLOW_THREADS

  0003b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _save$121182[rsp]
  00040	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 198  :     s[0] = ch;

  00045	0f b6 44 24 24	 movzx	 eax, BYTE PTR ch$[rsp]
  0004a	88 44 24 20	 mov	 BYTE PTR s$[rsp], al

; 199  :     return PyBytes_FromStringAndSize(s, 1);

  0004e	ba 01 00 00 00	 mov	 edx, 1
  00053	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00058	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
$LN2@msvcrt_get@2:

; 200  : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
msvcrt_getch ENDP
_TEXT	ENDS
PUBLIC	??_C@_07IFPHMJFN@?3getwch?$AA@			; `string'
EXTRN	PyUnicode_FromOrdinal:PROC
EXTRN	__imp__getwch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_getwch DD imagerel msvcrt_getwch
	DD	imagerel msvcrt_getwch+87
	DD	imagerel $unwind$msvcrt_getwch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_getwch DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_07IFPHMJFN@?3getwch?$AA@
CONST	SEGMENT
??_C@_07IFPHMJFN@?3getwch?$AA@ DB ':getwch', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_getwch
_TEXT	SEGMENT
ch$ = 32
_save$121194 = 40
self$ = 64
args$ = 72
msvcrt_getwch PROC					; COMDAT

; 215  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 216  :     wchar_t ch;
; 217  : 
; 218  :     if (!PyArg_ParseTuple(args, ":getwch"))

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07IFPHMJFN@?3getwch?$AA@
  00015	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001a	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001f	85 c0		 test	 eax, eax
  00021	75 04		 jne	 SHORT $LN1@msvcrt_get@3

; 219  :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 2b		 jmp	 SHORT $LN2@msvcrt_get@3
$LN1@msvcrt_get@3:

; 220  : 
; 221  :     Py_BEGIN_ALLOW_THREADS

  00027	e8 00 00 00 00	 call	 PyEval_SaveThread
  0002c	48 89 44 24 28	 mov	 QWORD PTR _save$121194[rsp], rax

; 222  :     ch = _getwch();

  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__getwch
  00037	66 89 44 24 20	 mov	 WORD PTR ch$[rsp], ax

; 223  :     Py_END_ALLOW_THREADS

  0003c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _save$121194[rsp]
  00041	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 224  :     return PyUnicode_FromOrdinal(ch);

  00046	0f b7 44 24 20	 movzx	 eax, WORD PTR ch$[rsp]
  0004b	8b c8		 mov	 ecx, eax
  0004d	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal
$LN2@msvcrt_get@3:

; 225  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
msvcrt_getwch ENDP
_TEXT	ENDS
PUBLIC	??_C@_07ODHHJIDJ@?3getche?$AA@			; `string'
EXTRN	__imp__getche:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_getche DD imagerel msvcrt_getche
	DD	imagerel msvcrt_getche+98
	DD	imagerel $unwind$msvcrt_getche
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_getche DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_07ODHHJIDJ@?3getche?$AA@
CONST	SEGMENT
??_C@_07ODHHJIDJ@?3getche?$AA@ DB ':getche', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_getche
_TEXT	SEGMENT
s$ = 32
ch$ = 36
_save$121207 = 40
self$ = 64
args$ = 72
msvcrt_getche PROC					; COMDAT

; 235  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 236  :     int ch;
; 237  :     char s[1];
; 238  : 
; 239  :     if (!PyArg_ParseTuple(args, ":getche"))

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07ODHHJIDJ@?3getche?$AA@
  00015	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001a	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001f	85 c0		 test	 eax, eax
  00021	75 04		 jne	 SHORT $LN1@msvcrt_get@4

; 240  :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 36		 jmp	 SHORT $LN2@msvcrt_get@4
$LN1@msvcrt_get@4:

; 241  : 
; 242  :     Py_BEGIN_ALLOW_THREADS

  00027	e8 00 00 00 00	 call	 PyEval_SaveThread
  0002c	48 89 44 24 28	 mov	 QWORD PTR _save$121207[rsp], rax

; 243  :     ch = _getche();

  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__getche
  00037	89 44 24 24	 mov	 DWORD PTR ch$[rsp], eax

; 244  :     Py_END_ALLOW_THREADS

  0003b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _save$121207[rsp]
  00040	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 245  :     s[0] = ch;

  00045	0f b6 44 24 24	 movzx	 eax, BYTE PTR ch$[rsp]
  0004a	88 44 24 20	 mov	 BYTE PTR s$[rsp], al

; 246  :     return PyBytes_FromStringAndSize(s, 1);

  0004e	ba 01 00 00 00	 mov	 edx, 1
  00053	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00058	e8 00 00 00 00	 call	 PyBytes_FromStringAndSize
$LN2@msvcrt_get@4:

; 247  : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
msvcrt_getche ENDP
_TEXT	ENDS
PUBLIC	??_C@_08NNFEFGC@?3getwche?$AA@			; `string'
EXTRN	__imp__getwche:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_getwche DD imagerel msvcrt_getwche
	DD	imagerel msvcrt_getwche+87
	DD	imagerel $unwind$msvcrt_getwche
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_getwche DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_08NNFEFGC@?3getwche?$AA@
CONST	SEGMENT
??_C@_08NNFEFGC@?3getwche?$AA@ DB ':getwche', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_getwche
_TEXT	SEGMENT
ch$ = 32
_save$121219 = 40
self$ = 64
args$ = 72
msvcrt_getwche PROC					; COMDAT

; 258  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 259  :     wchar_t ch;
; 260  : 
; 261  :     if (!PyArg_ParseTuple(args, ":getwche"))

  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08NNFEFGC@?3getwche?$AA@
  00015	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001a	e8 00 00 00 00	 call	 PyArg_ParseTuple
  0001f	85 c0		 test	 eax, eax
  00021	75 04		 jne	 SHORT $LN1@msvcrt_get@5

; 262  :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 2b		 jmp	 SHORT $LN2@msvcrt_get@5
$LN1@msvcrt_get@5:

; 263  : 
; 264  :     Py_BEGIN_ALLOW_THREADS

  00027	e8 00 00 00 00	 call	 PyEval_SaveThread
  0002c	48 89 44 24 28	 mov	 QWORD PTR _save$121219[rsp], rax

; 265  :     ch = _getwche();

  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__getwche
  00037	66 89 44 24 20	 mov	 WORD PTR ch$[rsp], ax

; 266  :     Py_END_ALLOW_THREADS

  0003c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _save$121219[rsp]
  00041	e8 00 00 00 00	 call	 PyEval_RestoreThread

; 267  :     return PyUnicode_FromOrdinal(ch);

  00046	0f b7 44 24 20	 movzx	 eax, WORD PTR ch$[rsp]
  0004b	8b c8		 mov	 ecx, eax
  0004d	e8 00 00 00 00	 call	 PyUnicode_FromOrdinal
$LN2@msvcrt_get@5:

; 268  : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
msvcrt_getwche ENDP
_TEXT	ENDS
PUBLIC	??_C@_07PBFCLMLB@c?3putch?$AA@			; `string'
EXTRN	__imp__putch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_putch DD imagerel msvcrt_putch
	DD	imagerel msvcrt_putch+81
	DD	imagerel $unwind$msvcrt_putch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_putch DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_07PBFCLMLB@c?3putch?$AA@
CONST	SEGMENT
??_C@_07PBFCLMLB@c?3putch?$AA@ DB 'c:putch', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_putch
_TEXT	SEGMENT
ch$ = 32
self$ = 64
args$ = 72
msvcrt_putch PROC					; COMDAT

; 278  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 279  :     char ch;
; 280  : 
; 281  :     if (!PyArg_ParseTuple(args, "c:putch", &ch))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR ch$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07PBFCLMLB@c?3putch?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN1@msvcrt_put

; 282  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 20		 jmp	 SHORT $LN2@msvcrt_put
$LN1@msvcrt_put:

; 283  : 
; 284  :     _putch(ch);

  0002c	0f be 44 24 20	 movsx	 eax, BYTE PTR ch$[rsp]
  00031	8b c8		 mov	 ecx, eax
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__putch

; 285  :     Py_INCREF(Py_None);

  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00040	e8 00 00 00 00	 call	 _Py_IncRef

; 286  :     return Py_None;

  00045	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@msvcrt_put:

; 287  : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
msvcrt_putch ENDP
_TEXT	ENDS
PUBLIC	??_C@_08EAGMJNID@C?3putwch?$AA@			; `string'
EXTRN	__imp__putwch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_putwch DD imagerel msvcrt_putwch
	DD	imagerel msvcrt_putwch+79
	DD	imagerel $unwind$msvcrt_putwch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_putwch DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_08EAGMJNID@C?3putwch?$AA@
CONST	SEGMENT
??_C@_08EAGMJNID@C?3putwch?$AA@ DB 'C:putwch', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_putwch
_TEXT	SEGMENT
ch$ = 32
self$ = 64
args$ = 72
msvcrt_putwch PROC					; COMDAT

; 297  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 298  :     int ch;
; 299  : 
; 300  :     if (!PyArg_ParseTuple(args, "C:putwch", &ch))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR ch$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08EAGMJNID@C?3putwch?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN1@msvcrt_put@2

; 301  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 1e		 jmp	 SHORT $LN2@msvcrt_put@2
$LN1@msvcrt_put@2:

; 302  : 
; 303  :     _putwch(ch);

  0002c	0f b7 4c 24 20	 movzx	 ecx, WORD PTR ch$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__putwch

; 304  :     Py_RETURN_NONE;

  00037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0003e	e8 00 00 00 00	 call	 _Py_IncRef
  00043	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@msvcrt_put@2:

; 305  : 
; 306  : }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
msvcrt_putwch ENDP
_TEXT	ENDS
PUBLIC	??_C@_09OFEIKODI@c?3ungetch?$AA@		; `string'
EXTRN	__imp__ungetch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_ungetch DD imagerel msvcrt_ungetch
	DD	imagerel msvcrt_ungetch+100
	DD	imagerel $unwind$msvcrt_ungetch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_ungetch DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_09OFEIKODI@c?3ungetch?$AA@
CONST	SEGMENT
??_C@_09OFEIKODI@c?3ungetch?$AA@ DB 'c:ungetch', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_ungetch
_TEXT	SEGMENT
ch$ = 32
self$ = 64
args$ = 72
msvcrt_ungetch PROC					; COMDAT

; 316  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 317  :     char ch;
; 318  : 
; 319  :     if (!PyArg_ParseTuple(args, "c:ungetch", &ch))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR ch$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09OFEIKODI@c?3ungetch?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@msvcrt_ung

; 320  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 33		 jmp	 SHORT $LN3@msvcrt_ung
$LN2@msvcrt_ung:

; 321  : 
; 322  :     if (_ungetch(ch) == EOF)

  0002c	0f be 44 24 20	 movsx	 eax, BYTE PTR ch$[rsp]
  00031	8b c8		 mov	 ecx, eax
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ungetch
  00039	83 f8 ff	 cmp	 eax, -1
  0003c	75 0e		 jne	 SHORT $LN1@msvcrt_ung

; 323  :         return PyErr_SetFromErrno(PyExc_IOError);

  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00045	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  0004a	eb 13		 jmp	 SHORT $LN3@msvcrt_ung
$LN1@msvcrt_ung:

; 324  :     Py_INCREF(Py_None);

  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00053	e8 00 00 00 00	 call	 _Py_IncRef

; 325  :     return Py_None;

  00058	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@msvcrt_ung:

; 326  : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
msvcrt_ungetch ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@NAHBLBGB@C?3ungetwch?$AA@		; `string'
EXTRN	__imp__ungetwch:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_ungetwch DD imagerel msvcrt_ungetwch
	DD	imagerel msvcrt_ungetwch+103
	DD	imagerel $unwind$msvcrt_ungetwch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_ungetwch DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_0L@NAHBLBGB@C?3ungetwch?$AA@
CONST	SEGMENT
??_C@_0L@NAHBLBGB@C?3ungetwch?$AA@ DB 'C:ungetwch', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_ungetwch
_TEXT	SEGMENT
ch$ = 32
self$ = 64
args$ = 72
msvcrt_ungetwch PROC					; COMDAT

; 338  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 339  :     int ch;
; 340  : 
; 341  :     if (!PyArg_ParseTuple(args, "C:ungetwch", &ch))

  0000e	4c 8d 44 24 20	 lea	 r8, QWORD PTR ch$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@NAHBLBGB@C?3ungetwch?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@msvcrt_ung@2

; 342  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 36		 jmp	 SHORT $LN3@msvcrt_ung@2
$LN2@msvcrt_ung@2:

; 343  : 
; 344  :     if (_ungetwch(ch) == WEOF)

  0002c	0f b7 4c 24 20	 movzx	 ecx, WORD PTR ch$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ungetwch
  00037	0f b7 c0	 movzx	 eax, ax
  0003a	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0003f	75 0e		 jne	 SHORT $LN1@msvcrt_ung@2

; 345  :         return PyErr_SetFromErrno(PyExc_IOError);

  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00048	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  0004d	eb 13		 jmp	 SHORT $LN3@msvcrt_ung@2
$LN1@msvcrt_ung@2:

; 346  :     Py_INCREF(Py_None);

  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  00056	e8 00 00 00 00	 call	 _Py_IncRef

; 347  :     return Py_None;

  0005b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN3@msvcrt_ung@2:

; 348  : }

  00062	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00066	c3		 ret	 0
msvcrt_ungetwch ENDP
_TEXT	ENDS
PUBLIC	??_C@_02PDIHAGKM@ii?$AA@			; `string'
EXTRN	__imp__CrtSetReportFile:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_setreportfile DD imagerel msvcrt_setreportfile
	DD	imagerel msvcrt_setreportfile+107
	DD	imagerel $unwind$msvcrt_setreportfile
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_setreportfile DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_02PDIHAGKM@ii?$AA@
CONST	SEGMENT
??_C@_02PDIHAGKM@ii?$AA@ DB 'ii', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_setreportfile
_TEXT	SEGMENT
res$ = 32
type$ = 40
file$ = 44
self$ = 64
args$ = 72
msvcrt_setreportfile PROC				; COMDAT

; 374  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 375  :     int type, file;
; 376  :     _HFILE res;
; 377  : 
; 378  :     if (!PyArg_ParseTuple(args, "ii", &type, &file))

  0000e	4c 8d 4c 24 2c	 lea	 r9, QWORD PTR file$[rsp]
  00013	4c 8d 44 24 28	 lea	 r8, QWORD PTR type$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PDIHAGKM@ii?$AA@
  0001f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN1@msvcrt_set@2

; 379  :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 35		 jmp	 SHORT $LN2@msvcrt_set@2
$LN1@msvcrt_set@2:

; 380  :     res = _CrtSetReportFile(type, (_HFILE)file);

  00031	48 63 44 24 2c	 movsxd	 rax, DWORD PTR file$[rsp]
  00036	48 8b d0	 mov	 rdx, rax
  00039	8b 4c 24 28	 mov	 ecx, DWORD PTR type$[rsp]
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtSetReportFile
  00043	48 89 44 24 20	 mov	 QWORD PTR res$[rsp], rax

; 381  :     return PyLong_FromLong((long)res);

  00048	8b 4c 24 20	 mov	 ecx, DWORD PTR res$[rsp]
  0004c	e8 00 00 00 00	 call	 PyLong_FromLong
  00051	eb 13		 jmp	 SHORT $LN2@msvcrt_set@2

; 382  :     Py_INCREF(Py_None);

  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:_Py_NoneStruct
  0005a	e8 00 00 00 00	 call	 _Py_IncRef

; 383  :     return Py_None;

  0005f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Py_NoneStruct
$LN2@msvcrt_set@2:

; 384  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
msvcrt_setreportfile ENDP
_TEXT	ENDS
EXTRN	__imp__CrtSetReportMode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_setreportmode DD imagerel msvcrt_setreportmode
	DD	imagerel msvcrt_setreportmode+102
	DD	imagerel $unwind$msvcrt_setreportmode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_setreportmode DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT msvcrt_setreportmode
_TEXT	SEGMENT
res$ = 32
mode$ = 36
type$ = 40
self$ = 64
args$ = 72
msvcrt_setreportmode PROC				; COMDAT

; 388  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 389  :     int type, mode;
; 390  :     int res;
; 391  : 
; 392  :     if (!PyArg_ParseTuple(args, "ii", &type, &mode))

  0000e	4c 8d 4c 24 24	 lea	 r9, QWORD PTR mode$[rsp]
  00013	4c 8d 44 24 28	 lea	 r8, QWORD PTR type$[rsp]
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02PDIHAGKM@ii?$AA@
  0001f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  00024	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00029	85 c0		 test	 eax, eax
  0002b	75 04		 jne	 SHORT $LN2@msvcrt_set@3

; 393  :         return NULL;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 30		 jmp	 SHORT $LN3@msvcrt_set@3
$LN2@msvcrt_set@3:

; 394  :     res = _CrtSetReportMode(type, mode);

  00031	8b 54 24 24	 mov	 edx, DWORD PTR mode$[rsp]
  00035	8b 4c 24 28	 mov	 ecx, DWORD PTR type$[rsp]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtSetReportMode
  0003f	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 395  :     if (res == -1)

  00043	83 7c 24 20 ff	 cmp	 DWORD PTR res$[rsp], -1
  00048	75 0e		 jne	 SHORT $LN1@msvcrt_set@3

; 396  :         return PyErr_SetFromErrno(PyExc_IOError);

  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR PyExc_IOError
  00051	e8 00 00 00 00	 call	 PyErr_SetFromErrno
  00056	eb 09		 jmp	 SHORT $LN3@msvcrt_set@3
$LN1@msvcrt_set@3:

; 397  :     return PyLong_FromLong(res);

  00058	8b 4c 24 20	 mov	 ecx, DWORD PTR res$[rsp]
  0005c	e8 00 00 00 00	 call	 PyLong_FromLong
$LN3@msvcrt_set@3:

; 398  : }

  00061	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00065	c3		 ret	 0
msvcrt_setreportmode ENDP
_TEXT	ENDS
PUBLIC	??_C@_01KBJDNOO@i?$AA@				; `string'
EXTRN	__imp__set_error_mode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$msvcrt_seterrormode DD imagerel msvcrt_seterrormode
	DD	imagerel msvcrt_seterrormode+72
	DD	imagerel $unwind$msvcrt_seterrormode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$msvcrt_seterrormode DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_01KBJDNOO@i?$AA@
CONST	SEGMENT
??_C@_01KBJDNOO@i?$AA@ DB 'i', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT msvcrt_seterrormode
_TEXT	SEGMENT
res$ = 32
mode$ = 36
self$ = 64
args$ = 72
msvcrt_seterrormode PROC				; COMDAT

; 402  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 403  :     int mode, res;
; 404  : 
; 405  :     if (!PyArg_ParseTuple(args, "i", &mode))

  0000e	4c 8d 44 24 24	 lea	 r8, QWORD PTR mode$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KBJDNOO@i?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN1@msvcrt_set@4

; 406  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 17		 jmp	 SHORT $LN2@msvcrt_set@4
$LN1@msvcrt_set@4:

; 407  :     res = _set_error_mode(mode);

  0002c	8b 4c 24 24	 mov	 ecx, DWORD PTR mode$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__set_error_mode
  00036	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 408  :     return PyLong_FromLong(res);

  0003a	8b 4c 24 20	 mov	 ecx, DWORD PTR res$[rsp]
  0003e	e8 00 00 00 00	 call	 PyLong_FromLong
$LN2@msvcrt_set@4:

; 409  : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
msvcrt_seterrormode ENDP
_TEXT	ENDS
PUBLIC	??_C@_01JPJNBJEM@I?$AA@				; `string'
EXTRN	PyLong_FromUnsignedLong:PROC
EXTRN	__imp_SetErrorMode:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$seterrormode DD imagerel seterrormode
	DD	imagerel seterrormode+72
	DD	imagerel $unwind$seterrormode
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$seterrormode DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT ??_C@_01JPJNBJEM@I?$AA@
CONST	SEGMENT
??_C@_01JPJNBJEM@I?$AA@ DB 'I', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT seterrormode
_TEXT	SEGMENT
res$ = 32
mode$ = 36
self$ = 64
args$ = 72
seterrormode PROC					; COMDAT

; 415  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 416  :     unsigned int mode, res;
; 417  : 
; 418  :     if (!PyArg_ParseTuple(args, "I", &mode))

  0000e	4c 8d 44 24 24	 lea	 r8, QWORD PTR mode$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01JPJNBJEM@I?$AA@
  0001a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR args$[rsp]
  0001f	e8 00 00 00 00	 call	 PyArg_ParseTuple
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN1@seterrormo

; 419  :         return NULL;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 17		 jmp	 SHORT $LN2@seterrormo
$LN1@seterrormo:

; 420  :     res = SetErrorMode(mode);

  0002c	8b 4c 24 24	 mov	 ecx, DWORD PTR mode$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetErrorMode
  00036	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 421  :     return PyLong_FromUnsignedLong(res);

  0003a	8b 4c 24 20	 mov	 ecx, DWORD PTR res$[rsp]
  0003e	e8 00 00 00 00	 call	 PyLong_FromUnsignedLong
$LN2@seterrormo:

; 422  : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
seterrormode ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BF@MAOGGMPB@CRT_ASSEMBLY_VERSION?$AA@	; `string'
PUBLIC	??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BD@MGPAMCGP@CRTDBG_REPORT_FILE?$AA@	; `string'
PUBLIC	??_C@_0BD@EAKIABBM@CRTDBG_FILE_STDOUT?$AA@	; `string'
PUBLIC	??_C@_0BD@HMAAFAHL@CRTDBG_FILE_STDERR?$AA@	; `string'
PUBLIC	??_C@_0BD@JKFIPNBK@CRTDBG_REPORT_MODE?$AA@	; `string'
PUBLIC	??_C@_0BB@GGLMJIE@CRTDBG_MODE_WNDW?$AA@		; `string'
PUBLIC	??_C@_0BB@LANLGOGE@CRTDBG_MODE_FILE?$AA@	; `string'
PUBLIC	??_C@_0BC@IBJGDPKE@CRTDBG_MODE_DEBUG?$AA@	; `string'
PUBLIC	??_C@_0L@MPHLONJG@CRT_ASSERT?$AA@		; `string'
PUBLIC	??_C@_09LOKEBDMO@CRT_ERROR?$AA@			; `string'
PUBLIC	??_C@_08GLPBODHI@CRT_WARN?$AA@			; `string'
PUBLIC	??_C@_0BH@JJFLKBIK@SEM_NOOPENFILEERRORBOX?$AA@	; `string'
PUBLIC	??_C@_0BG@CNOOOOCI@SEM_NOGPFAULTERRORBOX?$AA@	; `string'
PUBLIC	??_C@_0BL@GDBPKLFI@SEM_NOALIGNMENTFAULTEXCEPT?$AA@ ; `string'
PUBLIC	??_C@_0BH@OEFJJIGM@SEM_FAILCRITICALERRORS?$AA@	; `string'
PUBLIC	??_C@_08ILCJGBBJ@LK_UNLCK?$AA@			; `string'
PUBLIC	??_C@_07KNHLLCOM@LK_RLCK?$AA@			; `string'
PUBLIC	??_C@_09OMNGHHCN@LK_NBRLCK?$AA@			; `string'
PUBLIC	??_C@_08CHMIHOEA@LK_NBLCK?$AA@			; `string'
PUBLIC	??_C@_07GABODEOB@LK_LOCK?$AA@			; `string'
PUBLIC	PyInit_msvcrt
EXTRN	PyModule_AddObject:PROC
EXTRN	PyUnicode_FromFormat:PROC
EXTRN	PyModule_GetDict:PROC
EXTRN	PyModule_Create2TraceRefs:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyInit_msvcrt DD imagerel $LN5
	DD	imagerel $LN5+573
	DD	imagerel $unwind$PyInit_msvcrt
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyInit_msvcrt DD 010401H
	DD	0a204H
xdata	ENDS
;	COMDAT ??_C@_0BF@MAOGGMPB@CRT_ASSEMBLY_VERSION?$AA@
CONST	SEGMENT
??_C@_0BF@MAOGGMPB@CRT_ASSEMBLY_VERSION?$AA@ DB 'CRT_ASSEMBLY_VERSION', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ DB '%d.%d.%d.%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MGPAMCGP@CRTDBG_REPORT_FILE?$AA@
CONST	SEGMENT
??_C@_0BD@MGPAMCGP@CRTDBG_REPORT_FILE?$AA@ DB 'CRTDBG_REPORT_FILE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EAKIABBM@CRTDBG_FILE_STDOUT?$AA@
CONST	SEGMENT
??_C@_0BD@EAKIABBM@CRTDBG_FILE_STDOUT?$AA@ DB 'CRTDBG_FILE_STDOUT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HMAAFAHL@CRTDBG_FILE_STDERR?$AA@
CONST	SEGMENT
??_C@_0BD@HMAAFAHL@CRTDBG_FILE_STDERR?$AA@ DB 'CRTDBG_FILE_STDERR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JKFIPNBK@CRTDBG_REPORT_MODE?$AA@
CONST	SEGMENT
??_C@_0BD@JKFIPNBK@CRTDBG_REPORT_MODE?$AA@ DB 'CRTDBG_REPORT_MODE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GGLMJIE@CRTDBG_MODE_WNDW?$AA@
CONST	SEGMENT
??_C@_0BB@GGLMJIE@CRTDBG_MODE_WNDW?$AA@ DB 'CRTDBG_MODE_WNDW', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LANLGOGE@CRTDBG_MODE_FILE?$AA@
CONST	SEGMENT
??_C@_0BB@LANLGOGE@CRTDBG_MODE_FILE?$AA@ DB 'CRTDBG_MODE_FILE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IBJGDPKE@CRTDBG_MODE_DEBUG?$AA@
CONST	SEGMENT
??_C@_0BC@IBJGDPKE@CRTDBG_MODE_DEBUG?$AA@ DB 'CRTDBG_MODE_DEBUG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPHLONJG@CRT_ASSERT?$AA@
CONST	SEGMENT
??_C@_0L@MPHLONJG@CRT_ASSERT?$AA@ DB 'CRT_ASSERT', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LOKEBDMO@CRT_ERROR?$AA@
CONST	SEGMENT
??_C@_09LOKEBDMO@CRT_ERROR?$AA@ DB 'CRT_ERROR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08GLPBODHI@CRT_WARN?$AA@
CONST	SEGMENT
??_C@_08GLPBODHI@CRT_WARN?$AA@ DB 'CRT_WARN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@JJFLKBIK@SEM_NOOPENFILEERRORBOX?$AA@
CONST	SEGMENT
??_C@_0BH@JJFLKBIK@SEM_NOOPENFILEERRORBOX?$AA@ DB 'SEM_NOOPENFILEERRORBOX'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CNOOOOCI@SEM_NOGPFAULTERRORBOX?$AA@
CONST	SEGMENT
??_C@_0BG@CNOOOOCI@SEM_NOGPFAULTERRORBOX?$AA@ DB 'SEM_NOGPFAULTERRORBOX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@GDBPKLFI@SEM_NOALIGNMENTFAULTEXCEPT?$AA@
CONST	SEGMENT
??_C@_0BL@GDBPKLFI@SEM_NOALIGNMENTFAULTEXCEPT?$AA@ DB 'SEM_NOALIGNMENTFAU'
	DB	'LTEXCEPT', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@OEFJJIGM@SEM_FAILCRITICALERRORS?$AA@
CONST	SEGMENT
??_C@_0BH@OEFJJIGM@SEM_FAILCRITICALERRORS?$AA@ DB 'SEM_FAILCRITICALERRORS'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08ILCJGBBJ@LK_UNLCK?$AA@
CONST	SEGMENT
??_C@_08ILCJGBBJ@LK_UNLCK?$AA@ DB 'LK_UNLCK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07KNHLLCOM@LK_RLCK?$AA@
CONST	SEGMENT
??_C@_07KNHLLCOM@LK_RLCK?$AA@ DB 'LK_RLCK', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OMNGHHCN@LK_NBRLCK?$AA@
CONST	SEGMENT
??_C@_09OMNGHHCN@LK_NBRLCK?$AA@ DB 'LK_NBRLCK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CHMIHOEA@LK_NBLCK?$AA@
CONST	SEGMENT
??_C@_08CHMIHOEA@LK_NBLCK?$AA@ DB 'LK_NBLCK', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07GABODEOB@LK_LOCK?$AA@
CONST	SEGMENT
??_C@_07GABODEOB@LK_LOCK?$AA@ DB 'LK_LOCK', 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT PyInit_msvcrt
_TEXT	SEGMENT
st$ = 48
version$ = 56
d$ = 64
m$ = 72
PyInit_msvcrt PROC					; COMDAT

; 467  : {

$LN5:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 468  :     int st;
; 469  :     PyObject *d, *version;
; 470  :     PyObject *m = PyModule_Create(&msvcrtmodule);

  00004	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:msvcrtmodule
  00010	e8 00 00 00 00	 call	 PyModule_Create2TraceRefs
  00015	48 89 44 24 48	 mov	 QWORD PTR m$[rsp], rax

; 471  :     if (m == NULL)

  0001a	48 83 7c 24 48
	00		 cmp	 QWORD PTR m$[rsp], 0
  00020	75 07		 jne	 SHORT $LN2@PyInit_msv

; 472  :         return NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 0f 02 00 00	 jmp	 $LN3@PyInit_msv
$LN2@PyInit_msv:

; 473  :     d = PyModule_GetDict(m);

  00029	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  0002e	e8 00 00 00 00	 call	 PyModule_GetDict
  00033	48 89 44 24 40	 mov	 QWORD PTR d$[rsp], rax

; 474  : 
; 475  :     /* constants for the locking() function's mode argument */
; 476  :     insertint(d, "LK_LOCK", _LK_LOCK);

  00038	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07GABODEOB@LK_LOCK?$AA@
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  0004a	e8 00 00 00 00	 call	 insertint

; 477  :     insertint(d, "LK_NBLCK", _LK_NBLCK);

  0004f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08CHMIHOEA@LK_NBLCK?$AA@
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  00061	e8 00 00 00 00	 call	 insertint

; 478  :     insertint(d, "LK_NBRLCK", _LK_NBRLCK);

  00066	41 b8 04 00 00
	00		 mov	 r8d, 4
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09OMNGHHCN@LK_NBRLCK?$AA@
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  00078	e8 00 00 00 00	 call	 insertint

; 479  :     insertint(d, "LK_RLCK", _LK_RLCK);

  0007d	41 b8 03 00 00
	00		 mov	 r8d, 3
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KNHLLCOM@LK_RLCK?$AA@
  0008a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  0008f	e8 00 00 00 00	 call	 insertint

; 480  :     insertint(d, "LK_UNLCK", _LK_UNLCK);

  00094	45 33 c0	 xor	 r8d, r8d
  00097	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08ILCJGBBJ@LK_UNLCK?$AA@
  0009e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  000a3	e8 00 00 00 00	 call	 insertint

; 481  :     insertint(d, "SEM_FAILCRITICALERRORS", SEM_FAILCRITICALERRORS);

  000a8	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@OEFJJIGM@SEM_FAILCRITICALERRORS?$AA@
  000b5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  000ba	e8 00 00 00 00	 call	 insertint

; 482  :     insertint(d, "SEM_NOALIGNMENTFAULTEXCEPT", SEM_NOALIGNMENTFAULTEXCEPT);

  000bf	41 b8 04 00 00
	00		 mov	 r8d, 4
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@GDBPKLFI@SEM_NOALIGNMENTFAULTEXCEPT?$AA@
  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  000d1	e8 00 00 00 00	 call	 insertint

; 483  :     insertint(d, "SEM_NOGPFAULTERRORBOX", SEM_NOGPFAULTERRORBOX);

  000d6	41 b8 02 00 00
	00		 mov	 r8d, 2
  000dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@CNOOOOCI@SEM_NOGPFAULTERRORBOX?$AA@
  000e3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  000e8	e8 00 00 00 00	 call	 insertint

; 484  :     insertint(d, "SEM_NOOPENFILEERRORBOX", SEM_NOOPENFILEERRORBOX);

  000ed	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@JJFLKBIK@SEM_NOOPENFILEERRORBOX?$AA@
  000fa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  000ff	e8 00 00 00 00	 call	 insertint

; 485  : #ifdef _DEBUG
; 486  :     insertint(d, "CRT_WARN", _CRT_WARN);

  00104	45 33 c0	 xor	 r8d, r8d
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08GLPBODHI@CRT_WARN?$AA@
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  00113	e8 00 00 00 00	 call	 insertint

; 487  :     insertint(d, "CRT_ERROR", _CRT_ERROR);

  00118	41 b8 01 00 00
	00		 mov	 r8d, 1
  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LOKEBDMO@CRT_ERROR?$AA@
  00125	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  0012a	e8 00 00 00 00	 call	 insertint

; 488  :     insertint(d, "CRT_ASSERT", _CRT_ASSERT);

  0012f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@MPHLONJG@CRT_ASSERT?$AA@
  0013c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  00141	e8 00 00 00 00	 call	 insertint

; 489  :     insertint(d, "CRTDBG_MODE_DEBUG", _CRTDBG_MODE_DEBUG);

  00146	41 b8 02 00 00
	00		 mov	 r8d, 2
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@IBJGDPKE@CRTDBG_MODE_DEBUG?$AA@
  00153	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  00158	e8 00 00 00 00	 call	 insertint

; 490  :     insertint(d, "CRTDBG_MODE_FILE", _CRTDBG_MODE_FILE);

  0015d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@LANLGOGE@CRTDBG_MODE_FILE?$AA@
  0016a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  0016f	e8 00 00 00 00	 call	 insertint

; 491  :     insertint(d, "CRTDBG_MODE_WNDW", _CRTDBG_MODE_WNDW);

  00174	41 b8 04 00 00
	00		 mov	 r8d, 4
  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@GGLMJIE@CRTDBG_MODE_WNDW?$AA@
  00181	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  00186	e8 00 00 00 00	 call	 insertint

; 492  :     insertint(d, "CRTDBG_REPORT_MODE", _CRTDBG_REPORT_MODE);

  0018b	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00191	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@JKFIPNBK@CRTDBG_REPORT_MODE?$AA@
  00198	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  0019d	e8 00 00 00 00	 call	 insertint

; 493  :     insertint(d, "CRTDBG_FILE_STDERR", (int)_CRTDBG_FILE_STDERR);

  001a2	41 b8 fb ff ff
	ff		 mov	 r8d, -5
  001a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@HMAAFAHL@CRTDBG_FILE_STDERR?$AA@
  001af	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  001b4	e8 00 00 00 00	 call	 insertint

; 494  :     insertint(d, "CRTDBG_FILE_STDOUT", (int)_CRTDBG_FILE_STDOUT);

  001b9	41 b8 fc ff ff
	ff		 mov	 r8d, -4
  001bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@EAKIABBM@CRTDBG_FILE_STDOUT?$AA@
  001c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  001cb	e8 00 00 00 00	 call	 insertint

; 495  :     insertint(d, "CRTDBG_REPORT_FILE", (int)_CRTDBG_REPORT_FILE);

  001d0	41 b8 fa ff ff
	ff		 mov	 r8d, -6
  001d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@MGPAMCGP@CRTDBG_REPORT_FILE?$AA@
  001dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  001e2	e8 00 00 00 00	 call	 insertint

; 496  : #endif
; 497  : 
; 498  :     /* constants for the crt versions */
; 499  :     (void)st;
; 500  : #ifdef _VC_ASSEMBLY_PUBLICKEYTOKEN
; 501  :     st = PyModule_AddStringConstant(m, "VC_ASSEMBLY_PUBLICKEYTOKEN",
; 502  :                                     _VC_ASSEMBLY_PUBLICKEYTOKEN);
; 503  :     if (st < 0) return NULL;
; 504  : #endif
; 505  : #ifdef _CRT_ASSEMBLY_VERSION
; 506  :     st = PyModule_AddStringConstant(m, "CRT_ASSEMBLY_VERSION",
; 507  :                                     _CRT_ASSEMBLY_VERSION);
; 508  :     if (st < 0) return NULL;
; 509  : #endif
; 510  : #ifdef __LIBRARIES_ASSEMBLY_NAME_PREFIX
; 511  :     st = PyModule_AddStringConstant(m, "LIBRARIES_ASSEMBLY_NAME_PREFIX",
; 512  :                                     __LIBRARIES_ASSEMBLY_NAME_PREFIX);
; 513  :     if (st < 0) return NULL;
; 514  : #endif
; 515  : 
; 516  :     /* constants for the 2010 crt versions */
; 517  : #if defined(_VC_CRT_MAJOR_VERSION) && defined (_VC_CRT_MINOR_VERSION) && defined(_VC_CRT_BUILD_VERSION) && defined(_VC_CRT_RBUILD_VERSION)
; 518  :     version = PyUnicode_FromFormat("%d.%d.%d.%d", _VC_CRT_MAJOR_VERSION,
; 519  :                                                   _VC_CRT_MINOR_VERSION,
; 520  :                                                   _VC_CRT_BUILD_VERSION,
; 521  :                                                   _VC_CRT_RBUILD_VERSION);

  001e7	c7 44 24 20 cc
	01 00 00	 mov	 DWORD PTR [rsp+32], 460	; 000001ccH
  001ef	41 b9 6f 76 00
	00		 mov	 r9d, 30319		; 0000766fH
  001f5	45 33 c0	 xor	 r8d, r8d
  001f8	ba 0a 00 00 00	 mov	 edx, 10
  001fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
  00204	e8 00 00 00 00	 call	 PyUnicode_FromFormat
  00209	48 89 44 24 38	 mov	 QWORD PTR version$[rsp], rax

; 522  :     st = PyModule_AddObject(m, "CRT_ASSEMBLY_VERSION", version);

  0020e	4c 8b 44 24 38	 mov	 r8, QWORD PTR version$[rsp]
  00213	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@MAOGGMPB@CRT_ASSEMBLY_VERSION?$AA@
  0021a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR m$[rsp]
  0021f	e8 00 00 00 00	 call	 PyModule_AddObject
  00224	89 44 24 30	 mov	 DWORD PTR st$[rsp], eax

; 523  :     if (st < 0) return NULL;

  00228	83 7c 24 30 00	 cmp	 DWORD PTR st$[rsp], 0
  0022d	7d 04		 jge	 SHORT $LN1@PyInit_msv
  0022f	33 c0		 xor	 eax, eax
  00231	eb 05		 jmp	 SHORT $LN3@PyInit_msv
$LN1@PyInit_msv:

; 524  : #endif
; 525  : 
; 526  :     return m;

  00233	48 8b 44 24 48	 mov	 rax, QWORD PTR m$[rsp]
$LN3@PyInit_msv:

; 527  : }

  00238	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0023c	c3		 ret	 0
PyInit_msvcrt ENDP
_TEXT	ENDS
PUBLIC	_Py_DecRef
EXTRN	PyDict_SetItemString:PROC
EXTRN	PyErr_Clear:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$insertint DD imagerel insertint
	DD	imagerel insertint+83
	DD	imagerel $unwind$insertint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insertint DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT insertint
_TEXT	SEGMENT
v$ = 32
d$ = 64
name$ = 72
value$ = 80
insertint PROC						; COMDAT

; 358  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 359  :     PyObject *v = PyLong_FromLong((long) value);

  00013	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  00017	e8 00 00 00 00	 call	 PyLong_FromLong
  0001c	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 360  :     if (v == NULL) {

  00021	48 83 7c 24 20
	00		 cmp	 QWORD PTR v$[rsp], 0
  00027	75 07		 jne	 SHORT $LN2@insertint

; 361  :         /* Don't bother reporting this error */
; 362  :         PyErr_Clear();

  00029	e8 00 00 00 00	 call	 PyErr_Clear

; 363  :     }
; 364  :     else {

  0002e	eb 1e		 jmp	 SHORT $LN1@insertint
$LN2@insertint:

; 365  :         PyDict_SetItemString(d, name, v);

  00030	4c 8b 44 24 20	 mov	 r8, QWORD PTR v$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR d$[rsp]
  0003f	e8 00 00 00 00	 call	 PyDict_SetItemString

; 366  :         Py_DECREF(v);

  00044	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00049	e8 00 00 00 00	 call	 _Py_DecRef
$LN1@insertint:

; 367  :     }
; 368  : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
insertint ENDP
_TEXT	ENDS
PUBLIC	??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@		; `string'
EXTRN	_Py_Dealloc:PROC
EXTRN	_Py_NegativeRefcount:PROC
EXTRN	Px_DecRef:PROC
;	COMDAT pdata
; File c:\src\pyparallel\include\object.h
pdata	SEGMENT
$pdata$_Py_DecRef DD imagerel $LN13
	DD	imagerel $LN13+257
	DD	imagerel $unwind$_Py_DecRef
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_Py_DecRef DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT ??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
CONST	SEGMENT
??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@ DB '_Py_DecRef', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT _Py_DecRef
_TEXT	SEGMENT
tv81 = 48
op$ = 80
_Py_DecRef PROC						; COMDAT

; 923  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 924  :     if (!Py_PXCTX) {

  00009	e8 00 00 00 00	 call	 _Py_PXCTX
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 e6 00 00
	00		 jne	 $LN8@Py_DecRef

; 925  :         if (Px_PERSISTED(op) || Px_CLONED(op))

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0001b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0001f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00023	48 85 c0	 test	 rax, rax
  00026	75 14		 jne	 SHORT $LN6@Py_DecRef
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  0002d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00031	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00037	48 85 c0	 test	 rax, rax
  0003a	74 0f		 je	 SHORT $LN7@Py_DecRef
$LN6@Py_DecRef:

; 926  :             Px_DECREF(op);

  0003c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  00041	e8 00 00 00 00	 call	 Px_DecRef
  00046	e9 b1 00 00 00	 jmp	 $LN5@Py_DecRef
$LN7@Py_DecRef:

; 927  :         else if (!Px_ISPX(op)) {

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00050	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00054	48 83 e0 02	 and	 rax, 2
  00058	48 85 c0	 test	 rax, rax
  0005b	0f 85 9b 00 00
	00		 jne	 $LN4@Py_DecRef

; 928  :             _Py_DEC_REFTOTAL;

  00061	e8 00 00 00 00	 call	 _Py_PXCTX
  00066	85 c0		 test	 eax, eax
  00068	74 02		 je	 SHORT $LN11@Py_DecRef
  0006a	eb 11		 jmp	 SHORT $LN12@Py_DecRef
$LN11@Py_DecRef:
  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR _Py_RefTotal
  00073	48 ff c8	 dec	 rax
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR _Py_RefTotal, rax
$LN12@Py_DecRef:

; 929  :             if ((--((PyObject *)(op))->ob_refcnt) != 0) {

  0007d	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00082	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00086	48 ff c8	 dec	 rax
  00089	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00098	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
  0009c	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv81[rsp], 0
  000a2	74 4e		 je	 SHORT $LN3@Py_DecRef

; 930  :                 _Py_CHECK_REFCNT(op);

  000a4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  000ac	4c 8b 4c 24 50	 mov	 r9, QWORD PTR op$[rsp]
  000b1	41 b8 a2 03 00
	00		 mov	 r8d, 930		; 000003a2H
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DMHMLFIA@_Py_DecRef?$AA@
  000c5	e8 00 00 00 00	 call	 _PyParallel_Guard
  000ca	85 c0		 test	 eax, eax
  000cc	75 22		 jne	 SHORT $LN2@Py_DecRef
  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR op$[rsp]
  000d3	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d8	7d 16		 jge	 SHORT $LN2@Py_DecRef
  000da	4c 8b 44 24 50	 mov	 r8, QWORD PTR op$[rsp]
  000df	ba a2 03 00 00	 mov	 edx, 930		; 000003a2H
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@HDJFDCDP@c?3?2src?2pyparallel?2include?2object@
  000eb	e8 00 00 00 00	 call	 _Py_NegativeRefcount
$LN2@Py_DecRef:

; 931  :             } else

  000f0	eb 0a		 jmp	 SHORT $LN1@Py_DecRef
$LN3@Py_DecRef:

; 932  :                 _Py_Dealloc((PyObject *)(op));

  000f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op$[rsp]
  000f7	e8 00 00 00 00	 call	 _Py_Dealloc
$LN1@Py_DecRef:
$LN4@Py_DecRef:
$LN5@Py_DecRef:
$LN8@Py_DecRef:

; 933  :         }
; 934  :     }
; 935  : }

  000fc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00100	c3		 ret	 0
_Py_DecRef ENDP
_TEXT	ENDS
END
