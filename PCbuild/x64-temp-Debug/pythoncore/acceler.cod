; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	PyGrammar_AddAccelerators
;	COMDAT pdata
; File c:\src\pyparallel\parser\acceler.c
pdata	SEGMENT
$pdata$PyGrammar_AddAccelerators DD imagerel $LN6
	DD	imagerel $LN6+101
	DD	imagerel $unwind$PyGrammar_AddAccelerators
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyGrammar_AddAccelerators DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyGrammar_AddAccelerators
_TEXT	SEGMENT
i$ = 32
d$ = 40
g$ = 64
PyGrammar_AddAccelerators PROC				; COMDAT

; 25   : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 26   :     dfa *d;
; 27   :     int i;
; 28   :     d = g->g_dfa;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  0000e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00012	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax

; 29   :     for (i = g->g_ndfas; --i >= 0; d++)

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  0001c	8b 00		 mov	 eax, DWORD PTR [rax]
  0001e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00022	eb 0e		 jmp	 SHORT $LN3@PyGrammar_
$LN2@PyGrammar_:
  00024	48 8b 44 24 28	 mov	 rax, QWORD PTR d$[rsp]
  00029	48 83 c0 28	 add	 rax, 40			; 00000028H
  0002d	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax
$LN3@PyGrammar_:
  00032	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00036	ff c8		 dec	 eax
  00038	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0003c	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00041	7c 11		 jl	 SHORT $LN1@PyGrammar_

; 30   :         fixdfa(g, d);

  00043	48 8b 54 24 28	 mov	 rdx, QWORD PTR d$[rsp]
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$[rsp]
  0004d	e8 00 00 00 00	 call	 fixdfa
  00052	eb d0		 jmp	 SHORT $LN2@PyGrammar_
$LN1@PyGrammar_:

; 31   :     g->g_accel = 1;

  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00059	c7 40 24 01 00
	00 00		 mov	 DWORD PTR [rax+36], 1

; 32   : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
PyGrammar_AddAccelerators ENDP
_TEXT	ENDS
PUBLIC	PyGrammar_RemoveAccelerators
EXTRN	_PyObject_DebugFree:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$PyGrammar_RemoveAccelerators DD imagerel $LN10
	DD	imagerel $LN10+192
	DD	imagerel $unwind$PyGrammar_RemoveAccelerators
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$PyGrammar_RemoveAccelerators DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT PyGrammar_RemoveAccelerators
_TEXT	SEGMENT
i$ = 32
d$ = 40
s$20625 = 48
j$20626 = 56
g$ = 80
PyGrammar_RemoveAccelerators PROC			; COMDAT

; 36   : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 37   :     dfa *d;
; 38   :     int i;
; 39   :     g->g_accel = 0;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  0000e	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0

; 40   :     d = g->g_dfa;

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  0001a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001e	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax

; 41   :     for (i = g->g_ndfas; --i >= 0; d++) {

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00028	8b 00		 mov	 eax, DWORD PTR [rax]
  0002a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0002e	eb 0e		 jmp	 SHORT $LN7@PyGrammar_@2
$LN6@PyGrammar_@2:
  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR d$[rsp]
  00035	48 83 c0 28	 add	 rax, 40			; 00000028H
  00039	48 89 44 24 28	 mov	 QWORD PTR d$[rsp], rax
$LN7@PyGrammar_@2:
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00042	ff c8		 dec	 eax
  00044	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00048	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0004d	7c 6c		 jl	 SHORT $LN5@PyGrammar_@2

; 42   :         state *s;
; 43   :         int j;
; 44   :         s = d->d_state;

  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR d$[rsp]
  00054	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00058	48 89 44 24 30	 mov	 QWORD PTR s$20625[rsp], rax

; 45   :         for (j = 0; j < d->d_nstates; j++, s++) {

  0005d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$20626[rsp], 0
  00065	eb 18		 jmp	 SHORT $LN4@PyGrammar_@2
$LN3@PyGrammar_@2:
  00067	8b 44 24 38	 mov	 eax, DWORD PTR j$20626[rsp]
  0006b	ff c0		 inc	 eax
  0006d	89 44 24 38	 mov	 DWORD PTR j$20626[rsp], eax
  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR s$20625[rsp]
  00076	48 83 c0 28	 add	 rax, 40			; 00000028H
  0007a	48 89 44 24 30	 mov	 QWORD PTR s$20625[rsp], rax
$LN4@PyGrammar_@2:
  0007f	48 8b 44 24 28	 mov	 rax, QWORD PTR d$[rsp]
  00084	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00087	39 44 24 38	 cmp	 DWORD PTR j$20626[rsp], eax
  0008b	7d 29		 jge	 SHORT $LN2@PyGrammar_@2

; 46   :             if (s->s_accel)

  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR s$20625[rsp]
  00092	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00097	74 0e		 je	 SHORT $LN1@PyGrammar_@2

; 47   :                 PyObject_FREE(s->s_accel);

  00099	48 8b 44 24 30	 mov	 rax, QWORD PTR s$20625[rsp]
  0009e	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000a2	e8 00 00 00 00	 call	 _PyObject_DebugFree
$LN1@PyGrammar_@2:

; 48   :             s->s_accel = NULL;

  000a7	48 8b 44 24 30	 mov	 rax, QWORD PTR s$20625[rsp]
  000ac	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 49   :         }

  000b4	eb b1		 jmp	 SHORT $LN3@PyGrammar_@2
$LN2@PyGrammar_@2:

; 50   :     }

  000b6	e9 75 ff ff ff	 jmp	 $LN6@PyGrammar_@2
$LN5@PyGrammar_@2:

; 51   : }

  000bb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bf	c3		 ret	 0
PyGrammar_RemoveAccelerators ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fixdfa DD imagerel fixdfa
	DD	imagerel fixdfa+98
	DD	imagerel $unwind$fixdfa
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fixdfa DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fixdfa
_TEXT	SEGMENT
s$ = 32
j$ = 40
g$ = 64
d$ = 72
fixdfa	PROC						; COMDAT

; 55   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 56   :     state *s;
; 57   :     int j;
; 58   :     s = d->d_state;

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR d$[rsp]
  00013	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00017	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 59   :     for (j = 0; j < d->d_nstates; j++, s++)

  0001c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00024	eb 18		 jmp	 SHORT $LN3@fixdfa
$LN2@fixdfa:
  00026	8b 44 24 28	 mov	 eax, DWORD PTR j$[rsp]
  0002a	ff c0		 inc	 eax
  0002c	89 44 24 28	 mov	 DWORD PTR j$[rsp], eax
  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00035	48 83 c0 28	 add	 rax, 40			; 00000028H
  00039	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
$LN3@fixdfa:
  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR d$[rsp]
  00043	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00046	39 44 24 28	 cmp	 DWORD PTR j$[rsp], eax
  0004a	7d 11		 jge	 SHORT $LN1@fixdfa

; 60   :         fixstate(g, s);

  0004c	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR g$[rsp]
  00056	e8 00 00 00 00	 call	 fixstate
  0005b	eb c9		 jmp	 SHORT $LN2@fixdfa
$LN1@fixdfa:

; 61   : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
fixdfa	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@JMEPLMEJ@no?5mem?5to?5add?5parser?5accelerator@ ; `string'
PUBLIC	??_C@_0BA@NBNHCIHI@XXX?5ambiguity?$CB?6?$AA@	; `string'
PUBLIC	??_C@_0CC@MJKIBOFA@XXX?5too?5high?5nonterminal?5number?$CB@ ; `string'
PUBLIC	??_C@_0BG@GFBOHICG@XXX?5too?5many?5states?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@FLCIMHMA@no?5mem?5to?5build?5parser?5accelerat@ ; `string'
EXTRN	PyGrammar_FindDFA:PROC
EXTRN	__imp_printf:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	_PyObject_DebugMalloc:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fixstate DD imagerel fixstate
	DD	imagerel fixstate+956
	DD	imagerel $unwind$fixstate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fixstate DD 010e01H
	DD	0e20eH
xdata	ENDS
;	COMDAT ??_C@_0CD@JMEPLMEJ@no?5mem?5to?5add?5parser?5accelerator@
CONST	SEGMENT
??_C@_0CD@JMEPLMEJ@no?5mem?5to?5add?5parser?5accelerator@ DB 'no mem to a'
	DB	'dd parser accelerators', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@NBNHCIHI@XXX?5ambiguity?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BA@NBNHCIHI@XXX?5ambiguity?$CB?6?$AA@ DB 'XXX ambiguity!', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@MJKIBOFA@XXX?5too?5high?5nonterminal?5number?$CB@
CONST	SEGMENT
??_C@_0CC@MJKIBOFA@XXX?5too?5high?5nonterminal?5number?$CB@ DB 'XXX too h'
	DB	'igh nonterminal number!', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GFBOHICG@XXX?5too?5many?5states?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BG@GFBOHICG@XXX?5too?5many?5states?$CB?6?$AA@ DB 'XXX too many sta'
	DB	'tes!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@FLCIMHMA@no?5mem?5to?5build?5parser?5accelerat@
CONST	SEGMENT
??_C@_0CF@FLCIMHMA@no?5mem?5to?5build?5parser?5accelerat@ DB 'no mem to b'
	DB	'uild parser accelerators', 0aH, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT fixstate
_TEXT	SEGMENT
accel$ = 32
a$ = 40
nl$ = 48
k$ = 52
type$20664 = 56
lbl$20662 = 60
l$20663 = 64
ibit$20669 = 72
d1$20668 = 80
i$20691 = 88
tv140 = 92
tv253 = 96
g$ = 128
s$ = 136
fixstate PROC						; COMDAT

; 65   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 66   :     arc *a;
; 67   :     int k;
; 68   :     int *accel;
; 69   :     int nl = g->g_ll.ll_nlabels;

  0000e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00016	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00019	89 44 24 30	 mov	 DWORD PTR nl$[rsp], eax

; 70   :     s->s_accept = 0;

  0001d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00025	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 71   :     accel = (int *) PyObject_MALLOC(nl * sizeof(int));

  0002c	48 63 44 24 30	 movsxd	 rax, DWORD PTR nl$[rsp]
  00031	48 c1 e0 02	 shl	 rax, 2
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  0003d	48 89 44 24 20	 mov	 QWORD PTR accel$[rsp], rax

; 72   :     if (accel == NULL) {

  00042	48 83 7c 24 20
	00		 cmp	 QWORD PTR accel$[rsp], 0
  00048	75 25		 jne	 SHORT $LN28@fixstate

; 73   :         fprintf(stderr, "no mem to build parser accelerators\n");

  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00050	48 83 c0 60	 add	 rax, 96			; 00000060H
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@FLCIMHMA@no?5mem?5to?5build?5parser?5accelerat@
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 74   :         exit(1);

  00064	b9 01 00 00 00	 mov	 ecx, 1
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN28@fixstate:

; 75   :     }
; 76   :     for (k = 0; k < nl; k++)

  0006f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00077	eb 0a		 jmp	 SHORT $LN27@fixstate
$LN26@fixstate:
  00079	8b 44 24 34	 mov	 eax, DWORD PTR k$[rsp]
  0007d	ff c0		 inc	 eax
  0007f	89 44 24 34	 mov	 DWORD PTR k$[rsp], eax
$LN27@fixstate:
  00083	8b 44 24 30	 mov	 eax, DWORD PTR nl$[rsp]
  00087	39 44 24 34	 cmp	 DWORD PTR k$[rsp], eax
  0008b	7d 13		 jge	 SHORT $LN25@fixstate

; 77   :         accel[k] = -1;

  0008d	48 63 44 24 34	 movsxd	 rax, DWORD PTR k$[rsp]
  00092	48 8b 4c 24 20	 mov	 rcx, QWORD PTR accel$[rsp]
  00097	c7 04 81 ff ff
	ff ff		 mov	 DWORD PTR [rcx+rax*4], -1
  0009e	eb d9		 jmp	 SHORT $LN26@fixstate
$LN25@fixstate:

; 78   :     a = s->s_arc;

  000a0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000a8	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000ac	48 89 44 24 28	 mov	 QWORD PTR a$[rsp], rax

; 79   :     for (k = s->s_narcs; --k >= 0; a++) {

  000b1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000b9	8b 00		 mov	 eax, DWORD PTR [rax]
  000bb	89 44 24 34	 mov	 DWORD PTR k$[rsp], eax
  000bf	eb 0e		 jmp	 SHORT $LN24@fixstate
$LN23@fixstate:
  000c1	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  000c6	48 83 c0 04	 add	 rax, 4
  000ca	48 89 44 24 28	 mov	 QWORD PTR a$[rsp], rax
$LN24@fixstate:
  000cf	8b 44 24 34	 mov	 eax, DWORD PTR k$[rsp]
  000d3	ff c8		 dec	 eax
  000d5	89 44 24 34	 mov	 DWORD PTR k$[rsp], eax
  000d9	83 7c 24 34 00	 cmp	 DWORD PTR k$[rsp], 0
  000de	0f 8c a3 01 00
	00		 jl	 $LN22@fixstate

; 80   :         int lbl = a->a_lbl;

  000e4	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  000e9	0f bf 00	 movsx	 eax, WORD PTR [rax]
  000ec	89 44 24 3c	 mov	 DWORD PTR lbl$20662[rsp], eax

; 81   :         label *l = &g->g_ll.ll_label[lbl];

  000f0	48 63 44 24 3c	 movsxd	 rax, DWORD PTR lbl$20662[rsp]
  000f5	48 6b c0 10	 imul	 rax, 16
  000f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00101	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00105	48 89 44 24 40	 mov	 QWORD PTR l$20663[rsp], rax

; 82   :         int type = l->lb_type;

  0010a	48 8b 44 24 40	 mov	 rax, QWORD PTR l$20663[rsp]
  0010f	8b 00		 mov	 eax, DWORD PTR [rax]
  00111	89 44 24 38	 mov	 DWORD PTR type$20664[rsp], eax

; 83   :         if (a->a_arrow >= (1 << 7)) {

  00115	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  0011a	0f bf 40 02	 movsx	 eax, WORD PTR [rax+2]
  0011e	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00123	7c 0f		 jl	 SHORT $LN21@fixstate

; 84   :             printf("XXX too many states!\n");

  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BG@GFBOHICG@XXX?5too?5many?5states?$CB?6?$AA@
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 85   :             continue;

  00132	eb 8d		 jmp	 SHORT $LN23@fixstate
$LN21@fixstate:

; 86   :         }
; 87   :         if (ISNONTERMINAL(type)) {

  00134	81 7c 24 38 00
	01 00 00	 cmp	 DWORD PTR type$20664[rsp], 256 ; 00000100H
  0013c	0f 8c 01 01 00
	00		 jl	 $LN20@fixstate

; 88   :             dfa *d1 = PyGrammar_FindDFA(g, type);

  00142	8b 54 24 38	 mov	 edx, DWORD PTR type$20664[rsp]
  00146	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0014e	e8 00 00 00 00	 call	 PyGrammar_FindDFA
  00153	48 89 44 24 50	 mov	 QWORD PTR d1$20668[rsp], rax

; 89   :             int ibit;
; 90   :             if (type - NT_OFFSET >= (1 << 7)) {

  00158	8b 44 24 38	 mov	 eax, DWORD PTR type$20664[rsp]
  0015c	2d 00 01 00 00	 sub	 eax, 256		; 00000100H
  00161	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00166	7c 12		 jl	 SHORT $LN19@fixstate

; 91   :                 printf("XXX too high nonterminal number!\n");

  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@MJKIBOFA@XXX?5too?5high?5nonterminal?5number?$CB@
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 92   :                 continue;

  00175	e9 47 ff ff ff	 jmp	 $LN23@fixstate
$LN19@fixstate:

; 93   :             }
; 94   :             for (ibit = 0; ibit < g->g_ll.ll_nlabels; ibit++) {

  0017a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR ibit$20669[rsp], 0
  00182	eb 0a		 jmp	 SHORT $LN18@fixstate
$LN17@fixstate:
  00184	8b 44 24 48	 mov	 eax, DWORD PTR ibit$20669[rsp]
  00188	ff c0		 inc	 eax
  0018a	89 44 24 48	 mov	 DWORD PTR ibit$20669[rsp], eax
$LN18@fixstate:
  0018e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00196	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00199	39 44 24 48	 cmp	 DWORD PTR ibit$20669[rsp], eax
  0019d	0f 8d 9e 00 00
	00		 jge	 $LN16@fixstate

; 95   :                 if (testbit(d1->d_first, ibit)) {

  001a3	48 63 44 24 48	 movsxd	 rax, DWORD PTR ibit$20669[rsp]
  001a8	33 d2		 xor	 edx, edx
  001aa	b9 08 00 00 00	 mov	 ecx, 8
  001af	48 f7 f1	 div	 rcx
  001b2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR d1$20668[rsp]
  001b7	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  001bb	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  001bf	89 44 24 5c	 mov	 DWORD PTR tv140[rsp], eax
  001c3	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR ibit$20669[rsp]
  001c8	33 d2		 xor	 edx, edx
  001ca	48 8b c1	 mov	 rax, rcx
  001cd	b9 08 00 00 00	 mov	 ecx, 8
  001d2	48 f7 f1	 div	 rcx
  001d5	48 8b c2	 mov	 rax, rdx
  001d8	b9 01 00 00 00	 mov	 ecx, 1
  001dd	89 4c 24 60	 mov	 DWORD PTR tv253[rsp], ecx
  001e1	0f b6 c8	 movzx	 ecx, al
  001e4	8b 44 24 60	 mov	 eax, DWORD PTR tv253[rsp]
  001e8	d3 e0		 shl	 eax, cl
  001ea	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv140[rsp]
  001ee	23 c8		 and	 ecx, eax
  001f0	8b c1		 mov	 eax, ecx
  001f2	85 c0		 test	 eax, eax
  001f4	74 46		 je	 SHORT $LN15@fixstate

; 96   :                     if (accel[ibit] != -1)

  001f6	48 63 44 24 48	 movsxd	 rax, DWORD PTR ibit$20669[rsp]
  001fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR accel$[rsp]
  00200	83 3c 81 ff	 cmp	 DWORD PTR [rcx+rax*4], -1
  00204	74 0d		 je	 SHORT $LN14@fixstate

; 97   :                         printf("XXX ambiguity!\n");

  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@NBNHCIHI@XXX?5ambiguity?$CB?6?$AA@
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
$LN14@fixstate:

; 98   :                     accel[ibit] = a->a_arrow | (1 << 7) |
; 99   :                         ((type - NT_OFFSET) << 8);

  00213	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  00218	0f bf 40 02	 movsx	 eax, WORD PTR [rax+2]
  0021c	0f ba e8 07	 bts	 eax, 7
  00220	8b 4c 24 38	 mov	 ecx, DWORD PTR type$20664[rsp]
  00224	81 e9 00 01 00
	00		 sub	 ecx, 256		; 00000100H
  0022a	c1 e1 08	 shl	 ecx, 8
  0022d	0b c1		 or	 eax, ecx
  0022f	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR ibit$20669[rsp]
  00234	48 8b 54 24 20	 mov	 rdx, QWORD PTR accel$[rsp]
  00239	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN15@fixstate:

; 100  :                 }
; 101  :             }

  0023c	e9 43 ff ff ff	 jmp	 $LN17@fixstate
$LN16@fixstate:

; 102  :         }
; 103  :         else if (lbl == EMPTY)

  00241	eb 3f		 jmp	 SHORT $LN13@fixstate
$LN20@fixstate:
  00243	83 7c 24 3c 00	 cmp	 DWORD PTR lbl$20662[rsp], 0
  00248	75 11		 jne	 SHORT $LN12@fixstate

; 104  :             s->s_accept = 1;

  0024a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00252	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1
  00259	eb 27		 jmp	 SHORT $LN11@fixstate
$LN12@fixstate:

; 105  :         else if (lbl >= 0 && lbl < nl)

  0025b	83 7c 24 3c 00	 cmp	 DWORD PTR lbl$20662[rsp], 0
  00260	7c 20		 jl	 SHORT $LN10@fixstate
  00262	8b 44 24 30	 mov	 eax, DWORD PTR nl$[rsp]
  00266	39 44 24 3c	 cmp	 DWORD PTR lbl$20662[rsp], eax
  0026a	7d 16		 jge	 SHORT $LN10@fixstate

; 106  :             accel[lbl] = a->a_arrow;

  0026c	48 63 44 24 3c	 movsxd	 rax, DWORD PTR lbl$20662[rsp]
  00271	48 8b 4c 24 28	 mov	 rcx, QWORD PTR a$[rsp]
  00276	0f bf 49 02	 movsx	 ecx, WORD PTR [rcx+2]
  0027a	48 8b 54 24 20	 mov	 rdx, QWORD PTR accel$[rsp]
  0027f	89 0c 82	 mov	 DWORD PTR [rdx+rax*4], ecx
$LN10@fixstate:
$LN11@fixstate:
$LN13@fixstate:

; 107  :     }

  00282	e9 3a fe ff ff	 jmp	 $LN23@fixstate
$LN22@fixstate:
$LN9@fixstate:

; 108  :     while (nl > 0 && accel[nl-1] == -1)

  00287	83 7c 24 30 00	 cmp	 DWORD PTR nl$[rsp], 0
  0028c	7e 1f		 jle	 SHORT $LN8@fixstate
  0028e	8b 44 24 30	 mov	 eax, DWORD PTR nl$[rsp]
  00292	ff c8		 dec	 eax
  00294	48 98		 cdqe
  00296	48 8b 4c 24 20	 mov	 rcx, QWORD PTR accel$[rsp]
  0029b	83 3c 81 ff	 cmp	 DWORD PTR [rcx+rax*4], -1
  0029f	75 0c		 jne	 SHORT $LN8@fixstate

; 109  :         nl--;

  002a1	8b 44 24 30	 mov	 eax, DWORD PTR nl$[rsp]
  002a5	ff c8		 dec	 eax
  002a7	89 44 24 30	 mov	 DWORD PTR nl$[rsp], eax
  002ab	eb da		 jmp	 SHORT $LN9@fixstate
$LN8@fixstate:

; 110  :     for (k = 0; k < nl && accel[k] == -1;)

  002ad	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
$LN7@fixstate:
  002b5	8b 44 24 30	 mov	 eax, DWORD PTR nl$[rsp]
  002b9	39 44 24 34	 cmp	 DWORD PTR k$[rsp], eax
  002bd	7d 1c		 jge	 SHORT $LN6@fixstate
  002bf	48 63 44 24 34	 movsxd	 rax, DWORD PTR k$[rsp]
  002c4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR accel$[rsp]
  002c9	83 3c 81 ff	 cmp	 DWORD PTR [rcx+rax*4], -1
  002cd	75 0c		 jne	 SHORT $LN6@fixstate

; 111  :         k++;

  002cf	8b 44 24 34	 mov	 eax, DWORD PTR k$[rsp]
  002d3	ff c0		 inc	 eax
  002d5	89 44 24 34	 mov	 DWORD PTR k$[rsp], eax
  002d9	eb da		 jmp	 SHORT $LN7@fixstate
$LN6@fixstate:

; 112  :     if (k < nl) {

  002db	8b 44 24 30	 mov	 eax, DWORD PTR nl$[rsp]
  002df	39 44 24 34	 cmp	 DWORD PTR k$[rsp], eax
  002e3	0f 8d c4 00 00
	00		 jge	 $LN5@fixstate

; 113  :         int i;
; 114  :         s->s_accel = (int *) PyObject_MALLOC((nl-k) * sizeof(int));

  002e9	8b 44 24 34	 mov	 eax, DWORD PTR k$[rsp]
  002ed	8b 4c 24 30	 mov	 ecx, DWORD PTR nl$[rsp]
  002f1	2b c8		 sub	 ecx, eax
  002f3	8b c1		 mov	 eax, ecx
  002f5	48 98		 cdqe
  002f7	48 c1 e0 02	 shl	 rax, 2
  002fb	48 8b c8	 mov	 rcx, rax
  002fe	e8 00 00 00 00	 call	 _PyObject_DebugMalloc
  00303	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0030b	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 115  :         if (s->s_accel == NULL) {

  0030f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00317	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0031c	75 25		 jne	 SHORT $LN4@fixstate

; 116  :             fprintf(stderr, "no mem to add parser accelerators\n");

  0031e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___iob_func
  00324	48 83 c0 60	 add	 rax, 96			; 00000060H
  00328	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@JMEPLMEJ@no?5mem?5to?5add?5parser?5accelerator@
  0032f	48 8b c8	 mov	 rcx, rax
  00332	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 117  :             exit(1);

  00338	b9 01 00 00 00	 mov	 ecx, 1
  0033d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN4@fixstate:

; 118  :         }
; 119  :         s->s_lower = k;

  00343	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0034b	8b 4c 24 34	 mov	 ecx, DWORD PTR k$[rsp]
  0034f	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 120  :         s->s_upper = nl;

  00352	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0035a	8b 4c 24 30	 mov	 ecx, DWORD PTR nl$[rsp]
  0035e	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 121  :         for (i = 0; k < nl; i++, k++)

  00361	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$20691[rsp], 0
  00369	eb 14		 jmp	 SHORT $LN3@fixstate
$LN2@fixstate:
  0036b	8b 44 24 58	 mov	 eax, DWORD PTR i$20691[rsp]
  0036f	ff c0		 inc	 eax
  00371	89 44 24 58	 mov	 DWORD PTR i$20691[rsp], eax
  00375	8b 44 24 34	 mov	 eax, DWORD PTR k$[rsp]
  00379	ff c0		 inc	 eax
  0037b	89 44 24 34	 mov	 DWORD PTR k$[rsp], eax
$LN3@fixstate:
  0037f	8b 44 24 30	 mov	 eax, DWORD PTR nl$[rsp]
  00383	39 44 24 34	 cmp	 DWORD PTR k$[rsp], eax
  00387	7d 24		 jge	 SHORT $LN1@fixstate

; 122  :             s->s_accel[i] = accel[k];

  00389	48 63 44 24 34	 movsxd	 rax, DWORD PTR k$[rsp]
  0038e	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR i$20691[rsp]
  00393	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0039b	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0039f	4c 8b 44 24 20	 mov	 r8, QWORD PTR accel$[rsp]
  003a4	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  003a8	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  003ab	eb be		 jmp	 SHORT $LN2@fixstate
$LN1@fixstate:
$LN5@fixstate:

; 123  :     }
; 124  :     PyObject_FREE(accel);

  003ad	48 8b 4c 24 20	 mov	 rcx, QWORD PTR accel$[rsp]
  003b2	e8 00 00 00 00	 call	 _PyObject_DebugFree
$LN30@fixstate:

; 125  : }

  003b7	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003bb	c3		 ret	 0
fixstate ENDP
_TEXT	ENDS
END
